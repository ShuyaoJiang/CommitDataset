[+++ b/modules/transport-netty4/src/main/java/org/elasticsearch/transport/netty4/Netty4Transport.java, +                    + "receive_predictor[{}->{}]",, +++ b/modules/transport-netty4/src/main/java/org/elasticsearch/transport/netty4/Netty4Transport.java, +                    + "receive_predictor[{}->{}]",, +++ b/server/src/main/java/org/elasticsearch/common/settings/ClusterSettings.java, +                    TransportService.CONNECTIONS_PER_NODE_RECOVERY,, +                    TransportService.CONNECTIONS_PER_NODE_BULK,, +                    TransportService.CONNECTIONS_PER_NODE_REG,, +                    TransportService.CONNECTIONS_PER_NODE_STATE,, +                    TransportService.CONNECTIONS_PER_NODE_PING,, +                    TransportService.TCP_CONNECT_TIMEOUT,, +++ b/modules/transport-netty4/src/main/java/org/elasticsearch/transport/netty4/Netty4Transport.java, +                    + "receive_predictor[{}->{}]",, +++ b/server/src/main/java/org/elasticsearch/common/settings/ClusterSettings.java, +                    TransportService.CONNECTIONS_PER_NODE_RECOVERY,, +                    TransportService.CONNECTIONS_PER_NODE_BULK,, +                    TransportService.CONNECTIONS_PER_NODE_REG,, +                    TransportService.CONNECTIONS_PER_NODE_STATE,, +                    TransportService.CONNECTIONS_PER_NODE_PING,, +                    TransportService.TCP_CONNECT_TIMEOUT,, +++ b/server/src/main/java/org/elasticsearch/transport/ConnectionManager.java, +    private final ConnectionProfile defaultProfile;, +        this(settings, transport, threadPool, buildDefaultConnectionProfile(settings));, +    }, +, +    public ConnectionManager(Settings settings, Transport transport, ThreadPool threadPool, ConnectionProfile defaultProfile) {, +        this.defaultProfile = defaultProfile;, +    public Transport.Connection openConnection(DiscoveryNode node, ConnectionProfile connectionProfile) {, +        return transport.openConnection(node, ConnectionProfile.resolveConnectionProfile(connectionProfile, defaultProfile));, +    }, +, +        ConnectionProfile resolvedProfile = ConnectionProfile.resolveConnectionProfile(connectionProfile, defaultProfile);, +                    connection = transport.openConnection(node, resolvedProfile);, +                    connectionValidator.accept(connection, resolvedProfile);, +, +    static ConnectionProfile buildDefaultConnectionProfile(Settings settings) {, +        int connectionsPerNodeRecovery = TransportService.CONNECTIONS_PER_NODE_RECOVERY.get(settings);, +        int connectionsPerNodeBulk = TransportService.CONNECTIONS_PER_NODE_BULK.get(settings);, +        int connectionsPerNodeReg = TransportService.CONNECTIONS_PER_NODE_REG.get(settings);, +        int connectionsPerNodeState = TransportService.CONNECTIONS_PER_NODE_STATE.get(settings);, +        int connectionsPerNodePing = TransportService.CONNECTIONS_PER_NODE_PING.get(settings);, +        ConnectionProfile.Builder builder = new ConnectionProfile.Builder();, +        builder.setConnectTimeout(TransportService.TCP_CONNECT_TIMEOUT.get(settings));, +        builder.setHandshakeTimeout(TransportService.TCP_CONNECT_TIMEOUT.get(settings));, +        builder.addConnections(connectionsPerNodeBulk, TransportRequestOptions.Type.BULK);, +        builder.addConnections(connectionsPerNodePing, TransportRequestOptions.Type.PING);, +        // if we are not master eligible we don't need a dedicated channel to publish the state, +        builder.addConnections(DiscoveryNode.isMasterNode(settings) ? connectionsPerNodeState : 0, TransportRequestOptions.Type.STATE);, +        // if we are not a data-node we don't need any dedicated channels for recovery, +        builder.addConnections(DiscoveryNode.isDataNode(settings) ? connectionsPerNodeRecovery : 0, TransportRequestOptions.Type.RECOVERY);, +        builder.addConnections(connectionsPerNodeReg, TransportRequestOptions.Type.REG);, +        return builder.build();, +    }, +++ b/modules/transport-netty4/src/main/java/org/elasticsearch/transport/netty4/Netty4Transport.java, +                    + "receive_predictor[{}->{}]",, +++ b/server/src/main/java/org/elasticsearch/common/settings/ClusterSettings.java, +                    TransportService.CONNECTIONS_PER_NODE_RECOVERY,, +                    TransportService.CONNECTIONS_PER_NODE_BULK,, +                    TransportService.CONNECTIONS_PER_NODE_REG,, +                    TransportService.CONNECTIONS_PER_NODE_STATE,, +                    TransportService.CONNECTIONS_PER_NODE_PING,, +                    TransportService.TCP_CONNECT_TIMEOUT,, +++ b/server/src/main/java/org/elasticsearch/transport/ConnectionManager.java, +    private final ConnectionProfile defaultProfile;, +        this(settings, transport, threadPool, buildDefaultConnectionProfile(settings));, +    }, +, +    public ConnectionManager(Settings settings, Transport transport, ThreadPool threadPool, ConnectionProfile defaultProfile) {, +        this.defaultProfile = defaultProfile;, +    public Transport.Connection openConnection(DiscoveryNode node, ConnectionProfile connectionProfile) {, +        return transport.openConnection(node, ConnectionProfile.resolveConnectionProfile(connectionProfile, defaultProfile));, +    }, +, +        ConnectionProfile resolvedProfile = ConnectionProfile.resolveConnectionProfile(connectionProfile, defaultProfile);, +                    connection = transport.openConnection(node, resolvedProfile);, +                    connectionValidator.accept(connection, resolvedProfile);, +, +    static ConnectionProfile buildDefaultConnectionProfile(Settings settings) {, +        int connectionsPerNodeRecovery = TransportService.CONNECTIONS_PER_NODE_RECOVERY.get(settings);, +        int connectionsPerNodeBulk = TransportService.CONNECTIONS_PER_NODE_BULK.get(settings);, +        int connectionsPerNodeReg = TransportService.CONNECTIONS_PER_NODE_REG.get(settings);, +        int connectionsPerNodeState = TransportService.CONNECTIONS_PER_NODE_STATE.get(settings);, +        int connectionsPerNodePing = TransportService.CONNECTIONS_PER_NODE_PING.get(settings);, +        ConnectionProfile.Builder builder = new ConnectionProfile.Builder();, +        builder.setConnectTimeout(TransportService.TCP_CONNECT_TIMEOUT.get(settings));, +        builder.setHandshakeTimeout(TransportService.TCP_CONNECT_TIMEOUT.get(settings));, +        builder.addConnections(connectionsPerNodeBulk, TransportRequestOptions.Type.BULK);, +        builder.addConnections(connectionsPerNodePing, TransportRequestOptions.Type.PING);, +        // if we are not master eligible we don't need a dedicated channel to publish the state, +        builder.addConnections(DiscoveryNode.isMasterNode(settings) ? connectionsPerNodeState : 0, TransportRequestOptions.Type.STATE);, +        // if we are not a data-node we don't need any dedicated channels for recovery, +        builder.addConnections(DiscoveryNode.isDataNode(settings) ? connectionsPerNodeRecovery : 0, TransportRequestOptions.Type.RECOVERY);, +        builder.addConnections(connectionsPerNodeReg, TransportRequestOptions.Type.REG);, +        return builder.build();, +    }, +++ b/server/src/main/java/org/elasticsearch/transport/ConnectionProfile.java, +import java.util.Objects;, +    private ConnectionProfile(List<ConnectionTypeHandle> handles, int numConnections, TimeValue connectTimeout,, +                              TimeValue handshakeTimeout) {, +     * takes a {@link ConnectionProfile} resolves it to a fully specified (i.e., no nulls) profile]