[+++ b/server/src/main/java/org/elasticsearch/cluster/service/ClusterApplierService.java, +                "failed to execute cluster state applier in [{}], state:\nversion [{}], source [{}]\n{}",, +                executionTime, previousClusterState.version(), task.source, previousClusterState), e);, +            task.listener.onSuccess(task.source);, +                logger.debug("cluster state updated, version [{}], source [{}]\n{}", newClusterState.version(), task.source,, +                    newClusterState);, +            } else {, +                task.listener.onSuccess(task.source);, +                if (logger.isTraceEnabled()) {, +                    logger.warn(new ParameterizedMessage(, +                            executionTime, newClusterState.version(), newClusterState.stateUUID(), task.source, newClusterState), e);, +                } else {, +                    logger.warn(new ParameterizedMessage(, +                            "failed to apply updated cluster state in [{}]:\nversion [{}], uuid [{}], source [{}]",, +                            executionTime, newClusterState.version(), newClusterState.stateUUID(), task.source), e);, +                }, +                task.listener.onFailure(task.source, e);, +        logger.trace("connecting to nodes of cluster state with version {}", newClusterState.version());, +            logger.debug("applying settings from cluster state with version {}", newClusterState.version());, +++ b/server/src/main/java/org/elasticsearch/cluster/service/ClusterApplierService.java, +                "failed to execute cluster state applier in [{}], state:\nversion [{}], source [{}]\n{}",, +                executionTime, previousClusterState.version(), task.source, previousClusterState), e);, +            task.listener.onSuccess(task.source);, +                logger.debug("cluster state updated, version [{}], source [{}]\n{}", newClusterState.version(), task.source,, +                    newClusterState);, +            } else {, +                task.listener.onSuccess(task.source);, +                if (logger.isTraceEnabled()) {, +                    logger.warn(new ParameterizedMessage(, +                            executionTime, newClusterState.version(), newClusterState.stateUUID(), task.source, newClusterState), e);, +                } else {, +                    logger.warn(new ParameterizedMessage(, +                            "failed to apply updated cluster state in [{}]:\nversion [{}], uuid [{}], source [{}]",, +                            executionTime, newClusterState.version(), newClusterState.stateUUID(), task.source), e);, +                }, +                task.listener.onFailure(task.source, e);, +        logger.trace("connecting to nodes of cluster state with version {}", newClusterState.version());, +            logger.debug("applying settings from cluster state with version {}", newClusterState.version());, +++ b/server/src/main/java/org/elasticsearch/ingest/IngestService.java, +import org.apache.logging.log4j.LogManager;, +import org.apache.logging.log4j.Logger;, +    private static final Logger logger = LogManager.getLogger(IngestService.class);, +, +        try {, +        } catch (ElasticsearchParseException e) {, +            logger.warn("failed to update ingest pipelines", e);, +        }, +++ b/server/src/main/java/org/elasticsearch/cluster/service/ClusterApplierService.java, +                "failed to execute cluster state applier in [{}], state:\nversion [{}], source [{}]\n{}",, +                executionTime, previousClusterState.version(), task.source, previousClusterState), e);, +            task.listener.onSuccess(task.source);, +                logger.debug("cluster state updated, version [{}], source [{}]\n{}", newClusterState.version(), task.source,, +                    newClusterState);, +            } else {, +                task.listener.onSuccess(task.source);, +                if (logger.isTraceEnabled()) {, +                    logger.warn(new ParameterizedMessage(, +                            executionTime, newClusterState.version(), newClusterState.stateUUID(), task.source, newClusterState), e);, +                } else {, +                    logger.warn(new ParameterizedMessage(, +                            "failed to apply updated cluster state in [{}]:\nversion [{}], uuid [{}], source [{}]",, +                            executionTime, newClusterState.version(), newClusterState.stateUUID(), task.source), e);, +                }, +                task.listener.onFailure(task.source, e);, +        logger.trace("connecting to nodes of cluster state with version {}", newClusterState.version());, +            logger.debug("applying settings from cluster state with version {}", newClusterState.version());, +++ b/server/src/main/java/org/elasticsearch/ingest/IngestService.java, +import org.apache.logging.log4j.LogManager;, +import org.apache.logging.log4j.Logger;, +    private static final Logger logger = LogManager.getLogger(IngestService.class);, +, +        try {, +        } catch (ElasticsearchParseException e) {, +            logger.warn("failed to update ingest pipelines", e);, +        }, +++ b/server/src/test/java/org/elasticsearch/cluster/coordination/CoordinatorTests.java, +import org.elasticsearch.cluster.NodeConnectionsService;, +import org.elasticsearch.cluster.node.DiscoveryNodes;, +import org.elasticsearch.cluster.service.ClusterApplierService;, +import org.elasticsearch.cluster.service.ClusterService;, +import org.elasticsearch.common.util.concurrent.PrioritizedEsThreadPoolExecutor;, +        assertThat(leader.getLastAppliedClusterState().blocks().global(), hasItem(expectedBlock));, +            private DisruptableClusterApplierService clusterApplierService;, +            private ClusterService clusterService;, +                masterService = new AckedFakeThreadPoolMasterService(localNode.getId(), "test",, +                    runnable -> deterministicTaskQueue.scheduleNow(onNode(runnable)));, +                final ClusterSettings clusterSettings = new ClusterSettings(settings, ClusterSettings.BUILT_IN_CLUSTER_SETTINGS);, +                clusterApplierService = new DisruptableClusterApplierService(localNode.getId(), settings, clusterSettings,, +                    deterministicTaskQueue, this::onNode);, +                clusterService = new ClusterService(settings, clusterSettings, masterService, clusterApplierService);, +                clusterService.setNodeConnectionsService(, +                    new NodeConnectionsService(clusterService.getSettings(), deterministicTaskQueue.getThreadPool(this::onNode),, +                        transportService) {, +                        @Override, +                        public void connectToNodes(DiscoveryNodes discoveryNodes) {, +                            // override this method as it does blocking calls, +                        }, +                    });, +                    Cluster.this::provideUnicastHosts, clusterApplierService, onJoinValidators, Randomness.get());, +                clusterService.start();]