[+++ b/server/src/main/java/org/elasticsearch/indices/recovery/RecoverySourceHandler.java, +import org.elasticsearch.action.ActionListener;, +import org.elasticsearch.common.util.concurrent.FutureUtils;, +import org.elasticsearch.core.internal.io.IOUtils;, +import java.util.concurrent.CompletableFuture;, +        }, shardId + " validating recovery target ["+ request.targetAllocationId() + "] registered ", shard, cancellableThreads, logger);, +                shardId + " initiating tracking of " + request.targetAllocationId(), shard, cancellableThreads, logger);, +    static void runUnderPrimaryPermit(CancellableThreads.Interruptable runnable, String reason,, +                                      IndexShard primary, CancellableThreads cancellableThreads, Logger logger) {, +            CompletableFuture<Releasable> permit = new CompletableFuture<>();, +            final ActionListener<Releasable> onAcquired = new ActionListener<Releasable>() {, +                @Override, +                public void onResponse(Releasable releasable) {, +                    if (permit.complete(releasable) == false) {, +                        releasable.close();, +                    }, +                }, +, +                @Override, +                public void onFailure(Exception e) {, +                    permit.completeExceptionally(e);, +                }, +            };, +            primary.acquirePrimaryOperationPermit(onAcquired, ThreadPool.Names.SAME, reason);, +            try (Releasable ignored = FutureUtils.get(permit)) {, +                if (primary.isPrimaryMode() == false) {, +                    throw new IndexShardRelocatedException(primary.shardId());, +            } finally {, +                // just in case we got an exception (likely interrupted) while waiting for the get, +                permit.whenComplete((r, e) -> {, +                    if (r != null) {, +                        r.close();, +                    }, +                    if (e != null) {, +                        logger.trace("suppressing exception on completion (it was already bubbled up or the operation was aborted)", e);, +                    }, +                });, +            shardId + " marking " + request.targetAllocationId() + " as in sync", shard, cancellableThreads, logger);, +            shardId + " updating " + request.targetAllocationId() + "'s global checkpoint", shard, cancellableThreads, logger);, +++ b/server/src/main/java/org/elasticsearch/indices/recovery/RecoverySourceHandler.java, +import org.elasticsearch.action.ActionListener;, +import org.elasticsearch.common.util.concurrent.FutureUtils;, +import org.elasticsearch.core.internal.io.IOUtils;, +import java.util.concurrent.CompletableFuture;, +        }, shardId + " validating recovery target ["+ request.targetAllocationId() + "] registered ", shard, cancellableThreads, logger);, +                shardId + " initiating tracking of " + request.targetAllocationId(), shard, cancellableThreads, logger);, +    static void runUnderPrimaryPermit(CancellableThreads.Interruptable runnable, String reason,, +                                      IndexShard primary, CancellableThreads cancellableThreads, Logger logger) {, +            CompletableFuture<Releasable> permit = new CompletableFuture<>();, +            final ActionListener<Releasable> onAcquired = new ActionListener<Releasable>() {, +                @Override, +                public void onResponse(Releasable releasable) {, +                    if (permit.complete(releasable) == false) {, +                        releasable.close();, +                    }, +                }, +, +                @Override, +                public void onFailure(Exception e) {, +                    permit.completeExceptionally(e);, +                }, +            };, +            primary.acquirePrimaryOperationPermit(onAcquired, ThreadPool.Names.SAME, reason);, +            try (Releasable ignored = FutureUtils.get(permit)) {, +                if (primary.isPrimaryMode() == false) {, +                    throw new IndexShardRelocatedException(primary.shardId());, +            } finally {, +                // just in case we got an exception (likely interrupted) while waiting for the get, +                permit.whenComplete((r, e) -> {, +                    if (r != null) {, +                        r.close();, +                    }, +                    if (e != null) {, +                        logger.trace("suppressing exception on completion (it was already bubbled up or the operation was aborted)", e);, +                    }, +                });, +            shardId + " marking " + request.targetAllocationId() + " as in sync", shard, cancellableThreads, logger);, +            shardId + " updating " + request.targetAllocationId() + "'s global checkpoint", shard, cancellableThreads, logger);, +++ b/server/src/test/java/org/elasticsearch/indices/recovery/RecoverySourceHandlerTests.java, +import org.elasticsearch.common.util.CancellableThreads;, +    public void testCancellationsDoesNotLeakPrimaryPermits() throws Exception {, +        final CancellableThreads cancellableThreads = new CancellableThreads();, +        final IndexShard shard = mock(IndexShard.class);, +        final AtomicBoolean freed = new AtomicBoolean(true);, +        when(shard.isPrimaryMode()).thenReturn(true);, +        doAnswer(invocation -> {, +            freed.set(false);, +            ((ActionListener<Releasable>)invocation.getArguments()[0]).onResponse(() -> freed.set(true));, +            return null;, +        }).when(shard).acquirePrimaryOperationPermit(any(), anyString(), anyObject());, +, +        Thread cancelingThread = new Thread(() -> cancellableThreads.cancel("test"));, +        cancelingThread.start();, +        try {, +            RecoverySourceHandler.runUnderPrimaryPermit(() -> {}, "test", shard, cancellableThreads, logger);, +        } catch (CancellableThreads.ExecutionCancelledException e) {, +            // expected., +        }, +        cancelingThread.join();, +        // we have to use assert busy as we may be interrupted while acquiring the permit, if so we want to check]