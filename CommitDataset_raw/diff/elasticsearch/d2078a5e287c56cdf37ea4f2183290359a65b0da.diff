[+++ b/docs/reference/query-dsl/queries/simple-query-string-query.asciidoc, +* `~N` after a word signifies edit distance (fuzziness), +* `~N` after a phrase signifies slop amount, +`PRECEDENCE`, `ESCAPE`, `WHITESPACE`, `FUZZY`, `NEAR`, and `SLOP`., +++ b/docs/reference/query-dsl/queries/simple-query-string-query.asciidoc, +* `~N` after a word signifies edit distance (fuzziness), +* `~N` after a phrase signifies slop amount, +`PRECEDENCE`, `ESCAPE`, `WHITESPACE`, `FUZZY`, `NEAR`, and `SLOP`., +++ b/src/main/java/org/apache/lucene/queryparser/XSimpleQueryParser.java, +import org.apache.lucene.search.BooleanClause;, +import org.apache.lucene.search.BooleanQuery;, +import org.apache.lucene.search.FuzzyQuery;, +import org.apache.lucene.search.MatchAllDocsQuery;, +import org.apache.lucene.search.PrefixQuery;, +import org.apache.lucene.search.Query;, +import org.apache.lucene.util.automaton.LevenshteinAutomata;, + * SimpleQueryParser is used to parse human readable query syntax., + *  <li>'{@code ~}N' at the end of terms specifies fuzzy query: <tt>term~1</tt>, + *  <li>'{@code ~}N' at the end of phrases specifies near query: <tt>"term1 term2"~5</tt>, +    /** Enables {@code FUZZY} operators: (~) on single terms */, +    public static final int FUZZY_OPERATOR       = 1<<8;, +    /** Enables {@code NEAR} operators: (~) on phrases */, +    public static final int NEAR_OPERATOR        = 1<<9;, +, +        boolean hasSlop = false;, +                    // if there are still characters after the closing ", check for a, +                    // tilde, +                    if (state.length > (state.index + 1) &&, +                            state.data[state.index+1] == '~' &&, +                            (flags & NEAR_OPERATOR) != 0) {, +                        state.index++;, +                        // check for characters after the tilde, +                        if (state.length > (state.index + 1)) {, +                            hasSlop = true;, +                        }, +                        break;, +                    } else {, +            }, +            Query branch;, +            if (hasSlop) {, +                branch = newPhraseQuery(phrase, parseFuzziness(state));, +            } else {, +                branch = newPhraseQuery(phrase, 0);, +            }, +        boolean fuzzy = false;, +                } else if (tokenFinished(state)) {, +                } else if (copied > 0 && state.data[state.index] == '~' && (flags & FUZZY_OPERATOR) != 0) {, +                    fuzzy = true;, +                    break;, +            if (fuzzy && (flags & FUZZY_OPERATOR) != 0) {, +                String token = new String(state.buffer, 0, copied);, +                int fuzziness = parseFuzziness(state);, +                // edit distance has a maximum, limit to the maximum supported, +                fuzziness = Math.min(fuzziness, LevenshteinAutomata.MAXIMUM_SUPPORTED_DISTANCE);, +                if (fuzziness == 0) {, +                    branch = newDefaultQuery(token);, +                } else {, +                    branch = newFuzzyQuery(token, fuzziness);, +                }, +            } else if (prefix) {, +     * Helper parsing fuzziness from parsing state, +     * @return slop/edit distance, 0 in the case of non-parsing slop/edit string, +     */, +    private int parseFuzziness(State state) {, +        char slopText[] = new char[state.length];, +        int slopLength = 0;, +, +        if (state.data[state.index] == '~') {, +            while (state.index < state.length) {, +                state.index++;, +                // it's possible that the ~ was at the end, so check after incrementing, +                // to make sure we don't go out of bounds, +                if (state.index < state.length) {, +                    if (tokenFinished(state)) {, +                        break;, +                    }, +                    slopText[slopLength] = state.data[state.index];, +                    slopLength++;, +                }, +            }, +            int fuzziness = 0;, +            try {, +                fuzziness = Integer.parseInt(new String(slopText, 0, slopLength));, +            } catch (NumberFormatException e) {, +                // swallow number format exceptions parsing fuzziness, +            }, +            // negative -> 0, +            if (fuzziness < 0) {, +                fuzziness = 0;, +            }, +            return fuzziness;, +        }, +        return 0;, +    }, +, +    /**, +     * Helper returning true if the state has reached the end of token., +     */, +    private boolean tokenFinished(State state) {, +        if ((state.data[state.index] == '"' && (flags & PHRASE_OPERATOR) != 0)]