[+++ b/core/src/main/java/org/elasticsearch/cluster/metadata/MetaDataMappingService.java, +            final Map<String, MappingMetaData> mappings = new HashMap<>();, +                        mappings.put(index, new MappingMetaData(mergedMapper));, +                    mappings.put(index, new MappingMetaData(mergedMapper));, +            }, +            if (mappings.isEmpty()) {, +                // no changes, return, +                return currentState;, +            }, +            MetaData.Builder builder = MetaData.builder(currentState.metaData());, +            for (String indexName : request.indices()) {, +                IndexMetaData indexMetaData = currentState.metaData().index(indexName);, +                    throw new IndexNotFoundException(indexName);, +                MappingMetaData mappingMd = mappings.get(indexName);, +                if (mappingMd != null) {, +                    builder.put(IndexMetaData.builder(indexMetaData).putMapping(mappingMd));, +++ b/core/src/main/java/org/elasticsearch/cluster/metadata/MetaDataMappingService.java, +            final Map<String, MappingMetaData> mappings = new HashMap<>();, +                        mappings.put(index, new MappingMetaData(mergedMapper));, +                    mappings.put(index, new MappingMetaData(mergedMapper));, +            }, +            if (mappings.isEmpty()) {, +                // no changes, return, +                return currentState;, +            }, +            MetaData.Builder builder = MetaData.builder(currentState.metaData());, +            for (String indexName : request.indices()) {, +                IndexMetaData indexMetaData = currentState.metaData().index(indexName);, +                    throw new IndexNotFoundException(indexName);, +                MappingMetaData mappingMd = mappings.get(indexName);, +                if (mappingMd != null) {, +                    builder.put(IndexMetaData.builder(indexMetaData).putMapping(mappingMd));, +++ b/core/src/main/java/org/elasticsearch/search/sort/GeoDistanceSortBuilder.java, +import org.elasticsearch.common.geo.GeoUtils;, +import org.elasticsearch.common.io.stream.NamedWriteable;, +import org.elasticsearch.common.io.stream.StreamInput;, +import org.elasticsearch.common.io.stream.StreamOutput;, +import org.elasticsearch.common.xcontent.ToXContent;, +import org.elasticsearch.common.xcontent.XContentParser;, +import org.elasticsearch.index.query.QueryParseContext;, +import org.elasticsearch.search.MultiValueMode;, +import java.util.Objects;, +public class GeoDistanceSortBuilder extends SortBuilder, +        implements ToXContent, NamedWriteable<GeoDistanceSortBuilder>, SortElementParserTemp<GeoDistanceSortBuilder> {, +    public static final String NAME = "_geo_distance";, +    public static final boolean DEFAULT_COERCE = false;, +    public static final boolean DEFAULT_IGNORE_MALFORMED = false;, +    static final GeoDistanceSortBuilder PROTOTYPE = new GeoDistanceSortBuilder("", -1, -1);, +, +    private final String fieldName;, +    private GeoDistance geoDistance = GeoDistance.DEFAULT;, +    private DistanceUnit unit = DistanceUnit.DEFAULT;, +    private SortOrder order = SortOrder.ASC;, +    , +    // TODO there is an enum that covers that parameter which we should be using here, +    private String sortMode = null;, +    @SuppressWarnings("rawtypes"), +    , +    // TODO switch to GeoValidationMethod enum, +    private boolean coerce = DEFAULT_COERCE;, +    private boolean ignoreMalformed = DEFAULT_IGNORE_MALFORMED;, +     * @param points The points to create the range distance facets from., +    public GeoDistanceSortBuilder(String fieldName, GeoPoint... points) {, +        if (points.length == 0) {, +            throw new IllegalArgumentException("Geo distance sorting needs at least one point.");, +        }, +        this.points.addAll(Arrays.asList(points));, +    }, +, +    /**, +     * Constructs a new distance based sort on a geo point like field., +     *, +     * @param fieldName The geo point like field name., +     * @param lat Latitude of the point to create the range distance facets from., +     * @param lon Longitude of the point to create the range distance facets from., +     */, +    public GeoDistanceSortBuilder(String fieldName, double lat, double lon) {, +        this(fieldName, new GeoPoint(lat, lon));, +    }, +, +    /**, +     * Constructs a new distance based sort on a geo point like field., +     *, +     * @param fieldName The geo point like field name., +     * @param geohashes The points to create the range distance facets from., +     */, +    public GeoDistanceSortBuilder(String fieldName, String ... geohashes) {, +        if (geohashes.length == 0) {, +            throw new IllegalArgumentException("Geo distance sorting needs at least one point.");, +        }, +        for (String geohash : geohashes) {, +            this.points.add(GeoPoint.fromGeohash(geohash));, +        }, +        this.fieldName = fieldName;, +    }, +    , +    /**, +     * Copy constructor., +     * */, +    GeoDistanceSortBuilder(GeoDistanceSortBuilder original) {]