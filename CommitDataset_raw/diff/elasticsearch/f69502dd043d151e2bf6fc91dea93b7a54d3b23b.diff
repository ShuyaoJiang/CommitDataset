[+++ b/core/src/main/java/org/elasticsearch/index/translog/TranslogWriter.java, +import java.util.concurrent.atomic.AtomicBoolean;, +    /* A buffered outputstream what writes to the writers channel */, +    private final OutputStream outputStream;, +        this.outputStream = new BufferedChannelOutputStream(java.nio.channels.Channels.newOutputStream(channelReference.getChannel()), bufferSize.bytesAsInt());, +        totalOffset = lastSyncedOffset;, +    private synchronized final void closeWithTragicEvent(Throwable throwable) throws IOException {, +    public synchronized Translog.Location add(BytesReference data) throws IOException {, +            data.writeTo(outputStream);, +    public void sync() throws IOException {, +            synchronized (this) {, +                    outputStream.flush();, +    }, +            final TranslogReader reader = new InnerReader(this.generation, firstOperationOffset, channelReference);, +            synchronized (this) {, +                try {, +                    outputStream.flush();, +                    ImmutableTranslogReader reader = new ImmutableTranslogReader(this.generation, channelReference, firstOperationOffset, getWrittenOffset(), operationCounter);, +            }, +    private long getWrittenOffset() throws IOException {, +        return channelReference.getChannel().position();, +    }, +, +        if (position+targetBuffer.limit() > getWrittenOffset()) {, +            synchronized (this) {, +                outputStream.flush();, +    private final class BufferedChannelOutputStream extends BufferedOutputStream {, +, +        public BufferedChannelOutputStream(OutputStream out, int size) throws IOException {, +            super(out, size);, +        public synchronized void flush() throws IOException {, +            if (count > 0) {, +                try {, +                    ensureOpen();, +                    super.flush();, +                } catch (Throwable ex) {, +                    closeWithTragicEvent(ex);, +                    throw ex;, +                }, +            }, +        }, +, +        @Override, +        public void close() throws IOException {, +            // the stream is intentionally not closed because, +            // closing it will close the FileChannel, +            throw new IllegalStateException("never close this stream");, +++ b/core/src/main/java/org/elasticsearch/index/translog/TranslogWriter.java, +import java.util.concurrent.atomic.AtomicBoolean;, +    /* A buffered outputstream what writes to the writers channel */, +    private final OutputStream outputStream;, +        this.outputStream = new BufferedChannelOutputStream(java.nio.channels.Channels.newOutputStream(channelReference.getChannel()), bufferSize.bytesAsInt());, +        totalOffset = lastSyncedOffset;, +    private synchronized final void closeWithTragicEvent(Throwable throwable) throws IOException {, +    public synchronized Translog.Location add(BytesReference data) throws IOException {, +            data.writeTo(outputStream);, +    public void sync() throws IOException {, +            synchronized (this) {, +                    outputStream.flush();, +    }, +            final TranslogReader reader = new InnerReader(this.generation, firstOperationOffset, channelReference);, +            synchronized (this) {, +                try {, +                    outputStream.flush();, +                    ImmutableTranslogReader reader = new ImmutableTranslogReader(this.generation, channelReference, firstOperationOffset, getWrittenOffset(), operationCounter);, +            }, +    private long getWrittenOffset() throws IOException {, +        return channelReference.getChannel().position();, +    }, +, +        if (position+targetBuffer.limit() > getWrittenOffset()) {, +            synchronized (this) {, +                outputStream.flush();, +    private final class BufferedChannelOutputStream extends BufferedOutputStream {, +, +        public BufferedChannelOutputStream(OutputStream out, int size) throws IOException {, +            super(out, size);, +        public synchronized void flush() throws IOException {, +            if (count > 0) {, +                try {, +                    ensureOpen();, +                    super.flush();, +                } catch (Throwable ex) {, +                    closeWithTragicEvent(ex);, +                    throw ex;, +                }, +            }, +        }, +, +        @Override, +        public void close() throws IOException {, +            // the stream is intentionally not closed because, +            // closing it will close the FileChannel, +            throw new IllegalStateException("never close this stream");, +++ b/docs/reference/aggregations/bucket/filters-aggregation.asciidoc, +            }, +++ b/core/src/main/java/org/elasticsearch/index/translog/TranslogWriter.java, +import java.util.concurrent.atomic.AtomicBoolean;, +    /* A buffered outputstream what writes to the writers channel */, +    private final OutputStream outputStream;]