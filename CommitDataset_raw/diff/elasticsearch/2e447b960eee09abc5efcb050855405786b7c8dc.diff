[+++ b/buildSrc/src/main/resources/checkstyle_suppressions.xml, +  <suppress files="test[/\\]framework[/\\]src[/\\]main[/\\]java[/\\]org[/\\]elasticsearch[/\\]test[/\\]junit[/\\]rule[/\\]RepeatOnExceptionRule.java" checks="LineLength" />, +++ b/buildSrc/src/main/resources/checkstyle_suppressions.xml, +  <suppress files="test[/\\]framework[/\\]src[/\\]main[/\\]java[/\\]org[/\\]elasticsearch[/\\]test[/\\]junit[/\\]rule[/\\]RepeatOnExceptionRule.java" checks="LineLength" />, +++ b/buildSrc/version.properties, +elasticsearch     = 5.0.0, +++ b/buildSrc/src/main/resources/checkstyle_suppressions.xml, +  <suppress files="test[/\\]framework[/\\]src[/\\]main[/\\]java[/\\]org[/\\]elasticsearch[/\\]test[/\\]junit[/\\]rule[/\\]RepeatOnExceptionRule.java" checks="LineLength" />, +++ b/buildSrc/version.properties, +elasticsearch     = 5.0.0, +++ /dev/null, +++ b/buildSrc/src/main/resources/checkstyle_suppressions.xml, +  <suppress files="test[/\\]framework[/\\]src[/\\]main[/\\]java[/\\]org[/\\]elasticsearch[/\\]test[/\\]junit[/\\]rule[/\\]RepeatOnExceptionRule.java" checks="LineLength" />, +++ b/buildSrc/version.properties, +elasticsearch     = 5.0.0, +++ /dev/null, +++ /dev/null, +++ b/buildSrc/src/main/resources/checkstyle_suppressions.xml, +  <suppress files="test[/\\]framework[/\\]src[/\\]main[/\\]java[/\\]org[/\\]elasticsearch[/\\]test[/\\]junit[/\\]rule[/\\]RepeatOnExceptionRule.java" checks="LineLength" />, +++ b/buildSrc/version.properties, +elasticsearch     = 5.0.0, +++ /dev/null, +++ /dev/null, +++ b/core/src/main/java/org/elasticsearch/Version.java, +    public static final int V_5_0_0_ID = 5000099;, +    public static final Version V_5_0_0 = new Version(V_5_0_0_ID, org.apache.lucene.util.Version.LUCENE_6_0_0);, +    public static final Version CURRENT = V_5_0_0;, +            case V_5_0_0_ID:, +                return V_5_0_0;, +++ b/buildSrc/src/main/resources/checkstyle_suppressions.xml, +  <suppress files="test[/\\]framework[/\\]src[/\\]main[/\\]java[/\\]org[/\\]elasticsearch[/\\]test[/\\]junit[/\\]rule[/\\]RepeatOnExceptionRule.java" checks="LineLength" />, +++ b/buildSrc/version.properties, +elasticsearch     = 5.0.0, +++ /dev/null, +++ /dev/null, +++ b/core/src/main/java/org/elasticsearch/Version.java, +    public static final int V_5_0_0_ID = 5000099;, +    public static final Version V_5_0_0 = new Version(V_5_0_0_ID, org.apache.lucene.util.Version.LUCENE_6_0_0);, +    public static final Version CURRENT = V_5_0_0;, +            case V_5_0_0_ID:, +                return V_5_0_0;, +++ b/core/src/main/java/org/elasticsearch/action/admin/cluster/allocation/ClusterAllocationExplanation.java, +import org.apache.lucene.index.CorruptIndexException;, +import org.elasticsearch.ExceptionsHelper;, +import org.elasticsearch.action.admin.indices.shards.IndicesShardStoresResponse;, +import org.elasticsearch.index.shard.ShardStateMetaData;, +import java.util.ArrayList;, +import java.util.HashSet;, +import java.util.List;, +import java.util.Set;, +    private final long remainingDelayMillis;, +    private final Map<DiscoveryNode, NodeExplanation> nodeExplanations;, +    public ClusterAllocationExplanation(ShardId shard, boolean primary, @Nullable String assignedNodeId, long remainingDelayMillis,, +                                        @Nullable UnassignedInfo unassignedInfo, Map<DiscoveryNode, NodeExplanation> nodeExplanations) {, +        this.remainingDelayMillis = remainingDelayMillis;, +        this.nodeExplanations = nodeExplanations;, +        this.remainingDelayMillis = in.readVLong();, +        int mapSize = in.readVInt();, +        Map<DiscoveryNode, NodeExplanation> nodeToExplanation = new HashMap<>(mapSize);, +        for (int i = 0; i < mapSize; i++) {, +            NodeExplanation nodeExplanation = new NodeExplanation(in);, +            nodeToExplanation.put(nodeExplanation.getNode(), nodeExplanation);, +        this.nodeExplanations = nodeToExplanation;, +        out.writeVLong(remainingDelayMillis);, +        out.writeVInt(this.nodeExplanations.size());, +        for (NodeExplanation explanation : this.nodeExplanations.values()) {, +            explanation.writeTo(out);, +    /** Return the shard that the explanation is about */, +    /** Return true if the explained shard is primary, false otherwise */, +    public long getRemainingDelayMillis() {, +        return this.remainingDelayMillis;, +    }, +, +    /** Return a map of node to the explanation for that node */, +    public Map<DiscoveryNode, NodeExplanation> getNodeExplanations() {, +        return this.nodeExplanations;, +                builder.timeValueField("allocation_delay_ms", "allocation_delay", TimeValue.timeValueNanos(delay));, +                builder.timeValueField("remaining_delay_ms", "remaining_delay", TimeValue.timeValueMillis(remainingDelayMillis));, +            for (NodeExplanation explanation : nodeExplanations.values()) {, +                explanation.toXContent(builder, params);, +, +    /** An Enum representing the final decision for a shard allocation on a node */, +    public enum FinalDecision {, +        // Yes, the shard can be assigned, +        YES((byte) 0),, +        // No, the shard cannot be assigned, +        NO((byte) 1),, +        // The shard is already assigned to this node, +        ALREADY_ASSIGNED((byte) 2);, +, +        private final byte id;, +, +        FinalDecision (byte id) {, +            this.id = id;, +        }, +, +        private static FinalDecision fromId(byte id) {, +            switch (id) {, +                case 0: return YES;, +                case 1: return NO;]