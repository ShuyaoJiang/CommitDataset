[+++ b/core/src/main/java/org/elasticsearch/action/bulk/TransportSingleItemBulkWriteAction.java, +        // a replica operation can never throw a document-level failure,, +        // as the same document has been already indexed successfully in the primary, +++ b/core/src/main/java/org/elasticsearch/action/bulk/TransportSingleItemBulkWriteAction.java, +        // a replica operation can never throw a document-level failure,, +        // as the same document has been already indexed successfully in the primary, +++ b/core/src/test/java/org/elasticsearch/action/bulk/TransportBulkActionIngestTests.java, +import org.elasticsearch.action.index.IndexAction;, +import org.elasticsearch.action.index.IndexResponse;, +import org.elasticsearch.cluster.action.shard.ShardStateAction;, +import org.elasticsearch.cluster.metadata.IndexNameExpressionResolver;, +import org.elasticsearch.indices.IndicesService;, +import org.elasticsearch.threadpool.ThreadPool;, +import java.util.function.Supplier;, +    /** Single item bulk write action that wraps index requests */, +    TestSingleItemBulkWriteAction singleItemBulkWriteAction;, +, +    class TestSingleItemBulkWriteAction extends TransportSingleItemBulkWriteAction<IndexRequest, IndexResponse> {, +, +        TestSingleItemBulkWriteAction(TestTransportBulkAction bulkAction) {, +            super(Settings.EMPTY, IndexAction.NAME, transportService, TransportBulkActionIngestTests.this.clusterService,, +                    null, null, null, new ActionFilters(Collections.emptySet()), null,, +                    IndexRequest::new, IndexRequest::new, ThreadPool.Names.INDEX, bulkAction, null);, +        }, +, +        @Override, +        protected IndexResponse newResponseInstance() {, +            return new IndexResponse();, +        }, +    }, +, +        singleItemBulkWriteAction = new TestSingleItemBulkWriteAction(action);, +    public void testSingleItemBulkActionIngestSkipped() throws Exception {, +        IndexRequest indexRequest = new IndexRequest("index", "type", "id");, +        indexRequest.source(Collections.emptyMap());, +        singleItemBulkWriteAction.execute(null, indexRequest, ActionListener.wrap(response -> {}, exception -> {, +            throw new AssertionError(exception);, +        }));, +        assertTrue(action.isExecuted);, +        verifyZeroInteractions(ingestService);, +    }, +, +    public void testSingleItemBulkActionIngestLocal() throws Exception {, +        Exception exception = new Exception("fake exception");, +        IndexRequest indexRequest = new IndexRequest("index", "type", "id");, +        indexRequest.source(Collections.emptyMap());, +        indexRequest.setPipeline("testpipeline");, +        AtomicBoolean responseCalled = new AtomicBoolean(false);, +        AtomicBoolean failureCalled = new AtomicBoolean(false);, +        singleItemBulkWriteAction.execute(null, indexRequest, ActionListener.wrap(, +                response -> {, +                    responseCalled.set(true);, +                },, +                e -> {, +                    assertThat(e, sameInstance(exception));, +                    failureCalled.set(true);, +                }));, +, +        // check failure works, and passes through to the listener, +        assertFalse(action.isExecuted); // haven't executed yet, +        assertFalse(responseCalled.get());, +        assertFalse(failureCalled.get());, +        verify(executionService).executeBulkRequest(bulkDocsItr.capture(), failureHandler.capture(), completionHandler.capture());, +        completionHandler.getValue().accept(exception);, +        assertTrue(failureCalled.get());, +, +        // now check success, +        indexRequest.setPipeline(null); // this is done by the real pipeline execution service when processing, +        completionHandler.getValue().accept(null);, +        assertTrue(action.isExecuted);, +        assertFalse(responseCalled.get()); // listener would only be called by real index action, not our mocked one, +        verifyZeroInteractions(transportService);, +    }, +, +    public void testSingleItemBulkActionIngestForward() throws Exception {, +        localIngest = false;, +        IndexRequest indexRequest = new IndexRequest("index", "type", "id");, +        indexRequest.source(Collections.emptyMap());, +        indexRequest.setPipeline("testpipeline");, +        IndexResponse indexResponse = mock(IndexResponse.class);, +        AtomicBoolean responseCalled = new AtomicBoolean(false);, +        ActionListener<IndexResponse> listener = ActionListener.wrap(, +                response -> {, +                    responseCalled.set(true);, +                    assertSame(indexResponse, response);, +                },, +                e -> {, +                    throw new AssertionError(e);, +                });, +        singleItemBulkWriteAction.execute(null, indexRequest, listener);, +, +        // should not have executed ingest locally, +        verify(executionService, never()).executeBulkRequest(any(), any(), any());, +        // but instead should have sent to a remote node with the transport service, +        ArgumentCaptor<DiscoveryNode> node = ArgumentCaptor.forClass(DiscoveryNode.class);, +        verify(transportService).sendRequest(node.capture(), eq(BulkAction.NAME), any(), remoteResponseHandler.capture());, +        boolean usedNode1 = node.getValue() == remoteNode1; // make sure we used one of the nodes, +        if (usedNode1 == false) {, +            assertSame(remoteNode2, node.getValue());, +        }]