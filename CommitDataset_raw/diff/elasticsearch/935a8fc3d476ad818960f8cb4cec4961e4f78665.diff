[+++ b/core/src/main/java/org/elasticsearch/action/admin/indices/delete/TransportDeleteIndexAction.java, +        final String[] concreteIndices = indexNameExpressionResolver.concreteIndices(state, request);, +        deleteIndexService.deleteIndices(new MetaDataDeleteIndexService.Request(concreteIndices).timeout(request.timeout()).masterTimeout(request.masterNodeTimeout()), new MetaDataDeleteIndexService.Listener() {, +                listener.onResponse(new DeleteIndexResponse(response.acknowledged()));, +++ b/core/src/main/java/org/elasticsearch/action/admin/indices/delete/TransportDeleteIndexAction.java, +        final String[] concreteIndices = indexNameExpressionResolver.concreteIndices(state, request);, +        deleteIndexService.deleteIndices(new MetaDataDeleteIndexService.Request(concreteIndices).timeout(request.timeout()).masterTimeout(request.masterNodeTimeout()), new MetaDataDeleteIndexService.Listener() {, +                listener.onResponse(new DeleteIndexResponse(response.acknowledged()));, +++ b/core/src/main/java/org/elasticsearch/action/admin/indices/validate/query/TransportValidateQueryAction.java, +                searchContext.parsedQuery(queryParserService.parseTopLevelQuery(request.source()));, +++ b/core/src/main/java/org/elasticsearch/action/admin/indices/delete/TransportDeleteIndexAction.java, +        final String[] concreteIndices = indexNameExpressionResolver.concreteIndices(state, request);, +        deleteIndexService.deleteIndices(new MetaDataDeleteIndexService.Request(concreteIndices).timeout(request.timeout()).masterTimeout(request.masterNodeTimeout()), new MetaDataDeleteIndexService.Listener() {, +                listener.onResponse(new DeleteIndexResponse(response.acknowledged()));, +++ b/core/src/main/java/org/elasticsearch/action/admin/indices/validate/query/TransportValidateQueryAction.java, +                searchContext.parsedQuery(queryParserService.parseTopLevelQuery(request.source()));, +++ b/core/src/main/java/org/elasticsearch/action/explain/TransportExplainAction.java, +            context.parsedQuery(indexService.queryParserService().parseTopLevelQuery(request.source()));, +++ b/core/src/main/java/org/elasticsearch/action/admin/indices/delete/TransportDeleteIndexAction.java, +        final String[] concreteIndices = indexNameExpressionResolver.concreteIndices(state, request);, +        deleteIndexService.deleteIndices(new MetaDataDeleteIndexService.Request(concreteIndices).timeout(request.timeout()).masterTimeout(request.masterNodeTimeout()), new MetaDataDeleteIndexService.Listener() {, +                listener.onResponse(new DeleteIndexResponse(response.acknowledged()));, +++ b/core/src/main/java/org/elasticsearch/action/admin/indices/validate/query/TransportValidateQueryAction.java, +                searchContext.parsedQuery(queryParserService.parseTopLevelQuery(request.source()));, +++ b/core/src/main/java/org/elasticsearch/action/explain/TransportExplainAction.java, +            context.parsedQuery(indexService.queryParserService().parseTopLevelQuery(request.source()));, +++ b/core/src/main/java/org/elasticsearch/cluster/metadata/MetaDataDeleteIndexService.java, +import java.util.Arrays;, +import java.util.Collection;, +    public void deleteIndices(final Request request, final Listener userListener) {, +        Collection<String> indices = Arrays.asList(request.indices);, +, +        clusterService.submitStateUpdateTask("delete-index " + indices, Priority.URGENT, new ClusterStateUpdateTask() {, +                RoutingTable.Builder routingTableBuilder = RoutingTable.builder(currentState.routingTable());, +                MetaData.Builder metaDataBuilder = MetaData.builder(currentState.metaData());, +                ClusterBlocks.Builder clusterBlocksBuilder = ClusterBlocks.builder().blocks(currentState.blocks());, +, +                for (final String index: indices) {, +                    if (!currentState.metaData().hasConcreteIndex(index)) {, +                        throw new IndexNotFoundException(index);, +                    logger.debug("[{}] deleting index", index);, +                    routingTableBuilder.remove(index);, +                    clusterBlocksBuilder.removeIndexBlocks(index);, +                    metaDataBuilder.remove(index);, +                }, +                final AtomicInteger counter = new AtomicInteger(count * indices.size());, +, +                    public void onNodeIndexDeleted(String deleted, String nodeId) {, +                        if (indices.contains(deleted)) {, +                    public void onNodeIndexStoreDeleted(String deleted, String nodeId) {, +                        if (indices.contains(deleted)) {, +                listener.future = threadPool.schedule(request.timeout, ThreadPool.Names.SAME, () -> {, +                MetaData newMetaData = metaDataBuilder.build();, +                ClusterBlocks blocks = clusterBlocksBuilder.build();, +                RoutingAllocation.Result routingResult = allocationService.reroute(, +                        ClusterState.builder(currentState).routingTable(routingTableBuilder.build()).metaData(newMetaData).build());, +        final String[] indices;, +        public Request(String[] indices) {, +            this.indices = indices;, +++ b/core/src/main/java/org/elasticsearch/action/admin/indices/delete/TransportDeleteIndexAction.java, +        final String[] concreteIndices = indexNameExpressionResolver.concreteIndices(state, request);, +        deleteIndexService.deleteIndices(new MetaDataDeleteIndexService.Request(concreteIndices).timeout(request.timeout()).masterTimeout(request.masterNodeTimeout()), new MetaDataDeleteIndexService.Listener() {, +                listener.onResponse(new DeleteIndexResponse(response.acknowledged()));, +++ b/core/src/main/java/org/elasticsearch/action/admin/indices/validate/query/TransportValidateQueryAction.java, +                searchContext.parsedQuery(queryParserService.parseTopLevelQuery(request.source()));, +++ b/core/src/main/java/org/elasticsearch/action/explain/TransportExplainAction.java, +            context.parsedQuery(indexService.queryParserService().parseTopLevelQuery(request.source()));, +++ b/core/src/main/java/org/elasticsearch/cluster/metadata/MetaDataDeleteIndexService.java, +import java.util.Arrays;, +import java.util.Collection;, +    public void deleteIndices(final Request request, final Listener userListener) {, +        Collection<String> indices = Arrays.asList(request.indices);, +, +        clusterService.submitStateUpdateTask("delete-index " + indices, Priority.URGENT, new ClusterStateUpdateTask() {, +                RoutingTable.Builder routingTableBuilder = RoutingTable.builder(currentState.routingTable());, +                MetaData.Builder metaDataBuilder = MetaData.builder(currentState.metaData());, +                ClusterBlocks.Builder clusterBlocksBuilder = ClusterBlocks.builder().blocks(currentState.blocks());, +, +                for (final String index: indices) {, +                    if (!currentState.metaData().hasConcreteIndex(index)) {, +                        throw new IndexNotFoundException(index);, +                    logger.debug("[{}] deleting index", index);, +                    routingTableBuilder.remove(index);, +                    clusterBlocksBuilder.removeIndexBlocks(index);, +                    metaDataBuilder.remove(index);, +                }, +                final AtomicInteger counter = new AtomicInteger(count * indices.size());, +, +                    public void onNodeIndexDeleted(String deleted, String nodeId) {, +                        if (indices.contains(deleted)) {, +                    public void onNodeIndexStoreDeleted(String deleted, String nodeId) {, +                        if (indices.contains(deleted)) {, +                listener.future = threadPool.schedule(request.timeout, ThreadPool.Names.SAME, () -> {, +                MetaData newMetaData = metaDataBuilder.build();, +                ClusterBlocks blocks = clusterBlocksBuilder.build();, +                RoutingAllocation.Result routingResult = allocationService.reroute(, +                        ClusterState.builder(currentState).routingTable(routingTableBuilder.build()).metaData(newMetaData).build());, +        final String[] indices;, +        public Request(String[] indices) {, +            this.indices = indices;]