[+++ b/src/main/java/org/elasticsearch/index/engine/Engine.java, +    public static final String SYNC_COMMIT_ID = "sync_id";, +, +    /**, +     * Attempts to do a special commit where the given syncID is put into the commit data. The attempt, +     * succeeds if there are not pending writes in lucene and the current point is equal to the expected one., +     * @param syncId id of this sync, +     * @param expectedCommitId the expected value of, +     * @return true if the sync commit was made, false o.w., +     */, +    public abstract boolean syncFlushIfNoPendingChanges(String syncId, byte[] expectedCommitId) throws EngineException;, +, +     * @return the commit Id for the resulting commit, +    public abstract byte[] flush(boolean force, boolean waitIfOngoing) throws EngineException;, +     *, +     * @return the commit Id for the resulting commit, +    public abstract byte[] flush() throws EngineException;, +++ b/src/main/java/org/elasticsearch/index/engine/Engine.java, +    public static final String SYNC_COMMIT_ID = "sync_id";, +, +    /**, +     * Attempts to do a special commit where the given syncID is put into the commit data. The attempt, +     * succeeds if there are not pending writes in lucene and the current point is equal to the expected one., +     * @param syncId id of this sync, +     * @param expectedCommitId the expected value of, +     * @return true if the sync commit was made, false o.w., +     */, +    public abstract boolean syncFlushIfNoPendingChanges(String syncId, byte[] expectedCommitId) throws EngineException;, +, +     * @return the commit Id for the resulting commit, +    public abstract byte[] flush(boolean force, boolean waitIfOngoing) throws EngineException;, +     *, +     * @return the commit Id for the resulting commit, +    public abstract byte[] flush() throws EngineException;, +++ b/src/main/java/org/elasticsearch/index/engine/InternalEngine.java, +    public boolean syncFlushIfNoPendingChanges(String syncId, byte[] expectedCommitId) throws EngineException {, +        // best effort attempt before we aquire locks, +        ensureOpen();, +        if (indexWriter.hasUncommittedChanges()) {, +            logger.trace("can't sync commit [{}]. have pending changes", syncId);, +            return false;, +        }, +        if (Arrays.equals(expectedCommitId, lastCommittedSegmentInfos.getId()) == false) {, +            logger.trace("can't sync commit [{}]. current commit id is not equal to expected.", syncId);, +            return false;, +        }, +        try (ReleasableLock lock = writeLock.acquire()) {, +            ensureOpen();, +            if (indexWriter.hasUncommittedChanges()) {, +                logger.trace("can't sync commit [{}]. have pending changes", syncId);, +                return false;, +            }, +            if (Arrays.equals(expectedCommitId, lastCommittedSegmentInfos.getId()) == false) {, +                logger.trace("can't sync commit [{}]. current commit id is not equal to expected.", syncId);, +                return false;, +            }, +            logger.trace("starting sync commit [{}]", syncId);, +            long translogId = translog.currentId();, +            Map<String, String> commitData = new HashMap<>(2);, +            commitData.put(SYNC_COMMIT_ID, syncId);, +            commitData.put(Translog.TRANSLOG_ID_KEY, Long.toString(translogId));, +            indexWriter.setCommitData(commitData);, +            commitIndexWriter(indexWriter);, +            logger.debug("successfully sync committed. sync id [{}].", syncId);, +            return true;, +        } catch (IOException ex) {, +            maybeFailEngine("sync commit", ex);, +            throw new EngineException(shardId, "failed to sync commit", ex);, +        }, +    public byte[] flush() throws EngineException {, +        return flush(true, false, false);, +    @Override, +    public byte[] flush(boolean force, boolean waitIfOngoing) throws EngineException {, +        return flush(true, force, waitIfOngoing);, +    }, +, +    private byte[] flush(boolean commitTranslog, boolean force, boolean waitIfOngoing) throws EngineException {, +        final byte[] newCommitId;, +                newCommitId = lastCommittedSegmentInfos.getId();, +        return newCommitId;, +++ b/src/main/java/org/elasticsearch/index/engine/Engine.java, +    public static final String SYNC_COMMIT_ID = "sync_id";, +, +    /**, +     * Attempts to do a special commit where the given syncID is put into the commit data. The attempt, +     * succeeds if there are not pending writes in lucene and the current point is equal to the expected one., +     * @param syncId id of this sync, +     * @param expectedCommitId the expected value of, +     * @return true if the sync commit was made, false o.w., +     */, +    public abstract boolean syncFlushIfNoPendingChanges(String syncId, byte[] expectedCommitId) throws EngineException;, +, +     * @return the commit Id for the resulting commit, +    public abstract byte[] flush(boolean force, boolean waitIfOngoing) throws EngineException;, +     *, +     * @return the commit Id for the resulting commit, +    public abstract byte[] flush() throws EngineException;, +++ b/src/main/java/org/elasticsearch/index/engine/InternalEngine.java, +    public boolean syncFlushIfNoPendingChanges(String syncId, byte[] expectedCommitId) throws EngineException {, +        // best effort attempt before we aquire locks]