[+++ b/server/src/main/java/org/elasticsearch/index/engine/CombinedDeletionPolicy.java, +     * @param globalCheckpoint the persisted global checkpoint from the translog, see {@link Translog#readGlobalCheckpoint(Path, String)}, +++ b/server/src/main/java/org/elasticsearch/index/engine/CombinedDeletionPolicy.java, +     * @param globalCheckpoint the persisted global checkpoint from the translog, see {@link Translog#readGlobalCheckpoint(Path, String)}, +++ b/server/src/main/java/org/elasticsearch/index/shard/IndexShard.java, +            final String translogUUID = store.readLastCommittedSegmentsInfo().getUserData().get(Translog.TRANSLOG_UUID_KEY);, +            final long globalCheckpoint = Translog.readGlobalCheckpoint(translogConfig.getTranslogPath(), translogUUID);, +            replicationTracker.updateGlobalCheckpointOnReplica(globalCheckpoint, "read from translog checkpoint");, +++ b/server/src/main/java/org/elasticsearch/index/engine/CombinedDeletionPolicy.java, +     * @param globalCheckpoint the persisted global checkpoint from the translog, see {@link Translog#readGlobalCheckpoint(Path, String)}, +++ b/server/src/main/java/org/elasticsearch/index/shard/IndexShard.java, +            final String translogUUID = store.readLastCommittedSegmentsInfo().getUserData().get(Translog.TRANSLOG_UUID_KEY);, +            final long globalCheckpoint = Translog.readGlobalCheckpoint(translogConfig.getTranslogPath(), translogUUID);, +            replicationTracker.updateGlobalCheckpointOnReplica(globalCheckpoint, "read from translog checkpoint");, +++ b/server/src/main/java/org/elasticsearch/index/translog/Translog.java, +        return openReader(path, checkpoint, translogUUID);, +    }, +, +    private static TranslogReader openReader(Path path, Checkpoint checkpoint, String translogUUID) throws IOException {, +    static Checkpoint readCheckpoint(final Path location) throws IOException {, +     * This ensures that the translogUUID from this translog matches with the provided translogUUID., +     * @throws TranslogCorruptedException if the translog is corrupted or mismatched with the given uuid, +    public static long readGlobalCheckpoint(final Path location, final String expectedTranslogUUID) throws IOException {, +        final Checkpoint checkpoint = readCheckpoint(location);, +        // We need to open at least translog reader to validate the translogUUID., +        final Path translogFile = location.resolve(getFilename(checkpoint.generation));, +        try (TranslogReader reader = openReader(translogFile, checkpoint, expectedTranslogUUID)) {, +, +        } catch (TranslogCorruptedException ex) {, +            throw ex; // just bubble up., +        } catch (Exception ex) {, +            throw new TranslogCorruptedException("Translog at [" + location + "] is corrupted", ex);, +        }, +        return checkpoint.globalCheckpoint;, +++ b/server/src/main/java/org/elasticsearch/index/engine/CombinedDeletionPolicy.java, +     * @param globalCheckpoint the persisted global checkpoint from the translog, see {@link Translog#readGlobalCheckpoint(Path, String)}, +++ b/server/src/main/java/org/elasticsearch/index/shard/IndexShard.java, +            final String translogUUID = store.readLastCommittedSegmentsInfo().getUserData().get(Translog.TRANSLOG_UUID_KEY);, +            final long globalCheckpoint = Translog.readGlobalCheckpoint(translogConfig.getTranslogPath(), translogUUID);, +            replicationTracker.updateGlobalCheckpointOnReplica(globalCheckpoint, "read from translog checkpoint");, +++ b/server/src/main/java/org/elasticsearch/index/translog/Translog.java, +        return openReader(path, checkpoint, translogUUID);, +    }, +, +    private static TranslogReader openReader(Path path, Checkpoint checkpoint, String translogUUID) throws IOException {, +    static Checkpoint readCheckpoint(final Path location) throws IOException {, +     * This ensures that the translogUUID from this translog matches with the provided translogUUID., +     * @throws TranslogCorruptedException if the translog is corrupted or mismatched with the given uuid, +    public static long readGlobalCheckpoint(final Path location, final String expectedTranslogUUID) throws IOException {, +        final Checkpoint checkpoint = readCheckpoint(location);, +        // We need to open at least translog reader to validate the translogUUID., +        final Path translogFile = location.resolve(getFilename(checkpoint.generation));, +        try (TranslogReader reader = openReader(translogFile, checkpoint, expectedTranslogUUID)) {, +, +        } catch (TranslogCorruptedException ex) {, +            throw ex; // just bubble up., +        } catch (Exception ex) {, +            throw new TranslogCorruptedException("Translog at [" + location + "] is corrupted", ex);, +        }, +        return checkpoint.globalCheckpoint;, +++ b/server/src/main/java/org/elasticsearch/indices/recovery/PeerRecoveryTargetService.java, +import org.elasticsearch.index.translog.TranslogCorruptedException;, +            final Store store = recoveryTarget.store();, +            final String translogUUID = store.readLastCommittedSegmentsInfo().getUserData().get(Translog.TRANSLOG_UUID_KEY);, +            final long globalCheckpoint = Translog.readGlobalCheckpoint(recoveryTarget.translogLocation(), translogUUID);, +            final List<IndexCommit> existingCommits = DirectoryReader.listCommits(store.directory());, +            final SequenceNumbers.CommitInfo seqNoStats = store.loadSeqNoInfo(safeCommit);, +        } catch (final TranslogCorruptedException | IOException e) {, +++ b/server/src/main/java/org/elasticsearch/index/engine/CombinedDeletionPolicy.java, +     * @param globalCheckpoint the persisted global checkpoint from the translog, see {@link Translog#readGlobalCheckpoint(Path, String)}, +++ b/server/src/main/java/org/elasticsearch/index/shard/IndexShard.java, +            final String translogUUID = store.readLastCommittedSegmentsInfo().getUserData().get(Translog.TRANSLOG_UUID_KEY);, +            final long globalCheckpoint = Translog.readGlobalCheckpoint(translogConfig.getTranslogPath(), translogUUID);, +            replicationTracker.updateGlobalCheckpointOnReplica(globalCheckpoint, "read from translog checkpoint");, +++ b/server/src/main/java/org/elasticsearch/index/translog/Translog.java, +        return openReader(path, checkpoint, translogUUID);, +    }, +, +    private static TranslogReader openReader(Path path, Checkpoint checkpoint, String translogUUID) throws IOException {, +    static Checkpoint readCheckpoint(final Path location) throws IOException {, +     * This ensures that the translogUUID from this translog matches with the provided translogUUID., +     * @throws TranslogCorruptedException if the translog is corrupted or mismatched with the given uuid, +    public static long readGlobalCheckpoint(final Path location, final String expectedTranslogUUID) throws IOException {, +        final Checkpoint checkpoint = readCheckpoint(location);, +        // We need to open at least translog reader to validate the translogUUID., +        final Path translogFile = location.resolve(getFilename(checkpoint.generation));, +        try (TranslogReader reader = openReader(translogFile, checkpoint, expectedTranslogUUID)) {, +, +        } catch (TranslogCorruptedException ex) {, +            throw ex; // just bubble up., +        } catch (Exception ex) {, +            throw new TranslogCorruptedException("Translog at [" + location + "] is corrupted", ex);, +        }, +        return checkpoint.globalCheckpoint;, +++ b/server/src/main/java/org/elasticsearch/indices/recovery/PeerRecoveryTargetService.java, +import org.elasticsearch.index.translog.TranslogCorruptedException;, +            final Store store = recoveryTarget.store();, +            final String translogUUID = store.readLastCommittedSegmentsInfo().getUserData().get(Translog.TRANSLOG_UUID_KEY);, +            final long globalCheckpoint = Translog.readGlobalCheckpoint(recoveryTarget.translogLocation(), translogUUID);, +            final List<IndexCommit> existingCommits = DirectoryReader.listCommits(store.directory());]