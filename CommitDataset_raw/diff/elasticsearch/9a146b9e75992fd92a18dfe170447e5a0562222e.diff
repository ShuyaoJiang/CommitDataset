[+++ b/core/pom.xml, +                                <ant antfile="${elasticsearch.tools.directory}/ant/integration-tests.xml", +                                     target="start-external-cluster"/>, +                                <ant antfile="${elasticsearch.tools.directory}/ant/integration-tests.xml", +                                     target="stop-external-cluster"/>, +++ b/core/pom.xml, +                                <ant antfile="${elasticsearch.tools.directory}/ant/integration-tests.xml", +                                     target="start-external-cluster"/>, +                                <ant antfile="${elasticsearch.tools.directory}/ant/integration-tests.xml", +                                     target="stop-external-cluster"/>, +++ b/core/src/main/java/org/elasticsearch/action/bulk/BulkItemResponse.java, +import org.elasticsearch.ElasticsearchException;, +import org.elasticsearch.common.xcontent.XContentBuilder;, +++ b/core/pom.xml, +                                <ant antfile="${elasticsearch.tools.directory}/ant/integration-tests.xml", +                                     target="start-external-cluster"/>, +                                <ant antfile="${elasticsearch.tools.directory}/ant/integration-tests.xml", +                                     target="stop-external-cluster"/>, +++ b/core/src/main/java/org/elasticsearch/action/bulk/BulkItemResponse.java, +import org.elasticsearch.ElasticsearchException;, +import org.elasticsearch.common.xcontent.XContentBuilder;, +++ b/core/src/main/java/org/elasticsearch/action/bulk/TransportBulkAction.java, +                responses.set(idx, new BulkItemResponse(idx, "index", new BulkItemResponse.Failure(deleteRequest.index(), deleteRequest.type(), deleteRequest.id(), e)));, +                responses.set(idx, new BulkItemResponse(idx, "index", new BulkItemResponse.Failure(updateRequest.index(), updateRequest.type(), updateRequest.id(), e)));, +            BulkItemResponse bulkItemResponse = new BulkItemResponse(idx, "index", failure);, +++ b/core/pom.xml, +                                <ant antfile="${elasticsearch.tools.directory}/ant/integration-tests.xml", +                                     target="start-external-cluster"/>, +                                <ant antfile="${elasticsearch.tools.directory}/ant/integration-tests.xml", +                                     target="stop-external-cluster"/>, +++ b/core/src/main/java/org/elasticsearch/action/bulk/BulkItemResponse.java, +import org.elasticsearch.ElasticsearchException;, +import org.elasticsearch.common.xcontent.XContentBuilder;, +++ b/core/src/main/java/org/elasticsearch/action/bulk/TransportBulkAction.java, +                responses.set(idx, new BulkItemResponse(idx, "index", new BulkItemResponse.Failure(deleteRequest.index(), deleteRequest.type(), deleteRequest.id(), e)));, +                responses.set(idx, new BulkItemResponse(idx, "index", new BulkItemResponse.Failure(updateRequest.index(), updateRequest.type(), updateRequest.id(), e)));, +            BulkItemResponse bulkItemResponse = new BulkItemResponse(idx, "index", failure);, +++ b/core/src/main/java/org/elasticsearch/action/search/type/TransportSearchScrollScanAction.java, +import java.util.ArrayList;, +import java.util.Objects;, +                    QueryFetchSearchResult shardResult = result.result();, +                    Objects.requireNonNull(shardResult, "QueryFetchSearchResult can't be null");, +                    queryFetchResults.setOnce(shardIndex, shardResult);, +            List<AtomicArray.Entry<QueryFetchSearchResult>> entries = queryFetchResults.asList();, +            for (AtomicArray.Entry<QueryFetchSearchResult> entry : entries) {, +            List<ScoreDoc> docs = new ArrayList<>(numberOfHits);, +            for (AtomicArray.Entry<QueryFetchSearchResult> entry : entries) {, +                    docs.add(scoreDoc);, +            final InternalSearchResponse internalResponse = searchPhaseController.merge(docs.toArray(new ScoreDoc[0]), queryFetchResults, queryFetchResults);, +            for (AtomicArray.Entry<QueryFetchSearchResult> entry : entries) {, +                    // we found more than we want for this round, remove this from our scrolling, so we don't go back to, +                    // this shard, since all hits have been processed., +                    // The SearchContext already gets freed on the node holding the shard, via a similar check., +++ b/core/pom.xml, +                                <ant antfile="${elasticsearch.tools.directory}/ant/integration-tests.xml", +                                     target="start-external-cluster"/>, +                                <ant antfile="${elasticsearch.tools.directory}/ant/integration-tests.xml", +                                     target="stop-external-cluster"/>, +++ b/core/src/main/java/org/elasticsearch/action/bulk/BulkItemResponse.java, +import org.elasticsearch.ElasticsearchException;, +import org.elasticsearch.common.xcontent.XContentBuilder;, +++ b/core/src/main/java/org/elasticsearch/action/bulk/TransportBulkAction.java, +                responses.set(idx, new BulkItemResponse(idx, "index", new BulkItemResponse.Failure(deleteRequest.index(), deleteRequest.type(), deleteRequest.id(), e)));, +                responses.set(idx, new BulkItemResponse(idx, "index", new BulkItemResponse.Failure(updateRequest.index(), updateRequest.type(), updateRequest.id(), e)));, +            BulkItemResponse bulkItemResponse = new BulkItemResponse(idx, "index", failure);, +++ b/core/src/main/java/org/elasticsearch/action/search/type/TransportSearchScrollScanAction.java, +import java.util.ArrayList;, +import java.util.Objects;, +                    QueryFetchSearchResult shardResult = result.result();, +                    Objects.requireNonNull(shardResult, "QueryFetchSearchResult can't be null");, +                    queryFetchResults.setOnce(shardIndex, shardResult);, +            List<AtomicArray.Entry<QueryFetchSearchResult>> entries = queryFetchResults.asList();, +            for (AtomicArray.Entry<QueryFetchSearchResult> entry : entries) {, +            List<ScoreDoc> docs = new ArrayList<>(numberOfHits);, +            for (AtomicArray.Entry<QueryFetchSearchResult> entry : entries) {, +                    docs.add(scoreDoc);, +            final InternalSearchResponse internalResponse = searchPhaseController.merge(docs.toArray(new ScoreDoc[0]), queryFetchResults, queryFetchResults);, +            for (AtomicArray.Entry<QueryFetchSearchResult> entry : entries) {, +                    // we found more than we want for this round, remove this from our scrolling, so we don't go back to, +                    // this shard, since all hits have been processed., +                    // The SearchContext already gets freed on the node holding the shard, via a similar check., +++ b/core/src/main/java/org/elasticsearch/common/util/concurrent/AtomicArray.java, +    public final void setOnce(int i, E value) {, +        if (array.compareAndSet(i, null, value) == false) {, +            throw new IllegalStateException("index [" + i + "] has already been set");, +        }, +        if (nonNullList != null) { // read first, lighter, and most times it will be null..., +            nonNullList = null;, +        }, +    }, +, +++ b/core/pom.xml, +                                <ant antfile="${elasticsearch.tools.directory}/ant/integration-tests.xml", +                                     target="start-external-cluster"/>, +                                <ant antfile="${elasticsearch.tools.directory}/ant/integration-tests.xml", +                                     target="stop-external-cluster"/>, +++ b/core/src/main/java/org/elasticsearch/action/bulk/BulkItemResponse.java, +import org.elasticsearch.ElasticsearchException;, +import org.elasticsearch.common.xcontent.XContentBuilder;, +++ b/core/src/main/java/org/elasticsearch/action/bulk/TransportBulkAction.java]