[+++ b/core/src/main/java/org/elasticsearch/index/fielddata/ScriptDocValues.java, +import org.joda.time.DateTime;, +import java.util.Comparator;, +import java.util.function.UnaryOperator;, +public abstract class ScriptDocValues<T> extends AbstractList<T> {, +    public abstract void setNextDocId(int docId);, +    public final List<T> getValues() {, +        return this;, +    }, +    // Throw meaningful exceptions if someone tries to modify the ScriptDocValues., +    @Override, +    public final void add(int index, T element) {, +        throw new UnsupportedOperationException("doc values are unmodifiable");, +    }, +, +    @Override, +    public final boolean remove(Object o) {, +        throw new UnsupportedOperationException("doc values are unmodifiable");, +    }, +, +    @Override, +    public final void replaceAll(UnaryOperator<T> operator) {, +        throw new UnsupportedOperationException("doc values are unmodifiable");, +    }, +, +    @Override, +    public final T set(int index, T element) {, +        throw new UnsupportedOperationException("doc values are unmodifiable");, +    }, +, +    @Override, +    public final void sort(Comparator<? super T> c) {, +        throw new UnsupportedOperationException("doc values are unmodifiable");, +    }, +, +    public static final class Strings extends ScriptDocValues<String> {, +    public static final class Longs extends ScriptDocValues<Long> {, +        private Dates dates;, +            if (dates != null) {, +                dates.refreshArray();, +            }, +        public ReadableDateTime getDate() {, +            if (dates == null) {, +                dates = new Dates(values);, +                dates.refreshArray();, +            }, +            return dates.getValue();, +        public List<ReadableDateTime> getDates() {, +            if (dates == null) {, +                dates = new Dates(values);, +                dates.refreshArray();, +            }, +            return dates;, +    public static final class Dates extends ScriptDocValues<ReadableDateTime> {, +        private static final ReadableDateTime EPOCH = new DateTime(0, DateTimeZone.UTC);, +, +        private final SortedNumericDocValues values;, +        /**, +         * Values wrapped in {@link MutableDateTime}. Null by default an allocated on first usage so we allocate a reasonably size. We keep, +         * this array so we don't have allocate new {@link MutableDateTime}s on every usage. Instead we reuse them for every document., +         */, +        private MutableDateTime[] dates;, +, +        public Dates(SortedNumericDocValues values) {, +            this.values = values;, +        }, +, +        /**, +         * Fetch the first field value or 0 millis after epoch if there are no values., +         */, +        public ReadableDateTime getValue() {, +            if (values.count() == 0) {, +                return EPOCH;, +            }, +            return get(0);, +        }, +, +        @Override, +        public ReadableDateTime get(int index) {, +            if (index >= values.count()) {, +                throw new IndexOutOfBoundsException(, +                        "attempted to fetch the [" + index + "] date when there are only [" + values.count() + "] dates.");, +            }, +            return dates[index];, +        }, +, +        @Override, +        public int size() {, +            return values.count();, +        }, +, +        @Override, +        public void setNextDocId(int docId) {, +            values.setDocument(docId);, +            refreshArray();, +        }, +, +        /**, +         * Refresh the backing array. Package private so it can be called when {@link Longs} loads dates., +         */]