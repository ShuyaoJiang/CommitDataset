[+++ b/server/src/main/java/org/elasticsearch/search/SearchSortValues.java, +++ b/server/src/main/java/org/elasticsearch/search/SearchSortValues.java, +++ b/server/src/test/java/org/elasticsearch/search/SearchHitTests.java, +            hit.sortValues(SearchSortValuesTests.createTestItem(xContentType, transportSerialization));, +++ b/server/src/main/java/org/elasticsearch/search/SearchSortValues.java, +++ b/server/src/test/java/org/elasticsearch/search/SearchHitTests.java, +            hit.sortValues(SearchSortValuesTests.createTestItem(xContentType, transportSerialization));, +++ b/server/src/test/java/org/elasticsearch/search/SearchSortValuesTests.java, +import org.apache.lucene.util.BytesRef;, +import org.elasticsearch.Version;, +import org.elasticsearch.common.io.stream.Writeable;, +import org.elasticsearch.common.lucene.LuceneTests;, +import org.elasticsearch.test.AbstractSerializingTestCase;, +import org.elasticsearch.test.RandomObjects;, +public class SearchSortValuesTests extends AbstractSerializingTestCase<SearchSortValues> {, +    public static SearchSortValues createTestItem(XContentType xContentType, boolean transportSerialization) {, +        DocValueFormat[] sortValueFormats = new DocValueFormat[size];, +            Object sortValue = randomSortValue(xContentType, transportSerialization);, +            values[i] = sortValue;, +            //make sure that for BytesRef, we provide a specific doc value format that overrides format(BytesRef), +            sortValueFormats[i] = sortValue instanceof BytesRef ? DocValueFormat.RAW : randomDocValueFormat();, +        return new SearchSortValues(values, sortValueFormats);, +    private static Object randomSortValue(XContentType xContentType, boolean transportSerialization) {, +        Object randomSortValue = LuceneTests.randomSortValue();, +        //to simplify things, we directly serialize what we expect we would parse back when testing xcontent serialization, +        return transportSerialization ? randomSortValue : RandomObjects.getExpectedParsedValue(xContentType, randomSortValue);, +    }, +    private static DocValueFormat randomDocValueFormat() {, +        return randomFrom(DocValueFormat.BOOLEAN, DocValueFormat.RAW, DocValueFormat.IP, DocValueFormat.BINARY, DocValueFormat.GEOHASH);, +    }, +, +    @Override, +    protected SearchSortValues doParseInstance(XContentParser parser) throws IOException {, +        SearchSortValues searchSortValues = SearchSortValues.fromXContent(parser);, +        return searchSortValues;, +, +    @Override, +    protected SearchSortValues createXContextTestInstance(XContentType xContentType) {, +        return createTestItem(xContentType, false);, +    }, +, +    @Override, +    protected SearchSortValues createTestInstance() {, +        return createTestItem(randomFrom(XContentType.values()), true);, +    }, +, +    @Override, +    protected Writeable.Reader<SearchSortValues> instanceReader() {, +        return SearchSortValues::new;, +    }, +, +    @Override, +    protected String[] getShuffleFieldsExceptions() {, +        return new String[]{"sort"};, +        {, +        {, +            SearchSortValues sortValues = new SearchSortValues(new Object[0]);, +            XContentBuilder builder = JsonXContent.contentBuilder();, +            builder.startObject();, +            sortValues.toXContent(builder, ToXContent.EMPTY_PARAMS);, +            builder.endObject();, +            assertEquals("{}", Strings.toString(builder));, +    @Override, +    protected SearchSortValues mutateInstance(SearchSortValues instance) {, +        Object[] sortValues = instance.sortValues();, +            return createTestInstance();, +        if (randomBoolean()) {, +            return new SearchSortValues(new Object[0]);, +        }, +        Object[] values = Arrays.copyOf(sortValues, sortValues.length + 1);, +        values[sortValues.length] = randomSortValue(randomFrom(XContentType.values()), true);, +        return new SearchSortValues(values);, +    @Override, +    protected SearchSortValues copyInstance(SearchSortValues instance, Version version) {, +        return new SearchSortValues(Arrays.copyOf(instance.sortValues(), instance.sortValues().length));, +++ b/server/src/main/java/org/elasticsearch/search/SearchSortValues.java, +++ b/server/src/test/java/org/elasticsearch/search/SearchHitTests.java, +            hit.sortValues(SearchSortValuesTests.createTestItem(xContentType, transportSerialization));, +++ b/server/src/test/java/org/elasticsearch/search/SearchSortValuesTests.java, +import org.apache.lucene.util.BytesRef;, +import org.elasticsearch.Version;, +import org.elasticsearch.common.io.stream.Writeable;, +import org.elasticsearch.common.lucene.LuceneTests;, +import org.elasticsearch.test.AbstractSerializingTestCase;, +import org.elasticsearch.test.RandomObjects;, +public class SearchSortValuesTests extends AbstractSerializingTestCase<SearchSortValues> {, +    public static SearchSortValues createTestItem(XContentType xContentType, boolean transportSerialization) {, +        DocValueFormat[] sortValueFormats = new DocValueFormat[size];, +            Object sortValue = randomSortValue(xContentType, transportSerialization);, +            values[i] = sortValue;, +            //make sure that for BytesRef, we provide a specific doc value format that overrides format(BytesRef), +            sortValueFormats[i] = sortValue instanceof BytesRef ? DocValueFormat.RAW : randomDocValueFormat();, +        return new SearchSortValues(values, sortValueFormats);, +    private static Object randomSortValue(XContentType xContentType, boolean transportSerialization) {, +        Object randomSortValue = LuceneTests.randomSortValue();, +        //to simplify things, we directly serialize what we expect we would parse back when testing xcontent serialization, +        return transportSerialization ? randomSortValue : RandomObjects.getExpectedParsedValue(xContentType, randomSortValue);, +    }, +    private static DocValueFormat randomDocValueFormat() {, +        return randomFrom(DocValueFormat.BOOLEAN, DocValueFormat.RAW, DocValueFormat.IP, DocValueFormat.BINARY, DocValueFormat.GEOHASH);]