[+++ b/src/main/java/org/elasticsearch/index/gateway/local/LocalIndexShardGateway.java, +    private final ThreadPool threadPool;, +, +    private volatile ScheduledFuture flushScheduler;, +    private final TimeValue syncInterval;, +        this.threadPool = threadPool;, +        syncInterval = componentSettings.getAsTime("sync", TimeValue.timeValueSeconds(5));, +        if (syncInterval.millis() > 0) {, +            flushScheduler = threadPool.schedule(syncInterval, ThreadPool.Names.SAME, new Sync());, +        } else if (syncInterval.millis() == 0) {, +    class Sync implements Runnable {, +            // don't re-schedule  if its closed..., we are done, +            if (indexShard.state() == IndexShardState.CLOSED) {, +                return;, +            }, +            if (indexShard.state() == IndexShardState.STARTED && indexShard.translog().syncNeeded()) {, +                threadPool.executor(ThreadPool.Names.SNAPSHOT).execute(new Runnable() {, +                    @Override, +                    public void run() {, +                        try {, +                        } catch (Exception e) {, +                            if (indexShard.state() == IndexShardState.STARTED) {, +                                logger.warn("failed to sync translog", e);, +                            }, +                        }, +                        if (indexShard.state() != IndexShardState.CLOSED) {, +                            flushScheduler = threadPool.schedule(syncInterval, ThreadPool.Names.SAME, Sync.this);, +                        }, +                    }, +                });, +            } else {, +                flushScheduler = threadPool.schedule(syncInterval, ThreadPool.Names.SAME, Sync.this);, +++ b/src/main/java/org/elasticsearch/index/gateway/local/LocalIndexShardGateway.java, +    private final ThreadPool threadPool;, +, +    private volatile ScheduledFuture flushScheduler;, +    private final TimeValue syncInterval;, +        this.threadPool = threadPool;, +        syncInterval = componentSettings.getAsTime("sync", TimeValue.timeValueSeconds(5));, +        if (syncInterval.millis() > 0) {, +            flushScheduler = threadPool.schedule(syncInterval, ThreadPool.Names.SAME, new Sync());, +        } else if (syncInterval.millis() == 0) {, +    class Sync implements Runnable {, +            // don't re-schedule  if its closed..., we are done, +            if (indexShard.state() == IndexShardState.CLOSED) {, +                return;, +            }, +            if (indexShard.state() == IndexShardState.STARTED && indexShard.translog().syncNeeded()) {, +                threadPool.executor(ThreadPool.Names.SNAPSHOT).execute(new Runnable() {, +                    @Override, +                    public void run() {, +                        try {, +                        } catch (Exception e) {, +                            if (indexShard.state() == IndexShardState.STARTED) {, +                                logger.warn("failed to sync translog", e);, +                            }, +                        }, +                        if (indexShard.state() != IndexShardState.CLOSED) {, +                            flushScheduler = threadPool.schedule(syncInterval, ThreadPool.Names.SAME, Sync.this);, +                        }, +                    }, +                });, +            } else {, +                flushScheduler = threadPool.schedule(syncInterval, ThreadPool.Names.SAME, Sync.this);, +++ b/src/main/java/org/elasticsearch/index/translog/Translog.java, +    boolean syncNeeded();, +, +++ b/src/main/java/org/elasticsearch/index/gateway/local/LocalIndexShardGateway.java, +    private final ThreadPool threadPool;, +, +    private volatile ScheduledFuture flushScheduler;, +    private final TimeValue syncInterval;, +        this.threadPool = threadPool;, +        syncInterval = componentSettings.getAsTime("sync", TimeValue.timeValueSeconds(5));, +        if (syncInterval.millis() > 0) {, +            flushScheduler = threadPool.schedule(syncInterval, ThreadPool.Names.SAME, new Sync());, +        } else if (syncInterval.millis() == 0) {, +    class Sync implements Runnable {, +            // don't re-schedule  if its closed..., we are done, +            if (indexShard.state() == IndexShardState.CLOSED) {, +                return;, +            }, +            if (indexShard.state() == IndexShardState.STARTED && indexShard.translog().syncNeeded()) {, +                threadPool.executor(ThreadPool.Names.SNAPSHOT).execute(new Runnable() {, +                    @Override, +                    public void run() {, +                        try {, +                        } catch (Exception e) {, +                            if (indexShard.state() == IndexShardState.STARTED) {, +                                logger.warn("failed to sync translog", e);, +                            }, +                        }, +                        if (indexShard.state() != IndexShardState.CLOSED) {, +                            flushScheduler = threadPool.schedule(syncInterval, ThreadPool.Names.SAME, Sync.this);, +                        }, +                    }, +                });, +            } else {, +                flushScheduler = threadPool.schedule(syncInterval, ThreadPool.Names.SAME, Sync.this);, +++ b/src/main/java/org/elasticsearch/index/translog/Translog.java]