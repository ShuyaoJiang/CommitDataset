[+++ b/src/main/java/org/elasticsearch/action/admin/indices/recovery/TransportRecoveryAction.java, +import org.elasticsearch.index.gateway.IndexShardGatewayService;, +import org.elasticsearch.index.service.InternalIndexService;, +import org.elasticsearch.index.shard.service.InternalIndexShard;, +import org.elasticsearch.indices.IndicesService;, +import org.elasticsearch.indices.recovery.RecoveryState;, +import org.elasticsearch.indices.recovery.RecoveryStatus;, +import java.util.HashMap;, +        return state.routingTable().allAssignedShardsGrouped(concreteIndices, true, true);, +++ b/src/main/java/org/elasticsearch/action/admin/indices/recovery/TransportRecoveryAction.java, +import org.elasticsearch.index.gateway.IndexShardGatewayService;, +import org.elasticsearch.index.service.InternalIndexService;, +import org.elasticsearch.index.shard.service.InternalIndexShard;, +import org.elasticsearch.indices.IndicesService;, +import org.elasticsearch.indices.recovery.RecoveryState;, +import org.elasticsearch.indices.recovery.RecoveryStatus;, +import java.util.HashMap;, +        return state.routingTable().allAssignedShardsGrouped(concreteIndices, true, true);, +++ b/src/test/java/org/elasticsearch/indices/recovery/IndexRecoveryTests.java, +import org.elasticsearch.indices.recovery.RecoveryState.Stage;, +import org.elasticsearch.indices.recovery.RecoveryState.Type;, +import static org.elasticsearch.test.ElasticsearchIntegrationTest.Scope;, +, +    private void assertRecoveryStateWithoutStage(RecoveryState state, int shardId, Type type,, +                                                 String sourceNode, String targetNode, boolean hasRestoreSource) {, +        assertThat(state.getShardId().getId(), equalTo(shardId));, +        assertThat(state.getType(), equalTo(type));, +        if (sourceNode == null) {, +            assertNull(state.getSourceNode());, +        } else {, +            assertNotNull(state.getSourceNode());, +            assertThat(state.getSourceNode().getName(), equalTo(sourceNode));, +        }, +        if (targetNode == null) {, +            assertNull(state.getTargetNode());, +        } else {, +            assertNotNull(state.getTargetNode());, +            assertThat(state.getTargetNode().getName(), equalTo(targetNode));, +        }, +        if (hasRestoreSource) {, +            assertNotNull(state.getRestoreSource());, +        } else {, +            assertNull(state.getRestoreSource());, +        }, +, +    }, +, +    private void assertRecoveryState(RecoveryState state, int shardId, Type type, Stage stage,, +                                     String sourceNode, String targetNode, boolean hasRestoreSource) {, +        assertRecoveryStateWithoutStage(state, shardId, type, sourceNode, targetNode, hasRestoreSource);, +        assertThat(state.getStage(), equalTo(stage));, +    }, +, +    private void assertOnGoingRecoveryState(RecoveryState state, int shardId, Type type,, +                                            String sourceNode, String targetNode, boolean hasRestoreSource) {, +        assertRecoveryStateWithoutStage(state, shardId, type, sourceNode, targetNode, hasRestoreSource);, +        assertThat(state.getStage(), not(equalTo(Stage.DONE)));, +    }, +, +    private void slowDownRecovery() {, +        assertTrue(client().admin().cluster().prepareUpdateSettings(), +                .setTransientSettings(ImmutableSettings.builder(), +                        .put(RecoverySettings.INDICES_RECOVERY_MAX_BYTES_PER_SEC, "50b"), +                        .put(RecoverySettings.INDICES_RECOVERY_FILE_CHUNK_SIZE, "10b")), +                .get().isAcknowledged());, +    }, +, +    private void restoreRecoverySpeed() {, +        assertTrue(client().admin().cluster().prepareUpdateSettings(), +                .setTransientSettings(ImmutableSettings.builder(), +                        .put(RecoverySettings.INDICES_RECOVERY_MAX_BYTES_PER_SEC, "20mb"), +                        .put(RecoverySettings.INDICES_RECOVERY_FILE_CHUNK_SIZE, "512kb")), +                .get().isAcknowledged());, +    }, +, +        assertRecoveryState(state, 0, Type.GATEWAY, Stage.DONE, node, node, false);, +        assertRecoveryState(nodeAShardResponse.recoveryState(), 0, Type.GATEWAY, Stage.DONE, nodeA, nodeA, false);, +        assertRecoveryState(nodeBShardResponse.recoveryState(), 0, Type.REPLICA, Stage.DONE, nodeA, nodeB, false);, +, +        logger.info("--> slowing down recoveries");, +        slowDownRecovery();, +, +        List<ShardRecoveryResponse> nodeAResponses = findRecoveriesForTargetNode(nodeA, shardResponses);, +        assertThat(nodeAResponses.size(), equalTo(1));, +        List<ShardRecoveryResponse> nodeBResponses = findRecoveriesForTargetNode(nodeB, shardResponses);, +        assertThat(nodeBResponses.size(), equalTo(1));, +, +        assertRecoveryState(nodeAResponses.get(0).recoveryState(), 0, Type.GATEWAY, Stage.DONE, nodeA, nodeA, false);, +        validateIndexRecoveryState(nodeAResponses.get(0).recoveryState().getIndex());, +, +        assertOnGoingRecoveryState(nodeBResponses.get(0).recoveryState(), 0, Type.RELOCATION, nodeA, nodeB, false);, +        validateIndexRecoveryState(nodeBResponses.get(0).recoveryState().getIndex());, +, +        logger.info("--> speeding up recoveries");, +        restoreRecoverySpeed();, +, +        // wait for it to be finished, +        ensureGreen();, +, +        response = client().admin().indices().prepareRecoveries(INDEX_NAME).execute().actionGet();]