[+++ b/src/main/java/org/elasticsearch/search/aggregations/bucket/BytesRefHash.java, +     * <p color="red">Beware that the content of the {@link BytesRef} may become invalid as soon as {@link #release()} is called</p>, +++ b/src/main/java/org/elasticsearch/search/aggregations/bucket/BytesRefHash.java, +     * <p color="red">Beware that the content of the {@link BytesRef} may become invalid as soon as {@link #release()} is called</p>, +++ b/src/main/java/org/elasticsearch/search/aggregations/bucket/terms/StringTerms.java, +        BytesRef termBytes;, +++ b/src/main/java/org/elasticsearch/search/aggregations/bucket/BytesRefHash.java, +     * <p color="red">Beware that the content of the {@link BytesRef} may become invalid as soon as {@link #release()} is called</p>, +++ b/src/main/java/org/elasticsearch/search/aggregations/bucket/terms/StringTerms.java, +        BytesRef termBytes;, +++ b/src/main/java/org/elasticsearch/search/aggregations/bucket/terms/StringTermsAggregator.java, +            // the terms are owned by the BytesRefHash, we need to pull a copy since the BytesRef hash data may be recycled at some point, +            bucket.termBytes = BytesRef.deepCopyOf(bucket.termBytes);, +++ b/src/main/java/org/elasticsearch/search/aggregations/bucket/BytesRefHash.java, +     * <p color="red">Beware that the content of the {@link BytesRef} may become invalid as soon as {@link #release()} is called</p>, +++ b/src/main/java/org/elasticsearch/search/aggregations/bucket/terms/StringTerms.java, +        BytesRef termBytes;, +++ b/src/main/java/org/elasticsearch/search/aggregations/bucket/terms/StringTermsAggregator.java, +            // the terms are owned by the BytesRefHash, we need to pull a copy since the BytesRef hash data may be recycled at some point, +            bucket.termBytes = BytesRef.deepCopyOf(bucket.termBytes);, +++ b/src/test/java/org/elasticsearch/cache/recycler/MockPageCacheRecycler.java, +import java.lang.reflect.Array;, +    private <T> V<T> wrap(final V<T> v) {, +                final T ref = v();, +                for (int i = 0; i < Array.getLength(ref); ++i) {, +                    if (ref instanceof Object[]) {, +                        Array.set(ref, i, null);, +                    } else {, +                        Array.set(ref, i, (byte) random.nextInt(256));, +                    }, +                }, +++ b/src/main/java/org/elasticsearch/search/aggregations/bucket/BytesRefHash.java, +     * <p color="red">Beware that the content of the {@link BytesRef} may become invalid as soon as {@link #release()} is called</p>, +++ b/src/main/java/org/elasticsearch/search/aggregations/bucket/terms/StringTerms.java, +        BytesRef termBytes;, +++ b/src/main/java/org/elasticsearch/search/aggregations/bucket/terms/StringTermsAggregator.java, +            // the terms are owned by the BytesRefHash, we need to pull a copy since the BytesRef hash data may be recycled at some point, +            bucket.termBytes = BytesRef.deepCopyOf(bucket.termBytes);, +++ b/src/test/java/org/elasticsearch/cache/recycler/MockPageCacheRecycler.java, +import java.lang.reflect.Array;, +    private <T> V<T> wrap(final V<T> v) {, +                final T ref = v();, +                for (int i = 0; i < Array.getLength(ref); ++i) {, +                    if (ref instanceof Object[]) {, +                        Array.set(ref, i, null);, +                    } else {, +                        Array.set(ref, i, (byte) random.nextInt(256));, +                    }, +                }, +++ b/src/test/java/org/elasticsearch/search/aggregations/RandomTests.java, +        // These high numbers of docs and terms are important to trigger page recycling, +        final int numDocs = atLeast(10000);, +        final int maxNumTerms = randomIntBetween(10, 100000);]