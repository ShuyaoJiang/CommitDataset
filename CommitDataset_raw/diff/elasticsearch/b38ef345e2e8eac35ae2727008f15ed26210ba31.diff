[+++ b/client/src/main/java/org/elasticsearch/client/ConnectionPool.java, + * It keeps track of the different hosts to communicate with and allows to retrieve an iterator of connections to be used, + * Provides an iterator of connections to be used at each {@link #nextConnection()} call., +     * Returns an iterator of connections that should be used for a request call., +     * Ideally, the first connection is retrieved from the iterator and used successfully for the request., +     * Otherwise, after each failure the next connection should be retrieved from the iterator so that the request can be retried., +     * The maximum total of attempts is equal to the number of connections that are available in the iterator., +     * The iterator returned will never be empty, rather an {@link IllegalStateException} will be thrown in that case., +     * In case there are no alive connections available, or dead ones that should be retried, one dead connection, +     * gets resurrected and returned., +        List<Connection> rotatedConnections = new ArrayList<>(connections);, +        Collections.rotate(rotatedConnections, rotatedConnections.size() - lastConnectionIndex.getAndIncrement());, +        Iterator<Connection> connectionIterator = rotatedConnections.iterator();, +        if (rotatedConnections.isEmpty()) {, +            List<Connection> sortedConnections = new ArrayList<>(connections);, +            Collections.sort(sortedConnections, new Comparator<Connection>() {, +                @Override, +                public int compare(Connection o1, Connection o2) {, +                    return Long.compare(o1.getDeadUntil(), o2.getDeadUntil());, +                }, +            });, +            Connection connection = sortedConnections.get(0);, +            connection.markResurrected();, +            logger.trace("marked connection resurrected for " + connection.getHost());, +            return Collections.singleton(connection).iterator();, +        }, +        return rotatedConnections.iterator();, +++ b/client/src/main/java/org/elasticsearch/client/ConnectionPool.java, + * It keeps track of the different hosts to communicate with and allows to retrieve an iterator of connections to be used, + * Provides an iterator of connections to be used at each {@link #nextConnection()} call., +     * Returns an iterator of connections that should be used for a request call., +     * Ideally, the first connection is retrieved from the iterator and used successfully for the request., +     * Otherwise, after each failure the next connection should be retrieved from the iterator so that the request can be retried., +     * The maximum total of attempts is equal to the number of connections that are available in the iterator., +     * The iterator returned will never be empty, rather an {@link IllegalStateException} will be thrown in that case., +     * In case there are no alive connections available, or dead ones that should be retried, one dead connection, +     * gets resurrected and returned., +        List<Connection> rotatedConnections = new ArrayList<>(connections);, +        Collections.rotate(rotatedConnections, rotatedConnections.size() - lastConnectionIndex.getAndIncrement());, +        Iterator<Connection> connectionIterator = rotatedConnections.iterator();, +        if (rotatedConnections.isEmpty()) {, +            List<Connection> sortedConnections = new ArrayList<>(connections);, +            Collections.sort(sortedConnections, new Comparator<Connection>() {, +                @Override, +                public int compare(Connection o1, Connection o2) {, +                    return Long.compare(o1.getDeadUntil(), o2.getDeadUntil());, +                }, +            });, +            Connection connection = sortedConnections.get(0);, +            connection.markResurrected();, +            logger.trace("marked connection resurrected for " + connection.getHost());, +            return Collections.singleton(connection).iterator();, +        }, +        return rotatedConnections.iterator();, +++ b/client/src/main/java/org/elasticsearch/client/RestClient.java, +        return performRequest(request, connectionPool.nextConnection());, +++ b/client/src/main/java/org/elasticsearch/client/ConnectionPool.java, + * It keeps track of the different hosts to communicate with and allows to retrieve an iterator of connections to be used, + * Provides an iterator of connections to be used at each {@link #nextConnection()} call., +     * Returns an iterator of connections that should be used for a request call., +     * Ideally, the first connection is retrieved from the iterator and used successfully for the request., +     * Otherwise, after each failure the next connection should be retrieved from the iterator so that the request can be retried., +     * The maximum total of attempts is equal to the number of connections that are available in the iterator., +     * The iterator returned will never be empty, rather an {@link IllegalStateException} will be thrown in that case., +     * In case there are no alive connections available, or dead ones that should be retried, one dead connection, +     * gets resurrected and returned., +        List<Connection> rotatedConnections = new ArrayList<>(connections);, +        Collections.rotate(rotatedConnections, rotatedConnections.size() - lastConnectionIndex.getAndIncrement());, +        Iterator<Connection> connectionIterator = rotatedConnections.iterator();, +        if (rotatedConnections.isEmpty()) {, +            List<Connection> sortedConnections = new ArrayList<>(connections);, +            Collections.sort(sortedConnections, new Comparator<Connection>() {, +                @Override, +                public int compare(Connection o1, Connection o2) {, +                    return Long.compare(o1.getDeadUntil(), o2.getDeadUntil());, +                }, +            });, +            Connection connection = sortedConnections.get(0);, +            connection.markResurrected();, +            logger.trace("marked connection resurrected for " + connection.getHost());, +            return Collections.singleton(connection).iterator();, +        }, +        return rotatedConnections.iterator();, +++ b/client/src/main/java/org/elasticsearch/client/RestClient.java, +        return performRequest(request, connectionPool.nextConnection());, +++ b/client/src/main/java/org/elasticsearch/client/sniff/SniffingConnectionPool.java, +                    sniff(nextConnection(), excludeHost);]