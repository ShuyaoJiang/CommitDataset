[+++ b/server/src/main/java/org/elasticsearch/common/time/DateFormatters.java, +            dateTimeFormatters.addAll(javaDateFormatter.getParsers());, +++ b/server/src/main/java/org/elasticsearch/common/time/DateFormatters.java, +            dateTimeFormatters.addAll(javaDateFormatter.getParsers());, +++ b/server/src/main/java/org/elasticsearch/common/time/JavaDateFormatter.java, +import java.text.ParsePosition;, +import java.util.Collection;, +import java.util.Collections;, +import java.util.List;, +, +    private final List<DateTimeFormatter> parsers;, +, +            this.parsers = Collections.singletonList(printer);, +            this.parsers = Arrays.asList(parsers);, +            builder.append(this.parsers.get(0));, +        DateTimeFormatter roundupFormatter = builder.toFormatter(locale());, +            roundupFormatter = roundupFormatter.withZone(zone());, +            return doParse(input);, +    /**, +     * Attempt parsing the input without throwing exception. If multiple parsers are provided,, +     * it will continue iterating if the previous parser failed. The pattern must fully match, meaning whole input was used., +     * This also means that this method depends on <code>DateTimeFormatter.ClassicFormat.parseObject</code>, +     * which does not throw exceptions when parsing failed., +     *, +     * The approach with collection of parsers was taken because java-time requires ordering on optional (composite), +     * patterns. Joda does not suffer from this., +     * https://bugs.openjdk.java.net/browse/JDK-8188771, +     *, +     * @param input An arbitrary string resembling the string representation of a date or time, +     * @return a TemporalAccessor if parsing was successful., +     * @throws DateTimeParseException when unable to parse with any parsers, +     */, +    private TemporalAccessor doParse(String input) {, +        if (parsers.size() > 1) {, +            for (DateTimeFormatter formatter : parsers) {, +                ParsePosition pos = new ParsePosition(0);, +                Object object = formatter.toFormat().parseObject(input, pos);, +                if (parsingSucceeded(object, input, pos) == true) {, +                    return (TemporalAccessor) object;, +                }, +            }, +            throw new DateTimeParseException("Failed to parse with all enclosed parsers", input, 0);, +        }, +        return this.parsers.get(0).parse(input);, +    }, +, +    private boolean parsingSucceeded(Object object, String input, ParsePosition pos) {, +        return object != null && pos.getIndex() == input.length();, +    }, +, +        if (zoneId.equals(zone())) {, +        return new JavaDateFormatter(format, printer.withZone(zoneId),, +            parsers.stream().map(p -> p.withZone(zoneId)).toArray(size -> new DateTimeFormatter[size]));, +        if (locale.equals(locale())) {, +        return new JavaDateFormatter(format, printer.withLocale(locale),, +            parsers.stream().map(p -> p.withLocale(locale)).toArray(size -> new DateTimeFormatter[size]));, +        return new JavaDateMathParser(format, this, getRoundupParser());, +, +    Collection<DateTimeFormatter> getParsers() {, +        return parsers;, +    }, +++ b/server/src/main/java/org/elasticsearch/common/time/DateFormatters.java, +            dateTimeFormatters.addAll(javaDateFormatter.getParsers());, +++ b/server/src/main/java/org/elasticsearch/common/time/JavaDateFormatter.java, +import java.text.ParsePosition;, +import java.util.Collection;, +import java.util.Collections;, +import java.util.List;, +, +    private final List<DateTimeFormatter> parsers;, +, +            this.parsers = Collections.singletonList(printer);, +            this.parsers = Arrays.asList(parsers);, +            builder.append(this.parsers.get(0));, +        DateTimeFormatter roundupFormatter = builder.toFormatter(locale());, +            roundupFormatter = roundupFormatter.withZone(zone());, +            return doParse(input);, +    /**, +     * Attempt parsing the input without throwing exception. If multiple parsers are provided,, +     * it will continue iterating if the previous parser failed. The pattern must fully match, meaning whole input was used., +     * This also means that this method depends on <code>DateTimeFormatter.ClassicFormat.parseObject</code>, +     * which does not throw exceptions when parsing failed., +     *, +     * The approach with collection of parsers was taken because java-time requires ordering on optional (composite), +     * patterns. Joda does not suffer from this., +     * https://bugs.openjdk.java.net/browse/JDK-8188771, +     *, +     * @param input An arbitrary string resembling the string representation of a date or time, +     * @return a TemporalAccessor if parsing was successful., +     * @throws DateTimeParseException when unable to parse with any parsers, +     */, +    private TemporalAccessor doParse(String input) {, +        if (parsers.size() > 1) {, +            for (DateTimeFormatter formatter : parsers) {, +                ParsePosition pos = new ParsePosition(0);, +                Object object = formatter.toFormat().parseObject(input, pos);, +                if (parsingSucceeded(object, input, pos) == true) {, +                    return (TemporalAccessor) object;, +                }, +            }]