[+++ b/buildSrc/src/main/groovy/org/elasticsearch/gradle/test/ClusterConfiguration.groovy, +    Map<String, Object> settings = new HashMap<>(), +    void setting(String name, Object value) {, +++ b/buildSrc/src/main/groovy/org/elasticsearch/gradle/test/ClusterConfiguration.groovy, +    Map<String, Object> settings = new HashMap<>(), +    void setting(String name, Object value) {, +++ b/core/src/main/java/org/elasticsearch/bootstrap/Security.java, +import org.elasticsearch.common.network.NetworkModule;, +    /**, +     * Add dynamic {@link SocketPermission}s based on HTTP and transport settings., +     *, +     * @param policy the {@link Permissions} instance to apply the dynamic {@link SocketPermission}s to., +     * @param settings the {@link Settings} instance to read the HTTP and transport settings from, +     */, +    static void addBindPermissions(Permissions policy, Settings settings) {, +        addSocketPermissionForHttp(policy, settings);, +                addSocketPermissionForTransportProfile(policy, profileSettings, settings);, +            }, +        }, +, +        for (final Settings tribeNodeSettings : settings.getGroups("tribe", true).values()) {, +            // tribe nodes have HTTP disabled by default, so we check if HTTP is enabled before granting, +            if (NetworkModule.HTTP_ENABLED.exists(tribeNodeSettings) && NetworkModule.HTTP_ENABLED.get(tribeNodeSettings)) {, +                addSocketPermissionForHttp(policy, tribeNodeSettings);, +            }, +            addSocketPermissionForTransport(policy, tribeNodeSettings);, +        }, +    }, +, +    /**, +     * Add dynamic {@link SocketPermission} based on HTTP settings., +     *, +     * @param policy the {@link Permissions} instance to apply the dynamic {@link SocketPermission}s to., +     * @param settings the {@link Settings} instance to read the HTTP settingsfrom, +     */, +    private static void addSocketPermissionForHttp(final Permissions policy, final Settings settings) {, +        // http is simple, +        final String httpRange = HttpTransportSettings.SETTING_HTTP_PORT.get(settings).getPortRangeString();, +        addSocketPermissionForPortRange(policy, httpRange);, +    }, +, +    /**, +     * Add dynamic {@link SocketPermission} based on transport settings. This method will first check if there is a port range specified in, +     * the transport profile specified by {@code profileSettings} and will fall back to {@code settings}., +     *, +     * @param policy          the {@link Permissions} instance to apply the dynamic {@link SocketPermission}s to, +     * @param profileSettings the {@link Settings} to read the transport profile from, +     * @param settings        the {@link Settings} instance to read the transport settings from, +     */, +    private static void addSocketPermissionForTransportProfile(, +        final Permissions policy,, +        final Settings profileSettings,, +        final Settings settings) {, +        final String transportRange = profileSettings.get("port");, +        if (transportRange != null) {, +            addSocketPermissionForPortRange(policy, transportRange);, +        } else {, +            addSocketPermissionForTransport(policy, settings);, +        }, +    }, +, +    /**, +     * Add dynamic {@link SocketPermission} based on transport settings., +     *, +     * @param policy          the {@link Permissions} instance to apply the dynamic {@link SocketPermission}s to, +     * @param settings        the {@link Settings} instance to read the transport settings from, +     */, +    private static void addSocketPermissionForTransport(final Permissions policy, final Settings settings) {, +        final String transportRange = TransportSettings.PORT.get(settings);, +        addSocketPermissionForPortRange(policy, transportRange);, +    }, +, +    /**, +     * Add dynamic {@link SocketPermission} for the specified port range., +     *, +     * @param policy the {@link Permissions} instance to apply the dynamic {@link SocketPermission} to., +     * @param portRange the port range, +     */, +    private static void addSocketPermissionForPortRange(final Permissions policy, final String portRange) {, +        policy.add(new SocketPermission("*:" + portRange, "listen,resolve"));, +++ b/buildSrc/src/main/groovy/org/elasticsearch/gradle/test/ClusterConfiguration.groovy, +    Map<String, Object> settings = new HashMap<>(), +    void setting(String name, Object value) {, +++ b/core/src/main/java/org/elasticsearch/bootstrap/Security.java, +import org.elasticsearch.common.network.NetworkModule;, +    /**, +     * Add dynamic {@link SocketPermission}s based on HTTP and transport settings., +     *, +     * @param policy the {@link Permissions} instance to apply the dynamic {@link SocketPermission}s to., +     * @param settings the {@link Settings} instance to read the HTTP and transport settings from, +     */, +    static void addBindPermissions(Permissions policy, Settings settings) {, +        addSocketPermissionForHttp(policy, settings);, +                addSocketPermissionForTransportProfile(policy, profileSettings, settings);, +            }, +        }, +, +        for (final Settings tribeNodeSettings : settings.getGroups("tribe", true).values()) {, +            // tribe nodes have HTTP disabled by default, so we check if HTTP is enabled before granting, +            if (NetworkModule.HTTP_ENABLED.exists(tribeNodeSettings) && NetworkModule.HTTP_ENABLED.get(tribeNodeSettings)) {]