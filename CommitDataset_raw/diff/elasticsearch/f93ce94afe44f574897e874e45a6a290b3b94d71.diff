[+++ b/core/src/main/java/org/elasticsearch/client/transport/support/TransportProxyClient.java, +++ b/core/src/main/java/org/elasticsearch/client/transport/support/TransportProxyClient.java, +++ b/core/src/main/java/org/elasticsearch/index/mapper/ObjectMapper.java, +            ObjectMapper.Builder builder = new Builder(name);, +++ b/core/src/main/java/org/elasticsearch/client/transport/support/TransportProxyClient.java, +++ b/core/src/main/java/org/elasticsearch/index/mapper/ObjectMapper.java, +            ObjectMapper.Builder builder = new Builder(name);, +++ b/core/src/main/java/org/elasticsearch/index/mapper/RootObjectMapper.java, +import org.elasticsearch.common.Explicit;, +import java.util.Collection;, +import java.util.Collections;, +import static org.elasticsearch.common.xcontent.support.XContentMapValues.nodeBooleanValue;, +        protected Explicit<DynamicTemplate[]> dynamicTemplates = new Explicit<>(new DynamicTemplate[0], false);, +        protected Explicit<FormatDateTimeFormatter[]> dynamicDateTimeFormatters = new Explicit<>(Defaults.DYNAMIC_DATE_TIME_FORMATTERS, false);, +        protected Explicit<Boolean> dateDetection = new Explicit<>(Defaults.DATE_DETECTION, false);, +        protected Explicit<Boolean> numericDetection = new Explicit<>(Defaults.NUMERIC_DETECTION, false);, +        public Builder dynamicDateTimeFormatter(Collection<FormatDateTimeFormatter> dateTimeFormatters) {, +            this.dynamicDateTimeFormatters = new Explicit<>(dateTimeFormatters.toArray(new FormatDateTimeFormatter[0]), true);, +        public Builder dynamicTemplates(Collection<DynamicTemplate> templates) {, +            this.dynamicTemplates = new Explicit<>(templates.toArray(new DynamicTemplate[0]), true);, +                    dynamicDateTimeFormatters,, +                    dynamicTemplates,, +            RootObjectMapper.Builder builder = new Builder(name);, +        protected boolean processField(RootObjectMapper.Builder builder, String fieldName, Object fieldNode,, +                    List<FormatDateTimeFormatter> formatters = new ArrayList<>();, +                    for (Object formatter : (List<?>) fieldNode) {, +                        if (formatter.toString().startsWith("epoch_")) {, +                            throw new MapperParsingException("Epoch ["+ formatter +"] is not supported as dynamic date format");, +                        formatters.add(parseDateTimeFormatter(formatter));, +                    builder.dynamicDateTimeFormatter(formatters);, +                    builder.dynamicDateTimeFormatter(Collections.emptyList());, +                    builder.dynamicDateTimeFormatter(Collections.singleton(parseDateTimeFormatter(fieldNode)));, +                List<?> tmplNodes = (List<?>) fieldNode;, +                List<DynamicTemplate> templates = new ArrayList<>();, +                        templates.add(template);, +                builder.dynamicTemplates(templates);, +                ((Builder) builder).dateDetection = new Explicit<>(nodeBooleanValue(fieldNode), true);, +                ((Builder) builder).numericDetection = new Explicit<>(nodeBooleanValue(fieldNode), true);, +    private Explicit<FormatDateTimeFormatter[]> dynamicDateTimeFormatters;, +    private Explicit<Boolean> dateDetection;, +    private Explicit<Boolean> numericDetection;, +    private Explicit<DynamicTemplate[]> dynamicTemplates;, +                     Explicit<FormatDateTimeFormatter[]> dynamicDateTimeFormatters, Explicit<DynamicTemplate[]> dynamicTemplates,, +                     Explicit<Boolean> dateDetection, Explicit<Boolean> numericDetection) {, +        // for dynamic updates, no need to carry root-specific options, we just, +        // set everything to they implicit default value so that they are not, +        // applied at merge time, +        update.dynamicTemplates = new Explicit<>(new DynamicTemplate[0], false);, +        update.dynamicDateTimeFormatters = new Explicit<FormatDateTimeFormatter[]>(Defaults.DYNAMIC_DATE_TIME_FORMATTERS, false);, +        update.dateDetection = new Explicit<>(Defaults.DATE_DETECTION, false);, +        update.numericDetection = new Explicit<>(Defaults.NUMERIC_DETECTION, false);, +        return this.dateDetection.value();, +        return this.numericDetection.value();, +        return dynamicDateTimeFormatters.value();, +        for (DynamicTemplate dynamicTemplate : dynamicTemplates.value()) {, +        if (mergeWithObject.numericDetection.explicit()) {, +            this.numericDetection = mergeWithObject.numericDetection;, +        if (mergeWithObject.dateDetection.explicit()) {, +            this.dateDetection = mergeWithObject.dateDetection;, +        if (mergeWithObject.dynamicDateTimeFormatters.explicit()) {, +            this.dynamicDateTimeFormatters = mergeWithObject.dynamicDateTimeFormatters;, +        if (mergeWithObject.dynamicTemplates.explicit()) {, +            this.dynamicTemplates = mergeWithObject.dynamicTemplates;, +        final boolean includeDefaults = params.paramAsBoolean("include_defaults", false);, +, +        if (dynamicDateTimeFormatters.explicit() || includeDefaults) {, +            for (FormatDateTimeFormatter dateTimeFormatter : dynamicDateTimeFormatters.value()) {, +        if (dynamicTemplates.explicit() || includeDefaults) {, +            for (DynamicTemplate dynamicTemplate : dynamicTemplates.value()) {, +        if (dateDetection.explicit() || includeDefaults) {, +            builder.field("date_detection", dateDetection.value());, +        if (numericDetection.explicit() || includeDefaults) {, +            builder.field("numeric_detection", numericDetection.value());, +++ b/core/src/main/java/org/elasticsearch/client/transport/support/TransportProxyClient.java, +++ b/core/src/main/java/org/elasticsearch/index/mapper/ObjectMapper.java, +            ObjectMapper.Builder builder = new Builder(name);, +++ b/core/src/main/java/org/elasticsearch/index/mapper/RootObjectMapper.java, +import org.elasticsearch.common.Explicit;, +import java.util.Collection;, +import java.util.Collections;, +import static org.elasticsearch.common.xcontent.support.XContentMapValues.nodeBooleanValue;, +        protected Explicit<DynamicTemplate[]> dynamicTemplates = new Explicit<>(new DynamicTemplate[0], false);, +        protected Explicit<FormatDateTimeFormatter[]> dynamicDateTimeFormatters = new Explicit<>(Defaults.DYNAMIC_DATE_TIME_FORMATTERS, false);, +        protected Explicit<Boolean> dateDetection = new Explicit<>(Defaults.DATE_DETECTION, false);, +        protected Explicit<Boolean> numericDetection = new Explicit<>(Defaults.NUMERIC_DETECTION, false);, +        public Builder dynamicDateTimeFormatter(Collection<FormatDateTimeFormatter> dateTimeFormatters) {, +            this.dynamicDateTimeFormatters = new Explicit<>(dateTimeFormatters.toArray(new FormatDateTimeFormatter[0]), true);, +        public Builder dynamicTemplates(Collection<DynamicTemplate> templates) {, +            this.dynamicTemplates = new Explicit<>(templates.toArray(new DynamicTemplate[0]), true);, +                    dynamicDateTimeFormatters,, +                    dynamicTemplates,, +            RootObjectMapper.Builder builder = new Builder(name);, +        protected boolean processField(RootObjectMapper.Builder builder, String fieldName, Object fieldNode,, +                    List<FormatDateTimeFormatter> formatters = new ArrayList<>();, +                    for (Object formatter : (List<?>) fieldNode) {, +                        if (formatter.toString().startsWith("epoch_")) {, +                            throw new MapperParsingException("Epoch ["+ formatter +"] is not supported as dynamic date format");, +                        formatters.add(parseDateTimeFormatter(formatter));, +                    builder.dynamicDateTimeFormatter(formatters);, +                    builder.dynamicDateTimeFormatter(Collections.emptyList());]