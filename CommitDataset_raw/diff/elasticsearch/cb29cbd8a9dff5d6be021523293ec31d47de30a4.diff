[+++ b/plugin/src/main/java/org/elasticsearch/xpack/ml/action/PutJobAction.java, +            jobManager.putJob(request, state, listener);, +++ b/plugin/src/main/java/org/elasticsearch/xpack/ml/action/PutJobAction.java, +            jobManager.putJob(request, state, listener);, +++ b/plugin/src/main/java/org/elasticsearch/xpack/ml/job/JobManager.java, +    public void putJob(PutJobAction.Request request, ClusterState state, ActionListener<PutJobAction.Response> actionListener) {, +                jobProvider.createJobResultIndex(job, state, new ActionListener<Boolean>() {, +                        return updateClusterState(job, false, currentState);, +++ b/plugin/src/main/java/org/elasticsearch/xpack/ml/action/PutJobAction.java, +            jobManager.putJob(request, state, listener);, +++ b/plugin/src/main/java/org/elasticsearch/xpack/ml/job/JobManager.java, +    public void putJob(PutJobAction.Request request, ClusterState state, ActionListener<PutJobAction.Response> actionListener) {, +                jobProvider.createJobResultIndex(job, state, new ActionListener<Boolean>() {, +                        return updateClusterState(job, false, currentState);, +++ b/plugin/src/main/java/org/elasticsearch/xpack/ml/job/persistence/JobProvider.java, +import org.elasticsearch.ResourceAlreadyExistsException;, +import org.elasticsearch.cluster.ClusterState;, +    public void createJobResultIndex(Job job, ClusterState state, ActionListener<Boolean> listener) {, +            // Indices can be shared, so only create if it doesn't exist already. Saves us a roundtrip if, +            // already in the CS, +            if (!state.getMetaData().hasIndex(indexName)) {, +                LOGGER.trace("ES API CALL: create index {}", indexName);, +                CreateIndexRequest createIndexRequest = new CreateIndexRequest(indexName);, +                createIndexRequest.settings(mlResultsIndexSettings());, +                createIndexRequest.mapping(Result.TYPE.getPreferredName(), resultsMapping);, +                createIndexRequest.mapping(CategoryDefinition.TYPE.getPreferredName(), categoryDefinitionMapping);, +                createIndexRequest.mapping(DataCounts.TYPE.getPreferredName(), dataCountsMapping);, +                createIndexRequest.mapping(ModelSnapshot.TYPE.getPreferredName(), modelSnapshotMapping);, +, +                        ActionListener.wrap(r -> createdListener.onResponse(true),, +                                e -> {, +                                    // Possible that the index was created while the request was executing,, +                                    // so we need to handle that possibility, +                                    if (e instanceof ResourceAlreadyExistsException) {, +                                        LOGGER.info("Index already exists");, +                                        // Create the alias, +                                        createdListener.onResponse(true);, +                                    } else {, +                                        createdListener.onFailure(e);, +                                    }, +                                }, +                        ));, +            } else {, +                // Trigger the alias creation handler manually, since the index already exists, +                listener.onResponse(true);, +            }, +, +++ b/plugin/src/main/java/org/elasticsearch/xpack/ml/action/PutJobAction.java, +            jobManager.putJob(request, state, listener);, +++ b/plugin/src/main/java/org/elasticsearch/xpack/ml/job/JobManager.java, +    public void putJob(PutJobAction.Request request, ClusterState state, ActionListener<PutJobAction.Response> actionListener) {, +                jobProvider.createJobResultIndex(job, state, new ActionListener<Boolean>() {, +                        return updateClusterState(job, false, currentState);, +++ b/plugin/src/main/java/org/elasticsearch/xpack/ml/job/persistence/JobProvider.java, +import org.elasticsearch.ResourceAlreadyExistsException;, +import org.elasticsearch.cluster.ClusterState;, +    public void createJobResultIndex(Job job, ClusterState state, ActionListener<Boolean> listener) {, +            // Indices can be shared, so only create if it doesn't exist already. Saves us a roundtrip if, +            // already in the CS, +            if (!state.getMetaData().hasIndex(indexName)) {, +                LOGGER.trace("ES API CALL: create index {}", indexName);, +                CreateIndexRequest createIndexRequest = new CreateIndexRequest(indexName);, +                createIndexRequest.settings(mlResultsIndexSettings());, +                createIndexRequest.mapping(Result.TYPE.getPreferredName(), resultsMapping);, +                createIndexRequest.mapping(CategoryDefinition.TYPE.getPreferredName(), categoryDefinitionMapping);, +                createIndexRequest.mapping(DataCounts.TYPE.getPreferredName(), dataCountsMapping);, +                createIndexRequest.mapping(ModelSnapshot.TYPE.getPreferredName(), modelSnapshotMapping);, +, +                        ActionListener.wrap(r -> createdListener.onResponse(true),, +                                e -> {, +                                    // Possible that the index was created while the request was executing,, +                                    // so we need to handle that possibility, +                                    if (e instanceof ResourceAlreadyExistsException) {, +                                        LOGGER.info("Index already exists");, +                                        // Create the alias, +                                        createdListener.onResponse(true);, +                                    } else {, +                                        createdListener.onFailure(e);, +                                    }, +                                }, +                        ));, +            } else {, +                // Trigger the alias creation handler manually, since the index already exists, +                listener.onResponse(true);, +            }, +, +++ b/plugin/src/test/java/org/elasticsearch/xpack/ml/integration/AutodetectResultProcessorIT.java, +import org.elasticsearch.cluster.AckedClusterStateUpdateTask;, +import org.elasticsearch.cluster.ClusterName;, +import org.elasticsearch.cluster.ClusterState;, +import org.elasticsearch.cluster.metadata.MetaData;, +import org.elasticsearch.cluster.service.ClusterService;, +import org.elasticsearch.common.collect.ImmutableOpenMap;, +import org.elasticsearch.xpack.ml.job.metadata.MlMetadata;, +import static org.mockito.Matchers.any;, +import static org.mockito.Matchers.eq;, +import static org.mockito.Mockito.doAnswer;, +    @SuppressWarnings("unchecked"), +        ClusterState cs = ClusterState.builder(new ClusterName("_name")), +                .metaData(MetaData.builder().putCustom(MlMetadata.TYPE, MlMetadata.EMPTY_METADATA).indices(ImmutableOpenMap.of())).build();]