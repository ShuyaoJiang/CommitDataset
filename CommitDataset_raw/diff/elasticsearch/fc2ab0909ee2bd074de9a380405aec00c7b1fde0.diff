[+++ b/src/main/java/org/elasticsearch/action/bench/BenchmarkExecutor.java, +            try {, +                    logger.debug("Failed to execute benchmark [{}]", e.getMessage(), e);, +            } finally {, +                manage(); // first add the msg then call the count down on the latch otherwise we might iss one error, +            }, +, +            try {, +            } finally {, +, +        }, +++ b/src/main/java/org/elasticsearch/action/bench/BenchmarkExecutor.java, +            try {, +                    logger.debug("Failed to execute benchmark [{}]", e.getMessage(), e);, +            } finally {, +                manage(); // first add the msg then call the count down on the latch otherwise we might iss one error, +            }, +, +            try {, +            } finally {, +, +        }, +++ b/src/main/java/org/elasticsearch/action/bench/BenchmarkService.java, +import java.util.ArrayList;, +import java.util.HashMap;, +import java.util.List;, +import java.util.Map;, +import java.util.concurrent.CopyOnWriteArrayList;, +                assert isBenchmarkNode(node);, +        List<String> errors = new ArrayList<>();, +            if (r.hasErrors()) {, +                for (String error : r.errors()) {, +                    errors.add(error);, +                }, +            }, +            if (!errors.isEmpty()) {, +                response.errors(errors.toArray(new String[errors.size()]));, +            }, +            assert errors.isEmpty() || response.state() != BenchmarkResponse.State.COMPLETE : "Response can't be complete since it has errors";, +++ b/src/main/java/org/elasticsearch/action/bench/BenchmarkExecutor.java, +            try {, +                    logger.debug("Failed to execute benchmark [{}]", e.getMessage(), e);, +            } finally {, +                manage(); // first add the msg then call the count down on the latch otherwise we might iss one error, +            }, +, +            try {, +            } finally {, +, +        }, +++ b/src/main/java/org/elasticsearch/action/bench/BenchmarkService.java, +import java.util.ArrayList;, +import java.util.HashMap;, +import java.util.List;, +import java.util.Map;, +import java.util.concurrent.CopyOnWriteArrayList;, +                assert isBenchmarkNode(node);, +        List<String> errors = new ArrayList<>();, +            if (r.hasErrors()) {, +                for (String error : r.errors()) {, +                    errors.add(error);, +                }, +            }, +            if (!errors.isEmpty()) {, +                response.errors(errors.toArray(new String[errors.size()]));, +            }, +            assert errors.isEmpty() || response.state() != BenchmarkResponse.State.COMPLETE : "Response can't be complete since it has errors";, +++ b/src/test/java/org/elasticsearch/action/bench/BenchmarkIntegrationTest.java, +import org.elasticsearch.action.search.SearchRequest;, +import org.elasticsearch.index.query.FilterBuilders;, +import org.elasticsearch.index.query.functionscore.script.ScriptScoreFunctionBuilder;, +import java.util.*;, +import java.util.concurrent.CountDownLatch;, +import static org.elasticsearch.client.Requests.searchRequest;, +import static org.elasticsearch.index.query.QueryBuilders.functionScoreQuery;, +import static org.elasticsearch.index.query.functionscore.ScoreFunctionBuilders.scriptFunction;, +import static org.elasticsearch.search.builder.SearchSourceBuilder.searchSource;, +    private HashMap<Integer, Boolean> benchNodes = new HashMap<>();, +, +, +    protected synchronized Settings nodeSettings(int nodeOrdinal) {, +        if (nodeOrdinal == 0) { // at least one, +        } else {, +            if (benchNodes.containsKey(nodeOrdinal)) {, +                return ImmutableSettings.builder().put("node.bench", benchNodes.get(nodeOrdinal)).build();, +            } else {, +                boolean b = randomBoolean();, +                benchNodes.put(nodeOrdinal, b);, +                return ImmutableSettings.builder().put("node.bench", b).build();, +    }, +        waitForTestLatch = null;, +        waitForQuery = null;, +        numExecutorNodes = 1; // node 0 is always an executor, +        for (Boolean benchExecutor : benchNodes.values()) {, +            if (benchExecutor) {, +                numExecutorNodes++;, +            }, +        }, +        SearchRequest searchRequest = prepareBlockingScriptQuery();, +                BenchmarkTestUtil.randomRequest(client(), indices, numExecutorNodes, competitionSettingsMap, searchRequest);]