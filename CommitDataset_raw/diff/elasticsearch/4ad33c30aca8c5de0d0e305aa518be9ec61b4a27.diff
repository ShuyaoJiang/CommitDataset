[+++ b/rest-api-spec/test/script/30_expressions.yaml, +  - do: { search: { body: { script_fields : { my_field : { lang: expression, script: 'doc["age"].value + 19' } } } } }, +  - match:  { hits.hits.0.fields.my_field.0: 42.0 }, +++ b/rest-api-spec/test/script/30_expressions.yaml, +  - do: { search: { body: { script_fields : { my_field : { lang: expression, script: 'doc["age"].value + 19' } } } } }, +  - match:  { hits.hits.0.fields.my_field.0: 42.0 }, +++ b/src/test/java/org/elasticsearch/test/rest/client/http/HttpRequestBuilder.java, +import java.io.UnsupportedEncodingException;, +import java.net.URLEncoder;, +        try {, +            //manually url encode params, since URI does it only partially (e.g. '+' stays as is), +            this.params.put(name, URLEncoder.encode(value, "utf-8"));, +        } catch (UnsupportedEncodingException e) {, +            throw new RuntimeException(e);, +        }, +            //url encode rules for path and query params are different. We use URI to encode the path, but we manually encode each query param through URLEncoder., +            URI uri = new URI(protocol, null, host, port, path, null, null);, +            //String concatenation FTW. If we use the nicer multi argument URI constructor query parameters will get only partially encoded, +            //(e.g. '+' will stay as is) hence when trying to properly encode params manually they will end up double encoded (+ becomes %252B instead of %2B)., +            StringBuilder uriBuilder = new StringBuilder(protocol).append("://").append(host).append(":").append(port).append(uri.getRawPath());, +            if (params.size() > 0) {, +                uriBuilder.append("?").append(Joiner.on('&').withKeyValueSeparator("=").join(params));, +            }, +            return URI.create(uriBuilder.toString());, +            throw new IllegalArgumentException("unable to build uri", e);]