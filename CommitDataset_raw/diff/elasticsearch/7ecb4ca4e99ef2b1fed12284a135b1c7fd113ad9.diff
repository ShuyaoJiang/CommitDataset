[+++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/Def.java, +++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/Def.java, +++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/DefBootstrap.java, + * Has 7 flavors (passed as static bootstrap parameters): dynamic method call,, + * dynamic array store, iterator, and method reference., +    /** static bootstrap parameter indicating a unary math operator, e.g. ~foo */, +    public static final int UNARY_OPERATOR = 7;, +    /** static bootstrap parameter indicating a binary math operator, e.g. foo / bar */, +    public static final int BINARY_OPERATOR = 8;, +    /** static bootstrap parameter indicating a shift operator, e.g. foo &gt;&gt; bar */, +    public static final int SHIFT_OPERATOR = 9;, +            // For operators use a monomorphic cache, fallback is fast., +            // Just start with a depth of MAX-1, to keep it a constant., +            if (flavor == UNARY_OPERATOR || flavor == BINARY_OPERATOR || flavor == SHIFT_OPERATOR) {, +                depth = MAX_DEPTH - 1;, +            }, +, +         * guard method for inline caching: checks the receiver's class and the first argument, +         * are the same as the cached receiver and first argument., +         */, +        static boolean checkBinary(Class<?> left, Class<?> right, Object leftObject, Object rightObject) {, +            return leftObject.getClass() == left && rightObject.getClass() == right;, +        }, +        , +        /**, +         * guard method for inline caching: checks the first argument is the same, +         * as the cached first argument., +         */, +        static boolean checkBinaryArg(Class<?> left, Class<?> right, Object leftObject, Object rightObject) {, +            return rightObject.getClass() == right;, +        }, +, +        /**, +        private MethodHandle lookup(int flavor, String name, Object[] args) throws Throwable {, +                    return Def.lookupMethod(lookup, type(), args[0].getClass(), name, args, (Long) this.args[0]);, +                    return Def.lookupGetter(args[0].getClass(), name);, +                    return Def.lookupSetter(args[0].getClass(), name);, +                    return Def.lookupArrayLoad(args[0].getClass());, +                    return Def.lookupArrayStore(args[0].getClass());, +                    return Def.lookupIterator(args[0].getClass());, +                    return Def.lookupReference(lookup, (String) this.args[0], args[0].getClass(), name);, +                case UNARY_OPERATOR:, +                case SHIFT_OPERATOR:, +                    // shifts are treated as unary, as java allows long arguments without a cast (but bits are ignored), +                    return DefMath.lookupUnary(args[0].getClass(), name);, +                case BINARY_OPERATOR:, +                    if (args[0] == null || args[1] == null) {, +                        return getGeneric(flavor, name); // can handle nulls, +                    } else {, +                        return DefMath.lookupBinary(args[0].getClass(), args[1].getClass(), name);, +                    }, +         * Installs a permanent, generic solution that works with any parameter types, if possible., +         */, +        private MethodHandle getGeneric(int flavor, String name) throws Throwable {, +            switch(flavor) {, +                case UNARY_OPERATOR:, +                case BINARY_OPERATOR:, +                case SHIFT_OPERATOR:, +                    return DefMath.lookupGeneric(name);, +                default:, +                    return null;, +            }, +        }, +, +        /**, +                // caching defeated, +                MethodHandle generic = getGeneric(flavor, name);, +                if (generic != null) {, +                    setTarget(generic.asType(type()));, +                    return generic.invokeWithArguments(args);, +                } else {, +                    return lookup(flavor, name, args).invokeWithArguments(args);, +                }, +            final MethodType type = type();, +            final MethodHandle target = lookup(flavor, name, args).asType(type);, +            final MethodHandle test;, +            if (flavor == BINARY_OPERATOR || flavor == SHIFT_OPERATOR) {, +                // some binary operators support nulls, we handle them separate, +                Class<?> clazz0 = args[0] == null ? null : args[0].getClass();, +                Class<?> clazz1 = args[1] == null ? null : args[1].getClass();, +                if (type.parameterType(1) != Object.class) {, +                    // case 1: only the receiver is unknown, just check that, +                    MethodHandle unaryTest = CHECK_CLASS.bindTo(clazz0);, +                    test = unaryTest.asType(unaryTest.type(), +                                            .changeParameterType(0, type.parameterType(0)));, +                } else if (type.parameterType(0) != Object.class) {, +                    // case 2: only the argument is unknown, just check that, +                    MethodHandle unaryTest = CHECK_BINARY_ARG.bindTo(clazz0).bindTo(clazz1);, +                    test = unaryTest.asType(unaryTest.type(), +                                            .changeParameterType(0, type.parameterType(0)), +                                            .changeParameterType(1, type.parameterType(1)));, +                } else {, +                    // case 3: check both receiver and argument, +                    MethodHandle binaryTest = CHECK_BINARY.bindTo(clazz0).bindTo(clazz1);, +                    test = binaryTest.asType(binaryTest.type(), +                                            .changeParameterType(0, type.parameterType(0)), +                                            .changeParameterType(1, type.parameterType(1)));, +                }, +            } else {, +                MethodHandle receiverTest = CHECK_CLASS.bindTo(args[0].getClass());]