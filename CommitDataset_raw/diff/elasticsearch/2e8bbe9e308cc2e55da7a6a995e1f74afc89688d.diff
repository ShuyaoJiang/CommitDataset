[+++ b/src/main/java/org/apache/lucene/search/XLuceneConstantScoreQuery.java, +package org.apache.lucene.search;, +, +/*, + * Licensed to the Apache Software Foundation (ASF) under one or more, + * contributor license agreements.  See the NOTICE file distributed with, + * this work for additional information regarding copyright ownership., + * The ASF licenses this file to You under the Apache License, Version 2.0, + * (the "License"); you may not use this file except in compliance with, + * the License.  You may obtain a copy of the License at, + *, + *     http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS,, + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied., + * See the License for the specific language governing permissions and, + * limitations under the License., + */, +, +import org.apache.lucene.index.AtomicReaderContext;, +import org.apache.lucene.index.IndexReader;, +import org.apache.lucene.util.Bits;, +import org.apache.lucene.util.Version;, +import org.elasticsearch.common.lucene.Lucene;, +, +import java.io.IOException;, +import java.util.Collection;, +import java.util.Collections;, +, +/**, + * Extension of {@link ConstantScoreQuery} that works around LUCENE-5307., + */, +// we extend CSQ so that highlighters know how to deal with this query, +public class XLuceneConstantScoreQuery extends ConstantScoreQuery {, +, +    static {, +        assert Version.LUCENE_45.onOrAfter(Lucene.VERSION) : "Lucene 4.6 CSQ is fixed, remove this one!";, +    }, +, +    public XLuceneConstantScoreQuery(Query filter) {, +        super(filter);, +    }, +, +    public XLuceneConstantScoreQuery(Filter filter) {, +        super(filter);, +    }, +, +    @Override, +    public Query rewrite(IndexReader reader) throws IOException {, +        if (query != null) {, +            Query rewritten = query.rewrite(reader);, +            if (rewritten != query) {, +                rewritten = new XLuceneConstantScoreQuery(rewritten);, +                rewritten.setBoost(this.getBoost());, +                return rewritten;, +            }, +        } else {, +            assert filter != null;, +            // Fix outdated usage pattern from Lucene 2.x/early-3.x:, +            // because ConstantScoreQuery only accepted filters,, +            // QueryWrapperFilter was used to wrap queries., +            if (filter instanceof QueryWrapperFilter) {, +                final QueryWrapperFilter qwf = (QueryWrapperFilter) filter;, +                final Query rewritten = new XLuceneConstantScoreQuery(qwf.getQuery().rewrite(reader));, +                rewritten.setBoost(this.getBoost());, +                return rewritten;, +            }, +        }, +        return this;, +    }, +, +    @Override, +    public Weight createWeight(IndexSearcher searcher) throws IOException {, +        return new XConstantWeight(searcher);, +    }, +, +    protected class XConstantWeight extends Weight {, +        private final Weight innerWeight;, +        private float queryNorm;, +        private float queryWeight;, +, +        public XConstantWeight(IndexSearcher searcher) throws IOException {, +            this.innerWeight = (query == null) ? null : query.createWeight(searcher);, +        }, +, +        @Override, +        public Query getQuery() {, +            return XLuceneConstantScoreQuery.this;, +        }, +, +        @Override, +        public float getValueForNormalization() throws IOException {, +            // we calculate sumOfSquaredWeights of the inner weight, but ignore it (just to initialize everything), +            if (innerWeight != null) innerWeight.getValueForNormalization();, +            queryWeight = getBoost();, +            return queryWeight * queryWeight;, +        }, +, +        @Override]