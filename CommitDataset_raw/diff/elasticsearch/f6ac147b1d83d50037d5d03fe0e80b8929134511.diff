[+++ b/core/src/test/java/org/elasticsearch/transport/AbstractSimpleTransportTestCase.java, +import org.elasticsearch.ExceptionsHelper;, +import java.util.HashMap;, +import java.util.Map;, +        // serviceA.setLocalNode(nodeA);, +        //serviceB.setLocalNode(nodeB);, +        TransportRequestOptions options = timeout ? TransportRequestOptions.builder().withTimeout(1).build() :, +            TransportRequestOptions.EMPTY;, +, +        String info;, +        int resendCount;, +, +        public TestRequest() {, +        }, +, +        public TestRequest(String info) {, +            this.info = info;, +        }, +, +        @Override, +        public void readFrom(StreamInput in) throws IOException {, +            super.readFrom(in);, +            info = in.readOptionalString();, +            resendCount = in.readInt();, +        }, +, +        @Override, +        public void writeTo(StreamOutput out) throws IOException {, +            super.writeTo(out);, +            out.writeOptionalString(info);, +            out.writeInt(resendCount);, +        }, +, +        @Override, +        public String toString() {, +            return "TestRequest{" +, +                "info='" + info + '\'' +, +                '}';, +        }, +, +        String info;, +, +        public TestResponse() {, +        }, +, +        public TestResponse(String info) {, +            this.info = info;, +        }, +, +        @Override, +        public void readFrom(StreamInput in) throws IOException {, +            super.readFrom(in);, +            info = in.readOptionalString();, +        }, +, +        @Override, +        public void writeTo(StreamOutput out) throws IOException {, +            super.writeTo(out);, +            out.writeOptionalString(info);, +        }, +, +        @Override, +        public String toString() {, +            return "TestResponse{" +, +                "info='" + info + '\'' +, +                '}';, +        }, +    }, +, +    public void testSendRandomRequests() throws InterruptedException {, +        TransportService serviceC = build(, +            Settings.builder(), +                .put("name", "TS_TEST"), +                .put(TransportService.TRACE_LOG_INCLUDE_SETTING.getKey(), ""), +                .put(TransportService.TRACE_LOG_EXCLUDE_SETTING.getKey(), "NOTHING"), +                .build(),, +            version0);, +        DiscoveryNode nodeC =, +            new DiscoveryNode("TS_C", "TS_C", serviceC.boundAddress().publishAddress(), emptyMap(), emptySet(), version0);, +        serviceC.acceptIncomingRequests();, +, +        final CountDownLatch latch = new CountDownLatch(5);, +        TransportConnectionListener waitForConnection = new TransportConnectionListener() {, +            @Override, +            public void onNodeConnected(DiscoveryNode node) {, +                latch.countDown();, +            }, +, +            @Override, +            public void onNodeDisconnected(DiscoveryNode node) {, +                fail("disconnect should not be called " + node);, +            }, +        };, +        serviceA.addConnectionListener(waitForConnection);, +        serviceB.addConnectionListener(waitForConnection);, +        serviceC.addConnectionListener(waitForConnection);, +, +        serviceC.connectToNode(nodeA);, +        serviceC.connectToNode(nodeB);, +        serviceA.connectToNode(nodeC);]