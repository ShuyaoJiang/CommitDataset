[+++ b/plugin/src/main/java/org/elasticsearch/xpack/ml/action/OpenJobAction.java, +import org.elasticsearch.cluster.routing.IndexRoutingTable;, +import org.elasticsearch.xpack.ml.job.persistence.AnomalyDetectorsIndex;, +import org.elasticsearch.xpack.ml.job.persistence.JobProvider;, +import org.elasticsearch.xpack.ml.notifications.Auditor;, +                validate(request, clusterState);, +        if (verifyIndicesExistAndPrimaryShardsAreActive(logger, jobId, clusterState) == false) {, +            return null;, +        }, +, +            logger.warn("no node selected for job [{}], reasons [{}]", jobId, String.join(",", reasons));, +, +    static boolean verifyIndicesExistAndPrimaryShardsAreActive(Logger logger, String jobId, ClusterState clusterState) {, +        MlMetadata mlMetadata = clusterState.metaData().custom(MlMetadata.TYPE);, +        Job job = mlMetadata.getJobs().get(jobId);, +        String jobResultIndex = AnomalyDetectorsIndex.jobResultsIndexName(job.getResultsIndexName());, +        String[] indices = new String[]{AnomalyDetectorsIndex.jobStateIndexName(), jobResultIndex, JobProvider.ML_META_INDEX,, +                Auditor.NOTIFICATIONS_INDEX};, +        for (String index : indices) {, +            if (clusterState.metaData().hasIndex(index) == false) {, +                logger.warn("Not opening job [{}], because [{}] index is missing.", jobId, index);, +                return false;, +            }, +            IndexRoutingTable routingTable = clusterState.getRoutingTable().index(index);, +            if (routingTable == null || routingTable.allPrimaryShardsActive() == false) {, +                logger.warn("Not opening job [{}], because not all primary shards are active for the [{}] index.", jobId, index);, +                return false;, +            }, +        }, +        return true;, +    }, +++ b/plugin/src/main/java/org/elasticsearch/xpack/ml/action/OpenJobAction.java, +import org.elasticsearch.cluster.routing.IndexRoutingTable;, +import org.elasticsearch.xpack.ml.job.persistence.AnomalyDetectorsIndex;, +import org.elasticsearch.xpack.ml.job.persistence.JobProvider;, +import org.elasticsearch.xpack.ml.notifications.Auditor;, +                validate(request, clusterState);, +        if (verifyIndicesExistAndPrimaryShardsAreActive(logger, jobId, clusterState) == false) {, +            return null;, +        }, +, +            logger.warn("no node selected for job [{}], reasons [{}]", jobId, String.join(",", reasons));, +, +    static boolean verifyIndicesExistAndPrimaryShardsAreActive(Logger logger, String jobId, ClusterState clusterState) {, +        MlMetadata mlMetadata = clusterState.metaData().custom(MlMetadata.TYPE);, +        Job job = mlMetadata.getJobs().get(jobId);, +        String jobResultIndex = AnomalyDetectorsIndex.jobResultsIndexName(job.getResultsIndexName());, +        String[] indices = new String[]{AnomalyDetectorsIndex.jobStateIndexName(), jobResultIndex, JobProvider.ML_META_INDEX,, +                Auditor.NOTIFICATIONS_INDEX};, +        for (String index : indices) {, +            if (clusterState.metaData().hasIndex(index) == false) {, +                logger.warn("Not opening job [{}], because [{}] index is missing.", jobId, index);, +                return false;, +            }, +            IndexRoutingTable routingTable = clusterState.getRoutingTable().index(index);, +            if (routingTable == null || routingTable.allPrimaryShardsActive() == false) {, +                logger.warn("Not opening job [{}], because not all primary shards are active for the [{}] index.", jobId, index);, +                return false;, +            }, +        }, +        return true;, +    }, +++ b/plugin/src/test/java/org/elasticsearch/xpack/ml/action/OpenJobActionTests.java, +import org.elasticsearch.cluster.metadata.IndexMetaData;, +import org.elasticsearch.cluster.routing.IndexRoutingTable;, +import org.elasticsearch.cluster.routing.IndexShardRoutingTable;, +import org.elasticsearch.cluster.routing.RecoverySource;, +import org.elasticsearch.cluster.routing.RoutingTable;, +import org.elasticsearch.cluster.routing.ShardRouting;, +import org.elasticsearch.cluster.routing.UnassignedInfo;, +import org.elasticsearch.common.settings.Settings;, +import org.elasticsearch.index.Index;, +import org.elasticsearch.index.shard.ShardId;, +import org.elasticsearch.xpack.ml.MlMetadata;, +import org.elasticsearch.xpack.ml.job.persistence.AnomalyDetectorsIndex;, +import org.elasticsearch.xpack.ml.job.persistence.JobProvider;, +import org.elasticsearch.xpack.ml.notifications.Auditor;, +import org.elasticsearch.xpack.ml.support.BaseMlIntegTestCase;, +import java.util.ArrayList;, +import java.util.List;, +        MetaData.Builder metaData = MetaData.builder();, +        RoutingTable.Builder routingTable = RoutingTable.builder();, +        addJobAndIndices(metaData, routingTable, "job_id1", "job_id2", "job_id3", "job_id4");, +        metaData.putCustom(PersistentTasksInProgress.TYPE, tasks);, +        cs.metaData(metaData);, +        cs.routingTable(routingTable.build());, +        MetaData.Builder metaData = MetaData.builder();, +        RoutingTable.Builder routingTable = RoutingTable.builder();, +        addJobAndIndices(metaData, routingTable, "job_id1", "job_id2");, +        metaData.putCustom(PersistentTasksInProgress.TYPE, tasks);, +        cs.metaData(metaData);, +        cs.routingTable(routingTable.build());, +        MetaData.Builder metaData = MetaData.builder();, +        RoutingTable.Builder routingTable = RoutingTable.builder();, +        addJobAndIndices(metaData, routingTable, "job_id1", "job_id2");, +        metaData.putCustom(PersistentTasksInProgress.TYPE, tasks);, +        cs.metaData(metaData);, +        cs.routingTable(routingTable.build());, +        ClusterState.Builder csBuilder = ClusterState.builder(new ClusterName("_name"));, +        csBuilder.nodes(nodes);]