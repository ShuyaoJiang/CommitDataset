[+++ b/modules/elasticsearch/src/main/java/org/elasticsearch/action/admin/cluster/health/TransportClusterHealthAction.java, +import org.elasticsearch.gateway.GatewayService;, +        for (String index : clusterState.metaData().concreteIndices(request.indices())) {, +            } else if (clusterState.blocks().hasIndexBlock(indexHealth.index(), GatewayService.INDEX_NOT_RECOVERED_BLOCK)) {, +                indexHealth.status = ClusterHealthStatus.RED;, +            } else if (indexHealth.shards().isEmpty()) { // might be since none has been created yet (two phase index creation), +                indexHealth.status = ClusterHealthStatus.RED;, +        } else if (clusterState.blocks().hasGlobalBlock(GatewayService.NOT_RECOVERED_FROM_GATEWAY_BLOCK)) {, +            response.status = ClusterHealthStatus.RED;, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/action/admin/cluster/health/TransportClusterHealthAction.java, +import org.elasticsearch.gateway.GatewayService;, +        for (String index : clusterState.metaData().concreteIndices(request.indices())) {, +            } else if (clusterState.blocks().hasIndexBlock(indexHealth.index(), GatewayService.INDEX_NOT_RECOVERED_BLOCK)) {, +                indexHealth.status = ClusterHealthStatus.RED;, +            } else if (indexHealth.shards().isEmpty()) { // might be since none has been created yet (two phase index creation), +                indexHealth.status = ClusterHealthStatus.RED;, +        } else if (clusterState.blocks().hasGlobalBlock(GatewayService.NOT_RECOVERED_FROM_GATEWAY_BLOCK)) {, +            response.status = ClusterHealthStatus.RED;, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/cluster/metadata/MetaDataCreateIndexService.java, +                    listener.onResponse(new Response(true, clusterState.metaData().index(request.index)));, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/action/admin/cluster/health/TransportClusterHealthAction.java, +import org.elasticsearch.gateway.GatewayService;, +        for (String index : clusterState.metaData().concreteIndices(request.indices())) {, +            } else if (clusterState.blocks().hasIndexBlock(indexHealth.index(), GatewayService.INDEX_NOT_RECOVERED_BLOCK)) {, +                indexHealth.status = ClusterHealthStatus.RED;, +            } else if (indexHealth.shards().isEmpty()) { // might be since none has been created yet (two phase index creation), +                indexHealth.status = ClusterHealthStatus.RED;, +        } else if (clusterState.blocks().hasGlobalBlock(GatewayService.NOT_RECOVERED_FROM_GATEWAY_BLOCK)) {, +            response.status = ClusterHealthStatus.RED;, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/cluster/metadata/MetaDataCreateIndexService.java, +                    listener.onResponse(new Response(true, clusterState.metaData().index(request.index)));, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/gateway/GatewayService.java, +                    // first update the state that its blocked for not recovered, and then let recovery take its place, +                    // that way, we can wait till it is resolved, +                    updateClusterStateBlockedOnNotRecovered();, +                                    if (!currentState.blocks().hasIndexBlock(index, GatewayService.INDEX_NOT_RECOVERED_BLOCK)) {, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/action/admin/cluster/health/TransportClusterHealthAction.java, +import org.elasticsearch.gateway.GatewayService;, +        for (String index : clusterState.metaData().concreteIndices(request.indices())) {, +            } else if (clusterState.blocks().hasIndexBlock(indexHealth.index(), GatewayService.INDEX_NOT_RECOVERED_BLOCK)) {, +                indexHealth.status = ClusterHealthStatus.RED;, +            } else if (indexHealth.shards().isEmpty()) { // might be since none has been created yet (two phase index creation), +                indexHealth.status = ClusterHealthStatus.RED;, +        } else if (clusterState.blocks().hasGlobalBlock(GatewayService.NOT_RECOVERED_FROM_GATEWAY_BLOCK)) {, +            response.status = ClusterHealthStatus.RED;, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/cluster/metadata/MetaDataCreateIndexService.java, +                    listener.onResponse(new Response(true, clusterState.metaData().index(request.index)));, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/gateway/GatewayService.java, +                    // first update the state that its blocked for not recovered, and then let recovery take its place, +                    // that way, we can wait till it is resolved, +                    updateClusterStateBlockedOnNotRecovered();, +                                    if (!currentState.blocks().hasIndexBlock(index, GatewayService.INDEX_NOT_RECOVERED_BLOCK)) {, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/index/gateway/IndexShardGatewayService.java, +                if (indexShard.state() == IndexShardState.CLOSED) {, +                    return;, +                }, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/action/admin/cluster/health/TransportClusterHealthAction.java, +import org.elasticsearch.gateway.GatewayService;, +        for (String index : clusterState.metaData().concreteIndices(request.indices())) {, +            } else if (clusterState.blocks().hasIndexBlock(indexHealth.index(), GatewayService.INDEX_NOT_RECOVERED_BLOCK)) {, +                indexHealth.status = ClusterHealthStatus.RED;, +            } else if (indexHealth.shards().isEmpty()) { // might be since none has been created yet (two phase index creation), +                indexHealth.status = ClusterHealthStatus.RED;, +        } else if (clusterState.blocks().hasGlobalBlock(GatewayService.NOT_RECOVERED_FROM_GATEWAY_BLOCK)) {, +            response.status = ClusterHealthStatus.RED;, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/cluster/metadata/MetaDataCreateIndexService.java, +                    listener.onResponse(new Response(true, clusterState.metaData().index(request.index)));, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/gateway/GatewayService.java, +                    // first update the state that its blocked for not recovered, and then let recovery take its place, +                    // that way, we can wait till it is resolved, +                    updateClusterStateBlockedOnNotRecovered();, +                                    if (!currentState.blocks().hasIndexBlock(index, GatewayService.INDEX_NOT_RECOVERED_BLOCK)) {, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/index/gateway/IndexShardGatewayService.java, +                if (indexShard.state() == IndexShardState.CLOSED) {, +                    return;, +                }, +++ b/modules/test/integration/src/test/java/org/elasticsearch/test/integration/gateway/local/LocalGatewayIndexStateTests.java, +import org.elasticsearch.action.admin.cluster.health.ClusterHealthStatus;, +        logger.info("--> verifying that the state is green");, +        health = client("node1").admin().cluster().prepareHealth().setWaitForNodes("2").execute().actionGet();, +        assertThat(health.timedOut(), equalTo(false));, +        assertThat(health.status(), equalTo(ClusterHealthStatus.GREEN));, +, +        logger.info("--> waiting for two nodes");, +        health = client("node1").admin().cluster().prepareHealth().setWaitForNodes("2").execute().actionGet();, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/action/admin/cluster/health/TransportClusterHealthAction.java, +import org.elasticsearch.gateway.GatewayService;, +        for (String index : clusterState.metaData().concreteIndices(request.indices())) {, +            } else if (clusterState.blocks().hasIndexBlock(indexHealth.index(), GatewayService.INDEX_NOT_RECOVERED_BLOCK)) {, +                indexHealth.status = ClusterHealthStatus.RED;, +            } else if (indexHealth.shards().isEmpty()) { // might be since none has been created yet (two phase index creation), +                indexHealth.status = ClusterHealthStatus.RED;, +        } else if (clusterState.blocks().hasGlobalBlock(GatewayService.NOT_RECOVERED_FROM_GATEWAY_BLOCK)) {, +            response.status = ClusterHealthStatus.RED;, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/cluster/metadata/MetaDataCreateIndexService.java, +                    listener.onResponse(new Response(true, clusterState.metaData().index(request.index)));, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/gateway/GatewayService.java, +                    // first update the state that its blocked for not recovered, and then let recovery take its place, +                    // that way, we can wait till it is resolved, +                    updateClusterStateBlockedOnNotRecovered();]