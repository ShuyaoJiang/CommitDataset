[+++ b/docs/reference/cat/thread_pool.asciidoc, +..., +// TESTRESPONSE[s/\.\.\./(node-0 \\S+ 0 0 0\n)+/], +ccr (default distro only), +     0     0        0, +++ b/docs/reference/cat/thread_pool.asciidoc, +..., +// TESTRESPONSE[s/\.\.\./(node-0 \\S+ 0 0 0\n)+/], +ccr (default distro only), +     0     0        0, +++ b/docs/reference/indices/flush.asciidoc, +                     "max_unsafe_auto_id_timestamp" : "-1",, +                     "min_retained_seq_no": "0", +++ b/docs/reference/cat/thread_pool.asciidoc, +..., +// TESTRESPONSE[s/\.\.\./(node-0 \\S+ 0 0 0\n)+/], +ccr (default distro only), +     0     0        0, +++ b/docs/reference/indices/flush.asciidoc, +                     "max_unsafe_auto_id_timestamp" : "-1",, +                     "min_retained_seq_no": "0", +++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/FunctionRef.java, +        MethodType delegateMethodType = delegateMethod.getMethodType();, +        interfaceMethodType = interfaceMethod.getMethodType().dropParameterTypes(0, 1);, +        interfaceMethodType = interfaceMethod.getMethodType().dropParameterTypes(0, 1);, +++ b/docs/reference/cat/thread_pool.asciidoc, +..., +// TESTRESPONSE[s/\.\.\./(node-0 \\S+ 0 0 0\n)+/], +ccr (default distro only), +     0     0        0, +++ b/docs/reference/indices/flush.asciidoc, +                     "max_unsafe_auto_id_timestamp" : "-1",, +                     "min_retained_seq_no": "0", +++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/FunctionRef.java, +        MethodType delegateMethodType = delegateMethod.getMethodType();, +        interfaceMethodType = interfaceMethod.getMethodType().dropParameterTypes(0, 1);, +        interfaceMethodType = interfaceMethod.getMethodType().dropParameterTypes(0, 1);, +++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/lookup/PainlessLookupBuilder.java, +                                              asmConstructor, javaConstructor.getModifiers(), methodHandle), +                                typeParameters, asmMethod, javaMethod.getModifiers(), methodHandle));, +                                typeParameters, asmMethod, javaMethod.getModifiers(), methodHandle));, +++ b/docs/reference/cat/thread_pool.asciidoc, +..., +// TESTRESPONSE[s/\.\.\./(node-0 \\S+ 0 0 0\n)+/], +ccr (default distro only), +     0     0        0, +++ b/docs/reference/indices/flush.asciidoc, +                     "max_unsafe_auto_id_timestamp" : "-1",, +                     "min_retained_seq_no": "0", +++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/FunctionRef.java, +        MethodType delegateMethodType = delegateMethod.getMethodType();, +        interfaceMethodType = interfaceMethod.getMethodType().dropParameterTypes(0, 1);, +        interfaceMethodType = interfaceMethod.getMethodType().dropParameterTypes(0, 1);, +++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/lookup/PainlessLookupBuilder.java, +                                              asmConstructor, javaConstructor.getModifiers(), methodHandle), +                                typeParameters, asmMethod, javaMethod.getModifiers(), methodHandle));, +                                typeParameters, asmMethod, javaMethod.getModifiers(), methodHandle));, +++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/lookup/PainlessMethod.java, +                          org.objectweb.asm.commons.Method method, int modifiers, MethodHandle handle) {, +    }, +, +    /**, +     * Returns MethodType for this method., +     * <p>, +     * This works even for user-defined Methods (where the MethodHandle is null)., +     */, +    public MethodType getMethodType() {, +        // we have a methodhandle already (e.g. whitelisted class), +        // just return its type, +        if (handle != null) {, +            return handle.type();, +        }, +        // otherwise compute it, +        final Class<?> params[];, +        final Class<?> returnValue;, +        if (augmentation != null) {, +            // static method disguised as virtual/interface method, +            params = new Class<?>[1 + arguments.size()];, +            params[0] = augmentation;, +            for (int i = 0; i < arguments.size(); i++) {, +                params[i + 1] = PainlessLookupUtility.typeToJavaType(arguments.get(i));, +            }, +            returnValue = PainlessLookupUtility.typeToJavaType(rtn);, +        } else if (Modifier.isStatic(modifiers)) {, +            // static method: straightforward copy, +            params = new Class<?>[arguments.size()];, +            for (int i = 0; i < arguments.size(); i++) {, +                params[i] = PainlessLookupUtility.typeToJavaType(arguments.get(i));, +            }, +            returnValue = PainlessLookupUtility.typeToJavaType(rtn);, +        } else if ("<init>".equals(name)) {, +            // constructor: returns the owner class, +            params = new Class<?>[arguments.size()];, +            for (int i = 0; i < arguments.size(); i++) {, +                params[i] = PainlessLookupUtility.typeToJavaType(arguments.get(i));, +            }, +            returnValue = target;, +        } else {, +            // virtual/interface method: add receiver class, +            params = new Class<?>[1 + arguments.size()];]