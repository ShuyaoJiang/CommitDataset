[+++ b/core/src/main/java/org/elasticsearch/index/mapper/DocumentParser.java, +import org.elasticsearch.common.Strings;, +    private static String[] splitAndValidatePath(String fullFieldPath) {, +        String[] parts = fullFieldPath.split("\\.");, +        for (String part : parts) {, +            if (Strings.hasText(part) == false) {, +                throw new IllegalArgumentException(, +                    "object field starting or ending with a [.] makes object resolution ambiguous: [" + fullFieldPath + "]");, +            }, +        }, +        return parts;, +    }, +, +        parentMappers.add(createUpdate(mapping.root(), splitAndValidatePath(firstUpdate.name()), 0, firstUpdate));, +            String[] nameParts = splitAndValidatePath(newMapper.name());, +            final String[] paths = splitAndValidatePath(currentFieldName);, +            final String[] paths = splitAndValidatePath(arrayFieldName);, +            final String[] paths = splitAndValidatePath(currentFieldName);, +            final String[] paths = splitAndValidatePath(field);, +        String[] subfields = splitAndValidatePath(fieldName);, +++ b/core/src/main/java/org/elasticsearch/index/mapper/DocumentParser.java, +import org.elasticsearch.common.Strings;, +    private static String[] splitAndValidatePath(String fullFieldPath) {, +        String[] parts = fullFieldPath.split("\\.");, +        for (String part : parts) {, +            if (Strings.hasText(part) == false) {, +                throw new IllegalArgumentException(, +                    "object field starting or ending with a [.] makes object resolution ambiguous: [" + fullFieldPath + "]");, +            }, +        }, +        return parts;, +    }, +, +        parentMappers.add(createUpdate(mapping.root(), splitAndValidatePath(firstUpdate.name()), 0, firstUpdate));, +            String[] nameParts = splitAndValidatePath(newMapper.name());, +            final String[] paths = splitAndValidatePath(currentFieldName);, +            final String[] paths = splitAndValidatePath(arrayFieldName);, +            final String[] paths = splitAndValidatePath(currentFieldName);, +            final String[] paths = splitAndValidatePath(field);, +        String[] subfields = splitAndValidatePath(fieldName);, +++ b/core/src/test/java/org/elasticsearch/index/mapper/DocumentParserTests.java, +import static org.hamcrest.Matchers.containsString;, +, +    public void testDynamicFieldsStartingAndEndingWithDot() throws Exception {, +        BytesReference bytes = XContentFactory.jsonBuilder().startObject().startArray("top."), +                .startObject().startArray("foo."), +                .startObject(), +                .field("thing", "bah"), +                .endObject().endArray(), +                .endObject().endArray(), +                .endObject().bytes();, +, +        client().prepareIndex("idx", "type").setSource(bytes).get();, +, +        bytes = XContentFactory.jsonBuilder().startObject().startArray("top."), +                .startObject().startArray("foo."), +                .startObject(), +                .startObject("bar."), +                .startObject("aoeu"), +                .field("a", 1).field("b", 2), +                .endObject(), +                .endObject(), +                .endObject(), +                .endArray().endObject().endArray(), +                .endObject().bytes();, +, +        try {, +            client().prepareIndex("idx", "type").setSource(bytes).get();, +            fail("should have failed to dynamically introduce a double-dot field");, +        } catch (IllegalArgumentException e) {, +            assertThat(e.getMessage(),, +                    containsString("object field starting or ending with a [.] makes object resolution ambiguous: [top..foo..bar]"));, +        }, +    }, +++ b/core/src/main/java/org/elasticsearch/index/mapper/DocumentParser.java, +import org.elasticsearch.common.Strings;, +    private static String[] splitAndValidatePath(String fullFieldPath) {, +        String[] parts = fullFieldPath.split("\\.");, +        for (String part : parts) {, +            if (Strings.hasText(part) == false) {, +                throw new IllegalArgumentException(, +                    "object field starting or ending with a [.] makes object resolution ambiguous: [" + fullFieldPath + "]");, +            }, +        }, +        return parts;, +    }, +, +        parentMappers.add(createUpdate(mapping.root(), splitAndValidatePath(firstUpdate.name()), 0, firstUpdate));, +            String[] nameParts = splitAndValidatePath(newMapper.name());, +            final String[] paths = splitAndValidatePath(currentFieldName);, +            final String[] paths = splitAndValidatePath(arrayFieldName);, +            final String[] paths = splitAndValidatePath(currentFieldName);, +            final String[] paths = splitAndValidatePath(field);, +        String[] subfields = splitAndValidatePath(fieldName);, +++ b/core/src/test/java/org/elasticsearch/index/mapper/DocumentParserTests.java, +import static org.hamcrest.Matchers.containsString;, +, +    public void testDynamicFieldsStartingAndEndingWithDot() throws Exception {, +        BytesReference bytes = XContentFactory.jsonBuilder().startObject().startArray("top."), +                .startObject().startArray("foo.")]