[+++ b/modules/elasticsearch/src/main/java/org/elasticsearch/action/admin/indices/delete/TransportDeleteIndexAction.java, +import org.elasticsearch.action.admin.indices.mapping.delete.DeleteMappingRequest;, +import org.elasticsearch.action.admin.indices.mapping.delete.DeleteMappingResponse;, +import org.elasticsearch.action.admin.indices.mapping.delete.TransportDeleteMappingAction;, +import org.elasticsearch.cluster.metadata.IndexMetaData;, +import org.elasticsearch.index.percolator.PercolatorService;, +    private final TransportDeleteMappingAction deleteMappingAction;, +, +                                              ThreadPool threadPool, MetaDataDeleteIndexService deleteIndexService, TransportDeleteMappingAction deleteMappingAction) {, +        this.deleteMappingAction = deleteMappingAction;, +    @Override protected DeleteIndexResponse masterOperation(DeleteIndexRequest request, final ClusterState state) throws ElasticSearchException {, +        for (final String index : request.indices()) {, +                    // YACK, but here we go: If this index is also percolated, make sure to delete all percolated queries from the _percolator index, +                    IndexMetaData percolatorMetaData = state.metaData().index(PercolatorService.INDEX_NAME);, +                    if (percolatorMetaData != null && percolatorMetaData.mappings().containsKey(index)) {, +                        deleteMappingAction.execute(new DeleteMappingRequest(PercolatorService.INDEX_NAME).type(index), new ActionListener<DeleteMappingResponse>() {, +                            @Override public void onResponse(DeleteMappingResponse deleteMappingResponse) {, +                            @Override public void onFailure(Throwable e) {, +                                latch.countDown();, +                            }, +                        });, +                    }, +                }, +, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/action/admin/indices/delete/TransportDeleteIndexAction.java, +import org.elasticsearch.action.admin.indices.mapping.delete.DeleteMappingRequest;, +import org.elasticsearch.action.admin.indices.mapping.delete.DeleteMappingResponse;, +import org.elasticsearch.action.admin.indices.mapping.delete.TransportDeleteMappingAction;, +import org.elasticsearch.cluster.metadata.IndexMetaData;, +import org.elasticsearch.index.percolator.PercolatorService;, +    private final TransportDeleteMappingAction deleteMappingAction;, +, +                                              ThreadPool threadPool, MetaDataDeleteIndexService deleteIndexService, TransportDeleteMappingAction deleteMappingAction) {, +        this.deleteMappingAction = deleteMappingAction;, +    @Override protected DeleteIndexResponse masterOperation(DeleteIndexRequest request, final ClusterState state) throws ElasticSearchException {, +        for (final String index : request.indices()) {, +                    // YACK, but here we go: If this index is also percolated, make sure to delete all percolated queries from the _percolator index, +                    IndexMetaData percolatorMetaData = state.metaData().index(PercolatorService.INDEX_NAME);, +                    if (percolatorMetaData != null && percolatorMetaData.mappings().containsKey(index)) {, +                        deleteMappingAction.execute(new DeleteMappingRequest(PercolatorService.INDEX_NAME).type(index), new ActionListener<DeleteMappingResponse>() {, +                            @Override public void onResponse(DeleteMappingResponse deleteMappingResponse) {, +                            @Override public void onFailure(Throwable e) {, +                                latch.countDown();, +                            }, +                        });, +                    }, +                }, +, +++ b/modules/test/integration/src/test/java/org/elasticsearch/test/integration/percolator/SimplePercolatorTests.java, +, +        logger.info("--> delete the index");, +, +        try {, +            client.admin().indices().prepareDelete("test").execute().actionGet();, +        } catch (Exception e) {, +            // ignore, +        }, +, +        logger.info("--> make sure percoalted queries for it have been deleted as well");, +        assertThat(client.prepareCount("_percolator").setQuery(matchAllQuery()).execute().actionGet().count(), equalTo(0l));]