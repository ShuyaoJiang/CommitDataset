[+++ b/src/main/java/org/elasticsearch/action/admin/cluster/health/TransportClusterHealthAction.java, +import java.util.concurrent.atomic.AtomicReference;, +            final AtomicReference<ElasticsearchException> failure = new AtomicReference<>();, +                    failure.set(new ElasticsearchException("Error while waiting for events", t));, +                    latch.countDown();, +                }, +, +                @Override, +                public boolean runOnlyOnMaster() {, +                    return !request.local();, +            if (failure.get() != null) {, +                throw failure.get();, +            }, +++ b/src/main/java/org/elasticsearch/action/admin/cluster/health/TransportClusterHealthAction.java, +import java.util.concurrent.atomic.AtomicReference;, +            final AtomicReference<ElasticsearchException> failure = new AtomicReference<>();, +                    failure.set(new ElasticsearchException("Error while waiting for events", t));, +                    latch.countDown();, +                }, +, +                @Override, +                public boolean runOnlyOnMaster() {, +                    return !request.local();, +            if (failure.get() != null) {, +                throw failure.get();, +            }, +++ b/src/test/java/org/elasticsearch/cluster/ClusterHealthTests.java, +import org.elasticsearch.common.Priority;, +, +    @Test, +    public void simpleLocalHealthTest() {, +        createIndex("test");, +        ensureGreen(); // master should thing it's green now., +, +        for (String node : internalCluster().getNodeNames()) {, +            // a very high time out, which should never fire due to the local flag, +            ClusterHealthResponse health = client(node).admin().cluster().prepareHealth().setLocal(true).setWaitForEvents(Priority.LANGUID).setTimeout("30s").get("10s");, +            assertThat(health.getStatus(), equalTo(ClusterHealthStatus.GREEN));, +            assertThat(health.isTimedOut(), equalTo(false));, +        }, +    }, +]