[+++ b/core/src/main/java/org/elasticsearch/cluster/SnapshotsInProgress.java, +import org.elasticsearch.repositories.IndexId;, +        private final List<IndexId> indices;, +        public Entry(Snapshot snapshot, boolean includeGlobalState, boolean partial, State state, List<IndexId> indices,, +                     long startTime, ImmutableOpenMap<ShardId, ShardSnapshotStatus> shards) {, +        public List<IndexId> indices() {, +            List<IndexId> indexBuilder = new ArrayList<>();, +                indexBuilder.add(new IndexId(in.readString(), in.readString()));, +            for (IndexId index : entry.indices()) {, +                index.writeTo(out);, +            for (IndexId index : entry.indices()) {, +                index.toXContent(builder, params);, +++ b/core/src/main/java/org/elasticsearch/cluster/SnapshotsInProgress.java, +import org.elasticsearch.repositories.IndexId;, +        private final List<IndexId> indices;, +        public Entry(Snapshot snapshot, boolean includeGlobalState, boolean partial, State state, List<IndexId> indices,, +                     long startTime, ImmutableOpenMap<ShardId, ShardSnapshotStatus> shards) {, +        public List<IndexId> indices() {, +            List<IndexId> indexBuilder = new ArrayList<>();, +                indexBuilder.add(new IndexId(in.readString(), in.readString()));, +            for (IndexId index : entry.indices()) {, +                index.writeTo(out);, +            for (IndexId index : entry.indices()) {, +                index.toXContent(builder, params);, +++ b/core/src/main/java/org/elasticsearch/common/blobstore/BlobContainer.java, +import java.nio.file.NoSuchFileException;, +     * @throws  NoSuchFileException if the blob does not exist, +     * @throws  IOException if the blob can not be read., +     * @throws  NoSuchFileException if the blob does not exist, +     * @throws  IOException if the blob exists but could not be deleted., +++ b/core/src/main/java/org/elasticsearch/cluster/SnapshotsInProgress.java, +import org.elasticsearch.repositories.IndexId;, +        private final List<IndexId> indices;, +        public Entry(Snapshot snapshot, boolean includeGlobalState, boolean partial, State state, List<IndexId> indices,, +                     long startTime, ImmutableOpenMap<ShardId, ShardSnapshotStatus> shards) {, +        public List<IndexId> indices() {, +            List<IndexId> indexBuilder = new ArrayList<>();, +                indexBuilder.add(new IndexId(in.readString(), in.readString()));, +            for (IndexId index : entry.indices()) {, +                index.writeTo(out);, +            for (IndexId index : entry.indices()) {, +                index.toXContent(builder, params);, +++ b/core/src/main/java/org/elasticsearch/common/blobstore/BlobContainer.java, +import java.nio.file.NoSuchFileException;, +     * @throws  NoSuchFileException if the blob does not exist, +     * @throws  IOException if the blob can not be read., +     * @throws  NoSuchFileException if the blob does not exist, +     * @throws  IOException if the blob exists but could not be deleted., +++ b/core/src/main/java/org/elasticsearch/common/blobstore/fs/FsBlobContainer.java, +import java.io.FileNotFoundException;, +import java.nio.file.NoSuchFileException;, +import java.nio.file.StandardOpenOption;, +        Files.delete(blobPath);, +        final Path resolvedPath = path.resolve(name);, +        try {, +            return new BufferedInputStream(Files.newInputStream(resolvedPath), blobStore.bufferSizeInBytes());, +        } catch (FileNotFoundException fnfe) {, +            throw new NoSuchFileException("[" + name + "] blob not found");, +        }, +        try (OutputStream outputStream = Files.newOutputStream(file, StandardOpenOption.CREATE_NEW)) {, +++ b/core/src/main/java/org/elasticsearch/cluster/SnapshotsInProgress.java, +import org.elasticsearch.repositories.IndexId;, +        private final List<IndexId> indices;, +        public Entry(Snapshot snapshot, boolean includeGlobalState, boolean partial, State state, List<IndexId> indices,, +                     long startTime, ImmutableOpenMap<ShardId, ShardSnapshotStatus> shards) {, +        public List<IndexId> indices() {, +            List<IndexId> indexBuilder = new ArrayList<>();, +                indexBuilder.add(new IndexId(in.readString(), in.readString()));, +            for (IndexId index : entry.indices()) {, +                index.writeTo(out);, +            for (IndexId index : entry.indices()) {, +                index.toXContent(builder, params);, +++ b/core/src/main/java/org/elasticsearch/common/blobstore/BlobContainer.java, +import java.nio.file.NoSuchFileException;, +     * @throws  NoSuchFileException if the blob does not exist, +     * @throws  IOException if the blob can not be read., +     * @throws  NoSuchFileException if the blob does not exist, +     * @throws  IOException if the blob exists but could not be deleted., +++ b/core/src/main/java/org/elasticsearch/common/blobstore/fs/FsBlobContainer.java, +import java.io.FileNotFoundException;, +import java.nio.file.NoSuchFileException;, +import java.nio.file.StandardOpenOption;, +        Files.delete(blobPath);, +        final Path resolvedPath = path.resolve(name);, +        try {, +            return new BufferedInputStream(Files.newInputStream(resolvedPath), blobStore.bufferSizeInBytes());, +        } catch (FileNotFoundException fnfe) {, +            throw new NoSuchFileException("[" + name + "] blob not found");, +        }, +        try (OutputStream outputStream = Files.newOutputStream(file, StandardOpenOption.CREATE_NEW)) {, +++ b/core/src/main/java/org/elasticsearch/common/blobstore/support/AbstractBlobContainer.java, +++ b/core/src/main/java/org/elasticsearch/cluster/SnapshotsInProgress.java, +import org.elasticsearch.repositories.IndexId;, +        private final List<IndexId> indices;, +        public Entry(Snapshot snapshot, boolean includeGlobalState, boolean partial, State state, List<IndexId> indices,, +                     long startTime, ImmutableOpenMap<ShardId, ShardSnapshotStatus> shards) {, +        public List<IndexId> indices() {, +            List<IndexId> indexBuilder = new ArrayList<>();, +                indexBuilder.add(new IndexId(in.readString(), in.readString()));, +            for (IndexId index : entry.indices()) {]