[+++ b/src/main/java/org/elasticsearch/cluster/routing/IndexShardRoutingTable.java, +    public ShardIterator primaryFirstActiveShardsIt() {, +        ArrayList<ShardRouting> ordered = new ArrayList<ShardRouting>(activeShards.size());, +        // fill it in a randomized fashion, +        int index = Math.abs(counter.getAndIncrement());, +        for (int i = 0; i < activeShards.size(); i++) {, +            int loc = (index + i) % activeShards.size();, +            ShardRouting shardRouting = activeShards.get(loc);, +            ordered.add(shardRouting);, +            if (shardRouting.primary()) {, +                // switch, its the matching node id, +                ordered.set(i, ordered.get(0));, +                ordered.set(0, shardRouting);, +            }, +        }, +        return new PlainShardIterator(shardId, ordered);, +    }, +, +++ b/src/main/java/org/elasticsearch/cluster/routing/IndexShardRoutingTable.java, +    public ShardIterator primaryFirstActiveShardsIt() {, +        ArrayList<ShardRouting> ordered = new ArrayList<ShardRouting>(activeShards.size());, +        // fill it in a randomized fashion, +        int index = Math.abs(counter.getAndIncrement());, +        for (int i = 0; i < activeShards.size(); i++) {, +            int loc = (index + i) % activeShards.size();, +            ShardRouting shardRouting = activeShards.get(loc);, +            ordered.add(shardRouting);, +            if (shardRouting.primary()) {, +                // switch, its the matching node id, +                ordered.set(i, ordered.get(0));, +                ordered.set(0, shardRouting);, +            }, +        }, +        return new PlainShardIterator(shardId, ordered);, +    }, +, +++ b/src/main/java/org/elasticsearch/cluster/routing/operation/plain/PlainOperationRouting.java, +            if ("_primary_first".equals(preference) || "_primaryFirst".equals(preference)) {, +                return indexShard.primaryFirstActiveShardsIt();, +            }]