[+++ b/src/main/java/jsr166e/CompletableFuture.java, +     * @param <U> the function's return type, +     * @param <U> the function's return type, +     * @param <U> the type of the value, +            if (ex != null), +++ b/src/main/java/jsr166e/CompletableFuture.java, +     * @param <U> the function's return type, +     * @param <U> the function's return type, +     * @param <U> the type of the value, +            if (ex != null), +++ b/src/main/java/jsr166e/ConcurrentHashMapV8.java, +import java.util.AbstractMap;, +public class ConcurrentHashMapV8<K,V> extends AbstractMap<K,V>, +, +     * initiating thread allocates and sets up the replacement array., +     * However, rather than stalling, these other threads may proceed, +     * with insertions etc.  The use of TreeBins shields us from the, +     * worst case effects of overfilling while resizes are in, +     * from the table to the next table. However, threads claim small, +     * blocks of indices to transfer (via field transferIndex) before, +     * doing so, reducing contention.  A generation stamp in field, +     * sizeCtl ensures that resizings do not overlap. Because we are, +     * traversal.  This is arranged in part by proceeding from the, +     * last bin (table.length - 1) up towards the first.  Upon seeing, +     * a forwarding node, traversals (see class Traverser) arrange to, +     * move to the new table without revisiting nodes.  To ensure that, +     * no intervening nodes are skipped even when moved out of order,, +     * a stack (see class TableStack) is created on first encounter of, +     * a forwarding node during a traversal, to maintain its place if, +     * later processing the current table. The need for these, +     * save/restore mechanics is relatively rare, but when one, +     * forwarding node is encountered, typically many more will be., +     * So Traversers use a simple caching scheme to avoid creating so, +     * many new TableStack nodes. (Thanks to Peter Levart for, +     * suggesting use of a stack here.), +     * elements that are Comparable but not necessarily Comparable for, +     * the same T, so we cannot invoke compareTo among them. To handle, +     * this, the tree is ordered primarily by hash value, then by, +     * Comparable.compareTo order if applicable.  On lookup at a node,, +     * if elements are not comparable or compare as 0 then both left, +     * and right children may need to be searched in the case of tied, +     * hash values. (This corresponds to the full list search that, +     * would be necessary if all elements were non-Comparable and had, +     * tied hashes.) On insertion, to keep a total ordering (or as, +     * close as is required here) across rebalancings, we compare, +     * classes and identityHashCodes as tie-breakers. The red-black, +     * balancing code is updated from pre-jdk-collections, +     * Also, solely for compatibility with previous versions of this, +     * class, it extends AbstractMap, even though all of its methods, +     * are overridden, so it is just useless baggage., +     *, +    /**, +     * The number of bits used for generation stamp in sizeCtl., +     * Must be at least 6 for 32bit arrays., +     */, +    private static int RESIZE_STAMP_BITS = 16;, +, +    /**, +     * The maximum number of threads that can help resize., +     * Must fit in 32 - RESIZE_STAMP_BITS bits., +     */, +    private static final int MAX_RESIZERS = (1 << (32 - RESIZE_STAMP_BITS)) - 1;, +, +    /**, +     * The bit shift for recording size stamp in sizeCtl., +     */, +    private static final int RESIZE_STAMP_SHIFT = 32 - RESIZE_STAMP_BITS;, +, +     * and so in principle require only release ordering, not, +     * @throws java.io.IOException if an I/O error occurs, +     * @throws ClassNotFoundException if the class of a serialized object, +     *         could not be found, +     * @throws java.io.IOException if an I/O error occurs, +            @SuppressWarnings("unchecked"), +                Node<K,V>[] tab = (Node<K,V>[])new Node<?,?>[n];, +     * @return the new set, +     * Returns the stamp bits for resizing a table of size n., +     * Must be negative when shifted left by RESIZE_STAMP_SHIFT., +     */, +    static final int resizeStamp(int n) {, +        return Integer.numberOfLeadingZeros(n) | (1 << (RESIZE_STAMP_BITS - 1));, +    }, +, +    /**, +                        @SuppressWarnings("unchecked"), +                        Node<K,V>[] nt = (Node<K,V>[])new Node<?,?>[n];, +            Node<K,V>[] tab, nt; int n, sc;, +                   (n = tab.length) < MAXIMUM_CAPACITY) {, +                int rs = resizeStamp(n);, +                    if ((sc >>> RESIZE_STAMP_SHIFT) != rs || sc == rs + 1 ||, +                        sc == rs + MAX_RESIZERS || (nt = nextTable) == null ||, +                        transferIndex <= 0), +                    if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1)), +                else if (U.compareAndSwapInt(this, SIZECTL, sc,, +                                             (rs << RESIZE_STAMP_SHIFT) + 2)), +        if (tab != null && (f instanceof ForwardingNode) &&, +            int rs = resizeStamp(tab.length);, +            while (nextTab == nextTable && table == tab &&, +                   (sc = sizeCtl) < 0) {, +                if ((sc >>> RESIZE_STAMP_SHIFT) != rs || sc == rs + 1 ||]