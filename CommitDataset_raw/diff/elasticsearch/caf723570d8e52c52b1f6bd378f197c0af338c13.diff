[+++ b/src/main/java/org/elasticsearch/search/aggregations/bucket/terms/support/IncludeExclude.java, +import org.elasticsearch.search.aggregations.support.ValuesSource.Bytes.WithOrdinals;, +    public abstract static class StringFilter {, +        public abstract boolean accept(BytesRef value);, +    }, +, +    static class AutomatonBackedStringFilter extends StringFilter {, +        private AutomatonBackedStringFilter(Automaton automaton) {, +        @Override, +    static class TermListBackedStringFilter extends StringFilter {, +, +        private final Set<BytesRef> valids;, +        private final Set<BytesRef> invalids;, +, +        public TermListBackedStringFilter(Set<BytesRef> includeValues, Set<BytesRef> excludeValues) {, +            this.valids = includeValues;, +            this.invalids = excludeValues;, +        }, +, +        /**, +         * Returns whether the given value is accepted based on the, +         * {@code include} & {@code exclude} sets., +         */, +        @Override, +        public boolean accept(BytesRef value) {, +            return ((valids == null) || (valids.contains(value))) && ((invalids == null) || (!invalids.contains(value)));, +        }, +    }, +, +    public static abstract class OrdinalsFilter {, +        public abstract LongBitSet acceptedGlobalOrdinals(RandomAccessOrds globalOrdinals, ValuesSource.Bytes.WithOrdinals valueSource) throws IOException;, +        , +    }, +, +    static class AutomatonBackedOrdinalsFilter extends OrdinalsFilter {, +        private AutomatonBackedOrdinalsFilter(Automaton automaton) {, +         * , +        @Override, +    static class TermListBackedOrdinalsFilter extends OrdinalsFilter {, +, +        private final SortedSet<BytesRef> includeValues;, +        private final SortedSet<BytesRef> excludeValues;, +, +        public TermListBackedOrdinalsFilter(SortedSet<BytesRef> includeValues, SortedSet<BytesRef> excludeValues) {, +            this.includeValues = includeValues;, +            this.excludeValues = excludeValues;, +        }, +, +        @Override, +        public LongBitSet acceptedGlobalOrdinals(RandomAccessOrds globalOrdinals, WithOrdinals valueSource) throws IOException {, +            LongBitSet acceptedGlobalOrdinals = new LongBitSet(globalOrdinals.getValueCount());, +            if(includeValues!=null){, +                for (BytesRef term : includeValues) {, +                    long ord = globalOrdinals.lookupTerm(term);, +                    if (ord >= 0) {, +                        acceptedGlobalOrdinals.set(ord);, +                    }, +                }                , +            } else {, +                // default to all terms being acceptable, +                acceptedGlobalOrdinals.set(0, acceptedGlobalOrdinals.length());, +            }, +            if (excludeValues != null) {, +                for (BytesRef term : excludeValues) {, +                    long ord = globalOrdinals.lookupTerm(term);, +                    if (ord >= 0) {, +                        acceptedGlobalOrdinals.clear(ord);, +                    }, +                }, +            }, +            return acceptedGlobalOrdinals;, +        }, +, +    }, +, +        if (isRegexBased()) {, +            return new AutomatonBackedStringFilter(toAutomaton());, +        }, +        return new TermListBackedStringFilter(includeValues, excludeValues);, +, +        if (isRegexBased()) {, +            return new AutomatonBackedOrdinalsFilter(toAutomaton());, +        }, +        return new TermListBackedOrdinalsFilter(includeValues, excludeValues);]