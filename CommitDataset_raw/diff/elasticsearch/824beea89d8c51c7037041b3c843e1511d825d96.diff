[+++ b/core/src/main/java/org/elasticsearch/action/bulk/TransportShardBulkAction.java, +import java.io.IOException;, +    public static Engine.IndexResult executeIndexRequestOnReplica(IndexRequest request, IndexShard replica) throws IOException {, +    public static Engine.DeleteResult executeDeleteRequestOnPrimary(DeleteRequest request, IndexShard primary) throws IOException {, +    public static Engine.DeleteResult executeDeleteRequestOnReplica(DeleteRequest request, IndexShard replica) throws IOException {, +++ b/core/src/main/java/org/elasticsearch/action/bulk/TransportShardBulkAction.java, +import java.io.IOException;, +    public static Engine.IndexResult executeIndexRequestOnReplica(IndexRequest request, IndexShard replica) throws IOException {, +    public static Engine.DeleteResult executeDeleteRequestOnPrimary(DeleteRequest request, IndexShard primary) throws IOException {, +    public static Engine.DeleteResult executeDeleteRequestOnReplica(DeleteRequest request, IndexShard replica) throws IOException {, +++ b/core/src/main/java/org/elasticsearch/index/engine/Engine.java, +    public abstract IndexResult index(final Index index) throws IOException;, +    public abstract DeleteResult delete(final Delete delete) throws IOException;, +++ b/core/src/main/java/org/elasticsearch/action/bulk/TransportShardBulkAction.java, +import java.io.IOException;, +    public static Engine.IndexResult executeIndexRequestOnReplica(IndexRequest request, IndexShard replica) throws IOException {, +    public static Engine.DeleteResult executeDeleteRequestOnPrimary(DeleteRequest request, IndexShard primary) throws IOException {, +    public static Engine.DeleteResult executeDeleteRequestOnReplica(DeleteRequest request, IndexShard replica) throws IOException {, +++ b/core/src/main/java/org/elasticsearch/index/engine/Engine.java, +    public abstract IndexResult index(final Index index) throws IOException;, +    public abstract DeleteResult delete(final Delete delete) throws IOException;, +++ b/core/src/main/java/org/elasticsearch/index/engine/InternalEngine.java, +     * Checks for version conflicts. If a non-critical version conflict exists <code>true</code> is returned. In the case of a critical, +     * version conflict (if operation origin is primary) a {@link VersionConflictEngineException} is thrown., +     * @return <code>true</code> iff a non-critical version conflict (origin recovery or replica) is found otherwise <code>false</code>, +     * @throws VersionConflictEngineException if a critical version conflict was found where the operation origin is primary, +     * @throws IllegalArgumentException if an unsupported version type is used., +    private boolean checkVersionConflict(final Operation op, final long currentVersion, final long expectedVersion, final boolean deleted) {, +                throw new VersionConflictEngineException(, +, +                /* Version conflicts during recovery and on replicas are normal due to asynchronous execution; as such, we should return a, +                 * successful result.*/, +                return true;, +            return false;, +    public IndexResult index(Index index) throws IOException {, +        } catch (RuntimeException | IOException e) {, +            try {, +                maybeFailEngine("index", e);, +            } catch (Exception inner) {, +                e.addSuppressed(inner);, +            }, +            throw e;, +        // TODO we gotta split this method up it's too big!, +            Optional<IndexResult> resultOnVersionConflict;, +            try {, +                final boolean isVersionConflict = checkVersionConflict(index, currentVersion, expectedVersion, deleted);, +                resultOnVersionConflict = isVersionConflict ? Optional.of(new IndexResult(currentVersion, index.seqNo(), false)), +                    : Optional.empty();, +            } catch (IllegalArgumentException | VersionConflictEngineException ex) {, +                resultOnVersionConflict = Optional.of(new IndexResult(ex, currentVersion, index.seqNo()));, +            }, +                final long updatedVersion = index.versionType().updateVersion(currentVersion, expectedVersion);, +                IndexResult innerIndexResult;, +                try {, +                    innerIndexResult = new IndexResult(updatedVersion, seqNo, deleted);, +                } catch (Exception ex) {, +                    if (indexWriter.getTragicException() == null) {, +                        /* There is no tragic event recorded so this must be a document failure., +                         *, +                         * The handling inside IW doesn't guarantee that an tragic / aborting exception, +                         * will be used as THE tragicEventException since if there are multiple exceptions causing an abort in IW, +                         * only one wins. Yet, only the one that wins will also close the IW and in turn fail the engine such that, +                         * we can potentially handle the exception before the engine is failed., +                         * Bottom line is that we can only rely on the fact that if it's a document failure then, +                         * `indexWriter.getTragicException()` will be null otherwise we have to rethrow and treat it as fatal or rather, +                         * non-document failure, +                         */, +                        innerIndexResult = new IndexResult(ex, currentVersion, index.seqNo());, +                    } else {, +                        throw ex;, +                    }, +                }, +                assert innerIndexResult != null;, +                indexResult = innerIndexResult;, +    public DeleteResult delete(Delete delete) throws IOException {, +        } catch (RuntimeException | IOException e) {, +            try {, +                maybeFailEngine("index", e);, +            } catch (Exception inner) {, +                e.addSuppressed(inner);, +            }, +            throw e;, +            Optional<DeleteResult> resultOnVersionConflict;, +            try {, +                final boolean isVersionConflict = checkVersionConflict(delete, currentVersion, expectedVersion, deleted);, +                resultOnVersionConflict = isVersionConflict ? Optional.of(new DeleteResult(expectedVersion, delete.seqNo(), true)), +                    : Optional.empty();, +            } catch (IllegalArgumentException | VersionConflictEngineException ex) {, +                resultOnVersionConflict = Optional.of(new DeleteResult(ex, expectedVersion, delete.seqNo()));, +            }, +        assert uid != null : "uid must not be null";, +            // any exception that comes from this is a either an ACE or a fatal exception there can't be any document failures coming, +            // from this., +++ b/core/src/main/java/org/elasticsearch/action/bulk/TransportShardBulkAction.java, +import java.io.IOException;, +    public static Engine.IndexResult executeIndexRequestOnReplica(IndexRequest request, IndexShard replica) throws IOException {, +    public static Engine.DeleteResult executeDeleteRequestOnPrimary(DeleteRequest request, IndexShard primary) throws IOException {, +    public static Engine.DeleteResult executeDeleteRequestOnReplica(DeleteRequest request, IndexShard replica) throws IOException {, +++ b/core/src/main/java/org/elasticsearch/index/engine/Engine.java, +    public abstract IndexResult index(final Index index) throws IOException;]