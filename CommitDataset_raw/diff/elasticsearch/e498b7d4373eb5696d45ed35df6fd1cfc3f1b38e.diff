[+++ b/server/src/main/java/org/elasticsearch/common/time/EpochMillisDateFormatter.java, +import java.math.BigDecimal;, +import java.util.regex.Pattern;, +    private static final Pattern SPLIT_BY_DOT_PATTERN = Pattern.compile("\\.");, +    static DateFormatter INSTANCE = new EpochMillisDateFormatter();, +            if (input.contains(".")) {, +                String[] inputs = SPLIT_BY_DOT_PATTERN.split(input, 2);, +                Long milliSeconds = Long.valueOf(inputs[0]);, +                if (inputs[1].length() == 0) {, +                    // this is BWC compatible to joda time, nothing after the dot is allowed, +                    return Instant.ofEpochMilli(milliSeconds).atZone(ZoneOffset.UTC);, +                // scientific notation it is!, +                if (inputs[1].contains("e")) {, +                    return Instant.ofEpochMilli(Double.valueOf(input).longValue()).atZone(ZoneOffset.UTC);, +                if (inputs[1].length() > 6) {, +                    throw new DateTimeParseException("too much granularity after dot [" + input + "]", input, 0);, +                }, +                Long nanos = new BigDecimal(inputs[1]).movePointRight(6 - inputs[1].length()).longValueExact();, +                if (milliSeconds < 0) {, +                    nanos = nanos * -1;, +                }, +                return Instant.ofEpochMilli(milliSeconds).plusNanos(nanos).atZone(ZoneOffset.UTC);, +            } else {, +                return Instant.ofEpochMilli(Long.valueOf(input)).atZone(ZoneOffset.UTC);, +            }, +        } catch (NumberFormatException e) {, +            throw new DateTimeParseException("invalid number [" + input + "]", input, 0, e);, +        }, +    }, +++ b/server/src/main/java/org/elasticsearch/common/time/EpochMillisDateFormatter.java, +import java.math.BigDecimal;, +import java.util.regex.Pattern;, +    private static final Pattern SPLIT_BY_DOT_PATTERN = Pattern.compile("\\.");, +    static DateFormatter INSTANCE = new EpochMillisDateFormatter();, +            if (input.contains(".")) {, +                String[] inputs = SPLIT_BY_DOT_PATTERN.split(input, 2);, +                Long milliSeconds = Long.valueOf(inputs[0]);, +                if (inputs[1].length() == 0) {, +                    // this is BWC compatible to joda time, nothing after the dot is allowed, +                    return Instant.ofEpochMilli(milliSeconds).atZone(ZoneOffset.UTC);, +                // scientific notation it is!, +                if (inputs[1].contains("e")) {, +                    return Instant.ofEpochMilli(Double.valueOf(input).longValue()).atZone(ZoneOffset.UTC);, +                if (inputs[1].length() > 6) {, +                    throw new DateTimeParseException("too much granularity after dot [" + input + "]", input, 0);, +                }, +                Long nanos = new BigDecimal(inputs[1]).movePointRight(6 - inputs[1].length()).longValueExact();, +                if (milliSeconds < 0) {, +                    nanos = nanos * -1;, +                }, +                return Instant.ofEpochMilli(milliSeconds).plusNanos(nanos).atZone(ZoneOffset.UTC);, +            } else {, +                return Instant.ofEpochMilli(Long.valueOf(input)).atZone(ZoneOffset.UTC);, +            }, +        } catch (NumberFormatException e) {, +            throw new DateTimeParseException("invalid number [" + input + "]", input, 0, e);, +        }, +    }, +++ b/server/src/main/java/org/elasticsearch/common/time/EpochSecondsDateFormatter.java, +                // scientific notation it is!, +                if (inputs[1].contains("e")) {, +                    return Instant.ofEpochSecond(Double.valueOf(input).longValue()).atZone(ZoneOffset.UTC);, +                }, +                if (seconds < 0) {, +                    nanos = nanos * -1;, +                }, +++ b/server/src/main/java/org/elasticsearch/common/time/EpochMillisDateFormatter.java, +import java.math.BigDecimal;, +import java.util.regex.Pattern;, +    private static final Pattern SPLIT_BY_DOT_PATTERN = Pattern.compile("\\.");, +    static DateFormatter INSTANCE = new EpochMillisDateFormatter();, +            if (input.contains(".")) {, +                String[] inputs = SPLIT_BY_DOT_PATTERN.split(input, 2);, +                Long milliSeconds = Long.valueOf(inputs[0]);, +                if (inputs[1].length() == 0) {, +                    // this is BWC compatible to joda time, nothing after the dot is allowed, +                    return Instant.ofEpochMilli(milliSeconds).atZone(ZoneOffset.UTC);, +                // scientific notation it is!, +                if (inputs[1].contains("e")) {, +                    return Instant.ofEpochMilli(Double.valueOf(input).longValue()).atZone(ZoneOffset.UTC);, +                if (inputs[1].length() > 6) {, +                    throw new DateTimeParseException("too much granularity after dot [" + input + "]", input, 0);, +                }, +                Long nanos = new BigDecimal(inputs[1]).movePointRight(6 - inputs[1].length()).longValueExact();, +                if (milliSeconds < 0) {, +                    nanos = nanos * -1;, +                }, +                return Instant.ofEpochMilli(milliSeconds).plusNanos(nanos).atZone(ZoneOffset.UTC);, +            } else {, +                return Instant.ofEpochMilli(Long.valueOf(input)).atZone(ZoneOffset.UTC);, +            }, +        } catch (NumberFormatException e) {, +            throw new DateTimeParseException("invalid number [" + input + "]", input, 0, e);, +        }, +    }, +++ b/server/src/main/java/org/elasticsearch/common/time/EpochSecondsDateFormatter.java, +                // scientific notation it is!, +                if (inputs[1].contains("e")) {, +                    return Instant.ofEpochSecond(Double.valueOf(input).longValue()).atZone(ZoneOffset.UTC);, +                }]