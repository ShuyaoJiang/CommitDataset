[+++ b/server/src/main/java/org/elasticsearch/action/admin/indices/create/CreateIndexRequest.java, +import org.elasticsearch.common.collect.MapBuilder;, +        // wrap it in a type map if its not, +        if (source.size() != 1 || !source.containsKey(type)) {, +            source = MapBuilder.<String, Object>newMapBuilder().put(type, source).map();, +        }, +        mapping(type, PutMappingRequest.buildFromSimplifiedDef(type, source));, +++ b/server/src/main/java/org/elasticsearch/action/admin/indices/create/CreateIndexRequest.java, +import org.elasticsearch.common.collect.MapBuilder;, +        // wrap it in a type map if its not, +        if (source.size() != 1 || !source.containsKey(type)) {, +            source = MapBuilder.<String, Object>newMapBuilder().put(type, source).map();, +        }, +        mapping(type, PutMappingRequest.buildFromSimplifiedDef(type, source));, +++ b/server/src/main/java/org/elasticsearch/action/admin/indices/mapping/put/PutMappingRequest.java, +++ b/server/src/main/java/org/elasticsearch/action/admin/indices/create/CreateIndexRequest.java, +import org.elasticsearch.common.collect.MapBuilder;, +        // wrap it in a type map if its not, +        if (source.size() != 1 || !source.containsKey(type)) {, +            source = MapBuilder.<String, Object>newMapBuilder().put(type, source).map();, +        }, +        mapping(type, PutMappingRequest.buildFromSimplifiedDef(type, source));, +++ b/server/src/main/java/org/elasticsearch/action/admin/indices/mapping/put/PutMappingRequest.java, +++ b/server/src/test/java/org/elasticsearch/action/admin/indices/create/CreateIndexIT.java, +    public void testEmptyNestedMappings() throws Exception {, +++ b/server/src/main/java/org/elasticsearch/action/admin/indices/create/CreateIndexRequest.java, +import org.elasticsearch.common.collect.MapBuilder;, +        // wrap it in a type map if its not, +        if (source.size() != 1 || !source.containsKey(type)) {, +            source = MapBuilder.<String, Object>newMapBuilder().put(type, source).map();, +        }, +        mapping(type, PutMappingRequest.buildFromSimplifiedDef(type, source));, +++ b/server/src/main/java/org/elasticsearch/action/admin/indices/mapping/put/PutMappingRequest.java, +++ b/server/src/test/java/org/elasticsearch/action/admin/indices/create/CreateIndexIT.java, +    public void testEmptyNestedMappings() throws Exception {, +++ b/server/src/test/java/org/elasticsearch/action/admin/indices/create/CreateIndexRequestTests.java, +import org.elasticsearch.common.bytes.BytesReference;, +import org.elasticsearch.common.settings.Settings;, +import org.elasticsearch.test.ESTestCase;, +import org.elasticsearch.test.hamcrest.ElasticsearchAssertions;, +import static org.elasticsearch.cluster.metadata.IndexMetaData.SETTING_NUMBER_OF_SHARDS;, +import static org.elasticsearch.common.xcontent.ToXContent.EMPTY_PARAMS;, +public class CreateIndexRequestTests extends ESTestCase {, +        String mapping = Strings.toString(JsonXContent.contentBuilder().startObject().startObject("type").endObject().endObject());, +, +    public void testToXContent() throws IOException {, +        CreateIndexRequest request = new CreateIndexRequest("foo");, +, +        String mapping = Strings.toString(JsonXContent.contentBuilder().startObject().startObject("type").endObject().endObject());, +        request.mapping("my_type", mapping, XContentType.JSON);, +, +        Alias alias = new Alias("test_alias");, +        alias.routing("1");, +        alias.filter("{\"term\":{\"year\":2016}}");, +        alias.writeIndex(true);, +        request.alias(alias);, +, +        Settings.Builder settings = Settings.builder();, +        settings.put(SETTING_NUMBER_OF_SHARDS, 10);, +        request.settings(settings);, +, +        String actualRequestBody = Strings.toString(request);, +, +        String expectedRequestBody = "{\"settings\":{\"index\":{\"number_of_shards\":\"10\"}}," +, +            "\"mappings\":{\"my_type\":{\"type\":{}}}," +, +            "\"aliases\":{\"test_alias\":{\"filter\":{\"term\":{\"year\":2016}},\"routing\":\"1\",\"is_write_index\":true}}}";, +, +        assertEquals(expectedRequestBody, actualRequestBody);, +    }, +, +    public void testToAndFromXContent() throws IOException {, +, +        final CreateIndexRequest createIndexRequest = RandomCreateIndexGenerator.randomCreateIndexRequest();, +, +        boolean humanReadable = randomBoolean();, +        final XContentType xContentType = randomFrom(XContentType.values());, +        BytesReference originalBytes = toShuffledXContent(createIndexRequest, xContentType, EMPTY_PARAMS, humanReadable);, +, +        CreateIndexRequest parsedCreateIndexRequest = new CreateIndexRequest();, +        parsedCreateIndexRequest.source(originalBytes, xContentType);, +, +        assertMappingsEqual(createIndexRequest.mappings(), parsedCreateIndexRequest.mappings());, +        assertAliasesEqual(createIndexRequest.aliases(), parsedCreateIndexRequest.aliases());, +        assertEquals(createIndexRequest.settings(), parsedCreateIndexRequest.settings());, +, +        BytesReference finalBytes = toShuffledXContent(parsedCreateIndexRequest, xContentType, EMPTY_PARAMS, humanReadable);, +        ElasticsearchAssertions.assertToXContentEquivalent(originalBytes, finalBytes, xContentType);, +    }, +, +    public static void assertMappingsEqual(Map<String, String> expected, Map<String, String> actual) throws IOException {, +        assertEquals(expected.keySet(), actual.keySet());, +, +        for (Map.Entry<String, String> expectedEntry : expected.entrySet()) {, +            String expectedValue = expectedEntry.getValue();, +            String actualValue = actual.get(expectedEntry.getKey());, +            try (XContentParser expectedJson = JsonXContent.jsonXContent.createParser(NamedXContentRegistry.EMPTY,, +                    LoggingDeprecationHandler.INSTANCE, expectedValue);, +                 XContentParser actualJson = JsonXContent.jsonXContent.createParser(NamedXContentRegistry.EMPTY,, +                    LoggingDeprecationHandler.INSTANCE, actualValue)){, +                assertEquals(expectedJson.map(), actualJson.map());]