[+++ b/core/src/main/java/org/elasticsearch/action/bulk/MappingUpdatePerformer.java, +import org.elasticsearch.index.mapper.Mapping;, +     * Update the mappings on the master., +    void updateMappings(Mapping update, ShardId shardId, String type) throws Exception;, +++ b/core/src/main/java/org/elasticsearch/action/bulk/MappingUpdatePerformer.java, +import org.elasticsearch.index.mapper.Mapping;, +     * Update the mappings on the master., +    void updateMappings(Mapping update, ShardId shardId, String type) throws Exception;, +++ b/core/src/main/java/org/elasticsearch/action/bulk/TransportShardBulkAction.java, +        final Engine.Index preUpdateOperation;, +        final Mapping mappingUpdate;, +        final boolean mappingUpdateNeeded;, +            preUpdateOperation = prepareIndexOperationOnPrimary(request, primary);, +            mappingUpdate = preUpdateOperation.parsedDoc().dynamicMappingsUpdate();, +            mappingUpdateNeeded = mappingUpdate != null;, +            if (mappingUpdateNeeded) {, +                mappingUpdater.updateMappings(mappingUpdate, primary.shardId(), request.type());, +            }, +        if (mappingUpdateNeeded) {, +        } else {, +            // There was no mapping update, the operation is the same as the pre-update version., +            operation = preUpdateOperation;, +        }, +        public void updateMappings(final Mapping update, final ShardId shardId,, +++ b/core/src/main/java/org/elasticsearch/action/bulk/MappingUpdatePerformer.java, +import org.elasticsearch.index.mapper.Mapping;, +     * Update the mappings on the master., +    void updateMappings(Mapping update, ShardId shardId, String type) throws Exception;, +++ b/core/src/main/java/org/elasticsearch/action/bulk/TransportShardBulkAction.java, +        final Engine.Index preUpdateOperation;, +        final Mapping mappingUpdate;, +        final boolean mappingUpdateNeeded;, +            preUpdateOperation = prepareIndexOperationOnPrimary(request, primary);, +            mappingUpdate = preUpdateOperation.parsedDoc().dynamicMappingsUpdate();, +            mappingUpdateNeeded = mappingUpdate != null;, +            if (mappingUpdateNeeded) {, +                mappingUpdater.updateMappings(mappingUpdate, primary.shardId(), request.type());, +            }, +        if (mappingUpdateNeeded) {, +        } else {, +            // There was no mapping update, the operation is the same as the pre-update version., +            operation = preUpdateOperation;, +        }, +        public void updateMappings(final Mapping update, final ShardId shardId,, +++ b/core/src/test/java/org/elasticsearch/action/bulk/TransportShardBulkActionTests.java, +import org.elasticsearch.index.mapper.MapperService;, +import java.util.concurrent.atomic.AtomicBoolean;, +import java.util.concurrent.atomic.AtomicInteger;, +, +import static org.mockito.Mockito.any;, +import static org.mockito.Mockito.anyBoolean;, +import static org.mockito.Mockito.anyLong;, +import static org.mockito.Mockito.spy;, +import static org.mockito.Mockito.times;, +import static org.mockito.Mockito.verify;, +                .putMapping("type",, +                        "{\"properties\":{\"foo\":{\"type\":\"text\",\"fields\":" +, +                                "{\"keyword\":{\"type\":\"keyword\",\"ignore_above\":256}}}}}"), +                        new BulkItemResponse.Failure("index", "type", "id",, +    public void testMappingUpdateParsesCorrectNumberOfTimes() throws Exception {, +        IndexMetaData metaData = indexMetaData();, +        logger.info("--> metadata.getIndex(): {}", metaData.getIndex());, +        final IndexShard shard = spy(newStartedShard(true));, +, +        IndexRequest request = new IndexRequest("index", "type", "id"), +                .source(Requests.INDEX_CONTENT_TYPE, "foo", "bar");, +, +        final AtomicInteger updateCalled = new AtomicInteger(0);, +        final AtomicInteger verifyCalled = new AtomicInteger(0);, +        TransportShardBulkAction.executeIndexRequestOnPrimary(request, shard,, +                new MappingUpdatePerformer() {, +                    @Override, +                    public void updateMappings(Mapping update, ShardId shardId,, +                                               String type) throws Exception {, +                        // There should indeed be a mapping update, +                        assertNotNull(update);, +                        updateCalled.incrementAndGet();, +                    }, +, +                    @Override, +                    public void verifyMappings(Engine.Index operation,, +                                               ShardId shardId) throws Exception {, +                        // No-op, will be called, +                        logger.info("--> verifying mappings noop");, +                        verifyCalled.incrementAndGet();, +                    }, +        });, +, +        assertThat("mappings were \"updated\" once", updateCalled.get(), equalTo(1));, +        assertThat("mappings were \"verified\" once", verifyCalled.get(), equalTo(1));, +, +        // Verify that the shard "prepared" the operation twice, +        verify(shard, times(2)).prepareIndexOnPrimary(any(), anyLong(), any(),, +                anyLong(), anyBoolean());, +, +        // Update the mapping, so the next mapping updater doesn't do anything, +        final MapperService mapperService = shard.mapperService();, +        logger.info("--> mapperService.index(): {}", mapperService.index());, +        mapperService.updateMapping(metaData);, +]