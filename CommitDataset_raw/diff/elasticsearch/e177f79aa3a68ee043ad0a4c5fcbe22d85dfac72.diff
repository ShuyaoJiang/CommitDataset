[+++ b/plugin/src/main/java/org/elasticsearch/xpack/security/action/user/TransportHasPrivilegesAction.java, +        final Map<IndicesPermission.Group, Automaton> predicateCache = new HashMap<>();, +                                   Map<IndicesPermission.Group, Automaton> predicateCache) {, +        final Automaton checkIndexAutomaton = Automatons.patterns(checkIndex);, +, +            final Automaton groupIndexAutomaton = predicateCache.computeIfAbsent(group, g -> Automatons.patterns(g.indices()));, +            if (testIndex(checkIndexAutomaton, groupIndexAutomaton)) {, +    private static boolean testIndex(Automaton checkIndex, Automaton roleIndex) {, +        return Operations.subsetOf(checkIndex, roleIndex);, +    }, +, +    private static boolean testPrivilege(Privilege checkPrivilege, Automaton roleAutomaton) {, +++ b/plugin/src/main/java/org/elasticsearch/xpack/security/action/user/TransportHasPrivilegesAction.java, +        final Map<IndicesPermission.Group, Automaton> predicateCache = new HashMap<>();, +                                   Map<IndicesPermission.Group, Automaton> predicateCache) {, +        final Automaton checkIndexAutomaton = Automatons.patterns(checkIndex);, +, +            final Automaton groupIndexAutomaton = predicateCache.computeIfAbsent(group, g -> Automatons.patterns(g.indices()));, +            if (testIndex(checkIndexAutomaton, groupIndexAutomaton)) {, +    private static boolean testIndex(Automaton checkIndex, Automaton roleIndex) {, +        return Operations.subsetOf(checkIndex, roleIndex);, +    }, +, +    private static boolean testPrivilege(Privilege checkPrivilege, Automaton roleAutomaton) {, +++ b/plugin/src/test/java/org/elasticsearch/xpack/security/action/user/TransportHasPrivilegesActionTests.java, +     * Wildcards in the request are treated as, +     * <em>does the user have ___ privilege on every possible index that matches this pattern?</em>, +     * Or, expressed differently,, +     * <em>does the user have ___ privilege on a wildcard that covers (is a superset of) this pattern?</em>, +    public void testWildcardHandling() throws Exception {, +                .add(IndexPrivilege.ALL, "logstash-*", "foo?"), +                .add(IndexPrivilege.READ, "abc*"), +                .add(IndexPrivilege.WRITE, "*xyz"), +                        .privileges("write") // Yes, because (ALL,"logstash-*"), +                        .build(),, +                RoleDescriptor.IndicesPrivileges.builder(), +                        .indices("logstash-*"), +                        .privileges("read") // Yes, because (ALL,"logstash-*"), +                        .privileges("manage") // No, because "log*" includes indices that "logstash-*" does not, +                        .build(),, +                RoleDescriptor.IndicesPrivileges.builder(), +                        .indices("foo*", "foo?"), +                        .privileges("read") // Yes, "foo?", but not "foo*", because "foo*" > "foo?", +                        .build(),, +                RoleDescriptor.IndicesPrivileges.builder(), +                        .indices("abcd*"), +                        .privileges("read", "write") // read = Yes, because (READ, "abc*"), write = No, +                        .build(),, +                RoleDescriptor.IndicesPrivileges.builder(), +                        .indices("abc*xyz"), +                        .privileges("read", "write", "manage") // read = Yes ( READ "abc*"), write = Yes (WRITE, "*xyz"), manage = No, +                        .build(),, +                RoleDescriptor.IndicesPrivileges.builder(), +                        .indices("a*xyz"), +                        .privileges("read", "write", "manage") // read = No, write = Yes (WRITE, "*xyz"), manage = No, +        assertThat(response.getIndexPrivileges(), Matchers.iterableWithSize(8));, +                new IndexPrivileges("logstash-*", Collections.singletonMap("read", true)),, +                new IndexPrivileges("log*", Collections.singletonMap("manage", false)),, +                new IndexPrivileges("foo?", Collections.singletonMap("read", true)),, +                new IndexPrivileges("foo*", Collections.singletonMap("read", false)),, +                new IndexPrivileges("abcd*", mapBuilder().put("read", true).put("write", false).map()),, +                new IndexPrivileges("abc*xyz", mapBuilder().put("read", true).put("write", true).put("manage", false).map()),, +                new IndexPrivileges("a*xyz", mapBuilder().put("read", false).put("write", true).put("manage", false).map()), +, +    private static MapBuilder<String, Boolean> mapBuilder() {, +        return MapBuilder.newMapBuilder();, +    }, +]