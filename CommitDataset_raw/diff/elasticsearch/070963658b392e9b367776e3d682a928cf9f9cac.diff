[+++ b/core/src/main/java/org/elasticsearch/index/seqno/GlobalCheckpointTracker.java, +import org.elasticsearch.common.SuppressForbidden;, +    final ObjectLongMap<String> inSyncLocalCheckpoints;, +     * This map holds the last known local checkpoint for initializing shards that are undergoing recovery. Such shards do not participate, +     * in determining the global checkpoint. We must track these local checkpoints so that when a shard is activated we use the highest, +     * known checkpoint., +    final ObjectLongMap<String> trackingLocalCheckpoints;, +, +    /*, +     * This set contains allocation IDs for which there is a thread actively waiting for the local checkpoint to advance to at least the, +     * current global checkpoint., +     */, +    final Set<String> pendingInSync;, +        assert globalCheckpoint >= SequenceNumbersService.UNASSIGNED_SEQ_NO : "illegal initial global checkpoint: " + globalCheckpoint;, +        this.inSyncLocalCheckpoints = new ObjectLongHashMap<>(1 + indexSettings.getNumberOfReplicas());, +        this.trackingLocalCheckpoints = new ObjectLongHashMap<>(indexSettings.getNumberOfReplicas());, +        this.pendingInSync = new HashSet<>();, +     * @param localCheckpoint   the local checkpoint for the shard, +    public synchronized void updateLocalCheckpoint(final String allocationId, final long localCheckpoint) {, +        final boolean updated;, +        if (updateLocalCheckpoint(allocationId, localCheckpoint, inSyncLocalCheckpoints, "in-sync")) {, +            updated = true;, +        } else if (updateLocalCheckpoint(allocationId, localCheckpoint, trackingLocalCheckpoints, "tracking")) {, +            updated = true;, +        } else {, +            logger.trace("ignored local checkpoint [{}] of [{}], allocation ID is not tracked", localCheckpoint, allocationId);, +            updated = false;, +        if (updated) {, +            notifyAllWaiters();, +        }, +    }, +, +    @SuppressForbidden(reason = "Object#notifyAll waiters for local checkpoint advancement"), +    private synchronized void notifyAllWaiters() {, +        this.notifyAll();, +    }, +, +    private boolean updateLocalCheckpoint(, +            final String allocationId, final long localCheckpoint, ObjectLongMap<String> map, final String reason) {, +        final int index = map.indexOf(allocationId);, +        if (index >= 0) {, +            final long current = map.indexGet(index);, +            if (current < localCheckpoint) {, +                map.indexReplace(index, localCheckpoint);, +                logger.trace("updated local checkpoint of [{}] in [{}] from [{}] to [{}]", allocationId, reason, current, localCheckpoint);, +                        "skipped updating local checkpoint of [{}] in [{}] from [{}] to [{}], current checkpoint is higher",, +                        reason,, +                        localCheckpoint);, +            return true;, +            return false;, +     * @return {@code true} if the checkpoint has been updated or if it can not be updated since the local checkpoints of one of the active, +     * allocations is not known., +        long minLocalCheckpoint = Long.MAX_VALUE;, +        if (inSyncLocalCheckpoints.isEmpty() || !pendingInSync.isEmpty()) {, +        for (final ObjectLongCursor<String> localCheckpoint : inSyncLocalCheckpoints) {, +            if (localCheckpoint.value == SequenceNumbersService.UNASSIGNED_SEQ_NO) {, +                logger.trace("unknown local checkpoint for active allocation ID [{}], requesting a sync", localCheckpoint.key);, +            minLocalCheckpoint = Math.min(localCheckpoint.value, minLocalCheckpoint);, +        assert minLocalCheckpoint != SequenceNumbersService.UNASSIGNED_SEQ_NO : "new global checkpoint must be assigned";, +        if (minLocalCheckpoint < globalCheckpoint) {, +                    String.format(, +                            Locale.ROOT,, +                            "new global checkpoint [%d] is lower than previous one [%d]",, +                            minLocalCheckpoint,, +                            globalCheckpoint);, +        if (globalCheckpoint != minLocalCheckpoint) {, +            logger.trace("global checkpoint updated to [{}]", minLocalCheckpoint);, +            globalCheckpoint = minLocalCheckpoint;, +        } else {, +    }, +     * @param globalCheckpoint the global checkpoint, +    synchronized void updateGlobalCheckpointOnReplica(final long globalCheckpoint) {, +        if (this.globalCheckpoint <= globalCheckpoint) {, +            this.globalCheckpoint = globalCheckpoint;, +            logger.trace("global checkpoint updated from primary to [{}]", globalCheckpoint);, +    public synchronized void updateAllocationIdsFromMaster(, +            final Set<String> activeAllocationIds, final Set<String> initializingAllocationIds) {, +        // remove shards whose allocation ID no longer exists, +        inSyncLocalCheckpoints.removeAll(a -> !activeAllocationIds.contains(a) && !initializingAllocationIds.contains(a));, +, +        // add any new active allocation IDs, +        for (final String a : activeAllocationIds) {, +            if (!inSyncLocalCheckpoints.containsKey(a)) {, +                final long localCheckpoint = trackingLocalCheckpoints.getOrDefault(a, SequenceNumbersService.UNASSIGNED_SEQ_NO);, +                inSyncLocalCheckpoints.put(a, localCheckpoint);, +                logger.trace("marked [{}] as in-sync with local checkpoint [{}] via cluster state update from master", a, localCheckpoint);, +, +        trackingLocalCheckpoints.removeAll(a -> !initializingAllocationIds.contains(a));, +        for (final String a : initializingAllocationIds) {, +            if (inSyncLocalCheckpoints.containsKey(a)) {, +                /*, +                 * This can happen if we mark the allocation ID as in sync at the end of recovery before seeing a cluster state update from, +                 * marking the shard as active., +                 */, +                continue;, +            }, +            if (trackingLocalCheckpoints.containsKey(a)) {, +                // we are already tracking this allocation ID, +                continue;, +            }]