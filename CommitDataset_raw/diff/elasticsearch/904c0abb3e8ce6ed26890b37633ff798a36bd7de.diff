[+++ b/src/test/java/org/elasticsearch/common/lucene/search/XBooleanFilterTests.java, +import org.apache.lucene.search.*;, +import org.elasticsearch.test.ElasticsearchLuceneTestCase;, +import java.io.IOException;, +import java.util.Arrays;, +public class XBooleanFilterTests extends ElasticsearchLuceneTestCase {, +    private static final char[] distinctValues = new char[] {'a', 'b', 'c', 'd', 'v','z','y'};, +        directory = newDirectory();, +        super.tearDown();, +, +            filter = new PrettyPrintFieldCacheTermsFilter(String.valueOf(field), String.valueOf(character));, +    @Test, +    @AwaitsFix(bugUrl = "https://github.com/elasticsearch/elasticsearch/pull/4144/"), +    public void testRandom() throws IOException {, +        int iterations = atLeast(400); // don't worry that is fast!, +        for (int iter = 0; iter < iterations; iter++) {, +            int numClauses = 1 + random().nextInt(10);, +            FilterClause[] clauses = new FilterClause[numClauses];, +            BooleanQuery topLevel = new BooleanQuery();, +            BooleanQuery orQuery = new BooleanQuery();, +            boolean hasMust = false;, +            boolean hasShould = false;, +            boolean hasMustNot = false;, +            for(int i = 0; i < numClauses; i++) {, +                int field = random().nextInt(5);, +                char value = distinctValues[random().nextInt(distinctValues.length)];, +                switch(random().nextInt(10)) {, +                    case 9:, +                    case 8:, +                    case 7:, +                    case 6:, +                    case 5:, +                        hasMust = true;, +                        clauses[i] = newFilterClause(field, value, MUST, random().nextBoolean());, +                        topLevel.add(new BooleanClause(new TermQuery(new Term(String.valueOf(field), String.valueOf(value))), MUST));, +                        break;, +                    case 4:, +                    case 3:, +                    case 2:, +                    case 1:, +                        hasShould = true;, +                        clauses[i] = newFilterClause(field, value, SHOULD, random().nextBoolean());, +                        orQuery.add(new BooleanClause(new TermQuery(new Term(String.valueOf(field), String.valueOf(value))), SHOULD));, +                        break;, +                    case 0:, +                        hasMustNot = true;, +                        clauses[i] = newFilterClause(field, value, MUST_NOT, random().nextBoolean());, +                        topLevel.add(new BooleanClause(new TermQuery(new Term(String.valueOf(field), String.valueOf(value))), MUST_NOT));, +                        break;, +, +            }, +            if (orQuery.getClauses().length > 0) {, +                topLevel.add(new BooleanClause(orQuery, MUST));, +            }, +            if (hasMustNot && !hasMust && !hasShould) {  // pure negative, +                topLevel.add(new BooleanClause(new MatchAllDocsQuery(), MUST));, +            }, +            XBooleanFilter booleanFilter = createBooleanFilter(clauses);, +, +            FixedBitSet leftResult = new FixedBitSet(reader.maxDoc());, +            FixedBitSet rightResult = new FixedBitSet(reader.maxDoc());, +            DocIdSet left = booleanFilter.getDocIdSet(reader.getContext(), reader.getLiveDocs());, +            DocIdSet right = new QueryWrapperFilter(topLevel).getDocIdSet(reader.getContext(), reader.getLiveDocs());, +            if (left == null || right == null) {, +                if (left == null && right != null) {, +                    assertThat(errorMsg(clauses, topLevel), (right.iterator() == null ? DocIdSetIterator.NO_MORE_DOCS : right.iterator().nextDoc()), equalTo(DocIdSetIterator.NO_MORE_DOCS));, +                }, +                if (left != null && right == null) {, +                    assertThat(errorMsg(clauses, topLevel), (left.iterator() == null ? DocIdSetIterator.NO_MORE_DOCS : left.iterator().nextDoc()), equalTo(DocIdSetIterator.NO_MORE_DOCS));, +                }, +            } else {, +                DocIdSetIterator leftIter = left.iterator();, +                DocIdSetIterator rightIter = right.iterator();, +                if (leftIter != null) {, +                    leftResult.or(leftIter);, +                }, +, +                if (rightIter != null) {, +                    rightResult.or(rightIter);, +                }, +, +                assertThat(leftResult.cardinality(), equalTo(leftResult.cardinality()));, +                for (int i = 0; i < reader.maxDoc(); i++) {, +                    assertThat(errorMsg(clauses, topLevel) + " -- failed at index " + i, leftResult.get(i), equalTo(rightResult.get(i)));, +                }, +            }, +        }, +    }, +, +    private String errorMsg(FilterClause[] clauses, BooleanQuery query) {, +        return query.toString() + " vs. " + Arrays.toString(clauses);, +    }, +, +, +    public static final class PrettyPrintFieldCacheTermsFilter extends FieldCacheTermsFilter {, +, +        private final String value;, +        private final String field;, +, +        public PrettyPrintFieldCacheTermsFilter(String field, String value) {]