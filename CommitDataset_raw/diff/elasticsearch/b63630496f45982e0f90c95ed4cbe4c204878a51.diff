[+++ b/src/main/java/org/elasticsearch/watcher/support/WatcherDateUtils.java, +import org.elasticsearch.common.xcontent.XContentBuilder;, +import org.elasticsearch.watcher.WatcherException;, +    public static DateTime parseDate(String fieldName, XContentParser parser, DateTimeZone timeZone) throws IOException {, +        XContentParser.Token token = parser.currentToken();, +        throw new ParseException("could not parse date/time. expected date field [{}] to be either a number or a string but found [{}] instead", fieldName, token);, +    }, +, +    public static XContentBuilder writeDate(String fieldName, XContentBuilder builder, DateTime date) throws IOException {, +        return builder.field(fieldName, formatDate(date));, +, +    public static class ParseException extends WatcherException {, +        public ParseException(String msg, Object... args) {, +            super(msg, args);, +        }, +    }, +++ b/src/main/java/org/elasticsearch/watcher/support/WatcherDateUtils.java, +import org.elasticsearch.common.xcontent.XContentBuilder;, +import org.elasticsearch.watcher.WatcherException;, +    public static DateTime parseDate(String fieldName, XContentParser parser, DateTimeZone timeZone) throws IOException {, +        XContentParser.Token token = parser.currentToken();, +        throw new ParseException("could not parse date/time. expected date field [{}] to be either a number or a string but found [{}] instead", fieldName, token);, +    }, +, +    public static XContentBuilder writeDate(String fieldName, XContentBuilder builder, DateTime date) throws IOException {, +        return builder.field(fieldName, formatDate(date));, +, +    public static class ParseException extends WatcherException {, +        public ParseException(String msg, Object... args) {, +            super(msg, args);, +        }, +    }, +++ b/src/main/java/org/elasticsearch/watcher/trigger/TriggerEvent.java, +        data.put(Field.TRIGGERED_TIME.getPreferredName(), triggeredTime);, +    protected interface Field {, +        ParseField TRIGGERED_TIME = new ParseField("triggered_time");, +    }, +, +++ b/src/main/java/org/elasticsearch/watcher/support/WatcherDateUtils.java, +import org.elasticsearch.common.xcontent.XContentBuilder;, +import org.elasticsearch.watcher.WatcherException;, +    public static DateTime parseDate(String fieldName, XContentParser parser, DateTimeZone timeZone) throws IOException {, +        XContentParser.Token token = parser.currentToken();, +        throw new ParseException("could not parse date/time. expected date field [{}] to be either a number or a string but found [{}] instead", fieldName, token);, +    }, +, +    public static XContentBuilder writeDate(String fieldName, XContentBuilder builder, DateTime date) throws IOException {, +        return builder.field(fieldName, formatDate(date));, +, +    public static class ParseException extends WatcherException {, +        public ParseException(String msg, Object... args) {, +            super(msg, args);, +        }, +    }, +++ b/src/main/java/org/elasticsearch/watcher/trigger/TriggerEvent.java, +        data.put(Field.TRIGGERED_TIME.getPreferredName(), triggeredTime);, +    protected interface Field {, +        ParseField TRIGGERED_TIME = new ParseField("triggered_time");, +    }, +, +++ b/src/main/java/org/elasticsearch/watcher/trigger/manual/ManualTriggerEvent.java, +        builder.startObject();, +        WatcherDateUtils.writeDate(Field.TRIGGERED_TIME.getPreferredName(), builder, triggeredTime);, +        builder.field(Field.TRIGGER_DATA.getPreferredName(), triggerData);, +        return builder.endObject();, +            } else if (Field.TRIGGERED_TIME.match(currentFieldName)) {, +                try {, +                    triggeredTime = WatcherDateUtils.parseDate(currentFieldName, parser, UTC);, +                } catch (WatcherDateUtils.ParseException pe) {, +                    throw new ParseException("could not parse [{}] trigger event for [{}]. failed to parse date field [{}]", pe, ManualTriggerEngine.TYPE, context, currentFieldName);, +                if (Field.TRIGGER_DATA.match(currentFieldName)) {, +                    throw new ParseException("could not parse trigger event for [{}]. unexpected object value field [{}]", context, currentFieldName);, +                throw new ParseException("could not parse trigger event for [{}]. unexpected token [{}]", context, token);, +        public ParseException(String msg, Object... args) {, +            super(msg, args);, +        public ParseException(String msg, Throwable cause, Object... args) {, +            super(msg, cause, args);, +    interface Field extends TriggerEvent.Field {, +        ParseField TRIGGER_DATA = new ParseField("trigger_data");, +    }, +, +++ b/src/main/java/org/elasticsearch/watcher/support/WatcherDateUtils.java, +import org.elasticsearch.common.xcontent.XContentBuilder;, +import org.elasticsearch.watcher.WatcherException;, +    public static DateTime parseDate(String fieldName, XContentParser parser, DateTimeZone timeZone) throws IOException {, +        XContentParser.Token token = parser.currentToken();, +        throw new ParseException("could not parse date/time. expected date field [{}] to be either a number or a string but found [{}] instead", fieldName, token);, +    }, +, +    public static XContentBuilder writeDate(String fieldName, XContentBuilder builder, DateTime date) throws IOException {, +        return builder.field(fieldName, formatDate(date));, +, +    public static class ParseException extends WatcherException {, +        public ParseException(String msg, Object... args) {, +            super(msg, args);, +        }, +    }, +++ b/src/main/java/org/elasticsearch/watcher/trigger/TriggerEvent.java, +        data.put(Field.TRIGGERED_TIME.getPreferredName(), triggeredTime);, +    protected interface Field {]