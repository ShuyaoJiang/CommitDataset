[+++ b/src/main/java/org/elasticsearch/discovery/zen/ZenDiscovery.java, +, +        if (pingMasters.isEmpty()) {, +            // if we don't have enough master nodes, we bail, because there are not enough master to elect from, +++ b/src/main/java/org/elasticsearch/discovery/zen/ZenDiscovery.java, +, +        if (pingMasters.isEmpty()) {, +            // if we don't have enough master nodes, we bail, because there are not enough master to elect from, +++ b/src/test/java/org/elasticsearch/discovery/ClusterDiscoveryConfiguration.java, +        public UnicastZen(int numOfNodes, Settings extraSettings) {, +            this(numOfNodes, numOfNodes, extraSettings);, +        }, +, +++ b/src/main/java/org/elasticsearch/discovery/zen/ZenDiscovery.java, +, +        if (pingMasters.isEmpty()) {, +            // if we don't have enough master nodes, we bail, because there are not enough master to elect from, +++ b/src/test/java/org/elasticsearch/discovery/ClusterDiscoveryConfiguration.java, +        public UnicastZen(int numOfNodes, Settings extraSettings) {, +            this(numOfNodes, numOfNodes, extraSettings);, +        }, +, +++ b/src/test/java/org/elasticsearch/discovery/DiscoveryWithNetworkFailuresTests.java, +        if (randomBoolean()) {, +            return startMulticastCluster(numberOfNodes, -1);, +        } else {, +            return startUnicastCluster(numberOfNodes, null, -1);, +        }, +    }, +    final static Settings DEFAULT_SETTINGS = ImmutableSettings.builder(), +            .build();, +, +    private List<String> startMulticastCluster(int numberOfNodes, int minimumMasterNode) throws ExecutionException, InterruptedException {, +        if (minimumMasterNode < 0) {, +            minimumMasterNode = numberOfNodes / 2 + 1;, +        }, +        // TODO: Rarely use default settings form some of these, +        Settings settings = ImmutableSettings.builder(), +                .put(DEFAULT_SETTINGS), +                .put(ElectMasterService.DISCOVERY_ZEN_MINIMUM_MASTER_NODES, minimumMasterNode), +                .build();, +        List<String> nodes = internalCluster().startNodesAsync(numberOfNodes).get();, +        ensureStableCluster(numberOfNodes);, +, +        return nodes;, +    }, +, +    private List<String> startUnicastCluster(int numberOfNodes,@Nullable int[] unicastHostsOrdinals, int minimumMasterNode) throws ExecutionException, InterruptedException {, +        if (minimumMasterNode < 0) {, +            minimumMasterNode = numberOfNodes / 2 + 1;, +        }, +        // TODO: Rarely use default settings form some of these, +        Settings settings = ImmutableSettings.builder(), +                .put(DEFAULT_SETTINGS), +                .put(ElectMasterService.DISCOVERY_ZEN_MINIMUM_MASTER_NODES, minimumMasterNode), +                .build();, +, +        if (discoveryConfig == null) {, +            if (unicastHostsOrdinals == null) {, +                discoveryConfig = new ClusterDiscoveryConfiguration.UnicastZen(numberOfNodes, settings);, +            } else {, +                discoveryConfig = new ClusterDiscoveryConfiguration.UnicastZen(numberOfNodes, settings, unicastHostsOrdinals);, +            }, +, +        assertMaster(masterNode, nodes);, +    /**, +     * A 4 node cluster with m_m_n set to 3 and each node has one unicast enpoint. One node partitions from the master node., +     * The temporal unicast responses is empty. When partition is solved the one ping response contains a master node., +     * The rejoining node should take this master node and connect., +     */, +    @Test, +    @TestLogging("discovery.zen:TRACE,action:TRACE"), +    public void unicastSinglePingResponseContainsMaster() throws Exception {, +        List<String> nodes = startUnicastCluster(4, new int[] {0}, -1);, +        // Figure out what is the elected master node, +        final String masterNode = internalCluster().getMasterName();, +        logger.info("---> legit elected master node=" + masterNode);, +        List<String> otherNodes = new ArrayList<>(nodes);, +        otherNodes.remove(masterNode);, +        otherNodes.remove(nodes.get(0)); // <-- Don't isolate the node that is in the unicast endpoint for all the other nodes., +        final String isolatedNode = otherNodes.get(0);, +, +        // Forcefully clean temporal response lists on all nodes. Otherwise the node in the unicast host list, +        // includes all the other nodes that have pinged it and the issue doesn't manifest, +        for (ZenPingService pingService : internalCluster().getInstances(ZenPingService.class)) {, +            for (ZenPing zenPing : pingService.zenPings()) {, +                ((UnicastZenPing) zenPing).clearTemporalReponses();, +            }, +        }, +, +        // Simulate a network issue between the unlucky node and elected master node in both directions., +        NetworkDisconnectPartition networkDisconnect = new NetworkDisconnectPartition(masterNode, isolatedNode, getRandom());, +        setDisruptionScheme(networkDisconnect);, +        networkDisconnect.startDisrupting();, +        // Wait until elected master has removed that the unlucky node..., +        ensureStableCluster(3, masterNode);, +, +        // The isolate master node must report no master, so it starts with pinging, +        assertNoMaster(isolatedNode);, +        networkDisconnect.stopDisrupting();]