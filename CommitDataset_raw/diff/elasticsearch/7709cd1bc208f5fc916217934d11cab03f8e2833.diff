[+++ b/modules/benchmark/micro/src/main/java/log4j.properties, +#log4j.logger.monitor.jvm=DEBUG, +++ b/modules/benchmark/micro/src/main/java/log4j.properties, +#log4j.logger.monitor.jvm=DEBUG, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/monitor/jvm/JvmMonitorService.java, +    private final TimeValue gcThreshold;, +        this.gcThreshold = componentSettings.getAsTime("gc_threshold", timeValueMillis(5000));, +, +            for (int i = 0; i < currentJvmStats.gc().collectors().length; i++) {, +                GarbageCollector gc = currentJvmStats.gc().collectors()[i];, +                if (gc.lastGc() != null) {, +                    GarbageCollector.LastGc lastGc = gc.lastGc();, +                    if (lastGc.startTime == lastJvmStats.gc.collectors()[i].lastGc().startTime()) {, +                        // we already handled this one..., +                        continue;, +                    }, +                    if (lastGc.duration().millis() > gcThreshold.millis()) {, +                        logger.info("[gc][{}][{}] took [{}]/[{}], reclaimed [{}], leaving [{}] used, max [{}]", gc.name(), gc.getCollectionCount(), lastGc.duration(), gc.getCollectionTime(), lastGc.reclaimed(), lastGc.afterUsed(), lastGc.max());, +                    } else if (logger.isDebugEnabled()) {, +                        logger.debug("[gc][{}][{}] took [{}]/[{}], reclaimed [{}], leaving [{}] used, max [{}]", gc.name(), gc.getCollectionCount(), lastGc.duration(), gc.getCollectionTime(), lastGc.reclaimed(), lastGc.afterUsed(), lastGc.max());, +                    }, +                } else {, +                    long collectionTime = gc.collectionTime().millis() - lastJvmStats.gc().collectors()[i].collectionTime().millis();, +                    if (collectionTime > gcThreshold.millis()) {, +                        logger.info("[gc][{}] collection occurred, took [{}]", gc.name(), new TimeValue(collectionTime));, +                    }, +                }, +++ b/modules/benchmark/micro/src/main/java/log4j.properties, +#log4j.logger.monitor.jvm=DEBUG, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/monitor/jvm/JvmMonitorService.java, +    private final TimeValue gcThreshold;, +        this.gcThreshold = componentSettings.getAsTime("gc_threshold", timeValueMillis(5000));, +, +            for (int i = 0; i < currentJvmStats.gc().collectors().length; i++) {, +                GarbageCollector gc = currentJvmStats.gc().collectors()[i];, +                if (gc.lastGc() != null) {, +                    GarbageCollector.LastGc lastGc = gc.lastGc();, +                    if (lastGc.startTime == lastJvmStats.gc.collectors()[i].lastGc().startTime()) {, +                        // we already handled this one..., +                        continue;, +                    }, +                    if (lastGc.duration().millis() > gcThreshold.millis()) {, +                        logger.info("[gc][{}][{}] took [{}]/[{}], reclaimed [{}], leaving [{}] used, max [{}]", gc.name(), gc.getCollectionCount(), lastGc.duration(), gc.getCollectionTime(), lastGc.reclaimed(), lastGc.afterUsed(), lastGc.max());, +                    } else if (logger.isDebugEnabled()) {, +                        logger.debug("[gc][{}][{}] took [{}]/[{}], reclaimed [{}], leaving [{}] used, max [{}]", gc.name(), gc.getCollectionCount(), lastGc.duration(), gc.getCollectionTime(), lastGc.reclaimed(), lastGc.afterUsed(), lastGc.max());, +                    }, +                } else {, +                    long collectionTime = gc.collectionTime().millis() - lastJvmStats.gc().collectors()[i].collectionTime().millis();, +                    if (collectionTime > gcThreshold.millis()) {, +                        logger.info("[gc][{}] collection occurred, took [{}]", gc.name(), new TimeValue(collectionTime));, +                    }, +                }, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/monitor/jvm/JvmStats.java, +import java.lang.reflect.Method;, +import java.util.Map;, +    private final static RuntimeMXBean runtimeMXBean;, +    private final static MemoryMXBean memoryMXBean;, +    private final static ThreadMXBean threadMXBean;, +, +    private static boolean sunGc;, +    private static Method getLastGcInfoMethod;, +    private static Method getMemoryUsageBeforeGcMethod;, +    private static Method getMemoryUsageAfterGcMethod;, +    private static Method getStartTimeMethod;, +    private static Method getEndTimeMethod;, +    private static Method getDurationMethod;, +, +        try {, +            Class sunGcClass = Class.forName("com.sun.management.GarbageCollectorMXBean");, +            Class gcInfoClass = Class.forName("com.sun.management.GcInfo");, +, +            getLastGcInfoMethod = sunGcClass.getDeclaredMethod("getLastGcInfo");, +            getLastGcInfoMethod.setAccessible(true);, +, +            getMemoryUsageBeforeGcMethod = gcInfoClass.getDeclaredMethod("getMemoryUsageBeforeGc");, +            getMemoryUsageBeforeGcMethod.setAccessible(true);, +            getMemoryUsageAfterGcMethod = gcInfoClass.getDeclaredMethod("getMemoryUsageAfterGc");, +            getMemoryUsageAfterGcMethod.setAccessible(true);, +            getStartTimeMethod = gcInfoClass.getDeclaredMethod("getStartTime");, +            getStartTimeMethod.setAccessible(true);, +            getEndTimeMethod = gcInfoClass.getDeclaredMethod("getEndTime");, +            getEndTimeMethod.setAccessible(true);, +            getDurationMethod = gcInfoClass.getDeclaredMethod("getDuration");, +            getDurationMethod.setAccessible(true);, +, +            sunGc = true;, +        } catch (Throwable ex) {, +            sunGc = false;, +        }, +            if (sunGc) {, +                try {, +                    Object lastGcInfo = getLastGcInfoMethod.invoke(gcMxBean);, +                    if (lastGcInfo != null) {, +                        Map<String, MemoryUsage> usageBeforeGc = (Map<String, MemoryUsage>) getMemoryUsageBeforeGcMethod.invoke(lastGcInfo);, +                        Map<String, MemoryUsage> usageAfterGc = (Map<String, MemoryUsage>) getMemoryUsageAfterGcMethod.invoke(lastGcInfo);, +                        long startTime = (Long) getStartTimeMethod.invoke(lastGcInfo);, +                        long endTime = (Long) getEndTimeMethod.invoke(lastGcInfo);, +                        long duration = (Long) getDurationMethod.invoke(lastGcInfo);, +, +                        long previousMemoryUsed = 0;]