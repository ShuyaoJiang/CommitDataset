[+++ b/plugin/src/main/java/org/elasticsearch/xpack/monitoring/Monitoring.java, +        exporterFactories.put(HttpExporter.TYPE, config -> new HttpExporter(config, dynamicSSLService, threadPool.getThreadContext()));, +        final Exporters exporters = new Exporters(settings, exporterFactories, clusterService, threadPool.getThreadContext());, +++ b/plugin/src/main/java/org/elasticsearch/xpack/monitoring/Monitoring.java, +        exporterFactories.put(HttpExporter.TYPE, config -> new HttpExporter(config, dynamicSSLService, threadPool.getThreadContext()));, +        final Exporters exporters = new Exporters(settings, exporterFactories, clusterService, threadPool.getThreadContext());, +++ b/plugin/src/main/java/org/elasticsearch/xpack/monitoring/MonitoringService.java, +import org.elasticsearch.action.ActionListener;, +import java.util.concurrent.TimeUnit;, +        monitor.close();, +                        exporters.export(results, ActionListener.wrap(r -> semaphore.release(), this::onFailure));, +                    } else {, +                        semaphore.release();, +                    semaphore.release();, +        public void close() {, +                // Block until the lock can be acquired or 10s. The timed try acquire is necessary as there may be a failure that causes, +                // the semaphore to not get released and then the node will hang forever on shutdown, +                if (semaphore.tryAcquire(10L, TimeUnit.SECONDS) == false) {, +                    logger.warn("monitoring execution did not complete after waiting for 10s");, +                }, +++ b/plugin/src/main/java/org/elasticsearch/xpack/monitoring/Monitoring.java, +        exporterFactories.put(HttpExporter.TYPE, config -> new HttpExporter(config, dynamicSSLService, threadPool.getThreadContext()));, +        final Exporters exporters = new Exporters(settings, exporterFactories, clusterService, threadPool.getThreadContext());, +++ b/plugin/src/main/java/org/elasticsearch/xpack/monitoring/MonitoringService.java, +import org.elasticsearch.action.ActionListener;, +import java.util.concurrent.TimeUnit;, +        monitor.close();, +                        exporters.export(results, ActionListener.wrap(r -> semaphore.release(), this::onFailure));, +                    } else {, +                        semaphore.release();, +                    semaphore.release();, +        public void close() {, +                // Block until the lock can be acquired or 10s. The timed try acquire is necessary as there may be a failure that causes, +                // the semaphore to not get released and then the node will hang forever on shutdown, +                if (semaphore.tryAcquire(10L, TimeUnit.SECONDS) == false) {, +                    logger.warn("monitoring execution did not complete after waiting for 10s");, +                }, +++ b/plugin/src/main/java/org/elasticsearch/xpack/monitoring/action/TransportMonitoringBulkAction.java, +            try {, +                exportService.export(docs, ActionListener.wrap(, +                        r -> listener.onResponse(response(startTimeNanos)),, +                        e -> listener.onResponse(response(startTimeNanos, e))));, +            } catch (Exception e) {, +                listener.onResponse(response(startTimeNanos, e));, +    private MonitoringBulkResponse response(final long start) {, +        return new MonitoringBulkResponse(took(start));, +, +    private MonitoringBulkResponse response(final long start, final Exception e) {, +        return new MonitoringBulkResponse(took(start), new MonitoringBulkResponse.Error(e));, +    }, +, +    private long took(final long start) {, +        return TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - start);, +    }, +, +++ b/plugin/src/main/java/org/elasticsearch/xpack/monitoring/Monitoring.java, +        exporterFactories.put(HttpExporter.TYPE, config -> new HttpExporter(config, dynamicSSLService, threadPool.getThreadContext()));, +        final Exporters exporters = new Exporters(settings, exporterFactories, clusterService, threadPool.getThreadContext());, +++ b/plugin/src/main/java/org/elasticsearch/xpack/monitoring/MonitoringService.java, +import org.elasticsearch.action.ActionListener;, +import java.util.concurrent.TimeUnit;, +        monitor.close();, +                        exporters.export(results, ActionListener.wrap(r -> semaphore.release(), this::onFailure));, +                    } else {, +                        semaphore.release();, +                    semaphore.release();, +        public void close() {, +                // Block until the lock can be acquired or 10s. The timed try acquire is necessary as there may be a failure that causes, +                // the semaphore to not get released and then the node will hang forever on shutdown, +                if (semaphore.tryAcquire(10L, TimeUnit.SECONDS) == false) {, +                    logger.warn("monitoring execution did not complete after waiting for 10s");, +                }, +++ b/plugin/src/main/java/org/elasticsearch/xpack/monitoring/action/TransportMonitoringBulkAction.java, +            try {, +                exportService.export(docs, ActionListener.wrap(, +                        r -> listener.onResponse(response(startTimeNanos)),, +                        e -> listener.onResponse(response(startTimeNanos, e))));, +            } catch (Exception e) {, +                listener.onResponse(response(startTimeNanos, e));, +    private MonitoringBulkResponse response(final long start) {, +        return new MonitoringBulkResponse(took(start));, +, +    private MonitoringBulkResponse response(final long start, final Exception e) {, +        return new MonitoringBulkResponse(took(start), new MonitoringBulkResponse.Error(e));, +    }, +, +    private long took(final long start) {, +        return TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - start);, +    }, +, +++ b/plugin/src/main/java/org/elasticsearch/xpack/monitoring/exporter/ExportBulk.java, +import org.apache.lucene.util.SetOnce;, +import org.elasticsearch.action.ActionListener;, +import org.elasticsearch.common.util.concurrent.ThreadContext;, +import org.elasticsearch.xpack.common.IteratingActionListener;, +, +import java.util.List;, +import java.util.function.BiConsumer;, + * An export bulk holds one of more documents until it got flushed. The {@link ExportBulk#flush(ActionListener)} usually triggers the, + * exporting of the documents to their final destination.]