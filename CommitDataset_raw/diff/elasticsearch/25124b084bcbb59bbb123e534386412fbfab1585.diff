[+++ b/modules/elasticsearch/src/main/java/org/apache/lucene/queryParser/MapperQueryParser.java, +import org.apache.lucene.analysis.TokenStream;, +import org.apache.lucene.analysis.tokenattributes.TermAttribute;, +import org.elasticsearch.common.io.FastStringReader;, +import java.io.IOException;, +import java.io.StringReader;, +import java.util.ArrayList;, +    private boolean analyzeWildcard;, +, +        this.analyzeWildcard = settings.analyzeWildcard();, +    @Override protected Query getPrefixQuery(String field, String termStr) throws ParseException {, +        String indexedNameField = field;, +        currentMapper = null;, +        if (parseContext.mapperService() != null) {, +            MapperService.SmartNameFieldMappers fieldMappers = parseContext.mapperService().smartName(field);, +            if (fieldMappers != null) {, +                currentMapper = fieldMappers.fieldMappers().mapper();, +                if (currentMapper != null) {, +                    indexedNameField = currentMapper.names().indexName();, +                }, +                return wrapSmartNameQuery(getPossiblyAnalyzedPrefixQuery(indexedNameField, termStr), fieldMappers, parseContext);, +            }, +        }, +        return getPossiblyAnalyzedPrefixQuery(indexedNameField, termStr);, +    }, +, +    private Query getPossiblyAnalyzedPrefixQuery(String field, String termStr) throws ParseException {, +        if (!analyzeWildcard) {, +            return super.getPrefixQuery(field, termStr);, +        }, +        // LUCENE MONITOR: TermAttribute deprecated in 3.1, +        // get Analyzer from superclass and tokenize the term, +        TokenStream source = null;, +        try {, +            source = getAnalyzer().reusableTokenStream(field, new StringReader(termStr));, +        } catch (IOException e) {, +            return super.getPrefixQuery(field, termStr);, +        }, +        List<String> tlist = new ArrayList<String>();, +        TermAttribute termAtt = source.addAttribute(TermAttribute.class);, +, +        while (true) {, +            try {, +                if (!source.incrementToken()) break;, +            } catch (IOException e) {, +                break;, +            }, +            tlist.add(termAtt.term());, +        }, +, +        try {, +            source.close();, +        } catch (IOException e) {, +            // ignore, +        }, +, +        if (tlist.size() == 1) {, +            return super.getPrefixQuery(field, tlist.get(0));, +        } else {, +            return super.getPrefixQuery(field, termStr);, +            /* this means that the analyzer used either added or consumed, +* (common for a stemmer) tokens, and we can't build a PrefixQuery */, +//            throw new ParseException("Cannot build PrefixQuery with analyzer ", +//                    + getAnalyzer().getClass(), +//                    + (tlist.size() > 1 ? " - token(s) added" : " - token consumed"));, +        }, +, +    }, +, +                return wrapSmartNameQuery(getPossiblyAnalyzedWildcardQuery(indexedNameField, termStr), fieldMappers, parseContext);, +        return getPossiblyAnalyzedWildcardQuery(indexedNameField, termStr);, +    }, +, +    private Query getPossiblyAnalyzedWildcardQuery(String field, String termStr) throws ParseException {, +        if (!analyzeWildcard) {, +            return super.getWildcardQuery(field, termStr);, +        }, +        boolean isWithinToken = (!termStr.startsWith("?") && !termStr.startsWith("*"));, +        StringBuilder aggStr = new StringBuilder();, +        StringBuilder tmp = new StringBuilder();, +        for (int i = 0; i < termStr.length(); i++) {, +            char c = termStr.charAt(i);, +            if (c == '?' || c == '*') {, +                if (isWithinToken) {, +                    try {, +                        TokenStream source = getAnalyzer().reusableTokenStream(field, new FastStringReader(tmp.toString()));, +                        TermAttribute termAtt = source.addAttribute(TermAttribute.class);, +                        if (source.incrementToken()) {, +                            String term = termAtt.term();, +                            if (term.length() == 0) {, +                                // no tokens, just use what we have now, +                                aggStr.append(tmp);, +                            } else {, +                                aggStr.append(term);, +                            }, +                        } else {, +                            // no tokens, just use what we have now, +                            aggStr.append(tmp);, +                        }, +                        source.close();]