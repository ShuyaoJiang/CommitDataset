[+++ b/core/src/main/java/org/elasticsearch/common/xcontent/XContentBuilder.java, +import java.util.Arrays;, +import java.util.IdentityHashMap;, +, +        // checks that the array of object does not contain references to itself because, +        // iterating over entries will cause a stackoverflow error, +        ensureNoSelfReferences(values);, +, +, +        // checks that the map does not contain references to itself because, +        // iterating over map entries will cause a stackoverflow error, +        ensureNoSelfReferences(values);, +, +            // checks that the iterable does not contain references to itself because, +            // iterating over entries will cause a stackoverflow error, +            ensureNoSelfReferences(values);, +, +, +    static void ensureNoSelfReferences(Object value) {, +        ensureNoSelfReferences(value, Collections.newSetFromMap(new IdentityHashMap<>()));, +    }, +, +    private static void ensureNoSelfReferences(final Object value, final Set<Object> ancestors) {, +        if (value != null) {, +, +            Iterable<?> it;, +            if (value instanceof Map) {, +                it = ((Map) value).values();, +            } else if ((value instanceof Iterable) && (value instanceof Path == false)) {, +                it = (Iterable) value;, +            } else if (value instanceof Object[]) {, +                it = Arrays.asList((Object[]) value);, +            } else {, +                return;, +            }, +, +            if (ancestors.add(value) == false) {, +                throw new IllegalArgumentException("Object has already been built and is self-referencing itself");, +            }, +            for (Object o : it) {, +                ensureNoSelfReferences(o, ancestors);, +            }, +            ancestors.remove(value);, +        }, +    }, +++ b/core/src/main/java/org/elasticsearch/common/xcontent/XContentBuilder.java, +import java.util.Arrays;, +import java.util.IdentityHashMap;, +, +        // checks that the array of object does not contain references to itself because, +        // iterating over entries will cause a stackoverflow error, +        ensureNoSelfReferences(values);, +, +, +        // checks that the map does not contain references to itself because, +        // iterating over map entries will cause a stackoverflow error, +        ensureNoSelfReferences(values);, +, +            // checks that the iterable does not contain references to itself because, +            // iterating over entries will cause a stackoverflow error, +            ensureNoSelfReferences(values);, +, +, +    static void ensureNoSelfReferences(Object value) {, +        ensureNoSelfReferences(value, Collections.newSetFromMap(new IdentityHashMap<>()));, +    }, +, +    private static void ensureNoSelfReferences(final Object value, final Set<Object> ancestors) {, +        if (value != null) {, +, +            Iterable<?> it;, +            if (value instanceof Map) {, +                it = ((Map) value).values();, +            } else if ((value instanceof Iterable) && (value instanceof Path == false)) {, +                it = (Iterable) value;, +            } else if (value instanceof Object[]) {, +                it = Arrays.asList((Object[]) value);, +            } else {, +                return;, +            }, +, +            if (ancestors.add(value) == false) {, +                throw new IllegalArgumentException("Object has already been built and is self-referencing itself");, +            }, +            for (Object o : it) {, +                ensureNoSelfReferences(o, ancestors);, +            }, +            ancestors.remove(value);, +        }, +    }, +++ b/core/src/test/java/org/elasticsearch/common/xcontent/BaseXContentTestCase.java, +import java.util.ArrayList;, +import java.util.List;, +import static java.util.Collections.emptyMap;, +    public void testEnsureNoSelfReferences() throws IOException {, +        XContentBuilder.ensureNoSelfReferences(emptyMap());, +        XContentBuilder.ensureNoSelfReferences(null);, +, +        Map<String, Object> map = new HashMap<>();, +        map.put("field", map);]