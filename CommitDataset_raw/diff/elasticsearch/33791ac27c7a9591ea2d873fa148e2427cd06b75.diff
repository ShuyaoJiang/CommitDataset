[+++ b/server/src/main/java/org/elasticsearch/index/engine/InternalEngine.java, +        public static IndexingStrategy skipDueToVersionConflict(, +        public static DeletionStrategy skipDueToVersionConflict(, +++ b/server/src/main/java/org/elasticsearch/index/engine/InternalEngine.java, +        public static IndexingStrategy skipDueToVersionConflict(, +        public static DeletionStrategy skipDueToVersionConflict(, +++ b/test/framework/src/main/java/org/elasticsearch/index/engine/EngineTestCase.java, +                        if (primaryTermDocValues.advanceExact(i) == false) {, +                            // We have to skip non-root docs because its _id field is not stored (indexed only)., +                            continue;, +                        }, +                        final long primaryTerm = primaryTermDocValues.longValue();, +++ b/server/src/main/java/org/elasticsearch/index/engine/InternalEngine.java, +        public static IndexingStrategy skipDueToVersionConflict(, +        public static DeletionStrategy skipDueToVersionConflict(, +++ b/test/framework/src/main/java/org/elasticsearch/index/engine/EngineTestCase.java, +                        if (primaryTermDocValues.advanceExact(i) == false) {, +                            // We have to skip non-root docs because its _id field is not stored (indexed only)., +                            continue;, +                        }, +                        final long primaryTerm = primaryTermDocValues.longValue();, +++ b/test/framework/src/main/java/org/elasticsearch/index/replication/ESIndexLevelReplicationTestCase.java, +import org.elasticsearch.index.engine.DocIdSeqNoAndTerm;, +                    final List<DocIdSeqNoAndTerm> docsOnPrimary = getDocIdAndSeqNos(primary);, +                    for (IndexShard replica : replicas) {, +                        assertThat(getDocIdAndSeqNos(replica), equalTo(docsOnPrimary));, +                } catch (AlreadyClosedException ignored) { }, +++ b/server/src/main/java/org/elasticsearch/index/engine/InternalEngine.java, +        public static IndexingStrategy skipDueToVersionConflict(, +        public static DeletionStrategy skipDueToVersionConflict(, +++ b/test/framework/src/main/java/org/elasticsearch/index/engine/EngineTestCase.java, +                        if (primaryTermDocValues.advanceExact(i) == false) {, +                            // We have to skip non-root docs because its _id field is not stored (indexed only)., +                            continue;, +                        }, +                        final long primaryTerm = primaryTermDocValues.longValue();, +++ b/test/framework/src/main/java/org/elasticsearch/index/replication/ESIndexLevelReplicationTestCase.java, +import org.elasticsearch.index.engine.DocIdSeqNoAndTerm;, +                    final List<DocIdSeqNoAndTerm> docsOnPrimary = getDocIdAndSeqNos(primary);, +                    for (IndexShard replica : replicas) {, +                        assertThat(getDocIdAndSeqNos(replica), equalTo(docsOnPrimary));, +                } catch (AlreadyClosedException ignored) { }, +++ b/x-pack/plugin/ccr/src/main/java/org/elasticsearch/xpack/ccr/action/bulk/TransportBulkShardOperationsAction.java, +import org.elasticsearch.ExceptionsHelper;, +import org.elasticsearch.xpack.ccr.index.engine.AlreadyProcessedFollowingEngineException;, +import java.util.ArrayList;, +import java.util.function.Function;, +    public static CcrWritePrimaryResult shardOperationOnPrimary(, +        final Function<Translog.Operation, Translog.Operation> rewriteWithTerm = operation -> {, +        };, +, +, +        final List<Translog.Operation> appliedOperations = new ArrayList<>(sourceOperations.size());, +        Translog.Location location = null;, +        long waitingForGlobalCheckpoint = SequenceNumbers.UNASSIGNED_SEQ_NO;, +        for (Translog.Operation sourceOp : sourceOperations) {, +            final Translog.Operation targetOp = rewriteWithTerm.apply(sourceOp);, +            final Engine.Result result = primary.applyTranslogOperation(targetOp, Engine.Operation.Origin.PRIMARY);, +            if (result.getResultType() == Engine.Result.Type.SUCCESS) {, +                assert result.getSeqNo() == targetOp.seqNo();, +                appliedOperations.add(targetOp);, +                location = locationToSync(location, result.getTranslogLocation());, +            } else {, +                if (result.getFailure() instanceof AlreadyProcessedFollowingEngineException) {, +                    // Skipped operations will be delivered to replicas via primary-replica resync or peer-recovery., +                    // The primary must not acknowledge this request until the global checkpoint is at least the highest, +                    // seqno of all skipped operations (i.e., all skipped operations have been processed on every replica)., +                    waitingForGlobalCheckpoint = SequenceNumbers.max(waitingForGlobalCheckpoint, targetOp.seqNo());, +                } else {, +                    assert false : "Only already-processed error should happen; op=[" + targetOp + "] error=[" + result.getFailure() + "]";, +                    throw ExceptionsHelper.convertToElastic(result.getFailure());, +                }, +            }, +        }, +        assert appliedOperations.size() == sourceOperations.size() || waitingForGlobalCheckpoint != SequenceNumbers.UNASSIGNED_SEQ_NO :, +            "waiting global checkpoint is not assigned; waiting_gcp=" + waitingForGlobalCheckpoint +, +            " source_ops=" + sourceOperations.size() + " applied_ops=" + sourceOperations.size();, +        assert appliedOperations.size() == 0 || location != null;, +            shardId, historyUUID, appliedOperations, maxSeqNoOfUpdatesOrDeletes);, +        return new CcrWritePrimaryResult(replicaRequest, location, primary, waitingForGlobalCheckpoint, logger);, +        return shardOperationOnReplica(request, replica, logger);, +    public static WriteReplicaResult<BulkShardOperationsRequest> shardOperationOnReplica(, +        final BulkShardOperationsRequest request, final IndexShard replica, final Logger logger) throws IOException {, +        assert replica.getMaxSeqNoOfUpdatesOrDeletes() >= request.getMaxSeqNoOfUpdatesOrDeletes() :, +            "mus on replica [" + replica + "] < mus of request [" + request.getMaxSeqNoOfUpdatesOrDeletes() + "]";, +        for (final Translog.Operation operation : request.getOperations()) {, +            final Engine.Result result = replica.applyTranslogOperation(operation, Engine.Operation.Origin.REPLICA);, +            if (result.getResultType() != Engine.Result.Type.SUCCESS) {, +                assert false : "doc-level failure must not happen on replicas; op[" + operation + "] error[" + result.getFailure() + "]";, +                throw ExceptionsHelper.convertToElastic(result.getFailure());, +            }, +        assert request.getOperations().size() == 0 || location != null;, +        return new WriteReplicaResult<>(request, location, null, replica, logger);, +    static final class CcrWritePrimaryResult extends WritePrimaryResult<BulkShardOperationsRequest, BulkShardOperationsResponse> {, +        final long waitingForGlobalCheckpoint;, +        CcrWritePrimaryResult(BulkShardOperationsRequest request, Translog.Location location, IndexShard primary,, +                              long waitingForGlobalCheckpoint, Logger logger) {, +            this.waitingForGlobalCheckpoint = waitingForGlobalCheckpoint;, +            final ActionListener<BulkShardOperationsResponse> wrappedListener = ActionListener.wrap(response -> {, +            }, listener::onFailure);]