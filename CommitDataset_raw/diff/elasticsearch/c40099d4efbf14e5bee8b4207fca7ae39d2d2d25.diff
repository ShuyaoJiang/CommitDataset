[+++ b/core/src/main/java/org/elasticsearch/action/support/replication/TransportReplicationAction.java, +                logger.trace("Retrying operation on replica, action [{}], request [{}]", t, transportReplicaAction, request);, +                        // Forking a thread on local node via transport service so that custom transport service have an, +                        // opportunity to execute custom  logic before the replica operation begins, +                        String extraMessage = "action [" + transportReplicaAction  + "], request[" + request + "]";, +                        TransportChannelResponseHandler<TransportResponse.Empty> handler = TransportChannelResponseHandler.emptyResponseHandler(logger, channel, extraMessage);, +                        transportService.sendRequest(clusterService.localNode(), transportReplicaAction, request, handler);, +++ b/core/src/main/java/org/elasticsearch/action/support/replication/TransportReplicationAction.java, +                logger.trace("Retrying operation on replica, action [{}], request [{}]", t, transportReplicaAction, request);, +                        // Forking a thread on local node via transport service so that custom transport service have an, +                        // opportunity to execute custom  logic before the replica operation begins, +                        String extraMessage = "action [" + transportReplicaAction  + "], request[" + request + "]";, +                        TransportChannelResponseHandler<TransportResponse.Empty> handler = TransportChannelResponseHandler.emptyResponseHandler(logger, channel, extraMessage);, +                        transportService.sendRequest(clusterService.localNode(), transportReplicaAction, request, handler);, +++ b/core/src/main/java/org/elasticsearch/cluster/metadata/MetaDataMappingService.java, +                        // this will just throw exceptions in case of problems, +                        existingMapper.merge(newMapper.mapping(), true, request.updateAllTypes());, +++ b/core/src/main/java/org/elasticsearch/action/support/replication/TransportReplicationAction.java, +                logger.trace("Retrying operation on replica, action [{}], request [{}]", t, transportReplicaAction, request);, +                        // Forking a thread on local node via transport service so that custom transport service have an, +                        // opportunity to execute custom  logic before the replica operation begins, +                        String extraMessage = "action [" + transportReplicaAction  + "], request[" + request + "]";, +                        TransportChannelResponseHandler<TransportResponse.Empty> handler = TransportChannelResponseHandler.emptyResponseHandler(logger, channel, extraMessage);, +                        transportService.sendRequest(clusterService.localNode(), transportReplicaAction, request, handler);, +++ b/core/src/main/java/org/elasticsearch/cluster/metadata/MetaDataMappingService.java, +                        // this will just throw exceptions in case of problems, +                        existingMapper.merge(newMapper.mapping(), true, request.updateAllTypes());, +++ b/core/src/main/java/org/elasticsearch/index/mapper/DocumentMapper.java, +import java.util.Arrays;, +    private volatile Mapping mapping;, +    public void merge(Mapping mapping, boolean simulate, boolean updateAllTypes) {, +            // do the merge even if simulate == false so that we get exceptions, +            Mapping merged = this.mapping.merge(mapping, updateAllTypes);, +                this.mapping = merged;, +                Collection<ObjectMapper> objectMappers = new ArrayList<>();, +                Collection<FieldMapper> fieldMappers = new ArrayList<>(Arrays.asList(merged.metadataMappers));, +                MapperUtils.collect(merged.root, objectMappers, fieldMappers);, +                addMappers(objectMappers, fieldMappers, updateAllTypes);, +++ b/core/src/main/java/org/elasticsearch/action/support/replication/TransportReplicationAction.java, +                logger.trace("Retrying operation on replica, action [{}], request [{}]", t, transportReplicaAction, request);, +                        // Forking a thread on local node via transport service so that custom transport service have an, +                        // opportunity to execute custom  logic before the replica operation begins, +                        String extraMessage = "action [" + transportReplicaAction  + "], request[" + request + "]";, +                        TransportChannelResponseHandler<TransportResponse.Empty> handler = TransportChannelResponseHandler.emptyResponseHandler(logger, channel, extraMessage);, +                        transportService.sendRequest(clusterService.localNode(), transportReplicaAction, request, handler);, +++ b/core/src/main/java/org/elasticsearch/cluster/metadata/MetaDataMappingService.java, +                        // this will just throw exceptions in case of problems, +                        existingMapper.merge(newMapper.mapping(), true, request.updateAllTypes());, +++ b/core/src/main/java/org/elasticsearch/index/mapper/DocumentMapper.java, +import java.util.Arrays;, +    private volatile Mapping mapping;, +    public void merge(Mapping mapping, boolean simulate, boolean updateAllTypes) {, +            // do the merge even if simulate == false so that we get exceptions, +            Mapping merged = this.mapping.merge(mapping, updateAllTypes);, +                this.mapping = merged;, +                Collection<ObjectMapper> objectMappers = new ArrayList<>();, +                Collection<FieldMapper> fieldMappers = new ArrayList<>(Arrays.asList(merged.metadataMappers));, +                MapperUtils.collect(merged.root, objectMappers, fieldMappers);, +                addMappers(objectMappers, fieldMappers, updateAllTypes);, +++ b/core/src/main/java/org/elasticsearch/index/mapper/DocumentParser.java, +                    update = update.merge(newUpdate, false);, +            mapper = (M) mapper.merge(update, false);, +++ b/core/src/main/java/org/elasticsearch/action/support/replication/TransportReplicationAction.java, +                logger.trace("Retrying operation on replica, action [{}], request [{}]", t, transportReplicaAction, request);, +                        // Forking a thread on local node via transport service so that custom transport service have an, +                        // opportunity to execute custom  logic before the replica operation begins, +                        String extraMessage = "action [" + transportReplicaAction  + "], request[" + request + "]";, +                        TransportChannelResponseHandler<TransportResponse.Empty> handler = TransportChannelResponseHandler.emptyResponseHandler(logger, channel, extraMessage);, +                        transportService.sendRequest(clusterService.localNode(), transportReplicaAction, request, handler);, +++ b/core/src/main/java/org/elasticsearch/cluster/metadata/MetaDataMappingService.java, +                        // this will just throw exceptions in case of problems, +                        existingMapper.merge(newMapper.mapping(), true, request.updateAllTypes());, +++ b/core/src/main/java/org/elasticsearch/index/mapper/DocumentMapper.java, +import java.util.Arrays;, +    private volatile Mapping mapping;, +    public void merge(Mapping mapping, boolean simulate, boolean updateAllTypes) {, +            // do the merge even if simulate == false so that we get exceptions, +            Mapping merged = this.mapping.merge(mapping, updateAllTypes);, +                this.mapping = merged;, +                Collection<ObjectMapper> objectMappers = new ArrayList<>();, +                Collection<FieldMapper> fieldMappers = new ArrayList<>(Arrays.asList(merged.metadataMappers));, +                MapperUtils.collect(merged.root, objectMappers, fieldMappers);, +                addMappers(objectMappers, fieldMappers, updateAllTypes);, +++ b/core/src/main/java/org/elasticsearch/index/mapper/DocumentParser.java, +                    update = update.merge(newUpdate, false);, +            mapper = (M) mapper.merge(update, false);, +++ b/core/src/main/java/org/elasticsearch/index/mapper/FieldMapper.java, +public abstract class FieldMapper extends Mapper implements Cloneable {, +                    IndexOptions options = getDefaultIndexOption();, +                    if (options == IndexOptions.NONE) {, +                        // can happen when an existing type on the same index has disabled indexing, +                        // since we inherit the default field type from the first mapper that is, +                        // created on an index, +                        throw new IllegalArgumentException("mapper [" + name + "] has different [index] values from other types of the same index");, +                    }, +    protected MultiFields multiFields;, +    protected FieldMapper clone() {, +        try {, +            return (FieldMapper) super.clone();, +        } catch (CloneNotSupportedException e) {]