[+++ b/modules/elasticsearch/src/main/java/org/elasticsearch/transport/netty/NettyTransport.java, +import java.util.Map;, +    final ConcurrentMap<DiscoveryNode, Channel> connectedNodes = newConcurrentMap();, +        for (Iterator<Channel> it = connectedNodes.values().iterator(); it.hasNext();) {, +            Channel channel = it.next();, +            closeChannel(channel);, +        if (isCloseConnectionException(e.getCause())) {, +            // disconnect the node, +            Channel channel = ctx.getChannel();, +            for (Map.Entry<DiscoveryNode, Channel> entry : connectedNodes.entrySet()) {, +                if (entry.getValue().equals(channel)) {, +                    disconnectFromNode(entry.getKey());, +                }, +            }, +        } else if (isConnectException(e.getCause())) {, +        // We handle close connection exception in the #exceptionCaught method, which is the main reason we want to add this future, +//        channelFuture.addListener(new ChannelFutureListener() {, +//            @Override public void operationComplete(ChannelFuture future) throws Exception {, +//                if (!future.isSuccess()) {, +//                    // maybe add back the retry?, +//                    TransportResponseHandler handler = transportServiceAdapter.remove(requestId);, +//                    if (handler != null) {, +//                        handler.handleException(new RemoteTransportException("Failed write request", new SendRequestTransportException(node, action, future.getCause())));, +//                    }, +//                }, +//            }, +//        });, +        return connectedNodes.containsKey(node);, +            Channel channel = connectedNodes.get(node);, +            if (channel != null) {, +                channel = connectedNodes.get(node);, +                if (channel != null) {, +                InetSocketAddress address = ((InetSocketTransportAddress) node.address()).address();, +                ChannelFuture connectFuture = clientBootstrap.connect(address);, +                    throw new ConnectTransportException(node, "connect_timeout[" + connectTimeout + "]", connectFuture.getCause());, +                channel = connectFuture.getChannel();, +                channel.getCloseFuture().addListener(new ChannelCloseListener(node));, +                connectedNodes.put(node, channel);, +, +                    logger.debug("Connected to node [{}]", node);, +            }, +        Channel channel = connectedNodes.remove(node);, +        if (channel != null) {, +            try {, +                closeChannel(channel);, +            } finally {, +                logger.debug("Disconnected from [{}]", node);, +                transportServiceAdapter.raiseNodeDisconnected(node);, +            }, +        Channel channel = connectedNodes.get(node);, +    private void closeChannel(Channel channel) {, +        private final DiscoveryNode node;, +        private ChannelCloseListener(DiscoveryNode node) {, +            this.node = node;, +            disconnectFromNode(node);]