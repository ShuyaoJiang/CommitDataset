[+++ b/modules/elasticsearch/src/main/java/org/elasticsearch/index/translog/TranslogService.java, +        this.flushThresholdPeriod = componentSettings.getAsTime("flush_threshold_period", TimeValue.timeValueMinutes(30));, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/index/translog/TranslogService.java, +        this.flushThresholdPeriod = componentSettings.getAsTime("flush_threshold_period", TimeValue.timeValueMinutes(30));, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/indices/memory/IndexingMemoryBufferController.java, +import org.elasticsearch.ElasticSearchException;, +import org.elasticsearch.common.collect.Maps;, +import org.elasticsearch.common.component.AbstractLifecycleComponent;, +import org.elasticsearch.common.unit.TimeValue;, +import org.elasticsearch.index.translog.Translog;, +import org.elasticsearch.threadpool.ThreadPool;, +, +import java.util.Map;, +import java.util.concurrent.ScheduledFuture;, +public class IndexingMemoryBufferController extends AbstractLifecycleComponent<IndexingMemoryBufferController> {, +    private final ThreadPool threadPool;, +, +    private final ByteSizeValue indexingBuffer;, +, +    private final ByteSizeValue inactiveShardIndexBufferSize;, +    private final ByteSizeValue minShardIndexBufferSize;, +    private final ByteSizeValue maxShardIndexBufferSize;, +, +    private final TimeValue inactiveTime;, +    private final TimeValue interval;, +, +    private final Map<ShardId, ShardIndexingStatus> shardsIndicesStatus = Maps.newHashMap();, +, +    private volatile ScheduledFuture scheduler;, +, +    private final Object mutex = new Object();, +, +    @Inject public IndexingMemoryBufferController(Settings settings, ThreadPool threadPool, IndicesService indicesService) {, +        this.threadPool = threadPool;, +        this.inactiveShardIndexBufferSize = componentSettings.getAsBytesSize("inactive_shard_index_buffer_size", new ByteSizeValue(1, ByteSizeUnit.MB));, +        this.inactiveTime = componentSettings.getAsTime("shard_inactive_time", TimeValue.timeValueMinutes(30));, +        // we need to have this relatively small to move a shard from inactive to active fast (enough), +        this.interval = componentSettings.getAsTime("interval", TimeValue.timeValueSeconds(30));, +        logger.debug("using index_buffer_size [{}], with min_shard_index_buffer_size [{}], max_shard_index_buffer_size [{}], inactive_shard_index_buffer_size [{}], shard_inactive_time [{}]", this.indexingBuffer, this.minShardIndexBufferSize, this.maxShardIndexBufferSize, this.inactiveShardIndexBufferSize, this.inactiveTime);, +, +    @Override protected void doStart() throws ElasticSearchException {, +        indicesService.indicesLifecycle().addListener(listener);, +        // its fine to run it on the scheduler thread, no busy work, +        this.scheduler = threadPool.scheduleWithFixedDelay(new ShardsIndicesStatusChecker(), interval);, +    }, +, +    @Override protected void doStop() throws ElasticSearchException {, +        indicesService.indicesLifecycle().removeListener(listener);, +        if (scheduler != null) {, +            scheduler.cancel(false);, +            scheduler = null;, +        }, +    }, +, +    @Override protected void doClose() throws ElasticSearchException {, +    }, +, +    class ShardsIndicesStatusChecker implements Runnable {, +        @Override public void run() {, +            synchronized (mutex) {, +                boolean activeInactiveStatusChanges = false;, +                long time = System.currentTimeMillis();, +                for (IndexService indexService : indicesService) {, +                    for (IndexShard indexShard : indexService) {, +                        Translog translog = ((InternalIndexShard) indexShard).translog();, +                        ShardIndexingStatus status = shardsIndicesStatus.get(indexShard.shardId());, +                        if (status == null) { // not added yet, +                            continue;, +                        }, +                        // check if it is deemed to be inactive (sam translogId and numberOfOperations over a long period of time), +                        if (status.translogId == translog.currentId() && translog.numberOfOperations() == 0) {, +                            if (status.time == -1) { // first time, +                                status.time = time;, +                            }, +                            // inactive?, +                            if (!status.inactive) {, +                                if ((time - status.time) > inactiveTime.millis()) {, +                                    // inactive for this amount of time, mark it, +                                    status.inactive = true;, +                                    activeInactiveStatusChanges = true;, +                                    logger.debug("marking shard [{}][{}] as inactive (inactive_time[{}]), setting size to [{}]", indexShard.shardId().index().name(), indexShard.shardId().id(), inactiveTime, inactiveShardIndexBufferSize);, +                                    ((InternalIndexShard) indexShard).engine().updateIndexingBufferSize(inactiveShardIndexBufferSize);, +                                }, +                            }, +                        } else {, +                            if (status.inactive) {, +                                status.inactive = false;, +                                activeInactiveStatusChanges = true;, +                                logger.debug("marking shard [{}][{}] as active", indexShard.shardId().index().name(), indexShard.shardId().id());, +                            }, +                            status.time = -1;, +                        }, +                        status.translogId = translog.currentId();, +                        status.translogNumberOfOperations = translog.numberOfOperations();, +                    }, +                }, +                if (activeInactiveStatusChanges) {, +                    calcAndSetShardIndexingBuffer("shards became active/inactive");, +                }, +            }]