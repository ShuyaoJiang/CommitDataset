[+++ b/build.gradle, +final boolean bwc_tests_enabled = true, +final String bwc_tests_disabled_issue = "" /* place a PR link here when committing bwc changes */, +++ b/build.gradle, +final boolean bwc_tests_enabled = true, +final String bwc_tests_disabled_issue = "" /* place a PR link here when committing bwc changes */, +++ b/buildSrc/build.gradle, +    String qualifier = systemProperties.getProperty("build.version_qualifier", "");, +++ b/build.gradle, +final boolean bwc_tests_enabled = true, +final String bwc_tests_disabled_issue = "" /* place a PR link here when committing bwc changes */, +++ b/buildSrc/build.gradle, +    String qualifier = systemProperties.getProperty("build.version_qualifier", "");, +++ b/buildSrc/src/main/resources/checkstyle_suppressions.xml, +++ b/build.gradle, +final boolean bwc_tests_enabled = true, +final String bwc_tests_disabled_issue = "" /* place a PR link here when committing bwc changes */, +++ b/buildSrc/build.gradle, +    String qualifier = systemProperties.getProperty("build.version_qualifier", "");, +++ b/buildSrc/src/main/resources/checkstyle_suppressions.xml, +++ b/buildSrc/version.properties, +lucene            = 8.0.0-snapshot-6d9c714052, +++ b/build.gradle, +final boolean bwc_tests_enabled = true, +final String bwc_tests_disabled_issue = "" /* place a PR link here when committing bwc changes */, +++ b/buildSrc/build.gradle, +    String qualifier = systemProperties.getProperty("build.version_qualifier", "");, +++ b/buildSrc/src/main/resources/checkstyle_suppressions.xml, +++ b/buildSrc/version.properties, +lucene            = 8.0.0-snapshot-6d9c714052, +++ b/client/rest-high-level/src/main/java/org/elasticsearch/client/RestHighLevelClient.java, +     * Defines a helper method for requests that can 404 and in which case will return an empty Optional , +     * otherwise tries to parse the response body, +     */, +    protected final <Req extends Validatable, Resp> Optional<Resp> performRequestAndParseOptionalEntity(Req request,, +                                                                  CheckedFunction<Req, Request, IOException> requestConverter,, +                                                                  RequestOptions options,, +                                                                  CheckedFunction<XContentParser, Resp, IOException> entityParser, +                                                                  ) throws IOException {, +        Optional<ValidationException> validationException = request.validate();, +        if (validationException != null && validationException.isPresent()) {, +            throw validationException.get();, +        }, +        Request req = requestConverter.apply(request);, +        req.setOptions(options);, +        Response response;, +        try {, +            response = client.performRequest(req);, +        } catch (ResponseException e) {, +            if (RestStatus.NOT_FOUND.getStatus() == e.getResponse().getStatusLine().getStatusCode()) {, +                return Optional.empty();, +            }, +            throw parseResponseException(e);, +        }, +, +        try {, +            return Optional.of(parseEntity(response.getEntity(), entityParser));, +        } catch (Exception e) {, +            throw new IOException("Unable to parse response body for " + response, e);, +        }, +    }      , +, +    /**, +     * Async request which returns empty Optionals in the case of 404s or parses entity into an Optional, +     */, +    protected final <Req extends Validatable, Resp> void performRequestAsyncAndParseOptionalEntity(Req request,, +            CheckedFunction<Req, Request, IOException> requestConverter,, +            RequestOptions options,, +            CheckedFunction<XContentParser, Resp, IOException> entityParser,, +            ActionListener<Optional<Resp>> listener) {, +        Optional<ValidationException> validationException = request.validate();, +        if (validationException != null && validationException.isPresent()) {, +            listener.onFailure(validationException.get());, +            return;, +        }, +        Request req;, +        try {, +            req = requestConverter.apply(request);, +        } catch (Exception e) {, +            listener.onFailure(e);, +            return;, +        }, +        req.setOptions(options);, +        ResponseListener responseListener = wrapResponseListener404sOptional(response -> parseEntity(response.getEntity(), , +                entityParser), listener);, +        client.performRequestAsync(req, responseListener);        , +    }    , +    , +    final <Resp> ResponseListener wrapResponseListener404sOptional(CheckedFunction<Response, Resp, IOException> responseConverter,, +            ActionListener<Optional<Resp>> actionListener) {, +        return new ResponseListener() {, +            @Override, +            public void onSuccess(Response response) {, +                try {, +                    actionListener.onResponse(Optional.of(responseConverter.apply(response)));, +                } catch (Exception e) {, +                    IOException ioe = new IOException("Unable to parse response body for " + response, e);, +                    onFailure(ioe);, +                }, +            }]