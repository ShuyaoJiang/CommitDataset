[+++ b/docs/reference/index-modules/allocation.asciidoc, +, +By default, Elasticsearch will take into account shards that are currently being, +relocated to the target node when computing a node's disk usage. This can be, +changed by setting the `cluster.routing.allocation.disk.include_relocations`, +setting to `false` (defaults to `true`). Taking relocating shards' sizes into, +account may, however, mean that the disk usage for a node is incorrectly, +estimated on the high side, since the relocation could be 90% complete and a, +recently retrieved disk usage would include the total size of the relocating, +shard as well as the space already used by the running relocation., +++ b/docs/reference/index-modules/allocation.asciidoc, +, +By default, Elasticsearch will take into account shards that are currently being, +relocated to the target node when computing a node's disk usage. This can be, +changed by setting the `cluster.routing.allocation.disk.include_relocations`, +setting to `false` (defaults to `true`). Taking relocating shards' sizes into, +account may, however, mean that the disk usage for a node is incorrectly, +estimated on the high side, since the relocation could be 90% complete and a, +recently retrieved disk usage would include the total size of the relocating, +shard as well as the space already used by the running relocation., +++ b/src/main/java/org/elasticsearch/cluster/routing/allocation/decider/DiskThresholdDecider.java, +import org.elasticsearch.cluster.routing.ShardRoutingState;, +import java.util.List;, +    private volatile boolean includeRelocations;, +    public static final String CLUSTER_ROUTING_ALLOCATION_INCLUDE_RELOCATIONS = "cluster.routing.allocation.disk.include_relocations";, +            Boolean newRelocationsSetting = settings.getAsBoolean(CLUSTER_ROUTING_ALLOCATION_INCLUDE_RELOCATIONS, null);, +            if (newRelocationsSetting != null) {, +                logger.info("updating [{}] from [{}] to [{}]", CLUSTER_ROUTING_ALLOCATION_INCLUDE_RELOCATIONS,, +                        DiskThresholdDecider.this.includeRelocations, newRelocationsSetting);, +                DiskThresholdDecider.this.includeRelocations = newRelocationsSetting;, +            }, +        this.includeRelocations = settings.getAsBoolean(CLUSTER_ROUTING_ALLOCATION_INCLUDE_RELOCATIONS, true);, +    /**, +     * Returns the size of all shards that are currently being relocated to, +     * the node, but may not be finished transfering yet., +     */, +    public long sizeOfRelocatingShards(RoutingNode node, RoutingAllocation allocation, Map<String, Long> shardSizes) {, +        List<ShardRouting> relocatingShards = allocation.routingTable().shardsWithState(ShardRoutingState.RELOCATING);, +        long totalSize = 0;, +        for (ShardRouting routing : relocatingShards) {, +            if (routing.relocatingNodeId().equals(node.nodeId())) {, +                Long shardSize = shardSizes.get(shardIdentifierFromRouting(routing));, +                shardSize = shardSize == null ? 0 : shardSize;, +                totalSize += shardSize;, +            }, +        }, +        return totalSize;, +    }, +, +        if (includeRelocations) {, +            long relocatingShardsSize = sizeOfRelocatingShards(node, allocation, shardSizes);, +            DiskUsage usageIncludingRelocations = new DiskUsage(node.nodeId(), usage.getTotalBytes(), usage.getFreeBytes() - relocatingShardsSize);, +            if (logger.isDebugEnabled()) {, +                logger.debug("usage without relocations: {}", usage);, +                logger.debug("usage with relocations: [{} bytes] {}", relocatingShardsSize, usageIncludingRelocations);, +            }, +            usage = usageIncludingRelocations;, +        }, +, +                        freeDiskThresholdLow, freeDiskPercentage);, +                        freeDiskThresholdLow, freeDiskPercentage);, +        if (includeRelocations) {, +            Map<String, Long> shardSizes = clusterInfo.getShardSizes();, +            long relocatingShardsSize = sizeOfRelocatingShards(node, allocation, shardSizes);, +            DiskUsage usageIncludingRelocations = new DiskUsage(node.nodeId(), usage.getTotalBytes(), usage.getFreeBytes() - relocatingShardsSize);, +            if (logger.isDebugEnabled()) {, +                logger.debug("usage without relocations: {}", usage);, +                logger.debug("usage with relocations: [{} bytes] {}", relocatingShardsSize, usageIncludingRelocations);, +            }, +            usage = usageIncludingRelocations;, +        }, +, +++ b/docs/reference/index-modules/allocation.asciidoc, +, +By default, Elasticsearch will take into account shards that are currently being, +relocated to the target node when computing a node's disk usage. This can be, +changed by setting the `cluster.routing.allocation.disk.include_relocations`, +setting to `false` (defaults to `true`). Taking relocating shards' sizes into, +account may, however, mean that the disk usage for a node is incorrectly, +estimated on the high side, since the relocation could be 90% complete and a, +recently retrieved disk usage would include the total size of the relocating, +shard as well as the space already used by the running relocation., +++ b/src/main/java/org/elasticsearch/cluster/routing/allocation/decider/DiskThresholdDecider.java, +import org.elasticsearch.cluster.routing.ShardRoutingState;, +import java.util.List;, +    private volatile boolean includeRelocations;, +    public static final String CLUSTER_ROUTING_ALLOCATION_INCLUDE_RELOCATIONS = "cluster.routing.allocation.disk.include_relocations";, +            Boolean newRelocationsSetting = settings.getAsBoolean(CLUSTER_ROUTING_ALLOCATION_INCLUDE_RELOCATIONS, null);, +            if (newRelocationsSetting != null) {, +                logger.info("updating [{}] from [{}] to [{}]", CLUSTER_ROUTING_ALLOCATION_INCLUDE_RELOCATIONS,, +                        DiskThresholdDecider.this.includeRelocations, newRelocationsSetting);, +                DiskThresholdDecider.this.includeRelocations = newRelocationsSetting;, +            }, +        this.includeRelocations = settings.getAsBoolean(CLUSTER_ROUTING_ALLOCATION_INCLUDE_RELOCATIONS, true);, +    /**, +     * Returns the size of all shards that are currently being relocated to, +     * the node, but may not be finished transfering yet., +     */, +    public long sizeOfRelocatingShards(RoutingNode node, RoutingAllocation allocation, Map<String, Long> shardSizes) {, +        List<ShardRouting> relocatingShards = allocation.routingTable().shardsWithState(ShardRoutingState.RELOCATING);]