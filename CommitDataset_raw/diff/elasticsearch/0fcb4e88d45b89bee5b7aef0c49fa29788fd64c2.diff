[+++ b/modules/benchmark/micro/src/main/java/org/elasticsearch/benchmark/index/engine/SimpleEngineBenchmark.java, +import java.util.concurrent.CountDownLatch;, +import java.util.concurrent.CyclicBarrier;, +import java.util.concurrent.Executors;, +import java.util.concurrent.ScheduledExecutorService;, +import java.util.concurrent.TimeUnit;, +            ParsedDocument pDoc = new ParsedDocument(sId, sId, "type", null, -1, -1, doc, Lucene.STANDARD_ANALYZER, TRANSLOG_PAYLOAD, false);, +                    ParsedDocument pDoc = new ParsedDocument(sId, sId, "type", null, -1, -1, doc, Lucene.STANDARD_ANALYZER, TRANSLOG_PAYLOAD, false);, +++ b/modules/benchmark/micro/src/main/java/org/elasticsearch/benchmark/index/engine/SimpleEngineBenchmark.java, +import java.util.concurrent.CountDownLatch;, +import java.util.concurrent.CyclicBarrier;, +import java.util.concurrent.Executors;, +import java.util.concurrent.ScheduledExecutorService;, +import java.util.concurrent.TimeUnit;, +            ParsedDocument pDoc = new ParsedDocument(sId, sId, "type", null, -1, -1, doc, Lucene.STANDARD_ANALYZER, TRANSLOG_PAYLOAD, false);, +                    ParsedDocument pDoc = new ParsedDocument(sId, sId, "type", null, -1, -1, doc, Lucene.STANDARD_ANALYZER, TRANSLOG_PAYLOAD, false);, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/action/bulk/BulkRequest.java, +import org.elasticsearch.common.unit.TimeValue;, +                        if (parser.currentToken() == XContentParser.Token.VALUE_STRING) {, +                            ttl = TimeValue.parseTimeValue(parser.text(), null).millis();, +                        } else {, +                        }, +++ b/modules/benchmark/micro/src/main/java/org/elasticsearch/benchmark/index/engine/SimpleEngineBenchmark.java, +import java.util.concurrent.CountDownLatch;, +import java.util.concurrent.CyclicBarrier;, +import java.util.concurrent.Executors;, +import java.util.concurrent.ScheduledExecutorService;, +import java.util.concurrent.TimeUnit;, +            ParsedDocument pDoc = new ParsedDocument(sId, sId, "type", null, -1, -1, doc, Lucene.STANDARD_ANALYZER, TRANSLOG_PAYLOAD, false);, +                    ParsedDocument pDoc = new ParsedDocument(sId, sId, "type", null, -1, -1, doc, Lucene.STANDARD_ANALYZER, TRANSLOG_PAYLOAD, false);, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/action/bulk/BulkRequest.java, +import org.elasticsearch.common.unit.TimeValue;, +                        if (parser.currentToken() == XContentParser.Token.VALUE_STRING) {, +                            ttl = TimeValue.parseTimeValue(parser.text(), null).millis();, +                        } else {, +                        }, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/indices/ttl/IndicesTTLService.java, +import org.elasticsearch.cluster.metadata.MetaData;, +import org.elasticsearch.node.settings.NodeSettingsService;, +    static {, +        MetaData.addDynamicSettings(, +                "indices.ttl.interval", +        );, +    }, +    private volatile TimeValue interval;, +    @Inject public IndicesTTLService(Settings settings, IndicesService indicesService, NodeSettingsService nodeSettingsService, Client client) {, +        this.interval = componentSettings.getAsTime("interval", TimeValue.timeValueSeconds(60));, +        this.bulkSize = componentSettings.getAsInt("bulk_size", 10000);, +, +        nodeSettingsService.addListener(new ApplySettings());, +        this.purgerThread = new PurgerThread(EsExecutors.threadName(settings, "[ttl_expire]"));, +        this.purgerThread.interrupt();, +                try {, +                } catch (Throwable e) {, +                    if (running) {, +                        logger.warn("failed to execute ttl purge", e);, +                    }, +                }, +                    Thread.sleep(interval.millis());, +                    // ignore, if we are interrupted because we are shutting down, running will be false, +                if (hasTTLEnabled) {, +                    for (IndexShard indexShard : indexService) {, +                        if (indexShard.routingEntry().primary() && indexShard.state() == IndexShardState.STARTED && indexShard.routingEntry().started()) {, +                            shardsToPurge.add(indexShard);, +                BulkRequestBuilder bulkRequest = client.prepareBulk();, +                    bulkRequest = processBulkIfNeeded(bulkRequest, false);, +                processBulkIfNeeded(bulkRequest, true);, +    private BulkRequestBuilder processBulkIfNeeded(BulkRequestBuilder bulkRequest, boolean force) {, +                        logger.trace("bulk took " + bulkResponse.getTookInMillis() + "ms");, +        return bulkRequest;, +    }, +, +    class ApplySettings implements NodeSettingsService.Listener {, +        @Override public void onRefreshSettings(Settings settings) {, +            TimeValue interval = settings.getAsTime("indices.ttl.interval", IndicesTTLService.this.interval);, +            if (!interval.equals(IndicesTTLService.this.interval)) {, +                logger.info("updating indices.ttl.interval from [{}] to [{}]", IndicesTTLService.this.interval, interval);, +                IndicesTTLService.this.interval = interval;, +            }, +        }, +++ b/modules/benchmark/micro/src/main/java/org/elasticsearch/benchmark/index/engine/SimpleEngineBenchmark.java, +import java.util.concurrent.CountDownLatch;, +import java.util.concurrent.CyclicBarrier;, +import java.util.concurrent.Executors;, +import java.util.concurrent.ScheduledExecutorService;, +import java.util.concurrent.TimeUnit;, +            ParsedDocument pDoc = new ParsedDocument(sId, sId, "type", null, -1, -1, doc, Lucene.STANDARD_ANALYZER, TRANSLOG_PAYLOAD, false);, +                    ParsedDocument pDoc = new ParsedDocument(sId, sId, "type", null, -1, -1, doc, Lucene.STANDARD_ANALYZER, TRANSLOG_PAYLOAD, false);, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/action/bulk/BulkRequest.java, +import org.elasticsearch.common.unit.TimeValue;, +                        if (parser.currentToken() == XContentParser.Token.VALUE_STRING) {, +                            ttl = TimeValue.parseTimeValue(parser.text(), null).millis();, +                        } else {, +                        }, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/indices/ttl/IndicesTTLService.java, +import org.elasticsearch.cluster.metadata.MetaData;, +import org.elasticsearch.node.settings.NodeSettingsService;, +    static {, +        MetaData.addDynamicSettings(, +                "indices.ttl.interval"]