[+++ b/src/main/java/org/elasticsearch/index/fielddata/BytesValues.java, +import org.elasticsearch.index.fielddata.ordinals.Ordinals.Docs;, +import org.elasticsearch.index.fielddata.util.IntArrayRef;, +public abstract class  BytesValues {, +    public static final BytesValues EMPTY = new Empty();, +    private boolean multiValued;, +    protected final BytesRef scratch = new BytesRef();, +    , +    protected BytesValues(boolean multiValued) {, +        this.multiValued = multiValued;, +    }, +    public final boolean isMultiValued() {, +        return multiValued;, +    }, +    public abstract boolean hasValue(int docId);, +    public BytesRef makeSafe(BytesRef bytes) {, +        return BytesRef.deepCopyOf(bytes);, +    }, +    public BytesRef getValue(int docId) {, +        if (hasValue(docId)) {, +            return getValueScratch(docId, scratch);, +        } , +        return null;, +    }, +    public abstract BytesRef getValueScratch(int docId, BytesRef ret);, +    public abstract BytesRefArrayRef getValues(int docId);, +    public abstract Iter getIter(int docId);, +    , +    , +    public abstract void forEachValueInDoc(int docId, ValueInDocProc proc);, +    public static interface Iter {, +        public static class Empty implements Iter {, +        public final static class Single implements Iter {, +        , +        static final class Multi implements Iter {, +, +            private int ord;, +            private BytesValues.WithOrdinals withOrds;, +            private Ordinals.Docs.Iter ordsIter;, +            private final BytesRef scratch = new BytesRef();, +            public Multi(WithOrdinals withOrds) {, +                this.withOrds = withOrds;, +                assert withOrds.isMultiValued();, +                , +            public Multi reset(Ordinals.Docs.Iter ordsIter) {, +                this.ordsIter = ordsIter;, +                this.ord = ordsIter.next();, +                return this;, +            }, +, +            public boolean hasNext() {, +                return ord != 0;, +            }, +, +            @Override, +            public BytesRef next() {, +                withOrds.getValueScratchByOrd(ord, scratch);, +                ord = ordsIter.next();, +                return scratch;, +            }, +        }, +    }, +, +    public static class Empty extends BytesValues {, +        , +        public Empty() {, +            super(false);, +    public static class StringBased extends BytesValues {, +, +            super(values.isMultiValued());, +        public  static class ValueIter implements Iter {, +        public static class Proc implements StringValues.ValueInDocProc {, +    public static abstract class WithOrdinals extends BytesValues {, +        protected final Docs ordinals;, +        protected final BytesRefArrayRef arrayScratch = new BytesRefArrayRef(new BytesRef[10], 0);, +        protected WithOrdinals(Ordinals.Docs ordinals) {, +            super(ordinals.isMultiValued());, +            this.ordinals = ordinals;, +        }, +, +        public Ordinals.Docs ordinals() {, +            return ordinals;, +        }, +, +        public BytesRef getValueByOrd(int ord) {, +            return getValueScratchByOrd(ord, scratch);, +        }, +, +        @Override, +        public boolean hasValue(int docId) {, +            return ordinals.getOrd(docId) != 0;, +        }, +        , +        @Override, +        public BytesRefArrayRef getValues(int docId) {, +            assert !isMultiValued();, +            int ord = ordinals.getOrd(docId);, +            if (ord == 0) return BytesRefArrayRef.EMPTY;, +            arrayScratch.values[0] = getSafeValueByOrd(ord);, +            arrayScratch.end = 1;]