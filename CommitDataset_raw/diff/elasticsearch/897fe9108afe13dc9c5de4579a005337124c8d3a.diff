[+++ b/core/src/main/java/org/elasticsearch/common/util/iterable/Iterables.java, +    /** Flattens the two level {@code Iterable} into a single {@code Iterable}.  Note that this pre-caches the values from the outer {@code, +     *  Iterable}, but not the values from the inner one. */, +++ b/core/src/main/java/org/elasticsearch/common/util/iterable/Iterables.java, +    /** Flattens the two level {@code Iterable} into a single {@code Iterable}.  Note that this pre-caches the values from the outer {@code, +     *  Iterable}, but not the values from the inner one. */, +++ b/core/src/main/java/org/elasticsearch/indices/IndexingMemoryController.java, +            assert totalBytes >= 0;, +, +                        // Must pull this again because it may have changed since we first checked:, +                        totalBytes = bytesWrittenSinceCheck.get();, +                        if (totalBytes > indexingBuffer.bytes()/30) {, +                        }, +, +                    // Must get it again since other threads could have increased it while we were in runUnlocked, +                    totalBytes = bytesWrittenSinceCheck.get();, +                    // Another thread beat us to it: let them do all the work, yay!, +++ b/core/src/main/java/org/elasticsearch/common/util/iterable/Iterables.java, +    /** Flattens the two level {@code Iterable} into a single {@code Iterable}.  Note that this pre-caches the values from the outer {@code, +     *  Iterable}, but not the values from the inner one. */, +++ b/core/src/main/java/org/elasticsearch/indices/IndexingMemoryController.java, +            assert totalBytes >= 0;, +, +                        // Must pull this again because it may have changed since we first checked:, +                        totalBytes = bytesWrittenSinceCheck.get();, +                        if (totalBytes > indexingBuffer.bytes()/30) {, +                        }, +, +                    // Must get it again since other threads could have increased it while we were in runUnlocked, +                    totalBytes = bytesWrittenSinceCheck.get();, +                    // Another thread beat us to it: let them do all the work, yay!, +++ b/core/src/main/java/org/elasticsearch/indices/IndicesService.java, +        indexingMemoryController = new IndexingMemoryController(settings, threadPool,, +                                                                // ensure we pull an iter with new shards - flatten makes a copy, +                                                                () -> Iterables.flatten(this).iterator());, +++ b/core/src/main/java/org/elasticsearch/common/util/iterable/Iterables.java, +    /** Flattens the two level {@code Iterable} into a single {@code Iterable}.  Note that this pre-caches the values from the outer {@code, +     *  Iterable}, but not the values from the inner one. */, +++ b/core/src/main/java/org/elasticsearch/indices/IndexingMemoryController.java, +            assert totalBytes >= 0;, +, +                        // Must pull this again because it may have changed since we first checked:, +                        totalBytes = bytesWrittenSinceCheck.get();, +                        if (totalBytes > indexingBuffer.bytes()/30) {, +                        }, +, +                    // Must get it again since other threads could have increased it while we were in runUnlocked, +                    totalBytes = bytesWrittenSinceCheck.get();, +                    // Another thread beat us to it: let them do all the work, yay!, +++ b/core/src/main/java/org/elasticsearch/indices/IndicesService.java, +        indexingMemoryController = new IndexingMemoryController(settings, threadPool,, +                                                                // ensure we pull an iter with new shards - flatten makes a copy, +                                                                () -> Iterables.flatten(this).iterator());, +++ b/core/src/test/java/org/elasticsearch/common/util/iterable/IterablesTests.java, +import java.util.ArrayList;, +import java.util.List;, +import org.elasticsearch.test.ESTestCase;, +, +    public void testFlatten() {, +        List<List<Integer>> list = new ArrayList<>();, +        list.add(new ArrayList<>());, +, +        Iterable<Integer> allInts = Iterables.flatten(list);, +        int count = 0;, +        for(int x : allInts) {, +            count++;, +        }, +        assertEquals(0, count);, +        list.add(new ArrayList<>());, +        list.get(1).add(0);, +, +        // changes to the outer list are not seen since flatten pre-caches outer list on init:, +        count = 0;, +        for(int x : allInts) {, +            count++;, +        }, +        assertEquals(0, count);, +, +        // but changes to the original inner lists are seen:, +        list.get(0).add(0);, +        for(int x : allInts) {, +            count++;, +        }, +        assertEquals(1, count);, +    }, +, +++ b/core/src/main/java/org/elasticsearch/common/util/iterable/Iterables.java, +    /** Flattens the two level {@code Iterable} into a single {@code Iterable}.  Note that this pre-caches the values from the outer {@code, +     *  Iterable}, but not the values from the inner one. */, +++ b/core/src/main/java/org/elasticsearch/indices/IndexingMemoryController.java, +            assert totalBytes >= 0;, +, +                        // Must pull this again because it may have changed since we first checked:, +                        totalBytes = bytesWrittenSinceCheck.get();, +                        if (totalBytes > indexingBuffer.bytes()/30) {, +                        }, +, +                    // Must get it again since other threads could have increased it while we were in runUnlocked, +                    totalBytes = bytesWrittenSinceCheck.get();, +                    // Another thread beat us to it: let them do all the work, yay!]