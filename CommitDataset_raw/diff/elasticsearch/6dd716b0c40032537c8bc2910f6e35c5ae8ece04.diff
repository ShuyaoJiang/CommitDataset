[+++ b/server/src/main/java/org/elasticsearch/indices/IndicesRequestCache.java, +import java.util.Objects;, + * with the semantics of NRT (the index reader cache key is part of the cache key), and relies on size based, +        keysToClean.add(new CleanupKey(entity, null));, +        assert reader.getReaderCacheHelper() != null;, +        final Key key =  new Key(cacheEntity, reader.getReaderCacheHelper().getKey(), cacheKey);, +            CleanupKey cleanupKey = new CleanupKey(cacheEntity, reader.getReaderCacheHelper().getKey());, +        assert reader.getReaderCacheHelper() != null;, +        cache.invalidate(new Key(cacheEntity, reader.getReaderCacheHelper().getKey(), cacheKey));, +        public final IndexReader.CacheKey readerCacheKey;, +        Key(CacheEntity entity, IndexReader.CacheKey readerCacheKey, BytesReference value) {, +            this.readerCacheKey = Objects.requireNonNull(readerCacheKey);, +            if (Objects.equals(readerCacheKey, key.readerCacheKey) == false) return false;, +            result = 31 * result + readerCacheKey.hashCode();, +        final IndexReader.CacheKey readerCacheKey;, +        private CleanupKey(CacheEntity entity, IndexReader.CacheKey readerCacheKey) {, +            this.readerCacheKey = readerCacheKey;, +            if (Objects.equals(readerCacheKey, that.readerCacheKey) == false) return false;, +            result = 31 * result + Objects.hashCode(readerCacheKey);, +            if (cleanupKey.readerCacheKey == null || cleanupKey.entity.isOpen() == false) {, +                    if (currentKeysToClean.contains(new CleanupKey(key.entity, key.readerCacheKey))) {, +++ b/server/src/main/java/org/elasticsearch/indices/IndicesRequestCache.java, +import java.util.Objects;, + * with the semantics of NRT (the index reader cache key is part of the cache key), and relies on size based, +        keysToClean.add(new CleanupKey(entity, null));, +        assert reader.getReaderCacheHelper() != null;, +        final Key key =  new Key(cacheEntity, reader.getReaderCacheHelper().getKey(), cacheKey);, +            CleanupKey cleanupKey = new CleanupKey(cacheEntity, reader.getReaderCacheHelper().getKey());, +        assert reader.getReaderCacheHelper() != null;, +        cache.invalidate(new Key(cacheEntity, reader.getReaderCacheHelper().getKey(), cacheKey));, +        public final IndexReader.CacheKey readerCacheKey;, +        Key(CacheEntity entity, IndexReader.CacheKey readerCacheKey, BytesReference value) {, +            this.readerCacheKey = Objects.requireNonNull(readerCacheKey);, +            if (Objects.equals(readerCacheKey, key.readerCacheKey) == false) return false;, +            result = 31 * result + readerCacheKey.hashCode();, +        final IndexReader.CacheKey readerCacheKey;, +        private CleanupKey(CacheEntity entity, IndexReader.CacheKey readerCacheKey) {, +            this.readerCacheKey = readerCacheKey;, +            if (Objects.equals(readerCacheKey, that.readerCacheKey) == false) return false;, +            result = 31 * result + Objects.hashCode(readerCacheKey);, +            if (cleanupKey.readerCacheKey == null || cleanupKey.entity.isOpen() == false) {, +                    if (currentKeysToClean.contains(new CleanupKey(key.entity, key.readerCacheKey))) {, +++ b/server/src/main/java/org/elasticsearch/indices/IndicesService.java, +        // We use the cacheKey of the index reader as a part of a key of the IndicesRequestCache., +        assert context.searcher().getIndexReader().getReaderCacheHelper() != null;, +, +++ b/server/src/main/java/org/elasticsearch/indices/IndicesRequestCache.java, +import java.util.Objects;, + * with the semantics of NRT (the index reader cache key is part of the cache key), and relies on size based, +        keysToClean.add(new CleanupKey(entity, null));, +        assert reader.getReaderCacheHelper() != null;, +        final Key key =  new Key(cacheEntity, reader.getReaderCacheHelper().getKey(), cacheKey);, +            CleanupKey cleanupKey = new CleanupKey(cacheEntity, reader.getReaderCacheHelper().getKey());, +        assert reader.getReaderCacheHelper() != null;, +        cache.invalidate(new Key(cacheEntity, reader.getReaderCacheHelper().getKey(), cacheKey));, +        public final IndexReader.CacheKey readerCacheKey;, +        Key(CacheEntity entity, IndexReader.CacheKey readerCacheKey, BytesReference value) {, +            this.readerCacheKey = Objects.requireNonNull(readerCacheKey);, +            if (Objects.equals(readerCacheKey, key.readerCacheKey) == false) return false;, +            result = 31 * result + readerCacheKey.hashCode();, +        final IndexReader.CacheKey readerCacheKey;, +        private CleanupKey(CacheEntity entity, IndexReader.CacheKey readerCacheKey) {, +            this.readerCacheKey = readerCacheKey;, +            if (Objects.equals(readerCacheKey, that.readerCacheKey) == false) return false;, +            result = 31 * result + Objects.hashCode(readerCacheKey);, +            if (cleanupKey.readerCacheKey == null || cleanupKey.entity.isOpen() == false) {, +                    if (currentKeysToClean.contains(new CleanupKey(key.entity, key.readerCacheKey))) {, +++ b/server/src/main/java/org/elasticsearch/indices/IndicesService.java, +        // We use the cacheKey of the index reader as a part of a key of the IndicesRequestCache., +        assert context.searcher().getIndexReader().getReaderCacheHelper() != null;, +, +++ b/server/src/test/java/org/elasticsearch/index/shard/IndexShardIT.java, +import org.elasticsearch.action.search.SearchRequest;, +import org.elasticsearch.search.builder.SearchSourceBuilder;, +    public void testInvalidateIndicesRequestCacheWhenRollbackEngine() throws Exception {, +        createIndex("test", Settings.builder().put("index.number_of_shards", 1).put("index.number_of_replicas", 0), +            .put("index.refresh_interval", -1).build());, +        ensureGreen();, +        final IndicesService indicesService = getInstanceFromNode(IndicesService.class);, +        final IndexShard shard = indicesService.getShardOrNull(new ShardId(resolveIndex("test"), 0));, +        final SearchRequest countRequest = new SearchRequest("test").source(new SearchSourceBuilder().size(0));, +        final long numDocs = between(10, 20);, +        for (int i = 0; i < numDocs; i++) {, +            client().prepareIndex("test", "_doc", Integer.toString(i)).setSource("{}", XContentType.JSON).get();, +            if (randomBoolean()) {, +                shard.refresh("test");, +            }, +        }, +        shard.refresh("test");, +        assertThat(client().search(countRequest).actionGet().getHits().totalHits, equalTo(numDocs));, +        assertThat(shard.getLocalCheckpoint(), equalTo(shard.seqNoStats().getMaxSeqNo()));, +        shard.resetEngineToGlobalCheckpoint();, +        final long moreDocs = between(10, 20);, +        for (int i = 0; i < moreDocs; i++) {, +            client().prepareIndex("test", "_doc", Long.toString(i + numDocs)).setSource("{}", XContentType.JSON).get();, +            if (randomBoolean()) {, +                shard.refresh("test");, +            }, +        }, +        shard.refresh("test");]