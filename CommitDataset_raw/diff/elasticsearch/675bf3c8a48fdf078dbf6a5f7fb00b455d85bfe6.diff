[+++ b/client/rest-high-level/build.gradle, +  // Needed for serialization tests: , +  // (In order to serialize a server side class to a client side class or the other way around), +  testCompile "org.elasticsearch.plugin:x-pack-core:${version}", +++ b/client/rest-high-level/build.gradle, +  // Needed for serialization tests: , +  // (In order to serialize a server side class to a client side class or the other way around), +  testCompile "org.elasticsearch.plugin:x-pack-core:${version}", +++ b/client/rest-high-level/src/test/java/org/elasticsearch/client/ccr/CcrStatsResponseTests.java, +import org.elasticsearch.client.AbstractResponseTestCase;, +import org.elasticsearch.common.xcontent.XContentParser;, +import org.elasticsearch.xpack.core.ccr.ShardFollowNodeTaskStatus;, +import org.elasticsearch.xpack.core.ccr.action.CcrStatsAction;, +import org.elasticsearch.xpack.core.ccr.action.FollowStatsAction;, +import java.util.Collections;, +public class CcrStatsResponseTests extends AbstractResponseTestCase<CcrStatsAction.Response, CcrStatsResponse> {, +    @Override, +    protected CcrStatsAction.Response createServerTestInstance() {, +        org.elasticsearch.xpack.core.ccr.AutoFollowStats autoFollowStats = new org.elasticsearch.xpack.core.ccr.AutoFollowStats(, +            randomNonNegativeLong(),, +            randomNonNegativeLong(),, +            randomNonNegativeLong(),, +            randomReadExceptions(),, +            randomTrackingClusters(), +        );, +        FollowStatsAction.StatsResponses statsResponse = createStatsResponse();, +        return new CcrStatsAction.Response(autoFollowStats, statsResponse);, +    static NavigableMap<String, Tuple<Long, ElasticsearchException>> randomReadExceptions() {, +        return readExceptions;, +    static NavigableMap<String, org.elasticsearch.xpack.core.ccr.AutoFollowStats.AutoFollowedCluster> randomTrackingClusters() {, +        final NavigableMap<String, org.elasticsearch.xpack.core.ccr.AutoFollowStats.AutoFollowedCluster> readExceptions = new TreeMap<>();, +        for (int i = 0; i < count; i++) {, +            readExceptions.put("" + i,, +                new org.elasticsearch.xpack.core.ccr.AutoFollowStats.AutoFollowedCluster(randomLong(), randomNonNegativeLong()));, +        }, +        return readExceptions;, +    static FollowStatsAction.StatsResponses createStatsResponse() {, +        int numResponses = randomIntBetween(0, 8);, +        List<FollowStatsAction.StatsResponse> responses = new ArrayList<>(numResponses);, +        for (int i = 0; i < numResponses; i++) {, +            ShardFollowNodeTaskStatus status = new ShardFollowNodeTaskStatus(, +                Collections.emptyNavigableMap(),, +                randomBoolean() ? new ElasticsearchException("fatal error") : null);, +            responses.add(new FollowStatsAction.StatsResponse(status));, +        }, +        return new FollowStatsAction.StatsResponses(Collections.emptyList(), Collections.emptyList(), responses);, +    }, +, +    @Override, +    protected CcrStatsResponse doParseToClientInstance(XContentParser parser) throws IOException {, +        return CcrStatsResponse.fromXContent(parser);, +    }, +, +    @Override, +    protected void assertInstances(CcrStatsAction.Response serverTestInstance, CcrStatsResponse clientInstance) {, +        {, +            AutoFollowStats newAutoFollowStats = clientInstance.getAutoFollowStats();, +            org.elasticsearch.xpack.core.ccr.AutoFollowStats expectedAutoFollowStats = serverTestInstance.getAutoFollowStats();, +            assertThat(newAutoFollowStats.getNumberOfSuccessfulFollowIndices(),, +                equalTo(expectedAutoFollowStats.getNumberOfSuccessfulFollowIndices()));, +            assertThat(newAutoFollowStats.getNumberOfFailedRemoteClusterStateRequests(),, +                equalTo(expectedAutoFollowStats.getNumberOfFailedRemoteClusterStateRequests()));, +            assertThat(newAutoFollowStats.getNumberOfFailedFollowIndices(),, +                equalTo(expectedAutoFollowStats.getNumberOfFailedFollowIndices()));, +            assertThat(newAutoFollowStats.getRecentAutoFollowErrors().size(),, +                equalTo(expectedAutoFollowStats.getRecentAutoFollowErrors().size()));, +            assertThat(newAutoFollowStats.getRecentAutoFollowErrors().keySet(),, +                equalTo(expectedAutoFollowStats.getRecentAutoFollowErrors().keySet()));, +            for (final Map.Entry<String, Tuple<Long, ElasticsearchException>> entry :, +                newAutoFollowStats.getRecentAutoFollowErrors().entrySet()) {, +                // x-content loses the exception, +                final Tuple<Long, ElasticsearchException> expected =, +                    expectedAutoFollowStats.getRecentAutoFollowErrors().get(entry.getKey());, +                assertThat(entry.getValue().v2().getMessage(), containsString(expected.v2().getMessage()));, +                assertThat(entry.getValue().v1(), equalTo(expected.v1()));, +                assertNotNull(entry.getValue().v2().getCause());, +                assertThat(, +                    entry.getValue().v2().getCause(),, +                    anyOf(instanceOf(ElasticsearchException.class), instanceOf(IllegalStateException.class)));, +                assertThat(entry.getValue().v2().getCause().getMessage(), containsString(expected.v2().getCause().getMessage()));, +        {, +            IndicesFollowStats newIndicesFollowStats = clientInstance.getIndicesFollowStats();, +, +            // sort by index name, then shard ID, +            final Map<String, Map<Integer, FollowStatsAction.StatsResponse>> expectedIndicesFollowStats = new TreeMap<>();, +            for (final FollowStatsAction.StatsResponse statsResponse : serverTestInstance.getFollowStats().getStatsResponses()) {, +                expectedIndicesFollowStats.computeIfAbsent(, +                    statsResponse.status().followerIndex(),, +                    k -> new TreeMap<>()).put(statsResponse.status().getShardId(), statsResponse);, +            }, +            assertThat(newIndicesFollowStats.getShardFollowStats().size(),, +                equalTo(expectedIndicesFollowStats.size()));, +            assertThat(newIndicesFollowStats.getShardFollowStats().keySet(),, +                equalTo(expectedIndicesFollowStats.keySet()));, +            for (Map.Entry<String, List<ShardFollowStats>> indexEntry : newIndicesFollowStats.getShardFollowStats().entrySet()) {, +                List<ShardFollowStats> newStats = indexEntry.getValue();, +                Map<Integer, FollowStatsAction.StatsResponse> expectedStats = expectedIndicesFollowStats.get(indexEntry.getKey());, +                assertThat(newStats.size(), equalTo(expectedStats.size()));, +                for (int i = 0; i < newStats.size(); i++) {, +                    ShardFollowStats actualShardFollowStats = newStats.get(i);]