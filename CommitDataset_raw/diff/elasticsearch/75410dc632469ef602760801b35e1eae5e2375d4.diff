[+++ b/x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/MlConfigMigrator.java, +import org.elasticsearch.index.engine.VersionConflictEngineException;, +                        e -> {, +                            if (e instanceof VersionConflictEngineException) {, +                                // the snapshot already exists, +                                listener.onResponse(Boolean.TRUE);, +                            } else {, +                                listener.onFailure(e);, +                            }, +                        }),, +++ b/x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/MlConfigMigrator.java, +import org.elasticsearch.index.engine.VersionConflictEngineException;, +                        e -> {, +                            if (e instanceof VersionConflictEngineException) {, +                                // the snapshot already exists, +                                listener.onResponse(Boolean.TRUE);, +                            } else {, +                                listener.onFailure(e);, +                            }, +                        }),, +++ b/x-pack/plugin/ml/src/test/java/org/elasticsearch/xpack/ml/integration/MlConfigMigratorIT.java, +import org.elasticsearch.action.DocWriteRequest;, +import org.elasticsearch.action.index.IndexRequestBuilder;, +import org.elasticsearch.action.support.WriteRequest;, +    public void testExistingSnapshotDoesNotBlockMigration() throws InterruptedException {, +        // index a doc with the same Id as the config snapshot, +        IndexRequestBuilder indexRequest = client().prepareIndex(AnomalyDetectorsIndex.jobStateIndexName(),, +                ElasticsearchMappings.DOC_TYPE, "ml-config"), +                .setSource(Collections.singletonMap("a_field", "a_value")), +                .setOpType(DocWriteRequest.OpType.CREATE), +                .setRefreshPolicy(WriteRequest.RefreshPolicy.IMMEDIATE);, +, +        indexRequest.execute().actionGet();, +, +        // define the configs, +        MlMetadata.Builder mlMetadata = new MlMetadata.Builder();, +        mlMetadata.putJob(buildJobBuilder("job-foo").build(), false);, +, +        MetaData.Builder metaData = MetaData.builder();, +        RoutingTable.Builder routingTable = RoutingTable.builder();, +        addMlConfigIndex(metaData, routingTable);, +        ClusterState clusterState = ClusterState.builder(new ClusterName("_name")), +                .metaData(metaData.putCustom(MlMetadata.TYPE, mlMetadata.build())), +                .routingTable(routingTable.build()), +                .build();, +, +        doAnswer(invocation -> {, +            ClusterStateUpdateTask listener = (ClusterStateUpdateTask) invocation.getArguments()[1];, +            listener.clusterStateProcessed("source", mock(ClusterState.class), mock(ClusterState.class));, +            return null;, +        }).when(clusterService).submitStateUpdateTask(eq("remove-migrated-ml-configs"), any());, +, +        AtomicReference<Exception> exceptionHolder = new AtomicReference<>();, +        AtomicReference<Boolean> responseHolder = new AtomicReference<>();, +, +        // do the migration, +        MlConfigMigrator mlConfigMigrator = new MlConfigMigrator(nodeSettings(), client(), clusterService);, +        // writing the snapshot should fail because the doc already exists, +        // in which case the migration should continue, +        blockingCall(actionListener -> mlConfigMigrator.migrateConfigs(clusterState, actionListener),, +                responseHolder, exceptionHolder);, +, +        assertNull(exceptionHolder.get());, +        assertTrue(responseHolder.get());, +, +        // check the jobs have been migrated, +        AtomicReference<List<Job.Builder>> jobsHolder = new AtomicReference<>();, +        JobConfigProvider jobConfigProvider = new JobConfigProvider(client());, +        blockingCall(actionListener -> jobConfigProvider.expandJobs("*", true, true, actionListener),, +                jobsHolder, exceptionHolder);, +, +        assertNull(exceptionHolder.get());, +        assertThat(jobsHolder.get(), hasSize(1));, +        assertTrue(jobsHolder.get().get(0).build().getCustomSettings().containsKey(MlConfigMigrator.MIGRATED_FROM_VERSION));, +        assertEquals("job-foo", jobsHolder.get().get(0).build().getId());, +    }, +]