[+++ b/src/main/java/org/elasticsearch/common/util/concurrent/EsThreadPoolExecutor.java, +import org.elasticsearch.ElasticSearchIllegalStateException;, +, +    private volatile ShutdownListener listener;, +, +    private final Object monitor = new Object();, +, +, +    public void shutdown(ShutdownListener listener) {, +        synchronized (monitor) {, +            if (this.listener != null) {, +                throw new ElasticSearchIllegalStateException("Shutdown was already called on this thread pool");, +            }, +            if (isTerminated()) {, +                listener.onTerminated();, +            } else {, +                this.listener = listener;, +            }, +            shutdown();, +        }, +    }, +, +    @Override, +    protected synchronized void terminated() {, +        super.terminated();, +        synchronized (monitor) {, +            if (listener != null) {, +                try {, +                    listener.onTerminated();, +                } finally {, +                    listener = null;, +                }, +            }, +        }, +    }, +, +    public static interface ShutdownListener {, +        public void onTerminated();, +    }, +, +++ b/src/main/java/org/elasticsearch/common/util/concurrent/EsThreadPoolExecutor.java, +import org.elasticsearch.ElasticSearchIllegalStateException;, +, +    private volatile ShutdownListener listener;, +, +    private final Object monitor = new Object();, +, +, +    public void shutdown(ShutdownListener listener) {, +        synchronized (monitor) {, +            if (this.listener != null) {, +                throw new ElasticSearchIllegalStateException("Shutdown was already called on this thread pool");, +            }, +            if (isTerminated()) {, +                listener.onTerminated();, +            } else {, +                this.listener = listener;, +            }, +            shutdown();, +        }, +    }, +, +    @Override, +    protected synchronized void terminated() {, +        super.terminated();, +        synchronized (monitor) {, +            if (listener != null) {, +                try {, +                    listener.onTerminated();, +                } finally {, +                    listener = null;, +                }, +            }, +        }, +    }, +, +    public static interface ShutdownListener {, +        public void onTerminated();, +    }, +, +++ b/src/main/java/org/elasticsearch/threadpool/ThreadPool.java, +import com.google.common.base.Objects;, +import org.elasticsearch.cluster.metadata.MetaData;, +import org.elasticsearch.node.settings.NodeSettingsService;, +import java.util.Queue;, +import static org.elasticsearch.common.collect.MapBuilder.newMapBuilder;, +    static {, +        MetaData.addDynamicSettings(, +                "threadpool.*", +        );, +    }, +, +    private volatile ImmutableMap<String, ExecutorHolder> executors;, +, +    private final ImmutableMap<String, Settings> defaultExecutorTypeSettings;, +, +    private final Queue<ExecutorHolder> retiredExecutors = new ConcurrentLinkedQueue<ExecutorHolder>();, +        this(ImmutableSettings.Builder.EMPTY_SETTINGS, null);, +    public ThreadPool(Settings settings, @Nullable NodeSettingsService nodeSettingsService) {, +        defaultExecutorTypeSettings = ImmutableMap.<String, Settings>builder()]