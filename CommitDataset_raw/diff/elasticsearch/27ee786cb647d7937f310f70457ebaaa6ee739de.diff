[+++ b/dev-tools/checkstyle_suppressions.xml, +++ b/dev-tools/checkstyle_suppressions.xml, +++ b/sql/server/src/main/java/org/elasticsearch/xpack/sql/package-info.java, + * In a nutshell, currently, SQL acts as a <i>translator</i>, allowing, + * traditional SQL queries to be executed against Elasticsearch indices, + * without any modifications. Do note that SQL does <i>not</i> try to hide, + * Elasticsearch or abstract it in anyway; rather it maps the given SQL,, + * if possible, to one (at the moment) query DSL. Of course, this means, + * not all SQL queries are supported.<br>, + * Since Elasticsearch is not a database nor does it supports arbitrary, + * {@code JOIN}s (a cornerstone of SQL), SQL module is built from the, + * ground-up with Elasticsearch in mind first and SQL second. In fact,, + * even the grammar introduces Elasticsearch specific components that, + * have no concept in ANSI SQL., + * SQL module is roughly based on the Volcano project (by Graefe, + * {@code &} co), + * which argues for several design principles, from which 2 are relevant, + * to this project, namely:, + *  <dd>Use of extensible algebraic and logical set of operators to, + *  describe the operation to underlying engine. The engine job is to, + *  map a user query into logical algebra and then translate this into, + *  physical algebra.</dd>, + *  <dd>The use of <i>rules</i> as a way to identify relevant, + *  <i>pattern</i>s inside the plans that can be worked upon</dd>, + * In other words, the use of a logical plan, which represents what the, + * user has requested and a physical plan which is what the engine needs, + * to execute based on the user request. To manipulate the plans, the, + * engine does pattern matching implemented as rules that get applied over, + * and over until none matches., + * An example of a rule would be expanding {@code *} to actual concrete, + * references., + * As a side-note, the Volcano model has proved quite popular being used, + * (to different degrees) by the majority of SQL engines out there such, + * as Apache Calcite, Apache Impala, Apache Spark and Facebook Presto., + * The building operation of the SQL engine is defined by an action,, + * namely a rule (defined in {@link org.elasticsearch.xpack.sql.rule rule}, + * package that accepts one <i>immutable</i> tree (defined in, + * {@link org.elasticsearch.xpack.sql.tree tree} package) and transforms, + * it to another <i>immutable</i> tree., + * Each rules looks for a certain <i>pattern</i> that it can identify and, + * then transform., + *   <dd><i>Logical</i> representation of a user query. Any transformation, + *   of this plan should result in an <i>equivalent</i> plan - meaning for, + *   the same input, it will generate the same output.</dd>, + *   <dd><i>Execution</i> representation of a user query. This plan needs, + *   to translate to (currently) one query to Elasticsearch. It is likely, + *   in the future (once we look into supporting {@code JOIN}s, different, + *   strategies for generating a physical plan will be available depending, + *   on the cost. </dd>, + *   <dd>Both the logical and physical plan contain an expression trees, + *   that need to be incorporated into the query. For the most part, most, + *   of the work inside the engine resolves around expressions.</dd>, + *   <dd>Each node and its properties are immutable. A change in a property, + *   results in a new node which results in a new tree.</dd>, + *   <dd>Due to the algebraic nature of SQL, each tree has the notion of, + *   resolution which indicates whether it has been resolved or not. A node, + *   can be resolved only if it <b>and</b> its children have all been, + *   resolved.</dd>, + *   <dd>Each tree can be traversed top-to-bottom/pre-order/parents-first or, + *   bottom-up/post-order/children-first. The difference in the traversal, + *   depends on the pattern that is being identified.</dd>, + *  <li>The query is parsed and transformed into an <i>unresolved</i> AST or, + *  logical plan</li>, + *  <li>The physical plan gets mapped and then folded into an Elasticsearch, + *  query</li>, + * <h4>Digression - Visitors, pattern matching, {@code instanceof} and, + * Java 10/11/12</h4>, + * To implement the above concepts, several choices have been made in the, + * engine (which are not common in the rest of the XPack code base). In, + * particular the conventions/signatures of, + * {@link org.elasticsearch.xpack.sql.tree.Node tree}s and usage of, + * {@code instanceof} inside, + * {@link org.elasticsearch.xpack.sql.rule.Rule rule}s)., + * Java doesn't provide any utilities for tree abstractions or pattern, + * matching for that matter. Typically for tree traversal one would employ, + * the <a href="https://en.wikipedia.org/wiki/Visitor_pattern">Visitor</a>, + * <li>the visitor granularity is a node and patterns are likely to involve, + * multiple nodes</li>, + * <li>transforming a tree and identifying a pattern requires holding a, + * state which means either the tree or the visitor become stateful</li>, + * <li>it's unwieldy - every node type requires a dedicated {@code visit}, + * method</li>, + * While in Java, there might be hope for, + * <a href="http://cr.openjdk.java.net/~briangoetz/amber/pattern-match.html">the future</a>, + * Scala has made it a, + * <a href="https://docs.scala-lang.org/tour/pattern-matching.html">core feature</a>., + * Its byte-code implementation is less pretty as it relies on, + * {@code instanceof} checks. Which is how many rules are implemented in, + * the SQL engine as well. Where possible though, one can use <i>typed</i>, + * traversal by passing a {@code Class} token to the lambdas (i.e., + * {@link org.elasticsearch.xpack.sql.tree.Node#transformDown(java.util.function.Function, Class), + * pre-order transformation})., + *  <dd>Tokenizer and Lexer of the SQL grammar. Translates user query into an, + *  AST tree ({@code LogicalPlan}. Makes sure the user query is <b>syntactically</b>, + *  valid.</dd>, + *  <dd>Performs basic inspection of the {@code LogicalPlan} for gathering critical, + *  information for the main analysis. This stage is separate from {@code Analysis}, + *  <dd>Performs {@code LogicalPlan} analysis, resolution and verification. Makes, + *  sure the user query is actually valid and <b>semantically</b> valid.</dd>, + *  <dd>Transforms the <i>resolved</i> {@code LogicalPlan} into a <i>semantically</i>]