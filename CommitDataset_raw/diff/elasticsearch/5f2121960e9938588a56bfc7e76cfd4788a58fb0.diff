[+++ b/server/src/main/java/org/elasticsearch/index/engine/CommitStats.java, +     * A raw version of the commit id (see {@link SegmentInfos#getId()}, +     */, +    public Engine.CommitId getRawCommitId() {, +        return new Engine.CommitId(Base64.getDecoder().decode(id));, +    }, +, +    /**, +++ b/server/src/main/java/org/elasticsearch/index/engine/CommitStats.java, +     * A raw version of the commit id (see {@link SegmentInfos#getId()}, +     */, +    public Engine.CommitId getRawCommitId() {, +        return new Engine.CommitId(Base64.getDecoder().decode(id));, +    }, +, +    /**, +++ b/server/src/main/java/org/elasticsearch/indices/flush/SyncedFlushService.java, +import org.elasticsearch.Version;, +import org.elasticsearch.index.engine.CommitStats;, +            final ActionListener<Map<String, PreSyncedFlushResponse>> presyncListener = new ActionListener<Map<String, PreSyncedFlushResponse>>() {, +                public void onResponse(final Map<String, PreSyncedFlushResponse> presyncResponses) {, +                    if (presyncResponses.isEmpty()) {, +                                sendSyncRequests(syncId, activeShards, state, presyncResponses, shardId, totalShards, actionListener);, +            sendPreSyncRequests(activeShards, state, shardId, presyncListener);, +    private int numDocsOnPrimary(List<ShardRouting> shards, Map<String, PreSyncedFlushResponse> preSyncResponses) {, +        for (ShardRouting shard : shards) {, +            if (shard.primary()) {, +                final PreSyncedFlushResponse resp = preSyncResponses.get(shard.currentNodeId());, +                if (resp != null) {, +                    return resp.numDocs;, +                }, +            }, +        }, +        return PreSyncedFlushResponse.UNKNOWN_NUM_DOCS;, +    }, +    void sendSyncRequests(final String syncId, final List<ShardRouting> shards, ClusterState state, Map<String, PreSyncedFlushResponse> preSyncResponses,, +        final int numDocsOnPrimary = numDocsOnPrimary(shards, preSyncResponses);, +                countDownAndSendResponseIfDone(syncId, shards, shardId, totalShards, listener, countDown, results);, +            final PreSyncedFlushResponse preSyncedResponse = preSyncResponses.get(shard.currentNodeId());, +            if (preSyncedResponse == null) {, +                countDownAndSendResponseIfDone(syncId, shards, shardId, totalShards, listener, countDown, results);, +                continue;, +            }, +            if (preSyncedResponse.numDocs != numDocsOnPrimary, +                && preSyncedResponse.numDocs != PreSyncedFlushResponse.UNKNOWN_NUM_DOCS && numDocsOnPrimary != PreSyncedFlushResponse.UNKNOWN_NUM_DOCS) {, +                logger.warn("{} can't to issue sync id [{}] for out of sync replica [{}] with num docs [{}]; num docs on primary [{}]",, +                    shardId, syncId, shard, preSyncedResponse.numDocs, numDocsOnPrimary);, +                results.put(shard, new ShardSyncedFlushResponse("out of sync replica; " +, +                    "num docs on replica [" + preSyncedResponse.numDocs + "]; num docs on primary [" + numDocsOnPrimary + "]"));, +                countDownAndSendResponseIfDone(syncId, shards, shardId, totalShards, listener, countDown, results);, +            transportService.sendRequest(node, SYNCED_FLUSH_ACTION_NAME, new ShardSyncedFlushRequest(shard.shardId(), syncId, preSyncedResponse.commitId),, +                            countDownAndSendResponseIfDone(syncId, shards, shardId, totalShards, listener, countDown, results);, +                            countDownAndSendResponseIfDone(syncId, shards, shardId, totalShards, listener, countDown, results);, +    private void countDownAndSendResponseIfDone(String syncId, List<ShardRouting> shards, ShardId shardId, int totalShards,, +    void sendPreSyncRequests(final List<ShardRouting> shards, final ClusterState state, final ShardId shardId, final ActionListener<Map<String, PreSyncedFlushResponse>> listener) {, +        final ConcurrentMap<String, PreSyncedFlushResponse> presyncResponses = ConcurrentCollections.newConcurrentMap();, +                    listener.onResponse(presyncResponses);, +                    PreSyncedFlushResponse existing = presyncResponses.putIfAbsent(node.getId(), response);, +                        listener.onResponse(presyncResponses);, +                        listener.onResponse(presyncResponses);, +        indexShard.flush(flushRequest);, +        final CommitStats commitStats = indexShard.commitStats();, +        final Engine.CommitId commitId = commitStats.getRawCommitId();, +        logger.trace("{} pre sync flush done. commit id {}, num docs {}", request.shardId(), commitId, commitStats.getNumDocs());, +        return new PreSyncedFlushResponse(commitId, commitStats.getNumDocs());, +        static final int UNKNOWN_NUM_DOCS = -1;, +        int numDocs;, +        PreSyncedFlushResponse(Engine.CommitId commitId, int numDocs) {, +            this.numDocs = numDocs;, +        Engine.CommitId commitId() {, +        int numDocs() {, +            return numDocs;, +        }, +, +            if (in.getVersion().onOrAfter(Version.V_7_0_0_alpha1)) {, +                numDocs = in.readInt();, +            } else {, +                numDocs = UNKNOWN_NUM_DOCS;, +            }, +            if (out.getVersion().onOrAfter(Version.V_7_0_0_alpha1)) {, +                out.writeInt(numDocs);, +            }, +++ b/server/src/main/java/org/elasticsearch/index/engine/CommitStats.java, +     * A raw version of the commit id (see {@link SegmentInfos#getId()}, +     */, +    public Engine.CommitId getRawCommitId() {, +        return new Engine.CommitId(Base64.getDecoder().decode(id));, +    }, +, +    /**, +++ b/server/src/main/java/org/elasticsearch/indices/flush/SyncedFlushService.java, +import org.elasticsearch.Version;, +import org.elasticsearch.index.engine.CommitStats;, +            final ActionListener<Map<String, PreSyncedFlushResponse>> presyncListener = new ActionListener<Map<String, PreSyncedFlushResponse>>() {, +                public void onResponse(final Map<String, PreSyncedFlushResponse> presyncResponses) {, +                    if (presyncResponses.isEmpty()) {, +                                sendSyncRequests(syncId, activeShards, state, presyncResponses, shardId, totalShards, actionListener);, +            sendPreSyncRequests(activeShards, state, shardId, presyncListener);, +    private int numDocsOnPrimary(List<ShardRouting> shards, Map<String, PreSyncedFlushResponse> preSyncResponses) {, +        for (ShardRouting shard : shards) {]