[+++ b/docs/reference/search/suggesters/completion-suggest.asciidoc, +`preserve_separators`::, +`max_input_len`::, +    Limits the length of a single input, defaults to `50` UTF-16 code points., +    This limit is only used at index time to reduce the total number of, +    characters per input string in order to prevent massive inputs from, +    bloating the underlying datastructure. The most usecases won't be influenced, +    by the default value since prefix completions hardly grow beyond prefixes longer, +    than a handful of characters., +    , +++ b/docs/reference/search/suggesters/completion-suggest.asciidoc, +`preserve_separators`::, +`max_input_len`::, +    Limits the length of a single input, defaults to `50` UTF-16 code points., +    This limit is only used at index time to reduce the total number of, +    characters per input string in order to prevent massive inputs from, +    bloating the underlying datastructure. The most usecases won't be influenced, +    by the default value since prefix completions hardly grow beyond prefixes longer, +    than a handful of characters., +    , +++ b/src/main/java/org/elasticsearch/index/mapper/core/CompletionFieldMapper.java, +import org.elasticsearch.index.mapper.*;, +import java.io.Reader;, +        public static final int DEFAULT_MAX_INPUT_LENGTH = 50;, +        public static final String MAX_INPUT_LENGTH = "max_input_len";, +        private int maxInputLength = Defaults.DEFAULT_MAX_INPUT_LENGTH;, +        public Builder maxInputLength(int maxInputLength) {, +            if (maxInputLength <= 0) {, +                throw new ElasticSearchIllegalArgumentException(Fields.MAX_INPUT_LENGTH + " must be > 0 but was [" + maxInputLength + "]");, +            }, +            this.maxInputLength = maxInputLength;, +            return this;, +        }, +, +            return new CompletionFieldMapper(buildNames(context), indexAnalyzer, searchAnalyzer, provider, similarity, payloads,, +                    preserveSeparators, preservePositionIncrements, maxInputLength);, +                    NamedAnalyzer analyzer = getNamedAnalyzer(parserContext, fieldNode.toString());, +                    builder.indexAnalyzer(analyzer);, +                    builder.searchAnalyzer(analyzer);, +                    builder.indexAnalyzer(getNamedAnalyzer(parserContext, fieldNode.toString()));, +                    builder.searchAnalyzer(getNamedAnalyzer(parserContext, fieldNode.toString()));, +                } else if (fieldName.equals(Fields.MAX_INPUT_LENGTH) || fieldName.equals("maxInputLen")) {, +                    builder.maxInputLength(Integer.parseInt(fieldNode.toString()));, +                } else {, +                    throw new MapperParsingException("Unknown field [" + fieldName + "]");, +, +        private NamedAnalyzer getNamedAnalyzer(ParserContext parserContext, String name) {, +            NamedAnalyzer analyzer = parserContext.analysisService().analyzer(name);, +            if (analyzer == null) {, +                throw new ElasticSearchIllegalArgumentException("Can't find default or mapped analyzer with name [" + name +"]");, +            }, +            return analyzer;, +        }, +    private int maxInputLength;, +                                 boolean preserveSeparators, boolean preservePositionIncrements, int maxInputLength) {, +        this.maxInputLength = maxInputLength;, +        if (input.length() > maxInputLength) {, +            final int len = correctSubStringLen(input, Math.min(maxInputLength, input.length()));, +            input = input.substring(0, len);    , +        }, +    public static int correctSubStringLen(String input, int len) {, +        if (Character.isHighSurrogate(input.charAt(len-1))) {, +            assert input.length() >= len+1  && Character.isLowSurrogate(input.charAt(len));, +            return len + 1;, +        }, +        return len;, +    }, +, +        public SuggestField(String name, Reader value, FieldType type, BytesRef payload, CompletionTokenStream.ToFiniteStrings toFiniteStrings) {, +            super(name, value, type);, +            this.payload = payload;, +            this.toFiniteStrings = toFiniteStrings;, +        }, +, +        builder.field(Fields.PAYLOADS, this.payloads);, +        builder.field(Fields.PRESERVE_SEPARATORS, this.preserveSeparators);, +        builder.field(Fields.PRESERVE_POSITION_INCREMENTS, this.preservePositionIncrements);, +        builder.field(Fields.MAX_INPUT_LENGTH, this.maxInputLength);    , +        return builder.endObject();, +    , +    @Override, +    public void merge(Mapper mergeWith, MergeContext mergeContext) throws MergeMappingException {, +        super.merge(mergeWith, mergeContext);, +        CompletionFieldMapper fieldMergeWith = (CompletionFieldMapper) mergeWith;, +        if (payloads != fieldMergeWith.payloads) {, +            mergeContext.addConflict("mapper [" + names.fullName() + "] has different payload values");, +        }, +        if (preservePositionIncrements != fieldMergeWith.preservePositionIncrements) { , +            mergeContext.addConflict("mapper [" + names.fullName() + "] has different 'preserve_position_increments' values");, +        }, +        if (preserveSeparators != fieldMergeWith.preserveSeparators) {    , +            mergeContext.addConflict("mapper [" + names.fullName() + "] has different 'preserve_separators' values");, +        }, +        if (!mergeContext.mergeFlags().simulate()) {, +            this.maxInputLength = fieldMergeWith.maxInputLength;, +        }, +    }, +++ b/docs/reference/search/suggesters/completion-suggest.asciidoc, +`preserve_separators`::, +`max_input_len`::]