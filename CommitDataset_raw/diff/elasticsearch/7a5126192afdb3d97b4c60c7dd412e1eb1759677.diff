[+++ b/build.gradle, +// add buildSrc itself as a groovy project, +task buildSrcIdea(type: GradleBuild) {, +  buildFile = 'buildSrc/build.gradle', +  tasks = ['cleanIdea', 'ideaModule'], +}, +tasks.idea.dependsOn(buildSrcIdea), +++ b/build.gradle, +// add buildSrc itself as a groovy project, +task buildSrcIdea(type: GradleBuild) {, +  buildFile = 'buildSrc/build.gradle', +  tasks = ['cleanIdea', 'ideaModule'], +}, +tasks.idea.dependsOn(buildSrcIdea), +++ b/buildSrc/src/main/groovy/org/elasticsearch/gradle/test/StandaloneTestBasePlugin.groovy, +        project.idea.module.testSourceDirs += project.sourceSets.test.java.srcDirs, +        project.idea.module.scopes['TEST'] = [plus: [project.configurations.testRuntime]], +++ b/build.gradle, +// add buildSrc itself as a groovy project, +task buildSrcIdea(type: GradleBuild) {, +  buildFile = 'buildSrc/build.gradle', +  tasks = ['cleanIdea', 'ideaModule'], +}, +tasks.idea.dependsOn(buildSrcIdea), +++ b/buildSrc/src/main/groovy/org/elasticsearch/gradle/test/StandaloneTestBasePlugin.groovy, +        project.idea.module.testSourceDirs += project.sourceSets.test.java.srcDirs, +        project.idea.module.scopes['TEST'] = [plus: [project.configurations.testRuntime]], +++ b/core/src/main/java/org/elasticsearch/cluster/ClusterModule.java, +++ b/build.gradle, +// add buildSrc itself as a groovy project, +task buildSrcIdea(type: GradleBuild) {, +  buildFile = 'buildSrc/build.gradle', +  tasks = ['cleanIdea', 'ideaModule'], +}, +tasks.idea.dependsOn(buildSrcIdea), +++ b/buildSrc/src/main/groovy/org/elasticsearch/gradle/test/StandaloneTestBasePlugin.groovy, +        project.idea.module.testSourceDirs += project.sourceSets.test.java.srcDirs, +        project.idea.module.scopes['TEST'] = [plus: [project.configurations.testRuntime]], +++ b/core/src/main/java/org/elasticsearch/cluster/ClusterModule.java, +++ b/core/src/main/java/org/elasticsearch/cluster/metadata/MetaData.java, +        RecoverySettings.INDICES_RECOVERY_MAX_BYTES_PER_SEC));, +++ b/build.gradle, +// add buildSrc itself as a groovy project, +task buildSrcIdea(type: GradleBuild) {, +  buildFile = 'buildSrc/build.gradle', +  tasks = ['cleanIdea', 'ideaModule'], +}, +tasks.idea.dependsOn(buildSrcIdea), +++ b/buildSrc/src/main/groovy/org/elasticsearch/gradle/test/StandaloneTestBasePlugin.groovy, +        project.idea.module.testSourceDirs += project.sourceSets.test.java.srcDirs, +        project.idea.module.scopes['TEST'] = [plus: [project.configurations.testRuntime]], +++ b/core/src/main/java/org/elasticsearch/cluster/ClusterModule.java, +++ b/core/src/main/java/org/elasticsearch/cluster/metadata/MetaData.java, +        RecoverySettings.INDICES_RECOVERY_MAX_BYTES_PER_SEC));, +++ b/core/src/main/java/org/elasticsearch/index/mapper/DocumentParser.java, +            String[] paths = Strings.splitStringToArray(field, '.');, +            String fieldName = paths[paths.length-1];, +            ObjectMapper[] mappers = new ObjectMapper[paths.length-1];, +            if (paths.length > 1) {, +                ObjectMapper parent = context.root();, +                for (int i = 0; i < paths.length-1; i++) {, +                    mapper = context.docMapper().objectMappers().get(context.path().fullPathAsText(paths[i]));, +                        // One mapping is missing, check if we are allowed to create a dynamic one., +                        ObjectMapper.Dynamic dynamic = parent.dynamic();, +                        if (dynamic == null) {, +                            dynamic = dynamicOrDefault(context.root().dynamic());, +, +                        switch (dynamic) {, +                            case STRICT:, +                                throw new StrictDynamicMappingException(parent.fullPath(), paths[i]);, +                            case TRUE:, +                                Mapper.Builder builder = context.root().findTemplateBuilder(context, paths[i], "object");, +                                if (builder == null) {, +                                    // if this is a non root object, then explicitly set the dynamic behavior if set, +                                    if (!(parent instanceof RootObjectMapper) && parent.dynamic() != ObjectMapper.Defaults.DYNAMIC) {, +                                        ((ObjectMapper.Builder) builder).dynamic(parent.dynamic());, +                                    }, +                                    builder = MapperBuilders.object(paths[i]).enabled(true).pathType(parent.pathType());, +                                }, +                                Mapper.BuilderContext builderContext = new Mapper.BuilderContext(context.indexSettings(), context.path());, +                                mapper = (ObjectMapper) builder.build(builderContext);, +                                if (mapper.nested() != ObjectMapper.Nested.NO) {, +                                    throw new MapperParsingException("It is forbidden to create dynamic nested objects ([" + context.path().fullPathAsText(paths[i]) + "]) through `copy_to`");, +                                }, +                                break;, +                            case FALSE:, +                              // Maybe we should log something to tell the user that the copy_to is ignored in this case., +                              break;, +                            default:, +                                throw new AssertionError("Unexpected dynamic type " + dynamic);, +, +                        }, +                    }, +                    context.path().add(paths[i]);, +                    mappers[i] = mapper;, +                    parent = mapper;, +                }, +            }, +            ObjectMapper update = parseDynamicValue(context, mapper, fieldName, context.parser().currentToken());, +            if (paths.length > 1) {]