[+++ b/modules/elasticsearch/src/main/java/org/elasticsearch/gateway/local/LocalGatewayNodeAllocation.java, +import org.elasticsearch.ExceptionsHelper;, +import org.elasticsearch.common.unit.ByteSizeValue;, +import org.elasticsearch.common.unit.TimeValue;, +import org.elasticsearch.common.util.concurrent.ConcurrentCollections;, +import org.elasticsearch.index.service.InternalIndexService;, +import org.elasticsearch.index.store.IndexStore;, +import org.elasticsearch.index.store.StoreFileMetaData;, +import org.elasticsearch.indices.IndicesService;, +import org.elasticsearch.indices.store.TransportNodesListShardStoreMetaData;, +import org.elasticsearch.transport.ConnectTransportException;, +import java.util.concurrent.ConcurrentMap;, +    private final IndicesService indicesService;, +, +    private final TransportNodesListShardStoreMetaData listShardStoreMetaData;, +, +    private final ConcurrentMap<ShardId, ConcurrentMap<DiscoveryNode, IndexStore.StoreFilesMetaData>> cachedStores = ConcurrentCollections.newConcurrentMap();, +, +    private final TimeValue listTimeout;, +, +    @Inject public LocalGatewayNodeAllocation(Settings settings, IndicesService indicesService,, +                                              TransportNodesListGatewayState listGatewayState, TransportNodesListShardStoreMetaData listShardStoreMetaData) {, +        this.indicesService = indicesService;, +        this.listShardStoreMetaData = listShardStoreMetaData;, +, +        this.listTimeout = componentSettings.getAsTime("list_timeout", TimeValue.timeValueSeconds(30));, +    }, +, +    @Override public void applyStartedShards(NodeAllocations nodeAllocations, RoutingNodes routingNodes, DiscoveryNodes nodes, List<? extends ShardRouting> startedShards) {, +        for (ShardRouting shardRouting : startedShards) {, +            cachedStores.remove(shardRouting.shardId());, +        }, +        for (ShardRouting shardRouting : failedShards) {, +            cachedStores.remove(shardRouting.shardId());, +        }, +                            logger.debug("[{}][{}] initial allocation to [{}]", shardRouting.index(), shardRouting.id(), node);, +        if (!routingNodes.hasUnassigned()) {, +            return changed;, +        }, +, +        Iterator<MutableShardRouting> unassignedIterator = routingNodes.unassigned().iterator();, +        while (unassignedIterator.hasNext()) {, +            MutableShardRouting shard = unassignedIterator.next();, +            InternalIndexService indexService = (InternalIndexService) indicesService.indexService(shard.index());, +            if (indexService == null) {, +                continue;, +            }, +            // if the store is not persistent, it makes no sense to test for special allocation, +            if (!indexService.store().persistent()) {, +                continue;, +            }, +, +            // pre-check if it can be allocated to any node that currently exists, so we won't list the store for it for nothing, +            boolean canBeAllocatedToAtLeastOneNode = false;, +            for (DiscoveryNode discoNode : nodes.dataNodes().values()) {, +                RoutingNode node = routingNodes.node(discoNode.id());, +                if (node == null) {, +                    continue;, +                }, +                // if its THROTTLING, we are not going to allocate it to this node, so ignore it as well, +                if (nodeAllocations.canAllocate(shard, node, routingNodes).allocate()) {, +                    canBeAllocatedToAtLeastOneNode = true;, +                    break;, +                }, +            }, +, +            if (!canBeAllocatedToAtLeastOneNode) {, +                continue;, +            }, +, +            ConcurrentMap<DiscoveryNode, IndexStore.StoreFilesMetaData> shardStores = buildShardStores(nodes, shard);, +, +            long lastSizeMatched = 0;, +            DiscoveryNode lastDiscoNodeMatched = null;, +            RoutingNode lastNodeMatched = null;, +, +            for (Map.Entry<DiscoveryNode, IndexStore.StoreFilesMetaData> nodeStoreEntry : shardStores.entrySet()) {, +                DiscoveryNode discoNode = nodeStoreEntry.getKey();, +                IndexStore.StoreFilesMetaData storeFilesMetaData = nodeStoreEntry.getValue();, +                logger.trace("{}: checking node [{}]", shard, discoNode);, +, +                if (storeFilesMetaData == null) {, +                    // already allocated on that node..., +                    continue;, +                }, +, +                RoutingNode node = routingNodes.node(discoNode.id());, +                if (node == null) {, +                    continue;, +                }, +, +                // check if we can allocate on that node..., +                // we only check for NO, since if this node is THROTTLING and it has enough "same data", +                // then we will try and assign it next time, +                if (nodeAllocations.canAllocate(shard, node, routingNodes) == Decision.NO) {, +                    continue;, +                }, +, +                // if it is already allocated, we can't assign to it..., +                if (storeFilesMetaData.allocated()) {]