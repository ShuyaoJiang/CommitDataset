[+++ b/server/src/main/java/org/elasticsearch/action/support/replication/TransportWriteAction.java, +            shardStateAction.remoteShardFailed(replica.shardId(), replica.allocationId().getId(), primaryTerm, true, message, exception,, +            shardStateAction.remoteShardFailed(shardId, allocationId, primaryTerm, true, "mark copy as stale", null,, +++ b/server/src/main/java/org/elasticsearch/action/support/replication/TransportWriteAction.java, +            shardStateAction.remoteShardFailed(replica.shardId(), replica.allocationId().getId(), primaryTerm, true, message, exception,, +            shardStateAction.remoteShardFailed(shardId, allocationId, primaryTerm, true, "mark copy as stale", null,, +++ b/server/src/main/java/org/elasticsearch/cluster/action/shard/ShardStateAction.java, +import org.elasticsearch.Version;, +        transportService.registerRequestHandler(SHARD_STARTED_ACTION_NAME, ThreadPool.Names.SAME, StartedShardEntry::new, new ShardStartedTransportHandler(clusterService, new ShardStartedClusterStateTaskExecutor(allocationService, logger), logger));, +        transportService.registerRequestHandler(SHARD_FAILED_ACTION_NAME, ThreadPool.Names.SAME, FailedShardEntry::new, new ShardFailedTransportHandler(clusterService, new ShardFailedClusterStateTaskExecutor(allocationService, routingService, logger), logger));, +    private void sendShardAction(final String actionName, final ClusterState currentState, final TransportRequest request, final Listener listener) {, +            logger.warn("no master known for action [{}] for shard entry [{}]", actionName, request);, +            waitForNewMasterAndRetry(actionName, observer, request, listener, changePredicate);, +            logger.debug("sending [{}] to [{}] for shard entry [{}]", actionName, masterNode.getId(), request);, +                actionName, request, new EmptyTransportResponseHandler(ThreadPool.Names.SAME) {, +                            waitForNewMasterAndRetry(actionName, observer, request, listener, changePredicate);, +                            logger.warn(new ParameterizedMessage("unexpected failure while sending request [{}] to [{}] for shard entry [{}]", actionName, masterNode, request), exp);, +     * @param markAsStale        whether or not to mark a failing shard as stale (eg. removing from in-sync set) when failing the shard., +    public void remoteShardFailed(final ShardId shardId, String allocationId, long primaryTerm, boolean markAsStale, final String message, @Nullable final Exception failure, Listener listener) {, +        FailedShardEntry shardEntry = new FailedShardEntry(shardId, allocationId, primaryTerm, message, failure, markAsStale);, +        sendShardAction(SHARD_FAILED_ACTION_NAME, clusterService.state(), shardEntry, listener);, +        FailedShardEntry shardEntry = new FailedShardEntry(shardRouting.shardId(), shardRouting.allocationId().getId(), 0L, message, failure, true);, +    protected void waitForNewMasterAndRetry(String actionName, ClusterStateObserver observer, TransportRequest request, Listener listener, Predicate<ClusterState> changePredicate) {, +                    logger.trace("new cluster state [{}] after waiting for master election for shard entry [{}]", state, request);, +                sendShardAction(actionName, state, request, listener);, +                logger.warn("node closed while execution action [{}] for shard entry [{}]", actionName, request);, +    private static class ShardFailedTransportHandler implements TransportRequestHandler<FailedShardEntry> {, +        public void messageReceived(FailedShardEntry request, TransportChannel channel) throws Exception {, +    public static class ShardFailedClusterStateTaskExecutor implements ClusterStateTaskExecutor<FailedShardEntry> {, +        public ClusterTasksResult<FailedShardEntry> execute(ClusterState currentState, List<FailedShardEntry> tasks) throws Exception {, +            ClusterTasksResult.Builder<FailedShardEntry> batchResultBuilder = ClusterTasksResult.builder();, +            List<FailedShardEntry> tasksToBeApplied = new ArrayList<>();, +            for (FailedShardEntry task : tasks) {, +                        failedShardsToBeApplied.add(new FailedShard(matched, task.message, task.failure, task.markAsStale));, +    public static class FailedShardEntry extends TransportRequest {, +        final ShardId shardId;, +        final String allocationId;, +        final long primaryTerm;, +        final String message;, +        final Exception failure;, +        final boolean markAsStale;, +, +        FailedShardEntry(StreamInput in) throws IOException {, +            super(in);, +            shardId = ShardId.readShardId(in);, +            allocationId = in.readString();, +            primaryTerm = in.readVLong();, +            message = in.readString();, +            failure = in.readException();, +            if (in.getVersion().onOrAfter(Version.V_7_0_0_alpha1)) {, +                markAsStale = in.readBoolean();, +            } else {, +                markAsStale = true;, +            }, +        }, +, +        public FailedShardEntry(ShardId shardId, String allocationId, long primaryTerm, String message, Exception failure, boolean markAsStale) {, +            this.shardId = shardId;, +            this.allocationId = allocationId;, +            this.primaryTerm = primaryTerm;, +            this.message = message;, +            this.failure = failure;, +            this.markAsStale = markAsStale;, +        }, +, +        public ShardId getShardId() {, +            return shardId;, +        }, +, +        public String getAllocationId() {, +            return allocationId;, +        }, +, +        @Override, +        public void writeTo(StreamOutput out) throws IOException {, +            super.writeTo(out);, +            shardId.writeTo(out);, +            out.writeString(allocationId);, +            out.writeVLong(primaryTerm);, +            out.writeString(message);, +            out.writeException(failure);, +            if (out.getVersion().onOrAfter(Version.V_7_0_0_alpha1)) {, +                out.writeBoolean(markAsStale);, +            }, +        }, +, +        @Override, +        public String toString() {, +            List<String> components = new ArrayList<>(6);, +            components.add("shard id [" + shardId + "]");, +            components.add("allocation id [" + allocationId + "]");, +            components.add("primary term [" + primaryTerm + "]");, +            components.add("message [" + message + "]");, +            if (failure != null) {, +                components.add("failure [" + ExceptionsHelper.detailedMessage(failure) + "]");, +            }, +            components.add("markAsStale [" + markAsStale + "]");, +            return String.join(", ", components);, +        }, +    }]