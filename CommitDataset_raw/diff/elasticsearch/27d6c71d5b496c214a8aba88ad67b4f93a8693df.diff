[+++ b/modules/elasticsearch/src/main/java/org/elasticsearch/cluster/metadata/MetaDataDeleteIndexService.java, +import org.elasticsearch.threadpool.ThreadPool;, +import java.util.concurrent.ScheduledFuture;, +    private final ThreadPool threadPool;, +    @Inject public MetaDataDeleteIndexService(Settings settings, ThreadPool threadPool, ClusterService clusterService, ShardsAllocation shardsAllocation,, +        this.threadPool = threadPool;, +                        threadPool.schedule(new Runnable() {, +                            @Override public void run() {, +                        }, request.timeout, ThreadPool.ExecutionType.DEFAULT);, +        volatile ScheduledFuture future;, +                if (future != null) {, +                    future.cancel(false);, +                if (future != null) {, +                    future.cancel(false);, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/cluster/metadata/MetaDataDeleteIndexService.java, +import org.elasticsearch.threadpool.ThreadPool;, +import java.util.concurrent.ScheduledFuture;, +    private final ThreadPool threadPool;, +    @Inject public MetaDataDeleteIndexService(Settings settings, ThreadPool threadPool, ClusterService clusterService, ShardsAllocation shardsAllocation,, +        this.threadPool = threadPool;, +                        threadPool.schedule(new Runnable() {, +                            @Override public void run() {, +                        }, request.timeout, ThreadPool.ExecutionType.DEFAULT);, +        volatile ScheduledFuture future;, +                if (future != null) {, +                    future.cancel(false);, +                if (future != null) {, +                    future.cancel(false);, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/cluster/service/InternalClusterService.java, +    private final Queue<NotifyTimeout> onGoingTimeouts = new LinkedTransferQueue<NotifyTimeout>();, +    @Inject public InternalClusterService(Settings settings, DiscoveryService discoveryService, OperationRouting operationRouting, TransportService transportService, ThreadPool threadPool) {, +        for (NotifyTimeout onGoingTimeout : onGoingTimeouts) {, +            onGoingTimeout.cancel();, +            onGoingTimeout.listener.onClose();, +        for (Iterator<NotifyTimeout> it = onGoingTimeouts.iterator(); it.hasNext();) {, +            NotifyTimeout timeout = it.next();, +            if (timeout.listener.equals(listener)) {, +                timeout.cancel();, +        notifyTimeout.future = threadPool.schedule(notifyTimeout, timeout, ThreadPool.ExecutionType.THREADED);, +        onGoingTimeouts.add(notifyTimeout);, +    class NotifyTimeout implements Runnable {, +        ScheduledFuture future;, +        NotifyTimeout(TimeoutClusterStateListener listener, TimeValue timeout) {, +        public void cancel() {, +            future.cancel(false);, +        }, +, +        @Override public void run() {, +            if (future.isCancelled()) {, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/cluster/metadata/MetaDataDeleteIndexService.java, +import org.elasticsearch.threadpool.ThreadPool;, +import java.util.concurrent.ScheduledFuture;, +    private final ThreadPool threadPool;, +    @Inject public MetaDataDeleteIndexService(Settings settings, ThreadPool threadPool, ClusterService clusterService, ShardsAllocation shardsAllocation,, +        this.threadPool = threadPool;, +                        threadPool.schedule(new Runnable() {, +                            @Override public void run() {, +                        }, request.timeout, ThreadPool.ExecutionType.DEFAULT);, +        volatile ScheduledFuture future;, +                if (future != null) {, +                    future.cancel(false);, +                if (future != null) {, +                    future.cancel(false);, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/cluster/service/InternalClusterService.java, +    private final Queue<NotifyTimeout> onGoingTimeouts = new LinkedTransferQueue<NotifyTimeout>();, +    @Inject public InternalClusterService(Settings settings, DiscoveryService discoveryService, OperationRouting operationRouting, TransportService transportService, ThreadPool threadPool) {, +        for (NotifyTimeout onGoingTimeout : onGoingTimeouts) {, +            onGoingTimeout.cancel();, +            onGoingTimeout.listener.onClose();, +        for (Iterator<NotifyTimeout> it = onGoingTimeouts.iterator(); it.hasNext();) {, +            NotifyTimeout timeout = it.next();, +            if (timeout.listener.equals(listener)) {, +                timeout.cancel();, +        notifyTimeout.future = threadPool.schedule(notifyTimeout, timeout, ThreadPool.ExecutionType.THREADED);, +        onGoingTimeouts.add(notifyTimeout);, +    class NotifyTimeout implements Runnable {, +        ScheduledFuture future;, +        NotifyTimeout(TimeoutClusterStateListener listener, TimeValue timeout) {, +        public void cancel() {, +            future.cancel(false);, +        }, +, +        @Override public void run() {, +            if (future.isCancelled()) {, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/threadpool/ThreadPool.java, +    /**, +     * Returns an estimated current time in milliseconds., +     */, +    long estimatedCurrentTimeInMillis();, +, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/cluster/metadata/MetaDataDeleteIndexService.java, +import org.elasticsearch.threadpool.ThreadPool;, +import java.util.concurrent.ScheduledFuture;, +    private final ThreadPool threadPool;, +    @Inject public MetaDataDeleteIndexService(Settings settings, ThreadPool threadPool, ClusterService clusterService, ShardsAllocation shardsAllocation,, +        this.threadPool = threadPool;, +                        threadPool.schedule(new Runnable() {, +                            @Override public void run() {, +                        }, request.timeout, ThreadPool.ExecutionType.DEFAULT);, +        volatile ScheduledFuture future;]