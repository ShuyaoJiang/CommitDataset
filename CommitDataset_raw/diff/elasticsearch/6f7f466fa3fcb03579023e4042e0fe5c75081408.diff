[+++ b/plugin/src/main/java/org/elasticsearch/xpack/ml/job/process/DataCountsReporter.java, +import org.elasticsearch.xpack.ml.job.config.Job;, +    private final Job job;, +    private DataStreamDiagnostics diagnostics;, +, +    public DataCountsReporter(ThreadPool threadPool, Settings settings, Job job, DataCounts counts,, +        this.job = job;, +        incrementalRecordStats = new DataCounts(job.getId());, +        diagnostics = new DataStreamDiagnostics(job);, +     * @param recordTimeMs    The time of the record written, +            retrieveDiagnosticsIntermediateResults();, +            , +            dataCountsPersister.persistDataCounts(job.getId(), copy, new LoggingActionListener());, +        , +        diagnostics.checkRecord(recordTimeMs);, +        diagnostics.flush();, +        retrieveDiagnosticsIntermediateResults();, +        dataCountsPersister.persistDataCounts(job.getId(), runningTotalStats(), new LoggingActionListener());, +                "[%s] %d records written to autodetect; missingFieldCount=%d, invalidDateCount=%d, outOfOrderCount=%d", job.getId(),, +        incrementalRecordStats = new DataCounts(job.getId());, +        retrieveDiagnosticsIntermediateResults();, +        diagnostics.resetCounts();, +    private void retrieveDiagnosticsIntermediateResults() {, +        totalRecordStats.incrementBucketCount(diagnostics.getEmptyBucketCount());, +        totalRecordStats.incrementBucketCount(diagnostics.getBucketCount());, +        totalRecordStats.incrementSparseBucketCount(diagnostics.getSparseBucketCount());, +        totalRecordStats.updateLatestEmptyBucketTimeStamp(diagnostics.getLatestEmptyBucketTime());, +        totalRecordStats.updateLatestSparseBucketTimeStamp(diagnostics.getLatestSparseBucketTime());, +, +        incrementalRecordStats.incrementEmptyBucketCount(diagnostics.getEmptyBucketCount());, +        incrementalRecordStats.incrementBucketCount(diagnostics.getBucketCount());, +        incrementalRecordStats.incrementSparseBucketCount(diagnostics.getSparseBucketCount());, +        incrementalRecordStats.updateLatestEmptyBucketTimeStamp(diagnostics.getLatestEmptyBucketTime());, +        incrementalRecordStats.updateLatestSparseBucketTimeStamp(diagnostics.getLatestSparseBucketTime());, +, +        diagnostics.resetCounts();, +    }, +, +            logger.trace("[{}] Persisted DataCounts", job.getId());, +            logger.debug(new ParameterizedMessage("[{}] Error persisting DataCounts stats", job.getId()), e);, +++ b/plugin/src/main/java/org/elasticsearch/xpack/ml/job/process/DataCountsReporter.java, +import org.elasticsearch.xpack.ml.job.config.Job;, +    private final Job job;, +    private DataStreamDiagnostics diagnostics;, +, +    public DataCountsReporter(ThreadPool threadPool, Settings settings, Job job, DataCounts counts,, +        this.job = job;, +        incrementalRecordStats = new DataCounts(job.getId());, +        diagnostics = new DataStreamDiagnostics(job);, +     * @param recordTimeMs    The time of the record written, +            retrieveDiagnosticsIntermediateResults();, +            , +            dataCountsPersister.persistDataCounts(job.getId(), copy, new LoggingActionListener());, +        , +        diagnostics.checkRecord(recordTimeMs);, +        diagnostics.flush();, +        retrieveDiagnosticsIntermediateResults();, +        dataCountsPersister.persistDataCounts(job.getId(), runningTotalStats(), new LoggingActionListener());, +                "[%s] %d records written to autodetect; missingFieldCount=%d, invalidDateCount=%d, outOfOrderCount=%d", job.getId(),, +        incrementalRecordStats = new DataCounts(job.getId());, +        retrieveDiagnosticsIntermediateResults();, +        diagnostics.resetCounts();, +    private void retrieveDiagnosticsIntermediateResults() {, +        totalRecordStats.incrementBucketCount(diagnostics.getEmptyBucketCount());, +        totalRecordStats.incrementBucketCount(diagnostics.getBucketCount());, +        totalRecordStats.incrementSparseBucketCount(diagnostics.getSparseBucketCount());, +        totalRecordStats.updateLatestEmptyBucketTimeStamp(diagnostics.getLatestEmptyBucketTime());, +        totalRecordStats.updateLatestSparseBucketTimeStamp(diagnostics.getLatestSparseBucketTime());, +, +        incrementalRecordStats.incrementEmptyBucketCount(diagnostics.getEmptyBucketCount());, +        incrementalRecordStats.incrementBucketCount(diagnostics.getBucketCount());, +        incrementalRecordStats.incrementSparseBucketCount(diagnostics.getSparseBucketCount());, +        incrementalRecordStats.updateLatestEmptyBucketTimeStamp(diagnostics.getLatestEmptyBucketTime());, +        incrementalRecordStats.updateLatestSparseBucketTimeStamp(diagnostics.getLatestSparseBucketTime());, +, +        diagnostics.resetCounts();, +    }, +, +            logger.trace("[{}] Persisted DataCounts", job.getId());, +            logger.debug(new ParameterizedMessage("[{}] Error persisting DataCounts stats", job.getId()), e);, +++ b/plugin/src/main/java/org/elasticsearch/xpack/ml/job/process/DataStreamDiagnostics.java, +import org.elasticsearch.common.logging.Loggers;, +import org.elasticsearch.xpack.ml.job.config.Job;, +import java.util.Date;, +    private static final Logger LOGGER = Loggers.getLogger(DataStreamDiagnostics.class);, +     * , +     * Sparsity can only be calculated after the window has been filled. Currently, +     * this window is lost if a job gets closed and re-opened. We might fix this , +     * in future., +    private long latestReportedBucket = -1;, +    private long bucketCount = 0;, +    private long emptyBucketCount = 0;, +    private long latestEmptyBucketTime = -1;, +    private long sparseBucketCount = 0;, +    private long latestSparseBucketTime = -1;, +    , +    public DataStreamDiagnostics(Job job) {, +        bucketSpan = job.getAnalysisConfig().getBucketSpan().seconds();, +        latency = job.getAnalysisConfig().getLatency().seconds();, +        if (latestReportedBucket == -1) {]