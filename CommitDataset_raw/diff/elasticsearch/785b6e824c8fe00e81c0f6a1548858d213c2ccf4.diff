[+++ b/server/src/main/java/org/elasticsearch/cluster/coordination/Publication.java, +/*, + * Licensed to Elasticsearch under one or more contributor, + * license agreements. See the NOTICE file distributed with, + * this work for additional information regarding copyright, + * ownership. Elasticsearch licenses this file to you under, + * the Apache License, Version 2.0 (the "License"); you may, + * not use this file except in compliance with the License., + * You may obtain a copy of the License at, + *, + *    http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing,, + * software distributed under the License is distributed on an, + * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY, + * KIND, either express or implied.  See the License for the, + * specific language governing permissions and limitations, + * under the License., + */, +, +package org.elasticsearch.cluster.coordination;, +, +import org.apache.logging.log4j.message.ParameterizedMessage;, +import org.elasticsearch.ElasticsearchException;, +import org.elasticsearch.action.ActionListener;, +import org.elasticsearch.cluster.node.DiscoveryNode;, +import org.elasticsearch.common.component.AbstractComponent;, +import org.elasticsearch.common.settings.Settings;, +import org.elasticsearch.common.unit.TimeValue;, +import org.elasticsearch.discovery.Discovery;, +import org.elasticsearch.discovery.Discovery.AckListener;, +import org.elasticsearch.transport.TransportException;, +import org.elasticsearch.transport.TransportResponse;, +, +import java.util.ArrayList;, +import java.util.List;, +import java.util.Optional;, +import java.util.Set;, +import java.util.function.LongSupplier;, +, +public abstract class Publication extends AbstractComponent {, +, +    private final List<PublicationTarget> publicationTargets;, +    private final PublishRequest publishRequest;, +    private final AckListener ackListener;, +    private final LongSupplier currentTimeSupplier;, +    private final long startTime;, +, +    private Optional<ApplyCommitRequest> applyCommitRequest; // set when state is committed, +    private boolean isCompleted; // set when publication is completed, +    private boolean timedOut; // set when publication timed out, +, +    public Publication(Settings settings, PublishRequest publishRequest, AckListener ackListener, LongSupplier currentTimeSupplier) {, +        super(settings);, +        this.publishRequest = publishRequest;, +        this.ackListener = ackListener;, +        this.currentTimeSupplier = currentTimeSupplier;, +        startTime = currentTimeSupplier.getAsLong();, +        applyCommitRequest = Optional.empty();, +        publicationTargets = new ArrayList<>(publishRequest.getAcceptedState().getNodes().getNodes().size());, +        publishRequest.getAcceptedState().getNodes().iterator().forEachRemaining(n -> publicationTargets.add(new PublicationTarget(n)));, +    }, +, +    public void start(Set<DiscoveryNode> faultyNodes) {, +        logger.trace("publishing {} to {}", publishRequest, publicationTargets);, +, +        for (final DiscoveryNode faultyNode : faultyNodes) {, +            onFaultyNode(faultyNode);, +        }, +        onPossibleCommitFailure();, +        publicationTargets.forEach(PublicationTarget::sendPublishRequest);, +    }, +, +    public void onTimeout() {, +        assert timedOut == false;, +        timedOut = true;, +        if (applyCommitRequest.isPresent() == false) {, +            logger.debug("onTimeout: [{}] timed out before committing", this);, +            // fail all current publications, +            final Exception e = new ElasticsearchException("publication timed out before committing");, +            publicationTargets.stream().filter(PublicationTarget::isActive).forEach(pt -> pt.setFailed(e));, +        }, +        onPossibleCompletion();, +    }, +, +    public void onFaultyNode(DiscoveryNode faultyNode) {, +        publicationTargets.forEach(t -> t.onFaultyNode(faultyNode));, +        onPossibleCompletion();, +    }, +, +    private void onPossibleCompletion() {, +        if (isCompleted) {, +            return;, +        }, +, +        if (timedOut == false) {, +            for (final PublicationTarget target : publicationTargets) {, +                if (target.isActive()) {, +                    return;, +                }]