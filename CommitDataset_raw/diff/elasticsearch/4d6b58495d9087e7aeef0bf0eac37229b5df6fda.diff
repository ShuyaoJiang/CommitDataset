[+++ b/sql/server/src/main/java/org/elasticsearch/xpack/sql/expression/ExpressionId.java, +import java.util.concurrent.atomic.AtomicLong;, +/**, + * Unique identifier for an expression., + * <p>, + * We use an {@link AtomicLong} to guarantee that they are unique, + * and that they produce reproduceable values when run in subsequent, + * tests. They don't produce reproduceable values in production, but, + * you rarely debug with them in production and commonly do so in, + * tests., + */, +    private static final AtomicLong COUNTER = new AtomicLong();, +    private final long id;, +    public ExpressionId() {, +        this.id = COUNTER.incrementAndGet();, +        return Objects.hash(id);, +        if (obj == this) {, +        if (obj == null || obj.getClass() != getClass()) {, +        return id == other.id;, +        return Long.toString(id);, +++ b/sql/server/src/main/java/org/elasticsearch/xpack/sql/expression/ExpressionId.java, +import java.util.concurrent.atomic.AtomicLong;, +/**, + * Unique identifier for an expression., + * <p>, + * We use an {@link AtomicLong} to guarantee that they are unique, + * and that they produce reproduceable values when run in subsequent, + * tests. They don't produce reproduceable values in production, but, + * you rarely debug with them in production and commonly do so in, + * tests., + */, +    private static final AtomicLong COUNTER = new AtomicLong();, +    private final long id;, +    public ExpressionId() {, +        this.id = COUNTER.incrementAndGet();, +        return Objects.hash(id);, +        if (obj == this) {, +        if (obj == null || obj.getClass() != getClass()) {, +        return id == other.id;, +        return Long.toString(id);, +++ /dev/null, +++ b/sql/server/src/main/java/org/elasticsearch/xpack/sql/expression/ExpressionId.java, +import java.util.concurrent.atomic.AtomicLong;, +/**, + * Unique identifier for an expression., + * <p>, + * We use an {@link AtomicLong} to guarantee that they are unique, + * and that they produce reproduceable values when run in subsequent, + * tests. They don't produce reproduceable values in production, but, + * you rarely debug with them in production and commonly do so in, + * tests., + */, +    private static final AtomicLong COUNTER = new AtomicLong();, +    private final long id;, +    public ExpressionId() {, +        this.id = COUNTER.incrementAndGet();, +        return Objects.hash(id);, +        if (obj == this) {, +        if (obj == null || obj.getClass() != getClass()) {, +        return id == other.id;, +        return Long.toString(id);, +++ /dev/null, +++ b/sql/server/src/main/java/org/elasticsearch/xpack/sql/expression/NamedExpression.java, +        this.id = id == null ? new ExpressionId() : id;, +++ b/sql/server/src/main/java/org/elasticsearch/xpack/sql/expression/ExpressionId.java, +import java.util.concurrent.atomic.AtomicLong;, +/**, + * Unique identifier for an expression., + * <p>, + * We use an {@link AtomicLong} to guarantee that they are unique, + * and that they produce reproduceable values when run in subsequent, + * tests. They don't produce reproduceable values in production, but, + * you rarely debug with them in production and commonly do so in, + * tests., + */, +    private static final AtomicLong COUNTER = new AtomicLong();, +    private final long id;, +    public ExpressionId() {, +        this.id = COUNTER.incrementAndGet();, +        return Objects.hash(id);, +        if (obj == this) {, +        if (obj == null || obj.getClass() != getClass()) {, +        return id == other.id;, +        return Long.toString(id);, +++ /dev/null, +++ b/sql/server/src/main/java/org/elasticsearch/xpack/sql/expression/NamedExpression.java, +        this.id = id == null ? new ExpressionId() : id;, +++ b/sql/server/src/main/java/org/elasticsearch/xpack/sql/expression/SubQueryExpression.java, +        this.id = id == null ? new ExpressionId() : id;, +++ b/sql/server/src/main/java/org/elasticsearch/xpack/sql/expression/ExpressionId.java, +import java.util.concurrent.atomic.AtomicLong;, +/**, + * Unique identifier for an expression., + * <p>, + * We use an {@link AtomicLong} to guarantee that they are unique, + * and that they produce reproduceable values when run in subsequent, + * tests. They don't produce reproduceable values in production, but, + * you rarely debug with them in production and commonly do so in, + * tests., + */]