[+++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/Def.java, +                                                      numCaptures);, +                     Class<?> captures[] = new Class<?>[numCaptures];, +                     for (int capture = 0; capture < captures.length; capture++) {, +                         captures[capture] = callSiteType.parameterType(i + 1 + capture);, +                     }, +        PainlessMethod interfaceMethod = painlessLookup.lookupFunctionalInterfacePainlessMethod(interfaceType);, +                implMethod.javaMethod.getName(), 1);, +            MethodHandles.Lookup methodHandlesLookup, Class<?> clazz, String type, String call, int captures) throws Throwable {, +        final FunctionRef ref = FunctionRef.create(painlessLookup, localMethods, null, clazz, type, call, captures);, +        return callSite.dynamicInvoker().asType(MethodType.methodType(clazz, ref.factoryMethodType.parameterArray()));, +++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/Def.java, +                                                      numCaptures);, +                     Class<?> captures[] = new Class<?>[numCaptures];, +                     for (int capture = 0; capture < captures.length; capture++) {, +                         captures[capture] = callSiteType.parameterType(i + 1 + capture);, +                     }, +        PainlessMethod interfaceMethod = painlessLookup.lookupFunctionalInterfacePainlessMethod(interfaceType);, +                implMethod.javaMethod.getName(), 1);, +            MethodHandles.Lookup methodHandlesLookup, Class<?> clazz, String type, String call, int captures) throws Throwable {, +        final FunctionRef ref = FunctionRef.create(painlessLookup, localMethods, null, clazz, type, call, captures);, +        return callSite.dynamicInvoker().asType(MethodType.methodType(clazz, ref.factoryMethodType.parameterArray()));, +++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/FunctionRef.java, +import java.util.ArrayList;, +import java.util.Map;, +import java.util.Objects;, + * Contains all the values necessary to write the instruction to initiate a, + * {@link LambdaBootstrap} for either a function reference or a user-defined, + * lambda function., +    /**, +     * Creates a new FunctionRef which will resolve {@code type::call} from the whitelist., +     * @param painlessLookup the whitelist against which this script is being compiled, +     * @param localMethods user-defined and synthetic methods generated directly on the script class, +     * @param location the character number within the script at compile-time, +     * @param targetClass functional interface type to implement., +     * @param typeName the left hand side of a method reference expression, +     * @param methodName the right hand side of a method reference expression, +     * @param numberOfCaptures number of captured arguments, +     */, +    public static FunctionRef create(PainlessLookup painlessLookup, Map<String, LocalMethod> localMethods, Location location,, +            Class<?> targetClass, String typeName, String methodName, int numberOfCaptures) {, +, +        Objects.requireNonNull(painlessLookup);, +        Objects.requireNonNull(targetClass);, +        Objects.requireNonNull(typeName);, +        Objects.requireNonNull(methodName);, +, +        String targetClassName = PainlessLookupUtility.typeToCanonicalTypeName(targetClass);, +        PainlessMethod interfaceMethod;, +, +        try {, +            try {, +                interfaceMethod = painlessLookup.lookupFunctionalInterfacePainlessMethod(targetClass);, +            } catch (IllegalArgumentException iae) {, +                throw new IllegalArgumentException("cannot convert function reference [" + typeName + "::" + methodName + "] " +, +                        "to a non-functional interface [" + targetClassName + "]", iae);, +            }, +, +            String interfaceMethodName = interfaceMethod.javaMethod.getName();, +            MethodType interfaceMethodType = interfaceMethod.methodType.dropParameterTypes(0, 1);, +            String delegateClassName;, +            boolean isDelegateInterface;, +            int delegateInvokeType;, +            String delegateMethodName;, +            MethodType delegateMethodType;, +, +            Class<?> delegateMethodReturnType;, +            List<Class<?>> delegateMethodParameters;, +            int interfaceTypeParametersSize = interfaceMethod.typeParameters.size();, +, +            if ("this".equals(typeName)) {, +                Objects.requireNonNull(localMethods);, +, +                if (numberOfCaptures < 0) {, +                    throw new IllegalStateException("internal error");, +                }, +, +                String localMethodKey = Locals.buildLocalMethodKey(methodName, numberOfCaptures + interfaceTypeParametersSize);, +                LocalMethod localMethod = localMethods.get(localMethodKey);, +, +                if (localMethod == null) {, +                    throw new IllegalArgumentException("function reference [this::" + localMethodKey + "] " +, +                            "matching [" + targetClassName + ", " + interfaceMethodName + "/" + interfaceTypeParametersSize + "] " +, +                            "not found" + (localMethodKey.contains("$") ? " due to an incorrect number of arguments" : ""), +                    );, +                }, +, +                delegateClassName = CLASS_NAME;, +                isDelegateInterface = false;, +                delegateInvokeType = H_INVOKESTATIC;, +                delegateMethodName = localMethod.name;, +                delegateMethodType = localMethod.methodType;, +, +                delegateMethodReturnType = localMethod.returnType;, +                delegateMethodParameters = localMethod.typeParameters;, +            } else if ("new".equals(methodName)) {, +                if (numberOfCaptures != 0) {, +                    throw new IllegalStateException("internal error");, +                }, +]