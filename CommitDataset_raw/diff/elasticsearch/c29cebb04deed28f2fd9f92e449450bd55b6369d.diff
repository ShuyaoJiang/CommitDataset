[+++ b/server/src/main/java/org/elasticsearch/action/bulk/TransportShardBulkAction.java, +            indexNameExpressionResolver, BulkShardRequest::new, BulkShardRequest::new, ThreadPool.Names.WRITE, false);, +++ b/server/src/main/java/org/elasticsearch/action/bulk/TransportShardBulkAction.java, +            indexNameExpressionResolver, BulkShardRequest::new, BulkShardRequest::new, ThreadPool.Names.WRITE, false);, +++ b/server/src/main/java/org/elasticsearch/action/resync/TransportResyncReplicationAction.java, +            indexNameExpressionResolver, ResyncReplicationRequest::new, ResyncReplicationRequest::new, ThreadPool.Names.WRITE,, +            true /* we should never reject resync because of thread pool capacity on primary */);, +++ b/server/src/main/java/org/elasticsearch/action/bulk/TransportShardBulkAction.java, +            indexNameExpressionResolver, BulkShardRequest::new, BulkShardRequest::new, ThreadPool.Names.WRITE, false);, +++ b/server/src/main/java/org/elasticsearch/action/resync/TransportResyncReplicationAction.java, +            indexNameExpressionResolver, ResyncReplicationRequest::new, ResyncReplicationRequest::new, ThreadPool.Names.WRITE,, +            true /* we should never reject resync because of thread pool capacity on primary */);, +++ b/server/src/main/java/org/elasticsearch/action/support/replication/TransportReplicationAction.java, +                indexNameExpressionResolver, request, replicaRequest, executor, false, false);, +                                         boolean syncGlobalCheckpointAfterOperation, boolean forceExecutionOnPrimary) {, +, +        transportService.registerRequestHandler(actionName, request, ThreadPool.Names.SAME, this::handleOperationRequest);, +, +        transportService.registerRequestHandler(transportPrimaryAction,, +            () -> new ConcreteShardRequest<>(request), executor, forceExecutionOnPrimary, true, this::handlePrimaryRequest);, +, +        // we must never reject on because of thread pool capacity on replicas, +        transportService.registerRequestHandler(transportReplicaAction, () -> new ConcreteReplicaRequest<>(replicaRequest),, +            executor, true, true, this::handleReplicaRequest);, +++ b/server/src/main/java/org/elasticsearch/action/bulk/TransportShardBulkAction.java, +            indexNameExpressionResolver, BulkShardRequest::new, BulkShardRequest::new, ThreadPool.Names.WRITE, false);, +++ b/server/src/main/java/org/elasticsearch/action/resync/TransportResyncReplicationAction.java, +            indexNameExpressionResolver, ResyncReplicationRequest::new, ResyncReplicationRequest::new, ThreadPool.Names.WRITE,, +            true /* we should never reject resync because of thread pool capacity on primary */);, +++ b/server/src/main/java/org/elasticsearch/action/support/replication/TransportReplicationAction.java, +                indexNameExpressionResolver, request, replicaRequest, executor, false, false);, +                                         boolean syncGlobalCheckpointAfterOperation, boolean forceExecutionOnPrimary) {, +, +        transportService.registerRequestHandler(actionName, request, ThreadPool.Names.SAME, this::handleOperationRequest);, +, +        transportService.registerRequestHandler(transportPrimaryAction,, +            () -> new ConcreteShardRequest<>(request), executor, forceExecutionOnPrimary, true, this::handlePrimaryRequest);, +, +        // we must never reject on because of thread pool capacity on replicas, +        transportService.registerRequestHandler(transportReplicaAction, () -> new ConcreteReplicaRequest<>(replicaRequest),, +            executor, true, true, this::handleReplicaRequest);, +++ b/server/src/main/java/org/elasticsearch/action/support/replication/TransportWriteAction.java, +                                   ClusterService clusterService, IndicesService indicesService, ThreadPool threadPool,, +                                   ShardStateAction shardStateAction, ActionFilters actionFilters,, +                                   IndexNameExpressionResolver indexNameExpressionResolver, Supplier<Request> request,, +                                   Supplier<ReplicaRequest> replicaRequest, String executor, boolean forceExecutionOnPrimary) {, +              indexNameExpressionResolver, request, replicaRequest, executor, true, forceExecutionOnPrimary);, +++ b/server/src/main/java/org/elasticsearch/action/bulk/TransportShardBulkAction.java, +            indexNameExpressionResolver, BulkShardRequest::new, BulkShardRequest::new, ThreadPool.Names.WRITE, false);, +++ b/server/src/main/java/org/elasticsearch/action/resync/TransportResyncReplicationAction.java, +            indexNameExpressionResolver, ResyncReplicationRequest::new, ResyncReplicationRequest::new, ThreadPool.Names.WRITE,, +            true /* we should never reject resync because of thread pool capacity on primary */);, +++ b/server/src/main/java/org/elasticsearch/action/support/replication/TransportReplicationAction.java, +                indexNameExpressionResolver, request, replicaRequest, executor, false, false);, +                                         boolean syncGlobalCheckpointAfterOperation, boolean forceExecutionOnPrimary) {, +, +        transportService.registerRequestHandler(actionName, request, ThreadPool.Names.SAME, this::handleOperationRequest);, +, +        transportService.registerRequestHandler(transportPrimaryAction,, +            () -> new ConcreteShardRequest<>(request), executor, forceExecutionOnPrimary, true, this::handlePrimaryRequest);, +, +        // we must never reject on because of thread pool capacity on replicas, +        transportService.registerRequestHandler(transportReplicaAction, () -> new ConcreteReplicaRequest<>(replicaRequest),, +            executor, true, true, this::handleReplicaRequest);, +++ b/server/src/main/java/org/elasticsearch/action/support/replication/TransportWriteAction.java, +                                   ClusterService clusterService, IndicesService indicesService, ThreadPool threadPool,, +                                   ShardStateAction shardStateAction, ActionFilters actionFilters,, +                                   IndexNameExpressionResolver indexNameExpressionResolver, Supplier<Request> request,, +                                   Supplier<ReplicaRequest> replicaRequest, String executor, boolean forceExecutionOnPrimary) {, +              indexNameExpressionResolver, request, replicaRequest, executor, true, forceExecutionOnPrimary);, +++ b/server/src/main/java/org/elasticsearch/index/seqno/RetentionLeaseSyncAction.java, +                ThreadPool.Names.MANAGEMENT, false);, +++ b/server/src/main/java/org/elasticsearch/action/bulk/TransportShardBulkAction.java, +            indexNameExpressionResolver, BulkShardRequest::new, BulkShardRequest::new, ThreadPool.Names.WRITE, false);, +++ b/server/src/main/java/org/elasticsearch/action/resync/TransportResyncReplicationAction.java, +            indexNameExpressionResolver, ResyncReplicationRequest::new, ResyncReplicationRequest::new, ThreadPool.Names.WRITE,, +            true /* we should never reject resync because of thread pool capacity on primary */);, +++ b/server/src/main/java/org/elasticsearch/action/support/replication/TransportReplicationAction.java, +                indexNameExpressionResolver, request, replicaRequest, executor, false, false);, +                                         boolean syncGlobalCheckpointAfterOperation, boolean forceExecutionOnPrimary) {, +, +        transportService.registerRequestHandler(actionName, request, ThreadPool.Names.SAME, this::handleOperationRequest);, +, +        transportService.registerRequestHandler(transportPrimaryAction,, +            () -> new ConcreteShardRequest<>(request), executor, forceExecutionOnPrimary, true, this::handlePrimaryRequest);, +, +        // we must never reject on because of thread pool capacity on replicas, +        transportService.registerRequestHandler(transportReplicaAction, () -> new ConcreteReplicaRequest<>(replicaRequest),, +            executor, true, true, this::handleReplicaRequest);, +++ b/server/src/main/java/org/elasticsearch/action/support/replication/TransportWriteAction.java, +                                   ClusterService clusterService, IndicesService indicesService, ThreadPool threadPool,, +                                   ShardStateAction shardStateAction, ActionFilters actionFilters,, +                                   IndexNameExpressionResolver indexNameExpressionResolver, Supplier<Request> request,, +                                   Supplier<ReplicaRequest> replicaRequest, String executor, boolean forceExecutionOnPrimary) {, +              indexNameExpressionResolver, request, replicaRequest, executor, true, forceExecutionOnPrimary);, +++ b/server/src/main/java/org/elasticsearch/index/seqno/RetentionLeaseSyncAction.java, +                ThreadPool.Names.MANAGEMENT, false);, +++ b/server/src/test/java/org/elasticsearch/action/support/replication/TransportWriteActionTests.java, +                    TestRequest::new, ThreadPool.Names.SAME, false);, +                    TestRequest::new, TestRequest::new, ThreadPool.Names.SAME, false);]