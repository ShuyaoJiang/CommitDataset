[+++ b/core/src/main/java/org/elasticsearch/common/Strings.java, +++ b/core/src/main/java/org/elasticsearch/common/Strings.java, +++ b/core/src/main/java/org/elasticsearch/index/mapper/DocumentParser.java, +, +            boolean parseableAsLong = false;, +                parseableAsLong = true;, +            } catch (NumberFormatException e) {, +                // not a long number, +            }, +, +            boolean parseableAsDouble = false;, +            try {, +                Double.parseDouble(text);, +                parseableAsDouble = true;, +            } catch (NumberFormatException e) {, +                // not a double number, +            }, +, +            if (parseableAsLong && context.root().numericDetection()) {, +            } else if (parseableAsDouble && context.root().numericDetection()) {, +            } else if (parseableAsLong == false && parseableAsDouble == false && context.root().dateDetection()) {, +                // We refuse to match pure numbers, which are too likely to be, +                // false positives with date formats that include eg., +                // `epoch_millis` or `YYYY`, +                for (FormatDateTimeFormatter dateTimeFormatter : context.root().dynamicDateTimeFormatters()) {, +                    try {, +                        dateTimeFormatter.parser().parseMillis(text);, +                    } catch (IllegalArgumentException e) {, +                        // failure to parse this, continue, +                        continue;, +                    }, +                    Mapper.Builder builder = context.root().findTemplateBuilder(context, currentFieldName, XContentFieldType.DATE);, +                    if (builder == null) {, +                        builder = newDateBuilder(currentFieldName, dateTimeFormatter, Version.indexCreated(context.indexSettings()));, +                    }, +                    return builder;, +, +++ b/core/src/main/java/org/elasticsearch/common/Strings.java, +++ b/core/src/main/java/org/elasticsearch/index/mapper/DocumentParser.java, +, +            boolean parseableAsLong = false;, +                parseableAsLong = true;, +            } catch (NumberFormatException e) {, +                // not a long number, +            }, +, +            boolean parseableAsDouble = false;, +            try {, +                Double.parseDouble(text);, +                parseableAsDouble = true;, +            } catch (NumberFormatException e) {, +                // not a double number, +            }, +, +            if (parseableAsLong && context.root().numericDetection()) {, +            } else if (parseableAsDouble && context.root().numericDetection()) {, +            } else if (parseableAsLong == false && parseableAsDouble == false && context.root().dateDetection()) {, +                // We refuse to match pure numbers, which are too likely to be, +                // false positives with date formats that include eg., +                // `epoch_millis` or `YYYY`, +                for (FormatDateTimeFormatter dateTimeFormatter : context.root().dynamicDateTimeFormatters()) {, +                    try {, +                        dateTimeFormatter.parser().parseMillis(text);, +                    } catch (IllegalArgumentException e) {, +                        // failure to parse this, continue, +                        continue;, +                    }, +                    Mapper.Builder builder = context.root().findTemplateBuilder(context, currentFieldName, XContentFieldType.DATE);, +                    if (builder == null) {, +                        builder = newDateBuilder(currentFieldName, dateTimeFormatter, Version.indexCreated(context.indexSettings()));, +                    }, +                    return builder;, +, +++ b/core/src/test/java/org/elasticsearch/index/mapper/DocumentParserTests.java, +import static org.hamcrest.Matchers.not;, +, +    public void testDynamicDateDetectionDisabledOnNumbers() throws IOException {, +        DocumentMapperParser mapperParser = createIndex("test").mapperService().documentMapperParser();, +        String mapping = XContentFactory.jsonBuilder().startObject().startObject("type"), +                .startArray("dynamic_date_formats"), +                    .value("yyyy"), +                .endArray().endObject().endObject().string();, +        DocumentMapper mapper = mapperParser.parse("type", new CompressedXContent(mapping));, +, +        BytesReference bytes = XContentFactory.jsonBuilder(), +            .startObject(), +                .field("foo", "2016"), +            .endObject().bytes();, +, +        // Even though we matched the dynamic format, we do not match on numbers,, +        // which are too likely to be false positives, +        ParsedDocument doc = mapper.parse("test", "type", "1", bytes);, +        Mapping update = doc.dynamicMappingsUpdate();, +        assertNotNull(update);, +        Mapper dateMapper = update.root().getMapper("foo");, +        assertNotNull(dateMapper);, +        assertThat(dateMapper, not(instanceOf(DateFieldMapper.class)));, +    }, +, +    public void testDynamicDateDetectionEnabledWithNoSpecialCharacters() throws IOException {]