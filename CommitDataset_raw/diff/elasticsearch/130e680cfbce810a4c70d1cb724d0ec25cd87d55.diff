[+++ b/src/main/java/org/elasticsearch/discovery/zen/ZenDiscovery.java, +import org.elasticsearch.common.collect.Tuple;, +    private final BlockingQueue<Tuple<DiscoveryNode, MembershipAction.JoinCallback>> processJoinRequests = ConcurrentCollections.newBlockingQueue();, +, +            processJoinRequests.add(new Tuple<>(node, callback));, +, +                private final List<Tuple<DiscoveryNode, MembershipAction.JoinCallback>> drainedTasks = new ArrayList<>();, +, +                    processJoinRequests.drainTo(drainedTasks);, +                    if (drainedTasks.isEmpty()) {, +                        return currentState;, +, +                    boolean modified = false;, +                    DiscoveryNodes.Builder nodesBuilder = DiscoveryNodes.builder(currentState.nodes());, +                    for (Tuple<DiscoveryNode, MembershipAction.JoinCallback> task : drainedTasks) {, +                        DiscoveryNode node = task.v1();, +                        if (currentState.nodes().nodeExists(node.id())) {, +                            logger.debug("received a join request for an existing node [{}]", node);, +                        } else {, +                            modified = true;, +                            nodesBuilder.put(node);, +                                    nodesBuilder.remove(existingNode.id());, +                        }, +                    }, +, +                    ClusterState.Builder stateBuilder = ClusterState.builder(currentState);, +                    if (modified) {, +                        latestDiscoNodes = nodesBuilder.build();, +                        stateBuilder.nodes(latestDiscoNodes);, +                    }, +                    return stateBuilder.build();, +                    for (Tuple<DiscoveryNode, MembershipAction.JoinCallback> drainedTask : drainedTasks) {, +                        drainedTask.v2().onFailure(t);, +                    }, +                    for (Tuple<DiscoveryNode, MembershipAction.JoinCallback> drainedTask : drainedTasks) {, +                        drainedTask.v2().onSuccess();, +                    }]