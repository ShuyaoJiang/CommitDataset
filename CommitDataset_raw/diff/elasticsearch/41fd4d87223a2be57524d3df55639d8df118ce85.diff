[+++ b/docs/reference/migration/migrate_2_0.asciidoc, +, +The `date_histogram` options for `pre_zone` and `post_zone` are replaced by the `time_zone` option. The behavior of `time_zone` is, +equivalent to the former `pre_zone` option. Setting `time_zone` to a value like "+01:00" now will lead to the bucket calculations, +being applied in the specified time zone but In addition to this, also the `pre_zone_adjust_large_interval` is removed because we, +now always return dates and bucket keys in UTC., +++ b/docs/reference/migration/migrate_2_0.asciidoc, +, +The `date_histogram` options for `pre_zone` and `post_zone` are replaced by the `time_zone` option. The behavior of `time_zone` is, +equivalent to the former `pre_zone` option. Setting `time_zone` to a value like "+01:00" now will lead to the bucket calculations, +being applied in the specified time zone but In addition to this, also the `pre_zone_adjust_large_interval` is removed because we, +now always return dates and bucket keys in UTC., +++ b/docs/reference/search/aggregations/bucket/datehistogram-aggregation.asciidoc, +done on UTC. It is possible to provide a time zone value, which will cause all bucket, +computations to take place in the specified zone. The time returned for each bucket/entry is milliseconds since the, +epoch in UTC. The parameters is called `time_zone`. It accepts either a numeric value for the hours offset, for example:, +`"time_zone" : -2`. It also accepts a format of hours and minutes, like `"time_zone" : "-02:30"`., +Another option is to provide a time zone accepted as one of the values listed here., +Lets take an example. For `2012-04-01T04:15:30Z` (UTC), with a `time_zone` of `"-08:00"`. For day interval, the actual time by, +`2012-03-31T08:00:00Z` (UTC). For hour interval, internally applying the time zone results in `2012-03-31T20:15:30`, so rounding it, +in the time zone results in `2012-03-31T20:00:00`, but we return that rounded value converted back in UTC so be consistent as, +`2012-04-01T04:00:00Z` (UTC)., +++ b/docs/reference/migration/migrate_2_0.asciidoc, +, +The `date_histogram` options for `pre_zone` and `post_zone` are replaced by the `time_zone` option. The behavior of `time_zone` is, +equivalent to the former `pre_zone` option. Setting `time_zone` to a value like "+01:00" now will lead to the bucket calculations, +being applied in the specified time zone but In addition to this, also the `pre_zone_adjust_large_interval` is removed because we, +now always return dates and bucket keys in UTC., +++ b/docs/reference/search/aggregations/bucket/datehistogram-aggregation.asciidoc, +done on UTC. It is possible to provide a time zone value, which will cause all bucket, +computations to take place in the specified zone. The time returned for each bucket/entry is milliseconds since the, +epoch in UTC. The parameters is called `time_zone`. It accepts either a numeric value for the hours offset, for example:, +`"time_zone" : -2`. It also accepts a format of hours and minutes, like `"time_zone" : "-02:30"`., +Another option is to provide a time zone accepted as one of the values listed here., +Lets take an example. For `2012-04-01T04:15:30Z` (UTC), with a `time_zone` of `"-08:00"`. For day interval, the actual time by, +`2012-03-31T08:00:00Z` (UTC). For hour interval, internally applying the time zone results in `2012-03-31T20:15:30`, so rounding it, +in the time zone results in `2012-03-31T20:00:00`, but we return that rounded value converted back in UTC so be consistent as, +`2012-04-01T04:00:00Z` (UTC)., +++ b/src/main/java/org/elasticsearch/action/termvectors/TermVectorsRequest.java, +    long startTime;, +, +        if (this.doc != null) {, +            this.doc = other.doc().copyBytesArray();, +        }, +        if (other.perFieldAnalyzer != null) {, +            this.perFieldAnalyzer = new HashMap<>(other.perFieldAnalyzer);, +        }, +        this.version = other.version();, +        this.versionType = VersionType.fromValue(other.versionType().getValue());, +        this.startTime = other.startTime();, +    public long startTime() {, +        return this.startTime;, +    }, +, +++ b/docs/reference/migration/migrate_2_0.asciidoc, +, +The `date_histogram` options for `pre_zone` and `post_zone` are replaced by the `time_zone` option. The behavior of `time_zone` is, +equivalent to the former `pre_zone` option. Setting `time_zone` to a value like "+01:00" now will lead to the bucket calculations, +being applied in the specified time zone but In addition to this, also the `pre_zone_adjust_large_interval` is removed because we, +now always return dates and bucket keys in UTC., +++ b/docs/reference/search/aggregations/bucket/datehistogram-aggregation.asciidoc, +done on UTC. It is possible to provide a time zone value, which will cause all bucket, +computations to take place in the specified zone. The time returned for each bucket/entry is milliseconds since the, +epoch in UTC. The parameters is called `time_zone`. It accepts either a numeric value for the hours offset, for example:, +`"time_zone" : -2`. It also accepts a format of hours and minutes, like `"time_zone" : "-02:30"`., +Another option is to provide a time zone accepted as one of the values listed here., +Lets take an example. For `2012-04-01T04:15:30Z` (UTC), with a `time_zone` of `"-08:00"`. For day interval, the actual time by, +`2012-03-31T08:00:00Z` (UTC). For hour interval, internally applying the time zone results in `2012-03-31T20:15:30`, so rounding it, +in the time zone results in `2012-03-31T20:00:00`, but we return that rounded value converted back in UTC so be consistent as, +`2012-04-01T04:00:00Z` (UTC)., +++ b/src/main/java/org/elasticsearch/action/termvectors/TermVectorsRequest.java, +    long startTime;, +, +        if (this.doc != null) {, +            this.doc = other.doc().copyBytesArray();, +        }, +        if (other.perFieldAnalyzer != null) {, +            this.perFieldAnalyzer = new HashMap<>(other.perFieldAnalyzer);, +        }, +        this.version = other.version();, +        this.versionType = VersionType.fromValue(other.versionType().getValue());, +        this.startTime = other.startTime();, +    public long startTime() {, +        return this.startTime;, +    }, +, +++ b/src/main/java/org/elasticsearch/action/termvectors/TermVectorsResponse.java, +import org.elasticsearch.common.unit.TimeValue;, +        public static final XContentBuilderString TOOK = new XContentBuilderString("took");, +    private long tookInMillis;, +        out.writeBoolean(artificial);, +        out.writeVLong(tookInMillis);, +        artificial = in.readBoolean();, +        tookInMillis = in.readVLong();, +        builder.field(FieldStrings.TOOK, tookInMillis);, +    public void updateTookInMillis(long startTime) {, +        this.tookInMillis = Math.max(1, System.currentTimeMillis() - startTime);, +    }, +, +    public TimeValue getTook() {]