[+++ b/server/src/main/java/org/elasticsearch/gateway/ClusterStateUpdaters.java, +    public static ClusterState addStateNotRecoveredBlock(ClusterState state) {, +        return ClusterState.builder(state), +                .blocks(ClusterBlocks.builder(), +                        .blocks(state.blocks()).addGlobalBlock(GatewayService.STATE_NOT_RECOVERED_BLOCK).build()), +                .build();, +    }, +, +++ b/server/src/main/java/org/elasticsearch/gateway/ClusterStateUpdaters.java, +    public static ClusterState addStateNotRecoveredBlock(ClusterState state) {, +        return ClusterState.builder(state), +                .blocks(ClusterBlocks.builder(), +                        .blocks(state.blocks()).addGlobalBlock(GatewayService.STATE_NOT_RECOVERED_BLOCK).build()), +                .build();, +    }, +, +++ b/server/src/main/java/org/elasticsearch/gateway/GatewayMetaState.java, +            .andThen(ClusterStateUpdaters::addStateNotRecoveredBlock), +++ b/server/src/main/java/org/elasticsearch/gateway/ClusterStateUpdaters.java, +    public static ClusterState addStateNotRecoveredBlock(ClusterState state) {, +        return ClusterState.builder(state), +                .blocks(ClusterBlocks.builder(), +                        .blocks(state.blocks()).addGlobalBlock(GatewayService.STATE_NOT_RECOVERED_BLOCK).build()), +                .build();, +    }, +, +++ b/server/src/main/java/org/elasticsearch/gateway/GatewayMetaState.java, +            .andThen(ClusterStateUpdaters::addStateNotRecoveredBlock), +++ b/server/src/test/java/org/elasticsearch/cluster/coordination/CoordinatorTests.java, +import org.elasticsearch.env.NodeEnvironment;, +import org.elasticsearch.gateway.MockGatewayMetaState;, +import org.junit.After;, +    private final List<NodeEnvironment> nodeEnvironments = new ArrayList<>();, +, +    @After, +    public void closeNodeEnvironmentsAfterEachTest() {, +        for (NodeEnvironment nodeEnvironment : nodeEnvironments) {, +            nodeEnvironment.close();, +        }, +        nodeEnvironments.clear();, +    }, +, +        private final Function<DiscoveryNode, MockPersistedState> defaultPersistedStateSupplier =, +                localNode -> new MockPersistedState(localNode);, +        class MockPersistedState implements PersistedState {, +            private final PersistedState delegate;, +            private final NodeEnvironment nodeEnvironment;, +, +            MockPersistedState(DiscoveryNode localNode) {, +                try {, +                    if (rarely()) {, +                        nodeEnvironment = newNodeEnvironment();, +                        nodeEnvironments.add(nodeEnvironment);, +                        delegate = new MockGatewayMetaState(Settings.EMPTY, nodeEnvironment, xContentRegistry(), localNode), +                                .getPersistedState(Settings.EMPTY, null);, +                    } else {, +                        nodeEnvironment = null;, +                        delegate = new InMemoryPersistedState(0L,, +                                clusterState(0L, 0L, localNode, VotingConfiguration.EMPTY_CONFIG, VotingConfiguration.EMPTY_CONFIG, 0L));, +                    }, +                } catch (IOException e) {, +                    throw new UncheckedIOException("Unable to create MockPersistedState", e);, +                }, +            }, +, +            MockPersistedState(DiscoveryNode newLocalNode, MockPersistedState oldState) {, +                try {, +                    if (oldState.nodeEnvironment != null) {, +                        nodeEnvironment = oldState.nodeEnvironment;, +                        delegate = new MockGatewayMetaState(Settings.EMPTY, nodeEnvironment, xContentRegistry(), newLocalNode), +                                .getPersistedState(Settings.EMPTY, null);, +                    } else {, +                        nodeEnvironment = null;, +                        BytesStreamOutput outStream = new BytesStreamOutput();, +                        outStream.setVersion(Version.CURRENT);, +                        oldState.getLastAcceptedState().writeTo(outStream);, +                        StreamInput inStream = new NamedWriteableAwareStreamInput(outStream.bytes().streamInput(),, +                                new NamedWriteableRegistry(ClusterModule.getNamedWriteables()));, +                        delegate = new InMemoryPersistedState(oldState.getCurrentTerm(), ClusterState.readFrom(inStream,, +                                newLocalNode)); // adapts it to new localNode instance, +                    }, +                } catch (IOException e) {, +                    throw new UncheckedIOException("Unable to create MockPersistedState", e);, +                }, +                    // In the real-life IOError might be thrown, for example if state fsync fails., +                    // This will require node restart and we're not emulating it here., +, +            @Override, +            public long getCurrentTerm() {, +                return delegate.getCurrentTerm();, +            }, +, +            @Override, +            public ClusterState getLastAcceptedState() {, +                return delegate.getLastAcceptedState();, +                delegate.setCurrentTerm(currentTerm);, +                delegate.setLastAcceptedState(clusterState);, +            private final MockPersistedState persistedState;, +            ClusterNode(int nodeIndex, DiscoveryNode localNode, Function<DiscoveryNode, MockPersistedState> persistedStateSupplier) {, +                return new ClusterNode(nodeIndex, newLocalNode, node -> new MockPersistedState(newLocalNode, persistedState));]