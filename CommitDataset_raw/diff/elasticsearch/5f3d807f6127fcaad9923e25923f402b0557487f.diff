[+++ b/core/src/main/java/org/elasticsearch/index/mapper/geo/GeoShapeFieldMapper.java, +                } else if (Names.STRATEGY_POINTS_ONLY.equals(fieldName), +                    && builder.fieldType().strategyName.equals(SpatialStrategy.TERM.getStrategyName()) == false) {, +            defaultStrategy.setPointsOnly(pointsOnly);, +            if (this.strategyName.equals(SpatialStrategy.TERM)) {, +                this.pointsOnly = true;, +            }, +            if (fieldType().pointsOnly() && !(shape instanceof Point)) {, +++ b/core/src/main/java/org/elasticsearch/index/mapper/geo/GeoShapeFieldMapper.java, +                } else if (Names.STRATEGY_POINTS_ONLY.equals(fieldName), +                    && builder.fieldType().strategyName.equals(SpatialStrategy.TERM.getStrategyName()) == false) {, +            defaultStrategy.setPointsOnly(pointsOnly);, +            if (this.strategyName.equals(SpatialStrategy.TERM)) {, +                this.pointsOnly = true;, +            }, +            if (fieldType().pointsOnly() && !(shape instanceof Point)) {, +++ b/docs/reference/mapping/dynamic/templates.asciidoc, +The `match_pattern` parameter behaves just like the `match` parameter, but, +supports full Java regular expression matching on the field name instead of, +simple wildcards, for instance:, +  "match_pattern": "^profit_\d+$", +++ b/core/src/main/java/org/elasticsearch/index/mapper/geo/GeoShapeFieldMapper.java, +                } else if (Names.STRATEGY_POINTS_ONLY.equals(fieldName), +                    && builder.fieldType().strategyName.equals(SpatialStrategy.TERM.getStrategyName()) == false) {, +            defaultStrategy.setPointsOnly(pointsOnly);, +            if (this.strategyName.equals(SpatialStrategy.TERM)) {, +                this.pointsOnly = true;, +            }, +            if (fieldType().pointsOnly() && !(shape instanceof Point)) {, +++ b/docs/reference/mapping/dynamic/templates.asciidoc, +The `match_pattern` parameter behaves just like the `match` parameter, but, +supports full Java regular expression matching on the field name instead of, +simple wildcards, for instance:, +  "match_pattern": "^profit_\d+$", +++ b/docs/reference/mapping/types/geo-shape.asciidoc, +[cols="<,<,<",options="header",], +|Option |Description| Default, +GeohashPrefixTree and `quadtree` for QuadPrefixTree., +| `geohash`, +`m`,`meters`, `cm`,`centimeters`, `mm`, `millimeters`., +| `meters`, +| `50m`, +, +|`strategy` |The strategy parameter defines the approach for how to, +represent shapes at indexing and search time. It also influences the, +capabilities available so it is recommended to let Elasticsearch set, +this parameter automatically. There are two strategies available:, +`recursive` and `term`. Term strategy supports point types only (the, +`points_only` parameter will be automatically set to true) while, +Recursive strategy supports all shape types. (IMPORTANT: see, +<<prefix-trees, Prefix trees>> for more detailed information), +| `recursive`, +supported value. PERFORMANCE NOTE: This value will default to 0 if a `precision` or, +| `0.025`, +different ways. 1. Right-hand rule: `right`, `ccw`, `counterclockwise`,, +| `ccw`, +| `false`, +[[prefix-trees]], +a series of hashes representing grid squares (commonly referred to as "rasters"), +using implementations of a PrefixTree. The tree notion comes from the fact that, +the PrefixTree uses multiple grid layers, each with an increasing level of, +precision to represent the Earth. This can be thought of as increasing the level, +of detail of a map or image at higher zoom levels., +[[spatial-strategy]], +[float], +===== Spatial strategies, +The PrefixTree implementations rely on a SpatialStrategy for decomposing, +the provided Shape(s) into approximated grid squares. Each strategy answers, +the following:, +, +* What type of Shapes can be indexed?, +* What types of Query Operations and Shapes can be used?, +* Does it support more than one Shape per field?, +, +The following Strategy implementations (with corresponding capabilities), +are provided:, +, +[cols="<,<,<,<",options="header",], +|=======================================================================, +|Strategy |Supported Shapes |Supported Queries |Multiple Shapes, +, +|`recursive` |<<input-structure, All>> |`INTERSECTS`, `DISJOINT`, `WITHIN`, `CONTAINS` |Yes, +|`term` |<<point, Points>> |`INTERSECTS` |Yes, +, +|=======================================================================, +, +[[input-structure]], +[[point]], +++ b/core/src/main/java/org/elasticsearch/index/mapper/geo/GeoShapeFieldMapper.java, +                } else if (Names.STRATEGY_POINTS_ONLY.equals(fieldName), +                    && builder.fieldType().strategyName.equals(SpatialStrategy.TERM.getStrategyName()) == false) {, +            defaultStrategy.setPointsOnly(pointsOnly);, +            if (this.strategyName.equals(SpatialStrategy.TERM)) {, +                this.pointsOnly = true;, +            }, +            if (fieldType().pointsOnly() && !(shape instanceof Point)) {, +++ b/docs/reference/mapping/dynamic/templates.asciidoc, +The `match_pattern` parameter behaves just like the `match` parameter, but, +supports full Java regular expression matching on the field name instead of, +simple wildcards, for instance:]