[+++ b/src/main/java/org/elasticsearch/common/lucene/search/function/BoostScoreFunction.java, +    public double score(int docId, float subQueryScore) {, +        if (this == o), +            return true;, +        if (o == null || getClass() != o.getClass()), +            return false;, +        if (Float.compare(that.boost, boost) != 0), +            return false;, +++ b/src/main/java/org/elasticsearch/common/lucene/search/function/BoostScoreFunction.java, +    public double score(int docId, float subQueryScore) {, +        if (this == o), +            return true;, +        if (o == null || getClass() != o.getClass()), +            return false;, +        if (Float.compare(that.boost, boost) != 0), +            return false;, +++ b/src/main/java/org/elasticsearch/common/lucene/search/function/FiltersFunctionScoreQuery.java, +                        double factor = functionExplanation.getValue();, +                        float sc = toFloat(getBoost() * factor);, +                double max = Double.NEGATIVE_INFINITY;, +                double min = Double.POSITIVE_INFINITY;, +                        double factor = functionExplanation.getValue();, +                        Explanation res = new ComplexExplanation(true, toFloat(factor), "custom score, product of:");, +                    double factor = 0;, +                    float sc = toFloat(factor * subQueryExpl.getValue() * getBoost());, +            return toFloat(subQueryBoost * score * factor);, +    , +    public static float toFloat(double input) {, +        assert Double.compare(((float) input), input) == 0 || (Math.abs(((float) input) - input) <= 0.001);, +        return (float) input;, +    }, +++ b/src/main/java/org/elasticsearch/common/lucene/search/function/BoostScoreFunction.java, +    public double score(int docId, float subQueryScore) {, +        if (this == o), +            return true;, +        if (o == null || getClass() != o.getClass()), +            return false;, +        if (Float.compare(that.boost, boost) != 0), +            return false;, +++ b/src/main/java/org/elasticsearch/common/lucene/search/function/FiltersFunctionScoreQuery.java, +                        double factor = functionExplanation.getValue();, +                        float sc = toFloat(getBoost() * factor);, +                double max = Double.NEGATIVE_INFINITY;, +                double min = Double.POSITIVE_INFINITY;, +                        double factor = functionExplanation.getValue();, +                        Explanation res = new ComplexExplanation(true, toFloat(factor), "custom score, product of:");, +                    double factor = 0;, +                    float sc = toFloat(factor * subQueryExpl.getValue() * getBoost());, +            return toFloat(subQueryBoost * score * factor);, +    , +    public static float toFloat(double input) {, +        assert Double.compare(((float) input), input) == 0 || (Math.abs(((float) input) - input) <= 0.001);, +        return (float) input;, +    }, +++ b/src/main/java/org/elasticsearch/common/lucene/search/function/FunctionScoreQuery.java, +            double factor = function.score(scorer.docID(), scorer.score());, +            return toFloat(subQueryBoost * Math.min(maxBoost, factor));, +, +    public static float toFloat(double input) {, +        assert Double.compare(((float) input), input) == 0 || (Math.abs(((float) input) - input) <= 0.001);, +        return (float) input;, +    }, +, +++ b/src/main/java/org/elasticsearch/common/lucene/search/function/BoostScoreFunction.java, +    public double score(int docId, float subQueryScore) {, +        if (this == o), +            return true;, +        if (o == null || getClass() != o.getClass()), +            return false;, +        if (Float.compare(that.boost, boost) != 0), +            return false;, +++ b/src/main/java/org/elasticsearch/common/lucene/search/function/FiltersFunctionScoreQuery.java, +                        double factor = functionExplanation.getValue();, +                        float sc = toFloat(getBoost() * factor);, +                double max = Double.NEGATIVE_INFINITY;, +                double min = Double.POSITIVE_INFINITY;, +                        double factor = functionExplanation.getValue();, +                        Explanation res = new ComplexExplanation(true, toFloat(factor), "custom score, product of:");, +                    double factor = 0;, +                    float sc = toFloat(factor * subQueryExpl.getValue() * getBoost());, +            return toFloat(subQueryBoost * score * factor);, +    , +    public static float toFloat(double input) {, +        assert Double.compare(((float) input), input) == 0 || (Math.abs(((float) input) - input) <= 0.001);, +        return (float) input;, +    }, +++ b/src/main/java/org/elasticsearch/common/lucene/search/function/FunctionScoreQuery.java, +            double factor = function.score(scorer.docID(), scorer.score());, +            return toFloat(subQueryBoost * Math.min(maxBoost, factor));, +, +    public static float toFloat(double input) {, +        assert Double.compare(((float) input), input) == 0 || (Math.abs(((float) input) - input) <= 0.001);, +        return (float) input;, +    }, +, +++ b/src/main/java/org/elasticsearch/common/lucene/search/function/ScoreFunction.java, +    double score(int docId, float subQueryScore);, +++ b/src/main/java/org/elasticsearch/common/lucene/search/function/BoostScoreFunction.java, +    public double score(int docId, float subQueryScore) {, +        if (this == o)]