[+++ b/pom.xml, +        <lucene.maven.version>5.2.0-snapshot-1674183</lucene.maven.version>, +            <url>https://download.elastic.co/lucenesnapshots/1674183</url>, +++ b/pom.xml, +        <lucene.maven.version>5.2.0-snapshot-1674183</lucene.maven.version>, +            <url>https://download.elastic.co/lucenesnapshots/1674183</url>, +++ b/src/main/java/org/apache/lucene/queries/BlendedTermQuery.java, +, +import org.apache.lucene.index.IndexReader;, +import org.apache.lucene.index.IndexReaderContext;, +import org.apache.lucene.index.LeafReaderContext;, +import org.apache.lucene.index.Term;, +import org.apache.lucene.index.TermContext;, +import org.apache.lucene.index.TermState;, +import org.apache.lucene.search.BooleanClause;, +import org.apache.lucene.search.BooleanQuery;, +import org.apache.lucene.search.DisjunctionMaxQuery;, +import org.apache.lucene.search.Query;, +import org.apache.lucene.search.TermQuery;, +import org.apache.lucene.util.InPlaceMergeSorter;, +    protected void blend(final TermContext[] contexts, int maxDoc, IndexReader reader) throws IOException {, +        final int[] tieBreak = new int[contexts.length];, +        for (int i = 0; i < tieBreak.length; ++i) {, +            tieBreak[i] = i;, +        new InPlaceMergeSorter() {, +            @Override, +            protected void swap(int i, int j) {, +                final int tmp = tieBreak[i];, +                tieBreak[i] = tieBreak[j];, +                tieBreak[j] = tmp;, +            }, +            @Override, +            protected int compare(int i, int j) {, +                return Ints.compare(contexts[tieBreak[j]].docFreq(), contexts[tieBreak[i]].docFreq());, +            }, +        }.sort(0, tieBreak.length);, +        int prev = contexts[tieBreak[0]].docFreq();, +        for (int i : tieBreak) {, +            TermContext ctx = contexts[i];, +            contexts[i] = ctx = adjustDF(ctx, Math.min(maxDoc, actualDf));, +    private static TermContext adjustDF(TermContext ctx, int newDocFreq) {, +        // Use a value of ttf that is consistent with the doc freq (ie. gte), +        long newTTF;, +        if (ctx.totalTermFreq() < 0) {, +            newTTF = -1;, +        } else {, +            newTTF = Math.max(ctx.totalTermFreq(), newDocFreq);, +        }, +        List<LeafReaderContext> leaves = ctx.topReaderContext.leaves();, +        final int len;, +        if (leaves == null) {, +            len = 1;, +        } else {, +            len = leaves.size();, +        }, +        TermContext newCtx = new TermContext(ctx.topReaderContext);, +        for (int i = 0; i < len; ++i) {, +            TermState termState = ctx.get(i);, +            if (termState == null) {, +                continue;, +            }, +            newCtx.register(termState, i, newDocFreq, newTTF);, +            newDocFreq = 0;, +            newTTF = 0;, +        }, +        return newCtx;, +    }, +, +++ b/pom.xml, +        <lucene.maven.version>5.2.0-snapshot-1674183</lucene.maven.version>, +            <url>https://download.elastic.co/lucenesnapshots/1674183</url>, +++ b/src/main/java/org/apache/lucene/queries/BlendedTermQuery.java, +, +import org.apache.lucene.index.IndexReader;, +import org.apache.lucene.index.IndexReaderContext;, +import org.apache.lucene.index.LeafReaderContext;, +import org.apache.lucene.index.Term;, +import org.apache.lucene.index.TermContext;, +import org.apache.lucene.index.TermState;, +import org.apache.lucene.search.BooleanClause;, +import org.apache.lucene.search.BooleanQuery;, +import org.apache.lucene.search.DisjunctionMaxQuery;, +import org.apache.lucene.search.Query;, +import org.apache.lucene.search.TermQuery;, +import org.apache.lucene.util.InPlaceMergeSorter;, +    protected void blend(final TermContext[] contexts, int maxDoc, IndexReader reader) throws IOException {, +        final int[] tieBreak = new int[contexts.length];, +        for (int i = 0; i < tieBreak.length; ++i) {, +            tieBreak[i] = i;, +        new InPlaceMergeSorter() {, +            @Override, +            protected void swap(int i, int j) {, +                final int tmp = tieBreak[i];, +                tieBreak[i] = tieBreak[j];, +                tieBreak[j] = tmp;, +            }, +            @Override, +            protected int compare(int i, int j) {, +                return Ints.compare(contexts[tieBreak[j]].docFreq(), contexts[tieBreak[i]].docFreq());, +            }]