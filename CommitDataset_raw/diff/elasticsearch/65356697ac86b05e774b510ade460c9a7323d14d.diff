[+++ b/core/src/main/java/org/elasticsearch/cluster/routing/IndexRoutingTable.java, +            return initializeEmpty(indexMetaData, new UnassignedInfo(UnassignedInfo.Reason.INDEX_CREATED, null));, +            return initializeEmpty(indexMetaData, new UnassignedInfo(UnassignedInfo.Reason.CLUSTER_RECOVERED, null));, +            return initializeEmpty(indexMetaData, new UnassignedInfo(UnassignedInfo.Reason.DANGLING_INDEX_IMPORTED, null));, +            return initializeEmpty(indexMetaData, new UnassignedInfo(UnassignedInfo.Reason.INDEX_REOPENED, null));, +        private Builder initializeEmpty(IndexMetaData indexMetaData, UnassignedInfo unassignedInfo) {, +                final RecoverySource primaryRecoverySource;, +                if (indexMetaData.inSyncAllocationIds(shardNumber).isEmpty() == false) {, +                    // we have previous valid copies for this shard. use them for recovery, +                } else if (indexMetaData.getCreationVersion().before(Version.V_5_0_0_alpha1) &&, +                    unassignedInfo.getReason() != UnassignedInfo.Reason.INDEX_CREATED // tests can create old indices, +                    ) {, +                    // the index is old and didn't maintain inSyncAllocationIds. Fall back to old behavior and require, +                    // finding existing copies, +                    primaryRecoverySource = StoreRecoverySource.EXISTING_STORE_INSTANCE;, +                } else if (indexMetaData.getMergeSourceIndex() != null) {, +                    // this is a new index but the initial shards should merged from another index, +                    primaryRecoverySource = LocalShardsRecoverySource.INSTANCE;, +                } else {, +                    // a freshly created index with no restriction, +                    primaryRecoverySource = StoreRecoverySource.EMPTY_STORE_INSTANCE;, +                    indexShardRoutingBuilder.addShard(ShardRouting.newUnassigned(shardId, primary,, +                        primary ? primaryRecoverySource : PeerRecoverySource.INSTANCE, unassignedInfo));, +++ b/core/src/main/java/org/elasticsearch/cluster/routing/IndexRoutingTable.java, +            return initializeEmpty(indexMetaData, new UnassignedInfo(UnassignedInfo.Reason.INDEX_CREATED, null));, +            return initializeEmpty(indexMetaData, new UnassignedInfo(UnassignedInfo.Reason.CLUSTER_RECOVERED, null));, +            return initializeEmpty(indexMetaData, new UnassignedInfo(UnassignedInfo.Reason.DANGLING_INDEX_IMPORTED, null));, +            return initializeEmpty(indexMetaData, new UnassignedInfo(UnassignedInfo.Reason.INDEX_REOPENED, null));, +        private Builder initializeEmpty(IndexMetaData indexMetaData, UnassignedInfo unassignedInfo) {, +                final RecoverySource primaryRecoverySource;, +                if (indexMetaData.inSyncAllocationIds(shardNumber).isEmpty() == false) {, +                    // we have previous valid copies for this shard. use them for recovery, +                } else if (indexMetaData.getCreationVersion().before(Version.V_5_0_0_alpha1) &&, +                    unassignedInfo.getReason() != UnassignedInfo.Reason.INDEX_CREATED // tests can create old indices, +                    ) {, +                    // the index is old and didn't maintain inSyncAllocationIds. Fall back to old behavior and require, +                    // finding existing copies, +                    primaryRecoverySource = StoreRecoverySource.EXISTING_STORE_INSTANCE;, +                } else if (indexMetaData.getMergeSourceIndex() != null) {, +                    // this is a new index but the initial shards should merged from another index, +                    primaryRecoverySource = LocalShardsRecoverySource.INSTANCE;, +                } else {, +                    // a freshly created index with no restriction, +                    primaryRecoverySource = StoreRecoverySource.EMPTY_STORE_INSTANCE;, +                    indexShardRoutingBuilder.addShard(ShardRouting.newUnassigned(shardId, primary,, +                        primary ? primaryRecoverySource : PeerRecoverySource.INSTANCE, unassignedInfo));, +++ b/core/src/test/java/org/elasticsearch/cluster/health/ClusterStateHealthTests.java, +                assertThat("clusterState is:\n" + clusterState.prettyPrint(), health.getStatus(), equalTo(ClusterHealthStatus.YELLOW));, +                assertThat("clusterState is:\n" + clusterState.prettyPrint(), health.getStatus(), equalTo(ClusterHealthStatus.RED));, +                if (primaryShard.unassignedInfo().getNumFailedAllocations() > 0) {, +                    return false;, +                }, +                if (primaryShard.unassignedInfo().getLastAllocationStatus() == UnassignedInfo.AllocationStatus.DECIDERS_NO) {, +                    return false;, +                }]