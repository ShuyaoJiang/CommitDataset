[+++ b/buildSrc/src/main/resources/checkstyle_suppressions.xml, +  <suppress files="core[/\\]src[/\\]main[/\\]java[/\\]org[/\\]elasticsearch[/\\]index[/\\]mapper[/\\]DocumentMapperParser.java" checks="LineLength" />, +  <suppress files="core[/\\]src[/\\]main[/\\]java[/\\]org[/\\]elasticsearch[/\\]index[/\\]mapper[/\\]Mapper.java" checks="LineLength" />, +  <suppress files="core[/\\]src[/\\]main[/\\]java[/\\]org[/\\]elasticsearch[/\\]index[/\\]query[/\\]support[/\\]QueryParsers.java" checks="LineLength" />, +++ b/buildSrc/src/main/resources/checkstyle_suppressions.xml, +  <suppress files="core[/\\]src[/\\]main[/\\]java[/\\]org[/\\]elasticsearch[/\\]index[/\\]mapper[/\\]DocumentMapperParser.java" checks="LineLength" />, +  <suppress files="core[/\\]src[/\\]main[/\\]java[/\\]org[/\\]elasticsearch[/\\]index[/\\]mapper[/\\]Mapper.java" checks="LineLength" />, +  <suppress files="core[/\\]src[/\\]main[/\\]java[/\\]org[/\\]elasticsearch[/\\]index[/\\]query[/\\]support[/\\]QueryParsers.java" checks="LineLength" />, +++ b/core/src/main/java/org/elasticsearch/action/search/AbstractSearchAsyncAction.java, +import org.elasticsearch.transport.ConnectTransportException;, +import org.elasticsearch.transport.Transport;, +    protected final Function<String, Transport.Connection> nodeIdToConnection;, +                                        Function<String, Transport.Connection> nodeIdToConnection,, +        this.nodeIdToConnection = nodeIdToConnection;, +            // TODO upgrade this to an assert..., +            try {, +                final Transport.Connection connection = nodeIdToConnection.apply(shard.currentNodeId());, +                sendExecuteFirstPhase(connection, transportRequest, new ActionListener<FirstResult>() {, +                        onFirstPhaseResult(shardIndex, shard, connection.getNode().getId(), shardIt, t);, +            } catch (ConnectTransportException | IllegalArgumentException ex) {, +                // we are getting the connection early here so we might run into nodes that are not connected. in that case we move on to, +                // the next shard., +                onFirstPhaseResult(shardIndex, shard, shard.currentNodeId(), shardIt, ex);, +                Transport.Connection connection = nodeIdToConnection.apply(entry.value.shardTarget().nodeId());, +                sendReleaseSearchContext(entry.value.id(), connection);, +                        Transport.Connection connection = nodeIdToConnection.apply(entry.value.queryResult().shardTarget().nodeId());, +                        sendReleaseSearchContext(entry.value.queryResult().id(), connection);, +    protected void sendReleaseSearchContext(long contextId, Transport.Connection connection) {, +        if (connection != null) {, +            searchTransportService.sendFreeContext(connection, contextId, request);, +    protected abstract void sendExecuteFirstPhase(Transport.Connection connection, ShardSearchTransportRequest request,, +++ b/buildSrc/src/main/resources/checkstyle_suppressions.xml, +  <suppress files="core[/\\]src[/\\]main[/\\]java[/\\]org[/\\]elasticsearch[/\\]index[/\\]mapper[/\\]DocumentMapperParser.java" checks="LineLength" />, +  <suppress files="core[/\\]src[/\\]main[/\\]java[/\\]org[/\\]elasticsearch[/\\]index[/\\]mapper[/\\]Mapper.java" checks="LineLength" />, +  <suppress files="core[/\\]src[/\\]main[/\\]java[/\\]org[/\\]elasticsearch[/\\]index[/\\]query[/\\]support[/\\]QueryParsers.java" checks="LineLength" />, +++ b/core/src/main/java/org/elasticsearch/action/search/AbstractSearchAsyncAction.java, +import org.elasticsearch.transport.ConnectTransportException;, +import org.elasticsearch.transport.Transport;, +    protected final Function<String, Transport.Connection> nodeIdToConnection;, +                                        Function<String, Transport.Connection> nodeIdToConnection,, +        this.nodeIdToConnection = nodeIdToConnection;, +            // TODO upgrade this to an assert..., +            try {, +                final Transport.Connection connection = nodeIdToConnection.apply(shard.currentNodeId());, +                sendExecuteFirstPhase(connection, transportRequest, new ActionListener<FirstResult>() {, +                        onFirstPhaseResult(shardIndex, shard, connection.getNode().getId(), shardIt, t);, +            } catch (ConnectTransportException | IllegalArgumentException ex) {, +                // we are getting the connection early here so we might run into nodes that are not connected. in that case we move on to, +                // the next shard., +                onFirstPhaseResult(shardIndex, shard, shard.currentNodeId(), shardIt, ex);, +                Transport.Connection connection = nodeIdToConnection.apply(entry.value.shardTarget().nodeId());, +                sendReleaseSearchContext(entry.value.id(), connection);, +                        Transport.Connection connection = nodeIdToConnection.apply(entry.value.queryResult().shardTarget().nodeId());, +                        sendReleaseSearchContext(entry.value.queryResult().id(), connection);, +    protected void sendReleaseSearchContext(long contextId, Transport.Connection connection) {, +        if (connection != null) {, +            searchTransportService.sendFreeContext(connection, contextId, request);, +    protected abstract void sendExecuteFirstPhase(Transport.Connection connection, ShardSearchTransportRequest request,, +++ b/core/src/main/java/org/elasticsearch/action/search/RemoteClusterConnection.java, +/*, + * Licensed to Elasticsearch under one or more contributor, + * license agreements. See the NOTICE file distributed with, + * this work for additional information regarding copyright, + * ownership. Elasticsearch licenses this file to you under, + * the Apache License, Version 2.0 (the "License"); you may, + * not use this file except in compliance with the License., + * You may obtain a copy of the License at, + *, + *    http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing,, + * software distributed under the License is distributed on an, + * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY, + * KIND, either express or implied.  See the License for the, + * specific language governing permissions and limitations, + * under the License., + */, +package org.elasticsearch.action.search;, +, +import org.apache.logging.log4j.message.ParameterizedMessage;, +import org.apache.logging.log4j.util.Supplier;, +import org.elasticsearch.Version;, +import org.elasticsearch.action.ActionListener;, +import org.elasticsearch.action.admin.cluster.shards.ClusterSearchShardsAction;, +import org.elasticsearch.action.admin.cluster.shards.ClusterSearchShardsRequest;, +import org.elasticsearch.action.admin.cluster.shards.ClusterSearchShardsResponse;, +import org.elasticsearch.action.admin.cluster.state.ClusterStateAction;, +import org.elasticsearch.action.admin.cluster.state.ClusterStateRequest;, +import org.elasticsearch.action.admin.cluster.state.ClusterStateResponse;, +import org.elasticsearch.cluster.node.DiscoveryNode;, +import org.elasticsearch.cluster.node.DiscoveryNodes;, +import org.elasticsearch.common.component.AbstractComponent;, +import org.elasticsearch.common.settings.Settings;, +import org.elasticsearch.common.unit.TimeValue;, +import org.elasticsearch.common.util.concurrent.AbstractRunnable;, +import org.elasticsearch.discovery.Discovery;, +import org.elasticsearch.threadpool.ThreadPool;, +import org.elasticsearch.transport.ConnectionProfile;, +import org.elasticsearch.transport.Transport;, +import org.elasticsearch.transport.TransportActionProxy;]