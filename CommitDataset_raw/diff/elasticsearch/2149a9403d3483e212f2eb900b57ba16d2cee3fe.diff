[+++ b/src/main/java/org/elasticsearch/repositories/blobstore/BlobStoreRepository.java, +        MetaData metaData = readSnapshotMetaData(snapshotId, snapshot.indices(), true);, +                    logger.warn("[{}] failed to delete metadata for index [{}]", ex, snapshotId, index);, +                if (indexMetaData != null) {, +            }, +        return readSnapshotMetaData(snapshotId, indices, false);, +    private MetaData readSnapshotMetaData(SnapshotId snapshotId, ImmutableList<String> indices, boolean ignoreIndexErrors) {, +        MetaData metaData;, +        try {, +            byte[] data = snapshotsBlobContainer.readBlobFully(metaDataBlobName(snapshotId));, +            metaData = readMetaData(data);, +        } catch (FileNotFoundException | NoSuchFileException ex) {, +            throw new SnapshotMissingException(snapshotId, ex);, +        } catch (IOException ex) {, +            throw new SnapshotException(snapshotId, "failed to get snapshots", ex);, +        }, +        MetaData.Builder metaDataBuilder = MetaData.builder(metaData);, +        for (String index : indices) {, +            BlobPath indexPath = basePath().add("indices").add(index);, +            ImmutableBlobContainer indexMetaDataBlobContainer = blobStore().immutableBlobContainer(indexPath);, +            try {, +                byte[] data = indexMetaDataBlobContainer.readBlobFully(snapshotBlobName(snapshotId));, +                try (XContentParser parser = XContentHelper.createParser(data, 0, data.length)) {, +                    XContentParser.Token token;, +                    if ((token = parser.nextToken()) == XContentParser.Token.START_OBJECT) {, +                        IndexMetaData indexMetaData = IndexMetaData.Builder.fromXContent(parser);, +                        if ((token = parser.nextToken()) == XContentParser.Token.END_OBJECT) {, +                            metaDataBuilder.put(indexMetaData, false);, +                            continue;, +                        }, +                    }, +                    if (!ignoreIndexErrors) {, +                        throw new ElasticsearchParseException("unexpected token  [" + token + "]");, +                    } else {, +                        logger.warn("[{}] [{}] unexpected token while reading snapshot metadata [{}]", snapshotId, index, token);, +                    }, +                }, +            } catch (IOException ex) {, +                if (!ignoreIndexErrors) {, +                    throw new SnapshotException(snapshotId, "failed to read metadata", ex);, +                } else {, +                    logger.warn("[{}] [{}] failed to read metadata for index", snapshotId, index, ex);, +                }, +            }, +        }, +        return metaDataBuilder.build();, +    }, +, +        try (XContentParser parser = XContentHelper.createParser(data, 0, data.length)) {, +        try (XContentParser parser = XContentHelper.createParser(data, 0, data.length)) {, +        try (XContentParser parser = XContentHelper.createParser(data, 0, data.length)) {, +++ b/src/main/java/org/elasticsearch/repositories/blobstore/BlobStoreRepository.java, +        MetaData metaData = readSnapshotMetaData(snapshotId, snapshot.indices(), true);, +                    logger.warn("[{}] failed to delete metadata for index [{}]", ex, snapshotId, index);, +                if (indexMetaData != null) {, +            }, +        return readSnapshotMetaData(snapshotId, indices, false);, +    private MetaData readSnapshotMetaData(SnapshotId snapshotId, ImmutableList<String> indices, boolean ignoreIndexErrors) {, +        MetaData metaData;, +        try {, +            byte[] data = snapshotsBlobContainer.readBlobFully(metaDataBlobName(snapshotId));, +            metaData = readMetaData(data);, +        } catch (FileNotFoundException | NoSuchFileException ex) {, +            throw new SnapshotMissingException(snapshotId, ex);, +        } catch (IOException ex) {, +            throw new SnapshotException(snapshotId, "failed to get snapshots", ex);, +        }, +        MetaData.Builder metaDataBuilder = MetaData.builder(metaData);, +        for (String index : indices) {, +            BlobPath indexPath = basePath().add("indices").add(index);, +            ImmutableBlobContainer indexMetaDataBlobContainer = blobStore().immutableBlobContainer(indexPath);, +            try {, +                byte[] data = indexMetaDataBlobContainer.readBlobFully(snapshotBlobName(snapshotId));, +                try (XContentParser parser = XContentHelper.createParser(data, 0, data.length)) {, +                    XContentParser.Token token;, +                    if ((token = parser.nextToken()) == XContentParser.Token.START_OBJECT) {, +                        IndexMetaData indexMetaData = IndexMetaData.Builder.fromXContent(parser);, +                        if ((token = parser.nextToken()) == XContentParser.Token.END_OBJECT) {, +                            metaDataBuilder.put(indexMetaData, false);, +                            continue;, +                        }, +                    }, +                    if (!ignoreIndexErrors) {, +                        throw new ElasticsearchParseException("unexpected token  [" + token + "]");, +                    } else {, +                        logger.warn("[{}] [{}] unexpected token while reading snapshot metadata [{}]", snapshotId, index, token);, +                    }, +                }, +            } catch (IOException ex) {, +                if (!ignoreIndexErrors) {, +                    throw new SnapshotException(snapshotId, "failed to read metadata", ex);, +                } else {, +                    logger.warn("[{}] [{}] failed to read metadata for index", snapshotId, index, ex);, +                }, +            }, +        }, +        return metaDataBuilder.build();, +    }, +, +        try (XContentParser parser = XContentHelper.createParser(data, 0, data.length)) {]