[+++ b/src/main/java/org/elasticsearch/index/translog/Translog.java, +    void sync() throws IOException;, +++ b/src/main/java/org/elasticsearch/index/translog/Translog.java, +    void sync() throws IOException;, +++ b/src/main/java/org/elasticsearch/index/translog/fs/BufferingFsTranslogFile.java, +import java.util.concurrent.atomic.AtomicBoolean;, +    private final AtomicBoolean closed = new AtomicBoolean();, +    private volatile long lastPosition;, +        assert (((ReentrantReadWriteLock.WriteLock) rwl.writeLock()).isHeldByCurrentThread());, +    public void sync() throws IOException {, +        if (!syncNeeded()) {, +            lastSyncPosition = lastPosition;, +        if (!closed.compareAndSet(false, true)) {, +            return;, +        }, +            if (!delete) {, +                try {, +                } catch (Exception e) {, +                    throw new TranslogException(shardId, "failed to sync on close", e);, +                }, +            }, +    }, +++ b/src/main/java/org/elasticsearch/index/translog/Translog.java, +    void sync() throws IOException;, +++ b/src/main/java/org/elasticsearch/index/translog/fs/BufferingFsTranslogFile.java, +import java.util.concurrent.atomic.AtomicBoolean;, +    private final AtomicBoolean closed = new AtomicBoolean();, +    private volatile long lastPosition;, +        assert (((ReentrantReadWriteLock.WriteLock) rwl.writeLock()).isHeldByCurrentThread());, +    public void sync() throws IOException {, +        if (!syncNeeded()) {, +            lastSyncPosition = lastPosition;, +        if (!closed.compareAndSet(false, true)) {, +            return;, +        }, +            if (!delete) {, +                try {, +                } catch (Exception e) {, +                    throw new TranslogException(shardId, "failed to sync on close", e);, +                }, +            }, +    }, +++ b/src/main/java/org/elasticsearch/index/translog/fs/FsTranslog.java, +    public void sync() throws IOException {, +        try {, +        } catch (IOException e) {, +            // if we switches translots (!=), then this failure is not relevant, +            // we are working on a new translog, +            if (this.current == current1) {, +                throw e;, +            }, +        }, +++ b/src/main/java/org/elasticsearch/index/translog/Translog.java, +    void sync() throws IOException;, +++ b/src/main/java/org/elasticsearch/index/translog/fs/BufferingFsTranslogFile.java, +import java.util.concurrent.atomic.AtomicBoolean;, +    private final AtomicBoolean closed = new AtomicBoolean();, +    private volatile long lastPosition;, +        assert (((ReentrantReadWriteLock.WriteLock) rwl.writeLock()).isHeldByCurrentThread());, +    public void sync() throws IOException {, +        if (!syncNeeded()) {, +            lastSyncPosition = lastPosition;, +        if (!closed.compareAndSet(false, true)) {, +            return;, +        }, +            if (!delete) {, +                try {, +                } catch (Exception e) {, +                    throw new TranslogException(shardId, "failed to sync on close", e);, +                }, +            }, +    }, +++ b/src/main/java/org/elasticsearch/index/translog/fs/FsTranslog.java, +    public void sync() throws IOException {, +        try {, +        } catch (IOException e) {, +            // if we switches translots (!=), then this failure is not relevant, +            // we are working on a new translog, +            if (this.current == current1) {, +                throw e;, +            }, +        }, +++ b/src/main/java/org/elasticsearch/index/translog/fs/FsTranslogFile.java, +    void sync() throws IOException;, +++ b/src/main/java/org/elasticsearch/index/translog/Translog.java, +    void sync() throws IOException;, +++ b/src/main/java/org/elasticsearch/index/translog/fs/BufferingFsTranslogFile.java, +import java.util.concurrent.atomic.AtomicBoolean;, +    private final AtomicBoolean closed = new AtomicBoolean();, +    private volatile long lastPosition;, +        assert (((ReentrantReadWriteLock.WriteLock) rwl.writeLock()).isHeldByCurrentThread());, +    public void sync() throws IOException {, +        if (!syncNeeded()) {, +            lastSyncPosition = lastPosition;, +        if (!closed.compareAndSet(false, true)) {, +            return;, +        }, +            if (!delete) {, +                try {, +                } catch (Exception e) {]