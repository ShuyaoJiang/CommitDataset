[+++ b/core/src/main/java/org/elasticsearch/index/engine/Engine.java, +import org.elasticsearch.index.shard.TranslogRecoveryPerformer;, +     * Request that this engine throttle incoming indexing requests to one thread.  Must be matched by a later call to {@link #deactivateThrottling()}., +, +    /**, +     * Performs recovery from the transaction log., +     * This operation will close the engine if the recovery fails., +     */, +    public abstract Engine recoverFromTranslog() throws IOException;, +++ b/core/src/main/java/org/elasticsearch/index/engine/Engine.java, +import org.elasticsearch.index.shard.TranslogRecoveryPerformer;, +     * Request that this engine throttle incoming indexing requests to one thread.  Must be matched by a later call to {@link #deactivateThrottling()}., +, +    /**, +     * Performs recovery from the transaction log., +     * This operation will close the engine if the recovery fails., +     */, +    public abstract Engine recoverFromTranslog() throws IOException;, +++ b/core/src/main/java/org/elasticsearch/index/engine/EngineConfig.java, +    private volatile boolean forceNewTranslog = false;, +    /** if set to true the engine will start even if the translog id in the commit point can not be found and a new transaction log, +     * will be created this should be used if recovery from translog should be skipped */, +    public void setForceNewTranslog(boolean forceNewTranslog) {, +        this.forceNewTranslog = forceNewTranslog;, +    }, +, +++ b/core/src/main/java/org/elasticsearch/index/engine/Engine.java, +import org.elasticsearch.index.shard.TranslogRecoveryPerformer;, +     * Request that this engine throttle incoming indexing requests to one thread.  Must be matched by a later call to {@link #deactivateThrottling()}., +, +    /**, +     * Performs recovery from the transaction log., +     * This operation will close the engine if the recovery fails., +     */, +    public abstract Engine recoverFromTranslog() throws IOException;, +++ b/core/src/main/java/org/elasticsearch/index/engine/EngineConfig.java, +    private volatile boolean forceNewTranslog = false;, +    /** if set to true the engine will start even if the translog id in the commit point can not be found and a new transaction log, +     * will be created this should be used if recovery from translog should be skipped */, +    public void setForceNewTranslog(boolean forceNewTranslog) {, +        this.forceNewTranslog = forceNewTranslog;, +    }, +, +++ b/core/src/main/java/org/elasticsearch/index/engine/EngineFactory.java, +    Engine newReadWriteEngine(EngineConfig config);, +    Engine newReadOnlyEngine(EngineConfig config);, +++ b/core/src/main/java/org/elasticsearch/index/engine/Engine.java, +import org.elasticsearch.index.shard.TranslogRecoveryPerformer;, +     * Request that this engine throttle incoming indexing requests to one thread.  Must be matched by a later call to {@link #deactivateThrottling()}., +, +    /**, +     * Performs recovery from the transaction log., +     * This operation will close the engine if the recovery fails., +     */, +    public abstract Engine recoverFromTranslog() throws IOException;, +++ b/core/src/main/java/org/elasticsearch/index/engine/EngineConfig.java, +    private volatile boolean forceNewTranslog = false;, +    /** if set to true the engine will start even if the translog id in the commit point can not be found and a new transaction log, +     * will be created this should be used if recovery from translog should be skipped */, +    public void setForceNewTranslog(boolean forceNewTranslog) {, +        this.forceNewTranslog = forceNewTranslog;, +    }, +, +++ b/core/src/main/java/org/elasticsearch/index/engine/EngineFactory.java, +    Engine newReadWriteEngine(EngineConfig config);, +    Engine newReadOnlyEngine(EngineConfig config);, +++ b/core/src/main/java/org/elasticsearch/index/engine/InternalEngine.java, +    public InternalEngine(EngineConfig engineConfig) throws EngineException {, +                translog = openTranslog(engineConfig, writer, create || engineConfig.forceNewTranslog());, +                assert translog.getGeneration() != null;, +, +                if (engineConfig.forceNewTranslog()) {, +    @Override, +    public InternalEngine recoverFromTranslog() throws IOException {, +        boolean success = false;, +        try {, +            recoverFromTranslog(engineConfig.getTranslogRecoveryPerformer());, +            success = true;, +        } finally {, +            if (success == false) {, +                close();, +            }, +        }, +        return this;, +    }, +, +, +    private void recoverFromTranslog(TranslogRecoveryPerformer handler) throws IOException {, +        Translog.TranslogGeneration translogGeneration = translog.getGeneration();, +++ b/core/src/main/java/org/elasticsearch/index/engine/Engine.java, +import org.elasticsearch.index.shard.TranslogRecoveryPerformer;, +     * Request that this engine throttle incoming indexing requests to one thread.  Must be matched by a later call to {@link #deactivateThrottling()}., +, +    /**, +     * Performs recovery from the transaction log., +     * This operation will close the engine if the recovery fails., +     */, +    public abstract Engine recoverFromTranslog() throws IOException;, +++ b/core/src/main/java/org/elasticsearch/index/engine/EngineConfig.java, +    private volatile boolean forceNewTranslog = false;]