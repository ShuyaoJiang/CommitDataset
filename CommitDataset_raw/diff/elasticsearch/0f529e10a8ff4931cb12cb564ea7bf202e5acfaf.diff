[+++ b/core/src/main/java/org/elasticsearch/action/admin/cluster/allocation/ClusterAllocationExplanation.java, +    public ClusterAllocationExplanation(ShardId shard, boolean primary, @Nullable String assignedNodeId, long remainingDelayMillis,, +                                        @Nullable UnassignedInfo unassignedInfo, boolean hasPendingAsyncFetch,, +    /** Return the remaining allocation delay for this shard in millisocends */, +                long delay = unassignedInfo.getLastComputedLeftDelayNanos();, +                builder.timeValueField("allocation_delay_in_millis", "allocation_delay", TimeValue.timeValueNanos(delay));, +++ b/core/src/main/java/org/elasticsearch/action/admin/cluster/allocation/ClusterAllocationExplanation.java, +    public ClusterAllocationExplanation(ShardId shard, boolean primary, @Nullable String assignedNodeId, long remainingDelayMillis,, +                                        @Nullable UnassignedInfo unassignedInfo, boolean hasPendingAsyncFetch,, +    /** Return the remaining allocation delay for this shard in millisocends */, +                long delay = unassignedInfo.getLastComputedLeftDelayNanos();, +                builder.timeValueField("allocation_delay_in_millis", "allocation_delay", TimeValue.timeValueNanos(delay));, +++ b/core/src/main/java/org/elasticsearch/action/admin/cluster/allocation/TransportClusterAllocationExplainAction.java, +        if (ui != null) {, +            final Settings indexSettings = indexMetaData.getSettings();, +            long remainingDelayNanos = ui.getRemainingDelay(System.nanoTime(), metadata.settings(), indexSettings);, +        return new ClusterAllocationExplanation(shard.shardId(), shard.primary(), shard.currentNodeId(),, +                remainingDelayMillis, ui, gatewayAllocator.hasFetchPending(shard.shardId(), shard.primary()), explanations);, +++ b/core/src/main/java/org/elasticsearch/action/admin/cluster/allocation/ClusterAllocationExplanation.java, +    public ClusterAllocationExplanation(ShardId shard, boolean primary, @Nullable String assignedNodeId, long remainingDelayMillis,, +                                        @Nullable UnassignedInfo unassignedInfo, boolean hasPendingAsyncFetch,, +    /** Return the remaining allocation delay for this shard in millisocends */, +                long delay = unassignedInfo.getLastComputedLeftDelayNanos();, +                builder.timeValueField("allocation_delay_in_millis", "allocation_delay", TimeValue.timeValueNanos(delay));, +++ b/core/src/main/java/org/elasticsearch/action/admin/cluster/allocation/TransportClusterAllocationExplainAction.java, +        if (ui != null) {, +            final Settings indexSettings = indexMetaData.getSettings();, +            long remainingDelayNanos = ui.getRemainingDelay(System.nanoTime(), metadata.settings(), indexSettings);, +        return new ClusterAllocationExplanation(shard.shardId(), shard.primary(), shard.currentNodeId(),, +                remainingDelayMillis, ui, gatewayAllocator.hasFetchPending(shard.shardId(), shard.primary()), explanations);, +++ b/core/src/main/java/org/elasticsearch/cluster/ClusterModule.java, +++ b/core/src/main/java/org/elasticsearch/action/admin/cluster/allocation/ClusterAllocationExplanation.java, +    public ClusterAllocationExplanation(ShardId shard, boolean primary, @Nullable String assignedNodeId, long remainingDelayMillis,, +                                        @Nullable UnassignedInfo unassignedInfo, boolean hasPendingAsyncFetch,, +    /** Return the remaining allocation delay for this shard in millisocends */, +                long delay = unassignedInfo.getLastComputedLeftDelayNanos();, +                builder.timeValueField("allocation_delay_in_millis", "allocation_delay", TimeValue.timeValueNanos(delay));, +++ b/core/src/main/java/org/elasticsearch/action/admin/cluster/allocation/TransportClusterAllocationExplainAction.java, +        if (ui != null) {, +            final Settings indexSettings = indexMetaData.getSettings();, +            long remainingDelayNanos = ui.getRemainingDelay(System.nanoTime(), metadata.settings(), indexSettings);, +        return new ClusterAllocationExplanation(shard.shardId(), shard.primary(), shard.currentNodeId(),, +                remainingDelayMillis, ui, gatewayAllocator.hasFetchPending(shard.shardId(), shard.primary()), explanations);, +++ b/core/src/main/java/org/elasticsearch/cluster/ClusterModule.java, +++ /dev/null, +++ b/core/src/main/java/org/elasticsearch/action/admin/cluster/allocation/ClusterAllocationExplanation.java, +    public ClusterAllocationExplanation(ShardId shard, boolean primary, @Nullable String assignedNodeId, long remainingDelayMillis,, +                                        @Nullable UnassignedInfo unassignedInfo, boolean hasPendingAsyncFetch,, +    /** Return the remaining allocation delay for this shard in millisocends */, +                long delay = unassignedInfo.getLastComputedLeftDelayNanos();, +                builder.timeValueField("allocation_delay_in_millis", "allocation_delay", TimeValue.timeValueNanos(delay));, +++ b/core/src/main/java/org/elasticsearch/action/admin/cluster/allocation/TransportClusterAllocationExplainAction.java, +        if (ui != null) {, +            final Settings indexSettings = indexMetaData.getSettings();, +            long remainingDelayNanos = ui.getRemainingDelay(System.nanoTime(), metadata.settings(), indexSettings);, +        return new ClusterAllocationExplanation(shard.shardId(), shard.primary(), shard.currentNodeId(),, +                remainingDelayMillis, ui, gatewayAllocator.hasFetchPending(shard.shardId(), shard.primary()), explanations);, +++ b/core/src/main/java/org/elasticsearch/cluster/ClusterModule.java, +++ /dev/null, +++ b/core/src/main/java/org/elasticsearch/cluster/routing/RoutingService.java, +import org.elasticsearch.cluster.ClusterStateListener;, +import org.elasticsearch.common.unit.TimeValue;, +import org.elasticsearch.common.util.concurrent.AbstractRunnable;, +import org.elasticsearch.common.util.concurrent.FutureUtils;, +import org.elasticsearch.threadpool.ThreadPool;, +import java.util.concurrent.ScheduledFuture;, +public class RoutingService extends AbstractLifecycleComponent<RoutingService> implements ClusterStateListener {, +    final ThreadPool threadPool;, +    private volatile long minDelaySettingAtLastSchedulingNanos = Long.MAX_VALUE;, +    private volatile ScheduledFuture registeredNextDelayFuture;, +    public RoutingService(Settings settings, ThreadPool threadPool, ClusterService clusterService, AllocationService allocationService) {, +        this.threadPool = threadPool;, +        if (clusterService != null) {, +            clusterService.addFirst(this);, +        }, +        FutureUtils.cancel(registeredNextDelayFuture);, +        clusterService.remove(this);, +    @Override, +    public void clusterChanged(ClusterChangedEvent event) {, +        if (event.state().nodes().isLocalNodeElectedMaster()) {, +            // Figure out if an existing scheduled reroute is good enough or whether we need to cancel and reschedule., +            // If the minimum of the currently relevant delay settings is larger than something we scheduled in the past,, +            // we are guaranteed that the planned schedule will happen before any of the current shard delays are expired., +            long minDelaySetting = UnassignedInfo.findSmallestDelayedAllocationSettingNanos(settings, event.state());, +            if (minDelaySetting <= 0) {, +                logger.trace("no need to schedule reroute - no delayed unassigned shards, minDelaySetting [{}], scheduled [{}]", minDelaySetting, minDelaySettingAtLastSchedulingNanos);, +                minDelaySettingAtLastSchedulingNanos = Long.MAX_VALUE;, +                FutureUtils.cancel(registeredNextDelayFuture);, +            } else if (minDelaySetting < minDelaySettingAtLastSchedulingNanos) {, +                FutureUtils.cancel(registeredNextDelayFuture);, +                minDelaySettingAtLastSchedulingNanos = minDelaySetting;, +                TimeValue nextDelay = TimeValue.timeValueNanos(UnassignedInfo.findNextDelayedAllocationIn(event.state()));, +                assert nextDelay.nanos() > 0 : "next delay must be non 0 as minDelaySetting is [" + minDelaySetting + "]";, +                logger.info("delaying allocation for [{}] unassigned shards, next check in [{}]",, +                        UnassignedInfo.getNumberOfDelayedUnassigned(event.state()), nextDelay);, +                registeredNextDelayFuture = threadPool.schedule(nextDelay, ThreadPool.Names.SAME, new AbstractRunnable() {, +                    @Override, +                    protected void doRun() throws Exception {, +                        minDelaySettingAtLastSchedulingNanos = Long.MAX_VALUE;, +                        reroute("assign delayed unassigned shards");]