[+++ b/core/src/main/java/org/elasticsearch/search/SearchModule.java, +import org.elasticsearch.common.io.stream.Writeable.Reader;, +import org.elasticsearch.search.aggregations.Aggregator.Parser;, +import java.util.Map;, +import java.util.TreeMap;, +     */, +    public void registerAggregation(AggregationSpec spec) {, +        if (false == transportClient) {, +            namedWriteableRegistry.register(AggregationBuilder.class, spec.aggregationName.getPreferredName(), spec.builderReader);, +            aggregationParserRegistry.register(spec.aggregationParser, spec.aggregationName);, +        }, +        for (Map.Entry<String, Writeable.Reader<? extends InternalAggregation>> t : spec.internalReaders.entrySet()) {, +            String writeableName = t.getKey();, +            Writeable.Reader<? extends InternalAggregation> internalReader = t.getValue();, +            namedWriteableRegistry.register(InternalAggregation.class, writeableName, internalReader);, +        }, +    }, +, +    public static class AggregationSpec {, +        private final Map<String, Writeable.Reader<? extends InternalAggregation>> internalReaders = new TreeMap<>();, +        private final Writeable.Reader<? extends AggregationBuilder> builderReader;, +        private final Aggregator.Parser aggregationParser;, +        private final ParseField aggregationName;, +, +        /**, +         * Register an aggregation., +         * @param aggregationName names by which the aggregation may be parsed. The first name is special because it is the name that the, +         *          reader is registered under., +        public AggregationSpec(Reader<? extends AggregationBuilder> builderReader, Parser aggregationParser, ParseField aggregationName) {, +            this.builderReader = builderReader;, +            this.aggregationParser = aggregationParser;, +            this.aggregationName = aggregationName;, +, +        /**, +         * Add a reader for the shard level results of the aggregation with {@linkplain aggregationName}'s, +         * {@link ParseField#getPreferredName()} as the {@link NamedWriteable#getWriteableName()}., +         */, +        public AggregationSpec addResultReader(Writeable.Reader<? extends InternalAggregation> resultReader) {, +            return addResultReader(aggregationName.getPreferredName(), resultReader);, +        }, +, +        /**, +         * Add a reader for the shard level results of the aggregation., +         */, +        public AggregationSpec addResultReader(String writeableName, Writeable.Reader<? extends InternalAggregation> resultReader) {, +            internalReaders.put(writeableName, resultReader);, +            return this;, +        }, +        registerAggregation(new AggregationSpec(AvgAggregationBuilder::new, new AvgParser(), AvgAggregationBuilder.AGGREGATION_NAME_FIELD), +                .addResultReader(InternalAvg::new));, +        registerAggregation(new AggregationSpec(SumAggregationBuilder::new, new SumParser(), SumAggregationBuilder.AGGREGATION_NAME_FIELD), +                .addResultReader(InternalSum::new));, +        registerAggregation(new AggregationSpec(MinAggregationBuilder::new, new MinParser(), MinAggregationBuilder.AGGREGATION_NAME_FIELD), +                .addResultReader(InternalMin::new));, +        registerAggregation(new AggregationSpec(MaxAggregationBuilder::new, new MaxParser(), MaxAggregationBuilder.AGGREGATION_NAME_FIELD), +                .addResultReader(InternalMax::new));, +        registerAggregation(new AggregationSpec(StatsAggregationBuilder::new, new StatsParser(),, +                StatsAggregationBuilder.AGGREGATION_NAME_FIELD).addResultReader(InternalStats::new));, +        registerAggregation(new AggregationSpec(ExtendedStatsAggregationBuilder::new, new ExtendedStatsParser(),, +                ExtendedStatsAggregationBuilder.AGGREGATION_NAME_FIELD).addResultReader(InternalExtendedStats::new));, +        registerAggregation(new AggregationSpec(ValueCountAggregationBuilder::new, new ValueCountParser(),, +                ValueCountAggregationBuilder.AGGREGATION_NAME_FIELD).addResultReader(InternalValueCount::new));, +        registerAggregation(new AggregationSpec(PercentilesAggregationBuilder::new, new PercentilesParser(),, +                PercentilesAggregationBuilder.AGGREGATION_NAME_FIELD), +                    .addResultReader(InternalTDigestPercentiles.NAME, InternalTDigestPercentiles::new), +                    .addResultReader(InternalHDRPercentiles.NAME, InternalHDRPercentiles::new));, +        registerAggregation(new AggregationSpec(PercentileRanksAggregationBuilder::new, new PercentileRanksParser(),, +                PercentileRanksAggregationBuilder.AGGREGATION_NAME_FIELD), +                    .addResultReader(InternalTDigestPercentileRanks.NAME, InternalTDigestPercentileRanks::new), +                    .addResultReader(InternalHDRPercentileRanks.NAME, InternalHDRPercentileRanks::new));, +++ b/core/src/main/java/org/elasticsearch/search/SearchModule.java, +import org.elasticsearch.common.io.stream.Writeable.Reader;, +import org.elasticsearch.search.aggregations.Aggregator.Parser;, +import java.util.Map;, +import java.util.TreeMap;, +     */, +    public void registerAggregation(AggregationSpec spec) {, +        if (false == transportClient) {, +            namedWriteableRegistry.register(AggregationBuilder.class, spec.aggregationName.getPreferredName(), spec.builderReader);, +            aggregationParserRegistry.register(spec.aggregationParser, spec.aggregationName);, +        }, +        for (Map.Entry<String, Writeable.Reader<? extends InternalAggregation>> t : spec.internalReaders.entrySet()) {, +            String writeableName = t.getKey();, +            Writeable.Reader<? extends InternalAggregation> internalReader = t.getValue();, +            namedWriteableRegistry.register(InternalAggregation.class, writeableName, internalReader);, +        }, +    }, +, +    public static class AggregationSpec {, +        private final Map<String, Writeable.Reader<? extends InternalAggregation>> internalReaders = new TreeMap<>();, +        private final Writeable.Reader<? extends AggregationBuilder> builderReader;, +        private final Aggregator.Parser aggregationParser;, +        private final ParseField aggregationName;, +, +        /**, +         * Register an aggregation., +         * @param aggregationName names by which the aggregation may be parsed. The first name is special because it is the name that the, +         *          reader is registered under., +        public AggregationSpec(Reader<? extends AggregationBuilder> builderReader, Parser aggregationParser, ParseField aggregationName) {, +            this.builderReader = builderReader;]