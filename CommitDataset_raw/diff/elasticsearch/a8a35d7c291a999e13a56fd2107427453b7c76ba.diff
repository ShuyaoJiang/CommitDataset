[+++ b/src/main/java/org/elasticsearch/common/geo/builders/BasePolygonBuilder.java, +import com.google.common.collect.Sets;, +import com.spatial4j.core.exception.InvalidShapeException;, +import org.apache.commons.lang3.tuple.Pair;, +import java.util.HashMap;, +import java.util.HashSet;, +     * Validates only 1 vertex is tangential (shared) between the interior and exterior of a polygon, +     */, +    protected void validateHole(BaseLineStringBuilder shell, BaseLineStringBuilder hole) {, +        HashSet exterior = Sets.newHashSet(shell.points);, +        HashSet interior = Sets.newHashSet(hole.points);, +        exterior.retainAll(interior);, +        if (exterior.size() >= 2) {, +            throw new InvalidShapeException("Invalid polygon, interior cannot share more than one point with the exterior");, +        }, +    }, +, +    /**, +            validateHole(shell, this.holes.get(i));, +        double shiftOffset = any.coordinate.x > DATELINE ? DATELINE : (any.coordinate.x < -DATELINE ? -DATELINE : 0);, +            LOGGER.debug("shift: {[]}", shiftOffset);, +        int length = 0, connectedComponents = 0;, +        // if there are two connected components, splitIndex keeps track of where to split the edge array, +        // start at 1 since the source coordinate is shared, +        int splitIndex = 1;, +        Edge prev = edge;, +        // bookkeep the source and sink of each visited coordinate, +        HashMap<Coordinate, Pair<Edge, Edge>> visitedEdge = new HashMap<>();, +            current.coordinate = shift(current.coordinate, shiftOffset);, +, +                // found a closed loop - we have two connected components so we need to slice into two distinct components, +                if (visitedEdge.containsKey(current.coordinate)) {, +                    if (connectedComponents > 0 && current.next != edge) {, +                        throw new InvalidShapeException("Shape contains more than one shared point");, +                    // a negative id flags the edge as visited for the edges(...) method., +                    // since we're splitting connected components, we want the edges method to visit, +                    // the newly separated component, +                    final int visitID = -id;, +                    Edge firstAppearance = visitedEdge.get(current.coordinate).getRight();, +                    // correct the graph pointers by correcting the 'next' pointer for both the, +                    // first appearance and this appearance of the edge, +                    Edge temp = firstAppearance.next;, +                    firstAppearance.next = current.next;, +                    current.next = temp;, +                    current.component = visitID;, +                    // backtrack until we get back to this coordinate, setting the visit id to, +                    // a non-visited value (anything positive), +                    do {, +                        prev.component = visitID;, +                        prev = visitedEdge.get(prev.coordinate).getLeft();, +                        ++splitIndex;, +                    } while (!current.coordinate.equals(prev.coordinate));, +                    ++connectedComponents;, +                } else {, +                    visitedEdge.put(current.coordinate, Pair.of(prev, current));, +                }, +                edges.add(current);, +                prev = current;, +            }, +        } while(connectedComponents == 0 && (current = current.next) != edge);, +        return (splitIndex != 1) ? length-splitIndex: length;, +            boolean sharedVertex = false;, +            if (intersections == 0 || ((pos = Arrays.binarySearch(edges, 0, intersections, current, INTERSECTION_ORDER)) >= 0), +                            && !(sharedVertex = (edges[pos].intersect.compareTo(current.coordinate) == 0)) ) {, +                throw new InvalidShapeException("Invalid shape: Hole is not within polygon");, +            final int index = -((sharedVertex) ? 0 : pos+2);, +        boolean direction = (component == 0 ^ orientation == Orientation.RIGHT);, +++ b/src/main/java/org/elasticsearch/common/geo/builders/BasePolygonBuilder.java, +import com.google.common.collect.Sets;, +import com.spatial4j.core.exception.InvalidShapeException;, +import org.apache.commons.lang3.tuple.Pair;, +import java.util.HashMap;, +import java.util.HashSet;, +     * Validates only 1 vertex is tangential (shared) between the interior and exterior of a polygon, +     */, +    protected void validateHole(BaseLineStringBuilder shell, BaseLineStringBuilder hole) {, +        HashSet exterior = Sets.newHashSet(shell.points);, +        HashSet interior = Sets.newHashSet(hole.points);, +        exterior.retainAll(interior);, +        if (exterior.size() >= 2) {, +            throw new InvalidShapeException("Invalid polygon, interior cannot share more than one point with the exterior");, +        }, +    }, +, +    /**, +            validateHole(shell, this.holes.get(i));, +        double shiftOffset = any.coordinate.x > DATELINE ? DATELINE : (any.coordinate.x < -DATELINE ? -DATELINE : 0);, +            LOGGER.debug("shift: {[]}", shiftOffset);, +        int length = 0, connectedComponents = 0;, +        // if there are two connected components, splitIndex keeps track of where to split the edge array, +        // start at 1 since the source coordinate is shared, +        int splitIndex = 1;, +        Edge prev = edge;, +        // bookkeep the source and sink of each visited coordinate, +        HashMap<Coordinate, Pair<Edge, Edge>> visitedEdge = new HashMap<>();, +            current.coordinate = shift(current.coordinate, shiftOffset);, +, +                // found a closed loop - we have two connected components so we need to slice into two distinct components, +                if (visitedEdge.containsKey(current.coordinate)) {, +                    if (connectedComponents > 0 && current.next != edge) {]