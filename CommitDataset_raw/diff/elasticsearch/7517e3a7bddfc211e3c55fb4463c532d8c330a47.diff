[+++ b/server/src/main/java/org/elasticsearch/common/logging/DeprecationLogger.java, +                    next.addResponseHeader("Warning", warningHeaderValue);, +++ b/server/src/main/java/org/elasticsearch/common/logging/DeprecationLogger.java, +                    next.addResponseHeader("Warning", warningHeaderValue);, +++ b/server/src/main/java/org/elasticsearch/common/util/concurrent/ThreadContext.java, +import java.util.EnumSet;, +import java.util.LinkedHashSet;, +import java.util.function.BiConsumer;, +import java.util.function.BinaryOperator;, +import java.util.stream.Collector;, +        Map<String, Set<String>> responseHeaders = threadLocal.get().responseHeaders;, +        for (Map.Entry<String, Set<String>> entry : responseHeaders.entrySet()) {, +            map.put(entry.getKey(), Collections.unmodifiableList(new ArrayList<>(entry.getValue())));, +        private final Map<String, Set<String>> responseHeaders;, +            this.responseHeaders = in.readMap(StreamInput::readString, input -> {, +                final int size = input.readVInt();, +                if (size == 0) {, +                    return Collections.emptySet();, +                } else if (size == 1) {, +                    return Collections.singleton(input.readString());, +                } else {, +                    // use a linked hash set to preserve order, +                    final LinkedHashSet<String> values = new LinkedHashSet<>(size);, +                    for (int i = 0; i < size; i++) {, +                        final String value = input.readString();, +                        final boolean added = values.add(value);, +                        assert added : value;, +                    }, +                    return values;, +                }, +            });, +                                    Map<String, Set<String>> responseHeaders,, +                                    Map<String, Set<String>> responseHeaders,, +        private ThreadContextStruct putResponseHeaders(Map<String, Set<String>> headers) {, +            final Map<String, Set<String>> newResponseHeaders = new HashMap<>(this.responseHeaders);, +            for (Map.Entry<String, Set<String>> entry : headers.entrySet()) {, +                final Set<String> existingValues = newResponseHeaders.get(key);, +                    final Set<String> newValues =, +                            Stream.concat(entry.getValue().stream(), existingValues.stream()).collect(LINKED_HASH_SET_COLLECTOR);, +                    newResponseHeaders.put(key, Collections.unmodifiableSet(newValues));, +            final Map<String, Set<String>> newResponseHeaders;, +            final Set<String> existingValues = responseHeaders.get(key);, +                if (existingValues.contains(uniqueValue.apply(value))) {, +                // preserve insertion order, +                final Set<String> newValues = Stream.concat(existingValues.stream(), Stream.of(value)).collect(LINKED_HASH_SET_COLLECTOR);, +                newResponseHeaders = new HashMap<>(responseHeaders);, +                newResponseHeaders.put(key, Collections.unmodifiableSet(newValues));, +                newResponseHeaders = new HashMap<>(responseHeaders);, +                newResponseHeaders.put(key, Collections.singleton(value));, +            out.writeMap(responseHeaders, StreamOutput::writeString, StreamOutput::writeStringCollection);, +, +    private static final Collector<String, Set<String>, Set<String>> LINKED_HASH_SET_COLLECTOR = new LinkedHashSetCollector<>();, +, +    private static class LinkedHashSetCollector<T> implements Collector<T, Set<T>, Set<T>> {, +        @Override, +        public Supplier<Set<T>> supplier() {, +            return LinkedHashSet::new;, +        }, +, +        @Override, +        public BiConsumer<Set<T>, T> accumulator() {, +            return Set::add;, +        }, +, +        @Override, +        public BinaryOperator<Set<T>> combiner() {, +            return (left, right) -> {, +                left.addAll(right);, +                return left;, +            };, +        }, +, +        @Override, +        public Function<Set<T>, Set<T>> finisher() {, +            return Function.identity();, +        }, +, +        private static final Set<Characteristics> CHARACTERISTICS =, +                Collections.unmodifiableSet(EnumSet.of(Collector.Characteristics.IDENTITY_FINISH));, +, +        @Override, +        public Set<Characteristics> characteristics() {, +            return CHARACTERISTICS;, +        }, +    }, +]