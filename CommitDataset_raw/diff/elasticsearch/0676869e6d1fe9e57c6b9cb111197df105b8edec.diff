[+++ b/src/main/java/org/elasticsearch/index/engine/internal/InternalEngine.java, +        try {, +            SearcherManager manager = this.searcherManager;, +            if (manager == null) {, +                ensureOpen();, +                try (InternalLock _ = this.readLock.acquire()) {, +                    // we might start up right now and the searcherManager is not initialized, +                    // we take the read lock and retry again since write lock is taken, +                    // while start() is called and otherwise the ensureOpen() call will, +                    // barf., +                    manager = this.searcherManager;, +                    assert manager != null : "SearcherManager is null but shouldn't";, +                }, +            }, +        } catch (EngineClosedException ex) {, +            throw ex;, +++ b/src/main/java/org/elasticsearch/index/engine/internal/InternalEngine.java, +        try {, +            SearcherManager manager = this.searcherManager;, +            if (manager == null) {, +                ensureOpen();, +                try (InternalLock _ = this.readLock.acquire()) {, +                    // we might start up right now and the searcherManager is not initialized, +                    // we take the read lock and retry again since write lock is taken, +                    // while start() is called and otherwise the ensureOpen() call will, +                    // barf., +                    manager = this.searcherManager;, +                    assert manager != null : "SearcherManager is null but shouldn't";, +                }, +            }, +        } catch (EngineClosedException ex) {, +            throw ex;, +++ b/src/test/java/org/elasticsearch/index/engine/internal/InternalEngineTests.java, +import org.apache.lucene.store.AlreadyClosedException;, +import java.util.concurrent.atomic.AtomicBoolean;, +    public void testStartAndAcquireConcurrently() {, +        ConcurrentMergeSchedulerProvider mergeSchedulerProvider = new ConcurrentMergeSchedulerProvider(shardId, EMPTY_SETTINGS, threadPool, new IndexSettingsService(shardId.index(), EMPTY_SETTINGS));, +        final Engine engine = createEngine(engineSettingsService, store, createTranslog(), mergeSchedulerProvider);, +        final AtomicBoolean startPending = new AtomicBoolean(true);, +        Thread thread = new Thread() {, +            public void run() {, +                try {, +                    Thread.yield();, +                    engine.start();, +                } finally {, +                    startPending.set(false);, +                }, +, +            }, +        };, +        thread.start();, +        while(startPending.get()) {, +            try {, +                engine.acquireSearcher("foobar").close();, +                break;, +            } catch (EngineClosedException ex) {, +                // all good, +            }, +        }, +        engine.close();, +    }, +]