[+++ b/src/main/java/org/elasticsearch/indices/recovery/RecoveryTarget.java, +            validateRecoveryStatus(onGoingRecovery, request.shardId());, +            validateRecoveryStatus(onGoingRecovery, request.shardId());, +            validateRecoveryStatus(onGoingRecovery, request.shardId());, +                validateRecoveryStatus(onGoingRecovery, request.shardId());, +            validateRecoveryStatus(onGoingRecovery, request.shardId());, +            validateRecoveryStatus(onGoingRecovery, request.shardId());, +            validateRecoveryStatus(onGoingRecovery, request.shardId());, +, +    private void validateRecoveryStatus(RecoveryStatus onGoingRecovery, ShardId shardId) {, +        if (onGoingRecovery == null) {, +            // shard is getting closed on us, +            throw new IndexShardClosedException(shardId);, +        }, +        if (onGoingRecovery.indexShard.state() == IndexShardState.CLOSED) {, +            cancelRecovery(onGoingRecovery.indexShard);, +            onGoingRecovery.sentCanceledToSource = true;, +            throw new IndexShardClosedException(shardId);, +        }, +        if (onGoingRecovery.isCanceled()) {, +            onGoingRecovery.sentCanceledToSource = true;, +            throw new IndexShardClosedException(shardId);, +        }, +    }, +++ b/src/main/java/org/elasticsearch/indices/recovery/RecoveryTarget.java, +            validateRecoveryStatus(onGoingRecovery, request.shardId());, +            validateRecoveryStatus(onGoingRecovery, request.shardId());, +            validateRecoveryStatus(onGoingRecovery, request.shardId());, +                validateRecoveryStatus(onGoingRecovery, request.shardId());, +            validateRecoveryStatus(onGoingRecovery, request.shardId());, +            validateRecoveryStatus(onGoingRecovery, request.shardId());, +            validateRecoveryStatus(onGoingRecovery, request.shardId());, +, +    private void validateRecoveryStatus(RecoveryStatus onGoingRecovery, ShardId shardId) {, +        if (onGoingRecovery == null) {, +            // shard is getting closed on us, +            throw new IndexShardClosedException(shardId);, +        }, +        if (onGoingRecovery.indexShard.state() == IndexShardState.CLOSED) {, +            cancelRecovery(onGoingRecovery.indexShard);, +            onGoingRecovery.sentCanceledToSource = true;, +            throw new IndexShardClosedException(shardId);, +        }, +        if (onGoingRecovery.isCanceled()) {, +            onGoingRecovery.sentCanceledToSource = true;, +            throw new IndexShardClosedException(shardId);, +        }, +    }, +++ b/src/test/java/org/elasticsearch/recovery/RelocationTests.java, +import com.google.common.base.Predicate;, +import com.google.common.util.concurrent.ListenableFuture;, +import org.elasticsearch.action.admin.cluster.state.ClusterStateResponse;, +import org.elasticsearch.action.admin.indices.recovery.RecoveryResponse;, +import org.elasticsearch.action.admin.indices.stats.IndicesStatsResponse;, +import org.elasticsearch.cluster.metadata.IndexMetaData;, +import org.elasticsearch.cluster.routing.allocation.decider.FilterAllocationDecider;, +import org.elasticsearch.discovery.DiscoveryService;, +import org.elasticsearch.indices.recovery.RecoverySettings;, +import static org.elasticsearch.test.hamcrest.ElasticsearchAssertions.assertHitCount;, +import static org.hamcrest.Matchers.is;, +    @Test, +    public void testMoveShardsWhileRelocation() throws Exception {, +        final String indexName = "test";, +, +        ListenableFuture<String> blueFuture = internalCluster().startNodeAsync(ImmutableSettings.builder().put("node.color", "blue").build());, +        internalCluster().startNodeAsync(ImmutableSettings.builder().put("node.color", "green").build());, +        ListenableFuture<String> redFuture = internalCluster().startNodeAsync(ImmutableSettings.builder().put("node.color", "red").build());, +, +        ClusterHealthResponse response = client().admin().cluster().prepareHealth().setWaitForNodes(">=3").get();, +        assertThat(response.isTimedOut(), is(false));, +, +        String blueNodeName = blueFuture.get();, +        final String redNodeName = redFuture.get();, +, +        client().admin().indices().prepareCreate(indexName), +                .setSettings(, +                        ImmutableSettings.builder(), +                                .put(FilterAllocationDecider.INDEX_ROUTING_INCLUDE_GROUP + "color", "blue"), +                                .put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, 0), +                ).get();, +, +        List<IndexRequestBuilder> requests = new ArrayList<>();, +        int numDocs = scaledRandomIntBetween(25, 250);, +        for (int i = 0; i < numDocs; i++) {, +            requests.add(client().prepareIndex(indexName, "type").setCreate(true).setSource("{}"));, +        }, +        indexRandom(true, requests);, +        ensureSearchable(indexName);, +, +        ClusterStateResponse stateResponse = client().admin().cluster().prepareState().get();, +        String blueNodeId = internalCluster().getInstance(DiscoveryService.class, blueNodeName).localNode().id();, +, +        assertFalse(stateResponse.getState().readOnlyRoutingNodes().node(blueNodeId).isEmpty());, +, +        SearchResponse searchResponse = client().prepareSearch(indexName).get();, +        assertHitCount(searchResponse, numDocs);, +, +        // Slow down recovery in order to make recovery cancellations more likely, +        IndicesStatsResponse statsResponse = client().admin().indices().prepareStats(indexName).get();, +        long chunkSize = statsResponse.getIndex(indexName).getShards()[0].getStats().getStore().size().bytes() / 10;]