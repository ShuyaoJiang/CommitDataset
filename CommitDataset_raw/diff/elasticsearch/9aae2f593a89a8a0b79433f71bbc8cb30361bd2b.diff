[+++ b/core/src/main/java/org/elasticsearch/action/search/AbstractSearchAsyncAction.java, +        super(name, request, shardsIts, logger, maxConcurrentShardRequests, executor);, +++ b/core/src/main/java/org/elasticsearch/action/search/AbstractSearchAsyncAction.java, +        super(name, request, shardsIts, logger, maxConcurrentShardRequests, executor);, +++ b/core/src/main/java/org/elasticsearch/action/search/InitialSearchPhase.java, +import org.elasticsearch.common.util.concurrent.AbstractRunnable;, +import java.util.ArrayList;, +import java.util.List;, +import java.util.concurrent.Executor;, +    private final GroupShardsIterator<SearchShardIterator> toSkipShardsIts;, +    private final Executor executor;, +                       int maxConcurrentShardRequests, Executor executor) {, +        final List<SearchShardIterator> toSkipIterators = new ArrayList<>();, +        final List<SearchShardIterator> iterators = new ArrayList<>();, +        for (final SearchShardIterator iterator : shardsIts) {, +            if (iterator.skip()) {, +                toSkipIterators.add(iterator);, +            } else {, +                iterators.add(iterator);, +            }, +        }, +        this.toSkipShardsIts = new GroupShardsIterator<>(toSkipIterators);, +        this.shardsIts = new GroupShardsIterator<>(iterators);, +        this.executor = executor;, +        for (final SearchShardIterator iterator : toSkipShardsIts) {, +            assert iterator.skip();, +            skipShard(iterator);, +        }, +        if (shardsIts.size() > 0) {, +            int maxConcurrentShardRequests = Math.min(this.maxConcurrentShardRequests, shardsIts.size());, +            final boolean success = shardExecutionIndex.compareAndSet(0, maxConcurrentShardRequests);, +            for (int index = 0; index < maxConcurrentShardRequests; index++) {, +                final SearchShardIterator shardRoutings = shardsIts.get(index);, +                assert shardRoutings.skip() == false;, +                performPhaseOnShard(index, shardRoutings, shardRoutings.nextOrNull());, +            final SearchShardIterator shardRoutings = shardsIts.get(index);, +, +, +    private void maybeFork(final Thread thread, final Runnable runnable) {, +        if (thread == Thread.currentThread()) {, +            fork(runnable);, +        } else {, +            runnable.run();, +        }, +    private void fork(final Runnable runnable) {, +        executor.execute(new AbstractRunnable() {, +            @Override, +            public void onFailure(Exception e) {, +, +            }, +, +            @Override, +            protected void doRun() throws Exception {, +                runnable.run();, +            }, +, +            @Override, +            public boolean isForceExecution() {, +                // we can not allow a stuffed queue to reject execution here, +                return true;, +            }, +        });, +    }, +        /*, +         * We capture the thread that this phase is starting on. When we are called back after executing the phase, we are either on the, +         * same thread (because we never went async, or the same thread was selected from the thread pool) or a different thread. If we, +         * continue on the same thread in the case that we never went async and this happens repeatedly we will end up recursing deeply and, +         * could stack overflow. To prevent this, we fork if we are called back on the same thread that execution started on and otherwise, +         * we can continue (cf. InitialSearchPhase#maybeFork)., +         */, +        final Thread thread = Thread.currentThread();, +            fork(() -> onShardFailure(shardIndex, null, null, shardIt, new NoShardAvailableActionException(shardIt.shardId())));, +                        maybeFork(thread, () -> onShardResult(result, shardIt));, +                        maybeFork(thread, () -> onShardFailure(shardIndex, shard, shard.currentNodeId(), shardIt, t));, +            } catch (final Exception e) {, +                /*, +                 * It is possible to run into connection exceptions here because we are getting the connection early and might run in to, +                 * nodes that are not connected. In this case, on shard failure will move us to the next shard copy., +                 */, +                fork(() -> onShardFailure(shardIndex, shard, shard.currentNodeId(), shardIt, e));, +        } else if (shardsIt.skip() == false) {, +++ b/core/src/main/java/org/elasticsearch/action/search/AbstractSearchAsyncAction.java, +        super(name, request, shardsIts, logger, maxConcurrentShardRequests, executor);, +++ b/core/src/main/java/org/elasticsearch/action/search/InitialSearchPhase.java, +import org.elasticsearch.common.util.concurrent.AbstractRunnable;, +import java.util.ArrayList;, +import java.util.List;, +import java.util.concurrent.Executor;, +    private final GroupShardsIterator<SearchShardIterator> toSkipShardsIts;, +    private final Executor executor;, +                       int maxConcurrentShardRequests, Executor executor) {, +        final List<SearchShardIterator> toSkipIterators = new ArrayList<>();, +        final List<SearchShardIterator> iterators = new ArrayList<>();, +        for (final SearchShardIterator iterator : shardsIts) {, +            if (iterator.skip()) {, +                toSkipIterators.add(iterator);, +            } else {, +                iterators.add(iterator);, +            }, +        }]