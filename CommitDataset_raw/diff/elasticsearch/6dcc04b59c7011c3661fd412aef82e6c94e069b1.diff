[+++ b/modules/elasticsearch/src/main/java/org/elasticsearch/common/network/NetworkService.java, +import org.elasticsearch.common.unit.TimeValue;, +import java.util.concurrent.TimeUnit;, +        public static final String TCP_CONNECT_TIMEOUT = "network.tcp.connect_timeout";, +        public static TimeValue TCP_DEFAULT_CONNECT_TIMEOUT = new TimeValue(30, TimeUnit.SECONDS);, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/common/network/NetworkService.java, +import org.elasticsearch.common.unit.TimeValue;, +import java.util.concurrent.TimeUnit;, +        public static final String TCP_CONNECT_TIMEOUT = "network.tcp.connect_timeout";, +        public static TimeValue TCP_DEFAULT_CONNECT_TIMEOUT = new TimeValue(30, TimeUnit.SECONDS);, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/transport/netty/NettyTransport.java, +import org.elasticsearch.common.collect.ImmutableList;, +        this.connectTimeout = componentSettings.getAsTime("connect_timeout", settings.getAsTime("transport.tcp.connect_timeout", settings.getAsTime(TCP_CONNECT_TIMEOUT, TCP_DEFAULT_CONNECT_TIMEOUT)));, +                    connectToChannels(nodeChannels, node);, +        } catch (ConnectTransportException e) {, +            throw e;, +    private void connectToChannels(NodeChannels nodeChannels, DiscoveryNode node) {, +        ChannelFuture[] connectLow = new ChannelFuture[nodeChannels.low.length];, +        ChannelFuture[] connectMed = new ChannelFuture[nodeChannels.med.length];, +        ChannelFuture[] connectHigh = new ChannelFuture[nodeChannels.high.length];, +        for (int i = 0; i < connectLow.length; i++) {, +            connectLow[i] = clientBootstrap.connect(address);, +        for (int i = 0; i < connectMed.length; i++) {, +            connectMed[i] = clientBootstrap.connect(address);, +        }, +        for (int i = 0; i < connectHigh.length; i++) {, +            connectHigh[i] = clientBootstrap.connect(address);, +        }, +, +        try {, +            for (int i = 0; i < connectLow.length; i++) {, +                connectLow[i].awaitUninterruptibly((long) (connectTimeout.millis() * 1.5));, +                if (!connectLow[i].isSuccess()) {, +                    throw new ConnectTransportException(node, "connect_timeout[" + connectTimeout + "]", connectLow[i].getCause());, +                }, +                nodeChannels.low[i] = connectLow[i].getChannel();, +                nodeChannels.low[i].getCloseFuture().addListener(new ChannelCloseListener(node));, +            }, +, +            for (int i = 0; i < connectMed.length; i++) {, +                connectMed[i].awaitUninterruptibly((long) (connectTimeout.millis() * 1.5));, +                if (!connectMed[i].isSuccess()) {, +                    throw new ConnectTransportException(node, "connect_timeout[" + connectTimeout + "]", connectMed[i].getCause());, +                }, +                nodeChannels.med[i] = connectMed[i].getChannel();, +                nodeChannels.med[i].getCloseFuture().addListener(new ChannelCloseListener(node));, +            }, +, +            for (int i = 0; i < connectHigh.length; i++) {, +                connectHigh[i].awaitUninterruptibly((long) (connectTimeout.millis() * 1.5));, +                if (!connectHigh[i].isSuccess()) {, +                    throw new ConnectTransportException(node, "connect_timeout[" + connectTimeout + "]", connectHigh[i].getCause());, +                }, +                nodeChannels.high[i] = connectHigh[i].getChannel();, +                nodeChannels.high[i].getCloseFuture().addListener(new ChannelCloseListener(node));, +            }, +        } catch (RuntimeException e) {, +            // clean the futures, +            for (ChannelFuture future : ImmutableList.<ChannelFuture>builder().add(connectLow).add(connectMed).add(connectHigh).build()) {, +                future.cancel();, +                if (future.getChannel() != null && future.getChannel().isOpen()) {, +                    try {, +                        future.getChannel().close();, +                    } catch (Exception e1) {, +                        // ignore, +                    }, +                }, +            }, +            throw e;, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/common/network/NetworkService.java, +import org.elasticsearch.common.unit.TimeValue;, +import java.util.concurrent.TimeUnit;, +        public static final String TCP_CONNECT_TIMEOUT = "network.tcp.connect_timeout";, +        public static TimeValue TCP_DEFAULT_CONNECT_TIMEOUT = new TimeValue(30, TimeUnit.SECONDS);, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/transport/netty/NettyTransport.java, +import org.elasticsearch.common.collect.ImmutableList;, +        this.connectTimeout = componentSettings.getAsTime("connect_timeout", settings.getAsTime("transport.tcp.connect_timeout", settings.getAsTime(TCP_CONNECT_TIMEOUT, TCP_DEFAULT_CONNECT_TIMEOUT)));, +                    connectToChannels(nodeChannels, node);, +        } catch (ConnectTransportException e) {, +            throw e;, +    private void connectToChannels(NodeChannels nodeChannels, DiscoveryNode node) {, +        ChannelFuture[] connectLow = new ChannelFuture[nodeChannels.low.length];, +        ChannelFuture[] connectMed = new ChannelFuture[nodeChannels.med.length];, +        ChannelFuture[] connectHigh = new ChannelFuture[nodeChannels.high.length];, +        for (int i = 0; i < connectLow.length; i++) {, +            connectLow[i] = clientBootstrap.connect(address);, +        for (int i = 0; i < connectMed.length; i++) {, +            connectMed[i] = clientBootstrap.connect(address);, +        }, +        for (int i = 0; i < connectHigh.length; i++) {, +            connectHigh[i] = clientBootstrap.connect(address);, +        }, +, +        try {, +            for (int i = 0; i < connectLow.length; i++) {, +                connectLow[i].awaitUninterruptibly((long) (connectTimeout.millis() * 1.5));, +                if (!connectLow[i].isSuccess()) {, +                    throw new ConnectTransportException(node, "connect_timeout[" + connectTimeout + "]", connectLow[i].getCause());, +                }, +                nodeChannels.low[i] = connectLow[i].getChannel();]