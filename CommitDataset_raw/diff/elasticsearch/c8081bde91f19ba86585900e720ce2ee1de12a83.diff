[+++ b/buildSrc/src/main/resources/checkstyle_suppressions.xml, +++ b/buildSrc/src/main/resources/checkstyle_suppressions.xml, +++ b/core/src/main/java/org/elasticsearch/action/bulk/MappingUpdatePerformer.java, +import org.elasticsearch.index.shard.ShardId;, +     * Determine if any mappings need to be updated, and update them on the master node if, +     * necessary. Returnes a failure Exception in the event updating the mappings fails or null if, +     * successful., +    void updateMappingsIfNeeded(Engine.Index operation,, +                                ShardId shardId,, +                                String type) throws Exception;, +    /**, +     *  Throws a {@code ReplicationOperation.RetryOnPrimaryException} if the operation needs to be, +     * retried on the primary due to the mappings not being present yet, or a different exception if, +     * updating the mappings on the master failed., +     */, +    void verifyMappings(Engine.Index operation, ShardId shardId) throws Exception;, +++ b/buildSrc/src/main/resources/checkstyle_suppressions.xml, +++ b/core/src/main/java/org/elasticsearch/action/bulk/MappingUpdatePerformer.java, +import org.elasticsearch.index.shard.ShardId;, +     * Determine if any mappings need to be updated, and update them on the master node if, +     * necessary. Returnes a failure Exception in the event updating the mappings fails or null if, +     * successful., +    void updateMappingsIfNeeded(Engine.Index operation,, +                                ShardId shardId,, +                                String type) throws Exception;, +    /**, +     *  Throws a {@code ReplicationOperation.RetryOnPrimaryException} if the operation needs to be, +     * retried on the primary due to the mappings not being present yet, or a different exception if, +     * updating the mappings on the master failed., +     */, +    void verifyMappings(Engine.Index operation, ShardId shardId) throws Exception;, +++ b/core/src/main/java/org/elasticsearch/action/bulk/TransportShardBulkAction.java, +import org.elasticsearch.index.translog.Translog.Location;, +import org.elasticsearch.action.bulk.BulkItemResultHolder;, +import org.elasticsearch.action.bulk.BulkItemResponse;, +    static Translog.Location calculateTranslogLocation(final Translog.Location originalLocation,, +                                                       final BulkItemResultHolder bulkItemResult) {, +        final Engine.Result operationResult = bulkItemResult.operationResult;, +        if (operationResult != null && operationResult.hasFailure() == false) {, +            return locationToSync(originalLocation, operationResult.getTranslogLocation());, +        } else {, +            return originalLocation;, +        }, +    }, +, +    /**, +     * Creates a BulkItemResponse for the primary operation and returns it. If no bulk response is, +     * needed (because one already exists and the operation failed), then return null., +     */, +    static BulkItemResponse createPrimaryResponse(BulkItemResultHolder bulkItemResult,, +            return new BulkItemResponse(replicaRequest.id(), opType, response);, +            return primaryResponse;, +                return new BulkItemResponse(replicaRequest.id(), docWriteRequest.opType(),, +                        // Make sure to use request.index() here, if you, +                        new BulkItemResponse.Failure(request.index(), docWriteRequest.type(), docWriteRequest.id(), failure));, +            } else {, +                assert replicaRequest.getPrimaryResponse() != null : "replica request must have a primary response";, +                return null;, +        // Retrieve the primary response, and update the replica request with the primary's response, +        BulkItemResponse primaryResponse = createPrimaryResponse(responseHolder, opType, request);, +        if (primaryResponse != null) {, +            replicaRequest.setPrimaryResponse(primaryResponse);, +        }, +        // Update the translog with the new location, if needed, +        return calculateTranslogLocation(location, responseHolder);, +    private static Translog.Location locationToSync(Translog.Location current,, +                                                    Translog.Location next) {, +        /* here we are moving forward in the translog with each operation. Under the hood this might, +         * cross translog files which is ok since from the user perspective the translog is like a, +         * tape where only the highest location needs to be fsynced in order to sync all previous, +         * locations even though they are not in the same file. When the translog rolls over files, +         * the previous file is fsynced on after closing if needed.*/, +        assert current == null || current.compareTo(next) < 0 :, +                "translog locations are not increasing";, +    public static Engine.IndexResult executeIndexRequestOnReplica(, +            DocWriteResponse primaryResponse,, +            IndexRequest request,, +            IndexShard replica) throws IOException {, +            operation = prepareIndexOperationOnReplica(primaryResponse, request, replica);, +            return new Engine.IndexResult(e, primaryResponse.getVersion(),, +                    primaryResponse.getSeqNo());, +, +            final ShardId shardId = replica.shardId();, +            throw new RetryOnReplicaException(shardId,, +                    "Mappings are not available on the replica yet, triggered update: " + update);, +    /** Utility method to prepare an index operation on replica shards */, +    static Engine.Index prepareIndexOperationOnReplica(, +            DocWriteResponse primaryResponse,, +            IndexRequest request,, +            IndexShard replica) {, +, +        final ShardId shardId = replica.shardId();, +        final long version = primaryResponse.getVersion();, +        final long seqNo = primaryResponse.getSeqNo();, +        final SourceToParse sourceToParse =, +                SourceToParse.source(SourceToParse.Origin.REPLICA, shardId.getIndexName(),, +                        request.type(), request.id(), request.source(), request.getContentType()), +                .routing(request.routing()).parent(request.parent());, +        final VersionType versionType = request.versionType().versionTypeForReplicationAndRecovery();, +        assert versionType.validateVersionForWrites(version);]