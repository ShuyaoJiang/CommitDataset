[+++ b/src/main/java/org/elasticsearch/action/support/master/TransportMasterNodeOperationAction.java, +import org.elasticsearch.cluster.ClusterStateObserver;, +        innerExecute(request, listener, new ClusterStateObserver(clusterService, request.masterNodeTimeout(), logger), false);, +    private void innerExecute(final Request request, final ActionListener<Response> listener, final ClusterStateObserver observer, final boolean retrying) {, +        final ClusterState clusterState = observer.observedState();, +                logger.trace("can't execute due to a cluster block: [{}], retrying", blockException);, +                observer.waitForNextChange(, +                        new ClusterStateObserver.Listener() {, +                            public void onNewClusterState(ClusterState state) {, +                                innerExecute(request, listener, observer, false);, +                            public void onClusterServiceClose() {, +                        }, new ClusterStateObserver.ValidationPredicate() {, +                            protected boolean validate(ClusterState newState) {, +                                ClusterBlockException blockException = checkBlock(request, newState);, +                                return (blockException == null || !blockException.retryable());, +                );, +, +                    observer.waitForNextChange(, +                            new ClusterStateObserver.Listener() {, +                                public void onNewClusterState(ClusterState state) {, +                                    innerExecute(request, listener, observer, true);, +                                public void onClusterServiceClose() {, +                            }, new ClusterStateObserver.ChangePredicate() {, +                                @Override, +                                public boolean apply(ClusterState previousState, ClusterState.ClusterStateStatus previousStatus,, +                                                     ClusterState newState, ClusterState.ClusterStateStatus newStatus) {, +                                    return newState.nodes().masterNodeId() != null;, +                                }, +                                public boolean apply(ClusterChangedEvent event) {, +                                    return event.nodesDelta().masterNodeChanged();, +                    );, +                        observer.waitForNextChange(new ClusterStateObserver.Listener() {, +                                                       public void onNewClusterState(ClusterState state) {, +                                                           innerExecute(request, listener, observer, false);, +                                                       public void onClusterServiceClose() {, +                                                   }, new ClusterStateObserver.EventPredicate() {, +                                                       public boolean apply(ClusterChangedEvent event) {, +                                                           return event.nodesDelta().masterNodeChanged();, +                        );, +++ b/src/main/java/org/elasticsearch/action/support/master/TransportMasterNodeOperationAction.java, +import org.elasticsearch.cluster.ClusterStateObserver;, +        innerExecute(request, listener, new ClusterStateObserver(clusterService, request.masterNodeTimeout(), logger), false);, +    private void innerExecute(final Request request, final ActionListener<Response> listener, final ClusterStateObserver observer, final boolean retrying) {, +        final ClusterState clusterState = observer.observedState();, +                logger.trace("can't execute due to a cluster block: [{}], retrying", blockException);, +                observer.waitForNextChange(, +                        new ClusterStateObserver.Listener() {, +                            public void onNewClusterState(ClusterState state) {, +                                innerExecute(request, listener, observer, false);, +                            public void onClusterServiceClose() {, +                        }, new ClusterStateObserver.ValidationPredicate() {, +                            protected boolean validate(ClusterState newState) {, +                                ClusterBlockException blockException = checkBlock(request, newState);, +                                return (blockException == null || !blockException.retryable());, +                );, +, +                    observer.waitForNextChange(, +                            new ClusterStateObserver.Listener() {, +                                public void onNewClusterState(ClusterState state) {, +                                    innerExecute(request, listener, observer, true);, +                                public void onClusterServiceClose() {, +                            }, new ClusterStateObserver.ChangePredicate() {, +                                @Override, +                                public boolean apply(ClusterState previousState, ClusterState.ClusterStateStatus previousStatus,, +                                                     ClusterState newState, ClusterState.ClusterStateStatus newStatus) {, +                                    return newState.nodes().masterNodeId() != null;, +                                }, +                                public boolean apply(ClusterChangedEvent event) {, +                                    return event.nodesDelta().masterNodeChanged();, +                    );, +                        observer.waitForNextChange(new ClusterStateObserver.Listener() {, +                                                       public void onNewClusterState(ClusterState state) {, +                                                           innerExecute(request, listener, observer, false);, +                                                       public void onClusterServiceClose() {, +                                                   }, new ClusterStateObserver.EventPredicate() {, +                                                       public boolean apply(ClusterChangedEvent event) {, +                                                           return event.nodesDelta().masterNodeChanged();, +                        );, +++ b/src/main/java/org/elasticsearch/action/support/replication/TransportShardReplicationOperationAction.java, +import org.elasticsearch.cluster.ClusterStateObserver;, +        private volatile ClusterStateObserver observer;, +            observer = new ClusterStateObserver(clusterService, request.timeout(), logger);, +            doStart();, +        protected boolean doStart() throws ElasticsearchException {, +                ClusterBlockException blockException = checkGlobalBlock(observer.observedState(), request);, +                        retry(blockException);, +                if (!resolveRequest(observer.observedState(), request, listener)) {, +                blockException = checkRequestBlock(observer.observedState(), request);, +                        retry(blockException);, +                shardIt = shards(observer.observedState(), request);, +                retry(null);, +                if (!shard.active() || !observer.observedState().nodes().nodeExists(shard.currentNodeId())) {, +                    retry(null);, +                        retry(null);, +                if (shard.currentNodeId().equals(observer.observedState().nodes().localNodeId())) {, +                                        performOnPrimary(shard.id(), shard, observer.observedState());, +                            performOnPrimary(shard.id(), shard, observer.observedState());, +                    DiscoveryNode node = observer.observedState().nodes().get(shard.currentNodeId());, +                                retry(null);, +                retry(null);]