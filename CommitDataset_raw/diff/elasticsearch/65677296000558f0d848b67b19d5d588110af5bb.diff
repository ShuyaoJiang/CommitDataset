[+++ b/server/src/main/java/org/elasticsearch/ingest/CompoundProcessor.java, +import org.elasticsearch.common.collect.Tuple;, +import java.util.concurrent.TimeUnit;, +import java.util.function.LongSupplier;, +    private final List<Tuple<Processor, IngestMetric>> processorsWithMetrics;, +    private final LongSupplier relativeTimeProvider;, +, +    CompoundProcessor(LongSupplier relativeTimeProvider, Processor... processor) {, +        this(false, Arrays.asList(processor), Collections.emptyList(), relativeTimeProvider);, +    }, +        this(ignoreFailure, processors, onFailureProcessors, System::nanoTime);, +    }, +    CompoundProcessor(boolean ignoreFailure, List<Processor> processors, List<Processor> onFailureProcessors,, +                      LongSupplier relativeTimeProvider) {, +        this.relativeTimeProvider = relativeTimeProvider;, +        this.processorsWithMetrics = new ArrayList<>(processors.size());, +        processors.forEach(p -> processorsWithMetrics.add(new Tuple<>(p, new IngestMetric())));, +    }, +, +    List<Tuple<Processor, IngestMetric>> getProcessorsWithMetrics() {, +        return processorsWithMetrics;, +        for (Tuple<Processor, IngestMetric> processorWithMetric : processorsWithMetrics) {, +            Processor processor = processorWithMetric.v1();, +            IngestMetric metric = processorWithMetric.v2();, +            long startTimeInNanos = relativeTimeProvider.getAsLong();, +                metric.preIngest();, +                metric.ingestFailed();, +            } finally {, +                long ingestTimeInMillis = TimeUnit.NANOSECONDS.toMillis(relativeTimeProvider.getAsLong() - startTimeInNanos);, +                metric.postIngest(ingestTimeInMillis);, +, +++ b/server/src/main/java/org/elasticsearch/ingest/CompoundProcessor.java, +import org.elasticsearch.common.collect.Tuple;, +import java.util.concurrent.TimeUnit;, +import java.util.function.LongSupplier;, +    private final List<Tuple<Processor, IngestMetric>> processorsWithMetrics;, +    private final LongSupplier relativeTimeProvider;, +, +    CompoundProcessor(LongSupplier relativeTimeProvider, Processor... processor) {, +        this(false, Arrays.asList(processor), Collections.emptyList(), relativeTimeProvider);, +    }, +        this(ignoreFailure, processors, onFailureProcessors, System::nanoTime);, +    }, +    CompoundProcessor(boolean ignoreFailure, List<Processor> processors, List<Processor> onFailureProcessors,, +                      LongSupplier relativeTimeProvider) {, +        this.relativeTimeProvider = relativeTimeProvider;, +        this.processorsWithMetrics = new ArrayList<>(processors.size());, +        processors.forEach(p -> processorsWithMetrics.add(new Tuple<>(p, new IngestMetric())));, +    }, +, +    List<Tuple<Processor, IngestMetric>> getProcessorsWithMetrics() {, +        return processorsWithMetrics;, +        for (Tuple<Processor, IngestMetric> processorWithMetric : processorsWithMetrics) {, +            Processor processor = processorWithMetric.v1();, +            IngestMetric metric = processorWithMetric.v2();, +            long startTimeInNanos = relativeTimeProvider.getAsLong();, +                metric.preIngest();, +                metric.ingestFailed();, +            } finally {, +                long ingestTimeInMillis = TimeUnit.NANOSECONDS.toMillis(relativeTimeProvider.getAsLong() - startTimeInNanos);, +                metric.postIngest(ingestTimeInMillis);, +, +++ b/server/src/main/java/org/elasticsearch/ingest/ConditionalProcessor.java, +import java.util.concurrent.TimeUnit;, +import java.util.function.LongSupplier;, +    private final IngestMetric metric;, +    private final LongSupplier relativeTimeProvider;, +        this(tag, script, scriptService, processor, System::nanoTime);, +    }, +, +    ConditionalProcessor(String tag, Script script, ScriptService scriptService, Processor processor, LongSupplier relativeTimeProvider) {, +        this.metric = new IngestMetric();, +        this.relativeTimeProvider = relativeTimeProvider;, +            // Only record metric if the script evaluates to true, +            long startTimeInNanos = relativeTimeProvider.getAsLong();, +            try {, +                metric.preIngest();, +            } catch (Exception e) {, +                metric.ingestFailed();, +                throw e;, +            } finally {, +                long ingestTimeInMillis = TimeUnit.NANOSECONDS.toMillis(relativeTimeProvider.getAsLong() - startTimeInNanos);, +                metric.postIngest(ingestTimeInMillis);, +            }, +    Processor getProcessor() {, +        return processor;, +    }, +, +    IngestMetric getMetric() {, +        return metric;, +    }, +, +++ b/server/src/main/java/org/elasticsearch/ingest/CompoundProcessor.java, +import org.elasticsearch.common.collect.Tuple;, +import java.util.concurrent.TimeUnit;, +import java.util.function.LongSupplier;, +    private final List<Tuple<Processor, IngestMetric>> processorsWithMetrics;, +    private final LongSupplier relativeTimeProvider;, +, +    CompoundProcessor(LongSupplier relativeTimeProvider, Processor... processor) {]