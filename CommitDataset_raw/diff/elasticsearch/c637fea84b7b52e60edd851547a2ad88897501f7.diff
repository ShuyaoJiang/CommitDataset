[+++ b/core/src/main/java/org/elasticsearch/action/admin/cluster/snapshots/restore/RestoreSnapshotRequest.java, +    private boolean includeGlobalState = false;, +++ b/core/src/main/java/org/elasticsearch/action/admin/cluster/snapshots/restore/RestoreSnapshotRequest.java, +    private boolean includeGlobalState = false;, +++ b/core/src/main/java/org/elasticsearch/common/rounding/TimeZoneRounding.java, +            long timeLocal = utcMillis;, +            timeLocal = timeZone.convertUTCToLocal(utcMillis);, +            return timeZone.convertLocalToUTC(rounded, false);, +++ b/core/src/main/java/org/elasticsearch/action/admin/cluster/snapshots/restore/RestoreSnapshotRequest.java, +    private boolean includeGlobalState = false;, +++ b/core/src/main/java/org/elasticsearch/common/rounding/TimeZoneRounding.java, +            long timeLocal = utcMillis;, +            timeLocal = timeZone.convertUTCToLocal(utcMillis);, +            return timeZone.convertLocalToUTC(rounded, false);, +++ b/core/src/main/java/org/elasticsearch/common/xcontent/ConstructingObjectParser.java, +import java.util.Arrays;, + *           a -> new Thing((String) a[0], (String) a[1]));, + *       PARSER.declareInt(Thing::setMineral, new ParseField("mineral"));, +     * Consumer that marks a field as a constructor argument instead of a real object field., +    private static final BiConsumer<Object, Object> CONSTRUCTOR_ARG_MARKER = (a, b) -> {, +    private final List<ParseField> constructorArgNames = new ArrayList<>();, +     * Pass the {@linkplain BiConsumer} this returns the declare methods to declare a constructor argument. See this class's javadoc for an, +     * example. The order in which these are declared matters: it is the order that they come in the array passed to {@link #builder} and, +     * the order that missing arguments are reported to the user if any are missing. When all of these parameters are parsed from the, +     * {@linkplain XContentParser} the target object is immediately built., +        return (BiConsumer<Value, FieldT>) CONSTRUCTOR_ARG_MARKER;, +        if (consumer == CONSTRUCTOR_ARG_MARKER) {, +            int position = constructorArgNames.size();, +            constructorArgNames.add(parseField);, +        private final Object[] constructorArgs = new Object[constructorArgNames.size()];, +            if (constructorArgsCollected != constructorArgNames.size()) {, +                return;, +            }, +            try {, +                targetObject = builder.apply(constructorArgs);, +                while (queuedFieldsCount > 0) {, +                    queuedFieldsCount -= 1;, +                    queuedFields[queuedFieldsCount].accept(targetObject);, +                }, +            } catch (ParsingException e) {, +                throw new ParsingException(e.getLineNumber(), e.getColumnNumber(),, +                        "failed to build [" + objectParser.getName() + "] after last required field arrived", e);, +            } catch (Exception e) {, +                throw new ParsingException(null, "Failed to build [" + objectParser.getName() + "] after last required field arrived", e);, +            // The object hasn't been built which ought to mean we're missing some constructor arguments., +                if (constructorArgs[i] == null) {, +                    ParseField arg = constructorArgNames.get(i);, +                        message = new StringBuilder("Required [").append(arg);, +                        message.append(", ").append(arg);, +             * There won't be if there weren't any constructor arguments declared. That is fine, we'll just throw that error back at the to, +             * the user. This will happen every time so we can be confident that this'll be caught in testing so we can talk to the user, +             * like they are a developer. The only time a user will see this is if someone writes a parser and never tests it which seems, +             * like a bad idea., +            if (constructorArgNames.isEmpty()) {, +                throw new IllegalStateException("[" + objectParser.getName() + "] must configure at least on constructor argument. If it ", +                        + "doens't have any it should use ObjectParser instead of ConstructingObjectParser. This is a bug in the parser ", +                        + "declaration.");, +            if (message == null) {, +                throw new IllegalStateException("The targetObject wasn't built but we aren't missing any constructor args. This is a bug ", +                        + " in ConstructingObjectParser. Here are the constructor arguments " + Arrays.toString(constructorArgs), +                        + " and here are is the count [" + constructorArgsCollected + "]. Good luck figuring out what happened.", +                        + " I'm truly sorry you got here.");, +            throw new IllegalArgumentException(message.append(']').toString());, +++ b/core/src/main/java/org/elasticsearch/action/admin/cluster/snapshots/restore/RestoreSnapshotRequest.java, +    private boolean includeGlobalState = false;, +++ b/core/src/main/java/org/elasticsearch/common/rounding/TimeZoneRounding.java, +            long timeLocal = utcMillis;, +            timeLocal = timeZone.convertUTCToLocal(utcMillis);, +            return timeZone.convertLocalToUTC(rounded, false);, +++ b/core/src/main/java/org/elasticsearch/common/xcontent/ConstructingObjectParser.java, +import java.util.Arrays;, + *           a -> new Thing((String) a[0], (String) a[1]));, + *       PARSER.declareInt(Thing::setMineral, new ParseField("mineral"));, +     * Consumer that marks a field as a constructor argument instead of a real object field., +    private static final BiConsumer<Object, Object> CONSTRUCTOR_ARG_MARKER = (a, b) -> {, +    private final List<ParseField> constructorArgNames = new ArrayList<>();, +     * Pass the {@linkplain BiConsumer} this returns the declare methods to declare a constructor argument. See this class's javadoc for an, +     * example. The order in which these are declared matters: it is the order that they come in the array passed to {@link #builder} and, +     * the order that missing arguments are reported to the user if any are missing. When all of these parameters are parsed from the, +     * {@linkplain XContentParser} the target object is immediately built., +        return (BiConsumer<Value, FieldT>) CONSTRUCTOR_ARG_MARKER;, +        if (consumer == CONSTRUCTOR_ARG_MARKER) {, +            int position = constructorArgNames.size();, +            constructorArgNames.add(parseField);, +        private final Object[] constructorArgs = new Object[constructorArgNames.size()];, +            if (constructorArgsCollected != constructorArgNames.size()) {, +                return;, +            }, +            try {, +                targetObject = builder.apply(constructorArgs);, +                while (queuedFieldsCount > 0) {, +                    queuedFieldsCount -= 1;, +                    queuedFields[queuedFieldsCount].accept(targetObject);, +                }, +            } catch (ParsingException e) {, +                throw new ParsingException(e.getLineNumber(), e.getColumnNumber(),, +                        "failed to build [" + objectParser.getName() + "] after last required field arrived", e);, +            } catch (Exception e) {, +                throw new ParsingException(null, "Failed to build [" + objectParser.getName() + "] after last required field arrived", e);, +            // The object hasn't been built which ought to mean we're missing some constructor arguments.]