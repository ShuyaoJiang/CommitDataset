[+++ b/client/rest-high-level/src/test/java/org/elasticsearch/client/SearchIT.java, +        assertEquals(0.09340198804973046, matrixStats.getSkewness("num"), 0d);, +++ b/client/rest-high-level/src/test/java/org/elasticsearch/client/SearchIT.java, +        assertEquals(0.09340198804973046, matrixStats.getSkewness("num"), 0d);, +++ b/core/src/main/java/org/elasticsearch/action/admin/indices/shrink/TransportResizeAction.java, +, +            // if we have a source index with 1 shards it's legal to set this, +            final boolean splitFromSingleShards = resizeRequest.getResizeType() == ResizeType.SPLIT && metaData.getNumberOfShards() == 1;, +            if (splitFromSingleShards == false) {, +        }, +++ b/client/rest-high-level/src/test/java/org/elasticsearch/client/SearchIT.java, +        assertEquals(0.09340198804973046, matrixStats.getSkewness("num"), 0d);, +++ b/core/src/main/java/org/elasticsearch/action/admin/indices/shrink/TransportResizeAction.java, +, +            // if we have a source index with 1 shards it's legal to set this, +            final boolean splitFromSingleShards = resizeRequest.getResizeType() == ResizeType.SPLIT && metaData.getNumberOfShards() == 1;, +            if (splitFromSingleShards == false) {, +        }, +++ b/core/src/main/java/org/elasticsearch/cluster/metadata/IndexMetaData.java, +        int numSourceShards = sourceIndexMetadata.getNumberOfShards();, +        final int routingFactor = getRoutingFactor(numSourceShards, numTargetShards);, +        assertSplitMetadata(numSourceShards, numTargetShards, sourceIndexMetadata);, +        return new ShardId(sourceIndexMetadata.getIndex(), shardId/routingFactor);, +    }, +, +    private static void assertSplitMetadata(int numSourceShards, int numTargetShards, IndexMetaData sourceIndexMetadata) {, +        // note: if the number of shards is 1 in the source index we can just assume it's correct since from 1 we can split into anything, +        // this is important to special case here since we use this to validate this in various places in the code but allow to split form, +        // 1 to N but we never modify the sourceIndexMetadata to accommodate for that, +        int routingNumShards = numSourceShards == 1 ? numTargetShards : sourceIndexMetadata.getRoutingNumShards();, +        assert sourceIndexMetadata.getNumberOfShards() == 1 // special case - we can split into anything from 1 shard, +            || getRoutingFactor(numTargetShards, routingNumShards) >= 0;, +++ b/client/rest-high-level/src/test/java/org/elasticsearch/client/SearchIT.java, +        assertEquals(0.09340198804973046, matrixStats.getSkewness("num"), 0d);, +++ b/core/src/main/java/org/elasticsearch/action/admin/indices/shrink/TransportResizeAction.java, +, +            // if we have a source index with 1 shards it's legal to set this, +            final boolean splitFromSingleShards = resizeRequest.getResizeType() == ResizeType.SPLIT && metaData.getNumberOfShards() == 1;, +            if (splitFromSingleShards == false) {, +        }, +++ b/core/src/main/java/org/elasticsearch/cluster/metadata/IndexMetaData.java, +        int numSourceShards = sourceIndexMetadata.getNumberOfShards();, +        final int routingFactor = getRoutingFactor(numSourceShards, numTargetShards);, +        assertSplitMetadata(numSourceShards, numTargetShards, sourceIndexMetadata);, +        return new ShardId(sourceIndexMetadata.getIndex(), shardId/routingFactor);, +    }, +, +    private static void assertSplitMetadata(int numSourceShards, int numTargetShards, IndexMetaData sourceIndexMetadata) {, +        // note: if the number of shards is 1 in the source index we can just assume it's correct since from 1 we can split into anything, +        // this is important to special case here since we use this to validate this in various places in the code but allow to split form, +        // 1 to N but we never modify the sourceIndexMetadata to accommodate for that, +        int routingNumShards = numSourceShards == 1 ? numTargetShards : sourceIndexMetadata.getRoutingNumShards();, +        assert sourceIndexMetadata.getNumberOfShards() == 1 // special case - we can split into anything from 1 shard, +            || getRoutingFactor(numTargetShards, routingNumShards) >= 0;, +++ b/core/src/main/java/org/elasticsearch/cluster/metadata/MetaDataCreateIndexService.java, +                final Settings idxSettings = indexSettingsBuilder.build();, +                int numTargetShards = IndexMetaData.INDEX_NUMBER_OF_SHARDS_SETTING.get(idxSettings);, +                final Version indexVersionCreated = idxSettings.getAsVersion(IndexMetaData.SETTING_VERSION_CREATED, null);, +                final IndexMetaData sourceMetaData = recoverFromIndex == null ? null :, +                    currentState.metaData().getIndexSafe(recoverFromIndex);, +                if (sourceMetaData == null || sourceMetaData.getNumberOfShards() == 1) {, +                    // in this case we either have no index to recover from or, +                    // we have a source index with 1 shard and without an explicit split factor, +                    // or one that is valid in that case we can split into whatever and auto-generate a new factor., +                    if (IndexMetaData.INDEX_NUMBER_OF_ROUTING_SHARDS_SETTING.exists(idxSettings)) {, +                        routingNumShards = calculateNumRoutingShards(numTargetShards, indexVersionCreated);, +                    }, +                } else {, +                        : "index.number_of_routing_shards should not be present on the target index on resize";, +, +    /**, +     * Returns a default number of routing shards based on the number of shards of the index. The default number of routing shards will, +     * allow any index to be split at least once and at most 10 times by a factor of two. The closer the number or shards gets to 1024, +     * the less default split operations are supported, +     */, +    public static int calculateNumRoutingShards(int numShards, Version indexVersionCreated) {, +        if (indexVersionCreated.onOrAfter(Version.V_7_0_0_alpha1)) {, +            // only select this automatically for indices that are created on or after 7.0 this will prevent this new behaviour, +            // until we have a fully upgraded cluster. Additionally it will make integratin testing easier since mixed clusters, +            // will always have the behavior of the min node in the cluster., +            //, +            // We use as a default number of routing shards the higher number that can be expressed, +            // as {@code numShards * 2^x`} that is less than or equal to the maximum number of shards: 1024., +            int log2MaxNumShards = 10; // logBase2(1024), +            int log2NumShards = 32 - Integer.numberOfLeadingZeros(numShards - 1); // ceil(logBase2(numShards)), +            int numSplits = log2MaxNumShards - log2NumShards;, +            numSplits = Math.max(1, numSplits); // Ensure the index can be split at least once, +            return numShards * 1 << numSplits;, +        } else {, +            return numShards;, +        }, +    }, +++ b/client/rest-high-level/src/test/java/org/elasticsearch/client/SearchIT.java, +        assertEquals(0.09340198804973046, matrixStats.getSkewness("num"), 0d);, +++ b/core/src/main/java/org/elasticsearch/action/admin/indices/shrink/TransportResizeAction.java, +, +            // if we have a source index with 1 shards it's legal to set this, +            final boolean splitFromSingleShards = resizeRequest.getResizeType() == ResizeType.SPLIT && metaData.getNumberOfShards() == 1;, +            if (splitFromSingleShards == false) {, +        }]