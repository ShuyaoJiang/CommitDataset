[+++ b/src/main/java/org/elasticsearch/cluster/routing/allocation/AllocationService.java, +import com.google.common.collect.Lists;, +import java.util.*;, +        // shuffle the unassigned nodes, just so we won't have things like poison failed shards, +        Collections.shuffle(routingNodes.unassigned());, +        // shuffle the unassigned nodes, just so we won't have things like poison failed shards, +        Collections.shuffle(routingNodes.unassigned());, +        // shuffle the unassigned nodes, just so we won't have things like poison failed shards, +        Collections.shuffle(routingNodes.unassigned());, +        // shuffle the unassigned nodes, just so we won't have things like poison failed shards, +        Collections.shuffle(routingNodes.unassigned());, +        // move all the shards matching the failed shard to the end of the unassigned list, +        // so we give a chance for other allocations and won't create poison failed allocations, +        // that can keep other shards from being allocated (because of limits applied on how many, +        // shards we can start per node), +        List<MutableShardRouting> shardsToMove = Lists.newArrayList();, +        for (Iterator<MutableShardRouting> it = allocation.routingNodes().unassigned().iterator(); it.hasNext(); ) {, +            MutableShardRouting shardRouting = it.next();, +            if (shardRouting.shardId().equals(failedShard.shardId())) {, +                it.remove();, +                shardsToMove.add(shardRouting);, +            }, +        }, +        if (!shardsToMove.isEmpty()) {, +            allocation.routingNodes().unassigned().addAll(shardsToMove);, +        }, +, +++ b/src/main/java/org/elasticsearch/cluster/routing/allocation/AllocationService.java, +import com.google.common.collect.Lists;, +import java.util.*;, +        // shuffle the unassigned nodes, just so we won't have things like poison failed shards, +        Collections.shuffle(routingNodes.unassigned());, +        // shuffle the unassigned nodes, just so we won't have things like poison failed shards, +        Collections.shuffle(routingNodes.unassigned());, +        // shuffle the unassigned nodes, just so we won't have things like poison failed shards, +        Collections.shuffle(routingNodes.unassigned());, +        // shuffle the unassigned nodes, just so we won't have things like poison failed shards, +        Collections.shuffle(routingNodes.unassigned());, +        // move all the shards matching the failed shard to the end of the unassigned list, +        // so we give a chance for other allocations and won't create poison failed allocations, +        // that can keep other shards from being allocated (because of limits applied on how many, +        // shards we can start per node), +        List<MutableShardRouting> shardsToMove = Lists.newArrayList();, +        for (Iterator<MutableShardRouting> it = allocation.routingNodes().unassigned().iterator(); it.hasNext(); ) {, +            MutableShardRouting shardRouting = it.next();, +            if (shardRouting.shardId().equals(failedShard.shardId())) {, +                it.remove();, +                shardsToMove.add(shardRouting);, +            }, +        }, +        if (!shardsToMove.isEmpty()) {, +            allocation.routingNodes().unassigned().addAll(shardsToMove);, +        }, +, +++ b/src/test/java/org/elasticsearch/test/integration/document/DocumentActionsTests.java, +import org.elasticsearch.action.update.UpdateResponse;, +import org.elasticsearch.index.engine.DocumentMissingException;, +    public void testUpdate() throws Exception {, +        createIndex();, +        ClusterHealthResponse clusterHealth = client1.admin().cluster().prepareHealth().setWaitForGreenStatus().execute().actionGet();, +        assertThat(clusterHealth.timedOut(), equalTo(false));, +        assertThat(clusterHealth.status(), equalTo(ClusterHealthStatus.GREEN));, +, +        try {, +            client1.prepareUpdate("test", "type1", "1").setScript("ctx._source.field++").execute().actionGet();, +            assert false;, +        } catch (DocumentMissingException e) {, +            // all is well, +        }, +, +        client1.prepareIndex("test", "type1", "1").setSource("field", 1).execute().actionGet();, +, +        UpdateResponse updateResponse = client1.prepareUpdate("test", "type1", "1").setScript("ctx._source.field += 1").execute().actionGet();, +        assertThat(updateResponse.version(), equalTo(2L));, +, +        for (int i = 0; i < 5; i++) {, +            GetResponse getResponse = client1.prepareGet("test", "type1", "1").execute().actionGet();, +            assertThat(getResponse.sourceAsMap().get("field").toString(), equalTo("2"));, +        }, +, +        updateResponse = client1.prepareUpdate("test", "type1", "1").setScript("ctx._source.field += count").addScriptParam("count", 3).execute().actionGet();, +        assertThat(updateResponse.version(), equalTo(3L));, +, +        for (int i = 0; i < 5; i++) {, +            GetResponse getResponse = client1.prepareGet("test", "type1", "1").execute().actionGet();, +            assertThat(getResponse.sourceAsMap().get("field").toString(), equalTo("5"));, +        }, +, +        // check noop, +        updateResponse = client1.prepareUpdate("test", "type1", "1").setScript("ctx.op = 'none'").execute().actionGet();, +        assertThat(updateResponse.version(), equalTo(3L));, +, +        for (int i = 0; i < 5; i++) {, +            GetResponse getResponse = client1.prepareGet("test", "type1", "1").execute().actionGet();, +            assertThat(getResponse.sourceAsMap().get("field").toString(), equalTo("5"));, +        }, +, +        // check delete, +        updateResponse = client1.prepareUpdate("test", "type1", "1").setScript("ctx.op = 'delete'").execute().actionGet();, +        assertThat(updateResponse.version(), equalTo(4L));]