[+++ b/client/rest/src/main/java/org/elasticsearch/client/RestClient.java, +            if (pathPrefix != null && pathPrefix.isEmpty() == false) {, +                if (pathPrefix.endsWith("/") && path.startsWith("/")) {, +                    fullPath = pathPrefix.substring(0, pathPrefix.length() - 1) + path;, +                } else if (pathPrefix.endsWith("/") || path.startsWith("/")) {, +++ b/client/rest/src/main/java/org/elasticsearch/client/RestClient.java, +            if (pathPrefix != null && pathPrefix.isEmpty() == false) {, +                if (pathPrefix.endsWith("/") && path.startsWith("/")) {, +                    fullPath = pathPrefix.substring(0, pathPrefix.length() - 1) + path;, +                } else if (pathPrefix.endsWith("/") || path.startsWith("/")) {, +++ b/client/rest/src/main/java/org/elasticsearch/client/RestClientBuilder.java, +     * Elasticsearch is behind a proxy that provides a base path or a proxy that requires all paths to start with '/';, +     * it is not intended for other purposes and it should not be supplied in other scenarios., +     * @throws IllegalArgumentException if {@code pathPrefix} is empty, or ends with more than one '/'., +        if (pathPrefix.isEmpty()) {, +            throw new IllegalArgumentException("pathPrefix must not be empty");, +        }, +, +        String cleanPathPrefix = pathPrefix;, +        if (cleanPathPrefix.endsWith("/") && cleanPathPrefix.length() > 1) {, +++ b/client/rest/src/main/java/org/elasticsearch/client/RestClient.java, +            if (pathPrefix != null && pathPrefix.isEmpty() == false) {, +                if (pathPrefix.endsWith("/") && path.startsWith("/")) {, +                    fullPath = pathPrefix.substring(0, pathPrefix.length() - 1) + path;, +                } else if (pathPrefix.endsWith("/") || path.startsWith("/")) {, +++ b/client/rest/src/main/java/org/elasticsearch/client/RestClientBuilder.java, +     * Elasticsearch is behind a proxy that provides a base path or a proxy that requires all paths to start with '/';, +     * it is not intended for other purposes and it should not be supplied in other scenarios., +     * @throws IllegalArgumentException if {@code pathPrefix} is empty, or ends with more than one '/'., +        if (pathPrefix.isEmpty()) {, +            throw new IllegalArgumentException("pathPrefix must not be empty");, +        }, +, +        String cleanPathPrefix = pathPrefix;, +        if (cleanPathPrefix.endsWith("/") && cleanPathPrefix.length() > 1) {, +++ b/client/rest/src/test/java/org/elasticsearch/client/RestClientBuilderTests.java, +++ b/client/rest/src/main/java/org/elasticsearch/client/RestClient.java, +            if (pathPrefix != null && pathPrefix.isEmpty() == false) {, +                if (pathPrefix.endsWith("/") && path.startsWith("/")) {, +                    fullPath = pathPrefix.substring(0, pathPrefix.length() - 1) + path;, +                } else if (pathPrefix.endsWith("/") || path.startsWith("/")) {, +++ b/client/rest/src/main/java/org/elasticsearch/client/RestClientBuilder.java, +     * Elasticsearch is behind a proxy that provides a base path or a proxy that requires all paths to start with '/';, +     * it is not intended for other purposes and it should not be supplied in other scenarios., +     * @throws IllegalArgumentException if {@code pathPrefix} is empty, or ends with more than one '/'., +        if (pathPrefix.isEmpty()) {, +            throw new IllegalArgumentException("pathPrefix must not be empty");, +        }, +, +        String cleanPathPrefix = pathPrefix;, +        if (cleanPathPrefix.endsWith("/") && cleanPathPrefix.length() > 1) {, +++ b/client/rest/src/test/java/org/elasticsearch/client/RestClientBuilderTests.java, +++ b/client/rest/src/test/java/org/elasticsearch/client/RestClientTests.java, +        final Map<String, String> emptyMap = Collections.emptyMap();, +            URI uri = RestClient.buildUri("/foo$bar", "/index/type/id", emptyMap);, +            URI uri = RestClient.buildUri("/", "/*", emptyMap);, +            assertEquals("/*", uri.getPath());, +        }, +        {, +            URI uri = RestClient.buildUri("/", "*", emptyMap);, +            assertEquals("/*", uri.getPath());, +        }, +        {, +            URI uri = RestClient.buildUri(null, "*", emptyMap);, +            assertEquals("*", uri.getPath());, +        }, +        {, +            URI uri = RestClient.buildUri("", "*", emptyMap);, +            assertEquals("*", uri.getPath());, +        }, +        {, +            URI uri = RestClient.buildUri(null, "/*", emptyMap);, +            assertEquals("/*", uri.getPath());, +        }, +        {, +            URI uri = RestClient.buildUri(null, "/foo$bar/ty/pe/i/d", emptyMap);, +++ b/client/rest/src/main/java/org/elasticsearch/client/RestClient.java, +            if (pathPrefix != null && pathPrefix.isEmpty() == false) {, +                if (pathPrefix.endsWith("/") && path.startsWith("/")) {, +                    fullPath = pathPrefix.substring(0, pathPrefix.length() - 1) + path;, +                } else if (pathPrefix.endsWith("/") || path.startsWith("/")) {, +++ b/client/rest/src/main/java/org/elasticsearch/client/RestClientBuilder.java, +     * Elasticsearch is behind a proxy that provides a base path or a proxy that requires all paths to start with '/';, +     * it is not intended for other purposes and it should not be supplied in other scenarios., +     * @throws IllegalArgumentException if {@code pathPrefix} is empty, or ends with more than one '/'., +        if (pathPrefix.isEmpty()) {, +            throw new IllegalArgumentException("pathPrefix must not be empty");, +        }, +, +        String cleanPathPrefix = pathPrefix;, +        if (cleanPathPrefix.endsWith("/") && cleanPathPrefix.length() > 1) {, +++ b/client/rest/src/test/java/org/elasticsearch/client/RestClientBuilderTests.java, +++ b/client/rest/src/test/java/org/elasticsearch/client/RestClientTests.java, +        final Map<String, String> emptyMap = Collections.emptyMap();, +            URI uri = RestClient.buildUri("/foo$bar", "/index/type/id", emptyMap);, +            URI uri = RestClient.buildUri("/", "/*", emptyMap);, +            assertEquals("/*", uri.getPath());, +        }, +        {, +            URI uri = RestClient.buildUri("/", "*", emptyMap);]