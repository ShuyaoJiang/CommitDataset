[+++ b/modules/lang-expression/src/main/java/org/elasticsearch/script/expression/ExpressionScriptEngine.java, +import org.elasticsearch.script.TermsSetQueryScript;, +        } else if (context.instanceClazz.equals(TermsSetQueryScript.class)) {, +            TermsSetQueryScript.Factory factory = (p, lookup) -> newTermsSetQueryScript(expr, lookup, p);, +            return context.factoryClazz.cast(factory);, +                    bindFromParams(vars, bindings, variable);, +                    final ValueSource valueSource = getDocValueSource(variable, lookup);, +    private TermsSetQueryScript.LeafFactory newTermsSetQueryScript(Expression expr, SearchLookup lookup,, +        @Nullable Map<String, Object> vars) {, +        // NOTE: if we need to do anything complicated with bindings in the future, we can just extend Bindings,, +        // instead of complicating SimpleBindings (which should stay simple), +        SimpleBindings bindings = new SimpleBindings();, +        for (String variable : expr.variables) {, +            try {, +                if (vars != null && vars.containsKey(variable)) {, +                    bindFromParams(vars, bindings, variable);, +                } else {, +                    // delegate valuesource creation based on field's type, +                    // there are three types of "fields" to expressions, and each one has a different "api" of variables and methods., +                    final ValueSource valueSource = getDocValueSource(variable, lookup);, +                    bindings.add(variable, valueSource.asDoubleValuesSource());, +                }, +            } catch (Exception e) {, +                // we defer "binding" of variables until here: give context for that variable, +                throw convertToScriptException("link error", expr.sourceText, variable, e);, +            }, +        }, +        ReplaceableConstDoubleValueSource specialValue = null;, +        return new ExpressionTermSetQueryScript(expr, bindings, specialValue);, +    }, +, +, +    private static ValueSource getDocValueSource(String variable, SearchLookup lookup) throws ParseException {, +        VariableContext[] parts = VariableContext.parse(variable);, +        if (parts[0].text.equals("doc") == false) {, +            throw new ParseException("Unknown variable [" + parts[0].text + "]", 0);, +        }, +        if (parts.length < 2 || parts[1].type != VariableContext.Type.STR_INDEX) {, +            throw new ParseException("Variable 'doc' must be used with a specific field like: doc['myfield']", 3);, +        }, +, +        // .value is the default for doc['field'], its optional., +        String variablename = "value";, +        String methodname = null;, +        if (parts.length == 3) {, +            if (parts[2].type == VariableContext.Type.METHOD) {, +                methodname = parts[2].text;, +            } else if (parts[2].type == VariableContext.Type.MEMBER) {, +                variablename = parts[2].text;, +            } else {, +                throw new IllegalArgumentException(, +                    "Only member variables or member methods may be accessed on a field when not accessing the field directly", +                );, +            }, +        }, +        // true if the variable is of type doc['field'].date.xxx, +        boolean dateAccessor = false;, +        if (parts.length > 3) {, +            // access to the .date "object" within the field, +            if (parts.length == 4 && ("date".equals(parts[2].text) || "getDate".equals(parts[2].text))) {, +                if (parts[3].type == VariableContext.Type.METHOD) {, +                    methodname = parts[3].text;, +                    dateAccessor = true;, +                } else if (parts[3].type == VariableContext.Type.MEMBER) {, +                    variablename = parts[3].text;, +                    dateAccessor = true;, +                }, +            }, +            if (!dateAccessor) {, +                throw new IllegalArgumentException(, +                    "Variable [" + variable + "] does not follow an allowed format of either doc['field'] or doc['field'].method()", +                );, +            }, +        }, +, +        String fieldname = parts[1].text;, +        MappedFieldType fieldType = lookup.doc().mapperService().fullName(fieldname);, +, +        if (fieldType == null) {, +            throw new ParseException("Field [" + fieldname + "] does not exist in mappings", 5);, +        }, +, +        IndexFieldData<?> fieldData = lookup.doc().getForField(fieldType);, +        final ValueSource valueSource;, +        if (fieldType instanceof GeoPointFieldType) {, +            // geo, +            if (methodname == null) {, +                valueSource = GeoField.getVariable(fieldData, fieldname, variablename);, +            } else {, +                valueSource = GeoField.getMethod(fieldData, fieldname, methodname);, +            }, +        } else if (fieldType instanceof DateFieldMapper.DateFieldType) {, +            if (dateAccessor) {, +                // date object, +                if (methodname == null) {, +                    valueSource = DateObject.getVariable(fieldData, fieldname, variablename);, +                } else {, +                    valueSource = DateObject.getMethod(fieldData, fieldname, methodname);, +                }, +            } else {]