[+++ b/server/src/main/java/org/elasticsearch/action/support/replication/ReplicationOperation.java, +import org.elasticsearch.index.seqno.SequenceNumbers;, +            // we have to capture the max_seq_no_of_updates after this request was completed on the primary to make sure the value of, +            // max_seq_no_of_updates on replica when this request is executed is at least the value on the primary when it was executed on., +            final long maxSeqNoOfUpdatesOrDeletes = primary.maxSeqNoOfUpdatesOrDeletes();, +            assert maxSeqNoOfUpdatesOrDeletes != SequenceNumbers.UNASSIGNED_SEQ_NO : "seqno_of_updates still uninitialized";, +            performOnReplicas(replicaRequest, globalCheckpoint, maxSeqNoOfUpdatesOrDeletes, replicationGroup);, +                                   final long maxSeqNoOfUpdatesOrDeletes, final ReplicationGroup replicationGroup) {, +                performOnReplica(shard, replicaRequest, globalCheckpoint, maxSeqNoOfUpdatesOrDeletes);, +    private void performOnReplica(final ShardRouting shard, final ReplicaRequest replicaRequest,, +                                  final long globalCheckpoint, final long maxSeqNoOfUpdatesOrDeletes) {, +        replicasProxy.performOn(shard, replicaRequest, globalCheckpoint, maxSeqNoOfUpdatesOrDeletes, new ActionListener<ReplicaResponse>() {, +         * Returns the maximum seq_no of updates (index operations overwrite Lucene) or deletes on the primary., +         * This value must be captured after the execution of a replication request on the primary is completed., +         */, +        long maxSeqNoOfUpdatesOrDeletes();, +, +        /**, +         * @param maxSeqNoOfUpdatesOrDeletes the max seq_no of updates (index operations overwriting Lucene) or deletes on primary, +         *                                   after this replication was executed on it., +        void performOn(ShardRouting replica, RequestT replicaRequest, long globalCheckpoint,, +                       long maxSeqNoOfUpdatesOrDeletes, ActionListener<ReplicaResponse> listener);, +++ b/server/src/main/java/org/elasticsearch/action/support/replication/ReplicationOperation.java, +import org.elasticsearch.index.seqno.SequenceNumbers;, +            // we have to capture the max_seq_no_of_updates after this request was completed on the primary to make sure the value of, +            // max_seq_no_of_updates on replica when this request is executed is at least the value on the primary when it was executed on., +            final long maxSeqNoOfUpdatesOrDeletes = primary.maxSeqNoOfUpdatesOrDeletes();, +            assert maxSeqNoOfUpdatesOrDeletes != SequenceNumbers.UNASSIGNED_SEQ_NO : "seqno_of_updates still uninitialized";, +            performOnReplicas(replicaRequest, globalCheckpoint, maxSeqNoOfUpdatesOrDeletes, replicationGroup);, +                                   final long maxSeqNoOfUpdatesOrDeletes, final ReplicationGroup replicationGroup) {, +                performOnReplica(shard, replicaRequest, globalCheckpoint, maxSeqNoOfUpdatesOrDeletes);, +    private void performOnReplica(final ShardRouting shard, final ReplicaRequest replicaRequest,, +                                  final long globalCheckpoint, final long maxSeqNoOfUpdatesOrDeletes) {, +        replicasProxy.performOn(shard, replicaRequest, globalCheckpoint, maxSeqNoOfUpdatesOrDeletes, new ActionListener<ReplicaResponse>() {, +         * Returns the maximum seq_no of updates (index operations overwrite Lucene) or deletes on the primary., +         * This value must be captured after the execution of a replication request on the primary is completed., +         */, +        long maxSeqNoOfUpdatesOrDeletes();, +, +        /**, +         * @param maxSeqNoOfUpdatesOrDeletes the max seq_no of updates (index operations overwriting Lucene) or deletes on primary, +         *                                   after this replication was executed on it., +        void performOn(ShardRouting replica, RequestT replicaRequest, long globalCheckpoint,, +                       long maxSeqNoOfUpdatesOrDeletes, ActionListener<ReplicaResponse> listener);, +++ b/server/src/main/java/org/elasticsearch/action/support/replication/TransportReplicationAction.java, +     * {@link IndexShard#acquireReplicaOperationPermit(long, long, long, ActionListener, String, Object)}., +                    replicaRequest.getMaxSeqNoOfUpdatesOrDeletes(),, +        private final long maxSeqNoOfUpdatesOrDeletes;, +                long maxSeqNoOfUpdatesOrDeletes,, +            this.maxSeqNoOfUpdatesOrDeletes = maxSeqNoOfUpdatesOrDeletes;, +                            new ConcreteReplicaRequest<>(request, targetAllocationID, primaryTerm,, +                                globalCheckpoint, maxSeqNoOfUpdatesOrDeletes),, +            replica.acquireReplicaOperationPermit(primaryTerm, globalCheckpoint, maxSeqNoOfUpdatesOrDeletes, this, executor, request);, +        public long maxSeqNoOfUpdatesOrDeletes() {, +            return indexShard.getMaxSeqNoOfUpdatesOrDeletes();, +        }, +, +        @Override, +                final long maxSeqNoOfUpdatesOrDeletes,, +            final ConcreteReplicaRequest<ReplicaRequest> replicaRequest = new ConcreteReplicaRequest<>(, +                request, replica.allocationId().getId(), primaryTerm, globalCheckpoint, maxSeqNoOfUpdatesOrDeletes);, +        private long maxSeqNoOfUpdatesOrDeletes;, +                                      final long globalCheckpoint, final long maxSeqNoOfUpdatesOrDeletes) {, +            this.maxSeqNoOfUpdatesOrDeletes = maxSeqNoOfUpdatesOrDeletes;, +            if (in.getVersion().onOrAfter(Version.V_7_0_0_alpha1)) {, +                maxSeqNoOfUpdatesOrDeletes = in.readZLong();, +            } else {, +                // UNASSIGNED_SEQ_NO (-2) means uninitialized, and replicas will disable, +                // optimization using seq_no if its max_seq_no_of_updates is still uninitialized, +                maxSeqNoOfUpdatesOrDeletes = SequenceNumbers.UNASSIGNED_SEQ_NO;, +            }, +            if (out.getVersion().onOrAfter(Version.V_7_0_0_alpha1)) {, +                out.writeZLong(maxSeqNoOfUpdatesOrDeletes);, +            }, +        public long getMaxSeqNoOfUpdatesOrDeletes() {, +            return maxSeqNoOfUpdatesOrDeletes;, +        }, +, +                    ", maxSeqNoOfUpdatesOrDeletes=" + maxSeqNoOfUpdatesOrDeletes +, +++ b/server/src/main/java/org/elasticsearch/action/support/replication/ReplicationOperation.java, +import org.elasticsearch.index.seqno.SequenceNumbers;, +            // we have to capture the max_seq_no_of_updates after this request was completed on the primary to make sure the value of, +            // max_seq_no_of_updates on replica when this request is executed is at least the value on the primary when it was executed on., +            final long maxSeqNoOfUpdatesOrDeletes = primary.maxSeqNoOfUpdatesOrDeletes();, +            assert maxSeqNoOfUpdatesOrDeletes != SequenceNumbers.UNASSIGNED_SEQ_NO : "seqno_of_updates still uninitialized";, +            performOnReplicas(replicaRequest, globalCheckpoint, maxSeqNoOfUpdatesOrDeletes, replicationGroup);, +                                   final long maxSeqNoOfUpdatesOrDeletes, final ReplicationGroup replicationGroup) {, +                performOnReplica(shard, replicaRequest, globalCheckpoint, maxSeqNoOfUpdatesOrDeletes);, +    private void performOnReplica(final ShardRouting shard, final ReplicaRequest replicaRequest,, +                                  final long globalCheckpoint, final long maxSeqNoOfUpdatesOrDeletes) {, +        replicasProxy.performOn(shard, replicaRequest, globalCheckpoint, maxSeqNoOfUpdatesOrDeletes, new ActionListener<ReplicaResponse>() {, +         * Returns the maximum seq_no of updates (index operations overwrite Lucene) or deletes on the primary., +         * This value must be captured after the execution of a replication request on the primary is completed., +         */, +        long maxSeqNoOfUpdatesOrDeletes();, +, +        /**, +         * @param maxSeqNoOfUpdatesOrDeletes the max seq_no of updates (index operations overwriting Lucene) or deletes on primary, +         *                                   after this replication was executed on it., +        void performOn(ShardRouting replica, RequestT replicaRequest, long globalCheckpoint,]