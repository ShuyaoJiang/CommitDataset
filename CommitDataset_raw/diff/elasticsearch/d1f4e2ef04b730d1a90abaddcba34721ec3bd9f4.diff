[+++ b/modules/lang-painless/src/main/antlr/PainlessLexer.g4, +// We switch modes after a dot to ensure there are not conflicts, +// between shortcuts and decimal values.  Without the mode switch, +// shortcuts such as id.0.0 will fail because 0.0 will be interpreted, +// as a decimal value instead of two individual list-style shortcuts., +++ b/modules/lang-painless/src/main/antlr/PainlessLexer.g4, +// We switch modes after a dot to ensure there are not conflicts, +// between shortcuts and decimal values.  Without the mode switch, +// shortcuts such as id.0.0 will fail because 0.0 will be interpreted, +// as a decimal value instead of two individual list-style shortcuts., +++ b/modules/lang-painless/src/main/antlr/PainlessParser.g4, +    | FOR LP decltype ID COLON expression RP trailer                                           # each, +++ b/modules/lang-painless/src/main/antlr/PainlessLexer.g4, +// We switch modes after a dot to ensure there are not conflicts, +// between shortcuts and decimal values.  Without the mode switch, +// shortcuts such as id.0.0 will fail because 0.0 will be interpreted, +// as a decimal value instead of two individual list-style shortcuts., +++ b/modules/lang-painless/src/main/antlr/PainlessParser.g4, +    | FOR LP decltype ID COLON expression RP trailer                                           # each, +++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/Compiler.java, +, +            throw new IllegalStateException("An internal error occurred attempting to define the script [" + name + "].", exception);, +++ b/modules/lang-painless/src/main/antlr/PainlessLexer.g4, +// We switch modes after a dot to ensure there are not conflicts, +// between shortcuts and decimal values.  Without the mode switch, +// shortcuts such as id.0.0 will fail because 0.0 will be interpreted, +// as a decimal value instead of two individual list-style shortcuts., +++ b/modules/lang-painless/src/main/antlr/PainlessParser.g4, +    | FOR LP decltype ID COLON expression RP trailer                                           # each, +++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/Compiler.java, +, +            throw new IllegalStateException("An internal error occurred attempting to define the script [" + name + "].", exception);, +++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/ScriptImpl.java, +    /**, +     * Adds stack trace and other useful information to exceptiosn thrown, +     * from a Painless script., +     * @param t The throwable to build an exception around., +     * @return The generated ScriptException., +     */, +++ b/modules/lang-painless/src/main/antlr/PainlessLexer.g4, +// We switch modes after a dot to ensure there are not conflicts, +// between shortcuts and decimal values.  Without the mode switch, +// shortcuts such as id.0.0 will fail because 0.0 will be interpreted, +// as a decimal value instead of two individual list-style shortcuts., +++ b/modules/lang-painless/src/main/antlr/PainlessParser.g4, +    | FOR LP decltype ID COLON expression RP trailer                                           # each, +++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/Compiler.java, +, +            throw new IllegalStateException("An internal error occurred attempting to define the script [" + name + "].", exception);, +++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/ScriptImpl.java, +    /**, +     * Adds stack trace and other useful information to exceptiosn thrown, +     * from a Painless script., +     * @param t The throwable to build an exception around., +     * @return The generated ScriptException., +     */, +++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/antlr/PainlessParser.java, +  public static class EachContext extends StatementContext {, +    public TerminalNode FOR() { return getToken(PainlessParser.FOR, 0); }, +    public TerminalNode LP() { return getToken(PainlessParser.LP, 0); }, +    public DecltypeContext decltype() {, +      return getRuleContext(DecltypeContext.class,0);, +    }, +    public TerminalNode ID() { return getToken(PainlessParser.ID, 0); }, +    public TerminalNode COLON() { return getToken(PainlessParser.COLON, 0); }, +    public ExpressionContext expression() {, +      return getRuleContext(ExpressionContext.class,0);, +    }, +    public TerminalNode RP() { return getToken(PainlessParser.RP, 0); }, +    public TrailerContext trailer() {, +      return getRuleContext(TrailerContext.class,0);, +    }, +    public EachContext(StatementContext ctx) { copyFrom(ctx); }, +    @Override, +    public <T> T accept(ParseTreeVisitor<? extends T> visitor) {, +      if ( visitor instanceof PainlessParserVisitor ) return ((PainlessParserVisitor<? extends T>)visitor).visitEach(this);, +      else return visitor.visitChildren(this);, +    }, +  }, +      setState(130);, +        _localctx = new EachContext(_localctx);, +        match(FOR);, +        match(LP);, +        setState(98);, +        decltype();, +        setState(99);, +        match(ID);, +        setState(100);, +        match(COLON);, +        setState(101);, +        expression(0);, +        setState(102);, +        match(RP);, +        setState(103);, +        trailer();, +        _localctx = new DeclContext(_localctx);, +        setState(105);, +        declaration();, +        setState(106);, +        _localctx = new ContinueContext(_localctx);]