[+++ b/core/src/main/java/org/elasticsearch/cluster/ClusterStateTaskExecutor.java, +     * @param clusterChangedEvent the change event for this cluster state change, containing, +     *                            both old and new states, +    default void clusterStatePublished(ClusterChangedEvent clusterChangedEvent) {, +                TaskResult existing = executionResults.put(task, executionResult);, +                assert existing == null : task + " already has result " + existing;, +++ b/core/src/main/java/org/elasticsearch/cluster/ClusterStateTaskExecutor.java, +     * @param clusterChangedEvent the change event for this cluster state change, containing, +     *                            both old and new states, +    default void clusterStatePublished(ClusterChangedEvent clusterChangedEvent) {, +                TaskResult existing = executionResults.put(task, executionResult);, +                assert existing == null : task + " already has result " + existing;, +++ b/core/src/main/java/org/elasticsearch/cluster/action/shard/ShardStateAction.java, +import org.elasticsearch.cluster.ClusterChangedEvent;, +        public void clusterStatePublished(ClusterChangedEvent clusterChangedEvent) {, +            int numberOfUnassignedShards = clusterChangedEvent.state().getRoutingNodes().unassigned().size();, +++ b/core/src/main/java/org/elasticsearch/cluster/ClusterStateTaskExecutor.java, +     * @param clusterChangedEvent the change event for this cluster state change, containing, +     *                            both old and new states, +    default void clusterStatePublished(ClusterChangedEvent clusterChangedEvent) {, +                TaskResult existing = executionResults.put(task, executionResult);, +                assert existing == null : task + " already has result " + existing;, +++ b/core/src/main/java/org/elasticsearch/cluster/action/shard/ShardStateAction.java, +import org.elasticsearch.cluster.ClusterChangedEvent;, +        public void clusterStatePublished(ClusterChangedEvent clusterChangedEvent) {, +            int numberOfUnassignedShards = clusterChangedEvent.state().getRoutingNodes().unassigned().size();, +++ b/core/src/main/java/org/elasticsearch/cluster/node/DiscoveryNodes.java, +, +        public boolean isLocalNodeElectedMaster() {, +            return masterNodeId != null && masterNodeId.equals(localNodeId);, +        }, +++ b/core/src/main/java/org/elasticsearch/cluster/ClusterStateTaskExecutor.java, +     * @param clusterChangedEvent the change event for this cluster state change, containing, +     *                            both old and new states, +    default void clusterStatePublished(ClusterChangedEvent clusterChangedEvent) {, +                TaskResult existing = executionResults.put(task, executionResult);, +                assert existing == null : task + " already has result " + existing;, +++ b/core/src/main/java/org/elasticsearch/cluster/action/shard/ShardStateAction.java, +import org.elasticsearch.cluster.ClusterChangedEvent;, +        public void clusterStatePublished(ClusterChangedEvent clusterChangedEvent) {, +            int numberOfUnassignedShards = clusterChangedEvent.state().getRoutingNodes().unassigned().size();, +++ b/core/src/main/java/org/elasticsearch/cluster/node/DiscoveryNodes.java, +, +        public boolean isLocalNodeElectedMaster() {, +            return masterNodeId != null && masterNodeId.equals(localNodeId);, +        }, +++ b/core/src/main/java/org/elasticsearch/cluster/service/ClusterService.java, +import java.util.Collections;, +import java.util.IdentityHashMap;, +                                          final ClusterStateTaskListener listener) {, +        submitStateUpdateTasks(source, Collections.singletonMap(task, listener), config, executor);, +    /**, +     * Submits a batch of cluster state update tasks; submitted updates are guaranteed to be processed together,, +     * potentially with more tasks of the same executor., +     *, +     * @param source   the source of the cluster state update task, +     * @param tasks    a map of update tasks and their corresponding listeners, +     * @param config   the cluster state update task configuration, +     * @param executor the cluster state update task executor; tasks, +     *                 that share the same executor will be executed, +     *                 batches on this executor, +     * @param <T>      the type of the cluster state update task state, +     */, +    public <T> void submitStateUpdateTasks(final String source,, +                                           final Map<T, ClusterStateTaskListener> tasks, final ClusterStateTaskConfig config,, +                                           final ClusterStateTaskExecutor<T> executor) {, +        if (tasks.isEmpty()) {, +            return;, +        }, +            // convert to an identity map to check for dups based on update tasks semantics of using identity instead of equal, +            final IdentityHashMap<T, ClusterStateTaskListener> tasksIdentity = new IdentityHashMap<>(tasks);, +            final List<UpdateTask<T>> updateTasks = tasksIdentity.entrySet().stream().map(, +                entry -> new UpdateTask<>(source, entry.getKey(), config, executor, safe(entry.getValue(), logger)), +            ).collect(Collectors.toList());, +                List<UpdateTask> existingTasks = updateTasksPerExecutor.computeIfAbsent(executor, k -> new ArrayList<>());, +                for (@SuppressWarnings("unchecked") UpdateTask<T> existing : existingTasks) {, +                    if (tasksIdentity.containsKey(existing.task)) {, +                        throw new IllegalArgumentException("task [" + existing.task + "] is already queued");, +                    }, +                }, +                existingTasks.addAll(updateTasks);, +            final UpdateTask<T> firstTask = updateTasks.get(0);, +, +                updateTasksExecutor.execute(firstTask, threadPool.scheduler(), config.timeout(), () -> threadPool.generic().execute(() -> {, +                    for (UpdateTask<T> task : updateTasks) {, +                        if (task.processed.getAndSet(true) == false) {, +                            task.listener.onFailure(source, new ProcessClusterEventTimeoutException(config.timeout(), source));, +                        }, +                updateTasksExecutor.execute(firstTask);, +                executor.clusterStatePublished(clusterChangedEvent);, +++ b/core/src/main/java/org/elasticsearch/cluster/ClusterStateTaskExecutor.java, +     * @param clusterChangedEvent the change event for this cluster state change, containing, +     *                            both old and new states, +    default void clusterStatePublished(ClusterChangedEvent clusterChangedEvent) {, +                TaskResult existing = executionResults.put(task, executionResult);, +                assert existing == null : task + " already has result " + existing;, +++ b/core/src/main/java/org/elasticsearch/cluster/action/shard/ShardStateAction.java, +import org.elasticsearch.cluster.ClusterChangedEvent;, +        public void clusterStatePublished(ClusterChangedEvent clusterChangedEvent) {, +            int numberOfUnassignedShards = clusterChangedEvent.state().getRoutingNodes().unassigned().size();]