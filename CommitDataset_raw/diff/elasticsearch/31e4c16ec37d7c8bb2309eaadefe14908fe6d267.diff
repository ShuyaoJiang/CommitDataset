[+++ b/core/src/main/java/org/elasticsearch/common/joda/Joda.java, +            return hasMilliSecondPrecision ? 19 : 16;, +                bucket.getZone() != DateTimeZone.UTC) {, +            return hasMilliSecondPrecision ? 19 : 16;, +++ b/core/src/main/java/org/elasticsearch/common/joda/Joda.java, +            return hasMilliSecondPrecision ? 19 : 16;, +                bucket.getZone() != DateTimeZone.UTC) {, +            return hasMilliSecondPrecision ? 19 : 16;, +++ b/core/src/test/java/org/elasticsearch/common/joda/DateMathParserTests.java, +        assertDateMathEquals("32484216259000", "2999-05-20T17:24:19.000");, +        assertDateMathEquals("253382837059000", "9999-05-20T17:24:19.000");, +++ b/core/src/main/java/org/elasticsearch/common/joda/Joda.java, +            return hasMilliSecondPrecision ? 19 : 16;, +                bucket.getZone() != DateTimeZone.UTC) {, +            return hasMilliSecondPrecision ? 19 : 16;, +++ b/core/src/test/java/org/elasticsearch/common/joda/DateMathParserTests.java, +        assertDateMathEquals("32484216259000", "2999-05-20T17:24:19.000");, +        assertDateMathEquals("253382837059000", "9999-05-20T17:24:19.000");, +++ b/core/src/test/java/org/elasticsearch/deps/joda/SimpleJodaTests.java, +            formatter.parser().parseDateTime("-1234567890123456789");, +            formatter.parser().parseDateTime("-1234567890123456");, +            formatter.parser().parseDateTime(randomFrom("invalid date", "12345678901234567", "12345678901234567890"));, +            formatter.parser().parseDateTime(randomFrom("invalid date", "12345678901234567890"));, +        dateTime = formatter.parser().parseDateTime("1234567890123456789");, +        assertThat(dateTime.getMillis(), is(1234567890123456789L));, +        secondsDateTime = secondsFormatter.parser().parseDateTime("1234567890123456");, +        assertThat(secondsDateTime.getMillis(), is(1234567890123456000L));, +++ b/core/src/main/java/org/elasticsearch/common/joda/Joda.java, +            return hasMilliSecondPrecision ? 19 : 16;, +                bucket.getZone() != DateTimeZone.UTC) {, +            return hasMilliSecondPrecision ? 19 : 16;, +++ b/core/src/test/java/org/elasticsearch/common/joda/DateMathParserTests.java, +        assertDateMathEquals("32484216259000", "2999-05-20T17:24:19.000");, +        assertDateMathEquals("253382837059000", "9999-05-20T17:24:19.000");, +++ b/core/src/test/java/org/elasticsearch/deps/joda/SimpleJodaTests.java, +            formatter.parser().parseDateTime("-1234567890123456789");, +            formatter.parser().parseDateTime("-1234567890123456");, +            formatter.parser().parseDateTime(randomFrom("invalid date", "12345678901234567", "12345678901234567890"));, +            formatter.parser().parseDateTime(randomFrom("invalid date", "12345678901234567890"));, +        dateTime = formatter.parser().parseDateTime("1234567890123456789");, +        assertThat(dateTime.getMillis(), is(1234567890123456789L));, +        secondsDateTime = secondsFormatter.parser().parseDateTime("1234567890123456");, +        assertThat(secondsDateTime.getMillis(), is(1234567890123456000L));, +++ b/docs/reference/mapping/params/format.asciidoc, +    this timestamp is subject to the limits of a Java `Long.MIN_VALUE` and, +    `Long.MAX_VALUE`., +    timestamp is subject to the limits of a Java `Long.MIN_VALUE` and `Long., +    MAX_VALUE` divided by 1000 (the number of milliseconds in a second).]