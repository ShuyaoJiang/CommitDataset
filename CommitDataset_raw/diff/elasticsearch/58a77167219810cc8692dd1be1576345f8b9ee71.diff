[+++ b/server/src/main/java/org/elasticsearch/index/seqno/ReplicationTracker.java, +     * A callback when a new retention lease is created or an existing retention lease is removed. In practice, this callback invokes the, +     * retention lease sync action, to sync retention leases to replicas., +    private final BiConsumer<RetentionLeases, ActionListener<ReplicationResponse>> onSyncRetentionLeases;, +        onSyncRetentionLeases.accept(currentRetentionLeases, listener);, +     * Removes an existing retention lease., +     *, +     * @param id       the identifier of the retention lease, +     * @param listener the callback when the retention lease is successfully removed and synced to replicas, +     */, +    public void removeRetentionLease(final String id, final ActionListener<ReplicationResponse> listener) {, +        Objects.requireNonNull(listener);, +        final RetentionLeases currentRetentionLeases;, +        synchronized (this) {, +            assert primaryMode;, +            if (retentionLeases.contains(id) == false) {, +                throw new IllegalArgumentException("retention lease with ID [" + id + "] does not exist");, +            }, +            retentionLeases = new RetentionLeases(, +                    operationPrimaryTerm,, +                    retentionLeases.version() + 1,, +                    retentionLeases.leases().stream().filter(lease -> lease.id().equals(id) == false).collect(Collectors.toList()));, +            currentRetentionLeases = retentionLeases;, +        }, +        onSyncRetentionLeases.accept(currentRetentionLeases, listener);, +    }, +, +    /**, +     * @param onSyncRetentionLeases a callback when a new retention lease is created or an existing retention lease expires, +            final BiConsumer<RetentionLeases, ActionListener<ReplicationResponse>> onSyncRetentionLeases) {, +        this.onSyncRetentionLeases = Objects.requireNonNull(onSyncRetentionLeases);, +++ b/server/src/main/java/org/elasticsearch/index/seqno/ReplicationTracker.java, +     * A callback when a new retention lease is created or an existing retention lease is removed. In practice, this callback invokes the, +     * retention lease sync action, to sync retention leases to replicas., +    private final BiConsumer<RetentionLeases, ActionListener<ReplicationResponse>> onSyncRetentionLeases;, +        onSyncRetentionLeases.accept(currentRetentionLeases, listener);, +     * Removes an existing retention lease., +     *, +     * @param id       the identifier of the retention lease, +     * @param listener the callback when the retention lease is successfully removed and synced to replicas, +     */, +    public void removeRetentionLease(final String id, final ActionListener<ReplicationResponse> listener) {, +        Objects.requireNonNull(listener);, +        final RetentionLeases currentRetentionLeases;, +        synchronized (this) {, +            assert primaryMode;, +            if (retentionLeases.contains(id) == false) {, +                throw new IllegalArgumentException("retention lease with ID [" + id + "] does not exist");, +            }, +            retentionLeases = new RetentionLeases(, +                    operationPrimaryTerm,, +                    retentionLeases.version() + 1,, +                    retentionLeases.leases().stream().filter(lease -> lease.id().equals(id) == false).collect(Collectors.toList()));, +            currentRetentionLeases = retentionLeases;, +        }, +        onSyncRetentionLeases.accept(currentRetentionLeases, listener);, +    }, +, +    /**, +     * @param onSyncRetentionLeases a callback when a new retention lease is created or an existing retention lease expires, +            final BiConsumer<RetentionLeases, ActionListener<ReplicationResponse>> onSyncRetentionLeases) {, +        this.onSyncRetentionLeases = Objects.requireNonNull(onSyncRetentionLeases);, +++ b/server/src/main/java/org/elasticsearch/index/shard/IndexShard.java, +     * Removes an existing retention lease., +     *, +     * @param id       the identifier of the retention lease, +     * @param listener the callback when the retention lease is successfully removed and synced to replicas, +     */, +    public void removeRetentionLease(final String id, final ActionListener<ReplicationResponse> listener) {, +        Objects.requireNonNull(listener);, +        assert assertPrimaryMode();, +        verifyNotClosed();, +        replicationTracker.removeRetentionLease(id, listener);, +    }, +, +    /**, +++ b/server/src/main/java/org/elasticsearch/index/seqno/ReplicationTracker.java, +     * A callback when a new retention lease is created or an existing retention lease is removed. In practice, this callback invokes the, +     * retention lease sync action, to sync retention leases to replicas., +    private final BiConsumer<RetentionLeases, ActionListener<ReplicationResponse>> onSyncRetentionLeases;, +        onSyncRetentionLeases.accept(currentRetentionLeases, listener);, +     * Removes an existing retention lease., +     *, +     * @param id       the identifier of the retention lease, +     * @param listener the callback when the retention lease is successfully removed and synced to replicas, +     */, +    public void removeRetentionLease(final String id, final ActionListener<ReplicationResponse> listener) {, +        Objects.requireNonNull(listener);, +        final RetentionLeases currentRetentionLeases;, +        synchronized (this) {, +            assert primaryMode;, +            if (retentionLeases.contains(id) == false) {, +                throw new IllegalArgumentException("retention lease with ID [" + id + "] does not exist");, +            }, +            retentionLeases = new RetentionLeases(, +                    operationPrimaryTerm,, +                    retentionLeases.version() + 1,, +                    retentionLeases.leases().stream().filter(lease -> lease.id().equals(id) == false).collect(Collectors.toList()));, +            currentRetentionLeases = retentionLeases;, +        }]