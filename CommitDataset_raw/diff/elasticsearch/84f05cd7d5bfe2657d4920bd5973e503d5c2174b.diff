[+++ b/buildSrc/src/main/resources/checkstyle_suppressions.xml, +  <suppress files="core[/\\]src[/\\]main[/\\]java[/\\]org[/\\]elasticsearch[/\\]indices[/\\]recovery[/\\]RecoverySource.java" checks="LineLength" />, +++ b/buildSrc/src/main/resources/checkstyle_suppressions.xml, +  <suppress files="core[/\\]src[/\\]main[/\\]java[/\\]org[/\\]elasticsearch[/\\]indices[/\\]recovery[/\\]RecoverySource.java" checks="LineLength" />, +++ b/core/src/main/java/org/elasticsearch/action/admin/cluster/allocation/TransportClusterAllocationExplainAction.java, +        } else if (hasPendingAsyncFetch &&, +                shard.primary() == false &&, +                shard.unassigned() &&, +                shard.allocatedPostIndexCreate(indexMetaData) &&, +                nodeDecision.type() != Decision.Type.YES) {, +                    " decision and the shard's state is still being fetched";, +        } else if (hasPendingAsyncFetch &&, +                shard.unassigned() &&, +                shard.allocatedPostIndexCreate(indexMetaData)) {, +        } else if (shard.primary() && shard.unassigned() && shard.allocatedPostIndexCreate(indexMetaData) &&, +        } else if (shard.primary() && shard.unassigned() && shard.allocatedPostIndexCreate(indexMetaData) &&, +        } else if (shard.primary() && shard.unassigned() && storeCopy == ClusterAllocationExplanation.StoreCopy.CORRUPT) {, +        } else if (shard.primary() && shard.unassigned() && storeCopy == ClusterAllocationExplanation.StoreCopy.IO_ERROR) {, +++ b/buildSrc/src/main/resources/checkstyle_suppressions.xml, +  <suppress files="core[/\\]src[/\\]main[/\\]java[/\\]org[/\\]elasticsearch[/\\]indices[/\\]recovery[/\\]RecoverySource.java" checks="LineLength" />, +++ b/core/src/main/java/org/elasticsearch/action/admin/cluster/allocation/TransportClusterAllocationExplainAction.java, +        } else if (hasPendingAsyncFetch &&, +                shard.primary() == false &&, +                shard.unassigned() &&, +                shard.allocatedPostIndexCreate(indexMetaData) &&, +                nodeDecision.type() != Decision.Type.YES) {, +                    " decision and the shard's state is still being fetched";, +        } else if (hasPendingAsyncFetch &&, +                shard.unassigned() &&, +                shard.allocatedPostIndexCreate(indexMetaData)) {, +        } else if (shard.primary() && shard.unassigned() && shard.allocatedPostIndexCreate(indexMetaData) &&, +        } else if (shard.primary() && shard.unassigned() && shard.allocatedPostIndexCreate(indexMetaData) &&, +        } else if (shard.primary() && shard.unassigned() && storeCopy == ClusterAllocationExplanation.StoreCopy.CORRUPT) {, +        } else if (shard.primary() && shard.unassigned() && storeCopy == ClusterAllocationExplanation.StoreCopy.IO_ERROR) {, +++ b/core/src/main/java/org/elasticsearch/action/admin/indices/shards/TransportIndicesShardStoresAction.java, +            IndexMetaData indexMetaData = state.metaData().index(index);, +                ClusterShardHealth shardHealth = new ClusterShardHealth(shardId, routing, indexMetaData);, +++ b/buildSrc/src/main/resources/checkstyle_suppressions.xml, +  <suppress files="core[/\\]src[/\\]main[/\\]java[/\\]org[/\\]elasticsearch[/\\]indices[/\\]recovery[/\\]RecoverySource.java" checks="LineLength" />, +++ b/core/src/main/java/org/elasticsearch/action/admin/cluster/allocation/TransportClusterAllocationExplainAction.java, +        } else if (hasPendingAsyncFetch &&, +                shard.primary() == false &&, +                shard.unassigned() &&, +                shard.allocatedPostIndexCreate(indexMetaData) &&, +                nodeDecision.type() != Decision.Type.YES) {, +                    " decision and the shard's state is still being fetched";, +        } else if (hasPendingAsyncFetch &&, +                shard.unassigned() &&, +                shard.allocatedPostIndexCreate(indexMetaData)) {, +        } else if (shard.primary() && shard.unassigned() && shard.allocatedPostIndexCreate(indexMetaData) &&, +        } else if (shard.primary() && shard.unassigned() && shard.allocatedPostIndexCreate(indexMetaData) &&, +        } else if (shard.primary() && shard.unassigned() && storeCopy == ClusterAllocationExplanation.StoreCopy.CORRUPT) {, +        } else if (shard.primary() && shard.unassigned() && storeCopy == ClusterAllocationExplanation.StoreCopy.IO_ERROR) {, +++ b/core/src/main/java/org/elasticsearch/action/admin/indices/shards/TransportIndicesShardStoresAction.java, +            IndexMetaData indexMetaData = state.metaData().index(index);, +                ClusterShardHealth shardHealth = new ClusterShardHealth(shardId, routing, indexMetaData);, +++ b/core/src/main/java/org/elasticsearch/action/support/replication/TransportWriteAction.java, +            postWriteActions(indexShard, request, location, this, logger);, +            respondIfPossible();, +        protected void respondIfPossible() {, +        public synchronized void respondAfterAsyncAction(boolean forcedRefresh) {, +            respondIfPossible();, +            postWriteActions(indexShard, request, location, this, logger);, +            respondIfPossible();, +        protected void respondIfPossible() {, +        public synchronized void respondAfterAsyncAction(boolean forcedRefresh) {, +            respondIfPossible();, +        void respondAfterAsyncAction(boolean forcedRefresh);, +    static void postWriteActions(final IndexShard indexShard,, +        boolean pendingOps = false;, +        boolean immediateRefresh = false;, +                immediateRefresh = true;, +                    pendingOps = true;, +                        respond.respondAfterAsyncAction(forcedRefresh);, +                break;, +            case NONE:, +                break;, +        boolean fsyncTranslog = indexShard.getTranslogDurability() == Translog.Durability.REQUEST && location != null;, +        if (fsyncTranslog) {, +            indexShard.sync(location);, +        }, +        indexShard.maybeFlush();, +        if (pendingOps == false) {, +            respond.respondAfterAsyncAction(immediateRefresh);, +++ b/buildSrc/src/main/resources/checkstyle_suppressions.xml, +  <suppress files="core[/\\]src[/\\]main[/\\]java[/\\]org[/\\]elasticsearch[/\\]indices[/\\]recovery[/\\]RecoverySource.java" checks="LineLength" />, +++ b/core/src/main/java/org/elasticsearch/action/admin/cluster/allocation/TransportClusterAllocationExplainAction.java, +        } else if (hasPendingAsyncFetch &&, +                shard.primary() == false &&, +                shard.unassigned() &&, +                shard.allocatedPostIndexCreate(indexMetaData) &&, +                nodeDecision.type() != Decision.Type.YES) {, +                    " decision and the shard's state is still being fetched";, +        } else if (hasPendingAsyncFetch &&, +                shard.unassigned() &&, +                shard.allocatedPostIndexCreate(indexMetaData)) {, +        } else if (shard.primary() && shard.unassigned() && shard.allocatedPostIndexCreate(indexMetaData) &&, +        } else if (shard.primary() && shard.unassigned() && shard.allocatedPostIndexCreate(indexMetaData) &&, +        } else if (shard.primary() && shard.unassigned() && storeCopy == ClusterAllocationExplanation.StoreCopy.CORRUPT) {, +        } else if (shard.primary() && shard.unassigned() && storeCopy == ClusterAllocationExplanation.StoreCopy.IO_ERROR) {]