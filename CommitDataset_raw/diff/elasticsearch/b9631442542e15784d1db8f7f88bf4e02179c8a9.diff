[+++ b/client/rest-high-level/src/main/java/org/elasticsearch/client/Request.java, +++ b/client/rest-high-level/src/main/java/org/elasticsearch/client/Request.java, +++ b/client/rest-high-level/src/main/java/org/elasticsearch/client/RestHighLevelClient.java, +++ b/client/rest-high-level/src/main/java/org/elasticsearch/client/Request.java, +++ b/client/rest-high-level/src/main/java/org/elasticsearch/client/RestHighLevelClient.java, +++ b/client/rest-high-level/src/test/java/org/elasticsearch/client/CrudIT.java, +import org.elasticsearch.ElasticsearchStatusException;, +++ b/client/rest-high-level/src/main/java/org/elasticsearch/client/Request.java, +++ b/client/rest-high-level/src/main/java/org/elasticsearch/client/RestHighLevelClient.java, +++ b/client/rest-high-level/src/test/java/org/elasticsearch/client/CrudIT.java, +import org.elasticsearch.ElasticsearchStatusException;, +++ b/core/src/main/java/org/elasticsearch/search/SearchHit.java, +import org.elasticsearch.common.xcontent.ObjectParser;, +import org.elasticsearch.common.xcontent.ObjectParser.ValueType;, +import org.elasticsearch.search.suggest.completion.CompletionSuggestion;, +    @Override, +    public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {, +        builder.startObject();, +        toInnerXContent(builder, params);, +        builder.endObject();, +        return builder;, +    }, +, +    /**, +     * This parser outputs a temporary map of the objects needed to create the, +     * SearchHit instead of directly creating the SearchHit. The reason for this, +     * is that this way we can reuse the parser when parsing xContent from, +     * {@link CompletionSuggestion.Entry.Option} which unfortunately inlines the, +     * output of, +     * {@link #toInnerXContent(XContentBuilder, org.elasticsearch.common.xcontent.ToXContent.Params)}, +     * of the included search hit. The output of the map is used to create the, +     * actual SearchHit instance via {@link #createFromMap(Map)}, +     */, +    private static ObjectParser<Map<String, Object>, Void> MAP_PARSER = new ObjectParser<>("innerHitsParser", HashMap::new);, +, +    static {, +        declareInnerHitsParseFields(MAP_PARSER);, +, +    public static SearchHit fromXContent(XContentParser parser) {, +        return createFromMap(MAP_PARSER.apply(parser, null));, +, +    public static void declareInnerHitsParseFields(ObjectParser<Map<String, Object>, Void> parser) {, +        declareMetaDataFields(parser);, +        parser.declareString((map, value) -> map.put(Fields._TYPE, value), new ParseField(Fields._TYPE));, +        parser.declareString((map, value) -> map.put(Fields._INDEX, value), new ParseField(Fields._INDEX));, +        parser.declareString((map, value) -> map.put(Fields._ID, value), new ParseField(Fields._ID));, +        parser.declareString((map, value) -> map.put(Fields._NODE, value), new ParseField(Fields._NODE));, +        parser.declareField((map, value) -> map.put(Fields._SCORE, value), SearchHit::parseScore, new ParseField(Fields._SCORE),, +                ValueType.FLOAT_OR_NULL);, +        parser.declareLong((map, value) -> map.put(Fields._VERSION, value), new ParseField(Fields._VERSION));, +        parser.declareField((map, value) -> map.put(Fields._SHARD, value), (p, c) -> ShardId.fromString(p.text()),, +                new ParseField(Fields._SHARD), ValueType.STRING);, +        parser.declareObject((map, value) -> map.put(SourceFieldMapper.NAME, value), (p, c) -> parseSourceBytes(p),, +                new ParseField(SourceFieldMapper.NAME));, +        parser.declareObject((map, value) -> map.put(Fields.HIGHLIGHT, value), (p, c) -> parseHighlightFields(p),, +                new ParseField(Fields.HIGHLIGHT));, +        parser.declareObject((map, value) -> {, +            Map<String, SearchHitField> fieldMap = get(Fields.FIELDS, map, new HashMap<String, SearchHitField>());, +            fieldMap.putAll(value);, +            map.put(Fields.FIELDS, fieldMap);, +        }, (p, c) -> parseFields(p), new ParseField(Fields.FIELDS));, +        parser.declareObject((map, value) -> map.put(Fields._EXPLANATION, value), (p, c) -> parseExplanation(p),, +                new ParseField(Fields._EXPLANATION));, +        parser.declareObject((map, value) -> map.put(NestedIdentity._NESTED, value), NestedIdentity::fromXContent,, +                new ParseField(NestedIdentity._NESTED));, +        parser.declareObject((map, value) -> map.put(Fields.INNER_HITS, value), (p,c) -> parseInnerHits(p),, +                new ParseField(Fields.INNER_HITS));, +        parser.declareStringArray((map, list) -> map.put(Fields.MATCHED_QUERIES, list), new ParseField(Fields.MATCHED_QUERIES));, +        parser.declareField((map, list) -> map.put(Fields.SORT, list), SearchSortValues::fromXContent, new ParseField(Fields.SORT),, +                ValueType.OBJECT_ARRAY);, +, +    public static SearchHit createFromMap(Map<String, Object> values) {, +        String id = get(Fields._ID, values, null);, +        String type = get(Fields._TYPE, values, null);, +        NestedIdentity nestedIdentity = get(NestedIdentity._NESTED, values, null);, +        Map<String, SearchHitField> fields = get(Fields.FIELDS, values, null);, +, +        SearchHit searchHit = new SearchHit(-1, id, new Text(type), nestedIdentity, fields);, +        searchHit.index = get(Fields._INDEX, values, null);, +        searchHit.score(get(Fields._SCORE, values, DEFAULT_SCORE));, +        searchHit.version(get(Fields._VERSION, values, -1L));, +        searchHit.sortValues(get(Fields.SORT, values, SearchSortValues.EMPTY));, +        searchHit.highlightFields(get(Fields.HIGHLIGHT, values, null));, +        searchHit.sourceRef(get(SourceFieldMapper.NAME, values, null));, +        searchHit.explanation(get(Fields._EXPLANATION, values, null));, +        searchHit.setInnerHits(get(Fields.INNER_HITS, values, null));, +        List<String> matchedQueries = get(Fields.MATCHED_QUERIES, values, null);, +        if (matchedQueries != null) {, +        ShardId shardId = get(Fields._SHARD, values, null);, +        String nodeId = get(Fields._NODE, values, null);, +    @SuppressWarnings("unchecked"), +    private static <T> T get(String key, Map<String, Object> map, T defaultValue) {, +        return (T) map.getOrDefault(key, defaultValue);, +    }, +, +    private static float parseScore(XContentParser parser) throws IOException {, +        if (parser.currentToken() == XContentParser.Token.VALUE_NUMBER || parser.currentToken() == XContentParser.Token.VALUE_STRING) {, +            return parser.floatValue();, +        } else {, +            return Float.NaN;]