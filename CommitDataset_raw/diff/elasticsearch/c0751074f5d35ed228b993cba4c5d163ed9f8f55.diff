[+++ b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ml/MlMetaIndex.java, +import static org.elasticsearch.index.mapper.MapperService.SINGLE_MAPPING_NAME;, +            builder.startObject(SINGLE_MAPPING_NAME);, +++ b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ml/MlMetaIndex.java, +import static org.elasticsearch.index.mapper.MapperService.SINGLE_MAPPING_NAME;, +            builder.startObject(SINGLE_MAPPING_NAME);, +++ b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ml/annotations/AnnotationIndex.java, +import static org.elasticsearch.index.mapper.MapperService.SINGLE_MAPPING_NAME;, +                    createIndexRequest.mapping(SINGLE_MAPPING_NAME, annotationsMapping);, +                .startObject(SINGLE_MAPPING_NAME);, +++ b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ml/MlMetaIndex.java, +import static org.elasticsearch.index.mapper.MapperService.SINGLE_MAPPING_NAME;, +            builder.startObject(SINGLE_MAPPING_NAME);, +++ b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ml/annotations/AnnotationIndex.java, +import static org.elasticsearch.index.mapper.MapperService.SINGLE_MAPPING_NAME;, +                    createIndexRequest.mapping(SINGLE_MAPPING_NAME, annotationsMapping);, +                .startObject(SINGLE_MAPPING_NAME);, +++ b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ml/job/persistence/ElasticsearchMappings.java, +import org.elasticsearch.common.CheckedBiFunction;, +import static org.elasticsearch.index.mapper.MapperService.SINGLE_MAPPING_NAME;, +        builder.startObject(SINGLE_MAPPING_NAME);, +    public static XContentBuilder resultsMapping(String mappingType) throws IOException {, +        return resultsMapping(mappingType, Collections.emptyList());, +    public static XContentBuilder resultsMapping(String mappingType, Collection<String> extraTermFields) throws IOException {, +        builder.startObject(mappingType);, +        // end type, +        builder.endObject();, +, +    /**, +     * Generate a keyword mapping for {@code termFields} for the default type, +     * {@link org.elasticsearch.index.mapper.MapperService#SINGLE_MAPPING_NAME}, +     *, +     * If the returned mapping is used in index creation and the new index has a matching template, +     * then the mapping type ({@link org.elasticsearch.index.mapper.MapperService#SINGLE_MAPPING_NAME}), +     * must match the mapping type of the template otherwise the mappings will not be merged correctly., +     *, +     * @param termFields Fields to generate mapping for, +     * @return The mapping, +     */, +    public static XContentBuilder termFieldsMapping(Collection<String> termFields) {, +            builder.startObject(SINGLE_MAPPING_NAME);, +        builder.startObject(SINGLE_MAPPING_NAME);, +        XContentBuilder builder = jsonBuilder().startObject();, +        builder.startObject(SINGLE_MAPPING_NAME);, +, +                new String[0], MapperPlugin.NOOP_FIELD_FILTER);, +                MappingMetaData metaData = innerMap.valuesIt().next();, +    public static void addDocMappingIfMissing(String alias,, +                                              CheckedBiFunction<String, Collection<String>, XContentBuilder, IOException> mappingSupplier,, +            // Use the mapping type of the first index in the update, +            IndexMetaData indexMetaData = state.metaData().index(indicesThatRequireAnUpdate[0]);, +            String mappingType = indexMetaData.mapping().type();, +, +            try (XContentBuilder mapping = mappingSupplier.apply(mappingType, Collections.emptyList())) {, +                putMappingRequest.type(mappingType);, +++ b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ml/MlMetaIndex.java, +import static org.elasticsearch.index.mapper.MapperService.SINGLE_MAPPING_NAME;, +            builder.startObject(SINGLE_MAPPING_NAME);, +++ b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ml/annotations/AnnotationIndex.java, +import static org.elasticsearch.index.mapper.MapperService.SINGLE_MAPPING_NAME;, +                    createIndexRequest.mapping(SINGLE_MAPPING_NAME, annotationsMapping);, +                .startObject(SINGLE_MAPPING_NAME);, +++ b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ml/job/persistence/ElasticsearchMappings.java, +import org.elasticsearch.common.CheckedBiFunction;, +import static org.elasticsearch.index.mapper.MapperService.SINGLE_MAPPING_NAME;, +        builder.startObject(SINGLE_MAPPING_NAME);, +    public static XContentBuilder resultsMapping(String mappingType) throws IOException {, +        return resultsMapping(mappingType, Collections.emptyList());, +    public static XContentBuilder resultsMapping(String mappingType, Collection<String> extraTermFields) throws IOException {, +        builder.startObject(mappingType);, +        // end type, +        builder.endObject();, +, +    /**, +     * Generate a keyword mapping for {@code termFields} for the default type, +     * {@link org.elasticsearch.index.mapper.MapperService#SINGLE_MAPPING_NAME}, +     *, +     * If the returned mapping is used in index creation and the new index has a matching template, +     * then the mapping type ({@link org.elasticsearch.index.mapper.MapperService#SINGLE_MAPPING_NAME}), +     * must match the mapping type of the template otherwise the mappings will not be merged correctly., +     *, +     * @param termFields Fields to generate mapping for, +     * @return The mapping, +     */, +    public static XContentBuilder termFieldsMapping(Collection<String> termFields) {, +            builder.startObject(SINGLE_MAPPING_NAME);, +        builder.startObject(SINGLE_MAPPING_NAME);, +        XContentBuilder builder = jsonBuilder().startObject();, +        builder.startObject(SINGLE_MAPPING_NAME);, +, +                new String[0], MapperPlugin.NOOP_FIELD_FILTER);, +                MappingMetaData metaData = innerMap.valuesIt().next();, +    public static void addDocMappingIfMissing(String alias,, +                                              CheckedBiFunction<String, Collection<String>, XContentBuilder, IOException> mappingSupplier,, +            // Use the mapping type of the first index in the update, +            IndexMetaData indexMetaData = state.metaData().index(indicesThatRequireAnUpdate[0]);, +            String mappingType = indexMetaData.mapping().type();, +, +            try (XContentBuilder mapping = mappingSupplier.apply(mappingType, Collections.emptyList())) {, +                putMappingRequest.type(mappingType);]