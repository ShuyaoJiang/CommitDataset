[+++ b/core/src/main/java/org/elasticsearch/transport/RemoteClusterConnection.java, +import org.apache.lucene.util.SetOnce;, +import org.elasticsearch.cluster.ClusterName;, +    private SetOnce<ClusterName> remoteClusterName = new SetOnce<>();, +                            try {, +                                    (c) -> remoteClusterName.get() == null ? true : c.equals(remoteClusterName.get()));, +                            } catch (IllegalStateException ex) {, +                                logger.warn((Supplier<?>) () -> new ParameterizedMessage("seed node {} cluster name mismatch expected " +, +                                    "cluster name {}", connection.getNode(), remoteClusterName.get()), ex);, +                                throw ex;, +                            }, +                    if (remoteClusterName.get() == null) {, +                        assert response.getClusterName().value() != null;, +                        remoteClusterName.set(response.getClusterName());, +                    }, +++ b/core/src/main/java/org/elasticsearch/transport/RemoteClusterConnection.java, +import org.apache.lucene.util.SetOnce;, +import org.elasticsearch.cluster.ClusterName;, +    private SetOnce<ClusterName> remoteClusterName = new SetOnce<>();, +                            try {, +                                    (c) -> remoteClusterName.get() == null ? true : c.equals(remoteClusterName.get()));, +                            } catch (IllegalStateException ex) {, +                                logger.warn((Supplier<?>) () -> new ParameterizedMessage("seed node {} cluster name mismatch expected " +, +                                    "cluster name {}", connection.getNode(), remoteClusterName.get()), ex);, +                                throw ex;, +                            }, +                    if (remoteClusterName.get() == null) {, +                        assert response.getClusterName().value() != null;, +                        remoteClusterName.set(response.getClusterName());, +                    }, +++ b/core/src/test/java/org/elasticsearch/transport/RemoteClusterConnectionTests.java, +import org.hamcrest.Matchers;, +        ClusterName clusterName = ClusterName.CLUSTER_NAME_SETTING.get(s);, +                        ClusterState build = ClusterState.builder(clusterName).nodes(builder.build()).build();, +                        channel.sendResponse(new ClusterStateResponse(clusterName, build, 0L));, +    public void testClusterNameIsChecked() throws Exception {, +        List<DiscoveryNode> knownNodes = new CopyOnWriteArrayList<>();, +        List<DiscoveryNode> otherClusterKnownNodes = new CopyOnWriteArrayList<>();, +, +        Settings settings = Settings.builder().put("cluster.name", "testClusterNameIsChecked").build();, +        try (MockTransportService seedTransport = startTransport("seed_node", knownNodes, Version.CURRENT, threadPool, settings);, +            MockTransportService discoverableTransport = startTransport("discoverable_node", knownNodes, Version.CURRENT, threadPool,, +                settings);, +             MockTransportService otherClusterTransport = startTransport("other_cluster_discoverable_node", otherClusterKnownNodes,, +                 Version.CURRENT, threadPool, Settings.builder().put("cluster.name", "otherCluster").build());, +         MockTransportService otherClusterDiscoverable= startTransport("other_cluster_discoverable_node", otherClusterKnownNodes,, +             Version.CURRENT, threadPool, Settings.builder().put("cluster.name", "otherCluster").build())) {, +            DiscoveryNode seedNode = seedTransport.getLocalDiscoNode();, +            DiscoveryNode discoverableNode = discoverableTransport.getLocalDiscoNode();, +            knownNodes.add(seedTransport.getLocalDiscoNode());, +            knownNodes.add(discoverableTransport.getLocalDiscoNode());, +            otherClusterKnownNodes.add(otherClusterDiscoverable.getLocalDiscoNode());, +            otherClusterKnownNodes.add(otherClusterTransport.getLocalDiscoNode());, +            Collections.shuffle(knownNodes, random());, +, +            try (MockTransportService service = MockTransportService.createNewService(Settings.EMPTY, Version.CURRENT, threadPool, null)) {, +                service.start();, +                service.acceptIncomingRequests();, +                try (RemoteClusterConnection connection = new RemoteClusterConnection(Settings.EMPTY, "test-cluster",, +                    Arrays.asList(seedNode), service, Integer.MAX_VALUE, n -> true)) {, +                    updateSeedNodes(connection, Arrays.asList(seedNode));, +                    assertTrue(service.nodeConnected(seedNode));, +                    assertTrue(service.nodeConnected(discoverableNode));, +                    assertTrue(connection.assertNoRunningConnections());, +                    List<DiscoveryNode> discoveryNodes = Arrays.asList(otherClusterTransport.getLocalDiscoNode(), seedNode);, +                    Collections.shuffle(discoveryNodes, random());, +                    updateSeedNodes(connection, discoveryNodes);, +                    assertTrue(service.nodeConnected(seedNode));, +                    for (DiscoveryNode otherClusterNode : otherClusterKnownNodes) {, +                        assertFalse(service.nodeConnected(otherClusterNode));, +                    }, +                    assertFalse(service.nodeConnected(otherClusterTransport.getLocalDiscoNode()));, +                    assertTrue(service.nodeConnected(discoverableNode));, +                    assertTrue(connection.assertNoRunningConnections());, +                    IllegalStateException illegalStateException = expectThrows(IllegalStateException.class, () ->, +                        updateSeedNodes(connection, Arrays.asList(otherClusterTransport.getLocalDiscoNode())));, +                    assertThat(illegalStateException.getMessage(),, +                        Matchers.startsWith("handshake failed, mismatched cluster name [Cluster [otherCluster]]" +, +                            " - {other_cluster_discoverable_node}"));, +                }, +            }, +        }, +    }, +]