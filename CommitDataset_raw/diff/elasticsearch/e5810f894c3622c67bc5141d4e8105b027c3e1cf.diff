[+++ b/plugin/src/main/java/org/elasticsearch/xpack/ml/job/process/autodetect/output/AutoDetectResultProcessor.java, +, +        // If a function call in this throws for some reason we don't want it, +        // to kill the results reader thread as autodetect will be blocked, +        // trying to write its output., +                try {, +                    LOGGER.warn(new ParameterizedMessage("[{}] Error processing autodetect result", jobId), e);, +                }, +            }, +, +            try {, +                context.bulkResultsPersister.executeRequest();, +            } catch (Exception e) {, +                LOGGER.warn(new ParameterizedMessage("[{}] Error persisting autodetect results", jobId), e);, +            }, +, +            LOGGER.info("[{}] {} buckets parsed from autodetect output", jobId, bucketCount);, +        }, +        catch (Exception e) {, +            // We should only get here if the iterator throws in which, +            // case parsing the autodetect output has failed., +            LOGGER.error(new ParameterizedMessage("[{}] error parsing autodetect output", jobId), e);, +            LOGGER.info("[{}] Interrupted acquiring update model snapshot semaphore", jobId);, +++ b/plugin/src/main/java/org/elasticsearch/xpack/ml/job/process/autodetect/output/AutoDetectResultProcessor.java, +, +        // If a function call in this throws for some reason we don't want it, +        // to kill the results reader thread as autodetect will be blocked, +        // trying to write its output., +                try {, +                    LOGGER.warn(new ParameterizedMessage("[{}] Error processing autodetect result", jobId), e);, +                }, +            }, +, +            try {, +                context.bulkResultsPersister.executeRequest();, +            } catch (Exception e) {, +                LOGGER.warn(new ParameterizedMessage("[{}] Error persisting autodetect results", jobId), e);, +            }, +, +            LOGGER.info("[{}] {} buckets parsed from autodetect output", jobId, bucketCount);, +        }, +        catch (Exception e) {, +            // We should only get here if the iterator throws in which, +            // case parsing the autodetect output has failed., +            LOGGER.error(new ParameterizedMessage("[{}] error parsing autodetect output", jobId), e);, +            LOGGER.info("[{}] Interrupted acquiring update model snapshot semaphore", jobId);, +++ b/plugin/src/main/java/org/elasticsearch/xpack/ml/job/process/autodetect/output/AutodetectResultsParser.java, +            // if start of an array ignore it, we expect an array of results, +++ b/plugin/src/main/java/org/elasticsearch/xpack/ml/job/process/autodetect/output/AutoDetectResultProcessor.java, +, +        // If a function call in this throws for some reason we don't want it, +        // to kill the results reader thread as autodetect will be blocked, +        // trying to write its output., +                try {, +                    LOGGER.warn(new ParameterizedMessage("[{}] Error processing autodetect result", jobId), e);, +                }, +            }, +, +            try {, +                context.bulkResultsPersister.executeRequest();, +            } catch (Exception e) {, +                LOGGER.warn(new ParameterizedMessage("[{}] Error persisting autodetect results", jobId), e);, +            }, +, +            LOGGER.info("[{}] {} buckets parsed from autodetect output", jobId, bucketCount);, +        }, +        catch (Exception e) {, +            // We should only get here if the iterator throws in which, +            // case parsing the autodetect output has failed., +            LOGGER.error(new ParameterizedMessage("[{}] error parsing autodetect output", jobId), e);, +            LOGGER.info("[{}] Interrupted acquiring update model snapshot semaphore", jobId);, +++ b/plugin/src/main/java/org/elasticsearch/xpack/ml/job/process/autodetect/output/AutodetectResultsParser.java, +            // if start of an array ignore it, we expect an array of results, +++ b/plugin/src/test/java/org/elasticsearch/xpack/ml/job/process/autodetect/output/AutoDetectResultProcessorTests.java, +import org.elasticsearch.ElasticsearchException;, +import static org.mockito.Mockito.doThrow;, +, +    public void testPersisterThrowingDoesntBlockProcessing() {, +        AutodetectResult autodetectResult = mock(AutodetectResult.class);, +        ModelSizeStats modelSizeStats = mock(ModelSizeStats.class);, +        when(autodetectResult.getModelSizeStats()).thenReturn(modelSizeStats);, +, +        @SuppressWarnings("unchecked"), +        Iterator<AutodetectResult> iterator = mock(Iterator.class);, +        when(iterator.hasNext()).thenReturn(true).thenReturn(true).thenReturn(false);, +        when(iterator.next()).thenReturn(autodetectResult);, +        AutodetectProcess process = mock(AutodetectProcess.class);, +        when(process.readAutodetectResults()).thenReturn(iterator);, +, +        doThrow(new ElasticsearchException("this test throws")).when(persister).persistModelSizeStats(any());, +, +        processorUnderTest.process(process, randomBoolean());, +        verify(persister, times(2)).persistModelSizeStats(any());, +    }, +++ b/plugin/src/main/java/org/elasticsearch/xpack/ml/job/process/autodetect/output/AutoDetectResultProcessor.java, +, +        // If a function call in this throws for some reason we don't want it, +        // to kill the results reader thread as autodetect will be blocked, +        // trying to write its output., +                try {]