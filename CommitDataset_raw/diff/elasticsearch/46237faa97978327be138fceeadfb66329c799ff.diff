[+++ b/server/src/main/java/org/elasticsearch/action/admin/cluster/reroute/TransportClusterRerouteAction.java, +import org.elasticsearch.ExceptionsHelper;, +import org.elasticsearch.action.ActionListenerResponseHandler;, +import org.elasticsearch.action.admin.indices.shards.IndicesShardStoresAction;, +import org.elasticsearch.action.admin.indices.shards.IndicesShardStoresRequest;, +import org.elasticsearch.action.admin.indices.shards.IndicesShardStoresResponse;, +import org.elasticsearch.cluster.node.DiscoveryNode;, +import org.elasticsearch.cluster.routing.allocation.command.AbstractAllocateAllocationCommand;, +import org.elasticsearch.cluster.routing.allocation.command.AllocateStalePrimaryAllocationCommand;, +import org.elasticsearch.cluster.routing.allocation.command.AllocationCommand;, +import org.elasticsearch.common.Strings;, +import org.elasticsearch.common.collect.ImmutableOpenIntMap;, +import org.elasticsearch.common.collect.ImmutableOpenMap;, +import java.util.ArrayList;, +import java.util.HashMap;, +import java.util.List;, +import java.util.Map;, +, +        Map<String, List<AbstractAllocateAllocationCommand>> stalePrimaryAllocations = new HashMap<>();, +        for (AllocationCommand command : request.getCommands().commands()) {, +            if (command instanceof AllocateStalePrimaryAllocationCommand) {, +                final AllocateStalePrimaryAllocationCommand cmd = (AllocateStalePrimaryAllocationCommand) command;, +                stalePrimaryAllocations.computeIfAbsent(cmd.index(), k -> new ArrayList<>()).add(cmd);, +            }, +        }, +        if (stalePrimaryAllocations.isEmpty()) {, +            submitStateUpdate(request, listener);, +        } else {, +            verifyThenSubmitUpdate(request, listener, stalePrimaryAllocations);, +        }, +    }, +, +    private void verifyThenSubmitUpdate(ClusterRerouteRequest request, ActionListener<ClusterRerouteResponse> listener,, +        Map<String, List<AbstractAllocateAllocationCommand>> stalePrimaryAllocations) {, +        transportService.sendRequest(transportService.getLocalNode(), IndicesShardStoresAction.NAME,, +            new IndicesShardStoresRequest().indices(stalePrimaryAllocations.keySet().toArray(Strings.EMPTY_ARRAY)),, +            new ActionListenerResponseHandler<>(, +                ActionListener.wrap(, +                    response -> {, +                        ImmutableOpenMap<String, ImmutableOpenIntMap<List<IndicesShardStoresResponse.StoreStatus>>> status =, +                            response.getStoreStatuses();, +                        Exception e = null;, +                        for (Map.Entry<String, List<AbstractAllocateAllocationCommand>> entry : stalePrimaryAllocations.entrySet()) {, +                            final String index = entry.getKey();, +                            final ImmutableOpenIntMap<List<IndicesShardStoresResponse.StoreStatus>> indexStatus = status.get(index);, +                            assert indexStatus != null;, +                            for (AbstractAllocateAllocationCommand command : entry.getValue()) {, +                                final List<IndicesShardStoresResponse.StoreStatus> shardStatus =, +                                    indexStatus.get(command.shardId());, +                                if (shardStatus == null || shardStatus.isEmpty()) {, +                                    e = ExceptionsHelper.useOrSuppress(e, new IllegalArgumentException(, +                                        "No data for shard [" + command.shardId() + "] of index [" + index + "] found on any node"), +                                    );, +                                } else if (shardStatus.stream().noneMatch(storeStatus -> {, +                                    final DiscoveryNode node = storeStatus.getNode();, +                                    final String nodeInCommand = command.node();, +                                    return nodeInCommand.equals(node.getName()) || nodeInCommand.equals(node.getId());, +                                })) {, +                                    e = ExceptionsHelper.useOrSuppress(e, new IllegalArgumentException(, +                                        "No data for shard [" + command.shardId() + "] of index [" + index + "] found on node [", +                                            + command.node() + ']'));, +                                }, +                            }, +                        }, +                        if (e == null) {, +                            submitStateUpdate(request, listener);, +                        } else {, +                            listener.onFailure(e);, +                        }, +                    }, listener::onFailure, +                ), IndicesShardStoresResponse::new));, +    }, +, +    private void submitStateUpdate(final ClusterRerouteRequest request, final ActionListener<ClusterRerouteResponse> listener) {, +        clusterService.submitStateUpdateTask("cluster_reroute (api)",, +            new ClusterRerouteResponseAckedClusterStateUpdateTask(logger, allocationService, request,, +                ActionListener.wrap(, +                    }, listener::onFailure)));, +++ b/server/src/main/java/org/elasticsearch/action/admin/cluster/reroute/TransportClusterRerouteAction.java, +import org.elasticsearch.ExceptionsHelper;, +import org.elasticsearch.action.ActionListenerResponseHandler;, +import org.elasticsearch.action.admin.indices.shards.IndicesShardStoresAction;, +import org.elasticsearch.action.admin.indices.shards.IndicesShardStoresRequest;, +import org.elasticsearch.action.admin.indices.shards.IndicesShardStoresResponse;, +import org.elasticsearch.cluster.node.DiscoveryNode;, +import org.elasticsearch.cluster.routing.allocation.command.AbstractAllocateAllocationCommand;, +import org.elasticsearch.cluster.routing.allocation.command.AllocateStalePrimaryAllocationCommand;, +import org.elasticsearch.cluster.routing.allocation.command.AllocationCommand;, +import org.elasticsearch.common.Strings;, +import org.elasticsearch.common.collect.ImmutableOpenIntMap;, +import org.elasticsearch.common.collect.ImmutableOpenMap;, +import java.util.ArrayList;, +import java.util.HashMap;, +import java.util.List;, +import java.util.Map;, +, +        Map<String, List<AbstractAllocateAllocationCommand>> stalePrimaryAllocations = new HashMap<>();, +        for (AllocationCommand command : request.getCommands().commands()) {, +            if (command instanceof AllocateStalePrimaryAllocationCommand) {, +                final AllocateStalePrimaryAllocationCommand cmd = (AllocateStalePrimaryAllocationCommand) command;]