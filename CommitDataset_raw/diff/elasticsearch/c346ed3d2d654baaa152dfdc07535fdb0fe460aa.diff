[+++ b/src/test/java/org/elasticsearch/test/integration/percolator/ConcurrentPercolatorTests.java, +import org.elasticsearch.action.admin.cluster.health.ClusterHealthResponse;, +import org.elasticsearch.action.admin.cluster.health.ClusterHealthStatus;, +import org.elasticsearch.client.Client;, +import org.elasticsearch.client.Requests;, +import org.elasticsearch.common.Priority;, +import org.elasticsearch.common.network.NetworkUtils;, +import org.elasticsearch.common.settings.Settings;, +import org.elasticsearch.test.integration.AbstractNodesTests;, +import org.testng.annotations.AfterClass;, +import org.testng.annotations.BeforeClass;, +import org.testng.annotations.BeforeMethod;, +import static org.elasticsearch.common.settings.ImmutableSettings.settingsBuilder;, +public class ConcurrentPercolatorTests extends AbstractNodesTests {, +, +    private Client client;, +, +    @BeforeClass, +    public void startNodes() throws Exception {, +        Settings settings = settingsBuilder(), +                .put("cluster.name", "percolator-test-cluster-" + NetworkUtils.getLocalAddress().getHostName() + "_" + System.currentTimeMillis()), +                .put("gateway.type", "none").build();, +        logger.info("--> starting 3 nodes");, +        startNode("node1", settings);, +        startNode("node2", settings);, +        startNode("node3", settingsBuilder().put(settings).put("node.client", true));, +        client = client("node3");, +    }, +, +    @AfterClass, +    public void cleanAndCloseNodes() throws Exception {, +        closeAllNodes();, +    }, +, +    @BeforeMethod, +    public void beforeTest() throws Exception {, +        client.admin().indices().prepareDelete().execute().actionGet();, +        ensureGreen();, +    }, +, +                        // If percolate is locked, then make sure isn't unlocked, otherwise we hang forever, +                        CountDownLatch percolateLatch = latches[0];, +                        latches[0] = null;, +                        if (percolateLatch != null) {, +                            percolateLatch.countDown();, +                        }, +            latches[0] = new CountDownLatch(numIndexThreads); // Locks percolating until all indexing threads have been blocked, +            latches[1] = new CountDownLatch(1); // Locks indexing threads until percolate is done., +    private Client client() {, +        return client;, +    }, +, +    private void ensureGreen() {, +        ClusterHealthResponse actionGet = client.admin().cluster(), +                .health(Requests.clusterHealthRequest().waitForGreenStatus().waitForEvents(Priority.LANGUID).waitForRelocatingShards(0)).actionGet();, +        assertThat(actionGet.isTimedOut(), equalTo(false));, +        assertThat(actionGet.getStatus(), equalTo(ClusterHealthStatus.GREEN));, +    }, +]