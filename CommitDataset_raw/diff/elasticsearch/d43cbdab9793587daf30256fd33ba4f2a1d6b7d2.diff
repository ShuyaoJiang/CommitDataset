[+++ b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ml/job/persistence/AnomalyDetectorsIndex.java, +    public static final int CONFIG_INDEX_MAX_RESULTS_WINDOW = 10_000;, +, +++ b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ml/job/persistence/AnomalyDetectorsIndex.java, +    public static final int CONFIG_INDEX_MAX_RESULTS_WINDOW = 10_000;, +, +++ b/x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/MachineLearning.java, +                                .put(UnassignedInfo.INDEX_DELAYED_NODE_LEFT_TIMEOUT_SETTING.getKey(), delayedNodeTimeOutSetting), +                                .put(IndexSettings.MAX_RESULT_WINDOW_SETTING.getKey(),, +                                        AnomalyDetectorsIndex.CONFIG_INDEX_MAX_RESULTS_WINDOW)), +++ b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ml/job/persistence/AnomalyDetectorsIndex.java, +    public static final int CONFIG_INDEX_MAX_RESULTS_WINDOW = 10_000;, +, +++ b/x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/MachineLearning.java, +                                .put(UnassignedInfo.INDEX_DELAYED_NODE_LEFT_TIMEOUT_SETTING.getKey(), delayedNodeTimeOutSetting), +                                .put(IndexSettings.MAX_RESULT_WINDOW_SETTING.getKey(),, +                                        AnomalyDetectorsIndex.CONFIG_INDEX_MAX_RESULTS_WINDOW)), +++ b/x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/MlConfigMigrationEligibilityCheck.java, +import org.elasticsearch.cluster.routing.IndexRoutingTable;, +import org.elasticsearch.xpack.core.ml.job.persistence.AnomalyDetectorsIndex;, +, +     *     False if the .ml-config index shards are not active, +, +        return mlConfigIndexIsAllocated(clusterState);, +    }, +, +    static boolean mlConfigIndexIsAllocated(ClusterState clusterState) {, +        if (clusterState.metaData().hasIndex(AnomalyDetectorsIndex.configIndexName()) == false) {, +            return false;, +        }, +, +        IndexRoutingTable routingTable = clusterState.getRoutingTable().index(AnomalyDetectorsIndex.configIndexName());, +        if (routingTable == null || routingTable.allPrimaryShardsActive() == false) {, +            return false;, +        }, +     *     False if the job is not in the cluster state, +++ b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ml/job/persistence/AnomalyDetectorsIndex.java, +    public static final int CONFIG_INDEX_MAX_RESULTS_WINDOW = 10_000;, +, +++ b/x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/MachineLearning.java, +                                .put(UnassignedInfo.INDEX_DELAYED_NODE_LEFT_TIMEOUT_SETTING.getKey(), delayedNodeTimeOutSetting), +                                .put(IndexSettings.MAX_RESULT_WINDOW_SETTING.getKey(),, +                                        AnomalyDetectorsIndex.CONFIG_INDEX_MAX_RESULTS_WINDOW)), +++ b/x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/MlConfigMigrationEligibilityCheck.java, +import org.elasticsearch.cluster.routing.IndexRoutingTable;, +import org.elasticsearch.xpack.core.ml.job.persistence.AnomalyDetectorsIndex;, +, +     *     False if the .ml-config index shards are not active, +, +        return mlConfigIndexIsAllocated(clusterState);, +    }, +, +    static boolean mlConfigIndexIsAllocated(ClusterState clusterState) {, +        if (clusterState.metaData().hasIndex(AnomalyDetectorsIndex.configIndexName()) == false) {, +            return false;, +        }, +, +        IndexRoutingTable routingTable = clusterState.getRoutingTable().index(AnomalyDetectorsIndex.configIndexName());, +        if (routingTable == null || routingTable.allPrimaryShardsActive() == false) {, +            return false;, +        }, +     *     False if the job is not in the cluster state, +++ b/x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/MlConfigMigrator.java, +import org.elasticsearch.action.admin.indices.create.CreateIndexRequest;, +import org.elasticsearch.action.admin.indices.create.CreateIndexResponse;, +import org.elasticsearch.cluster.metadata.IndexMetaData;, +import org.elasticsearch.index.IndexSettings;, +, +        if (clusterState.metaData().hasIndex(AnomalyDetectorsIndex.configIndexName()) == false) {, +            createConfigIndex(ActionListener.wrap(, +                    response -> {, +                        unMarkMigrationInProgress.onResponse(Boolean.FALSE);, +                    },, +                    unMarkMigrationInProgress::onFailure, +            ));, +            return;, +        }, +, +        if (migrationEligibilityCheck.canStartMigration(clusterState) == false) {, +            unMarkMigrationInProgress.onResponse(Boolean.FALSE);, +            return;, +        }, +, +        snapshotMlMeta(MlMetadata.getMlMetadata(clusterState), ActionListener.wrap(, +                response -> {, +                    // We have successfully snapshotted the ML configs so we don't need to try again, +                    tookConfigSnapshot.set(true);, +            logger.debug("adding job to migrate: " + job.getId());, +            logger.debug("adding datafeed to migrate: " + datafeedConfig.getId());, +    private void createConfigIndex(ActionListener<Boolean> listener) {, +        logger.info("creating the .ml-config index");, +        CreateIndexRequest createIndexRequest = new CreateIndexRequest(AnomalyDetectorsIndex.configIndexName());, +        try, +        {, +            createIndexRequest.settings(, +                    Settings.builder(), +                            .put(IndexMetaData.SETTING_NUMBER_OF_SHARDS, 1), +                            .put(IndexMetaData.SETTING_AUTO_EXPAND_REPLICAS, "0-1"), +                            .put(IndexSettings.MAX_RESULT_WINDOW_SETTING.getKey(), AnomalyDetectorsIndex.CONFIG_INDEX_MAX_RESULTS_WINDOW), +            );]