[+++ b/src/main/java/org/elasticsearch/common/lucene/Lucene.java, +     * Wait for an index to exist for up to {@code timeLimitMillis}. Returns, +     * true if the index eventually exists, false if not., +     *, +     * Will retry the directory every second for at least {@code timeLimitMillis}, +     */, +    public static final boolean waitForIndex(final Directory directory, final long timeLimitMillis), +            throws IOException {, +        final long DELAY = 1000;, +        long waited = 0;, +        try {, +            while (true) {, +                if (waited >= timeLimitMillis) {, +                    break;, +                }, +                if (indexExists(directory)) {, +                    return true;, +                }, +                Thread.sleep(DELAY);, +                waited += DELAY;, +            }, +        } catch (InterruptedException e) {, +            Thread.currentThread().interrupt();, +            return false;, +        }, +        // one more try after all retries, +        return indexExists(directory);, +    }, +, +    /**, +++ b/src/main/java/org/elasticsearch/common/lucene/Lucene.java, +     * Wait for an index to exist for up to {@code timeLimitMillis}. Returns, +     * true if the index eventually exists, false if not., +     *, +     * Will retry the directory every second for at least {@code timeLimitMillis}, +     */, +    public static final boolean waitForIndex(final Directory directory, final long timeLimitMillis), +            throws IOException {, +        final long DELAY = 1000;, +        long waited = 0;, +        try {, +            while (true) {, +                if (waited >= timeLimitMillis) {, +                    break;, +                }, +                if (indexExists(directory)) {, +                    return true;, +                }, +                Thread.sleep(DELAY);, +                waited += DELAY;, +            }, +        } catch (InterruptedException e) {, +            Thread.currentThread().interrupt();, +            return false;, +        }, +        // one more try after all retries, +        return indexExists(directory);, +    }, +, +    /**, +++ b/src/main/java/org/elasticsearch/index/engine/ShadowEngine.java, +import org.elasticsearch.common.unit.TimeValue;, +import org.elasticsearch.index.shard.IndexShardException;, +    /** how long to wait for an index to exist */, +    public final static String NONEXISTENT_INDEX_RETRY_WAIT = "index.shadow.wait_for_initial_commit";, +    public final static TimeValue DEFAULT_NONEXISTENT_INDEX_RETRY_WAIT = TimeValue.timeValueSeconds(5);, +, +        final long nonexistentRetryTime = engineConfig.getIndexSettings(), +                .getAsTime(NONEXISTENT_INDEX_RETRY_WAIT, DEFAULT_NONEXISTENT_INDEX_RETRY_WAIT), +                .getMillis();, +                if (Lucene.waitForIndex(store.directory(), nonexistentRetryTime)) {, +                } else {, +                    throw new IndexShardException(shardId, "failed to open a shadow engine after" +, +                            nonexistentRetryTime + "ms, " +, +                            "directory is not an index");, +                }, +++ b/src/main/java/org/elasticsearch/common/lucene/Lucene.java, +     * Wait for an index to exist for up to {@code timeLimitMillis}. Returns, +     * true if the index eventually exists, false if not., +     *, +     * Will retry the directory every second for at least {@code timeLimitMillis}, +     */, +    public static final boolean waitForIndex(final Directory directory, final long timeLimitMillis), +            throws IOException {, +        final long DELAY = 1000;, +        long waited = 0;, +        try {, +            while (true) {, +                if (waited >= timeLimitMillis) {, +                    break;, +                }, +                if (indexExists(directory)) {, +                    return true;, +                }, +                Thread.sleep(DELAY);, +                waited += DELAY;, +            }, +        } catch (InterruptedException e) {, +            Thread.currentThread().interrupt();, +            return false;]