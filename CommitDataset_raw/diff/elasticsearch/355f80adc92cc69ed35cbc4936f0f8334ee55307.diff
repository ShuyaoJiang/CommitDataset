[+++ b/src/main/java/org/apache/lucene/search/vectorhighlight/XSimpleFragListBuilder.java, +package org.apache.lucene.search.vectorhighlight;, +, +/*, + * Licensed to the Apache Software Foundation (ASF) under one or more, + * contributor license agreements.  See the NOTICE file distributed with, + * this work for additional information regarding copyright ownership., + * The ASF licenses this file to You under the Apache License, Version 2.0, + * (the "License"); you may not use this file except in compliance with, + * the License.  You may obtain a copy of the License at, + *, + *     http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS,, + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied., + * See the License for the specific language governing permissions and, + * limitations under the License., + */, +, +import java.util.ArrayList;, +import java.util.Iterator;, +import java.util.List;, +, +import org.apache.lucene.search.vectorhighlight.FieldPhraseList.WeightedPhraseInfo;, +import org.apache.lucene.util.Version;, +import org.elasticsearch.common.lucene.Lucene;, +, +/**, + * A non-abstract copy of the abstract {@link BaseFragListBuilder}. that works, + * in the same way as {@link SimpleFragListBuilder} but isn't prone to the, + * problem of negative offsets. This is fixed in Lucene 4.3 and this class, + * should be removed once Elasticsearch upgraded to Lucene 4.3, + * <p>, + * LUCENE-4899: FastVectorHighlihgter failed with, + * {@link StringIndexOutOfBoundsException} if a single highlight phrase or term was, + * greater than the fragCharSize producing negative string offsets, + * </p>, + */, +public final class XSimpleFragListBuilder implements FragListBuilder {, +, +    public static final int MARGIN_DEFAULT = 6;, +    public static final int MIN_FRAG_CHAR_SIZE_FACTOR = 3;, +, +    final int margin;, +    final int minFragCharSize;, +    static {, +        assert Version.LUCENE_42 == Lucene.VERSION: "Elasticsearch has upgraded to Lucene Version: [" + Lucene.VERSION + "] this should can be removed"; , +    }, +, +    public XSimpleFragListBuilder(int margin) {, +        if (margin < 0), +            throw new IllegalArgumentException("margin(" + margin + ") is too small. It must be 0 or higher.");, +, +        this.margin = margin;, +        this.minFragCharSize = Math.max(1, margin * MIN_FRAG_CHAR_SIZE_FACTOR);, +    }, +, +    public XSimpleFragListBuilder() {, +        this(MARGIN_DEFAULT);, +    }, +, +    @Override, +    public FieldFragList createFieldFragList(FieldPhraseList fieldPhraseList, int fragCharSize) {, +        return createFieldFragList(fieldPhraseList, new SimpleFieldFragList(fragCharSize), fragCharSize);, +    }, +, +    protected FieldFragList createFieldFragList(FieldPhraseList fieldPhraseList, FieldFragList fieldFragList, int fragCharSize) {, +        if (fragCharSize < minFragCharSize), +            throw new IllegalArgumentException("fragCharSize(" + fragCharSize + ") is too small. It must be " + minFragCharSize + " or higher.");, +, +        List<WeightedPhraseInfo> wpil = new ArrayList<WeightedPhraseInfo>();, +        IteratorQueue<WeightedPhraseInfo> queue = new IteratorQueue<WeightedPhraseInfo>(fieldPhraseList.getPhraseList().iterator());, +        WeightedPhraseInfo phraseInfo = null;, +        int startOffset = 0;, +        while ((phraseInfo = queue.top()) != null) {, +            // if the phrase violates the border of previous fragment, discard, +            // it and try next phrase, +            if (phraseInfo.getStartOffset() < startOffset) {, +                queue.removeTop();, +                continue;, +            }, +, +            wpil.clear();, +            final int currentPhraseStartOffset = phraseInfo.getStartOffset();, +            int currentPhraseEndOffset = phraseInfo.getEndOffset();, +            int spanStart = Math.max(currentPhraseStartOffset - margin, startOffset);, +            int spanEnd = Math.max(currentPhraseEndOffset, spanStart + fragCharSize);, +            if (acceptPhrase(queue.removeTop(), currentPhraseEndOffset - currentPhraseStartOffset, fragCharSize)) {, +                wpil.add(phraseInfo);, +            }, +            while ((phraseInfo = queue.top()) != null) { // pull until we crossed the current spanEnd, +                if (phraseInfo.getEndOffset() <= spanEnd) {, +                    currentPhraseEndOffset = phraseInfo.getEndOffset();, +                    if (acceptPhrase(queue.removeTop(), currentPhraseEndOffset - currentPhraseStartOffset, fragCharSize)) {, +                        wpil.add(phraseInfo);, +                    }, +                } else {, +                    break;, +                }]