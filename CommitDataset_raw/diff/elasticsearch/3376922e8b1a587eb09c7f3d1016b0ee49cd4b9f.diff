[+++ b/server/src/main/java/org/elasticsearch/common/settings/ClusterSettings.java, +                    RemoteClusterAware.REMOTE_CLUSTERS_PROXY,, +++ b/server/src/main/java/org/elasticsearch/common/settings/ClusterSettings.java, +                    RemoteClusterAware.REMOTE_CLUSTERS_PROXY,, +++ b/server/src/main/java/org/elasticsearch/common/settings/Setting.java, +    public static Setting<String> simpleString(String key, Function<String, String> parser, Property... properties) {, +        return new Setting<>(key, s -> "", parser, properties);, +    }, +, +++ b/server/src/main/java/org/elasticsearch/common/settings/ClusterSettings.java, +                    RemoteClusterAware.REMOTE_CLUSTERS_PROXY,, +++ b/server/src/main/java/org/elasticsearch/common/settings/Setting.java, +    public static Setting<String> simpleString(String key, Function<String, String> parser, Property... properties) {, +        return new Setting<>(key, s -> "", parser, properties);, +    }, +, +++ b/server/src/main/java/org/elasticsearch/transport/RemoteClusterAware.java, +import java.util.EnumSet;, +import org.elasticsearch.common.Strings;, +import org.elasticsearch.common.UUIDs;, +import org.elasticsearch.common.collect.Tuple;, +    /**, +     * A proxy address for the remote cluster., +     * NOTE: this settings is undocumented until we have at last one transport that supports passing, +     * on the hostname via a mechanism like SNI., +     */, +    public static final Setting.AffixSetting<String> REMOTE_CLUSTERS_PROXY = Setting.affixKeySetting(, +        "search.remote.",, +        "proxy",, +        key -> Setting.simpleString(key, s -> {, +            if (Strings.hasLength(s)) {, +                parsePort(s);, +            }, +            return s;, +        }, Setting.Property.NodeScope, Setting.Property.Dynamic), REMOTE_CLUSTERS_SEEDS);, +, +, +    /**, +     * Builds the dynamic per-cluster config from the given settings. This is a map keyed by the cluster alias that points to a tuple, +     * (ProxyAddresss, [SeedNodeSuppliers]). If a cluster is configured with a proxy address all seed nodes will point to, +     * {@link TransportAddress#META_ADDRESS} and their configured address will be used as the hostname for the generated discovery node., +     */, +    protected static Map<String, Tuple<String, List<Supplier<DiscoveryNode>>>> buildRemoteClustersDynamicConfig(Settings settings) {, +                final boolean proxyMode = REMOTE_CLUSTERS_PROXY.getConcreteSettingForNamespace(clusterName).exists(settings);, +                    nodes.add(() -> buildSeedNode(clusterName, address, proxyMode));, +                }, +                return new Tuple<>(REMOTE_CLUSTERS_PROXY.getConcreteSettingForNamespace(clusterName).get(settings), nodes);, +            }));, +    }, +, +    static DiscoveryNode buildSeedNode(String clusterName, String address, boolean proxyMode) {, +        if (proxyMode) {, +            TransportAddress transportAddress = new TransportAddress(TransportAddress.META_ADDRESS, 0);, +            String hostName = address.substring(0, indexOfPortSeparator(address));, +            return new DiscoveryNode("", clusterName + "#" + address, UUIDs.randomBase64UUID(), hostName, address,, +                transportAddress, Collections, +                .emptyMap(), EnumSet.allOf(DiscoveryNode.Role.class),, +                Version.CURRENT.minimumCompatibilityVersion());, +        } else {, +, +    protected abstract void updateRemoteCluster(String clusterAlias, List<String> addresses, String proxy);, +        clusterSettings.addAffixUpdateConsumer(RemoteClusterAware.REMOTE_CLUSTERS_PROXY,, +            RemoteClusterAware.REMOTE_CLUSTERS_SEEDS,, +            (key, value) -> updateRemoteCluster(key, value.v2(), value.v1()),, +, +++ b/server/src/main/java/org/elasticsearch/common/settings/ClusterSettings.java, +                    RemoteClusterAware.REMOTE_CLUSTERS_PROXY,, +++ b/server/src/main/java/org/elasticsearch/common/settings/Setting.java, +    public static Setting<String> simpleString(String key, Function<String, String> parser, Property... properties) {, +        return new Setting<>(key, s -> "", parser, properties);, +    }, +, +++ b/server/src/main/java/org/elasticsearch/transport/RemoteClusterAware.java, +import java.util.EnumSet;, +import org.elasticsearch.common.Strings;, +import org.elasticsearch.common.UUIDs;, +import org.elasticsearch.common.collect.Tuple;, +    /**, +     * A proxy address for the remote cluster., +     * NOTE: this settings is undocumented until we have at last one transport that supports passing, +     * on the hostname via a mechanism like SNI., +     */, +    public static final Setting.AffixSetting<String> REMOTE_CLUSTERS_PROXY = Setting.affixKeySetting(, +        "search.remote.",, +        "proxy",, +        key -> Setting.simpleString(key, s -> {, +            if (Strings.hasLength(s)) {, +                parsePort(s);, +            }, +            return s;, +        }, Setting.Property.NodeScope, Setting.Property.Dynamic), REMOTE_CLUSTERS_SEEDS);, +, +, +    /**, +     * Builds the dynamic per-cluster config from the given settings. This is a map keyed by the cluster alias that points to a tuple, +     * (ProxyAddresss, [SeedNodeSuppliers]). If a cluster is configured with a proxy address all seed nodes will point to, +     * {@link TransportAddress#META_ADDRESS} and their configured address will be used as the hostname for the generated discovery node., +     */, +    protected static Map<String, Tuple<String, List<Supplier<DiscoveryNode>>>> buildRemoteClustersDynamicConfig(Settings settings) {, +                final boolean proxyMode = REMOTE_CLUSTERS_PROXY.getConcreteSettingForNamespace(clusterName).exists(settings);]