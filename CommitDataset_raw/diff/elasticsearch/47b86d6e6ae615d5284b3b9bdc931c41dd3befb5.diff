[+++ b/x-pack/plugin/ccr/qa/multi-cluster-with-non-compliant-license/src/test/java/org/elasticsearch/xpack/ccr/CcrMultiClusterLicenseIT.java, +                            "failure occurred while fetching cluster state in leader cluster \\[leader_cluster\\]")) {, +++ b/x-pack/plugin/ccr/qa/multi-cluster-with-non-compliant-license/src/test/java/org/elasticsearch/xpack/ccr/CcrMultiClusterLicenseIT.java, +                            "failure occurred while fetching cluster state in leader cluster \\[leader_cluster\\]")) {, +++ b/x-pack/plugin/ccr/src/main/java/org/elasticsearch/xpack/ccr/CcrLicenseChecker.java, +    public CcrLicenseChecker(final BooleanSupplier isCcrAllowed) {, +++ b/x-pack/plugin/ccr/qa/multi-cluster-with-non-compliant-license/src/test/java/org/elasticsearch/xpack/ccr/CcrMultiClusterLicenseIT.java, +                            "failure occurred while fetching cluster state in leader cluster \\[leader_cluster\\]")) {, +++ b/x-pack/plugin/ccr/src/main/java/org/elasticsearch/xpack/ccr/CcrLicenseChecker.java, +    public CcrLicenseChecker(final BooleanSupplier isCcrAllowed) {, +++ b/x-pack/plugin/ccr/src/main/java/org/elasticsearch/xpack/ccr/action/AutoFollowCoordinator.java, +import org.apache.logging.log4j.message.ParameterizedMessage;, +import org.elasticsearch.ElasticsearchException;, +import org.elasticsearch.common.collect.Tuple;, +import org.elasticsearch.common.util.concurrent.AtomicArray;, +import org.elasticsearch.xpack.core.ccr.AutoFollowStats;, +import java.util.Collections;, +import java.util.LinkedHashMap;, +import java.util.TreeMap;, +    private static final int MAX_AUTO_FOLLOW_ERRORS = 256;, +    // The following fields are read and updated under a lock:, +    private long numberOfSuccessfulIndicesAutoFollowed = 0;, +    private long numberOfFailedIndicesAutoFollowed = 0;, +    private long numberOfFailedRemoteClusterStateRequests = 0;, +    private final LinkedHashMap<String, ElasticsearchException> recentAutoFollowErrors;, +, +, +        this.recentAutoFollowErrors = new LinkedHashMap<String, ElasticsearchException>() {, +            @Override, +            protected boolean removeEldestEntry(final Map.Entry<String, ElasticsearchException> eldest) {, +                return size() > MAX_AUTO_FOLLOW_ERRORS;, +            }, +        };, +    }, +, +    public synchronized AutoFollowStats getStats() {, +        return new AutoFollowStats(, +            numberOfFailedIndicesAutoFollowed,, +            numberOfFailedRemoteClusterStateRequests,, +            numberOfSuccessfulIndicesAutoFollowed,, +            new TreeMap<>(recentAutoFollowErrors), +        );, +    }, +, +    synchronized void updateStats(List<AutoFollowResult> results) {, +        for (AutoFollowResult result : results) {, +            if (result.clusterStateFetchException != null) {, +                recentAutoFollowErrors.put(result.clusterAlias,, +                    new ElasticsearchException(result.clusterStateFetchException));, +                numberOfFailedRemoteClusterStateRequests++;, +                LOGGER.warn(new ParameterizedMessage("failure occurred while fetching cluster state in leader cluster [{}]",, +                    result.clusterAlias), result.clusterStateFetchException);, +            } else {, +                for (Map.Entry<Index, Exception> entry : result.autoFollowExecutionResults.entrySet()) {, +                    if (entry.getValue() != null) {, +                        numberOfFailedIndicesAutoFollowed++;, +                        recentAutoFollowErrors.put(result.clusterAlias + ":" + entry.getKey().getName(),, +                            new ElasticsearchException(entry.getValue()));, +                        LOGGER.warn(new ParameterizedMessage("failure occurred while auto following index [{}] in leader cluster [{}]",, +                            entry.getKey(), result.clusterAlias), entry.getValue());, +                    } else {, +                        numberOfSuccessfulIndicesAutoFollowed++;, +                    }, +                }, +            }, +, +        }, +        Consumer<List<AutoFollowResult>> handler = results -> {, +            updateStats(results);, +        private final Consumer<List<AutoFollowResult>> handler;, +        private final AtomicArray<AutoFollowResult> autoFollowResults;, +        AutoFollower(final Consumer<List<AutoFollowResult>> handler, final ClusterState followerClusterState) {, +            this.autoFollowResults = new AtomicArray<>(autoFollowMetadata.getPatterns().size());, +            int i = 0;, +                final int slot = i;, +                final String clusterAlias = entry.getKey();, +                final AutoFollowPattern autoFollowPattern = entry.getValue();, +                        final List<String> followedIndices = autoFollowMetadata.getFollowedLeaderIndexUUIDs().get(clusterAlias);, +                        final List<Index> leaderIndicesToFollow =, +                            getLeaderIndicesToFollow(autoFollowPattern, leaderClusterState, followerClusterState, followedIndices);, +                        if (leaderIndicesToFollow.isEmpty()) {, +                            finalise(slot, new AutoFollowResult(clusterAlias));, +                            Consumer<AutoFollowResult> resultHandler = result -> finalise(slot, result);, +                            checkAutoFollowPattern(clusterAlias, autoFollowPattern, leaderIndicesToFollow, resultHandler);, +                        }, +                    } else {, +                        finalise(slot, new AutoFollowResult(clusterAlias, e));, +                    }, +                });, +                i++;, +            }, +        }, +, +        private void checkAutoFollowPattern(String clusterAlias, AutoFollowPattern autoFollowPattern,, +                                            List<Index> leaderIndicesToFollow, Consumer<AutoFollowResult> resultHandler) {, +, +            final CountDown leaderIndicesCountDown = new CountDown(leaderIndicesToFollow.size());, +            final AtomicArray<Tuple<Index, Exception>> results = new AtomicArray<>(leaderIndicesToFollow.size());, +            for (int i = 0; i < leaderIndicesToFollow.size(); i++) {, +                final Index indexToFollow = leaderIndicesToFollow.get(i);]