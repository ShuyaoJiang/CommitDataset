[+++ b/src/main/java/org/elasticsearch/cluster/metadata/IndexMetaData.java, +import org.elasticsearch.ElasticSearchIllegalArgumentException;, +import java.util.HashMap;, +    public interface Custom {, +, +        interface Factory<T extends Custom> {, +, +            String type();, +, +            T readFrom(StreamInput in) throws IOException;, +, +            void writeTo(T customIndexMetaData, StreamOutput out) throws IOException;, +, +            T fromXContent(XContentParser parser) throws IOException;, +, +            void toXContent(T customIndexMetaData, XContentBuilder builder, ToXContent.Params params);, +        }, +    }, +, +    public static Map<String, Custom.Factory> customFactories = new HashMap<String, Custom.Factory>();, +, +    /**, +     * Register a custom index meta data factory. Make sure to call it from a static block., +     */, +    public static void registerFactory(String type, Custom.Factory factory) {, +        customFactories.put(type, factory);, +    }, +, +    @Nullable, +    public static <T extends Custom> Custom.Factory<T> lookupFactory(String type) {, +        return customFactories.get(type);, +    }, +, +    public static <T extends Custom> Custom.Factory<T> lookupFactorySafe(String type) throws ElasticSearchIllegalArgumentException {, +        Custom.Factory<T> factory = customFactories.get(type);, +        if (factory == null) {, +            throw new ElasticSearchIllegalArgumentException("No custom index metadata factoy registered for type [" + type + "]");, +        }, +        return factory;, +    }, +, +    private final ImmutableMap<String, Custom> customs;, +, +    private IndexMetaData(String index, long version, State state, Settings settings, ImmutableMap<String, MappingMetaData> mappings, ImmutableMap<String, AliasMetaData> aliases, ImmutableMap<String, Custom> customs) {, +        this.customs = customs;, +    public ImmutableMap<String, Custom> customs() {, +        return this.customs;, +    }, +, +    public ImmutableMap<String, Custom> getCustoms() {, +        return this.customs;, +    }, +, +        private MapBuilder<String, Custom> customs = MapBuilder.newMapBuilder();, +, +            customs.putAll(indexMetaData.customs);, +        public Builder putCustom(String type, Custom customIndexMetaData) {, +            this.customs.put(type, customIndexMetaData);, +            return this;, +        }, +, +        public Builder removeCustom(String type) {, +            this.customs.remove(type);, +            return this;, +        }, +, +        public Custom getCustom(String type) {, +            return this.customs.get(type);, +        }, +, +            return new IndexMetaData(index, version, state, tmpSettings, mappings.immutableMap(), tmpAliases.immutableMap(), customs.immutableMap());, +            for (Map.Entry<String, Custom> entry : indexMetaData.customs().entrySet()) {, +                builder.startObject(entry.getKey());, +                lookupFactorySafe(entry.getKey()).toXContent(entry.getValue(), builder, params);, +                builder.endObject();, +            }, +, +                    } else {, +                        // check if its a custom index metadata, +                        Custom.Factory<Custom> factory = lookupFactory(currentFieldName);, +                        if (factory == null) {, +                            //TODO warn, +                            parser.skipChildren();, +                        } else {, +                            builder.putCustom(factory.type(), factory.fromXContent(parser));, +                        }, +            int customSize = in.readVInt();, +            for (int i = 0; i < customSize; i++) {, +                String type = in.readUTF();, +                Custom customIndexMetaData = lookupFactorySafe(type).readFrom(in);, +                builder.putCustom(type, customIndexMetaData);, +            }, +            out.writeVInt(indexMetaData.customs().size());, +            for (Map.Entry<String, Custom> entry : indexMetaData.customs().entrySet()) {, +                out.writeUTF(entry.getKey());, +                lookupFactorySafe(entry.getKey()).writeTo(entry.getValue(), out);, +            }, +++ b/src/main/java/org/elasticsearch/cluster/metadata/IndexMetaData.java, +import org.elasticsearch.ElasticSearchIllegalArgumentException;, +import java.util.HashMap;]