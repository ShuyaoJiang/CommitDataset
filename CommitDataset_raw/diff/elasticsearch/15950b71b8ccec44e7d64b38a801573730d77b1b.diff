[+++ b/core/src/main/java/org/elasticsearch/cluster/routing/allocation/allocator/BalancedShardsAllocator.java, +        Setting.floatSetting("cluster.routing.allocation.balance.index", 0.55f, 0.0f, Property.Dynamic, Property.NodeScope);, +        Setting.floatSetting("cluster.routing.allocation.balance.shard", 0.45f, 0.0f, Property.Dynamic, Property.NodeScope);, +        private final Map<String, ModelNode> nodes;, +        private final NodeSorter sorter;, +            nodes = Collections.unmodifiableMap(buildModelFromAssigned());, +            sorter = newNodeSorter();, +            buildWeightOrderedIndices();, +         * shards only if the delta exceeds the threshold. In the default case, +            for (String index : buildWeightOrderedIndices()) {, +                // find nodes that have a shard of this index or where shards of this index are allowed to be allocated to,, +         * with 3 primary and 1 replica shards. At the first stage all three nodes hold, +         * 2 shard for each index. Now we add another node and the first index, +         * is balanced moving three shards from two of the nodes over to the new node since it, +        private String[] buildWeightOrderedIndices() {, +                        moveShard(shardRouting, sourceNode, routingNode);, +        private void moveShard(ShardRouting shardRouting, ModelNode sourceNode, RoutingNode routingNode) {, +        private Map<String, ModelNode> buildModelFromAssigned() {, +            Map<String, ModelNode> nodes = new HashMap<>();, +            return nodes;, +                    Tuple<Decision, ModelNode> allocationDecision = allocateUnassignedShard(shard, throttledNodes);, +                    final Decision decision = allocationDecision.v1();, +                    final ModelNode minNode = allocationDecision.v2();, +, +                    if (decision.type() == Type.YES) {, +                        if (logger.isTraceEnabled()) {, +                            logger.trace("Assigned shard [{}] to [{}]", shard, minNode.getNodeId());, +, +                        final long shardSize = DiskThresholdDecider.getExpectedShardSize(shard, allocation,, +                            ShardRouting.UNAVAILABLE_EXPECTED_SHARD_SIZE);, +                        shard = routingNodes.initializeShard(shard, minNode.getNodeId(), null, shardSize, allocation.changes());, +                        minNode.addShard(shard);, +                        if (!shard.primary()) {, +                            // copy over the same replica shards to the secondary array so they will get allocated, +                            // in a subsequent iteration, allowing replicas of other shards to be allocated first, +                    } else {, +                        // did *not* receive a YES decision, +                        if (logger.isTraceEnabled()) {, +                            logger.trace("No eligible node found to assign shard [{}] decision [{}]", shard, decision.type());, +, +                        if (minNode != null) {, +                            // throttle decision scenario, +                            assert decision.type() == Type.THROTTLE;, +                            final long shardSize = DiskThresholdDecider.getExpectedShardSize(shard, allocation,, +                                ShardRouting.UNAVAILABLE_EXPECTED_SHARD_SIZE);, +                            minNode.addShard(shard.initialize(minNode.getNodeId(), null, shardSize));, +                            final RoutingNode node = minNode.getRoutingNode();, +                            final Decision.Type nodeLevelDecision = deciders.canAllocate(node, allocation).type();, +                            if (nodeLevelDecision != Type.YES) {, +                                if (logger.isTraceEnabled()) {, +                                    logger.trace("Can not allocate on node [{}] remove from round decision [{}]", node, decision.type());, +                                }, +                                assert nodeLevelDecision == Type.NO;, +                                throttledNodes.add(minNode);, +                            }, +                        } else {, +                            assert decision.type() == Type.NO;, +                            if (logger.isTraceEnabled()) {, +                                logger.trace("No Node found to assign shard [{}]", shard);, +                            }, +                        }, +, +                        UnassignedInfo.AllocationStatus allocationStatus = UnassignedInfo.AllocationStatus.fromDecision(decision);, +                        unassigned.ignoreShard(shard, allocationStatus, allocation.changes());, +                        if (!shard.primary()) { // we could not allocate it and we are a replica - check if we can ignore the other replicas, +                            while(i < primaryLength-1 && comparator.compare(primary[i], primary[i+1]) == 0) {, +                                unassigned.ignoreShard(primary[++i], allocationStatus, allocation.changes());, +                            }, +                        }, +                    }, +                }, +                primaryLength = secondaryLength;, +                ShardRouting[] tmp = primary;, +                primary = secondary;, +                secondary = tmp;, +                secondaryLength = 0;, +            } while (primaryLength > 0);, +            // clear everything we have either added it or moved to ignoreUnassigned, +        }, +, +        /**, +         * Make a decision for allocating an unassigned shard.  This method returns a two values in a tuple: the, +         * first value is the {@link Decision} taken to allocate the unassigned shard, the second value is the, +         * {@link ModelNode} representing the node that the shard should be assigned to.  If the decision returned, +         * is of type {@link Type#NO}, then the assigned node will be null., +         */, +        private Tuple<Decision, ModelNode> allocateUnassignedShard(final ShardRouting shard, final Set<ModelNode> throttledNodes) {, +            assert !shard.assignedToNode() : "not an unassigned shard: " + shard;, +            if (allocation.deciders().canAllocate(shard, allocation).type() == Type.NO) {, +                // NO decision for allocating the shard, irrespective of any particular node, so exit early, +                return Tuple.tuple(Decision.NO, null);, +            }, +, +                            Decision currentDecision = allocation.deciders().canAllocate(shard, node.getRoutingNode(), allocation);, +                                final boolean updateMinNode;, +                                        updateMinNode = ((((nodeHigh > repId && minNodeHigh > repId), +                                                               || (nodeHigh < repId && minNodeHigh < repId)), +                                                              && (nodeHigh < minNodeHigh)), +                                                             || (nodeHigh > minNodeHigh && nodeHigh > repId && minNodeHigh < repId));, +                                        updateMinNode = currentDecision.type() == Type.YES;]