[+++ b/docs/reference/indices/flush.asciidoc, +                     "min_retained_seq_no" : "0", +++ b/docs/reference/indices/flush.asciidoc, +                     "min_retained_seq_no" : "0", +++ b/server/src/main/java/org/elasticsearch/index/engine/Engine.java, +++ b/docs/reference/indices/flush.asciidoc, +                     "min_retained_seq_no" : "0", +++ b/server/src/main/java/org/elasticsearch/index/engine/Engine.java, +++ b/server/src/main/java/org/elasticsearch/index/engine/InternalEngine.java, +                    commitData.put(Engine.MIN_RETAINED_SEQNO, Long.toString(softDeletesPolicy.getMinRetainedSeqNo()));, +++ b/docs/reference/indices/flush.asciidoc, +                     "min_retained_seq_no" : "0", +++ b/server/src/main/java/org/elasticsearch/index/engine/Engine.java, +++ b/server/src/main/java/org/elasticsearch/index/engine/InternalEngine.java, +                    commitData.put(Engine.MIN_RETAINED_SEQNO, Long.toString(softDeletesPolicy.getMinRetainedSeqNo()));, +++ b/server/src/main/java/org/elasticsearch/index/engine/SoftDeletesPolicy.java, +        return minRetainedSeqNo;, +++ b/docs/reference/indices/flush.asciidoc, +                     "min_retained_seq_no" : "0", +++ b/server/src/main/java/org/elasticsearch/index/engine/Engine.java, +++ b/server/src/main/java/org/elasticsearch/index/engine/InternalEngine.java, +                    commitData.put(Engine.MIN_RETAINED_SEQNO, Long.toString(softDeletesPolicy.getMinRetainedSeqNo()));, +++ b/server/src/main/java/org/elasticsearch/index/engine/SoftDeletesPolicy.java, +        return minRetainedSeqNo;, +++ b/server/src/main/java/org/elasticsearch/index/seqno/ReplicationTracker.java, +import org.elasticsearch.common.xcontent.NamedXContentRegistry;, +import org.elasticsearch.gateway.WriteStateException;, +import java.nio.file.Path;, +    /**, +     * Loads the latest retention leases from their dedicated state file., +     *, +     * @param path the path to the directory containing the state file, +     * @return the retention leases, +     * @throws IOException if an I/O exception occurs reading the retention leases, +     */, +    public RetentionLeases loadRetentionLeases(final Path path) throws IOException {, +        final RetentionLeases retentionLeases = RetentionLeases.FORMAT.loadLatestState(logger, NamedXContentRegistry.EMPTY, path);, +        if (retentionLeases == null) {, +            return RetentionLeases.EMPTY;, +        }, +        return retentionLeases;, +    }, +, +    private final Object retentionLeasePersistenceLock = new Object();, +, +    /**, +     * Persists the current retention leases to their dedicated state file., +     *, +     * @param path the path to the directory containing the state file, +     * @throws WriteStateException if an exception occurs writing the state file, +     */, +    public void persistRetentionLeases(final Path path) throws WriteStateException {, +        synchronized (retentionLeasePersistenceLock) {, +            final RetentionLeases currentRetentionLeases;, +            synchronized (this) {, +                currentRetentionLeases = retentionLeases;, +            }, +            logger.trace("persisting retention leases [{}]", currentRetentionLeases);, +            RetentionLeases.FORMAT.writeAndCleanup(currentRetentionLeases, path);, +        }, +    }, +, +++ b/docs/reference/indices/flush.asciidoc, +                     "min_retained_seq_no" : "0", +++ b/server/src/main/java/org/elasticsearch/index/engine/Engine.java, +++ b/server/src/main/java/org/elasticsearch/index/engine/InternalEngine.java, +                    commitData.put(Engine.MIN_RETAINED_SEQNO, Long.toString(softDeletesPolicy.getMinRetainedSeqNo()));, +++ b/server/src/main/java/org/elasticsearch/index/engine/SoftDeletesPolicy.java, +        return minRetainedSeqNo;, +++ b/server/src/main/java/org/elasticsearch/index/seqno/ReplicationTracker.java, +import org.elasticsearch.common.xcontent.NamedXContentRegistry;, +import org.elasticsearch.gateway.WriteStateException;, +import java.nio.file.Path;, +    /**, +     * Loads the latest retention leases from their dedicated state file., +     *, +     * @param path the path to the directory containing the state file, +     * @return the retention leases, +     * @throws IOException if an I/O exception occurs reading the retention leases, +     */, +    public RetentionLeases loadRetentionLeases(final Path path) throws IOException {, +        final RetentionLeases retentionLeases = RetentionLeases.FORMAT.loadLatestState(logger, NamedXContentRegistry.EMPTY, path);, +        if (retentionLeases == null) {, +            return RetentionLeases.EMPTY;, +        }, +        return retentionLeases;, +    }, +, +    private final Object retentionLeasePersistenceLock = new Object();, +, +    /**, +     * Persists the current retention leases to their dedicated state file., +     *, +     * @param path the path to the directory containing the state file, +     * @throws WriteStateException if an exception occurs writing the state file, +     */, +    public void persistRetentionLeases(final Path path) throws WriteStateException {, +        synchronized (retentionLeasePersistenceLock) {, +            final RetentionLeases currentRetentionLeases;, +            synchronized (this) {]