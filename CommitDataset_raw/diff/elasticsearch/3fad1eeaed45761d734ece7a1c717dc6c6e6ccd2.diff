[+++ b/server/src/main/java/org/elasticsearch/cluster/coordination/JoinTaskExecutor.java, +import org.elasticsearch.persistent.PersistentTasksCustomMetaData;, +        tmpState = PersistentTasksCustomMetaData.deassociateDeadNodes(tmpState);, +++ b/server/src/main/java/org/elasticsearch/cluster/coordination/JoinTaskExecutor.java, +import org.elasticsearch.persistent.PersistentTasksCustomMetaData;, +        tmpState = PersistentTasksCustomMetaData.deassociateDeadNodes(tmpState);, +++ b/server/src/main/java/org/elasticsearch/cluster/coordination/NodeRemovalClusterStateTaskExecutor.java, +import org.elasticsearch.persistent.PersistentTasksCustomMetaData;, +        ClusterState ptasksDeassociatedState = PersistentTasksCustomMetaData.deassociateDeadNodes(remainingNodesClusterState);, +        return resultBuilder.build(allocationService.deassociateDeadNodes(ptasksDeassociatedState, true, describeTasks(tasks)));, +++ b/server/src/main/java/org/elasticsearch/cluster/coordination/JoinTaskExecutor.java, +import org.elasticsearch.persistent.PersistentTasksCustomMetaData;, +        tmpState = PersistentTasksCustomMetaData.deassociateDeadNodes(tmpState);, +++ b/server/src/main/java/org/elasticsearch/cluster/coordination/NodeRemovalClusterStateTaskExecutor.java, +import org.elasticsearch.persistent.PersistentTasksCustomMetaData;, +        ClusterState ptasksDeassociatedState = PersistentTasksCustomMetaData.deassociateDeadNodes(remainingNodesClusterState);, +        return resultBuilder.build(allocationService.deassociateDeadNodes(ptasksDeassociatedState, true, describeTasks(tasks)));, +++ b/server/src/main/java/org/elasticsearch/cluster/routing/allocation/AllocationService.java, +++ b/server/src/main/java/org/elasticsearch/cluster/coordination/JoinTaskExecutor.java, +import org.elasticsearch.persistent.PersistentTasksCustomMetaData;, +        tmpState = PersistentTasksCustomMetaData.deassociateDeadNodes(tmpState);, +++ b/server/src/main/java/org/elasticsearch/cluster/coordination/NodeRemovalClusterStateTaskExecutor.java, +import org.elasticsearch.persistent.PersistentTasksCustomMetaData;, +        ClusterState ptasksDeassociatedState = PersistentTasksCustomMetaData.deassociateDeadNodes(remainingNodesClusterState);, +        return resultBuilder.build(allocationService.deassociateDeadNodes(ptasksDeassociatedState, true, describeTasks(tasks)));, +++ b/server/src/main/java/org/elasticsearch/cluster/routing/allocation/AllocationService.java, +++ b/server/src/main/java/org/elasticsearch/persistent/PersistentTasksCustomMetaData.java, +    static final Assignment LOST_NODE_ASSIGNMENT = new Assignment(null, "awaiting reassignment after node loss");, +, +    public static PersistentTasksCustomMetaData getPersistentTasksCustomMetaData(ClusterState clusterState) {, +        return clusterState.getMetaData().custom(PersistentTasksCustomMetaData.TYPE);, +    }, +, +    /**, +     * Unassign any persistent tasks executing on nodes that are no longer in, +     * the cluster. If the task's assigment has a non-null executor node and that, +     * node is no longer in the cluster then the assignment is set to, +     * {@link #LOST_NODE_ASSIGNMENT}, +     *, +     * @param clusterState The clusterstate, +     * @return If no changes the argument {@code clusterState} is returned else, +     *          a copy with the modified tasks, +     */, +    public static ClusterState deassociateDeadNodes(ClusterState clusterState) {, +        PersistentTasksCustomMetaData tasks = getPersistentTasksCustomMetaData(clusterState);, +        if (tasks == null) {, +            return clusterState;, +        }, +, +        PersistentTasksCustomMetaData.Builder taskBuilder = PersistentTasksCustomMetaData.builder(tasks);, +        for (PersistentTask<?> task : tasks.tasks()) {, +            if (task.getAssignment().getExecutorNode() != null &&, +                    clusterState.nodes().nodeExists(task.getAssignment().getExecutorNode()) == false) {, +                taskBuilder.reassignTask(task.getId(), LOST_NODE_ASSIGNMENT);, +            }, +        }, +, +        if (taskBuilder.isChanged() == false) {, +            return clusterState;, +        }, +, +        MetaData.Builder metaDataBuilder = MetaData.builder(clusterState.metaData());, +        metaDataBuilder.putCustom(TYPE, taskBuilder.build());, +        return ClusterState.builder(clusterState).metaData(metaDataBuilder).build();, +    }, +, +++ b/server/src/main/java/org/elasticsearch/cluster/coordination/JoinTaskExecutor.java, +import org.elasticsearch.persistent.PersistentTasksCustomMetaData;, +        tmpState = PersistentTasksCustomMetaData.deassociateDeadNodes(tmpState);, +++ b/server/src/main/java/org/elasticsearch/cluster/coordination/NodeRemovalClusterStateTaskExecutor.java, +import org.elasticsearch.persistent.PersistentTasksCustomMetaData;, +        ClusterState ptasksDeassociatedState = PersistentTasksCustomMetaData.deassociateDeadNodes(remainingNodesClusterState);, +        return resultBuilder.build(allocationService.deassociateDeadNodes(ptasksDeassociatedState, true, describeTasks(tasks)));, +++ b/server/src/main/java/org/elasticsearch/cluster/routing/allocation/AllocationService.java, +++ b/server/src/main/java/org/elasticsearch/persistent/PersistentTasksCustomMetaData.java, +    static final Assignment LOST_NODE_ASSIGNMENT = new Assignment(null, "awaiting reassignment after node loss");, +, +    public static PersistentTasksCustomMetaData getPersistentTasksCustomMetaData(ClusterState clusterState) {, +        return clusterState.getMetaData().custom(PersistentTasksCustomMetaData.TYPE);, +    }, +, +    /**, +     * Unassign any persistent tasks executing on nodes that are no longer in, +     * the cluster. If the task's assigment has a non-null executor node and that, +     * node is no longer in the cluster then the assignment is set to, +     * {@link #LOST_NODE_ASSIGNMENT}, +     *, +     * @param clusterState The clusterstate, +     * @return If no changes the argument {@code clusterState} is returned else, +     *          a copy with the modified tasks, +     */, +    public static ClusterState deassociateDeadNodes(ClusterState clusterState) {, +        PersistentTasksCustomMetaData tasks = getPersistentTasksCustomMetaData(clusterState);, +        if (tasks == null) {, +            return clusterState;, +        }, +, +        PersistentTasksCustomMetaData.Builder taskBuilder = PersistentTasksCustomMetaData.builder(tasks);, +        for (PersistentTask<?> task : tasks.tasks()) {, +            if (task.getAssignment().getExecutorNode() != null &&]