[+++ b/core/src/main/java/org/elasticsearch/common/geo/builders/LineStringBuilder.java, +        return Objects.hash(points);, +        return Objects.equals(points, other.points);, +++ b/core/src/main/java/org/elasticsearch/common/geo/builders/LineStringBuilder.java, +        return Objects.hash(points);, +        return Objects.equals(points, other.points);, +++ b/core/src/main/java/org/elasticsearch/common/geo/builders/MultiLineStringBuilder.java, +++ b/core/src/main/java/org/elasticsearch/common/geo/builders/LineStringBuilder.java, +        return Objects.hash(points);, +        return Objects.equals(points, other.points);, +++ b/core/src/main/java/org/elasticsearch/common/geo/builders/MultiLineStringBuilder.java, +++ b/core/src/main/java/org/elasticsearch/common/geo/builders/MultiPointBuilder.java, +        XShapeCollection<Point> multiPoints = new XShapeCollection<>(shapes, SPATIAL_CONTEXT);, +++ b/core/src/main/java/org/elasticsearch/common/geo/builders/LineStringBuilder.java, +        return Objects.hash(points);, +        return Objects.equals(points, other.points);, +++ b/core/src/main/java/org/elasticsearch/common/geo/builders/MultiLineStringBuilder.java, +++ b/core/src/main/java/org/elasticsearch/common/geo/builders/MultiPointBuilder.java, +        XShapeCollection<Point> multiPoints = new XShapeCollection<>(shapes, SPATIAL_CONTEXT);, +++ b/core/src/main/java/org/elasticsearch/common/geo/builders/PolygonBuilder.java, +    /**, +     * Create a connected list of a list of coordinates, +     *, +     * @param points, +     *            array of point, +     * @param offset, +     *            index of the first point, +     * @param length, +     *            number of points, +     * @return Array of edges, +     */, +    private static Edge[] ring(int component, boolean direction, boolean handedness, LineStringBuilder shell,, +                                 Coordinate[] points, int offset, Edge[] edges, int toffset, int length, final AtomicBoolean translated) {, +        // calculate the direction of the points:, +        // find the point a the top of the set and check its, +        // neighbors orientation. So direction is equivalent, +        // to clockwise/counterclockwise, +        final int top = top(points, offset, length);, +        final int prev = (offset + ((top + length - 1) % length));, +        final int next = (offset + ((top + 1) % length));, +        boolean orientation = points[offset + prev].x > points[offset + next].x;, +, +        // OGC requires shell as ccw (Right-Handedness) and holes as cw (Left-Handedness), +        // since GeoJSON doesn't specify (and doesn't need to) GEO core will assume OGC standards, +        // thus if orientation is computed as cw, the logic will translate points across dateline, +        // and convert to a right handed system, +, +        // compute the bounding box and calculate range, +        double[] range = range(points, offset, length);, +        final double rng = range[1] - range[0];, +        // translate the points if the following is true, +        //   1.  shell orientation is cw and range is greater than a hemisphere (180 degrees) but not spanning 2 hemispheres, +        //       (translation would result in a collapsed poly), +        //   2.  the shell of the candidate hole has been translated (to preserve the coordinate system), +        boolean incorrectOrientation = component == 0 && handedness != orientation;, +        if ( (incorrectOrientation && (rng > DATELINE && rng != 2*DATELINE)) || (translated.get() && component != 0)) {, +            translate(points);, +            // flip the translation bit if the shell is being translated, +            if (component == 0) {, +                translated.set(true);, +            }, +            // correct the orientation post translation (ccw for shell, cw for holes), +            if (component == 0 || (component != 0 && handedness == orientation)) {, +                orientation = !orientation;, +            }, +        }, +        return concat(component, direction ^ orientation, points, offset, edges, toffset, length);, +    }, +, +    private static final int top(Coordinate[] points, int offset, int length) {, +        int top = 0; // we start at 1 here since top points to 0, +        for (int i = 1; i < length; i++) {, +            if (points[offset + i].y < points[offset + top].y) {, +                top = i;, +            } else if (points[offset + i].y == points[offset + top].y) {, +                if (points[offset + i].x < points[offset + top].x) {, +                    top = i;, +                }, +            }, +        }, +        return top;, +    }, +, +    private static final double[] range(Coordinate[] points, int offset, int length) {, +        double minX = points[0].x;, +        double maxX = points[0].x;, +        double minY = points[0].y;, +        double maxY = points[0].y;, +        // compute the bounding coordinates (@todo: cleanup brute force), +        for (int i = 1; i < length; ++i) {, +            if (points[offset + i].x < minX) {, +                minX = points[offset + i].x;, +            }, +            if (points[offset + i].x > maxX) {, +                maxX = points[offset + i].x;, +            }, +            if (points[offset + i].y < minY) {, +                minY = points[offset + i].y;, +            }, +            if (points[offset + i].y > maxY) {]