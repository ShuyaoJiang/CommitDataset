[+++ b/buildSrc/src/main/groovy/org/elasticsearch/gradle/precommit/ForbiddenPatternsTask.groovy, +++ b/buildSrc/src/main/groovy/org/elasticsearch/gradle/precommit/ForbiddenPatternsTask.groovy, +++ b/buildSrc/src/main/groovy/org/elasticsearch/gradle/precommit/PrecommitTasks.groovy, +            configureCheckstyle(project),, +, +    private static Task configureCheckstyle(Project project) {, +        Task checkstyleTask = project.tasks.create('checkstyle'), +        // Apply the checkstyle plugin to create `checkstyleMain` and `checkstyleTest`. It only, +        // creates them if there is main or test code to check and it makes `check` depend, +        // on them. But we want `precommit` to depend on `checkstyle` which depends on them so, +        // we have to swap them., +        project.pluginManager.apply('checkstyle'), +        project.checkstyle {, +            config = project.resources.text.fromFile(, +                PrecommitTasks.getResource('/checkstyle.xml'), 'UTF-8'), +        }, +        for (String taskName : ['checkstyleMain', 'checkstyleTest']) {, +            Task task = project.tasks.findByName(taskName), +            if (task != null) {, +                project.tasks['check'].dependsOn.remove(task), +                checkstyleTask.dependsOn(task), +            }, +        }, +        return checkstyleTask, +    }, +++ b/buildSrc/src/main/groovy/org/elasticsearch/gradle/precommit/ForbiddenPatternsTask.groovy, +++ b/buildSrc/src/main/groovy/org/elasticsearch/gradle/precommit/PrecommitTasks.groovy, +            configureCheckstyle(project),, +, +    private static Task configureCheckstyle(Project project) {, +        Task checkstyleTask = project.tasks.create('checkstyle'), +        // Apply the checkstyle plugin to create `checkstyleMain` and `checkstyleTest`. It only, +        // creates them if there is main or test code to check and it makes `check` depend, +        // on them. But we want `precommit` to depend on `checkstyle` which depends on them so, +        // we have to swap them., +        project.pluginManager.apply('checkstyle'), +        project.checkstyle {, +            config = project.resources.text.fromFile(, +                PrecommitTasks.getResource('/checkstyle.xml'), 'UTF-8'), +        }, +        for (String taskName : ['checkstyleMain', 'checkstyleTest']) {, +            Task task = project.tasks.findByName(taskName), +            if (task != null) {, +                project.tasks['check'].dependsOn.remove(task), +                checkstyleTask.dependsOn(task), +            }, +        }, +        return checkstyleTask, +    }, +++ b/buildSrc/src/main/resources/checkstyle.xml, +<?xml version="1.0"?>, +<!DOCTYPE module PUBLIC, +          "-//Puppy Crawl//DTD Check Configuration 1.3//EN", +          "http://www.puppycrawl.com/dtds/configuration_1_3.dtd">, +, +<module name="Checker">, +  <property name="charset" value="UTF-8" />, +, +  <module name="TreeWalker">, +    <!-- ~3500 violations, +    <module name="LineLength">, +      <property name="max" value="140"/>, +    </module>, +    -->, +, +    <module name="AvoidStarImport" />, +    <!-- Doesn't pass but we could make it pass pretty quick., +    <module name="UnusedImports">, +      The next property is optional. If we remove it then imports that are, +      only referenced by Javadoc cause the check to fail., +      <property name="processJavadoc" value="true" />, +    </module>, +    -->, +, +    <!-- Non-inner classes must be in files that match their names. -->, +    <module name="OuterTypeFilename" />, +    <!-- No line wraps inside of import and package statements. -->, +    <module name="NoLineWrap" />, +    <!-- Each java file has only one outer class -->, +    <module name="OneTopLevelClass" />, +    <!-- The suffix L is preferred, because the letter l (ell) is often, +    hard to distinguish from the digit 1 (one). -->, +    <module name="UpperEll"/>, +, +    <!-- We don't use Java's builtin serialization and we suppress all warning, +      about it. The flip side of that coin is that we shouldn't _try_ to use, +      it. We can't outright ban it with ForbiddenApis because it complain about, +      every we reference a class that implements Serializable like String or, +      Exception., +      -->, +    <module name="RegexpSinglelineJava">, +      <property name="format" value="serialVersionUID" />, +      <property name="message" value="Do not declare serialVersionUID." />, +      <property name="ignoreComments" value="true" />, +    </module>, +    <module name="RegexpSinglelineJava">, +      <property name="format" value="java\.io\.Serializable" />, +      <property name="message" value="References java.io.Serializable." />, +      <property name="ignoreComments" value="true" />, +    </module>]