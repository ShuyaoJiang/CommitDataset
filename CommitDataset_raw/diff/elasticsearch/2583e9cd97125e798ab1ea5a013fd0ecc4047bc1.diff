[+++ b/elasticsearch/x-pack/security/src/main/java/org/elasticsearch/xpack/security/authz/accesscontrol/FieldSubsetReader.java, +     * @param negate {@code true} if this should be a negative set, meaning set of field names that is denied., +    public static DirectoryReader wrap(DirectoryReader in, Set<String> fieldNames, boolean negate) throws IOException {, +        return new FieldSubsetDirectoryReader(in, fieldNames, negate);, +        private final boolean negate;, +        FieldSubsetDirectoryReader(DirectoryReader in, Set<String> fieldNames, boolean negate) throws IOException {, +                    return new FieldSubsetReader(reader, fieldNames, negate);, +            this.negate = negate;, +            return new FieldSubsetDirectoryReader(in, fieldNames, negate);, +     * @param fields set of field names that should be allowed, +     * @param negate {@code true} if this should be a negative set, meaning set of field names that is denied., +    FieldSubsetReader(LeafReader in, Set<String> fields, boolean negate) {, +        // look at what fields the reader has, and preprocess a subset of them that are allowed, +            if (fields.contains(fi.name) ^ negate) {, +        fieldNames = new String[filteredInfos.size()];, +        for (int i = 0; i < fieldNames.length; i++) {, +            fieldNames[i] = filteredInfos.get(i).name;, +        }, +++ b/elasticsearch/x-pack/security/src/main/java/org/elasticsearch/xpack/security/authz/accesscontrol/FieldSubsetReader.java, +     * @param negate {@code true} if this should be a negative set, meaning set of field names that is denied., +    public static DirectoryReader wrap(DirectoryReader in, Set<String> fieldNames, boolean negate) throws IOException {, +        return new FieldSubsetDirectoryReader(in, fieldNames, negate);, +        private final boolean negate;, +        FieldSubsetDirectoryReader(DirectoryReader in, Set<String> fieldNames, boolean negate) throws IOException {, +                    return new FieldSubsetReader(reader, fieldNames, negate);, +            this.negate = negate;, +            return new FieldSubsetDirectoryReader(in, fieldNames, negate);, +     * @param fields set of field names that should be allowed, +     * @param negate {@code true} if this should be a negative set, meaning set of field names that is denied., +    FieldSubsetReader(LeafReader in, Set<String> fields, boolean negate) {, +        // look at what fields the reader has, and preprocess a subset of them that are allowed, +            if (fields.contains(fi.name) ^ negate) {, +        fieldNames = new String[filteredInfos.size()];, +        for (int i = 0; i < fieldNames.length; i++) {, +            fieldNames[i] = filteredInfos.get(i).name;, +        }, +++ b/elasticsearch/x-pack/security/src/main/java/org/elasticsearch/xpack/security/authz/accesscontrol/SecurityIndexSearcherWrapper.java, +                // TODO: support 'denied' fields (pass true as the 3rd parameter in this case), +                reader = FieldSubsetReader.wrap(reader, allowedFields, false);, +++ b/elasticsearch/x-pack/security/src/main/java/org/elasticsearch/xpack/security/authz/accesscontrol/FieldSubsetReader.java, +     * @param negate {@code true} if this should be a negative set, meaning set of field names that is denied., +    public static DirectoryReader wrap(DirectoryReader in, Set<String> fieldNames, boolean negate) throws IOException {, +        return new FieldSubsetDirectoryReader(in, fieldNames, negate);, +        private final boolean negate;, +        FieldSubsetDirectoryReader(DirectoryReader in, Set<String> fieldNames, boolean negate) throws IOException {, +                    return new FieldSubsetReader(reader, fieldNames, negate);, +            this.negate = negate;, +            return new FieldSubsetDirectoryReader(in, fieldNames, negate);, +     * @param fields set of field names that should be allowed, +     * @param negate {@code true} if this should be a negative set, meaning set of field names that is denied., +    FieldSubsetReader(LeafReader in, Set<String> fields, boolean negate) {, +        // look at what fields the reader has, and preprocess a subset of them that are allowed, +            if (fields.contains(fi.name) ^ negate) {, +        fieldNames = new String[filteredInfos.size()];, +        for (int i = 0; i < fieldNames.length; i++) {, +            fieldNames[i] = filteredInfos.get(i).name;, +        }, +++ b/elasticsearch/x-pack/security/src/main/java/org/elasticsearch/xpack/security/authz/accesscontrol/SecurityIndexSearcherWrapper.java, +                // TODO: support 'denied' fields (pass true as the 3rd parameter in this case), +                reader = FieldSubsetReader.wrap(reader, allowedFields, false);, +++ b/elasticsearch/x-pack/security/src/test/java/org/elasticsearch/xpack/security/authz/accesscontrol/FieldDataCacheWithFieldSubsetReaderTests.java, +        DirectoryReader ir = FieldSubsetReader.wrap(this.ir, Collections.<String>emptySet(), false);, +        DirectoryReader ir = FieldSubsetReader.wrap(this.ir, Collections.<String>emptySet(), false);, +        DirectoryReader ir = FieldSubsetReader.wrap(this.ir, Collections.<String>emptySet(), false);, +        DirectoryReader ir = FieldSubsetReader.wrap(this.ir, Collections.<String>emptySet(), false);, +++ b/elasticsearch/x-pack/security/src/main/java/org/elasticsearch/xpack/security/authz/accesscontrol/FieldSubsetReader.java, +     * @param negate {@code true} if this should be a negative set, meaning set of field names that is denied., +    public static DirectoryReader wrap(DirectoryReader in, Set<String> fieldNames, boolean negate) throws IOException {, +        return new FieldSubsetDirectoryReader(in, fieldNames, negate);, +        private final boolean negate;, +        FieldSubsetDirectoryReader(DirectoryReader in, Set<String> fieldNames, boolean negate) throws IOException {, +                    return new FieldSubsetReader(reader, fieldNames, negate);, +            this.negate = negate;, +            return new FieldSubsetDirectoryReader(in, fieldNames, negate);, +     * @param fields set of field names that should be allowed, +     * @param negate {@code true} if this should be a negative set, meaning set of field names that is denied., +    FieldSubsetReader(LeafReader in, Set<String> fields, boolean negate) {, +        // look at what fields the reader has, and preprocess a subset of them that are allowed, +            if (fields.contains(fi.name) ^ negate) {, +        fieldNames = new String[filteredInfos.size()];, +        for (int i = 0; i < fieldNames.length; i++) {, +            fieldNames[i] = filteredInfos.get(i).name;, +        }, +++ b/elasticsearch/x-pack/security/src/main/java/org/elasticsearch/xpack/security/authz/accesscontrol/SecurityIndexSearcherWrapper.java, +                // TODO: support 'denied' fields (pass true as the 3rd parameter in this case), +                reader = FieldSubsetReader.wrap(reader, allowedFields, false);, +++ b/elasticsearch/x-pack/security/src/test/java/org/elasticsearch/xpack/security/authz/accesscontrol/FieldDataCacheWithFieldSubsetReaderTests.java, +        DirectoryReader ir = FieldSubsetReader.wrap(this.ir, Collections.<String>emptySet(), false);, +        DirectoryReader ir = FieldSubsetReader.wrap(this.ir, Collections.<String>emptySet(), false);, +        DirectoryReader ir = FieldSubsetReader.wrap(this.ir, Collections.<String>emptySet(), false);, +        DirectoryReader ir = FieldSubsetReader.wrap(this.ir, Collections.<String>emptySet(), false);, +++ b/elasticsearch/x-pack/security/src/test/java/org/elasticsearch/xpack/security/authz/accesscontrol/FieldSubsetReaderTests.java, +        DirectoryReader ir = FieldSubsetReader.wrap(DirectoryReader.open(iw), fields, false);, +        DirectoryReader ir = FieldSubsetReader.wrap(DirectoryReader.open(iw), fields, false);, +        DirectoryReader ir = FieldSubsetReader.wrap(DirectoryReader.open(iw), fields, false);, +        DirectoryReader ir = FieldSubsetReader.wrap(DirectoryReader.open(iw), fields, false);, +        DirectoryReader ir = FieldSubsetReader.wrap(DirectoryReader.open(iw), fields, false);, +        DirectoryReader ir = FieldSubsetReader.wrap(DirectoryReader.open(iw), fields, false);, +        DirectoryReader ir = FieldSubsetReader.wrap(DirectoryReader.open(iw), fields, false);, +        DirectoryReader ir = FieldSubsetReader.wrap(DirectoryReader.open(iw), fields, false);]