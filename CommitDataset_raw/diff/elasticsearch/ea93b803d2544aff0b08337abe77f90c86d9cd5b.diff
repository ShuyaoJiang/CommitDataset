[+++ b/core/src/main/java/org/elasticsearch/index/query/RangeQueryBuilder.java, +    protected QueryBuilder<?> doRewrite(QueryRewriteContext queryRewriteContext) throws IOException {, +        FieldStatsProvider fieldStatsProvider = queryRewriteContext.getFieldStatsProvider();, +                if (from != null || to != null) {, +                    newRangeQuery.from(null);, +                    newRangeQuery.to(null);, +++ b/core/src/main/java/org/elasticsearch/index/query/RangeQueryBuilder.java, +    protected QueryBuilder<?> doRewrite(QueryRewriteContext queryRewriteContext) throws IOException {, +        FieldStatsProvider fieldStatsProvider = queryRewriteContext.getFieldStatsProvider();, +                if (from != null || to != null) {, +                    newRangeQuery.from(null);, +                    newRangeQuery.to(null);, +++ b/core/src/main/java/org/elasticsearch/search/SearchService.java, +        request.rewrite(context.getQueryShardContext());, +        // reset that we have used nowInMillis from the context since it may, +        // have been rewritten so its no longer in the query and the request can, +        // be cached. If it is still present in the request (e.g. in a range, +        // aggregation) it will still be caught when the aggregation is, +        // evaluated., +        context.resetNowInMillisUsed();, +++ b/core/src/main/java/org/elasticsearch/index/query/RangeQueryBuilder.java, +    protected QueryBuilder<?> doRewrite(QueryRewriteContext queryRewriteContext) throws IOException {, +        FieldStatsProvider fieldStatsProvider = queryRewriteContext.getFieldStatsProvider();, +                if (from != null || to != null) {, +                    newRangeQuery.from(null);, +                    newRangeQuery.to(null);, +++ b/core/src/main/java/org/elasticsearch/search/SearchService.java, +        request.rewrite(context.getQueryShardContext());, +        // reset that we have used nowInMillis from the context since it may, +        // have been rewritten so its no longer in the query and the request can, +        // be cached. If it is still present in the request (e.g. in a range, +        // aggregation) it will still be caught when the aggregation is, +        // evaluated., +        context.resetNowInMillisUsed();, +++ b/core/src/main/java/org/elasticsearch/search/internal/SearchContext.java, +    public final void resetNowInMillisUsed() {, +        this.nowInMillisUsed = false;, +    }, +, +++ b/core/src/main/java/org/elasticsearch/index/query/RangeQueryBuilder.java, +    protected QueryBuilder<?> doRewrite(QueryRewriteContext queryRewriteContext) throws IOException {, +        FieldStatsProvider fieldStatsProvider = queryRewriteContext.getFieldStatsProvider();, +                if (from != null || to != null) {, +                    newRangeQuery.from(null);, +                    newRangeQuery.to(null);, +++ b/core/src/main/java/org/elasticsearch/search/SearchService.java, +        request.rewrite(context.getQueryShardContext());, +        // reset that we have used nowInMillis from the context since it may, +        // have been rewritten so its no longer in the query and the request can, +        // be cached. If it is still present in the request (e.g. in a range, +        // aggregation) it will still be caught when the aggregation is, +        // evaluated., +        context.resetNowInMillisUsed();, +++ b/core/src/main/java/org/elasticsearch/search/internal/SearchContext.java, +    public final void resetNowInMillisUsed() {, +        this.nowInMillisUsed = false;, +    }, +, +++ b/core/src/test/java/org/elasticsearch/index/query/RangeQueryBuilderTests.java, +        assertThat(rewrittenRange.from(), equalTo(null));, +        assertThat(rewrittenRange.to(), equalTo(null));, +        assertThat(rewrittenRange.from(), equalTo(null));, +        assertThat(rewrittenRange.to(), equalTo(null));, +        assertThat(rewrittenRange.from(), equalTo(null));, +        assertThat(rewrittenRange.to(), equalTo(null));, +        assertThat(rewrittenRange.from(), equalTo(null));, +        assertThat(rewrittenRange.to(), equalTo(null));, +        assertThat(rewrittenRange.from(), equalTo(null));, +        assertThat(rewrittenRange.to(), equalTo(null));, +    }, +, +    public void testRewriteDateWithNowToMatchAll() throws IOException {, +        String fieldName = randomAsciiOfLengthBetween(1, 20);, +        RangeQueryBuilder query = new RangeQueryBuilder(fieldName);, +        String queryFromValue = "now-2d";, +        String queryToValue = "now";, +        DateTime shardMinValue = new DateTime().minusHours(12);, +        DateTime shardMaxValue = new DateTime().minusHours(24);, +        query.from(queryFromValue);, +        query.to(queryToValue);, +        QueryShardContext queryShardContext = queryShardContext();, +        FieldStatsProvider fieldStatsProvider = new FieldStatsProvider(null, null) {, +, +            @Override, +            public Relation isFieldWithinQuery(String fieldName, Object from, Object to, boolean includeLower, boolean includeUpper,, +                    DateTimeZone timeZone, DateMathParser dateMathParser) throws IOException {, +                return Relation.WITHIN;, +            }, +, +            @SuppressWarnings("unchecked"), +            @Override, +            public <T extends Comparable<T>> FieldStats<T> get(String field) throws IOException {, +                assertThat(field, equalTo(fieldName));, +                return (FieldStats<T>) new FieldStats.Date(randomLong(), randomLong(), randomLong(), randomLong(),, +                        shardMinValue.getMillis(), shardMaxValue.getMillis(), null);, +            }, +        };, +        queryShardContext.setFieldStatsProvider(fieldStatsProvider);, +        QueryBuilder<?> rewritten = query.rewrite(queryShardContext);, +        assertThat(rewritten, instanceOf(RangeQueryBuilder.class));]