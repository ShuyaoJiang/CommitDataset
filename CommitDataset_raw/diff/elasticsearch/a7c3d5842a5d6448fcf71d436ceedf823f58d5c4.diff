[+++ b/benchmarks/build.gradle, +thirdPartyAudit.ignoreViolations (, +), +++ b/benchmarks/build.gradle, +thirdPartyAudit.ignoreViolations (, +), +++ b/buildSrc/src/main/java/org/elasticsearch/gradle/precommit/ThirdPartyAuditTask.java, +import java.util.stream.Stream;, +    private Set<String> missingClassExcludes = new TreeSet<>();, +, +    private Set<String> violationsExcludes = new TreeSet<>();, +, +    private Set<String> jdkJarHellExcludes = new TreeSet<>();, +    public void ignoreMissingClasses(String... classesOrPackages) {, +        if (classesOrPackages.length == 0) {, +            missingClassExcludes = null;, +            return;, +        if (missingClassExcludes == null) {, +            missingClassExcludes = new TreeSet<>();, +        }, +        for (String each : classesOrPackages) {, +            missingClassExcludes.add(each);, +        }, +    }, +, +    public void ignoreViolations(String... violatingClasses) {, +        for (String each : violatingClasses) {, +            violationsExcludes.add(each);, +        }, +    }, +, +    public void ignoreJarHellWithJDK(String ...classes) {, +        for (String each : classes) {, +            jdkJarHellExcludes.add(each);, +    public Set<String> getJdkJarHellExcludes() {, +        return jdkJarHellExcludes;, +    }, +, +    @Input, +    @Optional, +    public Set<String> getMissingClassExcludes() {, +        return missingClassExcludes;, +        if (missingClassExcludes != null) {, +            long bogousExcludesCount = Stream.concat(missingClassExcludes.stream(), violationsExcludes.stream()), +                .filter(each -> missingClasses.contains(each) == false), +                .filter(each -> violationsClasses.contains(each) == false), +                .count();, +            if (bogousExcludesCount != 0 && bogousExcludesCount == missingClassExcludes.size() + violationsExcludes.size()) {, +                logForbiddenAPIsOutput(forbiddenApisOutput);, +                throw new IllegalStateException(, +                    "All excluded classes seem to have no issues. " +, +                        "This is sometimes an indication that the check silently failed", +                );, +            assertNoPointlessExclusions("are not missing", missingClassExcludes, missingClasses);, +            missingClasses.removeAll(missingClassExcludes);, +        }, +        assertNoPointlessExclusions("have no violations", violationsExcludes, violationsClasses);, +        assertNoPointlessExclusions("do not generate jar hell with the JDK", jdkJarHellExcludes, jdkJarHellClasses);, +, +        if (missingClassExcludes == null && (missingClasses.isEmpty() == false)) {, +            getLogger().info(, +                "Found missing classes, but task is configured to ignore all of them:\n {}",, +                formatClassList(missingClasses), +            );, +            missingClasses.clear();, +        }, +, +        violationsClasses.removeAll(violationsExcludes);, +        if (missingClasses.isEmpty() && violationsClasses.isEmpty()) {, +            getLogger().info("Third party audit passed successfully");, +        } else {, +            logForbiddenAPIsOutput(forbiddenApisOutput);, +            if (missingClasses.isEmpty() == false) {, +                getLogger().error("Missing classes:\n{}", formatClassList(missingClasses));, +            }, +            if(violationsClasses.isEmpty() == false) {, +                getLogger().error("Classes with violations:\n{}", formatClassList(violationsClasses));, +            }, +            throw new IllegalStateException("Audit of third party dependencies failed");, +        }, +, +        assertNoJarHell(jdkJarHellClasses);, +    }, +, +    private void logForbiddenAPIsOutput(String forbiddenApisOutput) {, +        getLogger().error("Forbidden APIs output:\n{}==end of forbidden APIs==", forbiddenApisOutput);, +    }, +, +    private void throwNotConfiguredCorrectlyException() {, +        throw new IllegalArgumentException("Audit of third party dependencies is not configured correctly");, +        jdkJarHellClasses.removeAll(jdkJarHellExcludes);, +    private void assertNoPointlessExclusions(String specifics, Set<String> excludes, Set<String> problematic) {, +        String notMissing = excludes.stream(), +            .filter(each -> problematic.contains(each) == false), +            .map(each -> "  * " + each), +            .collect(Collectors.joining("\n"));, +        if (notMissing.isEmpty() == false) {, +            getLogger().error("Unnecessary exclusions, following classes " + specifics + ":\n {}", notMissing);, +            throw new IllegalStateException("Third party audit task is not configured correctly");, +    private String formatClassList(Set<String> classList) {]