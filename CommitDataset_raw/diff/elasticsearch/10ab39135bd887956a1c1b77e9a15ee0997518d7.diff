[+++ b/x-pack/plugin/sql/qa/src/main/resources/docs.csv-spec, +SELECT * FROM (SELECT first_name, last_name FROM emp WHERE last_name NOT LIKE '%a%') WHERE first_name LIKE 'A%' ORDER BY 1;, + Anneke        |Preusig, +limitationSubSelectRewritten, +SELECT first_name, last_name FROM emp WHERE last_name NOT LIKE '%a%' AND first_name LIKE 'A%' ORDER BY 1;, + Anneke        |Preusig, +++ b/x-pack/plugin/sql/qa/src/main/resources/docs.csv-spec, +SELECT * FROM (SELECT first_name, last_name FROM emp WHERE last_name NOT LIKE '%a%') WHERE first_name LIKE 'A%' ORDER BY 1;, + Anneke        |Preusig, +limitationSubSelectRewritten, +SELECT first_name, last_name FROM emp WHERE last_name NOT LIKE '%a%' AND first_name LIKE 'A%' ORDER BY 1;, + Anneke        |Preusig, +++ b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/analysis/analyzer/Verifier.java, +import org.elasticsearch.xpack.sql.type.EsField;, +        return checkGroupByInexactField(p, localFailures), +                && checkGroupByAgg(p, localFailures, resolvedFunctions), +    private static boolean checkGroupByInexactField(LogicalPlan p, Set<Failure> localFailures) {, +        if (p instanceof Aggregate) {, +            Aggregate a = (Aggregate) p;, +, +            // The grouping can not be an aggregate function or an inexact field (e.g. text without a keyword), +            a.groupings().forEach(e -> e.forEachUp(c -> {, +                EsField.Exact exact = c.getExactInfo();, +                if (exact.hasExact() == false) {, +                    localFailures.add(fail(c, "Field of data type [" + c.dataType().typeName + "] cannot be used for grouping; " +, +                        exact.errorMsg()));, +                }, +            }, FieldAttribute.class));, +        }, +        return true;, +    }, +++ b/x-pack/plugin/sql/qa/src/main/resources/docs.csv-spec, +SELECT * FROM (SELECT first_name, last_name FROM emp WHERE last_name NOT LIKE '%a%') WHERE first_name LIKE 'A%' ORDER BY 1;, + Anneke        |Preusig, +limitationSubSelectRewritten, +SELECT first_name, last_name FROM emp WHERE last_name NOT LIKE '%a%' AND first_name LIKE 'A%' ORDER BY 1;, + Anneke        |Preusig, +++ b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/analysis/analyzer/Verifier.java, +import org.elasticsearch.xpack.sql.type.EsField;, +        return checkGroupByInexactField(p, localFailures), +                && checkGroupByAgg(p, localFailures, resolvedFunctions), +    private static boolean checkGroupByInexactField(LogicalPlan p, Set<Failure> localFailures) {, +        if (p instanceof Aggregate) {, +            Aggregate a = (Aggregate) p;, +, +            // The grouping can not be an aggregate function or an inexact field (e.g. text without a keyword), +            a.groupings().forEach(e -> e.forEachUp(c -> {, +                EsField.Exact exact = c.getExactInfo();, +                if (exact.hasExact() == false) {, +                    localFailures.add(fail(c, "Field of data type [" + c.dataType().typeName + "] cannot be used for grouping; " +, +                        exact.errorMsg()));, +                }, +            }, FieldAttribute.class));, +        }, +        return true;, +    }, +++ b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/execution/search/SourceGenerator.java, +    private SourceGenerator() {}, +, +                    FieldAttribute fa = ((FieldAttribute) attr).exactAttribute();, +                            while (nestedSort.getNestedSort() != null) {, +                                nestedSort = nestedSort.getNestedSort();, +++ b/x-pack/plugin/sql/qa/src/main/resources/docs.csv-spec, +SELECT * FROM (SELECT first_name, last_name FROM emp WHERE last_name NOT LIKE '%a%') WHERE first_name LIKE 'A%' ORDER BY 1;, + Anneke        |Preusig, +limitationSubSelectRewritten, +SELECT first_name, last_name FROM emp WHERE last_name NOT LIKE '%a%' AND first_name LIKE 'A%' ORDER BY 1;, + Anneke        |Preusig, +++ b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/analysis/analyzer/Verifier.java, +import org.elasticsearch.xpack.sql.type.EsField;, +        return checkGroupByInexactField(p, localFailures), +                && checkGroupByAgg(p, localFailures, resolvedFunctions), +    private static boolean checkGroupByInexactField(LogicalPlan p, Set<Failure> localFailures) {, +        if (p instanceof Aggregate) {, +            Aggregate a = (Aggregate) p;, +, +            // The grouping can not be an aggregate function or an inexact field (e.g. text without a keyword), +            a.groupings().forEach(e -> e.forEachUp(c -> {, +                EsField.Exact exact = c.getExactInfo();, +                if (exact.hasExact() == false) {, +                    localFailures.add(fail(c, "Field of data type [" + c.dataType().typeName + "] cannot be used for grouping; " +, +                        exact.errorMsg()));, +                }, +            }, FieldAttribute.class));, +        }, +        return true;, +    }, +++ b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/execution/search/SourceGenerator.java, +    private SourceGenerator() {}, +, +                    FieldAttribute fa = ((FieldAttribute) attr).exactAttribute();, +                            while (nestedSort.getNestedSort() != null) {, +                                nestedSort = nestedSort.getNestedSort();, +++ b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/Expressions.java, +++ b/x-pack/plugin/sql/qa/src/main/resources/docs.csv-spec, +SELECT * FROM (SELECT first_name, last_name FROM emp WHERE last_name NOT LIKE '%a%') WHERE first_name LIKE 'A%' ORDER BY 1;, + Anneke        |Preusig, +limitationSubSelectRewritten, +SELECT first_name, last_name FROM emp WHERE last_name NOT LIKE '%a%' AND first_name LIKE 'A%' ORDER BY 1;, + Anneke        |Preusig]