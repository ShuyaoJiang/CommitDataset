[+++ b/server/src/main/java/org/elasticsearch/action/admin/cluster/shards/ClusterSearchShardsResponse.java, +++ b/server/src/main/java/org/elasticsearch/action/admin/cluster/shards/ClusterSearchShardsResponse.java, +++ b/server/src/main/java/org/elasticsearch/action/search/TransportSearchAction.java, +import org.elasticsearch.action.admin.cluster.shards.ClusterSearchShardsRequest;, +import org.elasticsearch.client.Client;, +import org.elasticsearch.common.util.concurrent.CountDown;, +import org.elasticsearch.transport.RemoteTransportException;, +import java.util.concurrent.ConcurrentHashMap;, +import java.util.concurrent.atomic.AtomicInteger;, +import java.util.concurrent.atomic.AtomicReference;, +                AtomicInteger skippedClusters = new AtomicInteger(0);, +                collectSearchShards(searchRequest.indicesOptions(), searchRequest.preference(), searchRequest.routing(), skippedClusters,, +                    remoteClusterIndices, remoteClusterService, threadPool,, +                    ActionListener.wrap(, +                        searchShardsResponses -> {, +                            BiFunction<String, String, DiscoveryNode> clusterNodeLookup = processRemoteShards(, +                                searchShardsResponses, remoteClusterIndices, remoteShardIterators, remoteAliasFilters);, +                            int localClusters = localIndices == null ? 0 : 1;, +                            int totalClusters = remoteClusterIndices.size() + localClusters;, +                            int successfulClusters = searchShardsResponses.size() + localClusters;, +                                new SearchResponse.Clusters(totalClusters, successfulClusters, skippedClusters.get()));, +                        },, +                        listener::onFailure));, +    static void collectSearchShards(IndicesOptions indicesOptions, String preference, String routing, AtomicInteger skippedClusters,, +                                    Map<String, OriginalIndices> remoteIndicesByCluster, RemoteClusterService remoteClusterService,, +                                    ThreadPool threadPool, ActionListener<Map<String, ClusterSearchShardsResponse>> listener) {, +        final CountDown responsesCountDown = new CountDown(remoteIndicesByCluster.size());, +        final Map<String, ClusterSearchShardsResponse> searchShardsResponses = new ConcurrentHashMap<>();, +        final AtomicReference<RemoteTransportException> transportException = new AtomicReference<>();, +        for (Map.Entry<String, OriginalIndices> entry : remoteIndicesByCluster.entrySet()) {, +            final String clusterAlias = entry.getKey();, +            boolean skipUnavailable = remoteClusterService.isSkipUnavailable(clusterAlias);, +            Client clusterClient = remoteClusterService.getRemoteClusterClient(threadPool, clusterAlias);, +            final String[] indices = entry.getValue().indices();, +            ClusterSearchShardsRequest searchShardsRequest = new ClusterSearchShardsRequest(indices), +                .indicesOptions(indicesOptions).local(true).preference(preference).routing(routing);, +            clusterClient.admin().cluster().searchShards(searchShardsRequest, new ActionListener<ClusterSearchShardsResponse>() {, +                    @Override, +                    public void onResponse(ClusterSearchShardsResponse response) {, +                        searchShardsResponses.put(clusterAlias, response);, +                        maybeFinish();, +                    }, +, +                    @Override, +                    public void onFailure(Exception e) {, +                        if (skipUnavailable) {, +                            skippedClusters.incrementAndGet();, +                        } else {, +                            RemoteTransportException exception =, +                                new RemoteTransportException("error while communicating with remote cluster [" + clusterAlias + "]", e);, +                            if (transportException.compareAndSet(null, exception) == false) {, +                                transportException.accumulateAndGet(exception, (previous, current) -> {, +                                    current.addSuppressed(previous);, +                                    return current;, +                                });, +                        maybeFinish();, +                    }, +, +                    private void maybeFinish() {, +                        if (responsesCountDown.countDown()) {, +                            RemoteTransportException exception = transportException.get();, +                            if (exception == null) {, +                                listener.onResponse(searchShardsResponses);, +                            } else {, +                                listener.onFailure(transportException.get());, +                            }, +                        }, +                    }, +                }, +            );, +        }, +++ b/server/src/main/java/org/elasticsearch/action/admin/cluster/shards/ClusterSearchShardsResponse.java, +++ b/server/src/main/java/org/elasticsearch/action/search/TransportSearchAction.java, +import org.elasticsearch.action.admin.cluster.shards.ClusterSearchShardsRequest;, +import org.elasticsearch.client.Client;, +import org.elasticsearch.common.util.concurrent.CountDown;, +import org.elasticsearch.transport.RemoteTransportException;, +import java.util.concurrent.ConcurrentHashMap;, +import java.util.concurrent.atomic.AtomicInteger;, +import java.util.concurrent.atomic.AtomicReference;, +                AtomicInteger skippedClusters = new AtomicInteger(0);, +                collectSearchShards(searchRequest.indicesOptions(), searchRequest.preference(), searchRequest.routing(), skippedClusters,, +                    remoteClusterIndices, remoteClusterService, threadPool,, +                    ActionListener.wrap(, +                        searchShardsResponses -> {, +                            BiFunction<String, String, DiscoveryNode> clusterNodeLookup = processRemoteShards(, +                                searchShardsResponses, remoteClusterIndices, remoteShardIterators, remoteAliasFilters);, +                            int localClusters = localIndices == null ? 0 : 1;, +                            int totalClusters = remoteClusterIndices.size() + localClusters;, +                            int successfulClusters = searchShardsResponses.size() + localClusters;, +                                new SearchResponse.Clusters(totalClusters, successfulClusters, skippedClusters.get()));, +                        },, +                        listener::onFailure));, +    static void collectSearchShards(IndicesOptions indicesOptions, String preference, String routing, AtomicInteger skippedClusters,, +                                    Map<String, OriginalIndices> remoteIndicesByCluster, RemoteClusterService remoteClusterService,, +                                    ThreadPool threadPool, ActionListener<Map<String, ClusterSearchShardsResponse>> listener) {, +        final CountDown responsesCountDown = new CountDown(remoteIndicesByCluster.size());, +        final Map<String, ClusterSearchShardsResponse> searchShardsResponses = new ConcurrentHashMap<>();, +        final AtomicReference<RemoteTransportException> transportException = new AtomicReference<>();, +        for (Map.Entry<String, OriginalIndices> entry : remoteIndicesByCluster.entrySet()) {]