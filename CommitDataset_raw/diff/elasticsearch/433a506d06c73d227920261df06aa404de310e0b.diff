[+++ b/server/src/main/java/org/elasticsearch/snapshots/SnapshotShardsService.java, +                            final IndexShard indexShard = indicesService.indexServiceSafe(shardId.getIndex()).getShardOrNull(shardId.id());, +                            assert indexId != null;, +++ b/server/src/main/java/org/elasticsearch/snapshots/SnapshotShardsService.java, +                            final IndexShard indexShard = indicesService.indexServiceSafe(shardId.getIndex()).getShardOrNull(shardId.id());, +                            assert indexId != null;, +++ b/server/src/test/java/org/elasticsearch/snapshots/DedicatedClusterSnapshotRestoreIT.java, +import org.elasticsearch.test.disruption.BusyMasterServiceDisruption;, +import org.elasticsearch.test.disruption.ServiceDisruptionScheme;, +    public void testDataNodeRestartWithBusyMasterDuringSnapshot() throws Exception {, +        logger.info("-->  starting a master node and two data nodes");, +        internalCluster().startMasterOnlyNode();, +        internalCluster().startDataOnlyNodes(2);, +        logger.info("-->  creating repository");, +        assertAcked(client().admin().cluster().preparePutRepository("test-repo"), +            .setType("mock").setSettings(Settings.builder(), +                .put("location", randomRepoPath()), +                .put("compress", randomBoolean()), +                .put("max_snapshot_bytes_per_sec", "1000b"), +                .put("chunk_size", randomIntBetween(100, 1000), ByteSizeUnit.BYTES)));, +        assertAcked(prepareCreate("test-idx", 0, Settings.builder(), +            .put("number_of_shards", 5).put("number_of_replicas", 0)));, +        ensureGreen();, +        logger.info("-->  indexing some data");, +        final int numdocs = randomIntBetween(50, 100);, +        IndexRequestBuilder[] builders = new IndexRequestBuilder[numdocs];, +        for (int i = 0; i < builders.length; i++) {, +            builders[i] = client().prepareIndex("test-idx", "type1",, +                Integer.toString(i)).setSource("field1", "bar " + i);, +        }, +        indexRandom(true, builders);, +        flushAndRefresh();, +        final String dataNode = blockNodeWithIndex("test-repo", "test-idx");, +        logger.info("-->  snapshot");, +        client(internalCluster().getMasterName()).admin().cluster(), +            .prepareCreateSnapshot("test-repo", "test-snap").setWaitForCompletion(false).setIndices("test-idx").get();, +        ServiceDisruptionScheme disruption = new BusyMasterServiceDisruption(random(), Priority.HIGH);, +        setDisruptionScheme(disruption);, +        disruption.startDisrupting();, +        logger.info("-->  restarting data node, which should cause primary shards to be failed");, +        internalCluster().restartNode(dataNode, InternalTestCluster.EMPTY_CALLBACK);, +        unblockNode("test-repo", dataNode);, +        disruption.stopDisrupting();, +        // check that snapshot completes, +        assertBusy(() -> {, +            GetSnapshotsResponse snapshotsStatusResponse = client().admin().cluster(), +                .prepareGetSnapshots("test-repo").setSnapshots("test-snap").setIgnoreUnavailable(true).get();, +            assertEquals(1, snapshotsStatusResponse.getSnapshots().size());, +            SnapshotInfo snapshotInfo = snapshotsStatusResponse.getSnapshots().get(0);, +            assertTrue(snapshotInfo.state().toString(), snapshotInfo.state().completed());, +        }, 30, TimeUnit.SECONDS);, +    }, +, +++ b/server/src/main/java/org/elasticsearch/snapshots/SnapshotShardsService.java, +                            final IndexShard indexShard = indicesService.indexServiceSafe(shardId.getIndex()).getShardOrNull(shardId.id());, +                            assert indexId != null;, +++ b/server/src/test/java/org/elasticsearch/snapshots/DedicatedClusterSnapshotRestoreIT.java, +import org.elasticsearch.test.disruption.BusyMasterServiceDisruption;, +import org.elasticsearch.test.disruption.ServiceDisruptionScheme;, +    public void testDataNodeRestartWithBusyMasterDuringSnapshot() throws Exception {, +        logger.info("-->  starting a master node and two data nodes");, +        internalCluster().startMasterOnlyNode();, +        internalCluster().startDataOnlyNodes(2);, +        logger.info("-->  creating repository");, +        assertAcked(client().admin().cluster().preparePutRepository("test-repo"), +            .setType("mock").setSettings(Settings.builder(), +                .put("location", randomRepoPath()), +                .put("compress", randomBoolean()), +                .put("max_snapshot_bytes_per_sec", "1000b"), +                .put("chunk_size", randomIntBetween(100, 1000), ByteSizeUnit.BYTES)));, +        assertAcked(prepareCreate("test-idx", 0, Settings.builder(), +            .put("number_of_shards", 5).put("number_of_replicas", 0)));, +        ensureGreen();, +        logger.info("-->  indexing some data");, +        final int numdocs = randomIntBetween(50, 100);, +        IndexRequestBuilder[] builders = new IndexRequestBuilder[numdocs];, +        for (int i = 0; i < builders.length; i++) {, +            builders[i] = client().prepareIndex("test-idx", "type1",, +                Integer.toString(i)).setSource("field1", "bar " + i);, +        }, +        indexRandom(true, builders);, +        flushAndRefresh();, +        final String dataNode = blockNodeWithIndex("test-repo", "test-idx");, +        logger.info("-->  snapshot");, +        client(internalCluster().getMasterName()).admin().cluster(), +            .prepareCreateSnapshot("test-repo", "test-snap").setWaitForCompletion(false).setIndices("test-idx").get();, +        ServiceDisruptionScheme disruption = new BusyMasterServiceDisruption(random(), Priority.HIGH);, +        setDisruptionScheme(disruption);, +        disruption.startDisrupting();, +        logger.info("-->  restarting data node, which should cause primary shards to be failed");, +        internalCluster().restartNode(dataNode, InternalTestCluster.EMPTY_CALLBACK);, +        unblockNode("test-repo", dataNode);, +        disruption.stopDisrupting();, +        // check that snapshot completes, +        assertBusy(() -> {, +            GetSnapshotsResponse snapshotsStatusResponse = client().admin().cluster(), +                .prepareGetSnapshots("test-repo").setSnapshots("test-snap").setIgnoreUnavailable(true).get();, +            assertEquals(1, snapshotsStatusResponse.getSnapshots().size());, +            SnapshotInfo snapshotInfo = snapshotsStatusResponse.getSnapshots().get(0);, +            assertTrue(snapshotInfo.state().toString(), snapshotInfo.state().completed());]