[+++ b/x-pack/plugin/watcher/src/main/java/org/elasticsearch/xpack/watcher/trigger/schedule/Schedule.java, +/**, + * This interface is used to implement watcher specific schedules, the existing implementations are either, + * based on a cron based or an interval based schedule, + *, + * In addition to the methods defined here, you also have to implement the equals() method to properly work, + * for the trigger engine implementations., + */, +++ b/x-pack/plugin/watcher/src/main/java/org/elasticsearch/xpack/watcher/trigger/schedule/Schedule.java, +/**, + * This interface is used to implement watcher specific schedules, the existing implementations are either, + * based on a cron based or an interval based schedule, + *, + * In addition to the methods defined here, you also have to implement the equals() method to properly work, + * for the trigger engine implementations., + */, +++ b/x-pack/plugin/watcher/src/main/java/org/elasticsearch/xpack/watcher/trigger/schedule/engine/TickerScheduleTriggerEngine.java, +import java.util.Collections;, +    private final Map<String, ActiveSchedule> schedules = new ConcurrentHashMap<>();, +    private final Ticker ticker;, +        Map<String, ActiveSchedule> startingSchedules = new HashMap<>(jobs.size());, +                startingSchedules.put(job.id(), new ActiveSchedule(job.id(), trigger.getSchedule(), startTime));, +        this.schedules.putAll(startingSchedules);, +        ActiveSchedule currentSchedule = schedules.get(watch.id());, +        // only update the schedules data structure if the scheduled trigger really has changed, otherwise the time would be reset again, +        // resulting in later executions, as the time would only count after a watch has been stored, as this code is triggered by the, +        // watcher indexing listener, +        // this also means that updating an existing watch would not retrigger the schedule time, if it remains the same schedule, +        if (currentSchedule == null || currentSchedule.schedule.equals(trigger.getSchedule()) == false) {, +    }, +                DateTime triggeredDateTime = new DateTime(triggeredTime, UTC);, +                DateTime scheduledDateTime = new DateTime(scheduledTime, UTC);, +                logger.debug("triggered job [{}] at [{}] (scheduled time was [{}])", schedule.name, triggeredDateTime, scheduledDateTime);, +                events.add(new ScheduleTriggerEvent(schedule.name, triggeredDateTime, scheduledDateTime));, +    // visible for testing, +    Map<String, ActiveSchedule> getSchedules() {, +        return Collections.unmodifiableMap(schedules);, +    }, +, +++ b/x-pack/plugin/watcher/src/main/java/org/elasticsearch/xpack/watcher/trigger/schedule/Schedule.java, +/**, + * This interface is used to implement watcher specific schedules, the existing implementations are either, + * based on a cron based or an interval based schedule, + *, + * In addition to the methods defined here, you also have to implement the equals() method to properly work, + * for the trigger engine implementations., + */, +++ b/x-pack/plugin/watcher/src/main/java/org/elasticsearch/xpack/watcher/trigger/schedule/engine/TickerScheduleTriggerEngine.java, +import java.util.Collections;, +    private final Map<String, ActiveSchedule> schedules = new ConcurrentHashMap<>();, +    private final Ticker ticker;, +        Map<String, ActiveSchedule> startingSchedules = new HashMap<>(jobs.size());, +                startingSchedules.put(job.id(), new ActiveSchedule(job.id(), trigger.getSchedule(), startTime));, +        this.schedules.putAll(startingSchedules);, +        ActiveSchedule currentSchedule = schedules.get(watch.id());, +        // only update the schedules data structure if the scheduled trigger really has changed, otherwise the time would be reset again, +        // resulting in later executions, as the time would only count after a watch has been stored, as this code is triggered by the, +        // watcher indexing listener, +        // this also means that updating an existing watch would not retrigger the schedule time, if it remains the same schedule, +        if (currentSchedule == null || currentSchedule.schedule.equals(trigger.getSchedule()) == false) {, +    }, +                DateTime triggeredDateTime = new DateTime(triggeredTime, UTC);, +                DateTime scheduledDateTime = new DateTime(scheduledTime, UTC);, +                logger.debug("triggered job [{}] at [{}] (scheduled time was [{}])", schedule.name, triggeredDateTime, scheduledDateTime);, +                events.add(new ScheduleTriggerEvent(schedule.name, triggeredDateTime, scheduledDateTime));, +    // visible for testing, +    Map<String, ActiveSchedule> getSchedules() {, +        return Collections.unmodifiableMap(schedules);, +    }, +, +++ b/x-pack/plugin/watcher/src/test/java/org/elasticsearch/xpack/watcher/trigger/schedule/engine/TickerScheduleEngineTests.java, +import static org.hamcrest.Matchers.not;, +    private TickerScheduleTriggerEngine engine;, +    private TickerScheduleTriggerEngine createEngine() {, +    public void testAddOnlyWithNewSchedule() {, +        engine.start(Collections.emptySet());, +, +        // add watch with schedule, +        Watch oncePerSecondWatch = createWatch("_id", interval("1s"));, +        engine.add(oncePerSecondWatch);, +        TickerScheduleTriggerEngine.ActiveSchedule activeSchedule = engine.getSchedules().get("_id");, +        engine.add(oncePerSecondWatch);, +        assertThat(engine.getSchedules().get("_id"), is(activeSchedule));, +, +        // add watch with same id but different watch, +        Watch oncePerMinuteWatch = createWatch("_id", interval("1m"));, +        engine.add(oncePerMinuteWatch);, +        assertThat(engine.getSchedules().get("_id"), not(is(activeSchedule)));, +    }, +]