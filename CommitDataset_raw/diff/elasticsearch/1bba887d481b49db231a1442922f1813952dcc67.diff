[+++ b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/FieldAttribute.java, +            return innerField(exactField);, +++ b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/FieldAttribute.java, +            return innerField(exactField);, +++ b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/planner/QueryTranslator.java, +import org.elasticsearch.xpack.sql.expression.function.aggregate.MedianAbsoluteDeviation;, +            String targetFieldName = null;, +                targetFieldName = nameOf(((FieldAttribute) e.field()).exactAttribute());, +                throw new SqlIllegalArgumentException("Scalar function [{}] not allowed (yet) as argument for " + e.functionName(),, +                q = new WildcardQuery(e.source(), targetFieldName, p.asLuceneWildcard());, +                q = new RegexQuery(e.source(), targetFieldName, pattern);, +++ b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/FieldAttribute.java, +            return innerField(exactField);, +++ b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/planner/QueryTranslator.java, +import org.elasticsearch.xpack.sql.expression.function.aggregate.MedianAbsoluteDeviation;, +            String targetFieldName = null;, +                targetFieldName = nameOf(((FieldAttribute) e.field()).exactAttribute());, +                throw new SqlIllegalArgumentException("Scalar function [{}] not allowed (yet) as argument for " + e.functionName(),, +                q = new WildcardQuery(e.source(), targetFieldName, p.asLuceneWildcard());, +                q = new RegexQuery(e.source(), targetFieldName, pattern);, +++ b/x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/analysis/analyzer/VerifierErrorMessagesTests.java, +    public void testInvalidTypeForLikeMatch() {, +    public void testInvalidTypeForRLikeMatch() {, +        assertEquals("1:26: [text RLIKE 'foo'] cannot operate on field of data type [text]: " +, +                "No keyword/multi-field defined exact matches for [text]; define one or use MATCH/QUERY instead",, +            error("SELECT * FROM test WHERE text RLIKE 'foo'"));, +    }, +    , +++ b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/FieldAttribute.java, +            return innerField(exactField);, +++ b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/planner/QueryTranslator.java, +import org.elasticsearch.xpack.sql.expression.function.aggregate.MedianAbsoluteDeviation;, +            String targetFieldName = null;, +                targetFieldName = nameOf(((FieldAttribute) e.field()).exactAttribute());, +                throw new SqlIllegalArgumentException("Scalar function [{}] not allowed (yet) as argument for " + e.functionName(),, +                q = new WildcardQuery(e.source(), targetFieldName, p.asLuceneWildcard());, +                q = new RegexQuery(e.source(), targetFieldName, pattern);, +++ b/x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/analysis/analyzer/VerifierErrorMessagesTests.java, +    public void testInvalidTypeForLikeMatch() {, +    public void testInvalidTypeForRLikeMatch() {, +        assertEquals("1:26: [text RLIKE 'foo'] cannot operate on field of data type [text]: " +, +                "No keyword/multi-field defined exact matches for [text]; define one or use MATCH/QUERY instead",, +            error("SELECT * FROM test WHERE text RLIKE 'foo'"));, +    }, +    , +++ b/x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/planner/QueryTranslatorTests.java, +import org.elasticsearch.xpack.sql.querydsl.query.RegexQuery;, +import org.elasticsearch.xpack.sql.querydsl.query.WildcardQuery;, +        assertEquals(WildcardQuery.class, qt.query.getClass());, +        WildcardQuery qsq = ((WildcardQuery) qt.query);, +        assertEquals("some.string.typical", qsq.field());, +    }, +    , +    public void testRLikeOnInexact() {, +        LogicalPlan p = plan("SELECT * FROM test WHERE some.string RLIKE '.*a.*'");, +        assertTrue(p instanceof Project);, +        p = ((Project) p).child();, +        assertTrue(p instanceof Filter);, +        Expression condition = ((Filter) p).condition();, +        QueryTranslation qt = QueryTranslator.toQuery(condition, false);, +        assertEquals(RegexQuery.class, qt.query.getClass());, +        RegexQuery qsq = ((RegexQuery) qt.query);, +        assertEquals("some.string.typical", qsq.field());, +        LogicalPlan p = plan("SELECT LTRIM(keyword) lt FROM test WHERE LTRIM(keyword) like '%a%'");, +        assertEquals("Scalar function [LTRIM(keyword)] not allowed (yet) as argument for LIKE", ex.getMessage());, +    }, +    , +    public void testRLikeConstructsNotSupported() {, +        LogicalPlan p = plan("SELECT LTRIM(keyword) lt FROM test WHERE LTRIM(keyword) RLIKE '.*a.*'");, +        assertTrue(p instanceof Project);, +        p = ((Project) p).child();, +        assertTrue(p instanceof Filter);, +        Expression condition = ((Filter) p).condition();, +        SqlIllegalArgumentException ex = expectThrows(SqlIllegalArgumentException.class, () -> QueryTranslator.toQuery(condition, false));, +        assertEquals("Scalar function [LTRIM(keyword)] not allowed (yet) as argument for RLIKE", ex.getMessage());, +        assertTrue(bq.left() instanceof WildcardQuery);, +        assertTrue(nq.child() instanceof WildcardQuery);, +        WildcardQuery lqsq = (WildcardQuery) bq.left();, +        WildcardQuery rqsq = (WildcardQuery) nq.child();, +        assertEquals("keyword", lqsq.field());, +        assertEquals("keyword", rqsq.field());, +        assertTrue(bq.left() instanceof RegexQuery);, +        assertTrue(nq.child() instanceof RegexQuery);, +        RegexQuery lqsq = (RegexQuery) bq.left();, +        RegexQuery rqsq = (RegexQuery) nq.child();, +        assertEquals(firstPattern, lqsq.regex());, +        assertEquals("keyword", lqsq.field());, +        assertEquals(secondPattern, rqsq.regex());, +        assertEquals("keyword", rqsq.field());]