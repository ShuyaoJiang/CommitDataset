[+++ b/src/main/java/org/elasticsearch/gateway/local/LocalGateway.java, +        // order is important, first metaState, and then shardsState, +        // so dangling indices will be recorded, +++ b/src/main/java/org/elasticsearch/gateway/local/LocalGateway.java, +        // order is important, first metaState, and then shardsState, +        // so dangling indices will be recorded, +++ b/src/main/java/org/elasticsearch/gateway/local/state/meta/LocalGatewayMetaState.java, +import org.elasticsearch.common.util.concurrent.ConcurrentCollections;, +import org.elasticsearch.threadpool.ThreadPool;, +import java.util.concurrent.ScheduledFuture;, +    private final ThreadPool threadPool;, +, +    private final TimeValue danglingTimeout;, +    private final Map<String, DanglingIndex> danglingIndices = ConcurrentCollections.newConcurrentMap();, +    private final Object danglingMutex = new Object();, +, +    public LocalGatewayMetaState(Settings settings, ThreadPool threadPool, NodeEnvironment nodeEnv, TransportNodesListGatewayMetaState nodesListGatewayMetaState) throws Exception {, +        this.threadPool = threadPool;, +        this.danglingTimeout = settings.getAsTime("gateway.local.dangling_timeout", TimeValue.timeValueHours(2));, +, +    public boolean isDangling(String index) {, +        return danglingIndices.containsKey(index);, +    }, +, +        // handle dangling indices, +        if (nodeEnv.hasNodeFile()) {, +            if (danglingTimeout.millis() >= 0) {, +                synchronized (danglingMutex) {, +                    for (String danglingIndex : danglingIndices.keySet()) {, +                        if (event.state().metaData().hasIndex(danglingIndex)) {, +                            logger.debug("[{}] no longer dangling (created), removing", danglingIndex);, +                            DanglingIndex removed = danglingIndices.remove(danglingIndex);, +                            removed.future.cancel(false);, +                        }, +                    }, +                    // delete indices that are no longer part of the metadata, +                    try {, +                        for (String indexName : nodeEnv.findAllIndices()) {, +                            // if we have the index on the metadata, don't delete it, +                            if (event.state().metaData().hasIndex(indexName)) {, +                                continue;, +                            }, +                            if (danglingIndices.containsKey(indexName)) {, +                                // already dangling, continue, +                                continue;, +                            }, +                            if (danglingTimeout.millis() == 0) {, +                                logger.info("[{}] dangling index, exists on local file system, but not in cluster metadata, timeout set to 0, deleting now", indexName);, +                                FileSystemUtils.deleteRecursively(nodeEnv.indexLocations(new Index(indexName)));, +                            } else {, +                                logger.info("[{}] dangling index, exists on local file system, but not in cluster metadata, scheduling to delete in [{}]", indexName, danglingTimeout);, +                                danglingIndices.put(indexName, new DanglingIndex(indexName, threadPool.schedule(danglingTimeout, ThreadPool.Names.SAME, new RemoveDanglingIndex(indexName))));, +                            }, +                        }, +                    } catch (Exception e) {, +                        logger.warn("failed to find dangling indices", e);, +                    }, +                }, +            }, +        }, +, +                    if (!danglingIndices.containsKey(current.index())) {, +        }, +, +    class RemoveDanglingIndex implements Runnable {, +, +        private final String index;, +, +        RemoveDanglingIndex(String index) {, +            this.index = index;, +        }, +, +        @Override, +        public void run() {, +            synchronized (danglingMutex) {, +                DanglingIndex remove = danglingIndices.remove(index);, +                // no longer there..., +                if (remove == null) {, +                    return;, +                }, +                logger.info("[{}] deleting dangling index", index);, +                FileSystemUtils.deleteRecursively(nodeEnv.indexLocations(new Index(index)));, +            }, +        }, +    }, +, +    static class DanglingIndex {, +        public final String index;, +        public final ScheduledFuture future;, +, +        DanglingIndex(String index, ScheduledFuture future) {, +            this.index = index;, +            this.future = future;, +        }, +    }, +++ b/src/main/java/org/elasticsearch/gateway/local/LocalGateway.java, +        // order is important, first metaState, and then shardsState, +        // so dangling indices will be recorded, +++ b/src/main/java/org/elasticsearch/gateway/local/state/meta/LocalGatewayMetaState.java, +import org.elasticsearch.common.util.concurrent.ConcurrentCollections;]