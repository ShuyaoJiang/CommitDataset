[+++ b/buildSrc/src/main/resources/checkstyle_suppressions.xml, +++ b/buildSrc/src/main/resources/checkstyle_suppressions.xml, +++ b/core/src/main/java/org/elasticsearch/cluster/metadata/IndexGraveyard.java, +    /**, +     * Returns true if the graveyard contains a tombstone for the given index., +     */, +    public boolean containsIndex(final Index index) {, +        for (Tombstone tombstone : tombstones) {, +            if (tombstone.getIndex().equals(index)) {, +                return true;, +            }, +        }, +        return false;, +    }, +, +++ b/buildSrc/src/main/resources/checkstyle_suppressions.xml, +++ b/core/src/main/java/org/elasticsearch/cluster/metadata/IndexGraveyard.java, +    /**, +     * Returns true if the graveyard contains a tombstone for the given index., +     */, +    public boolean containsIndex(final Index index) {, +        for (Tombstone tombstone : tombstones) {, +            if (tombstone.getIndex().equals(index)) {, +                return true;, +            }, +        }, +        return false;, +    }, +, +++ b/core/src/main/java/org/elasticsearch/gateway/DanglingIndicesState.java, +import org.elasticsearch.cluster.metadata.IndexGraveyard;, +    public void processDanglingIndices(final MetaData metaData) {, +    void findNewAndAddDanglingIndices(final MetaData metaData) {, +    Map<Index, IndexMetaData> findNewDanglingIndices(final MetaData metaData) {, +            final IndexGraveyard graveyard = metaData.indexGraveyard();, +                } else if (graveyard.containsIndex(indexMetaData.getIndex())) {, +                    logger.warn("[{}] can not be imported as a dangling index, as an index with the same name and UUID exist in the " +, +                                "index tombstones.  This situation is likely caused by copying over the data directory for an index " +, +                                "that was previously deleted.", indexMetaData.getIndex());, +                    logger.info("[{}] dangling index exists on local file system, but not in cluster metadata, " +, +                                "auto import to cluster state", indexMetaData.getIndex());, +            allocateDangledIndices.allocateDangled(Collections.unmodifiableCollection(new ArrayList<>(danglingIndices.values())),, +                new LocalAllocateDangledIndices.Listener() {, +                }, +            );, +++ b/buildSrc/src/main/resources/checkstyle_suppressions.xml, +++ b/core/src/main/java/org/elasticsearch/cluster/metadata/IndexGraveyard.java, +    /**, +     * Returns true if the graveyard contains a tombstone for the given index., +     */, +    public boolean containsIndex(final Index index) {, +        for (Tombstone tombstone : tombstones) {, +            if (tombstone.getIndex().equals(index)) {, +                return true;, +            }, +        }, +        return false;, +    }, +, +++ b/core/src/main/java/org/elasticsearch/gateway/DanglingIndicesState.java, +import org.elasticsearch.cluster.metadata.IndexGraveyard;, +    public void processDanglingIndices(final MetaData metaData) {, +    void findNewAndAddDanglingIndices(final MetaData metaData) {, +    Map<Index, IndexMetaData> findNewDanglingIndices(final MetaData metaData) {, +            final IndexGraveyard graveyard = metaData.indexGraveyard();, +                } else if (graveyard.containsIndex(indexMetaData.getIndex())) {, +                    logger.warn("[{}] can not be imported as a dangling index, as an index with the same name and UUID exist in the " +, +                                "index tombstones.  This situation is likely caused by copying over the data directory for an index " +, +                                "that was previously deleted.", indexMetaData.getIndex());, +                    logger.info("[{}] dangling index exists on local file system, but not in cluster metadata, " +, +                                "auto import to cluster state", indexMetaData.getIndex());, +            allocateDangledIndices.allocateDangled(Collections.unmodifiableCollection(new ArrayList<>(danglingIndices.values())),, +                new LocalAllocateDangledIndices.Listener() {, +                }, +            );, +++ b/core/src/main/java/org/elasticsearch/indices/IndicesService.java, +                    throw new IllegalStateException("Can't delete unassigned index store for [" + indexName + "] - it's still part of " +, +                                                    "the cluster state [" + index.getIndexUUID() + "] [" + metaData.getIndexUUID() + "]");, +++ b/buildSrc/src/main/resources/checkstyle_suppressions.xml, +++ b/core/src/main/java/org/elasticsearch/cluster/metadata/IndexGraveyard.java, +    /**, +     * Returns true if the graveyard contains a tombstone for the given index., +     */, +    public boolean containsIndex(final Index index) {, +        for (Tombstone tombstone : tombstones) {, +            if (tombstone.getIndex().equals(index)) {, +                return true;, +            }, +        }, +        return false;, +    }, +, +++ b/core/src/main/java/org/elasticsearch/gateway/DanglingIndicesState.java, +import org.elasticsearch.cluster.metadata.IndexGraveyard;, +    public void processDanglingIndices(final MetaData metaData) {, +    void findNewAndAddDanglingIndices(final MetaData metaData) {, +    Map<Index, IndexMetaData> findNewDanglingIndices(final MetaData metaData) {, +            final IndexGraveyard graveyard = metaData.indexGraveyard();, +                } else if (graveyard.containsIndex(indexMetaData.getIndex())) {, +                    logger.warn("[{}] can not be imported as a dangling index, as an index with the same name and UUID exist in the " +]