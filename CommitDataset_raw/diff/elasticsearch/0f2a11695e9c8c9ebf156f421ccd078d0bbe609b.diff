[+++ b/core/src/main/java/org/elasticsearch/index/query/RangeQueryBuilder.java, +                if (relation != null && !isRelationAllowed(relation)) {, +                    throw new IllegalArgumentException(, +                        "[range] query does not support relation [" + relationString + "]");, +    }, +, +    private boolean isRelationAllowed(ShapeRelation relation) {, +        return relation == ShapeRelation.INTERSECTS, +            || relation == ShapeRelation.CONTAINS, +            || relation == ShapeRelation.WITHIN;, +    }, +        if (!isRelationAllowed(this.relation)) {, +            throw new IllegalArgumentException("[range] query does not support relation [" + relation + "]");, +        }, +++ b/core/src/main/java/org/elasticsearch/index/query/RangeQueryBuilder.java, +                if (relation != null && !isRelationAllowed(relation)) {, +                    throw new IllegalArgumentException(, +                        "[range] query does not support relation [" + relationString + "]");, +    }, +, +    private boolean isRelationAllowed(ShapeRelation relation) {, +        return relation == ShapeRelation.INTERSECTS, +            || relation == ShapeRelation.CONTAINS, +            || relation == ShapeRelation.WITHIN;, +    }, +        if (!isRelationAllowed(this.relation)) {, +            throw new IllegalArgumentException("[range] query does not support relation [" + relation + "]");, +        }, +++ b/core/src/main/java/org/elasticsearch/script/Script.java, +            Map<String, String> options = (Map<String, String>)(Map)in.readMap();, +            Map<String, String> options = (Map<String, String>)(Map)in.readMap();, +            Map<String, Object> options = (Map<String, Object>)(Map)this.options;, +            Map<String, Object> options = (Map<String, Object>)(Map)this.options;, +++ b/core/src/main/java/org/elasticsearch/index/query/RangeQueryBuilder.java, +                if (relation != null && !isRelationAllowed(relation)) {, +                    throw new IllegalArgumentException(, +                        "[range] query does not support relation [" + relationString + "]");, +    }, +, +    private boolean isRelationAllowed(ShapeRelation relation) {, +        return relation == ShapeRelation.INTERSECTS, +            || relation == ShapeRelation.CONTAINS, +            || relation == ShapeRelation.WITHIN;, +    }, +        if (!isRelationAllowed(this.relation)) {, +            throw new IllegalArgumentException("[range] query does not support relation [" + relation + "]");, +        }, +++ b/core/src/main/java/org/elasticsearch/script/Script.java, +            Map<String, String> options = (Map<String, String>)(Map)in.readMap();, +            Map<String, String> options = (Map<String, String>)(Map)in.readMap();, +            Map<String, Object> options = (Map<String, Object>)(Map)this.options;, +            Map<String, Object> options = (Map<String, Object>)(Map)this.options;, +++ b/core/src/test/java/org/elasticsearch/index/query/RangeQueryBuilderTests.java, +import org.elasticsearch.common.geo.ShapeRelation;, +, +    public void testParseRelation() {, +        String json =, +            "{\n" +, +                "    \"range\": {\n" +, +                "      \"age\": {\n" +, +                "        \"gte\": 30,\n" +, +                "        \"lte\": 40,\n" +, +                "        \"relation\": \"disjoint\"\n" +, +                "      }" +, +                "    }\n" +, +                "  }";, +        String fieldName = randomAlphaOfLengthBetween(1, 20);, +        IllegalArgumentException e1 = expectThrows(IllegalArgumentException.class, () -> parseQuery(json));, +        assertEquals("[range] query does not support relation [disjoint]", e1.getMessage());, +        RangeQueryBuilder builder = new RangeQueryBuilder(fieldName);, +        IllegalArgumentException e2 = expectThrows(IllegalArgumentException.class, ()->builder.relation("disjoint"));, +        assertEquals("[range] query does not support relation [disjoint]", e2.getMessage());, +        builder.relation("contains");, +        assertEquals(ShapeRelation.CONTAINS, builder.relation());, +        builder.relation("within");, +        assertEquals(ShapeRelation.WITHIN, builder.relation());, +        builder.relation("intersects");, +        assertEquals(ShapeRelation.INTERSECTS, builder.relation());, +    }, +++ b/core/src/main/java/org/elasticsearch/index/query/RangeQueryBuilder.java, +                if (relation != null && !isRelationAllowed(relation)) {, +                    throw new IllegalArgumentException(, +                        "[range] query does not support relation [" + relationString + "]");, +    }, +, +    private boolean isRelationAllowed(ShapeRelation relation) {, +        return relation == ShapeRelation.INTERSECTS, +            || relation == ShapeRelation.CONTAINS, +            || relation == ShapeRelation.WITHIN;, +    }, +        if (!isRelationAllowed(this.relation)) {, +            throw new IllegalArgumentException("[range] query does not support relation [" + relation + "]");, +        }, +++ b/core/src/main/java/org/elasticsearch/script/Script.java, +            Map<String, String> options = (Map<String, String>)(Map)in.readMap();, +            Map<String, String> options = (Map<String, String>)(Map)in.readMap();, +            Map<String, Object> options = (Map<String, Object>)(Map)this.options;, +            Map<String, Object> options = (Map<String, Object>)(Map)this.options;, +++ b/core/src/test/java/org/elasticsearch/index/query/RangeQueryBuilderTests.java, +import org.elasticsearch.common.geo.ShapeRelation;]