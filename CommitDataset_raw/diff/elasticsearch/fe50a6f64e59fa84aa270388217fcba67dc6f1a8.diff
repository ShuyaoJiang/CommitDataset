[+++ b/modules/elasticsearch/src/main/java/org/elasticsearch/ElasticSearchException.java, +            sb.append(toString()).append("; ");, +            if (getCause() instanceof ElasticSearchException) {, +                sb.append(((ElasticSearchException) getCause()).getDetailedMessage());, +            } else {, +                sb.append(getCause());, +            return super.toString();, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/ElasticSearchException.java, +            sb.append(toString()).append("; ");, +            if (getCause() instanceof ElasticSearchException) {, +                sb.append(((ElasticSearchException) getCause()).getDetailedMessage());, +            } else {, +                sb.append(getCause());, +            return super.toString();, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/cluster/metadata/MetaDataService.java, +    private final Object mutex = new Object();, +, +    public IndicesAliasesResult indicesAliases(final List<AliasAction> aliasActions) {, +        synchronized (mutex) {, +    }, +    public CreateIndexResult createIndex(final String cause, final String index, final Settings indexSettings, Map<String, String> mappings, TimeValue timeout) throws IndexAlreadyExistsException {, +        final CountDownLatch latch = new CountDownLatch(clusterService.state().nodes().size());, +        NodeIndexCreatedAction.Listener nodeCreatedListener = new NodeIndexCreatedAction.Listener() {, +            @Override public void onNodeIndexCreated(String mIndex, String nodeId) {, +                if (index.equals(mIndex)) {, +                    latch.countDown();, +                }, +            }, +        };, +        synchronized (mutex) {, +        }, +    public DeleteIndexResult deleteIndex(final String index, TimeValue timeout) throws IndexMissingException {, +        synchronized (mutex) {, +, +            RoutingTable routingTable = clusterState.routingTable();, +            if (!routingTable.hasIndex(index)) {, +                throw new IndexMissingException(new Index(index));, +            }, +, +            logger.info("[{}] deleting index", index);, +, +        }, +, +    public void updateMapping(final String index, final String type, final String mappingSource) {, +        synchronized (mutex) {, +    }, +    public PutMappingResult putMapping(final String[] indices, String mappingType, final String mappingSource, boolean ignoreConflicts, TimeValue timeout) throws ElasticSearchException {, +        final CountDownLatch latch = new CountDownLatch(clusterService.state().nodes().size() * indices.length);, +        final Set<String> indicesSet = newHashSet(indices);, +        final String fMappingType = mappingType;, +        NodeMappingCreatedAction.Listener listener = new NodeMappingCreatedAction.Listener() {, +            @Override public void onNodeMappingCreated(NodeMappingCreatedAction.NodeMappingCreatedResponse response) {, +                if (indicesSet.contains(response.index()) && response.type().equals(fMappingType)) {, +                    latch.countDown();, +                }, +            }, +        };, +        synchronized (mutex) {, +        }, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/ElasticSearchException.java, +            sb.append(toString()).append("; ");, +            if (getCause() instanceof ElasticSearchException) {, +                sb.append(((ElasticSearchException) getCause()).getDetailedMessage());, +            } else {, +                sb.append(getCause());, +            return super.toString();, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/cluster/metadata/MetaDataService.java, +    private final Object mutex = new Object();, +, +    public IndicesAliasesResult indicesAliases(final List<AliasAction> aliasActions) {, +        synchronized (mutex) {, +    }, +    public CreateIndexResult createIndex(final String cause, final String index, final Settings indexSettings, Map<String, String> mappings, TimeValue timeout) throws IndexAlreadyExistsException {, +        final CountDownLatch latch = new CountDownLatch(clusterService.state().nodes().size());, +        NodeIndexCreatedAction.Listener nodeCreatedListener = new NodeIndexCreatedAction.Listener() {, +            @Override public void onNodeIndexCreated(String mIndex, String nodeId) {, +                if (index.equals(mIndex)) {, +                    latch.countDown();, +                }, +            }, +        };, +        synchronized (mutex) {, +        }, +    public DeleteIndexResult deleteIndex(final String index, TimeValue timeout) throws IndexMissingException {, +        synchronized (mutex) {, +, +            RoutingTable routingTable = clusterState.routingTable();, +            if (!routingTable.hasIndex(index)) {, +                throw new IndexMissingException(new Index(index));, +            }, +, +            logger.info("[{}] deleting index", index);, +, +        }, +, +    public void updateMapping(final String index, final String type, final String mappingSource) {, +        synchronized (mutex) {, +    }, +    public PutMappingResult putMapping(final String[] indices, String mappingType, final String mappingSource, boolean ignoreConflicts, TimeValue timeout) throws ElasticSearchException {, +        final CountDownLatch latch = new CountDownLatch(clusterService.state().nodes().size() * indices.length);]