[+++ b/elasticsearch/src/main/java/org/elasticsearch/xpack/security/InternalClient.java, +                authentication.writeToContext(threadPool().getThreadContext(), cryptoService, signUserHeader);, +++ b/elasticsearch/src/main/java/org/elasticsearch/xpack/security/InternalClient.java, +                authentication.writeToContext(threadPool().getThreadContext(), cryptoService, signUserHeader);, +++ b/elasticsearch/src/main/java/org/elasticsearch/xpack/security/authc/Authentication.java, +    void writeToContextIfMissing(ThreadContext context, CryptoService cryptoService, boolean sign), +    /**, +     * Writes the authentication to the context. There must not be an existing authentication in the context and if there is an, +     * {@link IllegalStateException} will be thrown, +     */, +    public void writeToContext(ThreadContext ctx, CryptoService cryptoService, boolean sign), +++ b/elasticsearch/src/main/java/org/elasticsearch/xpack/security/InternalClient.java, +                authentication.writeToContext(threadPool().getThreadContext(), cryptoService, signUserHeader);, +++ b/elasticsearch/src/main/java/org/elasticsearch/xpack/security/authc/Authentication.java, +    void writeToContextIfMissing(ThreadContext context, CryptoService cryptoService, boolean sign), +    /**, +     * Writes the authentication to the context. There must not be an existing authentication in the context and if there is an, +     * {@link IllegalStateException} will be thrown, +     */, +    public void writeToContext(ThreadContext ctx, CryptoService cryptoService, boolean sign), +++ b/elasticsearch/src/main/java/org/elasticsearch/xpack/security/authz/AuthorizationService.java, +, +    // pkg-private for testing, +    GlobalPermission permission(Collection<Role> roles) {, +        // we need to special case the internal users in this method, if we apply the anonymous roles to every user including these system, +        // user accounts then we run into the chance of a deadlock because then we need to get a role that we may be trying to get as the, +        // internal user. The SystemUser is special cased as it has special privileges to execute internal actions and should never be, +        // passed into this method. The XPackUser has the Superuser role and we can simply return that, +        if (SystemUser.is(user)) {, +            throw new IllegalArgumentException("the user [" + user.principal() + "] is the system user and we should never try to get its" +, +                    " roles");, +        }, +        if (XPackUser.is(user)) {, +            assert XPackUser.INSTANCE.roles().length == 1 && SuperuserRole.NAME.equals(XPackUser.INSTANCE.roles()[0]);, +            return Collections.singleton(SuperuserRole.INSTANCE);, +        }, +, +++ b/elasticsearch/src/main/java/org/elasticsearch/xpack/security/InternalClient.java, +                authentication.writeToContext(threadPool().getThreadContext(), cryptoService, signUserHeader);, +++ b/elasticsearch/src/main/java/org/elasticsearch/xpack/security/authc/Authentication.java, +    void writeToContextIfMissing(ThreadContext context, CryptoService cryptoService, boolean sign), +    /**, +     * Writes the authentication to the context. There must not be an existing authentication in the context and if there is an, +     * {@link IllegalStateException} will be thrown, +     */, +    public void writeToContext(ThreadContext ctx, CryptoService cryptoService, boolean sign), +++ b/elasticsearch/src/main/java/org/elasticsearch/xpack/security/authz/AuthorizationService.java, +, +    // pkg-private for testing, +    GlobalPermission permission(Collection<Role> roles) {, +        // we need to special case the internal users in this method, if we apply the anonymous roles to every user including these system, +        // user accounts then we run into the chance of a deadlock because then we need to get a role that we may be trying to get as the, +        // internal user. The SystemUser is special cased as it has special privileges to execute internal actions and should never be, +        // passed into this method. The XPackUser has the Superuser role and we can simply return that, +        if (SystemUser.is(user)) {, +            throw new IllegalArgumentException("the user [" + user.principal() + "] is the system user and we should never try to get its" +, +                    " roles");, +        }, +        if (XPackUser.is(user)) {, +            assert XPackUser.INSTANCE.roles().length == 1 && SuperuserRole.NAME.equals(XPackUser.INSTANCE.roles()[0]);, +            return Collections.singleton(SuperuserRole.INSTANCE);, +        }, +, +++ b/elasticsearch/src/test/java/org/elasticsearch/xpack/security/authc/esnative/NativeRealmIntegTests.java, +import org.junit.Before;, +    private boolean roleExists;, +, +                    .put(AnonymousUser.ROLES_SETTING.getKey(), "native_anonymous"), +    @Before, +    public void setupAnonymousRoleIfNecessary() throws Exception {, +        roleExists = anonymousEnabled && randomBoolean();, +        if (anonymousEnabled) {, +            if (roleExists) {, +                logger.info("anonymous is enabled. creating [native_anonymous] role");, +                PutRoleResponse response = securityClient(), +                        .preparePutRole("native_anonymous"), +                        .cluster("ALL"), +                        .addIndices(new String[]{"*"}, new String[]{"ALL"}, new FieldPermissions(), null), +                        .get();, +                assertTrue(response.isCreated());, +            } else {, +                logger.info("anonymous is enabled, but configured with a missing role");, +            }, +        }, +    }, +, +            if (anonymousEnabled && roleExists) {, +        if (anonymousEnabled && roleExists) {, +        if (anonymousEnabled && roleExists) {, +        long roles = anonymousEnabled && roleExists ? 1L: 0L;, +        assertEquals(roles, usage.get("size"));, +++ b/elasticsearch/src/main/java/org/elasticsearch/xpack/security/InternalClient.java, +                authentication.writeToContext(threadPool().getThreadContext(), cryptoService, signUserHeader);, +++ b/elasticsearch/src/main/java/org/elasticsearch/xpack/security/authc/Authentication.java, +    void writeToContextIfMissing(ThreadContext context, CryptoService cryptoService, boolean sign), +    /**, +     * Writes the authentication to the context. There must not be an existing authentication in the context and if there is an, +     * {@link IllegalStateException} will be thrown, +     */, +    public void writeToContext(ThreadContext ctx, CryptoService cryptoService, boolean sign)]