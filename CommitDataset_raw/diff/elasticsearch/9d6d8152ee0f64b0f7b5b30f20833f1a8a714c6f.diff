[+++ b/core/src/main/java/org/elasticsearch/action/search/AbstractSearchAsyncAction.java, +        failIfOverShardCountLimit(clusterService, shardCount);, +        expectedSuccessfulOps = shardCount;, +        // we need to add 1 for non active partition, since we count it in the total!, +        expectedTotalOps = shardsIts.totalSizeWith1ForEmpty();, +, +        firstResults = new AtomicArray<>(shardsIts.size());, +    }, +, +    private void failIfOverShardCountLimit(ClusterService clusterService, int shardCount) {, +++ b/core/src/main/java/org/elasticsearch/action/search/AbstractSearchAsyncAction.java, +        failIfOverShardCountLimit(clusterService, shardCount);, +        expectedSuccessfulOps = shardCount;, +        // we need to add 1 for non active partition, since we count it in the total!, +        expectedTotalOps = shardsIts.totalSizeWith1ForEmpty();, +, +        firstResults = new AtomicArray<>(shardsIts.size());, +    }, +, +    private void failIfOverShardCountLimit(ClusterService clusterService, int shardCount) {, +++ b/core/src/main/java/org/elasticsearch/action/search/TransportSearchAction.java, +        searchAsyncAction(searchRequest, listener).start();, +    }, +, +    private AbstractSearchAsyncAction searchAsyncAction(SearchRequest searchRequest, ActionListener<SearchResponse> listener) {, +        return searchAsyncAction;, +, +++ b/core/src/main/java/org/elasticsearch/action/search/AbstractSearchAsyncAction.java, +        failIfOverShardCountLimit(clusterService, shardCount);, +        expectedSuccessfulOps = shardCount;, +        // we need to add 1 for non active partition, since we count it in the total!, +        expectedTotalOps = shardsIts.totalSizeWith1ForEmpty();, +, +        firstResults = new AtomicArray<>(shardsIts.size());, +    }, +, +    private void failIfOverShardCountLimit(ClusterService clusterService, int shardCount) {, +++ b/core/src/main/java/org/elasticsearch/action/search/TransportSearchAction.java, +        searchAsyncAction(searchRequest, listener).start();, +    }, +, +    private AbstractSearchAsyncAction searchAsyncAction(SearchRequest searchRequest, ActionListener<SearchResponse> listener) {, +        return searchAsyncAction;, +, +++ b/core/src/main/java/org/elasticsearch/action/support/replication/ReplicationOperation.java, +, +        performOnReplicas(primaryId, replicaRequest);, +, +        successfulShards.incrementAndGet();, +        decPendingAndFinishIfNeeded();, +    }, +, +    private void performOnReplicas(ShardId primaryId, ReplicaRequest replicaRequest) {, +++ b/core/src/main/java/org/elasticsearch/action/search/AbstractSearchAsyncAction.java, +        failIfOverShardCountLimit(clusterService, shardCount);, +        expectedSuccessfulOps = shardCount;, +        // we need to add 1 for non active partition, since we count it in the total!, +        expectedTotalOps = shardsIts.totalSizeWith1ForEmpty();, +, +        firstResults = new AtomicArray<>(shardsIts.size());, +    }, +, +    private void failIfOverShardCountLimit(ClusterService clusterService, int shardCount) {, +++ b/core/src/main/java/org/elasticsearch/action/search/TransportSearchAction.java, +        searchAsyncAction(searchRequest, listener).start();, +    }, +, +    private AbstractSearchAsyncAction searchAsyncAction(SearchRequest searchRequest, ActionListener<SearchResponse> listener) {, +        return searchAsyncAction;, +, +++ b/core/src/main/java/org/elasticsearch/action/support/replication/ReplicationOperation.java, +, +        performOnReplicas(primaryId, replicaRequest);, +, +        successfulShards.incrementAndGet();, +        decPendingAndFinishIfNeeded();, +    }, +, +    private void performOnReplicas(ShardId primaryId, ReplicaRequest replicaRequest) {, +++ b/core/src/main/java/org/elasticsearch/common/io/stream/StreamInput.java, +                return fastReadByteArray();, +                return readArrayList();, +                return readArray();, +                return readLinkedHashMap();, +                return readHashMap();, +                return readDate();, +                return readDateTime();, +    private byte[] fastReadByteArray() throws IOException {, +        int bytesSize = readVInt();, +        byte[] value = new byte[bytesSize];, +        readBytes(value, 0, bytesSize);, +        return value;, +    }, +, +    @SuppressWarnings("unchecked"), +    private List readArrayList() throws IOException {, +        int size = readVInt();, +        List list = new ArrayList(size);, +        for (int i = 0; i < size; i++) {, +            list.add(readGenericValue());]