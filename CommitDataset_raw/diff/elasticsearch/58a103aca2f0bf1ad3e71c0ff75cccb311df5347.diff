[+++ b/core/src/main/java/org/elasticsearch/action/admin/cluster/allocation/TransportClusterAllocationExplainAction.java, +        for (RoutingNode node : routingNodes) {, +++ b/core/src/main/java/org/elasticsearch/action/admin/cluster/allocation/TransportClusterAllocationExplainAction.java, +        for (RoutingNode node : routingNodes) {, +++ b/core/src/main/java/org/elasticsearch/cluster/action/shard/ShardStateAction.java, +import org.elasticsearch.cluster.routing.RoutingNode;, +            RoutingNode routingNode = currentState.getRoutingNodes().node(task.getShardRouting().currentNodeId());, +            if (routingNode != null) {, +                ShardRouting maybe = routingNode.getByShardId(task.getShardRouting().shardId());, +                if (maybe != null && maybe.isSameAllocation(task.getShardRouting())) {, +++ b/core/src/main/java/org/elasticsearch/action/admin/cluster/allocation/TransportClusterAllocationExplainAction.java, +        for (RoutingNode node : routingNodes) {, +++ b/core/src/main/java/org/elasticsearch/cluster/action/shard/ShardStateAction.java, +import org.elasticsearch.cluster.routing.RoutingNode;, +            RoutingNode routingNode = currentState.getRoutingNodes().node(task.getShardRouting().currentNodeId());, +            if (routingNode != null) {, +                ShardRouting maybe = routingNode.getByShardId(task.getShardRouting().shardId());, +                if (maybe != null && maybe.isSameAllocation(task.getShardRouting())) {, +++ b/core/src/main/java/org/elasticsearch/cluster/routing/IndexRoutingTable.java, +        public Builder addShard(ShardRouting shard) {, +                indexShard = new IndexShardRoutingTable.Builder(shard.shardId()).addShard(shard).build();, +++ b/core/src/main/java/org/elasticsearch/action/admin/cluster/allocation/TransportClusterAllocationExplainAction.java, +        for (RoutingNode node : routingNodes) {, +++ b/core/src/main/java/org/elasticsearch/cluster/action/shard/ShardStateAction.java, +import org.elasticsearch.cluster.routing.RoutingNode;, +            RoutingNode routingNode = currentState.getRoutingNodes().node(task.getShardRouting().currentNodeId());, +            if (routingNode != null) {, +                ShardRouting maybe = routingNode.getByShardId(task.getShardRouting().shardId());, +                if (maybe != null && maybe.isSameAllocation(task.getShardRouting())) {, +++ b/core/src/main/java/org/elasticsearch/cluster/routing/IndexRoutingTable.java, +        public Builder addShard(ShardRouting shard) {, +                indexShard = new IndexShardRoutingTable.Builder(shard.shardId()).addShard(shard).build();, +++ b/core/src/main/java/org/elasticsearch/cluster/routing/RoutingNode.java, +    void remove(ShardRouting shard) {, +        ShardRouting previousValue = shards.remove(shard.shardId());, +        assert previousValue == shard : "expected shard " + previousValue + " but was " + shard;, +    }, +, +++ b/core/src/main/java/org/elasticsearch/action/admin/cluster/allocation/TransportClusterAllocationExplainAction.java, +        for (RoutingNode node : routingNodes) {, +++ b/core/src/main/java/org/elasticsearch/cluster/action/shard/ShardStateAction.java, +import org.elasticsearch.cluster.routing.RoutingNode;, +            RoutingNode routingNode = currentState.getRoutingNodes().node(task.getShardRouting().currentNodeId());, +            if (routingNode != null) {, +                ShardRouting maybe = routingNode.getByShardId(task.getShardRouting().shardId());, +                if (maybe != null && maybe.isSameAllocation(task.getShardRouting())) {, +++ b/core/src/main/java/org/elasticsearch/cluster/routing/IndexRoutingTable.java, +        public Builder addShard(ShardRouting shard) {, +                indexShard = new IndexShardRoutingTable.Builder(shard.shardId()).addShard(shard).build();, +++ b/core/src/main/java/org/elasticsearch/cluster/routing/RoutingNode.java, +    void remove(ShardRouting shard) {, +        ShardRouting previousValue = shards.remove(shard.shardId());, +        assert previousValue == shard : "expected shard " + previousValue + " but was " + shard;, +    }, +, +++ b/core/src/main/java/org/elasticsearch/cluster/routing/RoutingNodes.java, +import org.elasticsearch.cluster.metadata.MetaData;, +        final RoutingTable routingTable = clusterState.routingTable();, +                            addInitialRecovery(targetShardRouting, routingTable);, +                            addInitialRecovery(shard, routingTable);, +        addRecovery(routing, true, null);, +        addRecovery(routing, false, null);, +    private void addInitialRecovery(ShardRouting routing, RoutingTable routingTable) {, +        addRecovery(routing, true, routingTable);, +    private void addRecovery(final ShardRouting routing, final boolean increment, final RoutingTable routingTable) {, +                for (ShardRouting assigned : assignedShards(routing.shardId())) {, +            if (primary == null && routingTable != null) {, +    public Iterator<RoutingNode> mutableIterator() {, +        return nodesToShards.values().iterator();, +     * Returns all shards that are not in the state UNASSIGNED with the same shard, +     * ID as the given shard., +     */, +    public List<ShardRouting> assignedShards(ShardId shardId) {, +        final List<ShardRouting> replicaSet = assignedShards.get(shardId);, +        return replicaSet == null ? EMPTY : Collections.unmodifiableList(replicaSet);, +    }, +, +    /**, +     * Returns the active primary shard for the given shard id or <code>null</code> if, +    public ShardRouting activePrimary(ShardId shardId) {, +        for (ShardRouting shardRouting : assignedShards(shardId)) {, +     * Returns one active replica shard for the given shard id or <code>null</code> if, +    public ShardRouting activeReplica(ShardId shardId) {, +        for (ShardRouting shardRouting : assignedShards(shardId)) {, +    public boolean allReplicasActive(ShardId shardId, MetaData metaData) {, +        final List<ShardRouting> shards = assignedShards(shardId);, +        if (shards.isEmpty() || shards.size() < metaData.getIndexSafe(shardId.getIndex()).getNumberOfReplicas() + 1) {, +        assert shard.initializing() : "expected an initializing shard " + shard;, +    public void remove(ShardRouting shard) {, +        assert shard.unassigned() == false : "only assigned shards can be removed here (" + shard + ")";, +        node(shard.currentNodeId()).remove(shard);, +        if (shard.initializing() && shard.relocatingNodeId() == null) {, +    /**, +     * Removes relocation source of an initializing non-primary shard. This allows the replica shard to continue recovery from, +     * the primary even though its non-primary relocation source has failed., +     */, +    public ShardRouting removeRelocationSource(ShardRouting shard) {, +        assert shard.isRelocationTarget() : "only relocation target shards can have their relocation source removed (" + shard + ")";, +        ensureMutable();, +        ShardRouting relocationMarkerRemoved = shard.removeRelocationSource();]