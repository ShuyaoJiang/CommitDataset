[+++ b/server/src/main/java/org/elasticsearch/persistent/PersistentTaskClusterService.java, +import org.elasticsearch.persistent.PersistentTasksInProgress.Assignment;, +                final Assignment assignment;, +                    assignment = PersistentTasksInProgress.FINISHED_TASK_ASSIGNMENT; // the task is stopped no need to assign it anywhere, +                    assignment = getAssignement(action, currentState, request);, +                return update(currentState, builder(currentState).addTask(action, request, stopped, removeOnCompletion, assignment));, +                        tasksInProgress.reassignTask(id, (action, request) -> getAssignement(action, currentState, request));, +                            .assignTask(id, (action, request) -> getAssignement(action, currentState, request)));, +    private <Request extends PersistentActionRequest> Assignment getAssignement(String action, ClusterState currentState, Request request) {, +        return persistentAction.getAssignment(request, currentState);, +            if (reassignmentRequired(event, this::getAssignement)) {, +        <Request extends PersistentActionRequest> Assignment getAssignment(String action, ClusterState currentState, Request request);, +                if (taskInProgress.needsReassignment(event.state().nodes())) {, +                    if (Objects.equals(taskInProgress.getAssignment(),, +                            decider.getAssignment(taskInProgress.getAction(), event.state(), taskInProgress.getRequest())) == false) {, +, +                return reassignTasks(currentState, logger, PersistentTaskClusterService.this::getAssignement);, +                if (task.needsReassignment(nodes)) {, +                    Assignment assignment = decider.getAssignment(task.getAction(), clusterState, task.getRequest());, +                    if (Objects.equals(assignment, task.getAssignment()) == false) {, +                                task.getAssignment().getExecutorNode(), assignment.getExecutorNode());, +                        clusterState = update(clusterState, builder(clusterState).reassignTask(task.getId(), assignment));, +                        logger.trace("ignoring task {} because assignment is the same {}", task.getId(), assignment);, +++ b/server/src/main/java/org/elasticsearch/persistent/PersistentTaskClusterService.java, +import org.elasticsearch.persistent.PersistentTasksInProgress.Assignment;, +                final Assignment assignment;, +                    assignment = PersistentTasksInProgress.FINISHED_TASK_ASSIGNMENT; // the task is stopped no need to assign it anywhere, +                    assignment = getAssignement(action, currentState, request);, +                return update(currentState, builder(currentState).addTask(action, request, stopped, removeOnCompletion, assignment));, +                        tasksInProgress.reassignTask(id, (action, request) -> getAssignement(action, currentState, request));, +                            .assignTask(id, (action, request) -> getAssignement(action, currentState, request)));, +    private <Request extends PersistentActionRequest> Assignment getAssignement(String action, ClusterState currentState, Request request) {, +        return persistentAction.getAssignment(request, currentState);, +            if (reassignmentRequired(event, this::getAssignement)) {, +        <Request extends PersistentActionRequest> Assignment getAssignment(String action, ClusterState currentState, Request request);, +                if (taskInProgress.needsReassignment(event.state().nodes())) {, +                    if (Objects.equals(taskInProgress.getAssignment(),, +                            decider.getAssignment(taskInProgress.getAction(), event.state(), taskInProgress.getRequest())) == false) {, +, +                return reassignTasks(currentState, logger, PersistentTaskClusterService.this::getAssignement);, +                if (task.needsReassignment(nodes)) {, +                    Assignment assignment = decider.getAssignment(task.getAction(), clusterState, task.getRequest());, +                    if (Objects.equals(assignment, task.getAssignment()) == false) {, +                                task.getAssignment().getExecutorNode(), assignment.getExecutorNode());, +                        clusterState = update(clusterState, builder(clusterState).reassignTask(task.getId(), assignment));, +                        logger.trace("ignoring task {} because assignment is the same {}", task.getId(), assignment);, +++ b/server/src/main/java/org/elasticsearch/persistent/PersistentTasksInProgress.java, +import org.elasticsearch.cluster.node.DiscoveryNodes;, +import org.elasticsearch.common.xcontent.ConstructingObjectParser;, +import static org.elasticsearch.common.xcontent.ConstructingObjectParser.constructorArg;, +    public static final ConstructingObjectParser<Assignment, Void> ASSIGNMENT_PARSER =, +            new ConstructingObjectParser<>("assignment", objects -> new Assignment((String) objects[0], (String) objects[1]));, +, +        // Assignment parser, +        ASSIGNMENT_PARSER.declareStringOrNull(constructorArg(), new ParseField("executor_node"));, +        ASSIGNMENT_PARSER.declareStringOrNull(constructorArg(), new ParseField("explanation"));, +, +        PERSISTENT_TASK_IN_PROGRESS_PARSER.declareObject(TaskBuilder::setAssignment, ASSIGNMENT_PARSER, new ParseField("assignment"));, +        return tasks.values().stream().filter(task -> action.equals(task.action) && nodeId.equals(task.assignment.executorNode)).count();, +    public static class Assignment {, +        @Nullable, +        private final String executorNode;, +        private final String explanation;, +, +        public Assignment(String executorNode, String explanation) {, +            this.executorNode = executorNode;, +            assert explanation != null;, +            this.explanation = explanation;, +        }, +, +        @Nullable, +        public String getExecutorNode() {, +            return executorNode;, +        }, +, +        public String getExplanation() {, +            return explanation;, +        }, +, +        @Override, +        public boolean equals(Object o) {, +            if (this == o) return true;, +            if (o == null || getClass() != o.getClass()) return false;, +            Assignment that = (Assignment) o;, +            return Objects.equals(executorNode, that.executorNode) &&, +                    Objects.equals(explanation, that.explanation);, +        }, +, +        @Override, +        public int hashCode() {, +            return Objects.hash(executorNode, explanation);, +        }, +, +        public boolean isAssigned() {, +            return executorNode != null;, +        }, +, +        @Override, +        public String toString() {, +            return "node: [" + executorNode + "], explanation: [" + explanation +"]";]