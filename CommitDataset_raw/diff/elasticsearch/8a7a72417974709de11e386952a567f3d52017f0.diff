[+++ b/plugin/src/main/java/org/elasticsearch/xpack/ml/MlMetadata.java, +import org.elasticsearch.xpack.ml.job.groups.GroupOrJobLookup;, +    private final GroupOrJobLookup groupOrJobLookup;, +        this.groupOrJobLookup = new GroupOrJobLookup(jobs.values());, +        return groupOrJobLookup.expandJobIds(expression, allowNoJobs);, +, +        this.groupOrJobLookup = new GroupOrJobLookup(jobs.values());, +++ b/plugin/src/main/java/org/elasticsearch/xpack/ml/MlMetadata.java, +import org.elasticsearch.xpack.ml.job.groups.GroupOrJobLookup;, +    private final GroupOrJobLookup groupOrJobLookup;, +        this.groupOrJobLookup = new GroupOrJobLookup(jobs.values());, +        return groupOrJobLookup.expandJobIds(expression, allowNoJobs);, +, +        this.groupOrJobLookup = new GroupOrJobLookup(jobs.values());, +++ b/plugin/src/main/java/org/elasticsearch/xpack/ml/datafeed/DatafeedJobValidator.java, +, +        if (bucketSpanMillis % histogramIntervalMillis != 0) {, +            throw ExceptionsHelper.badRequestException(Messages.getMessage(, +                    Messages.DATAFEED_AGGREGATIONS_INTERVAL_MUST_BE_DIVISOR_OF_BUCKET_SPAN,, +                    TimeValue.timeValueMillis(histogramIntervalMillis).getStringRep(),, +                    TimeValue.timeValueMillis(bucketSpanMillis).getStringRep()));, +        }, +, +++ b/plugin/src/main/java/org/elasticsearch/xpack/ml/MlMetadata.java, +import org.elasticsearch.xpack.ml.job.groups.GroupOrJobLookup;, +    private final GroupOrJobLookup groupOrJobLookup;, +        this.groupOrJobLookup = new GroupOrJobLookup(jobs.values());, +        return groupOrJobLookup.expandJobIds(expression, allowNoJobs);, +, +        this.groupOrJobLookup = new GroupOrJobLookup(jobs.values());, +++ b/plugin/src/main/java/org/elasticsearch/xpack/ml/datafeed/DatafeedJobValidator.java, +, +        if (bucketSpanMillis % histogramIntervalMillis != 0) {, +            throw ExceptionsHelper.badRequestException(Messages.getMessage(, +                    Messages.DATAFEED_AGGREGATIONS_INTERVAL_MUST_BE_DIVISOR_OF_BUCKET_SPAN,, +                    TimeValue.timeValueMillis(histogramIntervalMillis).getStringRep(),, +                    TimeValue.timeValueMillis(bucketSpanMillis).getStringRep()));, +        }, +, +++ b/plugin/src/main/java/org/elasticsearch/xpack/ml/datafeed/extractor/aggregation/AggregationDataExtractor.java, +        long histogramSearchStartTime = Math.max(0, context.start - getHistogramInterval());, +++ b/plugin/src/main/java/org/elasticsearch/xpack/ml/MlMetadata.java, +import org.elasticsearch.xpack.ml.job.groups.GroupOrJobLookup;, +    private final GroupOrJobLookup groupOrJobLookup;, +        this.groupOrJobLookup = new GroupOrJobLookup(jobs.values());, +        return groupOrJobLookup.expandJobIds(expression, allowNoJobs);, +, +        this.groupOrJobLookup = new GroupOrJobLookup(jobs.values());, +++ b/plugin/src/main/java/org/elasticsearch/xpack/ml/datafeed/DatafeedJobValidator.java, +, +        if (bucketSpanMillis % histogramIntervalMillis != 0) {, +            throw ExceptionsHelper.badRequestException(Messages.getMessage(, +                    Messages.DATAFEED_AGGREGATIONS_INTERVAL_MUST_BE_DIVISOR_OF_BUCKET_SPAN,, +                    TimeValue.timeValueMillis(histogramIntervalMillis).getStringRep(),, +                    TimeValue.timeValueMillis(bucketSpanMillis).getStringRep()));, +        }, +, +++ b/plugin/src/main/java/org/elasticsearch/xpack/ml/datafeed/extractor/aggregation/AggregationDataExtractor.java, +        long histogramSearchStartTime = Math.max(0, context.start - getHistogramInterval());, +++ b/plugin/src/main/java/org/elasticsearch/xpack/ml/job/config/Job.java, +import java.util.Collections;, +    public static final ParseField GROUPS = new ParseField("groups");, +            parser.declareStringArray(Builder::setGroups, GROUPS);, +    private final List<String> groups;, +    private Job(String jobId, String jobType, Version jobVersion, List<String> groups, String description, Date createTime,, +        this.groups = groups;, +        if (in.getVersion().onOrAfter(Version.V_6_1_0)) {, +            groups = in.readList(StreamInput::readString);, +        } else {, +            groups = Collections.emptyList();, +        }, +    public List<String> getGroups() {, +        return groups;, +    }, +, +        if (out.getVersion().onOrAfter(Version.V_6_1_0)) {, +            out.writeStringList(groups);, +        }, +        if (groups.isEmpty() == false) {, +            builder.field(GROUPS.getPreferredName(), groups);, +        }, +                && Objects.equals(this.groups, that.groups), +        return Objects.hash(jobId, jobType, jobVersion, groups, description, createTime, finishedTime, lastDataTime, analysisConfig,, +        private List<String> groups = Collections.emptyList();, +            this.groups = job.getGroups();, +            if (in.getVersion().onOrAfter(Version.V_6_1_0)) {, +                groups = in.readList(StreamInput::readString);, +            } else {, +                groups = Collections.emptyList();, +            }, +        public void setGroups(List<String> groups) {, +            this.groups = groups == null ? Collections.emptyList() : groups;, +            for (String group : this.groups) {, +                if (MlStrings.isValidId(group) == false) {, +                    throw new IllegalArgumentException(Messages.getMessage(Messages.INVALID_GROUP, group));, +                }, +            }, +        }, +, +            if (out.getVersion().onOrAfter(Version.V_6_1_0)) {]