[+++ b/core/src/main/java/org/elasticsearch/common/path/PathTrie.java, +import java.util.ArrayList;, +import java.util.Arrays;, +import java.util.EnumSet;, +import java.util.HashSet;, +import java.util.Iterator;, +import java.util.List;, +import java.util.NoSuchElementException;, +import java.util.Set;, +import java.util.function.BiFunction;, +import java.util.function.Supplier;, +    enum TrieMatchingMode {, +        /*, +         * Retrieve only explicitly mapped nodes, no wildcards are, +         * matched., +         */, +        EXPLICIT_NODES_ONLY,, +        /*, +         * Retrieve only explicitly mapped nodes, with wildcards, +         * allowed as root nodes., +         */, +        WILDCARD_ROOT_NODES_ALLOWED,, +        /*, +         * Retrieve only explicitly mapped nodes, with wildcards, +         * allowed as leaf nodes., +         */, +        WILDCARD_LEAF_NODES_ALLOWED,, +        /*, +         * Retrieve both explicitly mapped and wildcard nodes., +         */, +        WILDCARD_NODES_ALLOWED, +    }, +, +    static EnumSet<TrieMatchingMode> EXPLICIT_OR_ROOT_WILDCARD =, +            EnumSet.of(TrieMatchingMode.EXPLICIT_NODES_ONLY, TrieMatchingMode.WILDCARD_ROOT_NODES_ALLOWED);, +, +                /*, +                 * If the target node already exists, but is without a value,, +                 *  then the value should be updated., +                 */, +                    } else {, +        public synchronized void insertOrUpdate(String[] path, int index, T value, BiFunction<T, T, T> updater) {, +            if (index >= path.length), +                return;, +, +            String token = path[index];, +            String key = token;, +            if (isNamedWildcard(token)) {, +                key = wildcard;, +            }, +            TrieNode node = children.get(key);, +            if (node == null) {, +                T nodeValue = index == path.length - 1 ? value : null;, +                node = new TrieNode(token, nodeValue, wildcard);, +                addInnerChild(key, node);, +            } else {, +                if (isNamedWildcard(token)) {, +                    node.updateKeyWithNamedWildcard(token);, +                }, +                /*, +                 * If the target node already exists, but is without a value,, +                 *  then the value should be updated., +                 */, +                if (index == (path.length - 1)) {, +                    if (node.value != null) {, +                        node.value = updater.apply(node.value, value);, +                    } else {, +                        node.value = value;, +                    }, +                }, +            }, +, +            node.insertOrUpdate(path, index + 1, value, updater);, +        }, +, +        public T retrieve(String[] path, int index, Map<String, String> params, TrieMatchingMode trieMatchingMode) {, +, +                if (trieMatchingMode == TrieMatchingMode.WILDCARD_NODES_ALLOWED) {, +                    node = children.get(wildcard);, +                    if (node == null) {, +                        return null;, +                    }, +                    usedWildcard = true;, +                } else if (trieMatchingMode == TrieMatchingMode.WILDCARD_ROOT_NODES_ALLOWED && index == 1) {, +                    /*, +                     * Allow root node wildcard matches., +                     */, +                    node = children.get(wildcard);, +                    if (node == null) {, +                        return null;, +                    }, +                    usedWildcard = true;, +                } else if (trieMatchingMode == TrieMatchingMode.WILDCARD_LEAF_NODES_ALLOWED && index + 1 == path.length) {, +                    /*, +                     * Allow leaf node wildcard matches., +                     */, +                    return null;, +                }, +            } else {, +                if (index + 1 == path.length && node.value == null && children.get(wildcard) != null]