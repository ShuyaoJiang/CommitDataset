[+++ b/buildSrc/src/main/groovy/org/elasticsearch/gradle/AntTask.groovy, +        // otherwise groovy replaces System.out, and you have no chance to debug, +        // ant.saveStreams = false, +, +++ b/buildSrc/src/main/groovy/org/elasticsearch/gradle/AntTask.groovy, +        // otherwise groovy replaces System.out, and you have no chance to debug, +        // ant.saveStreams = false, +, +++ b/buildSrc/src/main/groovy/org/elasticsearch/gradle/BuildPlugin.groovy, +        // we are not shipping these jars, we act like dumb consumers of these things, +        if (project.path.startsWith(':test:fixtures')) {, +            return, +        }, +            if (configuration.name.endsWith('Fixture')) {, +                // just a self contained test-fixture configuration, likely transitive and hellacious, +                return, +            }, +++ b/buildSrc/src/main/groovy/org/elasticsearch/gradle/AntTask.groovy, +        // otherwise groovy replaces System.out, and you have no chance to debug, +        // ant.saveStreams = false, +, +++ b/buildSrc/src/main/groovy/org/elasticsearch/gradle/BuildPlugin.groovy, +        // we are not shipping these jars, we act like dumb consumers of these things, +        if (project.path.startsWith(':test:fixtures')) {, +            return, +        }, +            if (configuration.name.endsWith('Fixture')) {, +                // just a self contained test-fixture configuration, likely transitive and hellacious, +                return, +            }, +++ b/buildSrc/src/main/groovy/org/elasticsearch/gradle/precommit/ThirdPartyAuditTask.groovy, +package org.elasticsearch.gradle.precommit;, +import org.apache.tools.ant.BuildEvent;, +import org.apache.tools.ant.BuildException;, +import org.apache.tools.ant.BuildListener;, +import org.apache.tools.ant.BuildLogger;, +import org.apache.tools.ant.DefaultLogger;, +import org.apache.tools.ant.Project;, +import org.elasticsearch.gradle.AntTask;, +import org.gradle.api.artifacts.Configuration;, +import org.gradle.api.file.FileCollection;, +import java.nio.file.FileVisitResult;, +import java.nio.file.Files;, +import java.nio.file.Path;, +import java.nio.file.SimpleFileVisitor;, +import java.nio.file.attribute.BasicFileAttributes;, +import java.util.regex.Matcher;, +import java.util.regex.Pattern;, +        // we depend on this because its the only reliable configuration, +        // this probably makes the build slower: gradle you suck here when it comes to configurations, you pay the price., +        dependsOn(project.configurations.testCompile);, +        description = "Checks third party JAR bytecode for missing classes, use of internal APIs, and other horrors'";, +                throw new IllegalArgumentException("illegal third party audit exclusion: '" + s + "', wildcards are not permitted!");, +    // yes, we parse Uwe Schindler's errors to find missing classes, and to keep a continuous audit. Just don't let him know!, +    static final Pattern MISSING_CLASS_PATTERN =, +        Pattern.compile(/WARNING: The referenced class '(.*)' cannot be loaded\. Please fix the classpath\!/);, +        , +    static final Pattern VIOLATION_PATTERN = , +        Pattern.compile(/\s\sin ([a-zA-Z0-9\$\.]+) \(.*\)/);, +, +    // we log everything and capture errors and handle them with our whitelist, +    // this is important, as we detect stale whitelist entries, workaround forbidden apis bugs,, +    // and it also allows whitelisting missing classes!, +    static class EvilLogger extends DefaultLogger {, +        final Set<String> missingClasses = new TreeSet<>();, +        final Map<String,List<String>> violations = new TreeMap<>();, +        String previousLine = null;, +, +        @Override, +        public void messageLogged(BuildEvent event) {, +            if (event.getTask().getClass() == de.thetaphi.forbiddenapis.ant.AntTask.class) {, +                if (event.getPriority() == Project.MSG_WARN) {, +                    Matcher m = MISSING_CLASS_PATTERN.matcher(event.getMessage());, +                    if (m.matches()) {, +                        missingClasses.add(m.group(1).replace('.', '/') + ".class");, +                    }, +                } else if (event.getPriority() == Project.MSG_ERR) {, +                    Matcher m = VIOLATION_PATTERN.matcher(event.getMessage());, +                    if (m.matches()) {, +                        String violation = previousLine + '\n' + event.getMessage();, +                        String clazz = m.group(1).replace('.', '/') + ".class";, +                        List<String> current = violations.get(clazz);, +                        if (current == null) {, +                            current = new ArrayList<>();, +                            violations.put(clazz, current);, +                        }, +                        current.add(violation);, +                    }, +                    previousLine = event.getMessage();, +                }, +            }, +            super.messageLogged(event);, +        }, +    }, +, +        DefaultLogger log = new EvilLogger();, +        log.errorPrintStream = stream;, +        log.outputPrintStream = stream;, +        log.messageOutputLevel = outputLevel;, +        return log;]