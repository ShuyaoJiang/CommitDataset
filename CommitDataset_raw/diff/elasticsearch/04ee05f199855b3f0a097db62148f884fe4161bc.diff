[+++ b/x-pack/plugin/watcher/src/main/java/org/elasticsearch/xpack/watcher/notification/NotificationService.java, +import org.apache.logging.log4j.LogManager;, +import org.apache.logging.log4j.Logger;, +import org.elasticsearch.common.Nullable;, +import org.elasticsearch.common.settings.SecureSettings;, +import org.elasticsearch.common.settings.SecureString;, +import java.io.IOException;, +import java.io.InputStream;, +import java.security.GeneralSecurityException;, +import java.util.Set;, +    private final Logger logger;, +    private final Settings bootSettings;, +    private final List<Setting<?>> pluginSecureSettings;, +    // all are guarded by this, +    private volatile Map<String, Account> accounts;, +    private volatile Account defaultAccount;, +    // cached cluster setting, required when recreating the notification clients, +    // using the new "reloaded" secure settings, +    private volatile Settings cachedClusterSettings;, +    // cached secure settings, required when recreating the notification clients, +    // using the new updated cluster settings, +    private volatile SecureSettings cachedSecureSettings;, +    public NotificationService(String type, Settings settings, ClusterSettings clusterSettings, List<Setting<?>> pluginDynamicSettings,, +            List<Setting<?>> pluginSecureSettings) {, +        this(type, settings, pluginSecureSettings);, +        // register a grand updater for the whole group, as settings are usable together, +        clusterSettings.addSettingsUpdateConsumer(this::clusterSettingsConsumer, pluginDynamicSettings);, +    NotificationService(String type, Settings settings, List<Setting<?>> pluginSecureSettings) {, +        this.logger = LogManager.getLogger();, +        this.bootSettings = settings;, +        this.pluginSecureSettings = pluginSecureSettings;, +    }, +, +    private synchronized void clusterSettingsConsumer(Settings settings) {, +        // update cached cluster settings, +        this.cachedClusterSettings = settings;, +        // use these new dynamic cluster settings together with the previously cached, +        // secure settings, +        buildAccounts();, +        // `SecureSettings` are available here! cache them as they will be needed, +        // whenever dynamic cluster settings change and we have to rebuild the accounts, +        try {, +            this.cachedSecureSettings = extractSecureSettings(settings, pluginSecureSettings);, +        } catch (GeneralSecurityException e) {, +            logger.error("Keystore exception while reloading watcher notification service", e);, +            return;, +        }, +        // use these new secure settings together with the previously cached dynamic, +        // cluster settings, +        buildAccounts();, +    }, +, +    private void buildAccounts() {, +        // build complete settings combining cluster and secure settings, +        final Settings.Builder completeSettingsBuilder = Settings.builder().put(bootSettings, false);, +        if (this.cachedClusterSettings != null) {, +            completeSettingsBuilder.put(this.cachedClusterSettings, false);, +        }, +        if (this.cachedSecureSettings != null) {, +            completeSettingsBuilder.setSecureSettings(this.cachedSecureSettings);, +        }, +        final Settings completeSettings = completeSettingsBuilder.build();, +        // obtain account names and create accounts, +        final Set<String> accountNames = getAccountNames(completeSettings);, +        this.accounts = createAccounts(completeSettings, accountNames, this::createAccount);, +        this.defaultAccount = findDefaultAccountOrNull(completeSettings, this.accounts);, +    private String getNotificationsAccountPrefix() {, +        return "xpack.notification." + type + ".account.";, +    private Set<String> getAccountNames(Settings settings) {, +        // secure settings are not responsible for the client names, +        final Settings noSecureSettings = Settings.builder().put(settings, false).build();, +        return noSecureSettings.getByPrefix(getNotificationsAccountPrefix()).names();, +    }, +, +    private @Nullable String getDefaultAccountName(Settings settings) {, +        return settings.get("xpack.notification." + type + ".default_account");, +    }, +, +    private Map<String, Account> createAccounts(Settings settings, Set<String> accountNames,, +            BiFunction<String, Settings, Account> accountFactory) {, +        final Map<String, Account> accounts = new HashMap<>();, +        for (final String accountName : accountNames) {, +            final Settings accountSettings = settings.getAsSettings(getNotificationsAccountPrefix() + accountName);, +            final Account account = accountFactory.apply(accountName, accountSettings);, +            accounts.put(accountName, account);, +        }, +        return Collections.unmodifiableMap(accounts);, +    }, +, +    private @Nullable Account findDefaultAccountOrNull(Settings settings, Map<String, Account> accounts) {, +        final String defaultAccountName = getDefaultAccountName(settings);, +                return null;, +                return accounts.values().iterator().next();, +            final Account account = accounts.get(defaultAccountName);, +            if (account == null) {, +            return account;, +    }, +, +    /**, +     * Extracts the {@link SecureSettings}` out of the passed in {@link Settings} object. The {@code Setting} argument has to have the]