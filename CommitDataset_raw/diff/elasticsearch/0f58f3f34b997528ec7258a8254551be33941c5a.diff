[+++ b/buildSrc/src/main/resources/checkstyle_suppressions.xml, +++ b/buildSrc/src/main/resources/checkstyle_suppressions.xml, +++ b/core/src/main/java/org/elasticsearch/ElasticsearchException.java, +import static org.elasticsearch.common.xcontent.XContentParserUtils.ensureFieldName;, +        ElasticsearchException e = new ElasticsearchException(buildMessage(type, reason, stack), cause);, +     * This method is usually used when the {@link Exception} is rendered as a full XContent object, and its output can be parsed, +     * by the {@link #failureFromXContent(XContentParser)} method., +     * Parses the output of {@link #generateFailureXContent(XContentBuilder, Params, Exception, boolean)}, +     */, +    public static ElasticsearchException failureFromXContent(XContentParser parser) throws IOException {, +        XContentParser.Token token = parser.nextToken();, +        ensureFieldName(parser, token, ERROR);, +, +        token = parser.nextToken();, +        if (token.isValue()) {, +            return new ElasticsearchException(buildMessage("exception", parser.text(), null));, +        }, +, +        ensureExpectedToken(token, XContentParser.Token.START_OBJECT, parser::getTokenLocation);, +        token = parser.nextToken();, +, +        // TODO Root causes are ignored for now. They will be skipped by innerFromXContent() because, +        // it ignores metadata arrays of objects. If we decide to parse root causes, we'll have to, +        // change innerFromXContent() so that it does not parse root causes on its own., +        return innerFromXContent(parser);, +    }, +, +    /**, +    static String buildMessage(String type, String reason, String stack) {, +        StringBuilder message = new StringBuilder("Elasticsearch exception [");, +        message.append(TYPE).append('=').append(type).append(", ");, +        message.append(REASON).append('=').append(reason);, +        if (stack != null) {, +            message.append(", ").append(STACK_TRACE).append('=').append(stack);, +        }, +        message.append(']');, +        return message.toString();, +    }, +, +++ b/buildSrc/src/main/resources/checkstyle_suppressions.xml, +++ b/core/src/main/java/org/elasticsearch/ElasticsearchException.java, +import static org.elasticsearch.common.xcontent.XContentParserUtils.ensureFieldName;, +        ElasticsearchException e = new ElasticsearchException(buildMessage(type, reason, stack), cause);, +     * This method is usually used when the {@link Exception} is rendered as a full XContent object, and its output can be parsed, +     * by the {@link #failureFromXContent(XContentParser)} method., +     * Parses the output of {@link #generateFailureXContent(XContentBuilder, Params, Exception, boolean)}, +     */, +    public static ElasticsearchException failureFromXContent(XContentParser parser) throws IOException {, +        XContentParser.Token token = parser.nextToken();, +        ensureFieldName(parser, token, ERROR);, +, +        token = parser.nextToken();, +        if (token.isValue()) {, +            return new ElasticsearchException(buildMessage("exception", parser.text(), null));, +        }, +, +        ensureExpectedToken(token, XContentParser.Token.START_OBJECT, parser::getTokenLocation);, +        token = parser.nextToken();, +, +        // TODO Root causes are ignored for now. They will be skipped by innerFromXContent() because, +        // it ignores metadata arrays of objects. If we decide to parse root causes, we'll have to, +        // change innerFromXContent() so that it does not parse root causes on its own., +        return innerFromXContent(parser);, +    }, +, +    /**, +    static String buildMessage(String type, String reason, String stack) {, +        StringBuilder message = new StringBuilder("Elasticsearch exception [");, +        message.append(TYPE).append('=').append(type).append(", ");, +        message.append(REASON).append('=').append(reason);, +        if (stack != null) {, +            message.append(", ").append(STACK_TRACE).append('=').append(stack);, +        }, +        message.append(']');, +        return message.toString();, +    }, +, +++ b/core/src/main/java/org/elasticsearch/action/admin/cluster/node/tasks/cancel/TransportCancelTasksAction.java, +        String nodeId = clusterService.localNode().getId();, +        final boolean canceled;, +        if (cancellableTask.shouldCancelChildrenOnCancellation()) {, +            canceled = taskManager.cancel(cancellableTask, request.getReason(), banLock::onTaskFinished);, +            canceled = taskManager.cancel(cancellableTask, request.getReason(),, +                () -> listener.onResponse(cancellableTask.taskInfo(nodeId, false)));, +            if (canceled) {, +                logger.trace("task {} doesn't have any children that should be cancelled", cancellableTask.getId());, +            }, +        }, +        if (canceled == false) {, +, +++ b/buildSrc/src/main/resources/checkstyle_suppressions.xml, +++ b/core/src/main/java/org/elasticsearch/ElasticsearchException.java, +import static org.elasticsearch.common.xcontent.XContentParserUtils.ensureFieldName;, +        ElasticsearchException e = new ElasticsearchException(buildMessage(type, reason, stack), cause);, +     * This method is usually used when the {@link Exception} is rendered as a full XContent object, and its output can be parsed, +     * by the {@link #failureFromXContent(XContentParser)} method., +     * Parses the output of {@link #generateFailureXContent(XContentBuilder, Params, Exception, boolean)}, +     */, +    public static ElasticsearchException failureFromXContent(XContentParser parser) throws IOException {, +        XContentParser.Token token = parser.nextToken();]