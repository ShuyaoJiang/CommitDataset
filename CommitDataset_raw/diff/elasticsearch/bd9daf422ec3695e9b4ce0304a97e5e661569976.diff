[+++ b/core/src/main/java/org/elasticsearch/snapshots/SnapshotException.java, +++ b/core/src/main/java/org/elasticsearch/snapshots/SnapshotException.java, +++ b/core/src/main/java/org/elasticsearch/snapshots/SnapshotMissingException.java, +++ b/core/src/main/java/org/elasticsearch/snapshots/SnapshotException.java, +++ b/core/src/main/java/org/elasticsearch/snapshots/SnapshotMissingException.java, +++ b/core/src/main/java/org/elasticsearch/snapshots/SnapshotShardsService.java, +import org.apache.lucene.util.SetOnce;, +import static org.elasticsearch.transport.EmptyTransportResponseHandler.INSTANCE_SAME;, +            SnapshotsInProgress previousSnapshots = event.previousState().custom(SnapshotsInProgress.TYPE);, +            SnapshotsInProgress currentSnapshots = event.state().custom(SnapshotsInProgress.TYPE);, +            if ((previousSnapshots == null && currentSnapshots != null), +                || (previousSnapshots != null && previousSnapshots.equals(currentSnapshots) == false)) {, +, +            String previousMasterNodeId = event.previousState().nodes().getMasterNodeId();, +            String currentMasterNodeId = event.state().nodes().getMasterNodeId();, +            if (currentMasterNodeId != null && currentMasterNodeId.equals(previousMasterNodeId) == false) {, +                                        logger.debug("[{}] trying to cancel snapshot on shard [{}] that is finalizing, " +, +                                                     "letting it finish", entry.snapshot(), shard.key);, +                                        logger.debug("[{}] trying to cancel snapshot on the shard [{}] that is already done, " +, +                                                     "updating status on the master", entry.snapshot(), shard.key);, +                                        notifySuccessfulSnapshotShard(entry.snapshot(), shard.key, localNodeId);, +                                        logger.debug("[{}] trying to cancel snapshot on the shard [{}] that has already failed, " +, +                                                     "updating status on the master", entry.snapshot(), shard.key);, +                                        notifyFailedSnapshotShard(entry.snapshot(), shard.key, localNodeId, snapshotStatus.failure());, +                final Snapshot snapshot = entry.getKey();, +                final Map<String, IndexId> indicesMap = snapshotIndices.get(snapshot);, +, +, +                        final SetOnce<Exception> failure = new SetOnce<>();, +, +                            snapshot(indexShard, snapshot, indexId, shardEntry.getValue());, +                            logger.warn((Supplier<?>) () ->, +                                new ParameterizedMessage("[{}][{}] failed to snapshot shard", shardId, snapshot), e);, +                            failure.set(e);, +                        @Override, +                        public void onRejection(Exception e) {, +                            failure.set(e);, +, +                        @Override, +                        public void onAfter() {, +                            final Exception exception = failure.get();, +                            if (exception != null) {, +                                notifyFailedSnapshotShard(snapshot, shardId, localNodeId, ExceptionsHelper.detailedMessage(exception));, +                            } else {, +                                notifySuccessfulSnapshotShard(snapshot, shardId, localNodeId);, +                            }, +                        }, +                    });, +        final ShardId shardId = indexShard.shardId();, +        if (indexShard.routingEntry().primary() == false) {, +, +        final IndexShardState indexShardState = indexShard.state();, +        if (indexShardState == IndexShardState.CREATED || indexShardState == IndexShardState.RECOVERING) {, +        final Repository repository = snapshotsService.getRepositoriesService().repository(snapshot.getRepository());, +                    StringBuilder details = new StringBuilder();, +                    details.append("    index    : version [").append(snapshotStatus.indexVersion());, +                    details.append("], number_of_files [").append(snapshotStatus.numberOfFiles());, +                    details.append("] with total_size [").append(new ByteSizeValue(snapshotStatus.totalSize())).append("]\n");, +                        TimeValue.timeValueMillis(snapshotStatus.time()), details);, +        } catch (SnapshotFailedEngineException | IndexShardSnapshotFailedException e) {, +, +                                logger.debug("[{}] new master thinks the shard [{}] is not completed but the shard is done locally, " +, +                                             "updating status on the master", snapshot.snapshot(), shardId);, +                                notifySuccessfulSnapshotShard(snapshot.snapshot(), shardId, localNodeId);, +, +                                logger.debug("[{}] new master thinks the shard [{}] is not completed but the shard failed locally, " +, +                                             "updating status on master", snapshot.snapshot(), shardId);, +                                notifyFailedSnapshotShard(snapshot.snapshot(), shardId, localNodeId, localShardStatus.failure());, +    /** Notify the master node that the given shard has been successfully snapshotted **/, +    void notifySuccessfulSnapshotShard(final Snapshot snapshot, final ShardId shardId, final String localNodeId) {, +        sendSnapshotShardUpdate(snapshot, shardId, new ShardSnapshotStatus(localNodeId, State.SUCCESS));, +    }, +, +    /** Notify the master node that the given shard failed to be snapshotted **/, +    void notifyFailedSnapshotShard(final Snapshot snapshot, final ShardId shardId, final String localNodeId, final String failure) {, +        sendSnapshotShardUpdate(snapshot, shardId, new ShardSnapshotStatus(localNodeId, State.FAILED, failure));, +    }, +, +    /** Updates the shard snapshot status by sending a {@link UpdateIndexShardSnapshotStatusRequest} to the master node */, +    void sendSnapshotShardUpdate(final Snapshot snapshot, final ShardId shardId, final ShardSnapshotStatus status) {, +            transportService.sendRequest(transportService.getLocalNode(), UPDATE_SNAPSHOT_STATUS_ACTION_NAME, request, INSTANCE_SAME);, +++ b/core/src/main/java/org/elasticsearch/snapshots/SnapshotException.java, +++ b/core/src/main/java/org/elasticsearch/snapshots/SnapshotMissingException.java, +++ b/core/src/main/java/org/elasticsearch/snapshots/SnapshotShardsService.java, +import org.apache.lucene.util.SetOnce;, +import static org.elasticsearch.transport.EmptyTransportResponseHandler.INSTANCE_SAME;, +            SnapshotsInProgress previousSnapshots = event.previousState().custom(SnapshotsInProgress.TYPE);, +            SnapshotsInProgress currentSnapshots = event.state().custom(SnapshotsInProgress.TYPE);, +            if ((previousSnapshots == null && currentSnapshots != null), +                || (previousSnapshots != null && previousSnapshots.equals(currentSnapshots) == false)) {, +, +            String previousMasterNodeId = event.previousState().nodes().getMasterNodeId();, +            String currentMasterNodeId = event.state().nodes().getMasterNodeId();, +            if (currentMasterNodeId != null && currentMasterNodeId.equals(previousMasterNodeId) == false) {, +                                        logger.debug("[{}] trying to cancel snapshot on shard [{}] that is finalizing, " +, +                                                     "letting it finish", entry.snapshot(), shard.key);, +                                        logger.debug("[{}] trying to cancel snapshot on the shard [{}] that is already done, " +, +                                                     "updating status on the master", entry.snapshot(), shard.key);, +                                        notifySuccessfulSnapshotShard(entry.snapshot(), shard.key, localNodeId);, +                                        logger.debug("[{}] trying to cancel snapshot on the shard [{}] that has already failed, " +]