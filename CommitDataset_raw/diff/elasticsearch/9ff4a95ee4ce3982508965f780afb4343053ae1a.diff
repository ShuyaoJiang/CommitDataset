[+++ b/modules/elasticsearch/src/main/java/org/elasticsearch/action/admin/cluster/settings/TransportClusterUpdateSettingsAction.java, +import org.elasticsearch.cluster.ProcessedClusterStateUpdateTask;, +        clusterService.submitStateUpdateTask("cluster_update_settings", new ProcessedClusterStateUpdateTask() {, +                    return ClusterState.builder().state(currentState).metaData(metaData).build();, +                } catch (Exception e) {, +                    latch.countDown();, +                    logger.warn("failed to update cluster settings", e);, +                    return currentState;, +                } finally {, +                    // we don't release the latch here, only after we rerouted, +                }, +            }, +            @Override public void clusterStateProcessed(ClusterState clusterState) {, +                // now, reroute, +                clusterService.submitStateUpdateTask("reroute_after_cluster_update_settings", new ClusterStateUpdateTask() {, +                    @Override public ClusterState execute(ClusterState currentState) {, +                        try {, +                            RoutingAllocation.Result routingResult = allocationService.reroute(currentState);, +                            return newClusterStateBuilder().state(currentState).routingResult(routingResult).build();, +            }, +        });, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/action/admin/cluster/settings/TransportClusterUpdateSettingsAction.java, +import org.elasticsearch.cluster.ProcessedClusterStateUpdateTask;, +        clusterService.submitStateUpdateTask("cluster_update_settings", new ProcessedClusterStateUpdateTask() {, +                    return ClusterState.builder().state(currentState).metaData(metaData).build();, +                } catch (Exception e) {, +                    latch.countDown();, +                    logger.warn("failed to update cluster settings", e);, +                    return currentState;, +                } finally {, +                    // we don't release the latch here, only after we rerouted, +                }, +            }, +            @Override public void clusterStateProcessed(ClusterState clusterState) {, +                // now, reroute, +                clusterService.submitStateUpdateTask("reroute_after_cluster_update_settings", new ClusterStateUpdateTask() {, +                    @Override public ClusterState execute(ClusterState currentState) {, +                        try {, +                            RoutingAllocation.Result routingResult = allocationService.reroute(currentState);, +                            return newClusterStateBuilder().state(currentState).routingResult(routingResult).build();, +            }, +        });, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/cluster/node/DiscoveryNodeFilters.java, +                    if (Regex.simpleMatch(value, inetAddress.address().getAddress().getHostAddress())) {, +                        return true;, +                    }, +                }, +            } else if ("_id".equals(attr)) {, +                for (String value : values) {, +                    if (node.id().equals(value)) {, +                        return true;, +                return false;, +            } else if ("_name".equals(attr)) {, +                for (String value : values) {, +                    if (Regex.simpleMatch(value, node.name())) {, +                        return true;, +                    }, +                }, +                return false;, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/action/admin/cluster/settings/TransportClusterUpdateSettingsAction.java, +import org.elasticsearch.cluster.ProcessedClusterStateUpdateTask;, +        clusterService.submitStateUpdateTask("cluster_update_settings", new ProcessedClusterStateUpdateTask() {, +                    return ClusterState.builder().state(currentState).metaData(metaData).build();, +                } catch (Exception e) {, +                    latch.countDown();, +                    logger.warn("failed to update cluster settings", e);, +                    return currentState;, +                } finally {, +                    // we don't release the latch here, only after we rerouted, +                }, +            }, +            @Override public void clusterStateProcessed(ClusterState clusterState) {, +                // now, reroute, +                clusterService.submitStateUpdateTask("reroute_after_cluster_update_settings", new ClusterStateUpdateTask() {, +                    @Override public ClusterState execute(ClusterState currentState) {, +                        try {, +                            RoutingAllocation.Result routingResult = allocationService.reroute(currentState);, +                            return newClusterStateBuilder().state(currentState).routingResult(routingResult).build();, +            }, +        });, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/cluster/node/DiscoveryNodeFilters.java, +                    if (Regex.simpleMatch(value, inetAddress.address().getAddress().getHostAddress())) {, +                        return true;, +                    }, +                }, +            } else if ("_id".equals(attr)) {, +                for (String value : values) {, +                    if (node.id().equals(value)) {, +                        return true;, +                return false;, +            } else if ("_name".equals(attr)) {, +                for (String value : values) {, +                    if (Regex.simpleMatch(value, node.name())) {, +                        return true;, +                    }, +                }, +                return false;, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/index/mapper/internal/TTLFieldMapper.java, +            long ttl = context.parser().longValue();, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/action/admin/cluster/settings/TransportClusterUpdateSettingsAction.java]