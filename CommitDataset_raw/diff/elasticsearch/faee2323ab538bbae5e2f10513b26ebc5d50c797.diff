[+++ b/modules/lang-painless/src/main/antlr/PainlessParser.g4, +    : decltype REF NEW, +++ b/modules/lang-painless/src/main/antlr/PainlessParser.g4, +    : decltype REF NEW, +++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/antlr/PainlessParser.java, +    public DecltypeContext decltype() {, +      return getRuleContext(DecltypeContext.class,0);, +    }, +      decltype();, +    "\2\u01cc\u01cd\7M\2\2\u01cd\67\3\2\2\2\u01ce\u01cf\5\26\f\2\u01cf\u01d0"+, +++ b/modules/lang-painless/src/main/antlr/PainlessParser.g4, +    : decltype REF NEW, +++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/antlr/PainlessParser.java, +    public DecltypeContext decltype() {, +      return getRuleContext(DecltypeContext.class,0);, +    }, +      decltype();, +    "\2\u01cc\u01cd\7M\2\2\u01cd\67\3\2\2\2\u01ce\u01cf\5\26\f\2\u01cf\u01d0"+, +++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/antlr/Walker.java, +import java.util.Arrays;, +    private final List<SFunction> synthetic = new ArrayList<>();, +        functions.addAll(synthetic);, +, +        return new SFunction((FunctionReserved)reserved.pop(), location(ctx), rtnType, name, paramTypes, paramNames, statements, false);, +        if (!ctx.decltype().LBRACE().isEmpty()) {, +            // array constructors are special: we need to make a synthetic method, +            // taking integer as argument and returning a new instance, and return a ref to that., +            Location location = location(ctx);, +            String arrayType = ctx.decltype().getText();, +            SReturn code = new SReturn(location, , +                           new EChain(location,, +                           new LNewArray(location, arrayType, Arrays.asList(, +                           new EChain(location, , +                           new LVariable(location, "size"))))));, +            String name = "lambda$" + synthetic.size();, +            synthetic.add(new SFunction(new FunctionReserved(), location, arrayType, name, , +                          Arrays.asList("int"), Arrays.asList("size"), Arrays.asList(code), true));, +            return new EFunctionRef(location(ctx), "this", name);, +        }, +        return new EFunctionRef(location(ctx), ctx.decltype().getText(), ctx.NEW().getText());, +++ b/modules/lang-painless/src/main/antlr/PainlessParser.g4, +    : decltype REF NEW, +++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/antlr/PainlessParser.java, +    public DecltypeContext decltype() {, +      return getRuleContext(DecltypeContext.class,0);, +    }, +      decltype();, +    "\2\u01cc\u01cd\7M\2\2\u01cd\67\3\2\2\2\u01ce\u01cf\5\26\f\2\u01cf\u01d0"+, +++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/antlr/Walker.java, +import java.util.Arrays;, +    private final List<SFunction> synthetic = new ArrayList<>();, +        functions.addAll(synthetic);, +, +        return new SFunction((FunctionReserved)reserved.pop(), location(ctx), rtnType, name, paramTypes, paramNames, statements, false);, +        if (!ctx.decltype().LBRACE().isEmpty()) {, +            // array constructors are special: we need to make a synthetic method, +            // taking integer as argument and returning a new instance, and return a ref to that., +            Location location = location(ctx);, +            String arrayType = ctx.decltype().getText();, +            SReturn code = new SReturn(location, , +                           new EChain(location,, +                           new LNewArray(location, arrayType, Arrays.asList(, +                           new EChain(location, , +                           new LVariable(location, "size"))))));, +            String name = "lambda$" + synthetic.size();, +            synthetic.add(new SFunction(new FunctionReserved(), location, arrayType, name, , +                          Arrays.asList("int"), Arrays.asList("size"), Arrays.asList(code), true));, +            return new EFunctionRef(location(ctx), "this", name);, +        }, +        return new EFunctionRef(location(ctx), ctx.decltype().getText(), ctx.NEW().getText());, +++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/EChain.java, +import java.util.Arrays;, +    /** Creates a new simple EChain */, +    public EChain(Location location, ALink link) {, +        this(location, Arrays.asList(link), false, false, null, null);, +    }, +, +++ b/modules/lang-painless/src/main/antlr/PainlessParser.g4, +    : decltype REF NEW, +++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/antlr/PainlessParser.java, +    public DecltypeContext decltype() {, +      return getRuleContext(DecltypeContext.class,0);, +    }, +      decltype();, +    "\2\u01cc\u01cd\7M\2\2\u01cd\67\3\2\2\2\u01ce\u01cf\5\26\f\2\u01cf\u01d0"+, +++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/antlr/Walker.java, +import java.util.Arrays;, +    private final List<SFunction> synthetic = new ArrayList<>();, +        functions.addAll(synthetic);, +, +        return new SFunction((FunctionReserved)reserved.pop(), location(ctx), rtnType, name, paramTypes, paramNames, statements, false);, +        if (!ctx.decltype().LBRACE().isEmpty()) {, +            // array constructors are special: we need to make a synthetic method, +            // taking integer as argument and returning a new instance, and return a ref to that., +            Location location = location(ctx);, +            String arrayType = ctx.decltype().getText();, +            SReturn code = new SReturn(location, , +                           new EChain(location,, +                           new LNewArray(location, arrayType, Arrays.asList(, +                           new EChain(location, ]