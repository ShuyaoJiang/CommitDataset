[+++ b/src/main/java/org/elasticsearch/cluster/routing/RoutingNode.java, +import org.elasticsearch.ElasticSearchIllegalStateException;, +        for (MutableShardRouting shardRouting : shards) {, +            if (shardRouting.shardId().equals(shard.shardId())) {, +                throw new ElasticSearchIllegalStateException("Trying to add a shard [" + shard.shardId().index().name() + "][" + shard.shardId().id() + "] to a node [" + nodeId + "] where it already exists");, +            }, +        }, +++ b/src/main/java/org/elasticsearch/cluster/routing/RoutingNode.java, +import org.elasticsearch.ElasticSearchIllegalStateException;, +        for (MutableShardRouting shardRouting : shards) {, +            if (shardRouting.shardId().equals(shard.shardId())) {, +                throw new ElasticSearchIllegalStateException("Trying to add a shard [" + shard.shardId().index().name() + "][" + shard.shardId().id() + "] to a node [" + nodeId + "] where it already exists");, +            }, +        }, +++ b/src/main/java/org/elasticsearch/cluster/routing/allocation/AllocationService.java, +import org.elasticsearch.ElasticSearchIllegalStateException;, +, +                            if (shardEntry2.relocatingNodeId() != null) {, +                                // its also relocating, make sure to move the other routing to primary, +                                RoutingNode node = routingNodes.node(shardEntry2.relocatingNodeId());, +                                if (node != null) {, +                                    for (MutableShardRouting shardRouting : node) {, +                                        if (shardRouting.shardId().equals(shardEntry2.shardId()) && !shardRouting.primary()) {, +                                            shardRouting.moveToPrimary();, +                                            break;, +                                        }, +                                    }, +                                }, +                            }, +, +                if (!shardRoutingEntry.assignedToNode()) {, +                    throw new ElasticSearchIllegalStateException(shardRoutingEntry.shardId() + " is not assigned to a node, but listed on as existing on node [" + routingNode.nodeId() + "]");, +                }, +, +        // now, go over shards that are initializing and recovering from primary shards that are now down..., +        for (RoutingNode routingNode : routingNodes) {, +            for (Iterator<MutableShardRouting> shardsIterator = routingNode.shards().iterator(); shardsIterator.hasNext(); ) {, +                MutableShardRouting shardRoutingEntry = shardsIterator.next();, +                if (!shardRoutingEntry.assignedToNode()) {, +                    throw new ElasticSearchIllegalStateException(shardRoutingEntry.shardId() + " is not assigned to a node, but listed on as existing on node [" + routingNode.nodeId() + "]");, +                }, +                // we always recover from primaries, so we care about replicas that are not primaries, +                if (shardRoutingEntry.primary()) {, +                    continue;, +                }, +                // if its not initializing, then its not recovering from the primary, +                if (!shardRoutingEntry.initializing()) {, +                    continue;, +                }, +                // its initializing because its relocating from another node (its replica recovering from another replica), +                if (shardRoutingEntry.relocatingNodeId() != null) {, +                    continue;, +                }, +                for (MutableShardRouting unassignedShardRouting : routingNodes.unassigned()) {, +                    // double check on the unassignedShardRouting.primary(), but it has to be a primary... (well, we double checked actually before...), +                    if (unassignedShardRouting.shardId().equals(shardRoutingEntry.shardId()) && unassignedShardRouting.primary()) {, +                        // remove it..., +                        routingNodes.unassigned().add(shardRoutingEntry);, +                        shardRoutingEntry.deassignNode();, +                        shardsIterator.remove();, +                        break;, +                    }, +                }, +            }, +        }, +, +++ b/src/main/java/org/elasticsearch/cluster/routing/RoutingNode.java, +import org.elasticsearch.ElasticSearchIllegalStateException;, +        for (MutableShardRouting shardRouting : shards) {, +            if (shardRouting.shardId().equals(shard.shardId())) {, +                throw new ElasticSearchIllegalStateException("Trying to add a shard [" + shard.shardId().index().name() + "][" + shard.shardId().id() + "] to a node [" + nodeId + "] where it already exists");, +            }, +        }, +++ b/src/main/java/org/elasticsearch/cluster/routing/allocation/AllocationService.java, +import org.elasticsearch.ElasticSearchIllegalStateException;, +, +                            if (shardEntry2.relocatingNodeId() != null) {, +                                // its also relocating, make sure to move the other routing to primary, +                                RoutingNode node = routingNodes.node(shardEntry2.relocatingNodeId());, +                                if (node != null) {, +                                    for (MutableShardRouting shardRouting : node) {, +                                        if (shardRouting.shardId().equals(shardEntry2.shardId()) && !shardRouting.primary()) {, +                                            shardRouting.moveToPrimary();, +                                            break;, +                                        }, +                                    }, +                                }, +                            }, +, +                if (!shardRoutingEntry.assignedToNode()) {, +                    throw new ElasticSearchIllegalStateException(shardRoutingEntry.shardId() + " is not assigned to a node, but listed on as existing on node [" + routingNode.nodeId() + "]");, +                }, +, +        // now, go over shards that are initializing and recovering from primary shards that are now down..., +        for (RoutingNode routingNode : routingNodes) {, +            for (Iterator<MutableShardRouting> shardsIterator = routingNode.shards().iterator(); shardsIterator.hasNext(); ) {, +                MutableShardRouting shardRoutingEntry = shardsIterator.next();, +                if (!shardRoutingEntry.assignedToNode()) {, +                    throw new ElasticSearchIllegalStateException(shardRoutingEntry.shardId() + " is not assigned to a node, but listed on as existing on node [" + routingNode.nodeId() + "]");, +                }]