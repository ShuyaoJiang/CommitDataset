[+++ b/core/src/main/java/org/elasticsearch/cluster/routing/allocation/allocator/BalancedShardsAllocator.java, +                    // don't use canRebalance as we want hard filtering rules to apply. See #17698, +                    if (allocationDecision.type() == Type.YES) { // TODO maybe we can respect throttling here too?, +++ b/core/src/main/java/org/elasticsearch/cluster/routing/allocation/allocator/BalancedShardsAllocator.java, +                    // don't use canRebalance as we want hard filtering rules to apply. See #17698, +                    if (allocationDecision.type() == Type.YES) { // TODO maybe we can respect throttling here too?, +++ b/core/src/main/java/org/elasticsearch/cluster/routing/allocation/decider/ThrottlingAllocationDecider.java, +            CLUSTER_ROUTING_ALLOCATION_NODE_CONCURRENT_RECOVERIES_SETTING::getRaw,, +            CLUSTER_ROUTING_ALLOCATION_NODE_CONCURRENT_RECOVERIES_SETTING::getRaw,, +++ b/core/src/main/java/org/elasticsearch/cluster/routing/allocation/allocator/BalancedShardsAllocator.java, +                    // don't use canRebalance as we want hard filtering rules to apply. See #17698, +                    if (allocationDecision.type() == Type.YES) { // TODO maybe we can respect throttling here too?, +++ b/core/src/main/java/org/elasticsearch/cluster/routing/allocation/decider/ThrottlingAllocationDecider.java, +            CLUSTER_ROUTING_ALLOCATION_NODE_CONCURRENT_RECOVERIES_SETTING::getRaw,, +            CLUSTER_ROUTING_ALLOCATION_NODE_CONCURRENT_RECOVERIES_SETTING::getRaw,, +++ b/core/src/test/java/org/elasticsearch/cluster/routing/allocation/FilterRoutingTests.java, +    public void testConcurrentRecoveriesAfterShardsCannotRemainOnNode() {, +                .put("cluster.routing.allocation.node_concurrent_recoveries", "1"), +        logger.info("--> check that concurrent recoveries only allows 1 shard to move");]