[+++ b/plugin/src/main/java/org/elasticsearch/xpack/upgrade/actions/IndexUpgradeAction.java, +        /**, +         * Should this task store its result?, +         */, +        private boolean shouldStoreResult;, +, +        /**, +         * Should this task store its result after it has finished?, +         */, +        public Request setShouldStoreResult(boolean shouldStoreResult) {, +            this.shouldStoreResult = shouldStoreResult;, +            return this;, +        }, +, +        @Override, +        public boolean getShouldStoreResult() {, +            return shouldStoreResult;, +        }, +++ b/plugin/src/main/java/org/elasticsearch/xpack/upgrade/actions/IndexUpgradeAction.java, +        /**, +         * Should this task store its result?, +         */, +        private boolean shouldStoreResult;, +, +        /**, +         * Should this task store its result after it has finished?, +         */, +        public Request setShouldStoreResult(boolean shouldStoreResult) {, +            this.shouldStoreResult = shouldStoreResult;, +            return this;, +        }, +, +        @Override, +        public boolean getShouldStoreResult() {, +            return shouldStoreResult;, +        }, +++ b/plugin/src/main/java/org/elasticsearch/xpack/upgrade/rest/RestIndexUpgradeAction.java, +import org.elasticsearch.action.ActionRequestValidationException;, +import org.elasticsearch.tasks.LoggingTaskListener;, +import org.elasticsearch.tasks.Task;, +        if (request.paramAsBoolean("wait_for_completion", true)) {, +        } else {, +            upgradeRequest.setShouldStoreResult(true);, +, +            /*, +             * Validating before forking to make sure we can catch the issues earlier, +             */, +            ActionRequestValidationException validationException = upgradeRequest.validate();, +            if (validationException != null) {, +                throw validationException;, +            }, +            Task task = client.executeLocally(IndexUpgradeAction.INSTANCE, upgradeRequest, LoggingTaskListener.instance());, +            // Send task description id instead of waiting for the message, +            return channel -> {, +                try (XContentBuilder builder = channel.newBuilder()) {, +                    builder.startObject();, +                    builder.field("task", client.getLocalNodeId() + ":" + task.getId());, +                    builder.endObject();, +                    channel.sendResponse(new BytesRestResponse(RestStatus.OK, builder));, +                }, +            };, +        }, +++ b/plugin/src/main/java/org/elasticsearch/xpack/upgrade/actions/IndexUpgradeAction.java, +        /**, +         * Should this task store its result?, +         */, +        private boolean shouldStoreResult;, +, +        /**, +         * Should this task store its result after it has finished?, +         */, +        public Request setShouldStoreResult(boolean shouldStoreResult) {, +            this.shouldStoreResult = shouldStoreResult;, +            return this;, +        }, +, +        @Override, +        public boolean getShouldStoreResult() {, +            return shouldStoreResult;, +        }, +++ b/plugin/src/main/java/org/elasticsearch/xpack/upgrade/rest/RestIndexUpgradeAction.java, +import org.elasticsearch.action.ActionRequestValidationException;, +import org.elasticsearch.tasks.LoggingTaskListener;, +import org.elasticsearch.tasks.Task;, +        if (request.paramAsBoolean("wait_for_completion", true)) {, +        } else {, +            upgradeRequest.setShouldStoreResult(true);, +, +            /*, +             * Validating before forking to make sure we can catch the issues earlier, +             */, +            ActionRequestValidationException validationException = upgradeRequest.validate();, +            if (validationException != null) {, +                throw validationException;, +            }, +            Task task = client.executeLocally(IndexUpgradeAction.INSTANCE, upgradeRequest, LoggingTaskListener.instance());, +            // Send task description id instead of waiting for the message, +            return channel -> {, +                try (XContentBuilder builder = channel.newBuilder()) {, +                    builder.startObject();]