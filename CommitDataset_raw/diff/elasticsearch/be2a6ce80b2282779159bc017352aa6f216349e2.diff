[+++ b/core/src/main/java/org/elasticsearch/transport/TcpTransport.java, +import java.util.function.Consumer;, +        private final Consumer<Connection> onClose;, +        public NodeChannels(DiscoveryNode node, Channel[] channels, ConnectionProfile connectionProfile, Consumer<Connection> onClose) {, +            this.onClose = onClose;, +            this.onClose = channels.onClose;, +                onClose.accept(this);, +                transportServiceAdapter.onConnectionOpened(nodeChannels);, +++ b/core/src/main/java/org/elasticsearch/transport/TcpTransport.java, +import java.util.function.Consumer;, +        private final Consumer<Connection> onClose;, +        public NodeChannels(DiscoveryNode node, Channel[] channels, ConnectionProfile connectionProfile, Consumer<Connection> onClose) {, +            this.onClose = onClose;, +            this.onClose = channels.onClose;, +                onClose.accept(this);, +                transportServiceAdapter.onConnectionOpened(nodeChannels);, +++ b/core/src/main/java/org/elasticsearch/transport/Transport.java, +, +        /**, +         * Returns a key that this connection can be cached on. Delegating subclasses must delegate method call to, +         * the original connection., +         */, +        default Object getCacheKey() {, +            return this;, +        }, +++ b/core/src/main/java/org/elasticsearch/transport/TcpTransport.java, +import java.util.function.Consumer;, +        private final Consumer<Connection> onClose;, +        public NodeChannels(DiscoveryNode node, Channel[] channels, ConnectionProfile connectionProfile, Consumer<Connection> onClose) {, +            this.onClose = onClose;, +            this.onClose = channels.onClose;, +                onClose.accept(this);, +                transportServiceAdapter.onConnectionOpened(nodeChannels);, +++ b/core/src/main/java/org/elasticsearch/transport/Transport.java, +, +        /**, +         * Returns a key that this connection can be cached on. Delegating subclasses must delegate method call to, +         * the original connection., +         */, +        default Object getCacheKey() {, +            return this;, +        }, +++ b/core/src/main/java/org/elasticsearch/transport/TransportConnectionListener.java, +     * Called once a node connection is closed. The connection might not have been registered in the, +     * transport as a shared connection to a specific node, +     */, +    default void onConnectionClosed(Transport.Connection connection) {}, +, +    /**, +    default void onConnectionOpened(Transport.Connection connection) {}, +++ b/core/src/main/java/org/elasticsearch/transport/TcpTransport.java, +import java.util.function.Consumer;, +        private final Consumer<Connection> onClose;, +        public NodeChannels(DiscoveryNode node, Channel[] channels, ConnectionProfile connectionProfile, Consumer<Connection> onClose) {, +            this.onClose = onClose;, +            this.onClose = channels.onClose;, +                onClose.accept(this);, +                transportServiceAdapter.onConnectionOpened(nodeChannels);, +++ b/core/src/main/java/org/elasticsearch/transport/Transport.java, +, +        /**, +         * Returns a key that this connection can be cached on. Delegating subclasses must delegate method call to, +         * the original connection., +         */, +        default Object getCacheKey() {, +            return this;, +        }, +++ b/core/src/main/java/org/elasticsearch/transport/TransportConnectionListener.java, +     * Called once a node connection is closed. The connection might not have been registered in the, +     * transport as a shared connection to a specific node, +     */, +    default void onConnectionClosed(Transport.Connection connection) {}, +, +    /**, +    default void onConnectionOpened(Transport.Connection connection) {}, +++ b/core/src/main/java/org/elasticsearch/transport/TransportService.java, +            clientHandlers.put(requestId, new RequestHolder<>(responseHandler, connection, action, timeoutHandler));, +                traceReceivedResponse(requestId, holder.connection().getNode(), holder.action());, +        public void onConnectionOpened(Transport.Connection connection) {, +            threadPool.generic().execute(() -> listenersToNotify.forEach(listener -> listener.onConnectionOpened(connection)));, +            } catch (EsRejectedExecutionException ex) {, +                logger.debug("Rejected execution on NodeDisconnected", ex);, +            }, +        }, +, +        @Override, +        public void onConnectionClosed(Transport.Connection connection) {, +            try {, +                    if (holder.connection().getCacheKey().equals(connection.getCacheKey())) {, +                            threadPool.generic().execute(() -> holderToNotify.handler().handleException(new NodeDisconnectedException(, +                                connection.getNode(), holderToNotify.action())));, +                logger.debug("Rejected execution on onConnectionClosed", ex);, +                timeoutInfoHandlers.put(requestId, new TimeoutInfoHolder(holder.connection().getNode(), holder.action(), sentTime,, +                    timeoutTime));, +                        new ReceiveTimeoutTransportException(holder.connection().getNode(), holder.action(),, +        private final Transport.Connection connection;, +        RequestHolder(TransportResponseHandler<T> handler, Transport.Connection connection, String action, TimeoutHandler timeoutHandler) {, +            this.connection = connection;, +        public Transport.Connection connection() {, +            return this.connection;]