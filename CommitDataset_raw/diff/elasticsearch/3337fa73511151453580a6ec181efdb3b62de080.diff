[+++ b/x-pack/plugin/monitoring/src/main/java/org/elasticsearch/xpack/monitoring/MonitoringFeatureSet.java, +        for (Exporter exporter : exporters.getEnabledExporters()) {, +++ b/x-pack/plugin/monitoring/src/main/java/org/elasticsearch/xpack/monitoring/MonitoringFeatureSet.java, +        for (Exporter exporter : exporters.getEnabledExporters()) {, +++ b/x-pack/plugin/monitoring/src/main/java/org/elasticsearch/xpack/monitoring/MonitoringService.java, +        exporters.close();, +++ b/x-pack/plugin/monitoring/src/main/java/org/elasticsearch/xpack/monitoring/MonitoringFeatureSet.java, +        for (Exporter exporter : exporters.getEnabledExporters()) {, +++ b/x-pack/plugin/monitoring/src/main/java/org/elasticsearch/xpack/monitoring/MonitoringService.java, +        exporters.close();, +++ b/x-pack/plugin/monitoring/src/main/java/org/elasticsearch/xpack/monitoring/exporter/Exporter.java, +import org.elasticsearch.action.ActionListener;, +     * Opens up a new export bulk., +     *, +     * @param listener Returns {@code null} to indicate that this exporter is not ready to export the docs., +    public abstract void openBulk(ActionListener<ExportBulk> listener);, +    public void close() {, +++ b/x-pack/plugin/monitoring/src/main/java/org/elasticsearch/xpack/monitoring/MonitoringFeatureSet.java, +        for (Exporter exporter : exporters.getEnabledExporters()) {, +++ b/x-pack/plugin/monitoring/src/main/java/org/elasticsearch/xpack/monitoring/MonitoringService.java, +        exporters.close();, +++ b/x-pack/plugin/monitoring/src/main/java/org/elasticsearch/xpack/monitoring/exporter/Exporter.java, +import org.elasticsearch.action.ActionListener;, +     * Opens up a new export bulk., +     *, +     * @param listener Returns {@code null} to indicate that this exporter is not ready to export the docs., +    public abstract void openBulk(ActionListener<ExportBulk> listener);, +    public void close() {, +++ b/x-pack/plugin/monitoring/src/main/java/org/elasticsearch/xpack/monitoring/exporter/Exporters.java, +import org.elasticsearch.common.util.concurrent.AtomicArray;, +import org.elasticsearch.common.util.concurrent.CountDown;, +import org.elasticsearch.gateway.GatewayService;, +public class Exporters extends AbstractLifecycleComponent {, +    /**, +     * Get all enabled {@linkplain Exporter}s., +     *, +     * @return Never {@code null}. Can be empty if none are enabled., +     */, +    public Collection<Exporter> getEnabledExporters() {, +        return exporters.get().values();, +     * Wrap every {@linkplain Exporter}'s {@linkplain ExportBulk} in a {@linkplain ExportBulk.Compound}., +     *, +     * @param listener {@code null} if no exporters are ready or available., +     */, +    void wrapExportBulk(final ActionListener<ExportBulk> listener) {, +        final ClusterState state = clusterService.state();, +, +        // wait until we have a usable cluster state, +        if (state.blocks().hasGlobalBlock(GatewayService.STATE_NOT_RECOVERED_BLOCK) ||, +            ClusterState.UNKNOWN_UUID.equals(state.metaData().clusterUUID()) ||, +            state.version() == ClusterState.UNKNOWN_VERSION) {, +            logger.trace("skipping exporters because the cluster state is not loaded");, +, +            listener.onResponse(null);, +            return;, +        }, +, +        final Map<String, Exporter> exporterMap = exporters.get();, +        final AtomicArray<ExportBulk> accumulatedBulks = new AtomicArray<>(exporterMap.size());, +        final CountDown countDown = new CountDown(exporterMap.size());, +, +        int i = 0;, +, +        // get every exporter's ExportBulk and, when they've all responded, respond with a wrapped version, +        for (final Exporter exporter : exporterMap.values()) {, +            exporter.openBulk(, +                new AccumulatingExportBulkActionListener(exporter.name(), i++, accumulatedBulks, countDown, threadContext, listener));, +        }, +    }, +, +    /**, +    public void export(final Collection<MonitoringDoc> docs, final ActionListener<Void> listener) throws ExportException {, +            wrapExportBulk(ActionListener.wrap(bulk -> {, +                    doExport(bulk, docs, listener);, +                } else {, +                    listener.onResponse(null);, +                }, +            }, listener::onFailure));, +        } else {, +            listener.onResponse(null);, +        }, +    }, +, +    /**, +     * Add {@code docs} and send the {@code bulk}, then respond to the {@code listener}., +     *, +     * @param bulk The bulk object to send {@code docs} through., +     * @param docs The monitoring documents to send., +     * @param listener Returns {@code null} when complete, or failure where relevant., +     */, +    private void doExport(final ExportBulk bulk, final Collection<MonitoringDoc> docs, final ActionListener<Void> listener) {, +, +, +    /**, +     * {@code AccumulatingExportBulkActionListener} allows us to asynchronously gather all of the {@linkplain ExportBulk}s that are, +     * ready, as associated with the enabled {@linkplain Exporter}s., +     */, +    static class AccumulatingExportBulkActionListener implements ActionListener<ExportBulk> {, +, +        private final String name;]