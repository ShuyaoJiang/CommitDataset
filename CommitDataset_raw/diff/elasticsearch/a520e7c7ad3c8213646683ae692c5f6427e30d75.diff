[+++ b/core/src/main/java/org/elasticsearch/action/ingest/IngestActionFilter.java, +        executionService.executeIndexRequest(indexRequest, t -> {, +        executionService.executeBulkRequest(() -> bulkRequestModifier, (indexRequest, throwable) -> {, +++ b/core/src/main/java/org/elasticsearch/action/ingest/IngestActionFilter.java, +        executionService.executeIndexRequest(indexRequest, t -> {, +        executionService.executeBulkRequest(() -> bulkRequestModifier, (indexRequest, throwable) -> {, +++ b/core/src/main/java/org/elasticsearch/cluster/metadata/MetaDataMappingService.java, +            MetaData.Builder builder = MetaData.builder(currentState.metaData());, +, +                IndexMetaData indexMetaData = currentState.metaData().index(index);, +                    throw new IndexNotFoundException(index);, +                IndexMetaData.Builder indexMetaDataBuilder = IndexMetaData.builder(indexMetaData);, +                // Mapping updates on a single type may have side-effects on other types so we need to, +                // update mapping metadata on all types, +                for (DocumentMapper mapper : indexService.mapperService().docMappers(true)) {, +                    indexMetaDataBuilder.putMapping(new MappingMetaData(mapper.mappingSource()));, +                builder.put(indexMetaDataBuilder);, +++ b/core/src/main/java/org/elasticsearch/action/ingest/IngestActionFilter.java, +        executionService.executeIndexRequest(indexRequest, t -> {, +        executionService.executeBulkRequest(() -> bulkRequestModifier, (indexRequest, throwable) -> {, +++ b/core/src/main/java/org/elasticsearch/cluster/metadata/MetaDataMappingService.java, +            MetaData.Builder builder = MetaData.builder(currentState.metaData());, +, +                IndexMetaData indexMetaData = currentState.metaData().index(index);, +                    throw new IndexNotFoundException(index);, +                IndexMetaData.Builder indexMetaDataBuilder = IndexMetaData.builder(indexMetaData);, +                // Mapping updates on a single type may have side-effects on other types so we need to, +                // update mapping metadata on all types, +                for (DocumentMapper mapper : indexService.mapperService().docMappers(true)) {, +                    indexMetaDataBuilder.putMapping(new MappingMetaData(mapper.mappingSource()));, +                builder.put(indexMetaDataBuilder);, +++ b/core/src/main/java/org/elasticsearch/ingest/PipelineExecutionService.java, +    public void executeIndexRequest(IndexRequest request, Consumer<Throwable> failureHandler, Consumer<Boolean> completionHandler) {, +    public void executeBulkRequest(Iterable<ActionRequest<?>> actionRequests,, +        threadPool.executor(ThreadPool.Names.BULK).execute(new AbstractRunnable() {, +++ b/core/src/main/java/org/elasticsearch/action/ingest/IngestActionFilter.java, +        executionService.executeIndexRequest(indexRequest, t -> {, +        executionService.executeBulkRequest(() -> bulkRequestModifier, (indexRequest, throwable) -> {, +++ b/core/src/main/java/org/elasticsearch/cluster/metadata/MetaDataMappingService.java, +            MetaData.Builder builder = MetaData.builder(currentState.metaData());, +, +                IndexMetaData indexMetaData = currentState.metaData().index(index);, +                    throw new IndexNotFoundException(index);, +                IndexMetaData.Builder indexMetaDataBuilder = IndexMetaData.builder(indexMetaData);, +                // Mapping updates on a single type may have side-effects on other types so we need to, +                // update mapping metadata on all types, +                for (DocumentMapper mapper : indexService.mapperService().docMappers(true)) {, +                    indexMetaDataBuilder.putMapping(new MappingMetaData(mapper.mappingSource()));, +                builder.put(indexMetaDataBuilder);, +++ b/core/src/main/java/org/elasticsearch/ingest/PipelineExecutionService.java, +    public void executeIndexRequest(IndexRequest request, Consumer<Throwable> failureHandler, Consumer<Boolean> completionHandler) {, +    public void executeBulkRequest(Iterable<ActionRequest<?>> actionRequests,, +        threadPool.executor(ThreadPool.Names.BULK).execute(new AbstractRunnable() {, +++ b/core/src/main/java/org/elasticsearch/search/sort/GeoDistanceSortBuilder.java, +import org.elasticsearch.common.geo.GeoUtils;, +import org.elasticsearch.common.io.stream.NamedWriteable;, +import org.elasticsearch.common.io.stream.StreamInput;, +import org.elasticsearch.common.io.stream.StreamOutput;, +import org.elasticsearch.common.xcontent.ToXContent;, +import org.elasticsearch.common.xcontent.XContentParser;, +import org.elasticsearch.index.query.QueryParseContext;, +import org.elasticsearch.search.MultiValueMode;, +import java.util.Objects;, +public class GeoDistanceSortBuilder extends SortBuilder, +        implements ToXContent, NamedWriteable<GeoDistanceSortBuilder>, SortElementParserTemp<GeoDistanceSortBuilder> {, +    public static final String NAME = "_geo_distance";, +    public static final boolean DEFAULT_COERCE = false;, +    public static final boolean DEFAULT_IGNORE_MALFORMED = false;, +    static final GeoDistanceSortBuilder PROTOTYPE = new GeoDistanceSortBuilder("", -1, -1);, +, +    private final String fieldName;, +    private GeoDistance geoDistance = GeoDistance.DEFAULT;, +    private DistanceUnit unit = DistanceUnit.DEFAULT;, +    private SortOrder order = SortOrder.ASC;, +    , +    // TODO there is an enum that covers that parameter which we should be using here, +    private String sortMode = null;, +    @SuppressWarnings("rawtypes"), +    , +    // TODO switch to GeoValidationMethod enum, +    private boolean coerce = DEFAULT_COERCE;, +    private boolean ignoreMalformed = DEFAULT_IGNORE_MALFORMED;, +     * @param points The points to create the range distance facets from., +    public GeoDistanceSortBuilder(String fieldName, GeoPoint... points) {, +        if (points.length == 0) {, +            throw new IllegalArgumentException("Geo distance sorting needs at least one point.");, +        }, +        this.points.addAll(Arrays.asList(points));, +    }, +, +    /**, +     * Constructs a new distance based sort on a geo point like field., +     *, +     * @param fieldName The geo point like field name., +     * @param lat Latitude of the point to create the range distance facets from., +     * @param lon Longitude of the point to create the range distance facets from., +     */, +    public GeoDistanceSortBuilder(String fieldName, double lat, double lon) {, +        this(fieldName, new GeoPoint(lat, lon));, +    }]