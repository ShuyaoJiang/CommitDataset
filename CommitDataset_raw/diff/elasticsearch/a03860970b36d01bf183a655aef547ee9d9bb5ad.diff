[+++ b/src/main/java/org/elasticsearch/action/admin/indices/analyze/AnalyzeRequest.java, +public class AnalyzeRequest extends SingleCustomOperationRequest<AnalyzeRequest> {, +        this.index(index);, +++ b/src/main/java/org/elasticsearch/action/admin/indices/analyze/AnalyzeRequest.java, +public class AnalyzeRequest extends SingleCustomOperationRequest<AnalyzeRequest> {, +        this.index(index);, +++ b/src/main/java/org/elasticsearch/action/admin/indices/analyze/TransportAnalyzeAction.java, +import org.elasticsearch.action.ActionListener;, +import org.elasticsearch.transport.BaseTransportRequestHandler;, +import org.elasticsearch.transport.TransportChannel;, + * Transport action used to execute analyze requests, +        transportService.registerHandler(AnalyzeAction.NAME, new TransportHandler());, +            return super.checkRequestBlock(state, request);, +, +    private class TransportHandler extends BaseTransportRequestHandler<AnalyzeRequest> {, +, +        @Override, +        public AnalyzeRequest newInstance() {, +            return newRequest();, +        }, +, +        @Override, +        public void messageReceived(AnalyzeRequest request, final TransportChannel channel) throws Exception {, +            // no need to have a threaded listener since we just send back a response, +            request.listenerThreaded(false);, +            // if we have a local operation, execute it on a thread since we don't spawn, +            request.operationThreaded(true);, +            execute(request, new ActionListener<AnalyzeResponse>() {, +                @Override, +                public void onResponse(AnalyzeResponse result) {, +                    try {, +                        channel.sendResponse(result);, +                    } catch (Throwable e) {, +                        onFailure(e);, +                    }, +                }, +, +                @Override, +                public void onFailure(Throwable e) {, +                    try {, +                        channel.sendResponse(e);, +                    } catch (Exception e1) {, +                        logger.warn("Failed to send response for get", e1);, +                    }, +                }, +            });, +        }, +, +        @Override, +        public String executor() {, +            return ThreadPool.Names.SAME;, +        }, +    }, +++ b/src/main/java/org/elasticsearch/action/admin/indices/analyze/AnalyzeRequest.java, +public class AnalyzeRequest extends SingleCustomOperationRequest<AnalyzeRequest> {, +        this.index(index);, +++ b/src/main/java/org/elasticsearch/action/admin/indices/analyze/TransportAnalyzeAction.java, +import org.elasticsearch.action.ActionListener;, +import org.elasticsearch.transport.BaseTransportRequestHandler;, +import org.elasticsearch.transport.TransportChannel;, + * Transport action used to execute analyze requests, +        transportService.registerHandler(AnalyzeAction.NAME, new TransportHandler());, +            return super.checkRequestBlock(state, request);, +, +    private class TransportHandler extends BaseTransportRequestHandler<AnalyzeRequest> {, +, +        @Override, +        public AnalyzeRequest newInstance() {, +            return newRequest();, +        }, +, +        @Override, +        public void messageReceived(AnalyzeRequest request, final TransportChannel channel) throws Exception {, +            // no need to have a threaded listener since we just send back a response, +            request.listenerThreaded(false);, +            // if we have a local operation, execute it on a thread since we don't spawn, +            request.operationThreaded(true);, +            execute(request, new ActionListener<AnalyzeResponse>() {, +                @Override, +                public void onResponse(AnalyzeResponse result) {, +                    try {, +                        channel.sendResponse(result);, +                    } catch (Throwable e) {, +                        onFailure(e);, +                    }, +                }, +, +                @Override, +                public void onFailure(Throwable e) {, +                    try {, +                        channel.sendResponse(e);, +                    } catch (Exception e1) {, +                        logger.warn("Failed to send response for get", e1);, +                    }, +                }, +            });, +        }, +, +        @Override, +        public String executor() {]