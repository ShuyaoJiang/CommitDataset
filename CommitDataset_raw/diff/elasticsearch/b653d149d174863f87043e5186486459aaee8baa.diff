[+++ b/config/elasticsearch.yml, +# Recovery Throttling, +#   The number of concurrent recoveries happening on a node, +#cluster.routing.allocation.node_initial_primaries_recoveries: 4, +#cluster.routing.allocation.node_concurrent_recoveries: 2, +#   Peer shard recovery size based throttling (set to 100mb for example to enable), +#indices.recovery.max_size_per_sec: 0, +#   Number open concurrent recovery streams allows, +#indices.recovery.concurrent_streams: 5, +, +++ b/config/elasticsearch.yml, +# Recovery Throttling, +#   The number of concurrent recoveries happening on a node, +#cluster.routing.allocation.node_initial_primaries_recoveries: 4, +#cluster.routing.allocation.node_concurrent_recoveries: 2, +#   Peer shard recovery size based throttling (set to 100mb for example to enable), +#indices.recovery.max_size_per_sec: 0, +#   Number open concurrent recovery streams allows, +#indices.recovery.concurrent_streams: 5, +, +++ b/config/logging.yml, +  #indices.recovery: DEBUG, +++ b/config/elasticsearch.yml, +# Recovery Throttling, +#   The number of concurrent recoveries happening on a node, +#cluster.routing.allocation.node_initial_primaries_recoveries: 4, +#cluster.routing.allocation.node_concurrent_recoveries: 2, +#   Peer shard recovery size based throttling (set to 100mb for example to enable), +#indices.recovery.max_size_per_sec: 0, +#   Number open concurrent recovery streams allows, +#indices.recovery.concurrent_streams: 5, +, +++ b/config/logging.yml, +  #indices.recovery: DEBUG, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/indices/recovery/RecoverySettings.java, +import org.elasticsearch.common.RateLimiter;, +import org.elasticsearch.common.base.Objects;, +        MetaData.addDynamicSettings("indices.recovery.concurrent_streams");, +        MetaData.addDynamicSettings("indices.recovery.max_size_per_sec");, +    private volatile ByteSizeValue maxSizePerSec;, +    private volatile RateLimiter rateLimiter;, +, +        this.maxSizePerSec = componentSettings.getAsBytesSize("max_size_per_sec", new ByteSizeValue(0));, +        if (maxSizePerSec.bytes() <= 0) {, +            rateLimiter = null;, +        } else {, +            rateLimiter = new RateLimiter(maxSizePerSec.mbFrac());, +        }, +, +        logger.debug("using max_size_per_sec[{}], concurrent_streams [{}], file_chunk_size [{}], translog_size [{}], translog_ops [{}], and compress [{}]",, +                maxSizePerSec, concurrentStreams, fileChunkSize, translogSize, translogOps, compress);, +    public RateLimiter rateLimiter() {, +        return rateLimiter;, +    }, +, +            ByteSizeValue maxSizePerSec = settings.getAsBytesSize("indices.recovery.max_size_per_sec", RecoverySettings.this.maxSizePerSec);, +            if (!Objects.equal(maxSizePerSec, RecoverySettings.this.maxSizePerSec)) {, +                logger.info("updating [indices.recovery.max_size_per_sec] from [{}] to [{}]", RecoverySettings.this.maxSizePerSec, maxSizePerSec);, +                RecoverySettings.this.maxSizePerSec = maxSizePerSec;, +                if (maxSizePerSec.bytes() <= 0) {, +                    rateLimiter = null;, +                } else if (rateLimiter != null) {, +                    rateLimiter.setMaxRate(maxSizePerSec.mbFrac());, +                } else {, +                    rateLimiter = new RateLimiter(maxSizePerSec.mbFrac());, +                }, +            }, +, +++ b/config/elasticsearch.yml, +# Recovery Throttling, +#   The number of concurrent recoveries happening on a node, +#cluster.routing.allocation.node_initial_primaries_recoveries: 4, +#cluster.routing.allocation.node_concurrent_recoveries: 2, +#   Peer shard recovery size based throttling (set to 100mb for example to enable), +#indices.recovery.max_size_per_sec: 0, +#   Number open concurrent recovery streams allows, +#indices.recovery.concurrent_streams: 5, +, +++ b/config/logging.yml, +  #indices.recovery: DEBUG, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/indices/recovery/RecoverySettings.java, +import org.elasticsearch.common.RateLimiter;, +import org.elasticsearch.common.base.Objects;, +        MetaData.addDynamicSettings("indices.recovery.concurrent_streams");, +        MetaData.addDynamicSettings("indices.recovery.max_size_per_sec");, +    private volatile ByteSizeValue maxSizePerSec;, +    private volatile RateLimiter rateLimiter;, +, +        this.maxSizePerSec = componentSettings.getAsBytesSize("max_size_per_sec", new ByteSizeValue(0));, +        if (maxSizePerSec.bytes() <= 0) {, +            rateLimiter = null;, +        } else {, +            rateLimiter = new RateLimiter(maxSizePerSec.mbFrac());, +        }, +, +        logger.debug("using max_size_per_sec[{}], concurrent_streams [{}], file_chunk_size [{}], translog_size [{}], translog_ops [{}], and compress [{}]",, +                maxSizePerSec, concurrentStreams, fileChunkSize, translogSize, translogOps, compress);, +    public RateLimiter rateLimiter() {, +        return rateLimiter;, +    }]