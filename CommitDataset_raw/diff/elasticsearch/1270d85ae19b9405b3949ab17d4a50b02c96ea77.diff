[+++ b/x-pack/plugin/sql/qa/single-node/src/test/java/org/elasticsearch/xpack/sql/qa/single_node/JdbcDocCsvSpecIT.java, +        JdbcAssert.assertResultSets(expected, elastic, log, true, false);, +++ b/x-pack/plugin/sql/qa/single-node/src/test/java/org/elasticsearch/xpack/sql/qa/single_node/JdbcDocCsvSpecIT.java, +        JdbcAssert.assertResultSets(expected, elastic, log, true, false);, +++ b/x-pack/plugin/sql/qa/src/main/java/org/elasticsearch/xpack/sql/qa/jdbc/CsvSpecTestCase.java, +import org.apache.logging.log4j.Logger;, +import java.sql.SQLException;, +, +    @Override, +    protected void assertResults(ResultSet expected, ResultSet elastic) throws SQLException {, +        Logger log = logEsResultSet() ? logger : null;, +        JdbcAssert.assertResultSets(expected, elastic, log, false, false);, +    }, +++ b/x-pack/plugin/sql/qa/single-node/src/test/java/org/elasticsearch/xpack/sql/qa/single_node/JdbcDocCsvSpecIT.java, +        JdbcAssert.assertResultSets(expected, elastic, log, true, false);, +++ b/x-pack/plugin/sql/qa/src/main/java/org/elasticsearch/xpack/sql/qa/jdbc/CsvSpecTestCase.java, +import org.apache.logging.log4j.Logger;, +import java.sql.SQLException;, +, +    @Override, +    protected void assertResults(ResultSet expected, ResultSet elastic) throws SQLException {, +        Logger log = logEsResultSet() ? logger : null;, +        JdbcAssert.assertResultSets(expected, elastic, log, false, false);, +    }, +++ b/x-pack/plugin/sql/qa/src/main/java/org/elasticsearch/xpack/sql/qa/jdbc/JdbcAssert.java, + /*, +     * When lenientDataType is specified, the type comparison of a column is widden to reach a common, compatible ground., +     * For example in a non-lenient, strict case a comparison between an int and a tinyint would fail, with lenientDataType it will succeed, +     * as long as the actual value is the same., +    public static void assertResultSets(ResultSet expected, ResultSet actual, Logger logger, boolean lenientDataType) throws SQLException {, +        assertResultSets(expected, actual, logger, lenientDataType, true);, +    }, +    , +    /**, +     * Assert the given result sets, potentially in a lenient way., +     * When lenientDataType is specified, the type comparison of a column is widden to reach a common, compatible ground., +     * This means promoting integer types to long and floating types to double and comparing their values., +     * For example in a non-lenient, strict case a comparison between an int and a tinyint would fail, with lenientDataType it will succeed, +     * as long as the actual value is the same., +     * Also, has the option of treating the numeric results for floating point numbers in a leninent way, if chosen to. Usually,, +     * we would want lenient treatment for floating point numbers in sql-spec tests where the comparison is being made with H2., +     */, +    public static void assertResultSets(ResultSet expected, ResultSet actual, Logger logger, boolean lenientDataType,, +            boolean lenientFloatingNumbers) throws SQLException {, +            assertResultSetMetadata(ex, ac, logger, lenientDataType);, +            assertResultSetData(ex, ac, logger, lenientDataType, lenientFloatingNumbers);, +    public static void assertResultSetMetadata(ResultSet expected, ResultSet actual, Logger logger, boolean lenientDataType), +            throws SQLException {, +            int expectedType = typeOf(expectedMeta.getColumnType(column), lenientDataType);, +            int actualType = typeOf(actualMeta.getColumnType(column), lenientDataType);, +    public static void assertResultSetData(ResultSet expected, ResultSet actual, Logger logger, boolean lenientDataType), +            throws SQLException {, +        assertResultSetData(expected, actual, logger, lenientDataType, true);, +    }, +    , +    public static void assertResultSetData(ResultSet expected, ResultSet actual, Logger logger, boolean lenientDataType,, +            boolean lenientFloatingNumbers) throws SQLException {, +            doAssertResultSetData(ex, ac, logger, lenientDataType, lenientFloatingNumbers);, +    private static void doAssertResultSetData(ResultSet expected, ResultSet actual, Logger logger, boolean lenientDataType,, +            boolean lenientFloatingNumbers) throws SQLException {, +                    Object actualObject = lenientDataType ? actual.getObject(column, expectedColumnClass) : actual.getObject(column);, +                        assertEquals(msg, (double) expectedObject, (double) actualObject, lenientFloatingNumbers ? 1d : 0.0d);, +                        assertEquals(msg, (float) expectedObject, (float) actualObject, lenientFloatingNumbers ? 1f : 0.0f);, +    private static int typeOf(int columnType, boolean lenientDataType) {, +        if (lenientDataType) {, +++ b/x-pack/plugin/sql/qa/single-node/src/test/java/org/elasticsearch/xpack/sql/qa/single_node/JdbcDocCsvSpecIT.java, +        JdbcAssert.assertResultSets(expected, elastic, log, true, false);, +++ b/x-pack/plugin/sql/qa/src/main/java/org/elasticsearch/xpack/sql/qa/jdbc/CsvSpecTestCase.java, +import org.apache.logging.log4j.Logger;, +import java.sql.SQLException;, +, +    @Override, +    protected void assertResults(ResultSet expected, ResultSet elastic) throws SQLException {, +        Logger log = logEsResultSet() ? logger : null;, +        JdbcAssert.assertResultSets(expected, elastic, log, false, false);, +    }, +++ b/x-pack/plugin/sql/qa/src/main/java/org/elasticsearch/xpack/sql/qa/jdbc/JdbcAssert.java, + /*, +     * When lenientDataType is specified, the type comparison of a column is widden to reach a common, compatible ground., +     * For example in a non-lenient, strict case a comparison between an int and a tinyint would fail, with lenientDataType it will succeed, +     * as long as the actual value is the same., +    public static void assertResultSets(ResultSet expected, ResultSet actual, Logger logger, boolean lenientDataType) throws SQLException {, +        assertResultSets(expected, actual, logger, lenientDataType, true);, +    }, +    , +    /**, +     * Assert the given result sets, potentially in a lenient way., +     * When lenientDataType is specified, the type comparison of a column is widden to reach a common, compatible ground., +     * This means promoting integer types to long and floating types to double and comparing their values., +     * For example in a non-lenient, strict case a comparison between an int and a tinyint would fail, with lenientDataType it will succeed, +     * as long as the actual value is the same., +     * Also, has the option of treating the numeric results for floating point numbers in a leninent way, if chosen to. Usually,, +     * we would want lenient treatment for floating point numbers in sql-spec tests where the comparison is being made with H2., +     */, +    public static void assertResultSets(ResultSet expected, ResultSet actual, Logger logger, boolean lenientDataType,, +            boolean lenientFloatingNumbers) throws SQLException {, +            assertResultSetMetadata(ex, ac, logger, lenientDataType);, +            assertResultSetData(ex, ac, logger, lenientDataType, lenientFloatingNumbers);, +    public static void assertResultSetMetadata(ResultSet expected, ResultSet actual, Logger logger, boolean lenientDataType), +            throws SQLException {]