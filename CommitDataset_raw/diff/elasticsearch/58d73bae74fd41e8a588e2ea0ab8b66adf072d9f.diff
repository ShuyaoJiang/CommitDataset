[+++ b/core/src/main/java/org/elasticsearch/action/bulk/TransportShardBulkAction.java, +import org.elasticsearch.index.seqno.GlobalCheckpointSyncAction;, +                        indexRequest.seqNo(indexResult.getSeqNo());, +                        deleteRequest.seqNo(deleteResult.getSeqNo());, +, +                        indexRequest.seqNo(updateOperationResult.getSeqNo());, +                        deleteRequest.seqNo(updateOperationResult.getSeqNo());, +                assert (replicaRequest.request() instanceof IndexRequest, +                    && ((IndexRequest) replicaRequest.request()).seqNo() != SequenceNumbersService.UNASSIGNED_SEQ_NO) ||, +                    (replicaRequest.request() instanceof DeleteRequest, +                        && ((DeleteRequest) replicaRequest.request()).seqNo() != SequenceNumbersService.UNASSIGNED_SEQ_NO);, +                            operationResult = executeIndexRequestOnReplica((IndexRequest) docWriteRequest, replica);, +                            operationResult = executeDeleteRequestOnReplica((DeleteRequest) docWriteRequest, replica);, +++ b/core/src/main/java/org/elasticsearch/action/bulk/TransportShardBulkAction.java, +import org.elasticsearch.index.seqno.GlobalCheckpointSyncAction;, +                        indexRequest.seqNo(indexResult.getSeqNo());, +                        deleteRequest.seqNo(deleteResult.getSeqNo());, +, +                        indexRequest.seqNo(updateOperationResult.getSeqNo());, +                        deleteRequest.seqNo(updateOperationResult.getSeqNo());, +                assert (replicaRequest.request() instanceof IndexRequest, +                    && ((IndexRequest) replicaRequest.request()).seqNo() != SequenceNumbersService.UNASSIGNED_SEQ_NO) ||, +                    (replicaRequest.request() instanceof DeleteRequest, +                        && ((DeleteRequest) replicaRequest.request()).seqNo() != SequenceNumbersService.UNASSIGNED_SEQ_NO);, +                            operationResult = executeIndexRequestOnReplica((IndexRequest) docWriteRequest, replica);, +                            operationResult = executeDeleteRequestOnReplica((DeleteRequest) docWriteRequest, replica);, +++ b/core/src/main/java/org/elasticsearch/action/delete/TransportDeleteAction.java, +            request.seqNo(result.getSeqNo());, +++ b/core/src/main/java/org/elasticsearch/action/bulk/TransportShardBulkAction.java, +import org.elasticsearch.index.seqno.GlobalCheckpointSyncAction;, +                        indexRequest.seqNo(indexResult.getSeqNo());, +                        deleteRequest.seqNo(deleteResult.getSeqNo());, +, +                        indexRequest.seqNo(updateOperationResult.getSeqNo());, +                        deleteRequest.seqNo(updateOperationResult.getSeqNo());, +                assert (replicaRequest.request() instanceof IndexRequest, +                    && ((IndexRequest) replicaRequest.request()).seqNo() != SequenceNumbersService.UNASSIGNED_SEQ_NO) ||, +                    (replicaRequest.request() instanceof DeleteRequest, +                        && ((DeleteRequest) replicaRequest.request()).seqNo() != SequenceNumbersService.UNASSIGNED_SEQ_NO);, +                            operationResult = executeIndexRequestOnReplica((IndexRequest) docWriteRequest, replica);, +                            operationResult = executeDeleteRequestOnReplica((DeleteRequest) docWriteRequest, replica);, +++ b/core/src/main/java/org/elasticsearch/action/delete/TransportDeleteAction.java, +            request.seqNo(result.getSeqNo());, +++ b/core/src/main/java/org/elasticsearch/index/engine/InternalEngine.java, +import java.util.Optional;, +import java.util.function.Supplier;, +                // norelease, +                /*, +                 * We have no guarantees that all operations above the local checkpoint are in the Lucene commit or the translog. This means, +                 * that we there might be operations greater than the local checkpoint that will not be replayed. Here we force the local, +                 * checkpoint to the maximum sequence number in the commit (at the potential expense of correctness)., +                 */, +                while (seqNoService().getLocalCheckpoint() < seqNoService().getMaxSeqNo()) {, +                    seqNoService().markSeqNoAsCompleted(seqNoService().getLocalCheckpoint() + 1);, +                }, +                indexWriter = writer;, +                translog = openTranslog(engineConfig, writer, () -> seqNoService().getLocalCheckpoint());, +        try (ReleasableLock ignored = readLock.acquire()) {, +    /**, +     * Checks for version conflicts. If a version conflict exists, the optional return value represents the operation result. Otherwise, if, +     * no conflicts are found, the optional return value is not present., +     *, +     * @param <T>             the result type, +     * @param op              the operation, +     * @param currentVersion  the current version, +     * @param expectedVersion the expected version, +     * @param deleted         {@code true} if the current version is not found or represents a delete, +     * @param onSuccess       if there is a version conflict that can be ignored, the result of the operation, +     * @param onFailure       if there is a version conflict that can not be ignored, the result of the operation, +     * @return if there is a version conflict, the optional value is present and represents the operation result, otherwise the return value, +     * is not present, +     */, +    private <T extends Result> Optional<T> checkVersionConflict(, +        final boolean deleted,, +        final Supplier<T> onSuccess,, +        final Function<VersionConflictEngineException, T> onFailure) {, +        final T result;, +                result = onSuccess.get();, +                final VersionConflictEngineException e =, +                    new VersionConflictEngineException(, +                        shardId,, +                        op.type(),, +                        op.id(),, +                result = onFailure.apply(e);, +, +            return Optional.of(result);, +        } else {, +            return Optional.empty();, +        try (ReleasableLock ignored = readLock.acquire()) {, +        long seqNo = index.seqNo();, +            final Optional<IndexResult> checkVersionConflictResult =, +                checkVersionConflict(, +                    index,, +                    currentVersion,, +                    expectedVersion,, +                    deleted,, +                    () -> new IndexResult(currentVersion, index.seqNo(), false),, +                    e -> new IndexResult(e, currentVersion, index.seqNo()));, +, +            final IndexResult indexResult;]