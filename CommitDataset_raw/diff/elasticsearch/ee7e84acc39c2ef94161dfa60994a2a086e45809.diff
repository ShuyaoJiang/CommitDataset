[+++ b/core/src/main/java/org/elasticsearch/index/mapper/internal/FieldNamesFieldMapper.java, +++ b/core/src/main/java/org/elasticsearch/index/mapper/internal/FieldNamesFieldMapper.java, +++ b/core/src/main/java/org/elasticsearch/index/query/ExistsQueryBuilder.java, +import org.apache.lucene.search.TermRangeQuery;, +import org.elasticsearch.index.mapper.MappedFieldType;, +import org.elasticsearch.index.mapper.object.ObjectMapper;, +        ObjectMapper objectMapper = context.getObjectMapper(fieldPattern);, +        if (objectMapper != null) {, +            // automatic make the object mapper pattern, +            fieldPattern = fieldPattern + ".*";, +        }, +, +        Collection<String> fields = context.simpleMatchToIndexNames(fieldPattern);, +        if (fields.isEmpty()) {, +            // no fields exists, so we should not match anything, +            return Queries.newMatchNoDocsQuery();, +            MappedFieldType fieldType = context.fieldMapper(field);, +            Query filter = null;, +            if (fieldNamesFieldType.isEnabled()) {, +                final String f;, +                if (fieldType != null) {, +                    f = fieldType.name();, +                } else {, +                    f = field;, +                }, +                filter = fieldNamesFieldType.termQuery(f, context);, +            }, +            // if _field_names are not indexed, we need to go the slow way, +            if (filter == null && fieldType != null) {, +                filter = fieldType.rangeQuery(null, null, true, true);, +            }, +            if (filter == null) {, +                filter = new TermRangeQuery(field, null, null, true, true);, +            }, +++ b/core/src/main/java/org/elasticsearch/index/mapper/internal/FieldNamesFieldMapper.java, +++ b/core/src/main/java/org/elasticsearch/index/query/ExistsQueryBuilder.java, +import org.apache.lucene.search.TermRangeQuery;, +import org.elasticsearch.index.mapper.MappedFieldType;, +import org.elasticsearch.index.mapper.object.ObjectMapper;, +        ObjectMapper objectMapper = context.getObjectMapper(fieldPattern);, +        if (objectMapper != null) {, +            // automatic make the object mapper pattern, +            fieldPattern = fieldPattern + ".*";, +        }, +, +        Collection<String> fields = context.simpleMatchToIndexNames(fieldPattern);, +        if (fields.isEmpty()) {, +            // no fields exists, so we should not match anything, +            return Queries.newMatchNoDocsQuery();, +            MappedFieldType fieldType = context.fieldMapper(field);, +            Query filter = null;, +            if (fieldNamesFieldType.isEnabled()) {, +                final String f;, +                if (fieldType != null) {, +                    f = fieldType.name();, +                } else {, +                    f = field;, +                }, +                filter = fieldNamesFieldType.termQuery(f, context);, +            }, +            // if _field_names are not indexed, we need to go the slow way, +            if (filter == null && fieldType != null) {, +                filter = fieldType.rangeQuery(null, null, true, true);, +            }, +            if (filter == null) {, +                filter = new TermRangeQuery(field, null, null, true, true);, +            }, +++ b/core/src/main/java/org/elasticsearch/rest/action/cat/RestIndicesAction.java, +        table.addCell("query_cache.memory_size", "sibling:pri;alias:fcm,queryCacheMemory;default:false;text-align:right;desc:used query cache");, +        table.addCell("query_cache.evictions", "sibling:pri;alias:fce,queryCacheEvictions;default:false;text-align:right;desc:query cache evictions");, +        table.addCell("request_cache.memory_size", "sibling:pri;alias:qcm,queryCacheMemory;default:false;text-align:right;desc:used request cache");, +        table.addCell("request_cache.evictions", "sibling:pri;alias:qce,queryCacheEvictions;default:false;text-align:right;desc:request cache evictions");, +        table.addCell("request_cache.hit_count", "sibling:pri;alias:qchc,queryCacheHitCount;default:false;text-align:right;desc:request cache hit count");, +        table.addCell("request_cache.miss_count", "sibling:pri;alias:qcmc,queryCacheMissCount;default:false;text-align:right;desc:request cache miss count");, +++ b/core/src/main/java/org/elasticsearch/index/mapper/internal/FieldNamesFieldMapper.java, +++ b/core/src/main/java/org/elasticsearch/index/query/ExistsQueryBuilder.java, +import org.apache.lucene.search.TermRangeQuery;, +import org.elasticsearch.index.mapper.MappedFieldType;, +import org.elasticsearch.index.mapper.object.ObjectMapper;, +        ObjectMapper objectMapper = context.getObjectMapper(fieldPattern);, +        if (objectMapper != null) {, +            // automatic make the object mapper pattern, +            fieldPattern = fieldPattern + ".*";, +        }, +, +        Collection<String> fields = context.simpleMatchToIndexNames(fieldPattern);, +        if (fields.isEmpty()) {, +            // no fields exists, so we should not match anything, +            return Queries.newMatchNoDocsQuery();, +            MappedFieldType fieldType = context.fieldMapper(field);, +            Query filter = null;, +            if (fieldNamesFieldType.isEnabled()) {, +                final String f;, +                if (fieldType != null) {, +                    f = fieldType.name();, +                } else {, +                    f = field;, +                }, +                filter = fieldNamesFieldType.termQuery(f, context);, +            }]