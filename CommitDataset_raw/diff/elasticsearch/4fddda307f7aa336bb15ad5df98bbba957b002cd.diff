[+++ b/src/main/java/org/elasticsearch/discovery/zen/ZenDiscovery.java, +import org.elasticsearch.common.logging.ESLogger;, +import java.util.Queue;, +                ClusterState currentState = clusterService.state();, +                if (shouldIgnoreNewClusterState(logger, currentState, newClusterState)) {, +                    return;, +                }, +, +                        ClusterState updatedState = selectNextStateToProcess(processNewClusterStates);, +                        if (updatedState == null) {, +                            updatedState = currentState;, +                        if (shouldIgnoreNewClusterState(logger, currentState, updatedState)) {, +                        //    return disconnectFromCluster(newState, "not enough master nodes on new cluster state wreceived from [" + newState.nodes().masterNode() + "]");, +    /**, +     * Picks the cluster state with highest version with the same master from the queue. All cluster states with, +     * lower versions are ignored. If a cluster state with a different master is seen the processing logic stops and the, +     * last processed state is returned., +     */, +    static ClusterState selectNextStateToProcess(Queue<ProcessClusterState> processNewClusterStates) {, +        // try and get the state with the highest version out of all the ones with the same master node id, +        ProcessClusterState stateToProcess = processNewClusterStates.poll();, +        if (stateToProcess == null) {, +            return null;, +        }, +        stateToProcess.processed = true;, +        while (true) {, +            ProcessClusterState potentialState = processNewClusterStates.peek();, +            // nothing else in the queue, bail, +            if (potentialState == null) {, +                break;, +            }, +            // if its not from the same master, then bail, +            if (!Objects.equal(stateToProcess.clusterState.nodes().masterNodeId(), potentialState.clusterState.nodes().masterNodeId())) {, +                break;, +            }, +            // we are going to use it for sure, poll (remove) it, +            potentialState = processNewClusterStates.poll();, +            if (potentialState == null) {, +                // might happen if the queue is drained, +                break;, +            }, +            potentialState.processed = true;, +, +            if (potentialState.clusterState.version() > stateToProcess.clusterState.version()) {, +                // we found a new one, +                stateToProcess = potentialState;, +            }, +        }, +        return stateToProcess.clusterState;, +    }, +, +    /**, +     * In the case we follow an elected master the new cluster state needs to have the same elected master and, +     * the new cluster state version needs to be equal or higher than our cluster state version. If either conditions, +     * are true then the cluster state is dated and we should ignore it., +     */, +    static boolean shouldIgnoreNewClusterState(ESLogger logger, ClusterState currentState, ClusterState newClusterState) {, +        if (currentState.nodes().masterNodeId() == null) {, +            return false;, +        }, +        if (!currentState.nodes().masterNodeId().equals(newClusterState.nodes().masterNodeId())) {, +            logger.warn("received a cluster state from a different master then the current one, ignoring (received {}, current {})", newClusterState.nodes().masterNode(), currentState.nodes().masterNode());, +            return true;, +        } else if (newClusterState.version() < currentState.version()) {, +            // if the new state has a smaller version, and it has the same master node, then no need to process it, +            logger.debug("received a cluster state that has a lower version than the current one, ignoring (received {}, current {})", newClusterState.version(), currentState.version());, +            return true;, +        } else {, +            return false;, +        }, +    }, +, +++ b/src/main/java/org/elasticsearch/discovery/zen/ZenDiscovery.java, +import org.elasticsearch.common.logging.ESLogger;, +import java.util.Queue;, +                ClusterState currentState = clusterService.state();, +                if (shouldIgnoreNewClusterState(logger, currentState, newClusterState)) {, +                    return;, +                }, +, +                        ClusterState updatedState = selectNextStateToProcess(processNewClusterStates);, +                        if (updatedState == null) {, +                            updatedState = currentState;, +                        if (shouldIgnoreNewClusterState(logger, currentState, updatedState)) {, +                        //    return disconnectFromCluster(newState, "not enough master nodes on new cluster state wreceived from [" + newState.nodes().masterNode() + "]");, +    /**, +     * Picks the cluster state with highest version with the same master from the queue. All cluster states with, +     * lower versions are ignored. If a cluster state with a different master is seen the processing logic stops and the, +     * last processed state is returned., +     */, +    static ClusterState selectNextStateToProcess(Queue<ProcessClusterState> processNewClusterStates) {, +        // try and get the state with the highest version out of all the ones with the same master node id, +        ProcessClusterState stateToProcess = processNewClusterStates.poll();, +        if (stateToProcess == null) {, +            return null;, +        }, +        stateToProcess.processed = true;, +        while (true) {, +            ProcessClusterState potentialState = processNewClusterStates.peek();, +            // nothing else in the queue, bail]