[+++ b/core/src/main/java/org/elasticsearch/cluster/action/shard/ShardStateAction.java, +    private final ShardStartedClusterStateHandler shardStartedClusterStateHandler =, +            new ShardStartedClusterStateHandler();, +, +        clusterService.submitStateUpdateTask(, +                "shard-started (" + shardRoutingEntry.shardRouting + "), reason [" + shardRoutingEntry.message + "]",, +                shardRoutingEntry,, +                ClusterStateTaskConfig.build(Priority.URGENT),, +                shardStartedClusterStateHandler,, +                shardStartedClusterStateHandler);, +    }, +, +    class ShardStartedClusterStateHandler implements ClusterStateTaskExecutor<ShardRoutingEntry>, ClusterStateTaskListener {, +        public BatchResult<ShardRoutingEntry> execute(ClusterState currentState, List<ShardRoutingEntry> tasks) throws Exception {, +            BatchResult.Builder<ShardRoutingEntry> builder = BatchResult.builder();, +            ClusterState accumulator = ClusterState.builder(currentState).build();, +            for (ShardRoutingEntry task : tasks) {, +                task.processed = true;, +                try {, +                    RoutingAllocation.Result result =, +                            allocationService.applyStartedShard(currentState, task.shardRouting, true);, +                    builder.success(task);, +                    if (result.changed()) {, +                        accumulator = ClusterState.builder(accumulator).routingResult(result).build();, +                    }, +                } catch (Throwable t) {, +                    builder.failure(task, t);, +                }, +            return builder.build(accumulator);, +++ b/core/src/main/java/org/elasticsearch/cluster/action/shard/ShardStateAction.java, +    private final ShardStartedClusterStateHandler shardStartedClusterStateHandler =, +            new ShardStartedClusterStateHandler();, +, +        clusterService.submitStateUpdateTask(, +                "shard-started (" + shardRoutingEntry.shardRouting + "), reason [" + shardRoutingEntry.message + "]",, +                shardRoutingEntry,, +                ClusterStateTaskConfig.build(Priority.URGENT),, +                shardStartedClusterStateHandler,, +                shardStartedClusterStateHandler);, +    }, +, +    class ShardStartedClusterStateHandler implements ClusterStateTaskExecutor<ShardRoutingEntry>, ClusterStateTaskListener {, +        public BatchResult<ShardRoutingEntry> execute(ClusterState currentState, List<ShardRoutingEntry> tasks) throws Exception {, +            BatchResult.Builder<ShardRoutingEntry> builder = BatchResult.builder();, +            ClusterState accumulator = ClusterState.builder(currentState).build();, +            for (ShardRoutingEntry task : tasks) {, +                task.processed = true;, +                try {, +                    RoutingAllocation.Result result =, +                            allocationService.applyStartedShard(currentState, task.shardRouting, true);, +                    builder.success(task);, +                    if (result.changed()) {, +                        accumulator = ClusterState.builder(accumulator).routingResult(result).build();, +                    }, +                } catch (Throwable t) {, +                    builder.failure(task, t);, +                }, +            return builder.build(accumulator);, +++ b/core/src/main/java/org/elasticsearch/cluster/routing/allocation/AllocationService.java, +     * Applies the started shard. Note, shards can be called several, +     * times within this method. If the same instance of the routing, +     * table is returned, then no change has been made., +     * @param clusterState the cluster state, +     * @param startedShard the shard to start, +     * @param withReroute whether or not to reroute the resulting allocation, +     * @return the resulting routing table, +     */, +    public RoutingAllocation.Result applyStartedShard(, +            ClusterState clusterState,, +            ShardRouting startedShard,, +            boolean withReroute) {, +        return applyStartedShards(clusterState, Collections.singletonList(startedShard), withReroute);, +    }, +, +    /**]