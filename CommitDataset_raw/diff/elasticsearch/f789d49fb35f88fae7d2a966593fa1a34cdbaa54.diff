[+++ b/server/src/main/java/org/elasticsearch/cluster/routing/IndexRoutingTable.java, +                    shardRouting.recoverySource().getType() == RecoverySource.Type.EXISTING_STORE) {, +                    if (inSyncAllocationIds.contains(RecoverySource.ExistingStoreRecoverySource.FORCED_ALLOCATION_ID)) {, +                        if (inSyncAllocationIds.size() != 1) {, +                            throw new IllegalStateException("a primary shard routing " + shardRouting, +                                + " is a primary that is recovering from a stale primary has unexpected allocation ids in in-sync " +, +                        }, +                    } else if (inSyncAllocationIds.contains(shardRouting.allocationId().getId()) == false) {, +                        throw new IllegalStateException("a primary shard routing " + shardRouting, +                            + " is a primary that is recovering from a known allocation id but has no corresponding entry in the in-sync " +, +                            "allocation set " + inSyncAllocationIds);, +                    }, +                }, +++ b/server/src/main/java/org/elasticsearch/cluster/routing/IndexRoutingTable.java, +                    shardRouting.recoverySource().getType() == RecoverySource.Type.EXISTING_STORE) {, +                    if (inSyncAllocationIds.contains(RecoverySource.ExistingStoreRecoverySource.FORCED_ALLOCATION_ID)) {, +                        if (inSyncAllocationIds.size() != 1) {, +                            throw new IllegalStateException("a primary shard routing " + shardRouting, +                                + " is a primary that is recovering from a stale primary has unexpected allocation ids in in-sync " +, +                        }, +                    } else if (inSyncAllocationIds.contains(shardRouting.allocationId().getId()) == false) {, +                        throw new IllegalStateException("a primary shard routing " + shardRouting, +                            + " is a primary that is recovering from a known allocation id but has no corresponding entry in the in-sync " +, +                            "allocation set " + inSyncAllocationIds);, +                    }, +                }, +++ b/server/src/main/java/org/elasticsearch/cluster/routing/RecoverySource.java, +        /**, +         * Special allocation id that shard has during initialization on allocate_stale_primary, +         */, +        public static final String FORCED_ALLOCATION_ID = "_forced_allocation_";, +, +++ b/server/src/main/java/org/elasticsearch/cluster/routing/IndexRoutingTable.java, +                    shardRouting.recoverySource().getType() == RecoverySource.Type.EXISTING_STORE) {, +                    if (inSyncAllocationIds.contains(RecoverySource.ExistingStoreRecoverySource.FORCED_ALLOCATION_ID)) {, +                        if (inSyncAllocationIds.size() != 1) {, +                            throw new IllegalStateException("a primary shard routing " + shardRouting, +                                + " is a primary that is recovering from a stale primary has unexpected allocation ids in in-sync " +, +                        }, +                    } else if (inSyncAllocationIds.contains(shardRouting.allocationId().getId()) == false) {, +                        throw new IllegalStateException("a primary shard routing " + shardRouting, +                            + " is a primary that is recovering from a known allocation id but has no corresponding entry in the in-sync " +, +                            "allocation set " + inSyncAllocationIds);, +                    }, +                }, +++ b/server/src/main/java/org/elasticsearch/cluster/routing/RecoverySource.java, +        /**, +         * Special allocation id that shard has during initialization on allocate_stale_primary, +         */, +        public static final String FORCED_ALLOCATION_ID = "_forced_allocation_";, +, +++ b/server/src/main/java/org/elasticsearch/cluster/routing/allocation/IndexMetaDataUpdater.java, +import java.util.Objects;, +        assert Objects.equals(initializingShard.allocationId().getId(), startedShard.allocationId().getId()), +            : "initializingShard.allocationId [" + initializingShard.allocationId().getId(), +            + "] and startedShard.allocationId [" + startedShard.allocationId().getId() + "] have to have the same";, +        Updates updates = changes(startedShard.shardId());, +        updates.addedAllocationIds.add(startedShard.allocationId().getId());, +        if (startedShard.primary(), +            // started shard has to have null recoverySource; have to pick up recoverySource from its initializing state, +            && (initializingShard.recoverySource() == RecoverySource.ExistingStoreRecoverySource.FORCE_STALE_PRIMARY_INSTANCE)) {, +            updates.removedAllocationIds.add(RecoverySource.ExistingStoreRecoverySource.FORCED_ALLOCATION_ID);, +        }, +            RecoverySource recoverySource = updates.initializedPrimary.recoverySource();, +            RecoverySource.Type recoverySourceType = recoverySource.getType();, +                final String allocationId;, +                if (recoverySource == RecoverySource.ExistingStoreRecoverySource.FORCE_STALE_PRIMARY_INSTANCE) {, +                    allocationId = RecoverySource.ExistingStoreRecoverySource.FORCED_ALLOCATION_ID;, +                } else {, +                    assert recoverySource instanceof RecoverySource.SnapshotRecoverySource : recoverySource;, +                    allocationId = updates.initializedPrimary.allocationId().getId();, +                }, +                indexMetaDataBuilder.putInSyncAllocationIds(shardId.id(), Collections.singleton(allocationId));, +            assert oldInSyncAllocationIds.contains(RecoverySource.ExistingStoreRecoverySource.FORCED_ALLOCATION_ID) == false, +                || inSyncAllocationIds.contains(RecoverySource.ExistingStoreRecoverySource.FORCED_ALLOCATION_ID) == false :, +                "fake allocation id has to be removed, inSyncAllocationIds:" + inSyncAllocationIds;, +, +++ b/server/src/main/java/org/elasticsearch/cluster/routing/IndexRoutingTable.java, +                    shardRouting.recoverySource().getType() == RecoverySource.Type.EXISTING_STORE) {, +                    if (inSyncAllocationIds.contains(RecoverySource.ExistingStoreRecoverySource.FORCED_ALLOCATION_ID)) {, +                        if (inSyncAllocationIds.size() != 1) {, +                            throw new IllegalStateException("a primary shard routing " + shardRouting, +                                + " is a primary that is recovering from a stale primary has unexpected allocation ids in in-sync " +, +                        }, +                    } else if (inSyncAllocationIds.contains(shardRouting.allocationId().getId()) == false) {, +                        throw new IllegalStateException("a primary shard routing " + shardRouting, +                            + " is a primary that is recovering from a known allocation id but has no corresponding entry in the in-sync " +, +                            "allocation set " + inSyncAllocationIds);, +                    }, +                }, +++ b/server/src/main/java/org/elasticsearch/cluster/routing/RecoverySource.java, +        /**, +         * Special allocation id that shard has during initialization on allocate_stale_primary, +         */, +        public static final String FORCED_ALLOCATION_ID = "_forced_allocation_";, +, +++ b/server/src/main/java/org/elasticsearch/cluster/routing/allocation/IndexMetaDataUpdater.java, +import java.util.Objects;, +        assert Objects.equals(initializingShard.allocationId().getId(), startedShard.allocationId().getId()), +            : "initializingShard.allocationId [" + initializingShard.allocationId().getId()]