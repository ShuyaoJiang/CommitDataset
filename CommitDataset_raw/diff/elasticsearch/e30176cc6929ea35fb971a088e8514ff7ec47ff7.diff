[+++ b/src/main/java/org/elasticsearch/common/util/concurrent/KeyedLock.java, +import java.util.concurrent.locks.Lock;, +import java.util.concurrent.locks.ReadWriteLock;, +import java.util.concurrent.locks.ReentrantReadWriteLock;, +    protected final ThreadLocal<KeyLock> threadLocal = new ThreadLocal<>();, +                throw new ElasticsearchIllegalStateException("Lock already acquired in Thread" + Thread.currentThread().getId(), +            throw new ElasticsearchIllegalStateException("Lock not acquired");, +        release(key, lock);, +    }, +, +    void release(T key, KeyLock lock) {, +, +    /**, +     * A {@link KeyedLock} that allows to acquire a global lock that guarantees, +     * exclusive access to the resource the KeyedLock is guarding., +     */, +    public final static class GlobalLockable<T> extends KeyedLock<T> {, +, +        private final ReadWriteLock lock = new ReentrantReadWriteLock();, +, +        @Override, +        public void acquire(T key) {, +            boolean success = false;, +            lock.readLock().lock();, +            try {, +                super.acquire(key);, +                success = true;, +            } finally {, +                if (!success) {, +                    lock.readLock().unlock();, +                }, +            }, +        }, +, +        @Override, +        public void release(T key) {, +            KeyLock keyLock = threadLocal.get();, +            if (keyLock == null) {, +                throw new ElasticsearchIllegalStateException("Lock not acquired");, +            }, +            try {, +                release(key, keyLock);, +            } finally {, +                lock.readLock().unlock();, +            }, +        }, +, +        /**, +         * Returns a global lock guaranteeing exclusive access to the resource, +         * this KeyedLock is guarding., +         */, +        public Lock globalLock() {, +            return lock.writeLock();, +        }, +    }, +, +++ b/src/main/java/org/elasticsearch/common/util/concurrent/KeyedLock.java, +import java.util.concurrent.locks.Lock;, +import java.util.concurrent.locks.ReadWriteLock;, +import java.util.concurrent.locks.ReentrantReadWriteLock;, +    protected final ThreadLocal<KeyLock> threadLocal = new ThreadLocal<>();, +                throw new ElasticsearchIllegalStateException("Lock already acquired in Thread" + Thread.currentThread().getId(), +            throw new ElasticsearchIllegalStateException("Lock not acquired");, +        release(key, lock);, +    }, +, +    void release(T key, KeyLock lock) {, +, +    /**, +     * A {@link KeyedLock} that allows to acquire a global lock that guarantees, +     * exclusive access to the resource the KeyedLock is guarding., +     */, +    public final static class GlobalLockable<T> extends KeyedLock<T> {, +, +        private final ReadWriteLock lock = new ReentrantReadWriteLock();, +, +        @Override, +        public void acquire(T key) {, +            boolean success = false;, +            lock.readLock().lock();, +            try {, +                super.acquire(key);, +                success = true;, +            } finally {, +                if (!success) {, +                    lock.readLock().unlock();, +                }, +            }, +        }, +, +        @Override, +        public void release(T key) {, +            KeyLock keyLock = threadLocal.get();, +            if (keyLock == null) {, +                throw new ElasticsearchIllegalStateException("Lock not acquired");, +            }, +            try {, +                release(key, keyLock);, +            } finally {, +                lock.readLock().unlock();]