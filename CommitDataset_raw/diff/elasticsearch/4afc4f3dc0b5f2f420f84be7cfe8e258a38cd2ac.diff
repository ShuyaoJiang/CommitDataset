[+++ b/core/src/main/java/org/elasticsearch/action/percolate/TransportShardMultiPercolateAction.java, +++ b/core/src/main/java/org/elasticsearch/action/percolate/TransportShardMultiPercolateAction.java, +++ b/core/src/main/java/org/elasticsearch/cluster/service/InternalClusterService.java, +import org.elasticsearch.common.text.Text;, +            pendingClusterTasks.add(new PendingClusterTask(pending.insertionOrder, pending.priority, new Text(source), timeInQueue, pending.executing));, +++ b/core/src/main/java/org/elasticsearch/action/percolate/TransportShardMultiPercolateAction.java, +++ b/core/src/main/java/org/elasticsearch/cluster/service/InternalClusterService.java, +import org.elasticsearch.common.text.Text;, +            pendingClusterTasks.add(new PendingClusterTask(pending.insertionOrder, pending.priority, new Text(source), timeInQueue, pending.executing));, +++ b/core/src/main/java/org/elasticsearch/common/io/stream/StreamInput.java, +import org.elasticsearch.common.text.Text;, +        return new Text(readBytesReference(length));, +        return new Text(readBytesReference(length));, +++ b/core/src/main/java/org/elasticsearch/action/percolate/TransportShardMultiPercolateAction.java, +++ b/core/src/main/java/org/elasticsearch/cluster/service/InternalClusterService.java, +import org.elasticsearch.common.text.Text;, +            pendingClusterTasks.add(new PendingClusterTask(pending.insertionOrder, pending.priority, new Text(source), timeInQueue, pending.executing));, +++ b/core/src/main/java/org/elasticsearch/common/io/stream/StreamInput.java, +import org.elasticsearch.common.text.Text;, +        return new Text(readBytesReference(length));, +        return new Text(readBytesReference(length));, +++ /dev/null, +++ b/core/src/main/java/org/elasticsearch/action/percolate/TransportShardMultiPercolateAction.java, +++ b/core/src/main/java/org/elasticsearch/cluster/service/InternalClusterService.java, +import org.elasticsearch.common.text.Text;, +            pendingClusterTasks.add(new PendingClusterTask(pending.insertionOrder, pending.priority, new Text(source), timeInQueue, pending.executing));, +++ b/core/src/main/java/org/elasticsearch/common/io/stream/StreamInput.java, +import org.elasticsearch.common.text.Text;, +        return new Text(readBytesReference(length));, +        return new Text(readBytesReference(length));, +++ /dev/null, +++ /dev/null, +++ b/core/src/main/java/org/elasticsearch/action/percolate/TransportShardMultiPercolateAction.java, +++ b/core/src/main/java/org/elasticsearch/cluster/service/InternalClusterService.java, +import org.elasticsearch.common.text.Text;, +            pendingClusterTasks.add(new PendingClusterTask(pending.insertionOrder, pending.priority, new Text(source), timeInQueue, pending.executing));, +++ b/core/src/main/java/org/elasticsearch/common/io/stream/StreamInput.java, +import org.elasticsearch.common.text.Text;, +        return new Text(readBytesReference(length));, +        return new Text(readBytesReference(length));, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/core/src/main/java/org/elasticsearch/action/percolate/TransportShardMultiPercolateAction.java, +++ b/core/src/main/java/org/elasticsearch/cluster/service/InternalClusterService.java, +import org.elasticsearch.common.text.Text;, +            pendingClusterTasks.add(new PendingClusterTask(pending.insertionOrder, pending.priority, new Text(source), timeInQueue, pending.executing));, +++ b/core/src/main/java/org/elasticsearch/common/io/stream/StreamInput.java, +import org.elasticsearch.common.text.Text;, +        return new Text(readBytesReference(length));, +        return new Text(readBytesReference(length));, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/core/src/main/java/org/elasticsearch/common/text/Text.java, +import java.nio.charset.StandardCharsets;, +import org.elasticsearch.common.bytes.BytesArray;, +/**, + * Both {@link String} and {@link BytesReference} representation of the text. Starts with one of those, and if, + * the other is requests, caches the other one in a local reference so no additional conversion will be needed., + */, +public final class Text implements Comparable<Text> {, +, +    public static final Text[] EMPTY_ARRAY = new Text[0];, +, +    public static Text[] convertFromStringArray(String[] strings) {, +        if (strings.length == 0) {, +            return EMPTY_ARRAY;, +        }, +        Text[] texts = new Text[strings.length];, +        for (int i = 0; i < strings.length; i++) {, +            texts[i] = new Text(strings[i]);, +        }, +        return texts;, +    }, +, +    private BytesReference bytes;, +    private String text;, +    private int hash;, +, +    public Text(BytesReference bytes) {, +        this.bytes = bytes;, +    }, +, +    public Text(String text) {, +        this.text = text;, +    }, +     * Whether a {@link BytesReference} view of the data is already materialized., +    public boolean hasBytes() {, +        return bytes != null;, +    }, +     * Returns a {@link BytesReference} view of the data., +    public BytesReference bytes() {, +        if (bytes == null) {, +            bytes = new BytesArray(text.getBytes(StandardCharsets.UTF_8));, +        }, +        return bytes;, +    }, +     * Whether a {@link String} view of the data is already materialized., +    public boolean hasString() {]