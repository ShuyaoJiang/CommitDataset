[+++ b/server/src/main/java/org/elasticsearch/index/shard/IndexShard.java, +import org.elasticsearch.index.engine.ReadOnlyEngine;, +import java.util.function.Function;, +        return applyIndexOperation(getEngine(), UNASSIGNED_SEQ_NO, operationPrimaryTerm, version, versionType, autoGeneratedTimestamp,, +        return applyIndexOperation(getEngine(), seqNo, operationPrimaryTerm, version, null, autoGeneratedTimeStamp, isRetry,, +    private Engine.IndexResult applyIndexOperation(Engine engine, long seqNo, long opPrimaryTerm, long version,, +                                                   @Nullable VersionType versionType, long autoGeneratedTimeStamp, boolean isRetry,, +                                                   Engine.Operation.Origin origin, SourceToParse sourceToParse) throws IOException {, +        return index(engine, operation);, +        return markSeqNoAsNoop(getEngine(), seqNo, operationPrimaryTerm, reason, Engine.Operation.Origin.REPLICA);, +    private Engine.NoOpResult markSeqNoAsNoop(Engine engine, long seqNo, long opPrimaryTerm, String reason,, +        return noOp(engine, noOp);, +        return applyDeleteOperation(getEngine(), UNASSIGNED_SEQ_NO, operationPrimaryTerm, version, type, id, versionType,, +        return applyDeleteOperation(getEngine(), seqNo, operationPrimaryTerm, version, type, id, null, Engine.Operation.Origin.REPLICA);, +    private Engine.DeleteResult applyDeleteOperation(Engine engine, long seqNo, long opPrimaryTerm, long version, String type, String id,, +        return delete(engine, delete);, +        return applyTranslogOperation(getEngine(), operation, origin);, +    }, +, +    private Engine.Result applyTranslogOperation(Engine engine, Translog.Operation operation,, +                                                 Engine.Operation.Origin origin) throws IOException {, +                result = applyIndexOperation(engine, index.seqNo(), index.primaryTerm(), index.version(),, +                result = applyDeleteOperation(engine, delete.seqNo(), delete.primaryTerm(), delete.version(), delete.type(), delete.id(),, +                result = markSeqNoAsNoop(engine, noOp.seqNo(), noOp.primaryTerm(), noOp.reason(), origin);, +                Engine.Result result = applyTranslogOperation(engine, operation, origin);, +        synchronized (mutex) {, +            assert currentEngineReference.get() == null : "engine is running";, +            // we must create a new engine under mutex (see IndexShard#snapshotStoreMetadata)., +            final Engine newEngine = engineFactory.newReadWriteEngine(config);, +            onNewEngine(newEngine);, +            currentEngineReference.set(newEngine);, +            // We set active because we are now writing operations to the engine; this way,, +            // if we go idle after some time and become inactive, we still give sync'd flush a chance to run., +        }, +        // time elapses after the engine is created above (pulling the config settings) until we set the engine reference, during, +        // which settings changes could possibly have happened, so here we forcefully push any config changes to the new engine., +        onSettingsChanged();, +        assert currentEngineReference.get() == null || currentEngineReference.get() instanceof ReadOnlyEngine : "a write engine is running";, +        final SeqNoStats seqNoStats = seqNoStats();, +        final TranslogStats translogStats = translogStats();, +        // flush to make sure the latest commit, which will be opened by the read-only engine, includes all operations., +        flush(new FlushRequest().waitIfOngoing(true));, +            // we must create a new engine under mutex (see IndexShard#snapshotStoreMetadata)., +            final Engine readOnlyEngine = new ReadOnlyEngine(newEngineConfig(), seqNoStats, translogStats, false, Function.identity());, +            IOUtils.close(currentEngineReference.getAndSet(readOnlyEngine));, +        }, +, +        Engine newEngine = null;, +        try {, +            final long globalCheckpoint = getGlobalCheckpoint();, +            synchronized (mutex) {, +                verifyNotClosed();, +                // we must create a new engine under mutex (see IndexShard#snapshotStoreMetadata)., +                newEngine = engineFactory.newReadWriteEngine(newEngineConfig());, +                onNewEngine(newEngine);, +            synchronized (mutex) {, +                verifyNotClosed();, +                IOUtils.close(currentEngineReference.getAndSet(newEngine));, +                // We set active because we are now writing operations to the engine; this way,, +                // if we go idle after some time and become inactive, we still give sync'd flush a chance to run., +                active.set(true);, +                newEngine = null;, +            }, +            // time elapses after the engine is created above (pulling the config settings) until we set the engine reference, during, +            // which settings changes could possibly have happened, so here we forcefully push any config changes to the new engine., +            onSettingsChanged();, +        } finally {, +            IOUtils.close(newEngine);, +        }, +++ b/server/src/main/java/org/elasticsearch/index/shard/IndexShard.java, +import org.elasticsearch.index.engine.ReadOnlyEngine;, +import java.util.function.Function;, +        return applyIndexOperation(getEngine(), UNASSIGNED_SEQ_NO, operationPrimaryTerm, version, versionType, autoGeneratedTimestamp,, +        return applyIndexOperation(getEngine(), seqNo, operationPrimaryTerm, version, null, autoGeneratedTimeStamp, isRetry,, +    private Engine.IndexResult applyIndexOperation(Engine engine, long seqNo, long opPrimaryTerm, long version,, +                                                   @Nullable VersionType versionType, long autoGeneratedTimeStamp, boolean isRetry,, +                                                   Engine.Operation.Origin origin, SourceToParse sourceToParse) throws IOException {, +        return index(engine, operation);, +        return markSeqNoAsNoop(getEngine(), seqNo, operationPrimaryTerm, reason, Engine.Operation.Origin.REPLICA);, +    private Engine.NoOpResult markSeqNoAsNoop(Engine engine, long seqNo, long opPrimaryTerm, String reason,, +        return noOp(engine, noOp);, +        return applyDeleteOperation(getEngine(), UNASSIGNED_SEQ_NO, operationPrimaryTerm, version, type, id, versionType,, +        return applyDeleteOperation(getEngine(), seqNo, operationPrimaryTerm, version, type, id, null, Engine.Operation.Origin.REPLICA);, +    private Engine.DeleteResult applyDeleteOperation(Engine engine, long seqNo, long opPrimaryTerm, long version, String type, String id,, +        return delete(engine, delete);, +        return applyTranslogOperation(getEngine(), operation, origin);, +    }, +, +    private Engine.Result applyTranslogOperation(Engine engine, Translog.Operation operation,, +                                                 Engine.Operation.Origin origin) throws IOException {, +                result = applyIndexOperation(engine, index.seqNo(), index.primaryTerm(), index.version(),, +                result = applyDeleteOperation(engine, delete.seqNo(), delete.primaryTerm(), delete.version(), delete.type(), delete.id(),, +                result = markSeqNoAsNoop(engine, noOp.seqNo(), noOp.primaryTerm(), noOp.reason(), origin);, +                Engine.Result result = applyTranslogOperation(engine, operation, origin);, +        synchronized (mutex) {, +            assert currentEngineReference.get() == null : "engine is running";, +            // we must create a new engine under mutex (see IndexShard#snapshotStoreMetadata)., +            final Engine newEngine = engineFactory.newReadWriteEngine(config);, +            onNewEngine(newEngine);, +            currentEngineReference.set(newEngine);]