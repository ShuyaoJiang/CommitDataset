[+++ b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/execution/search/extractor/FieldHitExtractor.java, +import org.elasticsearch.common.collect.Tuple;, +import java.util.ArrayDeque;, +import java.util.Deque;, +import java.util.StringJoiner;, +        Object value = null;, +, +        // Used to avoid recursive method calls, +        // Holds the sub-maps in the document hierarchy that are pending to be inspected., +        // along with the current index of the `path`., +        Deque<Tuple<Integer, Map<String, Object>>> queue = new ArrayDeque<>();, +        queue.add(new Tuple<>(-1, map));, +, +        while (!queue.isEmpty()) {, +            Tuple<Integer, Map<String, Object>> tuple = queue.removeLast();, +            int idx = tuple.v1();, +            Map<String, Object> subMap = tuple.v2();, +, +            // Find all possible entries by examining all combinations under the current level ("idx") of the "path", +            // e.g.: If the path == "a.b.c.d" and the idx == 0, we need to check the current subMap against the keys:, +            //       "b", "b.c" and "b.c.d", +            StringJoiner sj = new StringJoiner(".");, +            for (int i = idx + 1; i < path.length; i++) {, +                sj.add(path[i]);, +                Object node = subMap.get(sj.toString());, +                if (node instanceof Map) {, +                    // Add the sub-map to the queue along with the current path index, +                    queue.add(new Tuple<>(i, (Map<String, Object>) node));, +                } else if (node != null) {, +                    if (i < path.length - 1) {, +                        // If we reach a concrete value without exhausting the full path, something is wrong with the mapping, +                        // e.g.: map is {"a" : { "b" : "value }} and we are looking for a path: "a.b.c.d", +                    if (value != null) {, +                        // A value has already been found so this means that there are more than one, +                        // values in the document for the same path but different hierarchy., +                        // e.g.: {"a" : {"b" : {"c" : "value"}}}, {"a.b" : {"c" : "value"}}, ..., +                        throw new SqlIllegalArgumentException("Multiple values (returned by [{}]) are not supported", fieldName);, +                    }, +                    value = node;, +                }, +            }, +++ b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/execution/search/extractor/FieldHitExtractor.java, +import org.elasticsearch.common.collect.Tuple;, +import java.util.ArrayDeque;, +import java.util.Deque;, +import java.util.StringJoiner;, +        Object value = null;, +, +        // Used to avoid recursive method calls, +        // Holds the sub-maps in the document hierarchy that are pending to be inspected., +        // along with the current index of the `path`., +        Deque<Tuple<Integer, Map<String, Object>>> queue = new ArrayDeque<>();, +        queue.add(new Tuple<>(-1, map));, +, +        while (!queue.isEmpty()) {, +            Tuple<Integer, Map<String, Object>> tuple = queue.removeLast();, +            int idx = tuple.v1();, +            Map<String, Object> subMap = tuple.v2();, +, +            // Find all possible entries by examining all combinations under the current level ("idx") of the "path", +            // e.g.: If the path == "a.b.c.d" and the idx == 0, we need to check the current subMap against the keys:, +            //       "b", "b.c" and "b.c.d", +            StringJoiner sj = new StringJoiner(".");, +            for (int i = idx + 1; i < path.length; i++) {, +                sj.add(path[i]);, +                Object node = subMap.get(sj.toString());, +                if (node instanceof Map) {, +                    // Add the sub-map to the queue along with the current path index, +                    queue.add(new Tuple<>(i, (Map<String, Object>) node));, +                } else if (node != null) {, +                    if (i < path.length - 1) {, +                        // If we reach a concrete value without exhausting the full path, something is wrong with the mapping, +                        // e.g.: map is {"a" : { "b" : "value }} and we are looking for a path: "a.b.c.d", +                    if (value != null) {, +                        // A value has already been found so this means that there are more than one, +                        // values in the document for the same path but different hierarchy., +                        // e.g.: {"a" : {"b" : {"c" : "value"}}}, {"a.b" : {"c" : "value"}}, ..., +                        throw new SqlIllegalArgumentException("Multiple values (returned by [{}]) are not supported", fieldName);, +                    }, +                    value = node;, +                }, +            }, +++ b/x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/execution/search/extractor/FieldHitExtractorTests.java, +import java.util.HashMap;, +import java.util.StringJoiner;, +    protected FieldHitExtractor mutateInstance(FieldHitExtractor instance) {, +    public void testFieldWithDots() {, +        FieldHitExtractor fe = new FieldHitExtractor("a.b", null, false);, +        Object value = randomValue();, +        Map<String, Object> map = singletonMap("a.b", value);, +        assertEquals(value, fe.extractFromSource(map));, +    }, +, +    public void testNestedFieldWithDots() {, +        FieldHitExtractor fe = new FieldHitExtractor("a.b.c", null, false);, +        Object value = randomValue();, +        Map<String, Object> map = singletonMap("a", singletonMap("b.c", value));, +        assertEquals(value, fe.extractFromSource(map));, +    }, +]