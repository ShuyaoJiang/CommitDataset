[+++ b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/upgrade/IndexUpgradeCheckVersion.java, +    public static final int UPGRADE_VERSION = 6;, +++ b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/upgrade/IndexUpgradeCheckVersion.java, +    public static final int UPGRADE_VERSION = 6;, +++ b/x-pack/plugin/upgrade/src/main/java/org/elasticsearch/xpack/upgrade/IndexUpgradeCheck.java, +import org.elasticsearch.ElasticsearchException;, +import org.elasticsearch.cluster.routing.allocation.decider.EnableAllocationDecider;, +import org.elasticsearch.cluster.routing.allocation.decider.EnableAllocationDecider.Allocation;, +                (cs, listener) -> {, +                    Allocation clusterRoutingAllocation = EnableAllocationDecider.CLUSTER_ROUTING_ALLOCATION_ENABLE_SETTING, +                            .get(cs.getMetaData().settings());, +                    if (Allocation.NONE == clusterRoutingAllocation) {, +                        listener.onFailure(new ElasticsearchException(, +                                "pre-upgrade check failed, please enable cluster routing allocation using setting [{}]",, +                                EnableAllocationDecider.CLUSTER_ROUTING_ALLOCATION_ENABLE_SETTING.getKey()));, +                    } else {, +                        listener.onResponse(null);, +                    }, +                }, (t, listener) -> listener.onResponse(TransportResponse.Empty.INSTANCE));, +                             BiConsumer<ClusterState, ActionListener<T>> preUpgrade,, +        this.reindexer = new InternalIndexReindexer<>(client, clusterService, IndexUpgradeCheckVersion.UPGRADE_VERSION, updateScript,, +, +    // pkg scope for testing, +    InternalIndexReindexer getInternalIndexReindexer() {, +        return reindexer;, +    }, +++ b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/upgrade/IndexUpgradeCheckVersion.java, +    public static final int UPGRADE_VERSION = 6;, +++ b/x-pack/plugin/upgrade/src/main/java/org/elasticsearch/xpack/upgrade/IndexUpgradeCheck.java, +import org.elasticsearch.ElasticsearchException;, +import org.elasticsearch.cluster.routing.allocation.decider.EnableAllocationDecider;, +import org.elasticsearch.cluster.routing.allocation.decider.EnableAllocationDecider.Allocation;, +                (cs, listener) -> {, +                    Allocation clusterRoutingAllocation = EnableAllocationDecider.CLUSTER_ROUTING_ALLOCATION_ENABLE_SETTING, +                            .get(cs.getMetaData().settings());, +                    if (Allocation.NONE == clusterRoutingAllocation) {, +                        listener.onFailure(new ElasticsearchException(, +                                "pre-upgrade check failed, please enable cluster routing allocation using setting [{}]",, +                                EnableAllocationDecider.CLUSTER_ROUTING_ALLOCATION_ENABLE_SETTING.getKey()));, +                    } else {, +                        listener.onResponse(null);, +                    }, +                }, (t, listener) -> listener.onResponse(TransportResponse.Empty.INSTANCE));, +                             BiConsumer<ClusterState, ActionListener<T>> preUpgrade,, +        this.reindexer = new InternalIndexReindexer<>(client, clusterService, IndexUpgradeCheckVersion.UPGRADE_VERSION, updateScript,, +, +    // pkg scope for testing, +    InternalIndexReindexer getInternalIndexReindexer() {, +        return reindexer;, +    }, +++ b/x-pack/plugin/upgrade/src/main/java/org/elasticsearch/xpack/upgrade/InternalIndexReindexer.java, +import org.apache.logging.log4j.LogManager;, +import org.apache.logging.log4j.Logger;, +import org.elasticsearch.ElasticsearchException;, +import org.elasticsearch.common.Strings;, +    private static final Logger logger = LogManager.getLogger(InternalIndexReindexer.class);, +    private final BiConsumer<ClusterState, ActionListener<T>> preUpgrade;, +                                  BiConsumer<ClusterState,ActionListener<T>> preUpgrade,, +        preUpgrade.accept(clusterState, ActionListener.wrap(, +        logger.trace("upgrading index {} to new index {}", index, newIndex);, +            parentAwareClient.admin().indices().prepareCreate(newIndex).execute(ActionListener.wrap(createIndexResponse -> {, +                setReadOnlyBlock(index, ActionListener.wrap(, +                        setReadOnlyResponse -> reindex(parentAwareClient, index, newIndex, ActionListener.wrap(bulkByScrollResponse -> {, +                            if ((bulkByScrollResponse.getBulkFailures() != null, +                                    && bulkByScrollResponse.getBulkFailures().isEmpty() == false), +                                    || (bulkByScrollResponse.getSearchFailures() != null, +                                            && bulkByScrollResponse.getSearchFailures().isEmpty() == false)) {, +                                ElasticsearchException ex = logAndThrowExceptionForFailures(bulkByScrollResponse);, +                                removeReadOnlyBlockOnReindexFailure(parentAwareClient, index, listener, ex);, +                            } else {, +                                // Successful completion of reindexing - remove read only and delete old index, +                                removeReadOnlyBlock(parentAwareClient, index,, +                                        ActionListener.wrap(unsetReadOnlyResponse -> parentAwareClient.admin().indices().prepareAliases(), +                                                .removeIndex(index).addAlias(newIndex, index), +                                                .execute(ActionListener.wrap(, +                                                        deleteIndexResponse -> listener.onResponse(bulkByScrollResponse),, +                                                        listener::onFailure)),, +                                                listener::onFailure));, +                            }, +                        }, e -> {, +                            logger.error("error occurred while reindexing", e);, +                            removeReadOnlyBlockOnReindexFailure(parentAwareClient, index, listener, e);, +                        })), listener::onFailure));, +            }, listener::onFailure));, +            logger.error("error occurred while upgrading index", ex);, +            removeReadOnlyBlockOnReindexFailure(parentAwareClient, index, listener, ex);, +    private void removeReadOnlyBlockOnReindexFailure(ParentTaskAssigningClient parentAwareClient, String index,, +            ActionListener<BulkByScrollResponse> listener, Exception ex) {, +        removeReadOnlyBlock(parentAwareClient, index, ActionListener.wrap(unsetReadOnlyResponse -> {, +            listener.onFailure(ex);, +        }, e1 -> {, +            listener.onFailure(ex);, +        }));, +    }, +, +    private ElasticsearchException logAndThrowExceptionForFailures(BulkByScrollResponse bulkByScrollResponse) {, +        String bulkFailures = (bulkByScrollResponse.getBulkFailures() != null), +                ? Strings.collectionToCommaDelimitedString(bulkByScrollResponse.getBulkFailures()), +                : "";, +        String searchFailures = (bulkByScrollResponse.getSearchFailures() != null)]