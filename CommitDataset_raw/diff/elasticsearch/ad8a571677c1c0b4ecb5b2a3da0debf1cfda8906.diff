[+++ b/core/src/main/java/org/elasticsearch/http/HttpTransportSettings.java, +import org.elasticsearch.common.unit.TimeValue;, +import java.util.concurrent.TimeUnit;, +    public static final Setting<TimeValue> SETTING_HTTP_READ_TIMEOUT =, +        Setting.timeSetting("http.read_timeout", new TimeValue(30, TimeUnit.SECONDS), new TimeValue(0), Property.NodeScope);, +, +++ b/core/src/main/java/org/elasticsearch/http/HttpTransportSettings.java, +import org.elasticsearch.common.unit.TimeValue;, +import java.util.concurrent.TimeUnit;, +    public static final Setting<TimeValue> SETTING_HTTP_READ_TIMEOUT =, +        Setting.timeSetting("http.read_timeout", new TimeValue(30, TimeUnit.SECONDS), new TimeValue(0), Property.NodeScope);, +, +++ b/modules/transport-netty4/src/main/java/org/elasticsearch/http/netty4/Netty4HttpServerTransport.java, +import io.netty.handler.timeout.ReadTimeoutHandler;, +import static org.elasticsearch.http.HttpTransportSettings.SETTING_HTTP_READ_TIMEOUT;, +    private final int readTimeoutMillis;, +        this.readTimeoutMillis = Math.toIntExact(SETTING_HTTP_READ_TIMEOUT.get(settings).getMillis());, +                logger.trace("Read timeout [{}]", ctx.channel().remoteAddress());, +            ch.pipeline().addLast("read_timeout", new ReadTimeoutHandler(transport.readTimeoutMillis, TimeUnit.MILLISECONDS));, +++ b/core/src/main/java/org/elasticsearch/http/HttpTransportSettings.java, +import org.elasticsearch.common.unit.TimeValue;, +import java.util.concurrent.TimeUnit;, +    public static final Setting<TimeValue> SETTING_HTTP_READ_TIMEOUT =, +        Setting.timeSetting("http.read_timeout", new TimeValue(30, TimeUnit.SECONDS), new TimeValue(0), Property.NodeScope);, +, +++ b/modules/transport-netty4/src/main/java/org/elasticsearch/http/netty4/Netty4HttpServerTransport.java, +import io.netty.handler.timeout.ReadTimeoutHandler;, +import static org.elasticsearch.http.HttpTransportSettings.SETTING_HTTP_READ_TIMEOUT;, +    private final int readTimeoutMillis;, +        this.readTimeoutMillis = Math.toIntExact(SETTING_HTTP_READ_TIMEOUT.get(settings).getMillis());, +                logger.trace("Read timeout [{}]", ctx.channel().remoteAddress());, +            ch.pipeline().addLast("read_timeout", new ReadTimeoutHandler(transport.readTimeoutMillis, TimeUnit.MILLISECONDS));, +++ b/modules/transport-netty4/src/test/java/org/elasticsearch/http/netty4/Netty4HttpServerTransportTests.java, +import io.netty.bootstrap.Bootstrap;, +import io.netty.channel.ChannelFuture;, +import io.netty.channel.ChannelHandlerAdapter;, +import io.netty.channel.ChannelInitializer;, +import io.netty.channel.nio.NioEventLoopGroup;, +import io.netty.channel.socket.SocketChannel;, +import io.netty.channel.socket.nio.NioSocketChannel;, +import org.elasticsearch.common.unit.TimeValue;, +import java.util.concurrent.TimeUnit;, +import java.util.concurrent.atomic.AtomicBoolean;, +, +    public void testReadTimeout() throws Exception {, +        final HttpServerTransport.Dispatcher dispatcher = new HttpServerTransport.Dispatcher() {, +, +            @Override, +            public void dispatchRequest(final RestRequest request, final RestChannel channel, final ThreadContext threadContext) {, +                throw new AssertionError("Should not have received a dispatched request");, +            }, +, +            @Override, +            public void dispatchBadRequest(final RestRequest request,, +                                           final RestChannel channel,, +                                           final ThreadContext threadContext,, +                                           final Throwable cause) {, +                throw new AssertionError("Should not have received a dispatched request");, +            }, +, +        };, +, +        Settings settings = Settings.builder(), +            .put(HttpTransportSettings.SETTING_HTTP_READ_TIMEOUT.getKey(), new TimeValue(randomIntBetween(100, 300))), +            .build();, +, +, +        NioEventLoopGroup group = new NioEventLoopGroup();, +        try (Netty4HttpServerTransport transport =, +                 new Netty4HttpServerTransport(settings, networkService, bigArrays, threadPool, xContentRegistry(), dispatcher)) {, +            transport.start();, +            final TransportAddress remoteAddress = randomFrom(transport.boundAddress.boundAddresses());, +, +            AtomicBoolean channelClosed = new AtomicBoolean(false);, +, +            Bootstrap clientBootstrap = new Bootstrap().channel(NioSocketChannel.class).handler(new ChannelInitializer<SocketChannel>() {, +, +                @Override, +                protected void initChannel(SocketChannel ch) {, +                    ch.pipeline().addLast(new ChannelHandlerAdapter() {});, +, +                }, +            }).group(group);, +            ChannelFuture connect = clientBootstrap.connect(remoteAddress.address());, +            connect.channel().closeFuture().addListener(future -> channelClosed.set(true));, +, +            assertBusy(() -> assertTrue("Channel should be closed due to read timeout", channelClosed.get()), 5, TimeUnit.SECONDS);, +, +        } finally {, +            group.shutdownGracefully().await();, +        }, +    }]