[+++ /dev/null, +++ /dev/null, +++ b/core/src/test/java/org/elasticsearch/index/IndexServiceTests.java, +import static org.elasticsearch.cluster.metadata.IndexMetaData.SETTING_NUMBER_OF_REPLICAS;, +import static org.elasticsearch.cluster.metadata.IndexMetaData.SETTING_NUMBER_OF_SHARDS;, +                .put(SETTING_NUMBER_OF_SHARDS, 2), +                .put(SETTING_NUMBER_OF_REPLICAS, 1), +                .put(SETTING_NUMBER_OF_SHARDS, 2), +                .put(SETTING_NUMBER_OF_REPLICAS, 1), +++ /dev/null, +++ b/core/src/test/java/org/elasticsearch/index/IndexServiceTests.java, +import static org.elasticsearch.cluster.metadata.IndexMetaData.SETTING_NUMBER_OF_REPLICAS;, +import static org.elasticsearch.cluster.metadata.IndexMetaData.SETTING_NUMBER_OF_SHARDS;, +                .put(SETTING_NUMBER_OF_SHARDS, 2), +                .put(SETTING_NUMBER_OF_REPLICAS, 1), +                .put(SETTING_NUMBER_OF_SHARDS, 2), +                .put(SETTING_NUMBER_OF_REPLICAS, 1), +++ b/core/src/test/java/org/elasticsearch/index/replication/ESIndexLevelReplicationTestCase.java, +import org.elasticsearch.index.shard.IndexShardTestCase;, +public abstract class ESIndexLevelReplicationTestCase extends IndexShardTestCase {, +        Settings settings = Settings.builder().put(IndexMetaData.SETTING_VERSION_CREATED, Version.CURRENT), +        IndexMetaData.Builder metaData = IndexMetaData.builder(index.getName()), +            .settings(settings), +            .primaryTerm(0, 1);, +        for (Map.Entry<String, String> typeMapping: indexMapping.entrySet()) {, +            metaData.putMapping(typeMapping.getKey(), typeMapping.getValue());, +        }, +        return new ReplicationGroup(metaData.build());, +        ReplicationGroup(final IndexMetaData indexMetaData) throws IOException {, +            primary = newShard(shardId, true, "s0", indexMetaData, null);, +            final IndexShard replica = newShard(shardId, false,"s" + replicaId.incrementAndGet(), indexMetaData, null);, +                                   boolean markAsRecovering) throws IOException {, +            ESIndexLevelReplicationTestCase.this.recoverReplica(replica, primary, targetSupplier, markAsRecovering);, +                closeShards(this);, +++ /dev/null, +++ b/core/src/test/java/org/elasticsearch/index/IndexServiceTests.java, +import static org.elasticsearch.cluster.metadata.IndexMetaData.SETTING_NUMBER_OF_REPLICAS;, +import static org.elasticsearch.cluster.metadata.IndexMetaData.SETTING_NUMBER_OF_SHARDS;, +                .put(SETTING_NUMBER_OF_SHARDS, 2), +                .put(SETTING_NUMBER_OF_REPLICAS, 1), +                .put(SETTING_NUMBER_OF_SHARDS, 2), +                .put(SETTING_NUMBER_OF_REPLICAS, 1), +++ b/core/src/test/java/org/elasticsearch/index/replication/ESIndexLevelReplicationTestCase.java, +import org.elasticsearch.index.shard.IndexShardTestCase;, +public abstract class ESIndexLevelReplicationTestCase extends IndexShardTestCase {, +        Settings settings = Settings.builder().put(IndexMetaData.SETTING_VERSION_CREATED, Version.CURRENT), +        IndexMetaData.Builder metaData = IndexMetaData.builder(index.getName()), +            .settings(settings), +            .primaryTerm(0, 1);, +        for (Map.Entry<String, String> typeMapping: indexMapping.entrySet()) {, +            metaData.putMapping(typeMapping.getKey(), typeMapping.getValue());, +        }, +        return new ReplicationGroup(metaData.build());, +        ReplicationGroup(final IndexMetaData indexMetaData) throws IOException {, +            primary = newShard(shardId, true, "s0", indexMetaData, null);, +            final IndexShard replica = newShard(shardId, false,"s" + replicaId.incrementAndGet(), indexMetaData, null);, +                                   boolean markAsRecovering) throws IOException {, +            ESIndexLevelReplicationTestCase.this.recoverReplica(replica, primary, targetSupplier, markAsRecovering);, +                closeShards(this);, +++ b/core/src/test/java/org/elasticsearch/index/shard/IndexShardIT.java, +/*, + * Licensed to Elasticsearch under one or more contributor, + * license agreements. See the NOTICE file distributed with, + * this work for additional information regarding copyright, + * ownership. Elasticsearch licenses this file to you under, + * the Apache License, Version 2.0 (the "License"); you may, + * not use this file except in compliance with the License., + * You may obtain a copy of the License at, + *, + *    http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing,, + * software distributed under the License is distributed on an, + * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY, + * KIND, either express or implied.  See the License for the, + * specific language governing permissions and limitations, + * under the License., + */, +package org.elasticsearch.index.shard;, +, +import org.apache.lucene.document.Field;, +import org.apache.lucene.document.NumericDocValuesField;, +import org.apache.lucene.index.Term;, +import org.apache.lucene.store.LockObtainFailedException;, +import org.apache.lucene.util.IOUtils;, +import org.elasticsearch.ExceptionsHelper;, +import org.elasticsearch.Version;, +import org.elasticsearch.action.admin.indices.stats.IndexStats;, +import org.elasticsearch.action.search.SearchResponse;, +import org.elasticsearch.action.support.IndicesOptions;, +import org.elasticsearch.cluster.ClusterInfoService;, +import org.elasticsearch.cluster.ClusterState;, +import org.elasticsearch.cluster.InternalClusterInfoService;, +import org.elasticsearch.cluster.metadata.IndexMetaData;, +import org.elasticsearch.cluster.node.DiscoveryNode;, +import org.elasticsearch.cluster.routing.RecoverySource;, +import org.elasticsearch.cluster.routing.ShardRouting;, +import org.elasticsearch.cluster.routing.ShardRoutingState;, +import org.elasticsearch.cluster.routing.TestShardRouting;, +import org.elasticsearch.cluster.routing.UnassignedInfo;]