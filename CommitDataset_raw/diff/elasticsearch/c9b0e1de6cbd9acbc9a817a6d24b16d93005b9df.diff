[+++ b/src/main/java/org/elasticsearch/action/support/replication/TransportShardReplicationOperationAction.java, +        // we must never reject on because of thread pool capacity on replicas, +        @Override, +        public boolean isForceExecution() {, +            return true;, +        }, +, +++ b/src/main/java/org/elasticsearch/action/support/replication/TransportShardReplicationOperationAction.java, +        // we must never reject on because of thread pool capacity on replicas, +        @Override, +        public boolean isForceExecution() {, +            return true;, +        }, +, +++ b/src/main/java/org/elasticsearch/gateway/local/state/meta/LocalAllocateDangledIndices.java, +    class AllocateDangledRequestHandler extends BaseTransportRequestHandler<AllocateDangledRequest> {, +++ b/src/main/java/org/elasticsearch/action/support/replication/TransportShardReplicationOperationAction.java, +        // we must never reject on because of thread pool capacity on replicas, +        @Override, +        public boolean isForceExecution() {, +            return true;, +        }, +, +++ b/src/main/java/org/elasticsearch/gateway/local/state/meta/LocalAllocateDangledIndices.java, +    class AllocateDangledRequestHandler extends BaseTransportRequestHandler<AllocateDangledRequest> {, +++ b/src/main/java/org/elasticsearch/transport/BaseTransportRequestHandler.java, +    /**, +     * Default force execution to false., +     */, +    @Override, +    public boolean isForceExecution() {, +        return false;, +    }, +++ b/src/main/java/org/elasticsearch/action/support/replication/TransportShardReplicationOperationAction.java, +        // we must never reject on because of thread pool capacity on replicas, +        @Override, +        public boolean isForceExecution() {, +            return true;, +        }, +, +++ b/src/main/java/org/elasticsearch/gateway/local/state/meta/LocalAllocateDangledIndices.java, +    class AllocateDangledRequestHandler extends BaseTransportRequestHandler<AllocateDangledRequest> {, +++ b/src/main/java/org/elasticsearch/transport/BaseTransportRequestHandler.java, +    /**, +     * Default force execution to false., +     */, +    @Override, +    public boolean isForceExecution() {, +        return false;, +    }, +++ b/src/main/java/org/elasticsearch/transport/TransportRequestHandler.java, +, +    /**, +     * See {@link org.elasticsearch.common.util.concurrent.AbstractRunnable#isForceExecution()}., +     */, +    boolean isForceExecution();, +++ b/src/main/java/org/elasticsearch/action/support/replication/TransportShardReplicationOperationAction.java, +        // we must never reject on because of thread pool capacity on replicas, +        @Override, +        public boolean isForceExecution() {, +            return true;, +        }, +, +++ b/src/main/java/org/elasticsearch/gateway/local/state/meta/LocalAllocateDangledIndices.java, +    class AllocateDangledRequestHandler extends BaseTransportRequestHandler<AllocateDangledRequest> {, +++ b/src/main/java/org/elasticsearch/transport/BaseTransportRequestHandler.java, +    /**, +     * Default force execution to false., +     */, +    @Override, +    public boolean isForceExecution() {, +        return false;, +    }, +++ b/src/main/java/org/elasticsearch/transport/TransportRequestHandler.java, +, +    /**, +     * See {@link org.elasticsearch.common.util.concurrent.AbstractRunnable#isForceExecution()}., +     */, +    boolean isForceExecution();, +++ b/src/main/java/org/elasticsearch/transport/local/LocalTransport.java, +import org.elasticsearch.common.component.Lifecycle;, +import org.elasticsearch.common.util.concurrent.AbstractRunnable;, +            if (handler.executor() == ThreadPool.Names.SAME) {, +                //noinspection unchecked, +            } else {, +                threadPool.executor(handler.executor()).execute(new AbstractRunnable() {, +                    @Override, +                    public void run() {, +                        try {, +                            //noinspection unchecked, +                            handler.messageReceived(request, transportChannel);, +                        } catch (Throwable e) {, +                            if (lifecycleState() == Lifecycle.State.STARTED) {, +                                // we can only send a response transport is started...., +                                try {, +                                    transportChannel.sendResponse(e);, +                                } catch (Throwable e1) {, +                                    logger.warn("Failed to send error message back to client for action [" + action + "]", e1);, +                                    logger.warn("Actual Exception", e);, +                                }]