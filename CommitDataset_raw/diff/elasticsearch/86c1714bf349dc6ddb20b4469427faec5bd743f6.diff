[+++ b/src/test/java/org/elasticsearch/test/integration/search/facet/ExtendedFacetsTests.java, +                        .startObject("fielddata"), +                        .field("format", "fst"), +                        .endObject(), +                        .endObject(), +                        .startObject("q_field"), +                        .field("type", "string"), +                        .field("index", "not_analyzed"), +        long seed = System.currentTimeMillis(); // LuceneTestCase... 1365254308314l;, +            Set<String> uniqueValuesSet = new HashSet<String>();, +            int numOfValuesField1 = 200;, +            int numOfValuesField2 = 200;, +            for (int i = 0; i < numOfValuesField1 + numOfValuesField2; i++) {, +                uniqueValuesSet.add(RandomStringGenerator.random(10, 0, 0, true, true, null, random));, +            }, +            String[] allUniqueValues = uniqueValuesSet.toArray(new String[uniqueValuesSet.size()]);, +, +            String[] field1Values = new String[numOfValuesField1];, +            System.arraycopy(allUniqueValues, 0, field1Values, 0, numOfValuesField1);, +, +            Map<String, Map<String, Integer>> queryValToField1FacetEntries = new HashMap<String, Map<String, Integer>>();, +            Map<String, Map<String, Integer>> queryValToField1and2FacetEntries = new HashMap<String, Map<String, Integer>>();, +                String field2Val = allUniqueValues[random.nextInt(allUniqueValues.length)];, +                                .field("field2", field2Val), +                                .field("q_field", queryVal), +, +                if (random.nextInt(2000) == 854) {, +                    client.admin().indices().prepareFlush("test").execute().actionGet();, +                addControlValues(queryValToField1FacetEntries, field1Val, queryVal);, +                addControlValues(queryValToField1and2FacetEntries, field1Val, queryVal);, +                addControlValues(queryValToField1and2FacetEntries, field2Val, queryVal);, +                for (String queryVal : queryValToField1FacetEntries.keySet()) {, +                    String[] allValues;, +                    Map<String, Integer> queryControlFacets;, +                    TermsFacetBuilder termsFacetBuilder = FacetBuilders.termsFacet("facet1").order(compType);, +, +                    boolean useFields;, +                    if (random.nextInt(4) == 3) {, +                        useFields = true;, +                        queryControlFacets = queryValToField1and2FacetEntries.get(queryVal);, +                        allValues = allUniqueValues;, +                        termsFacetBuilder.fields(facetField, "field2");, +                        queryControlFacets = queryValToField1FacetEntries.get(queryVal);, +                        allValues = field1Values;, +                        useFields = false;, +                        termsFacetBuilder.field(facetField);, +                    int size;, +                    if (compType == TermsFacet.ComparatorType.TERM || compType == TermsFacet.ComparatorType.REVERSE_TERM) {, +                        size = random.nextInt(queryControlFacets.size());, +                    } else {, +                        size = allValues.length;, +                    }, +                    termsFacetBuilder.size(size);, +                        int numExcludes = random.nextInt(5) + 1;, +                        List<String> facetValues = new ArrayList<String>(queryControlFacets.keySet());, +                        for (int i = 0; i < numExcludes; i++) {, +                        List<String> facetValues = new ArrayList<String>(queryControlFacets.keySet());, +                            .setQuery(QueryBuilders.termQuery("q_field", queryVal)), +                    TermsFacet actualFacetEntries = response.getFacets().facet("facet1");, +, +                    List<Tuple<Text, Integer>> expectedFacetEntries = getExpectedFacetEntries(allValues, queryControlFacets, size, compType, excludes, regex, allTerms);, +                    String reason = String.format("query: [%s] field: [%s] size: [%d] order: [%s] all_terms: [%s] fields: [%s] regex: [%s] excludes: [%s]", queryVal, facetField, size, compType, allTerms, useFields, regex, excludes);, +                    assertThat(reason, actualFacetEntries.getEntries().size(), equalTo(expectedFacetEntries.size()));, +                    for (int i = 0; i < expectedFacetEntries.size(); i++) {, +                        assertThat(reason, actualFacetEntries.getEntries().get(i).getTerm(), equalTo(expectedFacetEntries.get(i).v1()));, +                        assertThat(reason, actualFacetEntries.getEntries().get(i).getCount(), equalTo(expectedFacetEntries.get(i).v2()));, +    private void addControlValues(Map<String, Map<String, Integer>> queryValToFacetFieldEntries, String fieldVal, String queryVal) {, +        Map<String, Integer> controlFieldFacets = queryValToFacetFieldEntries.get(queryVal);, +        if (controlFieldFacets == null) {, +            controlFieldFacets = new HashMap<String, Integer>();, +            queryValToFacetFieldEntries.put(queryVal, controlFieldFacets);, +        }, +        Integer controlCount = controlFieldFacets.get(fieldVal);, +        if (controlCount == null) {, +            controlCount = 0;, +        }, +        controlFieldFacets.put(fieldVal, ++controlCount);, +    }, +, +    private List<Tuple<Text, Integer>> getExpectedFacetEntries(String[] fieldValues,, +                                                               Map<String, Integer> controlFacetsField,, +                                                               int size,, +                                                               TermsFacet.ComparatorType sort,, +                                                               List<String> excludes,, +                                                               String regex,, +                                                               boolean allTerms) {, +        for (Map.Entry<String, Integer> e : controlFacetsField.entrySet()) {, +            for (String fieldValue : fieldValues) {, +                if (!controlFacetsField.containsKey(fieldValue)) {, +                    if (excludes.contains(fieldValue)) {, +                    if (pattern != null && !pattern.matcher(fieldValue).matches()) {, +                    entries.add(new Tuple<Text, Integer>(new StringText(fieldValue), 0));, +    private final static Count count = new Count();, +    private final static CountReverse count_reverse = new CountReverse();, +    private final static Term term = new Term();, +    private final static TermReverse term_reverse = new TermReverse();, +    private static class Count implements Comparator<Tuple<Text, Integer>> {, +    private static class CountReverse implements Comparator<Tuple<Text, Integer>> {, +    private static class Term implements Comparator<Tuple<Text, Integer>> {, +    private static class TermReverse implements Comparator<Tuple<Text, Integer>> {]