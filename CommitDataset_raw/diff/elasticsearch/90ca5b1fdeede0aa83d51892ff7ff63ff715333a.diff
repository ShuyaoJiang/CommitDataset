[+++ b/server/src/main/java/org/elasticsearch/common/lucene/Lucene.java, +import org.apache.lucene.document.LongPoint;, +import org.apache.lucene.index.NumericDocValues;, +import org.elasticsearch.index.mapper.SeqNoFieldMapper;, +import java.util.function.LongConsumer;, +, +    /**, +     * Scans sequence numbers (i.e., {@link SeqNoFieldMapper#NAME}) between {@code fromSeqNo}(inclusive) and {@code toSeqNo}(inclusive), +     * in the provided directory reader. This method invokes the callback {@code onNewSeqNo} whenever a sequence number value is found., +     *, +     * @param directoryReader the directory reader to scan, +     * @param fromSeqNo       the lower bound of a range of seq_no to scan (inclusive), +     * @param toSeqNo         the upper bound of a range of seq_no to scan (inclusive), +     * @param onNewSeqNo      the callback to be called whenever a new valid sequence number is found, +     */, +    public static void scanSeqNosInReader(DirectoryReader directoryReader, long fromSeqNo, long toSeqNo,, +                                          LongConsumer onNewSeqNo) throws IOException {, +        final DirectoryReader reader = Lucene.wrapAllDocsLive(directoryReader);, +        final IndexSearcher searcher = new IndexSearcher(reader);, +        searcher.setQueryCache(null);, +        final Query query = LongPoint.newRangeQuery(SeqNoFieldMapper.NAME, fromSeqNo, toSeqNo);, +        final Weight weight = searcher.createWeight(query, ScoreMode.COMPLETE_NO_SCORES, 1.0f);, +        for (LeafReaderContext leaf : reader.leaves()) {, +            final Scorer scorer = weight.scorer(leaf);, +            if (scorer == null) {, +                continue;, +            }, +            final DocIdSetIterator docIdSetIterator = scorer.iterator();, +            final NumericDocValues seqNoDocValues = leaf.reader().getNumericDocValues(SeqNoFieldMapper.NAME);, +            int docId;, +            while ((docId = docIdSetIterator.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {, +                if (seqNoDocValues == null || seqNoDocValues.advanceExact(docId) == false) {, +                    throw new IllegalStateException("seq_no doc_values not found for doc_id=" + docId);, +                }, +                final long seqNo = seqNoDocValues.longValue();, +                assert fromSeqNo <= seqNo && seqNo <= toSeqNo : "from_seq_no=" + fromSeqNo + " seq_no=" + seqNo + " to_seq_no=" + toSeqNo;, +                onNewSeqNo.accept(seqNo);, +            }, +        }, +    }, +++ b/server/src/main/java/org/elasticsearch/common/lucene/Lucene.java, +import org.apache.lucene.document.LongPoint;, +import org.apache.lucene.index.NumericDocValues;, +import org.elasticsearch.index.mapper.SeqNoFieldMapper;, +import java.util.function.LongConsumer;, +, +    /**, +     * Scans sequence numbers (i.e., {@link SeqNoFieldMapper#NAME}) between {@code fromSeqNo}(inclusive) and {@code toSeqNo}(inclusive), +     * in the provided directory reader. This method invokes the callback {@code onNewSeqNo} whenever a sequence number value is found., +     *, +     * @param directoryReader the directory reader to scan, +     * @param fromSeqNo       the lower bound of a range of seq_no to scan (inclusive), +     * @param toSeqNo         the upper bound of a range of seq_no to scan (inclusive), +     * @param onNewSeqNo      the callback to be called whenever a new valid sequence number is found, +     */, +    public static void scanSeqNosInReader(DirectoryReader directoryReader, long fromSeqNo, long toSeqNo,, +                                          LongConsumer onNewSeqNo) throws IOException {, +        final DirectoryReader reader = Lucene.wrapAllDocsLive(directoryReader);, +        final IndexSearcher searcher = new IndexSearcher(reader);, +        searcher.setQueryCache(null);, +        final Query query = LongPoint.newRangeQuery(SeqNoFieldMapper.NAME, fromSeqNo, toSeqNo);, +        final Weight weight = searcher.createWeight(query, ScoreMode.COMPLETE_NO_SCORES, 1.0f);, +        for (LeafReaderContext leaf : reader.leaves()) {, +            final Scorer scorer = weight.scorer(leaf);, +            if (scorer == null) {, +                continue;, +            }, +            final DocIdSetIterator docIdSetIterator = scorer.iterator();, +            final NumericDocValues seqNoDocValues = leaf.reader().getNumericDocValues(SeqNoFieldMapper.NAME);, +            int docId;, +            while ((docId = docIdSetIterator.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {, +                if (seqNoDocValues == null || seqNoDocValues.advanceExact(docId) == false) {, +                    throw new IllegalStateException("seq_no doc_values not found for doc_id=" + docId);, +                }, +                final long seqNo = seqNoDocValues.longValue();, +                assert fromSeqNo <= seqNo && seqNo <= toSeqNo : "from_seq_no=" + fromSeqNo + " seq_no=" + seqNo + " to_seq_no=" + toSeqNo;, +                onNewSeqNo.accept(seqNo);, +            }, +        }, +    }, +++ b/server/src/main/java/org/elasticsearch/index/engine/InternalEngine.java, +import java.util.function.Supplier;, +            this.localCheckpointTracker = createLocalCheckpointTracker(engineConfig, lastCommittedSegmentInfos, logger,, +                () -> acquireSearcher("create_local_checkpoint_tracker", SearcherScope.INTERNAL), localCheckpointTrackerSupplier);, +    private static LocalCheckpointTracker createLocalCheckpointTracker(EngineConfig engineConfig, SegmentInfos lastCommittedSegmentInfos,, +        Logger logger, Supplier<Searcher> searcherSupplier, BiFunction<Long, Long, LocalCheckpointTracker> localCheckpointTrackerSupplier) {, +        try {, +                SequenceNumbers.loadSeqNoInfoFromLuceneCommit(lastCommittedSegmentInfos.userData.entrySet());, +            final long maxSeqNo = seqNoStats.maxSeqNo;, +            final long localCheckpoint = seqNoStats.localCheckpoint;, +            final LocalCheckpointTracker tracker = localCheckpointTrackerSupplier.apply(maxSeqNo, localCheckpoint);, +            // Operations that are optimized using max_seq_no_of_updates optimization must not be processed twice; otherwise, they will, +            // create duplicates in Lucene. To avoid this we check the LocalCheckpointTracker to see if an operation was already processed., +            // Thus, we need to restore the LocalCheckpointTracker bit by bit to ensure the consistency between LocalCheckpointTracker and, +            // Lucene index. This is not the only solution since we can bootstrap max_seq_no_of_updates with max_seq_no of the commit to, +            // disable the MSU optimization during recovery. Here we prefer to maintain the consistency of LocalCheckpointTracker., +            if (localCheckpoint < maxSeqNo && engineConfig.getIndexSettings().isSoftDeleteEnabled()) {, +                try (Searcher searcher = searcherSupplier.get()) {, +                    Lucene.scanSeqNosInReader(searcher.getDirectoryReader(), localCheckpoint + 1, maxSeqNo, tracker::markSeqNoAsCompleted);, +                }]