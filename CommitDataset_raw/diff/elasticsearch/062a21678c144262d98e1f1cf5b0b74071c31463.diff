[+++ b/client/src/main/java/org/elasticsearch/client/AbstractStaticConnectionPool.java, + * The {@link #onSuccess(Connection)} method marks the connection provided as an argument alive., + * The {@link #onFailure(Connection)} method marks the connection provided as an argument dead., +public abstract class AbstractStaticConnectionPool implements ConnectionPool {, +    protected abstract List<Connection> getConnections();, +    public final Stream<Connection> nextConnection() {, +        List<Connection> connections = getConnections();, +        List<Connection> sortedConnections = new ArrayList<>(connections);, +    protected List<Connection> createConnections(HttpHost... hosts) {, +        List<Connection> connections = new ArrayList<>();, +            connections.add(new Connection(host));, +    public Connection lastResortConnection() {, +        Connection Connection = getConnections().stream(), +        Connection.markResurrected();, +        return Connection;, +    public void onSuccess(Connection connection) {, +    public void onFailure(Connection connection) throws IOException {, +++ b/client/src/main/java/org/elasticsearch/client/AbstractStaticConnectionPool.java, + * The {@link #onSuccess(Connection)} method marks the connection provided as an argument alive., + * The {@link #onFailure(Connection)} method marks the connection provided as an argument dead., +public abstract class AbstractStaticConnectionPool implements ConnectionPool {, +    protected abstract List<Connection> getConnections();, +    public final Stream<Connection> nextConnection() {, +        List<Connection> connections = getConnections();, +        List<Connection> sortedConnections = new ArrayList<>(connections);, +    protected List<Connection> createConnections(HttpHost... hosts) {, +        List<Connection> connections = new ArrayList<>();, +            connections.add(new Connection(host));, +    public Connection lastResortConnection() {, +        Connection Connection = getConnections().stream(), +        Connection.markResurrected();, +        return Connection;, +    public void onSuccess(Connection connection) {, +    public void onFailure(Connection connection) throws IOException {, +++ b/client/src/main/java/org/elasticsearch/client/Connection.java, +import java.util.concurrent.TimeUnit;, +, + * Represents a connection to a host. It holds the host that the connection points to., + * Any change to the state of a connection should be made through the connection pool., +    //TODO make these values configurable through the connection pool?, +    private static final long DEFAULT_CONNECTION_TIMEOUT_MILLIS = TimeUnit.MINUTES.toMillis(1);, +    private static final long MAX_CONNECTION_TIMEOUT_MILLIS = TimeUnit.MINUTES.toMillis(30);, +    private volatile State state = State.UNKNOWN;, +    private volatile int failedAttempts = -1;, +    private volatile long deadUntil = -1;, +, +    /**, +     * Marks connection as dead. Should be called in case the corresponding node is not responding or caused failures., +     * Once marked dead, the number of failed attempts will be incremented on each call to this method. A dead connection, +     * should be retried once {@link #shouldBeRetried()} returns true, which depends on the number of previous failed attempts, +     * and when the last failure was registered., +     */, +    void markDead() {, +        synchronized (this) {, +            int failedAttempts = Math.max(this.failedAttempts, 0);, +            long timeoutMillis = (long)Math.min(DEFAULT_CONNECTION_TIMEOUT_MILLIS * 2 * Math.pow(2, failedAttempts * 0.5 - 1),, +                    MAX_CONNECTION_TIMEOUT_MILLIS);, +            this.deadUntil = System.nanoTime() + TimeUnit.MILLISECONDS.toNanos(timeoutMillis);, +            this.failedAttempts = ++failedAttempts;, +            this.state = State.DEAD;, +        }, +    }, +, +    /**, +     * Marks this connection alive. Should be called when the corresponding node is working properly., +     * Will reset the number of failed attempts that were counted in case the connection was previously dead,, +     * as well as its dead timeout., +     */, +    void markAlive() {, +        if (this.state != State.ALIVE) {, +            synchronized (this) {, +                this.deadUntil = -1;, +                this.failedAttempts = 0;, +                this.state = State.ALIVE;, +            }, +        }, +    }, +, +    /**, +     * Resets the connection to its initial state, so it will be retried. To be called when all the connections in the pool, +     * are dead, so that one connection can be retried. Note that calling this method only changes the state of the connection,, +     * it doesn't reset its failed attempts and dead until timestamp. That way if the connection goes back to dead straightaway, +     * all of its previous failed attempts are taken into account., +     */, +    void markResurrected() {, +        if (this.state == State.DEAD) {, +            synchronized (this) {, +                this.state = State.UNKNOWN;, +            }, +        }, +    }, +, +    /**, +     * Returns the timestamp till the connection is supposed to stay dead till it can be retried, +     */, +    public long getDeadUntil() {, +        return deadUntil;, +    }, +, +    /**]