[+++ b/src/main/java/org/elasticsearch/client/IndicesAdminClient.java, +++ b/src/main/java/org/elasticsearch/client/IndicesAdminClient.java, +++ b/src/main/java/org/elasticsearch/cluster/routing/RoutingTable.java, +++ b/src/main/java/org/elasticsearch/client/IndicesAdminClient.java, +++ b/src/main/java/org/elasticsearch/cluster/routing/RoutingTable.java, +++ b/src/main/java/org/elasticsearch/common/io/stream/StreamInput.java, +        }, +        return values;, +    }, +, +    public byte[] readByteArray() throws IOException {, +        int length = readVInt();, +        byte[] values = new byte[length];, +        for (int i = 0; i < length; i++) {, +            values[i] = readByte();, +++ b/src/main/java/org/elasticsearch/client/IndicesAdminClient.java, +++ b/src/main/java/org/elasticsearch/cluster/routing/RoutingTable.java, +++ b/src/main/java/org/elasticsearch/common/io/stream/StreamInput.java, +        }, +        return values;, +    }, +, +    public byte[] readByteArray() throws IOException {, +        int length = readVInt();, +        byte[] values = new byte[length];, +        for (int i = 0; i < length; i++) {, +            values[i] = readByte();, +++ b/src/main/java/org/elasticsearch/common/io/stream/StreamOutput.java, +     * Writes an array of bytes., +     *, +     * @param b the bytes to write, +     */, +    public void writeByteArray(byte[] b) throws IOException {, +        writeVInt(b.length);, +        writeBytes(b, 0, b.length);, +    }, +, +    /**, +++ b/src/main/java/org/elasticsearch/client/IndicesAdminClient.java, +++ b/src/main/java/org/elasticsearch/cluster/routing/RoutingTable.java, +++ b/src/main/java/org/elasticsearch/common/io/stream/StreamInput.java, +        }, +        return values;, +    }, +, +    public byte[] readByteArray() throws IOException {, +        int length = readVInt();, +        byte[] values = new byte[length];, +        for (int i = 0; i < length; i++) {, +            values[i] = readByte();, +++ b/src/main/java/org/elasticsearch/common/io/stream/StreamOutput.java, +     * Writes an array of bytes., +     *, +     * @param b the bytes to write, +     */, +    public void writeByteArray(byte[] b) throws IOException {, +        writeVInt(b.length);, +        writeBytes(b, 0, b.length);, +    }, +, +    /**, +++ b/src/main/java/org/elasticsearch/gateway/GatewayAllocator.java, +                                // see if we have a sync id we can make use of, +                                if (storeFilesMetaData.syncId() != null && storeFilesMetaData.syncId().equals(primaryNodeStore.syncId())) {, +                                    logger.trace("{}: node [{}] has same sync id {} as primary", shard, discoNode.name(), storeFilesMetaData.syncId());, +                                    lastNodeMatched = node;, +                                    lastSizeMatched = Long.MAX_VALUE;, +                                    lastDiscoNodeMatched = discoNode;, +                                } else {, +                                        logger.trace("{}: node [{}] has file {}",, +                                                shard, discoNode.name(), storeFileMetaData.name());, +            }, +++ b/src/main/java/org/elasticsearch/client/IndicesAdminClient.java, +++ b/src/main/java/org/elasticsearch/cluster/routing/RoutingTable.java, +++ b/src/main/java/org/elasticsearch/common/io/stream/StreamInput.java, +        }, +        return values;, +    }, +, +    public byte[] readByteArray() throws IOException {, +        int length = readVInt();, +        byte[] values = new byte[length];, +        for (int i = 0; i < length; i++) {, +            values[i] = readByte();, +++ b/src/main/java/org/elasticsearch/common/io/stream/StreamOutput.java, +     * Writes an array of bytes., +     *, +     * @param b the bytes to write, +     */, +    public void writeByteArray(byte[] b) throws IOException {, +        writeVInt(b.length);, +        writeBytes(b, 0, b.length);, +    }, +, +    /**, +++ b/src/main/java/org/elasticsearch/gateway/GatewayAllocator.java, +                                // see if we have a sync id we can make use of, +                                if (storeFilesMetaData.syncId() != null && storeFilesMetaData.syncId().equals(primaryNodeStore.syncId())) {, +                                    logger.trace("{}: node [{}] has same sync id {} as primary", shard, discoNode.name(), storeFilesMetaData.syncId());, +                                    lastNodeMatched = node;]