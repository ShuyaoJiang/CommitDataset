[+++ /dev/null, +++ /dev/null, +++ b/core/src/main/java/org/elasticsearch/index/aliases/IndexAliasesService.java, +import org.elasticsearch.cluster.metadata.AliasMetaData;, +import org.elasticsearch.common.collect.ImmutableOpenMap;, +public class IndexAliasesService extends AbstractIndexComponent {, +    private volatile ImmutableOpenMap<String, AliasMetaData> aliases = ImmutableOpenMap.of();, +    public Query aliasFilter(String... aliasNames) {, +        if (aliasNames == null || aliasNames.length == 0) {, +        if (aliasNames.length == 1) {, +            AliasMetaData alias = this.aliases.get(aliasNames[0]);, +            if (alias == null) {, +                throw new InvalidAliasNameException(index, aliasNames[0], "Unknown alias name was passed to alias Filter");, +            return parse(alias);, +            for (String aliasName : aliasNames) {, +                AliasMetaData alias = this.aliases.get(aliasName);, +                if (alias == null) {, +                    throw new InvalidAliasNameException(index, aliasNames[0], "Unknown alias name was passed to alias Filter");, +                Query parsedFilter = parse(alias);, +                if (parsedFilter != null) {, +                    combined.add(parsedFilter, BooleanClause.Occur.SHOULD);, +    public void setAliases(ImmutableOpenMap<String, AliasMetaData> aliases) {, +        this.aliases = aliases;, +    Query parse(AliasMetaData alias) {, +        if (alias.filter() == null) {, +            byte[] filterSource = alias.filter().uncompressed();, +            throw new AliasFilterParsingException(index, alias.getAlias(), "Invalid alias filter", ex);, +    // Used by tests:, +    void add(String alias, @Nullable CompressedXContent filter) {, +        AliasMetaData aliasMetaData = AliasMetaData.builder(alias).filter(filter).build();, +        aliases = ImmutableOpenMap.builder(aliases).fPut(alias, aliasMetaData).build();, +    }, +, +    boolean hasAlias(String alias) {, +        return aliases.containsKey(alias);, +    }, +, +   void remove(String alias) {, +       aliases = ImmutableOpenMap.builder(aliases).fRemove(alias).build();, +++ /dev/null, +++ b/core/src/main/java/org/elasticsearch/index/aliases/IndexAliasesService.java, +import org.elasticsearch.cluster.metadata.AliasMetaData;, +import org.elasticsearch.common.collect.ImmutableOpenMap;, +public class IndexAliasesService extends AbstractIndexComponent {, +    private volatile ImmutableOpenMap<String, AliasMetaData> aliases = ImmutableOpenMap.of();, +    public Query aliasFilter(String... aliasNames) {, +        if (aliasNames == null || aliasNames.length == 0) {, +        if (aliasNames.length == 1) {, +            AliasMetaData alias = this.aliases.get(aliasNames[0]);, +            if (alias == null) {, +                throw new InvalidAliasNameException(index, aliasNames[0], "Unknown alias name was passed to alias Filter");, +            return parse(alias);, +            for (String aliasName : aliasNames) {, +                AliasMetaData alias = this.aliases.get(aliasName);, +                if (alias == null) {, +                    throw new InvalidAliasNameException(index, aliasNames[0], "Unknown alias name was passed to alias Filter");, +                Query parsedFilter = parse(alias);, +                if (parsedFilter != null) {, +                    combined.add(parsedFilter, BooleanClause.Occur.SHOULD);, +    public void setAliases(ImmutableOpenMap<String, AliasMetaData> aliases) {, +        this.aliases = aliases;, +    Query parse(AliasMetaData alias) {, +        if (alias.filter() == null) {, +            byte[] filterSource = alias.filter().uncompressed();, +            throw new AliasFilterParsingException(index, alias.getAlias(), "Invalid alias filter", ex);, +    // Used by tests:, +    void add(String alias, @Nullable CompressedXContent filter) {, +        AliasMetaData aliasMetaData = AliasMetaData.builder(alias).filter(filter).build();, +        aliases = ImmutableOpenMap.builder(aliases).fPut(alias, aliasMetaData).build();, +    }, +, +    boolean hasAlias(String alias) {, +        return aliases.containsKey(alias);, +    }, +, +   void remove(String alias) {, +       aliases = ImmutableOpenMap.builder(aliases).fRemove(alias).build();, +++ b/core/src/main/java/org/elasticsearch/index/mapper/core/DateFieldMapper.java, +                return innerRangeQuery(lowerTerm, upperTerm, includeLower, includeUpper, timeZone, forcedDateParser);, +            }, +, +            // Even though we only cache rewritten queries it is good to let all queries implement hashCode() and equals():, +            @Override, +            public boolean equals(Object o) {, +                if (this == o) return true;, +                if (o == null || getClass() != o.getClass()) return false;, +                if (!super.equals(o)) return false;, +, +                LateParsingQuery that = (LateParsingQuery) o;, +, +                if (includeLower != that.includeLower) return false;, +                if (includeUpper != that.includeUpper) return false;, +                if (lowerTerm != null ? !lowerTerm.equals(that.lowerTerm) : that.lowerTerm != null) return false;, +                if (upperTerm != null ? !upperTerm.equals(that.upperTerm) : that.upperTerm != null) return false;, +                if (timeZone != null ? !timeZone.equals(that.timeZone) : that.timeZone != null) return false;, +                return !(forcedDateParser != null ? !forcedDateParser.equals(that.forcedDateParser) : that.forcedDateParser != null);, +, +            }, +, +            @Override]