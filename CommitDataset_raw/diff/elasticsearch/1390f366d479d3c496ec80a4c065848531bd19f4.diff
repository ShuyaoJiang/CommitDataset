[+++ b/x-pack/plugin/ccr/src/main/java/org/elasticsearch/xpack/ccr/action/AutoFollowCoordinator.java, +import org.elasticsearch.cluster.routing.IndexRoutingTable;, +                request.routingTable(true);, +                    IndexRoutingTable indexRoutingTable = leaderClusterState.routingTable().index(leaderIndexMetaData.getIndex());, +                    if (indexRoutingTable != null &&, +                        // Leader indices can be in the cluster state, but not all primary shards may be ready yet., +                        // This checks ensures all primary shards have started, so that index following does not fail., +                        // If not all primary shards are ready, then the next time the auto follow coordinator runs, +                        // this index will be auto followed., +                        indexRoutingTable.allPrimaryShardsActive() &&, +                        followedIndexUUIDs.contains(leaderIndexMetaData.getIndex().getUUID()) == false) {, +++ b/x-pack/plugin/ccr/src/main/java/org/elasticsearch/xpack/ccr/action/AutoFollowCoordinator.java, +import org.elasticsearch.cluster.routing.IndexRoutingTable;, +                request.routingTable(true);, +                    IndexRoutingTable indexRoutingTable = leaderClusterState.routingTable().index(leaderIndexMetaData.getIndex());, +                    if (indexRoutingTable != null &&, +                        // Leader indices can be in the cluster state, but not all primary shards may be ready yet., +                        // This checks ensures all primary shards have started, so that index following does not fail., +                        // If not all primary shards are ready, then the next time the auto follow coordinator runs, +                        // this index will be auto followed., +                        indexRoutingTable.allPrimaryShardsActive() &&, +                        followedIndexUUIDs.contains(leaderIndexMetaData.getIndex().getUUID()) == false) {, +++ b/x-pack/plugin/ccr/src/test/java/org/elasticsearch/xpack/ccr/action/AutoFollowCoordinatorTests.java, +import org.elasticsearch.cluster.routing.IndexRoutingTable;, +import org.elasticsearch.cluster.routing.RoutingTable;, +import org.elasticsearch.cluster.routing.ShardRouting;, +import org.elasticsearch.cluster.routing.ShardRoutingState;, +import org.elasticsearch.cluster.routing.TestShardRouting;, +        ClusterState leaderState = createRemoteClusterState("logs-20190101");, +        ClusterState leaderState = createRemoteClusterState("logs-20190101");, +        ClusterState leaderState = createRemoteClusterState("logs-20190101");, +        RoutingTable.Builder routingTableBuilder = RoutingTable.builder();, +            String indexName = "metrics-" + i;, +                .put(IndexMetaData.SETTING_INDEX_UUID, indexName), +, +            ShardRouting shardRouting =, +                TestShardRouting.newShardRouting(indexName, 0, "1", true, ShardRoutingState.INITIALIZING).moveToStarted();, +            IndexRoutingTable indexRoutingTable = IndexRoutingTable.builder(imdBuilder.get(indexName).getIndex()), +                .addShard(shardRouting), +                .build();, +            routingTableBuilder.add(indexRoutingTable);, +, +        ShardRouting shardRouting =, +            TestShardRouting.newShardRouting("logs-0", 0, "1", true, ShardRoutingState.INITIALIZING).moveToStarted();, +        IndexRoutingTable indexRoutingTable = IndexRoutingTable.builder(imdBuilder.get("logs-0").getIndex()).addShard(shardRouting).build();, +        routingTableBuilder.add(indexRoutingTable);, +            .routingTable(routingTableBuilder.build()), +    public void testGetLeaderIndicesToFollow_shardsNotStarted() {, +        AutoFollowPattern autoFollowPattern = new AutoFollowPattern("remote", Collections.singletonList("*"),, +            null, null, null, null, null, null, null, null, null, null, null);, +        Map<String, Map<String, String>> headers = new HashMap<>();, +        ClusterState followerState = ClusterState.builder(new ClusterName("remote")), +            .metaData(MetaData.builder().putCustom(AutoFollowMetadata.TYPE,, +                new AutoFollowMetadata(Collections.singletonMap("remote", autoFollowPattern), Collections.emptyMap(), headers))), +            .build();, +, +        // 1 shard started and another not started:, +        ClusterState leaderState = createRemoteClusterState("index1");, +        MetaData.Builder mBuilder= MetaData.builder(leaderState.metaData());, +        mBuilder.put(IndexMetaData.builder("index2"), +            .settings(settings(Version.CURRENT).put(IndexSettings.INDEX_SOFT_DELETES_SETTING.getKey(), true)), +            .numberOfShards(1), +            .numberOfReplicas(0));, +        ShardRouting shardRouting =, +            TestShardRouting.newShardRouting("index2", 0, "1", true, ShardRoutingState.INITIALIZING);, +        IndexRoutingTable indexRoutingTable = IndexRoutingTable.builder(mBuilder.get("index2").getIndex(), +        ).addShard(shardRouting).build();, +        leaderState = ClusterState.builder(leaderState.getClusterName()), +            .metaData(mBuilder), +            .routingTable(RoutingTable.builder(leaderState.routingTable()).add(indexRoutingTable).build()), +            .build();, +, +        List<Index> result = AutoFollower.getLeaderIndicesToFollow("remote", autoFollowPattern, leaderState, followerState,, +            Collections.emptyList());, +        assertThat(result.size(), equalTo(1));, +        assertThat(result.get(0).getName(), equalTo("index1"));, +, +        // Start second shard:, +        shardRouting = shardRouting.moveToStarted();, +        indexRoutingTable = IndexRoutingTable.builder(leaderState.metaData().indices().get("index2").getIndex()), +            .addShard(shardRouting).build();, +        leaderState = ClusterState.builder(leaderState.getClusterName()), +            .metaData(leaderState.metaData()), +            .routingTable(RoutingTable.builder(leaderState.routingTable()).add(indexRoutingTable).build()), +            .build();, +, +        result = AutoFollower.getLeaderIndicesToFollow("remote", autoFollowPattern, leaderState, followerState, Collections.emptyList());, +        assertThat(result.size(), equalTo(2));, +        result.sort(Comparator.comparing(Index::getName));, +        assertThat(result.get(0).getName(), equalTo("index1"));, +        assertThat(result.get(1).getName(), equalTo("index2"));, +    }, +, +    private static ClusterState createRemoteClusterState(String indexName) {, +        IndexMetaData indexMetaData = IndexMetaData.builder(indexName), +            .settings(settings(Version.CURRENT).put(IndexSettings.INDEX_SOFT_DELETES_SETTING.getKey(), true)), +            .numberOfShards(1), +            .numberOfReplicas(0), +            .build();, +        ClusterState.Builder csBuilder = ClusterState.builder(new ClusterName("remote"))]