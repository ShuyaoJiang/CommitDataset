[+++ b/x-pack/plugin/ccr/src/main/java/org/elasticsearch/xpack/ccr/Ccr.java, +            new AutoFollowCoordinator(client, clusterService, ccrLicenseChecker), +++ b/x-pack/plugin/ccr/src/main/java/org/elasticsearch/xpack/ccr/Ccr.java, +            new AutoFollowCoordinator(client, clusterService, ccrLicenseChecker), +++ b/x-pack/plugin/ccr/src/main/java/org/elasticsearch/xpack/ccr/CcrLicenseChecker.java, +                remoteClusterStateResponse   -> {, +                    ClusterState remoteClusterState = remoteClusterStateResponse.getState();, +                    IndexMetaData leaderIndexMetaData = remoteClusterState.getMetaData().index(leaderIndex);, +            final Consumer<ClusterStateResponse> leaderClusterStateConsumer) {, +            final Consumer<ClusterStateResponse> leaderClusterStateConsumer,, +                                ActionListener.wrap(leaderClusterStateConsumer::accept, onFailure);, +++ b/x-pack/plugin/ccr/src/main/java/org/elasticsearch/xpack/ccr/Ccr.java, +            new AutoFollowCoordinator(client, clusterService, ccrLicenseChecker), +++ b/x-pack/plugin/ccr/src/main/java/org/elasticsearch/xpack/ccr/CcrLicenseChecker.java, +                remoteClusterStateResponse   -> {, +                    ClusterState remoteClusterState = remoteClusterStateResponse.getState();, +                    IndexMetaData leaderIndexMetaData = remoteClusterState.getMetaData().index(leaderIndex);, +            final Consumer<ClusterStateResponse> leaderClusterStateConsumer) {, +            final Consumer<ClusterStateResponse> leaderClusterStateConsumer,, +                                ActionListener.wrap(leaderClusterStateConsumer::accept, onFailure);, +++ b/x-pack/plugin/ccr/src/main/java/org/elasticsearch/xpack/ccr/action/AutoFollowCoordinator.java, +import org.elasticsearch.action.admin.cluster.state.ClusterStateResponse;, +            AutoFollower autoFollower = new AutoFollower(remoteCluster, this::updateStats, clusterService::state) {, +                                           final long metadataVersion,, +                                           final BiConsumer<ClusterStateResponse, Exception> handler) {, +                    request.waitForMetaDataVersion(metadataVersion);, +                        remoteClusterStateResponse -> handler.accept(remoteClusterStateResponse, null));, +        private volatile long metadataVersion = 0;, +            getRemoteClusterState(remoteCluster, metadataVersion + 1, (remoteClusterStateResponse, remoteError) -> {, +                if (remoteClusterStateResponse != null) {, +                    if (remoteClusterStateResponse.isWaitForTimedOut()) {, +                        start();, +                        return;, +                    }, +                    ClusterState remoteClusterState = remoteClusterStateResponse.getState();, +                    metadataVersion = remoteClusterState.metaData().version();, +                start();, +         * Fetch a remote cluster state from with the specified cluster alias, +         * @param metadataVersion   the last seen metadata version, +            long metadataVersion,, +            BiConsumer<ClusterStateResponse, Exception> handler, +++ b/x-pack/plugin/ccr/src/main/java/org/elasticsearch/xpack/ccr/Ccr.java, +            new AutoFollowCoordinator(client, clusterService, ccrLicenseChecker), +++ b/x-pack/plugin/ccr/src/main/java/org/elasticsearch/xpack/ccr/CcrLicenseChecker.java, +                remoteClusterStateResponse   -> {, +                    ClusterState remoteClusterState = remoteClusterStateResponse.getState();, +                    IndexMetaData leaderIndexMetaData = remoteClusterState.getMetaData().index(leaderIndex);, +            final Consumer<ClusterStateResponse> leaderClusterStateConsumer) {, +            final Consumer<ClusterStateResponse> leaderClusterStateConsumer,, +                                ActionListener.wrap(leaderClusterStateConsumer::accept, onFailure);, +++ b/x-pack/plugin/ccr/src/main/java/org/elasticsearch/xpack/ccr/action/AutoFollowCoordinator.java, +import org.elasticsearch.action.admin.cluster.state.ClusterStateResponse;, +            AutoFollower autoFollower = new AutoFollower(remoteCluster, this::updateStats, clusterService::state) {, +                                           final long metadataVersion,, +                                           final BiConsumer<ClusterStateResponse, Exception> handler) {, +                    request.waitForMetaDataVersion(metadataVersion);, +                        remoteClusterStateResponse -> handler.accept(remoteClusterStateResponse, null));, +        private volatile long metadataVersion = 0;, +            getRemoteClusterState(remoteCluster, metadataVersion + 1, (remoteClusterStateResponse, remoteError) -> {, +                if (remoteClusterStateResponse != null) {, +                    if (remoteClusterStateResponse.isWaitForTimedOut()) {, +                        start();, +                        return;, +                    }, +                    ClusterState remoteClusterState = remoteClusterStateResponse.getState();, +                    metadataVersion = remoteClusterState.metaData().version();, +                start();, +         * Fetch a remote cluster state from with the specified cluster alias, +         * @param metadataVersion   the last seen metadata version, +            long metadataVersion,, +            BiConsumer<ClusterStateResponse, Exception> handler, +++ b/x-pack/plugin/ccr/src/main/java/org/elasticsearch/xpack/ccr/action/TransportPutAutoFollowPatternAction.java, +import org.elasticsearch.action.admin.cluster.state.ClusterStateResponse;, +        Consumer<ClusterStateResponse> consumer = remoteClusterState -> {, +                                return innerPut(request, filteredHeaders, currentState, remoteClusterState.getState());, +++ b/x-pack/plugin/ccr/src/main/java/org/elasticsearch/xpack/ccr/Ccr.java, +            new AutoFollowCoordinator(client, clusterService, ccrLicenseChecker), +++ b/x-pack/plugin/ccr/src/main/java/org/elasticsearch/xpack/ccr/CcrLicenseChecker.java, +                remoteClusterStateResponse   -> {, +                    ClusterState remoteClusterState = remoteClusterStateResponse.getState();, +                    IndexMetaData leaderIndexMetaData = remoteClusterState.getMetaData().index(leaderIndex);, +            final Consumer<ClusterStateResponse> leaderClusterStateConsumer) {, +            final Consumer<ClusterStateResponse> leaderClusterStateConsumer,, +                                ActionListener.wrap(leaderClusterStateConsumer::accept, onFailure);, +++ b/x-pack/plugin/ccr/src/main/java/org/elasticsearch/xpack/ccr/action/AutoFollowCoordinator.java, +import org.elasticsearch.action.admin.cluster.state.ClusterStateResponse;, +            AutoFollower autoFollower = new AutoFollower(remoteCluster, this::updateStats, clusterService::state) {, +                                           final long metadataVersion,, +                                           final BiConsumer<ClusterStateResponse, Exception> handler) {, +                    request.waitForMetaDataVersion(metadataVersion);, +                        remoteClusterStateResponse -> handler.accept(remoteClusterStateResponse, null));, +        private volatile long metadataVersion = 0;, +            getRemoteClusterState(remoteCluster, metadataVersion + 1, (remoteClusterStateResponse, remoteError) -> {, +                if (remoteClusterStateResponse != null) {, +                    if (remoteClusterStateResponse.isWaitForTimedOut()) {, +                        start();, +                        return;, +                    }, +                    ClusterState remoteClusterState = remoteClusterStateResponse.getState();, +                    metadataVersion = remoteClusterState.metaData().version();]