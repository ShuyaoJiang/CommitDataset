[+++ b/src/main/java/org/elasticsearch/index/mapper/core/AbstractFieldMapper.java, +import java.util.*;, +                // sort the mappers so we get consistent serialization format, +                Mapper[] sortedMappers = mappers.values().toArray(Mapper.class);, +                Arrays.sort(sortedMappers, new Comparator<Mapper>() {, +                    @Override, +                    public int compare(Mapper o1, Mapper o2) {, +                        return o1.name().compareTo(o2.name());, +                    }, +                });, +                for (Mapper mapper : sortedMappers) {, +                    mapper.toXContent(builder, params);, +++ b/src/main/java/org/elasticsearch/index/mapper/core/AbstractFieldMapper.java, +import java.util.*;, +                // sort the mappers so we get consistent serialization format, +                Mapper[] sortedMappers = mappers.values().toArray(Mapper.class);, +                Arrays.sort(sortedMappers, new Comparator<Mapper>() {, +                    @Override, +                    public int compare(Mapper o1, Mapper o2) {, +                        return o1.name().compareTo(o2.name());, +                    }, +                });, +                for (Mapper mapper : sortedMappers) {, +                    mapper.toXContent(builder, params);, +++ b/src/test/java/org/elasticsearch/index/mapper/multifield/MultiFieldTests.java, +import org.elasticsearch.common.xcontent.XContentBuilder;, +import org.elasticsearch.common.xcontent.XContentHelper;, +import org.elasticsearch.common.xcontent.support.XContentMapValues;, +import java.util.Arrays;, +import java.util.Map;, +, +, +    @Test, +    // The underlying order of the fields in multi fields in the mapping source should always be consistent, if not this, +    // can to unnecessary re-syncing of the mappings between the local instance and cluster state, +    public void testMultiFieldsInConsistentOrder() throws Exception {, +        String[] multiFieldNames = new String[randomIntBetween(2, 10)];, +        for (int i = 0; i < multiFieldNames.length; i++) {, +            multiFieldNames[i] = randomAsciiOfLength(4);, +        }, +, +        XContentBuilder builder = jsonBuilder().startObject().startObject("type").startObject("properties"), +                .startObject("my_field").field("type", "string").startObject("fields");, +        for (String multiFieldName : multiFieldNames) {, +            builder = builder.startObject(multiFieldName).field("type", "string").endObject();, +        }, +        builder = builder.endObject().endObject().endObject().endObject().endObject();, +        String mapping = builder.string();, +        DocumentMapper docMapper = createIndex("test").mapperService().documentMapperParser().parse(mapping);, +        Arrays.sort(multiFieldNames);, +, +        Map<String, Object> sourceAsMap = XContentHelper.convertToMap(docMapper.mappingSource().compressed(), true).v2();, +        @SuppressWarnings("unchecked"), +        Map<String, Object> multiFields = (Map<String, Object>) XContentMapValues.extractValue("type.properties.my_field.fields", sourceAsMap);, +        assertThat(multiFields.size(), equalTo(multiFieldNames.length));, +, +        int i = 0;, +        // underlying map is LinkedHashMap, so this ok:, +        for (String field : multiFields.keySet()) {, +            assertThat(field, equalTo(multiFieldNames[i++]));, +        }, +    }]