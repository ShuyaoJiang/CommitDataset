[+++ b/src/main/java/jsr166e/CompletableFuture.java, +/*, + * Written by Doug Lea with assistance from members of JCP JSR-166, + * Expert Group and released to the public domain, as explained at, + * http://creativecommons.org/publicdomain/zero/1.0/, + */, +, +package jsr166e;, +import jsr166y.ThreadLocalRandom;, +, +import java.util.concurrent.Future;, +import java.util.concurrent.TimeUnit;, +import java.util.concurrent.Executor;, +import java.util.concurrent.ExecutionException;, +import java.util.concurrent.TimeoutException;, +import java.util.concurrent.CancellationException;, +import java.util.concurrent.atomic.AtomicInteger;, +import java.util.concurrent.locks.LockSupport;, +, +/**, + * A {@link Future} that may be explicitly completed (setting its, + * value and status), and may include dependent functions and actions, + * that trigger upon its completion.  Methods are available for adding, + * those based on Functions, Blocks, and Runnables, depending on, + * whether they require arguments and/or produce results, as well as, + * those triggered after either or both the current and another, + * CompletableFuture complete.  Functions and actions supplied for, + * dependent completions (mainly using methods with prefix {@code, + * then}) may be performed by the thread that completes the current, + * CompletableFuture, or by any other caller of these methods.  There, + * are no guarantees about the order of processing completions unless, + * constrained by these methods., + *, + * <p>When two or more threads attempt to {@link #complete} or {@link, + * #completeExceptionally} a CompletableFuture, only one of them, + * succeeds., + *, + * <p>Upon exceptional completion, or when a completion entails, + * computation of a function or action, and it terminates abruptly, + * with an (unchecked) exception or error, then further completions, + * act as {@code completeExceptionally} with a {@link, + * CompletionException} holding that exception as its cause.  If a, + * CompletableFuture completes exceptionally, and is not followed by a, + * {@link #exceptionally} or {@link #handle} completion, then all of, + * its dependents (and their dependents) also complete exceptionally, + * with CompletionExceptions holding the ultimate cause.  In case of a, + * CompletionException, methods {@link #get()} and {@link #get(long,, + * TimeUnit)} throw an {@link ExecutionException} with the same cause, + * as would be held in the corresponding CompletionException. However,, + * in these cases, methods {@link #join()} and {@link #getNow} throw, + * the CompletionException, which simplifies usage especially within, + * other completion functions., + *, + * <p>CompletableFutures themselves do not execute asynchronously., + * However, the {@code async} methods provide commonly useful ways to, + * commence asynchronous processing, using either a given {@link, + * Executor} or by default the {@link ForkJoinPool#commonPool()}, of a, + * function or action that will result in the completion of a new, + * CompletableFuture. To simplify monitoring, debugging, and tracking,, + * all generated asynchronous tasks are instances of the tagging, + * interface {@link AsynchronousCompletionTask}., + *, + * <p><em>jsr166e note: During transition, this class, + * uses nested functional interfaces with different names but the, + * same forms as those expected for JDK8.</em>, + *, + * @author Doug Lea, + * @since 1.8, + */, +public class CompletableFuture<T> implements Future<T> {, +    // jsr166e nested interfaces, +, +    /** Interface describing a void action of one argument */, +    public interface Action<A> { void accept(A a); }, +    /** Interface describing a void action of two arguments */, +    public interface BiAction<A,B> { void accept(A a, B b); }, +    /** Interface describing a function of one argument */, +    public interface Fun<A,T> { T apply(A a); }, +    /** Interface describing a function of two arguments */, +    public interface BiFun<A,B,T> { T apply(A a, B b); }, +    /** Interface describing a function of no arguments */, +    public interface Generator<T> { T get(); }, +, +, +    /*, +     * Overview:, +     *, +     * 1. Non-nullness of field result (set via CAS) indicates done., +     * An AltResult is used to box null as a result, as well as to, +     * hold exceptions.  Using a single field makes completion fast, +     * and simple to detect and trigger, at the expense of a lot of, +     * encoding and decoding that infiltrates many methods. One minor, +     * simplification relies on the (static) NIL (to box null results), +     * being the only AltResult with a null exception field, so we, +     * don't usually need explicit comparisons with NIL. The CF, +     * exception propagation mechanics surrounding decoding rely on, +     * unchecked casts of decoded results really being unchecked,, +     * where user type errors are caught at point of use, as is, +     * currently the case in Java. These are highlighted by using, +     * SuppressWarnings-annotated temporaries.]