[+++ b/src/main/java/org/elasticsearch/discovery/zen/ZenDiscovery.java, +                                if (currentIndexMetaData != null && currentIndexMetaData.isSameUUID(indexMetaData.uuid()) &&, +                                        currentIndexMetaData.version() == indexMetaData.version()) {, +                                    // safe to reuse, +                                } else {, +                                    metaDataBuilder.put(indexMetaData, false);, +++ b/src/main/java/org/elasticsearch/discovery/zen/ZenDiscovery.java, +                                if (currentIndexMetaData != null && currentIndexMetaData.isSameUUID(indexMetaData.uuid()) &&, +                                        currentIndexMetaData.version() == indexMetaData.version()) {, +                                    // safe to reuse, +                                } else {, +                                    metaDataBuilder.put(indexMetaData, false);, +++ b/src/test/java/org/elasticsearch/indices/state/RareClusterStateTests.java, +import org.elasticsearch.cluster.metadata.IndexMetaData;, +import org.elasticsearch.common.unit.TimeValue;, +import org.elasticsearch.discovery.DiscoveryModule;, +import org.elasticsearch.discovery.DiscoverySettings;, +import org.elasticsearch.test.disruption.BlockClusterStateProcessing;, +import org.elasticsearch.test.junit.annotations.TestLogging;, +import java.util.Arrays;, +import java.util.HashSet;, +import java.util.Set;, +, +import static org.elasticsearch.test.hamcrest.ElasticsearchAssertions.assertAcked;, +import static org.elasticsearch.test.hamcrest.ElasticsearchAssertions.assertHitCount;, +, +@ElasticsearchIntegrationTest.ClusterScope(scope = ElasticsearchIntegrationTest.Scope.TEST, numDataNodes = 0, numClientNodes = 0, transportClientRatio = 0), +        internalCluster().startNode();, +    @Test, +    @TestLogging(value = "cluster.service:TRACE"), +    public void testDeleteCreateInOneBulk() throws Exception {, +        internalCluster().startNodesAsync(2, ImmutableSettings.builder(), +                .put(DiscoveryModule.DISCOVERY_TYPE_KEY, "zen"), +                .build()).get();, +        assertFalse(client().admin().cluster().prepareHealth().setWaitForNodes("2").get().isTimedOut());, +        prepareCreate("test").setSettings(IndexMetaData.SETTING_AUTO_EXPAND_REPLICAS, true).addMapping("type").get();, +        ensureGreen("test");, +, +        // now that the cluster is stable, remove publishing timeout, +        assertAcked(client().admin().cluster().prepareUpdateSettings().setTransientSettings(ImmutableSettings.builder().put(DiscoverySettings.PUBLISH_TIMEOUT, "0")));, +, +        Set<String> nodes = new HashSet<>(Arrays.asList(internalCluster().getNodeNames()));, +        nodes.remove(internalCluster().getMasterName());, +, +        // block none master node., +        BlockClusterStateProcessing disruption = new BlockClusterStateProcessing(nodes.iterator().next(), getRandom());, +        internalCluster().setDisruptionScheme(disruption);, +        logger.info("--> indexing a doc");, +        index("test", "type", "1");, +        refresh();, +        disruption.startDisrupting();, +        logger.info("--> delete index and recreate it");, +        assertFalse(client().admin().indices().prepareDelete("test").setTimeout("200ms").get().isAcknowledged());, +        assertFalse(prepareCreate("test").setTimeout("200ms").setSettings(IndexMetaData.SETTING_AUTO_EXPAND_REPLICAS, true).get().isAcknowledged());, +        logger.info("--> letting cluster proceed");, +        disruption.stopDisrupting();, +        ensureGreen(TimeValue.timeValueMinutes(30), "test");, +        assertHitCount(client().prepareSearch("test").get(), 0);, +    }, +, +++ b/src/main/java/org/elasticsearch/discovery/zen/ZenDiscovery.java, +                                if (currentIndexMetaData != null && currentIndexMetaData.isSameUUID(indexMetaData.uuid()) &&, +                                        currentIndexMetaData.version() == indexMetaData.version()) {, +                                    // safe to reuse, +                                } else {, +                                    metaDataBuilder.put(indexMetaData, false);, +++ b/src/test/java/org/elasticsearch/indices/state/RareClusterStateTests.java, +import org.elasticsearch.cluster.metadata.IndexMetaData;, +import org.elasticsearch.common.unit.TimeValue;, +import org.elasticsearch.discovery.DiscoveryModule;, +import org.elasticsearch.discovery.DiscoverySettings;, +import org.elasticsearch.test.disruption.BlockClusterStateProcessing;, +import org.elasticsearch.test.junit.annotations.TestLogging;, +import java.util.Arrays;, +import java.util.HashSet;, +import java.util.Set;, +, +import static org.elasticsearch.test.hamcrest.ElasticsearchAssertions.assertAcked;, +import static org.elasticsearch.test.hamcrest.ElasticsearchAssertions.assertHitCount;, +, +@ElasticsearchIntegrationTest.ClusterScope(scope = ElasticsearchIntegrationTest.Scope.TEST, numDataNodes = 0, numClientNodes = 0, transportClientRatio = 0), +        internalCluster().startNode();, +    @Test, +    @TestLogging(value = "cluster.service:TRACE"), +    public void testDeleteCreateInOneBulk() throws Exception {, +        internalCluster().startNodesAsync(2, ImmutableSettings.builder(), +                .put(DiscoveryModule.DISCOVERY_TYPE_KEY, "zen"), +                .build()).get();, +        assertFalse(client().admin().cluster().prepareHealth().setWaitForNodes("2").get().isTimedOut());, +        prepareCreate("test").setSettings(IndexMetaData.SETTING_AUTO_EXPAND_REPLICAS, true).addMapping("type").get();, +        ensureGreen("test");, +, +        // now that the cluster is stable, remove publishing timeout, +        assertAcked(client().admin().cluster().prepareUpdateSettings().setTransientSettings(ImmutableSettings.builder().put(DiscoverySettings.PUBLISH_TIMEOUT, "0")));, +, +        Set<String> nodes = new HashSet<>(Arrays.asList(internalCluster().getNodeNames()));, +        nodes.remove(internalCluster().getMasterName());, +, +        // block none master node., +        BlockClusterStateProcessing disruption = new BlockClusterStateProcessing(nodes.iterator().next(), getRandom());]