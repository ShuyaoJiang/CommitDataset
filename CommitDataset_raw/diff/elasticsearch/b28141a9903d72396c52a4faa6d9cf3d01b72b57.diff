[+++ b/core/src/main/java/org/elasticsearch/index/shard/IndexShard.java, +                        () -> {, +                            latch.await();, +                            getEngine().fillSeqNoGaps(newPrimaryTerm);, +                        },, +++ b/core/src/main/java/org/elasticsearch/index/shard/IndexShard.java, +                        () -> {, +                            latch.await();, +                            getEngine().fillSeqNoGaps(newPrimaryTerm);, +                        },, +++ b/core/src/test/java/org/elasticsearch/index/shard/IndexShardTests.java, +import static org.elasticsearch.index.VersionType.EXTERNAL;, +import static org.elasticsearch.index.engine.Engine.Operation.Origin.REPLICA;, +import static org.hamcrest.Matchers.not;, +    public void testPrimaryFillsSeqNoGapsOnPromotion() throws Exception {, +        final IndexShard indexShard = newStartedShard(false);, +, +        // most of the time this is large enough that most of the time there will be at least one gap, +        final int operations = 1024 - scaledRandomIntBetween(0, 1024);, +        int max = Math.toIntExact(SequenceNumbersService.NO_OPS_PERFORMED);, +        boolean gap = false;, +        for (int i = 0; i < operations; i++) {, +            final String id = Integer.toString(i);, +            final ParsedDocument doc = testParsedDocument(id, "test", null, new ParseContext.Document(), new BytesArray("{}"), null);, +            if (!rarely()) {, +                final Term uid = new Term("_id", doc.id());, +                final Engine.Index index =, +                        new Engine.Index(uid, doc, i, indexShard.getPrimaryTerm(), 1, EXTERNAL, REPLICA, System.nanoTime(), -1, false);, +                indexShard.index(index);, +                max = i;, +            } else {, +                gap = true;, +            }, +        }, +, +        final int maxSeqNo = max;, +        if (gap) {, +            assertThat(indexShard.getLocalCheckpoint(), not(equalTo(maxSeqNo)));, +        }, +, +        // promote the replica, +        final ShardRouting replicaRouting = indexShard.routingEntry();, +        final ShardRouting primaryRouting =, +                TestShardRouting.newShardRouting(, +                        replicaRouting.shardId(),, +                        replicaRouting.currentNodeId(),, +                        null,, +                        true,, +                        ShardRoutingState.STARTED,, +                        replicaRouting.allocationId());, +        indexShard.updateRoutingEntry(primaryRouting);, +        indexShard.updatePrimaryTerm(indexShard.getPrimaryTerm() + 1);, +, +        /*, +         * This operation completing means that the delay operation executed as part of increasing the primary term has completed and the, +         * gaps are filled., +         */, +        final CountDownLatch latch = new CountDownLatch(1);, +        indexShard.acquirePrimaryOperationPermit(, +                new ActionListener<Releasable>() {, +                    @Override, +                    public void onResponse(Releasable releasable) {, +                        releasable.close();, +                        latch.countDown();, +                    }, +, +                    @Override, +                    public void onFailure(Exception e) {, +                        throw new RuntimeException(e);, +                    }, +                },, +                ThreadPool.Names.GENERIC);, +, +        latch.await();, +        assertThat(indexShard.getLocalCheckpoint(), equalTo((long) maxSeqNo));, +        closeShards(indexShard);, +    }, +, +            1, 1, 1, EXTERNAL, IndexRequest.UNSET_AUTO_GENERATED_TIMESTAMP, false);]