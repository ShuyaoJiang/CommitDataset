[+++ b/server/src/main/java/org/elasticsearch/index/seqno/LocalCheckpointTracker.java, +++ b/server/src/main/java/org/elasticsearch/index/seqno/LocalCheckpointTracker.java, +++ b/server/src/test/java/org/elasticsearch/index/engine/InternalEngineTests.java, +                List<Engine.Operation> ops = generateHistoryOnReplica(between(1, 100), randomBoolean(), randomBoolean(), randomBoolean());, +++ b/server/src/main/java/org/elasticsearch/index/seqno/LocalCheckpointTracker.java, +++ b/server/src/test/java/org/elasticsearch/index/engine/InternalEngineTests.java, +                List<Engine.Operation> ops = generateHistoryOnReplica(between(1, 100), randomBoolean(), randomBoolean(), randomBoolean());, +++ b/server/src/test/java/org/elasticsearch/index/engine/LuceneChangesSnapshotTests.java, +    /**, +     * If an operation above the local checkpoint is delivered multiple times, an engine will add multiple copies of that operation, +     * into Lucene (only the first copy is non-stale; others are stale and soft-deleted). Moreover, a nested document is indexed into, +     * Lucene as multiple documents (only the root document has both seq_no and term, non-root docs only have seq_no). This test verifies, +     * that {@link LuceneChangesSnapshot} returns exactly one operation per seq_no, and skip non-root nested documents or stale copies., +     */, +    public void testSkipStaleOrNonRootOfNestedDocuments() throws Exception {, +        Map<Long, Long> seqNoToTerm = new HashMap<>();, +        List<Engine.Operation> operations = generateHistoryOnReplica(between(1, 100), randomBoolean(), randomBoolean(), randomBoolean());, +        for (Engine.Operation op : operations) {, +            // Engine skips deletes or indexes below the local checkpoint, +            if (engine.getLocalCheckpoint() < op.seqNo() || op instanceof Engine.NoOp) {, +                seqNoToTerm.put(op.seqNo(), op.primaryTerm());, +                    totalOps += ((Engine.Index) op).docs().size();, +                } else {, +                    totalOps++;, +            }, +            applyOperation(engine, op);, +                engine.rollTranslogGeneration();, +            if (rarely()) {, +                engine.flush();, +                assertThat(op.toString(), op.primaryTerm(), equalTo(seqNoToTerm.get(op.seqNo())));, +            assertThat(snapshot.skippedOperations(), equalTo(totalOps - seqNoToTerm.size()));, +++ b/server/src/main/java/org/elasticsearch/index/seqno/LocalCheckpointTracker.java, +++ b/server/src/test/java/org/elasticsearch/index/engine/InternalEngineTests.java, +                List<Engine.Operation> ops = generateHistoryOnReplica(between(1, 100), randomBoolean(), randomBoolean(), randomBoolean());, +++ b/server/src/test/java/org/elasticsearch/index/engine/LuceneChangesSnapshotTests.java, +    /**, +     * If an operation above the local checkpoint is delivered multiple times, an engine will add multiple copies of that operation, +     * into Lucene (only the first copy is non-stale; others are stale and soft-deleted). Moreover, a nested document is indexed into, +     * Lucene as multiple documents (only the root document has both seq_no and term, non-root docs only have seq_no). This test verifies, +     * that {@link LuceneChangesSnapshot} returns exactly one operation per seq_no, and skip non-root nested documents or stale copies., +     */, +    public void testSkipStaleOrNonRootOfNestedDocuments() throws Exception {, +        Map<Long, Long> seqNoToTerm = new HashMap<>();, +        List<Engine.Operation> operations = generateHistoryOnReplica(between(1, 100), randomBoolean(), randomBoolean(), randomBoolean());, +        for (Engine.Operation op : operations) {, +            // Engine skips deletes or indexes below the local checkpoint, +            if (engine.getLocalCheckpoint() < op.seqNo() || op instanceof Engine.NoOp) {, +                seqNoToTerm.put(op.seqNo(), op.primaryTerm());, +                    totalOps += ((Engine.Index) op).docs().size();, +                } else {, +                    totalOps++;, +            }, +            applyOperation(engine, op);, +                engine.rollTranslogGeneration();, +            if (rarely()) {, +                engine.flush();, +                assertThat(op.toString(), op.primaryTerm(), equalTo(seqNoToTerm.get(op.seqNo())));, +            assertThat(snapshot.skippedOperations(), equalTo(totalOps - seqNoToTerm.size()));, +++ b/server/src/test/java/org/elasticsearch/index/seqno/LocalCheckpointTrackerTests.java, +++ b/server/src/main/java/org/elasticsearch/index/seqno/LocalCheckpointTracker.java, +++ b/server/src/test/java/org/elasticsearch/index/engine/InternalEngineTests.java, +                List<Engine.Operation> ops = generateHistoryOnReplica(between(1, 100), randomBoolean(), randomBoolean(), randomBoolean());, +++ b/server/src/test/java/org/elasticsearch/index/engine/LuceneChangesSnapshotTests.java, +    /**, +     * If an operation above the local checkpoint is delivered multiple times, an engine will add multiple copies of that operation, +     * into Lucene (only the first copy is non-stale; others are stale and soft-deleted). Moreover, a nested document is indexed into, +     * Lucene as multiple documents (only the root document has both seq_no and term, non-root docs only have seq_no). This test verifies, +     * that {@link LuceneChangesSnapshot} returns exactly one operation per seq_no, and skip non-root nested documents or stale copies., +     */, +    public void testSkipStaleOrNonRootOfNestedDocuments() throws Exception {, +        Map<Long, Long> seqNoToTerm = new HashMap<>();, +        List<Engine.Operation> operations = generateHistoryOnReplica(between(1, 100), randomBoolean(), randomBoolean(), randomBoolean());, +        for (Engine.Operation op : operations) {, +            // Engine skips deletes or indexes below the local checkpoint, +            if (engine.getLocalCheckpoint() < op.seqNo() || op instanceof Engine.NoOp) {, +                seqNoToTerm.put(op.seqNo(), op.primaryTerm());, +                    totalOps += ((Engine.Index) op).docs().size();, +                } else {, +                    totalOps++;, +            }, +            applyOperation(engine, op);, +                engine.rollTranslogGeneration();, +            if (rarely()) {, +                engine.flush();, +                assertThat(op.toString(), op.primaryTerm(), equalTo(seqNoToTerm.get(op.seqNo())));, +            assertThat(snapshot.skippedOperations(), equalTo(totalOps - seqNoToTerm.size()));, +++ b/server/src/test/java/org/elasticsearch/index/seqno/LocalCheckpointTrackerTests.java, +++ b/test/framework/src/main/java/org/elasticsearch/index/engine/EngineTestCase.java, +import org.elasticsearch.common.CheckedBiFunction;, +    public static CheckedBiFunction<String, Integer, ParsedDocument, IOException> nestedParsedDocFactory() throws Exception {, +        return (docId, nestedFieldValues) -> {, +            if (nestedFieldValues > 0) {, +                for (int i = 0; i < nestedFieldValues; i++) {, +    public List<Engine.Operation> generateHistoryOnReplica(int numOps, boolean allowGapInSeqNo, boolean allowDuplicate,, +                                                           boolean includeNestedDocs) throws Exception {, +        final int maxIdValue = randomInt(numOps * 2);, +        final List<Engine.Operation> operations = new ArrayList<>(numOps);, +        CheckedBiFunction<String, Integer, ParsedDocument, IOException> nestedParsedDocFactory = nestedParsedDocFactory();, +            final String id = Integer.toString(randomInt(maxIdValue));, +            final Engine.Operation.TYPE opType = randomFrom(Engine.Operation.TYPE.values());]