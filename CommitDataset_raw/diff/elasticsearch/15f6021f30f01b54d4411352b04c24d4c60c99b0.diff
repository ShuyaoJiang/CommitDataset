[+++ b/elasticsearch-transport-client/build.gradle, +, +publishing {, +    publications {, +        nebula(MavenPublication) {, +            artifactId = archivesBaseName, +        }, +    }, +}, +++ b/elasticsearch-transport-client/build.gradle, +, +publishing {, +    publications {, +        nebula(MavenPublication) {, +            artifactId = archivesBaseName, +        }, +    }, +}, +++ b/elasticsearch/src/main/java/org/elasticsearch/xpack/security/authz/accesscontrol/SecurityIndexSearcherWrapper.java, +                            failIfQueryUsesClient(queryBuilder.get(), queryShardContext);, +     * Fall back validation that verifies that queries during rewrite don't use the client to make, +     * remote calls. In the case of DLS this can cause a dead lock if DLS is also applied on these remote calls., +     * For example in the case of terms query with lookup, this can cause recursive execution of the, +     * DLS query until the get thread pool has been exhausted: https://github.com/elastic/x-plugins/issues/3145, +    static void failIfQueryUsesClient(QueryBuilder queryBuilder, QueryRewriteContext original) throws IOException {, +        QueryRewriteContext copy = new QueryRewriteContext(original.getIndexSettings(), original.getMapperService(),, +                original.getScriptService(), null, client, original.getIndexReader(), original.getClusterState());, +++ b/elasticsearch-transport-client/build.gradle, +, +publishing {, +    publications {, +        nebula(MavenPublication) {, +            artifactId = archivesBaseName, +        }, +    }, +}, +++ b/elasticsearch/src/main/java/org/elasticsearch/xpack/security/authz/accesscontrol/SecurityIndexSearcherWrapper.java, +                            failIfQueryUsesClient(queryBuilder.get(), queryShardContext);, +     * Fall back validation that verifies that queries during rewrite don't use the client to make, +     * remote calls. In the case of DLS this can cause a dead lock if DLS is also applied on these remote calls., +     * For example in the case of terms query with lookup, this can cause recursive execution of the, +     * DLS query until the get thread pool has been exhausted: https://github.com/elastic/x-plugins/issues/3145, +    static void failIfQueryUsesClient(QueryBuilder queryBuilder, QueryRewriteContext original) throws IOException {, +        QueryRewriteContext copy = new QueryRewriteContext(original.getIndexSettings(), original.getMapperService(),, +                original.getScriptService(), null, client, original.getIndexReader(), original.getClusterState());, +++ b/elasticsearch/src/main/java/org/elasticsearch/xpack/watcher/Watcher.java, +import org.elasticsearch.threadpool.FixedExecutorBuilder;, +            final FixedExecutorBuilder builder =, +                    new FixedExecutorBuilder(, +                            settings,, +                            1000,, +++ b/elasticsearch-transport-client/build.gradle, +, +publishing {, +    publications {, +        nebula(MavenPublication) {, +            artifactId = archivesBaseName, +        }, +    }, +}, +++ b/elasticsearch/src/main/java/org/elasticsearch/xpack/security/authz/accesscontrol/SecurityIndexSearcherWrapper.java, +                            failIfQueryUsesClient(queryBuilder.get(), queryShardContext);, +     * Fall back validation that verifies that queries during rewrite don't use the client to make, +     * remote calls. In the case of DLS this can cause a dead lock if DLS is also applied on these remote calls., +     * For example in the case of terms query with lookup, this can cause recursive execution of the, +     * DLS query until the get thread pool has been exhausted: https://github.com/elastic/x-plugins/issues/3145, +    static void failIfQueryUsesClient(QueryBuilder queryBuilder, QueryRewriteContext original) throws IOException {, +        QueryRewriteContext copy = new QueryRewriteContext(original.getIndexSettings(), original.getMapperService(),, +                original.getScriptService(), null, client, original.getIndexReader(), original.getClusterState());, +++ b/elasticsearch/src/main/java/org/elasticsearch/xpack/watcher/Watcher.java, +import org.elasticsearch.threadpool.FixedExecutorBuilder;, +            final FixedExecutorBuilder builder =, +                    new FixedExecutorBuilder(, +                            settings,, +                            1000,, +++ b/elasticsearch/src/test/java/org/elasticsearch/xpack/security/SecurityTribeIT.java, +import org.elasticsearch.cluster.ClusterState;, +import java.util.HashSet;, +import java.util.Set;, +import static org.elasticsearch.test.hamcrest.ElasticsearchAssertions.assertAcked;, +import static org.hamcrest.Matchers.equalTo;, +        tribeClient = getClientWrapper().apply(tribeNode.client());, +        assertTribeNodeHasAllIndices();, +        assertTribeNodeHasAllIndices();, +        // always ensure the index exists on all of the clusters in this test, +        assertAcked(internalClient().admin().indices().prepareCreate(SecurityTemplateService.SECURITY_INDEX_NAME).get());, +        assertAcked(cluster2.getInstance(InternalClient.class).admin().indices(), +                .prepareCreate(SecurityTemplateService.SECURITY_INDEX_NAME).get());, +        assertTribeNodeHasAllIndices();, +, +    public void testUsersInNonPreferredClusterOnly() throws Exception {, +        final String preferredTribe = randomBoolean() ? "t1" : "t2";, +        setupTribeNode(Settings.builder().put("tribe.on_conflict", "prefer_" + preferredTribe).build());, +        final int randomUsers = scaledRandomIntBetween(3, 8);, +        final Client cluster1Client = client();, +        final Client cluster2Client = cluster2.client();, +        List<String> shouldBeSuccessfulUsers = new ArrayList<>();, +, +        // only create users in the non preferred client, +        final Client nonPreferredClient = "t1".equals(preferredTribe) ? cluster2Client : cluster1Client;]