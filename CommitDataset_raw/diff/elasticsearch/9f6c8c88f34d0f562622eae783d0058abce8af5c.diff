[+++ b/src/main/java/org/elasticsearch/common/lucene/docset/DocIdSets.java, +    public static long sizeInBytes(DocIdSet docIdSet) {, +        if (docIdSet instanceof FixedBitSet) {, +            return ((FixedBitSet) docIdSet).getBits().length * 8 + 16;, +        }, +        // only for empty ones and unknowns..., +        return 1;, +    }, +, +++ b/src/main/java/org/elasticsearch/common/lucene/docset/DocIdSets.java, +    public static long sizeInBytes(DocIdSet docIdSet) {, +        if (docIdSet instanceof FixedBitSet) {, +            return ((FixedBitSet) docIdSet).getBits().length * 8 + 16;, +        }, +        // only for empty ones and unknowns..., +        return 1;, +    }, +, +++ b/src/main/java/org/elasticsearch/index/cache/filter/ShardFilterCache.java, +import com.google.common.cache.RemovalListener;, +import com.google.common.cache.RemovalNotification;, +import org.apache.lucene.search.DocIdSet;, +import org.elasticsearch.common.lucene.docset.DocIdSets;, +public class ShardFilterCache extends AbstractIndexShardComponent implements RemovalListener<WeightedFilterCache.FilterCacheKey, DocIdSet> {, +    public void onCached(long sizeInBytes) {, +    @Override, +    public void onRemoval(RemovalNotification<WeightedFilterCache.FilterCacheKey, DocIdSet> removalNotification) {, +        if (removalNotification.wasEvicted()) {, +        if (removalNotification.getValue() != null) {, +            totalMetric.dec(DocIdSets.sizeInBytes(removalNotification.getValue()));, +        }, +++ b/src/main/java/org/elasticsearch/common/lucene/docset/DocIdSets.java, +    public static long sizeInBytes(DocIdSet docIdSet) {, +        if (docIdSet instanceof FixedBitSet) {, +            return ((FixedBitSet) docIdSet).getBits().length * 8 + 16;, +        }, +        // only for empty ones and unknowns..., +        return 1;, +    }, +, +++ b/src/main/java/org/elasticsearch/index/cache/filter/ShardFilterCache.java, +import com.google.common.cache.RemovalListener;, +import com.google.common.cache.RemovalNotification;, +import org.apache.lucene.search.DocIdSet;, +import org.elasticsearch.common.lucene.docset.DocIdSets;, +public class ShardFilterCache extends AbstractIndexShardComponent implements RemovalListener<WeightedFilterCache.FilterCacheKey, DocIdSet> {, +    public void onCached(long sizeInBytes) {, +    @Override, +    public void onRemoval(RemovalNotification<WeightedFilterCache.FilterCacheKey, DocIdSet> removalNotification) {, +        if (removalNotification.wasEvicted()) {, +        if (removalNotification.getValue() != null) {, +            totalMetric.dec(DocIdSets.sizeInBytes(removalNotification.getValue()));, +        }, +++ b/src/main/java/org/elasticsearch/index/cache/filter/weighted/WeightedFilterCache.java, +import org.elasticsearch.common.Nullable;, +public class WeightedFilterCache extends AbstractIndexComponent implements FilterCache, SegmentReader.CoreClosedListener {, +    final ConcurrentMap<Object, Boolean> seenReaders = ConcurrentCollections.newConcurrentMap();, +            for (Object readerKey : seenReaders.keySet()) {, +                indicesFilterCache.cache().invalidate(new FilterCacheKey(readerKey, new CacheKeyFilter.Key(key)));, +            FilterCacheKey cacheKey = new FilterCacheKey(context.reader().getCoreCacheKey(), filterKey);, +                    Boolean previous = cache.seenReaders.putIfAbsent(context.reader().getCoreCacheKey(), Boolean.TRUE);, +                ShardId shardId = ShardUtils.extractShardId(context.reader());, +                if (shardId != null) {, +                    IndexShard shard = cache.indexService.shard(shardId.id());, +                    if (shard != null) {, +                        cacheKey.removalListener = shard.filterCache();, +                        shard.filterCache().onCached(DocIdSets.sizeInBytes(cacheValue));, +                    }, +                }, +            int weight = (int) Math.min(DocIdSets.sizeInBytes(value), Integer.MAX_VALUE);, +        private final Object readerKey;, +        // if we know, we will try and set the removal listener (for statistics), +        // its ok that its not volatile because we make sure we only set it when the object is created before its shared between threads, +        @Nullable, +        public RemovalListener<WeightedFilterCache.FilterCacheKey, DocIdSet> removalListener;, +, +        public FilterCacheKey(Object readerKey, Object filterKey) {, +            this.readerKey = readerKey;, +            return readerKey;, +++ b/src/main/java/org/elasticsearch/common/lucene/docset/DocIdSets.java, +    public static long sizeInBytes(DocIdSet docIdSet) {, +        if (docIdSet instanceof FixedBitSet) {, +            return ((FixedBitSet) docIdSet).getBits().length * 8 + 16;, +        }, +        // only for empty ones and unknowns..., +        return 1;, +    }, +, +++ b/src/main/java/org/elasticsearch/index/cache/filter/ShardFilterCache.java, +import com.google.common.cache.RemovalListener;, +import com.google.common.cache.RemovalNotification;, +import org.apache.lucene.search.DocIdSet;, +import org.elasticsearch.common.lucene.docset.DocIdSets;, +public class ShardFilterCache extends AbstractIndexShardComponent implements RemovalListener<WeightedFilterCache.FilterCacheKey, DocIdSet> {, +    public void onCached(long sizeInBytes) {, +    @Override, +    public void onRemoval(RemovalNotification<WeightedFilterCache.FilterCacheKey, DocIdSet> removalNotification) {, +        if (removalNotification.wasEvicted()) {, +        if (removalNotification.getValue() != null) {, +            totalMetric.dec(DocIdSets.sizeInBytes(removalNotification.getValue()));]