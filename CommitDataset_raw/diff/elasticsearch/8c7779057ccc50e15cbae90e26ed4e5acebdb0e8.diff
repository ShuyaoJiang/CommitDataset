[+++ b/src/main/java/org/elasticsearch/index/fielddata/fieldcomparator/ByteValuesComparator.java, +import org.elasticsearch.index.fielddata.util.ByteArrayRef;, +    private final boolean reversed;, +    private final byte[] values;, +    public ByteValuesComparator(IndexNumericFieldData indexFieldData, byte missingValue, int numHits, boolean reversed) {, +        this.reversed = reversed;, +        readerValues = indexFieldData.load(context).getByteValues();, +        if (readerValues.isMultiValued()) {, +            readerValues = new MultiValuedBytesWrapper(readerValues, reversed);, +        }, +, +    public static class FilteredByteValues implements ByteValues {, +, +        protected final ByteValues delegate;, +, +        public FilteredByteValues(ByteValues delegate) {, +            this.delegate = delegate;, +        }, +, +        public boolean isMultiValued() {, +            return delegate.isMultiValued();, +        }, +, +        public boolean hasValue(int docId) {, +            return delegate.hasValue(docId);, +        }, +, +        public byte getValue(int docId) {, +            return delegate.getValue(docId);, +        }, +, +        public byte getValueMissing(int docId, byte missingValue) {, +            return delegate.getValueMissing(docId, missingValue);, +        }, +, +        public ByteArrayRef getValues(int docId) {, +            return delegate.getValues(docId);, +        }, +, +        public Iter getIter(int docId) {, +            return delegate.getIter(docId);, +        }, +, +        public void forEachValueInDoc(int docId, ValueInDocProc proc) {, +            delegate.forEachValueInDoc(docId, proc);, +        }, +    }, +, +    private static final class MultiValuedBytesWrapper extends FilteredByteValues {, +, +        private final boolean reversed;, +, +        public MultiValuedBytesWrapper(ByteValues delegate, boolean reversed) {, +            super(delegate);, +            this.reversed = reversed;, +        }, +, +        @Override, +        public byte getValueMissing(int docId, byte missing) {, +            ByteValues.Iter iter = delegate.getIter(docId);, +            if (!iter.hasNext()) {, +                return missing;, +            }, +, +            byte currentVal = iter.next();, +            byte relevantVal = currentVal;, +            while (true) {, +                if (reversed) {, +                    if (currentVal > relevantVal) {, +                        relevantVal = currentVal;, +                    }, +                } else {, +                    if (currentVal < relevantVal) {, +                        relevantVal = currentVal;, +                    }, +                }, +                if (!iter.hasNext()) {, +                    break;, +                }, +                currentVal = iter.next();, +            }, +            return relevantVal;, +        }, +, +    }, +, +++ b/src/main/java/org/elasticsearch/index/fielddata/fieldcomparator/ByteValuesComparator.java, +import org.elasticsearch.index.fielddata.util.ByteArrayRef;, +    private final boolean reversed;, +    private final byte[] values;, +    public ByteValuesComparator(IndexNumericFieldData indexFieldData, byte missingValue, int numHits, boolean reversed) {, +        this.reversed = reversed;, +        readerValues = indexFieldData.load(context).getByteValues();, +        if (readerValues.isMultiValued()) {, +            readerValues = new MultiValuedBytesWrapper(readerValues, reversed);, +        }, +, +    public static class FilteredByteValues implements ByteValues {, +, +        protected final ByteValues delegate;]