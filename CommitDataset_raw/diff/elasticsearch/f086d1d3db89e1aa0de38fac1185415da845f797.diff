[+++ b/core/src/main/java/org/elasticsearch/index/seqno/LocalCheckpointService.java, +, + * This class generates sequences numbers and keeps track of the so called local checkpoint - the highest number for which all previous, + * sequence numbers have been processed (inclusive)., +     * We keep a bit for each sequence number that is still pending. To optimize allocation, we do so in multiple arrays allocating them on, +     * demand and cleaning up while completed. This setting controls the size of the arrays., +    public static Setting<Integer> SETTINGS_BIT_ARRAYS_SIZE =, +        Setting.intSetting("index.seq_no.checkpoint.bit_arrays_size", 1024, 4, Setting.Property.IndexScope);, +     * An ordered list of bit arrays representing pending sequence numbers. The list is "anchored" in {@link #firstProcessedSeqNo} which, +     * marks the sequence number the fist bit in the first array corresponds to., +    final LinkedList<FixedBitSet> processedSeqNo = new LinkedList<>();, +, +    /**, +     * The size of each bit set representing processed sequence numbers., +     */, +, +    /**, +     * The sequence number that the first bit in the first array corresponds to., +     */, +    /**, +     * The current local checkpoint, i.e., all sequence numbers no more than this number have been completed., +     */, +    /**, +     * The next available sequence number., +     */, +     * Initialize the local checkpoint service. The {@code maxSeqNo} should be set to the last sequence number assigned by this shard, or, +     * {@link SequenceNumbersService#NO_OPS_PERFORMED} and {@code localCheckpoint} should be set to the last known local checkpoint for this, +     * shard, or {@link SequenceNumbersService#NO_OPS_PERFORMED}., +     * @param shardId         the shard this service is providing tracking local checkpoints for, +     * @param maxSeqNo        the last sequence number assigned by this shard, or {@link SequenceNumbersService#NO_OPS_PERFORMED}, +     * @param localCheckpoint the last known local checkpoint for this shard, or {@link SequenceNumbersService#NO_OPS_PERFORMED}, +        nextSeqNo = maxSeqNo == SequenceNumbersService.NO_OPS_PERFORMED ? 0 : maxSeqNo + 1;, +        checkpoint = localCheckpoint;, +     * Issue the next sequence number., +     *, +     * @return the next assigned sequence number, +     */, +     * Marks the processing of the provided sequence number as completed as updates the checkpoint if possible., +     *, +     * @param seqNo the sequence number to mark as completed, +     */, +    synchronized void markSeqNoAsCompleted(final long seqNo) {, +        // make sure we track highest seen sequence number, +            // this is possible during recovery where we might replay an operation that was also replicated, +        final FixedBitSet bitSet = getBitSetForSeqNo(seqNo);, +        final int offset = seqNoToBitSetOffset(seqNo);, +    /**, +     * The current checkpoint which can be advanced by {@link #markSeqNoAsCompleted(long)}., +     *, +     * @return the current checkpoint, +     */, +    /**, +     * The maximum sequence number issued so far., +     *, +     * @return the maximum sequence number, +     */, +     * Moves the checkpoint to the last consecutively processed sequence number. This method assumes that the sequence number following the, +     * current checkpoint is processed., +        // keep it simple for now, get the checkpoint one by one; in the future we can optimize and read words, +     * Return the bit array for the provided sequence number, possibly allocating a new array if needed., +     *, +     * @param seqNo the sequence number to obtain the bit array for, +     * @return the bit array corresponding to the provided sequence number, +    private FixedBitSet getBitSetForSeqNo(final long seqNo) {, +            throw new IndexOutOfBoundsException(, +                "sequence number too high; got [" + seqNo + "], firstProcessedSeqNo [" + firstProcessedSeqNo + "]");, +    /**, +     * Obtain the position in the bit array corresponding to the provided sequence number. The bit array corresponding to the sequence, +     * number can be obtained via {@link #getBitSetForSeqNo(long)}., +     *, +     * @param seqNo the sequence number to obtain the position for, +     * @return the position in the bit array corresponding to the provided sequence number, +     */, +    private int seqNoToBitSetOffset(final long seqNo) {]