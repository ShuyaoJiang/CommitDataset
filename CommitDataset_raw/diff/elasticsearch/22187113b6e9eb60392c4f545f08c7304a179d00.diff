[+++ b/build.gradle, +      javadoc = true, +  project.afterEvaluate {, +    // ignore missing javadocs, +    tasks.withType(Javadoc) { Javadoc javadoc ->, +      // the -quiet here is because of a bug in gradle, in that adding a string option, +      // by itself is not added to the options. By adding quiet, both this option and, +      // the "value" -quiet is added, separated by a space. This is ok since the javadoc, +      // command already adds -quiet, so we are just duplicating it, +      // see https://discuss.gradle.org/t/add-custom-javadoc-option-that-does-not-take-an-argument/5959, +      javadoc.options.addStringOption('Xdoclint:all,-missing', '-quiet'), +    }, +++ b/build.gradle, +      javadoc = true, +  project.afterEvaluate {, +    // ignore missing javadocs, +    tasks.withType(Javadoc) { Javadoc javadoc ->, +      // the -quiet here is because of a bug in gradle, in that adding a string option, +      // by itself is not added to the options. By adding quiet, both this option and, +      // the "value" -quiet is added, separated by a space. This is ok since the javadoc, +      // command already adds -quiet, so we are just duplicating it, +      // see https://discuss.gradle.org/t/add-custom-javadoc-option-that-does-not-take-an-argument/5959, +      javadoc.options.addStringOption('Xdoclint:all,-missing', '-quiet'), +    }, +++ b/buildSrc/src/main/groovy/org/elasticsearch/gradle/BuildPlugin.groovy, +import org.gradle.process.ExecResult, +, +    /** Performs checks on the build environment and prints information about the build environment. */, +            String javaHome = findJavaHome(), +            File gradleJavaHome = Jvm.current().javaHome, +            String gradleJavaVersionDetails = "${System.getProperty('java.vendor')} ${System.getProperty('java.version')}" +, +                " [${System.getProperty('java.vm.name')} ${System.getProperty('java.vm.version')}]", +, +            String javaVersionDetails = gradleJavaVersionDetails, +            String javaVersion = System.getProperty('java.version'), +            JavaVersion javaVersionEnum = JavaVersion.current(), +            if (new File(javaHome).canonicalPath != gradleJavaHome.canonicalPath) {, +                javaVersionDetails = findJavaVersionDetails(project, javaHome), +                javaVersionEnum = JavaVersion.toVersion(findJavaSpecificationVersion(project, javaHome)), +                javaVersion = findJavaVersion(project, javaHome), +            }, +            if (gradleJavaVersionDetails != javaVersionDetails) {, +                println "  JDK Version (gradle)  : ${gradleJavaVersionDetails}", +                println "  JDK Version (compile) : ${javaVersionDetails}", +            } else {, +                println "  JDK Version           : ${gradleJavaVersionDetails}", +            }, +            if (javaVersionEnum < minimumJava) {, +            project.rootProject.ext.javaHome = javaHome, +            project.rootProject.ext.javaVersion = javaVersion, +            project.rootProject.ext.buildChecksDone = true, +        }, +        project.targetCompatibility = minimumJava, +        project.sourceCompatibility = minimumJava, +        // set java home for each project, so they dont have to find it in the root project, +        project.ext.javaHome = project.rootProject.ext.javaHome, +        project.ext.javaVersion = project.rootProject.ext.javaVersion, +    }, +, +    /** Finds and enforces JAVA_HOME is set */, +    private static String findJavaHome() {, +        String javaHome = System.getenv('JAVA_HOME'), +        return javaHome, +    /** Finds printable java version of the given JAVA_HOME */, +    private static String findJavaVersionDetails(Project project, String javaHome) {, +        String versionInfoScript = 'print(' +, +            'java.lang.System.getProperty("java.vendor") + " " + java.lang.System.getProperty("java.version") + ' +, +            '" [" + java.lang.System.getProperty("java.vm.name") + " " + java.lang.System.getProperty("java.vm.version") + "]");', +        return runJavascript(project, javaHome, versionInfoScript).trim(), +    }, +, +    /** Finds the parsable java specification version */, +    private static String findJavaSpecificationVersion(Project project, String javaHome) {, +        String versionScript = 'print(java.lang.System.getProperty("java.specification.version"));', +        return runJavascript(project, javaHome, versionScript), +    }, +, +    /** Finds the parsable java specification version */, +    private static String findJavaVersion(Project project, String javaHome) {, +        String versionScript = 'print(java.lang.System.getProperty("java.version"));', +        return runJavascript(project, javaHome, versionScript), +    }, +, +    /** Runs the given javascript using jjs from the jdk, and returns the output */, +    private static String runJavascript(Project project, String javaHome, String script) {, +        File tmpScript = File.createTempFile('es-gradle-tmp', '.js'), +        tmpScript.setText(script, 'UTF-8'), +        ByteArrayOutputStream output = new ByteArrayOutputStream(), +        ExecResult result = project.exec {, +            executable = new File(javaHome, 'bin/jjs'), +            args tmpScript.toString(), +            standardOutput = output, +            errorOutput = new ByteArrayOutputStream(), +            ignoreExitValue = true // we do not fail so we can first cleanup the tmp file, +        }, +        java.nio.file.Files.delete(tmpScript.toPath()), +        result.assertNormalExitValue(), +        return output.toString('UTF-8').trim(), +    }, +]