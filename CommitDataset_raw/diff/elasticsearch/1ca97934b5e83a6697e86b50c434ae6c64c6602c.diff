[+++ b/.gitignore, +, +++ b/.gitignore, +, +++ b/core/src/main/java/org/elasticsearch/action/admin/cluster/health/TransportClusterHealthAction.java, +                    numberOfPendingTasks, numberOfInFlightFetch, UnassignedInfo.getNumberOfDelayedUnassigned(settings, clusterState),, +                numberOfInFlightFetch, UnassignedInfo.getNumberOfDelayedUnassigned(settings, clusterState), pendingTaskTimeInQueue);, +++ b/.gitignore, +, +++ b/core/src/main/java/org/elasticsearch/action/admin/cluster/health/TransportClusterHealthAction.java, +                    numberOfPendingTasks, numberOfInFlightFetch, UnassignedInfo.getNumberOfDelayedUnassigned(settings, clusterState),, +                numberOfInFlightFetch, UnassignedInfo.getNumberOfDelayedUnassigned(settings, clusterState), pendingTaskTimeInQueue);, +++ b/core/src/main/java/org/elasticsearch/bootstrap/JVMCheck.java, +            sb.append("Java version: ").append(fullVersion());, +            Loggers.getLogger(JVMCheck.class).warn("bypassing jvm version check for version [{}], this can result in data corruption!", fullVersion());, +                sb.append("Your version: " + fullVersion());, +    , +    /** , +     * Returns java + jvm version, looks like this:, +     * {@code Oracle Corporation 1.8.0_45 [Java HotSpot(TM) 64-Bit Server VM 25.45-b02]}, +     */, +    static String fullVersion() {, +        StringBuilder sb = new StringBuilder();, +        sb.append(Constants.JAVA_VENDOR);, +        sb.append(" ");, +        sb.append(Constants.JAVA_VERSION);, +        sb.append(" [");, +        sb.append(Constants.JVM_NAME);, +        sb.append(" ");, +        sb.append(Constants.JVM_VERSION);, +        sb.append("]");, +        return sb.toString();, +    }, +++ b/.gitignore, +, +++ b/core/src/main/java/org/elasticsearch/action/admin/cluster/health/TransportClusterHealthAction.java, +                    numberOfPendingTasks, numberOfInFlightFetch, UnassignedInfo.getNumberOfDelayedUnassigned(settings, clusterState),, +                numberOfInFlightFetch, UnassignedInfo.getNumberOfDelayedUnassigned(settings, clusterState), pendingTaskTimeInQueue);, +++ b/core/src/main/java/org/elasticsearch/bootstrap/JVMCheck.java, +            sb.append("Java version: ").append(fullVersion());, +            Loggers.getLogger(JVMCheck.class).warn("bypassing jvm version check for version [{}], this can result in data corruption!", fullVersion());, +                sb.append("Your version: " + fullVersion());, +    , +    /** , +     * Returns java + jvm version, looks like this:, +     * {@code Oracle Corporation 1.8.0_45 [Java HotSpot(TM) 64-Bit Server VM 25.45-b02]}, +     */, +    static String fullVersion() {, +        StringBuilder sb = new StringBuilder();, +        sb.append(Constants.JAVA_VENDOR);, +        sb.append(" ");, +        sb.append(Constants.JAVA_VERSION);, +        sb.append(" [");, +        sb.append(Constants.JVM_NAME);, +        sb.append(" ");, +        sb.append(Constants.JVM_VERSION);, +        sb.append("]");, +        return sb.toString();, +    }, +++ b/core/src/main/java/org/elasticsearch/cluster/routing/RoutingService.java, +                TimeValue nextDelay = TimeValue.timeValueMillis(UnassignedInfo.findNextDelayedAllocationIn(settings, event.state()));, +                logger.info("delaying allocation for [{}] unassigned shards, next check in [{}]", UnassignedInfo.getNumberOfDelayedUnassigned(settings, event.state()), nextDelay);, +++ b/.gitignore, +, +++ b/core/src/main/java/org/elasticsearch/action/admin/cluster/health/TransportClusterHealthAction.java, +                    numberOfPendingTasks, numberOfInFlightFetch, UnassignedInfo.getNumberOfDelayedUnassigned(settings, clusterState),, +                numberOfInFlightFetch, UnassignedInfo.getNumberOfDelayedUnassigned(settings, clusterState), pendingTaskTimeInQueue);, +++ b/core/src/main/java/org/elasticsearch/bootstrap/JVMCheck.java, +            sb.append("Java version: ").append(fullVersion());, +            Loggers.getLogger(JVMCheck.class).warn("bypassing jvm version check for version [{}], this can result in data corruption!", fullVersion());, +                sb.append("Your version: " + fullVersion());, +    , +    /** , +     * Returns java + jvm version, looks like this:, +     * {@code Oracle Corporation 1.8.0_45 [Java HotSpot(TM) 64-Bit Server VM 25.45-b02]}, +     */, +    static String fullVersion() {, +        StringBuilder sb = new StringBuilder();, +        sb.append(Constants.JAVA_VENDOR);, +        sb.append(" ");, +        sb.append(Constants.JAVA_VERSION);, +        sb.append(" [");, +        sb.append(Constants.JVM_NAME);, +        sb.append(" ");, +        sb.append(Constants.JVM_VERSION);, +        sb.append("]");, +        return sb.toString();, +    }, +++ b/core/src/main/java/org/elasticsearch/cluster/routing/RoutingService.java, +                TimeValue nextDelay = TimeValue.timeValueMillis(UnassignedInfo.findNextDelayedAllocationIn(settings, event.state()));, +                logger.info("delaying allocation for [{}] unassigned shards, next check in [{}]", UnassignedInfo.getNumberOfDelayedUnassigned(settings, event.state()), nextDelay);, +++ b/core/src/main/java/org/elasticsearch/cluster/routing/UnassignedInfo.java, +    public long getDelayAllocationExpirationIn(Settings settings, Settings indexSettings) {, +        long delta = System.currentTimeMillis() - timestamp;, +    public static int getNumberOfDelayedUnassigned(Settings settings, ClusterState state) {, +                long delay = shard.unassignedInfo().getDelayAllocationExpirationIn(settings, indexMetaData.getSettings());, +    public static long findNextDelayedAllocationIn(Settings settings, ClusterState state) {, +                long nextShardDelay = shard.unassignedInfo().getDelayAllocationExpirationIn(settings, indexMetaData.getSettings());, +++ b/.gitignore, +]