[+++ b/core/src/main/java/org/elasticsearch/index/translog/Checkpoint.java, +import org.apache.lucene.codecs.CodecUtil;, +import org.apache.lucene.store.Directory;, +import org.apache.lucene.store.IOContext;, +import org.apache.lucene.store.IndexInput;, +import org.apache.lucene.store.OutputStreamIndexOutput;, +import org.apache.lucene.store.SimpleFSDirectory;, +import java.io.ByteArrayOutputStream;, +    private static final int INITIAL_VERSION = 1; // start with 1, just to recognize there was some magic serialization logic before, +, +    private static final String CHECKPOINT_CODEC = "ckp";, +, +    static final int FILE_SIZE = CodecUtil.headerLength(CHECKPOINT_CODEC), +        + Integer.BYTES  // ops, +        + Long.BYTES // offset, +        + Long.BYTES // generation, +        + CodecUtil.footerLength();, +, +    static final int LEGACY_NON_CHECKSUMMED_FILE_LENGTH = Integer.BYTES  // ops, +            + Long.BYTES // offset, +            + Long.BYTES; // generation, +, +    private void write(DataOutput out) throws IOException {, +    // reads a checksummed checkpoint introduced in ES 5.0.0, +    static Checkpoint readChecksummedV1(DataInput in) throws IOException {, +        return new Checkpoint(in.readLong(), in.readInt(), in.readLong());, +    }, +, +    // reads checkpoint from ES < 5.0.0, +    static Checkpoint readNonChecksummed(DataInput in) throws IOException {, +        return new Checkpoint(in.readLong(), in.readInt(), in.readLong());, +    }, +, +        try (Directory dir = new SimpleFSDirectory(path.getParent())) {, +            try (final IndexInput indexInput = dir.openInput(path.getFileName().toString(), IOContext.DEFAULT)) {, +                if (indexInput.length() == LEGACY_NON_CHECKSUMMED_FILE_LENGTH) {, +                    // OLD unchecksummed file that was written < ES 5.0.0, +                    return Checkpoint.readNonChecksummed(indexInput);, +                }, +                // We checksum the entire file before we even go and parse it. If it's corrupted we barf right here., +                CodecUtil.checksumEntireFile(indexInput);, +                final int fileVersion = CodecUtil.checkHeader(indexInput, CHECKPOINT_CODEC, INITIAL_VERSION, INITIAL_VERSION);, +                return Checkpoint.readChecksummedV1(indexInput);, +            }, +        final ByteArrayOutputStream byteOutputStream = new ByteArrayOutputStream(FILE_SIZE) {, +            @Override, +            public synchronized byte[] toByteArray() {, +                // don't clone, +                return buf;, +            }, +        };, +        final String resourceDesc = "checkpoint(path=\"" + checkpointFile + "\", gen=" + checkpoint + ")";, +        try (final OutputStreamIndexOutput indexOutput =, +                 new OutputStreamIndexOutput(resourceDesc, checkpointFile.toString(), byteOutputStream, FILE_SIZE)) {, +            CodecUtil.writeHeader(indexOutput, CHECKPOINT_CODEC, INITIAL_VERSION);, +            checkpoint.write(indexOutput);, +            CodecUtil.writeFooter(indexOutput);, +, +            assert indexOutput.getFilePointer() == FILE_SIZE :, +                "get you number straights. Bytes written: " + indexOutput.getFilePointer() + " buffer size: " + FILE_SIZE;, +            assert indexOutput.getFilePointer() < 512 :, +                "checkpoint files have to be smaller 512b for atomic writes. size: " + indexOutput.getFilePointer();, +, +        }, +        // now go and write to the channel, in one go., +            Channels.writeToChannel(byteOutputStream.toByteArray(), channel);, +            // no need to force metadata, file size stays the same and we did the full fsync, +            // when we first created the file, so the directory entry doesn't change as well, +        if (this == o) {, +            return true;, +        }, +        if (o == null || getClass() != o.getClass()) {, +            return false;, +        }, +        if (offset != that.offset) {, +            return false;, +        }, +        if (numOps != that.numOps) {, +            return false;, +        }, +++ b/core/src/main/java/org/elasticsearch/index/translog/Checkpoint.java, +import org.apache.lucene.codecs.CodecUtil;, +import org.apache.lucene.store.Directory;, +import org.apache.lucene.store.IOContext;, +import org.apache.lucene.store.IndexInput;, +import org.apache.lucene.store.OutputStreamIndexOutput;, +import org.apache.lucene.store.SimpleFSDirectory;, +import java.io.ByteArrayOutputStream;, +    private static final int INITIAL_VERSION = 1; // start with 1, just to recognize there was some magic serialization logic before, +, +    private static final String CHECKPOINT_CODEC = "ckp";, +, +    static final int FILE_SIZE = CodecUtil.headerLength(CHECKPOINT_CODEC), +        + Integer.BYTES  // ops, +        + Long.BYTES // offset, +        + Long.BYTES // generation, +        + CodecUtil.footerLength();, +, +    static final int LEGACY_NON_CHECKSUMMED_FILE_LENGTH = Integer.BYTES  // ops, +            + Long.BYTES // offset]