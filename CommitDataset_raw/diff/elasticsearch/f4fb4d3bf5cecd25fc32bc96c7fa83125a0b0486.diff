[+++ b/core/src/main/java/org/elasticsearch/action/admin/indices/get/TransportGetIndexAction.java, +import org.elasticsearch.indices.IndicesService;, +import java.io.IOException;, +    private final IndicesService indicesService;, +, +                                   ThreadPool threadPool, ActionFilters actionFilters,, +                                   IndexNameExpressionResolver indexNameExpressionResolver, IndicesService indicesService) {, +        super(settings, GetIndexAction.NAME, transportService, clusterService, threadPool, actionFilters, GetIndexRequest::new,, +                indexNameExpressionResolver);, +        this.indicesService = indicesService;, +        return state.blocks().indicesBlockedException(ClusterBlockLevel.METADATA_READ,, +                indexNameExpressionResolver.concreteIndexNames(state, request));, +                        try {, +                            mappingsResult = state.metaData().findMappings(concreteIndices, request.types(),, +                                    indicesService.getFieldFilter());, +                        } catch (IOException e) {, +                            listener.onFailure(e);, +                            return;, +                        }, +++ b/core/src/main/java/org/elasticsearch/action/admin/indices/get/TransportGetIndexAction.java, +import org.elasticsearch.indices.IndicesService;, +import java.io.IOException;, +    private final IndicesService indicesService;, +, +                                   ThreadPool threadPool, ActionFilters actionFilters,, +                                   IndexNameExpressionResolver indexNameExpressionResolver, IndicesService indicesService) {, +        super(settings, GetIndexAction.NAME, transportService, clusterService, threadPool, actionFilters, GetIndexRequest::new,, +                indexNameExpressionResolver);, +        this.indicesService = indicesService;, +        return state.blocks().indicesBlockedException(ClusterBlockLevel.METADATA_READ,, +                indexNameExpressionResolver.concreteIndexNames(state, request));, +                        try {, +                            mappingsResult = state.metaData().findMappings(concreteIndices, request.types(),, +                                    indicesService.getFieldFilter());, +                        } catch (IOException e) {, +                            listener.onFailure(e);, +                            return;, +                        }, +++ b/core/src/main/java/org/elasticsearch/action/admin/indices/mapping/get/TransportGetFieldMappingsIndexAction.java, +import org.elasticsearch.common.bytes.BytesReference;, +import org.elasticsearch.common.xcontent.XContentHelper;, +import java.util.Collections;, +import java.util.HashMap;, +import java.util.function.Predicate;, +        super(settings, ACTION_NAME, threadPool, clusterService, transportService, actionFilters, indexNameExpressionResolver,, +                GetFieldMappingsIndexRequest::new, ThreadPool.Names.MANAGEMENT);, +        Predicate<String> metadataFieldPredicate = indicesService::isMetaDataField;, +        Predicate<String> fieldPredicate = metadataFieldPredicate.or(indicesService.getFieldFilter().apply(shardId.getIndexName()));, +, +        Map<String, Map<String, FieldMappingMetaData>> typeMappings = new HashMap<>();, +            Map<String, FieldMappingMetaData> fieldMapping = findFieldMappingsByType(fieldPredicate, documentMapper, request);, +        return new GetFieldMappingsResponse(singletonMap(shardId.getIndexName(), Collections.unmodifiableMap(typeMappings)));, +    private static Map<String, FieldMappingMetaData> findFieldMappingsByType(Predicate<String> fieldPredicate,, +                                                                             DocumentMapper documentMapper,, +                                                                             GetFieldMappingsIndexRequest request) {, +        Map<String, FieldMappingMetaData> fieldMappings = new HashMap<>();, +                    addFieldMapper(fieldPredicate, fieldMapper.fieldType().name(), fieldMapper, fieldMappings, request.includeDefaults());, +                        addFieldMapper(fieldPredicate,  fieldMapper.fieldType().name(),, +                                fieldMapper, fieldMappings, request.includeDefaults());, +                    addFieldMapper(fieldPredicate, field, fieldMapper, fieldMappings, request.includeDefaults());, +        return Collections.unmodifiableMap(fieldMappings);, +    private static void addFieldMapper(Predicate<String> fieldPredicate,, +                                       String field, FieldMapper fieldMapper, Map<String, FieldMappingMetaData> fieldMappings,, +                                       boolean includeDefaults) {, +        if (fieldPredicate.test(field)) {, +                BytesReference bytes = XContentHelper.toXContent(fieldMapper, XContentType.JSON,, +                        includeDefaults ? includeDefaultsParams : ToXContent.EMPTY_PARAMS, false);, +                fieldMappings.put(field, new FieldMappingMetaData(fieldMapper.fieldType().name(), bytes));, +    }, +++ b/core/src/main/java/org/elasticsearch/action/admin/indices/get/TransportGetIndexAction.java, +import org.elasticsearch.indices.IndicesService;, +import java.io.IOException;, +    private final IndicesService indicesService;, +, +                                   ThreadPool threadPool, ActionFilters actionFilters,, +                                   IndexNameExpressionResolver indexNameExpressionResolver, IndicesService indicesService) {, +        super(settings, GetIndexAction.NAME, transportService, clusterService, threadPool, actionFilters, GetIndexRequest::new,, +                indexNameExpressionResolver);, +        this.indicesService = indicesService;, +        return state.blocks().indicesBlockedException(ClusterBlockLevel.METADATA_READ,, +                indexNameExpressionResolver.concreteIndexNames(state, request));, +                        try {, +                            mappingsResult = state.metaData().findMappings(concreteIndices, request.types(),, +                                    indicesService.getFieldFilter());, +                        } catch (IOException e) {, +                            listener.onFailure(e);, +                            return;, +                        }, +++ b/core/src/main/java/org/elasticsearch/action/admin/indices/mapping/get/TransportGetFieldMappingsIndexAction.java, +import org.elasticsearch.common.bytes.BytesReference;, +import org.elasticsearch.common.xcontent.XContentHelper;, +import java.util.Collections;, +import java.util.HashMap;, +import java.util.function.Predicate;, +        super(settings, ACTION_NAME, threadPool, clusterService, transportService, actionFilters, indexNameExpressionResolver,, +                GetFieldMappingsIndexRequest::new, ThreadPool.Names.MANAGEMENT);, +        Predicate<String> metadataFieldPredicate = indicesService::isMetaDataField;, +        Predicate<String> fieldPredicate = metadataFieldPredicate.or(indicesService.getFieldFilter().apply(shardId.getIndexName()));, +, +        Map<String, Map<String, FieldMappingMetaData>> typeMappings = new HashMap<>();]