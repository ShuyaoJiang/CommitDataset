[+++ b/core/src/main/java/org/elasticsearch/common/rounding/TimeZoneRounding.java, +            long timeLocal = timeZone.convertUTCToLocal(utcMillis);, +            return timeZone.convertLocalToUTC(rounded, false, utcMillis);, +++ b/core/src/main/java/org/elasticsearch/common/rounding/TimeZoneRounding.java, +            long timeLocal = timeZone.convertUTCToLocal(utcMillis);, +            return timeZone.convertLocalToUTC(rounded, false, utcMillis);, +++ b/core/src/main/java/org/elasticsearch/common/xcontent/ConstructingObjectParser.java, + *           a -> new Thing((String) a[0], (String) a[1], (Integer) a[2]));, + *       PARSER.declareInt(optionalConstructorArg(), new ParseField("mineral"));, + *       PARSER.declareInt(Thing::setBug, new ParseField("bug"));, + * <p>, + * Note: if optional constructor arguments aren't specified then the number of allocations is always the worst case., + * </p>, +     * Consumer that marks a field as a required constructor argument instead of a real object field., +    private static final BiConsumer<Object, Object> REQUIRED_CONSTRUCTOR_ARG_MARKER = (a, b) -> {, +        throw new UnsupportedOperationException("I am just a marker I should never be called.");, +    };, +, +    /**, +     * Consumer that marks a field as an optional constructor argument instead of a real object field., +     */, +    private static final BiConsumer<Object, Object> OPTIONAL_CONSTRUCTOR_ARG_MARKER = (a, b) -> {, +    private final List<ConstructorArgInfo> constructorArgInfos = new ArrayList<>();, +     * Pass the {@linkplain BiConsumer} this returns the declare methods to declare a required constructor argument. See this class's, +     * javadoc for an example. The order in which these are declared matters: it is the order that they come in the array passed to, +     * {@link #builder} and the order that missing arguments are reported to the user if any are missing. When all of these parameters are, +     * parsed from the {@linkplain XContentParser} the target object is immediately built., +        return (BiConsumer<Value, FieldT>) REQUIRED_CONSTRUCTOR_ARG_MARKER;, +    }, +, +    /**, +     * Pass the {@linkplain BiConsumer} this returns the declare methods to declare an optional constructor argument. See this class's, +     * javadoc for an example. The order in which these are declared matters: it is the order that they come in the array passed to, +     * {@link #builder} and the order that missing arguments are reported to the user if any are missing. When all of these parameters are, +     * parsed from the {@linkplain XContentParser} the target object is immediately built., +     */, +    @SuppressWarnings("unchecked") // Safe because we never call the method. This is just trickery to make the interface pretty., +    public static <Value, FieldT> BiConsumer<Value, FieldT> optionalConstructorArg() {, +        return (BiConsumer<Value, FieldT>) OPTIONAL_CONSTRUCTOR_ARG_MARKER;, +        if (consumer == REQUIRED_CONSTRUCTOR_ARG_MARKER || consumer == OPTIONAL_CONSTRUCTOR_ARG_MARKER) {, +            int position = constructorArgInfos.size();, +            boolean required = consumer == REQUIRED_CONSTRUCTOR_ARG_MARKER;, +            constructorArgInfos.add(new ConstructorArgInfo(parseField, required));, +        private final Object[] constructorArgs = new Object[constructorArgInfos.size()];, +            if (constructorArgsCollected == constructorArgInfos.size()) {, +                buildTarget();, +            /*, +             * The object hasn't been built which ought to mean we're missing some constructor arguments. But they could be optional! We'll, +             * check if they are all optional and build the error message at the same time - if we don't start the error message then they, +             * were all optional!, +             */, +                if (constructorArgs[i] != null) continue;, +                ConstructorArgInfo arg = constructorArgInfos.get(i);, +                if (false == arg.required) continue;, +                    message = new StringBuilder("Required [").append(arg.field);, +                    message.append(", ").append(arg.field);, +            if (message != null) {, +                // There were non-optional constructor arguments missing., +                throw new IllegalArgumentException(message.append(']').toString());, +             * If there weren't any constructor arguments declared at all then we won't get an error message but this isn't really a valid, +             * use of ConstructingObjectParser. You should be using ObjectParser instead. Since this is more of a programmer error and the, +             * parser ought to still work we just assert this., +            assert false == constructorArgInfos.isEmpty() : "[" + objectParser.getName() + "] must configure at least on constructor ", +                        + "argument. If it doesn't have any it should use ObjectParser instead of ConstructingObjectParser. This is a bug ", +                        + "in the parser declaration.";, +            // All missing constructor arguments were optional. Just build the target and return it., +            buildTarget();, +            return targetObject;, +, +        private void buildTarget() {, +            try {, +                targetObject = builder.apply(constructorArgs);, +                while (queuedFieldsCount > 0) {, +                    queuedFieldsCount -= 1;, +                    queuedFields[queuedFieldsCount].accept(targetObject);, +            } catch (ParsingException e) {, +                throw new ParsingException(e.getLineNumber(), e.getColumnNumber(),, +                        "failed to build [" + objectParser.getName() + "] after last required field arrived", e);, +            } catch (Exception e) {, +                throw new ParsingException(null, "Failed to build [" + objectParser.getName() + "] after last required field arrived", e);, +            }, +        }, +    }, +, +    private static class ConstructorArgInfo {, +        final ParseField field;, +        final boolean required;, +, +        public ConstructorArgInfo(ParseField field, boolean required) {, +            this.field = field;, +            this.required = required;, +++ b/core/src/main/java/org/elasticsearch/common/rounding/TimeZoneRounding.java, +            long timeLocal = timeZone.convertUTCToLocal(utcMillis);, +            return timeZone.convertLocalToUTC(rounded, false, utcMillis);, +++ b/core/src/main/java/org/elasticsearch/common/xcontent/ConstructingObjectParser.java, + *           a -> new Thing((String) a[0], (String) a[1], (Integer) a[2]));, + *       PARSER.declareInt(optionalConstructorArg(), new ParseField("mineral"));, + *       PARSER.declareInt(Thing::setBug, new ParseField("bug"));, + * <p>, + * Note: if optional constructor arguments aren't specified then the number of allocations is always the worst case.]