[+++ b/src/main/java/org/elasticsearch/index/engine/internal/InternalEngine.java, +import org.apache.lucene.util.*;, +    private final AtomicBoolean isClosed = new AtomicBoolean(false);, +    private volatile boolean closedOrFailed = false;, +    private volatile Throwable failedEngine = null;, +        this.store = engineConfig.getStore();, +        store.incRef();, +        boolean success = false;, +        try {, +            this.mergeSchedulerFailureListener = new FailEngineOnMergeFailure();, +            this.mergeSchedulerListener = new MergeSchedulerListener();, +            this.mergeScheduler.addListener(mergeSchedulerListener);, +            this.mergeScheduler.addFailureListener(mergeSchedulerFailureListener);, +            success = true;, +        } finally {, +            if (success == false) {, +                // failure we need to dec the store reference, +                store.decRef();, +            }, +        }, +                IOUtils.closeWhileHandlingException(searcherManager, indexWriter);, +        if (closedOrFailed == false) {, +                if (closedOrFailed) {, +            ensureOpen();, +                if (closedOrFailed == false) {, +        if (closedOrFailed) {, +        ensureOpen();, +            assert closedOrFailed : "Engine is not closed but writer is null";, +            if (closedOrFailed) {, +                throw new EngineClosedException(shardId, failedEngine);, +        if (closedOrFailed) {, +            if (t != failedEngine && failedEngine != null) {, +                t.addSuppressed(failedEngine);, +            }, +            if (isClosed.compareAndSet(false, true)) {, +                    closedOrFailed = true;, +                    store.decRef();, +        return currentIndexWriter().getConfig();, +                try {, +            } catch (Throwable t) {, +                // don't bubble up these exceptions up, +                logger.warn("failEngine threw exception", t);, +            } finally {, +                closedOrFailed = true;, +                try (InternalLock _ = readLock.acquire()) {, +                    // we take the readlock here to ensure nobody replaces this IW concurrently., +                    if (indexWriter != null) {, +                        indexWriter.rollback();, +                    }, +                } catch (Throwable t) {, +                    logger.warn("Rolling back indexwriter on engine failure failed", t);, +                    // to be on the safe side we just rollback the IW, +                        if (closedOrFailed == false) {, +                    if (closedOrFailed == false) {, +++ b/src/main/java/org/elasticsearch/index/engine/internal/InternalEngine.java, +import org.apache.lucene.util.*;, +    private final AtomicBoolean isClosed = new AtomicBoolean(false);, +    private volatile boolean closedOrFailed = false;, +    private volatile Throwable failedEngine = null;, +        this.store = engineConfig.getStore();, +        store.incRef();, +        boolean success = false;, +        try {, +            this.mergeSchedulerFailureListener = new FailEngineOnMergeFailure();, +            this.mergeSchedulerListener = new MergeSchedulerListener();, +            this.mergeScheduler.addListener(mergeSchedulerListener);, +            this.mergeScheduler.addFailureListener(mergeSchedulerFailureListener);, +            success = true;, +        } finally {, +            if (success == false) {, +                // failure we need to dec the store reference, +                store.decRef();, +            }, +        }, +                IOUtils.closeWhileHandlingException(searcherManager, indexWriter);, +        if (closedOrFailed == false) {, +                if (closedOrFailed) {, +            ensureOpen();, +                if (closedOrFailed == false) {, +        if (closedOrFailed) {, +        ensureOpen();, +            assert closedOrFailed : "Engine is not closed but writer is null";, +            if (closedOrFailed) {, +                throw new EngineClosedException(shardId, failedEngine);, +        if (closedOrFailed) {, +            if (t != failedEngine && failedEngine != null) {, +                t.addSuppressed(failedEngine);, +            }, +            if (isClosed.compareAndSet(false, true)) {, +                    closedOrFailed = true;, +                    store.decRef();, +        return currentIndexWriter().getConfig();, +                try {, +            } catch (Throwable t) {, +                // don't bubble up these exceptions up, +                logger.warn("failEngine threw exception", t);, +            } finally {, +                closedOrFailed = true;, +                try (InternalLock _ = readLock.acquire()) {, +                    // we take the readlock here to ensure nobody replaces this IW concurrently.]