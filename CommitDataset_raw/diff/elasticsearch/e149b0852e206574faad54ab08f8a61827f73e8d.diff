[+++ b/benchmarks/build.gradle, +thirdPartyAudit.excludes = [, +], +++ b/benchmarks/build.gradle, +thirdPartyAudit.excludes = [, +], +++ b/build.gradle, +final boolean bwc_tests_enabled = true, +final String bwc_tests_disabled_issue = "" /* place a PR link here when committing bwc changes */, +  throw new GradleException('You must run `gradle idea` from the root of elasticsearch before importing into IntelliJ'), +++ b/benchmarks/build.gradle, +thirdPartyAudit.excludes = [, +], +++ b/build.gradle, +final boolean bwc_tests_enabled = true, +final String bwc_tests_disabled_issue = "" /* place a PR link here when committing bwc changes */, +  throw new GradleException('You must run `gradle idea` from the root of elasticsearch before importing into IntelliJ'), +++ b/buildSrc/src/main/java/org/elasticsearch/gradle/precommit/ThirdPartyAuditTask.java, +    /**, +     * patterns for classes to exclude, because we understand their issues, +     */, +    private Set<String> excludes = new TreeSet<>();, +    public void setExcludes(String... classes) {, +        excludes.clear();, +            if (each.indexOf('*') != -1) {, +                throw new IllegalArgumentException("illegal third party audit exclusion: '" + each + "', wildcards are not permitted!");, +            }, +            excludes.add(each);, +    public Set<String> getExcludes() {, +        return Collections.unmodifiableSet(excludes);, +        try {, +            assertNoPointlessExclusions(missingClasses, violationsClasses, jdkJarHellClasses);, +            assertNoMissingAndViolations(missingClasses, violationsClasses);, +        } catch (IllegalStateException e) {, +            getLogger().error(forbiddenApisOutput);, +            throw e;, +        jdkJarHellClasses.removeAll(excludes);, +    private void assertNoMissingAndViolations(Set<String> missingClasses, Set<String> violationsClasses) {, +        missingClasses.removeAll(excludes);, +        violationsClasses.removeAll(excludes);, +        String missingText = formatClassList(missingClasses);, +        String violationsText = formatClassList(violationsClasses);, +        if (missingText.isEmpty() && violationsText.isEmpty()) {, +            getLogger().info("Third party audit passed successfully");, +        } else {, +            throw new IllegalStateException(, +                "Audit of third party dependencies failed:\n" +, +                    (missingText.isEmpty() ?  "" : "Missing classes:\n" + missingText) +, +                    (violationsText.isEmpty() ? "" : "Classes with violations:\n" + violationsText), +            );, +    private void assertNoPointlessExclusions(Set<String> missingClasses, Set<String> violationsClasses, Set<String> jdkJarHellClasses) {, +        // keep our whitelist up to date, +        Set<String> bogusExclusions = new TreeSet<>(excludes);, +        bogusExclusions.removeAll(missingClasses);, +        bogusExclusions.removeAll(jdkJarHellClasses);, +        bogusExclusions.removeAll(violationsClasses);, +        if (bogusExclusions.isEmpty() == false) {, +            throw new IllegalStateException(, +                "Invalid exclusions, nothing is wrong with these classes: " + formatClassList(bogusExclusions), +            );, +        }, +    private String formatClassList(Set<String> classList) {, +        return classList.stream(), +            .map(name -> "  * " + name), +            .collect(Collectors.joining("\n"));, +    }, +, +++ b/benchmarks/build.gradle, +thirdPartyAudit.excludes = [, +], +++ b/build.gradle, +final boolean bwc_tests_enabled = true, +final String bwc_tests_disabled_issue = "" /* place a PR link here when committing bwc changes */, +  throw new GradleException('You must run `gradle idea` from the root of elasticsearch before importing into IntelliJ'), +++ b/buildSrc/src/main/java/org/elasticsearch/gradle/precommit/ThirdPartyAuditTask.java, +    /**, +     * patterns for classes to exclude, because we understand their issues, +     */, +    private Set<String> excludes = new TreeSet<>();, +    public void setExcludes(String... classes) {, +        excludes.clear();, +            if (each.indexOf('*') != -1) {, +                throw new IllegalArgumentException("illegal third party audit exclusion: '" + each + "', wildcards are not permitted!");, +            }, +            excludes.add(each);, +    public Set<String> getExcludes() {, +        return Collections.unmodifiableSet(excludes);, +        try {, +            assertNoPointlessExclusions(missingClasses, violationsClasses, jdkJarHellClasses);, +            assertNoMissingAndViolations(missingClasses, violationsClasses);, +        } catch (IllegalStateException e) {, +            getLogger().error(forbiddenApisOutput);, +            throw e;, +        jdkJarHellClasses.removeAll(excludes);, +    private void assertNoMissingAndViolations(Set<String> missingClasses, Set<String> violationsClasses) {, +        missingClasses.removeAll(excludes);, +        violationsClasses.removeAll(excludes);, +        String missingText = formatClassList(missingClasses);, +        String violationsText = formatClassList(violationsClasses);, +        if (missingText.isEmpty() && violationsText.isEmpty()) {]