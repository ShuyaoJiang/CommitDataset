[+++ b/src/main/java/org/elasticsearch/index/analysis/NumericDateAnalyzer.java, +import com.carrotsearch.hppc.IntObjectOpenHashMap;, +import com.google.common.collect.Maps;, +import org.elasticsearch.common.joda.FormatDateTimeFormatter;, +import org.elasticsearch.common.util.concurrent.ConcurrentCollections;, +import org.elasticsearch.common.util.concurrent.ConcurrentMapLong;, +import java.util.Map;, +import java.util.concurrent.ConcurrentMap;, +    private static final Map<String, IntObjectOpenHashMap<NamedAnalyzer>> globalAnalyzers = Maps.newHashMap();, +    public static synchronized NamedAnalyzer buildNamedAnalyzer(FormatDateTimeFormatter formatter, int precisionStep) {, +        IntObjectOpenHashMap<NamedAnalyzer> precisionMap = globalAnalyzers.get(formatter.format());, +        if (precisionMap == null) {, +            precisionMap = new IntObjectOpenHashMap<>();, +            globalAnalyzers.put(formatter.format(), precisionMap);, +        }, +        NamedAnalyzer namedAnalyzer = precisionMap.get(precisionStep);, +        if (namedAnalyzer == null) {, +            String name = "_date/" + ((precisionStep == Integer.MAX_VALUE) ? "max" : precisionStep);, +            namedAnalyzer = new NamedAnalyzer(name, AnalyzerScope.GLOBAL, new NumericDateAnalyzer(precisionStep, formatter.parser()));, +            precisionMap.put(precisionStep, namedAnalyzer);, +        }, +        return namedAnalyzer;, +    }, +, +    private final int precisionStep;, +++ b/src/main/java/org/elasticsearch/index/analysis/NumericDateAnalyzer.java, +import com.carrotsearch.hppc.IntObjectOpenHashMap;, +import com.google.common.collect.Maps;, +import org.elasticsearch.common.joda.FormatDateTimeFormatter;, +import org.elasticsearch.common.util.concurrent.ConcurrentCollections;, +import org.elasticsearch.common.util.concurrent.ConcurrentMapLong;, +import java.util.Map;, +import java.util.concurrent.ConcurrentMap;, +    private static final Map<String, IntObjectOpenHashMap<NamedAnalyzer>> globalAnalyzers = Maps.newHashMap();, +    public static synchronized NamedAnalyzer buildNamedAnalyzer(FormatDateTimeFormatter formatter, int precisionStep) {, +        IntObjectOpenHashMap<NamedAnalyzer> precisionMap = globalAnalyzers.get(formatter.format());, +        if (precisionMap == null) {, +            precisionMap = new IntObjectOpenHashMap<>();, +            globalAnalyzers.put(formatter.format(), precisionMap);, +        }, +        NamedAnalyzer namedAnalyzer = precisionMap.get(precisionStep);, +        if (namedAnalyzer == null) {, +            String name = "_date/" + ((precisionStep == Integer.MAX_VALUE) ? "max" : precisionStep);, +            namedAnalyzer = new NamedAnalyzer(name, AnalyzerScope.GLOBAL, new NumericDateAnalyzer(precisionStep, formatter.parser()));, +            precisionMap.put(precisionStep, namedAnalyzer);, +        }, +        return namedAnalyzer;, +    }, +, +    private final int precisionStep;, +++ b/src/main/java/org/elasticsearch/index/mapper/core/DateFieldMapper.java, +        super(names, precisionStep, boost, fieldType, docValues, ignoreMalformed, coerce, NumericDateAnalyzer.buildNamedAnalyzer(dateTimeFormatter, precisionStep),, +                NumericDateAnalyzer.buildNamedAnalyzer(dateTimeFormatter, Integer.MAX_VALUE),, +++ b/src/main/java/org/elasticsearch/index/analysis/NumericDateAnalyzer.java, +import com.carrotsearch.hppc.IntObjectOpenHashMap;, +import com.google.common.collect.Maps;, +import org.elasticsearch.common.joda.FormatDateTimeFormatter;, +import org.elasticsearch.common.util.concurrent.ConcurrentCollections;, +import org.elasticsearch.common.util.concurrent.ConcurrentMapLong;, +import java.util.Map;, +import java.util.concurrent.ConcurrentMap;, +    private static final Map<String, IntObjectOpenHashMap<NamedAnalyzer>> globalAnalyzers = Maps.newHashMap();, +    public static synchronized NamedAnalyzer buildNamedAnalyzer(FormatDateTimeFormatter formatter, int precisionStep) {, +        IntObjectOpenHashMap<NamedAnalyzer> precisionMap = globalAnalyzers.get(formatter.format());, +        if (precisionMap == null) {, +            precisionMap = new IntObjectOpenHashMap<>();, +            globalAnalyzers.put(formatter.format(), precisionMap);, +        }, +        NamedAnalyzer namedAnalyzer = precisionMap.get(precisionStep);, +        if (namedAnalyzer == null) {, +            String name = "_date/" + ((precisionStep == Integer.MAX_VALUE) ? "max" : precisionStep);, +            namedAnalyzer = new NamedAnalyzer(name, AnalyzerScope.GLOBAL, new NumericDateAnalyzer(precisionStep, formatter.parser()));, +            precisionMap.put(precisionStep, namedAnalyzer);, +        }, +        return namedAnalyzer;, +    }, +, +    private final int precisionStep;, +++ b/src/main/java/org/elasticsearch/index/mapper/core/DateFieldMapper.java, +        super(names, precisionStep, boost, fieldType, docValues, ignoreMalformed, coerce, NumericDateAnalyzer.buildNamedAnalyzer(dateTimeFormatter, precisionStep),, +                NumericDateAnalyzer.buildNamedAnalyzer(dateTimeFormatter, Integer.MAX_VALUE),, +++ b/src/test/java/org/elasticsearch/benchmark/mapping/ManyMappingsBenchmark.java, +    private static final boolean TWO_NODES = true;]