[+++ b/core/src/main/java/org/elasticsearch/index/analysis/AnalysisService.java, +            if (analyzerF instanceof NamedAnalyzer) {, +                analyzer = new NamedAnalyzer(analyzerFactory.name(), analyzerFactory.scope(), analyzerF);, +++ b/core/src/main/java/org/elasticsearch/index/analysis/AnalysisService.java, +            if (analyzerF instanceof NamedAnalyzer) {, +                analyzer = new NamedAnalyzer(analyzerFactory.name(), analyzerFactory.scope(), analyzerF);, +++ b/core/src/main/java/org/elasticsearch/index/analysis/CustomAnalyzerProvider.java, +        int positionOffsetGap = analyzerSettings.getAsInt("position_offset_gap", 0);, +++ b/core/src/main/java/org/elasticsearch/index/analysis/AnalysisService.java, +            if (analyzerF instanceof NamedAnalyzer) {, +                analyzer = new NamedAnalyzer(analyzerFactory.name(), analyzerFactory.scope(), analyzerF);, +++ b/core/src/main/java/org/elasticsearch/index/analysis/CustomAnalyzerProvider.java, +        int positionOffsetGap = analyzerSettings.getAsInt("position_offset_gap", 0);, +++ b/core/src/main/java/org/elasticsearch/index/mapper/core/StringFieldMapper.java, +        public static final int POSITION_OFFSET_GAP = 0;, +        protected int positionOffsetGap = Defaults.POSITION_OFFSET_GAP;, +            if (positionOffsetGap > 0) {, +                    builder.positionOffsetGap(XContentMapValues.nodeIntegerValue(propNode, -1));, +        if (includeDefaults || positionOffsetGap != Defaults.POSITION_OFFSET_GAP) {, +++ b/core/src/main/java/org/elasticsearch/index/analysis/AnalysisService.java, +            if (analyzerF instanceof NamedAnalyzer) {, +                analyzer = new NamedAnalyzer(analyzerFactory.name(), analyzerFactory.scope(), analyzerF);, +++ b/core/src/main/java/org/elasticsearch/index/analysis/CustomAnalyzerProvider.java, +        int positionOffsetGap = analyzerSettings.getAsInt("position_offset_gap", 0);, +++ b/core/src/main/java/org/elasticsearch/index/mapper/core/StringFieldMapper.java, +        public static final int POSITION_OFFSET_GAP = 0;, +        protected int positionOffsetGap = Defaults.POSITION_OFFSET_GAP;, +            if (positionOffsetGap > 0) {, +                    builder.positionOffsetGap(XContentMapValues.nodeIntegerValue(propNode, -1));, +        if (includeDefaults || positionOffsetGap != Defaults.POSITION_OFFSET_GAP) {, +++ b/core/src/test/java/org/elasticsearch/bwcompat/OldIndexBackwardsCompatibilityIT.java, +++ b/core/src/main/java/org/elasticsearch/index/analysis/AnalysisService.java, +            if (analyzerF instanceof NamedAnalyzer) {, +                analyzer = new NamedAnalyzer(analyzerFactory.name(), analyzerFactory.scope(), analyzerF);, +++ b/core/src/main/java/org/elasticsearch/index/analysis/CustomAnalyzerProvider.java, +        int positionOffsetGap = analyzerSettings.getAsInt("position_offset_gap", 0);, +++ b/core/src/main/java/org/elasticsearch/index/mapper/core/StringFieldMapper.java, +        public static final int POSITION_OFFSET_GAP = 0;, +        protected int positionOffsetGap = Defaults.POSITION_OFFSET_GAP;, +            if (positionOffsetGap > 0) {, +                    builder.positionOffsetGap(XContentMapValues.nodeIntegerValue(propNode, -1));, +        if (includeDefaults || positionOffsetGap != Defaults.POSITION_OFFSET_GAP) {, +++ b/core/src/test/java/org/elasticsearch/bwcompat/OldIndexBackwardsCompatibilityIT.java, +++ /dev/null, +++ b/core/src/main/java/org/elasticsearch/index/analysis/AnalysisService.java, +            if (analyzerF instanceof NamedAnalyzer) {, +                analyzer = new NamedAnalyzer(analyzerFactory.name(), analyzerFactory.scope(), analyzerF);, +++ b/core/src/main/java/org/elasticsearch/index/analysis/CustomAnalyzerProvider.java, +        int positionOffsetGap = analyzerSettings.getAsInt("position_offset_gap", 0);, +++ b/core/src/main/java/org/elasticsearch/index/mapper/core/StringFieldMapper.java, +        public static final int POSITION_OFFSET_GAP = 0;, +        protected int positionOffsetGap = Defaults.POSITION_OFFSET_GAP;, +            if (positionOffsetGap > 0) {, +                    builder.positionOffsetGap(XContentMapValues.nodeIntegerValue(propNode, -1));, +        if (includeDefaults || positionOffsetGap != Defaults.POSITION_OFFSET_GAP) {, +++ b/core/src/test/java/org/elasticsearch/bwcompat/OldIndexBackwardsCompatibilityIT.java, +++ /dev/null, +++ b/distribution/src/main/resources/bin/elasticsearch, +# full hostname passed through cut for portability on systems that do not support hostname -s, +# export on separate line for shells that do not support combining definition and export, +HOSTNAME=`hostname | cut -d. -f1`, +export HOSTNAME, +++ b/core/src/main/java/org/elasticsearch/index/analysis/AnalysisService.java, +            if (analyzerF instanceof NamedAnalyzer) {, +                analyzer = new NamedAnalyzer(analyzerFactory.name(), analyzerFactory.scope(), analyzerF);, +++ b/core/src/main/java/org/elasticsearch/index/analysis/CustomAnalyzerProvider.java, +        int positionOffsetGap = analyzerSettings.getAsInt("position_offset_gap", 0);, +++ b/core/src/main/java/org/elasticsearch/index/mapper/core/StringFieldMapper.java, +        public static final int POSITION_OFFSET_GAP = 0;, +        protected int positionOffsetGap = Defaults.POSITION_OFFSET_GAP;, +            if (positionOffsetGap > 0) {, +                    builder.positionOffsetGap(XContentMapValues.nodeIntegerValue(propNode, -1));, +        if (includeDefaults || positionOffsetGap != Defaults.POSITION_OFFSET_GAP) {, +++ b/core/src/test/java/org/elasticsearch/bwcompat/OldIndexBackwardsCompatibilityIT.java, +++ /dev/null, +++ b/distribution/src/main/resources/bin/elasticsearch, +# full hostname passed through cut for portability on systems that do not support hostname -s, +# export on separate line for shells that do not support combining definition and export, +HOSTNAME=`hostname | cut -d. -f1`, +export HOSTNAME, +++ b/distribution/src/main/resources/bin/plugin, +# full hostname passed through cut for portability on systems that do not support hostname -s, +# export on separate line for shells that do not support combining definition and export, +HOSTNAME=`hostname | cut -d. -f1`, +export HOSTNAME, +++ b/core/src/main/java/org/elasticsearch/index/analysis/AnalysisService.java, +            if (analyzerF instanceof NamedAnalyzer) {, +                analyzer = new NamedAnalyzer(analyzerFactory.name(), analyzerFactory.scope(), analyzerF);, +++ b/core/src/main/java/org/elasticsearch/index/analysis/CustomAnalyzerProvider.java, +        int positionOffsetGap = analyzerSettings.getAsInt("position_offset_gap", 0);, +++ b/core/src/main/java/org/elasticsearch/index/mapper/core/StringFieldMapper.java, +        public static final int POSITION_OFFSET_GAP = 0;, +        protected int positionOffsetGap = Defaults.POSITION_OFFSET_GAP;, +            if (positionOffsetGap > 0) {, +                    builder.positionOffsetGap(XContentMapValues.nodeIntegerValue(propNode, -1));, +        if (includeDefaults || positionOffsetGap != Defaults.POSITION_OFFSET_GAP) {, +++ b/core/src/test/java/org/elasticsearch/bwcompat/OldIndexBackwardsCompatibilityIT.java, +++ /dev/null, +++ b/distribution/src/main/resources/bin/elasticsearch, +# full hostname passed through cut for portability on systems that do not support hostname -s]