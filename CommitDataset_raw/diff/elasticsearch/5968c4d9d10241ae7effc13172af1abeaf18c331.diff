[+++ b/buildSrc/build.gradle, +  outputs.file(tempPropertiesFile), +++ b/buildSrc/build.gradle, +  outputs.file(tempPropertiesFile), +++ b/buildSrc/src/main/groovy/org/elasticsearch/gradle/precommit/JarHellTask.groovy, +    File successMarker = new File(project.buildDir, 'markers/jarHell'), +            FileCollection classpath = project.sourceSets.test.runtimeClasspath, +            inputs.files(classpath), +++ b/buildSrc/build.gradle, +  outputs.file(tempPropertiesFile), +++ b/buildSrc/src/main/groovy/org/elasticsearch/gradle/precommit/JarHellTask.groovy, +    File successMarker = new File(project.buildDir, 'markers/jarHell'), +            FileCollection classpath = project.sourceSets.test.runtimeClasspath, +            inputs.files(classpath), +++ b/buildSrc/src/main/groovy/org/elasticsearch/gradle/precommit/LicenseHeadersTask.groovy, +import org.gradle.api.file.FileCollection, +import org.gradle.api.tasks.OutputFile, +    @OutputFile, +    File reportFile = new File(project.buildDir, 'reports/licenseHeaders/rat.log'), +, +    private List<FileCollection> javaFiles, +, +        // Delay resolving the dependencies until after evaluation so we pick up generated sources, +        project.afterEvaluate {, +            List<FileCollection> javaFiles = project.sourceSets.collect({it.allJava}), +            setJavaFiles(javaFiles), +            inputs.files(javaFiles), +        }, +    }, +, +    /**, +     * Set the source sets this task processes. Should only be used by the afterEvaluate closure, +     * in the constructor., +     */, +    protected void setJavaFiles(List<FileCollection> javaFiles) {, +        this.javaFiles = javaFiles, +        List<FileCollection> input = javaFiles, +               for (FileCollection dirSet : input) {, +                   for (File dir: dirSet.srcDirs) {, +++ b/buildSrc/build.gradle, +  outputs.file(tempPropertiesFile), +++ b/buildSrc/src/main/groovy/org/elasticsearch/gradle/precommit/JarHellTask.groovy, +    File successMarker = new File(project.buildDir, 'markers/jarHell'), +            FileCollection classpath = project.sourceSets.test.runtimeClasspath, +            inputs.files(classpath), +++ b/buildSrc/src/main/groovy/org/elasticsearch/gradle/precommit/LicenseHeadersTask.groovy, +import org.gradle.api.file.FileCollection, +import org.gradle.api.tasks.OutputFile, +    @OutputFile, +    File reportFile = new File(project.buildDir, 'reports/licenseHeaders/rat.log'), +, +    private List<FileCollection> javaFiles, +, +        // Delay resolving the dependencies until after evaluation so we pick up generated sources, +        project.afterEvaluate {, +            List<FileCollection> javaFiles = project.sourceSets.collect({it.allJava}), +            setJavaFiles(javaFiles), +            inputs.files(javaFiles), +        }, +    }, +, +    /**, +     * Set the source sets this task processes. Should only be used by the afterEvaluate closure, +     * in the constructor., +     */, +    protected void setJavaFiles(List<FileCollection> javaFiles) {, +        this.javaFiles = javaFiles, +        List<FileCollection> input = javaFiles, +               for (FileCollection dirSet : input) {, +                   for (File dir: dirSet.srcDirs) {, +++ b/buildSrc/src/main/groovy/org/elasticsearch/gradle/precommit/ThirdPartyAuditTask.groovy, +import org.gradle.api.tasks.Input, +import org.gradle.api.tasks.InputFiles, +import org.gradle.api.tasks.OutputFile, +    private List<String> excludes = [];, +, +    /**, +     * Input for the task. Set javadoc for {#link getJars} for more., +     */, +    private FileCollection jars;, +, +    /**, +     * Classpath against which to run the third patty audit., +     */, +    private FileCollection classpath;, +, +    /**, +     * We use a simple "marker" file that we touch when the task succeeds, +     * as the task output. This is compared against the modified time of the, +     * inputs (ie the jars/class files)., +     */, +    @OutputFile, +    File successMarker = new File(project.buildDir, 'markers/thirdPartyAudit'), +, +, +        project.afterEvaluate {, +            Configuration configuration = project.configurations.findByName('runtime');, +            if (configuration == null) {, +                // some projects apparently do not have 'runtime'? what a nice inconsistency,, +                // basically only serves to waste time in build logic!]