[+++ b/x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/transport/nio/SSLDriver.java, +                        // If we need NEED_TASK we should run the tasks immediately, +                        if (handshakeStatus != SSLEngineResult.HandshakeStatus.NEED_TASK) {, +                        }, +            if (engine.isOutboundDone() || engine.isInboundDone()) {, +                // If the engine is partially closed, immediate transition to close mode., +                if (currentMode.isHandshake()) {, +                    currentMode = new CloseMode(true);, +                } else {, +                    String message = "Expected to be in handshaking mode. Instead in non-handshaking mode: " + currentMode;, +                    throw new AssertionError(message);, +                }, +            } else if (hasFlushPending() == false) {, +                // the peer might send an handshake error alert. If we attempt to receive the handshake alert,, +++ b/x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/transport/nio/SSLDriver.java, +                        // If we need NEED_TASK we should run the tasks immediately, +                        if (handshakeStatus != SSLEngineResult.HandshakeStatus.NEED_TASK) {, +                        }, +            if (engine.isOutboundDone() || engine.isInboundDone()) {, +                // If the engine is partially closed, immediate transition to close mode., +                if (currentMode.isHandshake()) {, +                    currentMode = new CloseMode(true);, +                } else {, +                    String message = "Expected to be in handshaking mode. Instead in non-handshaking mode: " + currentMode;, +                    throw new AssertionError(message);, +                }, +            } else if (hasFlushPending() == false) {, +                // the peer might send an handshake error alert. If we attempt to receive the handshake alert,, +++ b/x-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/transport/nio/SSLDriverTests.java, +        SSLEngine serverEngine = sslContext.createSSLEngine();, +        SSLEngine clientEngine = sslContext.createSSLEngine();, +, +        String[] serverProtocols = {"TLSv1.2"};, +        serverEngine.setEnabledProtocols(serverProtocols);, +        String[] clientProtocols = {"TLSv1.2"};, +        clientEngine.setEnabledProtocols(clientProtocols);, +        SSLDriver clientDriver = getDriver(clientEngine, true);, +        SSLDriver serverDriver = getDriver(serverEngine, false);, +        String[] serverProtocols = {"TLSv1.2"};, +        String[] clientProtocols = {"TLSv1.1"};, +        String oldExpected = "Client requested protocol TLSv1.1 not enabled or not supported";, +        String jdk11Expected = "Received fatal alert: protocol_version";, +        boolean expectedMessage = oldExpected.equals(sslException.getMessage()) || jdk11Expected.equals(sslException.getMessage());, +        assertTrue("Unexpected exception message: " + sslException.getMessage(), expectedMessage);, +, +        // In JDK11 we need an non-application write, +        if (serverDriver.needsNonApplicationWrite()) {, +            serverDriver.nonApplicationWrite();, +        }, +        // Prior to JDK11 we still need to send a close alert, +        if (serverDriver.isClosed() == false) {, +    }, +        expectThrows(SSLException.class, () -> handshake(clientDriver, serverDriver));, +        // In JDK11 we need an non-application write, +        if (serverDriver.needsNonApplicationWrite()) {, +            serverDriver.nonApplicationWrite();, +        }, +        // Prior to JDK11 we still need to send a close alert, +        if (serverDriver.isClosed() == false) {, +    }, +    @AwaitsFix(bugUrl = "https://github.com/elastic/elasticsearch/issues/32144")]