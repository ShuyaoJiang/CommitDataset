[+++ b/core/src/main/java/org/elasticsearch/search/aggregations/bucket/BestBucketsDeferringCollector.java, +                final long bucket = buckets.next();, +                final long rebasedBucket = hash.find(bucket);, +                if (rebasedBucket != -1) {, +++ b/core/src/main/java/org/elasticsearch/search/aggregations/bucket/BestBucketsDeferringCollector.java, +                final long bucket = buckets.next();, +                final long rebasedBucket = hash.find(bucket);, +                if (rebasedBucket != -1) {, +++ b/core/src/main/java/org/elasticsearch/search/aggregations/bucket/terms/TermsAggregationBuilder.java, +    private SubAggCollectionMode collectMode = null;, +        collectMode = in.readOptionalWriteable(SubAggCollectionMode::readFromStream);, +        out.writeOptionalWriteable(collectMode);, +        if (collectMode != null) {, +        }, +++ b/core/src/main/java/org/elasticsearch/search/aggregations/bucket/BestBucketsDeferringCollector.java, +                final long bucket = buckets.next();, +                final long rebasedBucket = hash.find(bucket);, +                if (rebasedBucket != -1) {, +++ b/core/src/main/java/org/elasticsearch/search/aggregations/bucket/terms/TermsAggregationBuilder.java, +    private SubAggCollectionMode collectMode = null;, +        collectMode = in.readOptionalWriteable(SubAggCollectionMode::readFromStream);, +        out.writeOptionalWriteable(collectMode);, +        if (collectMode != null) {, +        }, +++ b/core/src/main/java/org/elasticsearch/search/aggregations/bucket/terms/TermsAggregatorFactory.java, +            SubAggCollectionMode cm = collectMode;, +            if (cm == null) {, +                cm = SubAggCollectionMode.DEPTH_FIRST;, +                if (factories != AggregatorFactories.EMPTY) {, +                    cm = subAggCollectionMode(bucketCountThresholds.getShardSize(), maxOrd);, +                }, +            }, +, +                    cm, showTermDocCountError, pipelineAggregators, metaData);, +            SubAggCollectionMode cm = collectMode;, +            if (cm == null) {, +                if (factories != AggregatorFactories.EMPTY) {, +                    cm = subAggCollectionMode(bucketCountThresholds.getShardSize(), -1);, +                } else {, +                    cm = SubAggCollectionMode.DEPTH_FIRST;, +                }, +            }, +                        bucketCountThresholds, context, parent, cm, showTermDocCountError, longFilter,, +                    bucketCountThresholds, context, parent, cm, showTermDocCountError, longFilter, pipelineAggregators,, +    // return the SubAggCollectionMode that this aggregation should use based on the expected size, +    // and the cardinality of the field, +    static SubAggCollectionMode subAggCollectionMode(int expectedSize, long maxOrd) {, +        if (expectedSize == Integer.MAX_VALUE) {, +            // return all buckets, +            return SubAggCollectionMode.DEPTH_FIRST;, +        }, +        if (maxOrd == -1 || maxOrd > expectedSize) {, +            // use breadth_first if the cardinality is bigger than the expected size or unknown (-1), +            return SubAggCollectionMode.BREADTH_FIRST;, +        }, +        return SubAggCollectionMode.DEPTH_FIRST;, +    }, +, +++ b/core/src/main/java/org/elasticsearch/search/aggregations/bucket/BestBucketsDeferringCollector.java, +                final long bucket = buckets.next();, +                final long rebasedBucket = hash.find(bucket);, +                if (rebasedBucket != -1) {, +++ b/core/src/main/java/org/elasticsearch/search/aggregations/bucket/terms/TermsAggregationBuilder.java, +    private SubAggCollectionMode collectMode = null;, +        collectMode = in.readOptionalWriteable(SubAggCollectionMode::readFromStream);, +        out.writeOptionalWriteable(collectMode);, +        if (collectMode != null) {, +        }, +++ b/core/src/main/java/org/elasticsearch/search/aggregations/bucket/terms/TermsAggregatorFactory.java, +            SubAggCollectionMode cm = collectMode;, +            if (cm == null) {, +                cm = SubAggCollectionMode.DEPTH_FIRST;, +                if (factories != AggregatorFactories.EMPTY) {, +                    cm = subAggCollectionMode(bucketCountThresholds.getShardSize(), maxOrd);, +                }, +            }, +, +                    cm, showTermDocCountError, pipelineAggregators, metaData);, +            SubAggCollectionMode cm = collectMode;, +            if (cm == null) {, +                if (factories != AggregatorFactories.EMPTY) {, +                    cm = subAggCollectionMode(bucketCountThresholds.getShardSize(), -1);, +                } else {, +                    cm = SubAggCollectionMode.DEPTH_FIRST;, +                }, +            }, +                        bucketCountThresholds, context, parent, cm, showTermDocCountError, longFilter,, +                    bucketCountThresholds, context, parent, cm, showTermDocCountError, longFilter, pipelineAggregators,, +    // return the SubAggCollectionMode that this aggregation should use based on the expected size, +    // and the cardinality of the field, +    static SubAggCollectionMode subAggCollectionMode(int expectedSize, long maxOrd) {, +        if (expectedSize == Integer.MAX_VALUE) {, +            // return all buckets, +            return SubAggCollectionMode.DEPTH_FIRST;, +        }, +        if (maxOrd == -1 || maxOrd > expectedSize) {, +            // use breadth_first if the cardinality is bigger than the expected size or unknown (-1), +            return SubAggCollectionMode.BREADTH_FIRST;, +        }, +        return SubAggCollectionMode.DEPTH_FIRST;]