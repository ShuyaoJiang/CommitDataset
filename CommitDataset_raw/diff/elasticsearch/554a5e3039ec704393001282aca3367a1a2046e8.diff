[+++ b/core/src/main/java/org/elasticsearch/ElasticsearchException.java, +import org.elasticsearch.common.Nullable;, +import java.util.HashSet;, +import static java.util.Collections.emptyMap;, +import static java.util.Collections.singletonMap;, +     * Passed in the {@link Params} of {@link #generateThrowableXContent(XContentBuilder, Params, Throwable)}, +     * Passed in the {@link Params} of {@link #generateThrowableXContent(XContentBuilder, Params, Throwable)}, +    private static final boolean REST_EXCEPTION_SKIP_CAUSE_DEFAULT = false;, +    protected Map<String, List<String>> getHeaders() {, +        return headers;, +    }, +, +            generateThrowableXContent(builder, params, this);, +            innerToXContent(builder, params, this, getExceptionName(), getMessage(), headers, getCause());, +    protected static void innerToXContent(XContentBuilder builder, Params params,, +                                          Throwable throwable, String type, String message, Map<String, List<String>> headers,, +                                          Throwable cause) throws IOException {, +        builder.field(TYPE, type);, +        builder.field(REASON, message);, +        Set<String> customHeaders = new HashSet<>();, +                headerToXContent(builder, key.substring("es.".length()), headers.get(key));, +            } else {, +                customHeaders.add(key);, +, +        if (throwable instanceof ElasticsearchException) {, +            ElasticsearchException exception = (ElasticsearchException) throwable;, +            exception.metadataToXContent(builder, params);, +, +        if (params.paramAsBoolean(REST_EXCEPTION_SKIP_CAUSE, REST_EXCEPTION_SKIP_CAUSE_DEFAULT) == false) {, +            if (cause != null) {, +                builder.field(CAUSED_BY);, +                builder.startObject();, +                generateThrowableXContent(builder, params, cause);, +        if (customHeaders.isEmpty() == false) {, +            builder.startObject(HEADER);, +            for (String header : customHeaders) {, +                headerToXContent(builder, header, headers.get(header));, +            }, +            builder.endObject();, +        }, +, +        if (params.paramAsBoolean(REST_EXCEPTION_SKIP_STACK_TRACE, REST_EXCEPTION_SKIP_STACK_TRACE_DEFAULT) == false) {, +            builder.field(STACK_TRACE, ExceptionsHelper.stackTrace(throwable));, +        }, +    }, +, +    private static void headerToXContent(XContentBuilder builder, String key, List<String> values) throws IOException {, +     * Renders additional per exception information into the XContent, +    protected void metadataToXContent(XContentBuilder builder, Params params) throws IOException {, +    }, +, +    /**, +     * Static toXContent helper method that renders {@link org.elasticsearch.ElasticsearchException} or {@link Throwable} instances, +     * as XContent, delegating the rendering to {@link #toXContent(XContentBuilder, Params)}, +     * or {@link #innerToXContent(XContentBuilder, Params, Throwable, String, String, Map, Throwable)}., +     *, +     * This method is usually used when the {@link Throwable} is rendered as a part of another XContent object., +     */, +    public static void generateThrowableXContent(XContentBuilder builder, Params params, Throwable t) throws IOException {, +        t = ExceptionsHelper.unwrapCause(t);, +, +        if (t instanceof ElasticsearchException) {, +            ((ElasticsearchException) t).toXContent(builder, params);, +            innerToXContent(builder, params, t, getExceptionName(t), t.getMessage(), emptyMap(), t.getCause());, +        }, +    }, +, +    /**, +     * Render any exception as a xcontent, encapsulated within a field or object named "error". The level of details that are rendered, +     * depends on the value of the "detailed" parameter: when it's false only a simple message based on the type and message of the, +     * exception is rendered. When it's true all detail are provided including guesses root causes, cause and potentially stack, +     * trace., +     *, +     * This method is usually used when the {@link Exception} is rendered as a full XContent object., +     */, +    public static void generateFailureXContent(XContentBuilder builder, Params params, @Nullable Exception e, boolean detailed), +            throws IOException {, +        // No exception to render as an error, +        if (e == null) {, +            builder.field(ERROR, "unknown");, +            return;, +        }, +, +        // Render the exception with a simple message, +        if (detailed == false) {, +            String message = "No ElasticsearchException found";, +            Throwable t = e;, +            for (int counter = 0; counter < 10 && t != null; counter++) {, +                if (t instanceof ElasticsearchException) {, +                    message = t.getClass().getSimpleName() + "[" + t.getMessage() + "]";, +                    break;, +                }, +                t = t.getCause();, +            }, +            builder.field(ERROR, message);, +            return;, +        }, +, +        // Render the exception with all details, +        final ElasticsearchException[] rootCauses = ElasticsearchException.guessRootCauses(e);]