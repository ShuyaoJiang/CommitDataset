[+++ b/core/src/main/java/org/elasticsearch/transport/TcpTransport.java, +                if (Arrays.stream(nodeChannels.channels).allMatch(this::isOpen) == false) {, +                    throw new ConnectTransportException(node, "a channel closed while connecting");, +                }, +    /**, +     * Connect to the node with channels as defined by the specified connection profile. Implementations must invoke the specified channel, +     * close callback when a channel is closed., +     *, +     * @param node              the node to connect to, +     * @param connectionProfile the connection profile, +     * @param onChannelClose    callback to invoke when a channel is closed, +     * @return the channels, +     * @throws IOException if an I/O exception occurs while opening channels, +     */, +    protected abstract NodeChannels connectToChannels(DiscoveryNode node,, +                                                      ConnectionProfile connectionProfile,, +++ b/core/src/main/java/org/elasticsearch/transport/TcpTransport.java, +                if (Arrays.stream(nodeChannels.channels).allMatch(this::isOpen) == false) {, +                    throw new ConnectTransportException(node, "a channel closed while connecting");, +                }, +    /**, +     * Connect to the node with channels as defined by the specified connection profile. Implementations must invoke the specified channel, +     * close callback when a channel is closed., +     *, +     * @param node              the node to connect to, +     * @param connectionProfile the connection profile, +     * @param onChannelClose    callback to invoke when a channel is closed, +     * @return the channels, +     * @throws IOException if an I/O exception occurs while opening channels, +     */, +    protected abstract NodeChannels connectToChannels(DiscoveryNode node,, +                                                      ConnectionProfile connectionProfile,, +++ b/core/src/main/java/org/elasticsearch/transport/TransportService.java, +import java.util.concurrent.ExecutorService;, +    /**, +     * The executor service for this transport service., +     *, +     * @return the executor service, +     */, +    protected ExecutorService getExecutorService() {, +        return threadPool.generic();, +    }, +, +                    getExecutorService().execute(new AbstractRunnable() {, +        getExecutorService().execute(() -> listenersToNotify.forEach(listener -> listener.onNodeConnected(node)));, +        getExecutorService().execute(() -> listenersToNotify.forEach(listener -> listener.onConnectionOpened(connection)));, +            getExecutorService().execute( () -> {, +                        getExecutorService().execute(() -> holderToNotify.handler().handleException(new NodeDisconnectedException(, +++ b/core/src/main/java/org/elasticsearch/transport/TcpTransport.java, +                if (Arrays.stream(nodeChannels.channels).allMatch(this::isOpen) == false) {, +                    throw new ConnectTransportException(node, "a channel closed while connecting");, +                }, +    /**, +     * Connect to the node with channels as defined by the specified connection profile. Implementations must invoke the specified channel, +     * close callback when a channel is closed., +     *, +     * @param node              the node to connect to, +     * @param connectionProfile the connection profile, +     * @param onChannelClose    callback to invoke when a channel is closed, +     * @return the channels, +     * @throws IOException if an I/O exception occurs while opening channels, +     */, +    protected abstract NodeChannels connectToChannels(DiscoveryNode node,, +                                                      ConnectionProfile connectionProfile,, +++ b/core/src/main/java/org/elasticsearch/transport/TransportService.java, +import java.util.concurrent.ExecutorService;, +    /**, +     * The executor service for this transport service., +     *, +     * @return the executor service, +     */, +    protected ExecutorService getExecutorService() {, +        return threadPool.generic();, +    }, +, +                    getExecutorService().execute(new AbstractRunnable() {, +        getExecutorService().execute(() -> listenersToNotify.forEach(listener -> listener.onNodeConnected(node)));, +        getExecutorService().execute(() -> listenersToNotify.forEach(listener -> listener.onConnectionOpened(connection)));, +            getExecutorService().execute( () -> {, +                        getExecutorService().execute(() -> holderToNotify.handler().handleException(new NodeDisconnectedException(, +++ b/core/src/test/java/org/elasticsearch/transport/TCPTransportTests.java, +                protected NodeChannels connectToChannels(, +                        DiscoveryNode node, ConnectionProfile profile, Consumer onChannelClose) throws IOException {, +++ b/core/src/main/java/org/elasticsearch/transport/TcpTransport.java, +                if (Arrays.stream(nodeChannels.channels).allMatch(this::isOpen) == false) {, +                    throw new ConnectTransportException(node, "a channel closed while connecting");, +                }, +    /**, +     * Connect to the node with channels as defined by the specified connection profile. Implementations must invoke the specified channel, +     * close callback when a channel is closed., +     *, +     * @param node              the node to connect to, +     * @param connectionProfile the connection profile, +     * @param onChannelClose    callback to invoke when a channel is closed, +     * @return the channels, +     * @throws IOException if an I/O exception occurs while opening channels, +     */, +    protected abstract NodeChannels connectToChannels(DiscoveryNode node,, +                                                      ConnectionProfile connectionProfile,, +++ b/core/src/main/java/org/elasticsearch/transport/TransportService.java]