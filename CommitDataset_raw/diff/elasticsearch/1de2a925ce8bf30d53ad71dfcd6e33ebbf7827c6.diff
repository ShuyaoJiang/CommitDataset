[+++ b/test/framework/src/main/java/org/elasticsearch/test/rest/ESRestTestCase.java, +        if (name.startsWith(".watch") || name.startsWith(".triggered_watches")) {, +++ b/test/framework/src/main/java/org/elasticsearch/test/rest/ESRestTestCase.java, +        if (name.startsWith(".watch") || name.startsWith(".triggered_watches")) {, +++ b/x-pack/plugin/watcher/src/main/java/org/elasticsearch/xpack/watcher/WatcherService.java, +import org.elasticsearch.xpack.core.ClientHelper;, +        this.client = ClientHelper.clientWithOrigin(client, WATCHER_ORIGIN);, +        triggerService.pauseExecution();, +        int cancelledTaskCount = executionService.clearExecutionsAndQueue();, +        logger.info("reloading watcher, reason [{}], cancelled [{}] queued tasks", reason, cancelledTaskCount);, +, +        try {, +++ b/test/framework/src/main/java/org/elasticsearch/test/rest/ESRestTestCase.java, +        if (name.startsWith(".watch") || name.startsWith(".triggered_watches")) {, +++ b/x-pack/plugin/watcher/src/main/java/org/elasticsearch/xpack/watcher/WatcherService.java, +import org.elasticsearch.xpack.core.ClientHelper;, +        this.client = ClientHelper.clientWithOrigin(client, WATCHER_ORIGIN);, +        triggerService.pauseExecution();, +        int cancelledTaskCount = executionService.clearExecutionsAndQueue();, +        logger.info("reloading watcher, reason [{}], cancelled [{}] queued tasks", reason, cancelledTaskCount);, +, +        try {, +++ b/x-pack/plugin/watcher/src/main/java/org/elasticsearch/xpack/watcher/trigger/schedule/engine/TickerScheduleTriggerEngine.java, +import java.util.HashMap;, +        Map<String, ActiveSchedule> schedules = new HashMap<>(jobs.size());, +        // why are we calling putAll() here instead of assigning a brand, +        // new concurrent hash map you may ask yourself over here, +        // This requires some explanation how TriggerEngine.start() is, +        // invoked, when a reload due to the cluster state listener is done, +        // If the watches index does not exist, and new document is stored,, +        // then the creation of that index will trigger a reload which calls, +        // this method. The index operation however will run at the same time, +        // as the reload, so if we clean out the old data structure here,, +        // that can lead to that one watch not being triggered, +        this.schedules.putAll(schedules);, +++ b/test/framework/src/main/java/org/elasticsearch/test/rest/ESRestTestCase.java, +        if (name.startsWith(".watch") || name.startsWith(".triggered_watches")) {, +++ b/x-pack/plugin/watcher/src/main/java/org/elasticsearch/xpack/watcher/WatcherService.java, +import org.elasticsearch.xpack.core.ClientHelper;, +        this.client = ClientHelper.clientWithOrigin(client, WATCHER_ORIGIN);, +        triggerService.pauseExecution();, +        int cancelledTaskCount = executionService.clearExecutionsAndQueue();, +        logger.info("reloading watcher, reason [{}], cancelled [{}] queued tasks", reason, cancelledTaskCount);, +, +        try {, +++ b/x-pack/plugin/watcher/src/main/java/org/elasticsearch/xpack/watcher/trigger/schedule/engine/TickerScheduleTriggerEngine.java, +import java.util.HashMap;, +        Map<String, ActiveSchedule> schedules = new HashMap<>(jobs.size());, +        // why are we calling putAll() here instead of assigning a brand, +        // new concurrent hash map you may ask yourself over here, +        // This requires some explanation how TriggerEngine.start() is, +        // invoked, when a reload due to the cluster state listener is done, +        // If the watches index does not exist, and new document is stored,, +        // then the creation of that index will trigger a reload which calls, +        // this method. The index operation however will run at the same time, +        // as the reload, so if we clean out the old data structure here,, +        // that can lead to that one watch not being triggered, +        this.schedules.putAll(schedules);, +++ b/x-pack/plugin/watcher/src/test/java/org/elasticsearch/xpack/watcher/WatcherServiceTests.java, +import org.elasticsearch.action.ActionListener;, +import org.elasticsearch.action.admin.indices.refresh.RefreshAction;, +import org.elasticsearch.action.search.ClearScrollAction;, +import org.elasticsearch.action.search.SearchAction;, +import org.elasticsearch.action.search.SearchScrollAction;, +import org.junit.Before;, +import static org.mockito.Mockito.doAnswer;, +    private final Client client = mock(Client.class);, +, +    @Before, +    public void configureMockClient() {, +        when(client.settings()).thenReturn(Settings.EMPTY);, +        ThreadPool threadPool = mock(ThreadPool.class);, +        when(client.threadPool()).thenReturn(threadPool);, +        when(threadPool.getThreadContext()).thenReturn(new ThreadContext(Settings.EMPTY));, +    }, +, +                executionService, parser, client, executorService) {, +        WatcherService service = new WatcherService(Settings.EMPTY, triggerService, triggeredWatchStore,, +        doAnswer(invocation -> {, +            ActionListener<RefreshResponse> listener = (ActionListener<RefreshResponse>) invocation.getArguments()[2];, +            listener.onResponse(refreshResponse);, +            return null;, +        }).when(client).execute(eq(RefreshAction.INSTANCE), any(RefreshRequest.class), any(ActionListener.class));, +        doAnswer(invocation -> {, +            ActionListener<SearchResponse> listener = (ActionListener<SearchResponse>) invocation.getArguments()[2];, +            listener.onResponse(scrollSearchResponse);, +            return null;, +        }).when(client).execute(eq(SearchScrollAction.INSTANCE), any(SearchScrollRequest.class), any(ActionListener.class));, +        doAnswer(invocation -> {, +            ActionListener<SearchResponse> listener = (ActionListener<SearchResponse>) invocation.getArguments()[2];, +            listener.onResponse(searchResponse);, +            return null;, +        }).when(client).execute(eq(SearchAction.INSTANCE), any(SearchRequest.class), any(ActionListener.class));, +        doAnswer(invocation -> {, +            ActionListener<ClearScrollResponse> listener = (ActionListener<ClearScrollResponse>) invocation.getArguments()[2];, +            listener.onResponse(new ClearScrollResponse(true, 1));, +            return null;, +        }).when(client).execute(eq(ClearScrollAction.INSTANCE), any(ClearScrollRequest.class), any(ActionListener.class));, +            mock(ExecutionService.class), mock(WatchParser.class), client, executorService) {, +            executionService, mock(WatchParser.class), client, executorService) {]