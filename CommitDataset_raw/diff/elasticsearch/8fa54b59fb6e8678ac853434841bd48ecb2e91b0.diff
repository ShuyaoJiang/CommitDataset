[+++ b/src/test/java/org/elasticsearch/test/integration/percolator/TTLPercolatorTests.java, +import org.elasticsearch.action.admin.indices.stats.IndicesStatsResponse;, +        long waitTime = ttl + purgeInterval - timeSpent;, +        if (waitTime >= 0) {, +            Thread.sleep(waitTime); // Doesn't make sense to check the deleteCount before ttl has expired, +, +        // See comment in SimpleTTLTests, +        logger.info("Checking if the ttl purger has run");, +        long currentDeleteCount;, +        do {, +            if (rarely()) {, +                client.admin().indices().prepareFlush("test").setFull(true).execute().actionGet();, +            } else if (rarely()) {, +                client.admin().indices().prepareOptimize("test").setMaxNumSegments(1).execute().actionGet();, +            }, +            IndicesStatsResponse response = client.admin().indices().prepareStats("test"), +                    .clear().setIndexing(true), +                    .execute().actionGet();, +            currentDeleteCount = response.getIndices().get("test").getTotal().getIndexing().getTotal().getDeleteCount();, +        } while (currentDeleteCount < 2); // TTL deletes one doc, but it is indexed in the primary shard and replica shard., +        assertThat(currentDeleteCount, equalTo(2l));, +, +++ b/src/test/java/org/elasticsearch/test/integration/percolator/TTLPercolatorTests.java, +import org.elasticsearch.action.admin.indices.stats.IndicesStatsResponse;, +        long waitTime = ttl + purgeInterval - timeSpent;, +        if (waitTime >= 0) {, +            Thread.sleep(waitTime); // Doesn't make sense to check the deleteCount before ttl has expired, +, +        // See comment in SimpleTTLTests, +        logger.info("Checking if the ttl purger has run");, +        long currentDeleteCount;, +        do {, +            if (rarely()) {, +                client.admin().indices().prepareFlush("test").setFull(true).execute().actionGet();, +            } else if (rarely()) {, +                client.admin().indices().prepareOptimize("test").setMaxNumSegments(1).execute().actionGet();, +            }, +            IndicesStatsResponse response = client.admin().indices().prepareStats("test"), +                    .clear().setIndexing(true), +                    .execute().actionGet();, +            currentDeleteCount = response.getIndices().get("test").getTotal().getIndexing().getTotal().getDeleteCount();, +        } while (currentDeleteCount < 2); // TTL deletes one doc, but it is indexed in the primary shard and replica shard., +        assertThat(currentDeleteCount, equalTo(2l));, +, +++ b/src/test/java/org/elasticsearch/test/integration/ttl/SimpleTTLTests.java, +import org.elasticsearch.action.admin.indices.stats.IndicesStatsResponse;, +, +        // We can't assume that after waiting for ttl + purgeInterval (waitTime) that the document have actually been deleted., +        // The ttl purging happens in the background in a different thread, and might not have been completed after waiting for waitTime., +        // But we can use index statistics' delete count to be sure that deletes have been executed, that must be incremented before, +        // ttl purging has finished., +        logger.info("--> checking purger");, +        long currentDeleteCount;, +        do {, +            if (rarely()) {, +                client.admin().indices().prepareFlush("test").setFull(true).execute().actionGet();, +            } else if (rarely()) {, +                client.admin().indices().prepareOptimize("test").setMaxNumSegments(1).execute().actionGet();, +            }, +            IndicesStatsResponse response = client.admin().indices().prepareStats("test"), +                    .clear().setIndexing(true), +                    .execute().actionGet();, +            currentDeleteCount = response.getIndices().get("test").getTotal().getIndexing().getTotal().getDeleteCount();, +        } while (currentDeleteCount < 4); // TTL deletes two docs, but it is indexed in the primary shard and replica shard., +        assertThat(currentDeleteCount, equalTo(4l));, +]