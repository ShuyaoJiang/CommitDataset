[+++ b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/rollup/job/MetricConfig.java, +import org.elasticsearch.common.xcontent.ConstructingObjectParser;, +import org.elasticsearch.common.xcontent.ToXContentObject;, +import org.elasticsearch.common.xcontent.XContentParser;, +import static org.elasticsearch.common.xcontent.ConstructingObjectParser.constructorArg;, +, +public class MetricConfig implements Writeable, ToXContentObject {, +    private static final String NAME = "metrics";, +    private static final String FIELD = "field";, +    private static final String METRICS = "metrics";, +    private static final ConstructingObjectParser<MetricConfig, Void> PARSER;, +        PARSER = new ConstructingObjectParser<>(NAME, args -> {, +            @SuppressWarnings("unchecked") List<String> metrics = (List<String>) args[1];, +            return new MetricConfig((String) args[0], metrics);, +        });, +        PARSER.declareString(constructorArg(), new ParseField(FIELD));, +        PARSER.declareStringArray(constructorArg(), new ParseField(METRICS));, +    private final String field;, +    private final List<String> metrics;, +, +    public MetricConfig(final String field, final List<String> metrics) {, +        if (field == null || field.isEmpty()) {, +            throw new IllegalArgumentException("Field must be a non-null, non-empty string");, +        }, +        if (metrics == null || metrics.isEmpty()) {, +            throw new IllegalArgumentException("Metrics must be a non-null, non-empty array of strings");, +        }, +        metrics.forEach(m -> {, +            if (RollupField.SUPPORTED_METRICS.contains(m) == false) {, +                throw new IllegalArgumentException("Unsupported metric [" + m + "]. " +, +                    "Supported metrics include: " + RollupField.SUPPORTED_METRICS);, +            }, +        });, +        this.field = field;, +    MetricConfig(final StreamInput in) throws IOException {, +    /**, +     * @return the name of the field used in the metric configuration. Never {@code null}., +     */, +    /**, +     * @return the names of the metrics used in the metric configuration. Never {@code null}., +     */, +    public XContentBuilder toXContent(final XContentBuilder builder, final Params params) throws IOException {, +        builder.startObject();, +        {, +            builder.field(FIELD, field);, +            builder.field(METRICS, metrics);, +        }, +        return builder.endObject();, +    public boolean equals(final Object other) {, +        final MetricConfig that = (MetricConfig) other;, +        return Objects.equals(field, that.field) && Objects.equals(metrics, that.metrics);, +    public static MetricConfig fromXContent(final XContentParser parser) throws IOException {, +        return PARSER.parse(parser, null);, +++ b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/rollup/job/MetricConfig.java, +import org.elasticsearch.common.xcontent.ConstructingObjectParser;, +import org.elasticsearch.common.xcontent.ToXContentObject;, +import org.elasticsearch.common.xcontent.XContentParser;, +import static org.elasticsearch.common.xcontent.ConstructingObjectParser.constructorArg;, +, +public class MetricConfig implements Writeable, ToXContentObject {, +    private static final String NAME = "metrics";, +    private static final String FIELD = "field";, +    private static final String METRICS = "metrics";, +    private static final ConstructingObjectParser<MetricConfig, Void> PARSER;, +        PARSER = new ConstructingObjectParser<>(NAME, args -> {, +            @SuppressWarnings("unchecked") List<String> metrics = (List<String>) args[1];, +            return new MetricConfig((String) args[0], metrics);, +        });, +        PARSER.declareString(constructorArg(), new ParseField(FIELD));, +        PARSER.declareStringArray(constructorArg(), new ParseField(METRICS));, +    private final String field;, +    private final List<String> metrics;, +, +    public MetricConfig(final String field, final List<String> metrics) {, +        if (field == null || field.isEmpty()) {, +            throw new IllegalArgumentException("Field must be a non-null, non-empty string");, +        }, +        if (metrics == null || metrics.isEmpty()) {, +            throw new IllegalArgumentException("Metrics must be a non-null, non-empty array of strings");, +        }, +        metrics.forEach(m -> {, +            if (RollupField.SUPPORTED_METRICS.contains(m) == false) {, +                throw new IllegalArgumentException("Unsupported metric [" + m + "]. " +, +                    "Supported metrics include: " + RollupField.SUPPORTED_METRICS);, +            }, +        });, +        this.field = field;, +    MetricConfig(final StreamInput in) throws IOException {, +    /**, +     * @return the name of the field used in the metric configuration. Never {@code null}., +     */, +    /**, +     * @return the names of the metrics used in the metric configuration. Never {@code null}., +     */, +    public XContentBuilder toXContent(final XContentBuilder builder, final Params params) throws IOException {, +        builder.startObject();, +        {, +            builder.field(FIELD, field);, +            builder.field(METRICS, metrics);, +        }]