[+++ b/modules/rank-eval/src/main/java/org/elasticsearch/index/rankeval/DiscountedCumulativeGainAt.java, +import java.util.stream.Collectors;, +import static org.elasticsearch.index.rankeval.RankedListQualityMetric.filterUnknownDocuments;, +import static org.elasticsearch.index.rankeval.RankedListQualityMetric.joinHitsWithRatings;, +, +public class DiscountedCumulativeGainAt implements RankedListQualityMetric {, +        List<Integer> allRatings = ratedDocs.stream().mapToInt(RatedDocument::getRating).boxed().collect(Collectors.toList());, +        List<RatedSearchHit> ratedHits = joinHitsWithRatings(hits, ratedDocs);, +        List<Integer> ratingsInSearchHits = new ArrayList<>(Math.min(ratedHits.size(), position));, +        for (RatedSearchHit hit : ratedHits.subList(0, position)) {, +            // unknownDocRating might be null, which means it will be unrated docs are ignored in the dcg calculation, +            // we still need to add them as a placeholder so the rank of the subsequent ratings is correct, +            ratingsInSearchHits.add(hit.getRating().orElse(unknownDocRating));, +            double idcg = computeDCG(allRatings.subList(0, Math.min(ratingsInSearchHits.size(), allRatings.size())));, +        EvalQueryQuality evalQueryQuality = new EvalQueryQuality(taskId, dcg);, +        evalQueryQuality.addHitsAndRatings(ratedHits);, +        evalQueryQuality.setUnknownDocs(filterUnknownDocuments(ratedHits));, +++ b/modules/rank-eval/src/main/java/org/elasticsearch/index/rankeval/DiscountedCumulativeGainAt.java, +import java.util.stream.Collectors;, +import static org.elasticsearch.index.rankeval.RankedListQualityMetric.filterUnknownDocuments;, +import static org.elasticsearch.index.rankeval.RankedListQualityMetric.joinHitsWithRatings;, +, +public class DiscountedCumulativeGainAt implements RankedListQualityMetric {, +        List<Integer> allRatings = ratedDocs.stream().mapToInt(RatedDocument::getRating).boxed().collect(Collectors.toList());, +        List<RatedSearchHit> ratedHits = joinHitsWithRatings(hits, ratedDocs);, +        List<Integer> ratingsInSearchHits = new ArrayList<>(Math.min(ratedHits.size(), position));, +        for (RatedSearchHit hit : ratedHits.subList(0, position)) {, +            // unknownDocRating might be null, which means it will be unrated docs are ignored in the dcg calculation, +            // we still need to add them as a placeholder so the rank of the subsequent ratings is correct, +            ratingsInSearchHits.add(hit.getRating().orElse(unknownDocRating));, +            double idcg = computeDCG(allRatings.subList(0, Math.min(ratingsInSearchHits.size(), allRatings.size())));, +        EvalQueryQuality evalQueryQuality = new EvalQueryQuality(taskId, dcg);, +        evalQueryQuality.addHitsAndRatings(ratedHits);, +        evalQueryQuality.setUnknownDocs(filterUnknownDocuments(ratedHits));, +++ b/modules/rank-eval/src/main/java/org/elasticsearch/index/rankeval/DocumentKey.java, +/*, + * Licensed to Elasticsearch under one or more contributor, + * license agreements. See the NOTICE file distributed with, + * this work for additional information regarding copyright, + * ownership. Elasticsearch licenses this file to you under, + * the Apache License, Version 2.0 (the "License"); you may, + * not use this file except in compliance with the License., + * You may obtain a copy of the License at, + *, + *    http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing,, + * software distributed under the License is distributed on an, + * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY, + * KIND, either express or implied.  See the License for the, + * specific language governing permissions and limitations, + * under the License., + */, +, +package org.elasticsearch.index.rankeval;, +, +import org.elasticsearch.action.support.ToXContentToBytes;, +import org.elasticsearch.common.io.stream.StreamInput;, +import org.elasticsearch.common.io.stream.StreamOutput;, +import org.elasticsearch.common.io.stream.Writeable;, +import org.elasticsearch.common.xcontent.XContentBuilder;, +, +import java.io.IOException;, +import java.util.Objects;, +, +public class DocumentKey extends ToXContentToBytes implements Writeable {, +, +    private String docId;, +    private String type;, +    private String index;, +, +    void setIndex(String index) {, +        this.index = index;, +    }, +, +    void setType(String type) {, +        this.type = type;, +    }, +, +    void setDocId(String docId) {, +        this.docId = docId;, +    }, +, +    public DocumentKey(String index, String type, String docId) {, +        this.index = index;, +        this.type = type;, +        this.docId = docId;, +    }, +, +    public DocumentKey(StreamInput in) throws IOException {, +        this.index = in.readString();, +        this.type = in.readString();, +        this.docId = in.readString();, +    }, +, +    public String getIndex() {, +        return index;, +    }, +, +    public String getType() {]