[+++ b/src/main/java/org/elasticsearch/index/engine/internal/InternalEngine.java, +        try {, +            // we are either dirty due to a document added or due to a, +            // finished merge - either way we should refresh, +            return dirty || !searcherManager.isSearcherCurrent();, +        } catch (IOException e) {, +            logger.error("failed to access searcher manager", e);, +            failEngine(e);, +            throw new EngineException(shardId, "failed to access searcher manager",e);, +        }, +                    if (refreshNeeded() || refresh.force()) {, +        if (!possibleMergeNeeded()) {, +++ b/src/main/java/org/elasticsearch/index/engine/internal/InternalEngine.java, +        try {, +            // we are either dirty due to a document added or due to a, +            // finished merge - either way we should refresh, +            return dirty || !searcherManager.isSearcherCurrent();, +        } catch (IOException e) {, +            logger.error("failed to access searcher manager", e);, +            failEngine(e);, +            throw new EngineException(shardId, "failed to access searcher manager",e);, +        }, +                    if (refreshNeeded() || refresh.force()) {, +        if (!possibleMergeNeeded()) {, +++ b/src/main/java/org/elasticsearch/index/merge/policy/LogByteSizeMergePolicyProvider.java, +    public static final String MAX_MERGE_BYTE_SIZE_KEY = "index.merge.policy.max_merge_sizes";, +    public static final String MIN_MERGE_BYTE_SIZE_KEY = "index.merge.policy.min_merge_size";, +    public static final String MERGE_FACTORY_KEY = "index.merge.policy.merge_factor";, +        logger.debug("using [log_bytes_size] merge policy with merge_factor[{}], min_merge_size[{}], max_merge_size[{}], max_merge_docs[{}], calibrate_size_by_deletes[{}]",, +                mergeFactor, minMergeSize, maxMergeSize, maxMergeDocs, calibrateSizeByDeletes);, +        final CustomLogByteSizeMergePolicy  mergePolicy = new CustomLogByteSizeMergePolicy(this);, +++ b/src/main/java/org/elasticsearch/index/engine/internal/InternalEngine.java, +        try {, +            // we are either dirty due to a document added or due to a, +            // finished merge - either way we should refresh, +            return dirty || !searcherManager.isSearcherCurrent();, +        } catch (IOException e) {, +            logger.error("failed to access searcher manager", e);, +            failEngine(e);, +            throw new EngineException(shardId, "failed to access searcher manager",e);, +        }, +                    if (refreshNeeded() || refresh.force()) {, +        if (!possibleMergeNeeded()) {, +++ b/src/main/java/org/elasticsearch/index/merge/policy/LogByteSizeMergePolicyProvider.java, +    public static final String MAX_MERGE_BYTE_SIZE_KEY = "index.merge.policy.max_merge_sizes";, +    public static final String MIN_MERGE_BYTE_SIZE_KEY = "index.merge.policy.min_merge_size";, +    public static final String MERGE_FACTORY_KEY = "index.merge.policy.merge_factor";, +        logger.debug("using [log_bytes_size] merge policy with merge_factor[{}], min_merge_size[{}], max_merge_size[{}], max_merge_docs[{}], calibrate_size_by_deletes[{}]",, +                mergeFactor, minMergeSize, maxMergeSize, maxMergeDocs, calibrateSizeByDeletes);, +        final CustomLogByteSizeMergePolicy  mergePolicy = new CustomLogByteSizeMergePolicy(this);, +++ b/src/main/java/org/elasticsearch/index/merge/policy/LogDocMergePolicyProvider.java, +    public static final String MAX_MERGE_DOCS_KEY = "index.merge.policy.max_merge_docs";, +    public static final String MIN_MERGE_DOCS_KEY = "index.merge.policy.min_merge_docs";, +    public static final String MERGE_FACTORY_KEY = "index.merge.policy.merge_factor";, +        logger.debug("using [log_doc] merge policy with merge_factor[{}], min_merge_docs[{}], max_merge_docs[{}], calibrate_size_by_deletes[{}]",, +                mergeFactor, minMergeDocs, maxMergeDocs, calibrateSizeByDeletes);, +        final CustomLogDocMergePolicy mergePolicy = new CustomLogDocMergePolicy(this);, +++ b/src/main/java/org/elasticsearch/index/engine/internal/InternalEngine.java, +        try {, +            // we are either dirty due to a document added or due to a, +            // finished merge - either way we should refresh, +            return dirty || !searcherManager.isSearcherCurrent();, +        } catch (IOException e) {, +            logger.error("failed to access searcher manager", e);, +            failEngine(e);, +            throw new EngineException(shardId, "failed to access searcher manager",e);, +        }, +                    if (refreshNeeded() || refresh.force()) {, +        if (!possibleMergeNeeded()) {, +++ b/src/main/java/org/elasticsearch/index/merge/policy/LogByteSizeMergePolicyProvider.java, +    public static final String MAX_MERGE_BYTE_SIZE_KEY = "index.merge.policy.max_merge_sizes";, +    public static final String MIN_MERGE_BYTE_SIZE_KEY = "index.merge.policy.min_merge_size";, +    public static final String MERGE_FACTORY_KEY = "index.merge.policy.merge_factor";, +        logger.debug("using [log_bytes_size] merge policy with merge_factor[{}], min_merge_size[{}], max_merge_size[{}], max_merge_docs[{}], calibrate_size_by_deletes[{}]",, +                mergeFactor, minMergeSize, maxMergeSize, maxMergeDocs, calibrateSizeByDeletes);, +        final CustomLogByteSizeMergePolicy  mergePolicy = new CustomLogByteSizeMergePolicy(this);, +++ b/src/main/java/org/elasticsearch/index/merge/policy/LogDocMergePolicyProvider.java, +    public static final String MAX_MERGE_DOCS_KEY = "index.merge.policy.max_merge_docs";, +    public static final String MIN_MERGE_DOCS_KEY = "index.merge.policy.min_merge_docs";, +    public static final String MERGE_FACTORY_KEY = "index.merge.policy.merge_factor";, +        logger.debug("using [log_doc] merge policy with merge_factor[{}], min_merge_docs[{}], max_merge_docs[{}], calibrate_size_by_deletes[{}]",, +                mergeFactor, minMergeDocs, maxMergeDocs, calibrateSizeByDeletes);, +        final CustomLogDocMergePolicy mergePolicy = new CustomLogDocMergePolicy(this);, +++ b/src/main/java/org/elasticsearch/index/merge/policy/TieredMergePolicyProvider.java, +        logger.debug("using [tiered] merge policy with expunge_deletes_allowed[{}], floor_segment[{}], max_merge_at_once[{}], max_merge_at_once_explicit[{}], max_merged_segment[{}], segments_per_tier[{}], reclaim_deletes_weight[{}]",, +                forceMergeDeletesPctAllowed, floorSegment, maxMergeAtOnce, maxMergeAtOnceExplicit, maxMergedSegment, segmentsPerTier, reclaimDeletesWeight);, +        final CustomTieredMergePolicyProvider mergePolicy = new CustomTieredMergePolicyProvider(this);, +++ b/src/main/java/org/elasticsearch/index/engine/internal/InternalEngine.java, +        try {, +            // we are either dirty due to a document added or due to a, +            // finished merge - either way we should refresh, +            return dirty || !searcherManager.isSearcherCurrent();, +        } catch (IOException e) {, +            logger.error("failed to access searcher manager", e);, +            failEngine(e);, +            throw new EngineException(shardId, "failed to access searcher manager",e);, +        }, +                    if (refreshNeeded() || refresh.force()) {, +        if (!possibleMergeNeeded()) {, +++ b/src/main/java/org/elasticsearch/index/merge/policy/LogByteSizeMergePolicyProvider.java]