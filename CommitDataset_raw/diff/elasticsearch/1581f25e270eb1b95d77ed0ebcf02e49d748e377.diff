[+++ b/src/main/java/org/elasticsearch/cluster/service/InternalClusterService.java, +                    logger.debug("publishing cluster state version {}", newClusterState.version());, +                logger.debug("set local cluster state to version {}", newClusterState.version());, +++ b/src/main/java/org/elasticsearch/cluster/service/InternalClusterService.java, +                    logger.debug("publishing cluster state version {}", newClusterState.version());, +                logger.debug("set local cluster state to version {}", newClusterState.version());, +++ b/src/main/java/org/elasticsearch/discovery/local/LocalDiscovery.java, +import org.elasticsearch.common.unit.TimeValue;, +import java.util.concurrent.CountDownLatch;, +import java.util.concurrent.TimeUnit;, +    private final TimeValue publishTimeout;, +, +, +        this.publishTimeout = settings.getAsTime("discovery.zen.publish_timeout", TimeValue.timeValueSeconds(5));, +            LocalDiscovery[] members = clusterGroup.members().toArray(new LocalDiscovery[0]);, +            final CountDownLatch latch = new CountDownLatch(members.length);, +            for (LocalDiscovery discovery : members) {, +                    latch.countDown();, +                            latch.countDown();, +                            latch.countDown();, +                } else {, +                    latch.countDown();, +, +            if (publishTimeout.millis() > 0) {, +                try {, +                    boolean awaited = latch.await(publishTimeout.millis(), TimeUnit.MILLISECONDS);, +                    if (!awaited) {, +                        logger.debug("awaiting all nodes to process published state {} timed out, timeout {}", clusterState.version(), publishTimeout);, +                    }, +                } catch (InterruptedException e) {, +                    // ignore & restore interrupt, +                    Thread.currentThread().interrupt();, +                }, +            }, +, +, +++ b/src/main/java/org/elasticsearch/cluster/service/InternalClusterService.java, +                    logger.debug("publishing cluster state version {}", newClusterState.version());, +                logger.debug("set local cluster state to version {}", newClusterState.version());, +++ b/src/main/java/org/elasticsearch/discovery/local/LocalDiscovery.java, +import org.elasticsearch.common.unit.TimeValue;, +import java.util.concurrent.CountDownLatch;, +import java.util.concurrent.TimeUnit;, +    private final TimeValue publishTimeout;, +, +, +        this.publishTimeout = settings.getAsTime("discovery.zen.publish_timeout", TimeValue.timeValueSeconds(5));, +            LocalDiscovery[] members = clusterGroup.members().toArray(new LocalDiscovery[0]);, +            final CountDownLatch latch = new CountDownLatch(members.length);, +            for (LocalDiscovery discovery : members) {, +                    latch.countDown();, +                            latch.countDown();, +                            latch.countDown();, +                } else {, +                    latch.countDown();, +, +            if (publishTimeout.millis() > 0) {, +                try {, +                    boolean awaited = latch.await(publishTimeout.millis(), TimeUnit.MILLISECONDS);, +                    if (!awaited) {, +                        logger.debug("awaiting all nodes to process published state {} timed out, timeout {}", clusterState.version(), publishTimeout);, +                    }, +                } catch (InterruptedException e) {, +                    // ignore & restore interrupt, +                    Thread.currentThread().interrupt();, +                }, +            }, +, +, +++ b/src/main/java/org/elasticsearch/discovery/zen/ZenDiscovery.java, +    void handleNewClusterStateFromMaster(final ClusterState newState, final PublishClusterStateAction.NewClusterStateListener.NewStateProcessed newStateProcessed) {, +            clusterService.submitStateUpdateTask("zen-disco-master_receive_cluster_state_from_another_master [" + newState.nodes().masterNode() + "]", Priority.URGENT, new ProcessedClusterStateUpdateTask() {, +                public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {, +                    newStateProcessed.onNewClusterStateProcessed();, +                }, +, +                @Override, +                    newStateProcessed.onNewClusterStateFailed(t);, +                newStateProcessed.onNewClusterStateFailed(new ElasticSearchIllegalStateException("received state from a node that is not part of the cluster"));, +                        newStateProcessed.onNewClusterStateFailed(t);, +                        newStateProcessed.onNewClusterStateProcessed();, +, +        public void onNewClusterState(ClusterState clusterState, NewStateProcessed newStateProcessed) {, +            handleNewClusterStateFromMaster(clusterState, newStateProcessed);, +++ b/src/main/java/org/elasticsearch/cluster/service/InternalClusterService.java, +                    logger.debug("publishing cluster state version {}", newClusterState.version());, +                logger.debug("set local cluster state to version {}", newClusterState.version());, +++ b/src/main/java/org/elasticsearch/discovery/local/LocalDiscovery.java, +import org.elasticsearch.common.unit.TimeValue;, +import java.util.concurrent.CountDownLatch;, +import java.util.concurrent.TimeUnit;, +    private final TimeValue publishTimeout;, +, +, +        this.publishTimeout = settings.getAsTime("discovery.zen.publish_timeout", TimeValue.timeValueSeconds(5));, +            LocalDiscovery[] members = clusterGroup.members().toArray(new LocalDiscovery[0]);, +            final CountDownLatch latch = new CountDownLatch(members.length);, +            for (LocalDiscovery discovery : members) {, +                    latch.countDown();, +                            latch.countDown();]