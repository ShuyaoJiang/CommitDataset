[+++ b/src/main/java/org/elasticsearch/index/fielddata/fieldcomparator/BytesRefOrdValComparator.java, +            final int res = Long.compare(ords[slot1], ords[slot2]);, +            assert Integer.signum(res) == Integer.signum(compareValues(values[slot1], values[slot2])) : values[slot1] + " " + values[slot2] + " " + ords[slot1] + " " + ords[slot2];, +            return res;, +        return compareValues(val1, val2);, +            readerGen[slot] = currentReaderGen;, +++ b/src/main/java/org/elasticsearch/index/fielddata/fieldcomparator/BytesRefOrdValComparator.java, +            final int res = Long.compare(ords[slot1], ords[slot2]);, +            assert Integer.signum(res) == Integer.signum(compareValues(values[slot1], values[slot2])) : values[slot1] + " " + values[slot2] + " " + ords[slot1] + " " + ords[slot2];, +            return res;, +        return compareValues(val1, val2);, +            readerGen[slot] = currentReaderGen;, +++ b/src/test/java/org/elasticsearch/index/fielddata/NoOrdinalsStringFieldDataTests.java, +import org.elasticsearch.search.MultiValueMode;, +    public static IndexFieldData<AtomicFieldData<ScriptDocValues>> hideOrdinals(final IndexFieldData<?> in) {, +    @SuppressWarnings("unchecked"), +    @Override, +    public IndexFieldData<AtomicFieldData<ScriptDocValues>> getForField(String fieldName) {, +        return hideOrdinals(super.getForField(fieldName));, +    }, +, +++ b/src/main/java/org/elasticsearch/index/fielddata/fieldcomparator/BytesRefOrdValComparator.java, +            final int res = Long.compare(ords[slot1], ords[slot2]);, +            assert Integer.signum(res) == Integer.signum(compareValues(values[slot1], values[slot2])) : values[slot1] + " " + values[slot2] + " " + ords[slot1] + " " + ords[slot2];, +            return res;, +        return compareValues(val1, val2);, +            readerGen[slot] = currentReaderGen;, +++ b/src/test/java/org/elasticsearch/index/fielddata/NoOrdinalsStringFieldDataTests.java, +import org.elasticsearch.search.MultiValueMode;, +    public static IndexFieldData<AtomicFieldData<ScriptDocValues>> hideOrdinals(final IndexFieldData<?> in) {, +    @SuppressWarnings("unchecked"), +    @Override, +    public IndexFieldData<AtomicFieldData<ScriptDocValues>> getForField(String fieldName) {, +        return hideOrdinals(super.getForField(fieldName));, +    }, +, +++ b/src/test/java/org/elasticsearch/index/search/nested/NestedSortingTests.java, +import org.apache.lucene.util.TestUtil;, +import org.elasticsearch.index.fielddata.*;, +import org.elasticsearch.index.fielddata.IndexFieldData.XFieldComparatorSource;, +import org.elasticsearch.search.MultiValueMode;, +import java.io.IOException;, +    public void testDuel() throws Exception {, +        final int numDocs = scaledRandomIntBetween(100, 1000);, +        for (int i = 0; i < numDocs; ++i) {, +            final int numChildren = randomInt(2);, +            List<Document> docs = new ArrayList<>(numChildren + 1);, +            for (int j = 0; j < numChildren; ++j) {, +                Document doc = new Document();, +                doc.add(new StringField("f", TestUtil.randomSimpleString(getRandom(), 2), Field.Store.NO));, +                doc.add(new StringField("__type", "child", Field.Store.NO));, +                docs.add(doc);, +            }, +            if (randomBoolean()) {, +                docs.add(new Document());, +            }, +            Document parent = new Document();, +            parent.add(new StringField("__type", "parent", Field.Store.NO));, +            docs.add(parent);, +            writer.addDocuments(docs);, +            if (rarely()) { // we need to have a bit more segments than what RandomIndexWriter would do by default, +                DirectoryReader.open(writer, false).close();, +            }, +        }, +        writer.commit();, +, +        MultiValueMode sortMode = randomFrom(Arrays.asList(MultiValueMode.MIN, MultiValueMode.MAX));, +        IndexSearcher searcher = new IndexSearcher(DirectoryReader.open(writer, false));, +        PagedBytesIndexFieldData indexFieldData1 = getForField("f");, +        IndexFieldData<?> indexFieldData2 = NoOrdinalsStringFieldDataTests.hideOrdinals(indexFieldData1);, +        final String missingValue = randomBoolean() ? null : TestUtil.randomSimpleString(getRandom(), 2);, +        final int n = randomIntBetween(1, numDocs + 2);, +        final boolean reverse = randomBoolean();, +, +        final TopDocs topDocs1 = getTopDocs(searcher, indexFieldData1, missingValue, sortMode, n, reverse);, +        final TopDocs topDocs2 = getTopDocs(searcher, indexFieldData2, missingValue, sortMode, n, reverse);, +        for (int i = 0; i < topDocs1.scoreDocs.length; ++i) {, +            final FieldDoc fieldDoc1 = (FieldDoc) topDocs1.scoreDocs[i];, +            final FieldDoc fieldDoc2 = (FieldDoc) topDocs2.scoreDocs[i];, +            assertEquals(fieldDoc1.doc, fieldDoc2.doc);, +            assertArrayEquals(fieldDoc1.fields, fieldDoc2.fields);, +        }, +, +        searcher.getIndexReader().close();, +    }, +, +    private TopDocs getTopDocs(IndexSearcher searcher, IndexFieldData<?> indexFieldData, String missingValue, MultiValueMode sortMode, int n, boolean reverse) throws IOException {, +        Filter parentFilter = new TermFilter(new Term("__type", "parent"));, +        Filter childFilter = new TermFilter(new Term("__type", "child"));, +        XFieldComparatorSource innerSource = indexFieldData.comparatorSource(missingValue, sortMode);, +        NestedFieldComparatorSource nestedComparatorSource = new NestedFieldComparatorSource(sortMode, innerSource, parentFilter, childFilter);, +        Query query = new ConstantScoreQuery(parentFilter);, +        Sort sort = new Sort(new SortField("f", nestedComparatorSource, reverse));, +        return searcher.search(query, n, sort);, +    }, +, +    @Test]