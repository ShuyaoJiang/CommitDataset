[+++ b/core/src/main/java/org/elasticsearch/index/translog/Translog.java, +            assert versionType.validateVersionForWrites(this.version) : "invalid version for writes: " + this.version;, +                seqNo = in.readLong();, +                primaryTerm = in.readLong();, +            out.writeLong(seqNo);, +            out.writeLong(primaryTerm);, +++ b/core/src/main/java/org/elasticsearch/index/translog/Translog.java, +            assert versionType.validateVersionForWrites(this.version) : "invalid version for writes: " + this.version;, +                seqNo = in.readLong();, +                primaryTerm = in.readLong();, +            out.writeLong(seqNo);, +            out.writeLong(primaryTerm);, +++ b/core/src/test/java/org/elasticsearch/index/translog/TranslogTests.java, +import org.apache.lucene.document.Field;, +import org.apache.lucene.document.NumericDocValuesField;, +import org.apache.lucene.document.TextField;, +import org.elasticsearch.Version;, +import org.elasticsearch.index.engine.Engine;, +import org.elasticsearch.index.engine.Engine.Operation.Origin;, +import org.elasticsearch.index.mapper.ParseContext.Document;, +import org.elasticsearch.index.mapper.ParsedDocument;, +import org.elasticsearch.index.mapper.SeqNoFieldMapper;, +import org.elasticsearch.index.mapper.UidFieldMapper;, +import java.util.Arrays;, +            assertThat(stats.getTranslogSizeInBytes(), equalTo(139L));, +            assertThat(stats.getTranslogSizeInBytes(), equalTo(181L));, +            assertThat(stats.getTranslogSizeInBytes(), equalTo(223L));, +        final long expectedSizeInBytes = 266L;, +, +    public void testTranslogOpSerialization() throws Exception {, +        BytesReference B_1 = new BytesArray(new byte[]{1});, +        SeqNoFieldMapper.SequenceID seqID = SeqNoFieldMapper.SequenceID.emptySeqID();, +        assert Version.CURRENT.major <= 6 : "Using UNASSIGNED_SEQ_NO can be removed in 7.0, because 6.0+ nodes have actual sequence numbers";, +        long randomSeqNum = randomBoolean() ? SequenceNumbersService.UNASSIGNED_SEQ_NO : randomNonNegativeLong();, +        long randomPrimaryTerm = randomBoolean() ? 0 : randomNonNegativeLong();, +        seqID.seqNo.setLongValue(randomSeqNum);, +        seqID.seqNoDocValue.setLongValue(randomSeqNum);, +        seqID.primaryTerm.setLongValue(randomPrimaryTerm);, +        Field uidField = new Field("_uid", "1", UidFieldMapper.Defaults.FIELD_TYPE);, +        Field versionField = new NumericDocValuesField("_version", 1);, +        Document document = new Document();, +        document.add(new TextField("value", "test", Field.Store.YES));, +        document.add(uidField);, +        document.add(versionField);, +        document.add(seqID.seqNo);, +        document.add(seqID.seqNoDocValue);, +        document.add(seqID.primaryTerm);, +        ParsedDocument doc = new ParsedDocument(versionField, seqID, "1", "type", null, Arrays.asList(document), B_1, null);, +, +        Engine.Index eIndex = new Engine.Index(newUid("1"), doc, randomSeqNum, randomPrimaryTerm,, +                1, VersionType.INTERNAL, Origin.PRIMARY, 0, 0, false);, +        Engine.IndexResult eIndexResult = new Engine.IndexResult(1, randomSeqNum, true);, +        Translog.Index index = new Translog.Index(eIndex, eIndexResult);, +, +        BytesStreamOutput out = new BytesStreamOutput();, +        index.writeTo(out);, +        StreamInput in = out.bytes().streamInput();, +        Translog.Index serializedIndex = new Translog.Index(in);, +        assertEquals(index, serializedIndex);, +, +        Engine.Delete eDelete = new Engine.Delete("type", "1", newUid("1"), randomSeqNum, randomPrimaryTerm,, +                2, VersionType.INTERNAL, Origin.PRIMARY, 0);, +        Engine.DeleteResult eDeleteResult = new Engine.DeleteResult(2, randomSeqNum, true);, +        Translog.Delete delete = new Translog.Delete(eDelete, eDeleteResult);, +, +        out = new BytesStreamOutput();, +        delete.writeTo(out);, +        in = out.bytes().streamInput();, +        Translog.Delete serializedDelete = new Translog.Delete(in);, +        assertEquals(delete, serializedDelete);, +    }, +++ b/core/src/main/java/org/elasticsearch/index/translog/Translog.java, +            assert versionType.validateVersionForWrites(this.version) : "invalid version for writes: " + this.version;, +                seqNo = in.readLong();, +                primaryTerm = in.readLong();, +            out.writeLong(seqNo);, +            out.writeLong(primaryTerm);, +++ b/core/src/test/java/org/elasticsearch/index/translog/TranslogTests.java, +import org.apache.lucene.document.Field;, +import org.apache.lucene.document.NumericDocValuesField;, +import org.apache.lucene.document.TextField;, +import org.elasticsearch.Version;, +import org.elasticsearch.index.engine.Engine;, +import org.elasticsearch.index.engine.Engine.Operation.Origin;, +import org.elasticsearch.index.mapper.ParseContext.Document;, +import org.elasticsearch.index.mapper.ParsedDocument;, +import org.elasticsearch.index.mapper.SeqNoFieldMapper;, +import org.elasticsearch.index.mapper.UidFieldMapper;, +import java.util.Arrays;, +            assertThat(stats.getTranslogSizeInBytes(), equalTo(139L));, +            assertThat(stats.getTranslogSizeInBytes(), equalTo(181L));, +            assertThat(stats.getTranslogSizeInBytes(), equalTo(223L));, +        final long expectedSizeInBytes = 266L;, +, +    public void testTranslogOpSerialization() throws Exception {, +        BytesReference B_1 = new BytesArray(new byte[]{1});, +        SeqNoFieldMapper.SequenceID seqID = SeqNoFieldMapper.SequenceID.emptySeqID();, +        assert Version.CURRENT.major <= 6 : "Using UNASSIGNED_SEQ_NO can be removed in 7.0, because 6.0+ nodes have actual sequence numbers";, +        long randomSeqNum = randomBoolean() ? SequenceNumbersService.UNASSIGNED_SEQ_NO : randomNonNegativeLong();, +        long randomPrimaryTerm = randomBoolean() ? 0 : randomNonNegativeLong();]