[+++ b/server/src/main/java/org/elasticsearch/search/aggregations/bucket/histogram/AutoDateHistogramAggregationBuilder.java, +import org.joda.time.DateTimeZone;, +    private static final ParseField NUM_BUCKETS_FIELD = new ParseField("buckets");, +    /**, +     *, +     * Build roundings, computed dynamically as roundings are time zone dependent., +     * The current implementation probably should not be invoked in a tight loop., +     * @return Array of RoundingInfo, +     */, +    static RoundingInfo[] buildRoundings(DateTimeZone timeZone) {, +        RoundingInfo[] roundings = new RoundingInfo[6];, +        roundings[0] = new RoundingInfo(createRounding(DateTimeUnit.SECOND_OF_MINUTE, timeZone),, +            1000L, 1, 5, 10, 30);, +        roundings[1] = new RoundingInfo(createRounding(DateTimeUnit.MINUTES_OF_HOUR, timeZone),, +            60 * 1000L, 1, 5, 10, 30);, +        roundings[2] = new RoundingInfo(createRounding(DateTimeUnit.HOUR_OF_DAY, timeZone),, +            60 * 60 * 1000L, 1, 3, 12);, +        roundings[3] = new RoundingInfo(createRounding(DateTimeUnit.DAY_OF_MONTH, timeZone),, +            24 * 60 * 60 * 1000L, 1, 7);, +        roundings[4] = new RoundingInfo(createRounding(DateTimeUnit.MONTH_OF_YEAR, timeZone),, +            30 * 24 * 60 * 60 * 1000L, 1, 3);, +        roundings[5] = new RoundingInfo(createRounding(DateTimeUnit.YEAR_OF_CENTURY, timeZone),, +            365 * 24 * 60 * 60 * 1000L, 1, 5, 10, 20, 50, 100);, +        return roundings;, +    }, +, +        RoundingInfo[] roundings = buildRoundings(timeZone());, +    private static Rounding createRounding(DateTimeUnit interval, DateTimeZone timeZone) {, +        if (timeZone != null) {, +            tzRoundingBuilder.timeZone(timeZone);, +++ b/server/src/main/java/org/elasticsearch/search/aggregations/bucket/histogram/AutoDateHistogramAggregationBuilder.java, +import org.joda.time.DateTimeZone;, +    private static final ParseField NUM_BUCKETS_FIELD = new ParseField("buckets");, +    /**, +     *, +     * Build roundings, computed dynamically as roundings are time zone dependent., +     * The current implementation probably should not be invoked in a tight loop., +     * @return Array of RoundingInfo, +     */, +    static RoundingInfo[] buildRoundings(DateTimeZone timeZone) {, +        RoundingInfo[] roundings = new RoundingInfo[6];, +        roundings[0] = new RoundingInfo(createRounding(DateTimeUnit.SECOND_OF_MINUTE, timeZone),, +            1000L, 1, 5, 10, 30);, +        roundings[1] = new RoundingInfo(createRounding(DateTimeUnit.MINUTES_OF_HOUR, timeZone),, +            60 * 1000L, 1, 5, 10, 30);, +        roundings[2] = new RoundingInfo(createRounding(DateTimeUnit.HOUR_OF_DAY, timeZone),, +            60 * 60 * 1000L, 1, 3, 12);, +        roundings[3] = new RoundingInfo(createRounding(DateTimeUnit.DAY_OF_MONTH, timeZone),, +            24 * 60 * 60 * 1000L, 1, 7);, +        roundings[4] = new RoundingInfo(createRounding(DateTimeUnit.MONTH_OF_YEAR, timeZone),, +            30 * 24 * 60 * 60 * 1000L, 1, 3);, +        roundings[5] = new RoundingInfo(createRounding(DateTimeUnit.YEAR_OF_CENTURY, timeZone),, +            365 * 24 * 60 * 60 * 1000L, 1, 5, 10, 20, 50, 100);, +        return roundings;, +    }, +, +        RoundingInfo[] roundings = buildRoundings(timeZone());, +    private static Rounding createRounding(DateTimeUnit interval, DateTimeZone timeZone) {, +        if (timeZone != null) {, +            tzRoundingBuilder.timeZone(timeZone);, +++ b/server/src/main/java/org/elasticsearch/search/aggregations/bucket/histogram/InternalAutoDateHistogram.java, +    private int getAppropriateRounding(long minKey, long maxKey, int roundingIdx,, +                                              RoundingInfo[] roundings) {, +    private BucketReduceResult maybeMergeConsecutiveBuckets(BucketReduceResult reducedBucketsResult,, +                                                                   ReduceContext reduceContext) {, +            sameKeyedBuckets.add(new Bucket(Math.round(key), bucket.docCount, format, bucket.aggregations));, +++ b/server/src/main/java/org/elasticsearch/search/aggregations/bucket/histogram/AutoDateHistogramAggregationBuilder.java, +import org.joda.time.DateTimeZone;, +    private static final ParseField NUM_BUCKETS_FIELD = new ParseField("buckets");, +    /**, +     *, +     * Build roundings, computed dynamically as roundings are time zone dependent., +     * The current implementation probably should not be invoked in a tight loop., +     * @return Array of RoundingInfo, +     */, +    static RoundingInfo[] buildRoundings(DateTimeZone timeZone) {, +        RoundingInfo[] roundings = new RoundingInfo[6];, +        roundings[0] = new RoundingInfo(createRounding(DateTimeUnit.SECOND_OF_MINUTE, timeZone),, +            1000L, 1, 5, 10, 30);, +        roundings[1] = new RoundingInfo(createRounding(DateTimeUnit.MINUTES_OF_HOUR, timeZone),, +            60 * 1000L, 1, 5, 10, 30);, +        roundings[2] = new RoundingInfo(createRounding(DateTimeUnit.HOUR_OF_DAY, timeZone),, +            60 * 60 * 1000L, 1, 3, 12);, +        roundings[3] = new RoundingInfo(createRounding(DateTimeUnit.DAY_OF_MONTH, timeZone),, +            24 * 60 * 60 * 1000L, 1, 7);, +        roundings[4] = new RoundingInfo(createRounding(DateTimeUnit.MONTH_OF_YEAR, timeZone),, +            30 * 24 * 60 * 60 * 1000L, 1, 3);, +        roundings[5] = new RoundingInfo(createRounding(DateTimeUnit.YEAR_OF_CENTURY, timeZone),, +            365 * 24 * 60 * 60 * 1000L, 1, 5, 10, 20, 50, 100);, +        return roundings;, +    }, +, +        RoundingInfo[] roundings = buildRoundings(timeZone());, +    private static Rounding createRounding(DateTimeUnit interval, DateTimeZone timeZone) {, +        if (timeZone != null) {, +            tzRoundingBuilder.timeZone(timeZone);, +++ b/server/src/main/java/org/elasticsearch/search/aggregations/bucket/histogram/InternalAutoDateHistogram.java, +    private int getAppropriateRounding(long minKey, long maxKey, int roundingIdx,, +                                              RoundingInfo[] roundings) {, +    private BucketReduceResult maybeMergeConsecutiveBuckets(BucketReduceResult reducedBucketsResult,]