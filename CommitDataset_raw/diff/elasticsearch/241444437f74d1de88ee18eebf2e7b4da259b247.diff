[+++ b/src/main/java/org/elasticsearch/alerts/Alert.java, +import org.elasticsearch.common.io.stream.StreamInput;, +import org.elasticsearch.common.io.stream.StreamOutput;, +import org.elasticsearch.common.io.stream.Streamable;, +import static org.elasticsearch.alerts.support.AlertsDateUtils.*;, +    public Alert(String name, Schedule schedule, Trigger trigger, Payload payload, TimeValue throttlePeriod, AlertActions actions, Map<String, Object> metadata, Status status) {, +        throttler = new AlertThrottler(throttlePeriod);, +                throw new AlertsException("could not parse alert [" + name + "]", ioe);, +                        throw new AlertsSettingsException("could not parse alert [" + name + "] throttle period. could not parse token [" + token + "] as time value (must either be string or number)");, +                throw new AlertsSettingsException("could not parse alert [" + name + "]. missing alert schedule");, +                throw new AlertsSettingsException("could not parse alert [" + name + "]. missing alert trigger");, +                throw new AlertsSettingsException("could not parse alert [" + name + "]. missing alert actions");, +            return new Alert(name, schedule, trigger, payload, throttlePeriod, actions, metatdata, status);, +    public static class Status implements ToXContent, Streamable {, +        public static final ParseField TIMESTAMP_FIELD = new ParseField("last_throttled");, +        public static final ParseField ACK_FIELD = new ParseField("ack");, +        public static final ParseField LAST_THROTTLE_FIELD = new ParseField("last_throttle");, +        public static final ParseField REASON_FIELD = new ParseField("reason");, +        private Ack ack;, +        private Throttle lastThrottle;, +            this(-1, null, null, null, null, new Ack());, +        public Status(Status other) {, +            this(other.version, other.lastRan, other.lastTriggered, other.lastExecuted, other.lastThrottle, other.ack);, +        }, +, +        private Status(long version, DateTime lastRan, DateTime lastTriggered, DateTime lastExecuted, Throttle lastThrottle, Ack ack) {, +            this.lastThrottle = lastThrottle;, +            this.ack = ack;, +        public boolean ran() {, +            return lastRan != null;, +        }, +, +        public boolean triggered() {, +            return lastTriggered != null;, +        }, +, +        public boolean executed() {, +            return lastExecuted != null;, +        }, +, +        public Throttle lastThrottle() {, +            return lastThrottle;, +        public Ack ack() {, +            return ack;, +        public boolean acked() {, +            return ack.state == Ack.State.ACKED;, +        public void onRun(DateTime timestamp) {, +        public void onThrottle(DateTime timestamp, String reason) {, +            lastThrottle = new Throttle(timestamp, reason);, +         * if the alert is can be acked and during a run, the alert was not triggered and the current state is {@link Status.Ack.State#ACKED},, +         * we then need to reset the state to {@link Status.Ack.State#AWAITS_EXECUTION}, +        public void onTrigger(boolean triggered, DateTime timestamp) {, +            } else if (ack.state == Ack.State.ACKED) {, +                // didn't trigger now after it triggered in the past - we need to reset the ack state, +                ack = new Ack(Ack.State.AWAITS_EXECUTION, timestamp);, +         * Notifies this status that the alert was acked. If the current state is {@link Status.Ack.State#ACKABLE}, then we'll change it, +         * to {@link Status.Ack.State#ACKED} (when set to {@link Status.Ack.State#ACKED}, the {@link org.elasticsearch.alerts.throttle.AckThrottler} will lastThrottle the, +        public boolean onAck(DateTime timestamp) {, +            if (ack.state == Ack.State.ACKABLE) {, +                ack = new Ack(Ack.State.ACKED, timestamp);, +         * Notified this status that the alert was executed. If the current state is {@link Status.Ack.State#AWAITS_EXECUTION}, it will change to, +         * {@link Status.Ack.State#ACKABLE}., +        public void onExecution(DateTime timestamp) {, +            if (ack.state == Ack.State.AWAITS_EXECUTION) {, +                ack = new Ack(Ack.State.ACKABLE, timestamp);, +        public void writeTo(StreamOutput out) throws IOException {, +            out.writeLong(version);, +            writeOptionalDate(out, lastRan);, +            writeOptionalDate(out, lastTriggered);, +            writeOptionalDate(out, lastExecuted);, +            if (lastThrottle == null) {, +                out.writeBoolean(false);, +            } else {, +                out.writeBoolean(true);, +                writeDate(out, lastThrottle.timestamp);, +                out.writeString(lastThrottle.reason);, +            }, +            out.writeString(ack.state.name());, +            writeDate(out, ack.timestamp);, +        }, +, +        @Override, +        public void readFrom(StreamInput in) throws IOException {, +            version = in.readLong();, +            lastRan = readOptionalDate(in);, +            lastTriggered = readOptionalDate(in);, +            lastExecuted = readOptionalDate(in);, +            ack = new Ack(Ack.State.valueOf(in.readString()), readDate(in));, +            lastThrottle = in.readBoolean() ? new Throttle(readDate(in), in.readString()) : null;, +        }, +, +        public static Status read(StreamInput in) throws IOException {, +            Alert.Status status = new Alert.Status();, +            status.readFrom(in);, +            return status;, +        }, +, +        @Override, +            builder.startObject(ACK_FIELD.getPreferredName()), +                    .field(STATE_FIELD.getPreferredName(), ack.state.name().toLowerCase(Locale.ROOT))]