[+++ b/core/src/main/java/org/elasticsearch/index/shard/IndexShard.java, +import org.apache.lucene.index.CheckIndex;, +import org.apache.lucene.index.IndexCommit;, +import org.apache.lucene.index.KeepOnlyLastCommitDeletionPolicy;, +import org.apache.lucene.index.SnapshotDeletionPolicy;, +import org.elasticsearch.index.IndexSettings;, +import org.elasticsearch.index.store.Store.MetadataSnapshot;, +    public IndexShardState markAsRecovering(String reason, RecoveryState recoveryState) throws IndexShardStartedException,, +    public boolean recoverFromStore(DiscoveryNode localNode) {, +        assert shardRouting.primary() : "recover from store only makes sense if the shard is a primary shard";, +        final boolean shouldExist = shardRouting.allocatedPostIndexCreate();, +    public boolean restoreFromRepository(IndexShardRepository repository, DiscoveryNode locaNode) {, +        assert shardRouting.primary() : "recover from store only makes sense if the shard is a primary shard";, +++ b/core/src/main/java/org/elasticsearch/index/shard/IndexShard.java, +import org.apache.lucene.index.CheckIndex;, +import org.apache.lucene.index.IndexCommit;, +import org.apache.lucene.index.KeepOnlyLastCommitDeletionPolicy;, +import org.apache.lucene.index.SnapshotDeletionPolicy;, +import org.elasticsearch.index.IndexSettings;, +import org.elasticsearch.index.store.Store.MetadataSnapshot;, +    public IndexShardState markAsRecovering(String reason, RecoveryState recoveryState) throws IndexShardStartedException,, +    public boolean recoverFromStore(DiscoveryNode localNode) {, +        assert shardRouting.primary() : "recover from store only makes sense if the shard is a primary shard";, +        final boolean shouldExist = shardRouting.allocatedPostIndexCreate();, +    public boolean restoreFromRepository(IndexShardRepository repository, DiscoveryNode locaNode) {, +        assert shardRouting.primary() : "recover from store only makes sense if the shard is a primary shard";, +++ b/core/src/main/java/org/elasticsearch/index/shard/StoreRecovery.java, +++ b/core/src/main/java/org/elasticsearch/index/shard/IndexShard.java, +import org.apache.lucene.index.CheckIndex;, +import org.apache.lucene.index.IndexCommit;, +import org.apache.lucene.index.KeepOnlyLastCommitDeletionPolicy;, +import org.apache.lucene.index.SnapshotDeletionPolicy;, +import org.elasticsearch.index.IndexSettings;, +import org.elasticsearch.index.store.Store.MetadataSnapshot;, +    public IndexShardState markAsRecovering(String reason, RecoveryState recoveryState) throws IndexShardStartedException,, +    public boolean recoverFromStore(DiscoveryNode localNode) {, +        assert shardRouting.primary() : "recover from store only makes sense if the shard is a primary shard";, +        final boolean shouldExist = shardRouting.allocatedPostIndexCreate();, +    public boolean restoreFromRepository(IndexShardRepository repository, DiscoveryNode locaNode) {, +        assert shardRouting.primary() : "recover from store only makes sense if the shard is a primary shard";, +++ b/core/src/main/java/org/elasticsearch/index/shard/StoreRecovery.java, +++ b/core/src/main/java/org/elasticsearch/indices/cluster/IndicesClusterStateService.java, +        final RestoreSource restoreSource = shardRouting.restoreSource();, +, +                RecoveryState recoveryState = new RecoveryState(indexShard.shardId(), shardRouting.primary(), type, sourceNode, nodes.localNode());, +                indexShard.markAsRecovering("from " + sourceNode, recoveryState);, +        } else if (restoreSource == null) {, +            assert indexShard.routingEntry().equals(shardRouting); // should have already be done before, +            final RecoveryState recoveryState = new RecoveryState(indexShard.shardId(), shardRouting.primary(),, +                    RecoveryState.Type.STORE,, +                    nodes.localNode(), nodes.localNode());, +            indexShard.markAsRecovering("from store", recoveryState); // mark the shard as recovering on the cluster state thread, +            threadPool.generic().execute(() -> {, +                    if (indexShard.recoverFromStore(nodes.localNode())) {, +                } catch (Throwable t) {, +                    handleRecoveryFailure(indexService, shardRouting, true, t);, +                }, +, +            });, +        } else {, +            // recover from a restore, +            final RecoveryState recoveryState = new RecoveryState(indexShard.shardId(), shardRouting.primary(),, +                    RecoveryState.Type.SNAPSHOT, shardRouting.restoreSource(), nodes.localNode());, +            indexShard.markAsRecovering("from snapshot", recoveryState); // mark the shard as recovering on the cluster state thread, +            threadPool.generic().execute(() -> {, +                final ShardId sId = indexShard.shardId();, +                try {, +                    final IndexShardRepository indexShardRepository = repositoriesService.indexShardRepository(restoreSource.snapshotId().getRepository());, +                    if (indexShard.restoreFromRepository(indexShardRepository, nodes.localNode())) {, +                        restoreService.indexShardRestoreCompleted(restoreSource.snapshotId(), sId);, +                        shardStateAction.shardStarted(shardRouting, indexMetaData.getIndexUUID(), "after recovery from repository");, +                    }, +                } catch (Throwable first) {, +                    try {, +                        if (Lucene.isCorruptionException(first)) {, +                            restoreService.failRestore(restoreSource.snapshotId(), sId);, +                        }, +                    } catch (Throwable second) {, +                        first.addSuppressed(second);, +                    } finally {, +                        handleRecoveryFailure(indexService, shardRouting, true, first);, +                    }, +++ b/core/src/main/java/org/elasticsearch/index/shard/IndexShard.java, +import org.apache.lucene.index.CheckIndex;, +import org.apache.lucene.index.IndexCommit;, +import org.apache.lucene.index.KeepOnlyLastCommitDeletionPolicy;, +import org.apache.lucene.index.SnapshotDeletionPolicy;, +import org.elasticsearch.index.IndexSettings;, +import org.elasticsearch.index.store.Store.MetadataSnapshot;, +    public IndexShardState markAsRecovering(String reason, RecoveryState recoveryState) throws IndexShardStartedException,, +    public boolean recoverFromStore(DiscoveryNode localNode) {, +        assert shardRouting.primary() : "recover from store only makes sense if the shard is a primary shard";, +        final boolean shouldExist = shardRouting.allocatedPostIndexCreate();, +    public boolean restoreFromRepository(IndexShardRepository repository, DiscoveryNode locaNode) {, +        assert shardRouting.primary() : "recover from store only makes sense if the shard is a primary shard";, +++ b/core/src/main/java/org/elasticsearch/index/shard/StoreRecovery.java, +++ b/core/src/main/java/org/elasticsearch/indices/cluster/IndicesClusterStateService.java, +        final RestoreSource restoreSource = shardRouting.restoreSource();, +, +                RecoveryState recoveryState = new RecoveryState(indexShard.shardId(), shardRouting.primary(), type, sourceNode, nodes.localNode());]