[+++ b/docs/reference/migration/migrate_7_0/search.asciidoc, +, +==== Semantics changed for `max_concurrent_shard_requests`, +, +`max_concurrent_shard_requests` used to limit the total number of concurrent shard, +requests a single high level search request can execute. In 7.0 this changed to be the, +max number of concurrent shard requests per node. The default is now `5`., +++ b/docs/reference/migration/migrate_7_0/search.asciidoc, +, +==== Semantics changed for `max_concurrent_shard_requests`, +, +`max_concurrent_shard_requests` used to limit the total number of concurrent shard, +requests a single high level search request can execute. In 7.0 this changed to be the, +max number of concurrent shard requests per node. The default is now `5`., +++ b/rest-api-spec/src/main/resources/rest-api-spec/api/search.json, +          "description" : "The number of concurrent shard requests per node this search executes concurrently. This value should be used to limit the impact of the search on the cluster in order to limit the number of concurrent shard requests",, +          "default" : "The default is 5.", +++ b/docs/reference/migration/migrate_7_0/search.asciidoc, +, +==== Semantics changed for `max_concurrent_shard_requests`, +, +`max_concurrent_shard_requests` used to limit the total number of concurrent shard, +requests a single high level search request can execute. In 7.0 this changed to be the, +max number of concurrent shard requests per node. The default is now `5`., +++ b/rest-api-spec/src/main/resources/rest-api-spec/api/search.json, +          "description" : "The number of concurrent shard requests per node this search executes concurrently. This value should be used to limit the impact of the search on the cluster in order to limit the number of concurrent shard requests",, +          "default" : "The default is 5.", +++ b/server/src/main/java/org/elasticsearch/action/search/AbstractSearchAsyncAction.java, +                                        SearchTask task, SearchPhaseResults<Result> resultConsumer, int maxConcurrentRequestsPerNode,, +        super(name, request, shardsIts, logger, maxConcurrentRequestsPerNode, executor);, +++ b/docs/reference/migration/migrate_7_0/search.asciidoc, +, +==== Semantics changed for `max_concurrent_shard_requests`, +, +`max_concurrent_shard_requests` used to limit the total number of concurrent shard, +requests a single high level search request can execute. In 7.0 this changed to be the, +max number of concurrent shard requests per node. The default is now `5`., +++ b/rest-api-spec/src/main/resources/rest-api-spec/api/search.json, +          "description" : "The number of concurrent shard requests per node this search executes concurrently. This value should be used to limit the impact of the search on the cluster in order to limit the number of concurrent shard requests",, +          "default" : "The default is 5.", +++ b/server/src/main/java/org/elasticsearch/action/search/AbstractSearchAsyncAction.java, +                                        SearchTask task, SearchPhaseResults<Result> resultConsumer, int maxConcurrentRequestsPerNode,, +        super(name, request, shardsIts, logger, maxConcurrentRequestsPerNode, executor);, +++ b/server/src/main/java/org/elasticsearch/action/search/ExpandSearchPhase.java, +++ b/docs/reference/migration/migrate_7_0/search.asciidoc, +, +==== Semantics changed for `max_concurrent_shard_requests`, +, +`max_concurrent_shard_requests` used to limit the total number of concurrent shard, +requests a single high level search request can execute. In 7.0 this changed to be the, +max number of concurrent shard requests per node. The default is now `5`., +++ b/rest-api-spec/src/main/resources/rest-api-spec/api/search.json, +          "description" : "The number of concurrent shard requests per node this search executes concurrently. This value should be used to limit the impact of the search on the cluster in order to limit the number of concurrent shard requests",, +          "default" : "The default is 5.", +++ b/server/src/main/java/org/elasticsearch/action/search/AbstractSearchAsyncAction.java, +                                        SearchTask task, SearchPhaseResults<Result> resultConsumer, int maxConcurrentRequestsPerNode,, +        super(name, request, shardsIts, logger, maxConcurrentRequestsPerNode, executor);, +++ b/server/src/main/java/org/elasticsearch/action/search/ExpandSearchPhase.java, +++ b/server/src/main/java/org/elasticsearch/action/search/InitialSearchPhase.java, +import java.util.ArrayDeque;, +import java.util.Map;, +import java.util.concurrent.ConcurrentHashMap;, +    private final int maxConcurrentRequestsPerNode;, +    private final Map<String, PendingExecutions> pendingExecutionsPerNode = new ConcurrentHashMap<>();, +    private final boolean throttleConcurrentRequests;, +                       int maxConcurrentRequestsPerNode, Executor executor) {, +        this.maxConcurrentRequestsPerNode = Math.min(maxConcurrentRequestsPerNode, shardsIts.size());, +        // in the case were we have less shards than maxConcurrentRequestsPerNode we don't need to throttle, +        this.throttleConcurrentRequests = maxConcurrentRequestsPerNode < shardsIts.size();, +    public final void run() {, +            for (int index = 0; index < shardsIts.size(); index++) {, +    private static final class PendingExecutions {, +        private final int permits;, +        private int permitsTaken = 0;, +        private ArrayDeque<Runnable> queue = new ArrayDeque<>();, +, +        PendingExecutions(int permits) {, +            assert permits > 0 : "not enough permits: " + permits;, +            this.permits = permits;, +        }, +, +        void finishAndRunNext() {, +            synchronized (this) {, +                permitsTaken--;, +                assert permitsTaken >= 0 : "illegal taken permits: " + permitsTaken;, +            }, +            tryRun(null);, +        }, +, +        void tryRun(Runnable runnable) {, +            Runnable r = tryQueue(runnable);, +            if (r != null) {, +                r.run();, +            }, +        }, +, +        private synchronized Runnable tryQueue(Runnable runnable) {, +            Runnable toExecute = null;, +            if (permitsTaken < permits) {, +                permitsTaken++;]