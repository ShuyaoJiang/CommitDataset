[+++ b/core/src/main/java/org/elasticsearch/index/mapper/object/DynamicTemplate.java, +        String type;, +        if (mapping.containsKey("type")) {, +            type = mapping.get("type").toString();, +            type = type.replace("{dynamic_type}", dynamicType);, +            type = type.replace("{dynamicType}", dynamicType);, +        } else {, +            type = dynamicType;, +        }, +        if (type.equals(mapping.get("type")) == false // either the type was not set, or we updated it through replacements, +                && "text".equals(type)) { // and the result is "text", +            // now that string has been splitted into text and keyword, we use text for, +            // dynamic mappings. However before it used to be possible to index as a keyword, +            // by setting index=not_analyzed, so for now we will use a keyword field rather, +            // than a text field if index=not_analyzed and the field type was not specified, +            // explicitly, +            // TODO: remove this in 6.0, +            // TODO: how to do it in the future?, +            final Object index = mapping.get("index");, +            if ("not_analyzed".equals(index) || "no".equals(index)) {, +                type = "keyword";, +            }, +        }, +        return type;, +++ b/core/src/main/java/org/elasticsearch/index/mapper/object/DynamicTemplate.java, +        String type;, +        if (mapping.containsKey("type")) {, +            type = mapping.get("type").toString();, +            type = type.replace("{dynamic_type}", dynamicType);, +            type = type.replace("{dynamicType}", dynamicType);, +        } else {, +            type = dynamicType;, +        }, +        if (type.equals(mapping.get("type")) == false // either the type was not set, or we updated it through replacements, +                && "text".equals(type)) { // and the result is "text", +            // now that string has been splitted into text and keyword, we use text for, +            // dynamic mappings. However before it used to be possible to index as a keyword, +            // by setting index=not_analyzed, so for now we will use a keyword field rather, +            // than a text field if index=not_analyzed and the field type was not specified, +            // explicitly, +            // TODO: remove this in 6.0, +            // TODO: how to do it in the future?, +            final Object index = mapping.get("index");, +            if ("not_analyzed".equals(index) || "no".equals(index)) {, +                type = "keyword";, +            }, +        }, +        return type;, +++ b/core/src/test/java/org/elasticsearch/index/mapper/core/StringMappingUpgradeTests.java, +import org.elasticsearch.common.bytes.BytesReference;, +import org.elasticsearch.index.mapper.Mapper;, +import org.elasticsearch.index.mapper.ParsedDocument;, +, +    public void testUpgradeTemplateWithDynamicType() throws IOException {, +        IndexService indexService = createIndex("test");, +        DocumentMapperParser parser = indexService.mapperService().documentMapperParser();, +        String mapping = XContentFactory.jsonBuilder().startObject().startObject("type"), +                .startArray("dynamic_templates"), +                    .startObject(), +                        .startObject("my_template"), +                            .field("match_mapping_type", "string"), +                            .startObject("mapping"), +                                .field("store", true), +                            .endObject(), +                        .endObject(), +                    .endObject(), +                .endArray(), +                .endObject().endObject().string();, +        DocumentMapper mapper = parser.parse("type", new CompressedXContent(mapping));, +        BytesReference source = XContentFactory.jsonBuilder().startObject().field("foo", "bar").endObject().bytes();, +        ParsedDocument doc = mapper.parse("test", "type", "id", source);, +        Mapper fooMapper = doc.dynamicMappingsUpdate().root().getMapper("foo");, +        assertThat(fooMapper, instanceOf(TextFieldMapper.class));, +        assertTrue(((TextFieldMapper) fooMapper).fieldType().stored());, +    }, +, +    public void testUpgradeTemplateWithDynamicType2() throws IOException {, +        IndexService indexService = createIndex("test");, +        DocumentMapperParser parser = indexService.mapperService().documentMapperParser();, +        String mapping = XContentFactory.jsonBuilder().startObject().startObject("type"), +                .startArray("dynamic_templates"), +                    .startObject(), +                        .startObject("my_template"), +                            .field("match_mapping_type", "string"), +                            .startObject("mapping"), +                                .field("type", "{dynamic_type}"), +                                .field("store", true), +                            .endObject(), +                        .endObject(), +                    .endObject(), +                .endArray(), +                .endObject().endObject().string();, +        DocumentMapper mapper = parser.parse("type", new CompressedXContent(mapping));, +        BytesReference source = XContentFactory.jsonBuilder().startObject().field("foo", "bar").endObject().bytes();, +        ParsedDocument doc = mapper.parse("test", "type", "id", source);, +        Mapper fooMapper = doc.dynamicMappingsUpdate().root().getMapper("foo");, +        assertThat(fooMapper, instanceOf(TextFieldMapper.class));, +        assertTrue(((TextFieldMapper) fooMapper).fieldType().stored());, +    }, +]