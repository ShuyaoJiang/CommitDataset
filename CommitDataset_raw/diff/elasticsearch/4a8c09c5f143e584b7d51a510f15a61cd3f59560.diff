[+++ b/core/src/test/java/org/elasticsearch/VersionTests.java, +            if (field.getName().matches("_ID")) {, +                    if (v == Version.CURRENT) {, +                        // Current is weird - it counts as released even though it shouldn't., +                        continue;, +                    }, +                    assertFalse("Version " + maxBranchVersion + " cannot be a snapshot because version " + v + " exists",, +                            VersionUtils.allUnreleasedVersions().contains(maxBranchVersion));, +++ b/core/src/test/java/org/elasticsearch/VersionTests.java, +            if (field.getName().matches("_ID")) {, +                    if (v == Version.CURRENT) {, +                        // Current is weird - it counts as released even though it shouldn't., +                        continue;, +                    }, +                    assertFalse("Version " + maxBranchVersion + " cannot be a snapshot because version " + v + " exists",, +                            VersionUtils.allUnreleasedVersions().contains(maxBranchVersion));, +++ b/core/src/test/java/org/elasticsearch/bwcompat/OldIndexBackwardsCompatibilityIT.java, +            // The current version is in the "released" list even though it isn't released for historical reasons, +            if (v == Version.CURRENT) continue;, +++ b/core/src/test/java/org/elasticsearch/VersionTests.java, +            if (field.getName().matches("_ID")) {, +                    if (v == Version.CURRENT) {, +                        // Current is weird - it counts as released even though it shouldn't., +                        continue;, +                    }, +                    assertFalse("Version " + maxBranchVersion + " cannot be a snapshot because version " + v + " exists",, +                            VersionUtils.allUnreleasedVersions().contains(maxBranchVersion));, +++ b/core/src/test/java/org/elasticsearch/bwcompat/OldIndexBackwardsCompatibilityIT.java, +            // The current version is in the "released" list even though it isn't released for historical reasons, +            if (v == Version.CURRENT) continue;, +++ b/core/src/test/java/org/elasticsearch/bwcompat/RestoreBackwardsCompatIT.java, +            // The current version is in the "released" list even though it isn't released for historical reasons, +            if (v == Version.CURRENT) continue;, +++ b/core/src/test/java/org/elasticsearch/VersionTests.java, +            if (field.getName().matches("_ID")) {, +                    if (v == Version.CURRENT) {, +                        // Current is weird - it counts as released even though it shouldn't., +                        continue;, +                    }, +                    assertFalse("Version " + maxBranchVersion + " cannot be a snapshot because version " + v + " exists",, +                            VersionUtils.allUnreleasedVersions().contains(maxBranchVersion));, +++ b/core/src/test/java/org/elasticsearch/bwcompat/OldIndexBackwardsCompatibilityIT.java, +            // The current version is in the "released" list even though it isn't released for historical reasons, +            if (v == Version.CURRENT) continue;, +++ b/core/src/test/java/org/elasticsearch/bwcompat/RestoreBackwardsCompatIT.java, +            // The current version is in the "released" list even though it isn't released for historical reasons, +            if (v == Version.CURRENT) continue;, +++ b/test/framework/src/main/java/org/elasticsearch/test/VersionUtils.java, +import org.elasticsearch.common.Nullable;, +    private static final List<Version> ALL_VERSIONS;, +        List<Version> allVersions = new ArrayList<>(RELEASED_VERSIONS.size() + UNRELEASED_VERSIONS.size());, +        allVersions.addAll(RELEASED_VERSIONS);, +        allVersions.addAll(UNRELEASED_VERSIONS);, +        Collections.sort(allVersions);, +        ALL_VERSIONS = unmodifiableList(allVersions);, +    /**, +     * Returns an immutable, sorted list containing all versions, both released and unreleased., +     */, +    public static List<Version> allVersions() {, +        return ALL_VERSIONS;, +    }, +, +    /**, +     * Get the released version before {@code version}., +     */, +    /**, +     * Get the released version before {@link Version#CURRENT}., +     */, +    /**, +     * Returns the released {@link Version} before the {@link Version#CURRENT}, +     * where the minor version is less than the currents minor version., +     */, +    /** Returns the oldest released {@link Version} */, +        return ALL_VERSIONS.get(random.nextInt(ALL_VERSIONS.size()));, +    public static Version randomVersionBetween(Random random, @Nullable Version minVersion, @Nullable Version maxVersion) {, +            minVersionIndex = ALL_VERSIONS.indexOf(minVersion);, +        int maxVersionIndex = ALL_VERSIONS.size() - 1;, +            maxVersionIndex = ALL_VERSIONS.indexOf(maxVersion);, +            return ALL_VERSIONS.get(minVersionIndex + random.nextInt(range));, +++ b/core/src/test/java/org/elasticsearch/VersionTests.java, +            if (field.getName().matches("_ID")) {, +                    if (v == Version.CURRENT) {, +                        // Current is weird - it counts as released even though it shouldn't., +                        continue;, +                    }, +                    assertFalse("Version " + maxBranchVersion + " cannot be a snapshot because version " + v + " exists",, +                            VersionUtils.allUnreleasedVersions().contains(maxBranchVersion));, +++ b/core/src/test/java/org/elasticsearch/bwcompat/OldIndexBackwardsCompatibilityIT.java, +            // The current version is in the "released" list even though it isn't released for historical reasons, +            if (v == Version.CURRENT) continue;, +++ b/core/src/test/java/org/elasticsearch/bwcompat/RestoreBackwardsCompatIT.java, +            // The current version is in the "released" list even though it isn't released for historical reasons, +            if (v == Version.CURRENT) continue;, +++ b/test/framework/src/main/java/org/elasticsearch/test/VersionUtils.java, +import org.elasticsearch.common.Nullable;, +    private static final List<Version> ALL_VERSIONS;, +        List<Version> allVersions = new ArrayList<>(RELEASED_VERSIONS.size() + UNRELEASED_VERSIONS.size());, +        allVersions.addAll(RELEASED_VERSIONS);, +        allVersions.addAll(UNRELEASED_VERSIONS);, +        Collections.sort(allVersions);]