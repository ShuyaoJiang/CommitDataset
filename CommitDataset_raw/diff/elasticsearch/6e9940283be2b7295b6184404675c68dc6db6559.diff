[+++ b/core/src/main/java/org/elasticsearch/indices/recovery/RecoverySourceHandler.java, +            // if we are doing a sequence-number-based recovery, we have to skip older ops for which no sequence number was assigned, and, +            // any ops before the starting sequence number, +            final long seqNo = operation.seqNo();, +            if (startingSeqNo >= 0 && (seqNo == SequenceNumbersService.UNASSIGNED_SEQ_NO || seqNo < startingSeqNo)) continue;, +++ b/core/src/main/java/org/elasticsearch/indices/recovery/RecoverySourceHandler.java, +            // if we are doing a sequence-number-based recovery, we have to skip older ops for which no sequence number was assigned, and, +            // any ops before the starting sequence number, +            final long seqNo = operation.seqNo();, +            if (startingSeqNo >= 0 && (seqNo == SequenceNumbersService.UNASSIGNED_SEQ_NO || seqNo < startingSeqNo)) continue;, +++ b/core/src/test/java/org/elasticsearch/indices/recovery/RecoverySourceHandlerTests.java, +import org.apache.lucene.document.NumericDocValuesField;, +import org.apache.lucene.index.Term;, +import org.elasticsearch.common.bytes.BytesArray;, +import org.elasticsearch.common.bytes.BytesReference;, +import org.elasticsearch.common.lucene.uid.Versions;, +import org.elasticsearch.index.engine.Engine;, +import org.elasticsearch.index.mapper.Mapping;, +import org.elasticsearch.index.mapper.ParseContext;, +import org.elasticsearch.index.mapper.ParsedDocument;, +import org.elasticsearch.index.mapper.SeqNoFieldMapper;, +import org.elasticsearch.index.mapper.Uid;, +import org.elasticsearch.index.mapper.UidFieldMapper;, +import java.util.Arrays;, +    public void testSendSnapshotSendsOps() throws IOException {, +        final RecoverySettings recoverySettings = new RecoverySettings(Settings.EMPTY, service);, +        final int fileChunkSizeInBytes = recoverySettings.getChunkSize().bytesAsInt();, +        final long startingSeqNo = randomBoolean() ? SequenceNumbersService.UNASSIGNED_SEQ_NO : randomIntBetween(0, 16);, +        final StartRecoveryRequest request = new StartRecoveryRequest(, +            shardId,, +            new DiscoveryNode("b", buildNewFakeTransportAddress(), emptyMap(), emptySet(), Version.CURRENT),, +            new DiscoveryNode("b", buildNewFakeTransportAddress(), emptyMap(), emptySet(), Version.CURRENT),, +            null,, +            randomBoolean(),, +            randomNonNegativeLong(),, +            randomBoolean() ? SequenceNumbersService.UNASSIGNED_SEQ_NO : randomNonNegativeLong());, +        final IndexShard shard = mock(IndexShard.class);, +        when(shard.state()).thenReturn(IndexShardState.STARTED);, +        final RecoveryTargetHandler recoveryTarget = mock(RecoveryTargetHandler.class);, +        final RecoverySourceHandler handler =, +            new RecoverySourceHandler(shard, recoveryTarget, request, () -> 0L, e -> () -> {}, fileChunkSizeInBytes, Settings.EMPTY);, +        final List<Translog.Operation> operations = new ArrayList<>();, +        final int initialNumberOfDocs = randomIntBetween(16, 64);, +        for (int i = 0; i < initialNumberOfDocs; i++) {, +            final Engine.Index index = getIndex(Integer.toString(i));, +            operations.add(new Translog.Index(index, new Engine.IndexResult(1, SequenceNumbersService.UNASSIGNED_SEQ_NO, true)));, +        }, +        final int numberOfDocsWithValidSequenceNumbers = randomIntBetween(16, 64);, +        for (int i = initialNumberOfDocs; i < initialNumberOfDocs + numberOfDocsWithValidSequenceNumbers; i++) {, +            final Engine.Index index = getIndex(Integer.toString(i));, +            operations.add(new Translog.Index(index, new Engine.IndexResult(1, i - initialNumberOfDocs, true)));, +        }, +        operations.add(null);, +        int totalOperations = handler.sendSnapshot(startingSeqNo, new Translog.Snapshot() {, +            private int counter = 0;, +, +            @Override, +            public int totalOperations() {, +                return operations.size() - 1;, +            }, +, +            @Override, +            public Translog.Operation next() throws IOException {, +                return operations.get(counter++);, +            }, +        });, +        if (startingSeqNo == SequenceNumbersService.UNASSIGNED_SEQ_NO) {, +            assertThat(totalOperations, equalTo(initialNumberOfDocs + numberOfDocsWithValidSequenceNumbers));, +        } else {, +            assertThat(totalOperations, equalTo(Math.toIntExact(numberOfDocsWithValidSequenceNumbers - startingSeqNo)));, +        }, +    }, +, +    private Engine.Index getIndex(final String id) {, +        final String type = "test";, +        final ParseContext.Document document = new ParseContext.Document();, +        document.add(new TextField("test", "test", Field.Store.YES));, +        final Field uidField = new Field("_uid", Uid.createUid(type, id), UidFieldMapper.Defaults.FIELD_TYPE);, +        final Field versionField = new NumericDocValuesField("_version", Versions.MATCH_ANY);, +        final SeqNoFieldMapper.SequenceID seqID = SeqNoFieldMapper.SequenceID.emptySeqID();, +        document.add(uidField);, +        document.add(versionField);, +        document.add(seqID.seqNo);, +        document.add(seqID.seqNoDocValue);, +        document.add(seqID.primaryTerm);, +        final BytesReference source = new BytesArray(new byte[] { 1 });, +        final ParsedDocument doc = new ParsedDocument(versionField, seqID, id, type, null, Arrays.asList(document), source, null);, +        return new Engine.Index(new Term("_uid", doc.uid()), doc);, +    }, +, +++ b/core/src/main/java/org/elasticsearch/indices/recovery/RecoverySourceHandler.java, +            // if we are doing a sequence-number-based recovery, we have to skip older ops for which no sequence number was assigned, and, +            // any ops before the starting sequence number, +            final long seqNo = operation.seqNo();, +            if (startingSeqNo >= 0 && (seqNo == SequenceNumbersService.UNASSIGNED_SEQ_NO || seqNo < startingSeqNo)) continue;, +++ b/core/src/test/java/org/elasticsearch/indices/recovery/RecoverySourceHandlerTests.java, +import org.apache.lucene.document.NumericDocValuesField;, +import org.apache.lucene.index.Term;, +import org.elasticsearch.common.bytes.BytesArray;, +import org.elasticsearch.common.bytes.BytesReference;]