[+++ b/core/src/main/java/org/elasticsearch/cluster/routing/allocation/decider/DiskThresholdDecider.java, +        // Allow allocation regardless if only a single data node is available, +        if (allocation.nodes().dataNodes().size() <= 1) {, +                logger.trace("only a single data node is present, allowing allocation");, +            return allocation.decision(Decision.YES, NAME, "only a single data node is present");, +++ b/core/src/main/java/org/elasticsearch/cluster/routing/allocation/decider/DiskThresholdDecider.java, +        // Allow allocation regardless if only a single data node is available, +        if (allocation.nodes().dataNodes().size() <= 1) {, +                logger.trace("only a single data node is present, allowing allocation");, +            return allocation.decision(Decision.YES, NAME, "only a single data node is present");, +++ b/core/src/main/java/org/elasticsearch/index/engine/Engine.java, +        /**, +         * Returns operation start time in nanoseconds., +         */, +        /**, +         * Returns operation start time in nanoseconds., +         */, +++ b/core/src/main/java/org/elasticsearch/cluster/routing/allocation/decider/DiskThresholdDecider.java, +        // Allow allocation regardless if only a single data node is available, +        if (allocation.nodes().dataNodes().size() <= 1) {, +                logger.trace("only a single data node is present, allowing allocation");, +            return allocation.decision(Decision.YES, NAME, "only a single data node is present");, +++ b/core/src/main/java/org/elasticsearch/index/engine/Engine.java, +        /**, +         * Returns operation start time in nanoseconds., +         */, +        /**, +         * Returns operation start time in nanoseconds., +         */, +++ b/core/src/main/java/org/elasticsearch/index/engine/InternalEngine.java, +++ b/core/src/main/java/org/elasticsearch/cluster/routing/allocation/decider/DiskThresholdDecider.java, +        // Allow allocation regardless if only a single data node is available, +        if (allocation.nodes().dataNodes().size() <= 1) {, +                logger.trace("only a single data node is present, allowing allocation");, +            return allocation.decision(Decision.YES, NAME, "only a single data node is present");, +++ b/core/src/main/java/org/elasticsearch/index/engine/Engine.java, +        /**, +         * Returns operation start time in nanoseconds., +         */, +        /**, +         * Returns operation start time in nanoseconds., +         */, +++ b/core/src/main/java/org/elasticsearch/index/engine/InternalEngine.java, +++ b/core/src/main/java/org/elasticsearch/index/engine/ShadowEngine.java, +++ b/core/src/main/java/org/elasticsearch/cluster/routing/allocation/decider/DiskThresholdDecider.java, +        // Allow allocation regardless if only a single data node is available, +        if (allocation.nodes().dataNodes().size() <= 1) {, +                logger.trace("only a single data node is present, allowing allocation");, +            return allocation.decision(Decision.YES, NAME, "only a single data node is present");, +++ b/core/src/main/java/org/elasticsearch/index/engine/Engine.java, +        /**, +         * Returns operation start time in nanoseconds., +         */, +        /**, +         * Returns operation start time in nanoseconds., +         */, +++ b/core/src/main/java/org/elasticsearch/index/engine/InternalEngine.java, +++ b/core/src/main/java/org/elasticsearch/index/engine/ShadowEngine.java, +++ b/core/src/main/java/org/elasticsearch/index/shard/IndexShard.java, +import org.elasticsearch.index.store.Store.MetadataSnapshot;, +                      ShardPath path, BigArrays bigArrays, IndexSearcherWrappingService wrappingService) {, +        writeAllowed(create.origin());, +        writeAllowed(index.origin());, +        writeAllowed(delete.origin());, +    private void writeAllowed(Engine.Operation.Origin origin) throws IllegalIndexShardStateException {, +            if (shardIndexingBufferSize == EngineConfig.INACTIVE_SHARD_INDEXING_BUFFER) {, +                // it's inactive: make sure we do a refresh / full IW flush in this case, since the memory, +                // changes only after a "data" change has happened to the writer, +                // the index writer lazily allocates memory and a refresh will clean it all up., +                logger.debug("updating index_buffer_size from [{}] to (inactive) [{}]", preValue, shardIndexingBufferSize);, +                    logger.warn("failed to refresh after setting shard to inactive", e);, +            } else {, +                logger.debug("updating index_buffer_size from [{}] to [{}]", preValue, shardIndexingBufferSize);, +++ b/core/src/main/java/org/elasticsearch/cluster/routing/allocation/decider/DiskThresholdDecider.java, +        // Allow allocation regardless if only a single data node is available, +        if (allocation.nodes().dataNodes().size() <= 1) {, +                logger.trace("only a single data node is present, allowing allocation");, +            return allocation.decision(Decision.YES, NAME, "only a single data node is present");, +++ b/core/src/main/java/org/elasticsearch/index/engine/Engine.java, +        /**, +         * Returns operation start time in nanoseconds., +         */, +        /**, +         * Returns operation start time in nanoseconds., +         */, +++ b/core/src/main/java/org/elasticsearch/index/engine/InternalEngine.java, +++ b/core/src/main/java/org/elasticsearch/index/engine/ShadowEngine.java, +++ b/core/src/main/java/org/elasticsearch/index/shard/IndexShard.java, +import org.elasticsearch.index.store.Store.MetadataSnapshot;, +                      ShardPath path, BigArrays bigArrays, IndexSearcherWrappingService wrappingService) {, +        writeAllowed(create.origin());, +        writeAllowed(index.origin());, +        writeAllowed(delete.origin());, +    private void writeAllowed(Engine.Operation.Origin origin) throws IllegalIndexShardStateException {, +            if (shardIndexingBufferSize == EngineConfig.INACTIVE_SHARD_INDEXING_BUFFER) {, +                // it's inactive: make sure we do a refresh / full IW flush in this case, since the memory, +                // changes only after a "data" change has happened to the writer, +                // the index writer lazily allocates memory and a refresh will clean it all up., +                logger.debug("updating index_buffer_size from [{}] to (inactive) [{}]", preValue, shardIndexingBufferSize);, +                    logger.warn("failed to refresh after setting shard to inactive", e);]