[+++ b/buildSrc/src/main/groovy/org/elasticsearch/gradle/doc/RestTestsFromSnippetsTask.groovy, +++ b/buildSrc/src/main/groovy/org/elasticsearch/gradle/doc/RestTestsFromSnippetsTask.groovy, +++ b/buildSrc/src/main/resources/forbidden/es-core-signatures.txt, +, +@defaultMessage Don't use MethodHandles in slow ways, except in tests., +java.lang.invoke.MethodHandle#invoke(java.lang.Object[]), +java.lang.invoke.MethodHandle#invokeWithArguments(java.lang.Object[]), +java.lang.invoke.MethodHandle#invokeWithArguments(java.util.List), +++ b/buildSrc/src/main/groovy/org/elasticsearch/gradle/doc/RestTestsFromSnippetsTask.groovy, +++ b/buildSrc/src/main/resources/forbidden/es-core-signatures.txt, +, +@defaultMessage Don't use MethodHandles in slow ways, except in tests., +java.lang.invoke.MethodHandle#invoke(java.lang.Object[]), +java.lang.invoke.MethodHandle#invokeWithArguments(java.lang.Object[]), +java.lang.invoke.MethodHandle#invokeWithArguments(java.util.List), +++ b/core/src/main/java/org/elasticsearch/bootstrap/BootstrapCheck.java, +                if (!enforceLimits || (check.isSystemCheck() && ignoreSystemChecks)) {, +    // visible for testing, +    // visible for testing, +++ b/buildSrc/src/main/groovy/org/elasticsearch/gradle/doc/RestTestsFromSnippetsTask.groovy, +++ b/buildSrc/src/main/resources/forbidden/es-core-signatures.txt, +, +@defaultMessage Don't use MethodHandles in slow ways, except in tests., +java.lang.invoke.MethodHandle#invoke(java.lang.Object[]), +java.lang.invoke.MethodHandle#invokeWithArguments(java.lang.Object[]), +java.lang.invoke.MethodHandle#invokeWithArguments(java.util.List), +++ b/core/src/main/java/org/elasticsearch/bootstrap/BootstrapCheck.java, +                if (!enforceLimits || (check.isSystemCheck() && ignoreSystemChecks)) {, +    // visible for testing, +    // visible for testing, +++ b/core/src/main/java/org/elasticsearch/cluster/routing/RoutingNodes.java, +                            addInitialRecovery(targetShardRouting, routingTable);, +                        } else if (shard.active() == false) { // shards that are initializing without being relocated, +                            addInitialRecovery(shard, routingTable);, +        addRecovery(routing, true, null);, +        addRecovery(routing, false, null);, +    private void addInitialRecovery(ShardRouting routing, RoutingTable routingTable) {, +        addRecovery(routing, true, routingTable);, +    private void addRecovery(final ShardRouting routing, final boolean increment, final RoutingTable routingTable) {, +        final String sourceNodeId;, +        if (routing.relocatingNodeId() != null) { // this is a relocation-target, +            sourceNodeId = routing.relocatingNodeId();, +            if (routing.primary() && increment == false) { // primary is done relocating, +                    if (assigned.primary() == false && assigned.initializing() && assigned.relocatingNodeId() == null) {, +                // we transfer the recoveries to the relocated primary, +                recoveriesPerNode.get(sourceNodeId).addOutgoing(-numRecoveringReplicas);, +        } else if (routing.primary() == false) { // primary without relocationID is initial recovery, +            ShardRouting primary = findPrimary(routing);, +            if (primary == null && routingTable != null) {, +                primary = routingTable.index(routing.index().getName()).shard(routing.shardId().id()).primary;, +            } else if (primary == null) {, +                throw new IllegalStateException("replica is initializing but primary is unassigned");, +            }, +            sourceNodeId = primary.currentNodeId();, +        } else {, +            sourceNodeId = null;, +        }, +        if (sourceNodeId != null) {, +            Recoveries.getOrAdd(recoveriesPerNode, sourceNodeId).addOutgoing(howMany);, +    private ShardRouting findPrimary(ShardRouting routing) {, +        ShardRouting primary = null;, +        Recoveries.getOrAdd(recoveriesPerNode, shard.relocatingNodeId()).addOutgoing(-1);, +                    } else if (routing.relocating()) {, +                        outgoing++;, +                    if (routing.primary() && (routing.initializing() && routing.relocatingNodeId() != null) == false) { // we don't count the initialization end of the primary relocation, +                        List<ShardRouting> shardRoutings = routingNodes.assignedShards.get(routing.shardId());, +                        for (ShardRouting assigned : shardRoutings) {, +                            if (assigned.primary() == false && assigned.initializing() && assigned.relocatingNodeId() == null) {, +            assert incoming == value.incoming : incoming + " != " + value.incoming;, +++ b/buildSrc/src/main/groovy/org/elasticsearch/gradle/doc/RestTestsFromSnippetsTask.groovy, +++ b/buildSrc/src/main/resources/forbidden/es-core-signatures.txt, +, +@defaultMessage Don't use MethodHandles in slow ways, except in tests., +java.lang.invoke.MethodHandle#invoke(java.lang.Object[]), +java.lang.invoke.MethodHandle#invokeWithArguments(java.lang.Object[]), +java.lang.invoke.MethodHandle#invokeWithArguments(java.util.List), +++ b/core/src/main/java/org/elasticsearch/bootstrap/BootstrapCheck.java, +                if (!enforceLimits || (check.isSystemCheck() && ignoreSystemChecks)) {, +    // visible for testing, +    // visible for testing, +++ b/core/src/main/java/org/elasticsearch/cluster/routing/RoutingNodes.java, +                            addInitialRecovery(targetShardRouting, routingTable);, +                        } else if (shard.active() == false) { // shards that are initializing without being relocated, +                            addInitialRecovery(shard, routingTable);, +        addRecovery(routing, true, null);, +        addRecovery(routing, false, null);, +    private void addInitialRecovery(ShardRouting routing, RoutingTable routingTable) {, +        addRecovery(routing, true, routingTable);, +    private void addRecovery(final ShardRouting routing, final boolean increment, final RoutingTable routingTable) {, +        final String sourceNodeId;, +        if (routing.relocatingNodeId() != null) { // this is a relocation-target, +            sourceNodeId = routing.relocatingNodeId();, +            if (routing.primary() && increment == false) { // primary is done relocating, +                    if (assigned.primary() == false && assigned.initializing() && assigned.relocatingNodeId() == null) {, +                // we transfer the recoveries to the relocated primary, +                recoveriesPerNode.get(sourceNodeId).addOutgoing(-numRecoveringReplicas);, +        } else if (routing.primary() == false) { // primary without relocationID is initial recovery, +            ShardRouting primary = findPrimary(routing);, +            if (primary == null && routingTable != null) {, +                primary = routingTable.index(routing.index().getName()).shard(routing.shardId().id()).primary;]