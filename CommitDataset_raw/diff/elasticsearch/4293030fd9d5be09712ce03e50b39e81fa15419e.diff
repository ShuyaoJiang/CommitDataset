[+++ b/core/src/main/java/org/elasticsearch/search/aggregations/bucket/BestBucketsDeferringCollector.java, +                final long bucket = buckets.next();, +                final long rebasedBucket = hash.find(bucket);, +                if (rebasedBucket != -1) {, +++ b/core/src/main/java/org/elasticsearch/search/aggregations/bucket/BestBucketsDeferringCollector.java, +                final long bucket = buckets.next();, +                final long rebasedBucket = hash.find(bucket);, +                if (rebasedBucket != -1) {, +++ b/core/src/main/java/org/elasticsearch/search/aggregations/bucket/terms/TermsAggregationBuilder.java, +    private SubAggCollectionMode collectMode = SubAggCollectionMode.DEPTH_FIRST;, +        collectMode = SubAggCollectionMode.readFromStream(in);, +        collectMode.writeTo(out);, +++ b/core/src/main/java/org/elasticsearch/search/aggregations/bucket/BestBucketsDeferringCollector.java, +                final long bucket = buckets.next();, +                final long rebasedBucket = hash.find(bucket);, +                if (rebasedBucket != -1) {, +++ b/core/src/main/java/org/elasticsearch/search/aggregations/bucket/terms/TermsAggregationBuilder.java, +    private SubAggCollectionMode collectMode = SubAggCollectionMode.DEPTH_FIRST;, +        collectMode = SubAggCollectionMode.readFromStream(in);, +        collectMode.writeTo(out);, +++ b/core/src/main/java/org/elasticsearch/search/aggregations/bucket/terms/TermsAggregatorFactory.java, +                    collectMode, showTermDocCountError, pipelineAggregators, metaData);, +                        bucketCountThresholds, context, parent, collectMode, showTermDocCountError, longFilter,, +                    bucketCountThresholds, context, parent, collectMode, showTermDocCountError, longFilter, pipelineAggregators,, +++ b/core/src/main/java/org/elasticsearch/search/aggregations/bucket/BestBucketsDeferringCollector.java, +                final long bucket = buckets.next();, +                final long rebasedBucket = hash.find(bucket);, +                if (rebasedBucket != -1) {, +++ b/core/src/main/java/org/elasticsearch/search/aggregations/bucket/terms/TermsAggregationBuilder.java, +    private SubAggCollectionMode collectMode = SubAggCollectionMode.DEPTH_FIRST;, +        collectMode = SubAggCollectionMode.readFromStream(in);, +        collectMode.writeTo(out);, +++ b/core/src/main/java/org/elasticsearch/search/aggregations/bucket/terms/TermsAggregatorFactory.java, +                    collectMode, showTermDocCountError, pipelineAggregators, metaData);, +                        bucketCountThresholds, context, parent, collectMode, showTermDocCountError, longFilter,, +                    bucketCountThresholds, context, parent, collectMode, showTermDocCountError, longFilter, pipelineAggregators,, +++ /dev/null, +++ b/core/src/main/java/org/elasticsearch/search/aggregations/bucket/BestBucketsDeferringCollector.java, +                final long bucket = buckets.next();, +                final long rebasedBucket = hash.find(bucket);, +                if (rebasedBucket != -1) {, +++ b/core/src/main/java/org/elasticsearch/search/aggregations/bucket/terms/TermsAggregationBuilder.java, +    private SubAggCollectionMode collectMode = SubAggCollectionMode.DEPTH_FIRST;, +        collectMode = SubAggCollectionMode.readFromStream(in);, +        collectMode.writeTo(out);, +++ b/core/src/main/java/org/elasticsearch/search/aggregations/bucket/terms/TermsAggregatorFactory.java, +                    collectMode, showTermDocCountError, pipelineAggregators, metaData);, +                        bucketCountThresholds, context, parent, collectMode, showTermDocCountError, longFilter,, +                    bucketCountThresholds, context, parent, collectMode, showTermDocCountError, longFilter, pipelineAggregators,, +++ /dev/null, +++ b/docs/reference/aggregations/bucket/terms-aggregation.asciidoc, +are expanded in one depth-first pass and only then any pruning occurs. In some rare scenarios this can be very wasteful and can hit memory constraints., +Even though the number of movies may be comparatively small and we want only 50 result buckets there is a combinatorial explosion of buckets, +during calculation - a single movie will produce n² buckets where n is the number of actors. The sane option would be to first determine, +mode as opposed to the default `depth_first` mode:, +                 "collect_mode" : "breadth_first", +In most requests the volume of buckets generated is smaller than the number of documents that fall into them so the default `depth_first`, +collection mode is normally the best bet but occasionally the `breadth_first` strategy can be significantly more efficient. Currently, +elasticsearch will always use the `depth_first` collect_mode unless explicitly instructed to use `breadth_first` as in the above example., +++ b/core/src/main/java/org/elasticsearch/search/aggregations/bucket/BestBucketsDeferringCollector.java, +                final long bucket = buckets.next();, +                final long rebasedBucket = hash.find(bucket);, +                if (rebasedBucket != -1) {, +++ b/core/src/main/java/org/elasticsearch/search/aggregations/bucket/terms/TermsAggregationBuilder.java, +    private SubAggCollectionMode collectMode = SubAggCollectionMode.DEPTH_FIRST;, +        collectMode = SubAggCollectionMode.readFromStream(in);, +        collectMode.writeTo(out);, +++ b/core/src/main/java/org/elasticsearch/search/aggregations/bucket/terms/TermsAggregatorFactory.java, +                    collectMode, showTermDocCountError, pipelineAggregators, metaData);, +                        bucketCountThresholds, context, parent, collectMode, showTermDocCountError, longFilter,, +                    bucketCountThresholds, context, parent, collectMode, showTermDocCountError, longFilter, pipelineAggregators,, +++ /dev/null, +++ b/docs/reference/aggregations/bucket/terms-aggregation.asciidoc, +are expanded in one depth-first pass and only then any pruning occurs. In some rare scenarios this can be very wasteful and can hit memory constraints., +Even though the number of movies may be comparatively small and we want only 50 result buckets there is a combinatorial explosion of buckets, +during calculation - a single movie will produce n² buckets where n is the number of actors. The sane option would be to first determine, +mode as opposed to the default `depth_first` mode:, +                 "collect_mode" : "breadth_first", +In most requests the volume of buckets generated is smaller than the number of documents that fall into them so the default `depth_first`, +collection mode is normally the best bet but occasionally the `breadth_first` strategy can be significantly more efficient. Currently, +elasticsearch will always use the `depth_first` collect_mode unless explicitly instructed to use `breadth_first` as in the above example., +++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/DefBootstrap.java, +        private MethodHandle createMegamorphicHandle() {, +            return MethodHandles.foldArguments(MethodHandles.exactInvoker(type),, +                    MEGAMORPHIC_LOOKUP.bindTo(megamorphicCache));            , +        private MethodHandle lookupGeneric() {, +         * Called when a new type is encountered or if cached type does not match., +         * In that case we revert to a generic, but slower operator handling., +++ b/core/src/main/java/org/elasticsearch/search/aggregations/bucket/BestBucketsDeferringCollector.java, +                final long bucket = buckets.next();, +                final long rebasedBucket = hash.find(bucket);, +                if (rebasedBucket != -1) {, +++ b/core/src/main/java/org/elasticsearch/search/aggregations/bucket/terms/TermsAggregationBuilder.java, +    private SubAggCollectionMode collectMode = SubAggCollectionMode.DEPTH_FIRST;, +        collectMode = SubAggCollectionMode.readFromStream(in);, +        collectMode.writeTo(out);, +++ b/core/src/main/java/org/elasticsearch/search/aggregations/bucket/terms/TermsAggregatorFactory.java, +                    collectMode, showTermDocCountError, pipelineAggregators, metaData);, +                        bucketCountThresholds, context, parent, collectMode, showTermDocCountError, longFilter,, +                    bucketCountThresholds, context, parent, collectMode, showTermDocCountError, longFilter, pipelineAggregators,]