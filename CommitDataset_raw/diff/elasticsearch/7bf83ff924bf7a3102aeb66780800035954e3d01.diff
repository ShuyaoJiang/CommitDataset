[+++ b/src/main/java/org/elasticsearch/action/support/replication/TransportShardReplicationOperationAction.java, +import org.apache.lucene.util.IOUtils;, +import org.elasticsearch.cluster.routing.*;, +import org.elasticsearch.common.lease.Releasable;, +import org.elasticsearch.common.lease.Releasables;, +import org.elasticsearch.common.util.concurrent.RefCounted;, +import org.elasticsearch.transport.*;, +import java.io.Closeable;, +import java.util.concurrent.atomic.AtomicReference;, +            try (Releasable shardReference = getIndexShardOperationsCounter(request.internalShardId)) {, +            } catch (Throwable t) {, +                failReplicaIfNeeded(request.internalShardId.index().name(), request.internalShardId.id(), t);, +                throw t;, +            }, +        private volatile Releasable indexShardReference;, +        /**, +         * send the request to the node holding the primary or execute if local, +         */, +        /**, +         * upon success, finish the first phase and transfer responsibility to the {@link ReplicationPhase}, +         */, +                Releasables.close(indexShardReference);, +                Releasables.close(indexShardReference);, +        /**, +         * perform the operation on the node holding the primary, +         */, +                indexShardReference = getIndexShardOperationsCounter(primary.shardId());, +                replicationPhase = new ReplicationPhase(shardsIt, primaryResponse.v2(), primaryResponse.v1(), observer, primary, internalRequest, listener, indexShardReference);, +                    // We have to close here because when we retry we will increment get a new reference on index shard again and we do not want to, +                    // increment twice., +                    Releasables.close(indexShardReference);, +                    // We have to reset to null here because whe we retry it might be that we never get to the point where we assign a new reference, +                    // (for example, in case the operation was rejected because queue is full). In this case we would release again once one of the finish methods is called., +                    indexShardReference = null;, +    protected Releasable getIndexShardOperationsCounter(ShardId shardId) {, +        IndexService indexService = indicesService.indexServiceSafe(shardId.index().getName());, +        IndexShard indexShard = indexService.shardSafe(shardId.id());, +        return new IndexShardReference(indexShard);, +    }, +, +    /**, +     * inner class is responsible for send the requests to all replica shards and manage the responses, +     */, +        private final Releasable indexShardReference;, +                                InternalRequest internalRequest, ActionListener<Response> listener, Releasable indexShardReference) {, +            this.indexShardReference = indexShardReference;, +        /**, +         * total shard copies, +         */, +        /**, +         * total successful operations so far, +         */, +        /**, +         * number of pending operations, +         */, +        /**, +         * start sending current requests to replicas, +         */, +        /**, +         * send operation to the given node or perform it if local, +         */, +                Releasables.close(indexShardReference);, +                Releasables.close(indexShardReference);, +, +    static class IndexShardReference implements Releasable {, +, +        final private IndexShard counter;, +        private final AtomicBoolean closed = new AtomicBoolean(false);, +, +        IndexShardReference(IndexShard counter) {, +            counter.incrementOperationCounter();, +            this.counter = counter;, +        }, +, +        @Override, +        public void close() {, +            if (closed.compareAndSet(false, true)) {, +                counter.decrementOperationCounter();, +            }, +        }, +    }, +++ b/src/main/java/org/elasticsearch/action/support/replication/TransportShardReplicationOperationAction.java, +import org.apache.lucene.util.IOUtils;, +import org.elasticsearch.cluster.routing.*;, +import org.elasticsearch.common.lease.Releasable;, +import org.elasticsearch.common.lease.Releasables;, +import org.elasticsearch.common.util.concurrent.RefCounted;, +import org.elasticsearch.transport.*;, +import java.io.Closeable;, +import java.util.concurrent.atomic.AtomicReference;, +            try (Releasable shardReference = getIndexShardOperationsCounter(request.internalShardId)) {, +            } catch (Throwable t) {, +                failReplicaIfNeeded(request.internalShardId.index().name(), request.internalShardId.id(), t);, +                throw t;, +            }, +        private volatile Releasable indexShardReference;, +        /**, +         * send the request to the node holding the primary or execute if local, +         */, +        /**]