[+++ b/core/src/main/java/org/elasticsearch/cluster/routing/allocation/allocator/ShardsAllocators.java, +        final int numberOfInFlightFetch = gatewayAllocator.getNumberOfInFlightFetch();, +        if (numberOfInFlightFetch == 0) {, +            /*, +             * see https://github.com/elastic/elasticsearch/issues/14387, +             * if we allow rebalance operations while we are still fetching shard store data, +             * we might end up with unnecessary rebalance operations which can be super confusion/frustrating, +             * since once the fetches come back we might just move all the shards back again., +             * Therefore we only do a rebalance if we have fetched all information., +             */, +        } else {, +            logger.debug("skip rebalance [{}] shard store fetch operations are still in-flight", numberOfInFlightFetch);, +        }, +        return false;, +++ b/core/src/main/java/org/elasticsearch/cluster/routing/allocation/allocator/ShardsAllocators.java, +        final int numberOfInFlightFetch = gatewayAllocator.getNumberOfInFlightFetch();, +        if (numberOfInFlightFetch == 0) {, +            /*, +             * see https://github.com/elastic/elasticsearch/issues/14387, +             * if we allow rebalance operations while we are still fetching shard store data, +             * we might end up with unnecessary rebalance operations which can be super confusion/frustrating, +             * since once the fetches come back we might just move all the shards back again., +             * Therefore we only do a rebalance if we have fetched all information., +             */, +        } else {, +            logger.debug("skip rebalance [{}] shard store fetch operations are still in-flight", numberOfInFlightFetch);, +        }, +        return false;, +++ b/core/src/main/java/org/elasticsearch/index/mapper/MapperBuilders.java, +import org.elasticsearch.index.mapper.geo.GeoPointFieldMapper;, +import org.elasticsearch.index.mapper.internal.*;, +    public static GeoPointFieldMapper.Builder geoPointField(String name) {, +        return new GeoPointFieldMapper.Builder(name);, +    }, +, +++ b/core/src/main/java/org/elasticsearch/cluster/routing/allocation/allocator/ShardsAllocators.java, +        final int numberOfInFlightFetch = gatewayAllocator.getNumberOfInFlightFetch();, +        if (numberOfInFlightFetch == 0) {, +            /*, +             * see https://github.com/elastic/elasticsearch/issues/14387, +             * if we allow rebalance operations while we are still fetching shard store data, +             * we might end up with unnecessary rebalance operations which can be super confusion/frustrating, +             * since once the fetches come back we might just move all the shards back again., +             * Therefore we only do a rebalance if we have fetched all information., +             */, +        } else {, +            logger.debug("skip rebalance [{}] shard store fetch operations are still in-flight", numberOfInFlightFetch);, +        }, +        return false;, +++ b/core/src/main/java/org/elasticsearch/index/mapper/MapperBuilders.java, +import org.elasticsearch.index.mapper.geo.GeoPointFieldMapper;, +import org.elasticsearch.index.mapper.internal.*;, +    public static GeoPointFieldMapper.Builder geoPointField(String name) {, +        return new GeoPointFieldMapper.Builder(name);, +    }, +, +++ /dev/null, +++ b/core/src/main/java/org/elasticsearch/cluster/routing/allocation/allocator/ShardsAllocators.java, +        final int numberOfInFlightFetch = gatewayAllocator.getNumberOfInFlightFetch();, +        if (numberOfInFlightFetch == 0) {, +            /*, +             * see https://github.com/elastic/elasticsearch/issues/14387, +             * if we allow rebalance operations while we are still fetching shard store data, +             * we might end up with unnecessary rebalance operations which can be super confusion/frustrating, +             * since once the fetches come back we might just move all the shards back again., +             * Therefore we only do a rebalance if we have fetched all information., +             */, +        } else {, +            logger.debug("skip rebalance [{}] shard store fetch operations are still in-flight", numberOfInFlightFetch);, +        }, +        return false;, +++ b/core/src/main/java/org/elasticsearch/index/mapper/MapperBuilders.java, +import org.elasticsearch.index.mapper.geo.GeoPointFieldMapper;, +import org.elasticsearch.index.mapper.internal.*;, +    public static GeoPointFieldMapper.Builder geoPointField(String name) {, +        return new GeoPointFieldMapper.Builder(name);, +    }, +, +++ /dev/null, +++ b/core/src/main/java/org/elasticsearch/index/mapper/geo/GeoPointFieldMapper.java, +import com.carrotsearch.hppc.ObjectHashSet;, +import com.carrotsearch.hppc.cursors.ObjectCursor;, +import org.apache.lucene.document.Field;, +import org.apache.lucene.util.BytesRef;, +import org.apache.lucene.util.NumericUtils;, +import org.apache.lucene.util.GeoHashUtils;, +import org.elasticsearch.Version;, +import org.elasticsearch.common.Strings;, +import org.elasticsearch.common.collect.Iterators;, +import org.elasticsearch.common.geo.GeoDistance;, +import org.elasticsearch.common.unit.DistanceUnit;, +import org.elasticsearch.common.util.ByteUtils;, +import org.elasticsearch.common.xcontent.XContentBuilder;, +import org.elasticsearch.common.xcontent.XContentParser;, +import org.elasticsearch.common.xcontent.support.XContentMapValues;, +import org.elasticsearch.index.mapper.*;, +import org.elasticsearch.index.mapper.core.NumberFieldMapper;, +import org.elasticsearch.index.mapper.core.NumberFieldMapper.CustomNumericDocValuesField;, +import org.elasticsearch.index.mapper.object.ArrayValueMapperParser;, +import java.util.*;]