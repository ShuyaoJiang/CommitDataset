[+++ b/core/src/main/java/org/elasticsearch/node/Node.java, +            modules.add(new RepositoriesModule());, +++ b/core/src/main/java/org/elasticsearch/node/Node.java, +            modules.add(new RepositoriesModule());, +++ /dev/null, +++ b/core/src/main/java/org/elasticsearch/node/Node.java, +            modules.add(new RepositoriesModule());, +++ /dev/null, +++ b/core/src/main/java/org/elasticsearch/repositories/RepositoriesModule.java, + *, + * Plugins can add custom repository types by calling {@link #registerRepository(String, Class)}., +    private final RepositoryTypesRegistry repositoryTypes = new RepositoryTypesRegistry();, +    public RepositoriesModule() {, +        registerRepository(FsRepository.TYPE, FsRepository.class);, +        registerRepository(URLRepository.TYPE, URLRepository.class);, +    }, +    /** Registers a custom repository type to the given {@link Repository}. */, +    public void registerRepository(String type, Class<? extends Repository> repositoryType) {, +        repositoryTypes.registerRepository(type, repositoryType);, +        bind(RepositoryTypesRegistry.class).toInstance(repositoryTypes);, +++ b/core/src/main/java/org/elasticsearch/node/Node.java, +            modules.add(new RepositoriesModule());, +++ /dev/null, +++ b/core/src/main/java/org/elasticsearch/repositories/RepositoriesModule.java, + *, + * Plugins can add custom repository types by calling {@link #registerRepository(String, Class)}., +    private final RepositoryTypesRegistry repositoryTypes = new RepositoryTypesRegistry();, +    public RepositoriesModule() {, +        registerRepository(FsRepository.TYPE, FsRepository.class);, +        registerRepository(URLRepository.TYPE, URLRepository.class);, +    }, +    /** Registers a custom repository type to the given {@link Repository}. */, +    public void registerRepository(String type, Class<? extends Repository> repositoryType) {, +        repositoryTypes.registerRepository(type, repositoryType);, +        bind(RepositoryTypesRegistry.class).toInstance(repositoryTypes);, +++ b/core/src/main/java/org/elasticsearch/repositories/RepositoriesService.java, +import org.elasticsearch.common.inject.Injector;, +import org.elasticsearch.common.inject.ModulesBuilder;, +import static java.util.Collections.emptyMap;, +import static java.util.Collections.unmodifiableMap;, +import static org.elasticsearch.common.settings.Settings.Builder.EMPTY_SETTINGS;, +, +    private final RepositoryTypesRegistry typesRegistry;, +, +    private final Injector injector;, +    private volatile Map<String, RepositoryHolder> repositories = emptyMap();, +    public RepositoriesService(Settings settings, ClusterService clusterService, TransportService transportService, RepositoryTypesRegistry typesRegistry, Injector injector) {, +        this.injector = injector;, +            Map<String, RepositoryHolder> survivors = new HashMap<>();, +            for (Map.Entry<String, RepositoryHolder> entry : repositories.entrySet()) {, +                    closeRepository(entry.getKey(), entry.getValue());, +            Map<String, RepositoryHolder> builder = new HashMap<>();, +                    RepositoryHolder holder = survivors.get(repositoryMetaData.name());, +                    if (holder != null) {, +                        if (!holder.type.equals(repositoryMetaData.type()) || !holder.settings.equals(repositoryMetaData.settings())) {, +                            closeRepository(repositoryMetaData.name(), holder);, +                            holder = null;, +                                holder = createRepositoryHolder(repositoryMetaData);, +                            holder = createRepositoryHolder(repositoryMetaData);, +                    if (holder != null) {, +                        builder.put(repositoryMetaData.name(), holder);, +            repositories = unmodifiableMap(builder);, +     * @param repository repository name, +    public Repository repository(String repository) {, +        RepositoryHolder holder = repositories.get(repository);, +        if (holder != null) {, +            return holder.repository;, +        throw new RepositoryMissingException(repository);, +        RepositoryHolder previous = repositories.get(repositoryMetaData.name());, +            if (!previous.type.equals(repositoryMetaData.type()) && previous.settings.equals(repositoryMetaData.settings())) {, +        RepositoryHolder holder = createRepositoryHolder(repositoryMetaData);, +            // Closing previous version, +            closeRepository(repositoryMetaData.name(), previous);, +        Map<String, RepositoryHolder> newRepositories = new HashMap<>(repositories);, +        newRepositories.put(repositoryMetaData.name(), holder);, +    /**, +     * Closes the repository, +     *, +     * @param name   repository name, +     * @param holder repository holder, +     */, +    private void closeRepository(String name, RepositoryHolder holder) throws IOException {, +        logger.debug("closing repository [{}][{}]", holder.type, name);, +        if (holder.repository != null) {, +            holder.repository.close();, +        }, +    private RepositoryHolder createRepositoryHolder(RepositoryMetaData repositoryMetaData) {, +        Injector repositoryInjector = null;, +            ModulesBuilder modules = new ModulesBuilder();, +            RepositoryName name = new RepositoryName(repositoryMetaData.type(), repositoryMetaData.name());, +            modules.add(b -> {, +                b.bind(RepositoryName.class).toInstance(name);, +                typesRegistry.bindType(b, repositoryMetaData.type());, +                b.bind(RepositorySettings.class).toInstance(new RepositorySettings(settings, repositoryMetaData.settings()));, +            });, +, +            repositoryInjector = modules.createChildInjector(injector);, +            Repository repository = repositoryInjector.getInstance(Repository.class);, +            return new RepositoryHolder(repositoryMetaData.type(), repositoryMetaData.settings(), repository);, +     * Internal data structure for holding repository with its configuration information and injector]