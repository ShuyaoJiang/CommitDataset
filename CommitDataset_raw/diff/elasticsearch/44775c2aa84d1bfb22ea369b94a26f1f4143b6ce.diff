[+++ b/modules/elasticsearch/src/main/java/org/elasticsearch/action/bulk/TransportBulkAction.java, +import org.elasticsearch.ElasticSearchException;, +        final BulkItemResponse[] responses = new BulkItemResponse[bulkRequest.requests.size()];, +, +                // handle routing, +                MappingMetaData mappingMd = clusterState.metaData().index(indexRequest.index()).mapping(indexRequest.type());, +                if (mappingMd != null) {, +                    try {, +                        indexRequest.processRouting(mappingMd);, +                    } catch (ElasticSearchException e) {, +                        responses[i] = new BulkItemResponse(i, indexRequest.opType().toString().toLowerCase(),, +                                new BulkItemResponse.Failure(indexRequest.index(), indexRequest.type(), indexRequest.id(), e.getDetailedMessage()));, +                        continue;, +                    }, +                }, +, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/action/bulk/TransportBulkAction.java, +import org.elasticsearch.ElasticSearchException;, +        final BulkItemResponse[] responses = new BulkItemResponse[bulkRequest.requests.size()];, +, +                // handle routing, +                MappingMetaData mappingMd = clusterState.metaData().index(indexRequest.index()).mapping(indexRequest.type());, +                if (mappingMd != null) {, +                    try {, +                        indexRequest.processRouting(mappingMd);, +                    } catch (ElasticSearchException e) {, +                        responses[i] = new BulkItemResponse(i, indexRequest.opType().toString().toLowerCase(),, +                                new BulkItemResponse.Failure(indexRequest.index(), indexRequest.type(), indexRequest.id(), e.getDetailedMessage()));, +                        continue;, +                    }, +                }, +, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/action/index/IndexRequest.java, +import org.elasticsearch.ElasticSearchException;, +import org.elasticsearch.ElasticSearchParseException;, +import org.elasticsearch.action.RoutingMissingException;, +import org.elasticsearch.cluster.metadata.MappingMetaData;, +import org.elasticsearch.common.xcontent.XContentParser;, +     * The source of the document to index, recopied to a new array if it has an offset or unsafe., +    public byte[] unsafeSource() {, +        return this.source;, +    }, +, +    public int unsafeSourceOffset() {, +        return this.sourceOffset;, +    }, +, +    public int unsafeSourceLength() {, +        return this.sourceLength;, +    }, +, +    public void processRouting(MappingMetaData mappingMd) throws ElasticSearchException {, +        if (routing == null && mappingMd.routing().hasPath()) {, +            XContentParser parser = null;, +            try {, +                parser = XContentFactory.xContent(source, sourceOffset, sourceLength), +                        .createParser(source, sourceOffset, sourceLength);, +                routing = mappingMd.parseRouting(parser);, +            } catch (Exception e) {, +                throw new ElasticSearchParseException("failed to parse doc to extract routing", e);, +            } finally {, +                if (parser != null) {, +                    parser.close();, +                }, +            }, +        }, +        // might as well check for routing here, +        if (mappingMd.routing().required() && routing == null) {, +            throw new RoutingMissingException(index, type, id);, +        }, +    }, +, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/action/bulk/TransportBulkAction.java, +import org.elasticsearch.ElasticSearchException;, +        final BulkItemResponse[] responses = new BulkItemResponse[bulkRequest.requests.size()];, +, +                // handle routing, +                MappingMetaData mappingMd = clusterState.metaData().index(indexRequest.index()).mapping(indexRequest.type());, +                if (mappingMd != null) {, +                    try {, +                        indexRequest.processRouting(mappingMd);, +                    } catch (ElasticSearchException e) {, +                        responses[i] = new BulkItemResponse(i, indexRequest.opType().toString().toLowerCase(),, +                                new BulkItemResponse.Failure(indexRequest.index(), indexRequest.type(), indexRequest.id(), e.getDetailedMessage()));, +                        continue;, +                    }, +                }, +, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/action/index/IndexRequest.java, +import org.elasticsearch.ElasticSearchException;, +import org.elasticsearch.ElasticSearchParseException;, +import org.elasticsearch.action.RoutingMissingException;, +import org.elasticsearch.cluster.metadata.MappingMetaData;, +import org.elasticsearch.common.xcontent.XContentParser;, +     * The source of the document to index, recopied to a new array if it has an offset or unsafe., +    public byte[] unsafeSource() {, +        return this.source;, +    }, +, +    public int unsafeSourceOffset() {]