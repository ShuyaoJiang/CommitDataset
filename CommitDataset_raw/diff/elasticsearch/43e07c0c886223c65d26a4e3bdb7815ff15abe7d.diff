[+++ b/core/src/main/java/org/elasticsearch/index/shard/CommitPoint.java, +++ b/core/src/main/java/org/elasticsearch/index/shard/CommitPoint.java, +++ b/core/src/main/java/org/elasticsearch/index/snapshots/blobstore/BlobStoreIndexShardRepository.java, +import org.apache.lucene.index.IndexWriter;, +import org.apache.lucene.index.IndexWriterConfig;, +                    final BlobStoreIndexShardSnapshots shardSnapshots =, +                        indexShardSnapshotsFormat.read(blobContainer, Integer.toString(latest));, +                    return new Tuple<>(shardSnapshots, latest);, +            store = indicesService.indexServiceSafe(shardId.getIndex()).getShardOrNull(shardId.id()).store();, +            store = indicesService.indexServiceSafe(shardId.getIndex()).getShardOrNull(shardId.id()).store();, +, +                if (snapshot.indexFiles().size() == 1, +                    && snapshot.indexFiles().get(0).physicalName().startsWith("segments_"), +                    && snapshot.indexFiles().get(0).hasUnknownChecksum()) {, +                    // If the shard has no documents, it will only contain a single segments_N file for the, +                    // shard's snapshot.  If we are restoring a snapshot created by a previous supported version,, +                    // it is still possible that in that version, an empty shard has a segments_N file with an unsupported, +                    // version (and no checksum), because we don't know the Lucene version to assign segments_N until we, +                    // have written some data.  Since the segments_N for an empty shard could have an incompatible Lucene, +                    // version number and no checksum, even though the index itself is perfectly fine to restore, this, +                    // empty shard would cause exceptions to be thrown.  Since there is no data to restore from an empty, +                    // shard anyway, we just create the empty shard here and then exit., +                    IndexWriter writer = new IndexWriter(store.directory(), new IndexWriterConfig(null), +                                                                                .setOpenMode(IndexWriterConfig.OpenMode.CREATE), +                                                                                .setCommitOnClose(true));, +                    writer.close();, +                    return;, +                }, +, +++ b/core/src/main/java/org/elasticsearch/index/shard/CommitPoint.java, +++ b/core/src/main/java/org/elasticsearch/index/snapshots/blobstore/BlobStoreIndexShardRepository.java, +import org.apache.lucene.index.IndexWriter;, +import org.apache.lucene.index.IndexWriterConfig;, +                    final BlobStoreIndexShardSnapshots shardSnapshots =, +                        indexShardSnapshotsFormat.read(blobContainer, Integer.toString(latest));, +                    return new Tuple<>(shardSnapshots, latest);, +            store = indicesService.indexServiceSafe(shardId.getIndex()).getShardOrNull(shardId.id()).store();, +            store = indicesService.indexServiceSafe(shardId.getIndex()).getShardOrNull(shardId.id()).store();, +, +                if (snapshot.indexFiles().size() == 1, +                    && snapshot.indexFiles().get(0).physicalName().startsWith("segments_"), +                    && snapshot.indexFiles().get(0).hasUnknownChecksum()) {, +                    // If the shard has no documents, it will only contain a single segments_N file for the, +                    // shard's snapshot.  If we are restoring a snapshot created by a previous supported version,, +                    // it is still possible that in that version, an empty shard has a segments_N file with an unsupported, +                    // version (and no checksum), because we don't know the Lucene version to assign segments_N until we, +                    // have written some data.  Since the segments_N for an empty shard could have an incompatible Lucene, +                    // version number and no checksum, even though the index itself is perfectly fine to restore, this, +                    // empty shard would cause exceptions to be thrown.  Since there is no data to restore from an empty, +                    // shard anyway, we just create the empty shard here and then exit., +                    IndexWriter writer = new IndexWriter(store.directory(), new IndexWriterConfig(null), +                                                                                .setOpenMode(IndexWriterConfig.OpenMode.CREATE), +                                                                                .setCommitOnClose(true));, +                    writer.close();, +                    return;, +                }, +, +++ b/core/src/main/java/org/elasticsearch/index/snapshots/blobstore/BlobStoreIndexShardSnapshot.java, +        private static final String UNKNOWN_CHECKSUM = "_na_";, +, +            if (numberOfParts != fileInfo.numberOfParts) {, +                return false;, +            }, +            if (partBytes != fileInfo.partBytes) {, +                return false;, +            }, +            if (!name.equals(fileInfo.name)) {, +                return false;, +            }, +                if (!partSize.equals(fileInfo.partSize)) {, +                    return false;, +                }, +                if (fileInfo.partSize != null) {, +                    return false;, +                }, +        /**, +         * Checks if the checksum for the file is unknown. This only is possible on an empty shard's, +         * segments_N file which was created in older Lucene versions., +         */, +        public boolean hasUnknownChecksum() {, +            return metadata.checksum().equals(UNKNOWN_CHECKSUM);, +        }, +, +            builder.field(NAME, file.name);, +            builder.field(PHYSICAL_NAME, file.metadata.name());, +            builder.field(LENGTH, file.metadata.length());, +            if (file.metadata.checksum().equals(UNKNOWN_CHECKSUM) == false) {, +                builder.field(CHECKSUM, file.metadata.checksum());, +                builder.field(PART_SIZE, file.partSize.bytes());, +                builder.field(WRITTEN_BY, file.metadata.writtenBy());, +                builder.field(META_HASH, file.metadata.hash());, +            String writtenByStr = null;, +                            if (NAME.equals(currentFieldName)) {, +                            } else if (PHYSICAL_NAME.equals(currentFieldName)) {, +                            } else if (LENGTH.equals(currentFieldName)) {, +                            } else if (CHECKSUM.equals(currentFieldName)) {, +                            } else if (PART_SIZE.equals(currentFieldName)) {, +                            } else if (WRITTEN_BY.equals(currentFieldName)) {, +                                writtenByStr = parser.text();, +                                writtenBy = Lucene.parseVersionLenient(writtenByStr, null);]