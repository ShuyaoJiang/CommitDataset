[+++ b/modules/rank-eval/src/main/java/org/elasticsearch/index/rankeval/RankedListQualityMetric.java, +import java.util.Collection;, +    double combine(Collection<EvalQueryQuality> partialResults) {, +++ b/modules/rank-eval/src/main/java/org/elasticsearch/index/rankeval/RankedListQualityMetric.java, +import java.util.Collection;, +    double combine(Collection<EvalQueryQuality> partialResults) {, +++ b/modules/rank-eval/src/main/java/org/elasticsearch/index/rankeval/TransportRankEvalAction.java, +import java.util.concurrent.ConcurrentHashMap;, +import java.util.concurrent.atomic.AtomicInteger;, +            IndexNameExpressionResolver indexNameExpressionResolver, Client client, TransportService transportService) {, +        AtomicInteger numberOfEvaluationQueries = new AtomicInteger(specifications.size());, +        Map<String, EvalQueryQuality> partialResults = new ConcurrentHashMap<>(specifications.size());, +, +        for (QuerySpec querySpecification : specifications) {, +            final RankEvalActionListener searchListener = new RankEvalActionListener(listener, qualityTask, querySpecification,, +                    partialResults, unknownDocs, numberOfEvaluationQueries);, +            SearchSourceBuilder specRequest = querySpecification.getTestRequest();, +            String[] indices = new String[querySpecification.getIndices().size()];, +            querySpecification.getIndices().toArray(indices);, +            String[] types = new String[querySpecification.getTypes().size()];, +            querySpecification.getTypes().toArray(types);, +            client.search(templatedRequest, searchListener);, +        }, +    public static class RankEvalActionListener implements ActionListener<SearchResponse> {, +, +        private ActionListener<RankEvalResponse> listener;, +        private QuerySpec specification;, +        private Map<String, EvalQueryQuality> partialResults;, +        private RankEvalSpec task;, +        private Map<String, Collection<RatedDocumentKey>> unknownDocs;, +        private AtomicInteger responseCounter;, +, +        public RankEvalActionListener(ActionListener<RankEvalResponse> listener, RankEvalSpec task, QuerySpec specification,, +                Map<String, EvalQueryQuality> partialResults, Map<String, Collection<RatedDocumentKey>> unknownDocs,, +                AtomicInteger responseCounter) {, +            this.listener = listener;, +            this.task = task;, +            this.specification = specification;, +            this.partialResults = partialResults;, +            this.unknownDocs = unknownDocs;, +            this.responseCounter = responseCounter;, +        }, +, +        @Override, +        public void onResponse(SearchResponse searchResponse) {, +            SearchHits hits = searchResponse.getHits();, +            EvalQueryQuality queryQuality = task.getEvaluator().evaluate(hits.getHits(), specification.getRatedDocs());, +            partialResults.put(specification.getSpecId(), queryQuality);, +            unknownDocs.put(specification.getSpecId(), queryQuality.getUnknownDocs());, +, +            if (responseCounter.decrementAndGet() == 0) {, +                listener.onResponse(, +                        new RankEvalResponse(task.getTaskId(), task.getEvaluator().combine(partialResults.values()), unknownDocs));, +            }, +        }, +, +        @Override, +        public void onFailure(Exception exception) {, +            // TODO this fails the complete request. Investigate if maybe we want to collect errors and still return partial result., +            this.listener.onFailure(exception);, +        }]