[+++ b/src/main/java/org/elasticsearch/index/fielddata/plain/DoubleArrayIndexFieldData.java, +import org.elasticsearch.common.RamUsage;, +                final FixedBitSet set = builder.buildDocsWithValuesSet();, +, +                // there's sweatspot where due to low unique value count, using ordinals will consume less memory, +                long singleValuesArraySize = reader.maxDoc() * RamUsage.NUM_BYTES_DOUBLE + (set == null ? 0 : set.getBits().length * RamUsage.NUM_BYTES_LONG + RamUsage.NUM_BYTES_INT);, +                long uniqueValuesArraySize = values.size() * RamUsage.NUM_BYTES_DOUBLE;, +                long ordinalsSize = build.getMemorySizeInBytes();, +                if (uniqueValuesArraySize + ordinalsSize < singleValuesArraySize) {, +                    return new DoubleArrayAtomicFieldData.WithOrdinals(values.toArray(new double[values.size()]), reader.maxDoc(), build);, +                }, +, +, +++ b/src/main/java/org/elasticsearch/index/fielddata/plain/DoubleArrayIndexFieldData.java, +import org.elasticsearch.common.RamUsage;, +                final FixedBitSet set = builder.buildDocsWithValuesSet();, +, +                // there's sweatspot where due to low unique value count, using ordinals will consume less memory, +                long singleValuesArraySize = reader.maxDoc() * RamUsage.NUM_BYTES_DOUBLE + (set == null ? 0 : set.getBits().length * RamUsage.NUM_BYTES_LONG + RamUsage.NUM_BYTES_INT);, +                long uniqueValuesArraySize = values.size() * RamUsage.NUM_BYTES_DOUBLE;, +                long ordinalsSize = build.getMemorySizeInBytes();, +                if (uniqueValuesArraySize + ordinalsSize < singleValuesArraySize) {, +                    return new DoubleArrayAtomicFieldData.WithOrdinals(values.toArray(new double[values.size()]), reader.maxDoc(), build);, +                }, +, +, +++ b/src/main/java/org/elasticsearch/index/fielddata/plain/FloatArrayIndexFieldData.java, +import org.elasticsearch.common.RamUsage;, +                final FixedBitSet set = builder.buildDocsWithValuesSet();, +, +                // there's sweatspot where due to low unique value count, using ordinals will consume less memory, +                long singleValuesArraySize = reader.maxDoc() * RamUsage.NUM_BYTES_FLOAT + (set == null ? 0 : set.getBits().length * RamUsage.NUM_BYTES_LONG + RamUsage.NUM_BYTES_INT);, +                long uniqueValuesArraySize = values.size() * RamUsage.NUM_BYTES_FLOAT;, +                long ordinalsSize = build.getMemorySizeInBytes();, +                if (uniqueValuesArraySize + ordinalsSize < singleValuesArraySize) {, +                    return new FloatArrayAtomicFieldData.WithOrdinals(values.toArray(new float[values.size()]), reader.maxDoc(), build);, +                }, +, +++ b/src/main/java/org/elasticsearch/index/fielddata/plain/DoubleArrayIndexFieldData.java, +import org.elasticsearch.common.RamUsage;, +                final FixedBitSet set = builder.buildDocsWithValuesSet();, +, +                // there's sweatspot where due to low unique value count, using ordinals will consume less memory, +                long singleValuesArraySize = reader.maxDoc() * RamUsage.NUM_BYTES_DOUBLE + (set == null ? 0 : set.getBits().length * RamUsage.NUM_BYTES_LONG + RamUsage.NUM_BYTES_INT);, +                long uniqueValuesArraySize = values.size() * RamUsage.NUM_BYTES_DOUBLE;, +                long ordinalsSize = build.getMemorySizeInBytes();, +                if (uniqueValuesArraySize + ordinalsSize < singleValuesArraySize) {, +                    return new DoubleArrayAtomicFieldData.WithOrdinals(values.toArray(new double[values.size()]), reader.maxDoc(), build);, +                }, +, +, +++ b/src/main/java/org/elasticsearch/index/fielddata/plain/FloatArrayIndexFieldData.java, +import org.elasticsearch.common.RamUsage;, +                final FixedBitSet set = builder.buildDocsWithValuesSet();, +, +                // there's sweatspot where due to low unique value count, using ordinals will consume less memory, +                long singleValuesArraySize = reader.maxDoc() * RamUsage.NUM_BYTES_FLOAT + (set == null ? 0 : set.getBits().length * RamUsage.NUM_BYTES_LONG + RamUsage.NUM_BYTES_INT);, +                long uniqueValuesArraySize = values.size() * RamUsage.NUM_BYTES_FLOAT;, +                long ordinalsSize = build.getMemorySizeInBytes();, +                if (uniqueValuesArraySize + ordinalsSize < singleValuesArraySize) {, +                    return new FloatArrayAtomicFieldData.WithOrdinals(values.toArray(new float[values.size()]), reader.maxDoc(), build);, +                }, +, +++ b/src/main/java/org/elasticsearch/index/fielddata/plain/IntArrayIndexFieldData.java, +import org.elasticsearch.common.RamUsage;, +, +                        @Override, +                        public int size() {, +                            return values.size();, +                        }, +, +                @Override, +                public int size() {, +                    return values.size();, +                }, +, +        int size();, +            final FixedBitSet set = builder.buildDocsWithValuesSet();, +, +            // there's sweatspot where due to low unique value count, using ordinals will consume less memory, +            long singleValuesArraySize = reader.maxDoc() * RamUsage.NUM_BYTES_INT + (set == null ? 0 : set.getBits().length * RamUsage.NUM_BYTES_LONG + RamUsage.NUM_BYTES_INT);, +            long uniqueValuesArraySize = values.size() * RamUsage.NUM_BYTES_INT;, +            long ordinalsSize = build.getMemorySizeInBytes();, +            if (uniqueValuesArraySize + ordinalsSize < singleValuesArraySize) {, +                return new IntArrayAtomicFieldData.WithOrdinals(values.toArray(), reader.maxDoc(), build);, +            }, +, +++ b/src/main/java/org/elasticsearch/index/fielddata/plain/DoubleArrayIndexFieldData.java, +import org.elasticsearch.common.RamUsage;, +                final FixedBitSet set = builder.buildDocsWithValuesSet();, +, +                // there's sweatspot where due to low unique value count, using ordinals will consume less memory, +                long singleValuesArraySize = reader.maxDoc() * RamUsage.NUM_BYTES_DOUBLE + (set == null ? 0 : set.getBits().length * RamUsage.NUM_BYTES_LONG + RamUsage.NUM_BYTES_INT);, +                long uniqueValuesArraySize = values.size() * RamUsage.NUM_BYTES_DOUBLE;, +                long ordinalsSize = build.getMemorySizeInBytes();, +                if (uniqueValuesArraySize + ordinalsSize < singleValuesArraySize) {, +                    return new DoubleArrayAtomicFieldData.WithOrdinals(values.toArray(new double[values.size()]), reader.maxDoc(), build);, +                }, +, +]