[+++ b/src/main/java/org/elasticsearch/index/search/nested/NestedFieldComparatorSource.java, +package org.elasticsearch.index.search.nested;, +, +import org.apache.lucene.index.AtomicReaderContext;, +import org.apache.lucene.search.DocIdSet;, +import org.apache.lucene.search.FieldComparator;, +import org.apache.lucene.search.Filter;, +import org.apache.lucene.search.SortField;, +import org.apache.lucene.util.FixedBitSet;, +import org.elasticsearch.ElasticSearchIllegalArgumentException;, +import org.elasticsearch.common.lucene.docset.DocIdSets;, +import org.elasticsearch.index.fielddata.IndexFieldData;, +import org.elasticsearch.index.fielddata.fieldcomparator.SortMode;, +, +import java.io.IOException;, +, +/**, + */, +public class NestedFieldComparatorSource extends IndexFieldData.XFieldComparatorSource {, +, +    private final SortMode sortMode;, +    private final IndexFieldData.XFieldComparatorSource wrappedSource;, +    private final Filter rootDocumentsFilter;, +    private final Filter innerDocumentsFilter;, +, +    public NestedFieldComparatorSource(SortMode sortMode, IndexFieldData.XFieldComparatorSource wrappedSource, Filter rootDocumentsFilter, Filter innerDocumentsFilter) {, +        this.sortMode = sortMode;, +        this.wrappedSource = wrappedSource;, +        this.rootDocumentsFilter = rootDocumentsFilter;, +        this.innerDocumentsFilter = innerDocumentsFilter;, +    }, +, +    @Override, +    public FieldComparator<?> newComparator(String fieldname, int numHits, int sortPos, boolean reversed) throws IOException {, +        // +1: have one spare slot for value comparison between inner documents., +        FieldComparator wrappedComparator = wrappedSource.newComparator(fieldname, numHits + 1, sortPos, reversed);, +        switch (sortMode) {, +            case MAX:, +                return new NestedFieldComparator.Highest(wrappedComparator, rootDocumentsFilter, innerDocumentsFilter, numHits);, +            case MIN:, +                return new NestedFieldComparator.Lowest(wrappedComparator, rootDocumentsFilter, innerDocumentsFilter, numHits);, +            default:, +                throw new ElasticSearchIllegalArgumentException(, +                        String.format("Unsupported sort_mode[%s] for nested type", sortMode), +                );, +        }, +    }, +, +    @Override, +    public SortField.Type reducedType() {, +        return wrappedSource.reducedType();, +    }, +}, +, +abstract class NestedFieldComparator extends FieldComparator {, +, +    final Filter rootDocumentsFilter;, +    final Filter innerDocumentsFilter;, +    final int spareSlot;, +, +    FieldComparator wrappedComparator;, +    FixedBitSet rootDocuments;, +    FixedBitSet innerDocuments;, +, +    NestedFieldComparator(FieldComparator wrappedComparator, Filter rootDocumentsFilter, Filter innerDocumentsFilter, int spareSlot) {, +        this.wrappedComparator = wrappedComparator;, +        this.rootDocumentsFilter = rootDocumentsFilter;, +        this.innerDocumentsFilter = innerDocumentsFilter;, +        this.spareSlot = spareSlot;, +    }, +, +    @Override, +    public int compare(int slot1, int slot2) {, +        return wrappedComparator.compare(slot1, slot2);, +    }, +, +    @Override, +    public void setBottom(int slot) {, +        wrappedComparator.setBottom(slot);, +    }, +, +    @Override, +    public FieldComparator setNextReader(AtomicReaderContext context) throws IOException {, +        DocIdSet innerDocuments = innerDocumentsFilter.getDocIdSet(context, null);, +        if (DocIdSets.isEmpty(innerDocuments)) {, +            this.innerDocuments = null;, +        } else if (innerDocuments instanceof FixedBitSet) {, +            this.innerDocuments = (FixedBitSet) innerDocuments;, +        } else {, +            this.innerDocuments = DocIdSets.toFixedBitSet(innerDocuments.iterator(), context.reader().maxDoc());, +        }, +        DocIdSet rootDocuments = rootDocumentsFilter.getDocIdSet(context, null);, +        if (DocIdSets.isEmpty(rootDocuments)) {, +            this.rootDocuments = null;, +        } else if (rootDocuments instanceof FixedBitSet) {, +            this.rootDocuments = (FixedBitSet) rootDocuments;, +        } else {, +            this.rootDocuments = DocIdSets.toFixedBitSet(rootDocuments.iterator(), context.reader().maxDoc());, +        }, +]