[+++ b/modules/elasticsearch/src/main/java/org/elasticsearch/action/TransportActionModule.java, +import org.elasticsearch.action.delete.index.TransportIndexDeleteAction;, +import org.elasticsearch.action.delete.index.TransportShardDeleteAction;, +        bind(TransportIndexDeleteAction.class).asEagerSingleton();, +        bind(TransportShardDeleteAction.class).asEagerSingleton();, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/action/TransportActionModule.java, +import org.elasticsearch.action.delete.index.TransportIndexDeleteAction;, +import org.elasticsearch.action.delete.index.TransportShardDeleteAction;, +        bind(TransportIndexDeleteAction.class).asEagerSingleton();, +        bind(TransportShardDeleteAction.class).asEagerSingleton();, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/action/delete/TransportDeleteAction.java, +import org.elasticsearch.action.delete.index.IndexDeleteRequest;, +import org.elasticsearch.action.delete.index.IndexDeleteResponse;, +import org.elasticsearch.action.delete.index.TransportIndexDeleteAction;, +import org.elasticsearch.cluster.metadata.MappingMetaData;, +    private final TransportIndexDeleteAction indexDeleteAction;, +, +                                         TransportCreateIndexAction createIndexAction, TransportIndexDeleteAction indexDeleteAction) {, +        this.indexDeleteAction = indexDeleteAction;, +                    innerExecute(deleteRequest, listener);, +                        innerExecute(deleteRequest, listener);, +            innerExecute(deleteRequest, listener);, +    private void innerExecute(final DeleteRequest request, final ActionListener<DeleteResponse> listener) {, +        ClusterState clusterState = clusterService.state();, +        request.index(clusterState.metaData().concreteIndex(request.index())); // we need to get the concrete index here..., +        if (clusterState.metaData().hasIndex(request.index())) {, +            // check if routing is required, if so, do a broadcast delete, +            MappingMetaData mappingMd = clusterState.metaData().index(request.index()).mapping(request.type());, +            if (mappingMd != null && mappingMd.routing().required()) {, +                if (request.routing() == null) {, +                    indexDeleteAction.execute(new IndexDeleteRequest(request), new ActionListener<IndexDeleteResponse>() {, +                        @Override public void onResponse(IndexDeleteResponse indexDeleteResponse) {, +                            listener.onResponse(new DeleteResponse(request.index(), request.type(), request.id()));, +                        }, +, +                        @Override public void onFailure(Throwable e) {, +                            listener.onFailure(e);, +                        }, +                    });, +                    return;, +                }, +            }, +        }, +        super.doExecute(request, listener);, +    }, +, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/action/TransportActionModule.java, +import org.elasticsearch.action.delete.index.TransportIndexDeleteAction;, +import org.elasticsearch.action.delete.index.TransportShardDeleteAction;, +        bind(TransportIndexDeleteAction.class).asEagerSingleton();, +        bind(TransportShardDeleteAction.class).asEagerSingleton();, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/action/delete/TransportDeleteAction.java, +import org.elasticsearch.action.delete.index.IndexDeleteRequest;, +import org.elasticsearch.action.delete.index.IndexDeleteResponse;, +import org.elasticsearch.action.delete.index.TransportIndexDeleteAction;, +import org.elasticsearch.cluster.metadata.MappingMetaData;, +    private final TransportIndexDeleteAction indexDeleteAction;, +, +                                         TransportCreateIndexAction createIndexAction, TransportIndexDeleteAction indexDeleteAction) {, +        this.indexDeleteAction = indexDeleteAction;, +                    innerExecute(deleteRequest, listener);, +                        innerExecute(deleteRequest, listener);, +            innerExecute(deleteRequest, listener);, +    private void innerExecute(final DeleteRequest request, final ActionListener<DeleteResponse> listener) {, +        ClusterState clusterState = clusterService.state();, +        request.index(clusterState.metaData().concreteIndex(request.index())); // we need to get the concrete index here..., +        if (clusterState.metaData().hasIndex(request.index())) {, +            // check if routing is required, if so, do a broadcast delete, +            MappingMetaData mappingMd = clusterState.metaData().index(request.index()).mapping(request.type());, +            if (mappingMd != null && mappingMd.routing().required()) {, +                if (request.routing() == null) {, +                    indexDeleteAction.execute(new IndexDeleteRequest(request), new ActionListener<IndexDeleteResponse>() {, +                        @Override public void onResponse(IndexDeleteResponse indexDeleteResponse) {, +                            listener.onResponse(new DeleteResponse(request.index(), request.type(), request.id()));, +                        }, +, +                        @Override public void onFailure(Throwable e) {, +                            listener.onFailure(e);, +                        }, +                    });, +                    return;, +                }, +            }, +        }, +        super.doExecute(request, listener);, +    }, +, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/action/delete/index/IndexDeleteRequest.java, +/*, + * Licensed to Elastic Search and Shay Banon under one, + * or more contributor license agreements.  See the NOTICE file, + * distributed with this work for additional information, + * regarding copyright ownership. Elastic Search licenses this, + * file to you under the Apache License, Version 2.0 (the, + * "License"); you may not use this file except in compliance, + * with the License.  You may obtain a copy of the License at, + *, + *    http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing,]