[+++ b/src/main/java/org/elasticsearch/action/index/IndexRequest.java, +    public BytesHolder underlyingSourceBytes() {, +        return new BytesHolder(underlyingSource(), underlyingSourceOffset(), underlyingSourceLength());, +    }, +, +++ b/src/main/java/org/elasticsearch/action/index/IndexRequest.java, +    public BytesHolder underlyingSourceBytes() {, +        return new BytesHolder(underlyingSource(), underlyingSourceOffset(), underlyingSourceLength());, +    }, +, +++ b/src/main/java/org/elasticsearch/action/update/TransportUpdateAction.java, +import org.elasticsearch.common.BytesHolder;, +import org.elasticsearch.common.Nullable;, +        final GetResult getResult = indexShard.getService().get(request.type(), request.id(),, +        ctx.put("_source", sourceAndContent.v2());, +        final Map<String, Object> updatedSourceAsMap = (Map<String, Object>) ctx.get("_source");, +        final XContentType updateSourceContentType = sourceAndContent.v1();, +            final IndexRequest indexRequest = Requests.indexRequest(request.index()).type(request.type()).id(request.id()).routing(routing).parent(parent), +                    .source(updatedSourceAsMap, updateSourceContentType), +            // we fetch it from the index request so we don't generate the bytes twice, its already done in the index request, +            final BytesHolder updateSourceBytes = indexRequest.underlyingSourceBytes();, +                    update.getResult(extractGetResult(request, response.version(), updatedSourceAsMap, updateSourceContentType, updateSourceBytes));, +                    update.getResult(extractGetResult(request, response.version(), updatedSourceAsMap, updateSourceContentType, null));, +            update.getResult(extractGetResult(request, getResult.version(), updatedSourceAsMap, updateSourceContentType, null));, +, +    @Nullable, +    protected GetResult extractGetResult(final UpdateRequest request, long version, final Map<String, Object> source, XContentType sourceContentType, @Nullable final BytesHolder sourceAsBytes) {, +        if (request.fields() == null || request.fields().length == 0) {, +            return null;, +        }, +        boolean sourceRequested = false;, +        Map<String, GetField> fields = null;, +        if (request.fields() != null && request.fields().length > 0) {, +            SourceLookup sourceLookup = new SourceLookup();, +            sourceLookup.setNextSource(source);, +            for (String field : request.fields()) {, +                if (field.equals("_source")) {, +                    sourceRequested = true;, +                    continue;, +                }, +                Object value = sourceLookup.extractValue(field);, +                if (value != null) {, +                    if (fields == null) {, +                        fields = newHashMapWithExpectedSize(2);, +                    }, +                    GetField getField = fields.get(field);, +                    if (getField == null) {, +                        getField = new GetField(field, new ArrayList<Object>(2));, +                        fields.put(field, getField);, +                    }, +                    getField.values().add(value);, +                }, +            }, +        }, +, +        // TODO when using delete/none, we can still return the source as bytes by generating it (using the sourceContentType), +, +        return new GetResult(request.index(), request.type(), request.id(), version, true, sourceRequested ? sourceAsBytes : null, fields);, +    }, +++ b/src/main/java/org/elasticsearch/action/index/IndexRequest.java, +    public BytesHolder underlyingSourceBytes() {, +        return new BytesHolder(underlyingSource(), underlyingSourceOffset(), underlyingSourceLength());, +    }, +, +++ b/src/main/java/org/elasticsearch/action/update/TransportUpdateAction.java, +import org.elasticsearch.common.BytesHolder;, +import org.elasticsearch.common.Nullable;, +        final GetResult getResult = indexShard.getService().get(request.type(), request.id(),, +        ctx.put("_source", sourceAndContent.v2());, +        final Map<String, Object> updatedSourceAsMap = (Map<String, Object>) ctx.get("_source");, +        final XContentType updateSourceContentType = sourceAndContent.v1();, +            final IndexRequest indexRequest = Requests.indexRequest(request.index()).type(request.type()).id(request.id()).routing(routing).parent(parent), +                    .source(updatedSourceAsMap, updateSourceContentType), +            // we fetch it from the index request so we don't generate the bytes twice, its already done in the index request, +            final BytesHolder updateSourceBytes = indexRequest.underlyingSourceBytes();, +                    update.getResult(extractGetResult(request, response.version(), updatedSourceAsMap, updateSourceContentType, updateSourceBytes));, +                    update.getResult(extractGetResult(request, response.version(), updatedSourceAsMap, updateSourceContentType, null));, +            update.getResult(extractGetResult(request, getResult.version(), updatedSourceAsMap, updateSourceContentType, null));, +, +    @Nullable, +    protected GetResult extractGetResult(final UpdateRequest request, long version, final Map<String, Object> source, XContentType sourceContentType, @Nullable final BytesHolder sourceAsBytes) {, +        if (request.fields() == null || request.fields().length == 0) {, +            return null;, +        }, +        boolean sourceRequested = false;, +        Map<String, GetField> fields = null;, +        if (request.fields() != null && request.fields().length > 0) {, +            SourceLookup sourceLookup = new SourceLookup();, +            sourceLookup.setNextSource(source);, +            for (String field : request.fields()) {, +                if (field.equals("_source")) {, +                    sourceRequested = true;, +                    continue;, +                }, +                Object value = sourceLookup.extractValue(field);, +                if (value != null) {, +                    if (fields == null) {, +                        fields = newHashMapWithExpectedSize(2);, +                    }, +                    GetField getField = fields.get(field);]