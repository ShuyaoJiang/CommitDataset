[+++ b/core/src/main/java/org/elasticsearch/repositories/blobstore/BlobStoreRepository.java, +import java.nio.file.FileAlreadyExistsException;, +, +            startTime, failure, System.currentTimeMillis(), totalShards, shardFailures);, +        try {, +        } catch (FileAlreadyExistsException ex) {, +            // if another master was elected and took over finalizing the snapshot, it is possible, +            // that both nodes try to finalize the snapshot and write to the same blobs, so we just, +            // log a warning here and carry on, +            throw new RepositoryException(metadata.name(), "Blob already exists while " +, +                "finalizing snapshot, assume the snapshot has already been saved", ex);, +        return blobStoreSnapshot;, +++ b/core/src/main/java/org/elasticsearch/repositories/blobstore/BlobStoreRepository.java, +import java.nio.file.FileAlreadyExistsException;, +, +            startTime, failure, System.currentTimeMillis(), totalShards, shardFailures);, +        try {, +        } catch (FileAlreadyExistsException ex) {, +            // if another master was elected and took over finalizing the snapshot, it is possible, +            // that both nodes try to finalize the snapshot and write to the same blobs, so we just, +            // log a warning here and carry on, +            throw new RepositoryException(metadata.name(), "Blob already exists while " +, +                "finalizing snapshot, assume the snapshot has already been saved", ex);, +        return blobStoreSnapshot;, +++ b/core/src/main/java/org/elasticsearch/snapshots/SnapshotsService.java, +++ b/core/src/main/java/org/elasticsearch/repositories/blobstore/BlobStoreRepository.java, +import java.nio.file.FileAlreadyExistsException;, +, +            startTime, failure, System.currentTimeMillis(), totalShards, shardFailures);, +        try {, +        } catch (FileAlreadyExistsException ex) {, +            // if another master was elected and took over finalizing the snapshot, it is possible, +            // that both nodes try to finalize the snapshot and write to the same blobs, so we just, +            // log a warning here and carry on, +            throw new RepositoryException(metadata.name(), "Blob already exists while " +, +                "finalizing snapshot, assume the snapshot has already been saved", ex);, +        return blobStoreSnapshot;, +++ b/core/src/main/java/org/elasticsearch/snapshots/SnapshotsService.java, +++ b/core/src/test/java/org/elasticsearch/snapshots/AbstractSnapshotIntegTestCase.java, +    public static String blockMasterFromFinalizingSnapshot(final String repositoryName) {, +        final String masterName = internalCluster().getMasterName();, +        ((MockRepository)internalCluster().getInstance(RepositoriesService.class, masterName), +            .repository(repositoryName)).setBlockOnWriteIndexFile(true);, +        return masterName;, +    }, +, +++ b/core/src/main/java/org/elasticsearch/repositories/blobstore/BlobStoreRepository.java, +import java.nio.file.FileAlreadyExistsException;, +, +            startTime, failure, System.currentTimeMillis(), totalShards, shardFailures);, +        try {, +        } catch (FileAlreadyExistsException ex) {, +            // if another master was elected and took over finalizing the snapshot, it is possible, +            // that both nodes try to finalize the snapshot and write to the same blobs, so we just, +            // log a warning here and carry on, +            throw new RepositoryException(metadata.name(), "Blob already exists while " +, +                "finalizing snapshot, assume the snapshot has already been saved", ex);, +        return blobStoreSnapshot;, +++ b/core/src/main/java/org/elasticsearch/snapshots/SnapshotsService.java, +++ b/core/src/test/java/org/elasticsearch/snapshots/AbstractSnapshotIntegTestCase.java, +    public static String blockMasterFromFinalizingSnapshot(final String repositoryName) {, +        final String masterName = internalCluster().getMasterName();, +        ((MockRepository)internalCluster().getInstance(RepositoriesService.class, masterName), +            .repository(repositoryName)).setBlockOnWriteIndexFile(true);, +        return masterName;, +    }, +, +++ b/core/src/test/java/org/elasticsearch/snapshots/DedicatedClusterSnapshotRestoreIT.java, +import org.elasticsearch.cluster.SnapshotsInProgress;, +import org.elasticsearch.cluster.health.ClusterHealthStatus;, +    public void testMasterShutdownDuringFailedSnapshot() throws Exception {, +        logger.info("-->  starting two master nodes and two data nodes");, +        internalCluster().startMasterOnlyNodes(2);, +        internalCluster().startDataOnlyNodes(2);, +, +        logger.info("-->  creating repository");, +        assertAcked(client().admin().cluster().preparePutRepository("test-repo"), +            .setType("mock").setSettings(Settings.builder(), +                .put("location", randomRepoPath()), +                .put("compress", randomBoolean()), +                .put("chunk_size", randomIntBetween(100, 1000), ByteSizeUnit.BYTES)));, +, +        assertAcked(prepareCreate("test-idx", 0, Settings.builder(), +            .put("number_of_shards", 6).put("number_of_replicas", 0)));, +        ensureGreen();, +, +        logger.info("-->  indexing some data");, +        final int numdocs = randomIntBetween(50, 100);, +        IndexRequestBuilder[] builders = new IndexRequestBuilder[numdocs];, +        for (int i = 0; i < builders.length; i++) {, +            builders[i] = client().prepareIndex("test-idx", "type1",, +                Integer.toString(i)).setSource("field1", "bar " + i);, +        }, +        indexRandom(true, builders);, +        flushAndRefresh();, +, +        logger.info("-->  stopping random data node, which should cause shards to go missing");, +        internalCluster().stopRandomDataNode();, +        assertBusy(() ->, +            assertEquals(ClusterHealthStatus.RED, client().admin().cluster().prepareHealth().get().getStatus()),]