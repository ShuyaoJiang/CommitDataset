[+++ b/build.gradle, +import org.elasticsearch.gradle.LoggedExec, +import java.nio.file.Files, +static void assertLinesInFile(final Path path, final List<String> expectedLines) {, +  final List<String> actualLines = Files.readAllLines(path), +  int line = 0, +  for (final String expectedLine : expectedLines) {, +    final String actualLine = actualLines.get(line), +    if (expectedLine != actualLine) {, +      throw new GradleException("expected line [${line + 1}] in [${path}] to be [${expectedLine}] but was [${actualLine}]"), +    }, +    line++, +  }, +}, +, +/*, + * Check that all generated JARs have our NOTICE.txt and an appropriate, + * LICENSE.txt in them. We configurate this in gradle but we'd like to, + * be extra paranoid., + */, +subprojects { project ->, +  project.tasks.withType(Jar).whenTaskAdded { jarTask ->, +    final Task extract = project.task("extract${jarTask.name.capitalize()}", type: LoggedExec) {, +      dependsOn jarTask, +      ext.destination = project.buildDir.toPath().resolve("jar-extracted/${jarTask.name}"), +      commandLine "${->new File(rootProject.compilerJavaHome, 'bin/jar')}",, +          'xf', "${-> jarTask.outputs.files.singleFile}", 'META-INF/LICENSE.txt', 'META-INF/NOTICE.txt', +      workingDir destination, +      doFirst {, +        project.delete(destination), +        Files.createDirectories(destination), +      }, +    }, +, +    final Task checkNotice = project.task("verify${jarTask.name.capitalize()}Notice") {, +      dependsOn extract, +      doLast {, +        final List<String> noticeLines = Files.readAllLines(project.noticeFile.toPath()), +        final Path noticePath = extract.destination.resolve('META-INF/NOTICE.txt'), +        assertLinesInFile(noticePath, noticeLines), +      }, +    }, +    project.check.dependsOn checkNotice, +, +    final Task checkLicense = project.task("verify${jarTask.name.capitalize()}License") {, +      dependsOn extract, +      doLast {, +        final List<String> licenseLines = Files.readAllLines(project.licenseFile.toPath()), +        final Path licensePath = extract.destination.resolve('META-INF/LICENSE.txt'), +        assertLinesInFile(licensePath, licenseLines), +      }, +    }, +    project.check.dependsOn checkLicense, +  }, +}, +, +++ b/build.gradle, +import org.elasticsearch.gradle.LoggedExec, +import java.nio.file.Files, +static void assertLinesInFile(final Path path, final List<String> expectedLines) {, +  final List<String> actualLines = Files.readAllLines(path), +  int line = 0, +  for (final String expectedLine : expectedLines) {, +    final String actualLine = actualLines.get(line), +    if (expectedLine != actualLine) {, +      throw new GradleException("expected line [${line + 1}] in [${path}] to be [${expectedLine}] but was [${actualLine}]"), +    }, +    line++, +  }, +}, +, +/*, + * Check that all generated JARs have our NOTICE.txt and an appropriate, + * LICENSE.txt in them. We configurate this in gradle but we'd like to, + * be extra paranoid., + */, +subprojects { project ->, +  project.tasks.withType(Jar).whenTaskAdded { jarTask ->, +    final Task extract = project.task("extract${jarTask.name.capitalize()}", type: LoggedExec) {, +      dependsOn jarTask, +      ext.destination = project.buildDir.toPath().resolve("jar-extracted/${jarTask.name}"), +      commandLine "${->new File(rootProject.compilerJavaHome, 'bin/jar')}",, +          'xf', "${-> jarTask.outputs.files.singleFile}", 'META-INF/LICENSE.txt', 'META-INF/NOTICE.txt', +      workingDir destination, +      doFirst {, +        project.delete(destination), +        Files.createDirectories(destination), +      }, +    }, +, +    final Task checkNotice = project.task("verify${jarTask.name.capitalize()}Notice") {, +      dependsOn extract, +      doLast {, +        final List<String> noticeLines = Files.readAllLines(project.noticeFile.toPath()), +        final Path noticePath = extract.destination.resolve('META-INF/NOTICE.txt'), +        assertLinesInFile(noticePath, noticeLines), +      }, +    }, +    project.check.dependsOn checkNotice, +]