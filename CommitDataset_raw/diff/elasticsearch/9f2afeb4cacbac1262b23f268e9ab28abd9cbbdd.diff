[+++ b/modules/elasticsearch/src/main/java/org/elasticsearch/transport/ReceiveTimeoutTransportException.java, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/transport/ReceiveTimeoutTransportException.java, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/transport/TransportService.java, +import java.util.concurrent.ScheduledFuture;, +    public TransportService(Transport transport, ThreadPool threadPool) {, +        this(EMPTY_SETTINGS, transport, threadPool);, +    @Inject public TransportService(Settings settings, Transport transport, ThreadPool threadPool) {, +        TimeoutHandler timeoutHandler = null;, +                timeoutHandler = new TimeoutHandler(requestId);, +                timeoutHandler.future = threadPool.schedule(timeoutHandler, options.timeout(), ThreadPool.ExecutionType.THREADED);, +            clientHandlers.put(requestId, new RequestHolder<T>(handler, node, action, timeoutHandler));, +            if (timeoutHandler != null) {, +                timeoutHandler.future.cancel(false);, +                    long time = System.currentTimeMillis();, +                    logger.warn("Received response for a request that has timed out, sent [{}ms] ago, timed out [{}ms] ago, action [{}], node [{}], id [{}]", time - timeoutInfoHolder.sentTime(), time - timeoutInfoHolder.timeoutTime(), timeoutInfoHolder.action(), timeoutInfoHolder.node(), requestId);, +            holder.cancel();, +    class TimeoutHandler implements Runnable {, +        private final long sentTime = System.currentTimeMillis();, +, +        ScheduledFuture future;, +, +        TimeoutHandler(long requestId) {, +        public long sentTime() {, +            return sentTime;, +        }, +, +        @Override public void run() {, +            if (future.isCancelled()) {, +                long timeoutTime = System.currentTimeMillis();, +                timeoutInfoHandlers.put(requestId, new TimeoutInfoHolder(holder.node(), holder.action(), sentTime, timeoutTime));, +                holder.handler().handleException(new ReceiveTimeoutTransportException(holder.node(), holder.action(), "request_id [" + requestId + "] timed out after [" + (timeoutTime - sentTime) + "ms]"));, +        private final long sentTime;, +, +        private final long timeoutTime;, +, +        TimeoutInfoHolder(DiscoveryNode node, String action, long sentTime, long timeoutTime) {, +            this.sentTime = sentTime;, +            this.timeoutTime = timeoutTime;, +, +        public long sentTime() {, +            return sentTime;, +        }, +, +        public long timeoutTime() {, +            return timeoutTime;, +        }, +        private final TimeoutHandler timeout;, +        RequestHolder(TransportResponseHandler<T> handler, DiscoveryNode node, String action, TimeoutHandler timeout) {, +        public void cancel() {, +            if (timeout != null) {, +                timeout.future.cancel(false);, +            }, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/transport/ReceiveTimeoutTransportException.java, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/transport/TransportService.java, +import java.util.concurrent.ScheduledFuture;, +    public TransportService(Transport transport, ThreadPool threadPool) {, +        this(EMPTY_SETTINGS, transport, threadPool);, +    @Inject public TransportService(Settings settings, Transport transport, ThreadPool threadPool) {, +        TimeoutHandler timeoutHandler = null;, +                timeoutHandler = new TimeoutHandler(requestId);, +                timeoutHandler.future = threadPool.schedule(timeoutHandler, options.timeout(), ThreadPool.ExecutionType.THREADED);, +            clientHandlers.put(requestId, new RequestHolder<T>(handler, node, action, timeoutHandler));, +            if (timeoutHandler != null) {, +                timeoutHandler.future.cancel(false);, +                    long time = System.currentTimeMillis();, +                    logger.warn("Received response for a request that has timed out, sent [{}ms] ago, timed out [{}ms] ago, action [{}], node [{}], id [{}]", time - timeoutInfoHolder.sentTime(), time - timeoutInfoHolder.timeoutTime(), timeoutInfoHolder.action(), timeoutInfoHolder.node(), requestId);, +            holder.cancel();, +    class TimeoutHandler implements Runnable {, +        private final long sentTime = System.currentTimeMillis();, +, +        ScheduledFuture future;, +, +        TimeoutHandler(long requestId) {, +        public long sentTime() {, +            return sentTime;, +        }, +, +        @Override public void run() {, +            if (future.isCancelled()) {, +                long timeoutTime = System.currentTimeMillis();, +                timeoutInfoHandlers.put(requestId, new TimeoutInfoHolder(holder.node(), holder.action(), sentTime, timeoutTime));, +                holder.handler().handleException(new ReceiveTimeoutTransportException(holder.node(), holder.action(), "request_id [" + requestId + "] timed out after [" + (timeoutTime - sentTime) + "ms]"));, +        private final long sentTime;, +, +        private final long timeoutTime;, +, +        TimeoutInfoHolder(DiscoveryNode node, String action, long sentTime, long timeoutTime) {, +            this.sentTime = sentTime;, +            this.timeoutTime = timeoutTime;, +, +        public long sentTime() {, +            return sentTime;, +        }, +, +        public long timeoutTime() {, +            return timeoutTime;, +        }, +        private final TimeoutHandler timeout;, +        RequestHolder(TransportResponseHandler<T> handler, DiscoveryNode node, String action, TimeoutHandler timeout) {, +        public void cancel() {]