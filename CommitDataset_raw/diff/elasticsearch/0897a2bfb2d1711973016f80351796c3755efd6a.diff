[+++ b/x-pack/plugin/ilm/qa/multi-node/src/test/java/org/elasticsearch/xpack/indexlifecycle/TimeSeriesLifecycleActionsIT.java, +    public void testCanStopILMWithPolicyUsingNonexistentPolicy() throws Exception {, +        createIndexWithSettings(index, Settings.builder().put(IndexMetaData.SETTING_NUMBER_OF_SHARDS, 1), +            .put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, 0), +            .put(LifecycleSettings.LIFECYCLE_NAME_SETTING.getKey(), randomAlphaOfLengthBetween(5,15)));, +, +        Request stopILMRequest = new Request("POST", "_ilm/stop");, +        assertOK(client().performRequest(stopILMRequest));, +, +        Request statusRequest = new Request("GET", "_ilm/status");, +        assertBusy(() -> {, +            Response statusResponse = client().performRequest(statusRequest);, +            assertOK(statusResponse);, +            Map<String, Object> statusResponseMap = entityAsMap(statusResponse);, +            String status = (String) statusResponseMap.get("operation_mode");, +            assertEquals("STOPPED", status);, +        });, +, +        // Re-start ILM so that subsequent tests don't fail, +        Request startILMReqest = new Request("POST", "_ilm/start");, +        assertOK(client().performRequest(startILMReqest));, +    }, +, +++ b/x-pack/plugin/ilm/qa/multi-node/src/test/java/org/elasticsearch/xpack/indexlifecycle/TimeSeriesLifecycleActionsIT.java, +    public void testCanStopILMWithPolicyUsingNonexistentPolicy() throws Exception {, +        createIndexWithSettings(index, Settings.builder().put(IndexMetaData.SETTING_NUMBER_OF_SHARDS, 1), +            .put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, 0), +            .put(LifecycleSettings.LIFECYCLE_NAME_SETTING.getKey(), randomAlphaOfLengthBetween(5,15)));, +, +        Request stopILMRequest = new Request("POST", "_ilm/stop");, +        assertOK(client().performRequest(stopILMRequest));, +, +        Request statusRequest = new Request("GET", "_ilm/status");, +        assertBusy(() -> {, +            Response statusResponse = client().performRequest(statusRequest);, +            assertOK(statusResponse);, +            Map<String, Object> statusResponseMap = entityAsMap(statusResponse);, +            String status = (String) statusResponseMap.get("operation_mode");, +            assertEquals("STOPPED", status);, +        });, +, +        // Re-start ILM so that subsequent tests don't fail, +        Request startILMReqest = new Request("POST", "_ilm/start");, +        assertOK(client().performRequest(startILMReqest));, +    }, +, +++ b/x-pack/plugin/ilm/src/main/java/org/elasticsearch/xpack/indexlifecycle/IndexLifecycleService.java, +                    final LifecycleExecutionState lifecycleState = LifecycleExecutionState.fromIndexMetadata(idxMeta);, +                    StepKey stepKey = IndexLifecycleRunner.getCurrentStepKey(lifecycleState);, +, +                    if (OperationMode.STOPPING == currentMode) {, +                        if (stepKey != null && IGNORE_ACTIONS_MAINTENANCE_REQUESTED.contains(stepKey.getAction())) {, +                            logger.info("waiting to stop ILM because index [{}] with policy [{}] is currently in action [{}]",, +                                idxMeta.getIndex().getName(), policyName, stepKey.getAction());, +                            // ILM is trying to stop, but this index is in a Shrink action (or other dangerous action) so we can't stop, +                            safeToStop = false;, +                        } else {, +                            logger.info("skipping policy execution for index [{}] with policy [{}] because ILM is stopping",, +                                idxMeta.getIndex().getName(), policyName);, +                        }, +                    } else {, +                        lifecycleRunner.maybeRunAsyncAction(clusterState, idxMeta, policyName, stepKey);, +            }, +, +                final LifecycleExecutionState lifecycleState = LifecycleExecutionState.fromIndexMetadata(idxMeta);, +                StepKey stepKey = IndexLifecycleRunner.getCurrentStepKey(lifecycleState);, +, +                if (OperationMode.STOPPING == currentMode) {, +                    if (stepKey != null && IGNORE_ACTIONS_MAINTENANCE_REQUESTED.contains(stepKey.getAction())) {, +                        logger.info("waiting to stop ILM because index [{}] with policy [{}] is currently in action [{}]",, +                            idxMeta.getIndex().getName(), policyName, stepKey.getAction());, +                        // ILM is trying to stop, but this index is in a Shrink action (or other dangerous action) so we can't stop, +                        safeToStop = false;, +                    } else {, +                        logger.info("skipping policy execution for index [{}] with policy [{}] because ILM is stopping",, +                            idxMeta.getIndex().getName(), policyName);, +                    }, +                } else {, +                    if (fromClusterStateChange) {, +                        lifecycleRunner.runPolicyAfterStateChange(policyName, idxMeta);, +                    } else {, +                        lifecycleRunner.runPeriodicStep(policyName, idxMeta);, +            }, +        }, +]