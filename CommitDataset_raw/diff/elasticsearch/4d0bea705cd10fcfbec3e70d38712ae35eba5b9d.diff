[+++ b/server/src/main/java/org/elasticsearch/cluster/routing/allocation/decider/DiskThresholdDecider.java, +        ByteSizeValue freeBytesValue = new ByteSizeValue(freeBytes);, +                    logger.debug("less than the required {} free bytes threshold ({} free) on node {}, preventing allocation",, +                            diskThresholdSettings.getFreeBytesThresholdLow(), freeBytesValue, node.nodeId());, +                    diskThresholdSettings.getFreeBytesThresholdLow(), freeBytesValue);, +                    logger.debug("less than the required {} free bytes threshold ({} free) on node {}, " +, +                            diskThresholdSettings.getFreeBytesThresholdLow(), freeBytesValue, node.nodeId());, +                    logger.debug("less than the required {} free bytes threshold ({} free) on node {}, " +, +                            diskThresholdSettings.getFreeBytesThresholdHigh(), freeBytesValue, node.nodeId());, +                    diskThresholdSettings.getFreeBytesThresholdHigh(), freeBytesValue);, +            logger.warn("after allocating, node [{}] would have less than the required threshold of " +, +                    "{} free (currently {} free, estimated shard size is {}), preventing allocation",, +                    node.nodeId(), diskThresholdSettings.getFreeBytesThresholdHigh(), freeBytesValue, new ByteSizeValue(shardSize));, +                    "and cause it to have less than the minimum required [%s] of free space (free: [%s], estimated shard size: [%s])",, +                diskThresholdSettings.getFreeBytesThresholdHigh(),, +                freeBytesValue, new ByteSizeValue(shardSize));, +                freeBytesValue,, +++ b/server/src/main/java/org/elasticsearch/cluster/routing/allocation/decider/DiskThresholdDecider.java, +        ByteSizeValue freeBytesValue = new ByteSizeValue(freeBytes);, +                    logger.debug("less than the required {} free bytes threshold ({} free) on node {}, preventing allocation",, +                            diskThresholdSettings.getFreeBytesThresholdLow(), freeBytesValue, node.nodeId());, +                    diskThresholdSettings.getFreeBytesThresholdLow(), freeBytesValue);, +                    logger.debug("less than the required {} free bytes threshold ({} free) on node {}, " +, +                            diskThresholdSettings.getFreeBytesThresholdLow(), freeBytesValue, node.nodeId());, +                    logger.debug("less than the required {} free bytes threshold ({} free) on node {}, " +, +                            diskThresholdSettings.getFreeBytesThresholdHigh(), freeBytesValue, node.nodeId());, +                    diskThresholdSettings.getFreeBytesThresholdHigh(), freeBytesValue);, +            logger.warn("after allocating, node [{}] would have less than the required threshold of " +, +                    "{} free (currently {} free, estimated shard size is {}), preventing allocation",, +                    node.nodeId(), diskThresholdSettings.getFreeBytesThresholdHigh(), freeBytesValue, new ByteSizeValue(shardSize));, +                    "and cause it to have less than the minimum required [%s] of free space (free: [%s], estimated shard size: [%s])",, +                diskThresholdSettings.getFreeBytesThresholdHigh(),, +                freeBytesValue, new ByteSizeValue(shardSize));, +                freeBytesValue,, +++ b/server/src/test/java/org/elasticsearch/cluster/routing/allocation/decider/DiskThresholdDeciderUnitTests.java, +import org.elasticsearch.cluster.ClusterName;, +        ClusterState clusterState = ClusterState.builder(ClusterName.CLUSTER_NAME_SETTING.getDefault(Settings.EMPTY)), +            .metaData(metaData).routingTable(routingTable).build();, +    public void testCannotAllocateDueToLackOfDiskResources() {, +        ClusterSettings nss = new ClusterSettings(Settings.EMPTY, ClusterSettings.BUILT_IN_CLUSTER_SETTINGS);, +        DiskThresholdDecider decider = new DiskThresholdDecider(Settings.EMPTY, nss);, +, +        MetaData metaData = MetaData.builder(), +            .put(IndexMetaData.builder("test").settings(settings(Version.CURRENT)).numberOfShards(1).numberOfReplicas(1)), +            .build();, +, +        final Index index = metaData.index("test").getIndex();, +, +        ShardRouting test_0 = ShardRouting.newUnassigned(new ShardId(index, 0), true, EmptyStoreRecoverySource.INSTANCE,, +            new UnassignedInfo(UnassignedInfo.Reason.INDEX_CREATED, "foo"));, +        DiscoveryNode node_0 = new DiscoveryNode("node_0", buildNewFakeTransportAddress(), Collections.emptyMap(),, +            new HashSet<>(Arrays.asList(DiscoveryNode.Role.values())), Version.CURRENT);, +        DiscoveryNode node_1 = new DiscoveryNode("node_1", buildNewFakeTransportAddress(), Collections.emptyMap(),, +            new HashSet<>(Arrays.asList(DiscoveryNode.Role.values())), Version.CURRENT);, +, +        RoutingTable routingTable = RoutingTable.builder(), +            .addAsNew(metaData.index("test")), +            .build();, +, +        ClusterState clusterState = ClusterState.builder(ClusterName.CLUSTER_NAME_SETTING.getDefault(Settings.EMPTY)), +            .metaData(metaData).routingTable(routingTable).build();, +, +        clusterState = ClusterState.builder(clusterState).nodes(DiscoveryNodes.builder(), +            .add(node_0), +            .add(node_1), +        ).build();, +, +        // actual test -- after all that bloat :), +, +        ImmutableOpenMap.Builder<String, DiskUsage> leastAvailableUsages = ImmutableOpenMap.builder();, +        leastAvailableUsages.put("node_0", new DiskUsage("node_0", "node_0", "_na_", 100, 0)); // all full, +        ImmutableOpenMap.Builder<String, DiskUsage> mostAvailableUsage = ImmutableOpenMap.builder();, +        final int freeBytes = randomIntBetween(20, 100);, +        mostAvailableUsage.put("node_0", new DiskUsage("node_0", "node_0", "_na_", 100, freeBytes));, +, +        ImmutableOpenMap.Builder<String, Long> shardSizes = ImmutableOpenMap.builder();, +        // way bigger than available space, +        final long shardSize = randomIntBetween(110, 1000);, +        shardSizes.put("[test][0][p]", shardSize);, +        ClusterInfo clusterInfo = new ClusterInfo(leastAvailableUsages.build(), mostAvailableUsage.build(), shardSizes.build(), ImmutableOpenMap.of());, +        RoutingAllocation allocation = new RoutingAllocation(new AllocationDeciders(Settings.EMPTY, Collections.singleton(decider)),, +            clusterState.getRoutingNodes(), clusterState, clusterInfo, System.nanoTime());, +        allocation.debugDecision(true);, +        Decision decision = decider.canAllocate(test_0, new RoutingNode("node_0", node_0), allocation);, +        assertEquals(Decision.Type.NO, decision.type());, +, +        assertThat(decision.getExplanation(), containsString(, +            "allocating the shard to this node will bring the node above the high watermark cluster setting ", +                +"[cluster.routing.allocation.disk.watermark.high=90%] ", +                + "and cause it to have less than the minimum required [0b] of free space ", +                + "(free: [" + freeBytes + "b], estimated shard size: [" + shardSize + "b])"));, +    }, +, +++ b/server/src/main/java/org/elasticsearch/cluster/routing/allocation/decider/DiskThresholdDecider.java, +        ByteSizeValue freeBytesValue = new ByteSizeValue(freeBytes);, +                    logger.debug("less than the required {} free bytes threshold ({} free) on node {}, preventing allocation",, +                            diskThresholdSettings.getFreeBytesThresholdLow(), freeBytesValue, node.nodeId());, +                    diskThresholdSettings.getFreeBytesThresholdLow(), freeBytesValue);, +                    logger.debug("less than the required {} free bytes threshold ({} free) on node {}, " +, +                            diskThresholdSettings.getFreeBytesThresholdLow(), freeBytesValue, node.nodeId());]