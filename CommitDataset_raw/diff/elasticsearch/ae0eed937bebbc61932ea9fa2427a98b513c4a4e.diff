[+++ b/modules/elasticsearch/src/main/java/org/elasticsearch/action/get/GetResponse.java, +import org.elasticsearch.common.compress.lzf.LZF;, +        if (LZF.isCompressed(source)) {, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/action/get/GetResponse.java, +import org.elasticsearch.common.compress.lzf.LZF;, +        if (LZF.isCompressed(source)) {, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/common/compress/CompressedString.java, +        this.bytes = LZFEncoder.encode(result.result, result.length);, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/action/get/GetResponse.java, +import org.elasticsearch.common.compress.lzf.LZF;, +        if (LZF.isCompressed(source)) {, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/common/compress/CompressedString.java, +        this.bytes = LZFEncoder.encode(result.result, result.length);, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/common/compress/lzf/BufferRecycler.java, +/*, + * Licensed to Elastic Search and Shay Banon under one, + * or more contributor license agreements.  See the NOTICE file, + * distributed with this work for additional information, + * regarding copyright ownership. Elastic Search licenses this, + * file to you under the Apache License, Version 2.0 (the, + * "License"); you may not use this file except in compliance, + * with the License.  You may obtain a copy of the License at, + *, + *    http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing,, + * software distributed under the License is distributed on an, + * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY, + * KIND, either express or implied.  See the License for the, + * specific language governing permissions and limitations, + * under the License., + */, +, +package org.elasticsearch.common.compress.lzf;, +, +import java.lang.ref.SoftReference;, +, +/**, + * Simple helper class to encapsulate details of basic buffer, + * recycling scheme, which helps a lot (as per profiling) for, + * smaller encoding cases., + *, + * @author tatu, + */, +public class BufferRecycler {, +    private final static int MIN_ENCODING_BUFFER = 4000;, +, +    private final static int MIN_OUTPUT_BUFFER = 8000;, +, +    /**, +     * This <code>ThreadLocal</code> contains a {@link java.lang.ref.SoftRerefence}, +     * to a {@link BufferRecycler} used to provide a low-cost, +     * buffer recycling for buffers we need for encoding, decoding., +     */, +    final protected static ThreadLocal<SoftReference<BufferRecycler>> _recyclerRef, +            = new ThreadLocal<SoftReference<BufferRecycler>>();, +, +, +    private byte[] _inputBuffer;, +    private byte[] _outputBuffer;, +, +    private byte[] _decodingBuffer;, +    private byte[] _encodingBuffer;, +, +    private int[] _encodingHash;, +, +, +    /**, +     * Accessor to get thread-local recycler instance, +     */, +    public static BufferRecycler instance() {, +        SoftReference<BufferRecycler> ref = _recyclerRef.get();, +        BufferRecycler br = (ref == null) ? null : ref.get();, +        if (br == null) {, +            br = new BufferRecycler();, +            _recyclerRef.set(new SoftReference<BufferRecycler>(br));, +        }, +        return br;, +    }, +, +    /*, +    ///////////////////////////////////////////////////////////////////////, +    // Buffers for encoding (output), +    ///////////////////////////////////////////////////////////////////////, +     */, +, +    public byte[] allocEncodingBuffer(int minSize) {, +        byte[] buf = _encodingBuffer;, +        if (buf == null || buf.length < minSize) {, +            buf = new byte[Math.max(minSize, MIN_ENCODING_BUFFER)];, +        } else {, +            _encodingBuffer = null;, +        }, +        return buf;, +    }, +, +    public void releaseEncodeBuffer(byte[] buffer) {, +        if (_encodingBuffer == null || buffer.length > _encodingBuffer.length) {, +            _encodingBuffer = buffer;, +        }]