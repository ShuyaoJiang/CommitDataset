[+++ b/core/src/main/java/org/elasticsearch/index/engine/CombinedDeletionPolicy.java, +, +    public TranslogDeletionPolicy getTranslogDeletionPolicy() {, +        return translogDeletionPolicy;, +    }, +++ b/core/src/main/java/org/elasticsearch/index/engine/CombinedDeletionPolicy.java, +, +    public TranslogDeletionPolicy getTranslogDeletionPolicy() {, +        return translogDeletionPolicy;, +    }, +++ b/core/src/main/java/org/elasticsearch/index/engine/InternalEngine.java, +            final long translogGen = Long.parseLong(lastCommittedSegmentInfos.getUserData().get(Translog.TRANSLOG_GENERATION_KEY));, +            Translog.Snapshot snapshot = translog.newSnapshot(translogGen);, +        // clean up what's not needed, +        translog.trimUnreferencedReaders();, +    protected void commitIndexWriter(final IndexWriter writer, final Translog translog, @Nullable final String syncId) throws IOException {, +++ b/core/src/main/java/org/elasticsearch/index/engine/CombinedDeletionPolicy.java, +, +    public TranslogDeletionPolicy getTranslogDeletionPolicy() {, +        return translogDeletionPolicy;, +    }, +++ b/core/src/main/java/org/elasticsearch/index/engine/InternalEngine.java, +            final long translogGen = Long.parseLong(lastCommittedSegmentInfos.getUserData().get(Translog.TRANSLOG_GENERATION_KEY));, +            Translog.Snapshot snapshot = translog.newSnapshot(translogGen);, +        // clean up what's not needed, +        translog.trimUnreferencedReaders();, +    protected void commitIndexWriter(final IndexWriter writer, final Translog translog, @Nullable final String syncId) throws IOException {, +++ b/core/src/main/java/org/elasticsearch/index/translog/Checkpoint.java, +    final long minTranslogGeneration;, +        + Long.BYTES // minimum translog generation in the translog - introduced in 6.0.0, +     * @param minTranslogGeneration the minimum generation referenced by the translog at this moment., +    Checkpoint(long offset, int numOps, long generation, long minSeqNo, long maxSeqNo, long globalCheckpoint, long minTranslogGeneration) {, +        assert minSeqNo <= maxSeqNo : "minSeqNo [" + minSeqNo + "] is higher than maxSeqNo [" + maxSeqNo + "]";, +        assert minTranslogGeneration <= generation :, +            "minTranslogGen [" + minTranslogGeneration + "] is higher than generation [" + generation + "]";, +        this.minTranslogGeneration = minTranslogGeneration;, +        out.writeLong(minTranslogGeneration);, +    static Checkpoint emptyTranslogCheckpoint(final long offset, final long generation, final long globalCheckpoint,, +                                              long minTranslogGeneration) {, +        return new Checkpoint(offset, 0, generation, minSeqNo, maxSeqNo, globalCheckpoint, minTranslogGeneration);, +        return new Checkpoint(in.readLong(), in.readInt(), in.readLong(), in.readLong(), in.readLong(), in.readLong(), in.readLong());, +        final long minTranslogGeneration = -1L;, +        return new Checkpoint(in.readLong(), in.readInt(), in.readLong(), minSeqNo, maxSeqNo, globalCheckpoint, minTranslogGeneration);, +            ", minTranslogGeneration=" + minTranslogGeneration +, +++ b/core/src/main/java/org/elasticsearch/index/engine/CombinedDeletionPolicy.java, +, +    public TranslogDeletionPolicy getTranslogDeletionPolicy() {, +        return translogDeletionPolicy;, +    }, +++ b/core/src/main/java/org/elasticsearch/index/engine/InternalEngine.java, +            final long translogGen = Long.parseLong(lastCommittedSegmentInfos.getUserData().get(Translog.TRANSLOG_GENERATION_KEY));, +            Translog.Snapshot snapshot = translog.newSnapshot(translogGen);, +        // clean up what's not needed, +        translog.trimUnreferencedReaders();, +    protected void commitIndexWriter(final IndexWriter writer, final Translog translog, @Nullable final String syncId) throws IOException {, +++ b/core/src/main/java/org/elasticsearch/index/translog/Checkpoint.java, +    final long minTranslogGeneration;, +        + Long.BYTES // minimum translog generation in the translog - introduced in 6.0.0, +     * @param minTranslogGeneration the minimum generation referenced by the translog at this moment., +    Checkpoint(long offset, int numOps, long generation, long minSeqNo, long maxSeqNo, long globalCheckpoint, long minTranslogGeneration) {, +        assert minSeqNo <= maxSeqNo : "minSeqNo [" + minSeqNo + "] is higher than maxSeqNo [" + maxSeqNo + "]";, +        assert minTranslogGeneration <= generation :, +            "minTranslogGen [" + minTranslogGeneration + "] is higher than generation [" + generation + "]";, +        this.minTranslogGeneration = minTranslogGeneration;, +        out.writeLong(minTranslogGeneration);, +    static Checkpoint emptyTranslogCheckpoint(final long offset, final long generation, final long globalCheckpoint,, +                                              long minTranslogGeneration) {, +        return new Checkpoint(offset, 0, generation, minSeqNo, maxSeqNo, globalCheckpoint, minTranslogGeneration);, +        return new Checkpoint(in.readLong(), in.readInt(), in.readLong(), in.readLong(), in.readLong(), in.readLong(), in.readLong());, +        final long minTranslogGeneration = -1L;, +        return new Checkpoint(in.readLong(), in.readInt(), in.readLong(), minSeqNo, maxSeqNo, globalCheckpoint, minTranslogGeneration);, +            ", minTranslogGeneration=" + minTranslogGeneration +, +++ b/core/src/main/java/org/elasticsearch/index/translog/Translog.java, +import org.elasticsearch.Version;, +import java.util.Iterator;, +                this.readers.addAll(recoverFromFiles(checkpoint));, +                current = null;, +                final Checkpoint checkpoint = Checkpoint.emptyTranslogCheckpoint(0, generation, globalCheckpointSupplier.getAsLong(), generation);, +                current = createWriter(generation, generation);, +                readers.clear();, +    private ArrayList<TranslogReader> recoverFromFiles(Checkpoint checkpoint) throws IOException {, +, +            final long minGenerationToRecoverFrom;, +            if (checkpoint.minTranslogGeneration < 0) {, +                final Version indexVersionCreated = indexSettings().getIndexVersionCreated();, +                assert indexVersionCreated.before(Version.V_6_0_0_alpha3) :, +                    "no minTranslogGeneration in checkpoint, but index was created with version [" + indexVersionCreated + "]";, +                minGenerationToRecoverFrom = deletionPolicy.getMinTranslogGenerationForRecovery();, +            } else {, +                minGenerationToRecoverFrom = checkpoint.minTranslogGeneration;, +            }, +, +            for (long i = checkpoint.generation - 1; i >= minGenerationToRecoverFrom; i--) {, +                        minGenerationToRecoverFrom + " checkpoint: " + checkpoint.generation + " - translog ids must be consecutive");, +, +            // when we clean up files, we first update the checkpoint with a new minReferencedTranslog and then delete them;, +            // if we crash just at the wrong moment, it may be that we leave one unreferenced file behind so we delete it if there, +            IOUtils.deleteFilesIgnoringExceptions(location.resolve(getFilename(minGenerationToRecoverFrom - 1)),, +                location.resolve(getCommitCheckpointFileName(minGenerationToRecoverFrom - 1)));, +]