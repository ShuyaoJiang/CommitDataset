[+++ b/core/src/main/java/org/elasticsearch/index/shard/StoreRecovery.java, +            assert indexShard.shardRouting.primary() : "only primary shards can recover from store";, +            indexShard.getEngine().fillSeqNoGaps(indexShard.getPrimaryTerm());, +++ b/core/src/main/java/org/elasticsearch/index/shard/StoreRecovery.java, +            assert indexShard.shardRouting.primary() : "only primary shards can recover from store";, +            indexShard.getEngine().fillSeqNoGaps(indexShard.getPrimaryTerm());, +++ b/core/src/test/java/org/elasticsearch/snapshots/SharedClusterSnapshotRestoreIT.java, +import org.elasticsearch.action.admin.indices.stats.IndicesStatsResponse;, +import org.elasticsearch.index.Index;, +import org.elasticsearch.index.shard.IndexShard;, +import static org.elasticsearch.index.shard.IndexShardTests.getEngineFromShard;, +    public void testSnapshottingWithMissingSequenceNumbers() {, +        final String repositoryName = "test-repo";, +        final String snapshotName = "test-snap";, +        final String indexName = "test-idx";, +        final Client client = client();, +        final Path repo = randomRepoPath();, +, +        logger.info("-->  creating repository at {}", repo.toAbsolutePath());, +        assertAcked(client.admin().cluster().preparePutRepository(repositoryName), +            .setType("fs").setSettings(Settings.builder(), +                .put("location", repo), +                .put("compress", false), +                .put("chunk_size", randomIntBetween(100, 1000), ByteSizeUnit.BYTES)));, +        logger.info("--> creating an index and indexing documents");, +        final String dataNode = internalCluster().getDataNodeInstance(ClusterService.class).localNode().getName();, +        final Settings settings =, +            Settings, +                .builder(), +                .put("index.number_of_shards", 1), +                .put("index.number_of_replicas", 0), +                .put("index.routing.allocation.include._name", dataNode), +                .build();, +        createIndex(indexName, settings);, +        ensureGreen();, +        for (int i = 0; i < 5; i++) {, +            index(indexName, "_doc", Integer.toString(i), "foo", "bar" + i);, +        }, +, +        final Index index = resolveIndex(indexName);, +        final IndexShard primary = internalCluster().getInstance(IndicesService.class, dataNode).getShardOrNull(new ShardId(index, 0));, +        // create a gap in the sequence numbers, +        getEngineFromShard(primary).seqNoService().generateSeqNo();, +, +        for (int i = 5; i < 10; i++) {, +            index(indexName, "_doc", Integer.toString(i), "foo", "bar" + i);, +        }, +, +        refresh();, +, +        logger.info("--> snapshot");, +        CreateSnapshotResponse createSnapshotResponse = client.admin().cluster().prepareCreateSnapshot(repositoryName, snapshotName), +            .setWaitForCompletion(true).setIndices(indexName).get();, +        assertThat(createSnapshotResponse.getSnapshotInfo().successfulShards(), greaterThan(0));, +        assertThat(createSnapshotResponse.getSnapshotInfo().successfulShards(),, +            equalTo(createSnapshotResponse.getSnapshotInfo().totalShards()));, +, +        logger.info("--> delete indices");, +        assertAcked(client.admin().indices().prepareDelete(indexName));, +, +        logger.info("--> restore all indices from the snapshot");, +        RestoreSnapshotResponse restoreSnapshotResponse = client.admin().cluster().prepareRestoreSnapshot("test-repo", "test-snap"), +            .setWaitForCompletion(true).execute().actionGet();, +        assertThat(restoreSnapshotResponse.getRestoreInfo().totalShards(), greaterThan(0));, +, +        logger.info("--> indexing some more");, +        for (int i = 10; i < 15; i++) {, +            index(indexName, "_doc", Integer.toString(i), "foo", "bar" + i);, +        }, +, +        IndicesStatsResponse stats = client().admin().indices().prepareStats(indexName).clear().get();, +        ShardStats shardStats = stats.getShards()[0];, +        assertTrue(shardStats.getShardRouting().primary());, +        assertThat(shardStats.getSeqNoStats().getLocalCheckpoint(), equalTo(15L)); // 15 indexed docs and one "missing" op., +        assertThat(shardStats.getSeqNoStats().getGlobalCheckpoint(), equalTo(15L));, +        assertThat(shardStats.getSeqNoStats().getMaxSeqNo(), equalTo(15L));, +    }, +, +++ b/core/src/main/java/org/elasticsearch/index/shard/StoreRecovery.java, +            assert indexShard.shardRouting.primary() : "only primary shards can recover from store";, +            indexShard.getEngine().fillSeqNoGaps(indexShard.getPrimaryTerm());, +++ b/core/src/test/java/org/elasticsearch/snapshots/SharedClusterSnapshotRestoreIT.java, +import org.elasticsearch.action.admin.indices.stats.IndicesStatsResponse;, +import org.elasticsearch.index.Index;, +import org.elasticsearch.index.shard.IndexShard;, +import static org.elasticsearch.index.shard.IndexShardTests.getEngineFromShard;, +    public void testSnapshottingWithMissingSequenceNumbers() {, +        final String repositoryName = "test-repo";, +        final String snapshotName = "test-snap";, +        final String indexName = "test-idx";, +        final Client client = client();, +        final Path repo = randomRepoPath();, +, +        logger.info("-->  creating repository at {}", repo.toAbsolutePath());, +        assertAcked(client.admin().cluster().preparePutRepository(repositoryName), +            .setType("fs").setSettings(Settings.builder(), +                .put("location", repo), +                .put("compress", false), +                .put("chunk_size", randomIntBetween(100, 1000), ByteSizeUnit.BYTES)));, +        logger.info("--> creating an index and indexing documents");]