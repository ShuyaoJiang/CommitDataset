[+++ b/modules/elasticsearch/src/main/java/org/elasticsearch/gateway/Gateway.java, +import org.elasticsearch.cluster.ClusterState;, +        void onSuccess(ClusterState recoveredState);, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/gateway/Gateway.java, +import org.elasticsearch.cluster.ClusterState;, +        void onSuccess(ClusterState recoveredState);, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/gateway/GatewayService.java, +import org.elasticsearch.cluster.metadata.IndexMetaData;, +import org.elasticsearch.cluster.metadata.IndexTemplateMetaData;, +import org.elasticsearch.cluster.metadata.MetaDataCreateIndexService;, +import java.io.IOException;, +import java.util.Map;, +import java.util.concurrent.atomic.AtomicInteger;, +import static org.elasticsearch.common.unit.TimeValue.*;, +    private final MetaDataCreateIndexService createIndexService;, +, +    @Inject public GatewayService(Settings settings, Gateway gateway, ClusterService clusterService, DiscoveryService discoveryService, MetaDataCreateIndexService createIndexService, ThreadPool threadPool) {, +        this.createIndexService = createIndexService;, +        final Gateway.GatewayStateRecoveredListener recoveryListener = new GatewayRecoveryListener(latch);, +    class GatewayRecoveryListener implements Gateway.GatewayStateRecoveredListener {, +, +        private final CountDownLatch latch;, +, +        GatewayRecoveryListener(CountDownLatch latch) {, +            this.latch = latch;, +        }, +, +        @Override public void onSuccess(final ClusterState recoveredState) {, +            final AtomicInteger indicesCounter = new AtomicInteger(recoveredState.metaData().indices().size());, +            clusterService.submitStateUpdateTask("local-gateway-elected-state", new ProcessedClusterStateUpdateTask() {, +                @Override public ClusterState execute(ClusterState currentState) {, +                    MetaData.Builder metaDataBuilder = newMetaDataBuilder(), +                            .metaData(currentState.metaData());, +                    // mark the metadata as read from gateway, +                    metaDataBuilder.markAsRecoveredFromGateway();, +, +                    // add the index templates, +                    for (Map.Entry<String, IndexTemplateMetaData> entry : recoveredState.metaData().templates().entrySet()) {, +                        metaDataBuilder.put(entry.getValue());, +                    }, +, +                    return newClusterStateBuilder().state(currentState), +                            .version(recoveredState.version()), +                            .metaData(metaDataBuilder).build();, +                }, +, +                @Override public void clusterStateProcessed(ClusterState clusterState) {, +                    if (recoveredState.metaData().indices().isEmpty()) {, +                        markMetaDataAsReadFromGateway("success");, +                        latch.countDown();, +                        return;, +                    }, +                    // go over the meta data and create indices, we don't really need to copy over, +                    // the meta data per index, since we create the index and it will be added automatically, +                    for (final IndexMetaData indexMetaData : recoveredState.metaData()) {, +                        try {, +                            createIndexService.createIndex(new MetaDataCreateIndexService.Request(MetaDataCreateIndexService.Request.Origin.GATEWAY, "gateway", indexMetaData.index()), +                                    .settings(indexMetaData.settings()), +                                    .mappingsMetaData(indexMetaData.mappings()), +                                    .state(indexMetaData.state()), +                                    .timeout(timeValueSeconds(30)),, +, +                                    new MetaDataCreateIndexService.Listener() {, +                                        @Override public void onResponse(MetaDataCreateIndexService.Response response) {, +                                            if (indicesCounter.decrementAndGet() == 0) {, +                                                markMetaDataAsReadFromGateway("success");, +                                                latch.countDown();, +                                            }, +                                        }, +, +                                        @Override public void onFailure(Throwable t) {, +                                            logger.error("failed to create index [{}]", t, indexMetaData.index());, +                                            // we report success on index creation failure and do nothing, +                                            // should we disable writing the updated metadata?, +                                            if (indicesCounter.decrementAndGet() == 0) {, +                                                markMetaDataAsReadFromGateway("success");, +                                                latch.countDown();, +                                            }, +                                        }, +                                    });, +                        } catch (IOException e) {, +                            logger.error("failed to create index [{}]", e, indexMetaData.index());, +                            // we report success on index creation failure and do nothing, +                            // should we disable writing the updated metadata?, +                            if (indicesCounter.decrementAndGet() == 0) {, +                                markMetaDataAsReadFromGateway("success");, +                                latch.countDown();, +                            }, +                        }, +                    }, +                }, +            });, +        }, +, +        @Override public void onFailure(Throwable t) {, +            // don't remove the block here, we don't want to allow anything in such a case, +            logger.error("failed recover state, blocking...", t);, +        }, +    }, +]