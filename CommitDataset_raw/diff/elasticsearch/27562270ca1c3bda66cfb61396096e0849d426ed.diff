[+++ b/src/main/java/org/elasticsearch/indices/store/IndicesStore.java, +import org.elasticsearch.cluster.routing.IndexRoutingTable;, +import org.elasticsearch.cluster.routing.IndexShardRoutingTable;, +import org.elasticsearch.cluster.routing.ShardRouting;, +        for (IndexRoutingTable indexRoutingTable : event.state().routingTable()) {, +            // Note, closed indices will not have any routing information, so won't be deleted, +                ShardId shardId = indexShardRoutingTable.shardId();, +                // a shard can be deleted if all its copies are active, and its not allocated on this node, +                if (indexShardRoutingTable.size() == 0) {, +                    // should not really happen, there should always be at least 1 (primary) shard in a, +                    // shard replication group, in any case, protected from deleting something by mistake, +                    shardCanBeDeleted = false;, +                } else {, +                        // be conservative here, check on started, not even active, +                        if (!shardRouting.started()) {, +                if (shardCanBeDeleted) {, +                    IndexService indexService = indicesService.indexService(indexRoutingTable.index());, +                    if (indexService == null) {, +                        // not physical allocation of the index, delete it from the file system if applicable, +                        if (nodeEnv.hasNodeFile()) {, +                            logger.debug("[{}][{}] deleting shard that is no longer used", shardId.index().name(), shardId.id());, +                            FileSystemUtils.deleteRecursively(nodeEnv.shardLocations(shardId));, +                        }, +                    } else {, +                        if (!indexService.hasShard(shardId.id())) {, +                            if (indexService.store().canDeleteUnallocated(shardId)) {, +                                logger.debug("[{}][{}] deleting shard that is no longer used", shardId.index().name(), shardId.id());, +                                try {, +                                    indexService.store().deleteUnallocated(indexShardRoutingTable.shardId());, +                                } catch (Exception e) {, +                                    logger.debug("[{}][{}] failed to delete unallocated shard, ignoring", e, indexShardRoutingTable.shardId().index().name(), indexShardRoutingTable.shardId().id());, +                                }, +                            }, +                        } else {, +                            // this state is weird, should we log?, +                            // basically, it means that the shard is not allocated on this node using the routing, +                            // but its still physically exists on an IndexService, +                            // Note, this listener should run after IndicesClusterStateService...]