[+++ b/core/src/main/java/org/elasticsearch/action/percolate/TransportPercolateAction.java, +import org.elasticsearch.index.query.ConstantScoreQueryBuilder;, +            // wrapping in a constant score query with boost 0 for bwc reason., +            // percolator api didn't emit scores before and never included scores, +            // for how well percolator queries matched with the document being percolated, +            searchSource.field("query", new ConstantScoreQueryBuilder(percolatorQueryBuilder).boost(0f));, +++ b/core/src/main/java/org/elasticsearch/action/percolate/TransportPercolateAction.java, +import org.elasticsearch.index.query.ConstantScoreQueryBuilder;, +            // wrapping in a constant score query with boost 0 for bwc reason., +            // percolator api didn't emit scores before and never included scores, +            // for how well percolator queries matched with the document being percolated, +            searchSource.field("query", new ConstantScoreQueryBuilder(percolatorQueryBuilder).boost(0f));, +++ b/core/src/main/java/org/elasticsearch/index/query/PercolatorQuery.java, +import org.apache.lucene.search.SimpleCollector;, +import org.apache.lucene.search.TopDocs;, +                            if (needsScores) {, +                                QueryRegistry.Leaf percolatorQueries = queryRegistry.getQueries(leafReaderContext);, +                                Query query = percolatorQueries.getQuery(docId);, +                                Explanation detail = percolatorIndexSearcher.explain(query, 0);, +                                return Explanation.match(scorer.score(), "PercolatorQuery", detail);, +                            } else {, +                }, +                if (needsScores) {, +                    return new BaseScorer(this, approximation, percolatorQueries, percolatorIndexSearcher) {, +, +                        float score;, +                                TopDocs topDocs = percolatorIndexSearcher.search(query, 1);, +                                if (topDocs.totalHits > 0) {, +                                    score = topDocs.scoreDocs[0].score;, +                                    return true;, +                                } else {, +                                    return false;, +                                }, +, +                        @Override, +                        public float score() throws IOException {, +                            return score;, +                        }, +                } else {, +                    return new BaseScorer(this, approximation, percolatorQueries, percolatorIndexSearcher) {, +, +                        @Override, +                        public float score() throws IOException {, +                            return 0f;, +                        }, +, +                        boolean matchDocId(int docId) throws IOException {, +                            Query query = percolatorQueries.getQuery(docId);, +                            return query != null && Lucene.exists(percolatorIndexSearcher, query);, +                        }, +                    };, +                }, +    static abstract class BaseScorer extends Scorer {, +, +        final Scorer approximation;, +        final QueryRegistry.Leaf percolatorQueries;, +        final IndexSearcher percolatorIndexSearcher;, +, +        BaseScorer(Weight weight, Scorer approximation, QueryRegistry.Leaf percolatorQueries, IndexSearcher percolatorIndexSearcher) {, +            super(weight);, +            this.approximation = approximation;, +            this.percolatorQueries = percolatorQueries;, +            this.percolatorIndexSearcher = percolatorIndexSearcher;, +        }, +, +        @Override, +        public final DocIdSetIterator iterator() {, +            return TwoPhaseIterator.asDocIdSetIterator(twoPhaseIterator());, +        }, +, +        @Override, +        public final TwoPhaseIterator twoPhaseIterator() {, +            return new TwoPhaseIterator(approximation.iterator()) {, +                @Override, +                public boolean matches() throws IOException {, +                    return matchDocId(approximation.docID());, +                }, +, +                @Override, +                public float matchCost() {, +                    return MATCH_COST;, +                }, +            };, +        }, +, +        @Override, +        public final int freq() throws IOException {, +            return approximation.freq();, +        }, +, +        @Override, +        public final int docID() {, +            return approximation.docID();, +        }, +, +        abstract boolean matchDocId(int docId) throws IOException;, +, +    }, +, +++ b/core/src/main/java/org/elasticsearch/action/percolate/TransportPercolateAction.java]