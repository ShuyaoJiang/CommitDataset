[+++ b/src/main/java/org/elasticsearch/common/blobstore/fs/FsImmutableBlobContainer.java, +    public void writeBlob(final String blobName, final InputStream stream, final long sizeInBytes, final WriterListener listener) {, +                final File file = new File(path, blobName);, +                    try (final RandomAccessFile raf = new RandomAccessFile(file, "rw");, +                         final InputStream is = stream) {, +                        // clean the file if it exists, +                        raf.setLength(0);, +                        final byte[] buffer = new byte[blobStore.bufferSizeInBytes()];, +                            throw new ElasticsearchIllegalStateException("[" + blobName + "]: wrote [" + bytesWritten + "], expected to write [" + sizeInBytes + "]");, +                        // fsync the FD we are done with writing, +                        raf.getFD().sync();, +                        // try to fsync the directory to make sure all metadata is written to, +                        // the storage device - NOTE: if it's a dir it will not throw any exception, +                        FileSystemUtils.syncFile(path, true);, +                    FileSystemUtils.tryDeleteFile(file);, +++ b/src/main/java/org/elasticsearch/common/blobstore/fs/FsImmutableBlobContainer.java, +    public void writeBlob(final String blobName, final InputStream stream, final long sizeInBytes, final WriterListener listener) {, +                final File file = new File(path, blobName);, +                    try (final RandomAccessFile raf = new RandomAccessFile(file, "rw");, +                         final InputStream is = stream) {, +                        // clean the file if it exists, +                        raf.setLength(0);, +                        final byte[] buffer = new byte[blobStore.bufferSizeInBytes()];, +                            throw new ElasticsearchIllegalStateException("[" + blobName + "]: wrote [" + bytesWritten + "], expected to write [" + sizeInBytes + "]");, +                        // fsync the FD we are done with writing, +                        raf.getFD().sync();, +                        // try to fsync the directory to make sure all metadata is written to, +                        // the storage device - NOTE: if it's a dir it will not throw any exception, +                        FileSystemUtils.syncFile(path, true);, +                    FileSystemUtils.tryDeleteFile(file);, +++ b/src/main/java/org/elasticsearch/common/io/FileSystemUtils.java, +import org.apache.lucene.util.Constants;, +import org.apache.lucene.util.IOUtils;, +import org.apache.lucene.util.ThreadInterruptedException;, +import org.elasticsearch.Version;, +import java.nio.file.StandardOpenOption;, +    static {, +        assert Version.CURRENT.luceneVersion == org.apache.lucene.util.Version.LUCENE_47 : "Use IOUtils#fsync instead of syncFile in Lucene 4.8";, +, +    /**, +     * Ensure that any writes to the given file is written to the storage device that contains it., +     * @param fileToSync the file to fsync, +     * @param isDir if true, the given file is a directory (we open for read and ignore IOExceptions,, +     *  because not all file systems and operating systems allow to fsync on a directory), +     */, +    public static void syncFile(File fileToSync, boolean isDir) throws IOException {, +        IOException exc = null;, +, +        // If the file is a directory we have to open read-only, for regular files we must open r/w for the fsync to have an effect., +        // See http://blog.httrack.com/blog/2013/11/15/everything-you-always-wanted-to-know-about-fsync/, +        try (final FileChannel file = FileChannel.open(fileToSync.toPath(), isDir ? StandardOpenOption.READ : StandardOpenOption.WRITE)) {, +            for (int retry = 0; retry < 5; retry++) {, +                try {, +                    file.force(true);, +                    return;, +                    if (exc == null) {, +                    }, +                        Thread.sleep(5L);, +                        ThreadInterruptedException ex = new ThreadInterruptedException(ie);, +                        ex.addSuppressed(exc);, +                        throw ex;, +        } catch (IOException ioe) {, +            if (exc == null) {, +                exc = ioe;, +            }, +        }, +, +        if (isDir) {, +            assert (Constants.LINUX || Constants.MAC_OS_X) == false :, +                    "On Linux and MacOSX fsyncing a directory should not throw IOException, "+, +                            "we just don't want to rely on that in production (undocumented). Got: " + exc;, +            // Ignore exception if it is a directory, +            return;, +        }, +, +        // Throw original exception, +        throw exc;, +    private FileSystemUtils() {}, +    public static void tryDeleteFile(File file) {, +        try {, +            file.delete();, +        } catch (SecurityException e1) {, +            // ignore, +        }]