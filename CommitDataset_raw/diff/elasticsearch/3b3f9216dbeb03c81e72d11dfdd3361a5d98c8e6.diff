[+++ b/core/src/main/java/org/elasticsearch/client/transport/TransportClientNodesService.java, +    // TODO: migrate this to use low level connections and single type channels, +    /** {@link ConnectionProfile} to use when to connecting to the listed nodes and doing a liveness check */, +    private static final ConnectionProfile LISTED_NODES_PROFILE;, +, +    static {, +        ConnectionProfile.Builder builder = new ConnectionProfile.Builder();, +        builder.addConnections(1,, +            TransportRequestOptions.Type.BULK,, +            TransportRequestOptions.Type.PING,, +            TransportRequestOptions.Type.RECOVERY,, +            TransportRequestOptions.Type.REG,, +            TransportRequestOptions.Type.STATE);, +        LISTED_NODES_PROFILE = builder.build();, +    }, +, +                        logger.trace("connecting to listed node [{}]", listedNode);, +                        transportService.connectToNode(listedNode, LISTED_NODES_PROFILE);, +                                        transportService.connectToNode(listedNode, LISTED_NODES_PROFILE);, +++ b/core/src/main/java/org/elasticsearch/client/transport/TransportClientNodesService.java, +    // TODO: migrate this to use low level connections and single type channels, +    /** {@link ConnectionProfile} to use when to connecting to the listed nodes and doing a liveness check */, +    private static final ConnectionProfile LISTED_NODES_PROFILE;, +, +    static {, +        ConnectionProfile.Builder builder = new ConnectionProfile.Builder();, +        builder.addConnections(1,, +            TransportRequestOptions.Type.BULK,, +            TransportRequestOptions.Type.PING,, +            TransportRequestOptions.Type.RECOVERY,, +            TransportRequestOptions.Type.REG,, +            TransportRequestOptions.Type.STATE);, +        LISTED_NODES_PROFILE = builder.build();, +    }, +, +                        logger.trace("connecting to listed node [{}]", listedNode);, +                        transportService.connectToNode(listedNode, LISTED_NODES_PROFILE);, +                                        transportService.connectToNode(listedNode, LISTED_NODES_PROFILE);, +++ b/core/src/main/java/org/elasticsearch/discovery/zen/ElectMasterService.java, +    static List<DiscoveryNode> sortByMasterLikelihood(Iterable<DiscoveryNode> nodes) {, +++ b/core/src/main/java/org/elasticsearch/client/transport/TransportClientNodesService.java, +    // TODO: migrate this to use low level connections and single type channels, +    /** {@link ConnectionProfile} to use when to connecting to the listed nodes and doing a liveness check */, +    private static final ConnectionProfile LISTED_NODES_PROFILE;, +, +    static {, +        ConnectionProfile.Builder builder = new ConnectionProfile.Builder();, +        builder.addConnections(1,, +            TransportRequestOptions.Type.BULK,, +            TransportRequestOptions.Type.PING,, +            TransportRequestOptions.Type.RECOVERY,, +            TransportRequestOptions.Type.REG,, +            TransportRequestOptions.Type.STATE);, +        LISTED_NODES_PROFILE = builder.build();, +    }, +, +                        logger.trace("connecting to listed node [{}]", listedNode);, +                        transportService.connectToNode(listedNode, LISTED_NODES_PROFILE);, +                                        transportService.connectToNode(listedNode, LISTED_NODES_PROFILE);, +++ b/core/src/main/java/org/elasticsearch/discovery/zen/ElectMasterService.java, +    static List<DiscoveryNode> sortByMasterLikelihood(Iterable<DiscoveryNode> nodes) {, +++ b/core/src/main/java/org/elasticsearch/discovery/zen/UnicastZenPing.java, +import org.apache.lucene.store.AlreadyClosedException;, +import org.apache.lucene.util.IOUtils;, +import org.elasticsearch.common.util.concurrent.EsThreadPoolExecutor;, +import org.elasticsearch.common.util.concurrent.KeyedLock;, +import org.elasticsearch.transport.ConnectionProfile;, +import org.elasticsearch.transport.NodeNotConnectedException;, +import org.elasticsearch.transport.Transport.Connection;, +import java.util.Collections;, +import java.util.HashMap;, +import java.util.function.Consumer;, +import java.util.stream.Stream;, +    private final AtomicInteger pingingRoundIdGenerator = new AtomicInteger();, +    // used as a node id prefix for configured unicast host nodes/address, +    private final Map<Integer, PingingRound> activePingingRounds = newConcurrentMap();, +    protected final EsThreadPoolExecutor unicastZenPingExecutorService;, +        if (DISCOVERY_ZEN_PING_UNICAST_HOSTS_SETTING.exists(settings)) {, +            configuredHosts = DISCOVERY_ZEN_PING_UNICAST_HOSTS_SETTING.get(settings);, +            // we only limit to 1 addresses, makes no sense to ping 100 ports, +            limitPortCounts = LIMIT_FOREIGN_PORTS_COUNT;, +        } else {, +     * @param nodeId_prefix    a prefix to use for node ids, +    public static List<DiscoveryNode> resolveHostsLists(, +        final String nodeId_prefix,, +        Objects.requireNonNull(nodeId_prefix);, +                    for (int addressId = 0; addressId < addresses.length; addressId++) {, +                                nodeId_prefix + hostname + "_" + addressId + "#",, +                                addresses[addressId],, +        ThreadPool.terminate(unicastZenPingExecutorService, 10, TimeUnit.SECONDS);, +        Releasables.close(activePingingRounds.values());, +     * Sends three rounds of pings notifying the specified {@link Consumer} when pinging is complete. Pings are sent after resolving, +     * @param resultsConsumer the callback when pinging is complete, +    public void ping(final Consumer<PingCollection> resultsConsumer, final TimeValue duration) {, +        ping(resultsConsumer, duration, duration);, +    }, +, +    /**, +     * a variant of {@link #ping(Consumer, TimeValue)}, but allows separating the scheduling duration, +     * from the duration used for request level time outs. This is useful for testing]