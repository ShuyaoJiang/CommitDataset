[+++ b/test/framework/src/main/java/org/elasticsearch/index/replication/ESIndexLevelReplicationTestCase.java, +        public synchronized RetentionLease addRetentionLease(String id, long retainingSequenceNumber, String source,, +        public synchronized RetentionLease renewRetentionLease(String id, long retainingSequenceNumber, String source) {, +            return getPrimary().renewRetentionLease(id, retainingSequenceNumber, source);, +        }, +, +        public synchronized void removeRetentionLease(String id, ActionListener<ReplicationResponse> listener) {, +++ b/test/framework/src/main/java/org/elasticsearch/index/replication/ESIndexLevelReplicationTestCase.java, +        public synchronized RetentionLease addRetentionLease(String id, long retainingSequenceNumber, String source,, +        public synchronized RetentionLease renewRetentionLease(String id, long retainingSequenceNumber, String source) {, +            return getPrimary().renewRetentionLease(id, retainingSequenceNumber, source);, +        }, +, +        public synchronized void removeRetentionLease(String id, ActionListener<ReplicationResponse> listener) {, +++ b/x-pack/plugin/ccr/src/main/java/org/elasticsearch/xpack/ccr/CcrRetentionLeases.java, +import org.elasticsearch.common.settings.Setting;, +import java.util.concurrent.TimeUnit;, +    // this setting is intentionally not registered, it is only used in tests, +    public static final Setting<TimeValue> RETENTION_LEASE_RENEW_INTERVAL_SETTING =, +            Setting.timeSetting(, +                    "index.ccr.retention_lease.renew_interval",, +                    new TimeValue(5, TimeUnit.MINUTES),, +                    new TimeValue(0, TimeUnit.MILLISECONDS),, +                    Setting.Property.NodeScope);, +, +     * @param retainingSequenceNumber the retaining sequence number, +            final long retainingSequenceNumber,, +            asyncAddRetentionLease(leaderShardId, retentionLeaseId, retainingSequenceNumber, remoteClient, response);, +     * @param retainingSequenceNumber the retaining sequence number, +            final long retainingSequenceNumber,, +                new RetentionLeaseActions.AddRequest(leaderShardId, retentionLeaseId, retainingSequenceNumber, "ccr");, +     * @param retainingSequenceNumber the retaining sequence number, +            final long retainingSequenceNumber,, +            asyncRenewRetentionLease(leaderShardId, retentionLeaseId, retainingSequenceNumber, remoteClient, response);, +     * @param retainingSequenceNumber the retaining sequence number, +            final long retainingSequenceNumber,, +                new RetentionLeaseActions.RenewRequest(leaderShardId, retentionLeaseId, retainingSequenceNumber, "ccr");, +++ b/test/framework/src/main/java/org/elasticsearch/index/replication/ESIndexLevelReplicationTestCase.java, +        public synchronized RetentionLease addRetentionLease(String id, long retainingSequenceNumber, String source,, +        public synchronized RetentionLease renewRetentionLease(String id, long retainingSequenceNumber, String source) {, +            return getPrimary().renewRetentionLease(id, retainingSequenceNumber, source);, +        }, +, +        public synchronized void removeRetentionLease(String id, ActionListener<ReplicationResponse> listener) {, +++ b/x-pack/plugin/ccr/src/main/java/org/elasticsearch/xpack/ccr/CcrRetentionLeases.java, +import org.elasticsearch.common.settings.Setting;, +import java.util.concurrent.TimeUnit;, +    // this setting is intentionally not registered, it is only used in tests, +    public static final Setting<TimeValue> RETENTION_LEASE_RENEW_INTERVAL_SETTING =, +            Setting.timeSetting(, +                    "index.ccr.retention_lease.renew_interval",, +                    new TimeValue(5, TimeUnit.MINUTES),, +                    new TimeValue(0, TimeUnit.MILLISECONDS),, +                    Setting.Property.NodeScope);, +, +     * @param retainingSequenceNumber the retaining sequence number, +            final long retainingSequenceNumber,, +            asyncAddRetentionLease(leaderShardId, retentionLeaseId, retainingSequenceNumber, remoteClient, response);, +     * @param retainingSequenceNumber the retaining sequence number, +            final long retainingSequenceNumber,, +                new RetentionLeaseActions.AddRequest(leaderShardId, retentionLeaseId, retainingSequenceNumber, "ccr");, +     * @param retainingSequenceNumber the retaining sequence number, +            final long retainingSequenceNumber,, +            asyncRenewRetentionLease(leaderShardId, retentionLeaseId, retainingSequenceNumber, remoteClient, response);, +     * @param retainingSequenceNumber the retaining sequence number, +            final long retainingSequenceNumber,, +                new RetentionLeaseActions.RenewRequest(leaderShardId, retentionLeaseId, retainingSequenceNumber, "ccr");, +++ b/x-pack/plugin/ccr/src/main/java/org/elasticsearch/xpack/ccr/action/ShardFollowNodeTask.java, +import org.elasticsearch.threadpool.Scheduler;, +import org.elasticsearch.xpack.ccr.Ccr;, +    private Scheduler.Cancellable renewable;, +, +    synchronized Scheduler.Cancellable getRenewable() {, +        return renewable;, +    }, +, +         * avoid the need to declare these fields as volatile. That is, we are ensuring these fields are always accessed under the same, +         * lock., +            renewable = scheduleBackgroundRetentionLeaseRenewal(() -> {, +                synchronized (ShardFollowNodeTask.this) {, +                    return this.followerGlobalCheckpoint;, +                }, +            });, +    protected abstract Scheduler.Cancellable scheduleBackgroundRetentionLeaseRenewal(LongSupplier followerGlobalCheckpoint);, +, +        synchronized (this) {, +            if (renewable != null) {, +                renewable.cancel();, +                renewable = null;, +            }, +        }, +++ b/test/framework/src/main/java/org/elasticsearch/index/replication/ESIndexLevelReplicationTestCase.java, +        public synchronized RetentionLease addRetentionLease(String id, long retainingSequenceNumber, String source,, +        public synchronized RetentionLease renewRetentionLease(String id, long retainingSequenceNumber, String source) {, +            return getPrimary().renewRetentionLease(id, retainingSequenceNumber, source);, +        }, +, +        public synchronized void removeRetentionLease(String id, ActionListener<ReplicationResponse> listener) {, +++ b/x-pack/plugin/ccr/src/main/java/org/elasticsearch/xpack/ccr/CcrRetentionLeases.java, +import org.elasticsearch.common.settings.Setting;]