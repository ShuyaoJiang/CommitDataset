[+++ b/src/test/java/org/elasticsearch/test/integration/percolator/ConcurrentPercolatorTests.java, +import org.elasticsearch.common.util.concurrent.ConcurrentCollections;, +import java.util.Set;, +import java.util.concurrent.atomic.AtomicReference;, +        final AtomicReference<Throwable> exceptionHolder = new AtomicReference<Throwable>(null);, +        final AtomicInteger idGen = new AtomicInteger(0);, +        final Set<String> liveIds = ConcurrentCollections.newConcurrentSet();, +                                if (!liveIds.isEmpty() && getRandom().nextInt(100) < 19) {, +                                    String id;, +                                    do {, +                                        id = Integer.toString(randomInt(idGen.get()));, +                                    } while (!liveIds.remove(id));, +, +                                    assertThat("doc[" + id + "] should have been deleted, but isn't", response.isNotFound(), equalTo(false));, +                                    String id = Integer.toString(idGen.getAndIncrement());, +                                    liveIds.add(id);, +                                    assertThat(response.isCreated(), equalTo(true)); // We only add new docs, +                        exceptionHolder.set(t);, +                int atLeastExpected = liveIds.size();, +        assertThat("exceptionHolder should have been empty, but holds: " + exceptionHolder.toString(), exceptionHolder.get(), nullValue());]