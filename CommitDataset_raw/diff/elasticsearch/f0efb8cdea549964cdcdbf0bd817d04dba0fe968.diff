[+++ b/modules/elasticsearch/src/main/java/org/elasticsearch/index/mapper/internal/ParentFieldMapper.java, +import org.apache.lucene.search.ConstantScoreQuery;, +import org.apache.lucene.search.Filter;, +import org.apache.lucene.search.PublicTermsFilter;, +import org.apache.lucene.search.Query;, +import org.elasticsearch.common.Nullable;, +import org.elasticsearch.index.query.QueryParseContext;, +    @Override public Query fieldQuery(String value, @Nullable QueryParseContext context) {, +        if (context == null) {, +            return super.fieldQuery(value, context);, +        }, +        return new ConstantScoreQuery(fieldFilter(value, context));, +    }, +, +    @Override public Filter fieldFilter(String value, @Nullable QueryParseContext context) {, +        if (context == null) {, +            return super.fieldFilter(value, context);, +        }, +        // we use all types, cause we don't know if its exact or not..., +        PublicTermsFilter filter = new PublicTermsFilter();, +        for (String type : context.mapperService().types()) {, +            filter.addTerm(names.createIndexNameTerm(Uid.createUid(type, value)));, +        }, +        return filter;, +    }, +, +    /**, +     * We don't need to analyzer the text, and we need to convert it to UID..., +     */, +    @Override public boolean useFieldQueryWithQueryString() {, +        return true;, +    }, +, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/index/mapper/internal/ParentFieldMapper.java, +import org.apache.lucene.search.ConstantScoreQuery;, +import org.apache.lucene.search.Filter;, +import org.apache.lucene.search.PublicTermsFilter;, +import org.apache.lucene.search.Query;, +import org.elasticsearch.common.Nullable;, +import org.elasticsearch.index.query.QueryParseContext;, +    @Override public Query fieldQuery(String value, @Nullable QueryParseContext context) {, +        if (context == null) {, +            return super.fieldQuery(value, context);, +        }, +        return new ConstantScoreQuery(fieldFilter(value, context));, +    }, +, +    @Override public Filter fieldFilter(String value, @Nullable QueryParseContext context) {, +        if (context == null) {, +            return super.fieldFilter(value, context);, +        }, +        // we use all types, cause we don't know if its exact or not..., +        PublicTermsFilter filter = new PublicTermsFilter();, +        for (String type : context.mapperService().types()) {, +            filter.addTerm(names.createIndexNameTerm(Uid.createUid(type, value)));, +        }, +        return filter;, +    }, +, +    /**, +     * We don't need to analyzer the text, and we need to convert it to UID..., +     */, +    @Override public boolean useFieldQueryWithQueryString() {, +        return true;, +    }, +, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/index/search/UidFilter.java, +import java.util.Set;, +import java.util.TreeSet;, +    private final Set<Term> uids;, +        this.uids = new TreeSet<Term>();, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/index/mapper/internal/ParentFieldMapper.java, +import org.apache.lucene.search.ConstantScoreQuery;, +import org.apache.lucene.search.Filter;, +import org.apache.lucene.search.PublicTermsFilter;, +import org.apache.lucene.search.Query;, +import org.elasticsearch.common.Nullable;, +import org.elasticsearch.index.query.QueryParseContext;, +    @Override public Query fieldQuery(String value, @Nullable QueryParseContext context) {, +        if (context == null) {, +            return super.fieldQuery(value, context);, +        }, +        return new ConstantScoreQuery(fieldFilter(value, context));, +    }, +, +    @Override public Filter fieldFilter(String value, @Nullable QueryParseContext context) {, +        if (context == null) {, +            return super.fieldFilter(value, context);, +        }, +        // we use all types, cause we don't know if its exact or not..., +        PublicTermsFilter filter = new PublicTermsFilter();, +        for (String type : context.mapperService().types()) {, +            filter.addTerm(names.createIndexNameTerm(Uid.createUid(type, value)));, +        }, +        return filter;, +    }, +, +    /**, +     * We don't need to analyzer the text, and we need to convert it to UID..., +     */]