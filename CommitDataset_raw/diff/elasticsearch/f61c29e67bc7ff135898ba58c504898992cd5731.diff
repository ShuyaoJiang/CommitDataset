[+++ b/core/src/main/java/org/elasticsearch/index/query/BaseTermQueryBuilder.java, +     * because in {@link TermQueryBuilder} and {@link SpanTermQueryParser} string values are parsed to {@link BytesRef}, +++ b/core/src/main/java/org/elasticsearch/index/query/BaseTermQueryBuilder.java, +     * because in {@link TermQueryBuilder} and {@link SpanTermQueryParser} string values are parsed to {@link BytesRef}, +++ b/core/src/main/java/org/elasticsearch/index/query/BoolQueryBuilder.java, +import org.elasticsearch.common.ParseField;, +import org.elasticsearch.common.ParsingException;, +import org.elasticsearch.common.xcontent.XContentParser;, +    public static final ParseField QUERY_NAME_FIELD = new ParseField(BoolQueryBuilder.NAME);, +    public static final BoolQueryBuilder PROTOTYPE = new BoolQueryBuilder();, +    private static final String MUSTNOT = "mustNot";, +    private static final String MUST_NOT = "must_not";, +    private static final String FILTER = "filter";, +    private static final String SHOULD = "should";, +    private static final String MUST = "must";, +    private static final ParseField DISABLE_COORD_FIELD = new ParseField("disable_coord");, +    private static final ParseField MINIMUM_SHOULD_MATCH = new ParseField("minimum_should_match");, +    private static final ParseField MINIMUM_NUMBER_SHOULD_MATCH = new ParseField("minimum_number_should_match");, +    private static final ParseField ADJUST_PURE_NEGATIVE = new ParseField("adjust_pure_negative");, +        doXArrayContent(MUST, mustClauses, builder, params);, +        doXArrayContent(FILTER, filterClauses, builder, params);, +        doXArrayContent(MUST_NOT, mustNotClauses, builder, params);, +        doXArrayContent(SHOULD, shouldClauses, builder, params);, +        builder.field(DISABLE_COORD_FIELD.getPreferredName(), disableCoord);, +        builder.field(ADJUST_PURE_NEGATIVE.getPreferredName(), adjustPureNegative);, +            builder.field(MINIMUM_SHOULD_MATCH.getPreferredName(), minimumShouldMatch);, +    public static BoolQueryBuilder fromXContent(QueryParseContext parseContext) throws IOException, ParsingException {, +        XContentParser parser = parseContext.parser();, +, +        boolean disableCoord = BoolQueryBuilder.DISABLE_COORD_DEFAULT;, +        boolean adjustPureNegative = BoolQueryBuilder.ADJUST_PURE_NEGATIVE_DEFAULT;, +        float boost = AbstractQueryBuilder.DEFAULT_BOOST;, +        String minimumShouldMatch = null;, +, +        final List<QueryBuilder<?>> mustClauses = new ArrayList<>();, +        final List<QueryBuilder<?>> mustNotClauses = new ArrayList<>();, +        final List<QueryBuilder<?>> shouldClauses = new ArrayList<>();, +        final List<QueryBuilder<?>> filterClauses = new ArrayList<>();, +        String queryName = null;, +, +        String currentFieldName = null;, +        XContentParser.Token token;, +        QueryBuilder<?> query;, +        while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {, +            if (token == XContentParser.Token.FIELD_NAME) {, +                currentFieldName = parser.currentName();, +            } else if (parseContext.isDeprecatedSetting(currentFieldName)) {, +                // skip, +            } else if (token == XContentParser.Token.START_OBJECT) {, +                switch (currentFieldName) {, +                case MUST:, +                    query = parseContext.parseInnerQueryBuilder();, +                    mustClauses.add(query);, +                    break;, +                case SHOULD:, +                    query = parseContext.parseInnerQueryBuilder();, +                    shouldClauses.add(query);, +                    break;, +                case FILTER:, +                    query = parseContext.parseInnerQueryBuilder();, +                    filterClauses.add(query);, +                    break;, +                case MUST_NOT:, +                case MUSTNOT:, +                    query = parseContext.parseInnerQueryBuilder();, +                    mustNotClauses.add(query);, +                    break;, +                default:, +                    throw new ParsingException(parser.getTokenLocation(), "[bool] query does not support [" + currentFieldName + "]");, +                }, +            } else if (token == XContentParser.Token.START_ARRAY) {, +                while ((token = parser.nextToken()) != XContentParser.Token.END_ARRAY) {, +                    switch (currentFieldName) {, +                    case MUST:, +                        query = parseContext.parseInnerQueryBuilder();, +                        mustClauses.add(query);, +                        break;, +                    case SHOULD:, +                        query = parseContext.parseInnerQueryBuilder();, +                        shouldClauses.add(query);, +                        break;, +                    case FILTER:, +                        query = parseContext.parseInnerQueryBuilder();, +                        filterClauses.add(query);, +                        break;, +                    case MUST_NOT:, +                    case MUSTNOT:, +                        query = parseContext.parseInnerQueryBuilder();, +                        mustNotClauses.add(query);, +                        break;, +                    default:, +                        throw new ParsingException(parser.getTokenLocation(), "bool query does not support [" + currentFieldName + "]");, +                    }, +                }, +            } else if (token.isValue()) {, +                if (parseContext.parseFieldMatcher().match(currentFieldName, DISABLE_COORD_FIELD)) {, +                    disableCoord = parser.booleanValue();, +                } else if (parseContext.parseFieldMatcher().match(currentFieldName, MINIMUM_SHOULD_MATCH)) {, +                    minimumShouldMatch = parser.textOrNull();, +                } else if (parseContext.parseFieldMatcher().match(currentFieldName, AbstractQueryBuilder.BOOST_FIELD)) {]