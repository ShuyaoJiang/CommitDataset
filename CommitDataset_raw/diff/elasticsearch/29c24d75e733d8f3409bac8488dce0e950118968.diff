[+++ b/src/main/java/org/elasticsearch/search/aggregations/TransportAggregationModule.java, +, +++ b/src/main/java/org/elasticsearch/search/aggregations/TransportAggregationModule.java, +, +++ b/src/main/java/org/elasticsearch/search/aggregations/bucket/histogram/DateHistogramParser.java, +, +        return new HistogramAggregator.Factory(aggregationName, vsParser.config(), rounding, order, keyed, minDocCount, extendedBounds,, +                new InternalDateHistogram.Factory());, +++ b/src/main/java/org/elasticsearch/search/aggregations/TransportAggregationModule.java, +, +++ b/src/main/java/org/elasticsearch/search/aggregations/bucket/histogram/DateHistogramParser.java, +, +        return new HistogramAggregator.Factory(aggregationName, vsParser.config(), rounding, order, keyed, minDocCount, extendedBounds,, +                new InternalDateHistogram.Factory());, +++ b/src/main/java/org/elasticsearch/search/aggregations/bucket/histogram/HistogramParser.java, +        return new HistogramAggregator.Factory(aggregationName, vsParser.config(), rounding, order, keyed, minDocCount, extendedBounds,, +                new InternalHistogram.Factory());, +++ b/src/main/java/org/elasticsearch/search/aggregations/TransportAggregationModule.java, +, +++ b/src/main/java/org/elasticsearch/search/aggregations/bucket/histogram/DateHistogramParser.java, +, +        return new HistogramAggregator.Factory(aggregationName, vsParser.config(), rounding, order, keyed, minDocCount, extendedBounds,, +                new InternalDateHistogram.Factory());, +++ b/src/main/java/org/elasticsearch/search/aggregations/bucket/histogram/HistogramParser.java, +        return new HistogramAggregator.Factory(aggregationName, vsParser.config(), rounding, order, keyed, minDocCount, extendedBounds,, +                new InternalHistogram.Factory());, +++ b/src/main/java/org/elasticsearch/search/aggregations/bucket/histogram/InternalDateHistogram.java, +import org.elasticsearch.search.aggregations.InternalAggregation.Type;, +import org.elasticsearch.search.aggregations.bucket.histogram.InternalHistogram.EmptyBucketInfo;, +public class InternalDateHistogram {, +        Bucket(boolean keyed, @Nullable ValueFormatter formatter, InternalHistogram.Factory<Bucket> factory) {, +            super(keyed, formatter, factory);, +        Bucket(long key, long docCount, InternalAggregations aggregations, boolean keyed, @Nullable ValueFormatter formatter,, +                InternalHistogram.Factory<Bucket> factory) {, +            super(key, docCount, keyed, formatter, factory, aggregations);, +        Factory() {, +        public InternalHistogram create(String name, List<InternalDateHistogram.Bucket> buckets, InternalOrder order,, +            return new InternalHistogram(name, buckets, order, minDocCount, emptyBucketInfo, formatter, keyed, this, metaData);, +            return new Bucket(key, docCount, aggregations, keyed, formatter, this);, +        protected InternalDateHistogram.Bucket createEmptyBucket(boolean keyed, @Nullable ValueFormatter formatter) {, +            return new Bucket(keyed, formatter, this);, +        }, +    private InternalDateHistogram() {}, +++ b/src/main/java/org/elasticsearch/search/aggregations/TransportAggregationModule.java, +, +++ b/src/main/java/org/elasticsearch/search/aggregations/bucket/histogram/DateHistogramParser.java, +, +        return new HistogramAggregator.Factory(aggregationName, vsParser.config(), rounding, order, keyed, minDocCount, extendedBounds,, +                new InternalDateHistogram.Factory());, +++ b/src/main/java/org/elasticsearch/search/aggregations/bucket/histogram/HistogramParser.java, +        return new HistogramAggregator.Factory(aggregationName, vsParser.config(), rounding, order, keyed, minDocCount, extendedBounds,, +                new InternalHistogram.Factory());, +++ b/src/main/java/org/elasticsearch/search/aggregations/bucket/histogram/InternalDateHistogram.java, +import org.elasticsearch.search.aggregations.InternalAggregation.Type;, +import org.elasticsearch.search.aggregations.bucket.histogram.InternalHistogram.EmptyBucketInfo;, +public class InternalDateHistogram {, +        Bucket(boolean keyed, @Nullable ValueFormatter formatter, InternalHistogram.Factory<Bucket> factory) {, +            super(keyed, formatter, factory);, +        Bucket(long key, long docCount, InternalAggregations aggregations, boolean keyed, @Nullable ValueFormatter formatter,, +                InternalHistogram.Factory<Bucket> factory) {, +            super(key, docCount, keyed, formatter, factory, aggregations);, +        Factory() {, +        public InternalHistogram create(String name, List<InternalDateHistogram.Bucket> buckets, InternalOrder order,, +            return new InternalHistogram(name, buckets, order, minDocCount, emptyBucketInfo, formatter, keyed, this, metaData);, +            return new Bucket(key, docCount, aggregations, keyed, formatter, this);, +        protected InternalDateHistogram.Bucket createEmptyBucket(boolean keyed, @Nullable ValueFormatter formatter) {, +            return new Bucket(keyed, formatter, this);, +        }, +    private InternalDateHistogram() {}, +++ b/src/main/java/org/elasticsearch/search/aggregations/bucket/histogram/InternalHistogram.java, +import org.elasticsearch.ElasticsearchIllegalStateException;, +            Factory<?> factory = (Factory<?>) context.attributes().get("factory");, +            if (factory == null) {, +                throw new ElasticsearchIllegalStateException("No factory found for histogram buckets");, +            }, +            Bucket histogram = new Bucket(context.keyed(), context.formatter(), factory);, +        private Factory<?> factory;, +        public Bucket(boolean keyed, @Nullable ValueFormatter formatter, Factory<?> factory) {, +            this.factory = factory;, +        public Bucket(long key, long docCount, boolean keyed, @Nullable ValueFormatter formatter, Factory factory,, +                InternalAggregations aggregations) {, +            this(keyed, formatter, factory);, +            return factory;, +            return new InternalHistogram<>(name, buckets, order, minDocCount, emptyBucketInfo, formatter, keyed, this, metaData);, +            return (B) new Bucket(key, docCount, keyed, formatter, this, aggregations);, +        }, +, +        protected B createEmptyBucket(boolean keyed, @Nullable ValueFormatter formatter) {, +            return (B) new Bucket(keyed, formatter, this);, +    protected Factory<B> factory;, + EmptyBucketInfo emptyBucketInfo,, +            @Nullable ValueFormatter formatter, boolean keyed, Factory<B> factory, Map<String, Object> metaData) {, +        this.factory = factory;, +        return factory;, +                        iter.add(getFactory().createBucket(key, 0, emptyBucketInfo.subAggregations, keyed, formatter));, +                            iter.add(getFactory().createBucket(key, 0, emptyBucketInfo.subAggregations, keyed, formatter));, +                    iter.add(getFactory().createBucket(key, 0, emptyBucketInfo.subAggregations, keyed, formatter));, +                iter.add(getFactory().createBucket(key, 0, emptyBucketInfo.subAggregations, keyed, formatter));, +        this.factory = resolveFactory(in.readString());, +            B bucket = getFactory().createEmptyBucket(keyed, formatter);]