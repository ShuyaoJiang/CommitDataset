[+++ b/core/src/main/java/org/elasticsearch/indices/analysis/AnalysisModule.java, +import org.elasticsearch.index.analysis.WordDelimiterGraphTokenFilterFactory;, +        tokenFilters.register("word_delimiter_graph", WordDelimiterGraphTokenFilterFactory::new);, +++ b/core/src/main/java/org/elasticsearch/indices/analysis/AnalysisModule.java, +import org.elasticsearch.index.analysis.WordDelimiterGraphTokenFilterFactory;, +        tokenFilters.register("word_delimiter_graph", WordDelimiterGraphTokenFilterFactory::new);, +++ b/core/src/main/java/org/elasticsearch/indices/analysis/PreBuiltTokenFilters.java, +import org.apache.lucene.analysis.miscellaneous.WordDelimiterGraphFilter;, +    WORD_DELIMITER_GRAPH(CachingStrategy.ONE) {, +        @Override, +        public TokenStream create(TokenStream tokenStream, Version version) {, +            return new WordDelimiterGraphFilter(tokenStream,, +                WordDelimiterGraphFilter.GENERATE_WORD_PARTS |, +                    WordDelimiterGraphFilter.GENERATE_NUMBER_PARTS |, +                    WordDelimiterGraphFilter.SPLIT_ON_CASE_CHANGE |, +                    WordDelimiterGraphFilter.SPLIT_ON_NUMERICS |, +                    WordDelimiterGraphFilter.STEM_ENGLISH_POSSESSIVE, null);, +        }, +    },, +, +++ b/core/src/main/java/org/elasticsearch/indices/analysis/AnalysisModule.java, +import org.elasticsearch.index.analysis.WordDelimiterGraphTokenFilterFactory;, +        tokenFilters.register("word_delimiter_graph", WordDelimiterGraphTokenFilterFactory::new);, +++ b/core/src/main/java/org/elasticsearch/indices/analysis/PreBuiltTokenFilters.java, +import org.apache.lucene.analysis.miscellaneous.WordDelimiterGraphFilter;, +    WORD_DELIMITER_GRAPH(CachingStrategy.ONE) {, +        @Override, +        public TokenStream create(TokenStream tokenStream, Version version) {, +            return new WordDelimiterGraphFilter(tokenStream,, +                WordDelimiterGraphFilter.GENERATE_WORD_PARTS |, +                    WordDelimiterGraphFilter.GENERATE_NUMBER_PARTS |, +                    WordDelimiterGraphFilter.SPLIT_ON_CASE_CHANGE |, +                    WordDelimiterGraphFilter.SPLIT_ON_NUMERICS |, +                    WordDelimiterGraphFilter.STEM_ENGLISH_POSSESSIVE, null);, +        }, +    },, +, +++ b/core/src/main/java/org/elasticsearch/search/fetch/subphase/highlight/AbstractHighlighterBuilder.java, +import org.elasticsearch.Version;, +import org.elasticsearch.search.fetch.subphase.highlight.HighlightBuilder.BoundaryScannerType;, +import java.util.Locale;, +    public static final ParseField BOUNDARY_SCANNER_FIELD = new ParseField("boundary_scanner");, +    public static final ParseField BOUNDARY_SCANNER_LOCALE_FIELD = new ParseField("boundary_scanner_locale");, +    protected BoundaryScannerType boundaryScannerType;, +, +    protected Locale boundaryScannerLocale;, +, +        if (in.getVersion().onOrAfter(Version.V_5_4_0_UNRELEASED)) {, +            boundaryScannerType(in.readOptionalWriteable(BoundaryScannerType::readFromStream));, +        }, +        if (in.getVersion().onOrAfter(Version.V_5_4_0_UNRELEASED)) {, +            if (in.readBoolean()) {, +                boundaryScannerLocale(in.readString());, +            }, +        }, +        if (out.getVersion().onOrAfter(Version.V_5_4_0_UNRELEASED)) {, +            out.writeOptionalWriteable(boundaryScannerType);, +        }, +        if (out.getVersion().onOrAfter(Version.V_5_4_0_UNRELEASED)) {, +            boolean hasBoundaryScannerLocale = boundaryScannerLocale != null;, +            out.writeBoolean(hasBoundaryScannerLocale);, +            if (hasBoundaryScannerLocale) {, +                out.writeString(boundaryScannerLocale.toLanguageTag());, +            }, +        }, +     * controls which scanner to use for fragment boundaries, and defaults to "simple"., +     */, +    @SuppressWarnings("unchecked"), +    public HB boundaryScannerType(String boundaryScannerType) {, +        this.boundaryScannerType = BoundaryScannerType.fromString(boundaryScannerType);, +        return (HB) this;, +    }, +, +    /**, +     * When using the highlighterType <tt>fvh</tt> this setting, +     * controls which scanner to use for fragment boundaries, and defaults to "simple"., +     */, +    @SuppressWarnings("unchecked"), +    public HB boundaryScannerType(BoundaryScannerType boundaryScannerType) {, +        this.boundaryScannerType = boundaryScannerType;, +        return (HB) this;, +    }, +, +    /**, +     * @return the value set by {@link #boundaryScannerType(String)}, +     */, +    public BoundaryScannerType boundaryScannerType() {, +        return this.boundaryScannerType;, +    }, +, +    /**, +     * When using the highlighterType <tt>fvh</tt> this setting, +     * When using the highlighterType <tt>fvh</tt> and boundaryScannerType <tt>break_iterator</tt>, this setting, +     * controls the locale to use by the BreakIterator, defaults to "root"., +     */, +    @SuppressWarnings("unchecked"), +    public HB boundaryScannerLocale(String boundaryScannerLocale) {, +        if (boundaryScannerLocale != null) {, +            this.boundaryScannerLocale = Locale.forLanguageTag(boundaryScannerLocale);, +        }]