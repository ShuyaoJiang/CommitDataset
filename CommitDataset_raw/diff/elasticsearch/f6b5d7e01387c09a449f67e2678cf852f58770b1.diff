[+++ b/server/src/main/java/org/elasticsearch/common/lucene/uid/PerThreadIDVersionAndSeqNoLookup.java, +    public DocIdAndVersion lookupVersion(BytesRef id, boolean loadSeqNo, LeafReaderContext context), +            final long seqNo;, +            final long term;, +            if (loadSeqNo) {, +                NumericDocValues seqNos = context.reader().getNumericDocValues(SeqNoFieldMapper.NAME);, +                // remove the null check in 7.0 once we can't read indices with no seq#, +                if (seqNos != null && seqNos.advanceExact(docID)) {, +                    seqNo = seqNos.longValue();, +                } else {, +                    seqNo =  SequenceNumbers.UNASSIGNED_SEQ_NO;, +                }, +                NumericDocValues terms = context.reader().getNumericDocValues(SeqNoFieldMapper.PRIMARY_TERM_NAME);, +                if (terms != null && terms.advanceExact(docID)) {, +                    term = terms.longValue();, +                } else {, +                    term = 0;, +                }, +, +            } else {, +                seqNo = SequenceNumbers.UNASSIGNED_SEQ_NO;, +                term = 0;, +            }, +            return new DocIdAndVersion(docID, versions.longValue(), seqNo, term, context.reader(), context.docBase);, +                    // remove the null check in 7.0 once we can't read indices with no seq#, +++ b/server/src/main/java/org/elasticsearch/common/lucene/uid/PerThreadIDVersionAndSeqNoLookup.java, +    public DocIdAndVersion lookupVersion(BytesRef id, boolean loadSeqNo, LeafReaderContext context), +            final long seqNo;, +            final long term;, +            if (loadSeqNo) {, +                NumericDocValues seqNos = context.reader().getNumericDocValues(SeqNoFieldMapper.NAME);, +                // remove the null check in 7.0 once we can't read indices with no seq#, +                if (seqNos != null && seqNos.advanceExact(docID)) {, +                    seqNo = seqNos.longValue();, +                } else {, +                    seqNo =  SequenceNumbers.UNASSIGNED_SEQ_NO;, +                }, +                NumericDocValues terms = context.reader().getNumericDocValues(SeqNoFieldMapper.PRIMARY_TERM_NAME);, +                if (terms != null && terms.advanceExact(docID)) {, +                    term = terms.longValue();, +                } else {, +                    term = 0;, +                }, +, +            } else {, +                seqNo = SequenceNumbers.UNASSIGNED_SEQ_NO;, +                term = 0;, +            }, +            return new DocIdAndVersion(docID, versions.longValue(), seqNo, term, context.reader(), context.docBase);, +                    // remove the null check in 7.0 once we can't read indices with no seq#, +++ b/server/src/main/java/org/elasticsearch/common/lucene/uid/VersionsAndSeqNoResolver.java, +        public final long seqNo;, +        public final long primaryTerm;, +        public DocIdAndVersion(int docId, long version, long seqNo, long primaryTerm, LeafReader reader, int docBase) {, +            this.seqNo = seqNo;, +            this.primaryTerm = primaryTerm;, +    public static DocIdAndVersion loadDocIdAndVersion(IndexReader reader, Term term, boolean loadSeqNo) throws IOException {, +            DocIdAndVersion result = lookup.lookupVersion(term.bytes(), loadSeqNo, leaf);, +++ b/server/src/main/java/org/elasticsearch/common/lucene/uid/PerThreadIDVersionAndSeqNoLookup.java, +    public DocIdAndVersion lookupVersion(BytesRef id, boolean loadSeqNo, LeafReaderContext context), +            final long seqNo;, +            final long term;, +            if (loadSeqNo) {, +                NumericDocValues seqNos = context.reader().getNumericDocValues(SeqNoFieldMapper.NAME);, +                // remove the null check in 7.0 once we can't read indices with no seq#, +                if (seqNos != null && seqNos.advanceExact(docID)) {, +                    seqNo = seqNos.longValue();, +                } else {, +                    seqNo =  SequenceNumbers.UNASSIGNED_SEQ_NO;, +                }, +                NumericDocValues terms = context.reader().getNumericDocValues(SeqNoFieldMapper.PRIMARY_TERM_NAME);, +                if (terms != null && terms.advanceExact(docID)) {, +                    term = terms.longValue();, +                } else {, +                    term = 0;, +                }, +, +            } else {, +                seqNo = SequenceNumbers.UNASSIGNED_SEQ_NO;, +                term = 0;, +            }, +            return new DocIdAndVersion(docID, versions.longValue(), seqNo, term, context.reader(), context.docBase);, +                    // remove the null check in 7.0 once we can't read indices with no seq#, +++ b/server/src/main/java/org/elasticsearch/common/lucene/uid/VersionsAndSeqNoResolver.java, +        public final long seqNo;, +        public final long primaryTerm;, +        public DocIdAndVersion(int docId, long version, long seqNo, long primaryTerm, LeafReader reader, int docBase) {, +            this.seqNo = seqNo;, +            this.primaryTerm = primaryTerm;, +    public static DocIdAndVersion loadDocIdAndVersion(IndexReader reader, Term term, boolean loadSeqNo) throws IOException {, +            DocIdAndVersion result = lookup.lookupVersion(term.bytes(), loadSeqNo, leaf);, +++ b/server/src/main/java/org/elasticsearch/index/engine/Engine.java, +            docIdAndVersion = VersionsAndSeqNoResolver.loadDocIdAndVersion(searcher.reader(), get.uid(), true);, +        private final long ifSeqNoMatch;, +        private final long ifPrimaryTermMatch;, +                     long startTime, long autoGeneratedIdTimestamp, boolean isRetry, long ifSeqNoMatch, long ifPrimaryTermMatch) {, +            assert ifPrimaryTermMatch >= 0 : "ifPrimaryTermMatch [" + ifPrimaryTermMatch + "] must be non negative";, +            assert ifSeqNoMatch == SequenceNumbers.UNASSIGNED_SEQ_NO || ifSeqNoMatch >=0 :, +                "ifSeqNoMatch [" + ifSeqNoMatch + "] must be non negative or unset";, +            assert (origin == Origin.PRIMARY) || (ifSeqNoMatch == SequenceNumbers.UNASSIGNED_SEQ_NO && ifPrimaryTermMatch == 0) :]