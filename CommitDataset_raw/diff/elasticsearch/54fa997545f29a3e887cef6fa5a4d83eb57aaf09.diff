[+++ b/modules/reindex/src/main/java/org/elasticsearch/index/reindex/TransportReindexAction.java, +                RestClient restClient = RestClient.builder(, +                        new HttpHost(remoteInfo.getHost(), remoteInfo.getPort(), remoteInfo.getScheme())).build();, +                return new RemoteScrollableHitSource(logger, backoffPolicy, threadPool, task::countSearchRetry,, +                        this::finishHim, restClient, remoteInfo.getQuery(), mainRequest.getSearchRequest());, +++ b/modules/reindex/src/main/java/org/elasticsearch/index/reindex/TransportReindexAction.java, +                RestClient restClient = RestClient.builder(, +                        new HttpHost(remoteInfo.getHost(), remoteInfo.getPort(), remoteInfo.getScheme())).build();, +                return new RemoteScrollableHitSource(logger, backoffPolicy, threadPool, task::countSearchRetry,, +                        this::finishHim, restClient, remoteInfo.getQuery(), mainRequest.getSearchRequest());, +++ b/modules/reindex/src/main/java/org/elasticsearch/index/reindex/remote/RemoteScrollableHitSource.java, +import org.elasticsearch.client.ResponseListener;, +    private final RestClient client;, +            Consumer<Exception> fail, RestClient client, BytesReference query, SearchRequest searchRequest) {, +    private void onStartResponse(Consumer<? super Response> onResponse, Response response) {, +            public void onSuccess(org.elasticsearch.client.Response response) {, +    private <T> void execute(String method, String uri, Map<String, String> params, HttpEntity entity,, +                    public void onSuccess(org.elasticsearch.client.Response response) {, +                        T parsedResponse;, +                            InputStream content = response.getEntity().getContent();, +                                parsedResponse = parser.apply(xContentParser, () -> ParseFieldMatcher.STRICT);, +                        listener.accept(parsedResponse);, +                        if (e instanceof ResponseException) {, +                            ResponseException re = (ResponseException) e;, +                            if (RestStatus.TOO_MANY_REQUESTS.getStatus() == re.getResponse().getStatusLine().getStatusCode()) {, +                                    logger.trace("retrying rejected search after [{}]", e, delay);, +                                    return;, +                        }, +                        fail.accept(e);, +                    }, +++ b/modules/reindex/src/main/java/org/elasticsearch/index/reindex/TransportReindexAction.java, +                RestClient restClient = RestClient.builder(, +                        new HttpHost(remoteInfo.getHost(), remoteInfo.getPort(), remoteInfo.getScheme())).build();, +                return new RemoteScrollableHitSource(logger, backoffPolicy, threadPool, task::countSearchRetry,, +                        this::finishHim, restClient, remoteInfo.getQuery(), mainRequest.getSearchRequest());, +++ b/modules/reindex/src/main/java/org/elasticsearch/index/reindex/remote/RemoteScrollableHitSource.java, +import org.elasticsearch.client.ResponseListener;, +    private final RestClient client;, +            Consumer<Exception> fail, RestClient client, BytesReference query, SearchRequest searchRequest) {, +    private void onStartResponse(Consumer<? super Response> onResponse, Response response) {, +            public void onSuccess(org.elasticsearch.client.Response response) {, +    private <T> void execute(String method, String uri, Map<String, String> params, HttpEntity entity,, +                    public void onSuccess(org.elasticsearch.client.Response response) {, +                        T parsedResponse;, +                            InputStream content = response.getEntity().getContent();, +                                parsedResponse = parser.apply(xContentParser, () -> ParseFieldMatcher.STRICT);, +                        listener.accept(parsedResponse);, +                        if (e instanceof ResponseException) {, +                            ResponseException re = (ResponseException) e;, +                            if (RestStatus.TOO_MANY_REQUESTS.getStatus() == re.getResponse().getStatusLine().getStatusCode()) {, +                                    logger.trace("retrying rejected search after [{}]", e, delay);, +                                    return;, +                        }, +                        fail.accept(e);, +                    }, +++ b/modules/reindex/src/test/java/org/elasticsearch/index/reindex/remote/RemoteScrollableHitSourceTests.java, +import org.apache.http.HttpEntityEnclosingRequest;, +import org.apache.http.HttpHost;, +import org.apache.http.HttpResponse;, +import org.apache.http.ProtocolVersion;, +import org.apache.http.StatusLine;, +import org.apache.http.concurrent.FutureCallback;, +import org.apache.http.entity.InputStreamEntity;, +import org.apache.http.impl.nio.client.CloseableHttpAsyncClient;, +import org.apache.http.impl.nio.client.HttpAsyncClientBuilder;, +import org.apache.http.message.BasicHttpResponse;, +import org.apache.http.message.BasicStatusLine;, +import org.apache.http.nio.protocol.HttpAsyncRequestProducer;, +import org.apache.http.nio.protocol.HttpAsyncResponseConsumer;, +import org.elasticsearch.client.RestClient;, +import org.elasticsearch.rest.RestStatus;, +import org.mockito.invocation.InvocationOnMock;, +import org.mockito.stubbing.Answer;, +import java.util.concurrent.Future;, +import static org.mockito.Matchers.any;, +import static org.mockito.Mockito.mock;, +import static org.mockito.Mockito.when;, +                return Runnable::run;, +    @SuppressWarnings("unchecked"), +, +        CloseableHttpAsyncClient httpClient = mock(CloseableHttpAsyncClient.class);, +        when(httpClient.<HttpResponse>execute(any(HttpAsyncRequestProducer.class), any(HttpAsyncResponseConsumer.class),, +                any(FutureCallback.class))).thenAnswer(new Answer<Future<HttpResponse>>() {, +, +            public Future<HttpResponse> answer(InvocationOnMock invocationOnMock) throws Throwable {, +                HttpAsyncRequestProducer requestProducer = (HttpAsyncRequestProducer) invocationOnMock.getArguments()[0];, +                @SuppressWarnings("unchecked"), +                FutureCallback<HttpResponse> futureCallback = (FutureCallback<HttpResponse>) invocationOnMock.getArguments()[2];, +                HttpEntityEnclosingRequest request = (HttpEntityEnclosingRequest)requestProducer.generateRequest();, +                URL resource = resources[responseCount];, +                String path = paths[responseCount++];, +                ProtocolVersion protocolVersion = new ProtocolVersion("http", 1, 1);, +                if (path.startsWith("fail:")) {, +                    String body = Streams.copyToString(new InputStreamReader(request.getEntity().getContent(), StandardCharsets.UTF_8));, +                    if (path.equals("fail:rejection.json")) {, +                        StatusLine statusLine = new BasicStatusLine(protocolVersion, RestStatus.TOO_MANY_REQUESTS.getStatus(), "");, +                        BasicHttpResponse httpResponse = new BasicHttpResponse(statusLine);, +                        futureCallback.completed(httpResponse);, +                    } else {, +                        futureCallback.failed(new RuntimeException(body));]