[+++ b/server/src/main/java/org/elasticsearch/index/store/Store.java, +            final IndexCommit lastIndexCommitCommit = existingCommits.get(existingCommits.size() - 1);, +            final String translogUUID = lastIndexCommitCommit.getUserData().get(Translog.TRANSLOG_UUID_KEY);, +            if (startingIndexCommit.equals(lastIndexCommitCommit) == false) {, +                /*, +                 * Unlike other commit tags, the retention-leases tag is not restored when an engine is, +                 * recovered from translog. We need to manually copy it from the last commit to the safe commit;, +                 * otherwise we might lose the latest committed retention leases when re-opening an engine., +                 */, +                final Map<String, String> userData = new HashMap<>(startingIndexCommit.getUserData());, +                userData.put(Engine.RETENTION_LEASES, lastIndexCommitCommit.getUserData().getOrDefault(Engine.RETENTION_LEASES, ""));, +                    writer.setLiveCommitData(userData.entrySet());, +++ b/server/src/main/java/org/elasticsearch/index/store/Store.java, +            final IndexCommit lastIndexCommitCommit = existingCommits.get(existingCommits.size() - 1);, +            final String translogUUID = lastIndexCommitCommit.getUserData().get(Translog.TRANSLOG_UUID_KEY);, +            if (startingIndexCommit.equals(lastIndexCommitCommit) == false) {, +                /*, +                 * Unlike other commit tags, the retention-leases tag is not restored when an engine is, +                 * recovered from translog. We need to manually copy it from the last commit to the safe commit;, +                 * otherwise we might lose the latest committed retention leases when re-opening an engine., +                 */, +                final Map<String, String> userData = new HashMap<>(startingIndexCommit.getUserData());, +                userData.put(Engine.RETENTION_LEASES, lastIndexCommitCommit.getUserData().getOrDefault(Engine.RETENTION_LEASES, ""));, +                    writer.setLiveCommitData(userData.entrySet());, +++ b/server/src/test/java/org/elasticsearch/index/shard/IndexShardRetentionLeaseTests.java, +import org.elasticsearch.Version;, +import org.elasticsearch.cluster.node.DiscoveryNode;, +import org.elasticsearch.cluster.routing.ShardRoutingState;, +import org.elasticsearch.index.engine.InternalEngine;, +import org.elasticsearch.indices.recovery.RecoveryState;, +import java.util.ArrayList;, +import java.util.List;, +import java.util.concurrent.atomic.AtomicBoolean;, +import static org.elasticsearch.cluster.routing.TestShardRouting.newShardRouting;, +import static org.hamcrest.Matchers.containsInAnyOrder;, +    public void testRecoverFromStoreReserveRetentionLeases() throws Exception {, +        final AtomicBoolean throwDuringRecoverFromTranslog = new AtomicBoolean();, +        final IndexShard shard = newStartedShard(false, Settings.builder().put("index.soft_deletes.enabled", true).build(),, +            config -> new InternalEngine(config) {, +                @Override, +                public InternalEngine recoverFromTranslog(TranslogRecoveryRunner translogRecoveryRunner,, +                                                          long recoverUpToSeqNo) throws IOException {, +                    if (throwDuringRecoverFromTranslog.get()) {, +                        throw new RuntimeException("crashed before recover from translog is completed");, +                    }, +                    return super.recoverFromTranslog(translogRecoveryRunner, recoverUpToSeqNo);, +                }, +            });, +        final List<RetentionLease> leases = new ArrayList<>();, +        long version = randomLongBetween(0, 100);, +        long primaryTerm = randomLongBetween(1, 100);, +        final int iterations = randomIntBetween(1, 10);, +        for (int i = 0; i < iterations; i++) {, +            if (randomBoolean()) {, +                indexDoc(shard, "_doc", Integer.toString(i));, +            } else {, +                leases.add(new RetentionLease(Integer.toString(i), randomNonNegativeLong(),, +                    randomLongBetween(Integer.MAX_VALUE, Long.MAX_VALUE), "test"));, +            }, +            if (randomBoolean()) {, +                if (randomBoolean()) {, +                    version += randomLongBetween(1, 100);, +                    primaryTerm += randomLongBetween(0, 100);, +                    shard.updateRetentionLeasesOnReplica(new RetentionLeases(primaryTerm, version, leases));, +                    shard.flush(new FlushRequest().force(true).waitIfOngoing(true));, +                }, +            }, +            if (randomBoolean()) {, +                shard.updateGlobalCheckpointOnReplica(randomLongBetween(shard.getGlobalCheckpoint(), shard.getLocalCheckpoint()), "test");, +                flushShard(shard);, +            }, +        }, +        version += randomLongBetween(1, 100);, +        primaryTerm += randomLongBetween(0, 100);, +        shard.updateRetentionLeasesOnReplica(new RetentionLeases(primaryTerm, version, leases));, +        shard.flush(new FlushRequest().force(true).waitIfOngoing(true));, +        closeShard(shard, false);, +, +        final IndexShard failedShard = reinitShard(shard, newShardRouting(shard.routingEntry().shardId(),, +            shard.routingEntry().currentNodeId(), true, ShardRoutingState.INITIALIZING,, +            RecoverySource.ExistingStoreRecoverySource.INSTANCE));, +        final DiscoveryNode localNode = new DiscoveryNode("foo", buildNewFakeTransportAddress(),, +            Collections.emptyMap(), Collections.emptySet(), Version.CURRENT);, +        failedShard.markAsRecovering("store", new RecoveryState(failedShard.routingEntry(), localNode, null));, +        throwDuringRecoverFromTranslog.set(true);, +        expectThrows(IndexShardRecoveryException.class, failedShard::recoverFromStore);, +        closeShards(failedShard);, +, +        final IndexShard newShard = reinitShard(shard, newShardRouting(shard.routingEntry().shardId(),, +            shard.routingEntry().currentNodeId(), true, ShardRoutingState.INITIALIZING,, +            RecoverySource.ExistingStoreRecoverySource.INSTANCE));, +        newShard.markAsRecovering("store", new RecoveryState(failedShard.routingEntry(), localNode, null));, +        throwDuringRecoverFromTranslog.set(false);, +        assertTrue(newShard.recoverFromStore());, +        final RetentionLeases retentionLeases = newShard.getRetentionLeases();, +        assertThat(retentionLeases.version(), equalTo(version));, +        assertThat(retentionLeases.primaryTerm(), equalTo(primaryTerm));, +        if (leases.isEmpty()) {, +            assertThat(retentionLeases.leases(), empty());, +        } else {]