[+++ b/src/main/java/org/elasticsearch/index/fielddata/fieldcomparator/BytesRefFieldComparatorSource.java, +import org.apache.lucene.util.BytesRef;, +import org.apache.lucene.util.UnicodeUtil;, +import org.elasticsearch.ElasticSearchIllegalArgumentException;, +    /** UTF-8 term containing a single code point: {@link Character#MAX_CODE_POINT} which will compare greater than all other index terms, +     *  since {@link Character#MAX_CODE_POINT} is a noncharacter and thus shouldn't appear in an index term. */, +    public static final BytesRef MAX_TERM;, +    static {, +        MAX_TERM = new BytesRef();, +        final char[] chars = Character.toChars(Character.MAX_CODE_POINT);, +        UnicodeUtil.UTF16toUTF8(chars, 0, chars.length, MAX_TERM);, +    }, +, +    private final Object missingValue;, +    public BytesRefFieldComparatorSource(IndexFieldData<?> indexFieldData, Object missingValue, SortMode sortMode) {, +        this.missingValue = missingValue;, +        BytesRef missingBytes = null;, +        if (missingValue == null || "_last".equals(missingValue)) {, +            missingBytes = reversed ? null : MAX_TERM;, +        } else if ("_first".equals(missingValue)) {, +            missingBytes = reversed ? MAX_TERM : null;, +        } else if (missingValue instanceof BytesRef) {, +            missingBytes = (BytesRef) missingValue;, +        } else if (missingValue instanceof String) {, +            missingBytes = new BytesRef((String) missingValue);, +        } else if (missingValue instanceof byte[]) {, +            missingBytes = new BytesRef((byte[]) missingValue);, +        } else {, +            throw new ElasticSearchIllegalArgumentException("Unsupported missing value: " + missingValue);, +        }, +, +            return new BytesRefOrdValComparator((IndexFieldData.WithOrdinals<?>) indexFieldData, numHits, sortMode, missingBytes);, +        return new BytesRefValComparator(indexFieldData, numHits, sortMode, missingBytes);, +, +++ b/src/main/java/org/elasticsearch/index/fielddata/fieldcomparator/BytesRefFieldComparatorSource.java, +import org.apache.lucene.util.BytesRef;, +import org.apache.lucene.util.UnicodeUtil;, +import org.elasticsearch.ElasticSearchIllegalArgumentException;, +    /** UTF-8 term containing a single code point: {@link Character#MAX_CODE_POINT} which will compare greater than all other index terms, +     *  since {@link Character#MAX_CODE_POINT} is a noncharacter and thus shouldn't appear in an index term. */, +    public static final BytesRef MAX_TERM;, +    static {, +        MAX_TERM = new BytesRef();, +        final char[] chars = Character.toChars(Character.MAX_CODE_POINT);, +        UnicodeUtil.UTF16toUTF8(chars, 0, chars.length, MAX_TERM);, +    }, +, +    private final Object missingValue;, +    public BytesRefFieldComparatorSource(IndexFieldData<?> indexFieldData, Object missingValue, SortMode sortMode) {, +        this.missingValue = missingValue;, +        BytesRef missingBytes = null;, +        if (missingValue == null || "_last".equals(missingValue)) {, +            missingBytes = reversed ? null : MAX_TERM;, +        } else if ("_first".equals(missingValue)) {, +            missingBytes = reversed ? MAX_TERM : null;, +        } else if (missingValue instanceof BytesRef) {, +            missingBytes = (BytesRef) missingValue;, +        } else if (missingValue instanceof String) {, +            missingBytes = new BytesRef((String) missingValue);, +        } else if (missingValue instanceof byte[]) {, +            missingBytes = new BytesRef((byte[]) missingValue);, +        } else {, +            throw new ElasticSearchIllegalArgumentException("Unsupported missing value: " + missingValue);, +        }, +, +            return new BytesRefOrdValComparator((IndexFieldData.WithOrdinals<?>) indexFieldData, numHits, sortMode, missingBytes);, +        return new BytesRefValComparator(indexFieldData, numHits, sortMode, missingBytes);, +, +++ b/src/main/java/org/elasticsearch/index/fielddata/fieldcomparator/BytesRefOrdValComparator.java, + *, + * Internally this comparator multiplies ordinals by 4 so that virtual ordinals can be inserted in-between the original field data ordinals., + * Thanks to this, an ordinal for the missing value and the bottom value can be computed and all ordinals are directly comparable. For example,, + * if the field data ordinals are (a,1), (b,2) and (c,3), they will be internally stored as (a,4), (b,8), (c,12). Then the ordinal for the, + * missing value will be computed by binary searching. For example, if the missing value is 'ab', it will be assigned 6 as an ordinal (between, + * 'a' and 'b'. And if the bottom value is 'ac', it will be assigned 7 as an ordinal (between 'ab' and 'b')., +public final class BytesRefOrdValComparator extends NestedWrappableComparator<BytesRef> {, +    final BytesRef missingValue;, +    /* Ords for each slot, times 4., +    long missingOrd;, +    public BytesRefOrdValComparator(IndexFieldData.WithOrdinals<?> indexFieldData, int numHits, SortMode sortMode, BytesRef missingValue) {, +        this.missingValue = missingValue;, +    public int compareBottomMissing() {, +        throw new UnsupportedOperationException();, +    }, +, +    @Override, +    public void missing(int slot) {, +        throw new UnsupportedOperationException();, +    @Override, +    public int compareDocToValue(int doc, BytesRef value) {, +        throw new UnsupportedOperationException();, +    }, +, +    class PerSegmentComparator extends NestedWrappableComparator<BytesRef> {, +        final Ordinals.Docs readerOrds;, +        final BytesValues.WithOrdinals termsIndex;, +, +        public PerSegmentComparator(BytesValues.WithOrdinals termsIndex) {, +            this.readerOrds = termsIndex.ordinals();, +            this.termsIndex = termsIndex;]