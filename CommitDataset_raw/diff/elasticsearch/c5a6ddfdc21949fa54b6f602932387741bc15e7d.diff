[+++ b/core/src/main/java/org/elasticsearch/action/support/replication/ReplicationRequest.java, +    private long routedBasedOnClusterVersion = 0;, +, +    /**, +     * Sets the minimum version of the cluster state that is required on the next node before we redirect to another primary., +     * Used to prevent redirect loops, see also {@link TransportReplicationAction.ReroutePhase#doRun()}, +     */, +    @SuppressWarnings("unchecked"), +    Request routedBasedOnClusterVersion(long routedBasedOnClusterVersion) {, +        this.routedBasedOnClusterVersion = routedBasedOnClusterVersion;, +        return (Request) this;, +    }, +, +    long routedBasedOnClusterVersion() {, +        return routedBasedOnClusterVersion;, +    }, +, +        routedBasedOnClusterVersion = in.readVLong();, +        out.writeVLong(routedBasedOnClusterVersion);, +++ b/core/src/main/java/org/elasticsearch/action/support/replication/ReplicationRequest.java, +    private long routedBasedOnClusterVersion = 0;, +, +    /**, +     * Sets the minimum version of the cluster state that is required on the next node before we redirect to another primary., +     * Used to prevent redirect loops, see also {@link TransportReplicationAction.ReroutePhase#doRun()}, +     */, +    @SuppressWarnings("unchecked"), +    Request routedBasedOnClusterVersion(long routedBasedOnClusterVersion) {, +        this.routedBasedOnClusterVersion = routedBasedOnClusterVersion;, +        return (Request) this;, +    }, +, +    long routedBasedOnClusterVersion() {, +        return routedBasedOnClusterVersion;, +    }, +, +        routedBasedOnClusterVersion = in.readVLong();, +        out.writeVLong(routedBasedOnClusterVersion);, +++ b/core/src/main/java/org/elasticsearch/action/support/replication/TransportReplicationAction.java, +                if (state.version() < request.routedBasedOnClusterVersion()) {, +                    logger.trace("failed to find primary [{}] for request [{}] despite sender thinking it would be here. Local cluster state version [{}]] is older than on sending node (version [{}]), scheduling a retry...", request.shardId(), request, state.version(), request.routedBasedOnClusterVersion());, +                    retryBecauseUnavailable(request.shardId(), "failed to find primary as current cluster state with version [" + state.version() + "] is stale (expected at least [" + request.routedBasedOnClusterVersion() + "]");, +                    return;, +                } else {, +                    // chasing the node with the active primary for a second hop requires that we are at least up-to-date with the current cluster state version, +                    // this prevents redirect loops between two nodes when a primary was relocated and the relocation target is not aware that it is the active primary shard already., +                    request.routedBasedOnClusterVersion(state.version());, +                }, +++ b/core/src/main/java/org/elasticsearch/action/support/replication/ReplicationRequest.java, +    private long routedBasedOnClusterVersion = 0;, +, +    /**, +     * Sets the minimum version of the cluster state that is required on the next node before we redirect to another primary., +     * Used to prevent redirect loops, see also {@link TransportReplicationAction.ReroutePhase#doRun()}, +     */, +    @SuppressWarnings("unchecked"), +    Request routedBasedOnClusterVersion(long routedBasedOnClusterVersion) {, +        this.routedBasedOnClusterVersion = routedBasedOnClusterVersion;, +        return (Request) this;, +    }, +, +    long routedBasedOnClusterVersion() {, +        return routedBasedOnClusterVersion;, +    }, +, +        routedBasedOnClusterVersion = in.readVLong();, +        out.writeVLong(routedBasedOnClusterVersion);, +++ b/core/src/main/java/org/elasticsearch/action/support/replication/TransportReplicationAction.java, +                if (state.version() < request.routedBasedOnClusterVersion()) {, +                    logger.trace("failed to find primary [{}] for request [{}] despite sender thinking it would be here. Local cluster state version [{}]] is older than on sending node (version [{}]), scheduling a retry...", request.shardId(), request, state.version(), request.routedBasedOnClusterVersion());, +                    retryBecauseUnavailable(request.shardId(), "failed to find primary as current cluster state with version [" + state.version() + "] is stale (expected at least [" + request.routedBasedOnClusterVersion() + "]");, +                    return;, +                } else {, +                    // chasing the node with the active primary for a second hop requires that we are at least up-to-date with the current cluster state version, +                    // this prevents redirect loops between two nodes when a primary was relocated and the relocation target is not aware that it is the active primary shard already., +                    request.routedBasedOnClusterVersion(state.version());, +                }, +++ b/core/src/test/java/org/elasticsearch/action/support/replication/TransportReplicationActionTests.java, +import org.elasticsearch.cluster.routing.allocation.AllocationService;, +import org.elasticsearch.cluster.routing.allocation.RoutingAllocation;, +import org.elasticsearch.test.ESAllocationTestCase;, +import java.util.Arrays;, +    /**, +     * When relocating a primary shard, there is a cluster state update at the end of relocation where the active primary is switched from, +     * the relocation source to the relocation target. If relocation source receives and processes this cluster state, +     * before the relocation target, there is a time span where relocation source believes active primary to be on, +     * relocation target and relocation target believes active primary to be on relocation source. This results in replication, +     * requests being sent back and forth., +     *, +     * This test checks that replication request is not routed back from relocation target to relocation source in case of, +     * stale index routing table on relocation target., +     */, +    public void testNoRerouteOnStaleClusterState() throws InterruptedException, ExecutionException {, +        final String index = "test";, +        final ShardId shardId = new ShardId(index, 0);, +        ClusterState state = state(index, true, ShardRoutingState.RELOCATING);, +        String relocationTargetNode = state.getRoutingTable().shardRoutingTable(shardId).primaryShard().relocatingNodeId();, +        state = ClusterState.builder(state).nodes(DiscoveryNodes.builder(state.nodes()).localNodeId(relocationTargetNode)).build();, +        clusterService.setState(state);, +        logger.debug("--> relocation ongoing state:\n{}", clusterService.state().prettyPrint());]