[+++ b/src/main/java/org/elasticsearch/percolator/PercolatorService.java, +import org.elasticsearch.action.ActionListener;, +import org.elasticsearch.cluster.action.index.MappingUpdatedAction;, +import org.elasticsearch.cluster.node.DiscoveryNode;, +    private final MappingUpdatedAction mappingUpdatedAction;, +                             AggregationPhase aggregationPhase, ScriptService scriptService,, +                             MappingUpdatedAction mappingUpdatedAction) {, +        this.mappingUpdatedAction = mappingUpdatedAction;, +                        if (doc.mappingsModified()) {, +                            updateMappingOnMaster(docMapper, request, documentIndexService.indexUUID());, +                        }, +    // TODO: maybe move this logic into MappingUpdatedAction? There is similar logic for the index and bulk api now., +    private void updateMappingOnMaster(DocumentMapper documentMapper, final PercolateShardRequest request, String indexUUID) {, +        // we generate the order id before we get the mapping to send and refresh the source, so, +        // if 2 happen concurrently, we know that the later order will include the previous one, +        long orderId = mappingUpdatedAction.generateNextMappingUpdateOrder();, +        documentMapper.refreshSource();, +        DiscoveryNode node = clusterService.localNode();, +        final MappingUpdatedAction.MappingUpdatedRequest mappingRequest = new MappingUpdatedAction.MappingUpdatedRequest(, +                request.index(), indexUUID, request.documentType(), documentMapper.mappingSource(), orderId, node != null ? node.id() : null, +        );, +        logger.trace("Sending mapping updated to master: {}", mappingRequest);, +        mappingUpdatedAction.execute(mappingRequest, new ActionListener<MappingUpdatedAction.MappingUpdatedResponse>() {, +            @Override, +            public void onResponse(MappingUpdatedAction.MappingUpdatedResponse mappingUpdatedResponse) {, +                // all is well, +                logger.debug("Successfully updated master with mapping update: {}", mappingRequest);, +            }, +, +            @Override, +            public void onFailure(Throwable e) {, +                logger.warn("Failed to update master on updated mapping for {}", e, mappingRequest);, +            }, +        });, +    }, +, +++ b/src/main/java/org/elasticsearch/percolator/PercolatorService.java, +import org.elasticsearch.action.ActionListener;, +import org.elasticsearch.cluster.action.index.MappingUpdatedAction;, +import org.elasticsearch.cluster.node.DiscoveryNode;, +    private final MappingUpdatedAction mappingUpdatedAction;, +                             AggregationPhase aggregationPhase, ScriptService scriptService,, +                             MappingUpdatedAction mappingUpdatedAction) {, +        this.mappingUpdatedAction = mappingUpdatedAction;, +                        if (doc.mappingsModified()) {, +                            updateMappingOnMaster(docMapper, request, documentIndexService.indexUUID());, +                        }, +    // TODO: maybe move this logic into MappingUpdatedAction? There is similar logic for the index and bulk api now., +    private void updateMappingOnMaster(DocumentMapper documentMapper, final PercolateShardRequest request, String indexUUID) {, +        // we generate the order id before we get the mapping to send and refresh the source, so, +        // if 2 happen concurrently, we know that the later order will include the previous one, +        long orderId = mappingUpdatedAction.generateNextMappingUpdateOrder();, +        documentMapper.refreshSource();, +        DiscoveryNode node = clusterService.localNode();, +        final MappingUpdatedAction.MappingUpdatedRequest mappingRequest = new MappingUpdatedAction.MappingUpdatedRequest(, +                request.index(), indexUUID, request.documentType(), documentMapper.mappingSource(), orderId, node != null ? node.id() : null, +        );, +        logger.trace("Sending mapping updated to master: {}", mappingRequest);, +        mappingUpdatedAction.execute(mappingRequest, new ActionListener<MappingUpdatedAction.MappingUpdatedResponse>() {, +            @Override, +            public void onResponse(MappingUpdatedAction.MappingUpdatedResponse mappingUpdatedResponse) {, +                // all is well, +                logger.debug("Successfully updated master with mapping update: {}", mappingRequest);, +            }, +, +            @Override, +            public void onFailure(Throwable e) {, +                logger.warn("Failed to update master on updated mapping for {}", e, mappingRequest);, +            }, +        });, +    }, +, +++ b/src/test/java/org/elasticsearch/percolator/PercolatorTests.java, +import org.elasticsearch.action.admin.cluster.tasks.PendingClusterTasksResponse;, +import org.elasticsearch.common.Priority;, +        createIndex("index", "test");, +                for (Client client : cluster()) {, +                    GetMappingsResponse getMappingsResponse = client.admin().indices().prepareGetMappings("test1", "test2").get();, +                    if (!hasPercolatorType) {, +, +                    if (!getMappingsResponse.getMappings().get("test2").containsKey(PercolatorService.TYPE_NAME)) {, +                        return false;, +                    }, +                }, +                return true;, +    @Test, +    public void testPercolationWithDynamicTemplates() throws Exception {, +        assertAcked(prepareCreate("idx").addMapping("type", jsonBuilder().startObject().startObject("type"), +                .field("dynamic", false), +                .startObject("properties"), +                .startObject("custom"), +                .field("dynamic", true), +                .field("type", "object"), +                .field("incude_in_all", false), +                .endObject(), +                .endObject(), +                .startArray("dynamic_template"), +                .startObject(), +                .startObject("custom_fields"), +                .field("path_match", "custom.*")]