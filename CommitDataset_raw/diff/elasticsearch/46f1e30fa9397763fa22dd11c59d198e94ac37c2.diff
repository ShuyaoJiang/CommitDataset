[+++ b/src/main/java/org/elasticsearch/index/gateway/local/LocalIndexShardGateway.java, +import org.elasticsearch.cluster.action.index.MappingUpdatedAction;, +import org.elasticsearch.index.engine.Engine;, +import org.elasticsearch.index.service.IndexService;, +    private final MappingUpdatedAction mappingUpdatedAction;, +    private final IndexService indexService;, +    public LocalIndexShardGateway(ShardId shardId, @IndexSettings Settings indexSettings, ThreadPool threadPool, MappingUpdatedAction mappingUpdatedAction,, +                                  IndexService indexService, IndexShard indexShard) {, +        this.mappingUpdatedAction = mappingUpdatedAction;, +        this.indexService = indexService;, +                    Engine.IndexingOperation potentialIndexOperation = indexShard.performRecoveryOperation(operation);, +                    if (potentialIndexOperation != null) {, +                        mappingUpdatedAction.updateMappingOnMaster(indexService.index().name(), potentialIndexOperation.docMapper(), indexService.indexUUID());, +                    }, +++ b/src/main/java/org/elasticsearch/index/gateway/local/LocalIndexShardGateway.java, +import org.elasticsearch.cluster.action.index.MappingUpdatedAction;, +import org.elasticsearch.index.engine.Engine;, +import org.elasticsearch.index.service.IndexService;, +    private final MappingUpdatedAction mappingUpdatedAction;, +    private final IndexService indexService;, +    public LocalIndexShardGateway(ShardId shardId, @IndexSettings Settings indexSettings, ThreadPool threadPool, MappingUpdatedAction mappingUpdatedAction,, +                                  IndexService indexService, IndexShard indexShard) {, +        this.mappingUpdatedAction = mappingUpdatedAction;, +        this.indexService = indexService;, +                    Engine.IndexingOperation potentialIndexOperation = indexShard.performRecoveryOperation(operation);, +                    if (potentialIndexOperation != null) {, +                        mappingUpdatedAction.updateMappingOnMaster(indexService.index().name(), potentialIndexOperation.docMapper(), indexService.indexUUID());, +                    }, +++ b/src/main/java/org/elasticsearch/index/shard/service/InternalIndexShard.java, +    /**, +     * Performs a single recovery operation, and returns the indexing operation (or null if its not an indexing operation), +     * that can then be used for mapping updates (for example) if needed., +     */, +    public Engine.IndexingOperation performRecoveryOperation(Translog.Operation operation) throws ElasticsearchException {, +        Engine.IndexingOperation indexOperation = null;, +                    Engine.Create engineCreate = prepareCreate(, +                            create.version(), create.versionType().versionTypeForReplicationAndRecovery(), Engine.Operation.Origin.RECOVERY, true, false);, +                    engine.create(engineCreate);, +                    indexOperation = engineCreate;, +                    Engine.Index engineIndex = prepareIndex(source(index.source()).type(index.type()).id(index.id()), +                            index.version(), index.versionType().versionTypeForReplicationAndRecovery(), Engine.Operation.Origin.RECOVERY, true);, +                    engine.index(engineIndex);, +                    indexOperation = engineIndex;, +        return indexOperation;, +++ b/src/main/java/org/elasticsearch/index/gateway/local/LocalIndexShardGateway.java, +import org.elasticsearch.cluster.action.index.MappingUpdatedAction;, +import org.elasticsearch.index.engine.Engine;, +import org.elasticsearch.index.service.IndexService;, +    private final MappingUpdatedAction mappingUpdatedAction;, +    private final IndexService indexService;, +    public LocalIndexShardGateway(ShardId shardId, @IndexSettings Settings indexSettings, ThreadPool threadPool, MappingUpdatedAction mappingUpdatedAction,, +                                  IndexService indexService, IndexShard indexShard) {, +        this.mappingUpdatedAction = mappingUpdatedAction;, +        this.indexService = indexService;, +                    Engine.IndexingOperation potentialIndexOperation = indexShard.performRecoveryOperation(operation);, +                    if (potentialIndexOperation != null) {, +                        mappingUpdatedAction.updateMappingOnMaster(indexService.index().name(), potentialIndexOperation.docMapper(), indexService.indexUUID());, +                    }, +++ b/src/main/java/org/elasticsearch/index/shard/service/InternalIndexShard.java, +    /**, +     * Performs a single recovery operation, and returns the indexing operation (or null if its not an indexing operation), +     * that can then be used for mapping updates (for example) if needed., +     */, +    public Engine.IndexingOperation performRecoveryOperation(Translog.Operation operation) throws ElasticsearchException {, +        Engine.IndexingOperation indexOperation = null;, +                    Engine.Create engineCreate = prepareCreate(, +                            create.version(), create.versionType().versionTypeForReplicationAndRecovery(), Engine.Operation.Origin.RECOVERY, true, false);, +                    engine.create(engineCreate);, +                    indexOperation = engineCreate;, +                    Engine.Index engineIndex = prepareIndex(source(index.source()).type(index.type()).id(index.id()), +                            index.version(), index.versionType().versionTypeForReplicationAndRecovery(), Engine.Operation.Origin.RECOVERY, true);, +                    engine.index(engineIndex);, +                    indexOperation = engineIndex;, +        return indexOperation;, +++ b/src/test/java/org/elasticsearch/gateway/local/LocalGatewayIndexStateTests.java, +import org.elasticsearch.test.hamcrest.ElasticsearchAssertions;, +import static org.elasticsearch.test.ElasticsearchIntegrationTest.Scope;, +import static org.elasticsearch.test.hamcrest.ElasticsearchAssertions.assertAcked;, +        ensureYellow();, +        ensureYellow();, +        ensureGreen();, +        ensureGreen();, +        ensureGreen();, +        ensureGreen();, +        ensureGreen();, +        ensureGreen();, +        // we need to wait for mapping on master since the mapping update from translog update might get delayed, +        waitForMappingOnMaster("test", "type1");, +        ensureYellow();, +        ensureGreen();, +        ensureGreen();, +        ensureGreen();, +        // we need to wait for mapping on master since the mapping update from translog update might get delayed, +        waitForMappingOnMaster("test", "type1");, +        ensureGreen();, +        ensureGreen();, +        ensureGreen();, +        assertAcked(client().admin().indices().prepareOpen("test").get());, +        ensureGreen();, +        // we need to wait for mapping on master since the mapping update from translog update might get delayed]