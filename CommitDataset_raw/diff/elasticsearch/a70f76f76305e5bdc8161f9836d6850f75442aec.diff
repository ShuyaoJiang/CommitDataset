[+++ b/core/src/main/java/org/elasticsearch/action/support/master/TransportMasterNodeAction.java, +import org.elasticsearch.cluster.ClusterChangedEvent;, +    private static final ClusterStateObserver.ChangePredicate masterNodeChangedPredicate = new ClusterStateObserver.ChangePredicate() {, +        @Override, +        public boolean apply(ClusterState previousState, ClusterState.ClusterStateStatus previousStatus,, +                             ClusterState newState, ClusterState.ClusterStateStatus newStatus) {, +            // The condition !newState.nodes().masterNodeId().equals(previousState.nodes().masterNodeId()) is not sufficient as the same master node might get reelected after a disruption., +            return newState.nodes().masterNodeId() != null && newState != previousState;, +        }, +, +        @Override, +        public boolean apply(ClusterChangedEvent event) {, +            return event.nodesDelta().masterNodeChanged();, +        }, +    };, +, +                                retry(t, masterNodeChangedPredicate);, +                    retry(null, masterNodeChangedPredicate);, +                                retry(cause, masterNodeChangedPredicate);, +++ b/core/src/main/java/org/elasticsearch/action/support/master/TransportMasterNodeAction.java, +import org.elasticsearch.cluster.ClusterChangedEvent;, +    private static final ClusterStateObserver.ChangePredicate masterNodeChangedPredicate = new ClusterStateObserver.ChangePredicate() {, +        @Override, +        public boolean apply(ClusterState previousState, ClusterState.ClusterStateStatus previousStatus,, +                             ClusterState newState, ClusterState.ClusterStateStatus newStatus) {, +            // The condition !newState.nodes().masterNodeId().equals(previousState.nodes().masterNodeId()) is not sufficient as the same master node might get reelected after a disruption., +            return newState.nodes().masterNodeId() != null && newState != previousState;, +        }, +, +        @Override, +        public boolean apply(ClusterChangedEvent event) {, +            return event.nodesDelta().masterNodeChanged();, +        }, +    };, +, +                                retry(t, masterNodeChangedPredicate);, +                    retry(null, masterNodeChangedPredicate);, +                                retry(cause, masterNodeChangedPredicate);, +++ b/core/src/main/java/org/elasticsearch/action/support/replication/TransportReplicationAction.java, +                                shardStateAction.shardFailed(clusterService.state(), shard, indexUUID, "failed to perform " + transportReplicaAction + " on replica on node " + node, exp, shardFailedTimeout, new ReplicationFailedShardStateListener(nodeId, exp));, +++ b/core/src/main/java/org/elasticsearch/action/support/master/TransportMasterNodeAction.java, +import org.elasticsearch.cluster.ClusterChangedEvent;, +    private static final ClusterStateObserver.ChangePredicate masterNodeChangedPredicate = new ClusterStateObserver.ChangePredicate() {, +        @Override, +        public boolean apply(ClusterState previousState, ClusterState.ClusterStateStatus previousStatus,, +                             ClusterState newState, ClusterState.ClusterStateStatus newStatus) {, +            // The condition !newState.nodes().masterNodeId().equals(previousState.nodes().masterNodeId()) is not sufficient as the same master node might get reelected after a disruption., +            return newState.nodes().masterNodeId() != null && newState != previousState;, +        }, +, +        @Override, +        public boolean apply(ClusterChangedEvent event) {, +            return event.nodesDelta().masterNodeChanged();, +        }, +    };, +, +                                retry(t, masterNodeChangedPredicate);, +                    retry(null, masterNodeChangedPredicate);, +                                retry(cause, masterNodeChangedPredicate);, +++ b/core/src/main/java/org/elasticsearch/action/support/replication/TransportReplicationAction.java, +                                shardStateAction.shardFailed(clusterService.state(), shard, indexUUID, "failed to perform " + transportReplicaAction + " on replica on node " + node, exp, shardFailedTimeout, new ReplicationFailedShardStateListener(nodeId, exp));, +++ /dev/null, +++ b/core/src/main/java/org/elasticsearch/action/support/master/TransportMasterNodeAction.java, +import org.elasticsearch.cluster.ClusterChangedEvent;, +    private static final ClusterStateObserver.ChangePredicate masterNodeChangedPredicate = new ClusterStateObserver.ChangePredicate() {, +        @Override, +        public boolean apply(ClusterState previousState, ClusterState.ClusterStateStatus previousStatus,, +                             ClusterState newState, ClusterState.ClusterStateStatus newStatus) {, +            // The condition !newState.nodes().masterNodeId().equals(previousState.nodes().masterNodeId()) is not sufficient as the same master node might get reelected after a disruption., +            return newState.nodes().masterNodeId() != null && newState != previousState;, +        }, +, +        @Override, +        public boolean apply(ClusterChangedEvent event) {, +            return event.nodesDelta().masterNodeChanged();, +        }, +    };, +, +                                retry(t, masterNodeChangedPredicate);, +                    retry(null, masterNodeChangedPredicate);, +                                retry(cause, masterNodeChangedPredicate);, +++ b/core/src/main/java/org/elasticsearch/action/support/replication/TransportReplicationAction.java, +                                shardStateAction.shardFailed(clusterService.state(), shard, indexUUID, "failed to perform " + transportReplicaAction + " on replica on node " + node, exp, shardFailedTimeout, new ReplicationFailedShardStateListener(nodeId, exp));, +++ /dev/null, +++ b/core/src/main/java/org/elasticsearch/cluster/action/shard/ShardStateAction.java, +        transportService.registerRequestHandler(SHARD_STARTED_ACTION_NAME, ShardRoutingEntry::new, ThreadPool.Names.SAME, new ShardStartedTransportHandler(clusterService));, +        transportService.registerRequestHandler(SHARD_FAILED_ACTION_NAME, ShardRoutingEntry::new, ThreadPool.Names.SAME, new ShardFailedTransportHandler(clusterService));, +    public void shardFailed(final ClusterState clusterState, final ShardRouting shardRouting, final String indexUUID, final String message, @Nullable final Throwable failure, Listener listener) {, +        shardFailed(clusterState, shardRouting, indexUUID, message, failure, null, listener);, +    public void shardFailed(final ClusterState clusterState, final ShardRouting shardRouting, final String indexUUID, final String message, @Nullable final Throwable failure, TimeValue timeout, Listener listener) {, +        innerShardFailed(clusterState, shardRouting, indexUUID, message, failure, timeout, listener);, +    }, +, +    public void resendShardFailed(final ClusterState clusterState, final ShardRouting shardRouting, final String indexUUID, final String message, @Nullable final Throwable failure, Listener listener) {, +        logger.trace("re-sending failed shard [{}], index UUID [{}], reason [{}]", failure, shardRouting, indexUUID, message);, +        shardFailed(clusterState, shardRouting, indexUUID, message, failure, listener);, +    }, +, +    private void innerShardFailed(final ClusterState clusterState, final ShardRouting shardRouting, final String indexUUID, final String message, final Throwable failure, TimeValue timeout, Listener listener) {, +        DiscoveryNode masterNode = clusterState.nodes().masterNode();]