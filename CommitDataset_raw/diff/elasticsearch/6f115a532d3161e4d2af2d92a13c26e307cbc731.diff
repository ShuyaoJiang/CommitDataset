[+++ b/elasticsearch/x-pack/monitoring/src/main/java/org/elasticsearch/xpack/monitoring/AgentService.java, +/*, + * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one, + * or more contributor license agreements. Licensed under the Elastic License;, + * you may not use this file except in compliance with the Elastic License., + */, +package org.elasticsearch.xpack.monitoring;, +, +import org.apache.logging.log4j.message.ParameterizedMessage;, +import org.apache.logging.log4j.util.Supplier;, +import org.elasticsearch.common.Strings;, +import org.elasticsearch.common.component.AbstractLifecycleComponent;, +import org.elasticsearch.common.lease.Releasable;, +import org.elasticsearch.common.regex.Regex;, +import org.elasticsearch.common.settings.ClusterSettings;, +import org.elasticsearch.common.settings.Settings;, +import org.elasticsearch.common.unit.TimeValue;, +import org.elasticsearch.common.util.CollectionUtils;, +import org.elasticsearch.common.util.concurrent.EsExecutors;, +import org.elasticsearch.common.util.concurrent.ReleasableLock;, +import org.elasticsearch.xpack.monitoring.collector.Collector;, +import org.elasticsearch.xpack.monitoring.collector.cluster.ClusterStatsCollector;, +import org.elasticsearch.xpack.monitoring.exporter.ExportException;, +import org.elasticsearch.xpack.monitoring.exporter.Exporter;, +import org.elasticsearch.xpack.monitoring.exporter.Exporters;, +import org.elasticsearch.xpack.monitoring.exporter.MonitoringDoc;, +, +import java.util.ArrayList;, +import java.util.Collection;, +import java.util.Collections;, +import java.util.HashSet;, +import java.util.Locale;, +import java.util.Set;, +import java.util.concurrent.locks.ReentrantLock;, +, +/**, + * The {@code AgentService} is a service that does the work of publishing the details to the monitoring cluster., + * <p>, + * If this service is stopped, then the attached, monitored node is not going to publish its details to the monitoring cluster. Given, + * service life cycles, the intended way to temporarily stop the publishing is using the start and stop collection methods., + *, + * @see #stopCollection(), + * @see #startCollection(), + */, +public class AgentService extends AbstractLifecycleComponent {, +, +    private volatile ExportingWorker exportingWorker;, +, +    private volatile Thread workerThread;, +    private volatile long samplingIntervalMillis;, +    private final Collection<Collector> collectors;, +    private final String[] settingsCollectors;, +    private final Exporters exporters;, +, +    public AgentService(Settings settings, ClusterSettings clusterSettings, Set<Collector> collectors, Exporters exporters) {, +        super(settings);, +        this.samplingIntervalMillis = MonitoringSettings.INTERVAL.get(settings).millis();, +        this.settingsCollectors = MonitoringSettings.COLLECTORS.get(settings).toArray(new String[0]);, +        this.collectors = Collections.unmodifiableSet(filterCollectors(collectors, settingsCollectors));, +        this.exporters = exporters;, +, +        clusterSettings.addSettingsUpdateConsumer(MonitoringSettings.INTERVAL, this::setInterval);, +    }, +, +    private void setInterval(TimeValue interval) {, +        this.samplingIntervalMillis = interval.millis();, +        applyIntervalSettings();, +    }, +, +    protected Set<Collector> filterCollectors(Set<Collector> collectors, String[] filters) {, +        if (CollectionUtils.isEmpty(filters)) {, +            return collectors;, +        }, +, +        Set<Collector> list = new HashSet<>();, +        for (Collector collector : collectors) {, +            if (Regex.simpleMatch(filters, collector.name().toLowerCase(Locale.ROOT))) {, +                list.add(collector);, +            } else if (collector instanceof ClusterStatsCollector) {, +                list.add(collector);, +            }, +        }, +        return list;, +    }, +, +    protected void applyIntervalSettings() {, +        if (samplingIntervalMillis <= 0) {, +            logger.info("data sampling is disabled due to interval settings [{}]", samplingIntervalMillis);, +            if (workerThread != null) {, +, +                // notify  worker to stop on its leisure, not to disturb an exporting operation, +                exportingWorker.closed = true;, +, +                exportingWorker = null;, +                workerThread = null;, +            }, +        } else if (workerThread == null || !workerThread.isAlive()) {, +, +            exportingWorker = new ExportingWorker();, +            workerThread = new Thread(exportingWorker, EsExecutors.threadName(settings, "monitoring.exporters"));]