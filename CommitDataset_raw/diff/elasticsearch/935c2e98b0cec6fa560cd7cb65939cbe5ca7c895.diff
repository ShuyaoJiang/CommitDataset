[+++ b/server/src/main/java/org/elasticsearch/cluster/coordination/Coordinator.java, +    // TODO: the following field is package-private as some tests require access to it, +    private final SetOnce<CoordinationState> coordinationState = new SetOnce<>(); // initialized on start-up (see doStart), +            // check if node has accepted a state in this term already. If not, this node has never committed a cluster state in this, +            // term and therefore never removed the NO_MASTER_BLOCK for this term. This logic ensures that we quickly turn a node, +            // into follower, even before receiving the first cluster state update, but also don't have to deal with the situation, +            // where we would possibly have to remove the NO_MASTER_BLOCK from the applierState when turning a candidate back to follower., +            if (getLastAcceptedState().term() < getCurrentTerm()) {, +                assert getLocalNode().equals(applierState.nodes().getMasterNode()) ||, +                    (applierState.nodes().getMasterNodeId() == null && applierState.term() < getCurrentTerm());, +                assert lastKnownLeader.get().equals(applierState.nodes().getMasterNode()) ||, +                    (applierState.nodes().getMasterNodeId() == null &&, +                        (applierState.term() < getCurrentTerm() || applierState.version() < getLastAcceptedState().version()));, +++ b/server/src/main/java/org/elasticsearch/cluster/coordination/Coordinator.java, +    // TODO: the following field is package-private as some tests require access to it, +    private final SetOnce<CoordinationState> coordinationState = new SetOnce<>(); // initialized on start-up (see doStart), +            // check if node has accepted a state in this term already. If not, this node has never committed a cluster state in this, +            // term and therefore never removed the NO_MASTER_BLOCK for this term. This logic ensures that we quickly turn a node, +            // into follower, even before receiving the first cluster state update, but also don't have to deal with the situation, +            // where we would possibly have to remove the NO_MASTER_BLOCK from the applierState when turning a candidate back to follower., +            if (getLastAcceptedState().term() < getCurrentTerm()) {, +                assert getLocalNode().equals(applierState.nodes().getMasterNode()) ||, +                    (applierState.nodes().getMasterNodeId() == null && applierState.term() < getCurrentTerm());, +                assert lastKnownLeader.get().equals(applierState.nodes().getMasterNode()) ||, +                    (applierState.nodes().getMasterNodeId() == null &&, +                        (applierState.term() < getCurrentTerm() || applierState.version() < getLastAcceptedState().version()));, +++ b/server/src/test/java/org/elasticsearch/cluster/coordination/NodeJoinTests.java, +import org.elasticsearch.transport.Transport;, +import static org.hamcrest.Matchers.equalTo;, +    private Transport transport;, +        transport = capturingTransport;, +            final RequestHandlerRegistry<JoinRequest> joinHandler = (RequestHandlerRegistry<JoinRequest>), +                transport.getRequestHandler(JoinHelper.JOIN_ACTION_NAME);, +            joinHandler.processMessageReceived(joinRequest, new TransportChannel() {, +    public void testJoinFollowerWithHigherTerm() throws Exception {, +        handleStartJoinFrom(node1, newTerm);, +        handleFollowerCheckFrom(node1, newTerm);, +    private void handleStartJoinFrom(DiscoveryNode node, long term) throws Exception {, +        final RequestHandlerRegistry<StartJoinRequest> startJoinHandler = (RequestHandlerRegistry<StartJoinRequest>), +            transport.getRequestHandler(JoinHelper.START_JOIN_ACTION_NAME);, +        startJoinHandler.processMessageReceived(new StartJoinRequest(node, term), new TransportChannel() {, +            @Override, +            public String getProfileName() {, +                return "dummy";, +            }, +, +            @Override, +            public String getChannelType() {, +                return "dummy";, +            }, +, +            @Override, +            public void sendResponse(TransportResponse response) {, +, +            }, +, +            @Override, +            public void sendResponse(Exception exception) {, +                fail();, +            }, +        });, +        deterministicTaskQueue.runAllRunnableTasks();, +        assertFalse(isLocalNodeElectedMaster());, +        assertThat(coordinator.getMode(), equalTo(Coordinator.Mode.CANDIDATE));, +    }, +, +    private void handleFollowerCheckFrom(DiscoveryNode node, long term) throws Exception {, +        final RequestHandlerRegistry<FollowersChecker.FollowerCheckRequest> followerCheckHandler =, +            (RequestHandlerRegistry<FollowersChecker.FollowerCheckRequest>), +            transport.getRequestHandler(FollowersChecker.FOLLOWER_CHECK_ACTION_NAME);, +        followerCheckHandler.processMessageReceived(new FollowersChecker.FollowerCheckRequest(term, node), new TransportChannel() {, +            @Override, +            public String getProfileName() {, +                return "dummy";, +            }, +, +            @Override, +            public String getChannelType() {, +                return "dummy";, +            }, +, +            @Override, +            public void sendResponse(TransportResponse response) {, +, +            }, +, +            @Override, +            public void sendResponse(Exception exception) {, +                fail();, +            }, +        });, +        deterministicTaskQueue.runAllRunnableTasks();, +        assertFalse(isLocalNodeElectedMaster());, +        assertThat(coordinator.getMode(), equalTo(Coordinator.Mode.FOLLOWER));, +    }, +, +    public void testJoinFollowerFails() throws Exception {, +        handleStartJoinFrom(node1, newTerm);, +        handleFollowerCheckFrom(node1, newTerm);, +    public void testBecomeFollowerFailsPendingJoin() throws Exception {]