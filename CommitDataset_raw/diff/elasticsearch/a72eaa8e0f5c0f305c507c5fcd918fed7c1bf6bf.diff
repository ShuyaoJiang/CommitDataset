[+++ b/core/src/main/java/org/elasticsearch/action/bulk/MappingUpdatePerformer.java, +    void verifyMappings(Mapping update, ShardId shardId) throws Exception;, +++ b/core/src/main/java/org/elasticsearch/action/bulk/MappingUpdatePerformer.java, +    void verifyMappings(Mapping update, ShardId shardId) throws Exception;, +++ b/core/src/main/java/org/elasticsearch/action/bulk/TransportShardBulkAction.java, +import org.elasticsearch.index.mapper.MapperService;, +                                                             final IndexShard primary,, +                                                             final MappingUpdatePerformer mappingUpdater) throws Exception {, +        Engine.DeleteResult deleteResult = executeDeleteRequestOnPrimary(deleteRequest, primary, mappingUpdater);, +                responseHolder = executeDeleteRequest((DeleteRequest) itemRequest, request.items()[requestIndex], primary, mappingUpdater);, +                    result = executeDeleteRequestOnPrimary(deleteRequest, primary, mappingUpdater);, +                mappingUpdater.verifyMappings(operation.parsedDoc().dynamicMappingsUpdate(), primary.shardId());, +    private static Engine.DeleteResult executeDeleteRequestOnPrimary(DeleteRequest request, IndexShard primary,, +            final MappingUpdatePerformer mappingUpdater) throws Exception {, +        boolean mappingUpdateNeeded = false;, +        if (primary.indexSettings().isSingleType()) {, +            // When there is a single type, the unique identifier is only composed of the _id,, +            // so there is no way to differenciate foo#1 from bar#1. This is especially an issue, +            // if a user first deletes foo#1 and then indexes bar#1: since we do not encode the, +            // _type in the uid it might look like we are reindexing the same document, which, +            // would fail if bar#1 is indexed with a lower version than foo#1 was deleted with., +            // In order to work around this issue, we make deletions create types. This way, we, +            // fail if index and delete operations do not use the same type., +            try {, +                Mapping update = primary.mapperService().documentMapperWithAutoCreate(request.type()).getMapping();, +                if (update != null) {, +                    mappingUpdateNeeded = true;, +                    mappingUpdater.updateMappings(update, primary.shardId(), request.type());, +                }, +            } catch (MapperParsingException | IllegalArgumentException e) {, +                return new Engine.DeleteResult(e, request.version(), SequenceNumbersService.UNASSIGNED_SEQ_NO, false);, +            }, +        }, +        if (mappingUpdateNeeded) {, +            Mapping update = primary.mapperService().documentMapperWithAutoCreate(request.type()).getMapping();, +            mappingUpdater.verifyMappings(update, primary.shardId());, +        }, +    private static Engine.DeleteResult executeDeleteRequestOnReplica(DocWriteResponse primaryResponse, DeleteRequest request,, +            IndexShard replica) throws Exception {, +        if (replica.indexSettings().isSingleType()) {, +            // We need to wait for the replica to have the mappings, +            Mapping update;, +            try {, +                update = replica.mapperService().documentMapperWithAutoCreate(request.type()).getMapping();, +            } catch (MapperParsingException | IllegalArgumentException e) {, +                return new Engine.DeleteResult(e, request.version(), primaryResponse.getSeqNo(), false);, +            }, +            if (update != null) {, +                final ShardId shardId = replica.shardId();, +                throw new RetryOnReplicaException(shardId,, +                        "Mappings are not available on the replica yet, triggered update: " + update);, +            }, +        }, +, +        public void verifyMappings(Mapping update,, +            if (update != null) {, +++ b/core/src/main/java/org/elasticsearch/action/bulk/MappingUpdatePerformer.java, +    void verifyMappings(Mapping update, ShardId shardId) throws Exception;, +++ b/core/src/main/java/org/elasticsearch/action/bulk/TransportShardBulkAction.java, +import org.elasticsearch.index.mapper.MapperService;, +                                                             final IndexShard primary,, +                                                             final MappingUpdatePerformer mappingUpdater) throws Exception {, +        Engine.DeleteResult deleteResult = executeDeleteRequestOnPrimary(deleteRequest, primary, mappingUpdater);, +                responseHolder = executeDeleteRequest((DeleteRequest) itemRequest, request.items()[requestIndex], primary, mappingUpdater);, +                    result = executeDeleteRequestOnPrimary(deleteRequest, primary, mappingUpdater);, +                mappingUpdater.verifyMappings(operation.parsedDoc().dynamicMappingsUpdate(), primary.shardId());, +    private static Engine.DeleteResult executeDeleteRequestOnPrimary(DeleteRequest request, IndexShard primary,, +            final MappingUpdatePerformer mappingUpdater) throws Exception {, +        boolean mappingUpdateNeeded = false;, +        if (primary.indexSettings().isSingleType()) {, +            // When there is a single type, the unique identifier is only composed of the _id,, +            // so there is no way to differenciate foo#1 from bar#1. This is especially an issue, +            // if a user first deletes foo#1 and then indexes bar#1: since we do not encode the, +            // _type in the uid it might look like we are reindexing the same document, which, +            // would fail if bar#1 is indexed with a lower version than foo#1 was deleted with., +            // In order to work around this issue, we make deletions create types. This way, we, +            // fail if index and delete operations do not use the same type., +            try {, +                Mapping update = primary.mapperService().documentMapperWithAutoCreate(request.type()).getMapping();, +                if (update != null) {, +                    mappingUpdateNeeded = true;, +                    mappingUpdater.updateMappings(update, primary.shardId(), request.type());, +                }, +            } catch (MapperParsingException | IllegalArgumentException e) {, +                return new Engine.DeleteResult(e, request.version(), SequenceNumbersService.UNASSIGNED_SEQ_NO, false);, +            }, +        }, +        if (mappingUpdateNeeded) {, +            Mapping update = primary.mapperService().documentMapperWithAutoCreate(request.type()).getMapping();, +            mappingUpdater.verifyMappings(update, primary.shardId());, +        }, +    private static Engine.DeleteResult executeDeleteRequestOnReplica(DocWriteResponse primaryResponse, DeleteRequest request,, +            IndexShard replica) throws Exception {, +        if (replica.indexSettings().isSingleType()) {, +            // We need to wait for the replica to have the mappings, +            Mapping update;, +            try {, +                update = replica.mapperService().documentMapperWithAutoCreate(request.type()).getMapping();, +            } catch (MapperParsingException | IllegalArgumentException e) {, +                return new Engine.DeleteResult(e, request.version(), primaryResponse.getSeqNo(), false);]