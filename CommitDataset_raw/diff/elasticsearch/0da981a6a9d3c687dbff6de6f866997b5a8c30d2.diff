[+++ b/CONTRIBUTING.md, +runtime.</dd>, +<dt>`compileOnly`</dt><dd>Code that is on the classpath at compile time but that, +<dt>`bundle`</dt><dd>Only available in projects with the shadow plugin,, +dependencies with this configuration are bundled into the jar produced by the, +build. Since IDEs do not understand this configuration we rig them to treat, +dependencies in this configuration as `compile` dependencies.</dd>, +++ b/CONTRIBUTING.md, +runtime.</dd>, +<dt>`compileOnly`</dt><dd>Code that is on the classpath at compile time but that, +<dt>`bundle`</dt><dd>Only available in projects with the shadow plugin,, +dependencies with this configuration are bundled into the jar produced by the, +build. Since IDEs do not understand this configuration we rig them to treat, +dependencies in this configuration as `compile` dependencies.</dd>, +++ b/build.gradle, +import org.elasticsearch.gradle.plugin.PluginBuildPlugin, +    if (project.plugins.hasPlugin(BuildPlugin) || project.plugins.hasPlugin(PluginBuildPlugin)) {, +          .each({ c -> depJavadocClosure(false, c) }), +          .each({ c -> depJavadocClosure(false, c) }), +        project.configurations.bundle.dependencies, +            .each({ c -> depJavadocClosure(true, c) }), +   * in "IntelliJ mode" or "Eclipse mode" switch "bundle" dependencies into, +   * regular "compile" dependencies. This isn't needed for the project, +    project.plugins.withType(ShadowPlugin).whenPluginAdded {, +      project.afterEvaluate {, +        project.configurations.compile.extendsFrom project.configurations.bundle, +++ b/CONTRIBUTING.md, +runtime.</dd>, +<dt>`compileOnly`</dt><dd>Code that is on the classpath at compile time but that, +<dt>`bundle`</dt><dd>Only available in projects with the shadow plugin,, +dependencies with this configuration are bundled into the jar produced by the, +build. Since IDEs do not understand this configuration we rig them to treat, +dependencies in this configuration as `compile` dependencies.</dd>, +++ b/build.gradle, +import org.elasticsearch.gradle.plugin.PluginBuildPlugin, +    if (project.plugins.hasPlugin(BuildPlugin) || project.plugins.hasPlugin(PluginBuildPlugin)) {, +          .each({ c -> depJavadocClosure(false, c) }), +          .each({ c -> depJavadocClosure(false, c) }), +        project.configurations.bundle.dependencies, +            .each({ c -> depJavadocClosure(true, c) }), +   * in "IntelliJ mode" or "Eclipse mode" switch "bundle" dependencies into, +   * regular "compile" dependencies. This isn't needed for the project, +    project.plugins.withType(ShadowPlugin).whenPluginAdded {, +      project.afterEvaluate {, +        project.configurations.compile.extendsFrom project.configurations.bundle, +++ b/buildSrc/src/main/groovy/org/elasticsearch/gradle/BuildPlugin.groovy, +        configureConfigurations(project), +        // these plugins add lots of info to our jars, +        configureSourceSets(project), +, +            Configuration bundle = project.configurations.create('bundle'), +            bundle.dependencies.all(disableTransitiveDeps), +            generatePOMTask.ext.pomFileName = null, +                    rename {, +                        generatePOMTask.ext.pomFileName == null ? , +                            "${project.archivesBaseName}-${project.version}.pom" : , +                            generatePOMTask.ext.pomFileName , +                    }, +                        }, +                    }, +                }, +            }, +        }, +    }, +, +    /**, +     * Add dependencies that we are going to bundle to the compile classpath., +    static void configureSourceSets(Project project) {, +        project.plugins.withType(ShadowPlugin).whenPluginAdded {, +            ['main', 'test'].each {name ->, +                SourceSet sourceSet = project.sourceSets.findByName(name), +                if (sourceSet != null) {, +                    sourceSet.compileClasspath += project.configurations.bundle, +                /*, +                 * Bundle dependencies of the "bundled" configuration., +                 */, +                configurations = [project.configurations.bundle], +            project.artifacts {, +                apiElements project.tasks.shadowJar, +            }, +                // Test against a shadow jar if we made one, +            project.dependencyLicenses.dependencies += project.configurations.bundle.fileCollection {, +            deps.runtimeConfiguration.extendsFrom(project.configurations.runtime, project.configurations.bundle), +++ b/CONTRIBUTING.md, +runtime.</dd>, +<dt>`compileOnly`</dt><dd>Code that is on the classpath at compile time but that, +<dt>`bundle`</dt><dd>Only available in projects with the shadow plugin,, +dependencies with this configuration are bundled into the jar produced by the, +build. Since IDEs do not understand this configuration we rig them to treat, +dependencies in this configuration as `compile` dependencies.</dd>, +++ b/build.gradle, +import org.elasticsearch.gradle.plugin.PluginBuildPlugin, +    if (project.plugins.hasPlugin(BuildPlugin) || project.plugins.hasPlugin(PluginBuildPlugin)) {, +          .each({ c -> depJavadocClosure(false, c) }), +          .each({ c -> depJavadocClosure(false, c) }), +        project.configurations.bundle.dependencies, +            .each({ c -> depJavadocClosure(true, c) }), +   * in "IntelliJ mode" or "Eclipse mode" switch "bundle" dependencies into, +   * regular "compile" dependencies. This isn't needed for the project, +    project.plugins.withType(ShadowPlugin).whenPluginAdded {]