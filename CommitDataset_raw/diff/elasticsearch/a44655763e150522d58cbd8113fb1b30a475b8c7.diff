[+++ b/core/src/main/java/org/elasticsearch/gateway/PrimaryShardAllocator.java, +import org.elasticsearch.env.ShardLockObtainFailedException;, +    private static final Comparator<NodeGatewayStartedShards> NO_STORE_EXCEPTION_FIRST_COMPARATOR =, +        Comparator.comparing((NodeGatewayStartedShards state) -> state.storeException() == null).reversed();, +    private static final Comparator<NodeGatewayStartedShards> PRIMARY_FIRST_COMPARATOR =, +        Comparator.comparing(NodeGatewayStartedShards::primary).reversed();, +, +        List<NodeGatewayStartedShards> nodeShardStates = new ArrayList<>();, +                if (nodeShardState.storeException() instanceof ShardLockObtainFailedException) {, +                    logger.trace((Supplier<?>) () -> new ParameterizedMessage("[{}] on node [{}] has allocation id [{}] but the store can not be opened as it's locked, treating as valid shard", shard, nodeShardState.getNode(), finalAllocationId), nodeShardState.storeException());, +                } else {, +            }, +                assert nodeShardState.storeException() == null ||, +                    nodeShardState.storeException() instanceof ShardLockObtainFailedException :, +                    "only allow store that can be opened or that throws a ShardLockObtainFailedException while being opened but got a store throwing " + nodeShardState.storeException();, +                if (matchAnyShard || inSyncAllocationIds.contains(nodeShardState.allocationId())) {, +                    nodeShardStates.add(nodeShardState);, +        final Comparator<NodeGatewayStartedShards> comparator; // allocation preference, +        if (matchAnyShard) {, +            // prefer shards with matching allocation ids, +            Comparator<NodeGatewayStartedShards> matchingAllocationsFirst = Comparator.comparing(, +                (NodeGatewayStartedShards state) -> inSyncAllocationIds.contains(state.allocationId())).reversed();, +            comparator = matchingAllocationsFirst.thenComparing(NO_STORE_EXCEPTION_FIRST_COMPARATOR).thenComparing(PRIMARY_FIRST_COMPARATOR);, +        } else {, +            comparator = NO_STORE_EXCEPTION_FIRST_COMPARATOR.thenComparing(PRIMARY_FIRST_COMPARATOR);, +        }, +, +        nodeShardStates.sort(comparator);, +                final long finalVersion = version;, +                if (nodeShardState.storeException() instanceof ShardLockObtainFailedException) {, +                    logger.trace((Supplier<?>) () -> new ParameterizedMessage("[{}] on node [{}] has version [{}] but the store can not be opened as it's locked, treating as valid shard", shard, nodeShardState.getNode(), finalVersion), nodeShardState.storeException());, +                    if (nodeShardState.allocationId() != null) {, +                        version = Long.MAX_VALUE; // shard was already selected in a 5.x cluster as primary, prefer this shard copy again., +                    } else {, +                        version = 0L; // treat as lowest version so that this shard is the least likely to be selected as primary, +                    }, +                } else {, +                    // disregard the reported version and assign it as no version (same as shard does not exist), +                    logger.trace((Supplier<?>) () -> new ParameterizedMessage("[{}] on node [{}] has version [{}] but the store can not be opened, treating no version", shard, nodeShardState.getNode(), finalVersion), nodeShardState.storeException());, +            }, +++ b/core/src/main/java/org/elasticsearch/gateway/PrimaryShardAllocator.java, +import org.elasticsearch.env.ShardLockObtainFailedException;, +    private static final Comparator<NodeGatewayStartedShards> NO_STORE_EXCEPTION_FIRST_COMPARATOR =, +        Comparator.comparing((NodeGatewayStartedShards state) -> state.storeException() == null).reversed();, +    private static final Comparator<NodeGatewayStartedShards> PRIMARY_FIRST_COMPARATOR =, +        Comparator.comparing(NodeGatewayStartedShards::primary).reversed();, +, +        List<NodeGatewayStartedShards> nodeShardStates = new ArrayList<>();, +                if (nodeShardState.storeException() instanceof ShardLockObtainFailedException) {, +                    logger.trace((Supplier<?>) () -> new ParameterizedMessage("[{}] on node [{}] has allocation id [{}] but the store can not be opened as it's locked, treating as valid shard", shard, nodeShardState.getNode(), finalAllocationId), nodeShardState.storeException());, +                } else {, +            }, +                assert nodeShardState.storeException() == null ||, +                    nodeShardState.storeException() instanceof ShardLockObtainFailedException :, +                    "only allow store that can be opened or that throws a ShardLockObtainFailedException while being opened but got a store throwing " + nodeShardState.storeException();, +                if (matchAnyShard || inSyncAllocationIds.contains(nodeShardState.allocationId())) {, +                    nodeShardStates.add(nodeShardState);, +        final Comparator<NodeGatewayStartedShards> comparator; // allocation preference, +        if (matchAnyShard) {, +            // prefer shards with matching allocation ids, +            Comparator<NodeGatewayStartedShards> matchingAllocationsFirst = Comparator.comparing(, +                (NodeGatewayStartedShards state) -> inSyncAllocationIds.contains(state.allocationId())).reversed();, +            comparator = matchingAllocationsFirst.thenComparing(NO_STORE_EXCEPTION_FIRST_COMPARATOR).thenComparing(PRIMARY_FIRST_COMPARATOR);, +        } else {, +            comparator = NO_STORE_EXCEPTION_FIRST_COMPARATOR.thenComparing(PRIMARY_FIRST_COMPARATOR);, +        }, +, +        nodeShardStates.sort(comparator);, +                final long finalVersion = version;, +                if (nodeShardState.storeException() instanceof ShardLockObtainFailedException) {, +                    logger.trace((Supplier<?>) () -> new ParameterizedMessage("[{}] on node [{}] has version [{}] but the store can not be opened as it's locked, treating as valid shard", shard, nodeShardState.getNode(), finalVersion), nodeShardState.storeException());, +                    if (nodeShardState.allocationId() != null) {, +                        version = Long.MAX_VALUE; // shard was already selected in a 5.x cluster as primary, prefer this shard copy again., +                    } else {, +                        version = 0L; // treat as lowest version so that this shard is the least likely to be selected as primary, +                    }, +                } else {, +                    // disregard the reported version and assign it as no version (same as shard does not exist), +                    logger.trace((Supplier<?>) () -> new ParameterizedMessage("[{}] on node [{}] has version [{}] but the store can not be opened, treating no version", shard, nodeShardState.getNode(), finalVersion), nodeShardState.storeException());, +            }, +++ b/core/src/main/java/org/elasticsearch/index/store/Store.java, +    public static void tryOpenIndex(Path indexLocation, ShardId shardId, NodeEnvironment.ShardLocker shardLocker, Logger logger) throws IOException, ShardLockObtainFailedException {, +++ b/core/src/main/java/org/elasticsearch/gateway/PrimaryShardAllocator.java, +import org.elasticsearch.env.ShardLockObtainFailedException;, +    private static final Comparator<NodeGatewayStartedShards> NO_STORE_EXCEPTION_FIRST_COMPARATOR =, +        Comparator.comparing((NodeGatewayStartedShards state) -> state.storeException() == null).reversed();, +    private static final Comparator<NodeGatewayStartedShards> PRIMARY_FIRST_COMPARATOR =, +        Comparator.comparing(NodeGatewayStartedShards::primary).reversed();, +, +        List<NodeGatewayStartedShards> nodeShardStates = new ArrayList<>();, +                if (nodeShardState.storeException() instanceof ShardLockObtainFailedException) {, +                    logger.trace((Supplier<?>) () -> new ParameterizedMessage("[{}] on node [{}] has allocation id [{}] but the store can not be opened as it's locked, treating as valid shard", shard, nodeShardState.getNode(), finalAllocationId), nodeShardState.storeException());, +                } else {, +            }, +                assert nodeShardState.storeException() == null ||, +                    nodeShardState.storeException() instanceof ShardLockObtainFailedException :, +                    "only allow store that can be opened or that throws a ShardLockObtainFailedException while being opened but got a store throwing " + nodeShardState.storeException();, +                if (matchAnyShard || inSyncAllocationIds.contains(nodeShardState.allocationId())) {, +                    nodeShardStates.add(nodeShardState);, +        final Comparator<NodeGatewayStartedShards> comparator; // allocation preference]