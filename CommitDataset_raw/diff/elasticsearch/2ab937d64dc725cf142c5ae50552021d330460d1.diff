[+++ b/core/src/main/java/org/elasticsearch/index/engine/InternalEngine.java, +        } else if (t != null && indexWriter.isOpen() == false && indexWriter.getTragicException() == t) {, +++ b/core/src/main/java/org/elasticsearch/index/engine/InternalEngine.java, +        } else if (t != null && indexWriter.isOpen() == false && indexWriter.getTragicException() == t) {, +++ b/core/src/main/java/org/elasticsearch/index/translog/BufferingTranslogWriter.java, +            operationCounter++;, +                return new Translog.Location(generation, offset, data.length());, +            }, +            Channels.writeToChannel(buffer, 0, bufferCount, channel);, +            writtenOffset += bufferCount;, +    public void sync() throws IOException {, +        if (!syncNeeded()) {, +            return;, +        }, +        synchronized (this) {, +                    lastSyncedOffset = totalOffset;, +                checkpoint(lastSyncedOffset, operationCounter, channelReference);, +++ b/core/src/main/java/org/elasticsearch/index/engine/InternalEngine.java, +        } else if (t != null && indexWriter.isOpen() == false && indexWriter.getTragicException() == t) {, +++ b/core/src/main/java/org/elasticsearch/index/translog/BufferingTranslogWriter.java, +            operationCounter++;, +                return new Translog.Location(generation, offset, data.length());, +            }, +            Channels.writeToChannel(buffer, 0, bufferCount, channel);, +            writtenOffset += bufferCount;, +    public void sync() throws IOException {, +        if (!syncNeeded()) {, +            return;, +        }, +        synchronized (this) {, +                    lastSyncedOffset = totalOffset;, +                checkpoint(lastSyncedOffset, operationCounter, channelReference);, +++ b/core/src/main/java/org/elasticsearch/index/translog/Translog.java, +    private long lastCommittedTranslogFileGeneration = -1; // -1 is safe as it will not cause an translog deletion., +    boolean isOpen() {, +            newFile = TranslogWriter.create(config.getType(), shardId, translogUUID, fileGeneration, location.resolve(getFilename(fileGeneration)), new OnCloseRunnable(), config.getBufferSize());, +    public Location add(Operation operation) throws TranslogException {, +        } catch (AlreadyClosedException ex) {, +            try (ReleasableLock lock = writeLock.acquire()) {, +    }, +            throw new AlreadyClosedException("translog is already closed");, +++ b/core/src/main/java/org/elasticsearch/index/engine/InternalEngine.java, +        } else if (t != null && indexWriter.isOpen() == false && indexWriter.getTragicException() == t) {, +++ b/core/src/main/java/org/elasticsearch/index/translog/BufferingTranslogWriter.java, +            operationCounter++;, +                return new Translog.Location(generation, offset, data.length());, +            }, +            Channels.writeToChannel(buffer, 0, bufferCount, channel);, +            writtenOffset += bufferCount;, +    public void sync() throws IOException {, +        if (!syncNeeded()) {, +            return;, +        }, +        synchronized (this) {, +                    lastSyncedOffset = totalOffset;, +                checkpoint(lastSyncedOffset, operationCounter, channelReference);, +++ b/core/src/main/java/org/elasticsearch/index/translog/Translog.java, +    private long lastCommittedTranslogFileGeneration = -1; // -1 is safe as it will not cause an translog deletion., +    boolean isOpen() {, +            newFile = TranslogWriter.create(config.getType(), shardId, translogUUID, fileGeneration, location.resolve(getFilename(fileGeneration)), new OnCloseRunnable(), config.getBufferSize());, +    public Location add(Operation operation) throws TranslogException {, +        } catch (AlreadyClosedException ex) {, +            try (ReleasableLock lock = writeLock.acquire()) {, +    }, +            throw new AlreadyClosedException("translog is already closed");, +++ b/core/src/main/java/org/elasticsearch/index/translog/TranslogReader.java, +            doClose();, +    protected void doClose() throws IOException {, +        channelReference.decRef();, +        if (closed.get()) {, +++ b/core/src/main/java/org/elasticsearch/index/engine/InternalEngine.java, +        } else if (t != null && indexWriter.isOpen() == false && indexWriter.getTragicException() == t) {, +++ b/core/src/main/java/org/elasticsearch/index/translog/BufferingTranslogWriter.java, +            operationCounter++;, +                return new Translog.Location(generation, offset, data.length());, +            }, +            Channels.writeToChannel(buffer, 0, bufferCount, channel);, +            writtenOffset += bufferCount;, +    public void sync() throws IOException {, +        if (!syncNeeded()) {, +            return;, +        }, +        synchronized (this) {, +                    lastSyncedOffset = totalOffset;, +                checkpoint(lastSyncedOffset, operationCounter, channelReference);, +++ b/core/src/main/java/org/elasticsearch/index/translog/Translog.java, +    private long lastCommittedTranslogFileGeneration = -1; // -1 is safe as it will not cause an translog deletion., +    boolean isOpen() {, +            newFile = TranslogWriter.create(config.getType(), shardId, translogUUID, fileGeneration, location.resolve(getFilename(fileGeneration)), new OnCloseRunnable(), config.getBufferSize());, +    public Location add(Operation operation) throws TranslogException {, +        } catch (AlreadyClosedException ex) {, +            try (ReleasableLock lock = writeLock.acquire()) {, +    }, +            throw new AlreadyClosedException("translog is already closed");, +++ b/core/src/main/java/org/elasticsearch/index/translog/TranslogReader.java, +            doClose();, +    protected void doClose() throws IOException {, +        channelReference.decRef();, +        if (closed.get()) {, +++ b/core/src/main/java/org/elasticsearch/index/translog/TranslogWriter.java]