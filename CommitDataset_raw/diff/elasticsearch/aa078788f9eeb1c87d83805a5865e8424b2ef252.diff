[+++ b/src/main/java/org/elasticsearch/index/mapper/MapperService.java, +    public boolean hasNested() {, +        return this.hasNested;, +    }, +, +++ b/src/main/java/org/elasticsearch/index/mapper/MapperService.java, +    public boolean hasNested() {, +        return this.hasNested;, +    }, +, +++ b/src/main/java/org/elasticsearch/index/search/nested/IncludeAllChildrenQuery.java, +package org.elasticsearch.index.search.nested;, +, +import org.apache.lucene.index.IndexReader;, +import org.apache.lucene.index.Term;, +import org.apache.lucene.search.*;, +import org.apache.lucene.util.FixedBitSet;, +import org.elasticsearch.common.lucene.docset.FixedBitDocSet;, +, +import java.io.IOException;, +import java.util.Set;, +, +/**, + * A special query that accepts a top level parent matching query, and returns all the children of that parent as, + * well. This is handy when deleting by query., + */, +public class IncludeAllChildrenQuery extends Query {, +, +, +    private final Filter parentFilter;, +    private final Query parentQuery;, +, +    // If we are rewritten, this is the original childQuery we, +    // were passed; we use this for .equals() and, +    // .hashCode().  This makes rewritten query equal the, +    // original, so that user does not have to .rewrite() their, +    // query before searching:, +    private final Query origParentQuery;, +, +, +    public IncludeAllChildrenQuery(Query parentQuery, Filter parentFilter) {, +        this.origParentQuery = parentQuery;, +        this.parentQuery = parentQuery;, +        this.parentFilter = parentFilter;, +    }, +, +    IncludeAllChildrenQuery(Query origParentQuery, Query parentQuery, Filter parentFilter) {, +        this.origParentQuery = origParentQuery;, +        this.parentQuery = parentQuery;, +        this.parentFilter = parentFilter;, +    }, +, +    @Override, +    public Weight createWeight(Searcher searcher) throws IOException {, +        return new IncludeAllChildrenWeight(parentQuery, parentQuery.createWeight(searcher), parentFilter);, +    }, +, +    static class IncludeAllChildrenWeight extends Weight {, +, +        private final Query parentQuery;, +        private final Weight parentWeight;, +        private final Filter parentsFilter;, +, +        IncludeAllChildrenWeight(Query parentQuery, Weight parentWeight, Filter parentsFilter) {, +            this.parentQuery = parentQuery;, +            this.parentWeight = parentWeight;, +            this.parentsFilter = parentsFilter;, +        }, +, +        @Override, +        public Query getQuery() {, +            return parentQuery;, +        }, +, +        @Override, +        public float getValue() {, +            return parentWeight.getValue();, +        }, +, +        @Override, +        public float sumOfSquaredWeights() throws IOException {, +            return parentWeight.sumOfSquaredWeights() * parentQuery.getBoost() * parentQuery.getBoost();, +        }, +, +        @Override, +        public void normalize(float norm) {, +            parentWeight.normalize(norm * parentQuery.getBoost());, +        }, +, +        @Override, +        public Scorer scorer(IndexReader reader, boolean scoreDocsInOrder, boolean topScorer) throws IOException {, +            final Scorer parentScorer = parentWeight.scorer(reader, true, false);, +, +            // no matches, +            if (parentScorer == null) {, +                return null;, +            }, +, +            final int firstParentDoc = parentScorer.nextDoc();, +            if (firstParentDoc == DocIdSetIterator.NO_MORE_DOCS) {]