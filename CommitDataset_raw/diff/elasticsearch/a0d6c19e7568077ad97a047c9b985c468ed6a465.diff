[+++ b/client/rest-high-level/src/test/java/org/elasticsearch/client/RestHighLevelClientTests.java, +, +        assertEquals(8, namedXContents.size());, +        assertEquals(Integer.valueOf(3), categories.get(MetricDetail.class));, +        assertTrue(names.contains(DiscountedCumulativeGain.NAME));, +++ b/client/rest-high-level/src/test/java/org/elasticsearch/client/RestHighLevelClientTests.java, +, +        assertEquals(8, namedXContents.size());, +        assertEquals(Integer.valueOf(3), categories.get(MetricDetail.class));, +        assertTrue(names.contains(DiscountedCumulativeGain.NAME));, +++ b/modules/rank-eval/src/main/java/org/elasticsearch/index/rankeval/DiscountedCumulativeGain.java, +import static org.elasticsearch.common.xcontent.ConstructingObjectParser.constructorArg;, +        int unratedResults = 0;, +            // unknownDocRating might be null, in which case unrated docs will be ignored in the dcg calculation., +            // we still need to add them as a placeholder so the rank of the subsequent ratings is correct, +            if (hit.getRating().isPresent() == false) {, +                unratedResults++;, +        }, +        final double dcg = computeDCG(ratingsInSearchHits);, +        double result = dcg;, +        double idcg = 0;, +            idcg = computeDCG(allRatings.subList(0, Math.min(ratingsInSearchHits.size(), allRatings.size())));, +            if (idcg != 0) {, +                result = dcg / idcg;, +                result = 0;, +        EvalQueryQuality evalQueryQuality = new EvalQueryQuality(taskId, result);, +        evalQueryQuality.setMetricDetails(new Detail(dcg, idcg, unratedResults));, +    private static final ConstructingObjectParser<DiscountedCumulativeGain, Void> PARSER = new ConstructingObjectParser<>("dcg", false,, +, +    public static final class Detail implements MetricDetail {, +, +        private static ParseField DCG_FIELD = new ParseField("dcg");, +        private static ParseField IDCG_FIELD = new ParseField("ideal_dcg");, +        private static ParseField NDCG_FIELD = new ParseField("normalized_dcg");, +        private static ParseField UNRATED_FIELD = new ParseField("unrated_docs");, +        private final double dcg;, +        private final double idcg;, +        private final int unratedDocs;, +, +        Detail(double dcg, double idcg, int unratedDocs) {, +            this.dcg = dcg;, +            this.idcg = idcg;, +            this.unratedDocs = unratedDocs;, +, +        Detail(StreamInput in) throws IOException {, +            this.dcg = in.readDouble();, +            this.idcg = in.readDouble();, +            this.unratedDocs = in.readVInt();, +        }, +, +        @Override, +        public, +        String getMetricName() {, +            return NAME;, +        }, +, +        @Override, +        public XContentBuilder innerToXContent(XContentBuilder builder, Params params) throws IOException {, +            builder.field(DCG_FIELD.getPreferredName(), this.dcg);, +            if (this.idcg != 0) {, +                builder.field(IDCG_FIELD.getPreferredName(), this.idcg);, +                builder.field(NDCG_FIELD.getPreferredName(), this.dcg / this.idcg);, +            }, +            builder.field(UNRATED_FIELD.getPreferredName(), this.unratedDocs);, +            return builder;, +        }, +, +        private static final ConstructingObjectParser<Detail, Void> PARSER = new ConstructingObjectParser<>(NAME, true, args -> {, +            return new Detail((Double) args[0], (Double) args[1] != null ? (Double) args[1] : 0.0d, (Integer) args[2]);, +        });, +, +        static {, +            PARSER.declareDouble(constructorArg(), DCG_FIELD);, +            PARSER.declareDouble(optionalConstructorArg(), IDCG_FIELD);, +            PARSER.declareInt(constructorArg(), UNRATED_FIELD);, +        }, +, +        public static Detail fromXContent(XContentParser parser) {, +            return PARSER.apply(parser, null);, +        }, +, +        @Override, +        public void writeTo(StreamOutput out) throws IOException {, +            out.writeDouble(this.dcg);, +            out.writeDouble(this.idcg);, +            out.writeVInt(this.unratedDocs);, +        }, +, +        @Override, +        public String getWriteableName() {, +            return NAME;, +        }, +, +        /**, +         * @return the discounted cumulative gain, +         */, +        public double getDCG() {, +            return this.dcg;, +        }, +]