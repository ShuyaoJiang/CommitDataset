[+++ b/src/main/java/org/elasticsearch/index/store/DistributorDirectory.java, +import java.util.HashMap;, +    private final HashMap<String, Directory> nameDirMapping = new HashMap<>();, +    public synchronized final String[] listAll() throws IOException {, +        return nameDirMapping.keySet().toArray(new String[nameDirMapping.size()]);, +    public synchronized void deleteFile(String name) throws IOException {, +    public synchronized long fileLength(String name) throws IOException {, +    public synchronized IndexOutput createOutput(String name, IOContext context) throws IOException {, +        // no need to sync this operation it could be long running too, +    public synchronized void renameFile(String source, String dest) throws IOException {, +        final Directory directory = getDirectory(source);, +        final Directory targetDir = nameDirMapping.get(dest);, +        if (targetDir != null && targetDir != directory) {, +                    + " to: " + dest + ": target file already exists in a different directory");, +        nameDirMapping.put(dest, directory);, +    public synchronized IndexInput openInput(String name, IOContext context) throws IOException {, +    public synchronized void close() throws IOException {, +    Directory getDirectory(String name) throws IOException { // pkg private for testing, +        final Directory directory = nameDirMapping.get(name);, +            assert nameDirMapping.containsKey(name) == false;, +            nameDirMapping.put(name, dir);, +            return dir;, +    public synchronized void setLockFactory(LockFactory lockFactory) throws IOException {, +    public synchronized String getLockID() {, +    public synchronized String toString() {, +        synchronized (dir) {, +    }, +                        synchronized (DistributorDirectory.this) {, +                            if (nameDirMapping.get(name) == null) {, +                                nameDirMapping.put(name, dir);, +                            }, +                        }, +++ b/src/main/java/org/elasticsearch/index/store/DistributorDirectory.java, +import java.util.HashMap;, +    private final HashMap<String, Directory> nameDirMapping = new HashMap<>();, +    public synchronized final String[] listAll() throws IOException {, +        return nameDirMapping.keySet().toArray(new String[nameDirMapping.size()]);, +    public synchronized void deleteFile(String name) throws IOException {, +    public synchronized long fileLength(String name) throws IOException {, +    public synchronized IndexOutput createOutput(String name, IOContext context) throws IOException {, +        // no need to sync this operation it could be long running too, +    public synchronized void renameFile(String source, String dest) throws IOException {, +        final Directory directory = getDirectory(source);, +        final Directory targetDir = nameDirMapping.get(dest);, +        if (targetDir != null && targetDir != directory) {, +                    + " to: " + dest + ": target file already exists in a different directory");, +        nameDirMapping.put(dest, directory);, +    public synchronized IndexInput openInput(String name, IOContext context) throws IOException {, +    public synchronized void close() throws IOException {, +    Directory getDirectory(String name) throws IOException { // pkg private for testing, +        final Directory directory = nameDirMapping.get(name);, +            assert nameDirMapping.containsKey(name) == false;, +            nameDirMapping.put(name, dir);, +            return dir;, +    public synchronized void setLockFactory(LockFactory lockFactory) throws IOException {, +    public synchronized String getLockID() {, +    public synchronized String toString() {, +        synchronized (dir) {, +    }, +                        synchronized (DistributorDirectory.this) {, +                            if (nameDirMapping.get(name) == null) {, +                                nameDirMapping.put(name, dir);, +                            }, +                        }, +++ b/src/test/java/org/elasticsearch/index/store/DistributorDirectoryTest.java, +            assertNotNull(dd);, +            if (dd.getDirectory("foo.bar") != dd.getDirectory(file)) {, +                    fail("target file already exists in a different directory");, +            }, +++ b/src/main/java/org/elasticsearch/index/store/DistributorDirectory.java, +import java.util.HashMap;, +    private final HashMap<String, Directory> nameDirMapping = new HashMap<>();, +    public synchronized final String[] listAll() throws IOException {, +        return nameDirMapping.keySet().toArray(new String[nameDirMapping.size()]);, +    public synchronized void deleteFile(String name) throws IOException {, +    public synchronized long fileLength(String name) throws IOException {, +    public synchronized IndexOutput createOutput(String name, IOContext context) throws IOException {, +        // no need to sync this operation it could be long running too, +    public synchronized void renameFile(String source, String dest) throws IOException {, +        final Directory directory = getDirectory(source);, +        final Directory targetDir = nameDirMapping.get(dest);, +        if (targetDir != null && targetDir != directory) {, +                    + " to: " + dest + ": target file already exists in a different directory");, +        nameDirMapping.put(dest, directory);, +    public synchronized IndexInput openInput(String name, IOContext context) throws IOException {, +    public synchronized void close() throws IOException {, +    Directory getDirectory(String name) throws IOException { // pkg private for testing, +        final Directory directory = nameDirMapping.get(name);, +            assert nameDirMapping.containsKey(name) == false;, +            nameDirMapping.put(name, dir);, +            return dir;, +    public synchronized void setLockFactory(LockFactory lockFactory) throws IOException {, +    public synchronized String getLockID() {, +    public synchronized String toString() {, +        synchronized (dir) {, +    }, +                        synchronized (DistributorDirectory.this) {, +                            if (nameDirMapping.get(name) == null) {, +                                nameDirMapping.put(name, dir);, +                            }]