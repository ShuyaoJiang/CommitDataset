[+++ b/core/src/main/java/org/elasticsearch/action/search/SearchTransportService.java, +import org.elasticsearch.Version;, +import org.elasticsearch.action.admin.cluster.shards.ClusterSearchShardsAction;, +import org.elasticsearch.action.admin.cluster.shards.ClusterSearchShardsRequest;, +import org.elasticsearch.action.admin.cluster.shards.ClusterSearchShardsResponse;, +import org.elasticsearch.common.Randomness;, +import org.elasticsearch.common.settings.ClusterSettings;, +import org.elasticsearch.common.settings.Setting;, +import org.elasticsearch.common.transport.TransportAddress;, +import org.elasticsearch.common.util.concurrent.CountDown;, +import org.elasticsearch.transport.ConnectTransportException;, +import org.elasticsearch.transport.TransportException;, +import org.elasticsearch.transport.TransportResponseHandler;, +import java.net.InetAddress;, +import java.net.InetSocketAddress;, +import java.net.UnknownHostException;, +import java.util.ArrayList;, +import java.util.HashMap;, +import java.util.List;, +import java.util.Map;, +import java.util.concurrent.ConcurrentHashMap;, +import java.util.concurrent.atomic.AtomicReference;, +    //TODO what should the setting name be?, +    public static final Setting<Settings> REMOTE_CLUSTERS_SEEDS = Setting.groupSetting("action.search.remote.",, +            SearchTransportService::validateRemoteClustersSeeds,, +            Setting.Property.NodeScope,, +            Setting.Property.Dynamic);, +    private final TransportService transportService;, +    private volatile Map<String, List<DiscoveryNode>> remoteClustersSeeds;, +, +    public SearchTransportService(Settings settings, ClusterSettings clusterSettings, TransportService transportService) {, +        setRemoteClustersSeeds(REMOTE_CLUSTERS_SEEDS.get(settings));, +        clusterSettings.addSettingsUpdateConsumer(REMOTE_CLUSTERS_SEEDS, this::setRemoteClustersSeeds,, +                SearchTransportService::validateRemoteClustersSeeds);, +    }, +, +    private static void validateRemoteClustersSeeds(Settings settings) {, +        //TODO do we need a static whitelist like in reindex from remote?, +        for (String clusterName : settings.names()) {, +            String[] remoteHosts = settings.getAsArray(clusterName);, +            if (remoteHosts.length == 0) {, +                throw new IllegalArgumentException("no hosts set for remote cluster [" + clusterName + "], at least one host is required");, +            }, +            for (String remoteHost : remoteHosts) {, +                int portSeparator = remoteHost.lastIndexOf(':'); // in case we have a IPv6 address ie. [::1]:9300, +                if (portSeparator == -1 || portSeparator == remoteHost.length()) {, +                    throw new IllegalArgumentException("remote hosts need to be configured as [host:port], found [" + remoteHost + "] " +, +                        "instead for remote cluster [" + clusterName + "]");, +                }, +                String host = remoteHost.substring(0, portSeparator);, +                try {, +                    InetAddress.getByName(host);, +                } catch (UnknownHostException e) {, +                    throw new IllegalArgumentException("unknown host [" + host + "]", e);, +                }, +                String port = remoteHost.substring(portSeparator + 1);, +                try {, +                    Integer portValue = Integer.valueOf(port);, +                    if (portValue <= 0) {, +                        throw new IllegalArgumentException("port number must be > 0 but was: [" + portValue + "]");, +                    }, +                } catch(NumberFormatException e) {, +                    throw new IllegalArgumentException("port must be a number, found [" + port + "] instead for remote cluster [" +, +                            clusterName + "]");, +                }, +            }, +        }, +    }, +, +    static Map<String, List<DiscoveryNode>> buildRemoteClustersSeeds(Settings settings) {, +        Map<String, List<DiscoveryNode>> remoteClustersNodes = new HashMap<>();, +        for (String clusterName : settings.names()) {, +            String[] remoteHosts = settings.getAsArray(clusterName);, +            for (String remoteHost : remoteHosts) {, +                int portSeparator = remoteHost.lastIndexOf(':'); // in case we have a IPv6 address ie. [::1]:9300, +                String host = remoteHost.substring(0, portSeparator);, +                InetAddress hostAddress;, +                try {, +                    hostAddress = InetAddress.getByName(host);, +                } catch (UnknownHostException e) {, +                    throw new IllegalArgumentException("unknown host [" + host + "]", e);, +                }, +                int port = Integer.valueOf(remoteHost.substring(portSeparator + 1));, +                DiscoveryNode node = new DiscoveryNode(clusterName + "#" + remoteHost,, +                        new TransportAddress(new InetSocketAddress(hostAddress, port)),, +                        Version.CURRENT.minimumCompatibilityVersion());, +                //don't connect yet as that would require the remote node to be up and would fail the local node startup otherwise, +                List<DiscoveryNode> nodes = remoteClustersNodes.get(clusterName);, +                if (nodes == null) {, +                    nodes = new ArrayList<>();, +                    remoteClustersNodes.put(clusterName, nodes);, +                }, +                nodes.add(node);, +            }, +        }, +        return remoteClustersNodes;, +    }, +, +    private void setRemoteClustersSeeds(Settings settings) {, +        remoteClustersSeeds = buildRemoteClustersSeeds(settings);]