[+++ b/x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authz/store/CompositeRolesStore.java, +        fileRolesStore.addListener(this::invalidate);, +    public void invalidate(Set<String> roles) {, +        numInvalidation.incrementAndGet();, +, +        // the cache cannot be modified while doing this operation per the terms of the cache iterator, +        try (ReleasableLock ignored = writeLock.acquire()) {, +            Iterator<Set<String>> keyIter = roleCache.keys().iterator();, +            while (keyIter.hasNext()) {, +                Set<String> key = keyIter.next();, +                if (Sets.haveEmptyIntersection(key, roles) == false) {, +                    keyIter.remove();, +                }, +            }, +        }, +, +        negativeLookupCache.removeAll(roles);, +    }, +, +++ b/x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authz/store/CompositeRolesStore.java, +        fileRolesStore.addListener(this::invalidate);, +    public void invalidate(Set<String> roles) {, +        numInvalidation.incrementAndGet();, +, +        // the cache cannot be modified while doing this operation per the terms of the cache iterator, +        try (ReleasableLock ignored = writeLock.acquire()) {, +            Iterator<Set<String>> keyIter = roleCache.keys().iterator();, +            while (keyIter.hasNext()) {, +                Set<String> key = keyIter.next();, +                if (Sets.haveEmptyIntersection(key, roles) == false) {, +                    keyIter.remove();, +                }, +            }, +        }, +, +        negativeLookupCache.removeAll(roles);, +    }, +, +++ b/x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authz/store/FileRolesStore.java, +import org.elasticsearch.common.util.set.Sets;, +import java.util.Collections;, +import java.util.function.Consumer;, +import java.util.stream.Collectors;, +    private final List<Consumer<Set<String>>> listeners = new ArrayList<>();, +        this(settings, env, watcherService, null, licenseState);, +    FileRolesStore(Settings settings, Environment env, ResourceWatcherService watcherService, Consumer<Set<String>> listener,, +        final Map<String, RoleDescriptor> localPermissions = permissions;, +            RoleDescriptor descriptor = localPermissions.get(name);, +        final Map<String, RoleDescriptor> localPermissions = permissions;, +        usageStats.put("size", localPermissions.size());, +        for (RoleDescriptor descriptor : localPermissions.values()) {, +    public void addListener(Consumer<Set<String>> consumer) {, +        Objects.requireNonNull(consumer);, +            listeners.add(consumer);, +    // package private for testing, +    Set<String> getAllRoleNames() {, +        return permissions.keySet();, +    }, +, +        public synchronized void onFileChanged(Path file) {, +                final Map<String, RoleDescriptor> previousPermissions = permissions;, +                    logger.info("updated roles (roles file [{}] {})", file.toAbsolutePath(),, +                        Files.exists(file) ? "changed" : "removed");, +                final Set<String> changedOrMissingRoles = Sets.difference(previousPermissions.entrySet(), permissions.entrySet()), +                        .stream(), +                        .map(Map.Entry::getKey), +                        .collect(Collectors.toSet());, +                final Set<String> addedRoles = Sets.difference(permissions.keySet(), previousPermissions.keySet());, +                final Set<String> changedRoles = Collections.unmodifiableSet(Sets.union(changedOrMissingRoles, addedRoles));, +                listeners.forEach(c -> c.accept(changedRoles));, +++ b/x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authz/store/CompositeRolesStore.java, +        fileRolesStore.addListener(this::invalidate);, +    public void invalidate(Set<String> roles) {, +        numInvalidation.incrementAndGet();, +, +        // the cache cannot be modified while doing this operation per the terms of the cache iterator, +        try (ReleasableLock ignored = writeLock.acquire()) {, +            Iterator<Set<String>> keyIter = roleCache.keys().iterator();, +            while (keyIter.hasNext()) {, +                Set<String> key = keyIter.next();, +                if (Sets.haveEmptyIntersection(key, roles) == false) {, +                    keyIter.remove();, +                }, +            }, +        }, +, +        negativeLookupCache.removeAll(roles);, +    }, +, +++ b/x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authz/store/FileRolesStore.java, +import org.elasticsearch.common.util.set.Sets;, +import java.util.Collections;, +import java.util.function.Consumer;, +import java.util.stream.Collectors;, +    private final List<Consumer<Set<String>>> listeners = new ArrayList<>();, +        this(settings, env, watcherService, null, licenseState);, +    FileRolesStore(Settings settings, Environment env, ResourceWatcherService watcherService, Consumer<Set<String>> listener,, +        final Map<String, RoleDescriptor> localPermissions = permissions;, +            RoleDescriptor descriptor = localPermissions.get(name);, +        final Map<String, RoleDescriptor> localPermissions = permissions;]