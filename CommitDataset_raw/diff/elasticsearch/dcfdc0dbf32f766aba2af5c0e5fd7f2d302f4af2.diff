[+++ b/core/src/main/java/org/elasticsearch/action/support/replication/TransportReplicationAction.java, +                logger.trace("Retrying operation on replica, action [{}], request [{}]", t, actionName, request);, +                    failReplicaIfNeeded(request.internalShardId.getIndex(), request.internalShardId.id(), t, request);, +                logger.trace("primary shard [{}] is not yet active, scheduling a retry. action [{}], request [{}]", primary.shardId(), actionName, internalRequest.request);, +                logger.trace("operation failed. action [{}], request [{}]", failure, actionName, internalRequest.request);, +            logger.warn("unexpected error during the primary phase for action [{}], request [{}]", failure, actionName, internalRequest.request);, +                if (logger.isTraceEnabled()) {, +                    logger.trace("operation succeeded. action [{}],request [{}]", actionName, internalRequest.request);, +                }, +                if (logger.isTraceEnabled()) {, +                    logger.trace("operation completed on primary [{}], action [{}], request [{}], cluster state version [{}]", primary, actionName, por.request, observer.observedState().version());, +                }, +                    logger.trace("had an error while performing operation on primary ({}, action [{}], request [{}]), scheduling a retry.", e, primary, actionName, internalRequest.request);, +                logger.trace("not enough active copies of shard [{}] to meet write consistency of [{}] (have {}, needed {}), scheduling a retry. action [{}], request [{}]",, +                        shard.shardId(), consistencyLevel, sizeActive, requiredNumber, actionName, internalRequest.request);, +    private void failReplicaIfNeeded(String index, int shardId, Throwable t, ReplicaRequest request) {, +        logger.trace("failure on replica [{}][{}], action [{}], request [{}]", t, index, shardId, actionName, request);, +            if (logger.isTraceEnabled()) {, +                logger.trace("replication phase started. pending [{}], action [{}], request [{}], cluster state version used [{}]", pending.get(),, +                        actionName, replicaRequest, observer.observedState().version());, +            }, +                                logger.trace("[{}] transport failure during replica request [{}], action [{}]", exp, node, replicaRequest, actionName);, +                                failReplicaIfNeeded(shard.index(), shard.id(), e, replicaRequest);, +                    failReplicaIfNeeded(shard.index(), shard.id(), e, replicaRequest);, +++ b/core/src/main/java/org/elasticsearch/action/support/replication/TransportReplicationAction.java, +                logger.trace("Retrying operation on replica, action [{}], request [{}]", t, actionName, request);, +                    failReplicaIfNeeded(request.internalShardId.getIndex(), request.internalShardId.id(), t, request);, +                logger.trace("primary shard [{}] is not yet active, scheduling a retry. action [{}], request [{}]", primary.shardId(), actionName, internalRequest.request);, +                logger.trace("operation failed. action [{}], request [{}]", failure, actionName, internalRequest.request);, +            logger.warn("unexpected error during the primary phase for action [{}], request [{}]", failure, actionName, internalRequest.request);, +                if (logger.isTraceEnabled()) {, +                    logger.trace("operation succeeded. action [{}],request [{}]", actionName, internalRequest.request);, +                }, +                if (logger.isTraceEnabled()) {, +                    logger.trace("operation completed on primary [{}], action [{}], request [{}], cluster state version [{}]", primary, actionName, por.request, observer.observedState().version());, +                }, +                    logger.trace("had an error while performing operation on primary ({}, action [{}], request [{}]), scheduling a retry.", e, primary, actionName, internalRequest.request);, +                logger.trace("not enough active copies of shard [{}] to meet write consistency of [{}] (have {}, needed {}), scheduling a retry. action [{}], request [{}]",, +                        shard.shardId(), consistencyLevel, sizeActive, requiredNumber, actionName, internalRequest.request);, +    private void failReplicaIfNeeded(String index, int shardId, Throwable t, ReplicaRequest request) {, +        logger.trace("failure on replica [{}][{}], action [{}], request [{}]", t, index, shardId, actionName, request);, +            if (logger.isTraceEnabled()) {, +                logger.trace("replication phase started. pending [{}], action [{}], request [{}], cluster state version used [{}]", pending.get(),, +                        actionName, replicaRequest, observer.observedState().version());, +            }, +                                logger.trace("[{}] transport failure during replica request [{}], action [{}]", exp, node, replicaRequest, actionName);, +                                failReplicaIfNeeded(shard.index(), shard.id(), e, replicaRequest);, +                    failReplicaIfNeeded(shard.index(), shard.id(), e, replicaRequest);, +++ b/core/src/main/java/org/elasticsearch/action/update/TransportUpdateAction.java, +                                logger.trace("Retry attempt [{}] of [{}] on version conflict on [{}][{}][{}]",, +                                        retryCount + 1, request.retryOnConflict(), request.index(), request.shardId(), request.id());, +++ b/core/src/main/java/org/elasticsearch/action/support/replication/TransportReplicationAction.java, +                logger.trace("Retrying operation on replica, action [{}], request [{}]", t, actionName, request);, +                    failReplicaIfNeeded(request.internalShardId.getIndex(), request.internalShardId.id(), t, request);, +                logger.trace("primary shard [{}] is not yet active, scheduling a retry. action [{}], request [{}]", primary.shardId(), actionName, internalRequest.request);, +                logger.trace("operation failed. action [{}], request [{}]", failure, actionName, internalRequest.request);, +            logger.warn("unexpected error during the primary phase for action [{}], request [{}]", failure, actionName, internalRequest.request);, +                if (logger.isTraceEnabled()) {, +                    logger.trace("operation succeeded. action [{}],request [{}]", actionName, internalRequest.request);, +                }, +                if (logger.isTraceEnabled()) {, +                    logger.trace("operation completed on primary [{}], action [{}], request [{}], cluster state version [{}]", primary, actionName, por.request, observer.observedState().version());, +                }, +                    logger.trace("had an error while performing operation on primary ({}, action [{}], request [{}]), scheduling a retry.", e, primary, actionName, internalRequest.request);, +                logger.trace("not enough active copies of shard [{}] to meet write consistency of [{}] (have {}, needed {}), scheduling a retry. action [{}], request [{}]",, +                        shard.shardId(), consistencyLevel, sizeActive, requiredNumber, actionName, internalRequest.request);, +    private void failReplicaIfNeeded(String index, int shardId, Throwable t, ReplicaRequest request) {, +        logger.trace("failure on replica [{}][{}], action [{}], request [{}]", t, index, shardId, actionName, request);, +            if (logger.isTraceEnabled()) {, +                logger.trace("replication phase started. pending [{}], action [{}], request [{}], cluster state version used [{}]", pending.get(),, +                        actionName, replicaRequest, observer.observedState().version());, +            }, +                                logger.trace("[{}] transport failure during replica request [{}], action [{}]", exp, node, replicaRequest, actionName);, +                                failReplicaIfNeeded(shard.index(), shard.id(), e, replicaRequest);, +                    failReplicaIfNeeded(shard.index(), shard.id(), e, replicaRequest);, +++ b/core/src/main/java/org/elasticsearch/action/update/TransportUpdateAction.java, +                                logger.trace("Retry attempt [{}] of [{}] on version conflict on [{}][{}][{}]",, +                                        retryCount + 1, request.retryOnConflict(), request.index(), request.shardId(), request.id());, +++ b/core/src/main/java/org/elasticsearch/cluster/routing/AllocationId.java, +import org.elasticsearch.common.Nullable;, +import org.elasticsearch.common.xcontent.XContentParser;, +import org.elasticsearch.gateway.CorruptStateException;, +    private static final String ID_KEY = "id";, +    private static final String RELOCATION_ID_KEY = "relocation_id";, +    @Nullable, +        builder.startObject();, +        builder.field(ID_KEY, id);, +            builder.field(RELOCATION_ID_KEY, relocationId);, +, +    public static AllocationId fromXContent(XContentParser parser) throws IOException {, +        XContentParser.Token token = parser.currentToken();, +        if (token == null) { // fresh parser? move to the first real token under object, +            token = parser.nextToken();, +        }, +        assert token == XContentParser.Token.START_OBJECT;, +, +        String id = null;, +        String relocationId = null;, +, +        String currentFieldName = null;]