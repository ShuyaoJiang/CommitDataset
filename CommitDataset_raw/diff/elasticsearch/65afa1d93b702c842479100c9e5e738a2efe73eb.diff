[+++ b/docs/reference/query-dsl/queries/function-score-query.asciidoc, +The `random_score` generates scores using a hash of the `_uid` field,, +with a `seed` for variation. If `seed` is not specified, the current, +time is used., +, +NOTE: Using this feature will load field data for `_uid`, which can, +be a memory intensive operation since the values are unique., +++ b/docs/reference/query-dsl/queries/function-score-query.asciidoc, +The `random_score` generates scores using a hash of the `_uid` field,, +with a `seed` for variation. If `seed` is not specified, the current, +time is used., +, +NOTE: Using this feature will load field data for `_uid`, which can, +be a memory intensive operation since the values are unique., +++ b/src/main/java/org/elasticsearch/common/lucene/search/function/RandomScoreFunction.java, +import org.apache.lucene.util.StringHelper;, +import org.elasticsearch.index.fielddata.AtomicFieldData;, +import org.elasticsearch.index.fielddata.IndexFieldData;, +import org.elasticsearch.index.fielddata.SortedBinaryDocValues;, +    private int originalSeed;, +    private int saltedSeed;, +    private final IndexFieldData<?> uidFieldData;, +    private SortedBinaryDocValues uidByteData;, +    /**, +     * Creates a RandomScoreFunction., +     *, +     * @param seed A seed for randomness, +     * @param salt A value to salt the seed with, ideally unique to the running node/index, +     * @param uidFieldData The field data for _uid to use for generating consistent random values for the same id, +     */, +    public RandomScoreFunction(int seed, int salt, IndexFieldData<?> uidFieldData) {, +        this.originalSeed = seed;, +        this.saltedSeed = seed ^ salt;, +        this.uidFieldData = uidFieldData;, +        if (uidFieldData == null) throw new NullPointerException("uid missing");, +        AtomicFieldData leafData = uidFieldData.load(context);, +        uidByteData = leafData.getBytesValues();, +        if (uidByteData == null) throw new NullPointerException("failed to get uid byte data");, +        uidByteData.setDocument(docId);, +        int hash = StringHelper.murmurhash3_x86_32(uidByteData.valueAt(0), saltedSeed);, +        return (hash & 0x00FFFFFF) / (float)(1 << 24); // only use the lower 24 bits to construct a float from 0.0-1.0, +        exp.setDescription("random score function (seed: " + originalSeed + ")");, +++ b/docs/reference/query-dsl/queries/function-score-query.asciidoc, +The `random_score` generates scores using a hash of the `_uid` field,, +with a `seed` for variation. If `seed` is not specified, the current, +time is used., +, +NOTE: Using this feature will load field data for `_uid`, which can, +be a memory intensive operation since the values are unique., +++ b/src/main/java/org/elasticsearch/common/lucene/search/function/RandomScoreFunction.java, +import org.apache.lucene.util.StringHelper;, +import org.elasticsearch.index.fielddata.AtomicFieldData;, +import org.elasticsearch.index.fielddata.IndexFieldData;, +import org.elasticsearch.index.fielddata.SortedBinaryDocValues;, +    private int originalSeed;, +    private int saltedSeed;, +    private final IndexFieldData<?> uidFieldData;, +    private SortedBinaryDocValues uidByteData;, +    /**, +     * Creates a RandomScoreFunction., +     *, +     * @param seed A seed for randomness, +     * @param salt A value to salt the seed with, ideally unique to the running node/index, +     * @param uidFieldData The field data for _uid to use for generating consistent random values for the same id, +     */, +    public RandomScoreFunction(int seed, int salt, IndexFieldData<?> uidFieldData) {, +        this.originalSeed = seed;, +        this.saltedSeed = seed ^ salt;, +        this.uidFieldData = uidFieldData;, +        if (uidFieldData == null) throw new NullPointerException("uid missing");, +        AtomicFieldData leafData = uidFieldData.load(context);, +        uidByteData = leafData.getBytesValues();, +        if (uidByteData == null) throw new NullPointerException("failed to get uid byte data");, +        uidByteData.setDocument(docId);, +        int hash = StringHelper.murmurhash3_x86_32(uidByteData.valueAt(0), saltedSeed);, +        return (hash & 0x00FFFFFF) / (float)(1 << 24); // only use the lower 24 bits to construct a float from 0.0-1.0, +        exp.setDescription("random score function (seed: " + originalSeed + ")");, +++ b/src/main/java/org/elasticsearch/index/query/functionscore/ScoreFunctionBuilders.java, +    public static RandomScoreFunctionBuilder randomFunction(int seed) {, +++ b/docs/reference/query-dsl/queries/function-score-query.asciidoc, +The `random_score` generates scores using a hash of the `_uid` field,, +with a `seed` for variation. If `seed` is not specified, the current, +time is used., +, +NOTE: Using this feature will load field data for `_uid`, which can, +be a memory intensive operation since the values are unique., +++ b/src/main/java/org/elasticsearch/common/lucene/search/function/RandomScoreFunction.java, +import org.apache.lucene.util.StringHelper;, +import org.elasticsearch.index.fielddata.AtomicFieldData;, +import org.elasticsearch.index.fielddata.IndexFieldData;, +import org.elasticsearch.index.fielddata.SortedBinaryDocValues;, +    private int originalSeed;, +    private int saltedSeed;, +    private final IndexFieldData<?> uidFieldData;, +    private SortedBinaryDocValues uidByteData;, +    /**, +     * Creates a RandomScoreFunction., +     *, +     * @param seed A seed for randomness, +     * @param salt A value to salt the seed with, ideally unique to the running node/index]