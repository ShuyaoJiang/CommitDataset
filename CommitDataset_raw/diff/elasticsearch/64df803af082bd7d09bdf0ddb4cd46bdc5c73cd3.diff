[+++ b/x-pack/plugin/core/src/main/java/org/elasticsearch/index/engine/FrozenEngine.java, +import org.elasticsearch.common.settings.Setting;, +import org.elasticsearch.index.shard.SearchOperationListener;, +import org.elasticsearch.search.internal.SearchContext;, +import org.elasticsearch.transport.TransportRequest;, +    public static final Setting<Boolean> INDEX_FROZEN = Setting.boolSetting("index.frozen", false, Setting.Property.IndexScope,, +        Setting.Property.PrivateIndex);, +    /*, +     * We register this listener for a frozen index that will, +     *  1. reset the reader every time the search context is validated which happens when the context is looked up ie. on a fetch phase, +     *  etc., +     *  2. register a releasable resource that is cleaned after each phase that releases the reader for this searcher, +     */, +    public static class ReacquireEngineSearcherListener implements SearchOperationListener {, +, +        @Override, +        public void validateSearchContext(SearchContext context, TransportRequest transportRequest) {, +            Searcher engineSearcher = context.searcher().getEngineSearcher();, +            LazyDirectoryReader lazyDirectoryReader = unwrapLazyReader(engineSearcher.getDirectoryReader());, +            if (lazyDirectoryReader != null) {, +                try {, +                    lazyDirectoryReader.reset();, +                } catch (IOException e) {, +                    throw new UncheckedIOException(e);, +                }, +                // also register a release resource in this case if we have multiple roundtrips like in DFS, +                registerRelease(context, lazyDirectoryReader);, +            }, +        }, +, +        private void registerRelease(SearchContext context, LazyDirectoryReader lazyDirectoryReader) {, +            context.addReleasable(() -> {, +                try {, +                    lazyDirectoryReader.release();, +                } catch (IOException e) {, +                    throw new UncheckedIOException(e);, +                }, +            }, SearchContext.Lifetime.PHASE);, +        }, +, +        @Override, +        public void onNewContext(SearchContext context) {, +            Searcher engineSearcher = context.searcher().getEngineSearcher();, +            LazyDirectoryReader lazyDirectoryReader = unwrapLazyReader(engineSearcher.getDirectoryReader());, +            if (lazyDirectoryReader != null) {, +                registerRelease(context, lazyDirectoryReader);, +            }, +        }, +    }, +, +++ b/x-pack/plugin/core/src/main/java/org/elasticsearch/index/engine/FrozenEngine.java, +import org.elasticsearch.common.settings.Setting;, +import org.elasticsearch.index.shard.SearchOperationListener;, +import org.elasticsearch.search.internal.SearchContext;, +import org.elasticsearch.transport.TransportRequest;, +    public static final Setting<Boolean> INDEX_FROZEN = Setting.boolSetting("index.frozen", false, Setting.Property.IndexScope,, +        Setting.Property.PrivateIndex);, +    /*, +     * We register this listener for a frozen index that will, +     *  1. reset the reader every time the search context is validated which happens when the context is looked up ie. on a fetch phase, +     *  etc., +     *  2. register a releasable resource that is cleaned after each phase that releases the reader for this searcher, +     */, +    public static class ReacquireEngineSearcherListener implements SearchOperationListener {, +, +        @Override, +        public void validateSearchContext(SearchContext context, TransportRequest transportRequest) {, +            Searcher engineSearcher = context.searcher().getEngineSearcher();, +            LazyDirectoryReader lazyDirectoryReader = unwrapLazyReader(engineSearcher.getDirectoryReader());, +            if (lazyDirectoryReader != null) {, +                try {, +                    lazyDirectoryReader.reset();, +                } catch (IOException e) {, +                    throw new UncheckedIOException(e);, +                }, +                // also register a release resource in this case if we have multiple roundtrips like in DFS, +                registerRelease(context, lazyDirectoryReader);, +            }, +        }, +, +        private void registerRelease(SearchContext context, LazyDirectoryReader lazyDirectoryReader) {, +            context.addReleasable(() -> {, +                try {, +                    lazyDirectoryReader.release();, +                } catch (IOException e) {, +                    throw new UncheckedIOException(e);, +                }, +            }, SearchContext.Lifetime.PHASE);, +        }, +, +        @Override, +        public void onNewContext(SearchContext context) {, +            Searcher engineSearcher = context.searcher().getEngineSearcher();, +            LazyDirectoryReader lazyDirectoryReader = unwrapLazyReader(engineSearcher.getDirectoryReader());, +            if (lazyDirectoryReader != null) {, +                registerRelease(context, lazyDirectoryReader);, +            }, +        }, +    }, +]