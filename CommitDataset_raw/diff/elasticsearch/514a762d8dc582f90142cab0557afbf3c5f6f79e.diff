[+++ b/server/src/main/java/org/elasticsearch/action/admin/indices/close/TransportVerifyShardBeforeCloseAction.java, +        indexShard.verifyShardBeforeIndexClosing();, +++ b/server/src/main/java/org/elasticsearch/action/admin/indices/close/TransportVerifyShardBeforeCloseAction.java, +        indexShard.verifyShardBeforeIndexClosing();, +++ b/server/src/main/java/org/elasticsearch/index/engine/Engine.java, +     * Performs the pre-closing checks on the {@link Engine}., +     *, +     * @throws IllegalStateException if the sanity checks failed, +     */, +    public void verifyEngineBeforeIndexClosing() throws IllegalStateException {, +        final long globalCheckpoint = engineConfig.getGlobalCheckpointSupplier().getAsLong();, +        final long maxSeqNo = getSeqNoStats(globalCheckpoint).getMaxSeqNo();, +        if (globalCheckpoint != maxSeqNo) {, +            throw new IllegalStateException("Global checkpoint [" + globalCheckpoint, +                + "] mismatches maximum sequence number [" + maxSeqNo + "] on index shard " + shardId);, +        }, +    }, +, +    /**, +++ b/server/src/main/java/org/elasticsearch/action/admin/indices/close/TransportVerifyShardBeforeCloseAction.java, +        indexShard.verifyShardBeforeIndexClosing();, +++ b/server/src/main/java/org/elasticsearch/index/engine/Engine.java, +     * Performs the pre-closing checks on the {@link Engine}., +     *, +     * @throws IllegalStateException if the sanity checks failed, +     */, +    public void verifyEngineBeforeIndexClosing() throws IllegalStateException {, +        final long globalCheckpoint = engineConfig.getGlobalCheckpointSupplier().getAsLong();, +        final long maxSeqNo = getSeqNoStats(globalCheckpoint).getMaxSeqNo();, +        if (globalCheckpoint != maxSeqNo) {, +            throw new IllegalStateException("Global checkpoint [" + globalCheckpoint, +                + "] mismatches maximum sequence number [" + maxSeqNo + "] on index shard " + shardId);, +        }, +    }, +, +    /**, +++ b/server/src/main/java/org/elasticsearch/index/engine/ReadOnlyEngine.java, +    @Override, +    public void verifyEngineBeforeIndexClosing() throws IllegalStateException {, +        // the value of the global checkpoint is verified when the read-only engine is opened,, +        // and it is not expected to change during the lifecycle of the engine. We could also, +        // check this value before closing the read-only engine but if something went wrong, +        // and the global checkpoint is not in-sync with the max. sequence number anymore,, +        // checking the value here again would prevent the read-only engine to be closed and, +        // reopened as an internal engine, which would be the path to fix the issue., +    }, +, +++ b/server/src/main/java/org/elasticsearch/action/admin/indices/close/TransportVerifyShardBeforeCloseAction.java, +        indexShard.verifyShardBeforeIndexClosing();, +++ b/server/src/main/java/org/elasticsearch/index/engine/Engine.java, +     * Performs the pre-closing checks on the {@link Engine}., +     *, +     * @throws IllegalStateException if the sanity checks failed, +     */, +    public void verifyEngineBeforeIndexClosing() throws IllegalStateException {, +        final long globalCheckpoint = engineConfig.getGlobalCheckpointSupplier().getAsLong();, +        final long maxSeqNo = getSeqNoStats(globalCheckpoint).getMaxSeqNo();, +        if (globalCheckpoint != maxSeqNo) {, +            throw new IllegalStateException("Global checkpoint [" + globalCheckpoint, +                + "] mismatches maximum sequence number [" + maxSeqNo + "] on index shard " + shardId);, +        }, +    }, +, +    /**, +++ b/server/src/main/java/org/elasticsearch/index/engine/ReadOnlyEngine.java, +    @Override, +    public void verifyEngineBeforeIndexClosing() throws IllegalStateException {, +        // the value of the global checkpoint is verified when the read-only engine is opened,, +        // and it is not expected to change during the lifecycle of the engine. We could also, +        // check this value before closing the read-only engine but if something went wrong, +        // and the global checkpoint is not in-sync with the max. sequence number anymore,, +        // checking the value here again would prevent the read-only engine to be closed and, +        // reopened as an internal engine, which would be the path to fix the issue., +    }, +, +++ b/server/src/main/java/org/elasticsearch/index/shard/IndexShard.java, +, +    /**, +     * Performs the pre-closing checks on the {@link IndexShard}., +     *, +     * @throws IllegalStateException if the sanity checks failed, +     */, +    public void verifyShardBeforeIndexClosing() throws IllegalStateException {, +        getEngine().verifyEngineBeforeIndexClosing();, +    }, +++ b/server/src/main/java/org/elasticsearch/action/admin/indices/close/TransportVerifyShardBeforeCloseAction.java, +        indexShard.verifyShardBeforeIndexClosing();, +++ b/server/src/main/java/org/elasticsearch/index/engine/Engine.java, +     * Performs the pre-closing checks on the {@link Engine}., +     *, +     * @throws IllegalStateException if the sanity checks failed, +     */, +    public void verifyEngineBeforeIndexClosing() throws IllegalStateException {, +        final long globalCheckpoint = engineConfig.getGlobalCheckpointSupplier().getAsLong();, +        final long maxSeqNo = getSeqNoStats(globalCheckpoint).getMaxSeqNo();, +        if (globalCheckpoint != maxSeqNo) {, +            throw new IllegalStateException("Global checkpoint [" + globalCheckpoint, +                + "] mismatches maximum sequence number [" + maxSeqNo + "] on index shard " + shardId);, +        }, +    }]