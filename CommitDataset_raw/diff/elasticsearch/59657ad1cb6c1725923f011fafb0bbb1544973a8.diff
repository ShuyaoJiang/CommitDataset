[+++ b/core/src/main/java/org/elasticsearch/index/seqno/LocalCheckpointTracker.java, +import com.carrotsearch.hppc.LongObjectHashMap;, +     * We keep a bit for each sequence number that is still pending. To optimize allocation, we do so in multiple sets allocating them on, +     * demand and cleaning up while completed. This constant controls the size of the sets., +    static final int BIT_SET_SIZE = 1024;, +     * A collection of bit sets representing pending sequence numbers. Each sequence number is mapped to a bit set by dividing by the, +     * bit set size., +    final LongObjectHashMap<FixedBitSet> processedSeqNo = new LongObjectHashMap<>();, +            long bitSetKey = getBitSetKey(checkpoint);, +            FixedBitSet current = processedSeqNo.get(bitSetKey);, +            if (current == null) {, +                // the bit set corresponding to the checkpoint has already been removed, set ourselves up for the next bit set, +                assert checkpoint % BIT_SET_SIZE == BIT_SET_SIZE - 1;, +                current = processedSeqNo.get(++bitSetKey);, +            }, +                /*, +                 * The checkpoint always falls in the current bit set or we have already cleaned it; if it falls on the last bit of the, +                 * current bit set, we can clean it., +                 */, +                if (checkpoint == lastSeqNoInBitSet(bitSetKey)) {, +                    assert current != null;, +                    final FixedBitSet removed = processedSeqNo.remove(bitSetKey);, +                    assert removed == current;, +                    current = processedSeqNo.get(++bitSetKey);, +    private long lastSeqNoInBitSet(final long bitSetKey) {, +        return (1 + bitSetKey) * BIT_SET_SIZE - 1;, +     * Return the bit set for the provided sequence number, possibly allocating a new set if needed., +     *, +     * @param seqNo the sequence number to obtain the bit set for, +     * @return the bit set corresponding to the provided sequence number, +     */, +    private long getBitSetKey(final long seqNo) {, +        assert Thread.holdsLock(this);, +        return seqNo / BIT_SET_SIZE;, +    }, +, +    private FixedBitSet getBitSetForSeqNo(final long seqNo) {, +        assert Thread.holdsLock(this);, +        final long bitSetKey = getBitSetKey(seqNo);, +        final int index = processedSeqNo.indexOf(bitSetKey);, +        final FixedBitSet bitSet;, +        if (processedSeqNo.indexExists(index)) {, +            bitSet = processedSeqNo.indexGet(index);, +        } else {, +            bitSet = new FixedBitSet(BIT_SET_SIZE);, +            processedSeqNo.indexInsert(index, bitSetKey, bitSet);, +        }, +        return bitSet;, +    }, +, +    /**, +     * Obtain the position in the bit set corresponding to the provided sequence number. The bit set corresponding to the sequence number, +     * can be obtained via {@link #getBitSetForSeqNo(long)}., +     * @return the position in the bit set corresponding to the provided sequence number, +        return Math.toIntExact(seqNo % BIT_SET_SIZE);, +++ b/core/src/main/java/org/elasticsearch/index/seqno/LocalCheckpointTracker.java, +import com.carrotsearch.hppc.LongObjectHashMap;, +     * We keep a bit for each sequence number that is still pending. To optimize allocation, we do so in multiple sets allocating them on, +     * demand and cleaning up while completed. This constant controls the size of the sets., +    static final int BIT_SET_SIZE = 1024;, +     * A collection of bit sets representing pending sequence numbers. Each sequence number is mapped to a bit set by dividing by the, +     * bit set size., +    final LongObjectHashMap<FixedBitSet> processedSeqNo = new LongObjectHashMap<>();, +            long bitSetKey = getBitSetKey(checkpoint);, +            FixedBitSet current = processedSeqNo.get(bitSetKey);, +            if (current == null) {, +                // the bit set corresponding to the checkpoint has already been removed, set ourselves up for the next bit set, +                assert checkpoint % BIT_SET_SIZE == BIT_SET_SIZE - 1;, +                current = processedSeqNo.get(++bitSetKey);, +            }, +                /*, +                 * The checkpoint always falls in the current bit set or we have already cleaned it; if it falls on the last bit of the, +                 * current bit set, we can clean it., +                 */, +                if (checkpoint == lastSeqNoInBitSet(bitSetKey)) {, +                    assert current != null;, +                    final FixedBitSet removed = processedSeqNo.remove(bitSetKey);, +                    assert removed == current;, +                    current = processedSeqNo.get(++bitSetKey);, +    private long lastSeqNoInBitSet(final long bitSetKey) {, +        return (1 + bitSetKey) * BIT_SET_SIZE - 1;, +     * Return the bit set for the provided sequence number, possibly allocating a new set if needed., +     *, +     * @param seqNo the sequence number to obtain the bit set for, +     * @return the bit set corresponding to the provided sequence number, +     */, +    private long getBitSetKey(final long seqNo) {, +        assert Thread.holdsLock(this);, +        return seqNo / BIT_SET_SIZE;, +    }, +, +    private FixedBitSet getBitSetForSeqNo(final long seqNo) {, +        assert Thread.holdsLock(this);, +        final long bitSetKey = getBitSetKey(seqNo);, +        final int index = processedSeqNo.indexOf(bitSetKey);, +        final FixedBitSet bitSet;, +        if (processedSeqNo.indexExists(index)) {, +            bitSet = processedSeqNo.indexGet(index);, +        } else {, +            bitSet = new FixedBitSet(BIT_SET_SIZE);]