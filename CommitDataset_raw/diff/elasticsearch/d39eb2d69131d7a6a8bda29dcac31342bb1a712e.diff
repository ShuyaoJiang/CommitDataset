[+++ b/core/src/main/java/org/elasticsearch/action/admin/cluster/allocation/ClusterAllocationExplanation.java, +    private final Map<DiscoveryNode, Decision> nodeToDecision;, +    private final Map<DiscoveryNode, Float> nodeWeights;, +            Map<DiscoveryNode, Float> nodeWeights, long remainingDelayNanos) {, +        this.nodeToDecision = nodeToDecision == null ? Collections.emptyMap() : nodeToDecision;, +        this.nodeWeights = nodeWeights == null ? Collections.emptyMap() : nodeWeights;, +        Map<DiscoveryNode, Decision> ntd = null;, +        int size = in.readVInt();, +        ntd = new HashMap<>(size);, +        for (int i = 0; i < size; i++) {, +            DiscoveryNode dn = new DiscoveryNode(in);, +            Decision decision = Decision.readFrom(in);, +            ntd.put(dn, decision);, +        this.nodeToDecision = ntd;, +        Map<DiscoveryNode, Float> ntw = null;, +        size = in.readVInt();, +        ntw = new HashMap<>(size);, +        for (int i = 0; i < size; i++) {, +            DiscoveryNode dn = new DiscoveryNode(in);, +            float weight = in.readFloat();, +            ntw.put(dn, weight);, +        this.nodeWeights = ntw;, +        remainingDelayNanos = in.readVLong();, +, +        Map<DiscoveryNode, Decision> ntd = this.getNodeDecisions();, +        out.writeVInt(ntd.size());, +        for (Map.Entry<DiscoveryNode, Decision> entry : ntd.entrySet()) {, +            entry.getKey().writeTo(out);, +            Decision.writeTo(entry.getValue(), out);, +        }, +        Map<DiscoveryNode, Float> ntw = this.getNodeWeights();, +        out.writeVInt(ntw.size());, +        for (Map.Entry<DiscoveryNode, Float> entry : ntw.entrySet()) {, +            entry.getKey().writeTo(out);, +            out.writeFloat(entry.getValue());, +        }, +    /** Return a map of node to decision for shard allocation */, +    public Map<DiscoveryNode, Decision> getNodeDecisions() {, +        return this.nodeToDecision;, +    }, +, +    /**, +     * Return a map of node to balancer "weight" for allocation. Higher weights mean the balancer wants to allocated the shard to that node, +     * more, +     */, +    public Map<DiscoveryNode, Float> getNodeWeights() {, +        return this.nodeWeights;, +    }, +, +            for (Map.Entry<DiscoveryNode, Float> entry : nodeWeights.entrySet()) {, +                DiscoveryNode node = entry.getKey();, +                    Decision d = nodeToDecision.get(node);, +                    if (node.getId().equals(assignedNodeId)) {, +                        builder.field("final_decision", "CURRENTLY_ASSIGNED");, +                    } else {, +                        builder.field("final_decision", d.type().toString());, +                    builder.field("weight", entry.getValue());, +                    d.toXContent(builder, params);, +            }, +            builder.endObject(); // end nodes, +        }, +        builder.endObject(); // end wrapping object, +++ b/core/src/main/java/org/elasticsearch/action/admin/cluster/allocation/ClusterAllocationExplanation.java, +    private final Map<DiscoveryNode, Decision> nodeToDecision;, +    private final Map<DiscoveryNode, Float> nodeWeights;, +            Map<DiscoveryNode, Float> nodeWeights, long remainingDelayNanos) {, +        this.nodeToDecision = nodeToDecision == null ? Collections.emptyMap() : nodeToDecision;, +        this.nodeWeights = nodeWeights == null ? Collections.emptyMap() : nodeWeights;, +        Map<DiscoveryNode, Decision> ntd = null;, +        int size = in.readVInt();, +        ntd = new HashMap<>(size);, +        for (int i = 0; i < size; i++) {, +            DiscoveryNode dn = new DiscoveryNode(in);, +            Decision decision = Decision.readFrom(in);, +            ntd.put(dn, decision);, +        this.nodeToDecision = ntd;, +        Map<DiscoveryNode, Float> ntw = null;, +        size = in.readVInt();, +        ntw = new HashMap<>(size);, +        for (int i = 0; i < size; i++) {, +            DiscoveryNode dn = new DiscoveryNode(in);, +            float weight = in.readFloat();, +            ntw.put(dn, weight);, +        this.nodeWeights = ntw;, +        remainingDelayNanos = in.readVLong();, +, +        Map<DiscoveryNode, Decision> ntd = this.getNodeDecisions();, +        out.writeVInt(ntd.size());, +        for (Map.Entry<DiscoveryNode, Decision> entry : ntd.entrySet()) {, +            entry.getKey().writeTo(out);, +            Decision.writeTo(entry.getValue(), out);, +        }, +        Map<DiscoveryNode, Float> ntw = this.getNodeWeights();, +        out.writeVInt(ntw.size());, +        for (Map.Entry<DiscoveryNode, Float> entry : ntw.entrySet()) {, +            entry.getKey().writeTo(out);, +            out.writeFloat(entry.getValue());, +        }, +    /** Return a map of node to decision for shard allocation */, +    public Map<DiscoveryNode, Decision> getNodeDecisions() {]