[+++ b/docs/java-api/query-dsl-filters.asciidoc, +To use `QueryBuilders` or `FilterBuilders` just import them in your class:, +import static org.elasticsearch.index.query.QueryBuilders.*;, +import static org.elasticsearch.index.query.FilterBuilders.*;, +FilterBuilder filter = andFilter(, +    rangeFilter("postDate").from("2010-03-01").to("2010-04-01"),    <1>, +    prefixFilter("name.second", "ba"));                             <1>, +<1> filters, +FilterBuilder filter = boolFilter(), +    .must(termFilter("tag", "wow"))                     <1>, +    .mustNot(rangeFilter("age").from("10").to("20"))    <2>, +    .should(termFilter("tag", "sometag"))               <3>, +    .should(termFilter("tag", "sometagtag"));           <3>, +<1> must filter, +<2> must not filter, +<3> should filter, +FilterBuilder filter = existsFilter("user");    <1>, +<1> field, +FilterBuilder filter = idsFilter("my_type", "type2"), +    .addIds("1", "4", "100");, +FilterBuilder filter = idsFilter() <1>, +    .addIds("1", "4", "100");, +<1> type is optional, +FilterBuilder filter = limitFilter(100);    <1>, +<1> number of documents per shard, +FilterBuilder filter = typeFilter("my_type");   <1>, +<1> type, +FilterBuilder filter = geoBoundingBoxFilter("pin.location") <1>, +    .topLeft(40.73, -74.1)                                  <2>, +    .bottomRight(40.717, -73.99);                           <3>, +<1> field, +<2> bounding box top left point, +<3> bounding box bottom right point, +FilterBuilder filter = geoDistanceFilter("pin.location")    <1>, +    .point(40, -70)                                         <2>, +    .distance(200, DistanceUnit.KILOMETERS)                 <3>, +    .optimizeBbox("memory")                                 <4>, +    .geoDistance(GeoDistance.ARC);                          <5>, +<1> field, +<2> center point, +<3> distance from center point, +<4> optimize bounding box: `memory`, `indexed` or `none`, +<5> distance computation mode: `GeoDistance.SLOPPY_ARC` (default), `GeoDistance.ARC` (slighly more precise but, +    significantly slower) or `GeoDistance.PLANE` (faster, but inaccurate on long distances and close to the poles), +FilterBuilder filter = geoDistanceRangeFilter("pin.location")   <1>, +    .point(40, -70)                                             <2>, +    .from("200km")                                              <3>, +    .to("400km")                                                <4>, +    .includeLower(true)                                         <5>, +    .includeUpper(false)                                        <6>, +    .optimizeBbox("memory")                                     <7>, +    .geoDistance(GeoDistance.ARC);                              <8>, +<1> field, +<2> center point, +<3> starting distance from center point, +<4> ending distance from center point, +<5> include lower value means that `from` is `gt` when `false` or `gte` when `true`, +<6> include upper value means that `to` is `lt` when `false` or `lte` when `true`, +<7> optimize bounding box: `memory`, `indexed` or `none`, +<8> distance computation mode: `GeoDistance.SLOPPY_ARC` (default), `GeoDistance.ARC` (slighly more precise but, +    significantly slower) or `GeoDistance.PLANE` (faster, but inaccurate on long distances and close to the poles), +FilterBuilder filter = geoPolygonFilter("pin.location") <1>, +    .addPoint(40, -70)                                  <2>, +    .addPoint(30, -80)                                  <2>, +    .addPoint(20, -90);                                 <2>, +<1> field, +<2> add your polygon of points a document should fall within, +    <version>0.4.1</version>                        <1>, +    <version>1.13</version>                         <2>, +<1> check for updates in http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.spatial4j%22%20AND%20a%3A%22spatial4j%22[Maven Central], +<2> check for updates in http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.vividsolutions%22%20AND%20a%3A%22jts%22[Maven Central], +FilterBuilder filter = geoShapeFilter(, +        "location",                                     <1>, +        new RectangleImpl(0,10,0,10,SpatialContext.GEO) <2>, +    ), +    .relation(ShapeRelation.WITHIN);                    <3>, +<1> field, +<2> shape, +<3> relation, +, +[source,java], +--------------------------------------------------, +// Intersect shapes, +FilterBuilder filter = geoShapeFilter(, +        "location",                                     <1>, +        new PointImpl(0, 0, SpatialContext.GEO)         <2>, +    ), +    .relation(ShapeRelation.INTERSECTS);                <3>, +--------------------------------------------------, +<1> field, +<2> shape, +<3> relation, +, +[source,java], +--------------------------------------------------, +// Using pre-indexed shapes, +FilterBuilder filter = geoShapeFilter(, +        "location",                                     <1>, +        "New Zealand",                                  <2>, +        "countries")                                    <3>]