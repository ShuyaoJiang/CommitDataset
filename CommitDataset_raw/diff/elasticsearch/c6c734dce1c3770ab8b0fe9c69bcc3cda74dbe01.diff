[+++ b/core/src/main/java/org/elasticsearch/index/mapper/DateFieldMapper.java, +            // This check needs to be done after fromInclusive and toInclusive, +            // are resolved so we can throw an exception if they are invalid, +            // even if there are no points in the shard, +            if (PointValues.size(reader, name()) == 0) {, +                // no points, so nothing matches, +                return Relation.DISJOINT;, +            }, +, +            long minValue = LongPoint.decodeDimension(PointValues.getMinPackedValue(reader, name()), 0);, +            long maxValue = LongPoint.decodeDimension(PointValues.getMaxPackedValue(reader, name()), 0);, +, +++ b/core/src/main/java/org/elasticsearch/index/mapper/DateFieldMapper.java, +            // This check needs to be done after fromInclusive and toInclusive, +            // are resolved so we can throw an exception if they are invalid, +            // even if there are no points in the shard, +            if (PointValues.size(reader, name()) == 0) {, +                // no points, so nothing matches, +                return Relation.DISJOINT;, +            }, +, +            long minValue = LongPoint.decodeDimension(PointValues.getMinPackedValue(reader, name()), 0);, +            long maxValue = LongPoint.decodeDimension(PointValues.getMaxPackedValue(reader, name()), 0);, +, +++ b/core/src/test/java/org/elasticsearch/index/mapper/DateFieldTypeTests.java, +        QueryRewriteContext context = new QueryRewriteContext(null, null, null, null, null, null, null, () -> nowInMillis);, +                randomBoolean(), randomBoolean(), null, null, context));, +, +        QueryRewriteContext context = new QueryRewriteContext(null, null, null, null, null, null, null, () -> nowInMillis);, +        assertEquals(Relation.DISJOINT, ft2.isFieldWithinQuery(reader, "2015-10-09", "2016-01-02", false, false, null, null, context));, +++ b/core/src/main/java/org/elasticsearch/index/mapper/DateFieldMapper.java, +            // This check needs to be done after fromInclusive and toInclusive, +            // are resolved so we can throw an exception if they are invalid, +            // even if there are no points in the shard, +            if (PointValues.size(reader, name()) == 0) {, +                // no points, so nothing matches, +                return Relation.DISJOINT;, +            }, +, +            long minValue = LongPoint.decodeDimension(PointValues.getMinPackedValue(reader, name()), 0);, +            long maxValue = LongPoint.decodeDimension(PointValues.getMaxPackedValue(reader, name()), 0);, +, +++ b/core/src/test/java/org/elasticsearch/index/mapper/DateFieldTypeTests.java, +        QueryRewriteContext context = new QueryRewriteContext(null, null, null, null, null, null, null, () -> nowInMillis);, +                randomBoolean(), randomBoolean(), null, null, context));, +, +        QueryRewriteContext context = new QueryRewriteContext(null, null, null, null, null, null, null, () -> nowInMillis);, +        assertEquals(Relation.DISJOINT, ft2.isFieldWithinQuery(reader, "2015-10-09", "2016-01-02", false, false, null, null, context));, +++ b/core/src/test/java/org/elasticsearch/search/query/SearchQueryIT.java]