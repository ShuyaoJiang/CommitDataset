[+++ b/src/main/java/org/elasticsearch/action/bulk/BulkRequestBuilder.java, +++ b/src/main/java/org/elasticsearch/action/bulk/BulkRequestBuilder.java, +++ b/src/main/java/org/elasticsearch/action/bulk/BulkShardRequest.java, +++ b/src/main/java/org/elasticsearch/action/bulk/BulkRequestBuilder.java, +++ b/src/main/java/org/elasticsearch/action/bulk/BulkShardRequest.java, +++ b/src/main/java/org/elasticsearch/action/bulk/TransportShardBulkAction.java, +import org.elasticsearch.index.translog.Translog;, +        final IndexService indexService = indicesService.indexServiceSafe(request.index());, +        final IndexShard indexShard = indexService.shardSafe(shardRequest.shardId.id());, +        Translog.Location location = null;, +                    WriteResult<IndexResponse> result = shardIndexOperation(request, indexRequest, clusterState, indexShard, true);, +                    location = locationToSync(location, result.location);, +                    final WriteResult<DeleteResponse> writeResult = shardDeleteOperation(request, deleteRequest, indexShard);, +                    DeleteResponse deleteResponse = writeResult.response();, +                    location = locationToSync(location, writeResult.location);, +                        updateResult = shardUpdateOperation(clusterState, request, updateRequest, indexShard);, +                        if (updateResult.writeResult != null) {, +                            location = locationToSync(location, updateResult.writeResult.location);, +                        }, +                                WriteResult<IndexResponse> result = updateResult.writeResult;, +                                WriteResult<DeleteResponse> writeResult = updateResult.writeResult;, +                                DeleteResponse response = writeResult.response();, +        processAfter(request, indexShard, location);, +                                            IndexShard indexShard, boolean processed) throws Throwable {, +        return executeIndexRequestOnPrimary(request, indexRequest, indexShard);, +    private WriteResult<DeleteResponse> shardDeleteOperation(BulkShardRequest request, DeleteRequest deleteRequest, IndexShard indexShard) {, +        return new WriteResult(deleteResponse, delete.getTranslogLocation());, +    private UpdateResult shardUpdateOperation(ClusterState clusterState, BulkShardRequest bulkShardRequest, UpdateRequest updateRequest, IndexShard indexShard) {, +                    WriteResult result = shardIndexOperation(bulkShardRequest, indexRequest, clusterState, indexShard, false);, +        Translog.Location location = null;, +                    location = locationToSync(location, operation.getTranslogLocation());, +                    location = locationToSync(location, delete.getTranslogLocation());, +       processAfter(request, indexShard, location);, +    }, +, +    private void processAfter(BulkShardRequest request, IndexShard indexShard, Translog.Location location) {, +, +        if (indexShard.getTranslogDurability() == Translog.Durabilty.REQUEST && location != null) {, +            indexShard.sync(location);, +        }, +, +    private Translog.Location locationToSync(Translog.Location current, Translog.Location next) {, +        /* here we are moving forward in the translog with each operation. Under the hood, +         * this might cross translog files which is ok since from the user perspective, +         * the translog is like a tape where only the highest location needs to be fsynced, +         * in order to sync all previous locations even though they are not in the same file., +         * When the translog rolls over files the previous file is fsynced on after closing if needed.*/, +        assert next != null : "next operation can't be null";, +        assert current == null || current.compareTo(next) < 0 : "translog locations are not increasing";, +        return next;, +    }, +++ b/src/main/java/org/elasticsearch/action/bulk/BulkRequestBuilder.java, +++ b/src/main/java/org/elasticsearch/action/bulk/BulkShardRequest.java, +++ b/src/main/java/org/elasticsearch/action/bulk/TransportShardBulkAction.java, +import org.elasticsearch.index.translog.Translog;, +        final IndexService indexService = indicesService.indexServiceSafe(request.index());, +        final IndexShard indexShard = indexService.shardSafe(shardRequest.shardId.id());, +        Translog.Location location = null;, +                    WriteResult<IndexResponse> result = shardIndexOperation(request, indexRequest, clusterState, indexShard, true);, +                    location = locationToSync(location, result.location);, +                    final WriteResult<DeleteResponse> writeResult = shardDeleteOperation(request, deleteRequest, indexShard);, +                    DeleteResponse deleteResponse = writeResult.response();, +                    location = locationToSync(location, writeResult.location);, +                        updateResult = shardUpdateOperation(clusterState, request, updateRequest, indexShard);, +                        if (updateResult.writeResult != null) {, +                            location = locationToSync(location, updateResult.writeResult.location);, +                        }, +                                WriteResult<IndexResponse> result = updateResult.writeResult;, +                                WriteResult<DeleteResponse> writeResult = updateResult.writeResult;, +                                DeleteResponse response = writeResult.response();, +        processAfter(request, indexShard, location);, +                                            IndexShard indexShard, boolean processed) throws Throwable {, +        return executeIndexRequestOnPrimary(request, indexRequest, indexShard);, +    private WriteResult<DeleteResponse> shardDeleteOperation(BulkShardRequest request, DeleteRequest deleteRequest, IndexShard indexShard) {, +        return new WriteResult(deleteResponse, delete.getTranslogLocation());, +    private UpdateResult shardUpdateOperation(ClusterState clusterState, BulkShardRequest bulkShardRequest, UpdateRequest updateRequest, IndexShard indexShard) {, +                    WriteResult result = shardIndexOperation(bulkShardRequest, indexRequest, clusterState, indexShard, false);, +        Translog.Location location = null;, +                    location = locationToSync(location, operation.getTranslogLocation());, +                    location = locationToSync(location, delete.getTranslogLocation());, +       processAfter(request, indexShard, location);, +    }, +, +    private void processAfter(BulkShardRequest request, IndexShard indexShard, Translog.Location location) {, +, +        if (indexShard.getTranslogDurability() == Translog.Durabilty.REQUEST && location != null) {, +            indexShard.sync(location);, +        }, +, +    private Translog.Location locationToSync(Translog.Location current, Translog.Location next) {, +        /* here we are moving forward in the translog with each operation. Under the hood, +         * this might cross translog files which is ok since from the user perspective, +         * the translog is like a tape where only the highest location needs to be fsynced, +         * in order to sync all previous locations even though they are not in the same file., +         * When the translog rolls over files the previous file is fsynced on after closing if needed.*/, +        assert next != null : "next operation can't be null";, +        assert current == null || current.compareTo(next) < 0 : "translog locations are not increasing";, +        return next;, +    }, +++ b/src/main/java/org/elasticsearch/action/delete/TransportDeleteAction.java]