[+++ b/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/ScrollHelper.java, +                        } else if (results.size() == resp.getHits().getTotalHits()) {, +                            clearScroll.accept(resp);, +                            // Finally, return the list of the entity, +                            listener.onResponse(Collections.unmodifiableList(results));, +                        // Finally, return the list of the entity, +++ b/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/ScrollHelper.java, +                        } else if (results.size() == resp.getHits().getTotalHits()) {, +                            clearScroll.accept(resp);, +                            // Finally, return the list of the entity, +                            listener.onResponse(Collections.unmodifiableList(results));, +                        // Finally, return the list of the entity, +++ b/plugin/security/src/main/java/org/elasticsearch/xpack/security/action/saml/TransportSamlInvalidateSessionAction.java, +import java.util.Collection;, +    private List<Tuple<UserToken, String>> filterTokens(Collection<Tuple<UserToken, String>> tokens, Map<String, Object> requiredMetadata) {, +++ b/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/ScrollHelper.java, +                        } else if (results.size() == resp.getHits().getTotalHits()) {, +                            clearScroll.accept(resp);, +                            // Finally, return the list of the entity, +                            listener.onResponse(Collections.unmodifiableList(results));, +                        // Finally, return the list of the entity, +++ b/plugin/security/src/main/java/org/elasticsearch/xpack/security/action/saml/TransportSamlInvalidateSessionAction.java, +import java.util.Collection;, +    private List<Tuple<UserToken, String>> filterTokens(Collection<Tuple<UserToken, String>> tokens, Map<String, Object> requiredMetadata) {, +++ b/plugin/security/src/main/java/org/elasticsearch/xpack/security/authc/TokenService.java, +import org.elasticsearch.action.support.ContextPreservingActionListener;, +import org.elasticsearch.search.SearchHit;, +import org.elasticsearch.xpack.core.security.ScrollHelper;, +import java.util.Collection;, +import java.util.function.Supplier;, +    public void findActiveTokensForRealm(String realmName, ActionListener<Collection<Tuple<UserToken, String>>> listener) {, +        final SearchRequest request = client.prepareSearch(SecurityLifecycleService.SECURITY_INDEX_NAME), +                .setScroll(TimeValue.timeValueSeconds(10L)), +                .setSize(1000), +                .setFetchSource(true), +        final Supplier<ThreadContext.StoredContext> supplier = client.threadPool().getThreadContext().newRestorableContext(false);, +            ScrollHelper.fetchAllByEntity(client, request, new ContextPreservingActionListener<>(supplier, listener), this::parseHit));, +    private Tuple<UserToken, String> parseHit(SearchHit hit) {, +        if (source == null) {, +            throw new IllegalStateException("token document did not have source but source should have been fetched");, +        }, +, +++ b/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/ScrollHelper.java, +                        } else if (results.size() == resp.getHits().getTotalHits()) {, +                            clearScroll.accept(resp);, +                            // Finally, return the list of the entity, +                            listener.onResponse(Collections.unmodifiableList(results));, +                        // Finally, return the list of the entity, +++ b/plugin/security/src/main/java/org/elasticsearch/xpack/security/action/saml/TransportSamlInvalidateSessionAction.java, +import java.util.Collection;, +    private List<Tuple<UserToken, String>> filterTokens(Collection<Tuple<UserToken, String>> tokens, Map<String, Object> requiredMetadata) {, +++ b/plugin/security/src/main/java/org/elasticsearch/xpack/security/authc/TokenService.java, +import org.elasticsearch.action.support.ContextPreservingActionListener;, +import org.elasticsearch.search.SearchHit;, +import org.elasticsearch.xpack.core.security.ScrollHelper;, +import java.util.Collection;, +import java.util.function.Supplier;, +    public void findActiveTokensForRealm(String realmName, ActionListener<Collection<Tuple<UserToken, String>>> listener) {, +        final SearchRequest request = client.prepareSearch(SecurityLifecycleService.SECURITY_INDEX_NAME), +                .setScroll(TimeValue.timeValueSeconds(10L)), +                .setSize(1000), +                .setFetchSource(true), +        final Supplier<ThreadContext.StoredContext> supplier = client.threadPool().getThreadContext().newRestorableContext(false);, +            ScrollHelper.fetchAllByEntity(client, request, new ContextPreservingActionListener<>(supplier, listener), this::parseHit));, +    private Tuple<UserToken, String> parseHit(SearchHit hit) {, +        if (source == null) {, +            throw new IllegalStateException("token document did not have source but source should have been fetched");, +        }, +, +++ b/plugin/security/src/test/java/org/elasticsearch/xpack/security/ScrollHelperIntegTests.java, +        SearchHit[] hits = new SearchHit[] {new SearchHit(1), new SearchHit(2)};, +        InternalSearchResponse internalResponse = new InternalSearchResponse(new SearchHits(hits, 3, 1), null, null, null, false, false, 1);, +        assertEquals("scrolling returned more hits [4] than expected [3] so bailing out to prevent unbounded memory consumption.",, +++ b/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/ScrollHelper.java, +                        } else if (results.size() == resp.getHits().getTotalHits()) {, +                            clearScroll.accept(resp);, +                            // Finally, return the list of the entity, +                            listener.onResponse(Collections.unmodifiableList(results));, +                        // Finally, return the list of the entity, +++ b/plugin/security/src/main/java/org/elasticsearch/xpack/security/action/saml/TransportSamlInvalidateSessionAction.java, +import java.util.Collection;, +    private List<Tuple<UserToken, String>> filterTokens(Collection<Tuple<UserToken, String>> tokens, Map<String, Object> requiredMetadata) {, +++ b/plugin/security/src/main/java/org/elasticsearch/xpack/security/authc/TokenService.java, +import org.elasticsearch.action.support.ContextPreservingActionListener;, +import org.elasticsearch.search.SearchHit;, +import org.elasticsearch.xpack.core.security.ScrollHelper;, +import java.util.Collection;, +import java.util.function.Supplier;, +    public void findActiveTokensForRealm(String realmName, ActionListener<Collection<Tuple<UserToken, String>>> listener) {, +        final SearchRequest request = client.prepareSearch(SecurityLifecycleService.SECURITY_INDEX_NAME), +                .setScroll(TimeValue.timeValueSeconds(10L)), +                .setSize(1000), +                .setFetchSource(true), +        final Supplier<ThreadContext.StoredContext> supplier = client.threadPool().getThreadContext().newRestorableContext(false);, +            ScrollHelper.fetchAllByEntity(client, request, new ContextPreservingActionListener<>(supplier, listener), this::parseHit));, +    private Tuple<UserToken, String> parseHit(SearchHit hit) {, +        if (source == null) {, +            throw new IllegalStateException("token document did not have source but source should have been fetched");, +        }, +]