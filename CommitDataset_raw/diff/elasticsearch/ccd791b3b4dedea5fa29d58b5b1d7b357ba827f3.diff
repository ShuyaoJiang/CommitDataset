[+++ b/server/src/test/java/org/elasticsearch/index/engine/InternalEngineTests.java, +import java.util.Iterator;, +                                                              long primaryTerm,, +                                                              int minOpCount, int maxOpCount, String docId) {, +        final Term id = newUid(docId);, +        final int startWithSeqNo = 0;, +        final String valuePrefix = (forReplica ? "r_" : "p_" ) + docId + "_";, +                op = new Engine.Index(id, testParsedDocument(docId, null, testDocumentWithTextField(valuePrefix + i), B_1, null),, +                op = new Engine.Delete("test", docId, id,, +            randomFrom(VersionType.INTERNAL, VersionType.EXTERNAL, VersionType.EXTERNAL_GTE, VersionType.FORCE), 2, 2, 20, "1");, +    public void testConcurrentOutOfOrderDocsOnReplica() throws IOException, InterruptedException {, +        final List<Engine.Operation> opsDoc1 =, +            generateSingleDocHistory(true, randomFrom(VersionType.INTERNAL, VersionType.EXTERNAL), 2, 100, 300, "1");, +        final Engine.Operation lastOpDoc1 = opsDoc1.get(opsDoc1.size() - 1);, +        final String lastFieldValueDoc1;, +        if (lastOpDoc1 instanceof Engine.Index) {, +            Engine.Index index = (Engine.Index) lastOpDoc1;, +            lastFieldValueDoc1 = index.docs().get(0).get("value");, +            lastFieldValueDoc1 = null;, +        final List<Engine.Operation> opsDoc2 =, +            generateSingleDocHistory(true, randomFrom(VersionType.INTERNAL, VersionType.EXTERNAL), 2, 100, 300, "2");, +        final Engine.Operation lastOpDoc2 = opsDoc2.get(opsDoc2.size() - 1);, +        final String lastFieldValueDoc2;, +        if (lastOpDoc2 instanceof Engine.Index) {, +            Engine.Index index = (Engine.Index) lastOpDoc2;, +            lastFieldValueDoc2 = index.docs().get(0).get("value");, +        } else {, +            // delete, +            lastFieldValueDoc2 = null;, +        }, +        // randomly interleave, +        final AtomicLong seqNoGenerator = new AtomicLong();, +        Function<Engine.Operation, Engine.Operation> seqNoUpdater = operation -> {, +            final long newSeqNo = seqNoGenerator.getAndIncrement();, +            if (operation instanceof Engine.Index) {, +                Engine.Index index = (Engine.Index) operation;, +                return new Engine.Index(index.uid(), index.parsedDoc(), newSeqNo, index.primaryTerm(), index.version(),, +                    index.versionType(), index.origin(), index.startTime(), index.getAutoGeneratedIdTimestamp(), index.isRetry());, +            } else {, +                Engine.Delete delete = (Engine.Delete) operation;, +                return new Engine.Delete(delete.type(), delete.id(), delete.uid(), newSeqNo, delete.primaryTerm(),, +                    delete.version(), delete.versionType(), delete.origin(), delete.startTime());, +            }, +        };, +        final List<Engine.Operation> allOps = new ArrayList<>();, +        Iterator<Engine.Operation> iter1 = opsDoc1.iterator();, +        Iterator<Engine.Operation> iter2 = opsDoc2.iterator();, +        while (iter1.hasNext() && iter2.hasNext()) {, +            final Engine.Operation next = randomBoolean() ? iter1.next() : iter2.next();, +            allOps.add(seqNoUpdater.apply(next));, +        }, +        iter1.forEachRemaining(o -> allOps.add(seqNoUpdater.apply(o)));, +        iter2.forEachRemaining(o -> allOps.add(seqNoUpdater.apply(o)));, +        // insert some duplicates, +        allOps.addAll(randomSubsetOf(allOps));, +        shuffle(allOps, random());, +        concurrentlyApplyOps(allOps, engine);, +, +        engine.refresh("test");, +, +        if (lastFieldValueDoc1 != null) {, +                searcher.searcher().search(new TermQuery(new Term("value", lastFieldValueDoc1)), collector);, +        if (lastFieldValueDoc2 != null) {, +            try (Searcher searcher = engine.acquireSearcher("test")) {, +                final TotalHitCountCollector collector = new TotalHitCountCollector();, +                searcher.searcher().search(new TermQuery(new Term("value", lastFieldValueDoc2)), collector);, +                assertThat(collector.getTotalHits(), equalTo(1));, +            }, +        }, +, +        int totalExpectedOps = 0;, +        if (lastFieldValueDoc1 != null) {, +            totalExpectedOps++;, +        }, +        if (lastFieldValueDoc2 != null) {, +            totalExpectedOps++;, +        }, +        assertVisibleCount(engine, totalExpectedOps);, +        final List<Engine.Operation> ops = generateSingleDocHistory(false, VersionType.INTERNAL, 2, 2, 20, "1");, +        List<Engine.Operation> ops = generateSingleDocHistory(false, VersionType.INTERNAL, 2, 10, 100, "1");, +        final List<Engine.Operation> ops = generateSingleDocHistory(false, versionType, 2, 2, 20, "1");, +        final List<Engine.Operation> replicaOps = generateSingleDocHistory(true, VersionType.INTERNAL, 1, 2, 20, "1");, +        List<Engine.Operation> primaryOps = generateSingleDocHistory(false, VersionType.INTERNAL, 2, 2, 20, "1");, +        final List<Engine.Operation> ops = generateSingleDocHistory(false, VersionType.EXTERNAL, 2, 100, 300, "1");]