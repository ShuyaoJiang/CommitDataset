[+++ b/core/src/main/java/org/elasticsearch/action/bulk/TransportShardBulkAction.java, +                    UpdateResultHolder updateResultHolder = executeUpdateRequest(((UpdateRequest) itemRequest),, +                            primary, metaData, request, requestIndex);, +                    operation = updateResultHolder.operation;, +                    response = updateResultHolder.response;, +                    break;, +                case DELETE:, +                    final DeleteRequest deleteRequest = (DeleteRequest) itemRequest;, +                    operation = executeDeleteRequestOnPrimary(deleteRequest, primary);, +                    response = operation.hasFailure() ? null :, +                            new DeleteResponse(request.shardId(), deleteRequest.type(), deleteRequest.id(),, +                                operation.version(), ((Engine.Delete) operation).found());, +                    break;, +                default: throw new IllegalStateException("unexpected opType [" + itemRequest.opType() + "] found");, +            }, +            // update the bulk item request because update request execution can mutate the bulk item request, +            BulkItemRequest item = request.items()[requestIndex];, +            if (operation == null // in case of a noop update operation, +                    || operation.hasFailure() == false) {, +                if (operation != null) {, +                    location = locationToSync(location, operation.getTranslogLocation());, +                } else {, +                    assert response.getResult() == DocWriteResponse.Result.NOOP, +                            : "only noop update can have null operation";, +                }, +                // set update response, +                item.setPrimaryResponse(new BulkItemResponse(item.id(), opType, response));, +            } else {, +                DocWriteRequest docWriteRequest = item.request();, +                Exception failure = operation.getFailure();, +                if (isConflictException(failure)) {, +                    logger.trace((Supplier<?>) () -> new ParameterizedMessage("{} failed to execute bulk item ({}) {}",, +                            request.shardId(), docWriteRequest.opType().getLowercase(), request), failure);, +                } else {, +                    logger.debug((Supplier<?>) () -> new ParameterizedMessage("{} failed to execute bulk item ({}) {}",, +                            request.shardId(), docWriteRequest.opType().getLowercase(), request), failure);, +                }, +                // if its a conflict failure, and we already executed the request on a primary (and we execute it, +                // again, due to primary relocation and only processing up to N bulk items when the shard gets closed), +                // then just use the response we got from the successful execution, +                if (item.getPrimaryResponse() == null || isConflictException(failure) == false) {, +                    item.setPrimaryResponse(new BulkItemResponse(item.id(), docWriteRequest.opType(),, +                            new BulkItemResponse.Failure(request.index(), docWriteRequest.type(), docWriteRequest.id(), failure)));, +                }, +            }, +            assert item.getPrimaryResponse() != null;, +            assert preVersionTypes[requestIndex] != null;, +            if (item.getPrimaryResponse().isFailed(), +                    || item.getPrimaryResponse().getResponse().getResult() == DocWriteResponse.Result.NOOP) {, +                item.setIgnoreOnReplica();, +            } else {, +                // set the ShardInfo to 0 so we can safely send it to the replicas. We won't use it in the real response though., +                item.getPrimaryResponse().getResponse().setShardInfo(new ShardInfo());, +            }, +        } catch (Exception e) {, +            // rethrow the failure if we are going to retry on primary and let parent failure to handle it, +            if (retryPrimaryException(e)) {, +                // restore updated versions..., +                for (int j = 0; j < requestIndex; j++) {, +                    DocWriteRequest docWriteRequest = request.items()[j].request();, +                    docWriteRequest.version(preVersions[j]);, +                    docWriteRequest.versionType(preVersionTypes[j]);, +                }, +                throw e;, +            }, +            // TODO: maybe this assert is too strict, we can still get environment failures while executing write operations, +            assert false : "unexpected exception: " + e.getMessage() + " class:" + e.getClass().getSimpleName();, +        }, +        return location;, +    }, +, +    private static class UpdateResultHolder {, +        final Engine.Operation operation;, +        final DocWriteResponse response;, +, +        private UpdateResultHolder(Engine.Operation operation, DocWriteResponse response) {, +            this.operation = operation;, +            this.response = response;, +        }, +    }, +, +    /**, +     * Executes update request, delegating to a index or delete operation after translation,, +     * handles retries on version conflict and constructs update response, +     * NOTE: reassigns bulk item request at <code>requestIndex</code> for replicas to, +     * execute translated update request (NOOP update is an exception). NOOP updates are, +     * indicated by returning a <code>null</code> operation in {@link UpdateResultHolder}, +     * */, +    private UpdateResultHolder executeUpdateRequest(UpdateRequest updateRequest, IndexShard primary,, +                                                    IndexMetaData metaData, BulkShardRequest request,, +                                                    int requestIndex) throws Exception {, +            // translate update request, +            // execute translated update request, +            switch (translate.getResponseResult()) {, +                case CREATED:, +                case UPDATED:, +                    IndexRequest indexRequest = translate.action();, +                    MappingMetaData mappingMd = metaData.mappingOrDefault(indexRequest.type());, +                    indexRequest.process(mappingMd, allowIdGeneration, request.index());, +                    updateOperation = executeIndexRequestOnPrimary(indexRequest, primary, mappingUpdatedAction);]