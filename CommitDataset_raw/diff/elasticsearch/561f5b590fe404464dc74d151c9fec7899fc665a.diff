[+++ b/core/src/test/java/org/elasticsearch/cluster/allocation/AwarenessAllocationIT.java, +import org.elasticsearch.cluster.routing.allocation.decider.AwarenessAllocationDecider;, +import org.elasticsearch.discovery.zen.ZenDiscovery;, +                .put(AwarenessAllocationDecider.CLUSTER_ROUTING_ALLOCATION_AWARENESS_FORCE_GROUP + "zone.values", "a,b"), +                .put(AwarenessAllocationDecider.CLUSTER_ROUTING_ALLOCATION_AWARENESS_ATTRIBUTES, "zone"), +                .put(ElectMasterService.DISCOVERY_ZEN_MINIMUM_MASTER_NODES, 3), +                .put(ZenDiscovery.SETTING_JOIN_TIMEOUT, "10s"), +                Settings.settingsBuilder().put(commonSettings).put("node.zone", "a").build(),, +                Settings.settingsBuilder().put(commonSettings).put("node.zone", "b").build(),, +                Settings.settingsBuilder().put(commonSettings).put("node.zone", "b").build(),, +                Settings.settingsBuilder().put(commonSettings).put("node.zone", "a").build(), +, +        logger.info("--> waiting for nodes to form a cluster");, +        ClusterHealthResponse health = client().admin().cluster().prepareHealth().setWaitForNodes("4").execute().actionGet();, +        assertThat(health.isTimedOut(), equalTo(false));, +, +, +        logger.info("--> waiting for shards to be allocated");, +        health = client().admin().cluster().prepareHealth().setWaitForEvents(Priority.LANGUID).setWaitForGreenStatus().setWaitForRelocatingShards(0).execute().actionGet();, +, +++ b/core/src/test/java/org/elasticsearch/cluster/allocation/AwarenessAllocationIT.java, +import org.elasticsearch.cluster.routing.allocation.decider.AwarenessAllocationDecider;, +import org.elasticsearch.discovery.zen.ZenDiscovery;, +                .put(AwarenessAllocationDecider.CLUSTER_ROUTING_ALLOCATION_AWARENESS_FORCE_GROUP + "zone.values", "a,b"), +                .put(AwarenessAllocationDecider.CLUSTER_ROUTING_ALLOCATION_AWARENESS_ATTRIBUTES, "zone"), +                .put(ElectMasterService.DISCOVERY_ZEN_MINIMUM_MASTER_NODES, 3), +                .put(ZenDiscovery.SETTING_JOIN_TIMEOUT, "10s"), +                Settings.settingsBuilder().put(commonSettings).put("node.zone", "a").build(),, +                Settings.settingsBuilder().put(commonSettings).put("node.zone", "b").build(),, +                Settings.settingsBuilder().put(commonSettings).put("node.zone", "b").build(),, +                Settings.settingsBuilder().put(commonSettings).put("node.zone", "a").build(), +, +        logger.info("--> waiting for nodes to form a cluster");, +        ClusterHealthResponse health = client().admin().cluster().prepareHealth().setWaitForNodes("4").execute().actionGet();, +        assertThat(health.isTimedOut(), equalTo(false));, +, +, +        logger.info("--> waiting for shards to be allocated");, +        health = client().admin().cluster().prepareHealth().setWaitForEvents(Priority.LANGUID).setWaitForGreenStatus().setWaitForRelocatingShards(0).execute().actionGet();, +, +++ b/core/src/test/java/org/elasticsearch/common/io/PathUtilsForTesting.java, +        FileSystem mock = LuceneTestCase.getBaseTempDirForTestClass().getFileSystem();, +++ b/core/src/test/java/org/elasticsearch/cluster/allocation/AwarenessAllocationIT.java, +import org.elasticsearch.cluster.routing.allocation.decider.AwarenessAllocationDecider;, +import org.elasticsearch.discovery.zen.ZenDiscovery;, +                .put(AwarenessAllocationDecider.CLUSTER_ROUTING_ALLOCATION_AWARENESS_FORCE_GROUP + "zone.values", "a,b"), +                .put(AwarenessAllocationDecider.CLUSTER_ROUTING_ALLOCATION_AWARENESS_ATTRIBUTES, "zone"), +                .put(ElectMasterService.DISCOVERY_ZEN_MINIMUM_MASTER_NODES, 3), +                .put(ZenDiscovery.SETTING_JOIN_TIMEOUT, "10s"), +                Settings.settingsBuilder().put(commonSettings).put("node.zone", "a").build(),, +                Settings.settingsBuilder().put(commonSettings).put("node.zone", "b").build(),, +                Settings.settingsBuilder().put(commonSettings).put("node.zone", "b").build(),, +                Settings.settingsBuilder().put(commonSettings).put("node.zone", "a").build(), +, +        logger.info("--> waiting for nodes to form a cluster");, +        ClusterHealthResponse health = client().admin().cluster().prepareHealth().setWaitForNodes("4").execute().actionGet();, +        assertThat(health.isTimedOut(), equalTo(false));, +, +, +        logger.info("--> waiting for shards to be allocated");, +        health = client().admin().cluster().prepareHealth().setWaitForEvents(Priority.LANGUID).setWaitForGreenStatus().setWaitForRelocatingShards(0).execute().actionGet();, +, +++ b/core/src/test/java/org/elasticsearch/common/io/PathUtilsForTesting.java, +        FileSystem mock = LuceneTestCase.getBaseTempDirForTestClass().getFileSystem();, +++ b/core/src/test/java/org/elasticsearch/index/shard/NewPathForShardTests.java, +import com.carrotsearch.randomizedtesting.annotations.Repeat;, +import org.apache.lucene.mockfile.FilterFileSystem;, +import org.apache.lucene.mockfile.FilterPath;, +import org.elasticsearch.cluster.metadata.IndexMetaData;, +import org.elasticsearch.common.SuppressForbidden;, +import org.junit.Test;, +import java.io.File;, +import java.lang.reflect.Field;, +import java.nio.file.FileSystems;, +import java.nio.file.Files;, +import java.util.Arrays;, +import java.util.Set;, +, +import static org.elasticsearch.common.settings.Settings.settingsBuilder;, +@SuppressForbidden(reason = "ProviderMismatchException if I try to use PathUtils.getDefault instead"), +    private static FileSystem origFileSystem;, +    private static String aPathPart = File.separator + 'a' + File.separator;, +    private static String bPathPart = File.separator + 'b' + File.separator;, +        // Necessary so when Environment.clinit runs, to gather all FileStores, it sees ours:, +        origFileSystem = FileSystems.getDefault();, +, +        Field field = PathUtils.class.getDeclaredField("DEFAULT");, +        field.setAccessible(true);, +        FileSystem mock = new MockUsableSpaceFileSystemProvider().getFileSystem(getBaseTempDirForTestClass().toUri());, +        field.set(null, mock);, +        assertEquals(mock, PathUtils.getDefaultFileSystem());, +        Field field = PathUtils.class.getDeclaredField("DEFAULT");, +        field.setAccessible(true);, +        field.set(null, origFileSystem);, +        origFileSystem = null;, +    @SuppressForbidden(reason = "ProviderMismatchException if I try to use PathUtils.getDefault instead"), +        public MockUsableSpaceFileSystemProvider() {, +            super("mockusablespace://", FileSystems.getDefault());, +            fileSystem = new FilterFileSystem(this, origFileSystem) {, +                    @Override]