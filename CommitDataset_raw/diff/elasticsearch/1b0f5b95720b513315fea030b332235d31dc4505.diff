[+++ b/server/src/main/java/org/elasticsearch/persistent/AllocatedPersistentTask.java, +    private long allocationId;, +        persistentTasksService.updateStatus(persistentTaskId, allocationId, status, listener);, +    void init(PersistentTasksService persistentTasksService, long persistentTaskId, long allocationId) {, +        this.allocationId = allocationId;, +++ b/server/src/main/java/org/elasticsearch/persistent/AllocatedPersistentTask.java, +    private long allocationId;, +        persistentTasksService.updateStatus(persistentTaskId, allocationId, status, listener);, +    void init(PersistentTasksService persistentTasksService, long persistentTaskId, long allocationId) {, +        this.allocationId = allocationId;, +++ b/server/src/main/java/org/elasticsearch/persistent/NodePersistentTasksExecutor.java, + *, + * It abstracts away the execution of tasks and greatly simplifies testing of PersistentTasksNodeService, +++ b/server/src/main/java/org/elasticsearch/persistent/AllocatedPersistentTask.java, +    private long allocationId;, +        persistentTasksService.updateStatus(persistentTaskId, allocationId, status, listener);, +    void init(PersistentTasksService persistentTasksService, long persistentTaskId, long allocationId) {, +        this.allocationId = allocationId;, +++ b/server/src/main/java/org/elasticsearch/persistent/NodePersistentTasksExecutor.java, + *, + * It abstracts away the execution of tasks and greatly simplifies testing of PersistentTasksNodeService, +++ b/server/src/main/java/org/elasticsearch/persistent/PersistentTasksClusterService.java, +     * @param allocationId   the expected allocation id of the persistent task, +    public void updatePersistentTaskStatus(long id, long allocationId, Task.Status status, ActionListener<Empty> listener) {, +                if (tasksInProgress.hasTask(id, allocationId)) {, +                    if (tasksInProgress.hasTask(id)) {, +                        logger.warn("trying to update status on task {} with unexpected allocation id {}", id, allocationId);, +                    } else {, +                        logger.warn("trying to update status on non-existing task {}", id);, +                    }, +                    throw new ResourceNotFoundException("the task with id {} and allocation id {} doesn't exist", id, allocationId);, +++ b/server/src/main/java/org/elasticsearch/persistent/AllocatedPersistentTask.java, +    private long allocationId;, +        persistentTasksService.updateStatus(persistentTaskId, allocationId, status, listener);, +    void init(PersistentTasksService persistentTasksService, long persistentTaskId, long allocationId) {, +        this.allocationId = allocationId;, +++ b/server/src/main/java/org/elasticsearch/persistent/NodePersistentTasksExecutor.java, + *, + * It abstracts away the execution of tasks and greatly simplifies testing of PersistentTasksNodeService, +++ b/server/src/main/java/org/elasticsearch/persistent/PersistentTasksClusterService.java, +     * @param allocationId   the expected allocation id of the persistent task, +    public void updatePersistentTaskStatus(long id, long allocationId, Task.Status status, ActionListener<Empty> listener) {, +                if (tasksInProgress.hasTask(id, allocationId)) {, +                    if (tasksInProgress.hasTask(id)) {, +                        logger.warn("trying to update status on task {} with unexpected allocation id {}", id, allocationId);, +                    } else {, +                        logger.warn("trying to update status on non-existing task {}", id);, +                    }, +                    throw new ResourceNotFoundException("the task with id {} and allocation id {} doesn't exist", id, allocationId);, +++ b/server/src/main/java/org/elasticsearch/persistent/PersistentTasksCustomMetaData.java, +         * Checks if the task is currently present in the list and has the right allocation id, +         */, +        public boolean hasTask(long taskId, long allocationId) {, +            PersistentTask<?> taskInProgress = tasks.get(taskId);, +            if (taskInProgress != null) {, +                return taskInProgress.getAllocationId() == allocationId;, +            }, +            return false;, +        }, +, +        /**, +++ b/server/src/main/java/org/elasticsearch/persistent/AllocatedPersistentTask.java, +    private long allocationId;, +        persistentTasksService.updateStatus(persistentTaskId, allocationId, status, listener);, +    void init(PersistentTasksService persistentTasksService, long persistentTaskId, long allocationId) {, +        this.allocationId = allocationId;, +++ b/server/src/main/java/org/elasticsearch/persistent/NodePersistentTasksExecutor.java, + *, + * It abstracts away the execution of tasks and greatly simplifies testing of PersistentTasksNodeService, +++ b/server/src/main/java/org/elasticsearch/persistent/PersistentTasksClusterService.java, +     * @param allocationId   the expected allocation id of the persistent task, +    public void updatePersistentTaskStatus(long id, long allocationId, Task.Status status, ActionListener<Empty> listener) {, +                if (tasksInProgress.hasTask(id, allocationId)) {, +                    if (tasksInProgress.hasTask(id)) {, +                        logger.warn("trying to update status on task {} with unexpected allocation id {}", id, allocationId);, +                    } else {, +                        logger.warn("trying to update status on non-existing task {}", id);, +                    }, +                    throw new ResourceNotFoundException("the task with id {} and allocation id {} doesn't exist", id, allocationId);, +++ b/server/src/main/java/org/elasticsearch/persistent/PersistentTasksCustomMetaData.java, +         * Checks if the task is currently present in the list and has the right allocation id, +         */, +        public boolean hasTask(long taskId, long allocationId) {, +            PersistentTask<?> taskInProgress = tasks.get(taskId);, +            if (taskInProgress != null) {, +                return taskInProgress.getAllocationId() == allocationId;, +            }, +            return false;, +        }, +, +        /**, +++ b/server/src/main/java/org/elasticsearch/persistent/PersistentTasksExecutor.java, +++ b/server/src/main/java/org/elasticsearch/persistent/AllocatedPersistentTask.java, +    private long allocationId;, +        persistentTasksService.updateStatus(persistentTaskId, allocationId, status, listener);, +    void init(PersistentTasksService persistentTasksService, long persistentTaskId, long allocationId) {, +        this.allocationId = allocationId;, +++ b/server/src/main/java/org/elasticsearch/persistent/NodePersistentTasksExecutor.java, + *, + * It abstracts away the execution of tasks and greatly simplifies testing of PersistentTasksNodeService]