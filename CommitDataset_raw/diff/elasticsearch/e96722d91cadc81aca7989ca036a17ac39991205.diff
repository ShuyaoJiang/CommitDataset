[+++ b/core/src/main/java/org/elasticsearch/cluster/routing/IndexShardRoutingTable.java, +    public ShardIterator preferNodeActiveInitializingShardsIt(Set<String> nodeIds) {, +        ArrayList<ShardRouting> preferred = new ArrayList<>(activeShards.size() + allInitializingShards.size());, +        ArrayList<ShardRouting> notPreferred = new ArrayList<>(activeShards.size() + allInitializingShards.size());, +            if (nodeIds.contains(shardRouting.currentNodeId())) {, +                preferred.add(shardRouting);, +            } else {, +                notPreferred.add(shardRouting);, +        preferred.addAll(notPreferred);, +            preferred.addAll(allInitializingShards);, +        return new PlainShardIterator(shardId, preferred);, +++ b/core/src/main/java/org/elasticsearch/cluster/routing/IndexShardRoutingTable.java, +    public ShardIterator preferNodeActiveInitializingShardsIt(Set<String> nodeIds) {, +        ArrayList<ShardRouting> preferred = new ArrayList<>(activeShards.size() + allInitializingShards.size());, +        ArrayList<ShardRouting> notPreferred = new ArrayList<>(activeShards.size() + allInitializingShards.size());, +            if (nodeIds.contains(shardRouting.currentNodeId())) {, +                preferred.add(shardRouting);, +            } else {, +                notPreferred.add(shardRouting);, +        preferred.addAll(notPreferred);, +            preferred.addAll(allInitializingShards);, +        return new PlainShardIterator(shardId, preferred);, +++ b/core/src/main/java/org/elasticsearch/cluster/routing/OperationRouting.java, +import java.util.Arrays;, +import java.util.stream.Collectors;, +                case PREFER_NODES:, +                    final Set<String> nodesIds =, +                            Arrays.stream(, +                                    preference.substring(Preference.PREFER_NODES.type().length() + 1).split(","), +                            ).collect(Collectors.toSet());, +                    return indexShard.preferNodeActiveInitializingShardsIt(nodesIds);, +                    return indexShard.preferNodeActiveInitializingShardsIt(Collections.singleton(localNodeId));, +++ b/core/src/main/java/org/elasticsearch/cluster/routing/IndexShardRoutingTable.java, +    public ShardIterator preferNodeActiveInitializingShardsIt(Set<String> nodeIds) {, +        ArrayList<ShardRouting> preferred = new ArrayList<>(activeShards.size() + allInitializingShards.size());, +        ArrayList<ShardRouting> notPreferred = new ArrayList<>(activeShards.size() + allInitializingShards.size());, +            if (nodeIds.contains(shardRouting.currentNodeId())) {, +                preferred.add(shardRouting);, +            } else {, +                notPreferred.add(shardRouting);, +        preferred.addAll(notPreferred);, +            preferred.addAll(allInitializingShards);, +        return new PlainShardIterator(shardId, preferred);, +++ b/core/src/main/java/org/elasticsearch/cluster/routing/OperationRouting.java, +import java.util.Arrays;, +import java.util.stream.Collectors;, +                case PREFER_NODES:, +                    final Set<String> nodesIds =, +                            Arrays.stream(, +                                    preference.substring(Preference.PREFER_NODES.type().length() + 1).split(","), +                            ).collect(Collectors.toSet());, +                    return indexShard.preferNodeActiveInitializingShardsIt(nodesIds);, +                    return indexShard.preferNodeActiveInitializingShardsIt(Collections.singleton(localNodeId));, +++ b/core/src/main/java/org/elasticsearch/cluster/routing/Preference.java, +     * Route to preferred nodes, if possible, +    PREFER_NODES("_prefer_nodes"),, +            case "_prefer_nodes":, +                return PREFER_NODES;, +, +++ b/core/src/main/java/org/elasticsearch/cluster/routing/IndexShardRoutingTable.java, +    public ShardIterator preferNodeActiveInitializingShardsIt(Set<String> nodeIds) {, +        ArrayList<ShardRouting> preferred = new ArrayList<>(activeShards.size() + allInitializingShards.size());, +        ArrayList<ShardRouting> notPreferred = new ArrayList<>(activeShards.size() + allInitializingShards.size());, +            if (nodeIds.contains(shardRouting.currentNodeId())) {, +                preferred.add(shardRouting);, +            } else {, +                notPreferred.add(shardRouting);, +        preferred.addAll(notPreferred);, +            preferred.addAll(allInitializingShards);, +        return new PlainShardIterator(shardId, preferred);, +++ b/core/src/main/java/org/elasticsearch/cluster/routing/OperationRouting.java, +import java.util.Arrays;, +import java.util.stream.Collectors;, +                case PREFER_NODES:, +                    final Set<String> nodesIds =, +                            Arrays.stream(, +                                    preference.substring(Preference.PREFER_NODES.type().length() + 1).split(","), +                            ).collect(Collectors.toSet());, +                    return indexShard.preferNodeActiveInitializingShardsIt(nodesIds);, +                    return indexShard.preferNodeActiveInitializingShardsIt(Collections.singleton(localNodeId));, +++ b/core/src/main/java/org/elasticsearch/cluster/routing/Preference.java, +     * Route to preferred nodes, if possible, +    PREFER_NODES("_prefer_nodes"),, +            case "_prefer_nodes":, +                return PREFER_NODES;, +, +++ b/core/src/test/java/org/elasticsearch/cluster/routing/OperationRoutingTests.java, +import org.apache.lucene.util.IOUtils;, +import org.elasticsearch.action.support.replication.ClusterStateCreationUtils;, +import org.elasticsearch.cluster.routing.allocation.decider.AwarenessAllocationDecider;, +import org.elasticsearch.cluster.service.ClusterService;, +import org.elasticsearch.common.settings.Settings;, +import org.elasticsearch.index.Index;, +import org.elasticsearch.test.ClusterServiceUtils;, +import org.elasticsearch.threadpool.TestThreadPool;, +import java.io.IOException;, +import java.util.ArrayList;, +import java.util.HashSet;, +import java.util.List;, +import static org.hamcrest.Matchers.containsInAnyOrder;]