[+++ b/core/src/test/java/org/elasticsearch/search/aggregations/pipeline/DateDerivativeIT.java, +import org.hamcrest.Matcher;, +    // some index names used during these tests, +    private static final String IDX_DST_START = "idx_dst_start";, +    private static final String IDX_DST_END = "idx_dst_end";, +    private static final String IDX_DST_KATHMANDU = "idx_dst_kathmandu";, +, +    private static IndexRequestBuilder indexDoc(String idx, DateTime date, int value) throws Exception {, +                jsonBuilder().startObject().field("date", date).field("value", value).endObject());, +        internalCluster().wipeIndices(IDX_DST_START, IDX_DST_END, IDX_DST_KATHMANDU);, +    /**, +     * Do a derivative on a date histogram with time zone CET at DST start, +     */, +    public void testSingleValuedFieldNormalised_timeZone_CET_DstStart() throws Exception {, +        createIndex(IDX_DST_START);, +        List<IndexRequestBuilder> builders = new ArrayList<>();, +, +        DateTimeZone timezone = DateTimeZone.forID("CET");, +        addNTimes(1, IDX_DST_START, new DateTime("2012-03-24T01:00:00", timezone), builders);, +        addNTimes(2, IDX_DST_START, new DateTime("2012-03-25T01:00:00", timezone), builders); // day with dst shift, only 23h long, +        addNTimes(3, IDX_DST_START, new DateTime("2012-03-26T01:00:00", timezone), builders);, +        addNTimes(4, IDX_DST_START, new DateTime("2012-03-27T01:00:00", timezone), builders);, +        indexRandom(true, builders);, +        ensureSearchable();, +, +        SearchResponse response = client(), +                .prepareSearch(IDX_DST_START), +                .addAggregation(dateHistogram("histo").field("date").dateHistogramInterval(DateHistogramInterval.DAY), +                        .timeZone(timezone).minDocCount(0), +                        .subAggregation(derivative("deriv", "_count").unit(DateHistogramInterval.HOUR))), +                .execute(), +                .actionGet();, +, +        assertSearchResponse(response);, +, +        InternalHistogram deriv = response.getAggregations().get("histo");, +        assertThat(deriv, notNullValue());, +        assertThat(deriv.getName(), equalTo("histo"));, +        List<? extends Bucket> buckets = deriv.getBuckets();, +        assertThat(buckets.size(), equalTo(4));, +, +        assertBucket(buckets.get(0), new DateTime("2012-03-24", timezone).toDateTime(DateTimeZone.UTC), 1L, nullValue(), null, null);, +        assertBucket(buckets.get(1), new DateTime("2012-03-25", timezone).toDateTime(DateTimeZone.UTC), 2L, notNullValue(), 1d, 1d / 24d);, +        // the following is normalized using a 23h bucket width, +        assertBucket(buckets.get(2), new DateTime("2012-03-26", timezone).toDateTime(DateTimeZone.UTC), 3L, notNullValue(), 1d, 1d / 23d);, +        assertBucket(buckets.get(3), new DateTime("2012-03-27", timezone).toDateTime(DateTimeZone.UTC), 4L, notNullValue(), 1d, 1d / 24d);, +    }, +, +    /**, +     * Do a derivative on a date histogram with time zone CET at DST end, +     */, +    public void testSingleValuedFieldNormalised_timeZone_CET_DstEnd() throws Exception {, +        createIndex(IDX_DST_END);, +        DateTimeZone timezone = DateTimeZone.forID("CET");, +        List<IndexRequestBuilder> builders = new ArrayList<>();, +, +        addNTimes(1, IDX_DST_END, new DateTime("2012-10-27T01:00:00", timezone), builders);, +        addNTimes(2, IDX_DST_END, new DateTime("2012-10-28T01:00:00", timezone), builders); // day with dst shift -1h, 25h long, +        addNTimes(3, IDX_DST_END, new DateTime("2012-10-29T01:00:00", timezone), builders);, +        addNTimes(4, IDX_DST_END, new DateTime("2012-10-30T01:00:00", timezone), builders);, +        indexRandom(true, builders);, +        ensureSearchable();, +, +        SearchResponse response = client(), +                .prepareSearch(IDX_DST_END), +                .addAggregation(dateHistogram("histo").field("date").dateHistogramInterval(DateHistogramInterval.DAY), +                        .timeZone(timezone).minDocCount(0), +                        .subAggregation(derivative("deriv", "_count").unit(DateHistogramInterval.HOUR))), +                .execute(), +                .actionGet();, +, +        assertSearchResponse(response);, +, +        InternalHistogram deriv = response.getAggregations().get("histo");, +        assertThat(deriv, notNullValue());, +        assertThat(deriv.getName(), equalTo("histo"));, +        List<? extends Bucket> buckets = deriv.getBuckets();, +        assertThat(buckets.size(), equalTo(4));, +, +        assertBucket(buckets.get(0), new DateTime("2012-10-27", timezone).toDateTime(DateTimeZone.UTC), 1L, nullValue(), null, null);, +        assertBucket(buckets.get(1), new DateTime("2012-10-28", timezone).toDateTime(DateTimeZone.UTC), 2L, notNullValue(), 1d, 1d / 24d);, +        // the following is normalized using a 25h bucket width, +        assertBucket(buckets.get(2), new DateTime("2012-10-29", timezone).toDateTime(DateTimeZone.UTC), 3L, notNullValue(), 1d, 1d / 25d);, +        assertBucket(buckets.get(3), new DateTime("2012-10-30", timezone).toDateTime(DateTimeZone.UTC), 4L, notNullValue(), 1d, 1d / 24d);, +    }, +, +    /**, +     * also check for time zone shifts that are not one hour, e.g., +     * "Asia/Kathmandu, 1 Jan 1986 - Time Zone Change (IST â†’ NPT), at 00:00:00 clocks were turned forward 00:15 minutes, +     */, +    public void testSingleValuedFieldNormalised_timeZone_AsiaKathmandu() throws Exception {, +        createIndex(IDX_DST_KATHMANDU);, +        DateTimeZone timezone = DateTimeZone.forID("Asia/Kathmandu");, +        List<IndexRequestBuilder> builders = new ArrayList<>();, +, +        addNTimes(1, IDX_DST_KATHMANDU, new DateTime("1985-12-31T22:30:00", timezone), builders);, +        // the shift happens during the next bucket, which includes the 45min that do not start on the full hour, +        addNTimes(2, IDX_DST_KATHMANDU, new DateTime("1985-12-31T23:30:00", timezone), builders);, +        addNTimes(3, IDX_DST_KATHMANDU, new DateTime("1986-01-01T01:30:00", timezone), builders);, +        addNTimes(4, IDX_DST_KATHMANDU, new DateTime("1986-01-01T02:30:00", timezone), builders);]