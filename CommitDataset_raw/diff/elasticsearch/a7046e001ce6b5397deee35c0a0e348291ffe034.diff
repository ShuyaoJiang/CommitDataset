[+++ b/client/rest/src/main/java/org/elasticsearch/client/ResponseException.java, +++ b/client/rest/src/main/java/org/elasticsearch/client/ResponseException.java, +++ b/client/rest/src/main/java/org/elasticsearch/client/RestClient.java, +    RestClient(CloseableHttpAsyncClient client, Header[] defaultHeaders, List<Node> nodes, String pathPrefix,, +        InternalRequest internalRequest = new InternalRequest(request);, +        return performRequest(nextNodes(), internalRequest, null);, +    }, +, +    private Response performRequest(final NodeTuple<Iterator<Node>> nodeTuple,, +                                    final InternalRequest request,, +                                    Exception previousException) throws IOException {, +        RequestContext context = request.createContextForNextAttempt(nodeTuple.nodes.next(), nodeTuple.authCache);, +        HttpResponse httpResponse;, +        try {, +            httpResponse = client.execute(context.requestProducer, context.asyncResponseConsumer, context.context, null).get();, +        } catch(Exception e) {, +            RequestLogger.logFailedRequest(logger, request.httpRequest, context.node, e);, +            onFailure(context.node);, +            Exception cause = extractAndWrapCause(e);, +            addSuppressedException(previousException, cause);, +            if (nodeTuple.nodes.hasNext()) {, +                return performRequest(nodeTuple, request, cause);, +            }, +            if (cause instanceof IOException) {, +                throw (IOException) cause;, +            }, +            if (cause instanceof RuntimeException) {, +                throw (RuntimeException) cause;, +            }, +            throw new IllegalStateException("unexpected exception type: must be either RuntimeException or IOException", cause);, +        }, +        ResponseOrResponseException responseOrResponseException = convertResponse(request, context.node, httpResponse);, +        if (responseOrResponseException.responseException == null) {, +            return responseOrResponseException.response;, +        }, +        addSuppressedException(previousException, responseOrResponseException.responseException);, +        if (nodeTuple.nodes.hasNext()) {, +            return performRequest(nodeTuple, request, responseOrResponseException.responseException);, +        }, +        throw responseOrResponseException.responseException;, +    }, +, +    private ResponseOrResponseException convertResponse(InternalRequest request, Node node, HttpResponse httpResponse) throws IOException {, +        RequestLogger.logResponse(logger, request.httpRequest, node.getHost(), httpResponse);, +        int statusCode = httpResponse.getStatusLine().getStatusCode();, +        Response response = new Response(request.httpRequest.getRequestLine(), node.getHost(), httpResponse);, +        if (isSuccessfulResponse(statusCode) || request.ignoreErrorCodes.contains(response.getStatusLine().getStatusCode())) {, +            onResponse(node);, +            if (request.warningsHandler.warningsShouldFailRequest(response.getWarnings())) {, +                throw new WarningFailureException(response);, +            }, +            return new ResponseOrResponseException(response);, +        }, +        ResponseException responseException = new ResponseException(response);, +        if (isRetryStatus(statusCode)) {, +            //mark host dead and retry against next one, +            onFailure(node);, +            return new ResponseOrResponseException(responseException);, +        }, +        //mark host alive and don't retry, as the error should be a request problem, +        onResponse(node);, +        throw responseException;, +            FailureTrackingResponseListener failureTrackingResponseListener = new FailureTrackingResponseListener(responseListener);, +            InternalRequest internalRequest = new InternalRequest(request);, +            performRequestAsync(nextNodes(), internalRequest, failureTrackingResponseListener);, +    private void performRequestAsync(final NodeTuple<Iterator<Node>> nodeTuple,, +                                     final InternalRequest request,, +        final RequestContext context = request.createContextForNextAttempt(nodeTuple.nodes.next(), nodeTuple.authCache);, +        client.execute(context.requestProducer, context.asyncResponseConsumer, context.context, new FutureCallback<HttpResponse>() {, +                    ResponseOrResponseException responseOrResponseException = convertResponse(request, context.node, httpResponse);, +                    if (responseOrResponseException.responseException == null) {, +                        listener.onSuccess(responseOrResponseException.response);, +                        if (nodeTuple.nodes.hasNext()) {, +                            listener.trackFailure(responseOrResponseException.responseException);, +                            performRequestAsync(nodeTuple, request, listener);, +                            listener.onDefinitiveFailure(responseOrResponseException.responseException);, +                    RequestLogger.logFailedRequest(logger, request.httpRequest, context.node, failure);, +                    onFailure(context.node);, +                    if (nodeTuple.nodes.hasNext()) {, +                        listener.trackFailure(failure);, +                        performRequestAsync(nodeTuple, request, listener);, +                    } else {, +                        listener.onDefinitiveFailure(failure);, +                    }, +    private NodeTuple<Iterator<Node>> nextNodes() throws IOException {, +    private static void addSuppressedException(Exception suppressedException, Exception currentException) {, +            addSuppressedException(this.exception, exception);, +            this.exception = exception;, +, +    private class InternalRequest {, +        private final Request request;, +        private final Map<String, String> params;, +        private final Set<Integer> ignoreErrorCodes;, +        private final HttpRequestBase httpRequest;, +        private final WarningsHandler warningsHandler;, +, +        InternalRequest(Request request) {, +            this.request = request;, +            this.params = new HashMap<>(request.getParameters());, +            //ignore is a special parameter supported by the clients, shouldn't be sent to es]