[+++ b/src/test/java/org/elasticsearch/search/basic/SearchWithRandomExceptionsTests.java, +import org.apache.lucene.index.AtomicReader;, +import org.apache.lucene.index.DirectoryReader;, +import org.elasticsearch.action.admin.cluster.state.ClusterStateResponse;, +import org.elasticsearch.cluster.metadata.IndexMetaData;, +import org.elasticsearch.cluster.metadata.MetaData;, +import org.elasticsearch.common.settings.Settings;, +import org.elasticsearch.common.xcontent.XContentBuilder;, +import org.elasticsearch.test.engine.MockRobinEngine;, +import org.elasticsearch.test.engine.ThrowingAtomicReaderWrapper;, +import org.elasticsearch.test.store.MockFSIndexStoreModule;, +import java.util.Map;, +import java.util.Random;, +    public void testRandomDirectoryIOExceptions() throws IOException, InterruptedException, ExecutionException {, +                // check match all, +                searchResponse = client().prepareSearch().setQuery(QueryBuilders.matchAllQuery()).get();, +            } catch (SearchPhaseExecutionException ex) {, +                if (!expectAllShardsFailed) {, +                    throw ex;, +                } else {, +                    logger.info("expected SearchPhaseException: [{}]", ex.getMessage());, +                }, +            }, +            , +        }, +    }, +, +    @Test, +    public void testRandomExceptions() throws IOException, InterruptedException, ExecutionException {, +        final int numShards = between(1, 5);, +        String mapping = XContentFactory.jsonBuilder()., +                startObject()., +                startObject("type")., +                startObject("properties")., +                startObject("test"), +                .field("type", "string"), +                .field("index", "not_analyzed"), +                .endObject()., +                        endObject()., +                        endObject(), +                .endObject().string();, +        final double lowLevelRate;, +        final double topLevelRate;, +        if (frequently()) {, +            if (randomBoolean()) {, +                if (randomBoolean()) {, +                    lowLevelRate =  1.0/between(2, 10);, +                    topLevelRate = 0.0d;, +                } else {, +                    topLevelRate =  1.0/between(2, 10);, +                    lowLevelRate = 0.0d;, +                }, +            } else {, +                lowLevelRate =  1.0/between(2, 10);, +                topLevelRate =  1.0/between(2, 10);, +            }, +        } else {, +            // rarely no exception, +            topLevelRate = 0d;, +            lowLevelRate = 0d;, +        }, +, +        Builder settings = settingsBuilder(), +                .put("index.number_of_shards", numShards), +                .put("index.number_of_replicas", randomIntBetween(0, 1)), +                .put(MockRobinEngine.READER_WRAPPER_TYPE, RandomExceptionDirectoryReaderWrapper.class.getName()), +                .put(EXCEPTION_TOP_LEVEL_RATIO_KEY, topLevelRate), +                .put(EXCEPTION_LOW_LEVEL_RATIO_KEY, lowLevelRate), +                .put(MockRobinEngine.WRAP_READER_RATIO, 1.0d);, +        logger.info("creating index: [test] using settings: [{}]", settings.build().getAsMap());, +        client().admin().indices().prepareCreate("test"), +                .setSettings(settings), +                .addMapping("type", mapping).execute().actionGet();, +        ensureSearchable();, +        final int numDocs = between(10, 100);, +        long numCreated = 0;, +        boolean[] added = new boolean[numDocs];, +        for (int i = 0; i < numDocs ; i++) {, +            try {, +                IndexResponse indexResponse = client().prepareIndex("test", "type", "" + i).setTimeout(TimeValue.timeValueSeconds(1)).setSource("test", English.intToEnglish(i)).get();, +                if (indexResponse.isCreated()) {, +                    numCreated++;, +                    added[i] = true;, +                }, +            } catch (ElasticSearchException ex) {, +            }, +        }, +        logger.info("Start Refresh");, +        RefreshResponse refreshResponse = client().admin().indices().prepareRefresh("test").execute().get(); // don't assert on failures here, +        final boolean refreshFailed = refreshResponse.getShardFailures().length != 0 || refreshResponse.getFailedShards() != 0;, +        logger.info("Refresh failed [{}] numShardsFailed: [{}], shardFailuresLength: [{}], successfulShards: [{}], totalShards: [{}] ", refreshFailed, refreshResponse.getFailedShards(), refreshResponse.getShardFailures().length, refreshResponse.getSuccessfulShards(), refreshResponse.getTotalShards());, +, +        final int numSearches = atLeast(100);, +        // we don't check anything here really just making sure we don't leave any open files or a broken index behind., +        for (int i = 0; i < numSearches; i++) {, +            try {, +                int docToQuery = between(0, numDocs-1);, +                long expectedResults = added[docToQuery] ? 1 : 0;, +                logger.info("Searching for [test:{}]", English.intToEnglish(docToQuery));, +                SearchResponse searchResponse = client().prepareSearch().setQuery(QueryBuilders.matchQuery("test", English.intToEnglish(docToQuery))).get();]