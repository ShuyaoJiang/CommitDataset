[+++ b/libs/x-content/src/main/java/org/elasticsearch/common/xcontent/XContentSubParser.java, +/*, + * Licensed to Elasticsearch under one or more contributor, + * license agreements. See the NOTICE file distributed with, + * this work for additional information regarding copyright, + * ownership. Elasticsearch licenses this file to you under, + * the Apache License, Version 2.0 (the "License"); you may, + * not use this file except in compliance with the License., + * You may obtain a copy of the License at, + *, + *    http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing,, + * software distributed under the License is distributed on an, + * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY, + * KIND, either express or implied.  See the License for the, + * specific language governing permissions and limitations, + * under the License., + */, +, +package org.elasticsearch.common.xcontent;, +, +import java.io.IOException;, +import java.nio.CharBuffer;, +import java.util.List;, +import java.util.Map;, +, +/**, + * Wrapper for a XContentParser that makes a single object to look like a complete document., + *, + * The wrapper prevents the parsing logic to consume tokens outside of the wrapped object as well, + * as skipping to the end of the object in case of a parsing error. The wrapper is intended to be, + * used for parsing objects that should be ignored if they are malformed., + */, +public class XContentSubParser implements XContentParser {, +, +    private final XContentParser parser;, +    private int level;, +    private boolean closed;, +, +    public XContentSubParser(XContentParser parser) {, +        this.parser = parser;, +        if (parser.currentToken() != Token.START_OBJECT) {, +            throw new IllegalStateException("The sub parser has to be created on the start of an object");, +        }, +        level = 1;, +    }, +, +    @Override, +    public XContentType contentType() {, +        return parser.contentType();, +    }, +, +    @Override, +    public Token nextToken() throws IOException {, +        if (level > 0) {, +            Token token = parser.nextToken();, +            if (token == Token.START_OBJECT || token == Token.START_ARRAY) {, +                level++;, +            } else if (token == Token.END_OBJECT || token == Token.END_ARRAY) {, +                level--;, +            }, +            return token;, +        } else {, +            return null; // we have reached the end of the wrapped object, +        }, +    }, +, +    @Override, +    public void skipChildren() throws IOException {, +        Token token = parser.currentToken();, +        if (token != Token.START_OBJECT && token != Token.START_ARRAY) {, +            // skip if not starting on an object or an array, +            return;, +        }, +        int backToLevel = level - 1;, +        while (nextToken() != null) {, +            if (level <= backToLevel) {, +                return;, +            }, +        }, +    }, +, +    @Override, +    public Token currentToken() {, +        return parser.currentToken();, +    }, +, +    @Override, +    public String currentName() throws IOException {, +        return parser.currentName();, +    }, +, +    @Override, +    public Map<String, Object> map() throws IOException {, +        return parser.map();, +    }, +, +    @Override, +    public Map<String, Object> mapOrdered() throws IOException {]