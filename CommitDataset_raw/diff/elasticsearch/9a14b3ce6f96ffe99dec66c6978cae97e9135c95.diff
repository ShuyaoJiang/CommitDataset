[+++ b/src/test/java/org/elasticsearch/bwcompat/BasicBackwardsCompatibilityTest.java, +import org.apache.lucene.util.LuceneTestCase;, +    @LuceneTestCase.AwaitsFix(bugUrl = "working on this"), +    //made this tests a usual integration test to see if it fails in non bw comp mode, +    @LuceneTestCase.AwaitsFix(bugUrl = "working on this"), +    //made this tests a usual integration test to see if it fails in non bw comp mode, +++ b/src/test/java/org/elasticsearch/bwcompat/BasicBackwardsCompatibilityTest.java, +import org.apache.lucene.util.LuceneTestCase;, +    @LuceneTestCase.AwaitsFix(bugUrl = "working on this"), +    //made this tests a usual integration test to see if it fails in non bw comp mode, +    @LuceneTestCase.AwaitsFix(bugUrl = "working on this"), +    //made this tests a usual integration test to see if it fails in non bw comp mode, +++ b/src/test/java/org/elasticsearch/deleteByQuery/DeleteByQueryTests.java, +import org.elasticsearch.action.deletebyquery.IndexDeleteByQueryResponse;, +import org.elasticsearch.action.index.IndexRequestBuilder;, +import java.util.concurrent.ExecutionException;, +, +import static org.elasticsearch.test.hamcrest.ElasticsearchAssertions.assertNoFailures;, +    @Test, +    public void testDeleteByTermQuery() throws ExecutionException, InterruptedException {, +        createIndex("test");, +        ensureGreen();, +, +        int numDocs = iterations(10, 50);, +        IndexRequestBuilder[] indexRequestBuilders = new IndexRequestBuilder[numDocs + 1];, +        for (int i = 0; i < numDocs; i++) {, +            indexRequestBuilders[i] = client().prepareIndex("test", "test", Integer.toString(i)).setSource("field", "value");, +        }, +        indexRequestBuilders[numDocs] = client().prepareIndex("test", "test", Integer.toString(numDocs)).setSource("field", "other_value");, +        indexRandom(true, indexRequestBuilders);, +, +        SearchResponse searchResponse = client().prepareSearch("test").get();, +        assertNoFailures(searchResponse);, +        assertThat(searchResponse.getHits().totalHits(), equalTo((long)numDocs + 1));, +, +        DeleteByQueryResponse deleteByQueryResponse = client().prepareDeleteByQuery("test").setQuery(QueryBuilders.termQuery("field", "value")).get();, +        assertThat(deleteByQueryResponse.getIndices().size(), equalTo(1));, +        for (IndexDeleteByQueryResponse indexDeleteByQueryResponse : deleteByQueryResponse) {, +            assertThat(indexDeleteByQueryResponse.getIndex(), equalTo("test"));, +            assertThat(indexDeleteByQueryResponse.getFailures().length, equalTo(0));, +        }, +, +        refresh();, +        searchResponse = client().prepareSearch("test").get();, +        assertNoFailures(searchResponse);, +        assertThat(searchResponse.getHits().totalHits(), equalTo(1l));, +    }, +, +++ b/src/test/java/org/elasticsearch/bwcompat/BasicBackwardsCompatibilityTest.java, +import org.apache.lucene.util.LuceneTestCase;, +    @LuceneTestCase.AwaitsFix(bugUrl = "working on this"), +    //made this tests a usual integration test to see if it fails in non bw comp mode, +    @LuceneTestCase.AwaitsFix(bugUrl = "working on this"), +    //made this tests a usual integration test to see if it fails in non bw comp mode, +++ b/src/test/java/org/elasticsearch/deleteByQuery/DeleteByQueryTests.java, +import org.elasticsearch.action.deletebyquery.IndexDeleteByQueryResponse;, +import org.elasticsearch.action.index.IndexRequestBuilder;, +import java.util.concurrent.ExecutionException;, +, +import static org.elasticsearch.test.hamcrest.ElasticsearchAssertions.assertNoFailures;, +    @Test, +    public void testDeleteByTermQuery() throws ExecutionException, InterruptedException {, +        createIndex("test");, +        ensureGreen();, +, +        int numDocs = iterations(10, 50);, +        IndexRequestBuilder[] indexRequestBuilders = new IndexRequestBuilder[numDocs + 1];, +        for (int i = 0; i < numDocs; i++) {, +            indexRequestBuilders[i] = client().prepareIndex("test", "test", Integer.toString(i)).setSource("field", "value");, +        }, +        indexRequestBuilders[numDocs] = client().prepareIndex("test", "test", Integer.toString(numDocs)).setSource("field", "other_value");, +        indexRandom(true, indexRequestBuilders);, +, +        SearchResponse searchResponse = client().prepareSearch("test").get();, +        assertNoFailures(searchResponse);, +        assertThat(searchResponse.getHits().totalHits(), equalTo((long)numDocs + 1));, +, +        DeleteByQueryResponse deleteByQueryResponse = client().prepareDeleteByQuery("test").setQuery(QueryBuilders.termQuery("field", "value")).get();, +        assertThat(deleteByQueryResponse.getIndices().size(), equalTo(1));, +        for (IndexDeleteByQueryResponse indexDeleteByQueryResponse : deleteByQueryResponse) {, +            assertThat(indexDeleteByQueryResponse.getIndex(), equalTo("test"));, +            assertThat(indexDeleteByQueryResponse.getFailures().length, equalTo(0));, +        }, +, +        refresh();, +        searchResponse = client().prepareSearch("test").get();, +        assertNoFailures(searchResponse);, +        assertThat(searchResponse.getHits().totalHits(), equalTo(1l));, +    }, +, +++ b/src/test/java/org/elasticsearch/document/DocumentActionsTests.java, +import org.elasticsearch.action.index.IndexRequestBuilder;, +import org.elasticsearch.action.search.SearchResponse;, +import java.util.concurrent.ExecutionException;, +import static org.elasticsearch.test.hamcrest.ElasticsearchAssertions.assertAcked;, +    @Test, +    public void testDeleteRoutingRequired() throws ExecutionException, InterruptedException, IOException {, +        assertAcked(prepareCreate("test").addMapping("test",, +                XContentFactory.jsonBuilder().startObject().startObject("test").startObject("_routing").field("required", true).endObject().endObject().endObject()));, +        ensureGreen();]