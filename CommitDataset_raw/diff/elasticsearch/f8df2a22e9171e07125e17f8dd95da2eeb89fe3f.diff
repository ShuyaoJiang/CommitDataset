[+++ b/core/src/main/java/org/elasticsearch/client/transport/TransportClientNodesService.java, +                        void onDone() {, +                            try {, +                            } finally {, +                                latch.countDown();, +                            }, +                            onDone();, +                                        onDone();, +                                        } finally {, +                                            onDone();, +++ b/core/src/main/java/org/elasticsearch/client/transport/TransportClientNodesService.java, +                        void onDone() {, +                            try {, +                            } finally {, +                                latch.countDown();, +                            }, +                            onDone();, +                                        onDone();, +                                        } finally {, +                                            onDone();, +++ b/core/src/test/java/org/elasticsearch/client/transport/TransportClientNodesServiceTests.java, +import org.elasticsearch.action.admin.cluster.state.ClusterStateAction;, +import org.elasticsearch.action.admin.cluster.state.ClusterStateRequest;, +import org.elasticsearch.action.admin.cluster.state.ClusterStateResponse;, +import org.elasticsearch.common.unit.TimeValue;, +import org.elasticsearch.node.Node;, +import org.elasticsearch.test.transport.MockTransportService;, +import org.elasticsearch.transport.ConnectionProfile;, +import org.elasticsearch.transport.TransportChannel;, +import org.elasticsearch.transport.TransportRequestHandler;, +import java.io.Closeable;, +import java.io.IOException;, +import java.util.ArrayList;, +import java.util.Collections;, +import java.util.HashMap;, +import java.util.List;, +import java.util.Map;, +import java.util.concurrent.CopyOnWriteArrayList;, +import java.util.concurrent.CountDownLatch;, +import java.util.concurrent.TimeUnit;, +import java.util.concurrent.atomic.AtomicBoolean;, +import java.util.concurrent.atomic.AtomicInteger;, +import java.util.concurrent.atomic.AtomicReference;, +, +import static org.elasticsearch.test.transport.MockTransportService.createNewService;, +    public void testSniffNodesSamplerClosesConnections() throws Exception {, +        final TestThreadPool threadPool = new TestThreadPool("testSniffNodesSamplerClosesConnections");, +, +        Settings remoteSettings = Settings.builder().put(Node.NODE_NAME_SETTING.getKey(), "remote").build();, +        try (MockTransportService remoteService = createNewService(remoteSettings, Version.CURRENT, threadPool, null)) {, +            final MockHandler handler = new MockHandler(remoteService);, +            remoteService.registerRequestHandler(ClusterStateAction.NAME, ClusterStateRequest::new, ThreadPool.Names.SAME, handler);, +            remoteService.start();, +            remoteService.acceptIncomingRequests();, +, +            Settings clientSettings = Settings.builder(), +                    .put(TransportClient.CLIENT_TRANSPORT_SNIFF.getKey(), true), +                    .put(TransportClient.CLIENT_TRANSPORT_PING_TIMEOUT.getKey(), TimeValue.timeValueSeconds(1)), +                    .put(TransportClient.CLIENT_TRANSPORT_NODES_SAMPLER_INTERVAL.getKey(), TimeValue.timeValueSeconds(30)), +                    .build();, +, +            try (MockTransportService clientService = createNewService(clientSettings, Version.CURRENT, threadPool, null)) {, +                final List<MockConnection> establishedConnections = new CopyOnWriteArrayList<>();, +                final List<MockConnection> reusedConnections = new CopyOnWriteArrayList<>();, +, +                clientService.addDelegate(remoteService,  new MockTransportService.DelegateTransport(clientService.original()) {, +                    @Override, +                    public Connection openConnection(DiscoveryNode node, ConnectionProfile profile) throws IOException {, +                        MockConnection connection = new MockConnection(super.openConnection(node, profile));, +                        establishedConnections.add(connection);, +                        return connection;, +                    }, +, +                    @Override, +                    public Connection getConnection(DiscoveryNode node) {, +                        MockConnection connection = new MockConnection(super.getConnection(node));, +                        reusedConnections.add(connection);, +                        return connection;, +                    }, +                });, +, +                clientService.start();, +                clientService.acceptIncomingRequests();, +, +                try (TransportClientNodesService transportClientNodesService =, +                        new TransportClientNodesService(clientSettings, clientService, threadPool, (a, b) -> {})) {, +                    assertEquals(0, transportClientNodesService.connectedNodes().size());, +                    assertEquals(0, establishedConnections.size());, +                    assertEquals(0, reusedConnections.size());, +, +                    transportClientNodesService.addTransportAddresses(remoteService.getLocalDiscoNode().getAddress());, +                    assertEquals(1, transportClientNodesService.connectedNodes().size());, +                    assertClosedConnections(establishedConnections, 1);, +, +                    transportClientNodesService.doSample();, +                    assertClosedConnections(establishedConnections, 2);, +                    assertOpenConnections(reusedConnections, 1);, +, +                    handler.blockRequest();, +                    Thread thread = new Thread(transportClientNodesService::doSample);]