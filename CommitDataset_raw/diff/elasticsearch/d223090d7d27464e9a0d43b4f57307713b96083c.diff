[+++ b/core/src/main/java/org/elasticsearch/search/SearchModule.java, +import org.elasticsearch.search.aggregations.metrics.tophits.TopHitsAggregatorBuilder;, +        registerAggregation(TopHitsAggregatorBuilder::new, TopHitsAggregatorBuilder::parse,, +                TopHitsAggregatorBuilder.AGGREGATION_NAME_FIELD);, +++ b/core/src/main/java/org/elasticsearch/search/SearchModule.java, +import org.elasticsearch.search.aggregations.metrics.tophits.TopHitsAggregatorBuilder;, +        registerAggregation(TopHitsAggregatorBuilder::new, TopHitsAggregatorBuilder::parse,, +                TopHitsAggregatorBuilder.AGGREGATION_NAME_FIELD);, +++ b/core/src/main/java/org/elasticsearch/search/aggregations/metrics/tophits/TopHitsAggregatorBuilder.java, +import org.elasticsearch.common.ParseField;, +import org.elasticsearch.common.ParsingException;, +import org.elasticsearch.common.xcontent.XContentParser;, +import org.elasticsearch.index.query.QueryParseContext;, +    public static final String NAME = InternalTopHits.TYPE.name();, +    public static final ParseField AGGREGATION_NAME_FIELD = new ParseField(NAME);, +     * Read from a stream., +     */, +    public TopHitsAggregatorBuilder(StreamInput in) throws IOException {, +        super(in, InternalTopHits.TYPE);, +        explain = in.readBoolean();, +        fetchSourceContext = in.readOptionalStreamable(FetchSourceContext::new);, +        if (in.readBoolean()) {, +            int size = in.readVInt();, +            fieldDataFields = new ArrayList<>(size);, +            for (int i = 0; i < size; i++) {, +                fieldDataFields.add(in.readString());, +            }, +        }, +        if (in.readBoolean()) {, +            int size = in.readVInt();, +            fieldNames = new ArrayList<>(size);, +            for (int i = 0; i < size; i++) {, +                fieldNames.add(in.readString());, +            }, +        }, +        from = in.readVInt();, +        highlightBuilder = in.readOptionalWriteable(HighlightBuilder::new);, +        if (in.readBoolean()) {, +            int size = in.readVInt();, +            scriptFields = new HashSet<>(size);, +            for (int i = 0; i < size; i++) {, +                scriptFields.add(new ScriptField(in));, +            }, +        }, +        size = in.readVInt();, +        if (in.readBoolean()) {, +            int size = in.readVInt();, +            sorts = new ArrayList<>();, +            for (int i = 0; i < size; i++) {, +                sorts.add(in.readSortBuilder());, +            }, +        }, +        trackScores = in.readBoolean();, +        version = in.readBoolean();, +    }, +, +    @Override, +    protected void doWriteTo(StreamOutput out) throws IOException {, +        out.writeBoolean(explain);, +        out.writeOptionalStreamable(fetchSourceContext);, +        boolean hasFieldDataFields = fieldDataFields != null;, +        out.writeBoolean(hasFieldDataFields);, +        if (hasFieldDataFields) {, +            out.writeVInt(fieldDataFields.size());, +            for (String fieldName : fieldDataFields) {, +                out.writeString(fieldName);, +            }, +        }, +        boolean hasFieldNames = fieldNames != null;, +        out.writeBoolean(hasFieldNames);, +        if (hasFieldNames) {, +            out.writeVInt(fieldNames.size());, +            for (String fieldName : fieldNames) {, +                out.writeString(fieldName);, +            }, +        }, +        out.writeVInt(from);, +        out.writeOptionalWriteable(highlightBuilder);, +        boolean hasScriptFields = scriptFields != null;, +        out.writeBoolean(hasScriptFields);, +        if (hasScriptFields) {, +            out.writeVInt(scriptFields.size());, +            for (ScriptField scriptField : scriptFields) {, +                scriptField.writeTo(out);, +            }, +        }, +        out.writeVInt(size);, +        boolean hasSorts = sorts != null;, +        out.writeBoolean(hasSorts);, +        if (hasSorts) {, +            out.writeVInt(sorts.size());, +            for (SortBuilder<?> sort : sorts) {, +                out.writeSortBuilder(sort);, +            }, +        }, +        out.writeBoolean(trackScores);, +        out.writeBoolean(version);, +    }, +, +    @Override]