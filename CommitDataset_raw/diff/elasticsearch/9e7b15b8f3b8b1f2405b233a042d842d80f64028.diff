[+++ b/src/main/java/org/elasticsearch/gateway/local/state/meta/LocalGatewayMetaState.java, +import org.elasticsearch.ElasticsearchException;, +import org.elasticsearch.bootstrap.Elasticsearch;, +                    try {, +                    } catch (IOException ex) {, +                        throw new ElasticsearchException("failed to load index state", ex);, +                    }, +                    IndexMetaData indexMetaData;, +                    try {, +                        indexMetaData = loadIndexState(indexName);, +                    } catch (IOException ex) {, +                        throw new ElasticsearchException("failed to load index state", ex);, +                    }, +            writer.write(indexMetaData, INDEX_STATE_FILE_PREFIX, indexMetaData.version(), nodeEnv.indexPaths(new Index(indexMetaData.index())));, +            writer.write(metaData, GLOBAL_STATE_FILE_PREFIX, metaData.version(), nodeEnv.nodeDataPaths());, +    private IndexMetaData loadIndexState(String index) throws IOException {, +        return MetaDataStateFormat.loadLatestState(logger, indexStateFormat(format, formatParams, true), INDEX_STATE_FILE_PATTERN, "[" + index + "]", nodeEnv.indexPaths(new Index(index)));, +    private MetaData loadGlobalState() throws IOException {, +        return MetaDataStateFormat.loadLatestState(logger, globalStateFormat(format, gatewayModeFormatParams, true), GLOBAL_STATE_FILE_PATTERN, GLOBAL_STATE_LOG_TYPE, nodeEnv.nodeDataPaths());, +, +++ b/src/main/java/org/elasticsearch/gateway/local/state/meta/LocalGatewayMetaState.java, +import org.elasticsearch.ElasticsearchException;, +import org.elasticsearch.bootstrap.Elasticsearch;, +                    try {, +                    } catch (IOException ex) {, +                        throw new ElasticsearchException("failed to load index state", ex);, +                    }, +                    IndexMetaData indexMetaData;, +                    try {, +                        indexMetaData = loadIndexState(indexName);, +                    } catch (IOException ex) {, +                        throw new ElasticsearchException("failed to load index state", ex);, +                    }, +            writer.write(indexMetaData, INDEX_STATE_FILE_PREFIX, indexMetaData.version(), nodeEnv.indexPaths(new Index(indexMetaData.index())));, +            writer.write(metaData, GLOBAL_STATE_FILE_PREFIX, metaData.version(), nodeEnv.nodeDataPaths());, +    private IndexMetaData loadIndexState(String index) throws IOException {, +        return MetaDataStateFormat.loadLatestState(logger, indexStateFormat(format, formatParams, true), INDEX_STATE_FILE_PATTERN, "[" + index + "]", nodeEnv.indexPaths(new Index(index)));, +    private MetaData loadGlobalState() throws IOException {, +        return MetaDataStateFormat.loadLatestState(logger, globalStateFormat(format, gatewayModeFormatParams, true), GLOBAL_STATE_FILE_PATTERN, GLOBAL_STATE_LOG_TYPE, nodeEnv.nodeDataPaths());, +, +++ b/src/main/java/org/elasticsearch/gateway/local/state/meta/MetaDataStateFormat.java, +import java.io.*;, +import java.nio.file.*;, +    public final void write(final T state, final String prefix, final long version, final Path... locations) throws IOException {, +        Path stateLocation = locations[0].resolve(STATE_DIR_NAME);, +                stateLocation = locations[i].resolve(STATE_DIR_NAME);, +    public final T read(Path file, long expectedVersion) throws IOException {, +        try (Directory dir = newDirectory(file.getParent())) {, +            try (final IndexInput indexInput = dir.openInput(file.getFileName().toString(), IOContext.DEFAULT)) {, +    protected Directory newDirectory(Path dir) throws IOException {, +        return new SimpleFSDirectory(dir);, +    private void cleanupOldFiles(final String prefix, final String currentStateFile, Path[] locations) throws IOException {, +        final DirectoryStream.Filter<Path> filter = new DirectoryStream.Filter<Path>() {, +            @Override, +            public boolean accept(Path entry) throws IOException {, +                final String entryFileName = entry.getFileName().toString();, +                return Files.isRegularFile(entry), +                        && entryFileName.startsWith(prefix) // only state files, +                        && currentStateFile.equals(entryFileName) == false; // keep the current state file around, +            }, +        };, +        for (Path dataLocation : locations) {, +            try (DirectoryStream<Path> stream = Files.newDirectoryStream(dataLocation.resolve(STATE_DIR_NAME), filter)) {, +                for (Path stateFile : stream) {, +                    Files.deleteIfExists(stateFile);, +    public static <T> T loadLatestState(ESLogger logger, MetaDataStateFormat<T> format, Pattern pattern, String stateType, Path... dataLocations) throws IOException {, +        List<PathAndVersion> files = new ArrayList<>();, +            for (Path dataLocation : dataLocations) {, +                final Path stateDir = dataLocation.resolve(STATE_DIR_NAME);, +                if (!Files.exists(stateDir) || !Files.isDirectory(stateDir)) {, +                try (DirectoryStream<Path> paths = Files.newDirectoryStream(stateDir)) { // we don't pass a glob since we need the group part for parsing, +                    for (Path stateFile : paths) {, +                        final Matcher matcher = pattern.matcher(stateFile.getFileName().toString());, +                            files.add(new PathAndVersion(stateFile, version, legacy));, +                        }, +        for (PathAndVersion pathAndVersion : Collections2.filter(files, new VersionAndLegacyPredicate(maxVersion, maxVersionIsLegacy))) {, +                final Path stateFile = pathAndVersion.file;, +                final long version = pathAndVersion.version;, +                if (pathAndVersion.legacy) { // read the legacy format -- plain XContent, +                    try (InputStream stream = Files.newInputStream(stateFile)) {, +                            logger.debug("{}: no data for [{}], ignoring...", stateType, stateFile.toAbsolutePath());, +                            logger.debug("{}: no data for [{}], ignoring...", stateType, stateFile.toAbsolutePath());, +                logger.debug("{}: failed to read [{}], ignoring...", e, pathAndVersion.file.toAbsolutePath(), stateType);, +     * Filters out all {@link org.elasticsearch.gateway.local.state.meta.MetaDataStateFormat.PathAndVersion} instances with a different version than, +    private static final class VersionAndLegacyPredicate implements Predicate<PathAndVersion> {, +        public boolean apply(PathAndVersion input) {, +    private static class PathAndVersion {, +        final Path file;, +        private PathAndVersion(Path file, long version, boolean legacy) {, +++ b/src/main/java/org/elasticsearch/gateway/local/state/meta/LocalGatewayMetaState.java, +import org.elasticsearch.ElasticsearchException;, +import org.elasticsearch.bootstrap.Elasticsearch;, +                    try {, +                    } catch (IOException ex) {, +                        throw new ElasticsearchException("failed to load index state", ex);, +                    }, +                    IndexMetaData indexMetaData;, +                    try {, +                        indexMetaData = loadIndexState(indexName);, +                    } catch (IOException ex) {]