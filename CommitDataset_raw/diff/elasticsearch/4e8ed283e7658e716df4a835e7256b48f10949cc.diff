[+++ b/src/main/java/org/elasticsearch/watcher/WatcherLifeCycleService.java, +    private final WatcherService watcherService;, +    public WatcherLifeCycleService(Settings settings, ClusterService clusterService, IndicesService indicesService, ThreadPool threadPool, WatcherService watcherService) {, +        this.watcherService = watcherService;, +        watcherService.start(state);, +        watcherService.stop();, +            if (!watcherService.validate(state)) {, +            if (watcherService.state() == WatcherService.State.STOPPED && !manuallyStopped) {, +++ b/src/main/java/org/elasticsearch/watcher/WatcherLifeCycleService.java, +    private final WatcherService watcherService;, +    public WatcherLifeCycleService(Settings settings, ClusterService clusterService, IndicesService indicesService, ThreadPool threadPool, WatcherService watcherService) {, +        this.watcherService = watcherService;, +        watcherService.start(state);, +        watcherService.stop();, +            if (!watcherService.validate(state)) {, +            if (watcherService.state() == WatcherService.State.STOPPED && !manuallyStopped) {, +++ b/src/main/java/org/elasticsearch/watcher/WatcherService.java, +/*, + * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one, + * or more contributor license agreements. Licensed under the Elastic License;, + * you may not use this file except in compliance with the Elastic License., + */, +package org.elasticsearch.watcher;, +, +, +import org.elasticsearch.ElasticsearchIllegalStateException;, +import org.elasticsearch.action.index.IndexResponse;, +import org.elasticsearch.cluster.ClusterState;, +import org.elasticsearch.common.bytes.BytesReference;, +import org.elasticsearch.common.component.AbstractComponent;, +import org.elasticsearch.common.inject.Inject;, +import org.elasticsearch.common.settings.Settings;, +import org.elasticsearch.watcher.execution.ExecutionService;, +import org.elasticsearch.watcher.trigger.TriggerService;, +import org.elasticsearch.watcher.watch.Watch;, +import org.elasticsearch.watcher.watch.WatchLockService;, +import org.elasticsearch.watcher.watch.WatchStore;, +, +import java.io.IOException;, +import java.util.concurrent.ExecutionException;, +import java.util.concurrent.atomic.AtomicReference;, +, +public class WatcherService extends AbstractComponent {, +, +    private final TriggerService triggerService;, +    private final WatchStore watchStore;, +    private final WatchLockService watchLockService;, +    private final ExecutionService executionService;, +    private final AtomicReference<State> state = new AtomicReference<>(State.STOPPED);, +, +    @Inject, +    public WatcherService(Settings settings, TriggerService triggerService, WatchStore watchStore, ExecutionService executionService,, +                          WatchLockService watchLockService) {, +        super(settings);, +        this.triggerService = triggerService;, +        this.watchStore = watchStore;, +        this.watchLockService = watchLockService;, +        this.executionService = executionService;, +    }, +, +    public void start(ClusterState clusterState) {, +        if (state.compareAndSet(State.STOPPED, State.STARTING)) {, +            logger.info("starting watch service...");, +            watchLockService.start();, +, +            // Try to load watch store before the execution service, b/c action depends on watch store, +            watchStore.start(clusterState);, +            executionService.start(clusterState);, +            triggerService.start(watchStore.watches().values());, +            state.set(State.STARTED);, +            logger.info("watch service has started");, +        }, +    }, +, +    public boolean validate(ClusterState state) {, +        return watchStore.validate(state) && executionService.validate(state);, +    }, +, +    public void stop() {, +        if (state.compareAndSet(State.STARTED, State.STOPPING)) {, +            logger.info("stopping watch service...");, +            triggerService.stop();, +            executionService.stop();, +            watchLockService.stop();, +            watchStore.stop();, +            state.set(State.STOPPED);, +            logger.info("watch service has stopped");, +        }, +    }, +, +    public WatchStore.WatchDelete deleteWatch(String name) throws InterruptedException, ExecutionException {, +        ensureStarted();, +        WatchLockService.Lock lock = watchLockService.acquire(name);, +        try {, +            WatchStore.WatchDelete delete = watchStore.delete(name);, +            if (delete.deleteResponse().isFound()) {, +                triggerService.remove(name);, +            }, +            return delete;, +        } finally {]