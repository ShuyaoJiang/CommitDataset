[+++ b/core/src/main/java/org/elasticsearch/common/cache/Cache.java, +     * Use of different {@link CacheLoader} implementations on the same key concurrently may result in only the first, +     * loader function being called and the second will be returned the result provided by the first including any exceptions, +     * thrown during the execution of the first., +     *, +     * @return the current (existing or computed) non-null value associated with the specified key, +     * @throws ExecutionException thrown if loader throws an exception or returns a null value, +                // check to ensure the future hasn't been completed with an exception, +                if (future.isCompletedExceptionally()) {, +                    future.get(); // call get to force the exception to be thrown for other concurrent callers, +                    throw new IllegalStateException("the future was completed exceptionally but no exception was thrown");, +                }, +++ b/core/src/main/java/org/elasticsearch/common/cache/Cache.java, +     * Use of different {@link CacheLoader} implementations on the same key concurrently may result in only the first, +     * loader function being called and the second will be returned the result provided by the first including any exceptions, +     * thrown during the execution of the first., +     *, +     * @return the current (existing or computed) non-null value associated with the specified key, +     * @throws ExecutionException thrown if loader throws an exception or returns a null value, +                // check to ensure the future hasn't been completed with an exception, +                if (future.isCompletedExceptionally()) {, +                    future.get(); // call get to force the exception to be thrown for other concurrent callers, +                    throw new IllegalStateException("the future was completed exceptionally but no exception was thrown");, +                }, +++ b/core/src/test/java/org/elasticsearch/common/cache/CacheTests.java, +    public void testExceptionThrownDuringConcurrentComputeIfAbsent() throws BrokenBarrierException, InterruptedException {, +        int numberOfThreads = randomIntBetween(2, 32);, +        final Cache<String, String> cache = CacheBuilder.<String, String>builder().build();, +, +        CyclicBarrier barrier = new CyclicBarrier(1 + numberOfThreads);, +, +        final String key = randomAsciiOfLengthBetween(2, 32);, +        for (int i = 0; i < numberOfThreads; i++) {, +            Thread thread = new Thread(() -> {, +                try {, +                    barrier.await();, +                    for (int j = 0; j < numberOfEntries; j++) {, +                        try {, +                            String value = cache.computeIfAbsent(key, k -> {, +                                throw new RuntimeException("failed to load");, +                            });, +                            fail("expected exception but got: " + value);, +                        } catch (ExecutionException e) {, +                            assertNotNull(e.getCause());, +                            assertThat(e.getCause(), instanceOf(RuntimeException.class));, +                            assertEquals(e.getCause().getMessage(), "failed to load");, +                        }, +                    }, +                    barrier.await();, +                } catch (BrokenBarrierException | InterruptedException e) {, +                    throw new AssertionError(e);, +                }, +            });, +            thread.start();, +        }, +, +        // wait for all threads to be ready, +        barrier.await();, +        // wait for all threads to finish, +        barrier.await();, +    }, +]