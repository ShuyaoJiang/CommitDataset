[+++ b/plugin/watcher/src/main/java/org/elasticsearch/xpack/watcher/WatcherLifeCycleService.java, +import org.elasticsearch.common.util.concurrent.EsExecutors;, +import java.util.concurrent.TimeUnit;, +import static org.elasticsearch.common.util.concurrent.EsExecutors.daemonThreadFactory;, +    private static final String LIFECYCLE_THREADPOOL_NAME = "watcher-lifecycle";, +, +        // use a single thread executor so that lifecycle changes are handled in the order they, +        // are submitted in, +        this(settings, clusterService, watcherService, EsExecutors.newFixed(, +                LIFECYCLE_THREADPOOL_NAME,, +                1,, +                1000,, +                daemonThreadFactory(settings, LIFECYCLE_THREADPOOL_NAME),, +                threadPool.getThreadContext()));, +    }, +, +    WatcherLifeCycleService(Settings settings, ClusterService clusterService,, +                            WatcherService watcherService, ExecutorService executorService) {, +        this.executor = executorService;, +        stopExecutor();, +    }, +, +    void stopExecutor() {, +        ThreadPool.terminate(executor, 10L, TimeUnit.SECONDS);, +++ b/plugin/watcher/src/main/java/org/elasticsearch/xpack/watcher/WatcherLifeCycleService.java, +import org.elasticsearch.common.util.concurrent.EsExecutors;, +import java.util.concurrent.TimeUnit;, +import static org.elasticsearch.common.util.concurrent.EsExecutors.daemonThreadFactory;, +    private static final String LIFECYCLE_THREADPOOL_NAME = "watcher-lifecycle";, +, +        // use a single thread executor so that lifecycle changes are handled in the order they, +        // are submitted in, +        this(settings, clusterService, watcherService, EsExecutors.newFixed(, +                LIFECYCLE_THREADPOOL_NAME,, +                1,, +                1000,, +                daemonThreadFactory(settings, LIFECYCLE_THREADPOOL_NAME),, +                threadPool.getThreadContext()));, +    }, +, +    WatcherLifeCycleService(Settings settings, ClusterService clusterService,, +                            WatcherService watcherService, ExecutorService executorService) {, +        this.executor = executorService;, +        stopExecutor();, +    }, +, +    void stopExecutor() {, +        ThreadPool.terminate(executor, 10L, TimeUnit.SECONDS);, +++ b/plugin/watcher/src/main/java/org/elasticsearch/xpack/watcher/WatcherService.java, +        } else {, +            logger.debug("could not transition state from stopped to starting, current state [{}]", state.get());, +                } else {, +                    logger.debug("could not transition state from started to stopping, current state [{}]", state.get());, +++ b/plugin/watcher/src/main/java/org/elasticsearch/xpack/watcher/WatcherLifeCycleService.java, +import org.elasticsearch.common.util.concurrent.EsExecutors;, +import java.util.concurrent.TimeUnit;, +import static org.elasticsearch.common.util.concurrent.EsExecutors.daemonThreadFactory;, +    private static final String LIFECYCLE_THREADPOOL_NAME = "watcher-lifecycle";, +, +        // use a single thread executor so that lifecycle changes are handled in the order they, +        // are submitted in, +        this(settings, clusterService, watcherService, EsExecutors.newFixed(, +                LIFECYCLE_THREADPOOL_NAME,, +                1,, +                1000,, +                daemonThreadFactory(settings, LIFECYCLE_THREADPOOL_NAME),, +                threadPool.getThreadContext()));, +    }, +, +    WatcherLifeCycleService(Settings settings, ClusterService clusterService,, +                            WatcherService watcherService, ExecutorService executorService) {, +        this.executor = executorService;, +        stopExecutor();, +    }, +, +    void stopExecutor() {, +        ThreadPool.terminate(executor, 10L, TimeUnit.SECONDS);, +++ b/plugin/watcher/src/main/java/org/elasticsearch/xpack/watcher/WatcherService.java, +        } else {, +            logger.debug("could not transition state from stopped to starting, current state [{}]", state.get());, +                } else {, +                    logger.debug("could not transition state from started to stopping, current state [{}]", state.get());, +++ b/plugin/watcher/src/test/java/org/elasticsearch/xpack/watcher/WatcherLifeCycleServiceTests.java, +import org.elasticsearch.common.util.concurrent.ThreadContext;, +        when(threadPool.getThreadContext()).thenReturn(new ThreadContext(Settings.EMPTY));, +        lifeCycleService = new WatcherLifeCycleService(Settings.EMPTY, clusterService, watcherService,, +                EsExecutors.newDirectExecutorService()) {, +            @Override, +            void stopExecutor() {, +                // direct executor cannot be terminated, +            }, +        };]