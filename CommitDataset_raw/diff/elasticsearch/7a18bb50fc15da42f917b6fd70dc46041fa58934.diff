[+++ b/core/src/main/java/org/apache/lucene/queryparser/classic/MapperQueryParser.java, +import static java.util.Collections.unmodifiableMap;, +import static org.elasticsearch.common.lucene.search.Queries.fixNegativeQueryIfNeeded;, +, +            PhraseQuery pq = (PhraseQuery) q;, +            PhraseQuery.Builder builder = new PhraseQuery.Builder();, +            builder.setSlop(slop);, +            final Term[] terms = pq.getTerms();, +            final int[] positions = pq.getPositions();, +            for (int i = 0; i < terms.length; ++i) {, +                builder.add(terms[i], positions[i]);, +            }, +            pq = builder.build();, +            return pq;, +++ b/core/src/main/java/org/apache/lucene/queryparser/classic/MapperQueryParser.java, +import static java.util.Collections.unmodifiableMap;, +import static org.elasticsearch.common.lucene.search.Queries.fixNegativeQueryIfNeeded;, +, +            PhraseQuery pq = (PhraseQuery) q;, +            PhraseQuery.Builder builder = new PhraseQuery.Builder();, +            builder.setSlop(slop);, +            final Term[] terms = pq.getTerms();, +            final int[] positions = pq.getPositions();, +            for (int i = 0; i < terms.length; ++i) {, +                builder.add(terms[i], positions[i]);, +            }, +            pq = builder.build();, +            return pq;, +++ b/core/src/main/java/org/elasticsearch/action/ActionListener.java, +++ b/core/src/main/java/org/apache/lucene/queryparser/classic/MapperQueryParser.java, +import static java.util.Collections.unmodifiableMap;, +import static org.elasticsearch.common.lucene.search.Queries.fixNegativeQueryIfNeeded;, +, +            PhraseQuery pq = (PhraseQuery) q;, +            PhraseQuery.Builder builder = new PhraseQuery.Builder();, +            builder.setSlop(slop);, +            final Term[] terms = pq.getTerms();, +            final int[] positions = pq.getPositions();, +            for (int i = 0; i < terms.length; ++i) {, +                builder.add(terms[i], positions[i]);, +            }, +            pq = builder.build();, +            return pq;, +++ b/core/src/main/java/org/elasticsearch/action/ActionListener.java, +++ b/core/src/main/java/org/elasticsearch/action/admin/cluster/shards/ClusterSearchShardsGroup.java, +    ClusterSearchShardsGroup(ShardId shardId, ShardRouting[] shards) {, +++ b/core/src/main/java/org/apache/lucene/queryparser/classic/MapperQueryParser.java, +import static java.util.Collections.unmodifiableMap;, +import static org.elasticsearch.common.lucene.search.Queries.fixNegativeQueryIfNeeded;, +, +            PhraseQuery pq = (PhraseQuery) q;, +            PhraseQuery.Builder builder = new PhraseQuery.Builder();, +            builder.setSlop(slop);, +            final Term[] terms = pq.getTerms();, +            final int[] positions = pq.getPositions();, +            for (int i = 0; i < terms.length; ++i) {, +                builder.add(terms[i], positions[i]);, +            }, +            pq = builder.build();, +            return pq;, +++ b/core/src/main/java/org/elasticsearch/action/ActionListener.java, +++ b/core/src/main/java/org/elasticsearch/action/admin/cluster/shards/ClusterSearchShardsGroup.java, +    ClusterSearchShardsGroup(ShardId shardId, ShardRouting[] shards) {, +++ b/core/src/main/java/org/elasticsearch/action/admin/cluster/shards/ClusterSearchShardsResponse.java, +    ClusterSearchShardsResponse(ClusterSearchShardsGroup[] groups, DiscoveryNode[] nodes, Map<String, AliasFilter> indicesAndFilters) {, +++ b/core/src/main/java/org/apache/lucene/queryparser/classic/MapperQueryParser.java, +import static java.util.Collections.unmodifiableMap;, +import static org.elasticsearch.common.lucene.search.Queries.fixNegativeQueryIfNeeded;, +, +            PhraseQuery pq = (PhraseQuery) q;, +            PhraseQuery.Builder builder = new PhraseQuery.Builder();, +            builder.setSlop(slop);, +            final Term[] terms = pq.getTerms();, +            final int[] positions = pq.getPositions();, +            for (int i = 0; i < terms.length; ++i) {, +                builder.add(terms[i], positions[i]);, +            }, +            pq = builder.build();, +            return pq;, +++ b/core/src/main/java/org/elasticsearch/action/ActionListener.java, +++ b/core/src/main/java/org/elasticsearch/action/admin/cluster/shards/ClusterSearchShardsGroup.java, +    ClusterSearchShardsGroup(ShardId shardId, ShardRouting[] shards) {, +++ b/core/src/main/java/org/elasticsearch/action/admin/cluster/shards/ClusterSearchShardsResponse.java, +    ClusterSearchShardsResponse(ClusterSearchShardsGroup[] groups, DiscoveryNode[] nodes, Map<String, AliasFilter> indicesAndFilters) {, +++ b/core/src/main/java/org/elasticsearch/action/search/AbstractSearchAsyncAction.java, +    protected final Function<String, DiscoveryNode> nodeIdToDiscoveryNode;, +                                        Function<String, DiscoveryNode> nodeIdToDiscoveryNode,, +        this.nodeIdToDiscoveryNode = nodeIdToDiscoveryNode;, +            final DiscoveryNode node = nodeIdToDiscoveryNode.apply(shard.currentNodeId());, +            if (node == null) {, +                onFirstPhaseResult(shardIndex, shard, null, shardIt, new NoShardAvailableActionException(shardIt.shardId()));, +            } else {, +                sendExecuteFirstPhase(node, transportRequest , new ActionListener<FirstResult>() {, +                            onFirstPhaseResult(shardIndex, shard, node.getId(), shardIt, t);, +                DiscoveryNode node = nodeIdToDiscoveryNode.apply(entry.value.shardTarget().getNodeId());, +                sendReleaseSearchContext(entry.value.id(), node);, +                        DiscoveryNode node = nodeIdToDiscoveryNode.apply(entry.value.queryResult().shardTarget().getNodeId());, +                        sendReleaseSearchContext(entry.value.queryResult().id(), node);, +    protected void sendReleaseSearchContext(long contextId, DiscoveryNode node) {, +        if (node != null) {]