[+++ b/plugin/src/main/java/org/elasticsearch/xpack/security/authc/file/FileUserPasswdStore.java, +import org.elasticsearch.xpack.security.support.SecurityFiles;, +        SecurityFiles.writeFileAtomically(, +                path,, +                users,, +                e -> String.format(Locale.ROOT, "%s:%s", e.getKey(), new String(e.getValue())));, +++ b/plugin/src/main/java/org/elasticsearch/xpack/security/authc/file/FileUserPasswdStore.java, +import org.elasticsearch.xpack.security.support.SecurityFiles;, +        SecurityFiles.writeFileAtomically(, +                path,, +                users,, +                e -> String.format(Locale.ROOT, "%s:%s", e.getKey(), new String(e.getValue())));, +++ b/plugin/src/main/java/org/elasticsearch/xpack/security/authc/file/FileUserRolesStore.java, +import org.elasticsearch.xpack.security.support.SecurityFiles;, +import static org.elasticsearch.common.Strings.collectionToCommaDelimitedString;, +        SecurityFiles.writeFileAtomically(, +                path,, +                roleToUsers,, +                e -> String.format(Locale.ROOT, "%s:%s", e.getKey(), collectionToCommaDelimitedString(e.getValue())));, +++ b/plugin/src/main/java/org/elasticsearch/xpack/security/authc/file/FileUserPasswdStore.java, +import org.elasticsearch.xpack.security.support.SecurityFiles;, +        SecurityFiles.writeFileAtomically(, +                path,, +                users,, +                e -> String.format(Locale.ROOT, "%s:%s", e.getKey(), new String(e.getValue())));, +++ b/plugin/src/main/java/org/elasticsearch/xpack/security/authc/file/FileUserRolesStore.java, +import org.elasticsearch.xpack.security.support.SecurityFiles;, +import static org.elasticsearch.common.Strings.collectionToCommaDelimitedString;, +        SecurityFiles.writeFileAtomically(, +                path,, +                roleToUsers,, +                e -> String.format(Locale.ROOT, "%s:%s", e.getKey(), collectionToCommaDelimitedString(e.getValue())));, +++ b/plugin/src/main/java/org/elasticsearch/xpack/security/support/SecurityFiles.java, +import org.apache.lucene.util.IOUtils;, +import java.io.UncheckedIOException;, +import java.util.Locale;, +import java.util.Map;, +import java.util.function.Function;, +, +import static java.nio.file.StandardCopyOption.ATOMIC_MOVE;, +import static java.nio.file.StandardCopyOption.REPLACE_EXISTING;, +import static java.nio.file.StandardOpenOption.CREATE;, +import static java.nio.file.StandardOpenOption.TRUNCATE_EXISTING;, +import static java.nio.file.StandardOpenOption.WRITE;, +     * Atomically writes to the specified file a line per entry in the specified map using the specified transform to convert each entry to, +     * a line. The writing is done atomically in the following sense: first the lines are written to a temporary file and if the writing, +     * succeeds then the temporary file is moved to the specified path, replacing the file if it exists. If a failure occurs, any existing, +     * file is preserved, and the temporary file is cleaned up., +     * @param <K>       the key type of the map entries, +     * @param <V>       the value type of the map entries, +     * @param path      the path, +     * @param map       the map whose entries to transform into lines, +     * @param transform the transform to convert each map entry to a line, +    public static <K, V> void writeFileAtomically(final Path path, final Map<K, V> map, final Function<Map.Entry<K, V>, String> transform) {, +        Path tempFile = null;, +        try {, +            tempFile = Files.createTempFile(path.getParent(), path.getFileName().toString(), "tmp");, +            try (Writer writer = Files.newBufferedWriter(tempFile, StandardCharsets.UTF_8, CREATE, TRUNCATE_EXISTING, WRITE)) {, +                for (final Map.Entry<K, V> entry : map.entrySet()) {, +                    final StringBuilder sb = new StringBuilder();, +                    final String line = sb.append(transform.apply(entry)).append(System.lineSeparator()).toString();, +                    writer.write(line);, +                Files.move(tempFile, path, REPLACE_EXISTING, ATOMIC_MOVE);, +            } catch (final AtomicMoveNotSupportedException e) {, +                Files.move(tempFile, path, REPLACE_EXISTING);, +        } catch (final IOException e) {, +            throw new UncheckedIOException(String.format(Locale.ROOT, "could not write file [%s]", path.toAbsolutePath()), e);, +        } finally {, +            // we are ignoring exceptions here, so we do not need handle whether or not tempFile was initialized nor if the file exists, +            IOUtils.deleteFilesIgnoringExceptions(tempFile);, +++ b/plugin/src/main/java/org/elasticsearch/xpack/security/authc/file/FileUserPasswdStore.java, +import org.elasticsearch.xpack.security.support.SecurityFiles;, +        SecurityFiles.writeFileAtomically(, +                path,, +                users,, +                e -> String.format(Locale.ROOT, "%s:%s", e.getKey(), new String(e.getValue())));, +++ b/plugin/src/main/java/org/elasticsearch/xpack/security/authc/file/FileUserRolesStore.java, +import org.elasticsearch.xpack.security.support.SecurityFiles;, +import static org.elasticsearch.common.Strings.collectionToCommaDelimitedString;, +        SecurityFiles.writeFileAtomically(, +                path,, +                roleToUsers,, +                e -> String.format(Locale.ROOT, "%s:%s", e.getKey(), collectionToCommaDelimitedString(e.getValue())));, +++ b/plugin/src/main/java/org/elasticsearch/xpack/security/support/SecurityFiles.java, +import org.apache.lucene.util.IOUtils;, +import java.io.UncheckedIOException;, +import java.util.Locale;, +import java.util.Map;, +import java.util.function.Function;, +, +import static java.nio.file.StandardCopyOption.ATOMIC_MOVE;, +import static java.nio.file.StandardCopyOption.REPLACE_EXISTING;, +import static java.nio.file.StandardOpenOption.CREATE;, +import static java.nio.file.StandardOpenOption.TRUNCATE_EXISTING;, +import static java.nio.file.StandardOpenOption.WRITE;, +     * Atomically writes to the specified file a line per entry in the specified map using the specified transform to convert each entry to, +     * a line. The writing is done atomically in the following sense: first the lines are written to a temporary file and if the writing, +     * succeeds then the temporary file is moved to the specified path, replacing the file if it exists. If a failure occurs, any existing, +     * file is preserved, and the temporary file is cleaned up., +     * @param <K>       the key type of the map entries]