[+++ b/x-pack/plugin/ml/qa/native-multi-node-tests/src/test/java/org/elasticsearch/xpack/ml/integration/PersistJobIT.java, +import org.elasticsearch.action.search.SearchResponse;, +import org.elasticsearch.action.support.master.AcknowledgedResponse;, +import org.elasticsearch.search.SearchHit;, +import org.elasticsearch.xpack.core.ml.action.FlushJobAction;, +import org.elasticsearch.xpack.core.ml.job.persistence.AnomalyDetectorsIndex;, +import static org.hamcrest.Matchers.equalTo;, +import static org.hamcrest.Matchers.is;, +, +    private static final long BUCKET_SPAN_SECONDS = 300;, +    private static final TimeValue BUCKET_SPAN = TimeValue.timeValueSeconds(BUCKET_SPAN_SECONDS);, +, +    // check that state is persisted after time has been advanced even if no new data is seen in the interim, +    public void testPersistJobOnGracefulShutdown_givenTimeAdvancedAfterNoNewData() throws Exception {, +        String jobId = "time-advanced-after-no-new-data-test";, +, +        // open and run a job with a small data set, +        runJob(jobId);, +        FlushJobAction.Response flushResponse = flushJob(jobId, true);, +, +        closeJob(jobId);, +, +        // Check that state has been persisted, +        SearchResponse stateDocsResponse1 = client().prepareSearch(AnomalyDetectorsIndex.jobStateIndexPattern()), +            .setFetchSource(false), +            .setTrackTotalHits(true), +            .setSize(10000), +            .get();, +, +        int numQuantileRecords = 0;, +        int numStateRecords = 0;, +        for (SearchHit hit : stateDocsResponse1.getHits().getHits()) {, +            logger.info(hit.getId());, +            if (hit.getId().contains("quantiles")) {, +                ++numQuantileRecords;, +            } else if (hit.getId().contains("model_state")) {, +                ++numStateRecords;, +            }, +        }, +        assertThat(stateDocsResponse1.getHits().getTotalHits().value, equalTo(2L));, +        assertThat(numQuantileRecords, equalTo(1));, +        assertThat(numStateRecords, equalTo(1));, +, +        // re-open the job, +        openJob(jobId);, +, +        // advance time, +        long lastFinalizedBucketEnd = flushResponse.getLastFinalizedBucketEnd().getTime();, +        FlushJobAction.Request advanceTimeRequest = new FlushJobAction.Request(jobId);, +        advanceTimeRequest.setAdvanceTime(String.valueOf(lastFinalizedBucketEnd + BUCKET_SPAN_SECONDS * 1000));, +        advanceTimeRequest.setCalcInterim(false);, +        assertThat(client().execute(FlushJobAction.INSTANCE, advanceTimeRequest).actionGet().isFlushed(), is(true));, +, +        closeJob(jobId);, +, +        // Check that a new state record exists., +        SearchResponse stateDocsResponse2 = client().prepareSearch(AnomalyDetectorsIndex.jobStateIndexPattern()), +            .setFetchSource(false), +            .setTrackTotalHits(true), +            .setSize(10000), +            .get();, +, +        numQuantileRecords = 0;, +        numStateRecords = 0;, +        for (SearchHit hit : stateDocsResponse2.getHits().getHits()) {, +            logger.info(hit.getId());, +            if (hit.getId().contains("quantiles")) {, +                ++numQuantileRecords;, +            } else if (hit.getId().contains("model_state")) {, +                ++numStateRecords;, +            }, +        }, +, +        assertThat(stateDocsResponse2.getHits().getTotalHits().value, equalTo(3L));, +        assertThat(numQuantileRecords, equalTo(1));, +        assertThat(numStateRecords, equalTo(2));, +, +        deleteJob(jobId);, +    }, +, +    // Check an edge case where time is manually advanced before any valid data is seen, +    public void testPersistJobOnGracefulShutdown_givenNoDataAndTimeAdvanced() throws Exception {, +        String jobId = "no-data-and-time-advanced-test";, +, +        createAndOpenJob(jobId);, +, +        // Manually advance time., +        FlushJobAction.Request advanceTimeRequest = new FlushJobAction.Request(jobId);, +        advanceTimeRequest.setAdvanceTime(String.valueOf(BUCKET_SPAN_SECONDS * 1000));, +        advanceTimeRequest.setCalcInterim(false);, +        assertThat(client().execute(FlushJobAction.INSTANCE, advanceTimeRequest).actionGet().isFlushed(), is(true));, +, +        closeJob(jobId);, +, +        // Check that state has been persisted, +        SearchResponse stateDocsResponse = client().prepareSearch(AnomalyDetectorsIndex.jobStateIndexPattern()), +            .setFetchSource(false), +            .setTrackTotalHits(true), +            .setSize(10000), +            .get();]