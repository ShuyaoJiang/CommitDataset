[+++ b/modules/mapper-extras/src/main/java/org/elasticsearch/index/mapper/RangeFieldMapper.java, +import org.elasticsearch.common.collect.Tuple;, +import java.net.UnknownHostException;, +            final XContentParser.Token start = parser.currentToken();, +            if (start == XContentParser.Token.START_OBJECT) {, +            } else if (fieldType().rangeType == RangeType.IP && start == XContentParser.Token.VALUE_STRING) {, +                range = parseIpRangeFromCidr(parser);, +    private static Range parseIpRangeFromCidr(final XContentParser parser) throws IOException {, +        final Tuple<InetAddress, Integer> cidr = InetAddresses.parseCidr(parser.text());, +        // create the lower value by zeroing out the host portion, upper value by filling it with all ones., +        byte[] lower = cidr.v1().getAddress();, +        byte[] upper = lower.clone();, +        for (int i = cidr.v2(); i < 8 * lower.length; i++) {, +            int m = 1 << 7 - (i & 7);, +            lower[i >> 3] &= ~m;, +            upper[i >> 3] |= m;, +        }, +        try {, +            return new Range(RangeType.IP, InetAddress.getByAddress(lower), InetAddress.getByAddress(upper), true, true);, +        } catch (UnknownHostException bogus) {, +            throw new AssertionError(bogus);, +        }, +    }, +, +++ b/modules/mapper-extras/src/main/java/org/elasticsearch/index/mapper/RangeFieldMapper.java, +import org.elasticsearch.common.collect.Tuple;, +import java.net.UnknownHostException;, +            final XContentParser.Token start = parser.currentToken();, +            if (start == XContentParser.Token.START_OBJECT) {, +            } else if (fieldType().rangeType == RangeType.IP && start == XContentParser.Token.VALUE_STRING) {, +                range = parseIpRangeFromCidr(parser);, +    private static Range parseIpRangeFromCidr(final XContentParser parser) throws IOException {, +        final Tuple<InetAddress, Integer> cidr = InetAddresses.parseCidr(parser.text());, +        // create the lower value by zeroing out the host portion, upper value by filling it with all ones., +        byte[] lower = cidr.v1().getAddress();, +        byte[] upper = lower.clone();, +        for (int i = cidr.v2(); i < 8 * lower.length; i++) {, +            int m = 1 << 7 - (i & 7);, +            lower[i >> 3] &= ~m;, +            upper[i >> 3] |= m;, +        }, +        try {, +            return new Range(RangeType.IP, InetAddress.getByAddress(lower), InetAddress.getByAddress(upper), true, true);, +        } catch (UnknownHostException bogus) {, +            throw new AssertionError(bogus);, +        }, +    }, +, +++ b/modules/mapper-extras/src/test/java/org/elasticsearch/index/mapper/IpRangeFieldMapperTests.java, +/*, + * Licensed to Elasticsearch under one or more contributor, + * license agreements. See the NOTICE file distributed with, + * this work for additional information regarding copyright, + * ownership. Elasticsearch licenses this file to you under, + * the Apache License, Version 2.0 (the "License"); you may, + * not use this file except in compliance with the License., + * You may obtain a copy of the License at, + *, + *    http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing,, + * software distributed under the License is distributed on an, + * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY, + * KIND, either express or implied.  See the License for the, + * specific language governing permissions and limitations, + * under the License., + */, +package org.elasticsearch.index.mapper;, +, +import java.util.Collection;, +import java.util.HashMap;, +import java.util.Map;, +import org.apache.lucene.index.DocValuesType;, +import org.apache.lucene.index.IndexableField;, +import org.elasticsearch.common.compress.CompressedXContent;, +import org.elasticsearch.common.network.InetAddresses;, +import org.elasticsearch.common.xcontent.XContentBuilder;, +import org.elasticsearch.common.xcontent.XContentFactory;, +import org.elasticsearch.common.xcontent.XContentType;, +import org.elasticsearch.index.IndexService;, +import org.elasticsearch.plugins.Plugin;, +import org.elasticsearch.test.ESSingleNodeTestCase;, +import org.junit.Before;, +, +import static org.hamcrest.Matchers.containsString;, +, +public class IpRangeFieldMapperTests extends ESSingleNodeTestCase {, +, +    private IndexService indexService;, +    private DocumentMapperParser parser;, +, +    @Override, +    protected Collection<Class<? extends Plugin>> getPlugins() {, +        return pluginList(MapperExtrasPlugin.class);, +    }, +, +    @Before, +    public void setup() {, +        indexService = createIndex("test");, +        parser = indexService.mapperService().documentMapperParser();]