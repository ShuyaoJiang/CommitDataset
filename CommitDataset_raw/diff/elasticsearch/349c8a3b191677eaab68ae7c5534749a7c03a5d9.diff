[+++ b/server/src/main/java/org/elasticsearch/gateway/ClusterStateUpdaters.java, +++ b/server/src/main/java/org/elasticsearch/gateway/ClusterStateUpdaters.java, +++ b/server/src/main/java/org/elasticsearch/gateway/Gateway.java, +++ b/server/src/main/java/org/elasticsearch/gateway/ClusterStateUpdaters.java, +++ b/server/src/main/java/org/elasticsearch/gateway/Gateway.java, +++ b/server/src/main/java/org/elasticsearch/gateway/GatewayMetaState.java, +++ b/server/src/main/java/org/elasticsearch/gateway/ClusterStateUpdaters.java, +++ b/server/src/main/java/org/elasticsearch/gateway/Gateway.java, +++ b/server/src/main/java/org/elasticsearch/gateway/GatewayMetaState.java, +++ b/server/src/test/java/org/elasticsearch/action/admin/indices/create/CreateIndexIT.java, +import org.elasticsearch.cluster.routing.IndexRoutingTable;, +import org.elasticsearch.cluster.routing.IndexShardRoutingTable;, +import org.elasticsearch.cluster.routing.RoutingTable;, +import org.elasticsearch.cluster.routing.UnassignedInfo;, +import java.util.concurrent.TimeUnit;, +import static org.hamcrest.Matchers.greaterThan;, +        // check that the cluster does not keep reallocating shards, +        assertBusy(() -> {, +            final RoutingTable routingTable = client().admin().cluster().prepareState().get().getState().routingTable();, +            final IndexRoutingTable indexRoutingTable = routingTable.index("test");, +            assertNotNull(indexRoutingTable);, +            for (IndexShardRoutingTable shardRoutingTable : indexRoutingTable) {, +                assertTrue(shardRoutingTable.primaryShard().unassigned());, +                assertEquals(UnassignedInfo.AllocationStatus.DECIDERS_NO,, +                    shardRoutingTable.primaryShard().unassignedInfo().getLastAllocationStatus());, +                assertThat(shardRoutingTable.primaryShard().unassignedInfo().getNumFailedAllocations(), greaterThan(0));, +            }, +        }, 60, TimeUnit.SECONDS);, +        client().admin().indices().prepareClose("test").get();, +++ b/server/src/main/java/org/elasticsearch/gateway/ClusterStateUpdaters.java, +++ b/server/src/main/java/org/elasticsearch/gateway/Gateway.java, +++ b/server/src/main/java/org/elasticsearch/gateway/GatewayMetaState.java, +++ b/server/src/test/java/org/elasticsearch/action/admin/indices/create/CreateIndexIT.java, +import org.elasticsearch.cluster.routing.IndexRoutingTable;, +import org.elasticsearch.cluster.routing.IndexShardRoutingTable;, +import org.elasticsearch.cluster.routing.RoutingTable;, +import org.elasticsearch.cluster.routing.UnassignedInfo;, +import java.util.concurrent.TimeUnit;, +import static org.hamcrest.Matchers.greaterThan;, +        // check that the cluster does not keep reallocating shards, +        assertBusy(() -> {, +            final RoutingTable routingTable = client().admin().cluster().prepareState().get().getState().routingTable();, +            final IndexRoutingTable indexRoutingTable = routingTable.index("test");, +            assertNotNull(indexRoutingTable);, +            for (IndexShardRoutingTable shardRoutingTable : indexRoutingTable) {, +                assertTrue(shardRoutingTable.primaryShard().unassigned());, +                assertEquals(UnassignedInfo.AllocationStatus.DECIDERS_NO,, +                    shardRoutingTable.primaryShard().unassignedInfo().getLastAllocationStatus());, +                assertThat(shardRoutingTable.primaryShard().unassignedInfo().getNumFailedAllocations(), greaterThan(0));, +            }, +        }, 60, TimeUnit.SECONDS);, +        client().admin().indices().prepareClose("test").get();, +++ b/server/src/test/java/org/elasticsearch/gateway/ClusterStateUpdatersTests.java, +++ b/server/src/main/java/org/elasticsearch/gateway/ClusterStateUpdaters.java, +++ b/server/src/main/java/org/elasticsearch/gateway/Gateway.java, +++ b/server/src/main/java/org/elasticsearch/gateway/GatewayMetaState.java, +++ b/server/src/test/java/org/elasticsearch/action/admin/indices/create/CreateIndexIT.java, +import org.elasticsearch.cluster.routing.IndexRoutingTable;, +import org.elasticsearch.cluster.routing.IndexShardRoutingTable;, +import org.elasticsearch.cluster.routing.RoutingTable;, +import org.elasticsearch.cluster.routing.UnassignedInfo;, +import java.util.concurrent.TimeUnit;, +import static org.hamcrest.Matchers.greaterThan;, +        // check that the cluster does not keep reallocating shards, +        assertBusy(() -> {, +            final RoutingTable routingTable = client().admin().cluster().prepareState().get().getState().routingTable();, +            final IndexRoutingTable indexRoutingTable = routingTable.index("test");, +            assertNotNull(indexRoutingTable);, +            for (IndexShardRoutingTable shardRoutingTable : indexRoutingTable) {, +                assertTrue(shardRoutingTable.primaryShard().unassigned());, +                assertEquals(UnassignedInfo.AllocationStatus.DECIDERS_NO,, +                    shardRoutingTable.primaryShard().unassignedInfo().getLastAllocationStatus());, +                assertThat(shardRoutingTable.primaryShard().unassignedInfo().getNumFailedAllocations(), greaterThan(0));, +            }, +        }, 60, TimeUnit.SECONDS);, +        client().admin().indices().prepareClose("test").get();, +++ b/server/src/test/java/org/elasticsearch/gateway/ClusterStateUpdatersTests.java, +++ b/server/src/test/java/org/elasticsearch/gateway/GatewayIndexStateIT.java, +import org.elasticsearch.cluster.routing.IndexRoutingTable;, +import org.elasticsearch.cluster.routing.IndexShardRoutingTable;, +import org.elasticsearch.cluster.routing.RoutingTable;, +import org.elasticsearch.cluster.routing.UnassignedInfo;, +import java.util.concurrent.TimeUnit;, +import static org.hamcrest.Matchers.greaterThan;, +        // check that the cluster does not keep reallocating shards, +        assertBusy(() -> {, +            final RoutingTable routingTable = client().admin().cluster().prepareState().get().getState().routingTable();, +            final IndexRoutingTable indexRoutingTable = routingTable.index("test");, +            assertNotNull(indexRoutingTable);, +            for (IndexShardRoutingTable shardRoutingTable : indexRoutingTable) {, +                assertTrue(shardRoutingTable.primaryShard().unassigned());, +                assertEquals(UnassignedInfo.AllocationStatus.DECIDERS_NO,, +                    shardRoutingTable.primaryShard().unassignedInfo().getLastAllocationStatus());, +                assertThat(shardRoutingTable.primaryShard().unassignedInfo().getNumFailedAllocations(), greaterThan(0));, +            }, +        }, 60, TimeUnit.SECONDS);, +        client().admin().indices().prepareClose("test").get();, +, +        // check that the cluster does not keep reallocating shards, +        assertBusy(() -> {]