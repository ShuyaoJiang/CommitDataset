[+++ b/core/src/main/java/org/elasticsearch/action/bulk/TransportShardBulkAction.java, +                SourceToParse.source(shardId.getIndexName(),, +                SourceToParse.source(request.index(), request.type(),, +++ b/core/src/main/java/org/elasticsearch/action/bulk/TransportShardBulkAction.java, +                SourceToParse.source(shardId.getIndexName(),, +                SourceToParse.source(request.index(), request.type(),, +++ b/core/src/main/java/org/elasticsearch/index/engine/Engine.java, +     * Fills up the local checkpoints history with no-ops until the local checkpoint, +     * and the max seen sequence ID are identical., +     * @param primaryTerm the shards primary term this engine was created for, +     * @return the number of no-ops added, +     */, +    public abstract int fillSequenceNumberHistory(long primaryTerm) throws IOException;, +, +    /**, +++ b/core/src/main/java/org/elasticsearch/action/bulk/TransportShardBulkAction.java, +                SourceToParse.source(shardId.getIndexName(),, +                SourceToParse.source(request.index(), request.type(),, +++ b/core/src/main/java/org/elasticsearch/index/engine/Engine.java, +     * Fills up the local checkpoints history with no-ops until the local checkpoint, +     * and the max seen sequence ID are identical., +     * @param primaryTerm the shards primary term this engine was created for, +     * @return the number of no-ops added, +     */, +    public abstract int fillSequenceNumberHistory(long primaryTerm) throws IOException;, +, +    /**, +++ b/core/src/main/java/org/elasticsearch/index/engine/InternalEngine.java, +    @Override, +    public int fillSequenceNumberHistory(long primaryTerm) throws IOException {, +        try (ReleasableLock lock = writeLock.acquire()) {, +            ensureOpen();, +            final long localCheckpoint = seqNoService.getLocalCheckpoint();, +            final long maxSeqId = seqNoService.getMaxSeqNo();, +            int numNoOpsAdded = 0;, +            for (long seqNo = localCheckpoint + 1; seqNo <= maxSeqId;, +                 // the local checkpoint might have been advanced so we are leap-frogging, +                 // to the next seq ID we need to process and create a noop for, +                 seqNo = seqNoService.getLocalCheckpoint()+1) {, +                final NoOp noOp = new NoOp(seqNo, primaryTerm, Operation.Origin.PRIMARY, System.nanoTime(), "filling up seqNo history");, +                innerNoOp(noOp);, +                numNoOpsAdded++;, +                assert seqNo <= seqNoService.getLocalCheckpoint() : "localCheckpoint didn't advanced used to be " + seqNo + " now it's on:", +                     + seqNoService.getLocalCheckpoint();, +, +            }, +            return numNoOpsAdded;, +        }, +    }, +, +        assert readLock.isHeldByCurrentThread() || writeLock.isHeldByCurrentThread();, +++ b/core/src/main/java/org/elasticsearch/action/bulk/TransportShardBulkAction.java, +                SourceToParse.source(shardId.getIndexName(),, +                SourceToParse.source(request.index(), request.type(),, +++ b/core/src/main/java/org/elasticsearch/index/engine/Engine.java, +     * Fills up the local checkpoints history with no-ops until the local checkpoint, +     * and the max seen sequence ID are identical., +     * @param primaryTerm the shards primary term this engine was created for, +     * @return the number of no-ops added, +     */, +    public abstract int fillSequenceNumberHistory(long primaryTerm) throws IOException;, +, +    /**, +++ b/core/src/main/java/org/elasticsearch/index/engine/InternalEngine.java, +    @Override, +    public int fillSequenceNumberHistory(long primaryTerm) throws IOException {, +        try (ReleasableLock lock = writeLock.acquire()) {, +            ensureOpen();, +            final long localCheckpoint = seqNoService.getLocalCheckpoint();, +            final long maxSeqId = seqNoService.getMaxSeqNo();, +            int numNoOpsAdded = 0;, +            for (long seqNo = localCheckpoint + 1; seqNo <= maxSeqId;, +                 // the local checkpoint might have been advanced so we are leap-frogging, +                 // to the next seq ID we need to process and create a noop for, +                 seqNo = seqNoService.getLocalCheckpoint()+1) {, +                final NoOp noOp = new NoOp(seqNo, primaryTerm, Operation.Origin.PRIMARY, System.nanoTime(), "filling up seqNo history");, +                innerNoOp(noOp);, +                numNoOpsAdded++;, +                assert seqNo <= seqNoService.getLocalCheckpoint() : "localCheckpoint didn't advanced used to be " + seqNo + " now it's on:", +                     + seqNoService.getLocalCheckpoint();, +, +            }, +            return numNoOpsAdded;, +        }, +    }, +, +        assert readLock.isHeldByCurrentThread() || writeLock.isHeldByCurrentThread();, +++ b/core/src/main/java/org/elasticsearch/index/mapper/SourceToParse.java, +    public static SourceToParse source(String index, String type, String id, BytesReference source,, +        return new SourceToParse(index, type, id, source, contentType);, +    private SourceToParse(String index, String type, String id, BytesReference source, XContentType xContentType) {, +++ b/core/src/main/java/org/elasticsearch/action/bulk/TransportShardBulkAction.java, +                SourceToParse.source(shardId.getIndexName(),, +                SourceToParse.source(request.index(), request.type(),, +++ b/core/src/main/java/org/elasticsearch/index/engine/Engine.java, +     * Fills up the local checkpoints history with no-ops until the local checkpoint, +     * and the max seen sequence ID are identical., +     * @param primaryTerm the shards primary term this engine was created for, +     * @return the number of no-ops added, +     */]