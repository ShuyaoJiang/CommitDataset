[+++ b/core/src/main/java/org/apache/lucene/queryparser/classic/MapperQueryParser.java, +import static java.util.Collections.unmodifiableMap;, +import static org.elasticsearch.common.lucene.search.Queries.fixNegativeQueryIfNeeded;, +, +import org.apache.lucene.search.GraphQuery;, +            return addSlopToPhrase((PhraseQuery) q, slop);, +        } else if (q instanceof GraphQuery && ((GraphQuery) q).hasPhrase()) {, +            // we have a graph query that has at least one phrase sub-query, +            // re-build and set slop on all phrase queries, +            List<Query> oldQueries = ((GraphQuery) q).getQueries();, +            Query[] queries = new Query[oldQueries.size()];, +            for (int i = 0; i < queries.length; i++) {, +                Query oldQuery = oldQueries.get(i);, +                if (oldQuery instanceof PhraseQuery) {, +                    queries[i] = addSlopToPhrase((PhraseQuery) oldQuery, slop);, +                } else {, +                    queries[i] = oldQuery;, +                }, +            }, +, +            return new GraphQuery(queries);, +    /**, +     * Rebuild a phrase query with a slop value, +     */, +    private PhraseQuery addSlopToPhrase(PhraseQuery query, int slop) {, +        PhraseQuery.Builder builder = new PhraseQuery.Builder();, +        builder.setSlop(slop);, +        final Term[] terms = query.getTerms();, +        final int[] positions = query.getPositions();, +        for (int i = 0; i < terms.length; ++i) {, +            builder.add(terms[i], positions[i]);, +        }, +, +        return builder.build();, +    }, +, +++ b/core/src/main/java/org/apache/lucene/queryparser/classic/MapperQueryParser.java, +import static java.util.Collections.unmodifiableMap;, +import static org.elasticsearch.common.lucene.search.Queries.fixNegativeQueryIfNeeded;, +, +import org.apache.lucene.search.GraphQuery;, +            return addSlopToPhrase((PhraseQuery) q, slop);, +        } else if (q instanceof GraphQuery && ((GraphQuery) q).hasPhrase()) {, +            // we have a graph query that has at least one phrase sub-query, +            // re-build and set slop on all phrase queries, +            List<Query> oldQueries = ((GraphQuery) q).getQueries();, +            Query[] queries = new Query[oldQueries.size()];, +            for (int i = 0; i < queries.length; i++) {, +                Query oldQuery = oldQueries.get(i);, +                if (oldQuery instanceof PhraseQuery) {, +                    queries[i] = addSlopToPhrase((PhraseQuery) oldQuery, slop);, +                } else {, +                    queries[i] = oldQuery;, +                }, +            }, +, +            return new GraphQuery(queries);, +    /**, +     * Rebuild a phrase query with a slop value, +     */, +    private PhraseQuery addSlopToPhrase(PhraseQuery query, int slop) {, +        PhraseQuery.Builder builder = new PhraseQuery.Builder();, +        builder.setSlop(slop);, +        final Term[] terms = query.getTerms();, +        final int[] positions = query.getPositions();, +        for (int i = 0; i < terms.length; ++i) {, +            builder.add(terms[i], positions[i]);, +        }, +, +        return builder.build();, +    }, +, +++ b/core/src/main/java/org/elasticsearch/common/lucene/search/Queries.java, +import org.apache.lucene.queries.ExtendedCommonTermsQuery;, +import org.apache.lucene.search.GraphQuery;, +    /**, +     * Potentially apply minimum should match value if we have a query that it can be applied to,, +     * otherwise return the original query., +     */, +    public static Query maybeApplyMinimumShouldMatch(Query query, @Nullable String minimumShouldMatch) {, +        // If the coordination factor is disabled on a boolean query we don't apply the minimum should match., +        // This is done to make sure that the minimum_should_match doesn't get applied when there is only one word, +        // and multiple variations of the same word in the query (synonyms for instance)., +        if (query instanceof BooleanQuery && !((BooleanQuery) query).isCoordDisabled()) {, +            return applyMinimumShouldMatch((BooleanQuery) query, minimumShouldMatch);, +        } else if (query instanceof ExtendedCommonTermsQuery) {, +            ((ExtendedCommonTermsQuery)query).setLowFreqMinimumNumberShouldMatch(minimumShouldMatch);, +        } else if (query instanceof GraphQuery && ((GraphQuery) query).hasBoolean()) {, +            // we have a graph query that has at least one boolean sub-query, +            // re-build and set minimum should match value on all boolean queries, +            List<Query> oldQueries = ((GraphQuery) query).getQueries();, +            Query[] queries = new Query[oldQueries.size()];, +            for (int i = 0; i < queries.length; i++) {, +                queries[i] = maybeApplyMinimumShouldMatch(oldQueries.get(i), minimumShouldMatch);, +            }, +, +            return new GraphQuery(queries);, +        }, +, +        return query;]