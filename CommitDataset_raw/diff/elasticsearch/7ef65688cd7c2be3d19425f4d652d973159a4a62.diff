[+++ b/src/main/java/org/elasticsearch/index/query/TopChildrenQueryParser.java, +        TopChildrenQuery childQuery = new TopChildrenQuery(searchContext, query, childType, parentType, scoreType, factor, incrementalFactor);, +++ b/src/main/java/org/elasticsearch/index/query/TopChildrenQueryParser.java, +        TopChildrenQuery childQuery = new TopChildrenQuery(searchContext, query, childType, parentType, scoreType, factor, incrementalFactor);, +++ b/src/main/java/org/elasticsearch/index/search/child/ChildrenQuery.java, + * A query implementation that executes the wrapped child query and connects all the matching child docs to the related, + * parent documents using the {@link IdReaderTypeCache}., + * <p/>, + * This query is executed in two rounds. The first round resolves all the matching child documents and groups these, + * documents by parent uid value. Also the child scores are aggregated per parent uid value. During the second round, + * all parent documents having the same uid value that is collected in the first phase are emitted as hit including, + * a score based on the aggregated child scores and score type., +++ b/src/main/java/org/elasticsearch/index/query/TopChildrenQueryParser.java, +        TopChildrenQuery childQuery = new TopChildrenQuery(searchContext, query, childType, parentType, scoreType, factor, incrementalFactor);, +++ b/src/main/java/org/elasticsearch/index/search/child/ChildrenQuery.java, + * A query implementation that executes the wrapped child query and connects all the matching child docs to the related, + * parent documents using the {@link IdReaderTypeCache}., + * <p/>, + * This query is executed in two rounds. The first round resolves all the matching child documents and groups these, + * documents by parent uid value. Also the child scores are aggregated per parent uid value. During the second round, + * all parent documents having the same uid value that is collected in the first phase are emitted as hit including, + * a score based on the aggregated child scores and score type., +++ b/src/main/java/org/elasticsearch/index/search/child/TopChildrenQuery.java, +import org.elasticsearch.common.CacheRecycler;, +import org.elasticsearch.common.trove.ExtTHashMap;, + * A query that evaluates the top matching child documents (based on the score) in order to determine what, + * parent documents to return. This query tries to find just enough child documents to return the the requested, + * number of parent documents (or less if no other child document can be found)., + * <p/>, + * This query executes several internal searches. In the first round it tries to find ((request offset + requested size) * factor), + * child documents. The resulting child documents are mapped into their parent documents including the aggragted child scores., + * If not enough parent documents could be resolved then a subsequent round is executed, requesting previous requested, + * documents times incremental_factor. This logic repeats until enough parent documents are resolved or until no more, + * child documents are available., + * <p/>, + * This query is most of the times faster than the {@link ChildrenQuery}. Usually enough parent documents can be returned, + * in the first child document query round., +    private final SearchContext searchContext;, +    private final Query query;, +    private final String parentType;, +    private final String childType;, +    private final ScoreType scoreType;, +    private final int factor;, +    private final int incrementalFactor;, +    private boolean properlyInvoked = false;, +    private ExtTHashMap<Object, ParentDoc[]> parentDocs;, +    public TopChildrenQuery(SearchContext searchContext, Query query, String childType, String parentType, ScoreType scoreType, int factor, int incrementalFactor) {, +        this.searchContext = searchContext;, +    private TopChildrenQuery(TopChildrenQuery existing, Query rewrittenChildQuery) {, +        this.searchContext = existing.searchContext;, +        this.query = rewrittenChildQuery;, +        this.parentType = existing.parentType;, +        this.childType = existing.childType;, +        this.scoreType = existing.scoreType;, +        this.factor = existing.factor;, +        this.incrementalFactor = existing.incrementalFactor;, +        this.parentDocs = existing.parentDocs;, +        this.properlyInvoked = existing.properlyInvoked;, +    }, +, +        properlyInvoked = true;, +        this.parentDocs = CacheRecycler.popHashMap();, +        int parentHitsResolved;, +        int numChildDocs = (searchContext.from() + searchContext.size());, +        if (numChildDocs == 0) {, +            numChildDocs = 1;, +        numChildDocs *= factor;, +            parentDocs.clear();, +            TopDocs topChildDocs = searchContext.searcher().search(query, numChildDocs);, +            parentHitsResolved = resolveParentDocuments(topChildDocs, searchContext);, +            if (parentHitsResolved >= (searchContext.from() + searchContext.size())) {, +            if (topChildDocs.totalHits <= numChildDocs) {, +            numChildDocs *= incrementalFactor;, +            if (numChildDocs > topChildDocs.totalHits) {, +                numChildDocs = topChildDocs.totalHits;, +        if (parentDocs != null) {, +            CacheRecycler.pushHashMap(parentDocs);, +        }, +    int resolveParentDocuments(TopDocs topDocs, SearchContext context) {, +        int parentHitsResolved = 0;, +                        parentHitsResolved++; // we have a hit on a parent, +, +        return parentHitsResolved;, +    static class ParentDoc {, +        Query rewrittenChildQuery = query.rewrite(reader);, +        if (rewrittenChildQuery == query) {, +            return this;, +        }, +        int index = searchContext.rewrites().indexOf(this);, +        TopChildrenQuery rewrite = new TopChildrenQuery(this, rewrittenChildQuery);, +        searchContext.rewrites().set(index, rewrite);, +        return rewrite;, +        if (!properlyInvoked) {, +        } else {, +    }]