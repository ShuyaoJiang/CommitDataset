[+++ b/docs/reference/mapping/types/percolator.asciidoc, +if all unmapped fields are handled as if these were default text fields. In those cases one can configure the, +`index.percolator.map_unmapped_fields_as_text` setting to `true` (default to `false`) and then if a field referred in, +a percolator query does not exist, it will be handled as a default text field so that adding the percolator query doesn't, +++ b/docs/reference/mapping/types/percolator.asciidoc, +if all unmapped fields are handled as if these were default text fields. In those cases one can configure the, +`index.percolator.map_unmapped_fields_as_text` setting to `true` (default to `false`) and then if a field referred in, +a percolator query does not exist, it will be handled as a default text field so that adding the percolator query doesn't, +++ b/modules/percolator/src/main/java/org/elasticsearch/percolator/PercolateQueryBuilder.java, +import org.elasticsearch.index.IndexSettings;, +        PercolatorFieldMapper percolatorFieldMapper = (PercolatorFieldMapper) docMapper.mappers().getMapper(field);, +        boolean mapUnmappedFieldsAsString = percolatorFieldMapper.isMapUnmappedFieldAsText();, +++ b/docs/reference/mapping/types/percolator.asciidoc, +if all unmapped fields are handled as if these were default text fields. In those cases one can configure the, +`index.percolator.map_unmapped_fields_as_text` setting to `true` (default to `false`) and then if a field referred in, +a percolator query does not exist, it will be handled as a default text field so that adding the percolator query doesn't, +++ b/modules/percolator/src/main/java/org/elasticsearch/percolator/PercolateQueryBuilder.java, +import org.elasticsearch.index.IndexSettings;, +        PercolatorFieldMapper percolatorFieldMapper = (PercolatorFieldMapper) docMapper.mappers().getMapper(field);, +        boolean mapUnmappedFieldsAsString = percolatorFieldMapper.isMapUnmappedFieldAsText();, +++ b/modules/percolator/src/main/java/org/elasticsearch/percolator/PercolatorFieldMapper.java, +import org.elasticsearch.common.Booleans;, +import org.elasticsearch.common.logging.DeprecationLogger;, +import org.elasticsearch.common.logging.Loggers;, +import org.elasticsearch.index.IndexSettings;, +    @Deprecated, +    static final Setting<Boolean> INDEX_MAP_UNMAPPED_FIELDS_AS_STRING_SETTING = Setting.boolSetting(, +        "index.percolator.map_unmapped_fields_as_string", false, Setting.Property.IndexScope, Setting.Property.Deprecated);, +    static final Setting<Boolean> INDEX_MAP_UNMAPPED_FIELDS_AS_TEXT_SETTING = Setting.boolSetting(, +        "index.percolator.map_unmapped_fields_as_text", false, Setting.Property.IndexScope);, +    private static final DeprecationLogger DEPRECATION_LOGGER = new DeprecationLogger(Loggers.getLogger(PercolatorFieldMapper.class));, +    private final boolean mapUnmappedFieldAsText;, +        this.mapUnmappedFieldAsText = getMapUnmappedFieldAsText(indexSettings);, +    private static boolean getMapUnmappedFieldAsText(Settings indexSettings) {, +        if (INDEX_MAP_UNMAPPED_FIELDS_AS_TEXT_SETTING.exists(indexSettings) &&, +                INDEX_MAP_UNMAPPED_FIELDS_AS_STRING_SETTING.exists(indexSettings)) {, +            throw new IllegalArgumentException("Either specify [" + INDEX_MAP_UNMAPPED_FIELDS_AS_STRING_SETTING.getKey() +, +                    "] or [" + INDEX_MAP_UNMAPPED_FIELDS_AS_TEXT_SETTING.getKey() + "] setting, not both");, +        }, +, +        if (INDEX_MAP_UNMAPPED_FIELDS_AS_STRING_SETTING.exists(indexSettings)) {, +            DEPRECATION_LOGGER.deprecatedAndMaybeLog(INDEX_MAP_UNMAPPED_FIELDS_AS_STRING_SETTING.getKey(),, +                    "The [" + INDEX_MAP_UNMAPPED_FIELDS_AS_STRING_SETTING.getKey() +, +                    "] setting is deprecated in favour for the [" + INDEX_MAP_UNMAPPED_FIELDS_AS_TEXT_SETTING.getKey() + "] setting");, +            return INDEX_MAP_UNMAPPED_FIELDS_AS_STRING_SETTING.get(indexSettings);, +        } else {, +            return INDEX_MAP_UNMAPPED_FIELDS_AS_TEXT_SETTING.get(indexSettings);, +        }, +    }, +, +        Query query = toQuery(queryShardContext, mapUnmappedFieldAsText, queryBuilder);, +    boolean isMapUnmappedFieldAsText() {, +        return mapUnmappedFieldAsText;, +    }, +, +++ b/docs/reference/mapping/types/percolator.asciidoc, +if all unmapped fields are handled as if these were default text fields. In those cases one can configure the, +`index.percolator.map_unmapped_fields_as_text` setting to `true` (default to `false`) and then if a field referred in, +a percolator query does not exist, it will be handled as a default text field so that adding the percolator query doesn't, +++ b/modules/percolator/src/main/java/org/elasticsearch/percolator/PercolateQueryBuilder.java, +import org.elasticsearch.index.IndexSettings;, +        PercolatorFieldMapper percolatorFieldMapper = (PercolatorFieldMapper) docMapper.mappers().getMapper(field);, +        boolean mapUnmappedFieldsAsString = percolatorFieldMapper.isMapUnmappedFieldAsText();, +++ b/modules/percolator/src/main/java/org/elasticsearch/percolator/PercolatorFieldMapper.java, +import org.elasticsearch.common.Booleans;, +import org.elasticsearch.common.logging.DeprecationLogger;, +import org.elasticsearch.common.logging.Loggers;, +import org.elasticsearch.index.IndexSettings;, +    @Deprecated, +    static final Setting<Boolean> INDEX_MAP_UNMAPPED_FIELDS_AS_STRING_SETTING = Setting.boolSetting(, +        "index.percolator.map_unmapped_fields_as_string", false, Setting.Property.IndexScope, Setting.Property.Deprecated);, +    static final Setting<Boolean> INDEX_MAP_UNMAPPED_FIELDS_AS_TEXT_SETTING = Setting.boolSetting(, +        "index.percolator.map_unmapped_fields_as_text", false, Setting.Property.IndexScope);, +    private static final DeprecationLogger DEPRECATION_LOGGER = new DeprecationLogger(Loggers.getLogger(PercolatorFieldMapper.class));, +    private final boolean mapUnmappedFieldAsText;, +        this.mapUnmappedFieldAsText = getMapUnmappedFieldAsText(indexSettings);, +    private static boolean getMapUnmappedFieldAsText(Settings indexSettings) {, +        if (INDEX_MAP_UNMAPPED_FIELDS_AS_TEXT_SETTING.exists(indexSettings) &&, +                INDEX_MAP_UNMAPPED_FIELDS_AS_STRING_SETTING.exists(indexSettings)) {, +            throw new IllegalArgumentException("Either specify [" + INDEX_MAP_UNMAPPED_FIELDS_AS_STRING_SETTING.getKey() +, +                    "] or [" + INDEX_MAP_UNMAPPED_FIELDS_AS_TEXT_SETTING.getKey() + "] setting, not both");, +        }, +, +        if (INDEX_MAP_UNMAPPED_FIELDS_AS_STRING_SETTING.exists(indexSettings)) {, +            DEPRECATION_LOGGER.deprecatedAndMaybeLog(INDEX_MAP_UNMAPPED_FIELDS_AS_STRING_SETTING.getKey(),, +                    "The [" + INDEX_MAP_UNMAPPED_FIELDS_AS_STRING_SETTING.getKey() +, +                    "] setting is deprecated in favour for the [" + INDEX_MAP_UNMAPPED_FIELDS_AS_TEXT_SETTING.getKey() + "] setting");, +            return INDEX_MAP_UNMAPPED_FIELDS_AS_STRING_SETTING.get(indexSettings);, +        } else {, +            return INDEX_MAP_UNMAPPED_FIELDS_AS_TEXT_SETTING.get(indexSettings);, +        }, +    }, +, +        Query query = toQuery(queryShardContext, mapUnmappedFieldAsText, queryBuilder);, +    boolean isMapUnmappedFieldAsText() {, +        return mapUnmappedFieldAsText;, +    }, +, +++ b/modules/percolator/src/main/java/org/elasticsearch/percolator/PercolatorPlugin.java, +import java.util.Arrays;]