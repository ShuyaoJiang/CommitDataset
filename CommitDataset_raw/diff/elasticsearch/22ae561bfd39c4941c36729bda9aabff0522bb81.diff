[+++ b/src/main/java/org/elasticsearch/gateway/GatewayAllocator.java, +import com.google.common.collect.Lists;, +import org.apache.lucene.util.CollectionUtil;, +import org.elasticsearch.index.settings.IndexSettings;, +import java.util.*;, +    /**, +     * Return {@code true} if the index is configured to allow shards to be, +     * recovered on any node, +     */, +    private boolean recoverOnAnyNode(@IndexSettings Settings idxSettings) {, +        return IndexMetaData.isOnSharedFilesystem(idxSettings) &&, +                idxSettings.getAsBoolean(IndexMetaData.SETTING_SHARED_FS_ALLOW_RECOVERY_ON_ANY_NODE, false);, +    }, +, +            final Map<DiscoveryNode, Long> nodesWithVersion = Maps.newHashMap();, +            IndexMetaData indexMetaData = routingNodes.metaData().index(shard.index());, +            Settings idxSettings = indexMetaData.settings();, +                if (recoverOnAnyNode(idxSettings)) {, +                    }, +                    // We always put the node without clearing the map, +                    nodesWithVersion.put(node, version);, +                } else if (version != -1) {, +                    numberOfAllocationsFound++;, +                    // If we've found a new "best" candidate, clear the, +                    // current candidates and add it, +                    if (version > highestVersion) {, +                        highestVersion = version;, +                        nodesWithVersion.clear();, +                        nodesWithVersion.put(node, version);, +                        // If the candidate is the same, add it to the, +                        // list, but keep the current candidate, +                        nodesWithVersion.put(node, version);, +            // Now that we have a map of nodes to versions along with the, +            // number of allocations found (and not ignored), we need to sort, +            // it so the node with the highest version is at the beginning, +            List<DiscoveryNode> nodesWithHighestVersion = Lists.newArrayList();, +            nodesWithHighestVersion.addAll(nodesWithVersion.keySet());, +            CollectionUtil.timSort(nodesWithHighestVersion, new Comparator<DiscoveryNode>() {, +                @Override, +                public int compare(DiscoveryNode o1, DiscoveryNode o2) {, +                    return Long.compare(nodesWithVersion.get(o2), nodesWithVersion.get(o1));, +                }, +            });, +, +            if (logger.isDebugEnabled()) {, +                logger.debug("[{}][{}] found {} allocations of {}, highest version: [{}]",, +                        shard.index(), shard.id(), numberOfAllocationsFound, shard, highestVersion);, +            }, +            if (logger.isTraceEnabled()) {, +                StringBuilder sb = new StringBuilder("[");, +                for (DiscoveryNode n : nodesWithHighestVersion) {, +                    sb.append("[");, +                    sb.append(n.getName());, +                    sb.append("]");, +                    sb.append(" -> ");, +                    sb.append(nodesWithVersion.get(n));, +                    sb.append(", ");, +                }, +                sb.append("]");, +                logger.trace("{} candidates for allocation: {}", shard, sb.toString());, +++ b/src/main/java/org/elasticsearch/gateway/GatewayAllocator.java, +import com.google.common.collect.Lists;, +import org.apache.lucene.util.CollectionUtil;, +import org.elasticsearch.index.settings.IndexSettings;, +import java.util.*;, +    /**, +     * Return {@code true} if the index is configured to allow shards to be, +     * recovered on any node, +     */, +    private boolean recoverOnAnyNode(@IndexSettings Settings idxSettings) {, +        return IndexMetaData.isOnSharedFilesystem(idxSettings) &&, +                idxSettings.getAsBoolean(IndexMetaData.SETTING_SHARED_FS_ALLOW_RECOVERY_ON_ANY_NODE, false);, +    }, +, +            final Map<DiscoveryNode, Long> nodesWithVersion = Maps.newHashMap();, +            IndexMetaData indexMetaData = routingNodes.metaData().index(shard.index());, +            Settings idxSettings = indexMetaData.settings();, +                if (recoverOnAnyNode(idxSettings)) {, +                    }, +                    // We always put the node without clearing the map, +                    nodesWithVersion.put(node, version);, +                } else if (version != -1) {, +                    numberOfAllocationsFound++;, +                    // If we've found a new "best" candidate, clear the, +                    // current candidates and add it, +                    if (version > highestVersion) {, +                        highestVersion = version;, +                        nodesWithVersion.clear();, +                        nodesWithVersion.put(node, version);, +                        // If the candidate is the same, add it to the, +                        // list, but keep the current candidate, +                        nodesWithVersion.put(node, version);, +            // Now that we have a map of nodes to versions along with the, +            // number of allocations found (and not ignored), we need to sort, +            // it so the node with the highest version is at the beginning, +            List<DiscoveryNode> nodesWithHighestVersion = Lists.newArrayList();, +            nodesWithHighestVersion.addAll(nodesWithVersion.keySet());, +            CollectionUtil.timSort(nodesWithHighestVersion, new Comparator<DiscoveryNode>() {, +                @Override, +                public int compare(DiscoveryNode o1, DiscoveryNode o2) {]