[+++ b/src/main/java/org/elasticsearch/index/query/functionscore/DecayFunctionBuilder.java, +    protected static final String ORIGIN = "origin";, +    private Object origin;, +    public DecayFunctionBuilder(String fieldName, Object origin, Object scale) {, +        this.origin = origin;, +        builder.field(ORIGIN, origin);, +++ b/src/main/java/org/elasticsearch/index/query/functionscore/DecayFunctionBuilder.java, +    protected static final String ORIGIN = "origin";, +    private Object origin;, +    public DecayFunctionBuilder(String fieldName, Object origin, Object scale) {, +        this.origin = origin;, +        builder.field(ORIGIN, origin);, +++ b/src/main/java/org/elasticsearch/index/query/functionscore/DecayFunctionParser.java, + *          "origin" = "someValue", , + * "origin" here refers to the reference point and "scale" to the level of, + * uncertainty you have in your origin., + * was a week before or after that. Your "origin" for the date field would be, + * parameters origin and scale., +     *          "origin" = "someValue", , +                // parse per field the origin and scale value, +    // parses origin and scale parameter for field "fieldName", +        double origin = 0;, +            } else if (parameterName.equals(DecayFunctionBuilder.ORIGIN)) {, +                origin = parser.doubleValue();, +            throw new ElasticSearchParseException("Both " + DecayFunctionBuilder.SCALE + "and " + DecayFunctionBuilder.ORIGIN, +        return new NumericFieldDataScoreFunction(origin, scale, decay, offset, getDecayFunction(), numericFieldData);, +        GeoPoint origin = new GeoPoint();, +            } else if (parameterName.equals(DecayFunctionBuilder.ORIGIN)) {, +                origin = GeoPoint.parse(parser);, +        if (origin == null) {, +            throw new ElasticSearchParseException(DecayFunctionBuilder.ORIGIN + "must be set for geo fields.");, +        return new GeoFieldDataScoreFunction(origin, scale, decay, offset, getDecayFunction(), indexFieldData);, +        String originString = null;, +            } else if (parameterName.equals(DecayFunctionBuilder.ORIGIN)) {, +                originString = parser.text();, +        long origin = SearchContext.current().nowInMillis();, +        if (originString != null) {, +            origin = dateFieldMapper.value(originString).longValue();, +        return new NumericFieldDataScoreFunction(origin, scale, decay, offset, getDecayFunction(), numericFieldData);, +        private final GeoPoint origin;, +        public GeoFieldDataScoreFunction(GeoPoint origin, double scale, double decay, double offset, DecayFunction func,, +            this.origin = origin;, +            GeoPoint other = geoPointValues.getValueMissing(docId, origin);, +            double distance = Math.abs(distFunction.calculate(origin.lat(), origin.lon(), other.lat(), other.lon(),, +            final GeoPoint other = geoPointValues.getValueMissing(docId, origin);, +            return "arcDistance(" + other + "(=doc value), " + origin + "(=origin)) - " + offset, +                    + "(=offset) < 0.0 ? 0.0: arcDistance(" + other + "(=doc value), " + origin + "(=origin)) - " + offset, +        private final double origin;, +        public NumericFieldDataScoreFunction(double origin, double scale, double decay, double offset, DecayFunction func,, +            this.origin = origin;, +            double distance = Math.abs(doubleValues.getValueMissing(docId, origin) - origin) - offset;, +            return "Math.abs(" + doubleValues.getValueMissing(docId, origin) + "(=doc value) - " + origin + "(=origin)) - ", +                    + offset + "(=offset) < 0.0 ? 0.0: Math.abs(" + doubleValues.getValueMissing(docId, origin) + "(=doc value) - ", +                    + origin + ") - " + offset + "(=offset)";, +         * This function computes the distance from a defined origin. Since, +++ b/src/main/java/org/elasticsearch/index/query/functionscore/DecayFunctionBuilder.java, +    protected static final String ORIGIN = "origin";, +    private Object origin;, +    public DecayFunctionBuilder(String fieldName, Object origin, Object scale) {, +        this.origin = origin;, +        builder.field(ORIGIN, origin);, +++ b/src/main/java/org/elasticsearch/index/query/functionscore/DecayFunctionParser.java, + *          "origin" = "someValue", , + * "origin" here refers to the reference point and "scale" to the level of, + * uncertainty you have in your origin., + * was a week before or after that. Your "origin" for the date field would be, + * parameters origin and scale., +     *          "origin" = "someValue", , +                // parse per field the origin and scale value, +    // parses origin and scale parameter for field "fieldName", +        double origin = 0;, +            } else if (parameterName.equals(DecayFunctionBuilder.ORIGIN)) {, +                origin = parser.doubleValue();, +            throw new ElasticSearchParseException("Both " + DecayFunctionBuilder.SCALE + "and " + DecayFunctionBuilder.ORIGIN, +        return new NumericFieldDataScoreFunction(origin, scale, decay, offset, getDecayFunction(), numericFieldData);, +        GeoPoint origin = new GeoPoint();, +            } else if (parameterName.equals(DecayFunctionBuilder.ORIGIN)) {, +                origin = GeoPoint.parse(parser);, +        if (origin == null) {, +            throw new ElasticSearchParseException(DecayFunctionBuilder.ORIGIN + "must be set for geo fields.");, +        return new GeoFieldDataScoreFunction(origin, scale, decay, offset, getDecayFunction(), indexFieldData);, +        String originString = null;, +            } else if (parameterName.equals(DecayFunctionBuilder.ORIGIN)) {, +                originString = parser.text();, +        long origin = SearchContext.current().nowInMillis();, +        if (originString != null) {, +            origin = dateFieldMapper.value(originString).longValue();, +        return new NumericFieldDataScoreFunction(origin, scale, decay, offset, getDecayFunction(), numericFieldData);, +        private final GeoPoint origin;, +        public GeoFieldDataScoreFunction(GeoPoint origin, double scale, double decay, double offset, DecayFunction func,, +            this.origin = origin;, +            GeoPoint other = geoPointValues.getValueMissing(docId, origin);, +            double distance = Math.abs(distFunction.calculate(origin.lat(), origin.lon(), other.lat(), other.lon(),, +            final GeoPoint other = geoPointValues.getValueMissing(docId, origin);, +            return "arcDistance(" + other + "(=doc value), " + origin + "(=origin)) - " + offset, +                    + "(=offset) < 0.0 ? 0.0: arcDistance(" + other + "(=doc value), " + origin + "(=origin)) - " + offset, +        private final double origin;, +        public NumericFieldDataScoreFunction(double origin, double scale, double decay, double offset, DecayFunction func,, +            this.origin = origin;, +            double distance = Math.abs(doubleValues.getValueMissing(docId, origin) - origin) - offset;]