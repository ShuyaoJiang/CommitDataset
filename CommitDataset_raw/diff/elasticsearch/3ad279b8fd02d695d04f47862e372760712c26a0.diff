[+++ b/src/main/java/org/elasticsearch/action/admin/indices/cache/clear/TransportClearIndicesCacheAction.java, +            // we always clear the query cache, +            service.cache().queryParserCache().clear();, +++ b/src/main/java/org/elasticsearch/action/admin/indices/cache/clear/TransportClearIndicesCacheAction.java, +            // we always clear the query cache, +            service.cache().queryParserCache().clear();, +++ b/src/main/java/org/elasticsearch/common/util/concurrent/KeyedLock.java, +    private final boolean fair;, +, +    /**, +     * @param fair Use fair locking, ie threads get the lock in the order they requested it, +     */, +    public KeyedLock(boolean fair) {, +        this.fair = fair;, +    }, +, +    public KeyedLock() {, +        this(false);, +    }, +, +                KeyLock newLock = new KeyLock(fair);, +        KeyLock(boolean fair) {, +            super(fair);, +        }, +, +, +        private final ReadWriteLock lock;, +, +        public GlobalLockable(boolean fair){, +            super(fair);, +            lock = new ReentrantReadWriteLock(fair);, +        }, +, +        public GlobalLockable() {, +            this(false);, +        }, +++ b/src/main/java/org/elasticsearch/action/admin/indices/cache/clear/TransportClearIndicesCacheAction.java, +            // we always clear the query cache, +            service.cache().queryParserCache().clear();, +++ b/src/main/java/org/elasticsearch/common/util/concurrent/KeyedLock.java, +    private final boolean fair;, +, +    /**, +     * @param fair Use fair locking, ie threads get the lock in the order they requested it, +     */, +    public KeyedLock(boolean fair) {, +        this.fair = fair;, +    }, +, +    public KeyedLock() {, +        this(false);, +    }, +, +                KeyLock newLock = new KeyLock(fair);, +        KeyLock(boolean fair) {, +            super(fair);, +        }, +, +, +        private final ReadWriteLock lock;, +, +        public GlobalLockable(boolean fair){, +            super(fair);, +            lock = new ReentrantReadWriteLock(fair);, +        }, +, +        public GlobalLockable() {, +            this(false);, +        }, +++ b/src/main/java/org/elasticsearch/index/cache/IndexCache.java, +import org.elasticsearch.ElasticsearchException;, +import org.elasticsearch.cluster.ClusterChangedEvent;, +import org.elasticsearch.cluster.ClusterService;, +import org.elasticsearch.cluster.ClusterStateListener;, +import org.elasticsearch.common.Nullable;, +import org.elasticsearch.index.cache.query.parser.QueryParserCache;, +public class IndexCache extends AbstractIndexComponent implements Closeable, ClusterStateListener {, +    private final QueryParserCache queryParserCache;, +    private ClusterService clusterService;, +, +    public IndexCache(Index index, @IndexSettings Settings indexSettings, FilterCache filterCache, QueryParserCache queryParserCache, BitsetFilterCache bitsetFilterCache) {, +        this.queryParserCache = queryParserCache;, +    @Inject(optional = true), +    public void setClusterService(@Nullable ClusterService clusterService) {, +        this.clusterService = clusterService;, +        if (clusterService != null) {, +            clusterService.add(this);, +        }, +    }, +, +    public QueryParserCache queryParserCache() {, +        return this.queryParserCache;, +    }, +, +        IOUtils.close(filterCache, queryParserCache, bitsetFilterCache);, +        if (clusterService != null) {, +            clusterService.remove(this);, +        }, +        queryParserCache.clear();, +    @Override]