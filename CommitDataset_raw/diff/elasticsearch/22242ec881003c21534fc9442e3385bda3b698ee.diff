[+++ b/core/src/main/java/org/elasticsearch/common/io/stream/StreamOutput.java, +import java.util.Iterator;, +     * write map to stream with consistent order, +     * to make sure every map generated bytes order are same., +     * This method is compatible with {@code StreamInput.readMap} and {@code StreamInput.readGenericValue}, +     * This method only will handle the map keys order, not maps contained within the map, +     */, +    public void writeMapWithConsistentOrder(@Nullable Map<String, ? extends Object> map), +        throws IOException {, +        if (map == null) {, +            writeByte((byte) -1);, +            return;, +        }, +        assert false == (map instanceof LinkedHashMap);, +        this.writeByte((byte) 10);, +        this.writeVInt(map.size());, +        Iterator<? extends Map.Entry<String, ?>> iterator =, +            map.entrySet().stream().sorted((a, b) -> a.getKey().compareTo(b.getKey())).iterator();, +        while (iterator.hasNext()) {, +            Map.Entry<String, ?> next = iterator.next();, +            this.writeString(next.getKey());, +            this.writeGenericValue(next.getValue());, +        }, +    }, +, +    /**, +    /**, +     * Notice: when serialization a map, the stream out map with the stream in map maybe have the, +     * different key-value orders, they will maybe have different stream order., +     * If want to keep stream out map and stream in map have the same stream order when stream,, +     * can use {@code writeMapWithConsistentOrder}, +     */, +++ b/core/src/main/java/org/elasticsearch/common/io/stream/StreamOutput.java, +import java.util.Iterator;, +     * write map to stream with consistent order, +     * to make sure every map generated bytes order are same., +     * This method is compatible with {@code StreamInput.readMap} and {@code StreamInput.readGenericValue}, +     * This method only will handle the map keys order, not maps contained within the map, +     */, +    public void writeMapWithConsistentOrder(@Nullable Map<String, ? extends Object> map), +        throws IOException {, +        if (map == null) {, +            writeByte((byte) -1);, +            return;, +        }, +        assert false == (map instanceof LinkedHashMap);, +        this.writeByte((byte) 10);, +        this.writeVInt(map.size());, +        Iterator<? extends Map.Entry<String, ?>> iterator =, +            map.entrySet().stream().sorted((a, b) -> a.getKey().compareTo(b.getKey())).iterator();, +        while (iterator.hasNext()) {, +            Map.Entry<String, ?> next = iterator.next();, +            this.writeString(next.getKey());, +            this.writeGenericValue(next.getValue());, +        }, +    }, +, +    /**, +    /**, +     * Notice: when serialization a map, the stream out map with the stream in map maybe have the, +     * different key-value orders, they will maybe have different stream order., +     * If want to keep stream out map and stream in map have the same stream order when stream,, +     * can use {@code writeMapWithConsistentOrder}, +     */, +++ b/core/src/main/java/org/elasticsearch/search/builder/SearchSourceBuilder.java, +import org.elasticsearch.common.collect.Tuple;, +import java.util.stream.Collectors;, +import java.util.stream.StreamSupport;, +, +import static org.elasticsearch.common.collect.Tuple.tuple;, +        int indexBoostSize = in.readVInt();, +        if (indexBoostSize > 0) {, +            indexBoost = new ObjectFloatHashMap<>(indexBoostSize);, +            for (int i = 0; i < indexBoostSize; i++) {, +        int indexBoostSize = indexBoost == null ? 0 : indexBoost.size();, +        out.writeVInt(indexBoostSize);, +        if (indexBoostSize > 0) {, +            writeIndexBoost(out);, +    private void writeIndexBoost(StreamOutput out) throws IOException {, +        List<Tuple<String, Float>> ibs = StreamSupport, +            .stream(indexBoost.spliterator(), false), +            .map(i -> tuple(i.key, i.value)).sorted((o1, o2) -> o1.v1().compareTo(o2.v1())), +            .collect(Collectors.toList());, +        for (Tuple<String, Float> ib : ibs) {, +            out.writeString(ib.v1());, +            out.writeFloat(ib.v2());, +        }, +    }, +, +++ b/core/src/main/java/org/elasticsearch/common/io/stream/StreamOutput.java, +import java.util.Iterator;, +     * write map to stream with consistent order, +     * to make sure every map generated bytes order are same., +     * This method is compatible with {@code StreamInput.readMap} and {@code StreamInput.readGenericValue}, +     * This method only will handle the map keys order, not maps contained within the map, +     */, +    public void writeMapWithConsistentOrder(@Nullable Map<String, ? extends Object> map), +        throws IOException {, +        if (map == null) {, +            writeByte((byte) -1);]