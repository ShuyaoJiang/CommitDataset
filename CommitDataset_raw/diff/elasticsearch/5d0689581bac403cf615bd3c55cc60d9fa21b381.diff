[+++ b/core/src/main/java/org/elasticsearch/ElasticsearchException.java, +        MERGE_MAPPING_EXCEPTION(org.elasticsearch.index.mapper.MergeMappingException.class, org.elasticsearch.index.mapper.MergeMappingException::new, 87),, +++ b/core/src/main/java/org/elasticsearch/ElasticsearchException.java, +        MERGE_MAPPING_EXCEPTION(org.elasticsearch.index.mapper.MergeMappingException.class, org.elasticsearch.index.mapper.MergeMappingException::new, 87),, +++ b/core/src/main/java/org/elasticsearch/cluster/metadata/MetaDataMappingService.java, +import org.elasticsearch.index.mapper.MergeMappingException;, +                            throw new MergeMappingException(mergeResult.buildConflicts());, +++ b/core/src/main/java/org/elasticsearch/ElasticsearchException.java, +        MERGE_MAPPING_EXCEPTION(org.elasticsearch.index.mapper.MergeMappingException.class, org.elasticsearch.index.mapper.MergeMappingException::new, 87),, +++ b/core/src/main/java/org/elasticsearch/cluster/metadata/MetaDataMappingService.java, +import org.elasticsearch.index.mapper.MergeMappingException;, +                            throw new MergeMappingException(mergeResult.buildConflicts());, +++ b/core/src/main/java/org/elasticsearch/common/geo/builders/LineStringBuilder.java, +++ b/core/src/main/java/org/elasticsearch/ElasticsearchException.java, +        MERGE_MAPPING_EXCEPTION(org.elasticsearch.index.mapper.MergeMappingException.class, org.elasticsearch.index.mapper.MergeMappingException::new, 87),, +++ b/core/src/main/java/org/elasticsearch/cluster/metadata/MetaDataMappingService.java, +import org.elasticsearch.index.mapper.MergeMappingException;, +                            throw new MergeMappingException(mergeResult.buildConflicts());, +++ b/core/src/main/java/org/elasticsearch/common/geo/builders/LineStringBuilder.java, +++ b/core/src/main/java/org/elasticsearch/common/geo/builders/MultiPolygonBuilder.java, +++ b/core/src/main/java/org/elasticsearch/ElasticsearchException.java, +        MERGE_MAPPING_EXCEPTION(org.elasticsearch.index.mapper.MergeMappingException.class, org.elasticsearch.index.mapper.MergeMappingException::new, 87),, +++ b/core/src/main/java/org/elasticsearch/cluster/metadata/MetaDataMappingService.java, +import org.elasticsearch.index.mapper.MergeMappingException;, +                            throw new MergeMappingException(mergeResult.buildConflicts());, +++ b/core/src/main/java/org/elasticsearch/common/geo/builders/LineStringBuilder.java, +++ b/core/src/main/java/org/elasticsearch/common/geo/builders/MultiPolygonBuilder.java, +++ b/core/src/main/java/org/elasticsearch/common/geo/builders/PolygonBuilder.java, +import java.util.concurrent.atomic.AtomicBoolean;, +        final AtomicBoolean translated = new AtomicBoolean(false);, +        int offset = createEdges(0, orientation, shell, null, edges, 0, translated);, +            int length = createEdges(i+1, orientation, shell, this.holes.get(i), edges, offset, translated);, +                                   LineStringBuilder hole, Edge[] edges, int offset, final AtomicBoolean translated) {, +        ring(component, direction, orientation == Orientation.LEFT, shell, points, 0, edges, offset, points.length-1, translated);, +, +    /**, +     * Create a connected list of a list of coordinates, +     *, +     * @param points, +     *            array of point, +     * @param offset, +     *            index of the first point, +     * @param length, +     *            number of points, +     * @return Array of edges, +     */, +    private static Edge[] ring(int component, boolean direction, boolean handedness, LineStringBuilder shell,, +                                 Coordinate[] points, int offset, Edge[] edges, int toffset, int length, final AtomicBoolean translated) {, +        // calculate the direction of the points:, +        // find the point a the top of the set and check its, +        // neighbors orientation. So direction is equivalent, +        // to clockwise/counterclockwise, +        final int top = top(points, offset, length);, +        final int prev = (offset + ((top + length - 1) % length));, +        final int next = (offset + ((top + 1) % length));, +        boolean orientation = points[offset + prev].x > points[offset + next].x;, +, +        // OGC requires shell as ccw (Right-Handedness) and holes as cw (Left-Handedness), +        // since GeoJSON doesn't specify (and doesn't need to) GEO core will assume OGC standards, +        // thus if orientation is computed as cw, the logic will translate points across dateline, +        // and convert to a right handed system, +, +        // compute the bounding box and calculate range, +        double[] range = range(points, offset, length);, +        final double rng = range[1] - range[0];, +        // translate the points if the following is true, +        //   1.  shell orientation is cw and range is greater than a hemisphere (180 degrees) but not spanning 2 hemispheres, +        //       (translation would result in a collapsed poly), +        //   2.  the shell of the candidate hole has been translated (to preserve the coordinate system), +        boolean incorrectOrientation = component == 0 && handedness != orientation;, +        if ( (incorrectOrientation && (rng > DATELINE && rng != 2*DATELINE)) || (translated.get() && component != 0)) {, +            translate(points);, +            // flip the translation bit if the shell is being translated, +            if (component == 0) {, +                translated.set(true);, +            }, +            // correct the orientation post translation (ccw for shell, cw for holes), +            if (component == 0 || (component != 0 && handedness == orientation)) {, +                orientation = !orientation;, +            }, +        }, +        return concat(component, direction ^ orientation, points, offset, edges, toffset, length);, +    }, +, +    private static final int top(Coordinate[] points, int offset, int length) {, +        int top = 0; // we start at 1 here since top points to 0, +        for (int i = 1; i < length; i++) {, +            if (points[offset + i].y < points[offset + top].y) {, +                top = i;, +            } else if (points[offset + i].y == points[offset + top].y) {, +                if (points[offset + i].x < points[offset + top].x) {, +                    top = i;, +                }, +            }, +        }, +        return top;, +    }, +, +    private static final double[] range(Coordinate[] points, int offset, int length) {, +        double minX = points[0].x;]