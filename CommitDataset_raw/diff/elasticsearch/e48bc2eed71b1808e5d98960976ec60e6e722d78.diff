[+++ b/core/src/main/java/org/apache/lucene/search/grouping/CollapseTopFieldDocs.java, +/*, + * Licensed to Elasticsearch under one or more contributor, + * license agreements. See the NOTICE file distributed with, + * this work for additional information regarding copyright, + * ownership. Elasticsearch licenses this file to you under, + * the Apache License, Version 2.0 (the "License"); you may, + * not use this file except in compliance with the License., + * You may obtain a copy of the License at, + *, + *    http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing,, + * software distributed under the License is distributed on an, + * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY, + * KIND, either express or implied.  See the License for the, + * specific language governing permissions and limitations, + * under the License., + */, +package org.apache.lucene.search.grouping;, +, +import org.apache.lucene.search.FieldComparator;, +import org.apache.lucene.search.FieldDoc;, +import org.apache.lucene.search.ScoreDoc;, +import org.apache.lucene.search.Sort;, +import org.apache.lucene.search.SortField;, +import org.apache.lucene.search.TopFieldDocs;, +import org.apache.lucene.util.PriorityQueue;, +, +import java.io.IOException;, +import java.util.ArrayList;, +import java.util.HashSet;, +import java.util.List;, +import java.util.Set;, +, +/**, + * Represents hits returned by {@link CollapsingTopDocsCollector#getTopDocs()}., + */, +public class CollapseTopFieldDocs extends TopFieldDocs {, +    /** The field used for collapsing **/, +    public final String field;, +    /** The collapse value for each top doc */, +    public final Object[] collapseValues;, +, +    public CollapseTopFieldDocs(String field, int totalHits, ScoreDoc[] scoreDocs,, +                                SortField[] sortFields, Object[] values, float maxScore) {, +        super(totalHits, scoreDocs, sortFields, maxScore);, +        this.field = field;, +        this.collapseValues = values;, +    }, +, +    // Refers to one hit:, +    private static class ShardRef {, +        // Which shard (index into shardHits[]):, +        final int shardIndex;, +, +        // Which hit within the shard:, +        int hitIndex;, +, +        public ShardRef(int shardIndex) {, +            this.shardIndex = shardIndex;, +        }, +, +        @Override, +        public String toString() {, +            return "ShardRef(shardIndex=" + shardIndex + " hitIndex=" + hitIndex + ")";, +        }, +    };, +, +    private static class MergeSortQueue extends PriorityQueue<ShardRef> {, +        // These are really FieldDoc instances:, +        final ScoreDoc[][] shardHits;, +        final FieldComparator<?>[] comparators;, +        final int[] reverseMul;, +, +        public MergeSortQueue(Sort sort, CollapseTopFieldDocs[] shardHits) throws IOException {, +            super(shardHits.length);, +            this.shardHits = new ScoreDoc[shardHits.length][];, +            for (int shardIDX = 0; shardIDX < shardHits.length; shardIDX++) {, +                final ScoreDoc[] shard = shardHits[shardIDX].scoreDocs;, +                if (shard != null) {, +                    this.shardHits[shardIDX] = shard;, +                    // Fail gracefully if API is misused:, +                    for (int hitIDX = 0; hitIDX < shard.length; hitIDX++) {, +                        final ScoreDoc sd = shard[hitIDX];, +                        final FieldDoc gd = (FieldDoc) sd;, +                        assert gd.fields != null;, +                    }, +                }, +            }, +, +            final SortField[] sortFields = sort.getSort();, +            comparators = new FieldComparator[sortFields.length];, +            reverseMul = new int[sortFields.length];, +            for (int compIDX = 0; compIDX < sortFields.length; compIDX++) {, +                final SortField sortField = sortFields[compIDX];, +                comparators[compIDX] = sortField.getComparator(1, compIDX);, +                reverseMul[compIDX] = sortField.getReverse() ? -1 : 1;, +            }, +        }]