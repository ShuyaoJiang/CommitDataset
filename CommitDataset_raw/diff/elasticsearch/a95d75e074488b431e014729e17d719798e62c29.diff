[+++ b/src/main/java/org/elasticsearch/index/mapper/DocumentMapper.java, +, +        XContentBuilder builder = XContentFactory.contentBuilder(parser.contentType()).value(transformed);, +        return parser.contentType().xContent().createParser(builder.bytes());, +++ b/src/main/java/org/elasticsearch/index/mapper/DocumentMapper.java, +, +        XContentBuilder builder = XContentFactory.contentBuilder(parser.contentType()).value(transformed);, +        return parser.contentType().xContent().createParser(builder.bytes());, +++ b/src/test/java/org/elasticsearch/index/mapper/TransformOnIndexMapperIntegrationTest.java, +, +import org.elasticsearch.action.suggest.SuggestResponse;, +import org.elasticsearch.common.xcontent.XContentType;, +import org.elasticsearch.search.suggest.SuggestBuilders;, +import org.elasticsearch.search.suggest.completion.CompletionSuggestion;, +import static org.elasticsearch.test.hamcrest.ElasticsearchAssertions.assertAcked;, +import static org.elasticsearch.test.hamcrest.ElasticsearchAssertions.assertExists;, +import static org.elasticsearch.test.hamcrest.ElasticsearchAssertions.assertHitCount;, +import static org.elasticsearch.test.hamcrest.ElasticsearchAssertions.assertSearchHits;, +import static org.elasticsearch.test.hamcrest.ElasticsearchAssertions.assertSuggestion;, +import static org.hamcrest.Matchers.both;, +import static org.hamcrest.Matchers.hasEntry;, +import static org.hamcrest.Matchers.hasKey;, +import static org.hamcrest.Matchers.not;, +        setup(true);, +    // TODO: the completion suggester currently returns payloads with no reencoding so this test, +    // exists to make sure that _source transformation and completion work well together. If we, +    // ever fix the completion suggester to reencode the payloads then we can remove this test., +    @Test, +    public void contextSuggestPayloadTransformed() throws Exception {, +        XContentBuilder builder = XContentFactory.jsonBuilder().startObject();, +        builder.startObject("properties");, +        builder.startObject("suggest").field("type", "completion").field("payloads", true).endObject();, +        builder.endObject();, +        builder.startObject("transform");, +        builder.field("script", "ctx._source.suggest = ['input': ctx._source.text];ctx._source.suggest.payload = ['display': ctx._source.text, 'display_detail': 'on the fly']");, +        builder.field("lang", "groovy");, +        builder.endObject();, +        assertAcked(client().admin().indices().prepareCreate("test").addMapping("test", builder));, +        // Payload is stored using original source format (json, smile, yaml, whatever), +        XContentType type = XContentType.values()[between(0, XContentType.values().length - 1)];, +        XContentBuilder source = XContentFactory.contentBuilder(type);, +        source.startObject().field("text", "findme").endObject();, +        indexRandom(true, client().prepareIndex("test", "test", "findme").setSource(source));, +        SuggestResponse response = client().prepareSuggest("test").addSuggestion(, +                SuggestBuilders.completionSuggestion("test").field("suggest").text("findme")).get();, +        assertSuggestion(response.getSuggest(), 0, 0, "test", "findme");, +        CompletionSuggestion.Entry.Option option = (CompletionSuggestion.Entry.Option)response.getSuggest().getSuggestion("test").getEntries().get(0).getOptions().get(0);, +        // And it comes back in exactly that way., +        XContentBuilder expected = XContentFactory.contentBuilder(type);, +        expected.startObject().field("display", "findme").field("display_detail", "on the fly").endObject();, +        assertEquals(expected.string(), option.getPayloadAsString());, +    }, +, +     * @param forceRefresh, +    private void setup(boolean forceRefresh) throws IOException, InterruptedException, ExecutionException {, +        indexRandom(forceRefresh, client().prepareIndex("test", "test", "notitle").setSource("content", "findme"),]