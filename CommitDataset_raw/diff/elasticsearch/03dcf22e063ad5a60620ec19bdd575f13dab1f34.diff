[+++ b/server/src/main/java/org/elasticsearch/common/util/SingleObjectCache.java, +    /** Return the potentially stale cached entry. */, +    protected final T getNoRefresh() {, +        return cached;, +    }, +, +++ b/server/src/main/java/org/elasticsearch/common/util/SingleObjectCache.java, +    /** Return the potentially stale cached entry. */, +    protected final T getNoRefresh() {, +        return cached;, +    }, +, +++ b/server/src/main/java/org/elasticsearch/index/store/ByteSizeCachingDirectory.java, +/*, + * Licensed to Elasticsearch under one or more contributor, + * license agreements. See the NOTICE file distributed with, + * this work for additional information regarding copyright, + * ownership. Elasticsearch licenses this file to you under, + * the Apache License, Version 2.0 (the "License"); you may, + * not use this file except in compliance with the License., + * You may obtain a copy of the License at, + *, + *    http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing,, + * software distributed under the License is distributed on an, + * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY, + * KIND, either express or implied.  See the License for the, + * specific language governing permissions and limitations, + * under the License., + */, +, +package org.elasticsearch.index.store;, +, +import org.apache.lucene.store.Directory;, +import org.apache.lucene.store.FilterDirectory;, +import org.apache.lucene.store.IOContext;, +import org.apache.lucene.store.IndexOutput;, +import org.elasticsearch.common.lucene.store.FilterIndexOutput;, +import org.elasticsearch.common.unit.TimeValue;, +import org.elasticsearch.common.util.SingleObjectCache;, +, +import java.io.FileNotFoundException;, +import java.io.IOException;, +import java.io.UncheckedIOException;, +import java.nio.file.AccessDeniedException;, +import java.nio.file.NoSuchFileException;, +, +final class ByteSizeCachingDirectory extends FilterDirectory {, +, +    private static class SizeAndModCount {, +        final long size;, +        final long modCount;, +        final boolean pendingWrite;, +, +        SizeAndModCount(long length, long modCount, boolean pendingWrite) {, +            this.size = length;, +            this.modCount = modCount;, +            this.pendingWrite = pendingWrite;, +        }, +    }, +, +    private static long estimateSizeInBytes(Directory directory) throws IOException {, +        long estimatedSize = 0;, +        String[] files = directory.listAll();, +        for (String file : files) {, +            try {, +                estimatedSize += directory.fileLength(file);, +            } catch (NoSuchFileException | FileNotFoundException | AccessDeniedException e) {, +                // ignore, the file is not there no more; on Windows, if one thread concurrently deletes a file while, +                // calling Files.size, you can also sometimes hit AccessDeniedException, +            }, +        }, +        return estimatedSize;, +    }, +, +    private final SingleObjectCache<SizeAndModCount> size;, +    // Both these variables need to be accessed under `this` lock., +    private long modCount = 0;, +    private long numOpenOutputs = 0;, +, +    ByteSizeCachingDirectory(Directory in, TimeValue refreshInterval) {, +        super(in);, +        size = new SingleObjectCache<SizeAndModCount>(refreshInterval, new SizeAndModCount(0L, -1L, true)) {, +            @Override, +            protected SizeAndModCount refresh() {, +                // It is ok for the size of the directory to be more recent than, +                // the mod count, we would just recompute the size of the, +                // directory on the next call as well. However the opposite, +                // would be bad as we would potentially have a stale cache, +                // entry for a long time. So we fetch the values of modCount and, +                // numOpenOutputs BEFORE computing the size of the directory., +                final long modCount;, +                final boolean pendingWrite;, +                synchronized(ByteSizeCachingDirectory.this) {, +                    modCount = ByteSizeCachingDirectory.this.modCount;, +                    pendingWrite = ByteSizeCachingDirectory.this.numOpenOutputs != 0;, +                }, +                final long size;, +                try {]