[+++ b/x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/action/saml/TransportSamlAuthenticateAction.java, +                tokenService.createOAuth2Tokens(authentication, originatingAuthentication,, +                        tokenMeta, true, ActionListener.wrap(tuple -> {, +                        }, listener::onFailure));, +++ b/x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/action/saml/TransportSamlAuthenticateAction.java, +                tokenService.createOAuth2Tokens(authentication, originatingAuthentication,, +                        tokenMeta, true, ActionListener.wrap(tuple -> {, +                        }, listener::onFailure));, +++ b/x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/action/saml/TransportSamlInvalidateSessionAction.java, +        tokenService.findActiveTokensForRealm(realm.name(), containsMetadata(tokenMetadata), ActionListener.wrap(tokens -> {, +        ));, +++ b/x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/action/saml/TransportSamlAuthenticateAction.java, +                tokenService.createOAuth2Tokens(authentication, originatingAuthentication,, +                        tokenMeta, true, ActionListener.wrap(tuple -> {, +                        }, listener::onFailure));, +++ b/x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/action/saml/TransportSamlInvalidateSessionAction.java, +        tokenService.findActiveTokensForRealm(realm.name(), containsMetadata(tokenMetadata), ActionListener.wrap(tokens -> {, +        ));, +++ b/x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/action/saml/TransportSamlLogoutAction.java, +            } catch (ElasticsearchException e) {, +++ b/x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/action/saml/TransportSamlAuthenticateAction.java, +                tokenService.createOAuth2Tokens(authentication, originatingAuthentication,, +                        tokenMeta, true, ActionListener.wrap(tuple -> {, +                        }, listener::onFailure));, +++ b/x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/action/saml/TransportSamlInvalidateSessionAction.java, +        tokenService.findActiveTokensForRealm(realm.name(), containsMetadata(tokenMetadata), ActionListener.wrap(tokens -> {, +        ));, +++ b/x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/action/saml/TransportSamlLogoutAction.java, +            } catch (ElasticsearchException e) {, +++ b/x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/action/token/TransportCreateTokenAction.java, +        tokenService.createOAuth2Tokens(authentication, originatingAuth, Collections.emptyMap(), includeRefreshToken,, +                ActionListener.wrap(tuple -> {, +                    final CreateTokenResponse response = new CreateTokenResponse(tokenStr, tokenService.getExpirationDelay(), scope,, +                            tuple.v2());, +                }, listener::onFailure));, +++ b/x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/action/saml/TransportSamlAuthenticateAction.java, +                tokenService.createOAuth2Tokens(authentication, originatingAuthentication,, +                        tokenMeta, true, ActionListener.wrap(tuple -> {, +                        }, listener::onFailure));, +++ b/x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/action/saml/TransportSamlInvalidateSessionAction.java, +        tokenService.findActiveTokensForRealm(realm.name(), containsMetadata(tokenMetadata), ActionListener.wrap(tokens -> {, +        ));, +++ b/x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/action/saml/TransportSamlLogoutAction.java, +            } catch (ElasticsearchException e) {, +++ b/x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/action/token/TransportCreateTokenAction.java, +        tokenService.createOAuth2Tokens(authentication, originatingAuth, Collections.emptyMap(), includeRefreshToken,, +                ActionListener.wrap(tuple -> {, +                    final CreateTokenResponse response = new CreateTokenResponse(tokenStr, tokenService.getExpirationDelay(), scope,, +                            tuple.v2());, +                }, listener::onFailure));, +++ b/x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authc/TokenService.java, +import org.elasticsearch.action.DocWriteResponse.Result;, +import org.elasticsearch.common.bytes.BytesReference;, +import org.elasticsearch.common.io.Streams;, +import org.elasticsearch.common.io.stream.BytesStreamOutput;, +import java.time.DateTimeException;, +     * Creates an access token and optionally a refresh token as well, based on the provided authentication and metadata with an, +     * auto-generated token document id. The created tokens are stored in the security index., +    public void createOAuth2Tokens(Authentication authentication, Authentication originatingClientAuth,, +                                   Map<String, Object> metadata, boolean includeRefreshToken,, +                                   ActionListener<Tuple<UserToken, String>> listener) {, +        createOAuth2Tokens(UUIDs.randomBase64UUID(), authentication, originatingClientAuth, metadata, includeRefreshToken, listener);, +     * Create an access token and optionally a refresh token as well, based on the provided authentication and metadata, with the given, +     * token document id. The created tokens are be stored in the security index., +    private void createOAuth2Tokens(String userTokenId, Authentication authentication, Authentication originatingClientAuth,, +                                    Map<String, Object> metadata, boolean includeRefreshToken,, +                                    ActionListener<Tuple<UserToken, String>> listener) {, +            final String documentId = getTokenDocumentId(userToken);, +            final IndexRequest request;, +                request = client.prepareIndex(SECURITY_INDEX_NAME, SINGLE_MAPPING_NAME, documentId), +                // unexpected exception, +                listener.onFailure(e);, +                return;, +            }, +            securityIndex.prepareIndexIfNeededThenExecute(ex -> listener.onFailure(traceLog("prepare security index", documentId, ex)),, +                    () -> executeAsyncWithOrigin(client, SECURITY_ORIGIN, IndexAction.INSTANCE, request, ActionListener, +                            .wrap(indexResponse -> {, +                                if (indexResponse.getResult() == Result.CREATED) {, +                                    listener.onResponse(new Tuple<>(userToken, refreshToken));, +                                } else {, +                                    listener.onFailure(traceLog("create token",, +                                            new ElasticsearchException("failed to create token document [{}]", indexResponse)));, +                                }, +                            }, listener::onFailure)));, +    public void getAuthenticationAndMetaData(String token, ActionListener<Tuple<Authentication, Map<String, Object>>> listener) {, +            logger.warn("failed to get access token [{}] because index is not available", userTokenId);, +                                logger.warn("failed to get access token [{}] because index is not available", userTokenId);, +                                logger.error(new ParameterizedMessage("failed to get access token [{}]", userTokenId), e);, +    void decodeToken(String token, ActionListener<UserToken> listener) {, +        final byte[] bytes = token.getBytes(StandardCharsets.UTF_8);, +        try (StreamInput in = new InputStreamStreamInput(Base64.getDecoder().wrap(new ByteArrayInputStream(bytes)), bytes.length)) {, +            in.setVersion(version);, +                final byte[] iv = in.readByteArray();, +                final BytesStreamOutput out = new BytesStreamOutput();, +                Streams.copy(in, out);, +                final byte[] encryptedTokenId = BytesReference.toBytes(out.bytes());, +                final KeyAndCache keyAndCache = keyCache.get(passphraseHash);, +                        if (decodeKey != null) {, +                                final String tokenId = decryptTokenId(encryptedTokenId, cipher, version);, +                                getUserTokenFromId(tokenId, listener);]