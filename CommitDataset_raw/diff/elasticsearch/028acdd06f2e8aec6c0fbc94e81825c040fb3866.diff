[+++ b/core/src/main/java/org/elasticsearch/index/engine/EngineConfig.java, +     * Index setting to control the initial index buffer size.  NOTE: this setting is somewhat, +     * useless, since IndexingMemoryController will take over quickly and partition the, +     * indices.memory.index_buffer_size for this node across all shards., +     *, +     * <p>This setting is <b>not</b> realtime updateable., +++ b/core/src/main/java/org/elasticsearch/index/engine/EngineConfig.java, +     * Index setting to control the initial index buffer size.  NOTE: this setting is somewhat, +     * useless, since IndexingMemoryController will take over quickly and partition the, +     * indices.memory.index_buffer_size for this node across all shards., +     *, +     * <p>This setting is <b>not</b> realtime updateable., +++ b/core/src/main/java/org/elasticsearch/index/engine/InternalEngine.java, +        updateIndexWriterSettings();, +        // config().getVersionMapSize() may have changed:, +        checkVersionMapRefresh();, +        // config().isEnableGcDeletes() or config.getGcDeletesInMillis() may have changed:, +        maybePruneDeletedTombstones();, +++ b/core/src/main/java/org/elasticsearch/index/engine/EngineConfig.java, +     * Index setting to control the initial index buffer size.  NOTE: this setting is somewhat, +     * useless, since IndexingMemoryController will take over quickly and partition the, +     * indices.memory.index_buffer_size for this node across all shards., +     *, +     * <p>This setting is <b>not</b> realtime updateable., +++ b/core/src/main/java/org/elasticsearch/index/engine/InternalEngine.java, +        updateIndexWriterSettings();, +        // config().getVersionMapSize() may have changed:, +        checkVersionMapRefresh();, +        // config().isEnableGcDeletes() or config.getGcDeletesInMillis() may have changed:, +        maybePruneDeletedTombstones();, +++ b/core/src/main/java/org/elasticsearch/index/shard/IndexShard.java, +, +, +, +        Engine engine = engineUnsafe();, +        if (engine == null) {, +            logger.debug("updateBufferSize: engine is closed; skipping");, +            return;, +        }, +, +        if (preValue.bytes() != shardIndexingBufferSize.bytes()) {, +            // so we push changes these changes down to IndexWriter:, +            engine.onSettingsChanged();, +, +            if (shardIndexingBufferSize == EngineConfig.INACTIVE_SHARD_INDEXING_BUFFER) {, +                // it's inactive: make sure we do a refresh / full IW flush in this case, since the memory, +, +                engine().onSettingsChanged();, +    /** NOTE: returns null if engine is not yet started (e.g. recovery phase 1, copying over index files, is still running), or if engine is, +     *  closed. */, +++ b/core/src/main/java/org/elasticsearch/index/engine/EngineConfig.java, +     * Index setting to control the initial index buffer size.  NOTE: this setting is somewhat, +     * useless, since IndexingMemoryController will take over quickly and partition the, +     * indices.memory.index_buffer_size for this node across all shards., +     *, +     * <p>This setting is <b>not</b> realtime updateable., +++ b/core/src/main/java/org/elasticsearch/index/engine/InternalEngine.java, +        updateIndexWriterSettings();, +        // config().getVersionMapSize() may have changed:, +        checkVersionMapRefresh();, +        // config().isEnableGcDeletes() or config.getGcDeletesInMillis() may have changed:, +        maybePruneDeletedTombstones();, +++ b/core/src/main/java/org/elasticsearch/index/shard/IndexShard.java, +, +, +, +        Engine engine = engineUnsafe();, +        if (engine == null) {, +            logger.debug("updateBufferSize: engine is closed; skipping");, +            return;, +        }, +, +        if (preValue.bytes() != shardIndexingBufferSize.bytes()) {, +            // so we push changes these changes down to IndexWriter:, +            engine.onSettingsChanged();, +, +            if (shardIndexingBufferSize == EngineConfig.INACTIVE_SHARD_INDEXING_BUFFER) {, +                // it's inactive: make sure we do a refresh / full IW flush in this case, since the memory, +, +                engine().onSettingsChanged();, +    /** NOTE: returns null if engine is not yet started (e.g. recovery phase 1, copying over index files, is still running), or if engine is, +     *  closed. */, +++ b/core/src/main/java/org/elasticsearch/indices/memory/IndexingMemoryController.java, +    /** How much heap (% or bytes) we will share across all actively indexing shards on this node (default: 10%). */, +    public static final String INDEX_BUFFER_SIZE_SETTING = "indices.memory.index_buffer_size";, +    , +    /** Only applies when <code>indices.memory.index_buffer_size</code> is a %, to set a floor on the actual size in bytes (default: 48 MB). */, +    public static final String MIN_INDEX_BUFFER_SIZE_SETTING = "indices.memory.min_index_buffer_size";, +, +    /** Only applies when <code>indices.memory.index_buffer_size</code> is a %, to set a ceiling on the actual size in bytes (default: not set). */, +    public static final String MAX_INDEX_BUFFER_SIZE_SETTING = "indices.memory.max_index_buffer_size";, +, +    /** Sets a floor on the per-shard index buffer size (default: 4 MB). */, +    public static final String MIN_SHARD_INDEX_BUFFER_SIZE_SETTING = "indices.memory.min_shard_index_buffer_size";, +, +    /** Sets a ceiling on the per-shard index buffer size (default: 512 MB). */, +    public static final String MAX_SHARD_INDEX_BUFFER_SIZE_SETTING = "indices.memory.max_shard_index_buffer_size";, +, +    /** How much heap (% or bytes) we will share across all actively indexing shards for the translog buffer (default: 1%). */, +    public static final String TRANSLOG_BUFFER_SIZE_SETTING = "indices.memory.translog_buffer_size";]