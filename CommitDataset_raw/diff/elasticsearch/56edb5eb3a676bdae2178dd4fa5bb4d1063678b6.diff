[+++ b/server/src/main/java/org/elasticsearch/index/engine/Engine.java, +, +    /**, +     * Tries to prune buffered deletes from the version map., +     */, +    public abstract void maybePruneDeletes();, +++ b/server/src/main/java/org/elasticsearch/index/engine/Engine.java, +, +    /**, +     * Tries to prune buffered deletes from the version map., +     */, +    public abstract void maybePruneDeletes();, +++ b/server/src/main/java/org/elasticsearch/index/engine/InternalEngine.java, +        maybePruneDeletes();, +    @Override, +    public void maybePruneDeletes() {, +        maybePruneDeletes();, +        final long timeMSec = engineConfig.getThreadPool().relativeTimeInMillis();, +        versionMap.pruneTombstones(timeMSec, engineConfig.getIndexSettings().getGcDeletesInMillis());, +        // clean with current time Long.MAX_VALUE and interval 0 since we use a greater than relationship here., +        versionMap.pruneTombstones(Long.MAX_VALUE, 0);, +        maybePruneDeletes();, +++ b/server/src/main/java/org/elasticsearch/index/engine/Engine.java, +, +    /**, +     * Tries to prune buffered deletes from the version map., +     */, +    public abstract void maybePruneDeletes();, +++ b/server/src/main/java/org/elasticsearch/index/engine/InternalEngine.java, +        maybePruneDeletes();, +    @Override, +    public void maybePruneDeletes() {, +        maybePruneDeletes();, +        final long timeMSec = engineConfig.getThreadPool().relativeTimeInMillis();, +        versionMap.pruneTombstones(timeMSec, engineConfig.getIndexSettings().getGcDeletesInMillis());, +        // clean with current time Long.MAX_VALUE and interval 0 since we use a greater than relationship here., +        versionMap.pruneTombstones(Long.MAX_VALUE, 0);, +        maybePruneDeletes();, +++ b/server/src/main/java/org/elasticsearch/index/engine/LiveVersionMap.java, +import java.util.function.Function;, +        /** Tracks bytes used by current map, i.e. what is freed on refresh. For deletes, which are also added to tombstones, we only account, +         *  for the CHM entry here, and account for BytesRef/VersionValue against the tombstones, since refresh would not clear this RAM. */, +        final AtomicLong ramBytesUsed = new AtomicLong();, +, +        // minimum timestamp of delete operations that were made while this map was active. this is used to make sure they are kept in, +        // the tombstone, +        private final AtomicLong minDeleteTimestamp = new AtomicLong(Long.MAX_VALUE);, +, +, +        public VersionValue remove(BytesRef uid) {, +            return map.remove(uid);, +        }, +, +        public void updateMinDeletedTimestamp(DeleteVersionValue delete) {, +            long time = delete.time;, +            minDeleteTimestamp.updateAndGet(prev -> Math.min(time, prev));, +        }, +, +, +            return new Maps(new VersionLookup(ConcurrentCollections.newConcurrentMapWithAggressiveConcurrency(current.size())), current,, +                shouldInheritSafeAccess());, +, +        void put(BytesRef uid, VersionValue version) {, +            long uidRAMBytesUsed = BASE_BYTES_PER_BYTESREF + uid.bytes.length;, +            long ramAccounting = BASE_BYTES_PER_CHM_ENTRY + version.ramBytesUsed() + uidRAMBytesUsed;, +            VersionValue previousValue = current.put(uid, version);, +            ramAccounting += previousValue == null ? 0 : -(BASE_BYTES_PER_CHM_ENTRY + previousValue.ramBytesUsed() + uidRAMBytesUsed);, +            adjustRam(ramAccounting);, +        }, +, +        void adjustRam(long value) {, +            if (value != 0) {, +                long v = current.ramBytesUsed.addAndGet(value);, +                assert v >= 0 : "bytes=" + v;, +            }, +        }, +, +        void remove(BytesRef uid, DeleteVersionValue deleted) {, +            VersionValue previousValue = current.remove(uid);, +            current.updateMinDeletedTimestamp(deleted);, +            if (previousValue != null) {, +                long uidRAMBytesUsed = BASE_BYTES_PER_BYTESREF + uid.bytes.length;, +                adjustRam(-(BASE_BYTES_PER_CHM_ENTRY + previousValue.ramBytesUsed() + uidRAMBytesUsed));, +            }, +            if (old != VersionLookup.EMPTY) {, +                // we also need to remove it from the old map here to make sure we don't read this stale value while, +                // we are in the middle of a refresh. Most of the time the old map is an empty map so we can skip it there., +                old.remove(uid);, +            }, +        }, +, +        long getMinDeleteTimestamp() {, +            return Math.min(current.minDeleteTimestamp.get(), old.minDeleteTimestamp.get());, +        }, +            maps.put(uid, version);, +            removeTombstoneUnderLock(uid);, +            DeleteVersionValue versionValue = (DeleteVersionValue) version;, +            putTombstone(uid, versionValue);, +            maps.remove(uid, versionValue);, +        }]