[+++ b/core/src/main/java/org/elasticsearch/index/fielddata/IndexFieldData.java, +import org.elasticsearch.common.lucene.search.Queries;, +            public Query getInnerQuery() {, +                return innerQuery;, +            }, +, +            public BitSetProducer getRootFilter() {, +                return rootFilter;, +            }, +, +++ b/core/src/main/java/org/elasticsearch/index/fielddata/IndexFieldData.java, +import org.elasticsearch.common.lucene.search.Queries;, +            public Query getInnerQuery() {, +                return innerQuery;, +            }, +, +            public BitSetProducer getRootFilter() {, +                return rootFilter;, +            }, +, +++ b/core/src/main/java/org/elasticsearch/search/MultiValueMode.java, +    public NumericDocValues select(final SortedNumericDocValues values, final long missingValue, final BitSet parentDocs, final DocIdSetIterator childDocs, int maxDoc) throws IOException {, +        if (parentDocs == null || childDocs == null) {, +            int lastSeenParentDoc = -1;, +            public boolean advanceExact(int parentDoc) throws IOException {, +                assert parentDoc >= lastSeenParentDoc : "can only evaluate current and upcoming parent docs";, +                if (parentDoc == lastSeenParentDoc) {, +                } else if (parentDoc == 0) {, +                final int prevParentDoc = parentDocs.prevSetBit(parentDoc - 1);, +                final int firstChildDoc;, +                if (childDocs.docID() > prevParentDoc) {, +                    firstChildDoc = childDocs.docID();, +                    firstChildDoc = childDocs.advance(prevParentDoc + 1);, +                lastSeenParentDoc = parentDoc;, +                lastEmittedValue = pick(values, missingValue, childDocs, firstChildDoc, parentDoc);, +                return lastSeenParentDoc;, +    public NumericDoubleValues select(final SortedNumericDoubleValues values, final double missingValue, final BitSet parentDocs, final DocIdSetIterator childDocs, int maxDoc) throws IOException {, +        if (parentDocs == null || childDocs == null) {, +            int lastSeenParentDoc = 0;, +            public boolean advanceExact(int parentDoc) throws IOException {, +                assert parentDoc >= lastSeenParentDoc : "can only evaluate current and upcoming parent docs";, +                if (parentDoc == lastSeenParentDoc) {, +                final int prevParentDoc = parentDocs.prevSetBit(parentDoc - 1);, +                final int firstChildDoc;, +                if (childDocs.docID() > prevParentDoc) {, +                    firstChildDoc = childDocs.docID();, +                    firstChildDoc = childDocs.advance(prevParentDoc + 1);, +                lastSeenParentDoc = parentDoc;, +                lastEmittedValue = pick(values, missingValue, childDocs, firstChildDoc, parentDoc);, +    public BinaryDocValues select(final SortedBinaryDocValues values, final BytesRef missingValue, final BitSet parentDocs, final DocIdSetIterator childDocs, int maxDoc) throws IOException {, +        if (parentDocs == null || childDocs == null) {, +            int lastSeenParentDoc = 0;, +            public boolean advanceExact(int parentDoc) throws IOException {, +                assert parentDoc >= lastSeenParentDoc : "can only evaluate current and upcoming root docs";, +                if (parentDoc == lastSeenParentDoc) {, +                final int prevParentDoc = parentDocs.prevSetBit(parentDoc - 1);, +                final int firstChildDoc;, +                if (childDocs.docID() > prevParentDoc) {, +                    firstChildDoc = childDocs.docID();, +                    firstChildDoc = childDocs.advance(prevParentDoc + 1);, +                lastSeenParentDoc = parentDoc;, +                lastEmittedValue = pick(selectedValues, builder, childDocs, firstChildDoc, parentDoc);, +    public SortedDocValues select(final SortedSetDocValues values, final BitSet parentDocs, final DocIdSetIterator childDocs) throws IOException {, +        if (parentDocs == null || childDocs == null) {, +            int lastSeenParentDoc = 0;, +            public boolean advanceExact(int parentDoc) throws IOException {, +                assert parentDoc >= lastSeenParentDoc : "can only evaluate current and upcoming root docs";, +                if (parentDoc == lastSeenParentDoc) {, +                final int prevParentDoc = parentDocs.prevSetBit(parentDoc - 1);, +                final int firstChildDoc;, +                if (childDocs.docID() > prevParentDoc) {, +                    firstChildDoc = childDocs.docID();, +                    firstChildDoc = childDocs.advance(prevParentDoc + 1);, +                docID = lastSeenParentDoc = parentDoc;, +                lastEmittedOrd = pick(selectedValues, childDocs, firstChildDoc, parentDoc);, +++ b/core/src/main/java/org/elasticsearch/index/fielddata/IndexFieldData.java, +import org.elasticsearch.common.lucene.search.Queries;, +            public Query getInnerQuery() {, +                return innerQuery;, +            }, +, +            public BitSetProducer getRootFilter() {, +                return rootFilter;, +            }, +, +++ b/core/src/main/java/org/elasticsearch/search/MultiValueMode.java, +    public NumericDocValues select(final SortedNumericDocValues values, final long missingValue, final BitSet parentDocs, final DocIdSetIterator childDocs, int maxDoc) throws IOException {, +        if (parentDocs == null || childDocs == null) {, +            int lastSeenParentDoc = -1;, +            public boolean advanceExact(int parentDoc) throws IOException {, +                assert parentDoc >= lastSeenParentDoc : "can only evaluate current and upcoming parent docs";, +                if (parentDoc == lastSeenParentDoc) {, +                } else if (parentDoc == 0) {, +                final int prevParentDoc = parentDocs.prevSetBit(parentDoc - 1);, +                final int firstChildDoc;, +                if (childDocs.docID() > prevParentDoc) {, +                    firstChildDoc = childDocs.docID();, +                    firstChildDoc = childDocs.advance(prevParentDoc + 1);, +                lastSeenParentDoc = parentDoc;, +                lastEmittedValue = pick(values, missingValue, childDocs, firstChildDoc, parentDoc);]