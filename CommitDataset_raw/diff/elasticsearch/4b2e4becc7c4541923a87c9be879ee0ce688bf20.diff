[+++ b/src/main/java/org/elasticsearch/index/mapper/DocumentMapperParser.java, +import org.elasticsearch.ElasticsearchParseException;, +import java.util.Iterator;, +import java.util.Set;, +        // parse RootObjectMapper, +        Iterator<Map.Entry<String, Object>> iterator = mapping.entrySet().iterator();, +        // parse DocumentMapper, +        while(iterator.hasNext()) {, +            Map.Entry<String, Object> entry = iterator.next();, +                iterator.remove();, +                iterator.remove();, +                iterator.remove();, +                iterator.remove();, +                    iterator.remove();, +        ImmutableMap<String, Object> attributes = ImmutableMap.of();, +        if (mapping.containsKey("_meta")) {, +            attributes = ImmutableMap.copyOf((Map<String, Object>) mapping.remove("_meta"));, +        }, +        docBuilder.meta(attributes);, +, +        if (!mapping.isEmpty()) {, +            StringBuilder remainingFields = new StringBuilder();, +            for (String key : mapping.keySet()) {, +                remainingFields.append(" [").append(key).append(" : ").append(mapping.get(key).toString()).append("]");, +            }, +            throw new MapperParsingException("Root type mapping not empty after parsing! Remaining fields:" + remainingFields.toString());, +        }, +++ b/src/main/java/org/elasticsearch/index/mapper/DocumentMapperParser.java, +import org.elasticsearch.ElasticsearchParseException;, +import java.util.Iterator;, +import java.util.Set;, +        // parse RootObjectMapper, +        Iterator<Map.Entry<String, Object>> iterator = mapping.entrySet().iterator();, +        // parse DocumentMapper, +        while(iterator.hasNext()) {, +            Map.Entry<String, Object> entry = iterator.next();, +                iterator.remove();, +                iterator.remove();, +                iterator.remove();, +                iterator.remove();, +                    iterator.remove();, +        ImmutableMap<String, Object> attributes = ImmutableMap.of();, +        if (mapping.containsKey("_meta")) {, +            attributes = ImmutableMap.copyOf((Map<String, Object>) mapping.remove("_meta"));, +        }, +        docBuilder.meta(attributes);, +, +        if (!mapping.isEmpty()) {, +            StringBuilder remainingFields = new StringBuilder();, +            for (String key : mapping.keySet()) {, +                remainingFields.append(" [").append(key).append(" : ").append(mapping.get(key).toString()).append("]");, +            }, +            throw new MapperParsingException("Root type mapping not empty after parsing! Remaining fields:" + remainingFields.toString());, +        }, +++ b/src/main/java/org/elasticsearch/index/mapper/object/ObjectMapper.java, +            for (Map.Entry<String, Object> entry : node.entrySet()) {, +                parseObjectOrDocumentTypeProperties(fieldName, fieldNode, parserContext, builder);, +                parseObjectProperties(name, fieldName,  fieldNode,  builder);, +            }, +            parseNested(name, node, builder);, +            return builder;, +        }, +        protected static boolean parseObjectOrDocumentTypeProperties(String fieldName, Object fieldNode, ParserContext parserContext, ObjectMapper.Builder builder) {, +                return true;, +                return true;, +                return true;, +            }, +            return false;, +        }, +, +        protected static void parseObjectProperties(String name, String fieldName, Object fieldNode, ObjectMapper.Builder builder) {, +           if (fieldName.equals("path")) {, +                builder.pathType(parsePathType(name, fieldNode.toString()));, +        protected static void parseNested(String name, Map<String, Object> node, ObjectMapper.Builder builder) {, +            boolean nested = false;, +            boolean nestedIncludeInParent = false;, +            boolean nestedIncludeInRoot = false;, +            Object fieldNode = node.get("type");, +            if (fieldNode!=null) {, +                String type = fieldNode.toString();, +                if (type.equals(CONTENT_TYPE)) {, +                    builder.nested = Nested.NO;, +                } else if (type.equals(NESTED_CONTENT_TYPE)) {, +                    nested = true;, +                } else {, +                    throw new MapperParsingException("Trying to parse an object but has a different type [" + type + "] for [" + name + "]");, +                }, +            }, +            fieldNode = node.get("include_in_parent");, +            if (fieldNode != null) {, +                nestedIncludeInParent = nodeBooleanValue(fieldNode);, +            }, +            fieldNode = node.get("include_in_root");, +            if (fieldNode != null) {, +                nestedIncludeInRoot = nodeBooleanValue(fieldNode);, +            }, +        protected static void parseProperties(ObjectMapper.Builder objBuilder, Map<String, Object> propsNode, ParserContext parserContext) {, +++ b/src/main/java/org/elasticsearch/index/mapper/DocumentMapperParser.java, +import org.elasticsearch.ElasticsearchParseException;, +import java.util.Iterator;]