[+++ /dev/null, +++ /dev/null, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/common/util/concurrent/TransferThreadPoolExecutor.java, +/*, + * Licensed to Elastic Search and Shay Banon under one, + * or more contributor license agreements.  See the NOTICE file, + * distributed with this work for additional information, + * regarding copyright ownership. Elastic Search licenses this, + * file to you under the Apache License, Version 2.0 (the, + * "License"); you may not use this file except in compliance, + * with the License.  You may obtain a copy of the License at, + *, + *    http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing,, + * software distributed under the License is distributed on an, + * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY, + * KIND, either express or implied.  See the License for the, + * specific language governing permissions and limitations, + * under the License., + */, +, +package org.elasticsearch.common.util.concurrent;, +, +import org.elasticsearch.common.util.concurrent.jsr166y.LinkedTransferQueue;, +import org.elasticsearch.common.util.concurrent.jsr166y.TransferQueue;, +, +import java.util.*;, +import java.util.concurrent.AbstractExecutorService;, +import java.util.concurrent.RejectedExecutionException;, +import java.util.concurrent.ThreadFactory;, +import java.util.concurrent.TimeUnit;, +import java.util.concurrent.atomic.AtomicInteger;, +import java.util.concurrent.locks.Condition;, +import java.util.concurrent.locks.ReentrantLock;, +, +/**, + * @author kimchy (shay.banon), + */, +public class TransferThreadPoolExecutor extends AbstractExecutorService {, +, +    private final TransferQueue<Runnable> workQueue = new LinkedTransferQueue<Runnable>();, +, +    private final AtomicInteger queueSize = new AtomicInteger();, +, +    /**, +     * Lock held on updates to poolSize, corePoolSize,, +     * maximumPoolSize, runState, and workers set., +     */, +    private final ReentrantLock mainLock = new ReentrantLock();, +, +    /**, +     * Wait condition to support awaitTermination, +     */, +    private final Condition termination = mainLock.newCondition();, +, +    /**, +     * Set containing all worker threads in pool. Accessed only when, +     * holding mainLock., +     */, +    private final HashSet<Worker> workers = new HashSet<Worker>();, +, +, +    /**, +     * Factory for new threads. All threads are created using this, +     * factory (via method addThread).  All callers must be prepared, +     * for addThread to fail by returning null, which may reflect a, +     * system or user's policy limiting the number of threads.  Even, +     * though it is not treated as an error, failure to create threads, +     * may result in new tasks being rejected or existing ones, +     * remaining stuck in the queue. On the other hand, no special, +     * precautions exist to handle OutOfMemoryErrors that might be, +     * thrown while trying to create threads, since there is generally, +     * no recourse from within this class., +     */, +    private final ThreadFactory threadFactory;, +, +    /**, +     * runState provides the main lifecyle control, taking on values:, +     *, +     * RUNNING:  Accept new tasks and process queued tasks, +     * SHUTDOWN: Don't accept new tasks, but process queued tasks, +     * STOP:     Don't accept new tasks, don't process queued tasks,, +     * and interrupt in-progress tasks, +     * TERMINATED: Same as STOP, plus all threads have terminated, +     *, +     * The numerical order among these values matters, to allow, +     * ordered comparisons. The runState monotonically increases over, +     * time, but need not hit each state. The transitions are:, +     *, +     * RUNNING -> SHUTDOWN, +     * On invocation of shutdown(), perhaps implicitly in finalize(), +     * (RUNNING or SHUTDOWN) -> STOP, +     * On invocation of shutdownNow(), +     * SHUTDOWN -> TERMINATED, +     * When both queue and pool are empty, +     * STOP -> TERMINATED, +     * When pool is empty, +     */, +    volatile int runState;]