[+++ b/buildSrc/src/main/resources/checkstyle_suppressions.xml, +++ b/buildSrc/src/main/resources/checkstyle_suppressions.xml, +++ b/test/framework/src/main/java/org/elasticsearch/test/AbstractQueryTestCase.java, +import java.io.Closeable;, +import java.io.IOException;, +import java.lang.reflect.InvocationHandler;, +import java.lang.reflect.Method;, +import java.lang.reflect.Proxy;, +import java.util.ArrayList;, +import java.util.Collection;, +import java.util.Collections;, +import java.util.List;, +import java.util.Locale;, +import java.util.Map;, +import java.util.concurrent.ExecutionException;, +, +                String testQuery = validQuery.substring(0, insertionPosition) + "{ \"newField\" : ", +                        + validQuery.substring(insertionPosition) + "}";, +    protected static void assertParsedQuery(String queryAsString, QueryBuilder expectedQuery) throws IOException {, +    protected static void assertParsedQuery(String queryAsString, QueryBuilder expectedQuery, ParseFieldMatcher matcher), +            throws IOException {, +    private static void assertParsedQuery(BytesReference queryAsBytes, QueryBuilder expectedQuery) throws IOException {, +    private static void assertParsedQuery(BytesReference queryAsBytes, QueryBuilder expectedQuery, ParseFieldMatcher matcher), +            throws IOException {, +    protected static QueryBuilder parseQuery(String queryAsString) throws IOException {, +    protected static QueryBuilder parseQuery(String queryAsString, ParseFieldMatcher matcher) throws IOException {, +    protected static QueryBuilder parseQuery(BytesReference queryAsBytes) throws IOException {, +    protected static QueryBuilder parseQuery(BytesReference queryAsBytes, ParseFieldMatcher matcher) throws IOException {, +            //remove after assertLuceneQuery since the assertLuceneQuery impl might access the context as well, +            SearchContext.removeCurrent();, +            assertEquals("two equivalent query builders lead to different lucene queries",, +                    rewrite(secondLuceneQuery), rewrite(firstLuceneQuery));, +     * Few queries allow you to set the boost and queryName on the java api, although the corresponding parser, +     * doesn't parse them as they are not supported. This method allows to disable boost and queryName related tests for those queries., +     * Those queries are easy to identify: their parsers don't parse `boost` and `_name` as they don't apply to the specific query:, +     * wrapper query and match_none, +     * Checks the result of {@link QueryBuilder#toQuery(QueryShardContext)} given the original {@link QueryBuilder}, +     * and {@link QueryShardContext}. Verifies that named queries and boost are properly handled and delegates to, +     * {@link #doAssertLuceneQuery(AbstractQueryBuilder, Query, QueryShardContext)} for query specific checks., +    private void assertLuceneQuery(QB queryBuilder, Query query, QueryShardContext context) throws IOException {, +     * Checks the result of {@link QueryBuilder#toQuery(QueryShardContext)} given the original {@link QueryBuilder}, +     * and {@link QueryShardContext}. Contains the query specific checks to be implemented by subclasses., +    private QB copyQuery(QB query) throws IOException {, +        return new QueryParseContext(serviceHolder.indicesQueriesRegistry, parser, matcher);, +            builder.append(randomAsciiOfLengthBetween(1, 10)).append(" ");, +        if (serviceHolder.currentTypes.length == 0 || randomBoolean()) {, +    private String[] getRandomTypes() {, +    private static class ServiceHolder implements Closeable {, +        ServiceHolder(Collection<Class<? extends Plugin>> plugins, AbstractQueryTestCase<?> testCase) throws IOException {, +            ClusterServiceUtils.setState(clusterService, new ClusterState.Builder(clusterService.state()).metaData(, +                            new MetaData.Builder().put(new IndexMetaData.Builder(, +                                    index.getName()).settings(indexSettings).numberOfShards(1).numberOfReplicas(0))));, +                    this::createShardContext);, +                                + "\"properties\":{\"" + DATE_FIELD_NAME + "\":{\"type\":\"date\"},\"" +, +                                INT_FIELD_NAME + "\":{\"type\":\"integer\"}}}}}"),]