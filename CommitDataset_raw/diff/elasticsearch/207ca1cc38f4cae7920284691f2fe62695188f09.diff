[+++ b/plugins/discovery-gce/src/main/java/org/elasticsearch/cloud/gce/GceInstancesService.java, +public interface GceInstancesService extends Closeable {, +++ b/plugins/discovery-gce/src/main/java/org/elasticsearch/cloud/gce/GceInstancesService.java, +public interface GceInstancesService extends Closeable {, +++ b/plugins/discovery-gce/src/main/java/org/elasticsearch/cloud/gce/GceInstancesServiceImpl.java, +public class GceInstancesServiceImpl extends AbstractComponent implements GceInstancesService {, +++ b/plugins/discovery-gce/src/main/java/org/elasticsearch/cloud/gce/GceInstancesService.java, +public interface GceInstancesService extends Closeable {, +++ b/plugins/discovery-gce/src/main/java/org/elasticsearch/cloud/gce/GceInstancesServiceImpl.java, +public class GceInstancesServiceImpl extends AbstractComponent implements GceInstancesService {, +++ b/plugins/discovery-gce/src/main/java/org/elasticsearch/plugin/discovery/gce/GceDiscoveryPlugin.java, +    private final SetOnce<GceInstancesService> gceInstancesService = new SetOnce<>();, +    // overrideable for tests, +    protected GceInstancesService createGceInstancesService() {, +        return new GceInstancesServiceImpl(settings);, +    }, +            gceInstancesService.set(createGceInstancesService());, +++ b/plugins/discovery-gce/src/main/java/org/elasticsearch/cloud/gce/GceInstancesService.java, +public interface GceInstancesService extends Closeable {, +++ b/plugins/discovery-gce/src/main/java/org/elasticsearch/cloud/gce/GceInstancesServiceImpl.java, +public class GceInstancesServiceImpl extends AbstractComponent implements GceInstancesService {, +++ b/plugins/discovery-gce/src/main/java/org/elasticsearch/plugin/discovery/gce/GceDiscoveryPlugin.java, +    private final SetOnce<GceInstancesService> gceInstancesService = new SetOnce<>();, +    // overrideable for tests, +    protected GceInstancesService createGceInstancesService() {, +        return new GceInstancesServiceImpl(settings);, +    }, +            gceInstancesService.set(createGceInstancesService());, +++ b/plugins/discovery-gce/src/test/java/org/elasticsearch/discovery/gce/GceDiscoverTests.java, +import com.google.api.services.compute.model.Instance;, +import com.google.api.services.compute.model.NetworkInterface;, +import org.elasticsearch.action.admin.cluster.state.ClusterStateResponse;, +import org.elasticsearch.cloud.gce.GceInstancesService;, +import org.elasticsearch.cloud.gce.util.Access;, +import org.elasticsearch.cluster.node.DiscoveryNode;, +import org.elasticsearch.discovery.zen.ZenDiscovery;, +import org.elasticsearch.transport.TransportService;, +import org.junit.After;, +import java.util.ArrayList;, +import java.util.Map;, +import java.util.concurrent.ConcurrentHashMap;, +import static java.util.Collections.singletonList;, +@ESIntegTestCase.ClusterScope(supportsDedicatedMasters = false, numDataNodes = 0, numClientNodes = 0), +    /** Holds a list of the current discovery nodes started in tests **/, +    private static final Map<String, DiscoveryNode> nodes = new ConcurrentHashMap<>();, +    @After, +    public void clearGceNodes() {, +        nodes.clear();, +    }, +        return singletonList(TestPlugin.class);, +        return Settings.builder(), +                        .put(super.nodeSettings(nodeOrdinal)), +                        .put("cloud.gce.project_id", "test"), +                        .put("cloud.gce.zone", "test"), +                        // Make the test run faster, +                        .put(ZenDiscovery.JOIN_TIMEOUT_SETTING.getKey(), "1s"), +                        .put(ZenDiscovery.PING_TIMEOUT_SETTING.getKey(), "500ms"), +    public void testJoin() {, +        // start master node, +        final String masterNode = internalCluster().startMasterOnlyNode();, +        registerGceNode(masterNode);, +        ClusterStateResponse clusterStateResponse = client(masterNode).admin().cluster().prepareState(), +                                                                            .setMasterNodeTimeout("1s"), +                                                                            .clear(), +                                                                            .setNodes(true), +                                                                            .get();, +        assertNotNull(clusterStateResponse.getState().nodes().getMasterNodeId());, +        // start another node, +        final String secondNode = internalCluster().startNode();, +        registerGceNode(secondNode);, +        clusterStateResponse = client(secondNode).admin().cluster().prepareState(), +                                                                            .setMasterNodeTimeout("1s"), +                                                                            .clear(), +                                                                            .setNodes(true), +                                                                            .setLocal(true), +                                                                            .get();, +        assertNotNull(clusterStateResponse.getState().nodes().getMasterNodeId());, +        // wait for the cluster to form, +        assertNumberOfNodes(2);, +, +        final String thirdNode = internalCluster().startDataOnlyNode();, +        registerGceNode(thirdNode);, +        assertNumberOfNodes(3);, +    }, +, +    /**, +     * Register an existing node as a GCE node, +     *, +     * @param nodeName the name of the node, +     */, +    private static void registerGceNode(final String nodeName) {, +        final TransportService transportService = internalCluster().getInstance(TransportService.class, nodeName);, +        assertNotNull(transportService);, +        final DiscoveryNode discoveryNode = transportService.getLocalNode();, +        assertNotNull(discoveryNode);, +        if (nodes.put(discoveryNode.getName(), discoveryNode) != null) {, +            throw new IllegalArgumentException("Node [" + discoveryNode.getName() + "] cannot be registered twice");, +        }, +    }, +]