[+++ b/core/src/main/java/org/elasticsearch/index/mapper/IpFieldMapper.java, +        public Query termsQuery(List<?> values, QueryShardContext context) {, +            InetAddress[] addresses = new InetAddress[values.size()];, +            int i = 0;, +            for (Object value : values) {, +                InetAddress address;, +                if (value instanceof InetAddress) {, +                    address = (InetAddress) value;, +                } else {, +                    if (value instanceof BytesRef) {, +                        value = ((BytesRef) value).utf8ToString();, +                    }, +                    if (value.toString().contains("/")) {, +                        // the `terms` query contains some prefix queries, so we cannot create a set query, +                        // and need to fall back to a disjunction of `term` queries, +                        return super.termsQuery(values, context);, +                    }, +                    address = InetAddresses.forString(value.toString());, +                }, +                addresses[i++] = address;, +            }, +            return InetAddressPoint.newSetQuery(name(), addresses);, +        }, +, +        @Override, +++ b/core/src/main/java/org/elasticsearch/index/mapper/IpFieldMapper.java, +        public Query termsQuery(List<?> values, QueryShardContext context) {, +            InetAddress[] addresses = new InetAddress[values.size()];, +            int i = 0;, +            for (Object value : values) {, +                InetAddress address;, +                if (value instanceof InetAddress) {, +                    address = (InetAddress) value;, +                } else {, +                    if (value instanceof BytesRef) {, +                        value = ((BytesRef) value).utf8ToString();, +                    }, +                    if (value.toString().contains("/")) {, +                        // the `terms` query contains some prefix queries, so we cannot create a set query, +                        // and need to fall back to a disjunction of `term` queries, +                        return super.termsQuery(values, context);, +                    }, +                    address = InetAddresses.forString(value.toString());, +                }, +                addresses[i++] = address;, +            }, +            return InetAddressPoint.newSetQuery(name(), addresses);, +        }, +, +        @Override, +++ b/core/src/test/java/org/elasticsearch/index/mapper/IpFieldTypeTests.java, +import java.util.Arrays;, +import org.apache.lucene.search.BooleanQuery;, +import org.apache.lucene.search.ConstantScoreQuery;, +import org.apache.lucene.search.BooleanClause.Occur;, +    public void testTermsQuery() {, +        MappedFieldType ft = createDefaultFieldType();, +        ft.setName("field");, +, +        assertEquals(InetAddressPoint.newSetQuery("field", InetAddresses.forString("::2"), InetAddresses.forString("::5")),, +                ft.termsQuery(Arrays.asList(InetAddresses.forString("::2"), InetAddresses.forString("::5")), null));, +        assertEquals(InetAddressPoint.newSetQuery("field", InetAddresses.forString("::2"), InetAddresses.forString("::5")),, +                ft.termsQuery(Arrays.asList("::2", "::5"), null));, +, +        // if the list includes a prefix query we fallback to a bool query, +        assertEquals(new ConstantScoreQuery(new BooleanQuery.Builder(), +                .add(ft.termQuery("::42", null), Occur.SHOULD), +                .add(ft.termQuery("::2/16", null), Occur.SHOULD).build()),, +                ft.termsQuery(Arrays.asList("::42", "::2/16"), null));, +    }, +]