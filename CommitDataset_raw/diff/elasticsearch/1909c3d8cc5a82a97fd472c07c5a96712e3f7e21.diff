[+++ b/core/src/main/java/org/elasticsearch/index/mapper/core/StringFieldMapper.java, +import static org.elasticsearch.index.mapper.core.TypeParsers.parseTextField;, +            parseTextField(builder, name, node, parserContext);, +++ b/core/src/main/java/org/elasticsearch/index/mapper/core/StringFieldMapper.java, +import static org.elasticsearch.index.mapper.core.TypeParsers.parseTextField;, +            parseTextField(builder, name, node, parserContext);, +++ b/core/src/main/java/org/elasticsearch/index/mapper/core/TypeParsers.java, +    private static void parseAnalyzersAndTermVectors(FieldMapper.Builder builder, String name, Map<String, Object> fieldNode, Mapper.TypeParser.ParserContext parserContext) {, +, +        for (Iterator<Map.Entry<String, Object>> iterator = fieldNode.entrySet().iterator(); iterator.hasNext();) {, +            Map.Entry<String, Object> entry = iterator.next();, +            final String propName = Strings.toUnderscoreCase(entry.getKey());, +            final Object propNode = entry.getValue();, +            if (propName.equals("term_vector")) {, +                parseTermVector(name, propNode.toString(), builder);, +                iterator.remove();, +            } else if (propName.equals("store_term_vectors")) {, +                builder.storeTermVectors(nodeBooleanValue(propNode));, +                iterator.remove();, +            } else if (propName.equals("store_term_vector_offsets")) {, +                builder.storeTermVectorOffsets(nodeBooleanValue(propNode));, +                iterator.remove();, +            } else if (propName.equals("store_term_vector_positions")) {, +                builder.storeTermVectorPositions(nodeBooleanValue(propNode));, +                iterator.remove();, +            } else if (propName.equals("store_term_vector_payloads")) {, +                builder.storeTermVectorPayloads(nodeBooleanValue(propNode));, +                iterator.remove();, +            } else if (propName.equals("analyzer") || // for backcompat, reading old indexes, remove for v3.0, +                    propName.equals("index_analyzer") && parserContext.indexVersionCreated().before(Version.V_2_0_0_beta1)) {, +, +                NamedAnalyzer analyzer = parserContext.analysisService().analyzer(propNode.toString());, +                if (analyzer == null) {, +                    throw new MapperParsingException("analyzer [" + propNode.toString() + "] not found for field [" + name + "]");, +                }, +                indexAnalyzer = analyzer;, +                iterator.remove();, +            } else if (propName.equals("search_analyzer")) {, +                NamedAnalyzer analyzer = parserContext.analysisService().analyzer(propNode.toString());, +                if (analyzer == null) {, +                    throw new MapperParsingException("analyzer [" + propNode.toString() + "] not found for field [" + name + "]");, +                }, +                searchAnalyzer = analyzer;, +                iterator.remove();, +            }, +        }, +, +        if (indexAnalyzer == null) {, +            if (searchAnalyzer != null) {, +                throw new MapperParsingException("analyzer on field [" + name + "] must be set when search_analyzer is set");, +            }, +        } else if (searchAnalyzer == null) {, +            searchAnalyzer = indexAnalyzer;, +        }, +        builder.indexAnalyzer(indexAnalyzer);, +        builder.searchAnalyzer(searchAnalyzer);, +    }, +, +    /**, +     * Parse text field attributes. In addition to {@link #parseField common attributes}, +     * this will parse analysis and term-vectors related settings., +     */, +    public static void parseTextField(FieldMapper.Builder builder, String name, Map<String, Object> fieldNode, Mapper.TypeParser.ParserContext parserContext) {, +        parseField(builder, name, fieldNode, parserContext);, +        parseAnalyzersAndTermVectors(builder, name, fieldNode, parserContext);, +    }, +, +    /**, +     * Parse common field attributes such as {@code doc_values} or {@code store}., +     */, +    public static void parseField(FieldMapper.Builder builder, String name, Map<String, Object> fieldNode, Mapper.TypeParser.ParserContext parserContext) {, +        if (indexVersionCreated.before(Version.V_2_2_0)) {, +            // analyzer, search_analyzer, term_vectors were accepted on all fields, +            // before 2.2, even though it made little sense, +            parseAnalyzersAndTermVectors(builder, name, fieldNode, parserContext);, +++ b/core/src/main/java/org/elasticsearch/index/mapper/core/StringFieldMapper.java, +import static org.elasticsearch.index.mapper.core.TypeParsers.parseTextField;, +            parseTextField(builder, name, node, parserContext);, +++ b/core/src/main/java/org/elasticsearch/index/mapper/core/TypeParsers.java, +    private static void parseAnalyzersAndTermVectors(FieldMapper.Builder builder, String name, Map<String, Object> fieldNode, Mapper.TypeParser.ParserContext parserContext) {, +, +        for (Iterator<Map.Entry<String, Object>> iterator = fieldNode.entrySet().iterator(); iterator.hasNext();) {, +            Map.Entry<String, Object> entry = iterator.next();, +            final String propName = Strings.toUnderscoreCase(entry.getKey());, +            final Object propNode = entry.getValue();, +            if (propName.equals("term_vector")) {, +                parseTermVector(name, propNode.toString(), builder);, +                iterator.remove();, +            } else if (propName.equals("store_term_vectors")) {, +                builder.storeTermVectors(nodeBooleanValue(propNode));, +                iterator.remove();, +            } else if (propName.equals("store_term_vector_offsets")) {, +                builder.storeTermVectorOffsets(nodeBooleanValue(propNode));, +                iterator.remove();, +            } else if (propName.equals("store_term_vector_positions")) {, +                builder.storeTermVectorPositions(nodeBooleanValue(propNode));, +                iterator.remove();, +            } else if (propName.equals("store_term_vector_payloads")) {, +                builder.storeTermVectorPayloads(nodeBooleanValue(propNode));, +                iterator.remove();]