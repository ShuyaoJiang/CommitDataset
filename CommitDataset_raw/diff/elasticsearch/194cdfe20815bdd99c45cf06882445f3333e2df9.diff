[+++ b/server/src/main/java/org/elasticsearch/index/seqno/ReplicationTracker.java, +     * A callback when a new retention lease is created or an existing retention lease expires. In practice, this callback invokes the, +     * retention lease sync action, to sync retention leases to replicas., +    private final BiConsumer<Collection<RetentionLease>, ActionListener<ReplicationResponse>> onSyncRetentionLeases;, +     * Get all non-expired retention leases tracked on this shard. An unmodifiable copy of the retention leases is returned. Note that only, +     * the primary shard calculates which leases are expired, and if any have expired, syncs the retention leases to any replicas., +    public Collection<RetentionLease> getRetentionLeases() {, +        final boolean wasPrimaryMode;, +        final Collection<RetentionLease> nonExpiredRetentionLeases;, +        synchronized (this) {, +            if (primaryMode) {, +                // the primary calculates the non-expired retention leases and syncs them to replicas, +                final Collection<RetentionLease> expiredRetentionLeases = retentionLeases, +                        .filter(retentionLease -> currentTimeMillis - retentionLease.timestamp() > retentionLeaseMillis), +                if (expiredRetentionLeases.isEmpty()) {, +                    // early out as no retention leases have expired, +                    return copyRetentionLeases();, +                }, +                // clean up the expired retention leases, +                for (final RetentionLease expiredRetentionLease : expiredRetentionLeases) {, +                    retentionLeases.remove(expiredRetentionLease.id());, +                }, +            }, +            /*, +             * At this point, we were either in primary mode and have updated the non-expired retention leases into the tracking map, or, +             * we were in replica mode and merely need to copy the existing retention leases since a replica does not calculate the, +             * non-expired retention leases, instead receiving them on syncs from the primary., +             */, +            wasPrimaryMode = primaryMode;, +            nonExpiredRetentionLeases = copyRetentionLeases();, +        }, +        if (wasPrimaryMode) {, +            onSyncRetentionLeases.accept(nonExpiredRetentionLeases, ActionListener.wrap(() -> {}));, +        }, +        return nonExpiredRetentionLeases;, +        onSyncRetentionLeases.accept(currentRetentionLeases, listener);, +     * @param onSyncRetentionLeases a callback when a new retention lease is created or an existing retention lease expires, +            final BiConsumer<Collection<RetentionLease>, ActionListener<ReplicationResponse>> onSyncRetentionLeases) {, +        this.onSyncRetentionLeases = Objects.requireNonNull(onSyncRetentionLeases);, +++ b/server/src/main/java/org/elasticsearch/index/seqno/ReplicationTracker.java, +     * A callback when a new retention lease is created or an existing retention lease expires. In practice, this callback invokes the, +     * retention lease sync action, to sync retention leases to replicas., +    private final BiConsumer<Collection<RetentionLease>, ActionListener<ReplicationResponse>> onSyncRetentionLeases;, +     * Get all non-expired retention leases tracked on this shard. An unmodifiable copy of the retention leases is returned. Note that only, +     * the primary shard calculates which leases are expired, and if any have expired, syncs the retention leases to any replicas., +    public Collection<RetentionLease> getRetentionLeases() {, +        final boolean wasPrimaryMode;, +        final Collection<RetentionLease> nonExpiredRetentionLeases;, +        synchronized (this) {, +            if (primaryMode) {, +                // the primary calculates the non-expired retention leases and syncs them to replicas, +                final Collection<RetentionLease> expiredRetentionLeases = retentionLeases, +                        .filter(retentionLease -> currentTimeMillis - retentionLease.timestamp() > retentionLeaseMillis), +                if (expiredRetentionLeases.isEmpty()) {, +                    // early out as no retention leases have expired, +                    return copyRetentionLeases();, +                }, +                // clean up the expired retention leases, +                for (final RetentionLease expiredRetentionLease : expiredRetentionLeases) {, +                    retentionLeases.remove(expiredRetentionLease.id());, +                }, +            }, +            /*, +             * At this point, we were either in primary mode and have updated the non-expired retention leases into the tracking map, or, +             * we were in replica mode and merely need to copy the existing retention leases since a replica does not calculate the, +             * non-expired retention leases, instead receiving them on syncs from the primary., +             */, +            wasPrimaryMode = primaryMode;, +            nonExpiredRetentionLeases = copyRetentionLeases();, +        }, +        if (wasPrimaryMode) {, +            onSyncRetentionLeases.accept(nonExpiredRetentionLeases, ActionListener.wrap(() -> {}));, +        }, +        return nonExpiredRetentionLeases;, +        onSyncRetentionLeases.accept(currentRetentionLeases, listener);, +     * @param onSyncRetentionLeases a callback when a new retention lease is created or an existing retention lease expires, +            final BiConsumer<Collection<RetentionLease>, ActionListener<ReplicationResponse>> onSyncRetentionLeases) {, +        this.onSyncRetentionLeases = Objects.requireNonNull(onSyncRetentionLeases);, +++ b/server/src/test/java/org/elasticsearch/index/seqno/ReplicationTrackerRetentionLeaseTests.java, +import org.elasticsearch.common.collect.Tuple;, +import java.util.List;, +            assertRetentionLeases(replicationTracker, i + 1, minimumRetainingSequenceNumbers, () -> 0L, true);, +            assertRetentionLeases(replicationTracker, length, minimumRetainingSequenceNumbers, () -> 0L, true);, +    public void testAddRetentionLeaseCausesRetentionLeaseSync() {, +, +    public void testExpirationOnPrimary() {, +        runExpirationTest(true);, +    }, +, +    public void testExpirationOnReplica() {, +        runExpirationTest(false);, +    }, +, +    private void runExpirationTest(final boolean primaryMode) {, +        if (primaryMode) {, +        }, +        if (primaryMode) {, +        } else {, +            replicationTracker.updateRetentionLeasesOnReplica(, +                    Collections.singleton(new RetentionLease("0", retainingSequenceNumbers[0], currentTimeMillis.get(), "test-0")));]