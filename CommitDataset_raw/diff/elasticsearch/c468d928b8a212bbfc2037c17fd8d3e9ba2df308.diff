[+++ b/buildSrc/src/main/resources/checkstyle_suppressions.xml, +++ b/buildSrc/src/main/resources/checkstyle_suppressions.xml, +++ b/server/src/main/java/org/elasticsearch/indices/IndexingMemoryController.java, +    /** Only applies when <code>indices.memory.index_buffer_size</code> is a %,, +     * to set a floor on the actual size in bytes (default: 48 MB). */, +    public static final Setting<ByteSizeValue> MIN_INDEX_BUFFER_SIZE_SETTING = Setting.byteSizeSetting(, +        "indices.memory.min_index_buffer_size",, +    /** Only applies when <code>indices.memory.index_buffer_size</code> is a %,, +     * to set a ceiling on the actual size in bytes (default: not set). */, +    public static final Setting<ByteSizeValue> MAX_INDEX_BUFFER_SIZE_SETTING = Setting.byteSizeSetting(, +        "indices.memory.max_index_buffer_size",, +    /** If we see no indexing operations after this much time for a given shard,, +     * we consider that shard inactive (default: 5 minutes). */, +    public static final Setting<TimeValue> SHARD_INACTIVE_TIME_SETTING = Setting.positiveTimeSetting(, +        "indices.memory.shard_inactive_time",, +        TimeValue.timeValueMinutes(5),, +        Property.NodeScope, +    );, +    public static final Setting<TimeValue> SHARD_MEMORY_INTERVAL_TIME_SETTING = Setting.positiveTimeSetting(, +        "indices.memory.interval",, +        TimeValue.timeValueSeconds(5),, +        Property.NodeScope);, +                            // NOTE: this is only an approximate check, because bytes written is to the translog,, +                            // vs indexing memory buffer which is typically smaller but can be larger in extreme, +                            // cases (many unique terms).  This logic is here only as a safety against thread, +                            // starvation or too infrequent checking, to ensure we are still checking periodically,, +                            // in proportion to bytes processed by indexing:, +                    new ByteSizeValue(totalBytesUsed), INDEX_BUFFER_SIZE_SETTING.getKey(), indexingBuffer,, +                    new ByteSizeValue(totalBytesWriting));, +                                logger.trace("shard [{}] is using [{}] heap, writing [{}] heap", shard.shardId(), shardBytesUsed,, +                                    shardWritingBytes);, +                logger.debug("now write some indexing buffers: total indexing heap bytes used [{}] vs {} [{}], " +, +                    "currently writing bytes [{}], [{}] shards with non-zero indexing buffer", new ByteSizeValue(totalBytesUsed),, +                    INDEX_BUFFER_SIZE_SETTING.getKey(), indexingBuffer, new ByteSizeValue(totalBytesWriting), queue.size());, +                    logger.debug("write indexing buffer to disk for shard [{}] to free up its [{}] indexing buffer",, +                        largest.shard.shardId(), new ByteSizeValue(largest.bytesUsed));, +++ b/buildSrc/src/main/resources/checkstyle_suppressions.xml, +++ b/server/src/main/java/org/elasticsearch/indices/IndexingMemoryController.java, +    /** Only applies when <code>indices.memory.index_buffer_size</code> is a %,, +     * to set a floor on the actual size in bytes (default: 48 MB). */, +    public static final Setting<ByteSizeValue> MIN_INDEX_BUFFER_SIZE_SETTING = Setting.byteSizeSetting(, +        "indices.memory.min_index_buffer_size",, +    /** Only applies when <code>indices.memory.index_buffer_size</code> is a %,, +     * to set a ceiling on the actual size in bytes (default: not set). */, +    public static final Setting<ByteSizeValue> MAX_INDEX_BUFFER_SIZE_SETTING = Setting.byteSizeSetting(, +        "indices.memory.max_index_buffer_size",, +    /** If we see no indexing operations after this much time for a given shard,, +     * we consider that shard inactive (default: 5 minutes). */, +    public static final Setting<TimeValue> SHARD_INACTIVE_TIME_SETTING = Setting.positiveTimeSetting(, +        "indices.memory.shard_inactive_time",, +        TimeValue.timeValueMinutes(5),, +        Property.NodeScope, +    );, +    public static final Setting<TimeValue> SHARD_MEMORY_INTERVAL_TIME_SETTING = Setting.positiveTimeSetting(, +        "indices.memory.interval",, +        TimeValue.timeValueSeconds(5),, +        Property.NodeScope);, +                            // NOTE: this is only an approximate check, because bytes written is to the translog,, +                            // vs indexing memory buffer which is typically smaller but can be larger in extreme, +                            // cases (many unique terms).  This logic is here only as a safety against thread, +                            // starvation or too infrequent checking, to ensure we are still checking periodically,, +                            // in proportion to bytes processed by indexing:, +                    new ByteSizeValue(totalBytesUsed), INDEX_BUFFER_SIZE_SETTING.getKey(), indexingBuffer,, +                    new ByteSizeValue(totalBytesWriting));, +                                logger.trace("shard [{}] is using [{}] heap, writing [{}] heap", shard.shardId(), shardBytesUsed,, +                                    shardWritingBytes);, +                logger.debug("now write some indexing buffers: total indexing heap bytes used [{}] vs {} [{}], " +, +                    "currently writing bytes [{}], [{}] shards with non-zero indexing buffer", new ByteSizeValue(totalBytesUsed),, +                    INDEX_BUFFER_SIZE_SETTING.getKey(), indexingBuffer, new ByteSizeValue(totalBytesWriting), queue.size());, +                    logger.debug("write indexing buffer to disk for shard [{}] to free up its [{}] indexing buffer",, +                        largest.shard.shardId(), new ByteSizeValue(largest.bytesUsed));, +++ b/server/src/main/java/org/elasticsearch/indices/IndicesService.java, +                assert sizeInBytes >= 0 : "When reducing circuit breaker, it should be adjusted with a number higher or " +, +                    "equal to 0 and not [" + sizeInBytes + "]";, +        ExecutorService indicesStopExecutor =, +            Executors.newFixedThreadPool(5, EsExecutors.daemonThreadFactory(settings, "indices_shutdown"));, +        IOUtils.closeWhileHandlingException(, +            analysisRegistry,, +            indexingMemoryController,, +            indicesFieldDataCache,, +            cacheCleaner,, +            indicesRequestCache,, +            indicesQueryCache);, +        assert indexService.indexUUID().equals(index.getUUID()) : "uuid mismatch local: " + indexService.indexUUID() +, +            " incoming: " + index.getUUID();, +     * This method tries to update the meta data of the created {@link IndexService} if the given {@code metaDataUpdate}, +     * is different from the given {@code metaData}., +                logger.warn(() -> new ParameterizedMessage("[{}] failed to delete unassigned index (reason [{}])",, +                    metaData.getIndex(), reason), e);, +                    throw new IllegalStateException("Can't delete index store for [" + index.getName() +, +                        "] - it's still part of the indices service [" + localUUid + "] [" + metaData.getIndexUUID() + "]");, +            logger.debug(() -> new ParameterizedMessage("{} failed to delete index store - at least one shards is still locked", index),, +                ex);, +     * On data nodes, if the deleted shard is the last shard folder in its index, the method will attempt to remove, +     * the index folder as well., +        // master nodes keep the index meta data, even if having no shards.., +        if (clusterState.nodes().getLocalNode().isMasterNode() == false &&, +                logger.warn(() -> new ParameterizedMessage("[{}] failed to load state file from a stale deleted index, " +, +                    "folders will be left on disk", index), e);, +     * Checks if all pending deletes have completed. Used by tests to ensure we don't check directory contents]