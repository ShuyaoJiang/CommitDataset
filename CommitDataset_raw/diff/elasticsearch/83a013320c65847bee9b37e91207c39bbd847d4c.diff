[+++ b/src/test/java/org/elasticsearch/recovery/RecoveryWhileUnderLoadTests.java, +import org.elasticsearch.test.BackgroundIndexer;, +        try (BackgroundIndexer indexer = new BackgroundIndexer("test", "type", client())) {, +            waitForDocs(waitFor, indexer);, +            waitForDocs(waitFor, indexer);, +            waitForDocs(totalNumDocs, indexer);, +        try (BackgroundIndexer indexer = new BackgroundIndexer("test", "type", client())) {, +            waitForDocs(waitFor, indexer);, +            waitForDocs(waitFor, indexer);, +            waitForDocs(totalNumDocs, indexer);, +        try (BackgroundIndexer indexer = new BackgroundIndexer("test", "type", client())) {, +            waitForDocs(waitFor, indexer);, +            waitForDocs(waitFor, indexer);, +            waitForDocs(totalNumDocs, indexer);, +        try (BackgroundIndexer indexer = new BackgroundIndexer("test", "type", client())) {, +                waitForDocs(i, indexer);, +++ b/src/test/java/org/elasticsearch/recovery/RecoveryWhileUnderLoadTests.java, +import org.elasticsearch.test.BackgroundIndexer;, +        try (BackgroundIndexer indexer = new BackgroundIndexer("test", "type", client())) {, +            waitForDocs(waitFor, indexer);, +            waitForDocs(waitFor, indexer);, +            waitForDocs(totalNumDocs, indexer);, +        try (BackgroundIndexer indexer = new BackgroundIndexer("test", "type", client())) {, +            waitForDocs(waitFor, indexer);, +            waitForDocs(waitFor, indexer);, +            waitForDocs(totalNumDocs, indexer);, +        try (BackgroundIndexer indexer = new BackgroundIndexer("test", "type", client())) {, +            waitForDocs(waitFor, indexer);, +            waitForDocs(waitFor, indexer);, +            waitForDocs(totalNumDocs, indexer);, +        try (BackgroundIndexer indexer = new BackgroundIndexer("test", "type", client())) {, +                waitForDocs(i, indexer);, +++ b/src/test/java/org/elasticsearch/recovery/RelocationTests.java, +import org.elasticsearch.test.BackgroundIndexer;, +    public void testRelocationWhileIndexingRandom() throws Exception {, +        int numberOfRelocations = scaledRandomIntBetween(1, rarely() ? 10 : 4);, +        int numberOfReplicas = randomBoolean() ? 0 : 1;, +        int numberOfNodes = numberOfReplicas == 0 ? 2 : 3;, +        logger.info("testRelocationWhileIndexingRandom(numRelocations={}, numberOfReplicas={}, numberOfNodes={})", numberOfRelocations, numberOfReplicas, numberOfNodes);, +        String[] nodes = new String[numberOfNodes];, +                        .put("index.number_of_replicas", numberOfReplicas), +        for (int i = 1; i < numberOfNodes; i++) {, +            logger.info("--> starting [node{}] ...", i + 1);, +            nodes[i] = cluster().startNode();, +            if (i != numberOfNodes - 1) {, +                ClusterHealthResponse healthResponse = client().admin().cluster().prepareHealth().setWaitForEvents(Priority.LANGUID), +                        .setWaitForNodes(Integer.toString(i + 1)).setWaitForGreenStatus().execute().actionGet();, +                assertThat(healthResponse.isTimedOut(), equalTo(false));, +, +        try (BackgroundIndexer indexer = new BackgroundIndexer("test", "type1", client())) {, +            waitForDocs(numDocs, indexer);, +            int nodeShiftBased = numberOfReplicas; // if we have replicas shift those, +                fromNode += nodeShiftBased;, +                toNode += nodeShiftBased;, +                        .get();, +                if (rarely()) {, +                    logger.debug("--> flushing");, +                    client().admin().indices().prepareFlush().get();, +                }, +            logger.info("--> waiting for indexing threads to stop ...");, +            indexer.stop();, +                    SearchHits hits = client().prepareSearch("test").setQuery(matchAllQuery()).setSize((int) indexer.totalIndexedDocs()).setNoFields().execute().actionGet().getHits();, +                    if (hits.totalHits() != indexer.totalIndexedDocs()) {, +                        int[] hitIds = new int[(int) indexer.totalIndexedDocs()];, +                        for (int hit = 0; hit < indexer.totalIndexedDocs(); hit++) {, +                    assertThat(hits.totalHits(), equalTo(indexer.totalIndexedDocs()));, +++ b/src/test/java/org/elasticsearch/recovery/RecoveryWhileUnderLoadTests.java, +import org.elasticsearch.test.BackgroundIndexer;, +        try (BackgroundIndexer indexer = new BackgroundIndexer("test", "type", client())) {, +            waitForDocs(waitFor, indexer);, +            waitForDocs(waitFor, indexer);, +            waitForDocs(totalNumDocs, indexer);, +        try (BackgroundIndexer indexer = new BackgroundIndexer("test", "type", client())) {, +            waitForDocs(waitFor, indexer);, +            waitForDocs(waitFor, indexer);, +            waitForDocs(totalNumDocs, indexer);, +        try (BackgroundIndexer indexer = new BackgroundIndexer("test", "type", client())) {, +            waitForDocs(waitFor, indexer);, +            waitForDocs(waitFor, indexer);, +            waitForDocs(totalNumDocs, indexer);, +        try (BackgroundIndexer indexer = new BackgroundIndexer("test", "type", client())) {, +                waitForDocs(i, indexer);, +++ b/src/test/java/org/elasticsearch/recovery/RelocationTests.java, +import org.elasticsearch.test.BackgroundIndexer;, +    public void testRelocationWhileIndexingRandom() throws Exception {, +        int numberOfRelocations = scaledRandomIntBetween(1, rarely() ? 10 : 4);, +        int numberOfReplicas = randomBoolean() ? 0 : 1;, +        int numberOfNodes = numberOfReplicas == 0 ? 2 : 3;, +        logger.info("testRelocationWhileIndexingRandom(numRelocations={}, numberOfReplicas={}, numberOfNodes={})", numberOfRelocations, numberOfReplicas, numberOfNodes);, +        String[] nodes = new String[numberOfNodes];, +                        .put("index.number_of_replicas", numberOfReplicas), +        for (int i = 1; i < numberOfNodes; i++) {, +            logger.info("--> starting [node{}] ...", i + 1);, +            nodes[i] = cluster().startNode();, +            if (i != numberOfNodes - 1) {, +                ClusterHealthResponse healthResponse = client().admin().cluster().prepareHealth().setWaitForEvents(Priority.LANGUID), +                        .setWaitForNodes(Integer.toString(i + 1)).setWaitForGreenStatus().execute().actionGet();, +                assertThat(healthResponse.isTimedOut(), equalTo(false));, +, +        try (BackgroundIndexer indexer = new BackgroundIndexer("test", "type1", client())) {]