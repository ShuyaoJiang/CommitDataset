[+++ b/buildSrc/src/main/resources/checkstyle_suppressions.xml, +++ b/buildSrc/src/main/resources/checkstyle_suppressions.xml, +++ b/core/src/main/java/org/elasticsearch/action/admin/cluster/snapshots/restore/RestoreSnapshotRequest.java, +    private boolean includeGlobalState = false;, +++ b/buildSrc/src/main/resources/checkstyle_suppressions.xml, +++ b/core/src/main/java/org/elasticsearch/action/admin/cluster/snapshots/restore/RestoreSnapshotRequest.java, +    private boolean includeGlobalState = false;, +++ b/core/src/main/java/org/elasticsearch/action/support/WriteRequestBuilder.java, +     * Parse the refresh policy from a string, only modifying it if the string is non null. Convenient to use with request parsing., +    @SuppressWarnings("unchecked"), +    default B setRefreshPolicy(String refreshPolicy) {, +        request().setRefreshPolicy(refreshPolicy);, +        return (B) this;, +++ b/buildSrc/src/main/resources/checkstyle_suppressions.xml, +++ b/core/src/main/java/org/elasticsearch/action/admin/cluster/snapshots/restore/RestoreSnapshotRequest.java, +    private boolean includeGlobalState = false;, +++ b/core/src/main/java/org/elasticsearch/action/support/WriteRequestBuilder.java, +     * Parse the refresh policy from a string, only modifying it if the string is non null. Convenient to use with request parsing., +    @SuppressWarnings("unchecked"), +    default B setRefreshPolicy(String refreshPolicy) {, +        request().setRefreshPolicy(refreshPolicy);, +        return (B) this;, +++ b/core/src/main/java/org/elasticsearch/common/rounding/TimeZoneRounding.java, +            long timeLocal = timeZone.convertUTCToLocal(utcMillis);, +            return timeZone.convertLocalToUTC(rounded, false, utcMillis);, +++ b/buildSrc/src/main/resources/checkstyle_suppressions.xml, +++ b/core/src/main/java/org/elasticsearch/action/admin/cluster/snapshots/restore/RestoreSnapshotRequest.java, +    private boolean includeGlobalState = false;, +++ b/core/src/main/java/org/elasticsearch/action/support/WriteRequestBuilder.java, +     * Parse the refresh policy from a string, only modifying it if the string is non null. Convenient to use with request parsing., +    @SuppressWarnings("unchecked"), +    default B setRefreshPolicy(String refreshPolicy) {, +        request().setRefreshPolicy(refreshPolicy);, +        return (B) this;, +++ b/core/src/main/java/org/elasticsearch/common/rounding/TimeZoneRounding.java, +            long timeLocal = timeZone.convertUTCToLocal(utcMillis);, +            return timeZone.convertLocalToUTC(rounded, false, utcMillis);, +++ b/core/src/main/java/org/elasticsearch/common/xcontent/ConstructingObjectParser.java, + *           a -> new Thing((String) a[0], (String) a[1], (Integer) a[2]));, + *       PARSER.declareInt(optionalConstructorArg(), new ParseField("mineral"));, + *       PARSER.declareInt(Thing::setBug, new ParseField("bug"));, + * <p>, + * Note: if optional constructor arguments aren't specified then the number of allocations is always the worst case., + * </p>, +     * Consumer that marks a field as a required constructor argument instead of a real object field., +    private static final BiConsumer<Object, Object> REQUIRED_CONSTRUCTOR_ARG_MARKER = (a, b) -> {, +        throw new UnsupportedOperationException("I am just a marker I should never be called.");, +    };, +, +    /**, +     * Consumer that marks a field as an optional constructor argument instead of a real object field., +     */, +    private static final BiConsumer<Object, Object> OPTIONAL_CONSTRUCTOR_ARG_MARKER = (a, b) -> {, +    private final List<ConstructorArgInfo> constructorArgInfos = new ArrayList<>();, +     * Pass the {@linkplain BiConsumer} this returns the declare methods to declare a required constructor argument. See this class's, +     * javadoc for an example. The order in which these are declared matters: it is the order that they come in the array passed to, +     * {@link #builder} and the order that missing arguments are reported to the user if any are missing. When all of these parameters are, +     * parsed from the {@linkplain XContentParser} the target object is immediately built., +        return (BiConsumer<Value, FieldT>) REQUIRED_CONSTRUCTOR_ARG_MARKER;, +    }, +, +    /**, +     * Pass the {@linkplain BiConsumer} this returns the declare methods to declare an optional constructor argument. See this class's, +     * javadoc for an example. The order in which these are declared matters: it is the order that they come in the array passed to, +     * {@link #builder} and the order that missing arguments are reported to the user if any are missing. When all of these parameters are, +     * parsed from the {@linkplain XContentParser} the target object is immediately built., +     */, +    @SuppressWarnings("unchecked") // Safe because we never call the method. This is just trickery to make the interface pretty., +    public static <Value, FieldT> BiConsumer<Value, FieldT> optionalConstructorArg() {, +        return (BiConsumer<Value, FieldT>) OPTIONAL_CONSTRUCTOR_ARG_MARKER;, +        if (consumer == REQUIRED_CONSTRUCTOR_ARG_MARKER || consumer == OPTIONAL_CONSTRUCTOR_ARG_MARKER) {, +            int position = constructorArgInfos.size();, +            boolean required = consumer == REQUIRED_CONSTRUCTOR_ARG_MARKER;, +            constructorArgInfos.add(new ConstructorArgInfo(parseField, required));, +        private final Object[] constructorArgs = new Object[constructorArgInfos.size()];, +            if (constructorArgsCollected == constructorArgInfos.size()) {, +                buildTarget();, +            /*, +             * The object hasn't been built which ought to mean we're missing some constructor arguments. But they could be optional! We'll, +             * check if they are all optional and build the error message at the same time - if we don't start the error message then they, +             * were all optional!, +             */, +                if (constructorArgs[i] != null) continue;, +                ConstructorArgInfo arg = constructorArgInfos.get(i);, +                if (false == arg.required) continue;, +                    message = new StringBuilder("Required [").append(arg.field);, +                    message.append(", ").append(arg.field);, +            if (message != null) {, +                // There were non-optional constructor arguments missing., +                throw new IllegalArgumentException(message.append(']').toString());, +             * If there weren't any constructor arguments declared at all then we won't get an error message but this isn't really a valid, +             * use of ConstructingObjectParser. You should be using ObjectParser instead. Since this is more of a programmer error and the, +             * parser ought to still work we just assert this., +            assert false == constructorArgInfos.isEmpty() : "[" + objectParser.getName() + "] must configure at least on constructor ", +                        + "argument. If it doesn't have any it should use ObjectParser instead of ConstructingObjectParser. This is a bug ", +                        + "in the parser declaration.";, +            // All missing constructor arguments were optional. Just build the target and return it., +            buildTarget();, +            return targetObject;, +]