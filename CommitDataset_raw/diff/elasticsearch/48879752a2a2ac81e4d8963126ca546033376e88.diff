[+++ b/src/main/java/org/elasticsearch/action/bench/BenchmarkExecutor.java, +            throw new BenchmarkMissingException("Benchmark [" + benchmarkName + "] not found on [" + nodeName() + "]");, +        logger.debug("Aborted benchmark [{}] on [{}]", benchmarkName, nodeName());, +        return new AbortBenchmarkNodeResponse(benchmarkName, nodeName());, +, +        logger.debug("Reporting [{}] active benchmarks on [{}]", response.activeBenchmarks(), nodeName());, +                throw new ElasticsearchException("Benchmark [" + request.benchmarkName() + "] is already running on [" + nodeName() + "]");, +                logger.debug("Executing [iterations: {}] [multiplier: {}] for [{}] on [{}]",, +                        iterations, settings.multiplier(), request.benchmarkName(), nodeName());, +                        new CompetitionNodeResult(competitor.name(), nodeName(), iterations, competitionIterations);, +    private String nodeName() {, +        if (nodeName == null) {, +            nodeName = clusterService.localNode().name();, +        }, +        return nodeName;, +    }, +, +++ b/src/main/java/org/elasticsearch/action/bench/BenchmarkExecutor.java, +            throw new BenchmarkMissingException("Benchmark [" + benchmarkName + "] not found on [" + nodeName() + "]");, +        logger.debug("Aborted benchmark [{}] on [{}]", benchmarkName, nodeName());, +        return new AbortBenchmarkNodeResponse(benchmarkName, nodeName());, +, +        logger.debug("Reporting [{}] active benchmarks on [{}]", response.activeBenchmarks(), nodeName());, +                throw new ElasticsearchException("Benchmark [" + request.benchmarkName() + "] is already running on [" + nodeName() + "]");, +                logger.debug("Executing [iterations: {}] [multiplier: {}] for [{}] on [{}]",, +                        iterations, settings.multiplier(), request.benchmarkName(), nodeName());, +                        new CompetitionNodeResult(competitor.name(), nodeName(), iterations, competitionIterations);, +    private String nodeName() {, +        if (nodeName == null) {, +            nodeName = clusterService.localNode().name();, +        }, +        return nodeName;, +    }, +, +++ b/src/main/java/org/elasticsearch/action/bench/BenchmarkModule.java, +import org.elasticsearch.common.settings.Settings;, +    private final Settings settings;, +, +    public static final String BENCHMARK_SERVICE_KEY = "benchmark.service.impl";, +, +    public BenchmarkModule(Settings settings) {, +        this.settings = settings;, +    }, +, +, +        final Class<? extends BenchmarkService> service = settings.getAsClass(BENCHMARK_SERVICE_KEY, BenchmarkService.class);, +, +        if (!BenchmarkService.class.equals(service)) {, +            bind(BenchmarkService.class).to(service).asEagerSingleton();, +        } else {, +}, +++ b/src/main/java/org/elasticsearch/action/bench/BenchmarkExecutor.java, +            throw new BenchmarkMissingException("Benchmark [" + benchmarkName + "] not found on [" + nodeName() + "]");, +        logger.debug("Aborted benchmark [{}] on [{}]", benchmarkName, nodeName());, +        return new AbortBenchmarkNodeResponse(benchmarkName, nodeName());, +, +        logger.debug("Reporting [{}] active benchmarks on [{}]", response.activeBenchmarks(), nodeName());, +                throw new ElasticsearchException("Benchmark [" + request.benchmarkName() + "] is already running on [" + nodeName() + "]");, +                logger.debug("Executing [iterations: {}] [multiplier: {}] for [{}] on [{}]",, +                        iterations, settings.multiplier(), request.benchmarkName(), nodeName());, +                        new CompetitionNodeResult(competitor.name(), nodeName(), iterations, competitionIterations);, +    private String nodeName() {, +        if (nodeName == null) {, +            nodeName = clusterService.localNode().name();, +        }, +        return nodeName;, +    }, +, +++ b/src/main/java/org/elasticsearch/action/bench/BenchmarkModule.java, +import org.elasticsearch.common.settings.Settings;, +    private final Settings settings;, +, +    public static final String BENCHMARK_SERVICE_KEY = "benchmark.service.impl";, +, +    public BenchmarkModule(Settings settings) {, +        this.settings = settings;, +    }, +, +, +        final Class<? extends BenchmarkService> service = settings.getAsClass(BENCHMARK_SERVICE_KEY, BenchmarkService.class);, +, +        if (!BenchmarkService.class.equals(service)) {, +            bind(BenchmarkService.class).to(service).asEagerSingleton();, +        } else {, +}, +++ b/src/main/java/org/elasticsearch/action/bench/BenchmarkService.java, +    protected final BenchmarkExecutor executor;, +            int activeBenchmarks = 0;, +                activeBenchmarks += nodeResponse.activeBenchmarks();, +            consolidatedResponse.totalActiveBenchmarks(activeBenchmarks);, +++ b/src/main/java/org/elasticsearch/action/bench/BenchmarkExecutor.java, +            throw new BenchmarkMissingException("Benchmark [" + benchmarkName + "] not found on [" + nodeName() + "]");, +        logger.debug("Aborted benchmark [{}] on [{}]", benchmarkName, nodeName());, +        return new AbortBenchmarkNodeResponse(benchmarkName, nodeName());, +, +        logger.debug("Reporting [{}] active benchmarks on [{}]", response.activeBenchmarks(), nodeName());, +                throw new ElasticsearchException("Benchmark [" + request.benchmarkName() + "] is already running on [" + nodeName() + "]");, +                logger.debug("Executing [iterations: {}] [multiplier: {}] for [{}] on [{}]",, +                        iterations, settings.multiplier(), request.benchmarkName(), nodeName());, +                        new CompetitionNodeResult(competitor.name(), nodeName(), iterations, competitionIterations);]