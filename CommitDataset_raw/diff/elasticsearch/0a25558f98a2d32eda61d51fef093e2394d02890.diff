[+++ b/core/src/main/java/org/apache/lucene/queries/BinaryDocValuesRangeQuery.java, +/*, + * Licensed to Elasticsearch under one or more contributor, + * license agreements. See the NOTICE file distributed with, + * this work for additional information regarding copyright, + * ownership. Elasticsearch licenses this file to you under, + * the Apache License, Version 2.0 (the "License"); you may, + * not use this file except in compliance with the License., + * You may obtain a copy of the License at, + *, + *    http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing,, + * software distributed under the License is distributed on an, + * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY, + * KIND, either express or implied.  See the License for the, + * specific language governing permissions and limitations, + * under the License., + */, +package org.apache.lucene.queries;, +, +import org.apache.lucene.index.BinaryDocValues;, +import org.apache.lucene.index.LeafReaderContext;, +import org.apache.lucene.search.ConstantScoreScorer;, +import org.apache.lucene.search.ConstantScoreWeight;, +import org.apache.lucene.search.IndexSearcher;, +import org.apache.lucene.search.Query;, +import org.apache.lucene.search.Scorer;, +import org.apache.lucene.search.TwoPhaseIterator;, +import org.apache.lucene.search.Weight;, +import org.apache.lucene.store.ByteArrayDataInput;, +import org.apache.lucene.util.BytesRef;, +, +import java.io.IOException;, +import java.util.Objects;, +, +public final class BinaryDocValuesRangeQuery extends Query {, +, +    private final String fieldName;, +    private final QueryType queryType;, +    private final BytesRef from;, +    private final BytesRef to;, +    private final Object originalFrom;, +    private final Object originalTo;, +, +    public BinaryDocValuesRangeQuery(String fieldName, QueryType queryType, BytesRef from, BytesRef to,, +                                     Object originalFrom, Object originalTo) {, +        this.fieldName = fieldName;, +        this.queryType = queryType;, +        this.from = from;, +        this.to = to;, +        this.originalFrom = originalFrom;, +        this.originalTo = originalTo;, +    }, +, +    @Override, +    public Weight createWeight(IndexSearcher searcher, boolean needsScores, float boost) throws IOException {, +        return new ConstantScoreWeight(this, boost) {, +, +            @Override, +            public Scorer scorer(LeafReaderContext context) throws IOException {, +                final BinaryDocValues values = context.reader().getBinaryDocValues(fieldName);, +                if (values == null) {, +                    return null;, +                }, +, +                final TwoPhaseIterator iterator = new TwoPhaseIterator(values) {, +, +                    ByteArrayDataInput in = new ByteArrayDataInput();, +                    BytesRef otherFrom = new BytesRef(16);, +                    BytesRef otherTo = new BytesRef(16);, +, +                    @Override, +                    public boolean matches() throws IOException {, +                        BytesRef encodedRanges = values.binaryValue();, +                        in.reset(encodedRanges.bytes, encodedRanges.offset, encodedRanges.length);, +                        int numRanges = in.readVInt();, +                        for (int i = 0; i < numRanges; i++) {, +                            otherFrom.length = in.readVInt();, +                            otherFrom.bytes = encodedRanges.bytes;, +                            otherFrom.offset = in.getPosition();, +                            in.skipBytes(otherFrom.length);, +, +                            otherTo.length = in.readVInt();, +                            otherTo.bytes = encodedRanges.bytes;, +                            otherTo.offset = in.getPosition();, +                            in.skipBytes(otherTo.length);, +, +                            if (queryType.matches(from, to, otherFrom, otherTo)) {, +                                return true;, +                            }, +                        }, +                        return false;, +                    }, +, +                    @Override, +                    public float matchCost() {, +                        return 4; // at most 4 comparisons, +                    }, +                };]