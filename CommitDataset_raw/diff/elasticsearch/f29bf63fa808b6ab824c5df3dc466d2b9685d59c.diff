[+++ b/core/src/main/java/org/elasticsearch/cluster/action/shard/ShardStateAction.java, +                    routingService.scheduleReroute();, +++ b/core/src/main/java/org/elasticsearch/cluster/action/shard/ShardStateAction.java, +                    routingService.scheduleReroute();, +++ b/core/src/main/java/org/elasticsearch/cluster/routing/RoutingService.java, +import org.elasticsearch.cluster.node.DiscoveryNode;, +import java.util.concurrent.Future;, +import static org.elasticsearch.common.unit.TimeValue.timeValueSeconds;, +, +    private static final String CLUSTER_UPDATE_TASK_SOURCE = "routing-table-updater";, +    private final ThreadPool threadPool;, +, +, +    private final TimeValue schedule;, +, +    private volatile boolean routingTableDirty = false;, +, +    private volatile Future scheduledRoutingTableFuture;, +, +        this.schedule = settings.getAsTime("cluster.routing.schedule", timeValueSeconds(10));, +        FutureUtils.cancel(scheduledRoutingTableFuture);, +        scheduledRoutingTableFuture = null;, +    /** make sure that a reroute will be done by the next scheduled check */, +    public void scheduleReroute() {, +        routingTableDirty = true;, +        if (event.source().equals(CLUSTER_UPDATE_TASK_SOURCE)) {, +            // we are master, schedule the routing table updater, +            if (scheduledRoutingTableFuture == null) {, +                // a new master (us), make sure we reroute shards, +                routingTableDirty = true;, +                scheduledRoutingTableFuture = threadPool.scheduleWithFixedDelay(new RoutingTableUpdater(), schedule);, +            }, +            if (event.nodesRemoved()) {, +                // if nodes were removed, we don't want to wait for the scheduled task, +                // since we want to get primary election as fast as possible, +                routingTableDirty = true;, +                reroute();, +                // Commented out since we make sure to reroute whenever shards changes state or metadata changes state, +//            } else if (event.routingTableChanged()) {, +//                routingTableDirty = true;, +//                reroute();, +            } else {, +                if (event.nodesAdded()) {, +                    for (DiscoveryNode node : event.nodesDelta().addedNodes()) {, +                        if (node.dataNode()) {, +                            routingTableDirty = true;, +                            break;, +                        }, +                    }, +                }, +            }, +, +                        routingTableDirty = true;, +                        reroute();, +        } else {, +            FutureUtils.cancel(scheduledRoutingTableFuture);, +            scheduledRoutingTableFuture = null;, +    private void reroute() {, +            if (!routingTableDirty) {, +                return;, +            }, +                logger.trace("already has pending reroute, ignoring");, +            clusterService.submitStateUpdateTask(CLUSTER_UPDATE_TASK_SOURCE, Priority.HIGH, new ClusterStateUpdateTask() {, +            routingTableDirty = false;, +            logger.warn("Failed to reroute routing table, current state:\n{}", e, state.prettyPrint());, +        }, +    }, +, +    private class RoutingTableUpdater implements Runnable {, +, +        @Override, +        public void run() {, +            reroute();, +++ b/core/src/main/java/org/elasticsearch/cluster/action/shard/ShardStateAction.java, +                    routingService.scheduleReroute();, +++ b/core/src/main/java/org/elasticsearch/cluster/routing/RoutingService.java, +import org.elasticsearch.cluster.node.DiscoveryNode;, +import java.util.concurrent.Future;, +import static org.elasticsearch.common.unit.TimeValue.timeValueSeconds;, +, +    private static final String CLUSTER_UPDATE_TASK_SOURCE = "routing-table-updater";, +    private final ThreadPool threadPool;, +, +, +    private final TimeValue schedule;, +, +    private volatile boolean routingTableDirty = false;, +, +    private volatile Future scheduledRoutingTableFuture;, +, +        this.schedule = settings.getAsTime("cluster.routing.schedule", timeValueSeconds(10));, +        FutureUtils.cancel(scheduledRoutingTableFuture);, +        scheduledRoutingTableFuture = null;, +    /** make sure that a reroute will be done by the next scheduled check */, +    public void scheduleReroute() {, +        routingTableDirty = true;, +        if (event.source().equals(CLUSTER_UPDATE_TASK_SOURCE)) {, +            // we are master, schedule the routing table updater, +            if (scheduledRoutingTableFuture == null) {, +                // a new master (us), make sure we reroute shards]