[+++ b/src/main/java/org/apache/lucene/index/TrackingConcurrentMergeScheduler.java, +        long timeNS = System.nanoTime();, +            long tookMS = TimeValue.nsecToMSec(System.nanoTime() - timeNS);, +            totalMerges.inc(tookMS);, +            long stoppedMS = TimeValue.nsecToMSec(merge.rateLimiter.getTotalStoppedNS());, +            long throttledMS = TimeValue.nsecToMSec(merge.rateLimiter.getTotalPausedNS());, +                                           TimeValue.timeValueMillis(tookMS),, +            if (tookMS > 20000) { // if more than 20 seconds, DEBUG log it, +++ b/src/main/java/org/apache/lucene/index/TrackingConcurrentMergeScheduler.java, +        long timeNS = System.nanoTime();, +            long tookMS = TimeValue.nsecToMSec(System.nanoTime() - timeNS);, +            totalMerges.inc(tookMS);, +            long stoppedMS = TimeValue.nsecToMSec(merge.rateLimiter.getTotalStoppedNS());, +            long throttledMS = TimeValue.nsecToMSec(merge.rateLimiter.getTotalPausedNS());, +                                           TimeValue.timeValueMillis(tookMS),, +            if (tookMS > 20000) { // if more than 20 seconds, DEBUG log it, +++ b/src/main/java/org/elasticsearch/action/admin/cluster/health/TransportClusterHealthAction.java, +            final long endTimeMS = TimeValue.nsecToMSec(System.nanoTime()) + request.timeout().millis();, +                    final long timeoutInMillis = Math.max(0, endTimeMS - TimeValue.nsecToMSec(System.nanoTime()));, +++ b/src/main/java/org/apache/lucene/index/TrackingConcurrentMergeScheduler.java, +        long timeNS = System.nanoTime();, +            long tookMS = TimeValue.nsecToMSec(System.nanoTime() - timeNS);, +            totalMerges.inc(tookMS);, +            long stoppedMS = TimeValue.nsecToMSec(merge.rateLimiter.getTotalStoppedNS());, +            long throttledMS = TimeValue.nsecToMSec(merge.rateLimiter.getTotalPausedNS());, +                                           TimeValue.timeValueMillis(tookMS),, +            if (tookMS > 20000) { // if more than 20 seconds, DEBUG log it, +++ b/src/main/java/org/elasticsearch/action/admin/cluster/health/TransportClusterHealthAction.java, +            final long endTimeMS = TimeValue.nsecToMSec(System.nanoTime()) + request.timeout().millis();, +                    final long timeoutInMillis = Math.max(0, endTimeMS - TimeValue.nsecToMSec(System.nanoTime()));, +++ b/src/main/java/org/elasticsearch/action/update/UpdateHelper.java, +        long getDateNS = System.nanoTime();, +                ttl = ttl - TimeValue.nsecToMSec(System.nanoTime() - getDateNS); // It is an approximation of exact TTL value, could be improved, +++ b/src/main/java/org/apache/lucene/index/TrackingConcurrentMergeScheduler.java, +        long timeNS = System.nanoTime();, +            long tookMS = TimeValue.nsecToMSec(System.nanoTime() - timeNS);, +            totalMerges.inc(tookMS);, +            long stoppedMS = TimeValue.nsecToMSec(merge.rateLimiter.getTotalStoppedNS());, +            long throttledMS = TimeValue.nsecToMSec(merge.rateLimiter.getTotalPausedNS());, +                                           TimeValue.timeValueMillis(tookMS),, +            if (tookMS > 20000) { // if more than 20 seconds, DEBUG log it, +++ b/src/main/java/org/elasticsearch/action/admin/cluster/health/TransportClusterHealthAction.java, +            final long endTimeMS = TimeValue.nsecToMSec(System.nanoTime()) + request.timeout().millis();, +                    final long timeoutInMillis = Math.max(0, endTimeMS - TimeValue.nsecToMSec(System.nanoTime()));, +++ b/src/main/java/org/elasticsearch/action/update/UpdateHelper.java, +        long getDateNS = System.nanoTime();, +                ttl = ttl - TimeValue.nsecToMSec(System.nanoTime() - getDateNS); // It is an approximation of exact TTL value, could be improved, +++ b/src/main/java/org/elasticsearch/cluster/ClusterStateObserver.java, +    volatile Long startTimeNS;, +            this.startTimeNS = System.nanoTime();, +        Long timeoutTimeLeftMS;, +                long timeSinceStartMS = TimeValue.nsecToMSec(System.nanoTime() - startTimeNS);, +                timeoutTimeLeftMS = timeOutValue.millis() - timeSinceStartMS;, +                if (timeoutTimeLeftMS <= 0l) {, +                    logger.debug("observer timed out. notifying listener. timeout setting [{}], time since start [{}]", timeOutValue, new TimeValue(timeSinceStartMS));, +                timeoutTimeLeftMS = null;, +            this.startTimeNS = System.nanoTime();, +            timeoutTimeLeftMS = timeOutValue.millis();, +            clusterService.add(timeoutTimeLeftMS == null ? null : new TimeValue(timeoutTimeLeftMS), clusterStateListener);, +                long timeSinceStartMS = TimeValue.nsecToMSec(System.nanoTime() - startTimeNS);, +                logger.debug("observer: timeout notification from cluster service. timeout setting [{}], time since start [{}]", timeOutValue, new TimeValue(timeSinceStartMS));, +++ b/src/main/java/org/apache/lucene/index/TrackingConcurrentMergeScheduler.java, +        long timeNS = System.nanoTime();, +            long tookMS = TimeValue.nsecToMSec(System.nanoTime() - timeNS);, +            totalMerges.inc(tookMS);, +            long stoppedMS = TimeValue.nsecToMSec(merge.rateLimiter.getTotalStoppedNS());, +            long throttledMS = TimeValue.nsecToMSec(merge.rateLimiter.getTotalPausedNS());, +                                           TimeValue.timeValueMillis(tookMS),, +            if (tookMS > 20000) { // if more than 20 seconds, DEBUG log it, +++ b/src/main/java/org/elasticsearch/action/admin/cluster/health/TransportClusterHealthAction.java, +            final long endTimeMS = TimeValue.nsecToMSec(System.nanoTime()) + request.timeout().millis();, +                    final long timeoutInMillis = Math.max(0, endTimeMS - TimeValue.nsecToMSec(System.nanoTime()));, +++ b/src/main/java/org/elasticsearch/action/update/UpdateHelper.java, +        long getDateNS = System.nanoTime();, +                ttl = ttl - TimeValue.nsecToMSec(System.nanoTime() - getDateNS); // It is an approximation of exact TTL value, could be improved, +++ b/src/main/java/org/elasticsearch/cluster/ClusterStateObserver.java, +    volatile Long startTimeNS;, +            this.startTimeNS = System.nanoTime();, +        Long timeoutTimeLeftMS;, +                long timeSinceStartMS = TimeValue.nsecToMSec(System.nanoTime() - startTimeNS);, +                timeoutTimeLeftMS = timeOutValue.millis() - timeSinceStartMS;, +                if (timeoutTimeLeftMS <= 0l) {, +                    logger.debug("observer timed out. notifying listener. timeout setting [{}], time since start [{}]", timeOutValue, new TimeValue(timeSinceStartMS));, +                timeoutTimeLeftMS = null;, +            this.startTimeNS = System.nanoTime();, +            timeoutTimeLeftMS = timeOutValue.millis();, +            clusterService.add(timeoutTimeLeftMS == null ? null : new TimeValue(timeoutTimeLeftMS), clusterStateListener);, +                long timeSinceStartMS = TimeValue.nsecToMSec(System.nanoTime() - startTimeNS);, +                logger.debug("observer: timeout notification from cluster service. timeout setting [{}], time since start [{}]", timeOutValue, new TimeValue(timeSinceStartMS));, +++ b/src/main/java/org/elasticsearch/cluster/routing/allocation/decider/DiskThresholdDecider.java, +        private long lastRunNS;, +                        if ((System.nanoTime() - lastRunNS) > DiskThresholdDecider.this.rerouteInterval.nanos()) {, +                            lastRunNS = System.nanoTime();, +++ b/src/main/java/org/apache/lucene/index/TrackingConcurrentMergeScheduler.java, +        long timeNS = System.nanoTime();, +            long tookMS = TimeValue.nsecToMSec(System.nanoTime() - timeNS);, +            totalMerges.inc(tookMS);, +            long stoppedMS = TimeValue.nsecToMSec(merge.rateLimiter.getTotalStoppedNS());, +            long throttledMS = TimeValue.nsecToMSec(merge.rateLimiter.getTotalPausedNS());, +                                           TimeValue.timeValueMillis(tookMS),]