[+++ b/x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authc/ApiKeyService.java, +import javax.crypto.SecretKeyFactory;, +, +    // pkg scoped for testing, +    // pkg scoped for testing, +    long lastTimeWhenApiKeysRemoverWasTriggered() {, +        return lastExpirationRunMs;, +    }, +, +++ b/x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authc/ApiKeyService.java, +import javax.crypto.SecretKeyFactory;, +, +    // pkg scoped for testing, +    // pkg scoped for testing, +    long lastTimeWhenApiKeysRemoverWasTriggered() {, +        return lastExpirationRunMs;, +    }, +, +++ b/x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authc/ExpiredApiKeysRemover.java, +import java.time.Duration;, +    public static final Duration EXPIRED_API_KEYS_RETENTION_PERIOD = Duration.ofDays(7L);, +, +                .should(QueryBuilders.rangeQuery("expiration_time").lte(now.minus(EXPIRED_API_KEYS_RETENTION_PERIOD).toEpochMilli())), +++ b/x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authc/ApiKeyService.java, +import javax.crypto.SecretKeyFactory;, +, +    // pkg scoped for testing, +    // pkg scoped for testing, +    long lastTimeWhenApiKeysRemoverWasTriggered() {, +        return lastExpirationRunMs;, +    }, +, +++ b/x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authc/ExpiredApiKeysRemover.java, +import java.time.Duration;, +    public static final Duration EXPIRED_API_KEYS_RETENTION_PERIOD = Duration.ofDays(7L);, +, +                .should(QueryBuilders.rangeQuery("expiration_time").lte(now.minus(EXPIRED_API_KEYS_RETENTION_PERIOD).toEpochMilli())), +++ b/x-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/authc/ApiKeyIntegTests.java, +import com.google.common.collect.Sets;, +, +import org.elasticsearch.action.DocWriteResponse;, +import org.elasticsearch.action.admin.indices.refresh.RefreshResponse;, +import org.elasticsearch.action.update.UpdateResponse;, +import org.elasticsearch.threadpool.ThreadPool;, +import org.elasticsearch.xpack.core.security.action.ApiKey;, +import static org.hamcrest.Matchers.greaterThan;, +import static org.hamcrest.Matchers.nullValue;, +    private static final long DELETE_INTERVAL_MILLIS = 100L;, +            .put(ApiKeyService.DELETE_INTERVAL.getKey(), TimeValue.timeValueMillis(DELETE_INTERVAL_MILLIS)), +        awaitApiKeysRemoverCompletion();, +        deleteSecurityIndex();, +    }, +, +    private void awaitApiKeysRemoverCompletion() throws InterruptedException {, +        Client client = waitForExpiredApiKeysRemoverTriggerReadyAndGetClient().filterWithHeader(, +                Collections.singletonMap("Authorization", UsernamePasswordToken.basicAuthHeaderValue(SecuritySettingsSource.TEST_SUPERUSER,, +                        SecuritySettingsSourceField.TEST_PASSWORD_SECURE_STRING)));, +        List<CreateApiKeyResponse> createdApiKeys = createApiKeys(2, null);, +, +, +        securityClient.invalidateApiKey(InvalidateApiKeyRequest.usingApiKeyId(createdApiKeys.get(0).getId()), listener);, +, +        PlainActionFuture<GetApiKeyResponse> getApiKeyResponseListener = new PlainActionFuture<>();, +        securityClient.getApiKey(GetApiKeyRequest.usingRealmName("file"), getApiKeyResponseListener);, +        assertThat(getApiKeyResponseListener.get().getApiKeyInfos().length, is(2));, +, +        client = waitForExpiredApiKeysRemoverTriggerReadyAndGetClient().filterWithHeader(, +                Collections.singletonMap("Authorization", UsernamePasswordToken.basicAuthHeaderValue(SecuritySettingsSource.TEST_SUPERUSER,, +                        SecuritySettingsSourceField.TEST_PASSWORD_SECURE_STRING)));, +        securityClient = new SecurityClient(client);, +, +        // invalidate API key to trigger remover, +        listener = new PlainActionFuture<>();, +        securityClient.invalidateApiKey(InvalidateApiKeyRequest.usingApiKeyId(createdApiKeys.get(1).getId()), listener);, +        assertThat(listener.get().getInvalidatedApiKeys().size(), is(1));, +, +        awaitApiKeysRemoverCompletion();, +, +        refreshSecurityIndex();, +, +        // Verify that 1st invalidated API key is deleted whereas the next one is not, +        getApiKeyResponseListener = new PlainActionFuture<>();, +        securityClient.getApiKey(GetApiKeyRequest.usingRealmName("file"), getApiKeyResponseListener);, +        assertThat(getApiKeyResponseListener.get().getApiKeyInfos().length, is(1));, +        ApiKey apiKey = getApiKeyResponseListener.get().getApiKeyInfos()[0];, +        assertThat(apiKey.getId(), is(createdApiKeys.get(1).getId()));, +        assertThat(apiKey.isInvalidated(), is(true));, +    }, +, +    private Client waitForExpiredApiKeysRemoverTriggerReadyAndGetClient() throws Exception {, +        String nodeWithMostRecentRun = null;, +        long apiKeyLastTrigger = -1L;, +        for (String nodeName : internalCluster().getNodeNames()) {, +            ApiKeyService apiKeyService = internalCluster().getInstance(ApiKeyService.class, nodeName);, +            if (apiKeyService != null) {, +                if (apiKeyService.lastTimeWhenApiKeysRemoverWasTriggered() > apiKeyLastTrigger) {, +                    nodeWithMostRecentRun = nodeName;, +                    apiKeyLastTrigger = apiKeyService.lastTimeWhenApiKeysRemoverWasTriggered();, +               }, +            }]