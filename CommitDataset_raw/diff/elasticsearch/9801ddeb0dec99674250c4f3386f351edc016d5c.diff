[+++ b/modules/elasticsearch/src/main/java/org/elasticsearch/cluster/metadata/MetaDataCreateIndexService.java, +                    logger.warn("[{}] failed to create", e, request.index);, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/cluster/metadata/MetaDataCreateIndexService.java, +                    logger.warn("[{}] failed to create", e, request.index);, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/index/analysis/AnalysisModule.java, +import org.elasticsearch.ElasticSearchIllegalArgumentException;, +import org.elasticsearch.common.collect.Maps;, +import org.elasticsearch.common.settings.NoClassSettingsException;, +import org.elasticsearch.index.analysis.phonetic.PhoneticTokenFilterFactory;, +            private final Map<String, Class<? extends CharFilterFactory>> charFilters = Maps.newHashMap();, +            public CharFiltersBindings() {, +                charFilters.put(name, charFilterFactory);, +            private final Map<String, Class<? extends TokenFilterFactory>> tokenFilters = Maps.newHashMap();, +            public TokenFiltersBindings() {, +                tokenFilters.put(name, tokenFilterFactory);, +        // CHAR FILTERS, +, +        AnalysisBinderProcessor.CharFiltersBindings charFiltersBindings = new AnalysisBinderProcessor.CharFiltersBindings();, +        for (AnalysisBinderProcessor processor : processors) {, +            processor.processCharFilters(charFiltersBindings);, +        }, +, +            Class<? extends CharFilterFactory> type = null;, +            try {, +                type = charFilterSettings.getAsClass("type", null, "org.elasticsearch.index.analysis.", "CharFilterFactory");, +            } catch (NoClassSettingsException e) {, +                // nothing found, see if its in bindings as a binding name, +                if (charFilterSettings.get("type") != null) {, +                    type = charFiltersBindings.charFilters.get(charFilterSettings.get("type"));, +                }, +            }, +                // nothing found, see if its in bindings as a binding name, +                throw new ElasticSearchIllegalArgumentException("Char Filter [" + charFilterName + "] must have a type associated with it");, +        // go over the char filters in the bindings and register the ones that are not configured, +        for (Map.Entry<String, Class<? extends CharFilterFactory>> entry : charFiltersBindings.charFilters.entrySet()) {, +            String charFilterName = entry.getKey();, +            Class<? extends CharFilterFactory> clazz = entry.getValue();, +            // we don't want to re-register one that already exists, +            if (charFiltersSettings.containsKey(charFilterName)) {, +                continue;, +            }, +            // check, if it requires settings, then don't register it, we know default has no settings..., +            if (clazz.getAnnotation(AnalysisSettingsRequired.class) != null) {, +                continue;, +            }, +            // register it as default under the name, +            charFilterBinder.addBinding(charFilterName).toProvider(FactoryProvider.newFactory(CharFilterFactoryFactory.class, clazz)).in(Scopes.SINGLETON);, +        // TOKEN FILTERS, +, +        // initial default bindings, +        AnalysisBinderProcessor.TokenFiltersBindings tokenFiltersBindings = new AnalysisBinderProcessor.TokenFiltersBindings();, +        for (AnalysisBinderProcessor processor : processors) {, +            processor.processTokenFilters(tokenFiltersBindings);, +        }, +, +            Class<? extends TokenFilterFactory> type = null;, +            try {, +                type = tokenFilterSettings.getAsClass("type", null, "org.elasticsearch.index.analysis.", "TokenFilterFactory");, +            } catch (NoClassSettingsException e) {, +                // nothing found, see if its in bindings as a binding name, +                if (tokenFilterSettings.get("type") != null) {, +                    type = tokenFiltersBindings.tokenFilters.get(tokenFilterSettings.get("type"));, +                }, +            }, +                throw new ElasticSearchIllegalArgumentException("Token Filter [" + tokenFilterName + "] must have a type associated with it");, +        // go over the filters in the bindings and register the ones that are not configured, +        for (Map.Entry<String, Class<? extends TokenFilterFactory>> entry : tokenFiltersBindings.tokenFilters.entrySet()) {, +            String tokenFilterName = entry.getKey();, +            Class<? extends TokenFilterFactory> clazz = entry.getValue();, +            // we don't want to re-register one that already exists, +            if (tokenFiltersSettings.containsKey(tokenFilterName)) {, +                continue;, +            // check, if it requires settings, then don't register it, we know default has no settings..., +            if (clazz.getAnnotation(AnalysisSettingsRequired.class) != null) {, +                continue;, +            }, +            // register it as default under the name, +            tokenFilterBinder.addBinding(tokenFilterName).toProvider(FactoryProvider.newFactory(TokenFilterFactoryFactory.class, clazz)).in(Scopes.SINGLETON);, +        }, +, +        // TOKENIZER, +                throw new ElasticSearchIllegalArgumentException("Tokenizer [" + tokenizerName + "] must have a type associated with it");, +        // ANALYZER, +, +                    throw new ElasticSearchIllegalArgumentException("Analyzer [" + analyzerName + "] must have a type associated with it or a tokenizer");, +            tokenFiltersBindings.processTokenFilter("phonetic", PhoneticTokenFilterFactory.class);, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/cluster/metadata/MetaDataCreateIndexService.java, +                    logger.warn("[{}] failed to create", e, request.index);, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/index/analysis/AnalysisModule.java, +import org.elasticsearch.ElasticSearchIllegalArgumentException;, +import org.elasticsearch.common.collect.Maps;, +import org.elasticsearch.common.settings.NoClassSettingsException;, +import org.elasticsearch.index.analysis.phonetic.PhoneticTokenFilterFactory;, +            private final Map<String, Class<? extends CharFilterFactory>> charFilters = Maps.newHashMap();, +            public CharFiltersBindings() {, +                charFilters.put(name, charFilterFactory);, +            private final Map<String, Class<? extends TokenFilterFactory>> tokenFilters = Maps.newHashMap();, +            public TokenFiltersBindings() {, +                tokenFilters.put(name, tokenFilterFactory);, +        // CHAR FILTERS]