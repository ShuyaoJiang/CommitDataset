[+++ b/modules/transport-netty4/src/test/java/org/elasticsearch/transport/netty4/Netty4ScheduledPingTests.java, +        serviceA.registerRequestHandler("internal:sayHello", TransportRequest.Empty::new, ThreadPool.Names.GENERIC,, +            serviceB.submitRequest(nodeA, "internal:sayHello",, +++ b/modules/transport-netty4/src/test/java/org/elasticsearch/transport/netty4/Netty4ScheduledPingTests.java, +        serviceA.registerRequestHandler("internal:sayHello", TransportRequest.Empty::new, ThreadPool.Names.GENERIC,, +            serviceB.submitRequest(nodeA, "internal:sayHello",, +++ b/server/src/main/java/org/elasticsearch/discovery/zen/FaultDetection.java, +import org.elasticsearch.common.util.concurrent.AbstractRunnable;, +        public void onNodeDisconnected(DiscoveryNode node) {, +            AbstractRunnable runnable = new AbstractRunnable() {, +                @Override, +                public void onFailure(Exception e) {, +                    logger.warn("failed to handle transport disconnect for node: {}", node);, +                protected void doRun() {, +            };, +            threadPool.generic().execute(runnable);, +        }, +++ b/modules/transport-netty4/src/test/java/org/elasticsearch/transport/netty4/Netty4ScheduledPingTests.java, +        serviceA.registerRequestHandler("internal:sayHello", TransportRequest.Empty::new, ThreadPool.Names.GENERIC,, +            serviceB.submitRequest(nodeA, "internal:sayHello",, +++ b/server/src/main/java/org/elasticsearch/discovery/zen/FaultDetection.java, +import org.elasticsearch.common.util.concurrent.AbstractRunnable;, +        public void onNodeDisconnected(DiscoveryNode node) {, +            AbstractRunnable runnable = new AbstractRunnable() {, +                @Override, +                public void onFailure(Exception e) {, +                    logger.warn("failed to handle transport disconnect for node: {}", node);, +                protected void doRun() {, +            };, +            threadPool.generic().execute(runnable);, +        }, +++ b/server/src/main/java/org/elasticsearch/transport/TcpTransport.java, +import org.elasticsearch.common.collect.MapBuilder;, +import java.util.concurrent.CopyOnWriteArrayList;, +    private final DelegatingTransportConnectionListener transportListener = new DelegatingTransportConnectionListener();, +    private volatile Map<String, RequestHandlerRegistry> requestHandlers = Collections.emptyMap();, +    private final ResponseHandlers responseHandlers = new ResponseHandlers();, +    public void addConnectionListener(TransportConnectionListener listener) {, +        transportListener.listeners.add(listener);, +    }, +, +    @Override, +    public boolean removeConnectionListener(TransportConnectionListener listener) {, +        return transportListener.listeners.remove(listener);, +    }, +, +    @Override, +    public synchronized <Request extends TransportRequest> void registerRequestHandler(RequestHandlerRegistry<Request> reg) {, +        if (requestHandlers.containsKey(reg.getAction())) {, +            throw new IllegalArgumentException("transport handlers for action " + reg.getAction() + " is already registered");, +        requestHandlers = MapBuilder.newMapBuilder(requestHandlers).put(reg.getAction(), reg).immutableMap();, +                    transportListener.onConnectionClosed(this);, +                        transportListener.onNodeConnected(node);, +                                transportListener.onNodeDisconnected(node);, +                transportListener.onConnectionOpened(nodeChannels);, +                        transportListener.onNodeDisconnected(node);, +                IOUtils.closeWhileHandlingException(nodeChannels, () -> transportListener.onNodeDisconnected(node));, +                        transportListener.onNodeDisconnected(next.getKey());, +                () -> transportListener.onRequestSent(node, requestId, action, request, finalOptions), message.length());, +                () -> transportListener.onResponseSent(requestId, action, error), message.length());, +                () -> transportListener.onResponseSent(requestId, action, response, finalOptions), message.length());, +                    TransportResponseHandler theHandler = responseHandlers.onResponseReceived(requestId, transportListener);, +        transportListener.onRequestReceived(requestId, action);, +                final RequestHandlerRegistry reg = getRequestHandler(action);, +        final long requestId = responseHandlers.newRequestId();, +, +    private static final class DelegatingTransportConnectionListener implements TransportConnectionListener {, +        private final List<TransportConnectionListener> listeners = new CopyOnWriteArrayList<>();, +, +        @Override, +        public void onRequestReceived(long requestId, String action) {, +            for (TransportConnectionListener listener : listeners) {, +                listener.onRequestReceived(requestId, action);, +            }, +        }, +, +        @Override, +        public void onResponseSent(long requestId, String action, TransportResponse response, TransportResponseOptions finalOptions) {, +            for (TransportConnectionListener listener : listeners) {, +                listener.onResponseSent(requestId, action, response, finalOptions);, +            }, +        }, +, +        @Override, +        public void onResponseSent(long requestId, String action, Exception error) {, +            for (TransportConnectionListener listener : listeners) {, +                listener.onResponseSent(requestId, action, error);, +            }, +        }, +, +        @Override, +        public void onRequestSent(DiscoveryNode node, long requestId, String action, TransportRequest request,, +                                  TransportRequestOptions finalOptions) {, +            for (TransportConnectionListener listener : listeners) {, +                listener.onRequestSent(node, requestId, action, request, finalOptions);, +            }, +        }, +, +        @Override, +        public void onNodeDisconnected(DiscoveryNode key) {]