[+++ b/core/src/main/java/org/elasticsearch/common/io/stream/BytesStreamOutput.java, +    public void close() {, +++ b/core/src/main/java/org/elasticsearch/common/io/stream/BytesStreamOutput.java, +    public void close() {, +++ b/core/src/main/java/org/elasticsearch/indices/AbstractIndexShardCacheEntity.java, +    public final void onCached(IndicesRequestCache.Key key, BytesReference value) {, +    public final void onRemoval(RemovalNotification<IndicesRequestCache.Key, BytesReference> notification) {, +++ b/core/src/main/java/org/elasticsearch/common/io/stream/BytesStreamOutput.java, +    public void close() {, +++ b/core/src/main/java/org/elasticsearch/indices/AbstractIndexShardCacheEntity.java, +    public final void onCached(IndicesRequestCache.Key key, BytesReference value) {, +    public final void onRemoval(RemovalNotification<IndicesRequestCache.Key, BytesReference> notification) {, +++ b/core/src/main/java/org/elasticsearch/indices/IndicesRequestCache.java, +import java.util.function.Supplier;, +    BytesReference>, Closeable {, +    private final Cache<Key, BytesReference> cache;, +        CacheBuilder<Key, BytesReference> cacheBuilder = CacheBuilder.<Key, BytesReference>builder(), +    public void onRemoval(RemovalNotification<Key, BytesReference> notification) {, +    BytesReference getOrCompute(CacheEntity cacheEntity, Supplier<BytesReference> loader,, +            DirectoryReader reader, BytesReference cacheKey) throws Exception {, +        Loader cacheLoader = new Loader(cacheEntity, loader);, +        BytesReference value = cache.computeIfAbsent(key, cacheLoader);, +        if (cacheLoader.isLoaded()) {, +        return value;, +    private static class Loader implements CacheLoader<Key, BytesReference> {, +        private final Supplier<BytesReference> loader;, +        Loader(CacheEntity entity, Supplier<BytesReference> loader) {, +            this.loader = loader;, +        public BytesReference load(Key key) throws Exception {, +            BytesReference value = loader.get();, +    interface CacheEntity extends Accountable {, +         * Called after the value was loaded., +        void onCached(Key key, BytesReference value);, +        void onRemoval(RemovalNotification<Key, BytesReference> notification);, +        private static final long BASE_RAM_BYTES_USED = RamUsageEstimator.shallowSizeOfInstance(Key.class);, +, +            return BASE_RAM_BYTES_USED + entity.ramBytesUsed() + value.length();, +++ b/core/src/main/java/org/elasticsearch/common/io/stream/BytesStreamOutput.java, +    public void close() {, +++ b/core/src/main/java/org/elasticsearch/indices/AbstractIndexShardCacheEntity.java, +    public final void onCached(IndicesRequestCache.Key key, BytesReference value) {, +    public final void onRemoval(RemovalNotification<IndicesRequestCache.Key, BytesReference> notification) {, +++ b/core/src/main/java/org/elasticsearch/indices/IndicesRequestCache.java, +import java.util.function.Supplier;, +    BytesReference>, Closeable {, +    private final Cache<Key, BytesReference> cache;, +        CacheBuilder<Key, BytesReference> cacheBuilder = CacheBuilder.<Key, BytesReference>builder(), +    public void onRemoval(RemovalNotification<Key, BytesReference> notification) {, +    BytesReference getOrCompute(CacheEntity cacheEntity, Supplier<BytesReference> loader,, +            DirectoryReader reader, BytesReference cacheKey) throws Exception {, +        Loader cacheLoader = new Loader(cacheEntity, loader);, +        BytesReference value = cache.computeIfAbsent(key, cacheLoader);, +        if (cacheLoader.isLoaded()) {, +        return value;, +    private static class Loader implements CacheLoader<Key, BytesReference> {, +        private final Supplier<BytesReference> loader;, +        Loader(CacheEntity entity, Supplier<BytesReference> loader) {, +            this.loader = loader;, +        public BytesReference load(Key key) throws Exception {, +            BytesReference value = loader.get();, +    interface CacheEntity extends Accountable {, +         * Called after the value was loaded., +        void onCached(Key key, BytesReference value);, +        void onRemoval(RemovalNotification<Key, BytesReference> notification);, +        private static final long BASE_RAM_BYTES_USED = RamUsageEstimator.shallowSizeOfInstance(Key.class);, +, +            return BASE_RAM_BYTES_USED + entity.ramBytesUsed() + value.length();, +++ b/core/src/main/java/org/elasticsearch/indices/IndicesService.java, +import org.apache.lucene.util.RamUsageEstimator;, +import org.elasticsearch.common.io.stream.BytesStreamOutput;, +import org.elasticsearch.common.io.stream.StreamOutput;, +import java.util.function.Consumer;, +import java.util.function.Supplier;, +        indicesRequestCache.clear(new IndexShardCacheEntity(shard));, +        , +        boolean[] loadedFromCache = new boolean[] { true };, +        BytesReference bytesReference = cacheShardLevelResult(context.indexShard(), directoryReader, request.cacheKey(), out -> {, +            queryPhase.execute(context);, +            try {, +                context.queryResult().writeToNoId(out);, +            } catch (IOException e) {, +                throw new AssertionError("Could not serialize response", e);, +            }, +            loadedFromCache[0] = false;, +        });, +        if (loadedFromCache[0]) {, +            try {, +            } catch (IOException e) {, +                throw new IllegalStateException("Failed to write field stats output", e);, +            }, +    private BytesReference cacheShardLevelResult(IndexShard shard, DirectoryReader reader, BytesReference cacheKey, Consumer<StreamOutput> loader), +        IndexShardCacheEntity cacheEntity = new IndexShardCacheEntity(shard);, +        Supplier<BytesReference> supplier = () -> {, +            /* BytesStreamOutput allows to pass the expected size but by default uses, +             * BigArrays.PAGE_SIZE_IN_BYTES which is 16k. A common cached result ie., +             * a date histogram with 3 buckets is ~100byte so 16k might be very wasteful, +             * since we don't shrink to the actual size once we are done serializing., +             * By passing 512 as the expected size we will resize the byte array in the stream, +             * slowly until we hit the page size and don't waste too much memory for small query, +             * results.*/]