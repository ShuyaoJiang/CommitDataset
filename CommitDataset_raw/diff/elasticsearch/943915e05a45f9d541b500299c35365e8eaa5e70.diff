[+++ b/core/src/main/java/org/elasticsearch/index/engine/InternalEngine.java, +                failEngine("already closed by tragic event on the index writer", indexWriter.getTragicException());, +            } else if (translog.isOpen() == false && translog.getTragicException() != null) {, +                failEngine("already closed by tragic event on the translog", translog.getTragicException());, +        } else if (t != null &&, +            ((indexWriter.isOpen() == false && indexWriter.getTragicException() == t), +                || (translog.isOpen() == false && translog.getTragicException() == t))) {, +++ b/core/src/main/java/org/elasticsearch/index/engine/InternalEngine.java, +                failEngine("already closed by tragic event on the index writer", indexWriter.getTragicException());, +            } else if (translog.isOpen() == false && translog.getTragicException() != null) {, +                failEngine("already closed by tragic event on the translog", translog.getTragicException());, +        } else if (t != null &&, +            ((indexWriter.isOpen() == false && indexWriter.getTragicException() == t), +                || (translog.isOpen() == false && translog.getTragicException() == t))) {, +++ b/core/src/main/java/org/elasticsearch/index/translog/BufferingTranslogWriter.java, +                try {, +                } catch (Throwable ex) {, +                    closeWithTragicEvent(ex);, +                    throw ex;, +                }, +            } else {, +            }, +            operationCounter++;, +            ensureOpen();, +            final int bufferSize = bufferCount;, +            try {, +                Channels.writeToChannel(buffer, 0, bufferSize, channel);, +            } catch (Throwable ex) {, +                closeWithTragicEvent(ex);, +                throw ex;, +            }, +            writtenOffset += bufferSize;, +    public synchronized void sync() throws IOException {, +        if (syncNeeded()) {, +            ensureOpen(); // this call gives a better exception that the incRef if we are closed by a tragic event, +                final long offsetToSync;, +                final int opsCounter;, +                    offsetToSync = totalOffset;, +                    opsCounter = operationCounter;, +                ensureOpen(); // just for kicks - the checkpoint happens or not either way, +                try {, +                    checkpoint(offsetToSync, opsCounter, channelReference);, +                } catch (Throwable ex) {, +                    closeWithTragicEvent(ex);, +                    throw ex;, +                }, +                lastSyncedOffset = offsetToSync;, +++ b/core/src/main/java/org/elasticsearch/index/engine/InternalEngine.java, +                failEngine("already closed by tragic event on the index writer", indexWriter.getTragicException());, +            } else if (translog.isOpen() == false && translog.getTragicException() != null) {, +                failEngine("already closed by tragic event on the translog", translog.getTragicException());, +        } else if (t != null &&, +            ((indexWriter.isOpen() == false && indexWriter.getTragicException() == t), +                || (translog.isOpen() == false && translog.getTragicException() == t))) {, +++ b/core/src/main/java/org/elasticsearch/index/translog/BufferingTranslogWriter.java, +                try {, +                } catch (Throwable ex) {, +                    closeWithTragicEvent(ex);, +                    throw ex;, +                }, +            } else {, +            }, +            operationCounter++;, +            ensureOpen();, +            final int bufferSize = bufferCount;, +            try {, +                Channels.writeToChannel(buffer, 0, bufferSize, channel);, +            } catch (Throwable ex) {, +                closeWithTragicEvent(ex);, +                throw ex;, +            }, +            writtenOffset += bufferSize;, +    public synchronized void sync() throws IOException {, +        if (syncNeeded()) {, +            ensureOpen(); // this call gives a better exception that the incRef if we are closed by a tragic event, +                final long offsetToSync;, +                final int opsCounter;, +                    offsetToSync = totalOffset;, +                    opsCounter = operationCounter;, +                ensureOpen(); // just for kicks - the checkpoint happens or not either way, +                try {, +                    checkpoint(offsetToSync, opsCounter, channelReference);, +                } catch (Throwable ex) {, +                    closeWithTragicEvent(ex);, +                    throw ex;, +                }, +                lastSyncedOffset = offsetToSync;, +++ b/core/src/main/java/org/elasticsearch/index/translog/Translog.java, +    private volatile long lastCommittedTranslogFileGeneration = -1; // -1 is safe as it will not cause an translog deletion., +    /** Returns {@code true} if this {@code Translog} is still open. */, +    public boolean isOpen() {, +                    current.sync();, +                } finally {, +                    try {, +                }, +            newFile = TranslogWriter.create(config.getType(), shardId, translogUUID, fileGeneration, location.resolve(getFilename(fileGeneration)), new OnCloseRunnable(), config.getBufferSize(), getChannelFactory());, +    public Location add(Operation operation) throws IOException {, +        } catch (AlreadyClosedException | IOException ex) {, +            if (current.getTragicException() != null) {, +                try {]