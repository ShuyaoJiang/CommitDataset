[+++ b/core/src/test/java/org/elasticsearch/action/admin/indices/create/ShrinkIndexIT.java, +import org.elasticsearch.cluster.ClusterState;, +import org.elasticsearch.cluster.routing.ShardRouting;, +import org.elasticsearch.cluster.routing.allocation.decider.EnableAllocationDecider;, +import java.util.stream.Collectors;, +                .put("index.routing.allocation.require._name", discoveryNodes[0].getName()), +        // disable rebalancing to be able to capture the right stats. balancing can move the target primary, +        // making it hard to pin point the source shards., +        client().admin().cluster().prepareUpdateSettings().setTransientSettings(Settings.builder().put(, +            EnableAllocationDecider.CLUSTER_ROUTING_REBALANCE_ENABLE_SETTING.getKey(), "none", +        )).get();, +, +, +        // now merge source into a single shard index, +        // resolve true merge node - this is not always the node we required as all shards may be on another node, +        final ClusterState state = client().admin().cluster().prepareState().get().getState();, +        DiscoveryNode mergeNode = state.nodes().get(state.getRoutingTable().index("target").shard(0).primaryShard().currentNodeId());, +        logger.info("merge node {}", mergeNode);, +, +        final long maxSeqNo = Arrays.stream(sourceStats.getShards()), +            .filter(shard -> shard.getShardRouting().currentNodeId().equals(mergeNode.getId())), +            .map(ShardStats::getSeqNoStats).mapToLong(SeqNoStats::getMaxSeqNo).max().getAsLong();, +        final long maxUnsafeAutoIdTimestamp = Arrays.stream(sourceStats.getShards()), +            .filter(shard -> shard.getShardRouting().currentNodeId().equals(mergeNode.getId())), +            .map(ShardStats::getStats), +            .map(CommonStats::getSegments), +            .mapToLong(SegmentsStats::getMaxUnsafeAutoIdTimestamp), +            .max(), +            .getAsLong();, +, +        for (ShardStats shard: Arrays.stream(sourceStats.getShards()).filter(shard -> shard.getShardRouting().currentNodeId().equals(mergeNode.getId())).collect(Collectors.toList())) {, +            logger.info("used {}, timestamp: {}", shard.getShardRouting(), shard.getStats().getSegments().getMaxUnsafeAutoIdTimestamp());, +        }, +, +            final ShardRouting shardRouting = shardStats.getShardRouting();, +            assertThat("failed on " + shardRouting, seqNoStats.getMaxSeqNo(), equalTo(maxSeqNo));, +            assertThat("failed on " + shardRouting, seqNoStats.getLocalCheckpoint(), equalTo(maxSeqNo));, +            assertThat("failed on " + shardRouting,, +                shardStats.getStats().getSegments().getMaxUnsafeAutoIdTimestamp(), equalTo(maxUnsafeAutoIdTimestamp));, +, +        // clean up, +        client().admin().cluster().prepareUpdateSettings().setTransientSettings(Settings.builder().put(, +            EnableAllocationDecider.CLUSTER_ROUTING_REBALANCE_ENABLE_SETTING.getKey(), (String)null, +        )).get();]