[+++ b/core/src/main/java/org/elasticsearch/transport/TcpTransport.java, +                // first stop to accept any incoming connections so nobody can connect to this transport, +, +                stopInternal();, +            Thread.currentThread().interrupt();, +++ b/core/src/main/java/org/elasticsearch/transport/TcpTransport.java, +                // first stop to accept any incoming connections so nobody can connect to this transport, +, +                stopInternal();, +            Thread.currentThread().interrupt();, +++ b/test/framework/src/main/java/org/elasticsearch/transport/AbstractSimpleTransportTestCase.java, +    protected volatile DiscoveryNode nodeA;, +    protected volatile MockTransportService serviceA;, +    protected volatile DiscoveryNode nodeB;, +    protected volatile MockTransportService serviceB;, +++ b/core/src/main/java/org/elasticsearch/transport/TcpTransport.java, +                // first stop to accept any incoming connections so nobody can connect to this transport, +, +                stopInternal();, +            Thread.currentThread().interrupt();, +++ b/test/framework/src/main/java/org/elasticsearch/transport/AbstractSimpleTransportTestCase.java, +    protected volatile DiscoveryNode nodeA;, +    protected volatile MockTransportService serviceA;, +    protected volatile DiscoveryNode nodeB;, +    protected volatile MockTransportService serviceB;, +++ b/test/framework/src/main/java/org/elasticsearch/transport/MockTcpTransport.java, +            Thread.currentThread().interrupt();, +        /**, +         * Constructs a new MockChannel instance intended for handling the actual incoming / outgoing traffic., +         *, +         * @param socket The client socket. Mut not be null., +         * @param localAddress Address associated with the corresponding local server socket. Must not be null., +         * @param profile The associated profile name., +         * @param onClose Callback to execute when this channel is closed., +         */, +, +        /**, +         * Constructs a new MockChannel instance intended for accepting requests., +         *, +         * @param serverSocket The associated server socket. Must not be null., +         * @param profile The associated profile name., +         */, +        public MockChannel(ServerSocket serverSocket, String profile) {, +            this.localAddress = (InetSocketAddress) serverSocket.getLocalSocketAddress();, +            this.serverSocket = serverSocket;, +            this.profile = profile;, +            this.activeChannel = null;, +            this.onClose = null;, +        }, +, +                Socket incomingSocket = serverSocket.accept();, +                MockChannel incomingChannel = null;, +                try {, +                    configureSocket(incomingSocket);, +                    incomingChannel = new MockChannel(incomingSocket, localAddress, profile, workerChannels::remove);, +                    //establish a happens-before edge between closing and accepting a new connection, +                    synchronized (this) {, +                        if (isOpen.get()) {, +                            workerChannels.put(incomingChannel, Boolean.TRUE);, +                            // this spawns a new thread immediately, so OK under lock, +                            incomingChannel.loopRead(executor);, +                            // the channel is properly registered and will be cleared by the close code., +                            incomingSocket = null;, +                            incomingChannel = null;, +                        }, +                    }, +                } finally {, +                    // ensure we don't leak sockets and channels in the failure case. Note that we null both, +                    // if there are no exceptions so this becomes a no op., +                    IOUtils.closeWhileHandlingException(incomingSocket, incomingChannel);, +                }, +                    // There is a (slim) chance that we get interrupted right after a loop iteration, so check explicitly, +                    while (isOpen.get() && !Thread.currentThread().isInterrupted()) {, +                //establish a happens-before edge between closing and accepting a new connection, +                synchronized (this) {, +                    IOUtils.close(serverSocket, activeChannel, () -> IOUtils.close(workerChannels.keySet()),, +                        () -> cancellableThreads.cancel("channel closed"), onClose);, +                }]