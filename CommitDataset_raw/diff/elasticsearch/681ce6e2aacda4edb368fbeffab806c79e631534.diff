[+++ b/plugin/src/main/java/org/elasticsearch/xpack/watcher/Watcher.java, +                clock, watchParser, clusterService, internalClient);, +++ b/plugin/src/main/java/org/elasticsearch/xpack/watcher/Watcher.java, +                clock, watchParser, clusterService, internalClient);, +++ b/plugin/src/main/java/org/elasticsearch/xpack/watcher/WatcherService.java, +                executionService.start();, +++ b/plugin/src/main/java/org/elasticsearch/xpack/watcher/Watcher.java, +                clock, watchParser, clusterService, internalClient);, +++ b/plugin/src/main/java/org/elasticsearch/xpack/watcher/WatcherService.java, +                executionService.start();, +++ b/plugin/src/main/java/org/elasticsearch/xpack/watcher/execution/ExecutionService.java, +                            Clock clock, Watch.Parser parser, ClusterService clusterService, Client client) {, +    public void start() throws Exception {, +        currentExecutions.sort(Comparator.comparing(WatchExecutionSnapshot::executionTime));, +        executor.tasks().forEach(snapshot::add);, +        queuedWatches.sort(Comparator.comparing(QueuedWatch::executionTime));, +            executor.execute(new WatchExecutionTask(ctx, () -> execute(ctx)));, +    // the watch execution task takes another runnable as parameter, +    // the best solution would be to move the whole execute() method, which is handed over as ctor parameter, +    // over into this class, this is the quicker way though, +    static final class WatchExecutionTask implements Runnable {, +        private final Runnable runnable;, +        WatchExecutionTask(WatchExecutionContext ctx, Runnable runnable) {, +            this.runnable = runnable;, +            runnable.run();, +    static class WatchExecution {, +        WatchExecution(WatchExecutionContext context, Thread executionThread) {, +        WatchExecutionSnapshot createSnapshot() {, +++ b/plugin/src/main/java/org/elasticsearch/xpack/watcher/Watcher.java, +                clock, watchParser, clusterService, internalClient);, +++ b/plugin/src/main/java/org/elasticsearch/xpack/watcher/WatcherService.java, +                executionService.start();, +++ b/plugin/src/main/java/org/elasticsearch/xpack/watcher/execution/ExecutionService.java, +                            Clock clock, Watch.Parser parser, ClusterService clusterService, Client client) {, +    public void start() throws Exception {, +        currentExecutions.sort(Comparator.comparing(WatchExecutionSnapshot::executionTime));, +        executor.tasks().forEach(snapshot::add);, +        queuedWatches.sort(Comparator.comparing(QueuedWatch::executionTime));, +            executor.execute(new WatchExecutionTask(ctx, () -> execute(ctx)));, +    // the watch execution task takes another runnable as parameter, +    // the best solution would be to move the whole execute() method, which is handed over as ctor parameter, +    // over into this class, this is the quicker way though, +    static final class WatchExecutionTask implements Runnable {, +        private final Runnable runnable;, +        WatchExecutionTask(WatchExecutionContext ctx, Runnable runnable) {, +            this.runnable = runnable;, +            runnable.run();, +    static class WatchExecution {, +        WatchExecution(WatchExecutionContext context, Thread executionThread) {, +        WatchExecutionSnapshot createSnapshot() {, +++ b/plugin/src/test/java/org/elasticsearch/xpack/watcher/execution/ExecutionServiceTests.java, +import org.elasticsearch.xpack.watcher.trigger.TriggerEvent;, +import java.util.ArrayList;, +import java.util.Collection;, +import java.util.List;, +import static org.hamcrest.Matchers.hasSize;, +import static org.joda.time.DateTimeZone.UTC;, +import static org.mockito.Matchers.anyObject;, +        executionService = new ExecutionService(Settings.EMPTY, historyStore, triggeredWatchStore, executor, clock, parser,, +                clusterService, client);, +        executionService.start();, +        DateTime now = now(UTC);, +        DateTime now = now(UTC);, +        DateTime now = now(UTC);, +        DateTime now = DateTime.now(UTC);, +        DateTime now = DateTime.now(UTC);, +    public void testCurrentExecutionSnapshots() throws Exception {, +        DateTime time = DateTime.now(UTC);, +        int snapshotCount = randomIntBetween(2, 8);, +        for (int i = 0; i < snapshotCount; i++) {, +            time = time.minusSeconds(10);, +            WatchExecutionContext ctx = createMockWatchExecutionContext("_id" + i, time);, +            executionService.getCurrentExecutions().put("_id" + i, new ExecutionService.WatchExecution(ctx, Thread.currentThread()));, +        }, +, +        List<WatchExecutionSnapshot> snapshots = executionService.currentExecutions();, +        assertThat(snapshots, hasSize(snapshotCount));, +        assertThat(snapshots.get(0).watchId(), is("_id" + (snapshotCount-1)));, +        assertThat(snapshots.get(snapshots.size() - 1).watchId(), is("_id0"));, +    }, +, +    public void testQueuedWatches() throws Exception {, +        Collection<Runnable> tasks = new ArrayList<>();, +        DateTime time = DateTime.now(UTC);, +        int queuedWatchCount = randomIntBetween(2, 8);, +        for (int i = 0; i < queuedWatchCount; i++) {, +            time = time.minusSeconds(10);, +            WatchExecutionContext ctx = createMockWatchExecutionContext("_id" + i, time);, +            tasks.add(new ExecutionService.WatchExecutionTask(ctx, () -> logger.info("this will never be called")));, +        }, +, +        when(executor.tasks()).thenReturn(tasks.stream());, +, +        List<QueuedWatch> queuedWatches = executionService.queuedWatches();, +        assertThat(queuedWatches, hasSize(queuedWatchCount));, +        assertThat(queuedWatches.get(0).watchId(), is("_id" + (queuedWatchCount-1)));, +        assertThat(queuedWatches.get(queuedWatches.size() - 1).watchId(), is("_id0"));, +    }, +, +    private WatchExecutionContext createMockWatchExecutionContext(String watchId, DateTime executionTime) {]