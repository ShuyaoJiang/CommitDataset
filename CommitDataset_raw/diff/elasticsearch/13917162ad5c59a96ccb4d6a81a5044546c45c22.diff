[+++ b/server/src/main/java/org/elasticsearch/index/seqno/ReplicationTracker.java, +        // all pending in sync shards are tracked, +        for (String aId : pendingInSync) {, +            assert checkpoints.get(aId) != null : "aId [" + aId + "] is pending in sync but isn't tracked";, +        }, +, +                if (removedEntries) {, +                    pendingInSync.removeIf(aId -> checkpoints.containsKey(aId) == false);, +                }, +                // notify any waiter for local checkpoint advancement to recheck that their shard is still being tracked., +                notifyAllWaiters();, +++ b/server/src/main/java/org/elasticsearch/index/seqno/ReplicationTracker.java, +        // all pending in sync shards are tracked, +        for (String aId : pendingInSync) {, +            assert checkpoints.get(aId) != null : "aId [" + aId + "] is pending in sync but isn't tracked";, +        }, +, +                if (removedEntries) {, +                    pendingInSync.removeIf(aId -> checkpoints.containsKey(aId) == false);, +                }, +                // notify any waiter for local checkpoint advancement to recheck that their shard is still being tracked., +                notifyAllWaiters();, +++ b/server/src/test/java/org/elasticsearch/index/seqno/ReplicationTrackerTests.java, +        final long clusterStateVersion = randomNonNegativeLong();, +        tracker.updateFromMaster(clusterStateVersion, Collections.singleton(inSyncAllocationId.getId()),, +        if (randomBoolean()) {, +            // normal path, shard catches up, +        } else {, +            // master changes its mind and cancels the allocation, +            tracker.updateFromMaster(clusterStateVersion + 1, Collections.singleton(inSyncAllocationId.getId()),, +                routingTable(emptySet(), inSyncAllocationId), emptySet());, +            barrier.await();, +            assertTrue(complete.get());, +            assertNull(tracker.getTrackedLocalCheckpointForShard(trackingAllocationId.getId()));, +        }]