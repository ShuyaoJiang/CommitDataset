[+++ b/core/src/main/java/org/elasticsearch/common/util/iterable/Iterables.java, +    /** Flattens the two level {@code Iterable} into a single {@code Iterable}.  Note that this pre-caches the values from the outer {@code, +     *  Iterable}, but not the values from the inner one. */, +++ b/core/src/main/java/org/elasticsearch/common/util/iterable/Iterables.java, +    /** Flattens the two level {@code Iterable} into a single {@code Iterable}.  Note that this pre-caches the values from the outer {@code, +     *  Iterable}, but not the values from the inner one. */, +++ b/core/src/main/java/org/elasticsearch/index/mapper/DocumentParser.java, +import org.elasticsearch.common.collect.Tuple;, +            context.path().add(currentFieldName);, +            context.path().remove();, +, +            final String[] paths = currentFieldName.split("\\.");, +            currentFieldName = paths[paths.length - 1];, +            Tuple<Integer, ObjectMapper> parentMapperTuple = getDynamicParentMapper(context, paths, mapper);, +            ObjectMapper parentMapper = parentMapperTuple.v2();, +            ObjectMapper.Dynamic dynamic = dynamicOrDefault(parentMapper, context);, +                context.path().remove();, +            for (int i = 0; i < parentMapperTuple.v1(); i++) {, +                context.path().remove();, +            }, +            final String[] paths = arrayFieldName.split("\\.");, +            arrayFieldName = paths[paths.length - 1];, +            lastFieldName = arrayFieldName;, +            Tuple<Integer, ObjectMapper> parentMapperTuple = getDynamicParentMapper(context, paths, parentMapper);, +            parentMapper = parentMapperTuple.v2();, +                } else {, +                }, +            for (int i = 0; i < parentMapperTuple.v1(); i++) {, +                context.path().remove();, +            }, +, +            final String[] paths = currentFieldName.split("\\.");, +            currentFieldName = paths[paths.length - 1];, +            Tuple<Integer, ObjectMapper> parentMapperTuple = getDynamicParentMapper(context, paths, parentMapper);, +            parentMapper = parentMapperTuple.v2();, +            for (int i = 0; i < parentMapperTuple.v1(); i++) {, +                context.path().remove();, +            }, +            Tuple<Integer, ObjectMapper> parentMapperTuple = getDynamicParentMapper(context, paths, null);, +            ObjectMapper mapper = parentMapperTuple.v2();, +            parseDynamicValue(context, mapper, fieldName, context.parser().currentToken());, +            for (int i = 0; i < parentMapperTuple.v1(); i++) {, +                context.path().remove();, +            }, +        }, +    }, +, +    private static Tuple<Integer, ObjectMapper> getDynamicParentMapper(ParseContext context, final String[] paths,, +            ObjectMapper currentParent) {, +        ObjectMapper mapper = currentParent == null ? context.root() : currentParent;, +        int pathsAdded = 0;, +            ObjectMapper parent = mapper;, +            String currentPath = context.path().pathAsText(paths[i]);, +            FieldMapper existingFieldMapper = context.docMapper().mappers().getMapper(currentPath);, +            if (existingFieldMapper != null) {, +                throw new MapperParsingException(, +                        "Could not dynamically add mapping for field [{}]. Existing mapping for [{}] must be of type object but found [{}].",, +                        null, String.join(".", paths), currentPath, existingFieldMapper.fieldType.typeName());, +            }, +            mapper = context.docMapper().objectMappers().get(currentPath);, +                           // Should not dynamically create any more mappers so return the last mapper, +                        return new Tuple<Integer, ObjectMapper>(pathsAdded, parent);, +                pathsAdded++;, +        return new Tuple<Integer, ObjectMapper>(pathsAdded, mapper);, +++ b/core/src/main/java/org/elasticsearch/common/util/iterable/Iterables.java, +    /** Flattens the two level {@code Iterable} into a single {@code Iterable}.  Note that this pre-caches the values from the outer {@code, +     *  Iterable}, but not the values from the inner one. */, +++ b/core/src/main/java/org/elasticsearch/index/mapper/DocumentParser.java, +import org.elasticsearch.common.collect.Tuple;, +            context.path().add(currentFieldName);, +            context.path().remove();, +, +            final String[] paths = currentFieldName.split("\\.");, +            currentFieldName = paths[paths.length - 1];, +            Tuple<Integer, ObjectMapper> parentMapperTuple = getDynamicParentMapper(context, paths, mapper);, +            ObjectMapper parentMapper = parentMapperTuple.v2();, +            ObjectMapper.Dynamic dynamic = dynamicOrDefault(parentMapper, context);, +                context.path().remove();, +            for (int i = 0; i < parentMapperTuple.v1(); i++) {, +                context.path().remove();, +            }, +            final String[] paths = arrayFieldName.split("\\.");, +            arrayFieldName = paths[paths.length - 1];, +            lastFieldName = arrayFieldName;, +            Tuple<Integer, ObjectMapper> parentMapperTuple = getDynamicParentMapper(context, paths, parentMapper);, +            parentMapper = parentMapperTuple.v2();, +                } else {, +                }, +            for (int i = 0; i < parentMapperTuple.v1(); i++) {, +                context.path().remove();, +            }, +, +            final String[] paths = currentFieldName.split("\\.");, +            currentFieldName = paths[paths.length - 1];, +            Tuple<Integer, ObjectMapper> parentMapperTuple = getDynamicParentMapper(context, paths, parentMapper);, +            parentMapper = parentMapperTuple.v2();, +            for (int i = 0; i < parentMapperTuple.v1(); i++) {, +                context.path().remove();, +            }, +            Tuple<Integer, ObjectMapper> parentMapperTuple = getDynamicParentMapper(context, paths, null);]