[+++ b/server/src/main/java/org/elasticsearch/env/NodeEnvironment.java, +import java.io.UncheckedIOException;, +import java.util.Iterator;, +import java.util.stream.Collectors;, +import java.util.stream.Stream;, +        Set<Path> existingPaths = Stream.of(paths), +            .filter(FileSystemUtils::exists), +            .filter(leftOver -> {, +                // Relaxed assertion for the special case where only the empty state directory exists after deleting, +                // the shard directory because it was created again as a result of a metadata read action concurrently., +                try (DirectoryStream<Path> children = Files.newDirectoryStream(leftOver)) {, +                    Iterator<Path> iter = children.iterator();, +                    if (iter.hasNext() == false) {, +                        return true;, +                    Path maybeState = iter.next();, +                    if (iter.hasNext() || maybeState.equals(leftOver.resolve(MetaDataStateFormat.STATE_DIR_NAME)) == false) {, +                        return true;, +                    try (DirectoryStream<Path> stateChildren = Files.newDirectoryStream(maybeState)) {, +                        return stateChildren.iterator().hasNext();, +                    }, +                } catch (IOException e) {, +                    throw new UncheckedIOException(e);, +                }, +            }).collect(Collectors.toSet());, +++ b/server/src/main/java/org/elasticsearch/env/NodeEnvironment.java, +import java.io.UncheckedIOException;, +import java.util.Iterator;, +import java.util.stream.Collectors;, +import java.util.stream.Stream;, +        Set<Path> existingPaths = Stream.of(paths), +            .filter(FileSystemUtils::exists), +            .filter(leftOver -> {, +                // Relaxed assertion for the special case where only the empty state directory exists after deleting, +                // the shard directory because it was created again as a result of a metadata read action concurrently., +                try (DirectoryStream<Path> children = Files.newDirectoryStream(leftOver)) {, +                    Iterator<Path> iter = children.iterator();, +                    if (iter.hasNext() == false) {, +                        return true;, +                    Path maybeState = iter.next();, +                    if (iter.hasNext() || maybeState.equals(leftOver.resolve(MetaDataStateFormat.STATE_DIR_NAME)) == false) {, +                        return true;, +                    try (DirectoryStream<Path> stateChildren = Files.newDirectoryStream(maybeState)) {, +                        return stateChildren.iterator().hasNext();, +                    }, +                } catch (IOException e) {, +                    throw new UncheckedIOException(e);, +                }, +            }).collect(Collectors.toSet());, +++ b/server/src/test/java/org/elasticsearch/indices/recovery/IndexRecoveryIT.java]