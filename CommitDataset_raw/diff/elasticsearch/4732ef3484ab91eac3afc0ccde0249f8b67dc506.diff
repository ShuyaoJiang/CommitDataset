[+++ b/src/main/java/org/elasticsearch/index/engine/Engine.java, +     * Flushes the state of the engine including the transaction log, clearing memory., +     * @param force if <code>true</code> a lucene commit is executed even if no changes need to be committed., +     * @param waitIfOngoing if <code>true</code> this call will block until all currently running flushes have finished., +     *                      Otherwise this call will return without blocking., +    void flush(boolean force, boolean waitIfOngoing) throws EngineException;, +, +    /**, +     * Flushes the state of the engine including the transaction log, clearing memory and persisting, +     * documents in the lucene index to disk including a potentially heavy and durable fsync operation., +     * This operation is not going to block if another flush operation is currently running and won't write, +     * a lucene commit if nothing needs to be committed., +     */, +    void flush() throws EngineException;, +++ b/src/main/java/org/elasticsearch/index/engine/Engine.java, +     * Flushes the state of the engine including the transaction log, clearing memory., +     * @param force if <code>true</code> a lucene commit is executed even if no changes need to be committed., +     * @param waitIfOngoing if <code>true</code> this call will block until all currently running flushes have finished., +     *                      Otherwise this call will return without blocking., +    void flush(boolean force, boolean waitIfOngoing) throws EngineException;, +, +    /**, +     * Flushes the state of the engine including the transaction log, clearing memory and persisting, +     * documents in the lucene index to disk including a potentially heavy and durable fsync operation., +     * This operation is not going to block if another flush operation is currently running and won't write, +     * a lucene commit if nothing needs to be committed., +     */, +    void flush() throws EngineException;, +++ b/src/main/java/org/elasticsearch/index/engine/internal/InternalEngine.java, +    private final IndexWriter indexWriter;, +    private final SearcherManager searcherManager;, +        this.versionMap = new LiveVersionMap();, +        IndexWriter writer = null;, +        SearcherManager manager = null;, +            try {, +                writer = createWriter();, +            } catch (IOException e) {, +                throw new EngineCreationFailureException(shardId, "failed to create engine", e);, +            }, +            manager = createSearcherManager();, +            this.searcherManager = manager;, +                IOUtils.closeWhileHandlingException(writer, manager);, +                versionMap.clear();, +            // its inactive, make sure we do a refresh / full IW flush in this case, since the memory, +            // the index writer lazily allocates memory and a refresh will clean it all up., +                    refresh("update index buffer");, +                    logger.warn("failed to refresh after setting shard to inactive", e);, +    private SearcherManager createSearcherManager() throws EngineException {, +                final DirectoryReader directoryReader = ElasticsearchDirectoryReader.wrap(DirectoryReader.open(indexWriter, true), shardId);, +                searcherManager = new SearcherManager(directoryReader, searcherFactory);, +                return searcherManager;, +            ensureOpen();, +            ensureOpen();, +                innerCreate(create);, +                    innerCreate(create);, +    private void innerCreate(Create create) throws IOException {, +            innerCreateNoLock(create, Versions.NOT_FOUND, null);, +                innerCreateNoLock(create, currentVersion, versionValue);, +    private void innerCreateNoLock(Create create, long currentVersion, VersionValue versionValue) throws IOException {, +                indexWriter.updateDocuments(create.uid(), create.docs());, +                indexWriter.updateDocument(create.uid(), create.docs().get(0));, +                indexWriter.addDocuments(create.docs());, +                indexWriter.addDocument(create.docs().get(0));, +            ensureOpen();, +                innerIndex(index);, +                    innerIndex(index);, +    private void innerIndex(Index index) throws IOException {, +                    indexWriter.addDocuments(index.docs());, +                    indexWriter.addDocument(index.docs().get(0));, +                    indexWriter.updateDocuments(index.uid(), index.docs());, +                    indexWriter.updateDocument(index.uid(), index.docs().get(0));, +            ensureOpen();, +            innerDelete(delete);, +    private void innerDelete(Delete delete) throws IOException {, +                indexWriter.deleteDocuments(delete.uid());, +            ensureOpen();, +    public void flush() throws EngineException {, +        flush(true, false, false);, +    }, +, +    @Override, +    public void flush(boolean force, boolean waitIfOngoing) throws EngineException {, +        flush(true, force, waitIfOngoing);, +    }, +, +    private void flush(boolean commitTranslog, boolean force, boolean waitIfOngoing) throws EngineException {, +        if (commitTranslog) {, +                throw new FlushNotAllowedEngineException(shardId, "recovery is in progress, flush with committing translog is not allowed");, +             if (commitTranslog) {, +                    ensureOpen();, +            } else  {, +                    ensureOpen();, +            method.invoke(indexWriter);, +            flush(true, true, true);, +                ensureOpen();, +                MergePolicy mp = indexWriter.getConfig().getMergePolicy();, +                    indexWriter.forceMergeDeletes(false);, +                    indexWriter.maybeMerge();, +                    indexWriter.forceMerge(maxNumSegments, false);, +        flush(false, false, true);]