[+++ b/src/main/java/org/elasticsearch/index/search/nested/NestedFieldComparatorSource.java, +                } else if (cmp1 == 0) {, +    static abstract class NumericNestedFieldComparatorBase extends NestedFieldComparator {, +        protected NumberComparatorBase numberComparator;, +        NumericNestedFieldComparatorBase(NumberComparatorBase wrappedComparator, Filter rootDocumentsFilter, Filter innerDocumentsFilter, int spareSlot) {, +            super(wrappedComparator, rootDocumentsFilter, innerDocumentsFilter, spareSlot);, +            this.numberComparator = wrappedComparator;, +        }, +, +        @Override, +        public final int compareBottom(int rootDoc) throws IOException {, +            if (rootDoc == 0 || rootDocuments == null || innerDocuments == null) {, +                return compareBottomMissing(wrappedComparator);, +            }, +, +            final int prevRootDoc = rootDocuments.prevSetBit(rootDoc - 1);, +            int nestedDoc = innerDocuments.nextSetBit(prevRootDoc + 1);, +            if (nestedDoc >= rootDoc || nestedDoc == -1) {, +                return compareBottomMissing(wrappedComparator);, +            }, +, +            int counter = 1;, +            wrappedComparator.copy(spareSlot, nestedDoc);, +            nestedDoc = innerDocuments.nextSetBit(nestedDoc + 1);, +            while (nestedDoc > prevRootDoc && nestedDoc < rootDoc) {, +                onNested(spareSlot, nestedDoc);, +                nestedDoc = innerDocuments.nextSetBit(nestedDoc + 1);, +                counter++;, +            }, +            afterNested(spareSlot, counter);, +            return compare(bottomSlot, spareSlot);, +        }, +, +        @Override, +        public final void copy(int slot, int rootDoc) throws IOException {, +            if (rootDoc == 0 || rootDocuments == null || innerDocuments == null) {, +                copyMissing(wrappedComparator, slot);, +                return;, +            }, +, +            final int prevRootDoc = rootDocuments.prevSetBit(rootDoc - 1);, +            int nestedDoc = innerDocuments.nextSetBit(prevRootDoc + 1);, +            if (nestedDoc >= rootDoc || nestedDoc == -1) {, +                copyMissing(wrappedComparator, slot);, +                return;, +            }, +            int counter = 1;, +            wrappedComparator.copy(slot, nestedDoc);, +            nestedDoc = innerDocuments.nextSetBit(nestedDoc + 1);, +            while (nestedDoc > prevRootDoc && nestedDoc < rootDoc) {, +                onNested(slot, nestedDoc);, +                nestedDoc = innerDocuments.nextSetBit(nestedDoc + 1);, +                counter++;, +            }, +            afterNested(slot, counter);, +        }, +        , +        protected abstract void onNested(int slot, int nestedDoc);, +        , +        protected abstract void afterNested(int slot, int count);, +, +        @Override, +        public final FieldComparator setNextReader(AtomicReaderContext context) throws IOException {, +            super.setNextReader(context);, +            numberComparator = (NumberComparatorBase) super.wrappedComparator;, +            return this;, +        }, +    }, +, +    final static class Sum extends NumericNestedFieldComparatorBase {, +        protected void onNested(int slot, int nestedDoc) {, +            numberComparator.add(slot, nestedDoc);, +        protected void afterNested(int slot, int count) {, +    final static class Avg extends NumericNestedFieldComparatorBase {, +        protected void onNested(int slot, int nestedDoc) {, +            numberComparator.add(slot, nestedDoc);, +        protected void afterNested(int slot, int count) {, +            numberComparator.divide(slot, count);]