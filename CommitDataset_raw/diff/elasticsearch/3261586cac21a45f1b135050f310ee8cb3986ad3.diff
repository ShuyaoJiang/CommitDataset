[+++ b/core/src/main/java/org/elasticsearch/index/reindex/WorkingBulkByScrollTask.java, +        /* Drop the throttle to 0, immediately rescheduling any throttled, +         * operation so it will wake up and cancel itself. */, +        rethrottle(Float.POSITIVE_INFINITY);, +            logger.debug("[{}]: preparing bulk request for [{}]", getId(), delay);, +        if (requestsPerSecond <= 0) {, +            throw new IllegalArgumentException("requests per second must be more than 0 but was [" + requestsPerSecond + "]");, +        }, +                // No request has been queued so nothing to reschedule., +            if (newRequestsPerSecond < requestsPerSecond) {, +                /* The user is attempting to slow the request down. We'll let the, +                 * change in throttle take effect the next time we delay, +                 * prepareBulkRequest. We can't just reschedule the request further, +                 * out in the future because the bulk context might time out. */, +            /* Strangely enough getting here doesn't mean that you actually, +             * cancelled the request, just that you probably did. If you stress, +             * test it you'll find that requests sneak through. So each request, +             * is given a runOnce boolean to prevent that. */, +            if (remainingDelay < 0) {, +++ b/core/src/main/java/org/elasticsearch/index/reindex/WorkingBulkByScrollTask.java, +        /* Drop the throttle to 0, immediately rescheduling any throttled, +         * operation so it will wake up and cancel itself. */, +        rethrottle(Float.POSITIVE_INFINITY);, +            logger.debug("[{}]: preparing bulk request for [{}]", getId(), delay);, +        if (requestsPerSecond <= 0) {, +            throw new IllegalArgumentException("requests per second must be more than 0 but was [" + requestsPerSecond + "]");, +        }, +                // No request has been queued so nothing to reschedule., +            if (newRequestsPerSecond < requestsPerSecond) {, +                /* The user is attempting to slow the request down. We'll let the, +                 * change in throttle take effect the next time we delay, +                 * prepareBulkRequest. We can't just reschedule the request further, +                 * out in the future because the bulk context might time out. */, +            /* Strangely enough getting here doesn't mean that you actually, +             * cancelled the request, just that you probably did. If you stress, +             * test it you'll find that requests sneak through. So each request, +             * is given a runOnce boolean to prevent that. */, +            if (remainingDelay < 0) {, +++ b/core/src/main/java/org/elasticsearch/tasks/CancellableTask.java, +     * Returns true if this task can potentially have children that need to be cancelled when it parent is cancelled., +++ b/core/src/main/java/org/elasticsearch/index/reindex/WorkingBulkByScrollTask.java, +        /* Drop the throttle to 0, immediately rescheduling any throttled, +         * operation so it will wake up and cancel itself. */, +        rethrottle(Float.POSITIVE_INFINITY);, +            logger.debug("[{}]: preparing bulk request for [{}]", getId(), delay);, +        if (requestsPerSecond <= 0) {, +            throw new IllegalArgumentException("requests per second must be more than 0 but was [" + requestsPerSecond + "]");, +        }, +                // No request has been queued so nothing to reschedule., +            if (newRequestsPerSecond < requestsPerSecond) {, +                /* The user is attempting to slow the request down. We'll let the, +                 * change in throttle take effect the next time we delay, +                 * prepareBulkRequest. We can't just reschedule the request further, +                 * out in the future because the bulk context might time out. */, +            /* Strangely enough getting here doesn't mean that you actually, +             * cancelled the request, just that you probably did. If you stress, +             * test it you'll find that requests sneak through. So each request, +             * is given a runOnce boolean to prevent that. */, +            if (remainingDelay < 0) {, +++ b/core/src/main/java/org/elasticsearch/tasks/CancellableTask.java, +     * Returns true if this task can potentially have children that need to be cancelled when it parent is cancelled., +++ b/modules/reindex/src/main/java/org/elasticsearch/index/reindex/AbstractAsyncBulkByScrollAction.java, +import org.apache.logging.log4j.message.ParameterizedMessage;, +        logger.debug("[{}]: starting", task.getId());, +            logger.debug("[{}]: finishing early because the task was cancelled", task.getId());, +        logger.debug("[{}]: got scroll response with [{}] hits", task.getId(), response.getHits().size());, +            logger.debug("[{}]: finishing early because the task was cancelled", task.getId());, +        logger.debug("[{}]: preparing bulk request", task.getId());, +            logger.debug("[{}]: finishing early because the task was cancelled", task.getId());, +        if (logger.isDebugEnabled()) {, +            logger.debug("[{}]: sending [{}] entry, [{}] bulk request", task.getId(), request.requests().size(),, +                    new ByteSizeValue(request.estimatedSizeInBytes()));, +        }, +            logger.debug("[{}]: finishing early because the task was cancelled", task.getId());, +                logger.debug("[{}]: Finishing early because the task was cancelled", task.getId());, +            logger.debug("[{}]: finishing early because the task was cancelled", task.getId());, +        logger.debug("[{}]: refreshing", task.getId());, +        logger.debug(() -> new ParameterizedMessage("[{}]: finishing with a catastrophic failure", task.getId()), failure);, +        logger.debug("[{}]: finishing without any catastrophic failures", task.getId());, +++ b/core/src/main/java/org/elasticsearch/index/reindex/WorkingBulkByScrollTask.java, +        /* Drop the throttle to 0, immediately rescheduling any throttled, +         * operation so it will wake up and cancel itself. */, +        rethrottle(Float.POSITIVE_INFINITY);, +            logger.debug("[{}]: preparing bulk request for [{}]", getId(), delay);, +        if (requestsPerSecond <= 0) {, +            throw new IllegalArgumentException("requests per second must be more than 0 but was [" + requestsPerSecond + "]");, +        }, +                // No request has been queued so nothing to reschedule., +            if (newRequestsPerSecond < requestsPerSecond) {, +                /* The user is attempting to slow the request down. We'll let the, +                 * change in throttle take effect the next time we delay, +                 * prepareBulkRequest. We can't just reschedule the request further, +                 * out in the future because the bulk context might time out. */, +            /* Strangely enough getting here doesn't mean that you actually, +             * cancelled the request, just that you probably did. If you stress, +             * test it you'll find that requests sneak through. So each request, +             * is given a runOnce boolean to prevent that. */, +            if (remainingDelay < 0) {, +++ b/core/src/main/java/org/elasticsearch/tasks/CancellableTask.java, +     * Returns true if this task can potentially have children that need to be cancelled when it parent is cancelled.]