[+++ b/x-pack/plugin/watcher/src/main/java/org/elasticsearch/xpack/watcher/WatcherLifeCycleService.java, +            watcherService.start(event.state(), () -> this.state.set(WatcherState.STARTED));, +                    this.state.set(WatcherState.STARTING);, +                    watcherService.start(event.state(), () -> this.state.set(WatcherState.STARTED));, +++ b/x-pack/plugin/watcher/src/main/java/org/elasticsearch/xpack/watcher/WatcherLifeCycleService.java, +            watcherService.start(event.state(), () -> this.state.set(WatcherState.STARTED));, +                    this.state.set(WatcherState.STARTING);, +                    watcherService.start(event.state(), () -> this.state.set(WatcherState.STARTED));, +++ b/x-pack/plugin/watcher/src/main/java/org/elasticsearch/xpack/watcher/WatcherService.java, +        int cancelledTaskCount = executionService.clearExecutionsAndQueue();, +        logger.info("reloading watcher, reason [{}], cancelled [{}] queued tasks", reason, cancelledTaskCount);, +    /**, +     * start the watcher service, load watches in the background, +     *, +     * @param state                     the current cluster state, +     * @param postWatchesLoadedCallback the callback to be triggered, when watches where loaded successfully, +     */, +    public void start(ClusterState state, Runnable postWatchesLoadedCallback) {, +        executionService.unPause();, +        executor.execute(wrapWatcherService(() -> {, +                if (reloadInner(state, "starting", true)) {, +                    postWatchesLoadedCallback.run();, +                }, +            },, +     * reload watches and start scheduling them, +     *, +     * @param state                 the current cluster state, +     * @param reason                the reason for reloading, will be logged, +     * @param loadTriggeredWatches  should triggered watches be loaded in this run, not needed for reloading, only for starting, +     * @return                      true if no other loading of a newer cluster state happened in parallel, false otherwise, +    private synchronized boolean reloadInner(ClusterState state, String reason, boolean loadTriggeredWatches) {, +            return true;, +            return false;, +++ b/x-pack/plugin/watcher/src/main/java/org/elasticsearch/xpack/watcher/WatcherLifeCycleService.java, +            watcherService.start(event.state(), () -> this.state.set(WatcherState.STARTED));, +                    this.state.set(WatcherState.STARTING);, +                    watcherService.start(event.state(), () -> this.state.set(WatcherState.STARTED));, +++ b/x-pack/plugin/watcher/src/main/java/org/elasticsearch/xpack/watcher/WatcherService.java, +        int cancelledTaskCount = executionService.clearExecutionsAndQueue();, +        logger.info("reloading watcher, reason [{}], cancelled [{}] queued tasks", reason, cancelledTaskCount);, +    /**, +     * start the watcher service, load watches in the background, +     *, +     * @param state                     the current cluster state, +     * @param postWatchesLoadedCallback the callback to be triggered, when watches where loaded successfully, +     */, +    public void start(ClusterState state, Runnable postWatchesLoadedCallback) {, +        executionService.unPause();, +        executor.execute(wrapWatcherService(() -> {, +                if (reloadInner(state, "starting", true)) {, +                    postWatchesLoadedCallback.run();, +                }, +            },, +     * reload watches and start scheduling them, +     *, +     * @param state                 the current cluster state, +     * @param reason                the reason for reloading, will be logged, +     * @param loadTriggeredWatches  should triggered watches be loaded in this run, not needed for reloading, only for starting, +     * @return                      true if no other loading of a newer cluster state happened in parallel, false otherwise, +    private synchronized boolean reloadInner(ClusterState state, String reason, boolean loadTriggeredWatches) {, +            return true;, +            return false;, +++ b/x-pack/plugin/watcher/src/main/java/org/elasticsearch/xpack/watcher/execution/ExecutionService.java, +     * Pause the execution of the watcher executor, and empty the state., +     * Pausing means, that no new watch executions will be done unless this pausing is explicitely unset., +     * This is important when watcher is stopped, so that scheduled watches do not accidentally get executed., +     * This should not be used when we need to reload watcher based on some cluster state changes, then just calling, +     * {@link #clearExecutionsAndQueue()} is the way to go, +     *, +        return clearExecutionsAndQueue();, +    }, +, +    /**, +     * Empty the currently queued tasks and wait for current executions to finish., +     *, +     * @return the number of tasks that have been removed, +     */, +    public int clearExecutionsAndQueue() {, +++ b/x-pack/plugin/watcher/src/main/java/org/elasticsearch/xpack/watcher/WatcherLifeCycleService.java, +            watcherService.start(event.state(), () -> this.state.set(WatcherState.STARTED));, +                    this.state.set(WatcherState.STARTING);, +                    watcherService.start(event.state(), () -> this.state.set(WatcherState.STARTED));, +++ b/x-pack/plugin/watcher/src/main/java/org/elasticsearch/xpack/watcher/WatcherService.java, +        int cancelledTaskCount = executionService.clearExecutionsAndQueue();, +        logger.info("reloading watcher, reason [{}], cancelled [{}] queued tasks", reason, cancelledTaskCount);, +    /**, +     * start the watcher service, load watches in the background, +     *, +     * @param state                     the current cluster state, +     * @param postWatchesLoadedCallback the callback to be triggered, when watches where loaded successfully, +     */, +    public void start(ClusterState state, Runnable postWatchesLoadedCallback) {, +        executionService.unPause();, +        executor.execute(wrapWatcherService(() -> {, +                if (reloadInner(state, "starting", true)) {, +                    postWatchesLoadedCallback.run();, +                }, +            },, +     * reload watches and start scheduling them, +     *]