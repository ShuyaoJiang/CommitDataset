[+++ b/src/main/java/org/elasticsearch/common/geo/builders/ShapeBuilder.java, +            // validate the coordinate array for envelope type, +            if (coordinates.children.size() != 2) {, +                throw new ElasticsearchParseException("Invalid number of points (" + coordinates.children.size() + ") provided for " +, +                        "geo_shape ('envelope') when expecting an array of 2 coordinates");, +            }, +            // verify coordinate bounds, correct if necessary, +            Coordinate uL = coordinates.children.get(0).coordinate;, +            Coordinate lR = coordinates.children.get(1).coordinate;, +            if (((lR.x < uL.x) || (uL.y < lR.y))) {, +                Coordinate uLtmp = uL;, +                uL = new Coordinate(Math.min(uL.x, lR.x), Math.max(uL.y, lR.y));, +                lR = new Coordinate(Math.max(uLtmp.x, lR.x), Math.min(uLtmp.y, lR.y));, +            }, +            return newEnvelope(orientation).topLeft(uL).bottomRight(lR);, +++ b/src/main/java/org/elasticsearch/common/geo/builders/ShapeBuilder.java, +            // validate the coordinate array for envelope type, +            if (coordinates.children.size() != 2) {, +                throw new ElasticsearchParseException("Invalid number of points (" + coordinates.children.size() + ") provided for " +, +                        "geo_shape ('envelope') when expecting an array of 2 coordinates");, +            }, +            // verify coordinate bounds, correct if necessary, +            Coordinate uL = coordinates.children.get(0).coordinate;, +            Coordinate lR = coordinates.children.get(1).coordinate;, +            if (((lR.x < uL.x) || (uL.y < lR.y))) {, +                Coordinate uLtmp = uL;, +                uL = new Coordinate(Math.min(uL.x, lR.x), Math.max(uL.y, lR.y));, +                lR = new Coordinate(Math.max(uLtmp.x, lR.x), Math.min(uLtmp.y, lR.y));, +            }, +            return newEnvelope(orientation).topLeft(uL).bottomRight(lR);, +++ b/src/test/java/org/elasticsearch/common/geo/GeoJSONShapeParserTests.java, +        // test #1: envelope with expected coordinate order (TopLeft, BottomRight), +, +        // test #2: envelope with agnostic coordinate order (TopRight, BottomLeft), +        multilinesGeoJson = XContentFactory.jsonBuilder().startObject().field("type", "envelope"), +                .startArray("coordinates"), +                .startArray().value(50).value(30).endArray(), +                .startArray().value(-50).value(-30).endArray(), +                .endArray(), +                .endObject().string();, +, +        expected = SPATIAL_CONTEXT.makeRectangle(-50, 50, -30, 30);, +        assertGeometryEquals(expected, multilinesGeoJson);, +, +        // test #3: "envelope" (actually a triangle) with invalid number of coordinates (TopRight, BottomLeft, BottomRight), +        multilinesGeoJson = XContentFactory.jsonBuilder().startObject().field("type", "envelope"), +                .startArray("coordinates"), +                .startArray().value(50).value(30).endArray(), +                .startArray().value(-50).value(-30).endArray(), +                .startArray().value(50).value(-39).endArray(), +                .endArray(), +                .endObject().string();, +        XContentParser parser = JsonXContent.jsonXContent.createParser(multilinesGeoJson);, +        parser.nextToken();, +        ElasticsearchGeoAssertions.assertValidException(parser, ElasticsearchParseException.class);, +, +        // test #4: "envelope" with empty coordinates, +        multilinesGeoJson = XContentFactory.jsonBuilder().startObject().field("type", "envelope"), +                .startArray("coordinates"), +                .endArray(), +                .endObject().string();, +        parser = JsonXContent.jsonXContent.createParser(multilinesGeoJson);, +        parser.nextToken();, +        ElasticsearchGeoAssertions.assertValidException(parser, ElasticsearchParseException.class);]