[+++ b/x-pack/plugin/sql/qa/src/main/java/org/elasticsearch/xpack/sql/qa/rest/RestSqlTestCase.java, +        assertEquals(2, aggregations2.size());, +        assertEquals("having." + aggKeys.get(0), aggFilterKey);, +        assertEquals(aggKeys.get(0).toString(), bucketsPath.get("a0"));, +++ b/x-pack/plugin/sql/qa/src/main/java/org/elasticsearch/xpack/sql/qa/rest/RestSqlTestCase.java, +        assertEquals(2, aggregations2.size());, +        assertEquals("having." + aggKeys.get(0), aggFilterKey);, +        assertEquals(aggKeys.get(0).toString(), bucketsPath.get("a0"));, +++ b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/analysis/analyzer/Analyzer.java, +                                combine(agg.aggregates(), new Alias(f.location(), ".having", condition)));, +                        tryResolvingCondition = (Aggregate) analyze(tryResolvingCondition, false);, +                        if (tryResolvingCondition.resolved()) {, +                            condition = ((Alias) tryResolvingCondition.aggregates(), +                                .get(tryResolvingCondition.aggregates().size() - 1)).child();, +, +                    return new Filter(f.location(), f.child(), condition);, +++ b/x-pack/plugin/sql/qa/src/main/java/org/elasticsearch/xpack/sql/qa/rest/RestSqlTestCase.java, +        assertEquals(2, aggregations2.size());, +        assertEquals("having." + aggKeys.get(0), aggFilterKey);, +        assertEquals(aggKeys.get(0).toString(), bucketsPath.get("a0"));, +++ b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/analysis/analyzer/Analyzer.java, +                                combine(agg.aggregates(), new Alias(f.location(), ".having", condition)));, +                        tryResolvingCondition = (Aggregate) analyze(tryResolvingCondition, false);, +                        if (tryResolvingCondition.resolved()) {, +                            condition = ((Alias) tryResolvingCondition.aggregates(), +                                .get(tryResolvingCondition.aggregates().size() - 1)).child();, +, +                    return new Filter(f.location(), f.child(), condition);, +++ b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/rule/RuleExecutor.java, +                    if (log.isTraceEnabled()) {, +                        log.trace("About to apply rule {}", rule);, +                    }, +++ b/x-pack/plugin/sql/qa/src/main/java/org/elasticsearch/xpack/sql/qa/rest/RestSqlTestCase.java, +        assertEquals(2, aggregations2.size());, +        assertEquals("having." + aggKeys.get(0), aggFilterKey);, +        assertEquals(aggKeys.get(0).toString(), bucketsPath.get("a0"));, +++ b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/analysis/analyzer/Analyzer.java, +                                combine(agg.aggregates(), new Alias(f.location(), ".having", condition)));, +                        tryResolvingCondition = (Aggregate) analyze(tryResolvingCondition, false);, +                        if (tryResolvingCondition.resolved()) {, +                            condition = ((Alias) tryResolvingCondition.aggregates(), +                                .get(tryResolvingCondition.aggregates().size() - 1)).child();, +, +                    return new Filter(f.location(), f.child(), condition);, +++ b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/rule/RuleExecutor.java, +                    if (log.isTraceEnabled()) {, +                        log.trace("About to apply rule {}", rule);, +                    }, +++ b/x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/analysis/analyzer/VerifierErrorMessagesTests.java, +        assertEquals("1:48: Cannot filter HAVING on non-aggregate [int]; consider using WHERE instead",, +++ b/x-pack/plugin/sql/qa/src/main/java/org/elasticsearch/xpack/sql/qa/rest/RestSqlTestCase.java, +        assertEquals(2, aggregations2.size());, +        assertEquals("having." + aggKeys.get(0), aggFilterKey);, +        assertEquals(aggKeys.get(0).toString(), bucketsPath.get("a0"));, +++ b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/analysis/analyzer/Analyzer.java, +                                combine(agg.aggregates(), new Alias(f.location(), ".having", condition)));, +                        tryResolvingCondition = (Aggregate) analyze(tryResolvingCondition, false);, +                        if (tryResolvingCondition.resolved()) {, +                            condition = ((Alias) tryResolvingCondition.aggregates(), +                                .get(tryResolvingCondition.aggregates().size() - 1)).child();, +, +                    return new Filter(f.location(), f.child(), condition);, +++ b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/rule/RuleExecutor.java, +                    if (log.isTraceEnabled()) {, +                        log.trace("About to apply rule {}", rule);, +                    }, +++ b/x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/analysis/analyzer/VerifierErrorMessagesTests.java, +        assertEquals("1:48: Cannot filter HAVING on non-aggregate [int]; consider using WHERE instead",, +++ b/x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/planner/QueryTranslatorTests.java, +        assertTrue(p instanceof Filter);, +        Expression condition = ((Filter) p).condition();, +        assertTrue(p instanceof Filter);, +        Expression condition = ((Filter) p).condition();, +        assertTrue(p instanceof Filter);, +        Expression condition = ((Filter) p).condition();, +        assertTrue(p instanceof Filter);, +        Expression condition = ((Filter) p).condition();, +        assertTrue(p instanceof Filter);, +        Expression condition = ((Filter) p).condition();, +        assertTrue(p instanceof Filter);, +        Expression condition = ((Filter) p).condition();, +    public void testGroupByAndHavingWithFunctionOnTopOfAggregation() {, +        LogicalPlan p = plan("SELECT keyword, MAX(int) FROM test GROUP BY 1 HAVING ABS(MAX(int)) > 10");, +        assertTrue(p instanceof Filter);, +        Expression condition = ((Filter) p).condition();, +        assertFalse(condition.foldable());, +        QueryTranslation translation = QueryTranslator.toQuery(condition, true);, +        assertNull(translation.query);, +        AggFilter aggFilter = translation.aggFilter;, +        assertEquals("InternalSqlScriptUtils.nullSafeFilter(InternalSqlScriptUtils.gt(InternalSqlScriptUtils.abs" +, +                "(params.a0),params.v0))",, +            aggFilter.scriptTemplate().toString());, +        assertThat(aggFilter.scriptTemplate().params().toString(), startsWith("[{a=MAX(int){a->"));, +        assertThat(aggFilter.scriptTemplate().params().toString(), endsWith(", {v=10}]"));, +    }, +]