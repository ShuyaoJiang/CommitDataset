[+++ b/buildSrc/src/main/groovy/org/elasticsearch/gradle/BuildPlugin.groovy, +        if (System.getProperty("repos.mavenlocal") != null) {, +            // with -Drepos.mavenlocal=true we can force checking the local .m2 repo which is, +            // useful for development ie. bwc tests where we install stuff in the local repository, +            // such that we don't have to pass hardcoded files to gradle, +            repos.mavenLocal(), +        }, +++ b/buildSrc/src/main/groovy/org/elasticsearch/gradle/BuildPlugin.groovy, +        if (System.getProperty("repos.mavenlocal") != null) {, +            // with -Drepos.mavenlocal=true we can force checking the local .m2 repo which is, +            // useful for development ie. bwc tests where we install stuff in the local repository, +            // such that we don't have to pass hardcoded files to gradle, +            repos.mavenLocal(), +        }, +++ b/buildSrc/src/main/groovy/org/elasticsearch/gradle/test/ClusterConfiguration.groovy, +    int numBwcNodes = 0, +, +    @Input, +    String bwcVersion = null, +, +    @Input, +++ b/buildSrc/src/main/groovy/org/elasticsearch/gradle/BuildPlugin.groovy, +        if (System.getProperty("repos.mavenlocal") != null) {, +            // with -Drepos.mavenlocal=true we can force checking the local .m2 repo which is, +            // useful for development ie. bwc tests where we install stuff in the local repository, +            // such that we don't have to pass hardcoded files to gradle, +            repos.mavenLocal(), +        }, +++ b/buildSrc/src/main/groovy/org/elasticsearch/gradle/test/ClusterConfiguration.groovy, +    int numBwcNodes = 0, +, +    @Input, +    String bwcVersion = null, +, +    @Input, +++ b/buildSrc/src/main/groovy/org/elasticsearch/gradle/test/ClusterFormationTasks.groovy, +        File sharedDir = new File(project.buildDir, "cluster/shared"), +        // first we remove everything in the shared cluster directory to ensure there are no leftovers in repos or anything, +        // in theory this should not be necessary but repositories are only deleted in the cluster-state and not on-disk, +        // such that snapshots survive failures / test runs and there is no simple way today to fix that., +        Task cleanup = project.tasks.create(name: "${task.name}#prepareCluster.cleanShared", type: Delete, dependsOn: task.dependsOn.collect()) {, +            delete sharedDir, +            doLast {, +                sharedDir.mkdirs(), +            }, +        }, +        List<Task> startTasks = [cleanup], +        if (config.numNodes < config.numBwcNodes) {, +            throw new GradleException("numNodes must be >= numBwcNodes [${config.numNodes} < ${config.numBwcNodes}]"), +        }, +        if (config.numBwcNodes > 0 && config.bwcVersion == null) {, +            throw new GradleException("bwcVersion must not be null if numBwcNodes is > 0"), +        }, +        // this is our current version distribution configuration we use for all kinds of REST tests etc., +        project.configurations {, +            elasticsearchDistro, +        }, +        configureDistributionDependency(project, config.distribution, project.configurations.elasticsearchDistro, VersionProperties.elasticsearch), +        if (config.bwcVersion != null && config.numBwcNodes > 0) {, +            // if we have a cluster that has a BWC cluster we also need to configure a dependency on the BWC version, +            // this version uses the same distribution etc. and only differs in the version we depend on., +            // from here on everything else works the same as if it's the current version, we fetch the BWC version, +            // from mirrors using gradles built-in mechanism etc., +            project.configurations {, +                elasticsearchBwcDistro, +            }, +            configureDistributionDependency(project, config.distribution, project.configurations.elasticsearchBwcDistro, config.bwcVersion), +        }, +, +            // we start N nodes and out of these N nodes there might be M bwc nodes., +            // for each of those nodes we might have a different configuratioon, +            String elasticsearchVersion = VersionProperties.elasticsearch, +            Configuration configuration = project.configurations.elasticsearchDistro, +            if (i < config.numBwcNodes) {, +                elasticsearchVersion = config.bwcVersion, +                configuration = project.configurations.elasticsearchBwcDistro, +            }, +            NodeInfo node = new NodeInfo(config, i, project, task, elasticsearchVersion, sharedDir), +            startTasks.add(configureNode(project, task, cleanup, node, configuration)), +    static void configureDistributionDependency(Project project, String distro, Configuration configuration, String elasticsearchVersion) {, +        project.dependencies.add(configuration.name, "org.elasticsearch.distribution.${distro}:elasticsearch:${elasticsearchVersion}@${packaging}"), +    static Task configureNode(Project project, Task task, Object dependsOn, NodeInfo node, Configuration configuration) {, +        Task setup = project.tasks.create(name: taskName(task, node, 'clean'), type: Delete, dependsOn: dependsOn) {, +        setup = configureExtractTask(taskName(task, node, 'extract'), project, setup, node, configuration), +    static Task configureExtractTask(String name, Project project, Task setup, NodeInfo node, Configuration configuration) {, +        List extractDependsOn = [configuration, setup], +        /* configuration.singleFile will be an external artifact if this is being run by a plugin not living in the, +          elasticsearch source tree. If this is a plugin built in the elasticsearch source tree or this is a distro in, +          the elasticsearch source tree then this should be the version of elasticsearch built by the source tree., +          If it isn't then Bad Things(TM) will happen. */, +, +                    from {, +                        project.zipTree(configuration.singleFile), +                    }, +                        project.tarTree(project.resources.gzip(configuration.singleFile)), +                Object rpm = "${ -> configuration.singleFile}", +                Object deb = "${ -> configuration.singleFile}", +                'path.repo'                    : "${node.sharedDir}/repo",, +                'path.shared_data'             : "${node.sharedDir}/",, +++ b/buildSrc/src/main/groovy/org/elasticsearch/gradle/BuildPlugin.groovy]