[+++ b/src/main/java/org/elasticsearch/search/aggregations/bucket/significant/SignificantLongTermsAggregator.java, +            spare.supersetDf = termsAggFactory.getBackgroundFrequency(spare.term);, +++ b/src/main/java/org/elasticsearch/search/aggregations/bucket/significant/SignificantLongTermsAggregator.java, +            spare.supersetDf = termsAggFactory.getBackgroundFrequency(spare.term);, +++ b/src/main/java/org/elasticsearch/search/aggregations/bucket/significant/SignificantStringTermsAggregator.java, +            spare.supersetDf = termsAggFactory.getBackgroundFrequency(spare.termBytes);, +++ b/src/main/java/org/elasticsearch/search/aggregations/bucket/significant/SignificantLongTermsAggregator.java, +            spare.supersetDf = termsAggFactory.getBackgroundFrequency(spare.term);, +++ b/src/main/java/org/elasticsearch/search/aggregations/bucket/significant/SignificantStringTermsAggregator.java, +            spare.supersetDf = termsAggFactory.getBackgroundFrequency(spare.termBytes);, +++ b/src/main/java/org/elasticsearch/search/aggregations/bucket/significant/SignificantTermsAggregatorFactory.java, +import org.apache.lucene.index.*;, +import org.apache.lucene.index.FilterAtomicReader.FilterTermsEnum;, +import org.apache.lucene.util.Bits;, +import org.elasticsearch.common.util.LongArray;, +import org.elasticsearch.search.internal.ContextIndexSearcher;, +    private TermsEnum termsEnum;, +    private int numberOfAggregatorsCreated = 0;, +        , +        numberOfAggregatorsCreated++;, +        switch (numberOfAggregatorsCreated) {, +        case 1:, +            // Setup a termsEnum for use by first aggregator, +            try {, +                SearchContext searchContext = aggregationContext.searchContext();, +                ContextIndexSearcher searcher = searchContext.searcher();, +                Terms terms = MultiFields.getTerms(searcher.getIndexReader(), indexedFieldName);, +                //terms can be null if the choice of field is not found in this index, +                if (terms != null) {, +                    termsEnum = terms.iterator(null);, +                } , +            } catch (IOException e) {, +                throw new ElasticsearchException("IOException loading background document frequency info", e);, +            }, +            break;, +        case 2:, +            // When we have > 1 agg we have possibility of duplicate term frequency lookups and so introduce a cache, +            // in the form of a wrapper around the plain termsEnum created for use with the first agg, +            if (termsEnum != null) {, +                SearchContext searchContext = aggregationContext.searchContext();, +                termsEnum = new FrequencyCachingTermsEnumWrapper(termsEnum, searchContext.bigArrays(), true, false);, +            }, +            break;, +        }, +        , +    public long getBackgroundFrequency(BytesRef termBytes) {, +        assert termsEnum !=null; // having failed to find a field in the index we don't expect any calls for frequencies, +        long result = 0;, +            if (termsEnum.seekExact(termBytes)) {, +                result = termsEnum.docFreq();, +        } catch (IOException e) {, +            throw new ElasticsearchException("IOException loading background document frequency info", e);, +, +    public long getBackgroundFrequency(long term) {, +        return getBackgroundFrequency(indexedVal);, +            if (termsEnum instanceof Releasable) {, +                ((Releasable) termsEnum).release();, +            }, +        } finally {, +            termsEnum = null;, +        }, +        return true;, +    }, +, +    // A specialist TermsEnum wrapper for use in the repeated look-ups of frequency stats., +    // TODO factor out as a utility class to replace similar org.elasticsearch.search.suggest.phrase.WordScorer.FrequencyCachingTermsEnumWrapper, +    // This implementation is likely to produce less garbage than WordScorer's impl but will need benchmarking/testing for that use case. , +    static class FrequencyCachingTermsEnumWrapper extends FilterTermsEnum implements Releasable {, +, +        int currentTermDocFreq = 0;, +        long currentTermTotalFreq = 0;, +        private IntArray termDocFreqs;, +        private LongArray termTotalFreqs;, +        private BytesRefHash cachedTermOrds;, +        protected BigArrays bigArrays;, +        private boolean cacheDocFreqs;, +        private boolean cacheTotalFreqs;, +        private long currentTermOrd;, +, +        public FrequencyCachingTermsEnumWrapper(TermsEnum delegate, BigArrays bigArrays, boolean cacheDocFreqs, boolean cacheTotalFreqs)  {, +            super(delegate);, +            this.bigArrays = bigArrays;, +            this.cacheDocFreqs = cacheDocFreqs;, +            this.cacheTotalFreqs = cacheTotalFreqs;, +            if (cacheDocFreqs) {, +                termDocFreqs = bigArrays.newIntArray(INITIAL_NUM_TERM_FREQS_CACHED, false);, +            }, +            if (cacheTotalFreqs) {, +                termTotalFreqs = bigArrays.newLongArray(INITIAL_NUM_TERM_FREQS_CACHED, false);, +            }, +            cachedTermOrds = new BytesRefHash(INITIAL_NUM_TERM_FREQS_CACHED, bigArrays);, +        }, +, +        @Override, +        public boolean seekExact(BytesRef text) throws IOException {, +            currentTermDocFreq = 0;, +            currentTermTotalFreq = 0;, +            currentTermOrd = cachedTermOrds.add(text);, +            if (currentTermOrd < 0) { // already seen, initialize instance data with the cached frequencies, +                currentTermOrd = -1 - currentTermOrd;]