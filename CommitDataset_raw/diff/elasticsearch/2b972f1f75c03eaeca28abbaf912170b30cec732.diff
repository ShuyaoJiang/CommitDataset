[+++ b/core/src/main/java/org/elasticsearch/index/translog/TranslogWriter.java, +import java.util.concurrent.locks.ReentrantLock;, +    // lock order synchronized(syncLock) -> synchronized(this), +    private final Object syncLock = new Object();, +        syncUpTo(Long.MAX_VALUE);, +        if (lastSyncedOffset < offset && syncNeeded()) {, +            synchronized (syncLock) { // only one sync/checkpoint should happen concurrently but we wait, +                if (lastSyncedOffset < offset && syncNeeded()) {, +                    // double checked locking - we don't want to fsync unless we have to and now that we have, +                    // the lock we should check again since if this code is busy we might have fsynced enough already, +                    final long offsetToSync;, +                    final int opsCounter;, +                    synchronized (this) {, +                        ensureOpen();, +                        try {, +                            outputStream.flush();, +                            offsetToSync = totalOffset;, +                            opsCounter = operationCounter;, +                        } catch (Throwable ex) {, +                            closeWithTragicEvent(ex);, +                            throw ex;, +                        }, +                    }, +                    // now do the actual fsync outside of the synchronized block such that, +                    // we can continue writing to the buffer etc., +                    try {, +                        channel.force(false);, +                        writeCheckpoint(offsetToSync, opsCounter, path.getParent(), generation, StandardOpenOption.WRITE);, +                    } catch (Throwable ex) {, +                        closeWithTragicEvent(ex);, +                        throw ex;, +                    }, +                    assert lastSyncedOffset <= offsetToSync : "illegal state: " + lastSyncedOffset + " <= " + offsetToSync;, +                    lastSyncedOffset = offsetToSync; // write protected by syncLock, +            }, +        }, +        // only for testing until we have a disk-full FileSystem, +++ b/core/src/main/java/org/elasticsearch/index/translog/TranslogWriter.java, +import java.util.concurrent.locks.ReentrantLock;, +    // lock order synchronized(syncLock) -> synchronized(this), +    private final Object syncLock = new Object();, +        syncUpTo(Long.MAX_VALUE);, +        if (lastSyncedOffset < offset && syncNeeded()) {, +            synchronized (syncLock) { // only one sync/checkpoint should happen concurrently but we wait, +                if (lastSyncedOffset < offset && syncNeeded()) {, +                    // double checked locking - we don't want to fsync unless we have to and now that we have, +                    // the lock we should check again since if this code is busy we might have fsynced enough already, +                    final long offsetToSync;, +                    final int opsCounter;, +                    synchronized (this) {, +                        ensureOpen();, +                        try {, +                            outputStream.flush();, +                            offsetToSync = totalOffset;, +                            opsCounter = operationCounter;, +                        } catch (Throwable ex) {, +                            closeWithTragicEvent(ex);, +                            throw ex;, +                        }, +                    }, +                    // now do the actual fsync outside of the synchronized block such that, +                    // we can continue writing to the buffer etc., +                    try {, +                        channel.force(false);, +                        writeCheckpoint(offsetToSync, opsCounter, path.getParent(), generation, StandardOpenOption.WRITE);, +                    } catch (Throwable ex) {, +                        closeWithTragicEvent(ex);, +                        throw ex;, +                    }, +                    assert lastSyncedOffset <= offsetToSync : "illegal state: " + lastSyncedOffset + " <= " + offsetToSync;, +                    lastSyncedOffset = offsetToSync; // write protected by syncLock, +            }, +        }, +        // only for testing until we have a disk-full FileSystem, +++ b/docs/reference/search/count.asciidoc, +$ curl -XGET 'http://localhost:9200/twitter/tweet/_count?q=user:kimchy', +$ curl -XGET 'http://localhost:9200/twitter/tweet/_count' -d ', +}', +++ b/core/src/main/java/org/elasticsearch/index/translog/TranslogWriter.java, +import java.util.concurrent.locks.ReentrantLock;, +    // lock order synchronized(syncLock) -> synchronized(this), +    private final Object syncLock = new Object();, +        syncUpTo(Long.MAX_VALUE);, +        if (lastSyncedOffset < offset && syncNeeded()) {, +            synchronized (syncLock) { // only one sync/checkpoint should happen concurrently but we wait, +                if (lastSyncedOffset < offset && syncNeeded()) {, +                    // double checked locking - we don't want to fsync unless we have to and now that we have, +                    // the lock we should check again since if this code is busy we might have fsynced enough already, +                    final long offsetToSync;, +                    final int opsCounter;, +                    synchronized (this) {, +                        ensureOpen();, +                        try {, +                            outputStream.flush();, +                            offsetToSync = totalOffset;, +                            opsCounter = operationCounter;, +                        } catch (Throwable ex) {, +                            closeWithTragicEvent(ex);, +                            throw ex;, +                        }]