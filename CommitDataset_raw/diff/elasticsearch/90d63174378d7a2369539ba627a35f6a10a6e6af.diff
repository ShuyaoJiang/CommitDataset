[+++ b/core/src/main/java/org/elasticsearch/common/settings/IndexScopedSettings.java, +++ b/core/src/main/java/org/elasticsearch/common/settings/IndexScopedSettings.java, +++ b/core/src/main/java/org/elasticsearch/index/seqno/LocalCheckpointTracker.java, +     * demand and cleaning up while completed. This constant controls the size of the arrays., +    static final int BIT_ARRAYS_SIZE = 1024;, +    public LocalCheckpointTracker(final long maxSeqNo, final long localCheckpoint) {, +        assert checkpoint < firstProcessedSeqNo + BIT_ARRAYS_SIZE - 1 :, +                if (checkpoint == firstProcessedSeqNo + BIT_ARRAYS_SIZE - 1) {, +                    firstProcessedSeqNo += BIT_ARRAYS_SIZE;, +                    assert checkpoint - firstProcessedSeqNo < BIT_ARRAYS_SIZE;, +        final long bitSetOffset = (seqNo - firstProcessedSeqNo) / BIT_ARRAYS_SIZE;, +            processedSeqNo.add(new FixedBitSet(BIT_ARRAYS_SIZE));, +        return ((int) (seqNo - firstProcessedSeqNo)) % BIT_ARRAYS_SIZE;, +++ b/core/src/main/java/org/elasticsearch/common/settings/IndexScopedSettings.java, +++ b/core/src/main/java/org/elasticsearch/index/seqno/LocalCheckpointTracker.java, +     * demand and cleaning up while completed. This constant controls the size of the arrays., +    static final int BIT_ARRAYS_SIZE = 1024;, +    public LocalCheckpointTracker(final long maxSeqNo, final long localCheckpoint) {, +        assert checkpoint < firstProcessedSeqNo + BIT_ARRAYS_SIZE - 1 :, +                if (checkpoint == firstProcessedSeqNo + BIT_ARRAYS_SIZE - 1) {, +                    firstProcessedSeqNo += BIT_ARRAYS_SIZE;, +                    assert checkpoint - firstProcessedSeqNo < BIT_ARRAYS_SIZE;, +        final long bitSetOffset = (seqNo - firstProcessedSeqNo) / BIT_ARRAYS_SIZE;, +            processedSeqNo.add(new FixedBitSet(BIT_ARRAYS_SIZE));, +        return ((int) (seqNo - firstProcessedSeqNo)) % BIT_ARRAYS_SIZE;, +++ b/core/src/main/java/org/elasticsearch/index/seqno/SequenceNumbersService.java, +        localCheckpointTracker = new LocalCheckpointTracker(maxSeqNo, localCheckpoint);, +++ b/core/src/main/java/org/elasticsearch/common/settings/IndexScopedSettings.java, +++ b/core/src/main/java/org/elasticsearch/index/seqno/LocalCheckpointTracker.java, +     * demand and cleaning up while completed. This constant controls the size of the arrays., +    static final int BIT_ARRAYS_SIZE = 1024;, +    public LocalCheckpointTracker(final long maxSeqNo, final long localCheckpoint) {, +        assert checkpoint < firstProcessedSeqNo + BIT_ARRAYS_SIZE - 1 :, +                if (checkpoint == firstProcessedSeqNo + BIT_ARRAYS_SIZE - 1) {, +                    firstProcessedSeqNo += BIT_ARRAYS_SIZE;, +                    assert checkpoint - firstProcessedSeqNo < BIT_ARRAYS_SIZE;, +        final long bitSetOffset = (seqNo - firstProcessedSeqNo) / BIT_ARRAYS_SIZE;, +            processedSeqNo.add(new FixedBitSet(BIT_ARRAYS_SIZE));, +        return ((int) (seqNo - firstProcessedSeqNo)) % BIT_ARRAYS_SIZE;, +++ b/core/src/main/java/org/elasticsearch/index/seqno/SequenceNumbersService.java, +        localCheckpointTracker = new LocalCheckpointTracker(maxSeqNo, localCheckpoint);, +++ b/core/src/main/java/org/elasticsearch/indices/recovery/RecoverySourceHandler.java, +            final LocalCheckpointTracker tracker = new LocalCheckpointTracker(startingSeqNo, startingSeqNo - 1);, +++ b/core/src/main/java/org/elasticsearch/common/settings/IndexScopedSettings.java, +++ b/core/src/main/java/org/elasticsearch/index/seqno/LocalCheckpointTracker.java, +     * demand and cleaning up while completed. This constant controls the size of the arrays., +    static final int BIT_ARRAYS_SIZE = 1024;, +    public LocalCheckpointTracker(final long maxSeqNo, final long localCheckpoint) {, +        assert checkpoint < firstProcessedSeqNo + BIT_ARRAYS_SIZE - 1 :, +                if (checkpoint == firstProcessedSeqNo + BIT_ARRAYS_SIZE - 1) {, +                    firstProcessedSeqNo += BIT_ARRAYS_SIZE;, +                    assert checkpoint - firstProcessedSeqNo < BIT_ARRAYS_SIZE;, +        final long bitSetOffset = (seqNo - firstProcessedSeqNo) / BIT_ARRAYS_SIZE;, +            processedSeqNo.add(new FixedBitSet(BIT_ARRAYS_SIZE));, +        return ((int) (seqNo - firstProcessedSeqNo)) % BIT_ARRAYS_SIZE;, +++ b/core/src/main/java/org/elasticsearch/index/seqno/SequenceNumbersService.java, +        localCheckpointTracker = new LocalCheckpointTracker(maxSeqNo, localCheckpoint);, +++ b/core/src/main/java/org/elasticsearch/indices/recovery/RecoverySourceHandler.java, +            final LocalCheckpointTracker tracker = new LocalCheckpointTracker(startingSeqNo, startingSeqNo - 1);, +++ b/core/src/test/java/org/elasticsearch/index/seqno/LocalCheckpointTrackerTests.java, +import static org.elasticsearch.index.seqno.LocalCheckpointTracker.BIT_ARRAYS_SIZE;, +        return new LocalCheckpointTracker(SequenceNumbers.NO_OPS_PERFORMED, SequenceNumbers.NO_OPS_PERFORMED);, +        final int maxOps = BIT_ARRAYS_SIZE * randomIntBetween(1, 5) + (aligned ? 0 : randomIntBetween(1, BIT_ARRAYS_SIZE - 1));, +        assertThat(tracker.firstProcessedSeqNo, equalTo(((long) maxOps / BIT_ARRAYS_SIZE) * BIT_ARRAYS_SIZE));, +        assertThat(tracker.firstProcessedSeqNo, equalTo(((long) maxOps / BIT_ARRAYS_SIZE) * BIT_ARRAYS_SIZE));, +        assertThat(tracker.firstProcessedSeqNo, equalTo(((long) maxOps / BIT_ARRAYS_SIZE) * BIT_ARRAYS_SIZE));]