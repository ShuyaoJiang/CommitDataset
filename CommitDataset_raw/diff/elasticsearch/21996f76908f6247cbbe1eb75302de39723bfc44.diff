[+++ b/build.gradle, +  throw new GradleException('You must run `./gradlew idea` from the root of elasticsearch before importing into IntelliJ'), +++ b/build.gradle, +  throw new GradleException('You must run `./gradlew idea` from the root of elasticsearch before importing into IntelliJ'), +++ b/distribution/archives/integ-test-zip/src/test/java/org/elasticsearch/test/rest/WaitForRefreshAndCloseIT.java, +import org.elasticsearch.client.Request;, +++ b/build.gradle, +  throw new GradleException('You must run `./gradlew idea` from the root of elasticsearch before importing into IntelliJ'), +++ b/distribution/archives/integ-test-zip/src/test/java/org/elasticsearch/test/rest/WaitForRefreshAndCloseIT.java, +import org.elasticsearch.client.Request;, +++ b/server/src/main/java/org/elasticsearch/action/admin/indices/close/CloseIndexClusterStateUpdateRequest.java, +    CloseIndexClusterStateUpdateRequest() {, +++ b/build.gradle, +  throw new GradleException('You must run `./gradlew idea` from the root of elasticsearch before importing into IntelliJ'), +++ b/distribution/archives/integ-test-zip/src/test/java/org/elasticsearch/test/rest/WaitForRefreshAndCloseIT.java, +import org.elasticsearch.client.Request;, +++ b/server/src/main/java/org/elasticsearch/action/admin/indices/close/CloseIndexClusterStateUpdateRequest.java, +    CloseIndexClusterStateUpdateRequest() {, +++ b/server/src/main/java/org/elasticsearch/action/admin/indices/close/TransportCloseIndexAction.java, +import org.elasticsearch.cluster.ack.ClusterStateUpdateResponse;, +        CloseIndexClusterStateUpdateRequest updateRequest = new CloseIndexClusterStateUpdateRequest(), +                .ackTimeout(request.timeout()).masterNodeTimeout(request.masterNodeTimeout()), +        indexStateService.closeIndices(updateRequest, new ActionListener<ClusterStateUpdateResponse>() {, +            public void onResponse(ClusterStateUpdateResponse response) {, +                listener.onResponse(new AcknowledgedResponse(response.isAcknowledged()));, +            public void onFailure(Exception t) {, +++ b/build.gradle, +  throw new GradleException('You must run `./gradlew idea` from the root of elasticsearch before importing into IntelliJ'), +++ b/distribution/archives/integ-test-zip/src/test/java/org/elasticsearch/test/rest/WaitForRefreshAndCloseIT.java, +import org.elasticsearch.client.Request;, +++ b/server/src/main/java/org/elasticsearch/action/admin/indices/close/CloseIndexClusterStateUpdateRequest.java, +    CloseIndexClusterStateUpdateRequest() {, +++ b/server/src/main/java/org/elasticsearch/action/admin/indices/close/TransportCloseIndexAction.java, +import org.elasticsearch.cluster.ack.ClusterStateUpdateResponse;, +        CloseIndexClusterStateUpdateRequest updateRequest = new CloseIndexClusterStateUpdateRequest(), +                .ackTimeout(request.timeout()).masterNodeTimeout(request.masterNodeTimeout()), +        indexStateService.closeIndices(updateRequest, new ActionListener<ClusterStateUpdateResponse>() {, +            public void onResponse(ClusterStateUpdateResponse response) {, +                listener.onResponse(new AcknowledgedResponse(response.isAcknowledged()));, +            public void onFailure(Exception t) {, +++ /dev/null, +++ b/build.gradle, +  throw new GradleException('You must run `./gradlew idea` from the root of elasticsearch before importing into IntelliJ'), +++ b/distribution/archives/integ-test-zip/src/test/java/org/elasticsearch/test/rest/WaitForRefreshAndCloseIT.java, +import org.elasticsearch.client.Request;, +++ b/server/src/main/java/org/elasticsearch/action/admin/indices/close/CloseIndexClusterStateUpdateRequest.java, +    CloseIndexClusterStateUpdateRequest() {, +++ b/server/src/main/java/org/elasticsearch/action/admin/indices/close/TransportCloseIndexAction.java, +import org.elasticsearch.cluster.ack.ClusterStateUpdateResponse;, +        CloseIndexClusterStateUpdateRequest updateRequest = new CloseIndexClusterStateUpdateRequest(), +                .ackTimeout(request.timeout()).masterNodeTimeout(request.masterNodeTimeout()), +        indexStateService.closeIndices(updateRequest, new ActionListener<ClusterStateUpdateResponse>() {, +            public void onResponse(ClusterStateUpdateResponse response) {, +                listener.onResponse(new AcknowledgedResponse(response.isAcknowledged()));, +            public void onFailure(Exception t) {, +++ /dev/null, +++ b/server/src/main/java/org/elasticsearch/cluster/metadata/MetaDataIndexStateService.java, +, +, +                                     IndicesService indicesService, ThreadPool threadPool) {, +    public void closeIndices(final CloseIndexClusterStateUpdateRequest request, final ActionListener<ClusterStateUpdateResponse> listener) {, +        if (request.indices() == null || request.indices().length == 0) {, +        final String indicesAsString = Arrays.toString(request.indices());, +        clusterService.submitStateUpdateTask("close-indices " + indicesAsString,, +                new AckedClusterStateUpdateTask<ClusterStateUpdateResponse>(Priority.URGENT, request, listener) {, +            protected ClusterStateUpdateResponse newResponse(boolean acknowledged) {, +                return new ClusterStateUpdateResponse(acknowledged);, +            public ClusterState execute(ClusterState currentState) {, +                return closeIndices(currentState, request.indices(), indicesAsString);, +            }, +        });, +    public ClusterState closeIndices(ClusterState currentState, final Index[] indices, String indicesAsString) {, +        Set<IndexMetaData> indicesToClose = new HashSet<>();, +            final IndexMetaData indexMetaData = currentState.metaData().getIndexSafe(index);, +        logger.info("closing indices [{}]", indicesAsString);, +        MetaData.Builder mdBuilder = MetaData.builder(currentState.metaData());, +        ClusterBlocks.Builder blocksBuilder = ClusterBlocks.builder(), +            .blocks(currentState.blocks());, +        for (IndexMetaData openIndexMetadata : indicesToClose) {, +            final String indexName = openIndexMetadata.getIndex().getName();, +            mdBuilder.put(IndexMetaData.builder(openIndexMetadata).state(IndexMetaData.State.CLOSE));, +            blocksBuilder.addIndexBlock(indexName, INDEX_CLOSED_BLOCK);, +        ClusterState updatedState = ClusterState.builder(currentState).metaData(mdBuilder).blocks(blocksBuilder).build();, +, +        RoutingTable.Builder rtBuilder = RoutingTable.builder(currentState.routingTable());, +        for (IndexMetaData index : indicesToClose) {, +            rtBuilder.remove(index.getIndex().getName());, +        //no explicit wait for other nodes needed as we use AckedClusterStateUpdateTask, +        return  allocationService.reroute(, +            ClusterState.builder(updatedState).routingTable(rtBuilder.build()).build(),, +            "indices closed [" + indicesAsString + "]");, +, +++ b/build.gradle, +  throw new GradleException('You must run `./gradlew idea` from the root of elasticsearch before importing into IntelliJ'), +++ b/distribution/archives/integ-test-zip/src/test/java/org/elasticsearch/test/rest/WaitForRefreshAndCloseIT.java, +import org.elasticsearch.client.Request;, +++ b/server/src/main/java/org/elasticsearch/action/admin/indices/close/CloseIndexClusterStateUpdateRequest.java, +    CloseIndexClusterStateUpdateRequest() {, +++ b/server/src/main/java/org/elasticsearch/action/admin/indices/close/TransportCloseIndexAction.java, +import org.elasticsearch.cluster.ack.ClusterStateUpdateResponse;]