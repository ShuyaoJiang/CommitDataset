[+++ /dev/null, +++ /dev/null, +++ b/client/src/main/java/org/elasticsearch/client/ConnectionPool.java, +import org.apache.commons.logging.Log;, +import org.apache.commons.logging.LogFactory;, +import org.apache.http.HttpHost;, +, +import java.util.ArrayList;, +import java.util.Collections;, +import java.util.List;, +import java.util.Objects;, +import java.util.concurrent.atomic.AtomicInteger;, + * for each request. Marks connections as dead/alive when needed., + * Provides a stream of alive connections or dead ones that should be retried for each {@link #nextConnection()} call., + * In case the returned stream is empty a last resort dead connection should be retrieved by calling {@link #lastResortConnection()}, + * and resurrected so that a last resort request attempt can be performed., + * The {@link #onSuccess(Connection)} method marks the connection provided as an argument alive., + * The {@link #onFailure(Connection)} method marks the connection provided as an argument dead., + * This base implementation doesn't define the list implementation that stores connections, so that concurrency can be, + * handled in subclasses depending on the usecase (e.g. defining the list volatile or final when needed)., +public abstract class ConnectionPool implements Closeable {, +, +    private static final Log logger = LogFactory.getLog(ConnectionPool.class);, +, +    private final AtomicInteger lastConnectionIndex = new AtomicInteger(0);, +, +    /**, +     * Allows to retrieve the concrete list of connections. Not defined directly as a member, +     * of this class as subclasses may need to handle concurrency if the list can change, for, +     * instance defining the field as volatile. On the other hand static implementations, +     * can just make the list final instead., +     */, +    protected abstract List<Connection> getConnections();, +    public final Stream<Connection> nextConnection() {, +        List<Connection> connections = getConnections();, +        if (connections.isEmpty()) {, +            throw new IllegalStateException("no connections available in the connection pool");, +        }, +, +        List<Connection> sortedConnections = new ArrayList<>(connections);, +        //TODO is it possible to make this O(1)? (rotate is O(n)), +        Collections.rotate(sortedConnections, sortedConnections.size() - lastConnectionIndex.getAndIncrement());, +        return sortedConnections.stream().filter(connection -> connection.isAlive() || connection.shouldBeRetried());, +    }, +, +    /**, +     * Helper method to be used by subclasses when needing to create a new list, +     * of connections given their corresponding hosts, +     */, +    protected final List<Connection> createConnections(HttpHost... hosts) {, +        List<Connection> connections = new ArrayList<>();, +        for (HttpHost host : hosts) {, +            Objects.requireNonNull(host, "host cannot be null");, +            connections.add(new Connection(host));, +        }, +        return Collections.unmodifiableList(connections);, +    }, +     * only in case {@link #nextConnection()} returns an empty stream., +    public final Connection lastResortConnection() {, +        Connection Connection = getConnections().stream(), +                .sorted((o1, o2) -> Long.compare(o1.getDeadUntil(), o2.getDeadUntil())).findFirst().get();, +        Connection.markResurrected();, +        return Connection;, +    }, +    public void onSuccess(Connection connection) {, +        connection.markAlive();, +        logger.trace("marked connection alive for " + connection.getHost());, +    }, +    public void onFailure(Connection connection) throws IOException {, +        connection.markDead();, +        logger.debug("marked connection dead for " + connection.getHost());, +    }, +++ /dev/null, +++ b/client/src/main/java/org/elasticsearch/client/ConnectionPool.java, +import org.apache.commons.logging.Log;, +import org.apache.commons.logging.LogFactory;, +import org.apache.http.HttpHost;, +, +import java.util.ArrayList;, +import java.util.Collections;, +import java.util.List;, +import java.util.Objects;, +import java.util.concurrent.atomic.AtomicInteger;, + * for each request. Marks connections as dead/alive when needed., + * Provides a stream of alive connections or dead ones that should be retried for each {@link #nextConnection()} call., + * In case the returned stream is empty a last resort dead connection should be retrieved by calling {@link #lastResortConnection()}, + * and resurrected so that a last resort request attempt can be performed., + * The {@link #onSuccess(Connection)} method marks the connection provided as an argument alive., + * The {@link #onFailure(Connection)} method marks the connection provided as an argument dead., + * This base implementation doesn't define the list implementation that stores connections, so that concurrency can be, + * handled in subclasses depending on the usecase (e.g. defining the list volatile or final when needed)., +public abstract class ConnectionPool implements Closeable {, +, +    private static final Log logger = LogFactory.getLog(ConnectionPool.class);, +, +    private final AtomicInteger lastConnectionIndex = new AtomicInteger(0);, +, +    /**, +     * Allows to retrieve the concrete list of connections. Not defined directly as a member, +     * of this class as subclasses may need to handle concurrency if the list can change, for]