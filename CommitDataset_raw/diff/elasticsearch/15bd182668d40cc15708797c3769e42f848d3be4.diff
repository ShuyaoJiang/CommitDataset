[+++ b/core/pom.xml, +++ b/core/pom.xml, +++ b/core/src/main/java/org/elasticsearch/bootstrap/Security.java, +        System.setSecurityManager(new SecurityManager() {, +            // we disable this completely, because its granted otherwise:, +            // 'Note: The "exitVM.*" permission is automatically granted to, +            // all code loaded from the application class path, thus enabling, +            // applications to terminate themselves.', +            @Override, +            public void checkExit(int status) {, +                throw new SecurityException("exit(" + status + ") not allowed by system policy");, +            }, +        });, +++ b/core/pom.xml, +++ b/core/src/main/java/org/elasticsearch/bootstrap/Security.java, +        System.setSecurityManager(new SecurityManager() {, +            // we disable this completely, because its granted otherwise:, +            // 'Note: The "exitVM.*" permission is automatically granted to, +            // all code loaded from the application class path, thus enabling, +            // applications to terminate themselves.', +            @Override, +            public void checkExit(int status) {, +                throw new SecurityException("exit(" + status + ") not allowed by system policy");, +            }, +        });, +++ b/core/src/main/java/org/elasticsearch/index/engine/Engine.java, +    protected volatile long lastWriteNanos = Long.MAX_VALUE; // no write yet!, +++ b/core/pom.xml, +++ b/core/src/main/java/org/elasticsearch/bootstrap/Security.java, +        System.setSecurityManager(new SecurityManager() {, +            // we disable this completely, because its granted otherwise:, +            // 'Note: The "exitVM.*" permission is automatically granted to, +            // all code loaded from the application class path, thus enabling, +            // applications to terminate themselves.', +            @Override, +            public void checkExit(int status) {, +                throw new SecurityException("exit(" + status + ") not allowed by system policy");, +            }, +        });, +++ b/core/src/main/java/org/elasticsearch/index/engine/Engine.java, +    protected volatile long lastWriteNanos = Long.MAX_VALUE; // no write yet!, +++ b/core/src/main/java/org/elasticsearch/index/shard/IndexShard.java, +import org.apache.lucene.index.*;, +import org.elasticsearch.index.store.Store;, +    public IndexShardState recovering(String reason, RecoveryState recoveryState) throws IndexShardStartedException,, +    public boolean recoverFromStore(ShardRouting shard, DiscoveryNode localNode) {, +        assert shard.primary() : "recover from store only makes sense if the shard is a primary shard";, +        final boolean shouldExist = shard.allocatedPostIndexCreate();, +    public boolean restoreFromRepository(ShardRouting shard, IndexShardRepository repository, DiscoveryNode locaNode) {, +        assert shard.primary() : "recover from store only makes sense if the shard is a primary shard";, +++ b/core/pom.xml, +++ b/core/src/main/java/org/elasticsearch/bootstrap/Security.java, +        System.setSecurityManager(new SecurityManager() {, +            // we disable this completely, because its granted otherwise:, +            // 'Note: The "exitVM.*" permission is automatically granted to, +            // all code loaded from the application class path, thus enabling, +            // applications to terminate themselves.', +            @Override, +            public void checkExit(int status) {, +                throw new SecurityException("exit(" + status + ") not allowed by system policy");, +            }, +        });, +++ b/core/src/main/java/org/elasticsearch/index/engine/Engine.java, +    protected volatile long lastWriteNanos = Long.MAX_VALUE; // no write yet!, +++ b/core/src/main/java/org/elasticsearch/index/shard/IndexShard.java, +import org.apache.lucene.index.*;, +import org.elasticsearch.index.store.Store;, +    public IndexShardState recovering(String reason, RecoveryState recoveryState) throws IndexShardStartedException,, +    public boolean recoverFromStore(ShardRouting shard, DiscoveryNode localNode) {, +        assert shard.primary() : "recover from store only makes sense if the shard is a primary shard";, +        final boolean shouldExist = shard.allocatedPostIndexCreate();, +    public boolean restoreFromRepository(ShardRouting shard, IndexShardRepository repository, DiscoveryNode locaNode) {, +        assert shard.primary() : "recover from store only makes sense if the shard is a primary shard";, +++ b/core/src/main/java/org/elasticsearch/index/shard/StoreRecovery.java, +            try {, +                final RecoveryState recoveryState = new RecoveryState(indexShard.shardId(), indexShard.routingEntry().primary(), RecoveryState.Type.STORE, localNode, localNode);, +                indexShard.recovering("from store", recoveryState);, +            } catch (IllegalIndexShardStateException e) {, +                // that's fine, since we might be called concurrently, just ignore this, we are already recovering, +                return false;, +            }, +            try {, +                final RecoveryState recoveryState = new RecoveryState(shardId, shardRouting.primary(), RecoveryState.Type.SNAPSHOT, shardRouting.restoreSource(), localNode);, +                indexShard.recovering("from snapshot", recoveryState);, +            } catch (IllegalIndexShardStateException e) {, +                // that's fine, since we might be called concurrently, just ignore this, we are already recovering, +                return false;, +            }, +++ b/core/pom.xml, +++ b/core/src/main/java/org/elasticsearch/bootstrap/Security.java, +        System.setSecurityManager(new SecurityManager() {, +            // we disable this completely, because its granted otherwise:, +            // 'Note: The "exitVM.*" permission is automatically granted to, +            // all code loaded from the application class path, thus enabling, +            // applications to terminate themselves.', +            @Override, +            public void checkExit(int status) {, +                throw new SecurityException("exit(" + status + ") not allowed by system policy");, +            }, +        });]