[+++ b/src/main/java/org/elasticsearch/index/engine/internal/DeleteVersionValue.java, +import org.apache.lucene.util.RamUsageEstimator;, +, +    @Override, +    public long ramBytesUsed() {, +        return super.ramBytesUsed() + RamUsageEstimator.NUM_BYTES_LONG;, +    }, +++ b/src/main/java/org/elasticsearch/index/engine/internal/DeleteVersionValue.java, +import org.apache.lucene.util.RamUsageEstimator;, +, +    @Override, +    public long ramBytesUsed() {, +        return super.ramBytesUsed() + RamUsageEstimator.NUM_BYTES_LONG;, +    }, +++ b/src/main/java/org/elasticsearch/index/engine/internal/InternalEngine.java, +, +, +    /** When we last pruned expired tombstones from versionMap.deletes: */, +    private volatile long lastDeleteVersionPruneTimeMSec;, +, +    private final AtomicBoolean versionMapRefreshPending = new AtomicBoolean();, +        this.lastDeleteVersionPruneTimeMSec = threadPool.estimatedTimeInMillis();, +        checkVersionMapRefresh();, +        checkVersionMapRefresh();, +    }, +, +    /** Forces a refresh if the versionMap is using too much RAM (currently > 25% of IndexWriter's RAM buffer). */, +    private void checkVersionMapRefresh() {, +        // TODO: we force refresh when versionMap is using > 25% of IW's RAM buffer; should we make this separately configurable?, +        if (versionMap.ramBytesUsedForRefresh()/1024/1024. > 0.25*this.indexWriter.getConfig().getRAMBufferSizeMB() && versionMapRefreshPending.getAndSet(true) == false) {, +            // Now refresh to clear versionMap:, +            threadPool.executor(ThreadPool.Names.REFRESH).execute(new Runnable() {, +                    public void run() {, +                        refresh(new Refresh("version_table_full"));, +                    }, +                });, +        }, +, +        maybePruneDeletedTombstones();, +    }, +    , +    private void maybePruneDeletedTombstones() {, +        // It's expensive to prune because we walk the deletes map acquiring dirtyLock for each uid so we only do it, +        // every 1/4 of gcDeletesInMillis:, +        if (enableGcDeletes && threadPool.estimatedTimeInMillis() - lastDeleteVersionPruneTimeMSec > gcDeletesInMillis*0.25) {, +            pruneDeletedTombstones();, +        }, +            versionMap.putUnderLock(delete.uid().bytes(), new DeleteVersionValue(updatedVersion, threadPool.estimatedTimeInMillis(), translogLocation));, +, +        // TODO: This is heavy, since we refresh, but we must do this because we don't know which documents were in fact deleted (i.e., our, +        // versionMap isn't updated), so we must force a cutover to a new reader to "see" the deletions:, +        refresh(new Refresh("delete_by_query").force(true));, +, +        // TODO: maybe we should just put a scheduled job in threadPool?, +        // We check for pruning in each delete request, but we also prune here e.g. in case a delete burst comes in and then no more deletes, +        // for a long time:, +        maybePruneDeletedTombstones();, +        versionMapRefreshPending.set(false);, +, +                        maybePruneDeletedTombstones();, +, +                            // we need to refresh in order to clear older version values, +                            refresh(new Refresh("version_table_flush").force(true));, +, +, +                // We don't have to do this here; we do it defensively to make sure that even if wall clock time is misbehaving, +                // (e.g., moves backwards) we will at least still sometimes prune deleted tombstones:, +                if (enableGcDeletes) {, +                    pruneDeletedTombstones();, +                }, +, +, +                // We don't have to do this here; we do it defensively to make sure that even if wall clock time is misbehaving, +                // (e.g., moves backwards) we will at least still sometimes prune deleted tombstones:, +                if (enableGcDeletes) {, +                    pruneDeletedTombstones();, +                }, +, +    private void pruneDeletedTombstones() {, +        long timeMSec = threadPool.estimatedTimeInMillis();, +        // we only need to prune the deletes map; the current/old version maps are cleared on refresh:, +        for (Map.Entry<BytesRef, VersionValue> entry : versionMap.getAllTombstones()) {, +                VersionValue versionValue = versionMap.getTombstoneUnderLock(uid);, +                if (versionValue != null) {, +                    if (timeMSec - versionValue.time() > gcDeletesInMillis) {, +                        versionMap.removeTombstoneUnderLock(uid);, +        lastDeleteVersionPruneTimeMSec = timeMSec;, +    }, +, +++ b/src/main/java/org/elasticsearch/index/engine/internal/DeleteVersionValue.java, +import org.apache.lucene.util.RamUsageEstimator;, +, +    @Override, +    public long ramBytesUsed() {, +        return super.ramBytesUsed() + RamUsageEstimator.NUM_BYTES_LONG;, +    }, +++ b/src/main/java/org/elasticsearch/index/engine/internal/InternalEngine.java, +, +, +    /** When we last pruned expired tombstones from versionMap.deletes: */]