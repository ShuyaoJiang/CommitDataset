[+++ b/dev-tools/checkstyle_suppressions.xml, +++ b/dev-tools/checkstyle_suppressions.xml, +++ b/sql/server/src/main/java/org/elasticsearch/xpack/sql/querydsl/agg/AggPath.java, +    /*, +     * The depth indicates the level of an agg excluding the root agg, +     * (because all aggs in SQL require a group). However all other, +     * bucket aggs are counted., +     *, +     * Since the path does not indicate the type of agg used, to, +     * differentiate between metric properties and bucket properties,, +     * the bucket value is considered. This is needed since one might, +     * refer to the keys or count of a bucket path. As the opposite, +     * side there are metric aggs which have the same level as their, +     * parent (their nesting is an ES implementation detail)., +     *, +     * Examples:, +     *, +     * agg1 = 0;                  agg1 = default/root group, +     * agg1>agg2._count = 1;      ._count indicates agg2 is a bucket, +     *          agg and thus it counted - agg1 (default group),, +     *          depth=0, agg2 (bucketed), depth=1, +     * agg1>agg2>agg3.value = 1;  agg3.value indicates a metric bucket, +     *          thus only agg1 and agg2 are counted -> depth=2. In, +     *          other words, agg3.value has the same depth as, +     *          agg2._count, +     * agg1>agg2>agg3._count = 2; ._count indicates agg3 is a, +     *          bucket agg, so count it for depth -> depth = 2, +     * agg1>agg2>agg3.sum = 1;    .sum indicates agg3 is a metric agg,, +     *          only agg1 and agg2 are bucket and with agg1 being the, +     *          default group -> depth = 1, +     */, +++ b/dev-tools/checkstyle_suppressions.xml, +++ b/sql/server/src/main/java/org/elasticsearch/xpack/sql/querydsl/agg/AggPath.java, +    /*, +     * The depth indicates the level of an agg excluding the root agg, +     * (because all aggs in SQL require a group). However all other, +     * bucket aggs are counted., +     *, +     * Since the path does not indicate the type of agg used, to, +     * differentiate between metric properties and bucket properties,, +     * the bucket value is considered. This is needed since one might, +     * refer to the keys or count of a bucket path. As the opposite, +     * side there are metric aggs which have the same level as their, +     * parent (their nesting is an ES implementation detail)., +     *, +     * Examples:, +     *, +     * agg1 = 0;                  agg1 = default/root group, +     * agg1>agg2._count = 1;      ._count indicates agg2 is a bucket, +     *          agg and thus it counted - agg1 (default group),, +     *          depth=0, agg2 (bucketed), depth=1, +     * agg1>agg2>agg3.value = 1;  agg3.value indicates a metric bucket, +     *          thus only agg1 and agg2 are counted -> depth=2. In, +     *          other words, agg3.value has the same depth as, +     *          agg2._count, +     * agg1>agg2>agg3._count = 2; ._count indicates agg3 is a, +     *          bucket agg, so count it for depth -> depth = 2, +     * agg1>agg2>agg3.sum = 1;    .sum indicates agg3 is a metric agg,, +     *          only agg1 and agg2 are bucket and with agg1 being the, +     *          default group -> depth = 1, +     */, +++ b/sql/server/src/main/java/org/elasticsearch/xpack/sql/querydsl/agg/GroupByColumnAgg.java, +    public GroupByColumnAgg(String id, String propertyPath, String fieldName, List<LeafAgg> subAggs,, +            List<PipelineAgg> subPipelines, Map<String, Direction> order, int limit) {, +    protected GroupByColumnAgg copy(String id, String propertyPath, String fieldName, List<LeafAgg> subAggs,, +            List<PipelineAgg> subPipelines, Map<String, Direction> order) {, +++ b/dev-tools/checkstyle_suppressions.xml, +++ b/sql/server/src/main/java/org/elasticsearch/xpack/sql/querydsl/agg/AggPath.java, +    /*, +     * The depth indicates the level of an agg excluding the root agg, +     * (because all aggs in SQL require a group). However all other, +     * bucket aggs are counted., +     *, +     * Since the path does not indicate the type of agg used, to, +     * differentiate between metric properties and bucket properties,, +     * the bucket value is considered. This is needed since one might, +     * refer to the keys or count of a bucket path. As the opposite, +     * side there are metric aggs which have the same level as their, +     * parent (their nesting is an ES implementation detail)., +     *, +     * Examples:, +     *, +     * agg1 = 0;                  agg1 = default/root group, +     * agg1>agg2._count = 1;      ._count indicates agg2 is a bucket, +     *          agg and thus it counted - agg1 (default group),, +     *          depth=0, agg2 (bucketed), depth=1, +     * agg1>agg2>agg3.value = 1;  agg3.value indicates a metric bucket, +     *          thus only agg1 and agg2 are counted -> depth=2. In, +     *          other words, agg3.value has the same depth as, +     *          agg2._count, +     * agg1>agg2>agg3._count = 2; ._count indicates agg3 is a, +     *          bucket agg, so count it for depth -> depth = 2, +     * agg1>agg2>agg3.sum = 1;    .sum indicates agg3 is a metric agg,, +     *          only agg1 and agg2 are bucket and with agg1 being the, +     *          default group -> depth = 1, +     */, +++ b/sql/server/src/main/java/org/elasticsearch/xpack/sql/querydsl/agg/GroupByColumnAgg.java, +    public GroupByColumnAgg(String id, String propertyPath, String fieldName, List<LeafAgg> subAggs,, +            List<PipelineAgg> subPipelines, Map<String, Direction> order, int limit) {, +    protected GroupByColumnAgg copy(String id, String propertyPath, String fieldName, List<LeafAgg> subAggs,]