[+++ b/src/main/java/org/elasticsearch/discovery/zen/ZenDiscovery.java, +                    } else {, +                } else {, +                } else {, +++ b/src/main/java/org/elasticsearch/discovery/zen/ZenDiscovery.java, +                    } else {, +                } else {, +                } else {, +++ b/src/main/java/org/elasticsearch/transport/TransportService.java, +    protected TransportRequestHandler getHandler(String action) {, +        return serverHandlers.get(action);, +    }, +, +++ b/src/main/java/org/elasticsearch/discovery/zen/ZenDiscovery.java, +                    } else {, +                } else {, +                } else {, +++ b/src/main/java/org/elasticsearch/transport/TransportService.java, +    protected TransportRequestHandler getHandler(String action) {, +        return serverHandlers.get(action);, +    }, +, +++ b/src/test/java/org/elasticsearch/cluster/ClusterServiceTests.java, +        ListenableFuture<String> master = internalCluster().startNodeAsync(settings);, +        ListenableFuture<String> nonMaster = internalCluster().startNodeAsync(settingsBuilder().put(settings).put("node.master", false).build());, +        ClusterService clusterService = internalCluster().getInstance(ClusterService.class, nonMaster.get());, +++ b/src/main/java/org/elasticsearch/discovery/zen/ZenDiscovery.java, +                    } else {, +                } else {, +                } else {, +++ b/src/main/java/org/elasticsearch/transport/TransportService.java, +    protected TransportRequestHandler getHandler(String action) {, +        return serverHandlers.get(action);, +    }, +, +++ b/src/test/java/org/elasticsearch/cluster/ClusterServiceTests.java, +        ListenableFuture<String> master = internalCluster().startNodeAsync(settings);, +        ListenableFuture<String> nonMaster = internalCluster().startNodeAsync(settingsBuilder().put(settings).put("node.master", false).build());, +        ClusterService clusterService = internalCluster().getInstance(ClusterService.class, nonMaster.get());, +++ b/src/test/java/org/elasticsearch/cluster/NoMasterNodeTests.java, +import org.elasticsearch.action.bulk.BulkRequestBuilder;, +++ b/src/main/java/org/elasticsearch/discovery/zen/ZenDiscovery.java, +                    } else {, +                } else {, +                } else {, +++ b/src/main/java/org/elasticsearch/transport/TransportService.java, +    protected TransportRequestHandler getHandler(String action) {, +        return serverHandlers.get(action);, +    }, +, +++ b/src/test/java/org/elasticsearch/cluster/ClusterServiceTests.java, +        ListenableFuture<String> master = internalCluster().startNodeAsync(settings);, +        ListenableFuture<String> nonMaster = internalCluster().startNodeAsync(settingsBuilder().put(settings).put("node.master", false).build());, +        ClusterService clusterService = internalCluster().getInstance(ClusterService.class, nonMaster.get());, +++ b/src/test/java/org/elasticsearch/cluster/NoMasterNodeTests.java, +import org.elasticsearch.action.bulk.BulkRequestBuilder;, +++ b/src/test/java/org/elasticsearch/discovery/DiscoveryWithNetworkFailuresTests.java, +import org.apache.lucene.util.LuceneTestCase;, +import org.elasticsearch.ElasticsearchException;, +import org.elasticsearch.test.disruption.*;, +import java.util.*;, +import java.util.concurrent.ConcurrentHashMap;, +import java.util.concurrent.CountDownLatch;, +import java.util.concurrent.Semaphore;, +import java.util.concurrent.atomic.AtomicBoolean;, +import java.util.concurrent.atomic.AtomicInteger;, +import java.util.concurrent.atomic.AtomicReference;, +, +        NetworkDisconnectPartition networkDisconnect = new NetworkDisconnectPartition(masterDiscoNode.name(), unluckyNode, getRandom());, +        setDisruptionScheme(networkDisconnect);, +        networkDisconnect.startDisrupting();, +, +, +        networkDisconnect.stopDisrupting();, +        NetworkPartition networkPartition = addRandomPartition();, +, +        final String isolatedNode = networkPartition.getMinoritySide().get(0);, +        final String nonIsolatedNode = networkPartition.getMjaoritySide().get(0);, +        networkPartition.startDisrupting();, +, +, +        networkPartition.stopDisrupting();, +        ServiceDisruptionScheme scheme = addRandomIsolation(isolatedNode);, +        scheme.startDisrupting();, +        scheme.stopDisrupting();, +    }, +    @Test, +    @LuceneTestCase.AwaitsFix(bugUrl = "MvG will fix"), +    public void testAckedIndexing() throws Exception {, +        final List<String> nodes = internalCluster().startNodesAsync(3, nodeSettings).get();, +        ensureStableCluster(3);, +, +        assertAcked(prepareCreate("test"), +                .setSettings(ImmutableSettings.builder(), +                                .put(IndexMetaData.SETTING_NUMBER_OF_SHARDS, 1 + randomInt(2)), +                                .put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, randomInt(2)), +                ));, +, +        ensureGreen();, +]