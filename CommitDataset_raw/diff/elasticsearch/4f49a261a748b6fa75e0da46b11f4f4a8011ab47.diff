[+++ b/core/src/main/java/org/elasticsearch/index/engine/Engine.java, +, +        abstract String type();, +, +        abstract String id();, +        @Override, +        @Override, +        @Override, +        @Override, +++ b/core/src/main/java/org/elasticsearch/index/engine/Engine.java, +, +        abstract String type();, +, +        abstract String id();, +        @Override, +        @Override, +        @Override, +        @Override, +++ b/core/src/main/java/org/elasticsearch/index/engine/InternalEngine.java, +                VersionValue versionValue = versionMap.getUnderLock(get.uid());, +    private boolean checkVersionConflict(, +            final Operation op,, +            final long currentVersion,, +            final long expectedVersion,, +            final boolean deleted) {, +        if (op.versionType().isVersionConflictForWrites(currentVersion, expectedVersion, deleted)) {, +            if (op.origin().isRecovery()) {, +                // version conflict, but okay, +                return true;, +            } else {, +                // fatal version conflict, +                throw new VersionConflictEngineException(shardId, op.type(), op.id(),, +                        op.versionType().explainConflictForWrites(currentVersion, expectedVersion, deleted));, +            }, +        }, +        return false;, +    }, +, +    private long checkDeletedAndGCed(VersionValue versionValue) {, +        long currentVersion;, +        if (engineConfig.isEnableGcDeletes() && versionValue.delete() && (engineConfig.getThreadPool().estimatedTimeInMillis() - versionValue.time()) > getGcDeletesInMillis()) {, +            currentVersion = Versions.NOT_FOUND; // deleted, and GC, +        } else {, +            currentVersion = versionValue.version();, +        }, +        return currentVersion;, +    }, +, +    private static VersionValueSupplier NEW_VERSION_VALUE = (u, t, l) -> new VersionValue(u, l);, +, +    @FunctionalInterface, +    private interface VersionValueSupplier {, +        VersionValue apply(long updatedVersion, long time, Translog.Location location);, +    }, +, +    private <T extends Engine.Operation> void maybeAddToTranslog(, +            final T op,, +            final long updatedVersion,, +            final Function<T, Translog.Operation> toTranslogOp,, +            final VersionValueSupplier toVersionValue) throws IOException {, +        if (op.origin() != Operation.Origin.LOCAL_TRANSLOG_RECOVERY) {, +            final Translog.Location translogLocation = translog.add(toTranslogOp.apply(op));, +            op.setTranslogLocation(translogLocation);, +            versionMap.putUnderLock(op.uid().bytes(), toVersionValue.apply(updatedVersion, engineConfig.getThreadPool().estimatedTimeInMillis(), op.getTranslogLocation()));, +        } else {, +            // we do not replay in to the translog, so there is no, +            // translog location; that is okay because real-time, +            // gets are not possible during recovery and we will, +            // flush when the recovery is complete, +            versionMap.putUnderLock(op.uid().bytes(), toVersionValue.apply(updatedVersion, engineConfig.getThreadPool().estimatedTimeInMillis(), null));, +        }, +    }, +, +            final VersionValue versionValue = versionMap.getUnderLock(index.uid());, +                currentVersion = checkDeletedAndGCed(versionValue);, +            }, +, +            final long expectedVersion = index.version();, +            if (checkVersionConflict(index, currentVersion, expectedVersion, deleted)) return false;, +, +            final long updatedVersion = updateVersion(index, currentVersion, expectedVersion);, +, +            final boolean created = indexOrUpdate(index, currentVersion, versionValue);, +, +            maybeAddToTranslog(index, updatedVersion, Translog.Index::new, NEW_VERSION_VALUE);, +, +            return created;, +    private long updateVersion(Engine.Operation op, long currentVersion, long expectedVersion) {, +        final long updatedVersion = op.versionType().updateVersion(currentVersion, expectedVersion);, +        op.updateVersion(updatedVersion);, +        return updatedVersion;, +    private boolean indexOrUpdate(final Index index, final long currentVersion, final VersionValue versionValue) throws IOException {, +, +    private static void index(final Index index, final IndexWriter indexWriter) throws IOException {, +        if (index.docs().size() > 1) {, +            indexWriter.addDocuments(index.docs());, +        } else {, +            indexWriter.addDocument(index.docs().get(0));, +        }, +    private static boolean update(final Index index, final VersionValue versionValue, final IndexWriter indexWriter) throws IOException {]