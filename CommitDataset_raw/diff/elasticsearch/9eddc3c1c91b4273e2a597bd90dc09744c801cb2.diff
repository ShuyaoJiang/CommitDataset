[+++ b/core/pom.xml, +                        <exclude>src/main/java/org/elasticsearch/common/network/InetAddresses.java</exclude>, +                        <exclude>src/test/java/org/elasticsearch/common/network/InetAddressesTests.java</exclude>, +++ b/core/pom.xml, +                        <exclude>src/main/java/org/elasticsearch/common/network/InetAddresses.java</exclude>, +                        <exclude>src/test/java/org/elasticsearch/common/network/InetAddressesTests.java</exclude>, +++ b/core/src/main/java/org/elasticsearch/client/transport/TransportClientNodesService.java, +            String message = String.format(Locale.ROOT, "None of the configured nodes are available: %s", nodes);, +++ b/core/pom.xml, +                        <exclude>src/main/java/org/elasticsearch/common/network/InetAddresses.java</exclude>, +                        <exclude>src/test/java/org/elasticsearch/common/network/InetAddressesTests.java</exclude>, +++ b/core/src/main/java/org/elasticsearch/client/transport/TransportClientNodesService.java, +            String message = String.format(Locale.ROOT, "None of the configured nodes are available: %s", nodes);, +++ b/core/src/main/java/org/elasticsearch/common/network/InetAddresses.java, +/*, + * Copyright (C) 2008 The Guava Authors, + *, + * Licensed under the Apache License, Version 2.0 (the "License");, + * you may not use this file except in compliance with the License., + * You may obtain a copy of the License at, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS,, + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied., + * See the License for the specific language governing permissions and, + * limitations under the License., + */, +, +package org.elasticsearch.common.network;, +, +import java.net.Inet4Address;, +import java.net.Inet6Address;, +import java.net.InetAddress;, +import java.net.UnknownHostException;, +import java.nio.ByteBuffer;, +import java.util.Arrays;, +import java.util.Locale;, +, +public class InetAddresses {, +    private static int IPV4_PART_COUNT = 4;, +    private static int IPV6_PART_COUNT = 8;, +, +    public static boolean isInetAddress(String ipString) {, +        return ipStringToBytes(ipString) != null;, +    }, +, +    private static byte[] ipStringToBytes(String ipString) {, +        // Make a first pass to categorize the characters in this string., +        boolean hasColon = false;, +        boolean hasDot = false;, +        for (int i = 0; i < ipString.length(); i++) {, +            char c = ipString.charAt(i);, +            if (c == '.') {, +                hasDot = true;, +            } else if (c == ':') {, +                if (hasDot) {, +                    return null;  // Colons must not appear after dots., +                }, +                hasColon = true;, +            } else if (Character.digit(c, 16) == -1) {, +                return null;  // Everything else must be a decimal or hex digit., +            }, +        }, +, +        // Now decide which address family to parse., +        if (hasColon) {, +            if (hasDot) {, +                ipString = convertDottedQuadToHex(ipString);, +                if (ipString == null) {, +                    return null;, +                }, +            }, +            return textToNumericFormatV6(ipString);, +        } else if (hasDot) {, +            return textToNumericFormatV4(ipString);, +        }, +        return null;, +    }, +, +    private static String convertDottedQuadToHex(String ipString) {, +        int lastColon = ipString.lastIndexOf(':');, +        String initialPart = ipString.substring(0, lastColon + 1);, +        String dottedQuad = ipString.substring(lastColon + 1);, +        byte[] quad = textToNumericFormatV4(dottedQuad);, +        if (quad == null) {, +            return null;, +        }, +        String penultimate = Integer.toHexString(((quad[0] & 0xff) << 8) | (quad[1] & 0xff));, +        String ultimate = Integer.toHexString(((quad[2] & 0xff) << 8) | (quad[3] & 0xff));, +        return initialPart + penultimate + ":" + ultimate;, +    }, +, +    private static byte[] textToNumericFormatV4(String ipString) {, +        String[] address = ipString.split("\\.", IPV4_PART_COUNT + 1);, +        if (address.length != IPV4_PART_COUNT) {, +            return null;, +        }, +]