[+++ b/buildSrc/src/main/resources/checkstyle_suppressions.xml, +++ b/buildSrc/src/main/resources/checkstyle_suppressions.xml, +++ b/server/src/main/java/org/elasticsearch/common/blobstore/BlobContainer.java, +     * Reads blob content from the input stream and writes it to the container in a new blob with the given name,, +     * using an atomic write operation if the implementation supports it. When the BlobContainer implementation, +     * does not provide a specific implementation of writeBlobAtomic(String, InputStream, long), then, +     * the {@link #writeBlob(String, InputStream, long)} method is used., +     *, +     * This method assumes the container does not already contain a blob of the same blobName.  If a blob by the, +     * same name already exists, the operation will fail and an {@link IOException} will be thrown., +     *, +     * @param   blobName, +     *          The name of the blob to write the contents of the input stream to., +     * @param   inputStream, +     *          The input stream from which to retrieve the bytes to write to the blob., +     * @param   blobSize, +     *          The size of the blob to be written, in bytes.  It is implementation dependent whether, +     *          this value is used in writing the blob to the repository., +     * @throws  FileAlreadyExistsException if a blob by the same name already exists, +     * @throws  IOException if the input stream could not be read, or the target blob could not be written to., +     */, +    default void writeBlobAtomic(final String blobName, final InputStream inputStream, final long blobSize) throws IOException {, +        writeBlob(blobName, inputStream, blobSize);, +    }, +, +    /**, +++ b/buildSrc/src/main/resources/checkstyle_suppressions.xml, +++ b/server/src/main/java/org/elasticsearch/common/blobstore/BlobContainer.java, +     * Reads blob content from the input stream and writes it to the container in a new blob with the given name,, +     * using an atomic write operation if the implementation supports it. When the BlobContainer implementation, +     * does not provide a specific implementation of writeBlobAtomic(String, InputStream, long), then, +     * the {@link #writeBlob(String, InputStream, long)} method is used., +     *, +     * This method assumes the container does not already contain a blob of the same blobName.  If a blob by the, +     * same name already exists, the operation will fail and an {@link IOException} will be thrown., +     *, +     * @param   blobName, +     *          The name of the blob to write the contents of the input stream to., +     * @param   inputStream, +     *          The input stream from which to retrieve the bytes to write to the blob., +     * @param   blobSize, +     *          The size of the blob to be written, in bytes.  It is implementation dependent whether, +     *          this value is used in writing the blob to the repository., +     * @throws  FileAlreadyExistsException if a blob by the same name already exists, +     * @throws  IOException if the input stream could not be read, or the target blob could not be written to., +     */, +    default void writeBlobAtomic(final String blobName, final InputStream inputStream, final long blobSize) throws IOException {, +        writeBlob(blobName, inputStream, blobSize);, +    }, +, +    /**, +++ b/server/src/main/java/org/elasticsearch/common/blobstore/fs/FsBlobContainer.java, +import org.elasticsearch.common.UUIDs;, +import org.elasticsearch.core.internal.io.IOUtils;, +    private static final String TEMP_FILE_PREFIX = "pending-";, +    protected final FsBlobStore blobStore;, +    public void writeBlobAtomic(final String blobName, final InputStream inputStream, final long blobSize) throws IOException {, +        final String tempBlob = tempBlobName(blobName);, +        final Path tempBlobPath = path.resolve(tempBlob);, +        try {, +            try (OutputStream outputStream = Files.newOutputStream(tempBlobPath, StandardOpenOption.CREATE_NEW)) {, +                Streams.copy(inputStream, outputStream);, +            }, +            IOUtils.fsync(tempBlobPath, false);, +, +            final Path blobPath = path.resolve(blobName);, +            // If the target file exists then Files.move() behaviour is implementation specific, +            // the existing file might be replaced or this method fails by throwing an IOException., +            if (Files.exists(blobPath)) {, +                throw new FileAlreadyExistsException("blob [" + blobPath + "] already exists, cannot overwrite");, +            }, +            Files.move(tempBlobPath, blobPath, StandardCopyOption.ATOMIC_MOVE);, +        } catch (IOException ex) {, +            try {, +                deleteBlobIgnoringIfNotExists(tempBlob);, +            } catch (IOException e) {, +                ex.addSuppressed(e);, +            }, +            throw ex;, +        } finally {, +            IOUtils.fsync(path, true);, +        }, +    }, +, +    public static String tempBlobName(final String blobName) {, +        return "pending-" + blobName + "-" + UUIDs.randomBase64UUID();, +    }, +, +    /**, +     * Returns true if the blob is a leftover temporary blob., +     *, +     * The temporary blobs might be left after failed atomic write operation., +     */, +    public static boolean isTempBlobName(final String blobName) {, +        return blobName.startsWith(TEMP_FILE_PREFIX);, +    }, +, +    @Override, +++ b/buildSrc/src/main/resources/checkstyle_suppressions.xml, +++ b/server/src/main/java/org/elasticsearch/common/blobstore/BlobContainer.java]