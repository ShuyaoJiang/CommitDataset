[+++ b/core/src/main/java/org/elasticsearch/discovery/zen/ping/unicast/UnicastZenPing.java, +        for (final String host : hosts) {, +            configuredTargetNodes.addAll(resolveDiscoveryNodes(host, limitPortCounts, transportService,, +                () -> UNICAST_NODE_PREFIX + unicastNodeIdGenerator.incrementAndGet() + "#"));, +    /**, +     * Resolves a host to a list of discovery nodes.  The host is resolved into a transport, +     * address (or a collection of addresses if the number of ports is greater than one) and, +     * the transport addresses are used to created discovery nodes., +     *, +     * @param host the host to resolve, +     * @param limitPortCounts the number of ports to resolve (should be 1 for non-local transport), +     * @param transportService the transport service, +     * @param idGenerator the generator to supply unique ids for each discovery node, +     * @return a list of discovery nodes with resolved transport addresses, +     */, +    public static List<DiscoveryNode> resolveDiscoveryNodes(final String host, final int limitPortCounts,, +                                                            final TransportService transportService, final Supplier<String> idGenerator) {, +        List<DiscoveryNode> discoveryNodes = new ArrayList<>();, +        try {, +            TransportAddress[] addresses = transportService.addressesFromString(host, limitPortCounts);, +            for (TransportAddress address : addresses) {, +                discoveryNodes.add(new DiscoveryNode(idGenerator.get(), address, emptyMap(), emptySet(),, +                                                        Version.CURRENT.minimumCompatibilityVersion()));, +            }, +        } catch (Exception e) {, +            throw new IllegalArgumentException("Failed to resolve address for [" + host + "]", e);, +        }, +        return discoveryNodes;, +    }, +, +++ b/core/src/main/java/org/elasticsearch/discovery/zen/ping/unicast/UnicastZenPing.java, +        for (final String host : hosts) {, +            configuredTargetNodes.addAll(resolveDiscoveryNodes(host, limitPortCounts, transportService,, +                () -> UNICAST_NODE_PREFIX + unicastNodeIdGenerator.incrementAndGet() + "#"));, +    /**, +     * Resolves a host to a list of discovery nodes.  The host is resolved into a transport, +     * address (or a collection of addresses if the number of ports is greater than one) and, +     * the transport addresses are used to created discovery nodes., +     *, +     * @param host the host to resolve, +     * @param limitPortCounts the number of ports to resolve (should be 1 for non-local transport), +     * @param transportService the transport service, +     * @param idGenerator the generator to supply unique ids for each discovery node, +     * @return a list of discovery nodes with resolved transport addresses, +     */, +    public static List<DiscoveryNode> resolveDiscoveryNodes(final String host, final int limitPortCounts,, +                                                            final TransportService transportService, final Supplier<String> idGenerator) {, +        List<DiscoveryNode> discoveryNodes = new ArrayList<>();, +        try {, +            TransportAddress[] addresses = transportService.addressesFromString(host, limitPortCounts);, +            for (TransportAddress address : addresses) {, +                discoveryNodes.add(new DiscoveryNode(idGenerator.get(), address, emptyMap(), emptySet(),, +                                                        Version.CURRENT.minimumCompatibilityVersion()));, +            }, +        } catch (Exception e) {, +            throw new IllegalArgumentException("Failed to resolve address for [" + host + "]", e);, +        }, +        return discoveryNodes;, +    }, +, +++ b/dev-tools/smoke_test_rc.py, +                   "discovery-file",, +++ b/core/src/main/java/org/elasticsearch/discovery/zen/ping/unicast/UnicastZenPing.java, +        for (final String host : hosts) {, +            configuredTargetNodes.addAll(resolveDiscoveryNodes(host, limitPortCounts, transportService,, +                () -> UNICAST_NODE_PREFIX + unicastNodeIdGenerator.incrementAndGet() + "#"));, +    /**, +     * Resolves a host to a list of discovery nodes.  The host is resolved into a transport, +     * address (or a collection of addresses if the number of ports is greater than one) and, +     * the transport addresses are used to created discovery nodes., +     *, +     * @param host the host to resolve, +     * @param limitPortCounts the number of ports to resolve (should be 1 for non-local transport), +     * @param transportService the transport service, +     * @param idGenerator the generator to supply unique ids for each discovery node, +     * @return a list of discovery nodes with resolved transport addresses, +     */, +    public static List<DiscoveryNode> resolveDiscoveryNodes(final String host, final int limitPortCounts,, +                                                            final TransportService transportService, final Supplier<String> idGenerator) {, +        List<DiscoveryNode> discoveryNodes = new ArrayList<>();, +        try {, +            TransportAddress[] addresses = transportService.addressesFromString(host, limitPortCounts);, +            for (TransportAddress address : addresses) {, +                discoveryNodes.add(new DiscoveryNode(idGenerator.get(), address, emptyMap(), emptySet(),, +                                                        Version.CURRENT.minimumCompatibilityVersion()));, +            }, +        } catch (Exception e) {, +            throw new IllegalArgumentException("Failed to resolve address for [" + host + "]", e);, +        }, +        return discoveryNodes;, +    }, +, +++ b/dev-tools/smoke_test_rc.py, +                   "discovery-file",, +++ b/plugins/discovery-file/build.gradle, +/*, + * Licensed to Elasticsearch under one or more contributor, + * license agreements. See the NOTICE file distributed with, + * this work for additional information regarding copyright, + * ownership. Elasticsearch licenses this file to you under]