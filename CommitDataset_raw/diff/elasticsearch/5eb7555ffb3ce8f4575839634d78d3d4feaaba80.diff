[+++ b/core/src/main/java/org/elasticsearch/action/ActionRequest.java, +++ b/core/src/main/java/org/elasticsearch/action/ActionRequest.java, +++ b/core/src/main/java/org/elasticsearch/cluster/ClusterModule.java, +import org.elasticsearch.index.translog.TranslogConfig;, +, +++ b/core/src/main/java/org/elasticsearch/action/ActionRequest.java, +++ b/core/src/main/java/org/elasticsearch/cluster/ClusterModule.java, +import org.elasticsearch.index.translog.TranslogConfig;, +, +++ b/core/src/main/java/org/elasticsearch/cluster/routing/IndexShardRoutingTable.java, +, +++ b/core/src/main/java/org/elasticsearch/action/ActionRequest.java, +++ b/core/src/main/java/org/elasticsearch/cluster/ClusterModule.java, +import org.elasticsearch.index.translog.TranslogConfig;, +, +++ b/core/src/main/java/org/elasticsearch/cluster/routing/IndexShardRoutingTable.java, +, +++ b/core/src/main/java/org/elasticsearch/cluster/routing/RoutingNodes.java, +                        } else if (!shard.active()) { // shards that are initializing without being relocated, +++ b/core/src/main/java/org/elasticsearch/action/ActionRequest.java, +++ b/core/src/main/java/org/elasticsearch/cluster/ClusterModule.java, +import org.elasticsearch.index.translog.TranslogConfig;, +, +++ b/core/src/main/java/org/elasticsearch/cluster/routing/IndexShardRoutingTable.java, +, +++ b/core/src/main/java/org/elasticsearch/cluster/routing/RoutingNodes.java, +                        } else if (!shard.active()) { // shards that are initializing without being relocated, +++ b/core/src/main/java/org/elasticsearch/cluster/routing/allocation/AllocationService.java, +        RoutingNodes routingNodes = allocation.routingNodes();, +, +        // go over and remove dangling replicas that are initializing for primary shards, +        List<ShardRouting> shardsToFail = new ArrayList<>();, +                for (ShardRouting routing : routingNodes.assignedShards(shardEntry)) {, +                    if (!routing.primary() && routing.initializing()) {, +                        shardsToFail.add(routing);, +                    }, +                }, +, +            }, +        }, +        for (ShardRouting shardToFail : shardsToFail) {, +            changed |= applyFailedShard(allocation, shardToFail, false,, +                    new UnassignedInfo(UnassignedInfo.Reason.ALLOCATION_FAILED, "primary failed while replica initializing",, +                            null, allocation.getCurrentNanoTime(), System.currentTimeMillis()));, +        }, +, +        // now, go over and elect a new primary if possible, not, from this code block on, if one is elected,, +        // routingNodes.hasUnassignedPrimaries() will potentially be false, +, +        for (ShardRouting shardEntry : routingNodes.unassigned()) {, +            if (shardEntry.primary()) {, +, +, +++ b/core/src/main/java/org/elasticsearch/action/ActionRequest.java, +++ b/core/src/main/java/org/elasticsearch/cluster/ClusterModule.java, +import org.elasticsearch.index.translog.TranslogConfig;, +, +++ b/core/src/main/java/org/elasticsearch/cluster/routing/IndexShardRoutingTable.java, +, +++ b/core/src/main/java/org/elasticsearch/cluster/routing/RoutingNodes.java, +                        } else if (!shard.active()) { // shards that are initializing without being relocated, +++ b/core/src/main/java/org/elasticsearch/cluster/routing/allocation/AllocationService.java, +        RoutingNodes routingNodes = allocation.routingNodes();, +, +        // go over and remove dangling replicas that are initializing for primary shards, +        List<ShardRouting> shardsToFail = new ArrayList<>();, +                for (ShardRouting routing : routingNodes.assignedShards(shardEntry)) {, +                    if (!routing.primary() && routing.initializing()) {, +                        shardsToFail.add(routing);, +                    }, +                }, +, +            }, +        }, +        for (ShardRouting shardToFail : shardsToFail) {, +            changed |= applyFailedShard(allocation, shardToFail, false,, +                    new UnassignedInfo(UnassignedInfo.Reason.ALLOCATION_FAILED, "primary failed while replica initializing",, +                            null, allocation.getCurrentNanoTime(), System.currentTimeMillis()));, +        }, +, +        // now, go over and elect a new primary if possible, not, from this code block on, if one is elected,, +        // routingNodes.hasUnassignedPrimaries() will potentially be false, +, +        for (ShardRouting shardEntry : routingNodes.unassigned()) {, +            if (shardEntry.primary()) {, +, +, +++ b/core/src/main/java/org/elasticsearch/cluster/routing/allocation/decider/ThrottlingAllocationDecider.java, +    public static final String CLUSTER_ROUTING_ALLOCATION_CONCURRENT_RECOVERIES = "cluster.routing.allocation.concurrent_recoveries";, +    public static final Setting<Integer> CLUSTER_ROUTING_ALLOCATION_NODE_INITIAL_PRIMARIES_RECOVERIES_SETTING = Setting.intSetting("cluster.routing.allocation.node_initial_primaries_recoveries", DEFAULT_CLUSTER_ROUTING_ALLOCATION_NODE_INITIAL_PRIMARIES_RECOVERIES, 0, true, Setting.Scope.CLUSTER);, +    public static final Setting<Integer> CLUSTER_ROUTING_ALLOCATION_NODE_CONCURRENT_RECOVERIES_SETTING = new Setting<>("cluster.routing.allocation.node_concurrent_recoveries", (s) -> s.get(CLUSTER_ROUTING_ALLOCATION_CONCURRENT_RECOVERIES,Integer.toString(DEFAULT_CLUSTER_ROUTING_ALLOCATION_NODE_CONCURRENT_RECOVERIES)), (s) -> Setting.parseInt(s, 0, "cluster.routing.allocation.node_concurrent_recoveries"), true, Setting.Scope.CLUSTER);, +    private volatile int concurrentRecoveries;, +        this.concurrentRecoveries = CLUSTER_ROUTING_ALLOCATION_NODE_CONCURRENT_RECOVERIES_SETTING.get(settings);, +        logger.debug("using node_concurrent_recoveries [{}], node_initial_primaries_recoveries [{}]", concurrentRecoveries, primariesInitialRecoveries);, +        clusterSettings.addSettingsUpdateConsumer(CLUSTER_ROUTING_ALLOCATION_NODE_CONCURRENT_RECOVERIES_SETTING, this::setConcurrentRecoveries);, +    private void setConcurrentRecoveries(int concurrentRecoveries) {, +        this.concurrentRecoveries = concurrentRecoveries;, +, +        int currentRecoveries = 0;, +        for (ShardRouting shard : node) {]