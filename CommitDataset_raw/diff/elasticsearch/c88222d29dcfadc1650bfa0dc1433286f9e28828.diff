[+++ b/server/src/test/java/org/elasticsearch/discovery/MasterDisruptionIT.java, +++ b/server/src/test/java/org/elasticsearch/discovery/MasterDisruptionIT.java, +++ b/server/src/test/java/org/elasticsearch/discovery/StableMasterDisruptionIT.java, +import org.apache.logging.log4j.message.ParameterizedMessage;, +import org.elasticsearch.cluster.ClusterState;, +import org.elasticsearch.cluster.ClusterStateUpdateTask;, +import org.elasticsearch.cluster.coordination.Coordinator;, +import org.elasticsearch.cluster.node.DiscoveryNode;, +import org.elasticsearch.cluster.service.ClusterService;, +import org.elasticsearch.common.Priority;, +import org.elasticsearch.common.collect.Tuple;, +import org.elasticsearch.test.disruption.LongGCDisruption;, +import org.elasticsearch.test.disruption.SingleNodeDisruption;, +import org.elasticsearch.test.transport.MockTransportService;, +import java.util.ArrayList;, +import java.util.HashMap;, +import java.util.Map;, +import java.util.Objects;, +import java.util.concurrent.CountDownLatch;, +import java.util.concurrent.TimeUnit;, +        return Collections.singletonList(MockTransportService.TestPlugin.class);, +, +, +    /**, +     * Tests that emulates a frozen elected master node that unfreezes and pushes its cluster state to other nodes that already are, +     * following another elected master node. These nodes should reject this cluster state and prevent them from following the stale master., +     */, +    public void testStaleMasterNotHijackingMajority() throws Exception {, +        final List<String> nodes = internalCluster().startNodes(3, Settings.builder(), +            .put(LeaderChecker.LEADER_CHECK_TIMEOUT_SETTING.getKey(), "1s"), +            .put(Coordinator.PUBLISH_TIMEOUT_SETTING.getKey(), "1s"), +            .build());, +        ensureStableCluster(3);, +, +        // Save the current master node as old master node, because that node will get frozen, +        final String oldMasterNode = internalCluster().getMasterName();, +, +        // Simulating a painful gc by suspending all threads for a long time on the current elected master node., +        SingleNodeDisruption masterNodeDisruption = new LongGCDisruption(random(), oldMasterNode);, +, +        // Save the majority side, +        final List<String> majoritySide = new ArrayList<>(nodes);, +        majoritySide.remove(oldMasterNode);, +, +        // Keeps track of the previous and current master when a master node transition took place on each node on the majority side:, +        final Map<String, List<Tuple<String, String>>> masters = Collections.synchronizedMap(new HashMap<>());, +        for (final String node : majoritySide) {, +            masters.put(node, new ArrayList<>());, +            internalCluster().getInstance(ClusterService.class, node).addListener(event -> {, +                DiscoveryNode previousMaster = event.previousState().nodes().getMasterNode();, +                DiscoveryNode currentMaster = event.state().nodes().getMasterNode();, +                if (!Objects.equals(previousMaster, currentMaster)) {, +                    logger.info("--> node {} received new cluster state: {} \n and had previous cluster state: {}", node, event.state(),, +                        event.previousState());, +                    String previousMasterNodeName = previousMaster != null ? previousMaster.getName() : null;, +                    String currentMasterNodeName = currentMaster != null ? currentMaster.getName() : null;, +                    masters.get(node).add(new Tuple<>(previousMasterNodeName, currentMasterNodeName));, +                }, +            });, +        }, +, +        final CountDownLatch oldMasterNodeSteppedDown = new CountDownLatch(1);, +        internalCluster().getInstance(ClusterService.class, oldMasterNode).addListener(event -> {, +            if (event.state().nodes().getMasterNodeId() == null) {, +                oldMasterNodeSteppedDown.countDown();, +            }, +        });, +, +        internalCluster().setDisruptionScheme(masterNodeDisruption);, +        logger.info("--> freezing node [{}]", oldMasterNode);, +        masterNodeDisruption.startDisrupting();, +, +        // Wait for majority side to elect a new master, +        assertBusy(() -> {, +            for (final Map.Entry<String, List<Tuple<String, String>>> entry : masters.entrySet()) {, +                final List<Tuple<String, String>> transitions = entry.getValue();, +                assertTrue(entry.getKey() + ": " + transitions,, +                    transitions.stream().anyMatch(transition -> transition.v2() != null));, +            }, +        });, +, +        // The old master node is frozen, but here we submit a cluster state update task that doesn't get executed, but will be queued and, +        // once the old master node un-freezes it gets executed.  The old master node will send this update + the cluster state where it is, +        // flagged as master to the other nodes that follow the new master. These nodes should ignore this update., +        internalCluster().getInstance(ClusterService.class, oldMasterNode).submitStateUpdateTask("sneaky-update", new, +            ClusterStateUpdateTask(Priority.IMMEDIATE) {, +                @Override, +                public ClusterState execute(ClusterState currentState) {, +                    return ClusterState.builder(currentState).build();, +                }, +, +                @Override, +                public void onFailure(String source, Exception e) {, +                    logger.warn(() -> new ParameterizedMessage("failure [{}]", source), e);, +                }, +            });, +, +        // Save the new elected master node, +        final String newMasterNode = internalCluster().getMasterName(majoritySide.get(0));, +        logger.info("--> new detected master node [{}]", newMasterNode);]