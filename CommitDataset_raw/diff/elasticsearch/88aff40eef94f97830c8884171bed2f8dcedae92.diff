[+++ b/core/src/main/java/org/elasticsearch/cluster/routing/allocation/RoutingAllocation.java, +    /**, +     * Returns whether the given node id should be ignored from consideration when {@link AllocationDeciders}, +     * is deciding whether to allocate the specified shard id to that node.  The node will be ignored if, +     * the specified shard failed on that node, triggering the current round of allocation.  Since the shard, +     * just failed on that node, we don't want to try to reassign it there, if the node is still a part, +     * of the cluster., +     *, +     * @param shardId the shard id to be allocated, +     * @param nodeId the node id to check against, +     * @return true if the node id should be ignored in allocation decisions, false otherwise, +     */, +++ b/core/src/main/java/org/elasticsearch/cluster/routing/allocation/RoutingAllocation.java, +    /**, +     * Returns whether the given node id should be ignored from consideration when {@link AllocationDeciders}, +     * is deciding whether to allocate the specified shard id to that node.  The node will be ignored if, +     * the specified shard failed on that node, triggering the current round of allocation.  Since the shard, +     * just failed on that node, we don't want to try to reassign it there, if the node is still a part, +     * of the cluster., +     *, +     * @param shardId the shard id to be allocated, +     * @param nodeId the node id to check against, +     * @return true if the node id should be ignored in allocation decisions, false otherwise, +     */, +++ b/core/src/main/java/org/elasticsearch/cluster/routing/allocation/decider/AllocationDecider.java, +import org.elasticsearch.cluster.routing.allocation.decider.Decision.Type;, +, +    /**, +     * Returns a {@link Decision} whether the given primary shard can be, +     * forcibly allocated on the given node. This method should only be called, +     * for unassigned primary shards where the node has a shard copy on disk., +     *, +     * Note: all implementations that override this behavior should take into account, +     * the results of {@link #canAllocate(ShardRouting, RoutingNode, RoutingAllocation)}, +     * before making a decision on force allocation, because force allocation should only, +     * be considered if all deciders return {@link Decision#NO}., +     */, +    public Decision canForceAllocatePrimary(ShardRouting shardRouting, RoutingNode node, RoutingAllocation allocation) {, +        assert shardRouting.primary() : "must not call canForceAllocatePrimary on a non-primary shard " + shardRouting;, +        assert shardRouting.unassigned() : "must not call canForceAllocatePrimary on an assigned shard " + shardRouting;, +        Decision decision = canAllocate(shardRouting, node, allocation);, +        if (decision.type() == Type.NO) {, +            // On a NO decision, by default, we allow force allocating the primary., +            return allocation.decision(Decision.YES,, +                                       decision.label(),, +                                       "primary shard [{}] allowed to force allocate on node [{}]",, +                                       shardRouting.shardId(), node.nodeId());, +        } else {, +            // On a THROTTLE/YES decision, we use the same decision instead of forcing allocation, +            return decision;, +        }, +    }, +++ b/core/src/main/java/org/elasticsearch/cluster/routing/allocation/RoutingAllocation.java, +    /**, +     * Returns whether the given node id should be ignored from consideration when {@link AllocationDeciders}, +     * is deciding whether to allocate the specified shard id to that node.  The node will be ignored if, +     * the specified shard failed on that node, triggering the current round of allocation.  Since the shard, +     * just failed on that node, we don't want to try to reassign it there, if the node is still a part, +     * of the cluster., +     *, +     * @param shardId the shard id to be allocated, +     * @param nodeId the node id to check against, +     * @return true if the node id should be ignored in allocation decisions, false otherwise, +     */, +++ b/core/src/main/java/org/elasticsearch/cluster/routing/allocation/decider/AllocationDecider.java, +import org.elasticsearch.cluster.routing.allocation.decider.Decision.Type;, +, +    /**, +     * Returns a {@link Decision} whether the given primary shard can be, +     * forcibly allocated on the given node. This method should only be called, +     * for unassigned primary shards where the node has a shard copy on disk., +     *, +     * Note: all implementations that override this behavior should take into account, +     * the results of {@link #canAllocate(ShardRouting, RoutingNode, RoutingAllocation)}, +     * before making a decision on force allocation, because force allocation should only, +     * be considered if all deciders return {@link Decision#NO}., +     */, +    public Decision canForceAllocatePrimary(ShardRouting shardRouting, RoutingNode node, RoutingAllocation allocation) {, +        assert shardRouting.primary() : "must not call canForceAllocatePrimary on a non-primary shard " + shardRouting;, +        assert shardRouting.unassigned() : "must not call canForceAllocatePrimary on an assigned shard " + shardRouting;, +        Decision decision = canAllocate(shardRouting, node, allocation);, +        if (decision.type() == Type.NO) {, +            // On a NO decision, by default, we allow force allocating the primary., +            return allocation.decision(Decision.YES,, +                                       decision.label(),, +                                       "primary shard [{}] allowed to force allocate on node [{}]",, +                                       shardRouting.shardId(), node.nodeId());, +        } else {, +            // On a THROTTLE/YES decision, we use the same decision instead of forcing allocation, +            return decision;, +        }, +    }, +++ b/core/src/main/java/org/elasticsearch/cluster/routing/allocation/decider/AllocationDeciders.java, +, +    @Override, +    public Decision canForceAllocatePrimary(ShardRouting shardRouting, RoutingNode node, RoutingAllocation allocation) {, +        assert shardRouting.primary() : "must not call canForceAllocatePrimary on a non-primary shard routing " + shardRouting;, +, +        if (allocation.shouldIgnoreShardForNode(shardRouting.shardId(), node.nodeId())) {, +            return Decision.NO;]