[+++ b/core/src/main/java/org/elasticsearch/common/transport/BoundTransportAddress.java, + * A bounded transport address is a tuple of {@link TransportAddress}, one array that represents, + * the addresses the transport is bound to, and the other is the published one that represents the address clients, + * should communicate on., +    private TransportAddress[] boundAddresses;, +    public BoundTransportAddress(TransportAddress[] boundAddresses, TransportAddress publishAddress) {, +        if (boundAddresses == null || boundAddresses.length < 1) {, +            throw new IllegalArgumentException("at least one bound address must be provided");, +        }, +        this.boundAddresses = boundAddresses;, +    public TransportAddress[] boundAddresses() {, +        return boundAddresses;, +        int boundAddressLength = in.readInt();, +        boundAddresses = new TransportAddress[boundAddressLength];, +        for (int i = 0; i < boundAddressLength; i++) {, +            boundAddresses[i] = TransportAddressSerializers.addressFromStream(in);, +        }, +        out.writeInt(boundAddresses.length);, +        for (TransportAddress address : boundAddresses) {, +            TransportAddressSerializers.addressToStream(out, address);, +        }, +        StringBuilder builder = new StringBuilder("publish_address {");, +        builder.append(publishAddress);, +        builder.append("}, bound_addresses ");, +        boolean firstAdded = false;, +        for (TransportAddress address : boundAddresses) {, +            if (firstAdded) {, +                builder.append(", ");, +            } else {, +                firstAdded = true;, +            }, +, +            builder.append("{").append(address).append("}");, +        }, +        return builder.toString();, +++ b/core/src/main/java/org/elasticsearch/common/transport/BoundTransportAddress.java, + * A bounded transport address is a tuple of {@link TransportAddress}, one array that represents, + * the addresses the transport is bound to, and the other is the published one that represents the address clients, + * should communicate on., +    private TransportAddress[] boundAddresses;, +    public BoundTransportAddress(TransportAddress[] boundAddresses, TransportAddress publishAddress) {, +        if (boundAddresses == null || boundAddresses.length < 1) {, +            throw new IllegalArgumentException("at least one bound address must be provided");, +        }, +        this.boundAddresses = boundAddresses;, +    public TransportAddress[] boundAddresses() {, +        return boundAddresses;, +        int boundAddressLength = in.readInt();, +        boundAddresses = new TransportAddress[boundAddressLength];, +        for (int i = 0; i < boundAddressLength; i++) {, +            boundAddresses[i] = TransportAddressSerializers.addressFromStream(in);, +        }, +        out.writeInt(boundAddresses.length);, +        for (TransportAddress address : boundAddresses) {, +            TransportAddressSerializers.addressToStream(out, address);, +        }, +        StringBuilder builder = new StringBuilder("publish_address {");, +        builder.append(publishAddress);, +        builder.append("}, bound_addresses ");, +        boolean firstAdded = false;, +        for (TransportAddress address : boundAddresses) {, +            if (firstAdded) {, +                builder.append(", ");, +            } else {, +                firstAdded = true;, +            }, +, +            builder.append("{").append(address).append("}");, +        }, +        return builder.toString();, +++ b/core/src/main/java/org/elasticsearch/http/HttpInfo.java, +        builder.array(Fields.BOUND_ADDRESS, (Object[]) address.boundAddresses());, +++ b/core/src/main/java/org/elasticsearch/common/transport/BoundTransportAddress.java, + * A bounded transport address is a tuple of {@link TransportAddress}, one array that represents, + * the addresses the transport is bound to, and the other is the published one that represents the address clients, + * should communicate on., +    private TransportAddress[] boundAddresses;, +    public BoundTransportAddress(TransportAddress[] boundAddresses, TransportAddress publishAddress) {, +        if (boundAddresses == null || boundAddresses.length < 1) {, +            throw new IllegalArgumentException("at least one bound address must be provided");, +        }, +        this.boundAddresses = boundAddresses;, +    public TransportAddress[] boundAddresses() {, +        return boundAddresses;, +        int boundAddressLength = in.readInt();, +        boundAddresses = new TransportAddress[boundAddressLength];, +        for (int i = 0; i < boundAddressLength; i++) {, +            boundAddresses[i] = TransportAddressSerializers.addressFromStream(in);, +        }, +        out.writeInt(boundAddresses.length);, +        for (TransportAddress address : boundAddresses) {, +            TransportAddressSerializers.addressToStream(out, address);, +        }, +        StringBuilder builder = new StringBuilder("publish_address {");, +        builder.append(publishAddress);, +        builder.append("}, bound_addresses ");, +        boolean firstAdded = false;, +        for (TransportAddress address : boundAddresses) {, +            if (firstAdded) {, +                builder.append(", ");]