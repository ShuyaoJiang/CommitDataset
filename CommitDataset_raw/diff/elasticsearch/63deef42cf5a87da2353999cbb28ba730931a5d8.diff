[+++ b/modules/elasticsearch/src/main/java/org/elasticsearch/common/blobstore/support/ImmutableAppendableBlobContainer.java, +/*, + * Licensed to Elastic Search and Shay Banon under one, + * or more contributor license agreements.  See the NOTICE file, + * distributed with this work for additional information, + * regarding copyright ownership. Elastic Search licenses this, + * file to you under the Apache License, Version 2.0 (the, + * "License"); you may not use this file except in compliance, + * with the License.  You may obtain a copy of the License at, + *, + *    http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing,, + * software distributed under the License is distributed on an, + * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY, + * KIND, either express or implied.  See the License for the, + * specific language governing permissions and limitations, + * under the License., + */, +, +package org.elasticsearch.common.blobstore.support;, +, +import org.elasticsearch.common.blobstore.AppendableBlobContainer;, +import org.elasticsearch.common.blobstore.BlobMetaData;, +import org.elasticsearch.common.blobstore.ImmutableBlobContainer;, +import org.elasticsearch.common.collect.ImmutableMap;, +import org.elasticsearch.common.collect.Sets;, +import org.elasticsearch.common.io.FastByteArrayInputStream;, +import org.elasticsearch.common.io.stream.BytesStreamOutput;, +, +import java.io.IOException;, +import java.util.Set;, +, +/**, + * An appendable container that uses an immutable container to implement an appendable one., + *, + * @author kimchy (shay.banon), + */, +public class ImmutableAppendableBlobContainer extends AbstractBlobContainer implements AppendableBlobContainer {, +, +    private final ImmutableBlobContainer container;, +, +    public ImmutableAppendableBlobContainer(ImmutableBlobContainer container) {, +        super(container.path());, +        this.container = container;, +    }, +, +    @Override public boolean canAppendToExistingBlob() {, +        return false;, +    }, +, +    @Override public AppendableBlob appendBlob(final String blobName) throws IOException {, +        return new AppendableBlob() {, +            int part = 0;, +, +            @Override public void append(final AppendBlobListener listener) {, +                BytesStreamOutput out = new BytesStreamOutput();, +                String partBlobName = blobName + ".a" + (part++);, +                try {, +                    listener.withStream(out);, +                } catch (IOException e) {, +                    listener.onFailure(e);, +                }, +                FastByteArrayInputStream is = new FastByteArrayInputStream(out.unsafeByteArray(), 0, out.size());, +                container.writeBlob(partBlobName, is, out.size(), new ImmutableBlobContainer.WriterListener() {, +                    @Override public void onCompleted() {, +                        listener.onCompleted();, +                    }, +, +                    @Override public void onFailure(Throwable t) {, +                        listener.onFailure(t);, +                    }, +                });, +            }, +, +            @Override public void close() {, +, +            }, +        };, +    }, +, +    @Override public void readBlob(final String blobName, final ReadBlobListener listener) {, +        container.readBlob(blobName + ".a0", new ReadBlobListener() {, +            int part = 0;, +, +            @Override public void onPartial(byte[] data, int offset, int size) throws IOException {, +                listener.onPartial(data, offset, size);, +            }, +, +            @Override public void onCompleted() {, +                part++;, +                if (container.blobExists(blobName + ".a" + part)) {, +                    container.readBlob(blobName + ".a" + part, this);, +                }, +            }, +, +            @Override public void onFailure(Throwable t) {, +                listener.onFailure(t);, +            }, +        });]