[+++ b/buildSrc/src/main/resources/checkstyle_suppressions.xml, +++ b/buildSrc/src/main/resources/checkstyle_suppressions.xml, +++ b/core/src/main/java/org/elasticsearch/search/searchafter/SearchAfterBuilder.java, +import org.elasticsearch.common.text.Text;, +        for (int i = 0; i < values.length; i++) {, +            if (values[i] == null) continue;, +            if (values[i] instanceof String) continue;, +            if (values[i] instanceof Text) continue;, +            if (values[i] instanceof Long) continue;, +            if (values[i] instanceof Integer) continue;, +            if (values[i] instanceof Short) continue;, +            if (values[i] instanceof Byte) continue;, +            if (values[i] instanceof Double) continue;, +            if (values[i] instanceof Float) continue;, +            if (values[i] instanceof Boolean) continue;, +            if (values[i] instanceof Boolean) continue;, +            throw new IllegalArgumentException("Can't handle " + SEARCH_AFTER + " field value of type [" + values[i].getClass() + "]");, +        }, +        return Arrays.copyOf(sortValues, sortValues.length);, +++ b/buildSrc/src/main/resources/checkstyle_suppressions.xml, +++ b/core/src/main/java/org/elasticsearch/search/searchafter/SearchAfterBuilder.java, +import org.elasticsearch.common.text.Text;, +        for (int i = 0; i < values.length; i++) {, +            if (values[i] == null) continue;, +            if (values[i] instanceof String) continue;, +            if (values[i] instanceof Text) continue;, +            if (values[i] instanceof Long) continue;, +            if (values[i] instanceof Integer) continue;, +            if (values[i] instanceof Short) continue;, +            if (values[i] instanceof Byte) continue;, +            if (values[i] instanceof Double) continue;, +            if (values[i] instanceof Float) continue;, +            if (values[i] instanceof Boolean) continue;, +            if (values[i] instanceof Boolean) continue;, +            throw new IllegalArgumentException("Can't handle " + SEARCH_AFTER + " field value of type [" + values[i].getClass() + "]");, +        }, +        return Arrays.copyOf(sortValues, sortValues.length);, +++ b/core/src/test/java/org/elasticsearch/search/searchafter/SearchAfterBuilderTests.java, +import org.elasticsearch.common.geo.GeoPoint;, +            assertThat("searchFrom copy's hashcode is different from original hashcode", secondBuilder.hashCode(),, +                    equalTo(firstBuilder.hashCode()));, +            assertThat("searchFrom copy's hashcode is different from original hashcode", secondBuilder.hashCode(),, +                    equalTo(thirdBuilder.hashCode()));, +            assertThat("searchFrom copy's hashcode is different from original hashcode", firstBuilder.hashCode(),, +                    equalTo(thirdBuilder.hashCode()));, +, +    /**, +     * Explicitly tests what you can't list as a sortValue. What you can list is tested by {@link #randomSearchFromBuilder()}., +     */, +    public void testBadTypes() throws IOException {, +        randomSearchFromBuilderWithSortValueThrows(new Object());, +        randomSearchFromBuilderWithSortValueThrows(new GeoPoint(0, 0));, +        randomSearchFromBuilderWithSortValueThrows(randomSearchFromBuilder());, +        randomSearchFromBuilderWithSortValueThrows(this);, +    }, +, +    private void randomSearchFromBuilderWithSortValueThrows(Object containing) throws IOException {, +        // Get a valid one, +        SearchAfterBuilder builder = randomSearchFromBuilder();, +        // Now replace its values with one containing the passed in object, +        Object[] values = builder.getSortValues();, +        values[between(0, values.length - 1)] = containing;, +        Exception e = expectThrows(IllegalArgumentException.class, () -> builder.setSortValues(values));, +        assertEquals(e.getMessage(), "Can't handle search_after field value of type [" + containing.getClass() + "]");, +    }]