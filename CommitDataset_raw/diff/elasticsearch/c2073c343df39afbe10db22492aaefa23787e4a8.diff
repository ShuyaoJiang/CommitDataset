[+++ b/src/main/java/org/elasticsearch/cluster/routing/allocation/allocator/EvenShardsCountAllocator.java, +import org.elasticsearch.cluster.routing.allocation.decider.Decision;, +                Decision decision = allocation.deciders().canAllocate(shard, node, allocation);, +                if (decision.type() == Decision.Type.YES) {, +                Decision decision = allocation.deciders().canAllocate(shard, routingNode, allocation);, +                if (decision.type() == Decision.Type.YES) {, +                    Decision decision = allocation.deciders().canAllocate(startedShard, lowRoutingNode, allocation);, +                    if (decision.type() == Decision.Type.YES) {, +            Decision decision = allocation.deciders().canAllocate(shardRouting, nodeToCheck, allocation);, +            if (decision.type() == Decision.Type.YES) {, +++ b/src/main/java/org/elasticsearch/cluster/routing/allocation/allocator/EvenShardsCountAllocator.java, +import org.elasticsearch.cluster.routing.allocation.decider.Decision;, +                Decision decision = allocation.deciders().canAllocate(shard, node, allocation);, +                if (decision.type() == Decision.Type.YES) {, +                Decision decision = allocation.deciders().canAllocate(shard, routingNode, allocation);, +                if (decision.type() == Decision.Type.YES) {, +                    Decision decision = allocation.deciders().canAllocate(startedShard, lowRoutingNode, allocation);, +                    if (decision.type() == Decision.Type.YES) {, +            Decision decision = allocation.deciders().canAllocate(shardRouting, nodeToCheck, allocation);, +            if (decision.type() == Decision.Type.YES) {, +++ b/src/main/java/org/elasticsearch/cluster/routing/allocation/command/AllocateAllocationCommand.java, +import org.elasticsearch.cluster.routing.allocation.decider.Decision;, +        Decision decision = allocation.deciders().canAllocate(shardRouting, routingNode, allocation);, +        if (decision.type() == Decision.Type.NO) {, +            throw new ElasticSearchIllegalArgumentException("[allocate] allocation of " + shardId + " on node " + discoNode + " is not allowed, reason: " + decision);, +++ b/src/main/java/org/elasticsearch/cluster/routing/allocation/allocator/EvenShardsCountAllocator.java, +import org.elasticsearch.cluster.routing.allocation.decider.Decision;, +                Decision decision = allocation.deciders().canAllocate(shard, node, allocation);, +                if (decision.type() == Decision.Type.YES) {, +                Decision decision = allocation.deciders().canAllocate(shard, routingNode, allocation);, +                if (decision.type() == Decision.Type.YES) {, +                    Decision decision = allocation.deciders().canAllocate(startedShard, lowRoutingNode, allocation);, +                    if (decision.type() == Decision.Type.YES) {, +            Decision decision = allocation.deciders().canAllocate(shardRouting, nodeToCheck, allocation);, +            if (decision.type() == Decision.Type.YES) {, +++ b/src/main/java/org/elasticsearch/cluster/routing/allocation/command/AllocateAllocationCommand.java, +import org.elasticsearch.cluster.routing.allocation.decider.Decision;, +        Decision decision = allocation.deciders().canAllocate(shardRouting, routingNode, allocation);, +        if (decision.type() == Decision.Type.NO) {, +            throw new ElasticSearchIllegalArgumentException("[allocate] allocation of " + shardId + " on node " + discoNode + " is not allowed, reason: " + decision);, +++ b/src/main/java/org/elasticsearch/cluster/routing/allocation/command/MoveAllocationCommand.java, +import org.elasticsearch.cluster.routing.allocation.decider.Decision;, +            Decision decision = allocation.deciders().canAllocate(shardRouting, toRoutingNode, allocation);, +            if (decision.type() == Decision.Type.NO) {, +                throw new ElasticSearchIllegalArgumentException("[move_allocation] can't move " + shardId + ", from " + fromDiscoNode + ", to " + toDiscoNode + ", since its not allowed, reason: " + decision);, +            if (decision.type() == Decision.Type.THROTTLE) {, +++ b/src/main/java/org/elasticsearch/cluster/routing/allocation/allocator/EvenShardsCountAllocator.java, +import org.elasticsearch.cluster.routing.allocation.decider.Decision;, +                Decision decision = allocation.deciders().canAllocate(shard, node, allocation);, +                if (decision.type() == Decision.Type.YES) {, +                Decision decision = allocation.deciders().canAllocate(shard, routingNode, allocation);, +                if (decision.type() == Decision.Type.YES) {, +                    Decision decision = allocation.deciders().canAllocate(startedShard, lowRoutingNode, allocation);, +                    if (decision.type() == Decision.Type.YES) {, +            Decision decision = allocation.deciders().canAllocate(shardRouting, nodeToCheck, allocation);, +            if (decision.type() == Decision.Type.YES) {, +++ b/src/main/java/org/elasticsearch/cluster/routing/allocation/command/AllocateAllocationCommand.java, +import org.elasticsearch.cluster.routing.allocation.decider.Decision;, +        Decision decision = allocation.deciders().canAllocate(shardRouting, routingNode, allocation);, +        if (decision.type() == Decision.Type.NO) {, +            throw new ElasticSearchIllegalArgumentException("[allocate] allocation of " + shardId + " on node " + discoNode + " is not allowed, reason: " + decision);, +++ b/src/main/java/org/elasticsearch/cluster/routing/allocation/command/MoveAllocationCommand.java, +import org.elasticsearch.cluster.routing.allocation.decider.Decision;, +            Decision decision = allocation.deciders().canAllocate(shardRouting, toRoutingNode, allocation);, +            if (decision.type() == Decision.Type.NO) {, +                throw new ElasticSearchIllegalArgumentException("[move_allocation] can't move " + shardId + ", from " + fromDiscoNode + ", to " + toDiscoNode + ", since its not allowed, reason: " + decision);, +            if (decision.type() == Decision.Type.THROTTLE) {, +++ b/src/main/java/org/elasticsearch/cluster/routing/allocation/decider/AllocationDecider.java, +        return Decision.ALWAYS;, +++ b/src/main/java/org/elasticsearch/cluster/routing/allocation/allocator/EvenShardsCountAllocator.java, +import org.elasticsearch.cluster.routing.allocation.decider.Decision;, +                Decision decision = allocation.deciders().canAllocate(shard, node, allocation);, +                if (decision.type() == Decision.Type.YES) {, +                Decision decision = allocation.deciders().canAllocate(shard, routingNode, allocation);, +                if (decision.type() == Decision.Type.YES) {, +                    Decision decision = allocation.deciders().canAllocate(startedShard, lowRoutingNode, allocation);, +                    if (decision.type() == Decision.Type.YES) {, +            Decision decision = allocation.deciders().canAllocate(shardRouting, nodeToCheck, allocation);, +            if (decision.type() == Decision.Type.YES) {, +++ b/src/main/java/org/elasticsearch/cluster/routing/allocation/command/AllocateAllocationCommand.java, +import org.elasticsearch.cluster.routing.allocation.decider.Decision;, +        Decision decision = allocation.deciders().canAllocate(shardRouting, routingNode, allocation);, +        if (decision.type() == Decision.Type.NO) {, +            throw new ElasticSearchIllegalArgumentException("[allocate] allocation of " + shardId + " on node " + discoNode + " is not allowed, reason: " + decision);, +++ b/src/main/java/org/elasticsearch/cluster/routing/allocation/command/MoveAllocationCommand.java, +import org.elasticsearch.cluster.routing.allocation.decider.Decision;, +            Decision decision = allocation.deciders().canAllocate(shardRouting, toRoutingNode, allocation);, +            if (decision.type() == Decision.Type.NO) {, +                throw new ElasticSearchIllegalArgumentException("[move_allocation] can't move " + shardId + ", from " + fromDiscoNode + ", to " + toDiscoNode + ", since its not allowed, reason: " + decision);, +            if (decision.type() == Decision.Type.THROTTLE) {, +++ b/src/main/java/org/elasticsearch/cluster/routing/allocation/decider/AllocationDecider.java, +        return Decision.ALWAYS;, +++ b/src/main/java/org/elasticsearch/cluster/routing/allocation/decider/AllocationDeciders.java, +        Decision.Multi ret = new Decision.Multi();, +        for (AllocationDecider allocationDecider : allocations) {, +            Decision decision = allocationDecider.canAllocate(shardRouting, node, allocation);, +            // the assumption is that a decider that returns the static instance Decision#ALWAYS, +            // does not really implements canAllocate, +            if (decision != Decision.ALWAYS) {, +                ret.add(decision);]