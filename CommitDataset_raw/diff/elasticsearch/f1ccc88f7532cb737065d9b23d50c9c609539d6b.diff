[+++ b/core/src/main/java/org/elasticsearch/action/admin/cluster/allocation/ClusterAllocationExplanation.java, +    private final long allocationDelayMillis;, +    public ClusterAllocationExplanation(ShardId shard, boolean primary, @Nullable String assignedNodeId, long allocationDelayMillis,, +                                        long remainingDelayMillis, @Nullable UnassignedInfo unassignedInfo, boolean hasPendingAsyncFetch,, +        this.allocationDelayMillis = allocationDelayMillis;, +        this.allocationDelayMillis = in.readVLong();, +        out.writeVLong(allocationDelayMillis);, +    /** Return the configured delay before the shard can be allocated in milliseconds */, +    public long getAllocationDelayMillis() {, +        return this.allocationDelayMillis;, +    }, +, +    /** Return the remaining allocation delay for this shard in milliseconds */, +                builder.timeValueField("allocation_delay_in_millis", "allocation_delay", TimeValue.timeValueMillis(allocationDelayMillis));, +++ b/core/src/main/java/org/elasticsearch/action/admin/cluster/allocation/ClusterAllocationExplanation.java, +    private final long allocationDelayMillis;, +    public ClusterAllocationExplanation(ShardId shard, boolean primary, @Nullable String assignedNodeId, long allocationDelayMillis,, +                                        long remainingDelayMillis, @Nullable UnassignedInfo unassignedInfo, boolean hasPendingAsyncFetch,, +        this.allocationDelayMillis = allocationDelayMillis;, +        this.allocationDelayMillis = in.readVLong();, +        out.writeVLong(allocationDelayMillis);, +    /** Return the configured delay before the shard can be allocated in milliseconds */, +    public long getAllocationDelayMillis() {, +        return this.allocationDelayMillis;, +    }, +, +    /** Return the remaining allocation delay for this shard in milliseconds */, +                builder.timeValueField("allocation_delay_in_millis", "allocation_delay", TimeValue.timeValueMillis(allocationDelayMillis));, +++ b/core/src/main/java/org/elasticsearch/action/admin/cluster/allocation/TransportClusterAllocationExplainAction.java, +import static org.elasticsearch.cluster.routing.UnassignedInfo.INDEX_DELAYED_NODE_LEFT_TIMEOUT_SETTING;, +, +        long allocationDelayMillis = INDEX_DELAYED_NODE_LEFT_TIMEOUT_SETTING.get(indexMetaData.getSettings()).getMillis();, +        if (ui != null && ui.isDelayed()) {, +            long remainingDelayNanos = ui.getRemainingDelay(System.nanoTime(), indexMetaData.getSettings());, +        return new ClusterAllocationExplanation(shard.shardId(), shard.primary(),, +            shard.currentNodeId(), allocationDelayMillis, remainingDelayMillis, ui,, +            gatewayAllocator.hasFetchPending(shard.shardId(), shard.primary()), explanations);, +++ b/core/src/main/java/org/elasticsearch/action/admin/cluster/allocation/ClusterAllocationExplanation.java, +    private final long allocationDelayMillis;, +    public ClusterAllocationExplanation(ShardId shard, boolean primary, @Nullable String assignedNodeId, long allocationDelayMillis,, +                                        long remainingDelayMillis, @Nullable UnassignedInfo unassignedInfo, boolean hasPendingAsyncFetch,, +        this.allocationDelayMillis = allocationDelayMillis;, +        this.allocationDelayMillis = in.readVLong();, +        out.writeVLong(allocationDelayMillis);, +    /** Return the configured delay before the shard can be allocated in milliseconds */, +    public long getAllocationDelayMillis() {, +        return this.allocationDelayMillis;, +    }, +, +    /** Return the remaining allocation delay for this shard in milliseconds */, +                builder.timeValueField("allocation_delay_in_millis", "allocation_delay", TimeValue.timeValueMillis(allocationDelayMillis));, +++ b/core/src/main/java/org/elasticsearch/action/admin/cluster/allocation/TransportClusterAllocationExplainAction.java, +import static org.elasticsearch.cluster.routing.UnassignedInfo.INDEX_DELAYED_NODE_LEFT_TIMEOUT_SETTING;, +, +        long allocationDelayMillis = INDEX_DELAYED_NODE_LEFT_TIMEOUT_SETTING.get(indexMetaData.getSettings()).getMillis();, +        if (ui != null && ui.isDelayed()) {, +            long remainingDelayNanos = ui.getRemainingDelay(System.nanoTime(), indexMetaData.getSettings());, +        return new ClusterAllocationExplanation(shard.shardId(), shard.primary(),, +            shard.currentNodeId(), allocationDelayMillis, remainingDelayMillis, ui,, +            gatewayAllocator.hasFetchPending(shard.shardId(), shard.primary()), explanations);, +++ b/core/src/main/java/org/elasticsearch/bootstrap/Security.java, +        addPath(policy, Environment.PATH_PLUGINS_SETTING.getKey(), environment.pluginsFile(), "read,readlink");, +++ b/core/src/main/java/org/elasticsearch/action/admin/cluster/allocation/ClusterAllocationExplanation.java, +    private final long allocationDelayMillis;, +    public ClusterAllocationExplanation(ShardId shard, boolean primary, @Nullable String assignedNodeId, long allocationDelayMillis,, +                                        long remainingDelayMillis, @Nullable UnassignedInfo unassignedInfo, boolean hasPendingAsyncFetch,, +        this.allocationDelayMillis = allocationDelayMillis;, +        this.allocationDelayMillis = in.readVLong();, +        out.writeVLong(allocationDelayMillis);, +    /** Return the configured delay before the shard can be allocated in milliseconds */, +    public long getAllocationDelayMillis() {, +        return this.allocationDelayMillis;, +    }, +, +    /** Return the remaining allocation delay for this shard in milliseconds */, +                builder.timeValueField("allocation_delay_in_millis", "allocation_delay", TimeValue.timeValueMillis(allocationDelayMillis));, +++ b/core/src/main/java/org/elasticsearch/action/admin/cluster/allocation/TransportClusterAllocationExplainAction.java, +import static org.elasticsearch.cluster.routing.UnassignedInfo.INDEX_DELAYED_NODE_LEFT_TIMEOUT_SETTING;, +, +        long allocationDelayMillis = INDEX_DELAYED_NODE_LEFT_TIMEOUT_SETTING.get(indexMetaData.getSettings()).getMillis();, +        if (ui != null && ui.isDelayed()) {, +            long remainingDelayNanos = ui.getRemainingDelay(System.nanoTime(), indexMetaData.getSettings());, +        return new ClusterAllocationExplanation(shard.shardId(), shard.primary(),, +            shard.currentNodeId(), allocationDelayMillis, remainingDelayMillis, ui,, +            gatewayAllocator.hasFetchPending(shard.shardId(), shard.primary()), explanations);, +++ b/core/src/main/java/org/elasticsearch/bootstrap/Security.java, +        addPath(policy, Environment.PATH_PLUGINS_SETTING.getKey(), environment.pluginsFile(), "read,readlink");, +++ b/core/src/main/java/org/elasticsearch/cluster/ClusterModule.java, +import org.elasticsearch.cluster.routing.DelayedAllocationService;, +        bind(DelayedAllocationService.class).asEagerSingleton();, +++ b/core/src/main/java/org/elasticsearch/action/admin/cluster/allocation/ClusterAllocationExplanation.java, +    private final long allocationDelayMillis;, +    public ClusterAllocationExplanation(ShardId shard, boolean primary, @Nullable String assignedNodeId, long allocationDelayMillis,, +                                        long remainingDelayMillis, @Nullable UnassignedInfo unassignedInfo, boolean hasPendingAsyncFetch,, +        this.allocationDelayMillis = allocationDelayMillis;, +        this.allocationDelayMillis = in.readVLong();, +        out.writeVLong(allocationDelayMillis);, +    /** Return the configured delay before the shard can be allocated in milliseconds */, +    public long getAllocationDelayMillis() {, +        return this.allocationDelayMillis;]