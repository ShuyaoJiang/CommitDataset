[+++ b/core/src/main/java/org/elasticsearch/cluster/service/InternalClusterService.java, +        this.updateTasksExecutor = EsExecutors.newSinglePrioritizing(UPDATE_THREAD_NAME, daemonThreadFactory(settings, UPDATE_THREAD_NAME));, +++ b/core/src/main/java/org/elasticsearch/cluster/service/InternalClusterService.java, +        this.updateTasksExecutor = EsExecutors.newSinglePrioritizing(UPDATE_THREAD_NAME, daemonThreadFactory(settings, UPDATE_THREAD_NAME));, +++ b/core/src/main/java/org/elasticsearch/common/util/concurrent/EsAbortPolicy.java, +        throw new EsRejectedExecutionException("rejected execution of " + r + " on " + executor, executor.isShutdown());, +++ b/core/src/main/java/org/elasticsearch/cluster/service/InternalClusterService.java, +        this.updateTasksExecutor = EsExecutors.newSinglePrioritizing(UPDATE_THREAD_NAME, daemonThreadFactory(settings, UPDATE_THREAD_NAME));, +++ b/core/src/main/java/org/elasticsearch/common/util/concurrent/EsAbortPolicy.java, +        throw new EsRejectedExecutionException("rejected execution of " + r + " on " + executor, executor.isShutdown());, +++ b/core/src/main/java/org/elasticsearch/common/util/concurrent/EsExecutors.java, +    public static PrioritizedEsThreadPoolExecutor newSinglePrioritizing(String name, ThreadFactory threadFactory) {, +        return new PrioritizedEsThreadPoolExecutor(name, 1, 1, 0L, TimeUnit.MILLISECONDS, threadFactory);, +    public static EsThreadPoolExecutor newScaling(String name, int min, int max, long keepAliveTime, TimeUnit unit, ThreadFactory threadFactory) {, +        EsThreadPoolExecutor executor = new EsThreadPoolExecutor(name, min, max, keepAliveTime, unit, queue, threadFactory, new ForceQueuePolicy());, +    public static EsThreadPoolExecutor newCached(String name, long keepAliveTime, TimeUnit unit, ThreadFactory threadFactory) {, +        return new EsThreadPoolExecutor(name, 0, Integer.MAX_VALUE, keepAliveTime, unit, new SynchronousQueue<Runnable>(), threadFactory, new EsAbortPolicy());, +    public static EsThreadPoolExecutor newFixed(String name, int size, int queueCapacity, ThreadFactory threadFactory) {, +        return new EsThreadPoolExecutor(name, size, size, 0, TimeUnit.MILLISECONDS, queue, threadFactory, new EsAbortPolicy());, +++ b/core/src/main/java/org/elasticsearch/cluster/service/InternalClusterService.java, +        this.updateTasksExecutor = EsExecutors.newSinglePrioritizing(UPDATE_THREAD_NAME, daemonThreadFactory(settings, UPDATE_THREAD_NAME));, +++ b/core/src/main/java/org/elasticsearch/common/util/concurrent/EsAbortPolicy.java, +        throw new EsRejectedExecutionException("rejected execution of " + r + " on " + executor, executor.isShutdown());, +++ b/core/src/main/java/org/elasticsearch/common/util/concurrent/EsExecutors.java, +    public static PrioritizedEsThreadPoolExecutor newSinglePrioritizing(String name, ThreadFactory threadFactory) {, +        return new PrioritizedEsThreadPoolExecutor(name, 1, 1, 0L, TimeUnit.MILLISECONDS, threadFactory);, +    public static EsThreadPoolExecutor newScaling(String name, int min, int max, long keepAliveTime, TimeUnit unit, ThreadFactory threadFactory) {, +        EsThreadPoolExecutor executor = new EsThreadPoolExecutor(name, min, max, keepAliveTime, unit, queue, threadFactory, new ForceQueuePolicy());, +    public static EsThreadPoolExecutor newCached(String name, long keepAliveTime, TimeUnit unit, ThreadFactory threadFactory) {, +        return new EsThreadPoolExecutor(name, 0, Integer.MAX_VALUE, keepAliveTime, unit, new SynchronousQueue<Runnable>(), threadFactory, new EsAbortPolicy());, +    public static EsThreadPoolExecutor newFixed(String name, int size, int queueCapacity, ThreadFactory threadFactory) {, +        return new EsThreadPoolExecutor(name, size, size, 0, TimeUnit.MILLISECONDS, queue, threadFactory, new EsAbortPolicy());, +++ b/core/src/main/java/org/elasticsearch/common/util/concurrent/EsRejectedExecutionException.java, +import org.elasticsearch.common.io.stream.StreamOutput;, +    private final boolean isExecutorShutdown;, +, +    public EsRejectedExecutionException(String message, boolean isExecutorShutdown) {, +        super(message);, +        this.isExecutorShutdown = isExecutorShutdown;, +    }, +        this(message, false);, +        this.isExecutorShutdown = false;, +        this.isExecutorShutdown = false;, +        isExecutorShutdown = in.readBoolean();, +    }, +, +    @Override, +    public void writeTo(StreamOutput out) throws IOException {, +        super.writeTo(out);, +        out.writeBoolean(isExecutorShutdown);, +    }, +, +    /**, +     * Checks if the thread pool that rejected the execution was terminated, +     * shortly after the rejection. Its possible that this returns false and the, +     * thread pool has since been terminated but if this returns false then the, +     * termination wasn't a factor in this rejection. Conversely if this returns, +     * true the shutdown was probably a factor in this rejection but might have, +     * been triggered just after the action rejection., +     */, +    public boolean isExecutorShutdown() {, +        return isExecutorShutdown;, +++ b/core/src/main/java/org/elasticsearch/cluster/service/InternalClusterService.java, +        this.updateTasksExecutor = EsExecutors.newSinglePrioritizing(UPDATE_THREAD_NAME, daemonThreadFactory(settings, UPDATE_THREAD_NAME));, +++ b/core/src/main/java/org/elasticsearch/common/util/concurrent/EsAbortPolicy.java, +        throw new EsRejectedExecutionException("rejected execution of " + r + " on " + executor, executor.isShutdown());, +++ b/core/src/main/java/org/elasticsearch/common/util/concurrent/EsExecutors.java, +    public static PrioritizedEsThreadPoolExecutor newSinglePrioritizing(String name, ThreadFactory threadFactory) {, +        return new PrioritizedEsThreadPoolExecutor(name, 1, 1, 0L, TimeUnit.MILLISECONDS, threadFactory);, +    public static EsThreadPoolExecutor newScaling(String name, int min, int max, long keepAliveTime, TimeUnit unit, ThreadFactory threadFactory) {, +        EsThreadPoolExecutor executor = new EsThreadPoolExecutor(name, min, max, keepAliveTime, unit, queue, threadFactory, new ForceQueuePolicy());, +    public static EsThreadPoolExecutor newCached(String name, long keepAliveTime, TimeUnit unit, ThreadFactory threadFactory) {, +        return new EsThreadPoolExecutor(name, 0, Integer.MAX_VALUE, keepAliveTime, unit, new SynchronousQueue<Runnable>(), threadFactory, new EsAbortPolicy());, +    public static EsThreadPoolExecutor newFixed(String name, int size, int queueCapacity, ThreadFactory threadFactory) {, +        return new EsThreadPoolExecutor(name, size, size, 0, TimeUnit.MILLISECONDS, queue, threadFactory, new EsAbortPolicy());, +++ b/core/src/main/java/org/elasticsearch/common/util/concurrent/EsRejectedExecutionException.java, +import org.elasticsearch.common.io.stream.StreamOutput;, +    private final boolean isExecutorShutdown;, +, +    public EsRejectedExecutionException(String message, boolean isExecutorShutdown) {, +        super(message);, +        this.isExecutorShutdown = isExecutorShutdown;, +    }, +        this(message, false);, +        this.isExecutorShutdown = false;, +        this.isExecutorShutdown = false;, +        isExecutorShutdown = in.readBoolean();, +    }, +, +    @Override, +    public void writeTo(StreamOutput out) throws IOException {, +        super.writeTo(out);, +        out.writeBoolean(isExecutorShutdown);, +    }, +, +    /**, +     * Checks if the thread pool that rejected the execution was terminated, +     * shortly after the rejection. Its possible that this returns false and the, +     * thread pool has since been terminated but if this returns false then the, +     * termination wasn't a factor in this rejection. Conversely if this returns]