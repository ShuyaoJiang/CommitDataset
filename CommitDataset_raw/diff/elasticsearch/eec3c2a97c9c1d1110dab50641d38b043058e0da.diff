[+++ b/core/pom.xml, +                                <include>org/elasticsearch/bootstrap/BootstrapForTesting$*.class</include>, +                                <include>org/elasticsearch/bootstrap/BootstrapForTesting$*.class</include>, +++ b/core/pom.xml, +                                <include>org/elasticsearch/bootstrap/BootstrapForTesting$*.class</include>, +                                <include>org/elasticsearch/bootstrap/BootstrapForTesting$*.class</include>, +++ b/core/src/main/java/org/elasticsearch/action/admin/indices/delete/TransportDeleteIndexAction.java, +        final String[] concreteIndices = indexNameExpressionResolver.concreteIndices(state, request);, +        deleteIndexService.deleteIndices(new MetaDataDeleteIndexService.Request(concreteIndices).timeout(request.timeout()).masterTimeout(request.masterNodeTimeout()), new MetaDataDeleteIndexService.Listener() {, +                listener.onResponse(new DeleteIndexResponse(response.acknowledged()));, +++ b/core/pom.xml, +                                <include>org/elasticsearch/bootstrap/BootstrapForTesting$*.class</include>, +                                <include>org/elasticsearch/bootstrap/BootstrapForTesting$*.class</include>, +++ b/core/src/main/java/org/elasticsearch/action/admin/indices/delete/TransportDeleteIndexAction.java, +        final String[] concreteIndices = indexNameExpressionResolver.concreteIndices(state, request);, +        deleteIndexService.deleteIndices(new MetaDataDeleteIndexService.Request(concreteIndices).timeout(request.timeout()).masterTimeout(request.masterNodeTimeout()), new MetaDataDeleteIndexService.Listener() {, +                listener.onResponse(new DeleteIndexResponse(response.acknowledged()));, +++ b/core/src/main/java/org/elasticsearch/action/admin/indices/validate/query/TransportValidateQueryAction.java, +                searchContext.parsedQuery(queryParserService.parseTopLevelQuery(request.source()));, +++ b/core/pom.xml, +                                <include>org/elasticsearch/bootstrap/BootstrapForTesting$*.class</include>, +                                <include>org/elasticsearch/bootstrap/BootstrapForTesting$*.class</include>, +++ b/core/src/main/java/org/elasticsearch/action/admin/indices/delete/TransportDeleteIndexAction.java, +        final String[] concreteIndices = indexNameExpressionResolver.concreteIndices(state, request);, +        deleteIndexService.deleteIndices(new MetaDataDeleteIndexService.Request(concreteIndices).timeout(request.timeout()).masterTimeout(request.masterNodeTimeout()), new MetaDataDeleteIndexService.Listener() {, +                listener.onResponse(new DeleteIndexResponse(response.acknowledged()));, +++ b/core/src/main/java/org/elasticsearch/action/admin/indices/validate/query/TransportValidateQueryAction.java, +                searchContext.parsedQuery(queryParserService.parseTopLevelQuery(request.source()));, +++ b/core/src/main/java/org/elasticsearch/action/explain/TransportExplainAction.java, +            context.parsedQuery(indexService.queryParserService().parseTopLevelQuery(request.source()));, +++ b/core/pom.xml, +                                <include>org/elasticsearch/bootstrap/BootstrapForTesting$*.class</include>, +                                <include>org/elasticsearch/bootstrap/BootstrapForTesting$*.class</include>, +++ b/core/src/main/java/org/elasticsearch/action/admin/indices/delete/TransportDeleteIndexAction.java, +        final String[] concreteIndices = indexNameExpressionResolver.concreteIndices(state, request);, +        deleteIndexService.deleteIndices(new MetaDataDeleteIndexService.Request(concreteIndices).timeout(request.timeout()).masterTimeout(request.masterNodeTimeout()), new MetaDataDeleteIndexService.Listener() {, +                listener.onResponse(new DeleteIndexResponse(response.acknowledged()));, +++ b/core/src/main/java/org/elasticsearch/action/admin/indices/validate/query/TransportValidateQueryAction.java, +                searchContext.parsedQuery(queryParserService.parseTopLevelQuery(request.source()));, +++ b/core/src/main/java/org/elasticsearch/action/explain/TransportExplainAction.java, +            context.parsedQuery(indexService.queryParserService().parseTopLevelQuery(request.source()));, +++ b/core/src/main/java/org/elasticsearch/bootstrap/ESPolicy.java, +    final Map<String,Policy> plugins;, +    public ESPolicy(PermissionCollection dynamic, Map<String,Policy> plugins) {, +        this.template = Security.readPolicy(getClass().getResource(POLICY_RESOURCE), JarHell.parseClassPath());, +        this.untrusted = Security.readPolicy(getClass().getResource(UNTRUSTED_RESOURCE), new URL[0]);, +            // check for an additional plugin permission: plugin policy is, +            // only consulted for its codesources., +            Policy plugin = plugins.get(location.getFile());, +            if (plugin != null && plugin.implies(domain, permission)) {, +++ b/core/pom.xml, +                                <include>org/elasticsearch/bootstrap/BootstrapForTesting$*.class</include>, +                                <include>org/elasticsearch/bootstrap/BootstrapForTesting$*.class</include>, +++ b/core/src/main/java/org/elasticsearch/action/admin/indices/delete/TransportDeleteIndexAction.java, +        final String[] concreteIndices = indexNameExpressionResolver.concreteIndices(state, request);, +        deleteIndexService.deleteIndices(new MetaDataDeleteIndexService.Request(concreteIndices).timeout(request.timeout()).masterTimeout(request.masterNodeTimeout()), new MetaDataDeleteIndexService.Listener() {, +                listener.onResponse(new DeleteIndexResponse(response.acknowledged()));, +++ b/core/src/main/java/org/elasticsearch/action/admin/indices/validate/query/TransportValidateQueryAction.java, +                searchContext.parsedQuery(queryParserService.parseTopLevelQuery(request.source()));, +++ b/core/src/main/java/org/elasticsearch/action/explain/TransportExplainAction.java, +            context.parsedQuery(indexService.queryParserService().parseTopLevelQuery(request.source()));, +++ b/core/src/main/java/org/elasticsearch/bootstrap/ESPolicy.java, +    final Map<String,Policy> plugins;, +    public ESPolicy(PermissionCollection dynamic, Map<String,Policy> plugins) {, +        this.template = Security.readPolicy(getClass().getResource(POLICY_RESOURCE), JarHell.parseClassPath());, +        this.untrusted = Security.readPolicy(getClass().getResource(UNTRUSTED_RESOURCE), new URL[0]);, +            // check for an additional plugin permission: plugin policy is, +            // only consulted for its codesources., +            Policy plugin = plugins.get(location.getFile());, +            if (plugin != null && plugin.implies(domain, permission)) {, +++ b/core/src/main/java/org/elasticsearch/bootstrap/Security.java, +import org.elasticsearch.common.io.PathUtils;, +import java.net.URISyntaxException;, +import java.util.ArrayList;, +import java.util.List;, +    static Map<String,Policy> getPluginPermissions(Environment environment) throws IOException, NoSuchAlgorithmException {, +        Map<String,Policy> map = new HashMap<>();, +                        // first get a list of URLs for the plugins' jars:, +                        List<URL> codebases = new ArrayList<>();, +                                codebases.add(jar.toUri().toURL());, +                        , +                        // parse the plugin's policy file into a set of permissions, +                        Policy policy = readPolicy(policyFile.toUri().toURL(), codebases.toArray(new URL[codebases.size()]));, +                        , +                        // consult this policy for each of the plugin's jars:, +                        for (URL url : codebases) {, +                            if (map.put(url.getFile(), policy) != null) {, +                                // just be paranoid ok?, +                                throw new IllegalStateException("per-plugin permissions already granted for jar file: " + url);, +                            }, +    /**, +     * Reads and returns the specified {@code policyFile}., +     * <p>, +     * Resources (e.g. jar files and directories) listed in {@code codebases} location, +     * will be provided to the policy file via a system property of the short name:, +     * e.g. <code>${codebase.joda-convert-1.2.jar}</code> would map to full URL., +     */, +    @SuppressForbidden(reason = "accesses fully qualified URLs to configure security"), +    static Policy readPolicy(URL policyFile, URL codebases[]) {, +        try {]