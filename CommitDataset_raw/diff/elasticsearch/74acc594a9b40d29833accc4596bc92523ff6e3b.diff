[+++ b/test/framework/src/main/java/org/elasticsearch/test/disruption/IntermittentLongGCDisruption.java, +            while (suspendThreads(nodeThreads)) ;, +++ b/test/framework/src/main/java/org/elasticsearch/test/disruption/IntermittentLongGCDisruption.java, +            while (suspendThreads(nodeThreads)) ;, +++ b/test/framework/src/main/java/org/elasticsearch/test/disruption/LongGCDisruption.java, +        // logging has shared JVM locks; we may suspend a thread and block other nodes from doing their thing, +        // security manager is shared across all nodes and it uses synchronized maps internally, +                final AtomicReference<Exception> suspendingError = new AtomicReference<>();, +                final Thread suspendingThread = new Thread(new AbstractRunnable() {, +                        suspendingError.set(e);, +                        // keep trying to suspend threads, until no new threads are discovered., +                        while (suspendThreads(suspendedThreads)) {, +                suspendingThread.setName(currentThreadName + "[LongGCDisruption][threadSuspender]");, +                suspendingThread.start();, +                    suspendingThread.join(getSuspendingTimeoutInMillis());, +                    suspendingThread.interrupt(); // best effort to signal suspending, +                if (suspendingError.get() != null) {, +                    throw new RuntimeException("unknown error while suspending threads", suspendingError.get());, +                if (suspendingThread.isAlive()) {, +                    logger.warn("failed to suspend node [{}]'s threads within [{}] millis. Suspending thread stack trace:\n {}", +                        , disruptedNode, getSuspendingTimeoutInMillis(), stackTrace(suspendingThread.getStackTrace()));, +                    suspendingThread.interrupt(); // best effort;, +                         * We need to join on the suspending thread in case it has suspended a thread that is in a critical section and, +                         * needs to be resumed., +                        suspendingThread.join();, +                    throw new RuntimeException("suspending node threads took too long");, +                blockDetectionThread.join(getSuspendingTimeoutInMillis());, +    @SuppressWarnings("deprecation") // suspends/resumes threads intentionally, +    @SuppressForbidden(reason = "suspends/resumes threads intentionally"), +    protected boolean suspendThreads(Set<Thread> nodeThreads) {, +                    logger.trace("suspending thread [{}]", threadName);, +                         * At the bottom of this try-block we will know whether or not it is safe to suspend the thread; we start by, +                             * interrupted exception and never resume the suspended thread that is in a critical section. Also, logging, +                             * before resuming makes for confusing log messages if we never hit the resume., +    protected long getSuspendingTimeoutInMillis() {, +    @SuppressWarnings("deprecation") // suspends/resumes threads intentionally, +    @SuppressForbidden(reason = "suspends/resumes threads intentionally"), +++ b/test/framework/src/main/java/org/elasticsearch/test/disruption/IntermittentLongGCDisruption.java, +            while (suspendThreads(nodeThreads)) ;, +++ b/test/framework/src/main/java/org/elasticsearch/test/disruption/LongGCDisruption.java, +        // logging has shared JVM locks; we may suspend a thread and block other nodes from doing their thing, +        // security manager is shared across all nodes and it uses synchronized maps internally, +                final AtomicReference<Exception> suspendingError = new AtomicReference<>();, +                final Thread suspendingThread = new Thread(new AbstractRunnable() {, +                        suspendingError.set(e);, +                        // keep trying to suspend threads, until no new threads are discovered., +                        while (suspendThreads(suspendedThreads)) {, +                suspendingThread.setName(currentThreadName + "[LongGCDisruption][threadSuspender]");, +                suspendingThread.start();, +                    suspendingThread.join(getSuspendingTimeoutInMillis());, +                    suspendingThread.interrupt(); // best effort to signal suspending, +                if (suspendingError.get() != null) {, +                    throw new RuntimeException("unknown error while suspending threads", suspendingError.get());, +                if (suspendingThread.isAlive()) {, +                    logger.warn("failed to suspend node [{}]'s threads within [{}] millis. Suspending thread stack trace:\n {}", +                        , disruptedNode, getSuspendingTimeoutInMillis(), stackTrace(suspendingThread.getStackTrace()));, +                    suspendingThread.interrupt(); // best effort;, +                         * We need to join on the suspending thread in case it has suspended a thread that is in a critical section and, +                         * needs to be resumed., +                        suspendingThread.join();, +                    throw new RuntimeException("suspending node threads took too long");, +                blockDetectionThread.join(getSuspendingTimeoutInMillis());, +    @SuppressWarnings("deprecation") // suspends/resumes threads intentionally, +    @SuppressForbidden(reason = "suspends/resumes threads intentionally"), +    protected boolean suspendThreads(Set<Thread> nodeThreads) {, +                    logger.trace("suspending thread [{}]", threadName);, +                         * At the bottom of this try-block we will know whether or not it is safe to suspend the thread; we start by, +                             * interrupted exception and never resume the suspended thread that is in a critical section. Also, logging, +                             * before resuming makes for confusing log messages if we never hit the resume., +    protected long getSuspendingTimeoutInMillis() {, +    @SuppressWarnings("deprecation") // suspends/resumes threads intentionally, +    @SuppressForbidden(reason = "suspends/resumes threads intentionally"), +++ b/test/framework/src/test/java/org/elasticsearch/test/disruption/LongGCDisruptionTests.java, +            protected long getSuspendingTimeoutInMillis() {, +            assertThat(e.getMessage(), containsString("suspending node threads took too long"));]