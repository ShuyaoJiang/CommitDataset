[+++ b/modules/elasticsearch/src/main/java/org/elasticsearch/gateway/local/LocalGateway.java, +    private volatile boolean initialized = false;, +, +        lazyInitialize();, +        lazyInitialize();, +    /**, +     * We do here lazy initialization on not only on start(), since we might be called before start by another node (really will, +     * happen in term of timing in testing, but still), and we want to return the cluster state when we can., +     *, +     * It is synchronized since we want to wait for it to be loaded if called concurrently. There should really be a nicer, +     * solution here, but for now, its good enough., +     */, +    private synchronized void lazyInitialize() {, +        if (initialized) {, +            return;, +        }, +        initialized = true;, +, +        // if this is not a possible master node or data node, bail, we won't save anything here..., +        if (!clusterService.state().nodes().localNode().masterNode() || !clusterService.state().nodes().localNode().dataNode()) {, +            location = null;, +        } else {, +            // create the location where the state will be stored, +            this.location = new File(nodeEnv.nodeLocation(), "_state");, +            this.location.mkdirs();, +            try {, +                long version = findLatestStateVersion();, +                if (version != -1) {, +                    this.currentState = readState(Streams.copyToByteArray(new FileInputStream(new File(location, "state-" + version))));, +                }, +            } catch (Exception e) {, +                logger.warn("failed to read local state", e);, +            }, +        }, +    }, +, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/gateway/local/LocalGateway.java, +    private volatile boolean initialized = false;, +, +        lazyInitialize();, +        lazyInitialize();, +    /**, +     * We do here lazy initialization on not only on start(), since we might be called before start by another node (really will, +     * happen in term of timing in testing, but still), and we want to return the cluster state when we can., +     *, +     * It is synchronized since we want to wait for it to be loaded if called concurrently. There should really be a nicer, +     * solution here, but for now, its good enough., +     */, +    private synchronized void lazyInitialize() {, +        if (initialized) {, +            return;, +        }, +        initialized = true;, +, +        // if this is not a possible master node or data node, bail, we won't save anything here..., +        if (!clusterService.state().nodes().localNode().masterNode() || !clusterService.state().nodes().localNode().dataNode()) {, +            location = null;, +        } else {, +            // create the location where the state will be stored, +            this.location = new File(nodeEnv.nodeLocation(), "_state");, +            this.location.mkdirs();, +            try {, +                long version = findLatestStateVersion();, +                if (version != -1) {, +                    this.currentState = readState(Streams.copyToByteArray(new FileInputStream(new File(location, "state-" + version))));, +                }, +            } catch (Exception e) {, +                logger.warn("failed to read local state", e);, +            }, +        }, +    }, +, +++ b/modules/test/integration/src/test/java/org/elasticsearch/test/integration/gateway/local/SimpleRecoveryLocalGatewayTests.java, +    @AfterMethod public void cleanAndCloseNodes() throws Exception {, +        for (int i = 0; i < 10; i++) {, +            if (node("node" + i) != null) {, +                node("node" + i).stop();, +                ((InternalNode) node("node" + i)).injector().getInstance(Gateway.class).reset();, +            }, +        }, +        cleanAndCloseNodes();, +, +    @Test public void testTwoNodeFirstNodeCleared() throws Exception {, +        // clean two nodes, +        buildNode("node1", settingsBuilder().put("gateway.type", "local").build());, +        buildNode("node2", settingsBuilder().put("gateway.type", "local").build());, +        cleanAndCloseNodes();, +, +        Node node1 = startNode("node1", settingsBuilder().put("gateway.type", "local").put("index.number_of_shards", 1).build());, +        Node node2 = startNode("node2", settingsBuilder().put("gateway.type", "local").put("index.number_of_shards", 1).build());, +, +        node1.client().prepareIndex("test", "type1", "1").setSource(jsonBuilder().startObject().field("field", "value1").endObject()).execute().actionGet();, +        node1.client().admin().indices().prepareFlush().execute().actionGet();, +        node1.client().prepareIndex("test", "type1", "2").setSource(jsonBuilder().startObject().field("field", "value2").endObject()).execute().actionGet();, +        node1.client().admin().indices().prepareRefresh().execute().actionGet();, +, +        assertThat(node1.client().prepareCount().setQuery(matchAllQuery()).execute().actionGet().count(), equalTo(2l));, +, +        logger.info("--> closing nodes");, +        closeNode("node1");]