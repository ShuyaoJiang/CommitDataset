[+++ b/server/src/main/java/org/elasticsearch/index/engine/Engine.java, +import org.apache.lucene.util.IOUtils;, +            ReferenceManager<IndexSearcher> referenceManager = getReferenceManager(scope);, +            Searcher engineSearcher = new Searcher(source, referenceManager.acquire(),, +                s -> {, +                  try {, +                      referenceManager.release(s);, +                  } finally {, +                      store.decRef();, +                  }, +              }, logger);, +        private final AtomicBoolean released = new AtomicBoolean(false);, +        private final Logger logger;, +        private final IOUtils.IOConsumer<IndexSearcher> onClose;, +        public Searcher(String source, IndexSearcher searcher, Logger logger) {, +            this(source, searcher, s -> s.getIndexReader().close(), logger);, +        }, +, +        public Searcher(String source, IndexSearcher searcher, IOUtils.IOConsumer<IndexSearcher> onClose, Logger logger) {, +            this.onClose = onClose;, +            this.logger = logger;, +        public final String source() {, +        public final IndexReader reader() {, +        public final DirectoryReader getDirectoryReader() {, +        public final IndexSearcher searcher() {, +            if (released.compareAndSet(false, true) == false) {, +                /* In general, searchers should never be released twice or this would break reference counting. There is one rare case, +                 * when it might happen though: when the request and the Reaper thread would both try to release it in a very short amount, +                 * of time, this is why we only log a warning instead of throwing an exception., +                 */, +                logger.warn("Searcher was released twice", new IllegalStateException("Double release"));, +                return;, +            }, +            try {, +                onClose.accept(searcher());, +            } catch (IOException e) {, +                throw new IllegalStateException("Cannot close", e);, +            } catch (AlreadyClosedException e) {, +                // This means there's a bug somewhere: don't suppress it, +                throw new AssertionError(e);, +            }, +        }, +, +        public final Logger getLogger() {, +            return logger;, +++ b/server/src/main/java/org/elasticsearch/index/engine/Engine.java, +import org.apache.lucene.util.IOUtils;, +            ReferenceManager<IndexSearcher> referenceManager = getReferenceManager(scope);, +            Searcher engineSearcher = new Searcher(source, referenceManager.acquire(),, +                s -> {, +                  try {, +                      referenceManager.release(s);, +                  } finally {, +                      store.decRef();, +                  }, +              }, logger);, +        private final AtomicBoolean released = new AtomicBoolean(false);, +        private final Logger logger;, +        private final IOUtils.IOConsumer<IndexSearcher> onClose;, +        public Searcher(String source, IndexSearcher searcher, Logger logger) {, +            this(source, searcher, s -> s.getIndexReader().close(), logger);, +        }, +, +        public Searcher(String source, IndexSearcher searcher, IOUtils.IOConsumer<IndexSearcher> onClose, Logger logger) {, +            this.onClose = onClose;, +            this.logger = logger;, +        public final String source() {, +        public final IndexReader reader() {, +        public final DirectoryReader getDirectoryReader() {, +        public final IndexSearcher searcher() {, +            if (released.compareAndSet(false, true) == false) {, +                /* In general, searchers should never be released twice or this would break reference counting. There is one rare case, +                 * when it might happen though: when the request and the Reaper thread would both try to release it in a very short amount, +                 * of time, this is why we only log a warning instead of throwing an exception., +                 */, +                logger.warn("Searcher was released twice", new IllegalStateException("Double release"));, +                return;, +            }, +            try {, +                onClose.accept(searcher());, +            } catch (IOException e) {, +                throw new IllegalStateException("Cannot close", e);, +            } catch (AlreadyClosedException e) {, +                // This means there's a bug somewhere: don't suppress it, +                throw new AssertionError(e);, +            }, +        }, +, +        public final Logger getLogger() {, +            return logger;, +++ /dev/null, +++ b/server/src/main/java/org/elasticsearch/index/engine/Engine.java, +import org.apache.lucene.util.IOUtils;, +            ReferenceManager<IndexSearcher> referenceManager = getReferenceManager(scope);, +            Searcher engineSearcher = new Searcher(source, referenceManager.acquire(),, +                s -> {, +                  try {, +                      referenceManager.release(s);, +                  } finally {, +                      store.decRef();]