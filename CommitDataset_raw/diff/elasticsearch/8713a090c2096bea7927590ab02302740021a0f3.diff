[+++ b/src/main/java/org/elasticsearch/indices/recovery/RecoveryState.java, +        public float percentFilesRecovered() {, +            return percentFilesRecovered(recoveredFileCount.get());, +        }, +, +        public float percentBytesRecovered() {, +            return percentBytesRecovered(recoveredByteCount.get());, +        }, +, +++ b/src/main/java/org/elasticsearch/indices/recovery/RecoveryState.java, +        public float percentFilesRecovered() {, +            return percentFilesRecovered(recoveredFileCount.get());, +        }, +, +        public float percentBytesRecovered() {, +            return percentBytesRecovered(recoveredByteCount.get());, +        }, +, +++ b/src/main/java/org/elasticsearch/indices/recovery/RecoveryTarget.java, +                        onGoingRecovery.recoveryState.getIndex().addRecoveredByteCount(content.length());, +++ b/src/main/java/org/elasticsearch/indices/recovery/RecoveryState.java, +        public float percentFilesRecovered() {, +            return percentFilesRecovered(recoveredFileCount.get());, +        }, +, +        public float percentBytesRecovered() {, +            return percentBytesRecovered(recoveredByteCount.get());, +        }, +, +++ b/src/main/java/org/elasticsearch/indices/recovery/RecoveryTarget.java, +                        onGoingRecovery.recoveryState.getIndex().addRecoveredByteCount(content.length());, +++ b/src/test/java/org/elasticsearch/indices/recovery/IndexRecoveryTests.java, +import org.elasticsearch.action.index.IndexRequestBuilder;, +import java.util.concurrent.ExecutionException;, +import static org.hamcrest.Matchers.*;, +    private static final String INDEX_TYPE = "test-type-1";, +    private static final int MIN_DOC_COUNT = 500;, +    private static final int MAX_DOC_COUNT = 1000;, +, +        validateIndexRecoveryState(state.getIndex());, +        validateIndexRecoveryState(nodeAShardResponse.recoveryState().getIndex());, +        validateIndexRecoveryState(nodeBShardResponse.recoveryState().getIndex());, +        validateIndexRecoveryState(state.getIndex());, +                validateIndexRecoveryState(shardResponse.recoveryState().getIndex());, +    private IndicesStatsResponse createAndPopulateIndex(String name, int nodeCount, int shardCount, int replicaCount), +            throws ExecutionException, InterruptedException {, +, +        final int numDocs = between(MIN_DOC_COUNT, MAX_DOC_COUNT);, +        final IndexRequestBuilder[] docs = new IndexRequestBuilder[numDocs];, +, +        for (int i = 0; i < numDocs; i++) {, +            docs[i] = client().prepareIndex(INDEX_NAME, INDEX_TYPE)., +                    setSource("foo-int-" + i, randomInt(),, +                              "foo-string-" + i, randomAsciiOfLength(32),, +                              "foo-float-" + i, randomFloat());, +, +        indexRandom(true, docs);, +        flush();, +        assertThat(client().prepareCount(INDEX_NAME).get().getCount(), equalTo((long) numDocs));, +, +    private void validateIndexRecoveryState(RecoveryState.Index indexState) {, +        assertThat(indexState.time(), greaterThanOrEqualTo(0L));, +        assertThat(indexState.percentFilesRecovered(), greaterThanOrEqualTo(0.0f));, +        assertThat(indexState.percentFilesRecovered(), lessThanOrEqualTo(100.0f));, +        assertThat(indexState.percentBytesRecovered(), greaterThanOrEqualTo(0.0f));, +        assertThat(indexState.percentBytesRecovered(), lessThanOrEqualTo(100.0f));, +    }]