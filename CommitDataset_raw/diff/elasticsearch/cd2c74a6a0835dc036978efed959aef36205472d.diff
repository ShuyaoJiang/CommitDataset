[+++ b/src/main/java/org/elasticsearch/alerts/AlertsStore.java, +            if (AlertsStore.this.state.compareAndSet(State.STOPPED, State.LOADING)) {, +                threadPool.executor(ThreadPool.Names.GENERIC).execute(new Runnable() {, +                    @Override, +                    public void run() {, +                        if (AlertsStore.this.state.compareAndSet(State.LOADING, State.STARTED)) {, +                });, +            }, +        }, +++ b/src/main/java/org/elasticsearch/alerts/AlertsStore.java, +            if (AlertsStore.this.state.compareAndSet(State.STOPPED, State.LOADING)) {, +                threadPool.executor(ThreadPool.Names.GENERIC).execute(new Runnable() {, +                    @Override, +                    public void run() {, +                        if (AlertsStore.this.state.compareAndSet(State.LOADING, State.STARTED)) {, +                });, +            }, +        }, +++ b/src/main/java/org/elasticsearch/alerts/TemplateHelper.java, +import org.elasticsearch.action.ActionFuture;, +import org.elasticsearch.action.admin.indices.template.put.PutIndexTemplateRequest;, +import org.elasticsearch.action.admin.indices.template.put.PutIndexTemplateResponse;, +    public TemplateHelper(Settings settings, TransportPutIndexTemplateAction transportPutIndexTemplateAction) {, +     * If that isn't the case then the template from the classpath will be uploaded to the cluster., +     *, +     * In the the template doesn't exists this method blocks until the template has been created., +            PutIndexTemplateRequest request = new PutIndexTemplateRequest(templateName).source(template);, +            // We're already running on the master and TransportPutIndexTemplateAction#executor() is SAME, so it is ok to wait:, +            ActionFuture<PutIndexTemplateResponse> future = transportPutIndexTemplateAction.execute(request);, +            PutIndexTemplateResponse response = future.actionGet();, +++ b/src/main/java/org/elasticsearch/alerts/AlertsStore.java, +            if (AlertsStore.this.state.compareAndSet(State.STOPPED, State.LOADING)) {, +                threadPool.executor(ThreadPool.Names.GENERIC).execute(new Runnable() {, +                    @Override, +                    public void run() {, +                        if (AlertsStore.this.state.compareAndSet(State.LOADING, State.STARTED)) {, +                });, +            }, +        }, +++ b/src/main/java/org/elasticsearch/alerts/TemplateHelper.java, +import org.elasticsearch.action.ActionFuture;, +import org.elasticsearch.action.admin.indices.template.put.PutIndexTemplateRequest;, +import org.elasticsearch.action.admin.indices.template.put.PutIndexTemplateResponse;, +    public TemplateHelper(Settings settings, TransportPutIndexTemplateAction transportPutIndexTemplateAction) {, +     * If that isn't the case then the template from the classpath will be uploaded to the cluster., +     *, +     * In the the template doesn't exists this method blocks until the template has been created., +            PutIndexTemplateRequest request = new PutIndexTemplateRequest(templateName).source(template);, +            // We're already running on the master and TransportPutIndexTemplateAction#executor() is SAME, so it is ok to wait:, +            ActionFuture<PutIndexTemplateResponse> future = transportPutIndexTemplateAction.execute(request);, +            PutIndexTemplateResponse response = future.actionGet();, +++ b/src/main/java/org/elasticsearch/alerts/actions/AlertActionManager.java, +            if (this.state.compareAndSet(State.STOPPED, State.LOADING)) {, +                threadPool.executor(ThreadPool.Names.GENERIC).execute(new Runnable() {, +                    @Override, +                    public void run() {, +                        if (AlertActionManager.this.state.compareAndSet(State.LOADING, State.STARTED)) {, +                });, +            }, +        }]