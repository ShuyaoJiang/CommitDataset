[+++ b/core/src/main/java/org/elasticsearch/common/lucene/search/Queries.java, +import org.elasticsearch.ElasticsearchException;, +, +    public static Query newUnmappedFieldQuery(String field) {, +        return Queries.newMatchNoDocsQuery("unmapped field [" + (field != null ? field : "null") + "]");, +    }, +, +    public static Query newLenientFieldQuery(String field, RuntimeException e) {, +        String message = ElasticsearchException.getExceptionName(e) + ":[" + e.getMessage() + "]";, +        return Queries.newMatchNoDocsQuery("failed [" + field + "] query, caused by " + message);, +    }, +, +++ b/core/src/main/java/org/elasticsearch/common/lucene/search/Queries.java, +import org.elasticsearch.ElasticsearchException;, +, +    public static Query newUnmappedFieldQuery(String field) {, +        return Queries.newMatchNoDocsQuery("unmapped field [" + (field != null ? field : "null") + "]");, +    }, +, +    public static Query newLenientFieldQuery(String field, RuntimeException e) {, +        String message = ElasticsearchException.getExceptionName(e) + ":[" + e.getMessage() + "]";, +        return Queries.newMatchNoDocsQuery("failed [" + field + "] query, caused by " + message);, +    }, +, +++ b/core/src/main/java/org/elasticsearch/index/query/MultiMatchQueryBuilder.java, +import org.elasticsearch.index.search.QueryStringQueryParser;, +        Map<String, Float> newFieldsBoosts = QueryStringQueryParser.resolveMappingFields(context, fieldsBoosts);, +++ b/core/src/main/java/org/elasticsearch/common/lucene/search/Queries.java, +import org.elasticsearch.ElasticsearchException;, +, +    public static Query newUnmappedFieldQuery(String field) {, +        return Queries.newMatchNoDocsQuery("unmapped field [" + (field != null ? field : "null") + "]");, +    }, +, +    public static Query newLenientFieldQuery(String field, RuntimeException e) {, +        String message = ElasticsearchException.getExceptionName(e) + ":[" + e.getMessage() + "]";, +        return Queries.newMatchNoDocsQuery("failed [" + field + "] query, caused by " + message);, +    }, +, +++ b/core/src/main/java/org/elasticsearch/index/query/MultiMatchQueryBuilder.java, +import org.elasticsearch.index.search.QueryStringQueryParser;, +        Map<String, Float> newFieldsBoosts = QueryStringQueryParser.resolveMappingFields(context, fieldsBoosts);, +++ b/core/src/main/java/org/elasticsearch/index/query/QueryStringQueryBuilder.java, +    private static final ParseField ALL_FIELDS_FIELD = new ParseField("all_fields"), +            .withAllDeprecated("Set [default_field] to `*` instead");, +                Boolean useAllField = in.readOptionalBoolean();, +                if (useAllField != null && useAllField) {, +                    defaultField = "*";, +            }, +                Boolean useAllFields = defaultField == null ? null : Regex.isMatchAllPattern(defaultField);, +                out.writeOptionalBoolean(useAllFields);, +     * This setting is deprecated, set {@link #defaultField(String)} to "*" instead., +    @Deprecated, +        if (useAllFields) {, +            this.defaultField = "*";, +        }, +    @Deprecated, +        return defaultField == null ? null : Regex.isMatchAllPattern(defaultField);, +                    defaultField = "*";, +                Objects.equals(maxDeterminizedStates, other.maxDeterminizedStates);, +                timeZone == null ? 0 : timeZone.getID(), escape, maxDeterminizedStates);, +        if (fieldsAndWeights.size() > 0 && this.defaultField != null) {, +            throw addValidationError("cannot use [fields] parameter in conjunction with [default_field]", null);, +            if (Regex.isMatchAllPattern(defaultField)) {, +                queryParser = new QueryStringQueryParser(context, lenient == null ? true : lenient);, +                queryParser = new QueryStringQueryParser(context, defaultField, isLenient);, +        } else if (fieldsAndWeights.size() > 0) {, +            final Map<String, Float> resolvedFields = QueryStringQueryParser.resolveMappingFields(context, fieldsAndWeights);, +            // Expand to all fields if:, +            // - The index default search field is "*", +            // - The index default search field is "_all" and _all is disabled, +            // TODO the index default search field should be "*" for new indices., +            if (Regex.isMatchAllPattern(context.defaultField()) ||, +                queryParser = new QueryStringQueryParser(context, lenient == null ? true : lenient);, +++ b/core/src/main/java/org/elasticsearch/common/lucene/search/Queries.java, +import org.elasticsearch.ElasticsearchException;, +, +    public static Query newUnmappedFieldQuery(String field) {, +        return Queries.newMatchNoDocsQuery("unmapped field [" + (field != null ? field : "null") + "]");, +    }, +, +    public static Query newLenientFieldQuery(String field, RuntimeException e) {, +        String message = ElasticsearchException.getExceptionName(e) + ":[" + e.getMessage() + "]";, +        return Queries.newMatchNoDocsQuery("failed [" + field + "] query, caused by " + message);, +    }, +, +++ b/core/src/main/java/org/elasticsearch/index/query/MultiMatchQueryBuilder.java, +import org.elasticsearch.index.search.QueryStringQueryParser;, +        Map<String, Float> newFieldsBoosts = QueryStringQueryParser.resolveMappingFields(context, fieldsBoosts);, +++ b/core/src/main/java/org/elasticsearch/index/query/QueryStringQueryBuilder.java, +    private static final ParseField ALL_FIELDS_FIELD = new ParseField("all_fields"), +            .withAllDeprecated("Set [default_field] to `*` instead");, +                Boolean useAllField = in.readOptionalBoolean();, +                if (useAllField != null && useAllField) {, +                    defaultField = "*";, +            }, +                Boolean useAllFields = defaultField == null ? null : Regex.isMatchAllPattern(defaultField);, +                out.writeOptionalBoolean(useAllFields);, +     * This setting is deprecated, set {@link #defaultField(String)} to "*" instead., +    @Deprecated]