[+++ b/docs/reference/settings/notification-settings.asciidoc, +`xpack.http.whitelist`::, +A list of URLs, that the internal HTTP client is allowed to connect to. This, +client is used in the HTTP input, the webhook, the slack, pagerduty, hipchat, +and jira actions. This setting can be updated dynamically.  It defaults to `*`, +allowing everything. Note: If you configure this setting and you are using one, +of the slack/pagerduty/hipchat actions, you have to ensure that the, +corresponding endpoints are whitelisted as well., +, +++ b/docs/reference/settings/notification-settings.asciidoc, +`xpack.http.whitelist`::, +A list of URLs, that the internal HTTP client is allowed to connect to. This, +client is used in the HTTP input, the webhook, the slack, pagerduty, hipchat, +and jira actions. This setting can be updated dynamically.  It defaults to `*`, +allowing everything. Note: If you configure this setting and you are using one, +of the slack/pagerduty/hipchat actions, you have to ensure that the, +corresponding endpoints are whitelisted as well., +, +++ b/x-pack/plugin/watcher/src/main/java/org/elasticsearch/xpack/watcher/Watcher.java, +        httpClient = new HttpClient(settings, getSslService(), cryptoService, clusterService);, +++ b/docs/reference/settings/notification-settings.asciidoc, +`xpack.http.whitelist`::, +A list of URLs, that the internal HTTP client is allowed to connect to. This, +client is used in the HTTP input, the webhook, the slack, pagerduty, hipchat, +and jira actions. This setting can be updated dynamically.  It defaults to `*`, +allowing everything. Note: If you configure this setting and you are using one, +of the slack/pagerduty/hipchat actions, you have to ensure that the, +corresponding endpoints are whitelisted as well., +, +++ b/x-pack/plugin/watcher/src/main/java/org/elasticsearch/xpack/watcher/Watcher.java, +        httpClient = new HttpClient(settings, getSslService(), cryptoService, clusterService);, +++ b/x-pack/plugin/watcher/src/main/java/org/elasticsearch/xpack/watcher/common/http/HttpClient.java, +import org.apache.http.HttpRequestInterceptor;, +import org.apache.http.ProtocolException;, +import org.apache.http.client.methods.HttpRequestWrapper;, +import org.apache.http.impl.client.DefaultRedirectStrategy;, +import org.apache.http.protocol.HttpContext;, +import org.apache.lucene.util.automaton.Automaton;, +import org.apache.lucene.util.automaton.CharacterRunAutomaton;, +import org.apache.lucene.util.automaton.MinimizationOperations;, +import org.apache.lucene.util.automaton.Operations;, +import org.elasticsearch.ElasticsearchException;, +import org.elasticsearch.cluster.service.ClusterService;, +import org.elasticsearch.common.regex.Regex;, +import java.util.concurrent.atomic.AtomicReference;, +    private final AtomicReference<CharacterRunAutomaton> whitelistAutomaton = new AtomicReference<>();, +    private final SSLService sslService;, +    public HttpClient(Settings settings, SSLService sslService, CryptoService cryptoService, ClusterService clusterService) {, +        this.sslService = sslService;, +        setWhitelistAutomaton(HttpSettings.HOSTS_WHITELIST.get(settings));, +        clusterService.getClusterSettings().addSettingsUpdateConsumer(HttpSettings.HOSTS_WHITELIST, this::setWhitelistAutomaton);, +        this.client = createHttpClient();, +    }, +, +    private CloseableHttpClient createHttpClient() {, +        clientBuilder.setRedirectStrategy(new DefaultRedirectStrategy() {, +            @Override, +            public boolean isRedirected(org.apache.http.HttpRequest request, org.apache.http.HttpResponse response,, +                                        HttpContext context) throws ProtocolException {, +                boolean isRedirected = super.isRedirected(request, response, context);, +                if (isRedirected) {, +                    String host = response.getHeaders("Location")[0].getValue();, +                    if (isWhitelisted(host) == false) {, +                        throw new ElasticsearchException("host [" + host + "] is not whitelisted in setting [" +, +                            HttpSettings.HOSTS_WHITELIST.getKey() + "], will not redirect");, +                    }, +                }, +                return isRedirected;, +            }, +        });, +, +        clientBuilder.addInterceptorFirst((HttpRequestInterceptor) (request, context) -> {, +            if (request instanceof HttpRequestWrapper == false) {, +                throw new ElasticsearchException("unable to check request [{}/{}] for white listing", request,, +                    request.getClass().getName());, +            }, +, +            HttpRequestWrapper wrapper = ((HttpRequestWrapper) request);, +            final String host;, +            if (wrapper.getTarget() != null) {, +                host = wrapper.getTarget().toURI();, +            } else {, +                host = wrapper.getOriginal().getRequestLine().getUri();, +            }, +, +            if (isWhitelisted(host) == false) {, +                throw new ElasticsearchException("host [" + host + "] is not whitelisted in setting [" +, +                    HttpSettings.HOSTS_WHITELIST.getKey() + "], will not connect");, +            }, +        });, +, +        return clientBuilder.build();, +    }, +, +    private void setWhitelistAutomaton(List<String> whiteListedHosts) {, +        whitelistAutomaton.set(createAutomaton(whiteListedHosts));, +, +    private boolean isWhitelisted(String host) {, +        return whitelistAutomaton.get().run(host);, +    }]