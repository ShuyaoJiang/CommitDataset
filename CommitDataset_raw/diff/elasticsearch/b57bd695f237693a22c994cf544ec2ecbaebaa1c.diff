[+++ b/server/src/main/java/org/elasticsearch/persistent/PersistentTasksClusterService.java, +import org.elasticsearch.tasks.Task;, +     * @param taskId     the task's id, +     * @param taskName   the task's name, +     * @param taskParams the task's parameters, +    public <Params extends PersistentTaskParams> void createPersistentTask(String taskId, String taskName, @Nullable Params taskParams,, +            public ClusterState execute(ClusterState currentState) {, +, +                PersistentTasksExecutor<Params> taskExecutor = registry.getPersistentTaskExecutorSafe(taskName);, +                taskExecutor.validate(taskParams, currentState);, +, +                Assignment assignment = createAssignment(taskName, taskParams, currentState);, +                return update(currentState, builder.addTask(taskId, taskName, taskParams, assignment));, +            public ClusterState execute(ClusterState currentState) {, +            public ClusterState execute(ClusterState currentState) {, +    /**, +     * Creates a new {@link Assignment} for the given persistent task., +     *, +     * @param taskName the task's name, +     * @param taskParams the task's parameters, +     * @param currentState the current {@link ClusterState}, +     * @return a new {@link Assignment}, +     */, +    private <Params extends PersistentTaskParams> Assignment createAssignment(final String taskName,, +                                                                              final @Nullable Params taskParams,, +                                                                              final ClusterState currentState) {, +        return persistentTasksExecutor.getAssignment(taskParams, currentState);, +            if (shouldReassignPersistentTasks(event)) {, +                clusterService.submitStateUpdateTask("reassign persistent tasks", new ClusterStateUpdateTask() {, +                    @Override, +                    public ClusterState execute(ClusterState currentState) {, +                        return reassignTasks(currentState);, +                    }, +, +                    @Override, +                    public void onFailure(String source, Exception e) {, +                        logger.warn("failed to reassign persistent tasks", e);, +                    }, +                });, +    /**, +     * Returns true if the cluster state change(s) require to reassign some persistent tasks. It can happen in the following, +     * situations: a node left or is added, the routing table changed, the master node changed or the persistent tasks changed., +     */, +    boolean shouldReassignPersistentTasks(final ClusterChangedEvent event) {, +        final PersistentTasksCustomMetaData tasks = event.state().getMetaData().custom(PersistentTasksCustomMetaData.TYPE);, +        if (tasks == null) {, +            return false;, +        boolean masterChanged = event.previousState().nodes().isLocalNodeElectedMaster() == false;, +        if (persistentTasksChanged(event) || event.nodesChanged() || event.routingTableChanged() || masterChanged) {, +            for (PersistentTask<?> task : tasks.tasks()) {, +                if (needsReassignment(task.getAssignment(), event.state().nodes())) {, +                    Assignment assignment = createAssignment(task.getTaskName(), task.getParams(), event.state());, +                    if (Objects.equals(assignment, task.getAssignment()) == false) {, +                        return true;, +            }, +     * Evaluates the cluster state and tries to assign tasks to nodes., +     *, +     * @param currentState the cluster state to analyze, +     * @return an updated version of the cluster state, +    ClusterState reassignTasks(final ClusterState currentState) {, +, +        final PersistentTasksCustomMetaData tasks = currentState.getMetaData().custom(PersistentTasksCustomMetaData.TYPE);, +            final DiscoveryNodes nodes = currentState.nodes();, +, +                if (needsReassignment(task.getAssignment(), nodes)) {, +                    Assignment assignment = createAssignment(task.getTaskName(), task.getParams(), clusterState);, +    /** Returns true if the persistent tasks are not equal between the previous and the current cluster state **/, +    static boolean persistentTasksChanged(final ClusterChangedEvent event) {, +        String type = PersistentTasksCustomMetaData.TYPE;, +        return Objects.equals(event.state().metaData().custom(type), event.previousState().metaData().custom(type)) == false;, +    }, +, +    /** Returns true if the task is not assigned or is assigned to a non-existing node */, +    static boolean needsReassignment(final Assignment assignment, final DiscoveryNodes nodes) {, +        return (assignment.isAssigned() == false || nodes.nodeExists(assignment.getExecutorNode()) == false);, +    }, +, +++ b/server/src/main/java/org/elasticsearch/persistent/PersistentTasksClusterService.java, +import org.elasticsearch.tasks.Task;, +     * @param taskId     the task's id, +     * @param taskName   the task's name, +     * @param taskParams the task's parameters, +    public <Params extends PersistentTaskParams> void createPersistentTask(String taskId, String taskName, @Nullable Params taskParams,, +            public ClusterState execute(ClusterState currentState) {, +, +                PersistentTasksExecutor<Params> taskExecutor = registry.getPersistentTaskExecutorSafe(taskName);, +                taskExecutor.validate(taskParams, currentState);, +, +                Assignment assignment = createAssignment(taskName, taskParams, currentState);, +                return update(currentState, builder.addTask(taskId, taskName, taskParams, assignment));, +            public ClusterState execute(ClusterState currentState) {, +            public ClusterState execute(ClusterState currentState) {, +    /**, +     * Creates a new {@link Assignment} for the given persistent task., +     *, +     * @param taskName the task's name, +     * @param taskParams the task's parameters, +     * @param currentState the current {@link ClusterState}, +     * @return a new {@link Assignment}, +     */]