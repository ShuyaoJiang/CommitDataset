[+++ b/src/main/java/org/elasticsearch/indices/recovery/RecoverySettings.java, +    public static final String INDICES_RECOVERY_CONCURRENT_SMALL_FILE_STREAMS = "indices.recovery.concurrent_small_file_streams";, +    public static final long SMALL_FILE_CUTOFF_BYTES = ByteSizeValue.parseBytesSizeValue("5mb").bytes();, +, +    private volatile int concurrentSmallFileStreams;, +    private final ThreadPoolExecutor concurrentSmallFileStreamPool;, +        this.concurrentSmallFileStreams = componentSettings.getAsInt("concurrent_small_file_streams", settings.getAsInt("index.shard.recovery.concurrent_small_file_streams", 2));, +        this.concurrentSmallFileStreamPool = EsExecutors.newScaling(0, concurrentSmallFileStreams, 60, TimeUnit.SECONDS, EsExecutors.daemonThreadFactory(settings, "[small_file_recovery_stream]"));, +    public ThreadPoolExecutor concurrentSmallFileStreamPool() {, +        return concurrentSmallFileStreamPool;, +    }, +, +, +            int concurrentSmallFileStreams = settings.getAsInt(INDICES_RECOVERY_CONCURRENT_SMALL_FILE_STREAMS, RecoverySettings.this.concurrentSmallFileStreams);, +            if (concurrentSmallFileStreams != RecoverySettings.this.concurrentSmallFileStreams) {, +                logger.info("updating [indices.recovery.concurrent_small_file_streams] from [{}] to [{}]", RecoverySettings.this.concurrentSmallFileStreams, concurrentSmallFileStreams);, +                RecoverySettings.this.concurrentSmallFileStreams = concurrentSmallFileStreams;, +                RecoverySettings.this.concurrentSmallFileStreamPool.setMaximumPoolSize(concurrentSmallFileStreams);, +            }, +++ b/src/main/java/org/elasticsearch/indices/recovery/RecoverySettings.java, +    public static final String INDICES_RECOVERY_CONCURRENT_SMALL_FILE_STREAMS = "indices.recovery.concurrent_small_file_streams";, +    public static final long SMALL_FILE_CUTOFF_BYTES = ByteSizeValue.parseBytesSizeValue("5mb").bytes();, +, +    private volatile int concurrentSmallFileStreams;, +    private final ThreadPoolExecutor concurrentSmallFileStreamPool;, +        this.concurrentSmallFileStreams = componentSettings.getAsInt("concurrent_small_file_streams", settings.getAsInt("index.shard.recovery.concurrent_small_file_streams", 2));, +        this.concurrentSmallFileStreamPool = EsExecutors.newScaling(0, concurrentSmallFileStreams, 60, TimeUnit.SECONDS, EsExecutors.daemonThreadFactory(settings, "[small_file_recovery_stream]"));, +    public ThreadPoolExecutor concurrentSmallFileStreamPool() {, +        return concurrentSmallFileStreamPool;, +    }, +, +, +            int concurrentSmallFileStreams = settings.getAsInt(INDICES_RECOVERY_CONCURRENT_SMALL_FILE_STREAMS, RecoverySettings.this.concurrentSmallFileStreams);, +            if (concurrentSmallFileStreams != RecoverySettings.this.concurrentSmallFileStreams) {, +                logger.info("updating [indices.recovery.concurrent_small_file_streams] from [{}] to [{}]", RecoverySettings.this.concurrentSmallFileStreams, concurrentSmallFileStreams);, +                RecoverySettings.this.concurrentSmallFileStreams = concurrentSmallFileStreams;, +                RecoverySettings.this.concurrentSmallFileStreamPool.setMaximumPoolSize(concurrentSmallFileStreams);, +            }, +++ b/src/main/java/org/elasticsearch/indices/recovery/RecoverySource.java, +import java.util.concurrent.ThreadPoolExecutor;, +                    int fileIndex = 0;, +                        ThreadPoolExecutor pool;, +                        long fileSize = response.phase1FileSizes.get(fileIndex);, +                        if (fileSize > recoverySettings.SMALL_FILE_CUTOFF_BYTES) {, +                            pool = recoverySettings.concurrentStreamPool();, +                        } else {, +                            pool = recoverySettings.concurrentSmallFileStreamPool();, +                        }, +, +                        pool.execute(new Runnable() {, +                        fileIndex++;]