[+++ b/core/src/main/java/org/elasticsearch/search/sort/ScoreSortBuilder.java, +import org.elasticsearch.common.ParseField;, +import org.elasticsearch.common.ParseFieldMatcher;, +import org.elasticsearch.common.ParsingException;, +import org.elasticsearch.common.io.stream.NamedWriteable;, +import org.elasticsearch.common.io.stream.StreamInput;, +import org.elasticsearch.common.io.stream.StreamOutput;, +import org.elasticsearch.common.xcontent.XContentParser;, +import org.elasticsearch.index.query.QueryParseContext;, +import java.util.Objects;, +public class ScoreSortBuilder extends SortBuilder implements NamedWriteable<ScoreSortBuilder>,, +    SortElementParserTemp<ScoreSortBuilder> {, +    private static final String NAME = "_score";, +    static final ScoreSortBuilder PROTOTYPE = new ScoreSortBuilder();, +    public static final ParseField REVERSE_FIELD = new ParseField("reverse");, +    public static final ParseField ORDER_FIELD = new ParseField("order");, +    private SortOrder order = SortOrder.DESC;, +        Objects.requireNonNull(order, "sort order cannot be null.");, +    /**, +     * Get the order of sort scoring. By default, its {@link SortOrder#DESC}., +     */, +    public SortOrder order() {, +        return this.order;, +    }, +, +        builder.startObject(NAME);, +            builder.field(REVERSE_FIELD.getPreferredName(), true);, +, +    @Override, +    public ScoreSortBuilder fromXContent(QueryParseContext context, String elementName) throws IOException {, +        XContentParser parser = context.parser();, +        ParseFieldMatcher matcher = context.parseFieldMatcher();, +, +        XContentParser.Token token;, +        String currentName = parser.currentName();, +        ScoreSortBuilder result = new ScoreSortBuilder();, +        while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {, +            if (token == XContentParser.Token.FIELD_NAME) {, +                currentName = parser.currentName();, +            } else if (token.isValue()) {, +                if (matcher.match(currentName, REVERSE_FIELD)) {, +                    if (parser.booleanValue()) {, +                        result.order(SortOrder.ASC);, +                    }, +                    // else we keep the default DESC, +                } else if (matcher.match(currentName, ORDER_FIELD)) {, +                    result.order(SortOrder.fromString(parser.text()));, +                } else {, +                    throw new ParsingException(parser.getTokenLocation(), "[" + NAME + "] failed to parse field [" + currentName + "]");, +                }, +            } else {, +                throw new ParsingException(parser.getTokenLocation(), "[" + NAME + "] unexpected token [" + token + "]");, +            }, +        }, +        return result;, +    }, +, +    @Override, +    public boolean equals(Object object) {, +        if (this == object) {, +            return true;, +        }, +        if (object == null || getClass() != object.getClass()) {, +            return false;, +        }, +        ScoreSortBuilder other = (ScoreSortBuilder) object;, +        return Objects.equals(order, other.order);, +    }, +, +    @Override, +    public int hashCode() {, +        return Objects.hash(this.order);, +    }, +, +    @Override, +    public void writeTo(StreamOutput out) throws IOException {, +        order.writeTo(out);, +    }, +, +    @Override, +    public ScoreSortBuilder readFrom(StreamInput in) throws IOException {, +        return new ScoreSortBuilder().order(SortOrder.readOrderFrom(in));, +    }, +, +    @Override, +    public String getWriteableName() {, +        return NAME;, +    }, +++ b/core/src/main/java/org/elasticsearch/search/sort/ScoreSortBuilder.java, +import org.elasticsearch.common.ParseField;, +import org.elasticsearch.common.ParseFieldMatcher;, +import org.elasticsearch.common.ParsingException;, +import org.elasticsearch.common.io.stream.NamedWriteable;, +import org.elasticsearch.common.io.stream.StreamInput;, +import org.elasticsearch.common.io.stream.StreamOutput;, +import org.elasticsearch.common.xcontent.XContentParser;, +import org.elasticsearch.index.query.QueryParseContext;, +import java.util.Objects;, +public class ScoreSortBuilder extends SortBuilder implements NamedWriteable<ScoreSortBuilder>,, +    SortElementParserTemp<ScoreSortBuilder> {]