[+++ b/src/main/java/org/elasticsearch/plugins/AbstractPlugin.java, + * <p/>, + * A plugin can be dynamically injected with {@link Module} by implementing <tt>onModule(AnyModule)</tt> method, + * removing the need to override {@link #processModule(org.elasticsearch.common.inject.Module)} and check using, + * instanceof., +++ b/src/main/java/org/elasticsearch/plugins/AbstractPlugin.java, + * <p/>, + * A plugin can be dynamically injected with {@link Module} by implementing <tt>onModule(AnyModule)</tt> method, + * removing the need to override {@link #processModule(org.elasticsearch.common.inject.Module)} and check using, + * instanceof., +++ b/src/main/java/org/elasticsearch/plugins/Plugin.java, + * <p/>, + * A plugin can be dynamically injected with {@link Module} by implementing <tt>onModule(AnyModule)</tt> method, + * removing the need to override {@link #processModule(org.elasticsearch.common.inject.Module)} and check using, + * instanceof., +    /**, +     * Process a specific module. Note, its simpler to implement a custom <tt>onModule(AnyModule module)</tt>, +     * method, which will be automatically be called by the relevant type., +     */, +++ b/src/main/java/org/elasticsearch/plugins/AbstractPlugin.java, + * <p/>, + * A plugin can be dynamically injected with {@link Module} by implementing <tt>onModule(AnyModule)</tt> method, + * removing the need to override {@link #processModule(org.elasticsearch.common.inject.Module)} and check using, + * instanceof., +++ b/src/main/java/org/elasticsearch/plugins/Plugin.java, + * <p/>, + * A plugin can be dynamically injected with {@link Module} by implementing <tt>onModule(AnyModule)</tt> method, + * removing the need to override {@link #processModule(org.elasticsearch.common.inject.Module)} and check using, + * instanceof., +    /**, +     * Process a specific module. Note, its simpler to implement a custom <tt>onModule(AnyModule module)</tt>, +     * method, which will be automatically be called by the relevant type., +     */, +++ b/src/main/java/org/elasticsearch/plugins/PluginsService.java, +import org.elasticsearch.common.collect.MapBuilder;, +    private final ImmutableMap<Plugin, List<OnModuleReference>> onModuleReferences;, +, +    static class OnModuleReference {, +        public final Class<? extends Module> moduleClass;, +        public final Method onModuleMethod;, +, +        OnModuleReference(Class<? extends Module> moduleClass, Method onModuleMethod) {, +            this.moduleClass = moduleClass;, +            this.onModuleMethod = onModuleMethod;, +        }, +    }, +, +, +        MapBuilder<Plugin, List<OnModuleReference>> onModuleReferences = MapBuilder.newMapBuilder();, +        for (Plugin plugin : plugins.values()) {, +            List<OnModuleReference> list = Lists.newArrayList();, +            for (Method method : plugin.getClass().getDeclaredMethods()) {, +                if (!method.getName().equals("onModule")) {, +                    continue;, +                }, +                if (method.getParameterTypes().length == 0 || method.getParameterTypes().length > 1) {, +                    logger.warn("Plugin: {} implementing onModule with no parameters or more than one parameter", plugin.name());, +                    continue;, +                }, +                Class moduleClass = method.getParameterTypes()[0];, +                if (!Module.class.isAssignableFrom(moduleClass)) {, +                    logger.warn("Plugin: {} implementing onModule by the type is not of Module type {}", plugin.name(), moduleClass);, +                    continue;, +                }, +                method.setAccessible(true);, +                list.add(new OnModuleReference(moduleClass, method));, +            }, +            if (!list.isEmpty()) {, +                onModuleReferences.put(plugin, list);, +            }, +        }, +        this.onModuleReferences = onModuleReferences.immutableMap();, +            // see if there are onModule references, +            List<OnModuleReference> references = onModuleReferences.get(plugin);, +            if (references != null) {, +                for (OnModuleReference reference : references) {, +                    if (reference.moduleClass.isAssignableFrom(module.getClass())) {, +                        try {, +                            reference.onModuleMethod.invoke(plugin, module);, +                        } catch (Exception e) {, +                            logger.warn("plugin {}, failed to invoke custom onModule method", e, plugin.name());, +                        }, +                    }, +                }, +            }]