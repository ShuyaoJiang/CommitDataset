[+++ b/core/src/main/java/org/apache/lucene/queries/MinDocQuery.java, +import org.apache.lucene.util.Bits;, +            public Scorer scorer(LeafReaderContext context, final Bits acceptDocs) throws IOException {, +                        while (doc < maxDoc) {, +                            if (acceptDocs == null || acceptDocs.get(doc)) {, +                                break;, +                            }, +                            doc += 1;, +                        }, +++ b/core/src/main/java/org/apache/lucene/queries/MinDocQuery.java, +import org.apache.lucene.util.Bits;, +            public Scorer scorer(LeafReaderContext context, final Bits acceptDocs) throws IOException {, +                        while (doc < maxDoc) {, +                            if (acceptDocs == null || acceptDocs.get(doc)) {, +                                break;, +                            }, +                            doc += 1;, +                        }, +++ b/core/src/main/java/org/apache/lucene/queryparser/classic/MapperQueryParser.java, +                        applySlop(q, slop);, +                        applySlop(q, slop);, +    protected WildcardQuery newWildcardQuery(Term t) {, +        // Backport: https://issues.apache.org/jira/browse/LUCENE-6677, +        assert Version.LATEST == Version.LUCENE_5_2_1;, +        WildcardQuery query = new WildcardQuery(t, maxDeterminizedStates);, +        query.setRewriteMethod(multiTermRewriteMethod);, +        return query;, +    }, +, +    @Override, +    private void applySlop(Query q, int slop) {, +        if (q instanceof FilteredQuery) {, +            applySlop(((FilteredQuery)q).getQuery(), slop);, +        if (q instanceof PhraseQuery) {, +            ((PhraseQuery) q).setSlop(slop);, +++ b/core/src/main/java/org/apache/lucene/queries/MinDocQuery.java, +import org.apache.lucene.util.Bits;, +            public Scorer scorer(LeafReaderContext context, final Bits acceptDocs) throws IOException {, +                        while (doc < maxDoc) {, +                            if (acceptDocs == null || acceptDocs.get(doc)) {, +                                break;, +                            }, +                            doc += 1;, +                        }, +++ b/core/src/main/java/org/apache/lucene/queryparser/classic/MapperQueryParser.java, +                        applySlop(q, slop);, +                        applySlop(q, slop);, +    protected WildcardQuery newWildcardQuery(Term t) {, +        // Backport: https://issues.apache.org/jira/browse/LUCENE-6677, +        assert Version.LATEST == Version.LUCENE_5_2_1;, +        WildcardQuery query = new WildcardQuery(t, maxDeterminizedStates);, +        query.setRewriteMethod(multiTermRewriteMethod);, +        return query;, +    }, +, +    @Override, +    private void applySlop(Query q, int slop) {, +        if (q instanceof FilteredQuery) {, +            applySlop(((FilteredQuery)q).getQuery(), slop);, +        if (q instanceof PhraseQuery) {, +            ((PhraseQuery) q).setSlop(slop);, +++ b/core/src/main/java/org/apache/lucene/search/postingshighlight/CustomSeparatorBreakIterator.java, +/*, +Licensed to Elasticsearch under one or more contributor, +license agreements. See the NOTICE file distributed with, +this work for additional information regarding copyright, +ownership. Elasticsearch licenses this file to you under, +the Apache License, Version 2.0 (the "License"); you may, +not use this file except in compliance with the License., +You may obtain a copy of the License at, + *, +   http://www.apache.org/licenses/LICENSE-2.0, + *, +Unless required by applicable law or agreed to in writing,, +software distributed under the License is distributed on an, +"AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY, +KIND, either express or implied.  See the License for the, +specific language governing permissions and limitations, +under the License., + */, +, +package org.apache.lucene.search.postingshighlight;, +, +import java.text.BreakIterator;, +import java.text.CharacterIterator;, +, +/**, + * A {@link BreakIterator} that breaks the text whenever a certain separator, provided as a constructor argument, is found., + */, +public class CustomSeparatorBreakIterator extends BreakIterator {, +, +    private final char separator;, +    private CharacterIterator text;, +    private int current;, +, +    public CustomSeparatorBreakIterator(char separator) {, +        this.separator = separator;, +    }, +, +    @Override]