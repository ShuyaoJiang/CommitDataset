[+++ b/src/main/java/org/elasticsearch/index/fielddata/plain/ParentChildIndexFieldData.java, +import org.apache.lucene.index.*;, +import org.elasticsearch.common.breaker.MemoryCircuitBreaker;, +import org.elasticsearch.index.fielddata.*;, + * ParentChildIndexFieldData is responsible for loading the id cache mapping, + * needed for has_child and has_parent queries into memory., +    public ParentChildIndexFieldData(Index index, @IndexSettings Settings indexSettings, FieldMapper.Names fieldNames,, +                                     FieldDataType fieldDataType, IndexFieldDataCache cache, MapperService mapperService,, +                                     CircuitBreakerService breakerService) {, +            ParentChildEstimator estimator = new ParentChildEstimator(breakerService.getBreaker(), termsEnum);, +            TermsEnum estimatedTermsEnum = estimator.beforeLoad(null);, +                for (BytesRef term = estimatedTermsEnum.next(); term != null; term = estimatedTermsEnum.next()) {, +                    // Usually this would be estimatedTermsEnum, but the, +                    // abstract TermsEnum class does not support the .type(), +                    // and .id() methods, so we skip using the wrapped, +                    // TermsEnum and delegate directly to the, +                    // ParentChildFilteredTermsEnum that was originally wrapped, +                    docsEnum = estimatedTermsEnum.docs(null, docsEnum, DocsEnum.FLAG_NONE);, +                    estimator.afterLoad(estimatedTermsEnum, data.getMemorySizeInBytes());, +    /**, +     * Estimator that wraps parent/child id field data by wrapping the data, +     * in a RamAccountingTermsEnum., +     */, +    public class ParentChildEstimator implements PerValueEstimator {, +, +        private final MemoryCircuitBreaker breaker;, +        private final TermsEnum filteredEnum;, +, +        // The TermsEnum is passed in here instead of being generated in the, +        // beforeLoad() function since it's filtered inside the previous, +        // TermsEnum wrappers, +        public ParentChildEstimator(MemoryCircuitBreaker breaker, TermsEnum filteredEnum) {, +            this.breaker = breaker;, +            this.filteredEnum = filteredEnum;, +        }, +, +        /**, +         * General overhead for ids is 2 times the length of the ID, +         */, +        @Override, +        public long bytesPerValue(BytesRef term) {, +            if (term == null) {, +                return 0;, +            }, +            return 2 * term.length;, +        }, +, +        /**, +         * Wraps the already filtered {@link TermsEnum} in a, +         * {@link RamAccountingTermsEnum} and returns it, +         */, +        @Override, +        public TermsEnum beforeLoad(Terms terms) throws IOException {, +            return new RamAccountingTermsEnum(filteredEnum, breaker, this);, +        }, +, +        /**, +         * Adjusts the breaker based on the difference between the actual usage, +         * and the aggregated estimations., +         */, +        @Override, +        public void afterLoad(TermsEnum termsEnum, long actualUsed) {, +            assert termsEnum instanceof RamAccountingTermsEnum;, +            long estimatedBytes = ((RamAccountingTermsEnum) termsEnum).getTotalBytes();, +            breaker.addWithoutBreaking(-(estimatedBytes - actualUsed));, +        }, +    }, +]