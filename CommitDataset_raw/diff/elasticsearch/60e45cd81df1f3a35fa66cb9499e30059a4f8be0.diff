[+++ b/buildSrc/build.gradle, +  // only run tests as build-tools, +  test.enabled = false, +  test {, +    include "**/*Tests.class", +    exclude "**/*IT.class", +  }, +, +  // This can't be an RandomizedTestingTask because we can't yet reference it, +++ b/buildSrc/build.gradle, +  // only run tests as build-tools, +  test.enabled = false, +  test {, +    include "**/*Tests.class", +    exclude "**/*IT.class", +  }, +, +  // This can't be an RandomizedTestingTask because we can't yet reference it, +++ b/buildSrc/src/main/groovy/org/elasticsearch/gradle/BuildPlugin.groovy, +        project.tasks.withType(RandomizedTestingTask) {task ->, +            // Make sure all test tasks are configured properly, +            if (name != "test") {, +                project.tasks.matching { it.name == "test"}.all { testTask ->, +                    task.testClassesDirs = testTask.testClassesDirs, +                    task.classpath = testTask.classpath, +                    task.shouldRunAfter testTask, +                }, +            }, +            // no loose ends: check has to depend on all test tasks, +            project.tasks.matching {it.name == "check"}.all {, +                dependsOn(task), +            }, +, +++ b/buildSrc/build.gradle, +  // only run tests as build-tools, +  test.enabled = false, +  test {, +    include "**/*Tests.class", +    exclude "**/*IT.class", +  }, +, +  // This can't be an RandomizedTestingTask because we can't yet reference it, +++ b/buildSrc/src/main/groovy/org/elasticsearch/gradle/BuildPlugin.groovy, +        project.tasks.withType(RandomizedTestingTask) {task ->, +            // Make sure all test tasks are configured properly, +            if (name != "test") {, +                project.tasks.matching { it.name == "test"}.all { testTask ->, +                    task.testClassesDirs = testTask.testClassesDirs, +                    task.classpath = testTask.classpath, +                    task.shouldRunAfter testTask, +                }, +            }, +            // no loose ends: check has to depend on all test tasks, +            project.tasks.matching {it.name == "check"}.all {, +                dependsOn(task), +            }, +, +++ b/buildSrc/src/main/groovy/org/elasticsearch/gradle/plugin/PluginBuildPlugin.groovy, +++ b/buildSrc/build.gradle, +  // only run tests as build-tools, +  test.enabled = false, +  test {, +    include "**/*Tests.class", +    exclude "**/*IT.class", +  }, +, +  // This can't be an RandomizedTestingTask because we can't yet reference it, +++ b/buildSrc/src/main/groovy/org/elasticsearch/gradle/BuildPlugin.groovy, +        project.tasks.withType(RandomizedTestingTask) {task ->, +            // Make sure all test tasks are configured properly, +            if (name != "test") {, +                project.tasks.matching { it.name == "test"}.all { testTask ->, +                    task.testClassesDirs = testTask.testClassesDirs, +                    task.classpath = testTask.classpath, +                    task.shouldRunAfter testTask, +                }, +            }, +            // no loose ends: check has to depend on all test tasks, +            project.tasks.matching {it.name == "check"}.all {, +                dependsOn(task), +            }, +, +++ b/buildSrc/src/main/groovy/org/elasticsearch/gradle/plugin/PluginBuildPlugin.groovy, +++ b/buildSrc/src/main/java/org/elasticsearch/gradle/precommit/TestingConventionsTasks.java, +import org.gradle.api.Task;, +import org.gradle.api.file.FileTree;, +import org.gradle.api.tasks.testing.Test;, +import org.gradle.api.tasks.util.PatternFilterable;, +import java.lang.reflect.InvocationTargetException;, +import java.util.HashMap;, +import java.util.Map;, +import java.util.Set;, +    private Map<String, File> testClassNames;, +        final String problems;, +            Predicate<Class<?>> implementsNamingConvention = clazz ->, +                clazz.getName().endsWith(TEST_CLASS_SUFIX) ||, +            Map<File, ? extends Class<?>> classes = getTestClassNames().entrySet().stream(), +                .collect(Collectors.toMap(, +                    Map.Entry::getValue,, +                    entry -> loadClassWithoutInitializing(entry.getKey(), isolatedClassLoader))]