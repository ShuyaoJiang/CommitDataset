[+++ b/x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/action/TransportOpenJobAction.java, +                                  IndexNameExpressionResolver indexNameExpressionResolver,, +                                                                            boolean isMemoryTrackerRecentlyRefreshed,, +        boolean allocateByMemory = isMemoryTrackerRecentlyRefreshed;, +        if (isMemoryTrackerRecentlyRefreshed == false) {, +            String jobId = params.getJobId();, +            String resultsWriteAlias = AnomalyDetectorsIndex.resultsWriteAlias(jobId);, +            List<String> unavailableIndices = verifyIndicesPrimaryShardsAreActive(resultsWriteAlias, clusterState);, +            if (unavailableIndices.size() != 0) {, +                String reason = "Not opening job [" + jobId + "], because not all primary shards are active for the following indices [" +, +                    String.join(",", unavailableIndices) + "]";, +                logger.debug(reason);, +                return new PersistentTasksCustomMetaData.Assignment(null, reason);, +            }, +, +            boolean isMemoryTrackerRecentlyRefreshed = memoryTracker.isRecentlyRefreshed();, +            if (isMemoryTrackerRecentlyRefreshed == false) {, +                boolean scheduledRefresh = memoryTracker.asyncRefresh();, +                if (scheduledRefresh) {, +                    String reason = "Not opening job [" + jobId + "] because job memory requirements are stale - refresh requested";, +                    logger.debug(reason);, +                    return new PersistentTasksCustomMetaData.Assignment(null, reason);, +                }, +            }, +, +            PersistentTasksCustomMetaData.Assignment assignment = selectLeastLoadedMlNode(jobId,, +                isMemoryTrackerRecentlyRefreshed,, +++ b/x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/action/TransportOpenJobAction.java, +                                  IndexNameExpressionResolver indexNameExpressionResolver,, +                                                                            boolean isMemoryTrackerRecentlyRefreshed,, +        boolean allocateByMemory = isMemoryTrackerRecentlyRefreshed;, +        if (isMemoryTrackerRecentlyRefreshed == false) {, +            String jobId = params.getJobId();, +            String resultsWriteAlias = AnomalyDetectorsIndex.resultsWriteAlias(jobId);, +            List<String> unavailableIndices = verifyIndicesPrimaryShardsAreActive(resultsWriteAlias, clusterState);, +            if (unavailableIndices.size() != 0) {, +                String reason = "Not opening job [" + jobId + "], because not all primary shards are active for the following indices [" +, +                    String.join(",", unavailableIndices) + "]";, +                logger.debug(reason);, +                return new PersistentTasksCustomMetaData.Assignment(null, reason);, +            }, +, +            boolean isMemoryTrackerRecentlyRefreshed = memoryTracker.isRecentlyRefreshed();, +            if (isMemoryTrackerRecentlyRefreshed == false) {, +                boolean scheduledRefresh = memoryTracker.asyncRefresh();, +                if (scheduledRefresh) {, +                    String reason = "Not opening job [" + jobId + "] because job memory requirements are stale - refresh requested";, +                    logger.debug(reason);, +                    return new PersistentTasksCustomMetaData.Assignment(null, reason);, +                }, +            }, +, +            PersistentTasksCustomMetaData.Assignment assignment = selectLeastLoadedMlNode(jobId,, +                isMemoryTrackerRecentlyRefreshed,, +++ b/x-pack/plugin/ml/src/test/java/org/elasticsearch/xpack/ml/action/TransportOpenJobActionTests.java, +import org.elasticsearch.common.util.set.Sets;, +    private boolean isMemoryTrackerRecentlyRefreshed;, +        isMemoryTrackerRecentlyRefreshed = true;, +        when(memoryTracker.isRecentlyRefreshed()).thenReturn(isMemoryTrackerRecentlyRefreshed);, +                cs.build(), 2, 30, memoryTracker, isMemoryTrackerRecentlyRefreshed, logger);, +                30, memoryTracker, isMemoryTrackerRecentlyRefreshed, logger);, +        Assignment result = TransportOpenJobAction.selectLeastLoadedMlNode("job_id2", job, cs.build(), 2, 30, memoryTracker,, +            isMemoryTrackerRecentlyRefreshed, logger);, +        Assignment result = TransportOpenJobAction.selectLeastLoadedMlNode("job_id6", job, cs, 2, 30, memoryTracker,, +            isMemoryTrackerRecentlyRefreshed, logger);, +        result = TransportOpenJobAction.selectLeastLoadedMlNode("job_id7", job, cs, 2, 30, memoryTracker, isMemoryTrackerRecentlyRefreshed,, +            logger);, +        result = TransportOpenJobAction.selectLeastLoadedMlNode("job_id7", job, cs, 2, 30, memoryTracker, isMemoryTrackerRecentlyRefreshed,, +            logger);, +        result = TransportOpenJobAction.selectLeastLoadedMlNode("job_id7", job, cs, 2, 30, memoryTracker, isMemoryTrackerRecentlyRefreshed,, +            logger);, +        Assignment result = TransportOpenJobAction.selectLeastLoadedMlNode("job_id7", job, cs, 2, 30, memoryTracker,, +            isMemoryTrackerRecentlyRefreshed, logger);, +        result = TransportOpenJobAction.selectLeastLoadedMlNode("job_id8", job, cs, 2, 30, memoryTracker, isMemoryTrackerRecentlyRefreshed,, +            logger);, +            memoryTracker, isMemoryTrackerRecentlyRefreshed, logger);, +                2, 30, memoryTracker, isMemoryTrackerRecentlyRefreshed, logger);, +            isMemoryTrackerRecentlyRefreshed, logger);, +            isMemoryTrackerRecentlyRefreshed, logger);, +        ClusterSettings clusterSettings = new ClusterSettings(Settings.EMPTY,, +            Sets.newHashSet(MachineLearning.CONCURRENT_JOB_ALLOCATIONS, MachineLearning.MAX_MACHINE_MEMORY_PERCENT,, +        );, +    // An index being unavailable should take precedence over waiting for a lazy node, +    public void testGetAssignment_GivenUnavailableIndicesWithLazyNode() {, +        Settings settings = Settings.builder().put(MachineLearning.MAX_LAZY_ML_NODES.getKey(), 1).build();, +        ClusterService clusterService = mock(ClusterService.class);, +        ClusterSettings clusterSettings = new ClusterSettings(settings,, +            Sets.newHashSet(MachineLearning.CONCURRENT_JOB_ALLOCATIONS, MachineLearning.MAX_MACHINE_MEMORY_PERCENT,, +                MachineLearning.MAX_LAZY_ML_NODES), +        );, +        when(clusterService.getClusterSettings()).thenReturn(clusterSettings);, +, +        ClusterState.Builder csBuilder = ClusterState.builder(new ClusterName("_name"));, +        MetaData.Builder metaData = MetaData.builder();, +        RoutingTable.Builder routingTable = RoutingTable.builder();, +        addIndices(metaData, routingTable);, +        routingTable.remove(".ml-state");, +        csBuilder.metaData(metaData);, +        csBuilder.routingTable(routingTable.build());, +]