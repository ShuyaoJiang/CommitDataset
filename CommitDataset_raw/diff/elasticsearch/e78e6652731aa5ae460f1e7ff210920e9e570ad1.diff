[+++ b/modules/elasticsearch/src/main/java/org/elasticsearch/cluster/node/DiscoveryNodes.java, +    @Override public String toString() {, +        StringBuilder sb = new StringBuilder();, +        sb.append("{");, +        for (DiscoveryNode node : this) {, +            sb.append(node).append(',');, +        }, +        sb.append("}");, +        return sb.toString();, +    }, +, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/cluster/node/DiscoveryNodes.java, +    @Override public String toString() {, +        StringBuilder sb = new StringBuilder();, +        sb.append("{");, +        for (DiscoveryNode node : this) {, +            sb.append(node).append(',');, +        }, +        sb.append("}");, +        return sb.toString();, +    }, +, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/cluster/service/InternalClusterService.java, +import org.elasticsearch.discovery.Discovery;, +    private final ClusterBlocks.Builder initialBlocks = ClusterBlocks.builder().addGlobalBlock(Discovery.NO_MASTER_BLOCK);, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/cluster/node/DiscoveryNodes.java, +    @Override public String toString() {, +        StringBuilder sb = new StringBuilder();, +        sb.append("{");, +        for (DiscoveryNode node : this) {, +            sb.append(node).append(',');, +        }, +        sb.append("}");, +        return sb.toString();, +    }, +, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/cluster/service/InternalClusterService.java, +import org.elasticsearch.discovery.Discovery;, +    private final ClusterBlocks.Builder initialBlocks = ClusterBlocks.builder().addGlobalBlock(Discovery.NO_MASTER_BLOCK);, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/discovery/local/LocalDiscovery.java, +import org.elasticsearch.cluster.block.ClusterBlocks;, +                        // remove the NO_MASTER block in this case, +                        ClusterBlocks.Builder blocks = ClusterBlocks.builder().blocks(currentState.blocks()).removeGlobalBlock(Discovery.NO_MASTER_BLOCK);, +                        return newClusterStateBuilder().state(currentState).nodes(nodesBuilder).blocks(blocks).build();, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/cluster/node/DiscoveryNodes.java, +    @Override public String toString() {, +        StringBuilder sb = new StringBuilder();, +        sb.append("{");, +        for (DiscoveryNode node : this) {, +            sb.append(node).append(',');, +        }, +        sb.append("}");, +        return sb.toString();, +    }, +, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/cluster/service/InternalClusterService.java, +import org.elasticsearch.discovery.Discovery;, +    private final ClusterBlocks.Builder initialBlocks = ClusterBlocks.builder().addGlobalBlock(Discovery.NO_MASTER_BLOCK);, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/discovery/local/LocalDiscovery.java, +import org.elasticsearch.cluster.block.ClusterBlocks;, +                        // remove the NO_MASTER block in this case, +                        ClusterBlocks.Builder blocks = ClusterBlocks.builder().blocks(currentState.blocks()).removeGlobalBlock(Discovery.NO_MASTER_BLOCK);, +                        return newClusterStateBuilder().state(currentState).nodes(nodesBuilder).blocks(blocks).build();, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/discovery/zen/ZenDiscovery.java, +import org.elasticsearch.common.collect.Sets;, +import org.elasticsearch.gateway.GatewayService;, +import java.util.Set;, +        if (currentJoinThread != null) {, +            // we are already joining, ignore..., +            return;, +        }, +    private void handleLeaveRequest(final DiscoveryNode node) {, +        if (lifecycleState() != Lifecycle.State.STARTED) {, +            // not started, ignore a node failure, +            return;, +        }, +        if (master) {, +            clusterService.submitStateUpdateTask("zen-disco-node_left(" + node + ")", new ClusterStateUpdateTask() {, +                @Override public ClusterState execute(ClusterState currentState) {, +                    DiscoveryNodes.Builder builder = new DiscoveryNodes.Builder(), +                            .putAll(currentState.nodes()), +                            .remove(node.id());, +                    latestDiscoNodes = builder.build();, +                    currentState = newClusterStateBuilder().state(currentState).nodes(latestDiscoNodes).build();, +                    // check if we have enough master nodes, if not, we need to move into joining the cluster again, +                    if (!electMaster.hasEnoughMasterNodes(currentState.nodes())) {, +                        return disconnectFromCluster(currentState, "not enough master nodes");, +                    }, +                    return currentState;, +                }, +            });, +        } else {, +            handleMasterGone(node, "shut_down");, +        }, +    }, +, +                currentState = newClusterStateBuilder().state(currentState).nodes(latestDiscoNodes).build();, +                // check if we have enough master nodes, if not, we need to move into joining the cluster again, +                if (!electMaster.hasEnoughMasterNodes(currentState.nodes())) {, +                    return disconnectFromCluster(currentState, "not enough master nodes");]