[+++ b/modules/elasticsearch/src/main/java/org/elasticsearch/gateway/local/LocalGatewayNodeAllocation.java, +import org.elasticsearch.cluster.metadata.IndexMetaData;, +import org.elasticsearch.common.trove.ExtTObjectIntHasMap;, +import org.elasticsearch.common.trove.TObjectIntHashMap;, +import org.elasticsearch.common.trove.TObjectIntIterator;, +    private final String initialShards;, +, +        this.initialShards = componentSettings.get("initial_shards", "quorum");, +                // and a list of the number of shard instances, +                TObjectIntHashMap<ShardId> shardsCounts = new ExtTObjectIntHasMap<ShardId>().defaultReturnValue(-1);, +                        ShardId shardId = entry.getKey();, +                        if (shardId.index().name().equals(indexRoutingTable.index())) {, +                            shardsCounts.adjustOrPutValue(shardId, 1, 1);, +, +                            Tuple<DiscoveryNode, Long> t = shards.get(shardId);, +                                shards.put(shardId, t);, +                    moveIndexToIgnoreUnassigned(routingNodes, indexRoutingTable);, +                } else {, +                    // check if the counts meets the minimum set, +                    int requiredNumber = 1;, +                    IndexMetaData indexMetaData = routingNodes.metaData().index(indexRoutingTable.index());, +                    if ("quorum".equals(initialShards)) {, +                        if (indexMetaData.numberOfReplicas() > 1) {, +                            requiredNumber = ((1 + indexMetaData.numberOfReplicas()) / 2) + 1;, +                    } else if ("full".equals(initialShards)) {, +                        requiredNumber = indexMetaData.numberOfReplicas() + 1;, +                    } else if ("full-1".equals(initialShards)) {, +                        if (indexMetaData.numberOfReplicas() > 1) {, +                            requiredNumber = indexMetaData.numberOfReplicas();, +                        requiredNumber = Integer.parseInt(initialShards);, +                    }, +, +                    boolean allocate = true;, +                    for (TObjectIntIterator<ShardId> it = shardsCounts.iterator(); it.hasNext();) {, +                        it.advance();, +                        if (it.value() < requiredNumber) {, +                            allocate = false;, +                        }, +                    }, +, +                    if (allocate) {, +                    } else {, +                        moveIndexToIgnoreUnassigned(routingNodes, indexRoutingTable);, +                    }, +    private void moveIndexToIgnoreUnassigned(RoutingNodes routingNodes, IndexRoutingTable indexRoutingTable) {, +        for (Iterator<MutableShardRouting> it = routingNodes.unassigned().iterator(); it.hasNext();) {, +            MutableShardRouting shardRouting = it.next();, +            if (shardRouting.index().equals(indexRoutingTable.index())) {, +                it.remove();, +                routingNodes.ignoredUnassigned().add(shardRouting);, +            }, +        }, +    }, +, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/gateway/local/LocalGatewayNodeAllocation.java, +import org.elasticsearch.cluster.metadata.IndexMetaData;, +import org.elasticsearch.common.trove.ExtTObjectIntHasMap;, +import org.elasticsearch.common.trove.TObjectIntHashMap;, +import org.elasticsearch.common.trove.TObjectIntIterator;, +    private final String initialShards;, +, +        this.initialShards = componentSettings.get("initial_shards", "quorum");, +                // and a list of the number of shard instances, +                TObjectIntHashMap<ShardId> shardsCounts = new ExtTObjectIntHasMap<ShardId>().defaultReturnValue(-1);, +                        ShardId shardId = entry.getKey();, +                        if (shardId.index().name().equals(indexRoutingTable.index())) {, +                            shardsCounts.adjustOrPutValue(shardId, 1, 1);, +, +                            Tuple<DiscoveryNode, Long> t = shards.get(shardId);, +                                shards.put(shardId, t);, +                    moveIndexToIgnoreUnassigned(routingNodes, indexRoutingTable);, +                } else {, +                    // check if the counts meets the minimum set, +                    int requiredNumber = 1;, +                    IndexMetaData indexMetaData = routingNodes.metaData().index(indexRoutingTable.index());, +                    if ("quorum".equals(initialShards)) {, +                        if (indexMetaData.numberOfReplicas() > 1) {, +                            requiredNumber = ((1 + indexMetaData.numberOfReplicas()) / 2) + 1;, +                    } else if ("full".equals(initialShards)) {, +                        requiredNumber = indexMetaData.numberOfReplicas() + 1;, +                    } else if ("full-1".equals(initialShards)) {, +                        if (indexMetaData.numberOfReplicas() > 1) {, +                            requiredNumber = indexMetaData.numberOfReplicas();, +                        requiredNumber = Integer.parseInt(initialShards);, +                    }, +, +                    boolean allocate = true;, +                    for (TObjectIntIterator<ShardId> it = shardsCounts.iterator(); it.hasNext();) {, +                        it.advance();, +                        if (it.value() < requiredNumber) {, +                            allocate = false;, +                        }, +                    }, +, +                    if (allocate) {, +                    } else {, +                        moveIndexToIgnoreUnassigned(routingNodes, indexRoutingTable);, +                    }, +    private void moveIndexToIgnoreUnassigned(RoutingNodes routingNodes, IndexRoutingTable indexRoutingTable) {, +        for (Iterator<MutableShardRouting> it = routingNodes.unassigned().iterator(); it.hasNext();) {]