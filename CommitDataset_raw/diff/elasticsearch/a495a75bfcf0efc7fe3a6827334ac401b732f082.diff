[+++ b/core/src/main/java/org/elasticsearch/search/aggregations/bucket/children/ChildrenParser.java, +        return new AggregatorFactory[] { new ParentToChildrenAggregator.Factory(null, null) };, +++ b/core/src/main/java/org/elasticsearch/search/aggregations/bucket/children/ChildrenParser.java, +        return new AggregatorFactory[] { new ParentToChildrenAggregator.Factory(null, null) };, +++ b/core/src/main/java/org/elasticsearch/search/aggregations/bucket/children/ParentToChildrenAggregator.java, +import org.elasticsearch.common.ParseField;, +import org.elasticsearch.common.io.stream.StreamInput;, +import org.elasticsearch.common.io.stream.StreamOutput;, +import org.elasticsearch.common.xcontent.XContentBuilder;, +import org.elasticsearch.search.aggregations.support.ValueType;, +import org.elasticsearch.search.aggregations.support.ValuesSource.Bytes.ParentChild;, +import java.util.Objects;, +import java.util.Set;, +    static final ParseField TYPE_FIELD = new ParseField("type");, +, +        /**, +         * @param name, +         *            the name of this aggregation, +         * @param childType, +         *            the type of children documents, +         */, +            super(name, InternalChildren.TYPE, ValuesSourceType.BYTES, ValueType.STRING);, +        @Override, +        protected XContentBuilder doXContentBody(XContentBuilder builder, Params params) throws IOException {, +            builder.field(TYPE_FIELD.getPreferredName(), childType);, +            return builder;, +        }, +, +        @Override, +        protected ValuesSourceAggregatorFactory<ParentChild> innerReadFrom(String name, ValuesSourceType valuesSourceType,, +                ValueType targetValueType, StreamInput in) throws IOException {, +            String childType = in.readString();, +            Factory factory = new Factory(name, childType);, +            return factory;, +        }, +, +        @Override, +        protected void innerWriteTo(StreamOutput out) throws IOException {, +            out.writeString(childType);, +        }, +, +        @Override, +        protected int innerHashCode() {, +            return Objects.hash(childType);, +        }, +, +        @Override, +        protected boolean innerEquals(Object obj) {, +            Factory other = (Factory) obj;, +            return Objects.equals(childType, other.childType);, +        }, +, +++ b/core/src/main/java/org/elasticsearch/search/aggregations/bucket/children/ChildrenParser.java, +        return new AggregatorFactory[] { new ParentToChildrenAggregator.Factory(null, null) };, +++ b/core/src/main/java/org/elasticsearch/search/aggregations/bucket/children/ParentToChildrenAggregator.java, +import org.elasticsearch.common.ParseField;, +import org.elasticsearch.common.io.stream.StreamInput;, +import org.elasticsearch.common.io.stream.StreamOutput;, +import org.elasticsearch.common.xcontent.XContentBuilder;, +import org.elasticsearch.search.aggregations.support.ValueType;, +import org.elasticsearch.search.aggregations.support.ValuesSource.Bytes.ParentChild;, +import java.util.Objects;, +import java.util.Set;, +    static final ParseField TYPE_FIELD = new ParseField("type");, +, +        /**, +         * @param name, +         *            the name of this aggregation, +         * @param childType, +         *            the type of children documents, +         */, +            super(name, InternalChildren.TYPE, ValuesSourceType.BYTES, ValueType.STRING);, +        @Override, +        protected XContentBuilder doXContentBody(XContentBuilder builder, Params params) throws IOException {, +            builder.field(TYPE_FIELD.getPreferredName(), childType);, +            return builder;, +        }, +, +        @Override, +        protected ValuesSourceAggregatorFactory<ParentChild> innerReadFrom(String name, ValuesSourceType valuesSourceType,, +                ValueType targetValueType, StreamInput in) throws IOException {, +            String childType = in.readString();, +            Factory factory = new Factory(name, childType);, +            return factory;, +        }, +, +        @Override, +        protected void innerWriteTo(StreamOutput out) throws IOException {, +            out.writeString(childType);, +        }, +, +        @Override, +        protected int innerHashCode() {, +            return Objects.hash(childType);, +        }, +, +        @Override, +        protected boolean innerEquals(Object obj) {, +            Factory other = (Factory) obj;, +            return Objects.equals(childType, other.childType);]