[+++ b/build.gradle, +++ b/build.gradle, +++ b/buildSrc/build.gradle, +  compile 'com.bmuschko:gradle-nexus-plugin:2.3.1', +++ b/build.gradle, +++ b/buildSrc/build.gradle, +  compile 'com.bmuschko:gradle-nexus-plugin:2.3.1', +++ b/buildSrc/src/main/groovy/org/elasticsearch/gradle/BuildPlugin.groovy, +import nebula.plugin.extraconfigurations.ProvidedBasePlugin, +import org.gradle.api.*, +import org.gradle.api.artifacts.*, +import org.gradle.api.artifacts.maven.MavenPom, +        project.pluginManager.apply('com.bmuschko.nexus'), +        project.pluginManager.apply(ProvidedBasePlugin), +        // fail on any conflicting dependency versions, +        project.configurations.all({ Configuration configuration ->, +            if (configuration.name.startsWith('_transitive_')) {, +                // don't force transitive configurations to not conflict with themselves, since, +                // we just have them to find *what* transitive deps exist, +                return, +            }, +            configuration.resolutionStrategy.failOnVersionConflict(), +        }), +        Closure disableTransitiveDeps = { ModuleDependency dep ->, +, +                // also create a configuration just for this dependency version, so that later, +                // we can determine which dependencies it has (for pom generation excludes), +                String depId = "${dep.getGroup()}:${dep.getName()}:${dep.getVersion()}", +                String depConfig = "_transitive_${depId}", +                if (project.configurations.findByName(depConfig) == null) {, +                    project.configurations.create(depConfig), +                    project.dependencies.add(depConfig, depId), +        }, +, +        project.configurations.compile.dependencies.all(disableTransitiveDeps), +        project.configurations.testCompile.dependencies.all(disableTransitiveDeps), +        project.configurations.provided.dependencies.all(disableTransitiveDeps), +, +        // add exclusions to the pom directly, for each of the transitive deps of this project's deps, +        project.modifyPom { MavenPom pom ->, +            pom.withXml { XmlProvider xml ->, +                // first find if we have dependencies at all, and grab the node, +                NodeList depsNodes = xml.asNode().get('dependencies'), +                if (depsNodes.isEmpty()) {, +                    return, +                }, +, +                // check each dependency for any transitive deps, +                for (Node depNode : depsNodes.get(0).children()) {, +                    String groupId = depNode.get('groupId').get(0).text(), +                    String artifactId = depNode.get('artifactId').get(0).text(), +                    String version = depNode.get('version').get(0).text(), +, +                    // collect the transitive deps now that we know what this dependency is, +                    String depId = "${groupId}:${artifactId}:${version}", +                    String depConfig = "_transitive_${depId}", +                    Configuration configuration = project.configurations.findByName(depConfig), +                    if (configuration == null) {, +                        continue // we did not make this dep non-transitive, +                    }, +                    Set<ResolvedArtifact> artifacts = configuration.resolvedConfiguration.resolvedArtifacts, +                    if (artifacts.size() <= 1) {, +                        // this dep has no transitive deps (or the only artifact is itself), +                        continue, +                    }, +, +                    // we now know we have something to exclude, so add the exclusion elements, +                    Node exclusions = depNode.appendNode('exclusions'), +                    for (ResolvedArtifact transitiveArtifact : artifacts) {, +                        ModuleVersionIdentifier transitiveDep = transitiveArtifact.moduleVersion.id, +                        if (transitiveDep.group == groupId && transitiveDep.name == artifactId) {, +                            continue; // don't exclude the dependency itself!, +                        }, +                        Node exclusion = exclusions.appendNode('exclusion'), +                        exclusion.appendNode('groupId', transitiveDep.group), +                        exclusion.appendNode('artifactId', transitiveDep.name), +                    }, +                }, +++ b/build.gradle, +++ b/buildSrc/build.gradle, +  compile 'com.bmuschko:gradle-nexus-plugin:2.3.1', +++ b/buildSrc/src/main/groovy/org/elasticsearch/gradle/BuildPlugin.groovy, +import nebula.plugin.extraconfigurations.ProvidedBasePlugin, +import org.gradle.api.*, +import org.gradle.api.artifacts.*, +import org.gradle.api.artifacts.maven.MavenPom, +        project.pluginManager.apply('com.bmuschko.nexus'), +        project.pluginManager.apply(ProvidedBasePlugin), +        // fail on any conflicting dependency versions, +        project.configurations.all({ Configuration configuration ->, +            if (configuration.name.startsWith('_transitive_')) {, +                // don't force transitive configurations to not conflict with themselves, since, +                // we just have them to find *what* transitive deps exist, +                return, +            }, +            configuration.resolutionStrategy.failOnVersionConflict(), +        }), +        Closure disableTransitiveDeps = { ModuleDependency dep ->, +, +                // also create a configuration just for this dependency version, so that later]