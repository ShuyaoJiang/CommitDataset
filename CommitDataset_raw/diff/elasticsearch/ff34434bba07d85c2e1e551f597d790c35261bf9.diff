[+++ b/build.gradle, +// introspect all versions of ES that may be tested agains for backwards compatibility, +String currentVersion = VersionProperties.elasticsearch.minus('-SNAPSHOT'), +int prevMajor = Integer.parseInt(currentVersion.split('\\.')[0]) - 1, +List<String> versions = [], +// keep track of the previous major version's last minor, so we know where wire compat begins, +int prevMinorIndex = -1 // index in the versions list of the last minor from the prev major, +int lastPrevMinor = -1 // the minor version number from the prev major we most recently seen, +  Matcher match = line =~ /\W+public static final Version V_(\d+)_(\d+)_(\d+)(_UNRELEASED)? .*/, +    int major = Integer.parseInt(match.group(1)), +    int minor = Integer.parseInt(match.group(2)), +    int bugfix = Integer.parseInt(match.group(3)), +    String versionStr = "${major}.${minor}.${bugfix}", +    if (currentVersion != versionStr) {, +      versions.add(versionStr), +    if (major == prevMajor && minor > lastPrevMinor) {, +      prevMinorIndex = versions.size() - 1, +      lastPrevMinor = minor, +    }, +  }, +}, +if (versions.toSorted() != versions) {, +  throw new GradleException('Versions.java contains out of order version constants'), +}, +if (currentVersion.split('\\.')[2].split('-')[0] == '0') {, +  // If on a release branch, after the initial release of that branch, the bugfix version will, +  // be bumped, and will be != 0. On master and N.x branches, we want to test against the, +  // unreleased version of closest branch. So for those cases, the version includes -SNAPSHOT,, +  // and the bwc-zip distribution will checkout and build that version. The version parsing, +  // logic above pulls the bugfix version, and then strips off any prerelease version, +  versions[-1] += '-SNAPSHOT', +    indexCompatVersions = versions, +    wireCompatVersions = versions.subList(prevMinorIndex, versions.size()), +    "org.elasticsearch.distribution.zip:elasticsearch:${wireCompatVersions[-1]}": ':distribution:bwc-zip',, +++ b/build.gradle, +// introspect all versions of ES that may be tested agains for backwards compatibility, +String currentVersion = VersionProperties.elasticsearch.minus('-SNAPSHOT'), +int prevMajor = Integer.parseInt(currentVersion.split('\\.')[0]) - 1, +List<String> versions = [], +// keep track of the previous major version's last minor, so we know where wire compat begins, +int prevMinorIndex = -1 // index in the versions list of the last minor from the prev major, +int lastPrevMinor = -1 // the minor version number from the prev major we most recently seen, +  Matcher match = line =~ /\W+public static final Version V_(\d+)_(\d+)_(\d+)(_UNRELEASED)? .*/, +    int major = Integer.parseInt(match.group(1)), +    int minor = Integer.parseInt(match.group(2)), +    int bugfix = Integer.parseInt(match.group(3)), +    String versionStr = "${major}.${minor}.${bugfix}", +    if (currentVersion != versionStr) {, +      versions.add(versionStr), +    if (major == prevMajor && minor > lastPrevMinor) {, +      prevMinorIndex = versions.size() - 1, +      lastPrevMinor = minor, +    }, +  }, +}, +if (versions.toSorted() != versions) {, +  throw new GradleException('Versions.java contains out of order version constants'), +}, +if (currentVersion.split('\\.')[2].split('-')[0] == '0') {, +  // If on a release branch, after the initial release of that branch, the bugfix version will, +  // be bumped, and will be != 0. On master and N.x branches, we want to test against the, +  // unreleased version of closest branch. So for those cases, the version includes -SNAPSHOT,, +  // and the bwc-zip distribution will checkout and build that version. The version parsing, +  // logic above pulls the bugfix version, and then strips off any prerelease version, +  versions[-1] += '-SNAPSHOT', +    indexCompatVersions = versions, +    wireCompatVersions = versions.subList(prevMinorIndex, versions.size()), +    "org.elasticsearch.distribution.zip:elasticsearch:${wireCompatVersions[-1]}": ':distribution:bwc-zip',, +++ b/buildSrc/src/main/resources/checkstyle_suppressions.xml, +++ b/build.gradle, +// introspect all versions of ES that may be tested agains for backwards compatibility, +String currentVersion = VersionProperties.elasticsearch.minus('-SNAPSHOT'), +int prevMajor = Integer.parseInt(currentVersion.split('\\.')[0]) - 1, +List<String> versions = [], +// keep track of the previous major version's last minor, so we know where wire compat begins, +int prevMinorIndex = -1 // index in the versions list of the last minor from the prev major, +int lastPrevMinor = -1 // the minor version number from the prev major we most recently seen, +  Matcher match = line =~ /\W+public static final Version V_(\d+)_(\d+)_(\d+)(_UNRELEASED)? .*/, +    int major = Integer.parseInt(match.group(1)), +    int minor = Integer.parseInt(match.group(2)), +    int bugfix = Integer.parseInt(match.group(3)), +    String versionStr = "${major}.${minor}.${bugfix}", +    if (currentVersion != versionStr) {, +      versions.add(versionStr), +    if (major == prevMajor && minor > lastPrevMinor) {, +      prevMinorIndex = versions.size() - 1, +      lastPrevMinor = minor, +    }, +  }, +}, +if (versions.toSorted() != versions) {, +  throw new GradleException('Versions.java contains out of order version constants'), +}, +if (currentVersion.split('\\.')[2].split('-')[0] == '0') {, +  // If on a release branch, after the initial release of that branch, the bugfix version will, +  // be bumped, and will be != 0. On master and N.x branches, we want to test against the, +  // unreleased version of closest branch. So for those cases, the version includes -SNAPSHOT,, +  // and the bwc-zip distribution will checkout and build that version. The version parsing, +  // logic above pulls the bugfix version, and then strips off any prerelease version, +  versions[-1] += '-SNAPSHOT']