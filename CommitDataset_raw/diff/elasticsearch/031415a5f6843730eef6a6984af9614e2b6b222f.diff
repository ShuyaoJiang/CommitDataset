[+++ b/server/src/main/java/org/elasticsearch/action/support/replication/ReplicationOperation.java, +            markUnavailableShardsAsStale(replicaRequest, replicationGroup);, +            performOnReplicas(replicaRequest, globalCheckpoint, replicationGroup);, +    private void markUnavailableShardsAsStale(ReplicaRequest replicaRequest, ReplicationGroup replicationGroup) {, +        for (String allocationId : replicationGroup.getUnavailableInSyncShards()) {, +                                   final ReplicationGroup replicationGroup) {, +        // for total stats, add number of unassigned shards and, +        // number of initializing shards that are not ready yet to receive operations (recovery has not opened engine yet on the target), +        totalShards.addAndGet(replicationGroup.getSkippedShards().size());, +        final ShardRouting primaryRouting = primary.routingEntry();, +, +        for (final ShardRouting shard : replicationGroup.getReplicationTargets()) {, +            if (shard.isSameAllocation(primaryRouting) == false) {, +++ b/server/src/main/java/org/elasticsearch/action/support/replication/ReplicationOperation.java, +            markUnavailableShardsAsStale(replicaRequest, replicationGroup);, +            performOnReplicas(replicaRequest, globalCheckpoint, replicationGroup);, +    private void markUnavailableShardsAsStale(ReplicaRequest replicaRequest, ReplicationGroup replicationGroup) {, +        for (String allocationId : replicationGroup.getUnavailableInSyncShards()) {, +                                   final ReplicationGroup replicationGroup) {, +        // for total stats, add number of unassigned shards and, +        // number of initializing shards that are not ready yet to receive operations (recovery has not opened engine yet on the target), +        totalShards.addAndGet(replicationGroup.getSkippedShards().size());, +        final ShardRouting primaryRouting = primary.routingEntry();, +, +        for (final ShardRouting shard : replicationGroup.getReplicationTargets()) {, +            if (shard.isSameAllocation(primaryRouting) == false) {, +++ /dev/null, +++ b/server/src/main/java/org/elasticsearch/action/support/replication/ReplicationOperation.java, +            markUnavailableShardsAsStale(replicaRequest, replicationGroup);, +            performOnReplicas(replicaRequest, globalCheckpoint, replicationGroup);, +    private void markUnavailableShardsAsStale(ReplicaRequest replicaRequest, ReplicationGroup replicationGroup) {, +        for (String allocationId : replicationGroup.getUnavailableInSyncShards()) {, +                                   final ReplicationGroup replicationGroup) {, +        // for total stats, add number of unassigned shards and, +        // number of initializing shards that are not ready yet to receive operations (recovery has not opened engine yet on the target), +        totalShards.addAndGet(replicationGroup.getSkippedShards().size());, +        final ShardRouting primaryRouting = primary.routingEntry();, +, +        for (final ShardRouting shard : replicationGroup.getReplicationTargets()) {, +            if (shard.isSameAllocation(primaryRouting) == false) {, +++ /dev/null, +++ b/server/src/main/java/org/elasticsearch/index/seqno/ReplicationTracker.java, +/*, + * Licensed to Elasticsearch under one or more contributor, + * license agreements. See the NOTICE file distributed with, + * this work for additional information regarding copyright, + * ownership. Elasticsearch licenses this file to you under, + * the Apache License, Version 2.0 (the "License"); you may, + * not use this file except in compliance with the License., + * You may obtain a copy of the License at, + *, + *    http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing,, + * software distributed under the License is distributed on an, + * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY, + * KIND, either express or implied.  See the License for the, + * specific language governing permissions and limitations, + * under the License., + */, +, +package org.elasticsearch.index.seqno;, +, +import com.carrotsearch.hppc.ObjectLongHashMap;, +import com.carrotsearch.hppc.ObjectLongMap;, +import org.elasticsearch.Version;, +import org.elasticsearch.cluster.routing.AllocationId;, +import org.elasticsearch.cluster.routing.IndexShardRoutingTable;, +import org.elasticsearch.cluster.routing.ShardRouting;, +import org.elasticsearch.common.SuppressForbidden;, +import org.elasticsearch.common.io.stream.StreamInput;, +import org.elasticsearch.common.io.stream.StreamOutput;, +import org.elasticsearch.common.io.stream.Writeable;, +import org.elasticsearch.index.IndexSettings;, +import org.elasticsearch.index.shard.AbstractIndexShardComponent;, +import org.elasticsearch.index.shard.ReplicationGroup;, +import org.elasticsearch.index.shard.ShardId;, +, +import java.io.IOException;, +import java.util.Collection;, +import java.util.HashMap;, +import java.util.HashSet;, +import java.util.Map;, +import java.util.OptionalLong;, +import java.util.Set;, +import java.util.function.Function;, +import java.util.function.LongConsumer;, +import java.util.function.LongSupplier;, +import java.util.function.ToLongFunction;, +import java.util.stream.Collectors;, +import java.util.stream.LongStream;, +, +/**, + * This class is responsible for tracking the replication group with its progress and safety markers (local and global checkpoints)., + *, + * The global checkpoint is the highest sequence number for which all lower (or equal) sequence number have been processed, + * on all shards that are currently active. Since shards count as "active" when the master starts, + * them, and before this primary shard has been notified of this fact, we also include shards that have completed recovery. These shards, + * have received all old operations via the recovery mechanism and are kept up to date by the various replications actions. The set of, + * shards that are taken into account for the global checkpoint calculation are called the "in-sync shards".]