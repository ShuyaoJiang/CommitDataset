[+++ b/server/src/main/java/org/elasticsearch/transport/RemoteClusterAware.java, +import java.util.function.Supplier;, +    public static final Setting.AffixSetting<List<String>> REMOTE_CLUSTERS_SEEDS = Setting.affixKeySetting(, +        "search.remote.",, +        "seeds",, +        key -> Setting.listSetting(, +            key, Collections.emptyList(),, +            s -> {, +                // validate seed address, +                parsePort(s);, +                return s;, +            },, +            Setting.Property.NodeScope,, +            Setting.Property.Dynamic, +        ), +    );, +    protected static Map<String, List<Supplier<DiscoveryNode>>> buildRemoteClustersSeeds(Settings settings) {, +        Stream<Setting<List<String>>> allConcreteSettings = REMOTE_CLUSTERS_SEEDS.getAllConcreteSettings(settings);, +                List<String> addresses = concreteSetting.get(settings);, +                List<Supplier<DiscoveryNode>> nodes = new ArrayList<>(addresses.size());, +                for (String address : addresses) {, +                    nodes.add(() -> {, +                        TransportAddress transportAddress = new TransportAddress(RemoteClusterAware.parseSeedAddress(address));, +                        return new DiscoveryNode(clusterName + "#" + transportAddress.toString(),, +                    });, +    protected abstract void updateRemoteCluster(String clusterAlias, List<String> addresses);, +    protected static InetSocketAddress parseSeedAddress(String remoteHost) {, +        String host = remoteHost.substring(0, indexOfPortSeparator(remoteHost));, +        return new InetSocketAddress(hostAddress, parsePort(remoteHost));, +    }, +, +    private static int parsePort(String remoteHost) {, +            int port = Integer.valueOf(remoteHost.substring(indexOfPortSeparator(remoteHost) + 1));, +            return port;, +            throw new IllegalArgumentException("failed to parse port", e);, +    private static int indexOfPortSeparator(String remoteHost) {, +        int portSeparator = remoteHost.lastIndexOf(':'); // in case we have a IPv6 address ie. [::1]:9300, +        if (portSeparator == -1 || portSeparator == remoteHost.length()) {, +            throw new IllegalArgumentException("remote hosts need to be configured as [host:port], found [" + remoteHost + "] instead");, +        }, +        return portSeparator;, +    }, +, +++ b/server/src/main/java/org/elasticsearch/transport/RemoteClusterAware.java, +import java.util.function.Supplier;, +    public static final Setting.AffixSetting<List<String>> REMOTE_CLUSTERS_SEEDS = Setting.affixKeySetting(, +        "search.remote.",, +        "seeds",, +        key -> Setting.listSetting(, +            key, Collections.emptyList(),, +            s -> {, +                // validate seed address, +                parsePort(s);, +                return s;, +            },, +            Setting.Property.NodeScope,, +            Setting.Property.Dynamic, +        ), +    );, +    protected static Map<String, List<Supplier<DiscoveryNode>>> buildRemoteClustersSeeds(Settings settings) {, +        Stream<Setting<List<String>>> allConcreteSettings = REMOTE_CLUSTERS_SEEDS.getAllConcreteSettings(settings);, +                List<String> addresses = concreteSetting.get(settings);, +                List<Supplier<DiscoveryNode>> nodes = new ArrayList<>(addresses.size());, +                for (String address : addresses) {, +                    nodes.add(() -> {, +                        TransportAddress transportAddress = new TransportAddress(RemoteClusterAware.parseSeedAddress(address));, +                        return new DiscoveryNode(clusterName + "#" + transportAddress.toString(),, +                    });, +    protected abstract void updateRemoteCluster(String clusterAlias, List<String> addresses);, +    protected static InetSocketAddress parseSeedAddress(String remoteHost) {, +        String host = remoteHost.substring(0, indexOfPortSeparator(remoteHost));, +        return new InetSocketAddress(hostAddress, parsePort(remoteHost));, +    }, +, +    private static int parsePort(String remoteHost) {, +            int port = Integer.valueOf(remoteHost.substring(indexOfPortSeparator(remoteHost) + 1));, +            return port;, +            throw new IllegalArgumentException("failed to parse port", e);, +    private static int indexOfPortSeparator(String remoteHost) {, +        int portSeparator = remoteHost.lastIndexOf(':'); // in case we have a IPv6 address ie. [::1]:9300, +        if (portSeparator == -1 || portSeparator == remoteHost.length()) {, +            throw new IllegalArgumentException("remote hosts need to be configured as [host:port], found [" + remoteHost + "] instead");, +        }, +        return portSeparator;, +    }, +, +++ b/server/src/main/java/org/elasticsearch/transport/RemoteClusterConnection.java, +import java.util.function.Supplier;, +    private volatile List<Supplier<DiscoveryNode>> seedNodes;, +    RemoteClusterConnection(Settings settings, String clusterAlias, List<Supplier<DiscoveryNode>> seedNodes,, +    synchronized void updateSeedNodes(List<Supplier<DiscoveryNode>> seedNodes, ActionListener<Void> connectListener) {, +        private void collectRemoteNodes(Iterator<Supplier<DiscoveryNode>> seedNodes,, +                        final DiscoveryNode seedNode = seedNodes.next().get();, +            private final Iterator<Supplier<DiscoveryNode>> seedNodes;, +                                             ActionListener<Void> listener, Iterator<Supplier<DiscoveryNode>> seedNodes,, +        List<TransportAddress> seedNodeAddresses = seedNodes.stream().map(node -> node.get().getAddress()).collect(Collectors.toList());, +++ b/server/src/main/java/org/elasticsearch/transport/RemoteClusterAware.java, +import java.util.function.Supplier;, +    public static final Setting.AffixSetting<List<String>> REMOTE_CLUSTERS_SEEDS = Setting.affixKeySetting(, +        "search.remote.",]