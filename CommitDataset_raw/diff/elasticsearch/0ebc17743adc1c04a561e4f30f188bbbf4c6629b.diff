[+++ b/server/src/main/java/org/elasticsearch/search/aggregations/bucket/histogram/InternalDateHistogram.java, +        if (reduceContext.isFinalReduce()) {, +            if (InternalOrder.isKeyDesc(order)) {, +            } else if (InternalOrder.isKeyAsc(order) == false){, +                // nothing to do when sorting by key ascending, as data is already sorted since shards return, +                // sorted buckets and the merge-sort performed by reduceBuckets maintains order., +                // otherwise, sorted by compound order or sub-aggregation, we need to fall back to a costly n*log(n) sort, +        }, +++ b/server/src/main/java/org/elasticsearch/search/aggregations/bucket/histogram/InternalDateHistogram.java, +        if (reduceContext.isFinalReduce()) {, +            if (InternalOrder.isKeyDesc(order)) {, +            } else if (InternalOrder.isKeyAsc(order) == false){, +                // nothing to do when sorting by key ascending, as data is already sorted since shards return, +                // sorted buckets and the merge-sort performed by reduceBuckets maintains order., +                // otherwise, sorted by compound order or sub-aggregation, we need to fall back to a costly n*log(n) sort, +        }, +++ b/server/src/main/java/org/elasticsearch/search/aggregations/bucket/histogram/InternalHistogram.java, +        if (reduceContext.isFinalReduce()) {, +            if (InternalOrder.isKeyDesc(order)) {, +            } else if (InternalOrder.isKeyAsc(order) ==  false){, +                // nothing to do when sorting by key ascending, as data is already sorted since shards return, +                // sorted buckets and the merge-sort performed by reduceBuckets maintains order., +                // otherwise, sorted by compound order or sub-aggregation, we need to fall back to a costly n*log(n) sort, +        }, +++ b/server/src/main/java/org/elasticsearch/search/aggregations/bucket/histogram/InternalDateHistogram.java, +        if (reduceContext.isFinalReduce()) {, +            if (InternalOrder.isKeyDesc(order)) {, +            } else if (InternalOrder.isKeyAsc(order) == false){, +                // nothing to do when sorting by key ascending, as data is already sorted since shards return, +                // sorted buckets and the merge-sort performed by reduceBuckets maintains order., +                // otherwise, sorted by compound order or sub-aggregation, we need to fall back to a costly n*log(n) sort, +        }, +++ b/server/src/main/java/org/elasticsearch/search/aggregations/bucket/histogram/InternalHistogram.java, +        if (reduceContext.isFinalReduce()) {, +            if (InternalOrder.isKeyDesc(order)) {, +            } else if (InternalOrder.isKeyAsc(order) ==  false){, +                // nothing to do when sorting by key ascending, as data is already sorted since shards return, +                // sorted buckets and the merge-sort performed by reduceBuckets maintains order., +                // otherwise, sorted by compound order or sub-aggregation, we need to fall back to a costly n*log(n) sort, +        }, +++ b/test/framework/src/main/java/org/elasticsearch/test/InternalAggregationTestCase.java, +import org.elasticsearch.search.aggregations.pipeline.ExtendedStatsBucketPipelineAggregationBuilder;, +import org.elasticsearch.search.aggregations.pipeline.InternalBucketMetricValue;, +import org.elasticsearch.search.aggregations.pipeline.InternalSimpleValue;, +import org.elasticsearch.search.aggregations.pipeline.ParsedBucketMetricValue;, +import org.elasticsearch.search.aggregations.pipeline.ParsedExtendedStatsBucket;, +import org.elasticsearch.search.aggregations.pipeline.ParsedPercentilesBucket;, +import org.elasticsearch.search.aggregations.pipeline.ParsedSimpleValue;, +import org.elasticsearch.search.aggregations.pipeline.ParsedStatsBucket;, +import org.elasticsearch.search.aggregations.pipeline.PercentilesBucketPipelineAggregationBuilder;, +import org.elasticsearch.search.aggregations.pipeline.PipelineAggregator;, +import org.elasticsearch.search.aggregations.pipeline.StatsBucketPipelineAggregationBuilder;, +import static org.hamcrest.Matchers.lessThanOrEqualTo;, +            int initialBucketCount = 0;, +            for (InternalAggregation internalAggregation : internalAggregations) {, +                initialBucketCount += countInnerBucket(internalAggregation);, +            }, +            int reducedBucketCount = countInnerBucket(reduced);, +            //check that non final reduction never adds buckets, +            assertThat(reducedBucketCount, lessThanOrEqualTo(initialBucketCount));, +            assertMultiBucketConsumer(reducedBucketCount, bucketConsumer);, +        final ParsedAggregation parsedAggregation = parseAndAssert(aggregation, randomBoolean(), false);, +        assertFromXContent(aggregation, parsedAggregation);, +        final ParsedAggregation parsedAggregation = parseAndAssert(aggregation, randomBoolean(), true);, +        assertFromXContent(aggregation, parsedAggregation);, +        assertMultiBucketConsumer(countInnerBucket(agg), bucketConsumer);, +    }, +, +    private static void assertMultiBucketConsumer(int innerBucketCount, MultiBucketConsumer bucketConsumer) {, +        assertThat(bucketConsumer.getCount(), equalTo(innerBucketCount));]