[+++ b/core/src/main/java/org/elasticsearch/cluster/routing/allocation/allocator/BalancedShardsAllocator.java, +     * Returns a decision on rebalancing a single shard to form a more optimal cluster balance.  This, +     * method is not used in itself for cluster rebalancing because all shards from all indices are, +     * taken into account when making rebalancing decisions.  This method is only intended to be used, +     * from the cluster allocation explain API to explain possible rebalancing decisions for a single, +     * shard., +     */, +    public RebalanceDecision decideRebalance(final ShardRouting shard, final RoutingAllocation allocation) {, +        assert allocation.debugDecision() : "debugDecision should be set in explain mode";, +        return new Balancer(logger, allocation, weightFunction, threshold).decideRebalance(shard);, +    }, +, +    /**, +        /**, +         * The absolute value difference between two weights., +         */, +        /**, +         * Returns {@code true} iff the weight delta between two nodes is under a defined threshold., +         * See {@link #THRESHOLD_SETTING} for defining the threshold., +         */, +        /**, +         * Makes a decision about moving a single shard to a different node to form a more, +         * optimally balanced cluster.  This method is invoked from the cluster allocation, +         * explain API only., +         */, +        private RebalanceDecision decideRebalance(final ShardRouting shard) {, +            if (shard.started() == false) {, +                // cannot rebalance a shard that isn't started, +                return RebalanceDecision.NOT_TAKEN;, +            }, +, +            Decision canRebalance = allocation.deciders().canRebalance(shard, allocation);, +, +            if (allocation.hasPendingAsyncFetch()) {, +                return new RebalanceDecision(, +                    canRebalance,, +                    Type.NO,, +                    "cannot rebalance due to in-flight shard store fetches, otherwise allocation may prematurely rebalance a shard to " +, +                        "a node that is soon to receive another shard assignment upon completion of the shard store fetch, " +, +                        "rendering the cluster imbalanced again", +                );, +            }, +, +            sorter.reset(shard.getIndexName());, +            ModelNode[] modelNodes = sorter.modelNodes;, +            final String currentNodeId = shard.currentNodeId();, +            // find currently assigned node, +            ModelNode currentNode = null;, +            for (ModelNode node : modelNodes) {, +                if (node.getNodeId().equals(currentNodeId)) {, +                    currentNode = node;, +                    break;, +                }, +            }, +            assert currentNode != null : "currently assigned node could not be found";, +, +            // balance the shard, if a better node can be found, +            final float currentWeight = sorter.weight(currentNode);, +            final AllocationDeciders deciders = allocation.deciders();, +            final String idxName = shard.getIndexName();, +            Map<String, NodeRebalanceDecision> nodeDecisions = new HashMap<>(modelNodes.length - 1);, +            Type rebalanceDecisionType = Type.NO;, +            String assignedNodeId = null;, +            for (ModelNode node : modelNodes) {, +                if (node == currentNode) {, +                    continue; // skip over node we're currently allocated to it, +                }, +                final Decision canAllocate = deciders.canAllocate(shard, node.getRoutingNode(), allocation);, +                // the current weight of the node in the cluster, as computed by the weight function;, +                // this is a comparison of the number of shards on this node to the number of shards, +                // that should be on each node on average (both taking the cluster as a whole into account, +                // as well as shards per index), +                final float nodeWeight = sorter.weight(node);, +                // if the node we are examining has a worse (higher) weight than the node the shard is, +                // assigned to, then there is no way moving the shard to the node with the worse weight, +                // can make the balance of the cluster better, so we check for that here, +                final boolean betterWeightThanCurrent = nodeWeight <= currentWeight;, +                boolean rebalanceConditionsMet = false;, +                boolean deltaAboveThreshold = false;, +                float weightWithShardAdded = Float.POSITIVE_INFINITY;, +                if (betterWeightThanCurrent) {, +                    // get the delta between the weights of the node we are checking and the node that holds the shard, +                    final float currentDelta = absDelta(nodeWeight, currentWeight);, +                    // checks if the weight delta is above a certain threshold; if it is not above a certain threshold,, +                    // then even though the node we are examining has a better weight and may make the cluster balance, +                    // more even, it doesn't make sense to execute the heavyweight operation of relocating a shard unless, +                    // the gains make it worth it, as defined by the threshold, +                    deltaAboveThreshold = lessThan(currentDelta, threshold) == false;, +                    // simulate the weight of the node if we were to relocate the shard to it, +                    weightWithShardAdded = weight.weightShardAdded(this, node, idxName);, +                    // calculate the delta of the weights of the two nodes if we were to add the shard to the, +                    // node in question and move it away from the node that currently holds it., +                    final float proposedDelta = weightWithShardAdded - weight.weightShardRemoved(this, currentNode, idxName);, +                    rebalanceConditionsMet = deltaAboveThreshold && proposedDelta < currentDelta;, +                    // if the simulated weight delta with the shard moved away is better than the weight delta, +                    // with the shard remaining on the current node, and we are allowed to allocate to the, +                    // node in question, then allow the rebalance, +                    if (rebalanceConditionsMet && canAllocate.type().higherThan(rebalanceDecisionType)) {, +                        // rebalance to the node, only will get overwritten if the decision here is to, +                        // THROTTLE and we get a decision with YES on another node]