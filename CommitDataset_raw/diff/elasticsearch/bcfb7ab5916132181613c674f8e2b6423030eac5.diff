[+++ b/modules/percolator/src/main/java/org/elasticsearch/percolator/QueryAnalyzer.java, +import java.util.Comparator;, +import java.util.stream.Collectors;, +                            // In case that there are duplicate query extractions we need to be careful with incrementing msm,, +                            // because that could lead to valid matches not becoming candidate matches:, +                            // query: (field:val1 AND field:val2) AND (field:val2 AND field:val3), +                            // doc:   field: val1 val2 val3, +                            // So lets be protective and decrease the msm:, +                            int resultMsm = result.minimumShouldMatch;, +                            for (QueryExtraction queryExtraction : result.extractions) {, +                                if (queryExtraction.range != null) {, +                                    if (seenRangeFields.add(queryExtraction.range.fieldName)) {, +                                        resultMsm = 1;, +                                        resultMsm = 0;, +                                    }, +                                }, +, +, +        List<DisjunctionClause> clauses = new ArrayList<>(disjunctions.size());, +                if (terms.add(extraction) == false) {, +                    resultMsm = Math.max(0, resultMsm - 1);, +            clauses.add(new DisjunctionClause(resultMsm, subResult.extractions.stream(), +                .filter(extraction -> extraction.range != null), +                .map(extraction -> extraction.range.fieldName), +                .collect(toSet())));, +            clauses = clauses.stream(), +                .filter(o -> o.msm > 0), +                .sorted(Comparator.comparingInt(o -> o.msm)), +                .collect(Collectors.toList());, +            int limit = Math.min(clauses.size(), Math.max(1, requiredShouldClauses));, +                if (clauses.get(i).rangeFieldNames.isEmpty() == false) {, +                    for (String rangeField: clauses.get(i).rangeFieldNames) {, +                        if (seenRangeFields.add(rangeField)) {, +                    }, +                    msm += clauses.get(i).msm;, +    static class DisjunctionClause {, +, +        final int msm;, +        final Set<String> rangeFieldNames;, +, +        DisjunctionClause(int msm, Set<String> rangeFieldNames) {, +            this.msm = msm;, +            this.rangeFieldNames = rangeFieldNames;, +        }, +    }, +, +++ b/modules/percolator/src/main/java/org/elasticsearch/percolator/QueryAnalyzer.java, +import java.util.Comparator;, +import java.util.stream.Collectors;, +                            // In case that there are duplicate query extractions we need to be careful with incrementing msm,, +                            // because that could lead to valid matches not becoming candidate matches:, +                            // query: (field:val1 AND field:val2) AND (field:val2 AND field:val3), +                            // doc:   field: val1 val2 val3, +                            // So lets be protective and decrease the msm:, +                            int resultMsm = result.minimumShouldMatch;, +                            for (QueryExtraction queryExtraction : result.extractions) {, +                                if (queryExtraction.range != null) {, +                                    if (seenRangeFields.add(queryExtraction.range.fieldName)) {, +                                        resultMsm = 1;, +                                        resultMsm = 0;, +                                    }, +                                }, +, +, +        List<DisjunctionClause> clauses = new ArrayList<>(disjunctions.size());, +                if (terms.add(extraction) == false) {, +                    resultMsm = Math.max(0, resultMsm - 1);, +            clauses.add(new DisjunctionClause(resultMsm, subResult.extractions.stream(), +                .filter(extraction -> extraction.range != null), +                .map(extraction -> extraction.range.fieldName), +                .collect(toSet())));, +            clauses = clauses.stream(), +                .filter(o -> o.msm > 0), +                .sorted(Comparator.comparingInt(o -> o.msm)), +                .collect(Collectors.toList());, +            int limit = Math.min(clauses.size(), Math.max(1, requiredShouldClauses));, +                if (clauses.get(i).rangeFieldNames.isEmpty() == false) {, +                    for (String rangeField: clauses.get(i).rangeFieldNames) {, +                        if (seenRangeFields.add(rangeField)) {, +                    }, +                    msm += clauses.get(i).msm;, +    static class DisjunctionClause {, +, +        final int msm;, +        final Set<String> rangeFieldNames;, +, +        DisjunctionClause(int msm, Set<String> rangeFieldNames) {, +            this.msm = msm;, +            this.rangeFieldNames = rangeFieldNames;, +        }, +    }, +, +++ b/modules/percolator/src/test/java/org/elasticsearch/percolator/CandidateQueryTests.java, +import org.apache.lucene.document.StoredField;, +import org.apache.lucene.index.MultiDocValues;, +import org.apache.lucene.index.NumericDocValues;, +import org.elasticsearch.common.geo.ShapeRelation;, +import org.elasticsearch.index.mapper.MappedFieldType;, +import org.elasticsearch.index.mapper.NumberFieldMapper;, +        Map<String, List<String>> stringContent = new HashMap<>();]