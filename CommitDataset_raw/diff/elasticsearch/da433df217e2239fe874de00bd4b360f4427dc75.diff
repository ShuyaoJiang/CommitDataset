[+++ b/src/main/java/org/elasticsearch/common/xcontent/XContentType.java, +, +        @Override, +        public String shortName() {, +            return "json";, +        }, +, +        @Override, +        public String shortName() {, +            return "smile";, +        }, +, +    public abstract String shortName();, +++ b/src/main/java/org/elasticsearch/common/xcontent/XContentType.java, +, +        @Override, +        public String shortName() {, +            return "json";, +        }, +, +        @Override, +        public String shortName() {, +            return "smile";, +        }, +, +    public abstract String shortName();, +++ b/src/main/java/org/elasticsearch/common/xcontent/json/JsonXContentGenerator.java, +        // the start of the parser, +        if (parser.currentToken() == null) {, +            parser.nextToken();, +        }, +++ b/src/main/java/org/elasticsearch/common/xcontent/XContentType.java, +, +        @Override, +        public String shortName() {, +            return "json";, +        }, +, +        @Override, +        public String shortName() {, +            return "smile";, +        }, +, +    public abstract String shortName();, +++ b/src/main/java/org/elasticsearch/common/xcontent/json/JsonXContentGenerator.java, +        // the start of the parser, +        if (parser.currentToken() == null) {, +            parser.nextToken();, +        }, +++ b/src/main/java/org/elasticsearch/index/mapper/internal/SourceFieldMapper.java, +import com.google.common.base.Objects;, +import org.elasticsearch.common.io.stream.*;, +import static org.elasticsearch.common.xcontent.support.XContentMapValues.nodeStringValue;, +        public static final String FORMAT = null; // default format is to use the one provided, +        private String format = Defaults.FORMAT;, +, +        public Builder format(String format) {, +            this.format = format;, +            return this;, +        }, +, +            return new SourceFieldMapper(name, enabled, format, compress, compressThreshold, includes, excludes);, +                } else if ("format".equals(fieldName)) {, +                    builder.format(nodeStringValue(fieldNode, null));, +    private String format;, +, +    private XContentType formatContentType;, +, +        this(Defaults.NAME, Defaults.ENABLED, Defaults.FORMAT, null, -1, Defaults.INCLUDES, Defaults.EXCLUDES);, +    protected SourceFieldMapper(String name, boolean enabled, String format, Boolean compress, long compressThreshold, String[] includes, String[] excludes) {, +        this.format = format;, +        this.formatContentType = format == null ? null : XContentType.fromRestContentType(format);, +            XContentType contentType = formatContentType;, +            if (contentType == null) {, +                contentType = mapTuple.v1();, +            }, +            XContentBuilder builder = XContentFactory.contentBuilder(contentType, streamOutput).map(filteredSource);, +                try {, +                    XContentType contentType = XContentFactory.xContentType(data, dataOffset, dataLength);, +                    if (formatContentType != null && formatContentType != contentType) {, +                        XContentBuilder builder = XContentFactory.contentBuilder(formatContentType, cachedEntry.cachedLZFBytes());, +                        builder.copyCurrentStructure(XContentFactory.xContent(contentType).createParser(data, dataOffset, dataLength));, +                        builder.close();, +                    } else {, +                    }, +                } finally {, +                    CachedStreamOutput.pushEntry(cachedEntry);, +                }, +            }, +        } else if (formatContentType != null) {, +            // see if we need to convert the content type, +            if (LZF.isCompressed(data, dataOffset, dataLength)) {, +                BytesStreamInput siBytes = new BytesStreamInput(data, dataOffset, dataLength, false);, +                LZFStreamInput siLzf = CachedStreamInput.cachedLzf(siBytes);, +                XContentType contentType = XContentFactory.xContentType(siLzf);, +                siLzf.resetToBufferStart();, +                if (contentType != formatContentType) {, +                    // we need to reread and store back, compressed...., +                    CachedStreamOutput.Entry cachedEntry = CachedStreamOutput.popEntry();, +                    try {]