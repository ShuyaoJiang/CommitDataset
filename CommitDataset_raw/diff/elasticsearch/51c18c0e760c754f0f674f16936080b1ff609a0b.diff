[+++ b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ssl/SSLService.java, +import java.util.function.Supplier;, +        final SSLContextHolder contextHolder = sslContextHolder(configuration);, +        SSLSocketFactory socketFactory = contextHolder.sslContext().getSocketFactory();, +        final SecuritySSLSocketFactory securitySSLSocketFactory = new SecuritySSLSocketFactory(, +            () -> contextHolder.sslContext().getSocketFactory(),, +            configuration.supportedProtocols().toArray(Strings.EMPTY_ARRAY),, +        contextHolder.addReloadListener(securitySSLSocketFactory::reload);, +        return securitySSLSocketFactory;, +        private final Supplier<SSLSocketFactory> delegateSupplier;, +        private volatile SSLSocketFactory delegate;, +, +        SecuritySSLSocketFactory(Supplier<SSLSocketFactory> delegateSupplier, String[] supportedProtocols, String[] ciphers) {, +            this.delegateSupplier = delegateSupplier;, +            this.delegate = this.delegateSupplier.get();, +        public void reload() {, +            final SSLSocketFactory newDelegate = delegateSupplier.get();, +            this.delegate = newDelegate;, +        }, +, +        private final List<Runnable> reloadListeners;, +            this.reloadListeners = new ArrayList<>();, +            this.reloadListeners.forEach(Runnable::run);, +, +        public void addReloadListener(Runnable listener) {, +            this.reloadListeners.add(listener);, +        }, +++ b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ssl/SSLService.java, +import java.util.function.Supplier;, +        final SSLContextHolder contextHolder = sslContextHolder(configuration);, +        SSLSocketFactory socketFactory = contextHolder.sslContext().getSocketFactory();, +        final SecuritySSLSocketFactory securitySSLSocketFactory = new SecuritySSLSocketFactory(, +            () -> contextHolder.sslContext().getSocketFactory(),, +            configuration.supportedProtocols().toArray(Strings.EMPTY_ARRAY),, +        contextHolder.addReloadListener(securitySSLSocketFactory::reload);, +        return securitySSLSocketFactory;, +        private final Supplier<SSLSocketFactory> delegateSupplier;, +        private volatile SSLSocketFactory delegate;, +, +        SecuritySSLSocketFactory(Supplier<SSLSocketFactory> delegateSupplier, String[] supportedProtocols, String[] ciphers) {, +            this.delegateSupplier = delegateSupplier;, +            this.delegate = this.delegateSupplier.get();, +        public void reload() {, +            final SSLSocketFactory newDelegate = delegateSupplier.get();, +            this.delegate = newDelegate;, +        }, +, +        private final List<Runnable> reloadListeners;, +            this.reloadListeners = new ArrayList<>();, +            this.reloadListeners.forEach(Runnable::run);, +, +        public void addReloadListener(Runnable listener) {, +            this.reloadListeners.add(listener);, +        }, +++ b/x-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/authc/ldap/LdapSessionFactoryTests.java, +import org.elasticsearch.env.Environment;, +import org.elasticsearch.watcher.ResourceWatcherService;, +import org.elasticsearch.xpack.core.ssl.SSLConfigurationReloader;, +import java.nio.file.Files;, +import java.nio.file.Path;, +import java.nio.file.StandardCopyOption;, +    private Path ldapCaPath;, +, +    @Override, +    protected boolean openLdapsPort() {, +        // Support LDAPS, because it's used in some test, +        return true;, +    }, +        final Path origCa = getDataPath("/org/elasticsearch/xpack/security/authc/ldap/support/ldap-ca.crt");, +        ldapCaPath = createTempFile();, +        Files.copy(origCa, ldapCaPath, StandardCopyOption.REPLACE_EXISTING);, +        globalSettings = Settings.builder(), +            .put("path.home", createTempDir()), +            .putList(RealmSettings.realmSslPrefix(REALM_IDENTIFIER) + "certificate_authorities", ldapCaPath.toString()), +            .build();, +        String protocol = randomFrom("ldap", "ldaps");, +        String ldapUrl = new LDAPURL(protocol, "localhost", ldapServer.getListenPort(protocol), null, null, null, null).toString();, +, +    /**, +     * This test connects to the in memory LDAP server over SSL using 2 different CA certificates., +     * One certificate is valid, the other is not., +     * The path to the certificate never changes, but the contents are copied in place., +     * If the realm's CA path is monitored for changes and the underlying SSL context is reloaded, then we will get two different outcomes, +     * (one failure, one success) depending on which file content is in place., +     */, +    public void testSslTrustIsReloaded() throws Exception {, +        InMemoryDirectoryServer ldapServer = randomFrom(ldapServers);, +        String ldapUrl = new LDAPURL("ldaps", "localhost", ldapServer.getListenPort("ldaps"), null, null, null, null).toString();, +        String groupSearchBase = "o=sevenSeas";, +        String userTemplates = "cn={0},ou=people,o=sevenSeas";, +, +        Settings settings = Settings.builder(), +            .put(globalSettings), +            .put(buildLdapSettings(ldapUrl, userTemplates, groupSearchBase, LdapSearchScope.SUB_TREE)), +            .build();, +, +        final Path realCa = getDataPath("/org/elasticsearch/xpack/security/authc/ldap/support/ldap-ca.crt");, +        final Path fakeCa = getDataPath("/org/elasticsearch/xpack/security/authc/ldap/support/smb_ca.crt");, +, +        final Environment environment = TestEnvironment.newEnvironment(settings);]