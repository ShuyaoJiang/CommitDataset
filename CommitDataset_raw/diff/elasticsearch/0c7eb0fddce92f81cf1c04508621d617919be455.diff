[+++ b/src/main/java/org/elasticsearch/index/query/IdsQueryBuilder.java, +import com.google.common.collect.Iterables;, +, +import org.apache.lucene.queries.TermsQuery;, +import org.apache.lucene.search.Query;, +import org.apache.lucene.util.BytesRef;, +import org.elasticsearch.common.io.stream.StreamInput;, +import org.elasticsearch.common.io.stream.StreamOutput;, +import org.elasticsearch.common.io.stream.Streamable;, +import org.elasticsearch.common.lucene.search.Queries;, +import org.elasticsearch.index.mapper.Uid;, +import org.elasticsearch.index.mapper.internal.UidFieldMapper;, +import java.util.Collection;, +import java.util.Objects;, +public class IdsQueryBuilder extends BaseQueryBuilder implements Streamable, BoostableQueryBuilder<IdsQueryBuilder> {, +    private List<String> types = new ArrayList<>();, +    private List<String> ids = new ArrayList<>();, +    private float boost = 1.0f;, +        this.types = (types == null || types.length == 0) ? new ArrayList<String>() : Arrays.asList(types);, +     * Get the types used in this query, +     * @return the types, +     */, +    public Collection<String> types() {, +        return this.types;, +    }, +, +    /**, +     * Adds ids to the query., +        this.ids.addAll(Arrays.asList(ids));, +     * Adds ids to the query., +     * Gets the ids for the query., +     */, +    public Collection<String> ids() {, +        return this.ids;, +    }, +, +    /**, +     * Gets the boost for this query., +     */, +    public float boost() {, +        return this.boost;, +    }, +, +    /**, +     * Sets the query name for the query that can be used when searching for matched_filters per hit., +    /**, +     * Gets the query name for the query., +     */, +    public String queryName() {, +        return this.queryName;, +    }, +, +                for (String type : types) {, +        for (String value : ids) {, +, +    public Query toQuery(QueryParseContext parseContext) throws IOException, QueryParsingException {, +        if (this.ids.isEmpty()) {, +            return Queries.newMatchNoDocsQuery();, +        }, +, +        Collection<String> typesForQuery = this.types;, +        if (typesForQuery == null || typesForQuery.isEmpty()) {, +            typesForQuery = parseContext.queryTypes();, +        } else if (typesForQuery.size() == 1 && Iterables.getFirst(typesForQuery, null).equals("_all")) {, +            typesForQuery = parseContext.mapperService().types();, +        }, +, +        TermsQuery query = new TermsQuery(UidFieldMapper.NAME, Uid.createTypeUids(typesForQuery, ids));, +        query.setBoost(boost);, +        if (queryName != null) {, +            parseContext.addNamedQuery(queryName, query);, +        }, +        return query;, +    }, +, +    @Override, +    public QueryValidationException validate() {, +        // all fields can be empty or null, +        return null;, +    }, +, +    @Override, +    public void readFrom(StreamInput in) throws IOException {, +        this.types = in.readStringList();, +        this.ids = in.readStringList();, +        queryName = in.readOptionalString();, +        boost = in.readFloat();, +    }, +, +    @Override, +    public void writeTo(StreamOutput out) throws IOException {, +        out.writeStringList(this.types);, +        out.writeStringList(this.ids);, +        out.writeOptionalString(queryName);, +        out.writeFloat(boost);, +    }, +, +    @Override, +    public int hashCode() {, +        return Objects.hash(ids, types, boost, queryName);]