[+++ b/core/src/main/java/org/elasticsearch/cluster/ClusterChangedEvent.java, +import java.util.Objects;, + * An event received by the local node, signaling that the cluster state has changed., +        Objects.requireNonNull(source, "source must not be null");, +        Objects.requireNonNull(state, "state must not be null");, +        Objects.requireNonNull(previousState, "previousState must not be null");, +    /**, +     * The new cluster state that caused this change event., +     */, +    /**, +     * The previous cluster state for this change event., +     */, +    /**, +     * Returns <code>true</code> iff the routing tables (for all indices) have, +     * changed between the previous cluster state and the current cluster state., +     * Note that this is an object reference equality test, not an equals test., +     */, +    /**, +     * Returns <code>true</code> iff the routing table has changed for the given index., +     * Note that this is an object reference equality test, not an equals test., +     */, +        Objects.requireNonNull(index, "index must not be null");, +        // If the new cluster state has a new cluster UUID, the likely scenario is that a node was elected, +        // master that has had its data directory wiped out, in which case we don't want to delete the indices and lose data;, +        // rather we want to import them as dangling indices instead.  So we check here if the cluster UUID differs from the previous, +        // cluster UUID, in which case, we don't want to delete indices that the master erroneously believes shouldn't exist., +        // See test DiscoveryWithServiceDisruptionsIT.testIndicesDeleted(), +        if (metaDataChanged() == false || isNewCluster()) {, +    /**, +     * Returns <code>true</code> iff the metadata for the cluster has changed between, +     * the previous cluster state and the new cluster state. Note that this is an object, +     * reference equality test, not an equals test., +     */, +    /**, +     * Returns <code>true</code> iff the {@link IndexMetaData} for a given index, +     * has changed between the previous cluster state and the new cluster state., +     * Note that this is an object reference equality test, not an equals test., +     */, +    /**, +     * Returns <code>true</code> iff the cluster level blocks have changed between cluster states., +     * Note that this is an object reference equality test, not an equals test., +     */, +    /**, +     * Returns <code>true</code> iff the local node is the mater node of the cluster., +     */, +    /**, +     * Returns the {@link org.elasticsearch.cluster.node.DiscoveryNodes.Delta} between, +     * the previous cluster state and the new cluster state., +     */, +    /**, +     * Returns <code>true</code> iff nodes have been removed from the cluster since the last cluster state., +     */, +    /**, +     * Returns <code>true</code> iff nodes have been added from the cluster since the last cluster state., +     */, +    /**, +     * Returns <code>true</code> iff nodes have been changed (added or removed) from the cluster since the last cluster state., +     */, +    // Determines whether or not the current cluster state represents an entirely, +    // different cluster from the previous cluster state, which will happen when a, +    // master node is elected that has never been part of the cluster before., +    private boolean isNewCluster() {, +        final String prevClusterUUID = previousState.metaData().clusterUUID();, +        final String currClusterUUID = state.metaData().clusterUUID();, +        return prevClusterUUID.equals(currClusterUUID) == false;, +++ b/core/src/main/java/org/elasticsearch/cluster/ClusterChangedEvent.java, +import java.util.Objects;, + * An event received by the local node, signaling that the cluster state has changed., +        Objects.requireNonNull(source, "source must not be null");, +        Objects.requireNonNull(state, "state must not be null");, +        Objects.requireNonNull(previousState, "previousState must not be null");, +    /**, +     * The new cluster state that caused this change event., +     */, +    /**, +     * The previous cluster state for this change event., +     */, +    /**, +     * Returns <code>true</code> iff the routing tables (for all indices) have, +     * changed between the previous cluster state and the current cluster state., +     * Note that this is an object reference equality test, not an equals test., +     */, +    /**, +     * Returns <code>true</code> iff the routing table has changed for the given index., +     * Note that this is an object reference equality test, not an equals test., +     */, +        Objects.requireNonNull(index, "index must not be null");, +        // If the new cluster state has a new cluster UUID, the likely scenario is that a node was elected, +        // master that has had its data directory wiped out, in which case we don't want to delete the indices and lose data;, +        // rather we want to import them as dangling indices instead.  So we check here if the cluster UUID differs from the previous, +        // cluster UUID, in which case, we don't want to delete indices that the master erroneously believes shouldn't exist., +        // See test DiscoveryWithServiceDisruptionsIT.testIndicesDeleted(), +        if (metaDataChanged() == false || isNewCluster()) {, +    /**, +     * Returns <code>true</code> iff the metadata for the cluster has changed between, +     * the previous cluster state and the new cluster state. Note that this is an object, +     * reference equality test, not an equals test., +     */, +    /**, +     * Returns <code>true</code> iff the {@link IndexMetaData} for a given index]