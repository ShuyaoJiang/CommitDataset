[+++ b/src/main/java/org/elasticsearch/action/bulk/BulkRequestBuilder.java, +++ b/src/main/java/org/elasticsearch/action/bulk/BulkRequestBuilder.java, +++ b/src/main/java/org/elasticsearch/action/bulk/BulkShardRequest.java, +                // if we are serializing to a node that is pre 1.3.3, make sure to pass null to maintain, +                // the old behavior of putting null in the request to be ignored on the replicas, +                if (item.isIgnoreOnReplica() && out.getVersion().before(Version.V_1_3_3)) {, +                    out.writeBoolean(false);, +                } else {, +                }, +++ b/src/main/java/org/elasticsearch/action/bulk/BulkRequestBuilder.java, +++ b/src/main/java/org/elasticsearch/action/bulk/BulkShardRequest.java, +                // if we are serializing to a node that is pre 1.3.3, make sure to pass null to maintain, +                // the old behavior of putting null in the request to be ignored on the replicas, +                if (item.isIgnoreOnReplica() && out.getVersion().before(Version.V_1_3_3)) {, +                    out.writeBoolean(false);, +                } else {, +                }, +++ b/src/main/java/org/elasticsearch/action/bulk/TransportShardBulkAction.java, +import org.elasticsearch.action.ActionWriteResponse;, +import org.elasticsearch.common.compress.CompressedString;, +import org.elasticsearch.index.mapper.MapperService;, +import org.elasticsearch.river.RiverIndexName;, +        IndexService indexService = indicesService.indexServiceSafe(request.index());, +        IndexShard indexShard = indexService.shardSafe(shardRequest.shardId.id());, +                    WriteResult result = shardIndexOperation(request, indexRequest, clusterState, indexShard, indexService, true);, +                    DeleteResponse deleteResponse = shardDeleteOperation(request, deleteRequest, indexShard).response();, +                        updateResult = shardUpdateOperation(clusterState, request, updateRequest, indexShard, indexService);, +                                WriteResult result = updateResult.writeResult;, +                                DeleteResponse response = updateResult.writeResult.response();, +        if (request.refresh()) {, +            try {, +                indexShard.refresh("refresh_flag_bulk");, +            } catch (Throwable e) {, +                // ignore, +            }, +        }, +    static class WriteResult {, +, +        final ActionWriteResponse response;, +, +        WriteResult(ActionWriteResponse response) {, +            this.response = response;, +        }, +, +        @SuppressWarnings("unchecked"), +        <T extends ActionWriteResponse> T response() {, +            // this sets total, pending and failed to 0 and this is ok, because we will embed this into the replica, +            // request and not use it, +            response.setShardInfo(new ActionWriteResponse.ShardInfo());, +            return (T) response;, +        }, +, +    }, +, +                                            IndexShard indexShard, IndexService indexService, boolean processed) throws Throwable {, +        final IndexResponse response = executeIndexRequestOnPrimary(request, indexRequest, indexShard);, +        return new WriteResult(response);, +    private WriteResult shardDeleteOperation(BulkShardRequest request, DeleteRequest deleteRequest, IndexShard indexShard) {, +        return new WriteResult(deleteResponse);, +    private UpdateResult shardUpdateOperation(ClusterState clusterState, BulkShardRequest bulkShardRequest, UpdateRequest updateRequest, IndexShard indexShard, IndexService indexService) {, +                    WriteResult result = shardIndexOperation(bulkShardRequest, indexRequest, clusterState, indexShard, indexService, false);, +++ b/src/main/java/org/elasticsearch/action/bulk/BulkRequestBuilder.java, +++ b/src/main/java/org/elasticsearch/action/bulk/BulkShardRequest.java, +                // if we are serializing to a node that is pre 1.3.3, make sure to pass null to maintain, +                // the old behavior of putting null in the request to be ignored on the replicas, +                if (item.isIgnoreOnReplica() && out.getVersion().before(Version.V_1_3_3)) {, +                    out.writeBoolean(false);, +                } else {, +                }, +++ b/src/main/java/org/elasticsearch/action/bulk/TransportShardBulkAction.java, +import org.elasticsearch.action.ActionWriteResponse;, +import org.elasticsearch.common.compress.CompressedString;, +import org.elasticsearch.index.mapper.MapperService;, +import org.elasticsearch.river.RiverIndexName;, +        IndexService indexService = indicesService.indexServiceSafe(request.index());, +        IndexShard indexShard = indexService.shardSafe(shardRequest.shardId.id());, +                    WriteResult result = shardIndexOperation(request, indexRequest, clusterState, indexShard, indexService, true);, +                    DeleteResponse deleteResponse = shardDeleteOperation(request, deleteRequest, indexShard).response();, +                        updateResult = shardUpdateOperation(clusterState, request, updateRequest, indexShard, indexService);, +                                WriteResult result = updateResult.writeResult;, +                                DeleteResponse response = updateResult.writeResult.response();, +        if (request.refresh()) {, +            try {, +                indexShard.refresh("refresh_flag_bulk");, +            } catch (Throwable e) {, +                // ignore, +            }, +        }, +    static class WriteResult {, +, +        final ActionWriteResponse response;, +, +        WriteResult(ActionWriteResponse response) {, +            this.response = response;, +        }, +, +        @SuppressWarnings("unchecked"), +        <T extends ActionWriteResponse> T response() {, +            // this sets total, pending and failed to 0 and this is ok, because we will embed this into the replica, +            // request and not use it]