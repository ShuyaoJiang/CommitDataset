[+++ b/server/src/main/java/org/elasticsearch/transport/RemoteClusterConnection.java, +import org.elasticsearch.action.support.ContextPreservingActionListener;, +            final ActionListener<Void> listener = connectListener == null ? null :, +                ContextPreservingActionListener.wrapPreservingContext(connectListener, transportService.getThreadPool().getThreadContext());, +                if (listener != null && queue.offer(listener) == false) {, +                    listener.onFailure(new RejectedExecutionException("connect queue is full"));, +++ b/server/src/main/java/org/elasticsearch/transport/RemoteClusterConnection.java, +import org.elasticsearch.action.support.ContextPreservingActionListener;, +            final ActionListener<Void> listener = connectListener == null ? null :, +                ContextPreservingActionListener.wrapPreservingContext(connectListener, transportService.getThreadPool().getThreadContext());, +                if (listener != null && queue.offer(listener) == false) {, +                    listener.onFailure(new RejectedExecutionException("connect queue is full"));, +++ b/server/src/test/java/org/elasticsearch/transport/RemoteClusterConnectionTests.java, +import org.elasticsearch.common.util.concurrent.ThreadContext;, +    public void testFetchShardsThreadContextHeader() throws Exception {, +        List<DiscoveryNode> knownNodes = new CopyOnWriteArrayList<>();, +        try (MockTransportService seedTransport = startTransport("seed_node", knownNodes, Version.CURRENT);, +             MockTransportService discoverableTransport = startTransport("discoverable_node", knownNodes, Version.CURRENT)) {, +            DiscoveryNode seedNode = seedTransport.getLocalDiscoNode();, +            knownNodes.add(seedTransport.getLocalDiscoNode());, +            knownNodes.add(discoverableTransport.getLocalDiscoNode());, +            Collections.shuffle(knownNodes, random());, +            try (MockTransportService service = MockTransportService.createNewService(Settings.EMPTY, Version.CURRENT, threadPool, null)) {, +                service.start();, +                service.acceptIncomingRequests();, +                List<DiscoveryNode> nodes = Collections.singletonList(seedNode);, +                try (RemoteClusterConnection connection = new RemoteClusterConnection(Settings.EMPTY, "test-cluster",, +                    nodes, service, Integer.MAX_VALUE, n -> true)) {, +                    SearchRequest request = new SearchRequest("test-index");, +                    Thread[] threads = new Thread[10];, +                    for (int i = 0; i < threads.length; i++) {, +                        final String threadId = Integer.toString(i);, +                        threads[i] = new Thread(() -> {, +                            ThreadContext threadContext = seedTransport.threadPool.getThreadContext();, +                            threadContext.putHeader("threadId", threadId);, +                            AtomicReference<ClusterSearchShardsResponse> reference = new AtomicReference<>();, +                            AtomicReference<Exception> failReference = new AtomicReference<>();, +                            final ClusterSearchShardsRequest searchShardsRequest = new ClusterSearchShardsRequest("test-index"), +                                .indicesOptions(request.indicesOptions()).local(true).preference(request.preference()), +                                .routing(request.routing());, +                            CountDownLatch responseLatch = new CountDownLatch(1);, +                            connection.fetchSearchShards(searchShardsRequest,, +                                new LatchedActionListener<>(ActionListener.wrap(, +                                    resp -> {, +                                        reference.set(resp);, +                                        assertEquals(threadId, seedTransport.threadPool.getThreadContext().getHeader("threadId"));, +                                    },, +                                    failReference::set), responseLatch));, +                            try {, +                                responseLatch.await();, +                            } catch (InterruptedException e) {, +                                throw new RuntimeException(e);, +                            }, +                            assertNull(failReference.get());, +                            assertNotNull(reference.get());, +                            ClusterSearchShardsResponse clusterSearchShardsResponse = reference.get();, +                            assertEquals(knownNodes, Arrays.asList(clusterSearchShardsResponse.getNodes()));, +                        });, +                    }, +                    for (int i = 0; i < threads.length; i++) {, +                        threads[i].start();, +                    }, +, +                    for (int i = 0; i < threads.length; i++) {, +                        threads[i].join();, +                    }, +                    assertTrue(connection.assertNoRunningConnections());, +                }, +            }, +        }, +    }, +]