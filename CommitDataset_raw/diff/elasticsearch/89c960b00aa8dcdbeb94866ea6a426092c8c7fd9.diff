[+++ b/core/src/main/java/org/elasticsearch/action/support/replication/TransportReplicationAction.java, +                logger.trace("Retrying operation on replica, action [{}], request [{}]", t, transportReplicaAction, request);, +                        // Forking a thread on local node via transport service so that custom transport service have an, +                        // opportunity to execute custom  logic before the replica operation begins, +                        String extraMessage = "action [" + transportReplicaAction  + "], request[" + request + "]";, +                        TransportChannelResponseHandler<TransportResponse.Empty> handler = TransportChannelResponseHandler.emptyResponseHandler(logger, channel, extraMessage);, +                        transportService.sendRequest(clusterService.localNode(), transportReplicaAction, request, handler);, +++ b/core/src/main/java/org/elasticsearch/action/support/replication/TransportReplicationAction.java, +                logger.trace("Retrying operation on replica, action [{}], request [{}]", t, transportReplicaAction, request);, +                        // Forking a thread on local node via transport service so that custom transport service have an, +                        // opportunity to execute custom  logic before the replica operation begins, +                        String extraMessage = "action [" + transportReplicaAction  + "], request[" + request + "]";, +                        TransportChannelResponseHandler<TransportResponse.Empty> handler = TransportChannelResponseHandler.emptyResponseHandler(logger, channel, extraMessage);, +                        transportService.sendRequest(clusterService.localNode(), transportReplicaAction, request, handler);, +++ b/core/src/main/java/org/elasticsearch/cluster/action/shard/ShardStateAction.java, +import org.elasticsearch.cluster.ClusterService;, +import org.elasticsearch.cluster.ClusterState;, +import org.elasticsearch.cluster.ClusterStateTaskConfig;, +import org.elasticsearch.cluster.ClusterStateTaskExecutor;, +import org.elasticsearch.cluster.ClusterStateTaskListener;, +import org.elasticsearch.cluster.NotMasterException;, +import org.elasticsearch.transport.EmptyTransportResponseHandler;, +import org.elasticsearch.transport.TransportChannel;, +import org.elasticsearch.transport.TransportException;, +import org.elasticsearch.transport.TransportRequest;, +import org.elasticsearch.transport.TransportRequestHandler;, +import org.elasticsearch.transport.TransportRequestOptions;, +import org.elasticsearch.transport.TransportResponse;, +import org.elasticsearch.transport.TransportService;, +import java.util.Locale;, +public class ShardStateAction extends AbstractComponent {, +                    logger.warn("unexpected failure while sending request to [{}] to fail shard [{}]", exp, masterNode, shardRoutingEntry);, +    private class ShardFailedTransportHandler implements TransportRequestHandler<ShardRoutingEntry> {, +        @Override, +        public void messageReceived(ShardRoutingEntry request, TransportChannel channel) throws Exception {, +            handleShardFailureOnMaster(request, new ClusterStateTaskListener() {, +                    @Override, +                    public void onFailure(String source, Throwable t) {, +                        logger.error("unexpected failure while failing shard [{}]", t, request.shardRouting);, +                        try {, +                            channel.sendResponse(t);, +                        } catch (Throwable channelThrowable) {, +                            logger.warn("failed to send failure [{}] while failing shard [{}]", channelThrowable, t, request.shardRouting);, +                        }, +                    }, +, +                    @Override, +                    public void onNoLongerMaster(String source) {, +                        logger.error("no longer master while failing shard [{}]", request.shardRouting);, +                        try {, +                            channel.sendResponse(new NotMasterException(source));, +                        } catch (Throwable channelThrowable) {, +                            logger.warn("failed to send no longer master while failing shard [{}]", channelThrowable, request.shardRouting);, +                        }, +                    }, +, +                    @Override, +                    public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {, +                        try {, +                            int numberOfUnassignedShards = newState.getRoutingNodes().unassigned().size();, +                            if (oldState != newState && numberOfUnassignedShards > 0) {, +                                String reason = String.format(Locale.ROOT, "[%d] unassigned shards after failing shard [%s]", numberOfUnassignedShards, request.shardRouting);, +                                if (logger.isTraceEnabled()) {, +                                    logger.trace(reason + ", scheduling a reroute");, +                                }, +                                routingService.reroute(reason);, +                            }, +                        } finally {, +                            try {, +                                channel.sendResponse(TransportResponse.Empty.INSTANCE);, +                            } catch (Throwable channelThrowable) {, +                                logger.warn("failed to send response while failing shard [{}]", channelThrowable, request.shardRouting);, +                            }, +                        }, +                    }, +                }, +            );, +        }, +    }, +, +    class ShardFailedClusterStateHandler implements ClusterStateTaskExecutor<ShardRoutingEntry> {, +        @Override, +        public BatchResult<ShardRoutingEntry> execute(ClusterState currentState, List<ShardRoutingEntry> tasks) throws Exception {, +            BatchResult.Builder<ShardRoutingEntry> batchResultBuilder = BatchResult.builder();, +            List<FailedRerouteAllocation.FailedShard> failedShards = new ArrayList<>(tasks.size());, +            for (ShardRoutingEntry task : tasks) {, +                failedShards.add(new FailedRerouteAllocation.FailedShard(task.shardRouting, task.message, task.failure));, +            }, +            ClusterState maybeUpdatedState = currentState;, +            try {, +                RoutingAllocation.Result result = allocationService.applyFailedShards(currentState, failedShards);, +                if (result.changed()) {, +                    maybeUpdatedState = ClusterState.builder(currentState).routingResult(result).build();, +                }, +                batchResultBuilder.successes(tasks);, +            } catch (Throwable t) {, +                batchResultBuilder.failures(tasks, t);, +            }, +            return batchResultBuilder.build(maybeUpdatedState);, +        }]