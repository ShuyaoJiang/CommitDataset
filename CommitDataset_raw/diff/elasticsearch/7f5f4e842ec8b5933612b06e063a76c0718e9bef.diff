[+++ b/src/main/java/org/elasticsearch/cluster/action/index/MappingUpdatedAction.java, +import java.util.Collections;, +import java.util.Iterator;, +import java.util.List;, +import java.util.Map;, +                if (this == o) {, +                    return true;, +                }, +                if (o == null || getClass() != o.getClass()) {, +                    return false;, +                }, +                if (!indexUUID.equals(updateKey.indexUUID)) {, +                    return false;, +                }, +                if (!type.equals(updateKey.type)) {, +                    return false;, +                }, +++ b/src/main/java/org/elasticsearch/cluster/action/index/MappingUpdatedAction.java, +import java.util.Collections;, +import java.util.Iterator;, +import java.util.List;, +import java.util.Map;, +                if (this == o) {, +                    return true;, +                }, +                if (o == null || getClass() != o.getClass()) {, +                    return false;, +                }, +                if (!indexUUID.equals(updateKey.indexUUID)) {, +                    return false;, +                }, +                if (!type.equals(updateKey.type)) {, +                    return false;, +                }, +++ b/src/main/java/org/elasticsearch/indices/recovery/RecoverySource.java, +import org.elasticsearch.cluster.action.index.MappingUpdatedAction;, +import org.elasticsearch.index.mapper.DocumentMapper;, +import org.elasticsearch.index.service.IndexService;, +import java.util.concurrent.TimeUnit;, +    private final MappingUpdatedAction mappingUpdatedAction;, +                          RecoverySettings recoverySettings, MappingUpdatedAction mappingUpdatedAction, ClusterService clusterService) {, +        this.mappingUpdatedAction = mappingUpdatedAction;, +        final IndexService indexService = indicesService.indexServiceSafe(request.shardId().index().name());, +        final InternalIndexShard shard = (InternalIndexShard) indexService.shardSafe(request.shardId().id());, +                logger.trace("{} recovery [phase2] to {}: start", request.shardId(), request.targetNode());, +                logger.trace("{} recovery [phase2] to {}: start took [{}]", request.shardId(), request.targetNode(), request.targetNode(), stopWatch.totalTime());, +, +                logger.trace("{} recovery [phase2] to {}: updating current mapping to master", request.shardId(), request.targetNode());, +                updateMappingOnMaster();, +, +                logger.trace("{} recovery [phase2] to {}: sending transaction log operations", request.shardId(), request.targetNode());, +                logger.trace("{} recovery [phase2] to {}: took [{}]", request.shardId(), request.targetNode(), stopWatch.totalTime());, +            private void updateMappingOnMaster() {, +                List<DocumentMapper> documentMappersToUpdate = Lists.newArrayList(indexService.mapperService());, +                if (documentMappersToUpdate.size() == 0) {, +                    return;, +                }, +                final CountDownLatch countDownLatch = new CountDownLatch(documentMappersToUpdate.size());, +                MappingUpdatedAction.MappingUpdateListener listener = new MappingUpdatedAction.MappingUpdateListener() {, +                    @Override, +                    public void onMappingUpdate() {, +                        countDownLatch.countDown();, +                    }, +, +                    @Override, +                    public void onFailure(Throwable t) {, +                        logger.debug("{} recovery to {}: failed to update mapping on master", request.shardId(), request.targetNode(), t);, +                        countDownLatch.countDown();, +                    }, +                };, +                for (DocumentMapper documentMapper : documentMappersToUpdate) {, +                    mappingUpdatedAction.updateMappingOnMaster(indexService.index().getName(), documentMapper, indexService.indexUUID(), listener);, +                }, +                try {, +                    if (!countDownLatch.await(internalActionTimeout.millis(), TimeUnit.MILLISECONDS)) {, +                        logger.debug("{} recovery [phase2] to {}: waiting on pending mapping update timed out. waited [{}]", request.shardId(), request.targetNode(), internalActionTimeout);, +                    }, +                } catch (InterruptedException e) {, +                    Thread.currentThread().interrupt();, +                    logger.debug("interrupted while waiting for mapping to update on master");, +                }, +, +            }, +, +++ b/src/main/java/org/elasticsearch/cluster/action/index/MappingUpdatedAction.java, +import java.util.Collections;, +import java.util.Iterator;, +import java.util.List;, +import java.util.Map;, +                if (this == o) {, +                    return true;, +                }, +                if (o == null || getClass() != o.getClass()) {, +                    return false;, +                }, +                if (!indexUUID.equals(updateKey.indexUUID)) {, +                    return false;, +                }, +                if (!type.equals(updateKey.type)) {, +                    return false;]