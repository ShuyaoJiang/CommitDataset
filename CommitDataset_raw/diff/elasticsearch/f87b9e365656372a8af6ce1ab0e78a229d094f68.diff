[+++ b/modules/elasticsearch/src/main/java/org/elasticsearch/cluster/routing/RoutingTable.java, +    private final long version;, +, +    RoutingTable(long version, Map<String, IndexRoutingTable> indicesRouting) {, +        this.version = version;, +    public long version() {, +        return this.version;, +    }, +, +        private long version;, +, +            version = routingTable.version;, +        public Builder updateNodes(RoutingNodes routingNodes) {, +            // this is being called without pre initializing the routing table, so we must copy over the version as well, +            this.version = routingNodes.routingTable().version();, +, +            Map<String, IndexRoutingTable.Builder> indexRoutingTableBuilders = newHashMap();, +            for (RoutingNode routingNode : routingNodes) {, +                for (MutableShardRouting shardRoutingEntry : routingNode) {, +                    // every relocating shard has a double entry, ignore the target one., +                    if (shardRoutingEntry.state() == ShardRoutingState.INITIALIZING && shardRoutingEntry.relocatingNodeId() != null), +                        continue;, +, +                    String index = shardRoutingEntry.index();, +                    IndexRoutingTable.Builder indexBuilder = indexRoutingTableBuilders.get(index);, +                    if (indexBuilder == null) {, +                        indexBuilder = new IndexRoutingTable.Builder(index);, +                        indexRoutingTableBuilders.put(index, indexBuilder);, +                    }, +, +                    boolean allocatedPostApi = routingNodes.routingTable().index(shardRoutingEntry.index()).shard(shardRoutingEntry.id()).allocatedPostApi();, +                    indexBuilder.addShard(new ImmutableShardRouting(shardRoutingEntry), !allocatedPostApi);, +                }, +            }, +            for (MutableShardRouting shardRoutingEntry : Iterables.concat(routingNodes.unassigned(), routingNodes.ignoredUnassigned())) {, +                String index = shardRoutingEntry.index();, +                IndexRoutingTable.Builder indexBuilder = indexRoutingTableBuilders.get(index);, +                if (indexBuilder == null) {, +                    indexBuilder = new IndexRoutingTable.Builder(index);, +                    indexRoutingTableBuilders.put(index, indexBuilder);, +                }, +                boolean allocatedPostApi = routingNodes.routingTable().index(shardRoutingEntry.index()).shard(shardRoutingEntry.id()).allocatedPostApi();, +                indexBuilder.addShard(new ImmutableShardRouting(shardRoutingEntry), !allocatedPostApi);, +            }, +            for (IndexRoutingTable.Builder indexBuilder : indexRoutingTableBuilders.values()) {, +                add(indexBuilder);, +            }, +            return this;, +        }, +, +        public Builder version(long version) {, +            this.version = version;, +            return new RoutingTable(version, indicesRouting);, +            builder.version = in.readLong();, +            out.writeLong(table.version);, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/cluster/routing/RoutingTable.java, +    private final long version;, +, +    RoutingTable(long version, Map<String, IndexRoutingTable> indicesRouting) {, +        this.version = version;, +    public long version() {, +        return this.version;, +    }, +, +        private long version;, +, +            version = routingTable.version;, +        public Builder updateNodes(RoutingNodes routingNodes) {, +            // this is being called without pre initializing the routing table, so we must copy over the version as well, +            this.version = routingNodes.routingTable().version();, +, +            Map<String, IndexRoutingTable.Builder> indexRoutingTableBuilders = newHashMap();, +            for (RoutingNode routingNode : routingNodes) {, +                for (MutableShardRouting shardRoutingEntry : routingNode) {, +                    // every relocating shard has a double entry, ignore the target one., +                    if (shardRoutingEntry.state() == ShardRoutingState.INITIALIZING && shardRoutingEntry.relocatingNodeId() != null), +                        continue;, +, +                    String index = shardRoutingEntry.index();, +                    IndexRoutingTable.Builder indexBuilder = indexRoutingTableBuilders.get(index);, +                    if (indexBuilder == null) {, +                        indexBuilder = new IndexRoutingTable.Builder(index);, +                        indexRoutingTableBuilders.put(index, indexBuilder);, +                    }, +, +                    boolean allocatedPostApi = routingNodes.routingTable().index(shardRoutingEntry.index()).shard(shardRoutingEntry.id()).allocatedPostApi();, +                    indexBuilder.addShard(new ImmutableShardRouting(shardRoutingEntry), !allocatedPostApi);, +                }, +            }, +            for (MutableShardRouting shardRoutingEntry : Iterables.concat(routingNodes.unassigned(), routingNodes.ignoredUnassigned())) {, +                String index = shardRoutingEntry.index();, +                IndexRoutingTable.Builder indexBuilder = indexRoutingTableBuilders.get(index);, +                if (indexBuilder == null) {, +                    indexBuilder = new IndexRoutingTable.Builder(index);, +                    indexRoutingTableBuilders.put(index, indexBuilder);, +                }, +                boolean allocatedPostApi = routingNodes.routingTable().index(shardRoutingEntry.index()).shard(shardRoutingEntry.id()).allocatedPostApi();, +                indexBuilder.addShard(new ImmutableShardRouting(shardRoutingEntry), !allocatedPostApi);, +            }, +            for (IndexRoutingTable.Builder indexBuilder : indexRoutingTableBuilders.values()) {]