[+++ b/src/test/java/org/elasticsearch/test/ElasticsearchIntegrationTest.java, +        Class<?> targetClass = getTestClass();, +++ b/src/test/java/org/elasticsearch/test/ElasticsearchIntegrationTest.java, +        Class<?> targetClass = getTestClass();, +++ b/src/test/java/org/elasticsearch/test/ElasticsearchTestCase.java, +    // -----------------------------------------------------------------, +    // Suite and test case setup/cleanup., +    // -----------------------------------------------------------------, +, +    // TODO: Parent/child and other things does not work with the query cache, +    // We must disable query cache for both suite and test to override lucene, but LTC resets it after the suite, +    @BeforeClass, +    public static void disableQueryCacheSuite() {, +        IndexSearcher.setDefaultQueryCache(null);, +    }, +    @Before, +    public final void disableQueryCache() {, +        IndexSearcher.setDefaultQueryCache(null);, +    }, +    , +    public static void setFileSystem() throws Exception {, +    @AfterClass, +    public static void restoreFileSystem() throws Exception {, +        Field field1 = PathUtils.class.getDeclaredField("ACTUAL_DEFAULT");, +        field1.setAccessible(true);, +        Field field2 = PathUtils.class.getDeclaredField("DEFAULT");, +        field2.setAccessible(true);, +        field2.set(null, field1.get(null));, +    }, +, +    // setup a default exception handler which knows when and how to print a stacktrace, +    private static Thread.UncaughtExceptionHandler defaultHandler;, +    @BeforeClass, +    public static void setDefaultExceptionHandler() throws Exception {, +        defaultHandler = Thread.getDefaultUncaughtExceptionHandler();, +        Thread.setDefaultUncaughtExceptionHandler(new ElasticsearchUncaughtExceptionHandler(defaultHandler));, +    }, +    @AfterClass, +    public static void restoreDefaultExceptionHandler() throws Exception {, +        Thread.setDefaultUncaughtExceptionHandler(defaultHandler);, +    }, +, +    // randomize content type for request builders, +    @BeforeClass, +    public static void setContentType() throws Exception {, +        Requests.CONTENT_TYPE = randomFrom(XContentType.values());, +        Requests.INDEX_CONTENT_TYPE = randomFrom(XContentType.values());, +    }, +    @AfterClass, +    public static void restoreContentType() {, +        Requests.CONTENT_TYPE = XContentType.SMILE;, +        Requests.INDEX_CONTENT_TYPE = XContentType.JSON;, +    }, +    , +    // randomize and override the number of cpus so tests reproduce regardless of real number of cpus, +    @BeforeClass, +    public static void setProcessors() {, +        int numCpu = TestUtil.nextInt(random(), 1, 4);, +        System.setProperty(EsExecutors.DEFAULT_SYSPROP, Integer.toString(numCpu));, +        assertEquals(numCpu, EsExecutors.boundedNumberOfProcessors(ImmutableSettings.EMPTY));, +    }, +    @AfterClass, +    public static void restoreProcessors() {, +        System.clearProperty(EsExecutors.DEFAULT_SYSPROP);, +    public static void setAfterSuiteAssertions() throws Exception {, +    public final void ensureCleanedUp() throws Exception {, +        // field cache should NEVER get loaded., +        String[] entries = UninvertingReader.getUninvertedStats();, +        assertEquals("fieldcache must never be used, got=" + Arrays.toString(entries), 0, entries.length);, +    // this must be a separate method from other ensure checks above so suite scoped integ tests can call...TODO: fix that, +    public final void ensureAllSearchContextsReleased() throws Exception {, +    @Before, +    public final void resetCheckIndexStatus() throws Exception {, +    public final void ensureCheckIndexPassed() throws Exception {, +    // TODO: replaces uses of getRandom() with random(), +    // TODO: decide on one set of naming for between/scaledBetween and remove others, +    // TODO: replace frequently() with usually(), +    /** A random integer from 0..max (inclusive). */, +    public static int randomInt(int max) {, +        return RandomizedTest.randomInt(max);, +    }, +    , +    public static String[] generateRandomStringArray(int maxArraySize, int maxStringSize, boolean allowNull) {, +        if (allowNull && random().nextBoolean()) {, +            return null;, +        }, +        String[] array = new String[random().nextInt(maxArraySize)]; // allow empty arrays, +        for (int i = 0; i < array.length; i++) {, +            array[i] = RandomStrings.randomAsciiOfLength(random(), maxStringSize);, +        }, +        return array;, +    }, +, +    public static boolean terminate(ExecutorService... services) throws InterruptedException {, +        boolean terminated = true;, +        for (ExecutorService service : services) {, +            if (service != null) {, +                terminated &= ThreadPool.terminate(service, 10, TimeUnit.SECONDS);, +            }, +        }]