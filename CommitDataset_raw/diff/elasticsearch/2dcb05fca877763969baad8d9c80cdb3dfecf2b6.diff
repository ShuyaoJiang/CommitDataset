[+++ b/core/src/main/java/org/elasticsearch/action/DocWriteResponse.java, +import org.elasticsearch.common.ParseField;, +import org.elasticsearch.common.xcontent.ConstructingObjectParser;, +import org.elasticsearch.common.xcontent.ObjectParser;, +import static org.elasticsearch.common.xcontent.ConstructingObjectParser.constructorArg;, +import static org.elasticsearch.common.xcontent.ConstructingObjectParser.optionalConstructorArg;, +, +    private static final String _SHARDS = "_shards";, +    private static final String _INDEX = "_index";, +    private static final String _TYPE = "_type";, +    private static final String _ID = "_id";, +    private static final String _VERSION = "_version";, +    private static final String _SEQ_NO = "_seq_no";, +    private static final String RESULT = "result";, +    private static final String FORCED_REFRESH = "forced_refresh";, +, +        builder.field(_INDEX, shardId.getIndexName()), +                .field(_TYPE, type), +                .field(_ID, id), +                .field(_VERSION, version), +                .field(RESULT, getResult().getLowercase());, +            builder.field(FORCED_REFRESH, true);, +        builder.field(_SHARDS, shardInfo);, +            builder.field(_SEQ_NO, getSeqNo());, +, +    /**, +     * Declare the {@link ObjectParser} fields to use when parsing a {@link DocWriteResponse}, +     */, +    protected static void declareParserFields(ConstructingObjectParser<? extends DocWriteResponse, Void> objParser) {, +        objParser.declareString(constructorArg(), new ParseField(_INDEX));, +        objParser.declareString(constructorArg(), new ParseField(_TYPE));, +        objParser.declareString(constructorArg(), new ParseField(_ID));, +        objParser.declareLong(constructorArg(), new ParseField(_VERSION));, +        objParser.declareString(constructorArg(), new ParseField(RESULT));, +        objParser.declareLong(optionalConstructorArg(), new ParseField(_SEQ_NO));, +        objParser.declareBoolean(DocWriteResponse::setForcedRefresh, new ParseField(FORCED_REFRESH));, +        objParser.declareObject(DocWriteResponse::setShardInfo, (p, c) -> ShardInfo.fromXContent(p), new ParseField(_SHARDS));, +    }, +++ b/core/src/main/java/org/elasticsearch/action/DocWriteResponse.java, +import org.elasticsearch.common.ParseField;, +import org.elasticsearch.common.xcontent.ConstructingObjectParser;, +import org.elasticsearch.common.xcontent.ObjectParser;, +import static org.elasticsearch.common.xcontent.ConstructingObjectParser.constructorArg;, +import static org.elasticsearch.common.xcontent.ConstructingObjectParser.optionalConstructorArg;, +, +    private static final String _SHARDS = "_shards";, +    private static final String _INDEX = "_index";, +    private static final String _TYPE = "_type";, +    private static final String _ID = "_id";, +    private static final String _VERSION = "_version";, +    private static final String _SEQ_NO = "_seq_no";, +    private static final String RESULT = "result";, +    private static final String FORCED_REFRESH = "forced_refresh";, +, +        builder.field(_INDEX, shardId.getIndexName()), +                .field(_TYPE, type), +                .field(_ID, id), +                .field(_VERSION, version), +                .field(RESULT, getResult().getLowercase());, +            builder.field(FORCED_REFRESH, true);, +        builder.field(_SHARDS, shardInfo);, +            builder.field(_SEQ_NO, getSeqNo());, +, +    /**, +     * Declare the {@link ObjectParser} fields to use when parsing a {@link DocWriteResponse}, +     */, +    protected static void declareParserFields(ConstructingObjectParser<? extends DocWriteResponse, Void> objParser) {, +        objParser.declareString(constructorArg(), new ParseField(_INDEX));, +        objParser.declareString(constructorArg(), new ParseField(_TYPE));, +        objParser.declareString(constructorArg(), new ParseField(_ID));, +        objParser.declareLong(constructorArg(), new ParseField(_VERSION));, +        objParser.declareString(constructorArg(), new ParseField(RESULT));, +        objParser.declareLong(optionalConstructorArg(), new ParseField(_SEQ_NO));, +        objParser.declareBoolean(DocWriteResponse::setForcedRefresh, new ParseField(FORCED_REFRESH));, +        objParser.declareObject(DocWriteResponse::setShardInfo, (p, c) -> ShardInfo.fromXContent(p), new ParseField(_SHARDS));, +    }, +++ b/core/src/main/java/org/elasticsearch/action/index/IndexResponse.java, +import org.elasticsearch.cluster.metadata.IndexMetaData;, +import org.elasticsearch.common.ParseField;, +import org.elasticsearch.common.xcontent.ConstructingObjectParser;, +import org.elasticsearch.common.xcontent.XContentParser;, +import org.elasticsearch.index.Index;, +import org.elasticsearch.index.seqno.SequenceNumbersService;, +import static org.elasticsearch.common.xcontent.ConstructingObjectParser.constructorArg;, +, +    private static final String CREATED = "created";, +, +        builder.field(CREATED, result == Result.CREATED);, +, +    /**, +     * ConstructingObjectParser used to parse the {@link IndexResponse}. We use a ObjectParser here, +     * because most fields are parsed by the parent abstract class {@link DocWriteResponse} and it's, +     * not easy to parse part of the fields in the parent class and other fields in the children class, +     * using the usual streamed parsing method., +     */, +    private static final ConstructingObjectParser<IndexResponse, Void> PARSER;, +    static {, +        PARSER = new ConstructingObjectParser<>(IndexResponse.class.getName(),, +                args -> {, +                    // index uuid and shard id are unknown and can't be parsed back for now.]