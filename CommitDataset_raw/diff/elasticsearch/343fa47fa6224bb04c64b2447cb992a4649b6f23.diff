[+++ b/core/pom.xml, +                                <include>org/elasticsearch/bootstrap/MockPluginPolicy.class</include>, +                                <include>org/elasticsearch/bootstrap/MockPluginPolicy.class</include>, +++ b/core/pom.xml, +                                <include>org/elasticsearch/bootstrap/MockPluginPolicy.class</include>, +                                <include>org/elasticsearch/bootstrap/MockPluginPolicy.class</include>, +++ b/core/src/main/java/org/apache/lucene/util/XGeoHashUtils.java, +/*, + * Licensed to Elasticsearch under one or more contributor, + * license agreements. See the NOTICE file distributed with, + * this work for additional information regarding copyright, + * ownership. Elasticsearch licenses this file to you under, + * the Apache License, Version 2.0 (the "License"); you may, + * not use this file except in compliance with the License., + * You may obtain a copy of the License at, + *, + *    http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing,, + * software distributed under the License is distributed on an, + * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY, + * KIND, either express or implied.  See the License for the, + * specific language governing permissions and limitations, + * under the License., + */, +, +package org.apache.lucene.util;, +, +import java.util.ArrayList;, +import java.util.Collection;, +, +/**, + * Utilities for converting to/from the GeoHash standard, + *, + * The geohash long format is represented as lon/lat (x/y) interleaved with the 4 least significant bits, + * representing the level (1-12) [xyxy...xyxyllll], + *, + * This differs from a morton encoded value which interleaves lat/lon (y/x)., + *, + * @lucene.experimental, + */, +public class XGeoHashUtils {, +    public static final char[] BASE_32 = {'0', '1', '2', '3', '4', '5', '6',, +            '7', '8', '9', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'j', 'k', 'm', 'n',, +            'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'};, +, +    public static final String BASE_32_STRING = new String(BASE_32);, +, +    public static final int PRECISION = 12;, +    private static final short MORTON_OFFSET = (XGeoUtils.BITS<<1) - (PRECISION*5);, +, +    /**, +     * Encode lon/lat to the geohash based long format (lon/lat interleaved, 4 least significant bits = level), +     */, +    public static final long longEncode(final double lon, final double lat, final int level) {, +        // shift to appropriate level, +        final short msf = (short)(((12 - level) * 5) + MORTON_OFFSET);, +        return ((BitUtil.flipFlop(XGeoUtils.mortonHash(lon, lat)) >>> msf) << 4) | level;, +    }, +, +    /**, +     * Encode from geohash string to the geohash based long format (lon/lat interleaved, 4 least significant bits = level), +     */, +    public static final long longEncode(final String hash) {, +        int level = hash.length()-1;, +        long b;, +        long l = 0L;, +        for(char c : hash.toCharArray()) {, +            b = (long)(BASE_32_STRING.indexOf(c));, +            l |= (b<<(level--*5));, +        }, +        return (l<<4)|hash.length();, +    }, +, +    /**, +     * Encode an existing geohash long to the provided precision, +     */, +    public static long longEncode(long geohash, int level) {, +        final short precision = (short)(geohash & 15);, +        if (precision == level) {, +            return geohash;, +        } else if (precision > level) {, +            return ((geohash >>> (((precision - level) * 5) + 4)) << 4) | level;, +        }, +        return ((geohash >>> 4) << (((level - precision) * 5) + 4) | level);, +    }, +, +    /**, +     * Encode to a geohash string from the geohash based long format, +     */, +    public static final String stringEncode(long geoHashLong) {, +        int level = (int)geoHashLong&15;, +        geoHashLong >>>= 4;, +        char[] chars = new char[level];, +        do {, +            chars[--level] = BASE_32[(int)(geoHashLong&31L)];, +            geoHashLong>>>=5;, +        } while(level > 0);, +, +        return new String(chars);]