[+++ b/core/src/main/java/org/elasticsearch/gateway/PrimaryShardAllocator.java, +                if (allocationId == null && nodeShardState.legacyVersion() == ShardStateMetaData.NO_VERSION) {, +                    logger.trace("[{}] on node [{}] has no shard state information", shard, nodeShardState.getNode());, +                } else if (allocationId != null) {, +                    assert nodeShardState.legacyVersion() == ShardStateMetaData.NO_VERSION : "Allocation id and legacy version cannot be both present";, +                    logger.trace("[{}] on node [{}] has allocation id [{}]", shard, nodeShardState.getNode(), allocationId);, +                } else {, +                    logger.trace("[{}] on node [{}] has no allocation id, out-dated shard (shard state version: [{}])", shard, nodeShardState.getNode(), nodeShardState.legacyVersion());, +                if (version == ShardStateMetaData.NO_VERSION && nodeShardState.allocationId() == null) {, +                    logger.trace("[{}] on node [{}] has no shard state information", shard, nodeShardState.getNode());, +                } else if (version != ShardStateMetaData.NO_VERSION) {, +                    assert nodeShardState.allocationId() == null : "Allocation id and legacy version cannot be both present";, +                    // shard was already selected in a 5.x cluster as primary for recovery, was initialized (and wrote a new state file) but, +                    // did not make it to STARTED state before the cluster crashed (otherwise list of active allocation ids would be, +                    // non-empty and allocation id - based allocation mode would be chosen)., +                    // Prefer this shard copy again., +                    version = Long.MAX_VALUE;, +                    logger.trace("[{}] on node [{}] has allocation id [{}]", shard, nodeShardState.getNode(), nodeShardState.allocationId());, +                }, +            } else {, +++ b/core/src/main/java/org/elasticsearch/gateway/PrimaryShardAllocator.java, +                if (allocationId == null && nodeShardState.legacyVersion() == ShardStateMetaData.NO_VERSION) {, +                    logger.trace("[{}] on node [{}] has no shard state information", shard, nodeShardState.getNode());, +                } else if (allocationId != null) {, +                    assert nodeShardState.legacyVersion() == ShardStateMetaData.NO_VERSION : "Allocation id and legacy version cannot be both present";, +                    logger.trace("[{}] on node [{}] has allocation id [{}]", shard, nodeShardState.getNode(), allocationId);, +                } else {, +                    logger.trace("[{}] on node [{}] has no allocation id, out-dated shard (shard state version: [{}])", shard, nodeShardState.getNode(), nodeShardState.legacyVersion());, +                if (version == ShardStateMetaData.NO_VERSION && nodeShardState.allocationId() == null) {, +                    logger.trace("[{}] on node [{}] has no shard state information", shard, nodeShardState.getNode());, +                } else if (version != ShardStateMetaData.NO_VERSION) {, +                    assert nodeShardState.allocationId() == null : "Allocation id and legacy version cannot be both present";, +                    // shard was already selected in a 5.x cluster as primary for recovery, was initialized (and wrote a new state file) but, +                    // did not make it to STARTED state before the cluster crashed (otherwise list of active allocation ids would be, +                    // non-empty and allocation id - based allocation mode would be chosen)., +                    // Prefer this shard copy again., +                    version = Long.MAX_VALUE;, +                    logger.trace("[{}] on node [{}] has allocation id [{}]", shard, nodeShardState.getNode(), nodeShardState.allocationId());, +                }, +            } else {, +++ b/core/src/main/java/org/elasticsearch/index/cache/bitset/BitsetFilterCache.java, +            if (indexSettings.getIndex().equals(indexShard.indexSettings().getIndex()) == false) {, +++ b/core/src/main/java/org/elasticsearch/gateway/PrimaryShardAllocator.java, +                if (allocationId == null && nodeShardState.legacyVersion() == ShardStateMetaData.NO_VERSION) {, +                    logger.trace("[{}] on node [{}] has no shard state information", shard, nodeShardState.getNode());, +                } else if (allocationId != null) {, +                    assert nodeShardState.legacyVersion() == ShardStateMetaData.NO_VERSION : "Allocation id and legacy version cannot be both present";, +                    logger.trace("[{}] on node [{}] has allocation id [{}]", shard, nodeShardState.getNode(), allocationId);, +                } else {, +                    logger.trace("[{}] on node [{}] has no allocation id, out-dated shard (shard state version: [{}])", shard, nodeShardState.getNode(), nodeShardState.legacyVersion());, +                if (version == ShardStateMetaData.NO_VERSION && nodeShardState.allocationId() == null) {, +                    logger.trace("[{}] on node [{}] has no shard state information", shard, nodeShardState.getNode());, +                } else if (version != ShardStateMetaData.NO_VERSION) {, +                    assert nodeShardState.allocationId() == null : "Allocation id and legacy version cannot be both present";, +                    // shard was already selected in a 5.x cluster as primary for recovery, was initialized (and wrote a new state file) but, +                    // did not make it to STARTED state before the cluster crashed (otherwise list of active allocation ids would be, +                    // non-empty and allocation id - based allocation mode would be chosen)., +                    // Prefer this shard copy again., +                    version = Long.MAX_VALUE;, +                    logger.trace("[{}] on node [{}] has allocation id [{}]", shard, nodeShardState.getNode(), nodeShardState.allocationId());, +                }, +            } else {, +++ b/core/src/main/java/org/elasticsearch/index/cache/bitset/BitsetFilterCache.java, +            if (indexSettings.getIndex().equals(indexShard.indexSettings().getIndex()) == false) {, +++ b/core/src/main/java/org/elasticsearch/index/shard/IndexShard.java, +        QueryShardContext queryShardContext = new QueryShardContext(indexSettings, indexCache.bitsetFilterCache(), indexFieldDataService, mapperService, similarityService, provider.getScriptService(), provider.getIndicesQueriesRegistry());, +     * @throws IOException if shard state could not be persisted, +    public void updateRoutingEntry(final ShardRouting newRouting, final boolean persistState) throws IOException {, +        return luceneVersion == null ? indexSettings.getIndexVersionCreated().luceneVersion : luceneVersion;, +        boolean shouldExist = shardRouting.allocatedPostIndexCreate(indexSettings.getIndexMetaData());, +    void persistMetadata(ShardRouting newRouting, @Nullable ShardRouting currentRouting) throws IOException {, +, +        // only persist metadata if routing information that is persisted in shard state metadata actually changed, +        if (currentRouting == null, +            || currentRouting.primary() != newRouting.primary(), +            || currentRouting.allocationId().equals(newRouting.allocationId()) == false) {, +            assert currentRouting == null || currentRouting.isSameAllocation(newRouting);, +                writeReason = "initial state with allocation id [" + newRouting.allocationId() + "]";, +            } else {, +            }, +            logger.trace("{} writing shard state, reason [{}]", shardId, writeReason);, +            final ShardStateMetaData newShardStateMetadata = new ShardStateMetaData(newRouting.primary(), getIndexUUID(), newRouting.allocationId());, +            ShardStateMetaData.FORMAT.write(newShardStateMetadata, newShardStateMetadata.legacyVersion, shardPath().getShardStatePath());, +            indexSettings.getSettings().getAsTime(IndexingMemoryController.SHARD_INACTIVE_TIME_SETTING, IndexingMemoryController.SHARD_DEFAULT_INACTIVE_TIME));, +++ b/core/src/main/java/org/elasticsearch/gateway/PrimaryShardAllocator.java, +                if (allocationId == null && nodeShardState.legacyVersion() == ShardStateMetaData.NO_VERSION) {, +                    logger.trace("[{}] on node [{}] has no shard state information", shard, nodeShardState.getNode());, +                } else if (allocationId != null) {, +                    assert nodeShardState.legacyVersion() == ShardStateMetaData.NO_VERSION : "Allocation id and legacy version cannot be both present";, +                    logger.trace("[{}] on node [{}] has allocation id [{}]", shard, nodeShardState.getNode(), allocationId);, +                } else {, +                    logger.trace("[{}] on node [{}] has no allocation id, out-dated shard (shard state version: [{}])", shard, nodeShardState.getNode(), nodeShardState.legacyVersion());, +                if (version == ShardStateMetaData.NO_VERSION && nodeShardState.allocationId() == null) {, +                    logger.trace("[{}] on node [{}] has no shard state information", shard, nodeShardState.getNode());, +                } else if (version != ShardStateMetaData.NO_VERSION) {, +                    assert nodeShardState.allocationId() == null : "Allocation id and legacy version cannot be both present";, +                    // shard was already selected in a 5.x cluster as primary for recovery, was initialized (and wrote a new state file) but, +                    // did not make it to STARTED state before the cluster crashed (otherwise list of active allocation ids would be, +                    // non-empty and allocation id - based allocation mode would be chosen)., +                    // Prefer this shard copy again.]