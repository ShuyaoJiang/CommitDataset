[+++ b/core/src/main/java/org/elasticsearch/client/transport/support/TransportProxyClient.java, +++ b/core/src/main/java/org/elasticsearch/client/transport/support/TransportProxyClient.java, +++ b/core/src/main/java/org/elasticsearch/cluster/routing/RecoverySource.java, +import org.elasticsearch.cluster.metadata.IndexMetaData;, +import java.util.EnumSet;, +, +    private static EnumSet<RecoverySource.Type> INITIAL_RECOVERY_TYPES = EnumSet.of(Type.EMPTY_STORE, Type.LOCAL_SHARDS, Type.SNAPSHOT);, +, +    /**, +     * returns true for recovery types that indicate that a primary is being allocated for the very first time., +     * This recoveries can be controlled by {@link IndexMetaData#INDEX_ROUTING_INITIAL_RECOVERY_GROUP_SETTING}, +     */, +    public static boolean isInitialRecovery(RecoverySource.Type type) {, +           return INITIAL_RECOVERY_TYPES.contains(type);, +    }, +++ b/core/src/main/java/org/elasticsearch/client/transport/support/TransportProxyClient.java, +++ b/core/src/main/java/org/elasticsearch/cluster/routing/RecoverySource.java, +import org.elasticsearch.cluster.metadata.IndexMetaData;, +import java.util.EnumSet;, +, +    private static EnumSet<RecoverySource.Type> INITIAL_RECOVERY_TYPES = EnumSet.of(Type.EMPTY_STORE, Type.LOCAL_SHARDS, Type.SNAPSHOT);, +, +    /**, +     * returns true for recovery types that indicate that a primary is being allocated for the very first time., +     * This recoveries can be controlled by {@link IndexMetaData#INDEX_ROUTING_INITIAL_RECOVERY_GROUP_SETTING}, +     */, +    public static boolean isInitialRecovery(RecoverySource.Type type) {, +           return INITIAL_RECOVERY_TYPES.contains(type);, +    }, +++ b/core/src/main/java/org/elasticsearch/cluster/routing/allocation/decider/FilterAllocationDecider.java, +            if (initialRecoveryFilters != null  &&, +                RecoverySource.isInitialRecovery(shardRouting.recoverySource().getType()) &&, +++ b/core/src/main/java/org/elasticsearch/client/transport/support/TransportProxyClient.java, +++ b/core/src/main/java/org/elasticsearch/cluster/routing/RecoverySource.java, +import org.elasticsearch.cluster.metadata.IndexMetaData;, +import java.util.EnumSet;, +, +    private static EnumSet<RecoverySource.Type> INITIAL_RECOVERY_TYPES = EnumSet.of(Type.EMPTY_STORE, Type.LOCAL_SHARDS, Type.SNAPSHOT);, +, +    /**, +     * returns true for recovery types that indicate that a primary is being allocated for the very first time., +     * This recoveries can be controlled by {@link IndexMetaData#INDEX_ROUTING_INITIAL_RECOVERY_GROUP_SETTING}, +     */, +    public static boolean isInitialRecovery(RecoverySource.Type type) {, +           return INITIAL_RECOVERY_TYPES.contains(type);, +    }, +++ b/core/src/main/java/org/elasticsearch/cluster/routing/allocation/decider/FilterAllocationDecider.java, +            if (initialRecoveryFilters != null  &&, +                RecoverySource.isInitialRecovery(shardRouting.recoverySource().getType()) &&, +++ b/core/src/test/java/org/elasticsearch/action/admin/indices/create/CreateIndexIT.java, +, +        final boolean createWithReplicas = randomBoolean();, +            .setSettings(Settings.builder().put("index.number_of_replicas", createWithReplicas ? 1 : 0).build()).get());, +, +        if (createWithReplicas == false) {, +        }, +++ b/core/src/main/java/org/elasticsearch/client/transport/support/TransportProxyClient.java, +++ b/core/src/main/java/org/elasticsearch/cluster/routing/RecoverySource.java, +import org.elasticsearch.cluster.metadata.IndexMetaData;, +import java.util.EnumSet;, +, +    private static EnumSet<RecoverySource.Type> INITIAL_RECOVERY_TYPES = EnumSet.of(Type.EMPTY_STORE, Type.LOCAL_SHARDS, Type.SNAPSHOT);, +, +    /**, +     * returns true for recovery types that indicate that a primary is being allocated for the very first time., +     * This recoveries can be controlled by {@link IndexMetaData#INDEX_ROUTING_INITIAL_RECOVERY_GROUP_SETTING}, +     */, +    public static boolean isInitialRecovery(RecoverySource.Type type) {, +           return INITIAL_RECOVERY_TYPES.contains(type);, +    }, +++ b/core/src/main/java/org/elasticsearch/cluster/routing/allocation/decider/FilterAllocationDecider.java, +            if (initialRecoveryFilters != null  &&, +                RecoverySource.isInitialRecovery(shardRouting.recoverySource().getType()) &&, +++ b/core/src/test/java/org/elasticsearch/action/admin/indices/create/CreateIndexIT.java, +, +        final boolean createWithReplicas = randomBoolean();, +            .setSettings(Settings.builder().put("index.number_of_replicas", createWithReplicas ? 1 : 0).build()).get());, +, +        if (createWithReplicas == false) {, +        }, +++ b/core/src/test/java/org/elasticsearch/cluster/routing/allocation/FilterAllocationDeciderTests.java, +import org.elasticsearch.cluster.routing.RecoverySource;, +import org.elasticsearch.cluster.routing.allocation.decider.ReplicaAfterPrimaryActiveAllocationDecider;, +import org.elasticsearch.snapshots.Snapshot;, +import org.elasticsearch.snapshots.SnapshotId;, +import java.util.Arrays;, +import static org.elasticsearch.cluster.metadata.IndexMetaData.INDEX_SHRINK_SOURCE_NAME;, +import static org.elasticsearch.cluster.metadata.IndexMetaData.INDEX_SHRINK_SOURCE_UUID;, +    public void testFilterInitialRecovery() {, +            Arrays.asList(filterAllocationDecider, new ReplicaAfterPrimaryActiveAllocationDecider(Settings.EMPTY)));, +        // after failing the shard we are unassigned since the node is blacklisted and we can't initialize on the other node, +        assertEquals(filterAllocationDecider.canAllocate(routingTable.index("idx").shard(0).primaryShard(),, +        assertEquals(filterAllocationDecider.canAllocate(routingTable.index("idx").shard(0).primaryShard(),, +        assertEquals(routingTable.index("idx").shard(0).primaryShard().state(), INITIALIZING);, +        assertEquals(routingTable.index("idx").shard(0).primaryShard().currentNodeId(), "node2");, +        state = service.applyStartedShards(state, routingTable.index("idx").shard(0).shardsWithState(INITIALIZING));, +        assertEquals(routingTable.index("idx").shard(0).primaryShard().state(), STARTED);, +        assertEquals(routingTable.index("idx").shard(0).primaryShard().currentNodeId(), "node2");, +, +        // replicas should be initializing]