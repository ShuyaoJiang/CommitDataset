[+++ b/src/main/java/org/elasticsearch/search/suggest/Suggest.java, +    public static class Suggestion implements Iterable<Suggestion.Entry>, Streamable, ToXContent {, +        private final List<Entry> entries = new ArrayList<Entry>(5);, +        void addTerm(Entry entry) {, +            entries.add(entry);, +        }, +, +        @Override, +        public Iterator<Entry> iterator() {, +            return entries.iterator();, +         * @return The entries for this suggestion., +        public List<Entry> getEntries() {, +            return entries;, +         * For internal usage., +            assert entries.size() == other.entries.size();, +            for (int i = 0; i < entries.size(); i++) {, +                Entry thisEntry = entries.get(i);, +                Entry otherEntry = other.entries.get(i);, +                thisEntry.reduce(otherEntry, sort);, +         * Trims the number of options per suggest text term to the requested size., +         * For internal usage., +            for (Entry entry : entries) {, +                entry.trim(size);, +            entries.clear();, +                entries.add(Entry.read(in));, +            out.writeVInt(entries.size());, +            for (Entry entry : entries) {, +                entry.writeTo(out);, +            builder.startArray(name);, +            for (Entry entry : entries) {, +                entry.toXContent(builder, params);, +         * Represents a part from the suggest text with suggested options., +        public static class Entry implements Iterable<Entry.Option>, Streamable, ToXContent {, +                static final XContentBuilderString TEXT = new XContentBuilderString("text");, +                static final XContentBuilderString OFFSET = new XContentBuilderString("offset");, +                static final XContentBuilderString LENGTH = new XContentBuilderString("length");, +                static final XContentBuilderString OPTIONS = new XContentBuilderString("options");, +            private Text text;, +            private int offset;, +            private int length;, +            private List<Option> options;, +            Entry(Text text, int offset, int length) {, +                this.text = text;, +                this.offset = offset;, +                this.length = length;, +                this.options = new ArrayList<Option>(5);, +            Entry() {, +            void addOption(Option option) {, +                options.add(option);, +            void reduce(Entry otherEntry, Sort sort) {, +                assert text.equals(otherEntry.text);, +                assert offset == otherEntry.offset;, +                assert length == otherEntry.length;, +                for (Option otherOption : otherEntry.options) {, +                    int index = options.indexOf(otherOption);, +                        Option thisOption = options.get(index);, +                        thisOption.setFreq(thisOption.freq + otherOption.freq);, +                        options.add(otherOption);, +                Comparator<Option> comparator;, +                Collections.sort(options, comparator);, +             * @return the text (analyzed by suggest analyzer) originating from the suggest text. Usually this is a, +             *         single term., +            public Text getText() {, +                return text;, +             * @return the start offset (not analyzed) for this entry in the suggest text., +            public int getOffset() {, +                return offset;, +             * @return the length (not analyzed) for this entry in the suggest text., +            public int getLength() {, +                return length;, +            }, +, +            @Override, +            public Iterator<Option> iterator() {, +                return options.iterator();, +             * @return The suggested options for this particular suggest entry. If there are no suggested terms then, +            public List<Option> getOptions() {, +                return options;, +                int optionsToRemove = Math.max(0, options.size() - size);, +                for (int i = 0; i < optionsToRemove; i++) {, +                    options.remove(options.size() - 1);, +                Entry entry = (Entry) o;, +                if (length != entry.length) return false;, +                if (offset != entry.offset) return false;, +                if (!this.text.equals(entry.text)) return false;, +                int result = text.hashCode();, +                result = 31 * result + offset;, +                result = 31 * result + length;, +            static Entry read(StreamInput in) throws IOException {, +                Entry entry = new Entry();, +                entry.readFrom(in);, +                return entry;, +                text = in.readText();, +                offset = in.readVInt();, +                length = in.readVInt();, +                options = new ArrayList<Option>(suggestedWords);, +                    options.add(Option.create(in));, +                out.writeText(text);, +                out.writeVInt(offset);, +                out.writeVInt(length);]