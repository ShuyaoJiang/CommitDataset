[+++ b/docs/reference/rest-api/info.asciidoc, +++ b/docs/reference/rest-api/info.asciidoc, +++ b/server/src/main/java/org/elasticsearch/index/get/GetResult.java, +import org.elasticsearch.common.Strings;, +import org.elasticsearch.index.mapper.IgnoredFieldMapper;, +            // TODO: can we avoid having an exception here?, +            if (field.getName().equals(IgnoredFieldMapper.NAME)) {, +                builder.field(field.getName(), field.getValues());, +            } else {, +                builder.field(field.getName(), field.<Object>getValue());, +            }, +                if (IgnoredFieldMapper.NAME.equals(currentFieldName)) {, +                    fields.put(currentFieldName, new DocumentField(currentFieldName, parser.list()));, +                } else {, +        }, +        return Objects.hash(version, exists, index, type, id, fields, sourceAsMap());, +    }, +, +    @Override, +    public String toString() {, +        return Strings.toString(this, true, true);, +++ b/docs/reference/rest-api/info.asciidoc, +++ b/server/src/main/java/org/elasticsearch/index/get/GetResult.java, +import org.elasticsearch.common.Strings;, +import org.elasticsearch.index.mapper.IgnoredFieldMapper;, +            // TODO: can we avoid having an exception here?, +            if (field.getName().equals(IgnoredFieldMapper.NAME)) {, +                builder.field(field.getName(), field.getValues());, +            } else {, +                builder.field(field.getName(), field.<Object>getValue());, +            }, +                if (IgnoredFieldMapper.NAME.equals(currentFieldName)) {, +                    fields.put(currentFieldName, new DocumentField(currentFieldName, parser.list()));, +                } else {, +        }, +        return Objects.hash(version, exists, index, type, id, fields, sourceAsMap());, +    }, +, +    @Override, +    public String toString() {, +        return Strings.toString(this, true, true);, +++ b/server/src/main/java/org/elasticsearch/search/SearchHit.java, +                if (metadatafield.equals(IgnoredFieldMapper.NAME)) {, +                    parser.declareObjectArray((map, list) -> {, +                            @SuppressWarnings("unchecked"), +                            Map<String, DocumentField> fieldMap = (Map<String, DocumentField>) map.computeIfAbsent(Fields.FIELDS,, +                                v -> new HashMap<String, DocumentField>());, +                            DocumentField field = new DocumentField(metadatafield, list);, +                            fieldMap.put(field.getName(), field);, +                        }, (p, c) -> parseFieldsValue(p),, +                        new ParseField(metadatafield));, +                } else {, +                        }, (p, c) -> new DocumentField(metadatafield, Collections.singletonList(parseFieldsValue(p))),, +                        new ParseField(metadatafield), ValueType.VALUE);, +                }, +, +    @Override, +    public String toString() {, +        return Strings.toString(this, true, true);, +    }, +++ b/docs/reference/rest-api/info.asciidoc, +++ b/server/src/main/java/org/elasticsearch/index/get/GetResult.java, +import org.elasticsearch.common.Strings;, +import org.elasticsearch.index.mapper.IgnoredFieldMapper;, +            // TODO: can we avoid having an exception here?, +            if (field.getName().equals(IgnoredFieldMapper.NAME)) {, +                builder.field(field.getName(), field.getValues());, +            } else {, +                builder.field(field.getName(), field.<Object>getValue());, +            }, +                if (IgnoredFieldMapper.NAME.equals(currentFieldName)) {, +                    fields.put(currentFieldName, new DocumentField(currentFieldName, parser.list()));, +                } else {, +        }, +        return Objects.hash(version, exists, index, type, id, fields, sourceAsMap());, +    }, +, +    @Override, +    public String toString() {, +        return Strings.toString(this, true, true);, +++ b/server/src/main/java/org/elasticsearch/search/SearchHit.java, +                if (metadatafield.equals(IgnoredFieldMapper.NAME)) {, +                    parser.declareObjectArray((map, list) -> {, +                            @SuppressWarnings("unchecked"), +                            Map<String, DocumentField> fieldMap = (Map<String, DocumentField>) map.computeIfAbsent(Fields.FIELDS,, +                                v -> new HashMap<String, DocumentField>());, +                            DocumentField field = new DocumentField(metadatafield, list);, +                            fieldMap.put(field.getName(), field);, +                        }, (p, c) -> parseFieldsValue(p),, +                        new ParseField(metadatafield));, +                } else {, +                        }, (p, c) -> new DocumentField(metadatafield, Collections.singletonList(parseFieldsValue(p))),, +                        new ParseField(metadatafield), ValueType.VALUE);, +                }, +, +    @Override, +    public String toString() {, +        return Strings.toString(this, true, true);, +    }, +++ b/server/src/test/java/org/elasticsearch/index/get/DocumentFieldTests.java]