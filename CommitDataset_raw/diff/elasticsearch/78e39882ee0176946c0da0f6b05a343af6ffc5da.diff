[+++ b/src/main/java/org/elasticsearch/index/merge/scheduler/ConcurrentMergeSchedulerProvider.java, +import org.elasticsearch.index.settings.IndexSettingsService;, +    private final IndexSettingsService indexSettingsService;, +    private final ApplySettings applySettings = new ApplySettings();, +, +    private volatile int maxThreadCount;, +    private volatile int maxMergeCount;, +    public ConcurrentMergeSchedulerProvider(ShardId shardId, @IndexSettings Settings indexSettings, ThreadPool threadPool, IndexSettingsService indexSettingsService) {, +        this.indexSettingsService = indexSettingsService;, +        logger.debug("using [concurrent] merge scheduler with max_thread_count[{}], max_merge_count[{}]", maxThreadCount, maxMergeCount);, +, +        indexSettingsService.addListener(applySettings);, +    @Override, +    public void close() {, +        indexSettingsService.removeListener(applySettings);, +    }, +, +, +    class ApplySettings implements IndexSettingsService.Listener {, +        @Override, +        public void onRefreshSettings(Settings settings) {, +            int maxThreadCount = settings.getAsInt("index.merge.scheduler.max_thread_count", ConcurrentMergeSchedulerProvider.this.maxThreadCount);, +            if (maxThreadCount != ConcurrentMergeSchedulerProvider.this.maxThreadCount) {, +                logger.info("updating [max_thread_count] from [{}] to [{}]", ConcurrentMergeSchedulerProvider.this.maxThreadCount, maxThreadCount);, +                ConcurrentMergeSchedulerProvider.this.maxThreadCount = maxThreadCount;, +                for (CustomConcurrentMergeScheduler scheduler : schedulers) {, +                    scheduler.setMaxMergesAndThreads(ConcurrentMergeSchedulerProvider.this.maxMergeCount, maxThreadCount);, +                }, +            }, +, +            int maxMergeCount = settings.getAsInt("index.merge.scheduler.max_merge_count", ConcurrentMergeSchedulerProvider.this.maxMergeCount);, +            if (maxMergeCount != ConcurrentMergeSchedulerProvider.this.maxMergeCount) {, +                logger.info("updating [max_merge_count] from [{}] to [{}]", ConcurrentMergeSchedulerProvider.this.maxMergeCount, maxMergeCount);, +                ConcurrentMergeSchedulerProvider.this.maxMergeCount = maxMergeCount;, +                for (CustomConcurrentMergeScheduler scheduler : schedulers) {, +                    scheduler.setMaxMergesAndThreads(maxMergeCount, ConcurrentMergeSchedulerProvider.this.maxThreadCount);, +                }, +            }, +        }, +    }, +++ b/src/main/java/org/elasticsearch/index/merge/scheduler/ConcurrentMergeSchedulerProvider.java, +import org.elasticsearch.index.settings.IndexSettingsService;, +    private final IndexSettingsService indexSettingsService;, +    private final ApplySettings applySettings = new ApplySettings();, +, +    private volatile int maxThreadCount;, +    private volatile int maxMergeCount;, +    public ConcurrentMergeSchedulerProvider(ShardId shardId, @IndexSettings Settings indexSettings, ThreadPool threadPool, IndexSettingsService indexSettingsService) {, +        this.indexSettingsService = indexSettingsService;, +        logger.debug("using [concurrent] merge scheduler with max_thread_count[{}], max_merge_count[{}]", maxThreadCount, maxMergeCount);, +, +        indexSettingsService.addListener(applySettings);, +    @Override, +    public void close() {, +        indexSettingsService.removeListener(applySettings);, +    }, +, +, +    class ApplySettings implements IndexSettingsService.Listener {, +        @Override, +        public void onRefreshSettings(Settings settings) {, +            int maxThreadCount = settings.getAsInt("index.merge.scheduler.max_thread_count", ConcurrentMergeSchedulerProvider.this.maxThreadCount);, +            if (maxThreadCount != ConcurrentMergeSchedulerProvider.this.maxThreadCount) {, +                logger.info("updating [max_thread_count] from [{}] to [{}]", ConcurrentMergeSchedulerProvider.this.maxThreadCount, maxThreadCount);, +                ConcurrentMergeSchedulerProvider.this.maxThreadCount = maxThreadCount;, +                for (CustomConcurrentMergeScheduler scheduler : schedulers) {, +                    scheduler.setMaxMergesAndThreads(ConcurrentMergeSchedulerProvider.this.maxMergeCount, maxThreadCount);, +                }, +            }, +, +            int maxMergeCount = settings.getAsInt("index.merge.scheduler.max_merge_count", ConcurrentMergeSchedulerProvider.this.maxMergeCount);, +            if (maxMergeCount != ConcurrentMergeSchedulerProvider.this.maxMergeCount) {, +                logger.info("updating [max_merge_count] from [{}] to [{}]", ConcurrentMergeSchedulerProvider.this.maxMergeCount, maxMergeCount);, +                ConcurrentMergeSchedulerProvider.this.maxMergeCount = maxMergeCount;, +                for (CustomConcurrentMergeScheduler scheduler : schedulers) {, +                    scheduler.setMaxMergesAndThreads(maxMergeCount, ConcurrentMergeSchedulerProvider.this.maxThreadCount);, +                }, +            }, +        }, +    }, +++ b/src/main/java/org/elasticsearch/index/merge/scheduler/MergeSchedulerProvider.java, +, +    public abstract void close();, +++ b/src/main/java/org/elasticsearch/index/merge/scheduler/ConcurrentMergeSchedulerProvider.java, +import org.elasticsearch.index.settings.IndexSettingsService;, +    private final IndexSettingsService indexSettingsService;, +    private final ApplySettings applySettings = new ApplySettings();, +, +    private volatile int maxThreadCount;, +    private volatile int maxMergeCount;, +    public ConcurrentMergeSchedulerProvider(ShardId shardId, @IndexSettings Settings indexSettings, ThreadPool threadPool, IndexSettingsService indexSettingsService) {, +        this.indexSettingsService = indexSettingsService;, +        logger.debug("using [concurrent] merge scheduler with max_thread_count[{}], max_merge_count[{}]", maxThreadCount, maxMergeCount);, +, +        indexSettingsService.addListener(applySettings);, +    @Override, +    public void close() {, +        indexSettingsService.removeListener(applySettings);, +    }, +]