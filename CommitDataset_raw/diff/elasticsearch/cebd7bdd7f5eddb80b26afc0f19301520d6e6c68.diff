[+++ b/core/src/main/java/org/elasticsearch/index/mapper/MapperService.java, +                // simulate first, +                MergeResult result = oldMapper.merge(mapper.mapping(), true, updateAllTypes);, +                    throw new MergeMappingException(result.buildConflicts());, +                // then apply for real, +                result = oldMapper.merge(mapper.mapping(), false, updateAllTypes);, +                assert result.hasConflicts() == false; // we already simulated, +++ b/core/src/main/java/org/elasticsearch/index/mapper/MapperService.java, +                // simulate first, +                MergeResult result = oldMapper.merge(mapper.mapping(), true, updateAllTypes);, +                    throw new MergeMappingException(result.buildConflicts());, +                // then apply for real, +                result = oldMapper.merge(mapper.mapping(), false, updateAllTypes);, +                assert result.hasConflicts() == false; // we already simulated, +++ b/core/src/test/java/org/elasticsearch/index/mapper/update/UpdateMappingTests.java, +import org.elasticsearch.index.mapper.MergeMappingException;, +import org.elasticsearch.index.mapper.core.LongFieldMapper;, +    public void testConflictSameType() throws Exception {, +        XContentBuilder mapping = XContentFactory.jsonBuilder().startObject().startObject("type"), +                .startObject("properties").startObject("foo").field("type", "long").endObject(), +                .endObject().endObject().endObject();, +        MapperService mapperService = createIndex("test", Settings.settingsBuilder().build(), "type", mapping).mapperService();, +, +        XContentBuilder update = XContentFactory.jsonBuilder().startObject().startObject("type"), +                .startObject("properties").startObject("foo").field("type", "double").endObject(), +                .endObject().endObject().endObject();, +, +        try {, +            mapperService.merge("type", new CompressedXContent(update.string()), false, false);, +            fail();, +        } catch (MergeMappingException e) {, +            // expected, +        }, +, +        try {, +            mapperService.merge("type", new CompressedXContent(update.string()), false, false);, +            fail();, +        } catch (MergeMappingException e) {, +            // expected, +        }, +, +        assertTrue(mapperService.documentMapper("type").mapping().root().getMapper("foo") instanceof LongFieldMapper);, +    }, +, +    public void testConflictNewType() throws Exception {, +        XContentBuilder mapping = XContentFactory.jsonBuilder().startObject().startObject("type1"), +                .startObject("properties").startObject("foo").field("type", "long").endObject(), +                .endObject().endObject().endObject();, +        MapperService mapperService = createIndex("test", Settings.settingsBuilder().build(), "type1", mapping).mapperService();, +, +        XContentBuilder update = XContentFactory.jsonBuilder().startObject().startObject("type2"), +                .startObject("properties").startObject("foo").field("type", "double").endObject(), +                .endObject().endObject().endObject();, +, +        try {, +            mapperService.merge("type2", new CompressedXContent(update.string()), false, false);, +            fail();, +        } catch (IllegalArgumentException e) {, +            // expected, +            assertTrue(e.getMessage().contains("conflicts with existing mapping in other types"));, +        }, +, +        try {, +            mapperService.merge("type2", new CompressedXContent(update.string()), false, false);, +            fail();, +        } catch (IllegalArgumentException e) {, +            // expected, +            assertTrue(e.getMessage().contains("conflicts with existing mapping in other types"));, +        }, +, +        assertTrue(mapperService.documentMapper("type1").mapping().root().getMapper("foo") instanceof LongFieldMapper);, +        assertNull(mapperService.documentMapper("type2"));, +    }, +, +    // same as the testConflictNewType except that the mapping update is on an existing type, +    @AwaitsFix(bugUrl="https://github.com/elastic/elasticsearch/issues/15049"), +    public void testConflictNewTypeUpdate() throws Exception {, +        XContentBuilder mapping1 = XContentFactory.jsonBuilder().startObject().startObject("type1"), +                .startObject("properties").startObject("foo").field("type", "long").endObject(), +                .endObject().endObject().endObject();, +        XContentBuilder mapping2 = XContentFactory.jsonBuilder().startObject().startObject("type2").endObject().endObject();, +        MapperService mapperService = createIndex("test", Settings.settingsBuilder().build()).mapperService();, +, +        mapperService.merge("type1", new CompressedXContent(mapping1.string()), false, false);, +        mapperService.merge("type2", new CompressedXContent(mapping2.string()), false, false);, +, +        XContentBuilder update = XContentFactory.jsonBuilder().startObject().startObject("type2"), +                .startObject("properties").startObject("foo").field("type", "double").endObject(), +                .endObject().endObject().endObject();, +, +        try {, +            mapperService.merge("type2", new CompressedXContent(update.string()), false, false);, +            fail();, +        } catch (IllegalArgumentException e) {, +            // expected, +            assertTrue(e.getMessage().contains("conflicts with existing mapping in other types"));, +        }, +, +        try {, +            mapperService.merge("type2", new CompressedXContent(update.string()), false, false);]