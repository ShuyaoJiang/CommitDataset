[+++ b/core/src/main/java/org/elasticsearch/index/mapper/DocumentParser.java, +            // We first need the stack to only contain mappers in common with the previously processed mapper, +            // For example, if the first mapper processed was a.b.c, and we now have a.d, the stack will contain, +            // a.b, and we want to merge b back into the stack so it just contains a, +            int i = removeUncommonMappers(parentMappers, nameParts);, +, +            // Then we need to add back mappers that may already exist within the stack, but are not on it., +            // For example, if we processed a.b, followed by an object mapper a.c.d, and now are adding a.c.d.e, +            // then the stack will only have a on it because we will have already merged a.c.d into the stack., +            // So we need to pull a.c, followed by a.c.d, onto the stack so e can be added to the end., +            i = expandCommonMappers(parentMappers, nameParts, i);, +, +            // If there are still parents of the new mapper which are not on the stack, we need to pull them, +            // from the existing mappings. In order to maintain the invariant that the stack only contains, +            // fields which are updated, we cannot simply add the existing mappers to the stack, since they, +            // may have other subfields which will not be updated. Instead, we pull the mapper from the existing, +            // mappings, and build an update with only the new mapper and its parents. This then becomes our, +            // "new mapper", and can be added to the stack., +            if (i < nameParts.length - 1) {, +                newMapper = createExistingMapperUpdate(parentMappers, nameParts, i, docMapper, newMapper);, +    /**, +     * Removes mappers that exist on the stack, but are not part of the path of the current nameParts,, +     * Returns the next unprocessed index from nameParts., +     */, +    private static int removeUncommonMappers(List<ObjectMapper> parentMappers, String[] nameParts) {, +        int keepBefore = 1;, +        while (keepBefore < parentMappers.size() &&, +            parentMappers.get(keepBefore).simpleName().equals(nameParts[keepBefore - 1])) {, +            ++keepBefore;, +        }, +        popMappers(parentMappers, keepBefore, true);, +        return keepBefore - 1;, +    }, +, +    /**, +     * Adds mappers from the end of the stack that exist as updates within those mappers., +     * Returns the next unprocessed index from nameParts., +     */, +    private static int expandCommonMappers(List<ObjectMapper> parentMappers, String[] nameParts, int i) {, +        ObjectMapper last = parentMappers.get(parentMappers.size() - 1);, +        while (i < nameParts.length - 1 && last.getMapper(nameParts[i]) != null) {, +            Mapper newLast = last.getMapper(nameParts[i]);, +            assert newLast instanceof ObjectMapper;, +            parentMappers.add((ObjectMapper)newLast);, +            ++i;, +        }, +        return i;, +    }, +, +    /** Creates an update for intermediate object mappers that are not on the stack, but parents of newMapper. */, +    private static ObjectMapper createExistingMapperUpdate(List<ObjectMapper> parentMappers, String[] nameParts, int i,, +                                                           DocumentMapper docMapper, Mapper newMapper) {, +        String updateParentName = nameParts[i];, +        final ObjectMapper lastParent = parentMappers.get(parentMappers.size() - 1);, +        if (parentMappers.size() > 1) {, +            // only prefix with parent mapper if the parent mapper isn't the root (which has a fake name), +            updateParentName = lastParent.name() + '.' + nameParts[i];, +        }, +        ObjectMapper updateParent = docMapper.objectMappers().get(updateParentName);, +        assert updateParent != null : updateParentName + " doesn't exist";, +        return createUpdate(updateParent, nameParts, i + 1, newMapper);, +    }, +, +            assert intermediate != null : "Field " + previousIntermediate.name() + " does not have a subfield " + nameParts[i];, +++ b/core/src/main/java/org/elasticsearch/index/mapper/DocumentParser.java, +            // We first need the stack to only contain mappers in common with the previously processed mapper, +            // For example, if the first mapper processed was a.b.c, and we now have a.d, the stack will contain, +            // a.b, and we want to merge b back into the stack so it just contains a, +            int i = removeUncommonMappers(parentMappers, nameParts);, +, +            // Then we need to add back mappers that may already exist within the stack, but are not on it., +            // For example, if we processed a.b, followed by an object mapper a.c.d, and now are adding a.c.d.e, +            // then the stack will only have a on it because we will have already merged a.c.d into the stack., +            // So we need to pull a.c, followed by a.c.d, onto the stack so e can be added to the end., +            i = expandCommonMappers(parentMappers, nameParts, i);, +, +            // If there are still parents of the new mapper which are not on the stack, we need to pull them, +            // from the existing mappings. In order to maintain the invariant that the stack only contains, +            // fields which are updated, we cannot simply add the existing mappers to the stack, since they, +            // may have other subfields which will not be updated. Instead, we pull the mapper from the existing, +            // mappings, and build an update with only the new mapper and its parents. This then becomes our, +            // "new mapper", and can be added to the stack., +            if (i < nameParts.length - 1) {, +                newMapper = createExistingMapperUpdate(parentMappers, nameParts, i, docMapper, newMapper);, +    /**, +     * Removes mappers that exist on the stack, but are not part of the path of the current nameParts,, +     * Returns the next unprocessed index from nameParts., +     */, +    private static int removeUncommonMappers(List<ObjectMapper> parentMappers, String[] nameParts) {, +        int keepBefore = 1;, +        while (keepBefore < parentMappers.size() &&, +            parentMappers.get(keepBefore).simpleName().equals(nameParts[keepBefore - 1])) {, +            ++keepBefore;, +        }, +        popMappers(parentMappers, keepBefore, true);, +        return keepBefore - 1;, +    }, +, +    /**, +     * Adds mappers from the end of the stack that exist as updates within those mappers.]