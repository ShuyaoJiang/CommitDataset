[+++ b/src/main/java/org/elasticsearch/common/joda/DateMathParser.java, +            // we create a date time for inclusive upper range, we "include" by default the day level data, +            // so something like 2011-01-01 will include the full first day of 2011., +            // we also use 1970-01-01 as the base for it so we can handle searches like 10:12:55 (just time), +            // since when we index those, the base is 1970-01-01, +            MutableDateTime dateTime = new MutableDateTime(1970, 1, 1, 23, 59, 59, 999, DateTimeZone.UTC);, +++ b/src/main/java/org/elasticsearch/common/joda/DateMathParser.java, +            // we create a date time for inclusive upper range, we "include" by default the day level data, +            // so something like 2011-01-01 will include the full first day of 2011., +            // we also use 1970-01-01 as the base for it so we can handle searches like 10:12:55 (just time), +            // since when we index those, the base is 1970-01-01, +            MutableDateTime dateTime = new MutableDateTime(1970, 1, 1, 23, 59, 59, 999, DateTimeZone.UTC);, +++ b/src/test/java/org/elasticsearch/test/unit/index/mapper/date/SimpleDateMappingTests.java, +import org.apache.lucene.search.Filter;, +import org.apache.lucene.search.NumericRangeFilter;, +import org.elasticsearch.common.unit.TimeValue;, +import org.elasticsearch.index.mapper.core.LongFieldMapper;, +import org.joda.time.DateTime;, +import org.joda.time.DateTimeZone;, +    public void testHourFormat() throws Exception {, +        String mapping = XContentFactory.jsonBuilder().startObject().startObject("type"), +                .field("date_detection", false), +                .startObject("properties").startObject("date_field").field("type", "date").field("format", "HH:mm:ss").endObject().endObject(), +                .endObject().endObject().string();, +, +        DocumentMapper defaultMapper = MapperTests.newParser().parse(mapping);, +, +        ParsedDocument doc = defaultMapper.parse("type", "1", XContentFactory.jsonBuilder(), +                .startObject(), +                .field("date_field", "10:00:00"), +                .endObject(), +                .bytes());, +        assertThat(((LongFieldMapper.CustomLongNumericField) doc.rootDoc().getField("date_field")).numericAsString(), equalTo(Long.toString(new DateTime(TimeValue.timeValueHours(10).millis(), DateTimeZone.UTC).getMillis())));, +, +        Filter filter = defaultMapper.mappers().smartNameFieldMapper("date_field").rangeFilter("10:00:00", "11:00:00", true, true, null);, +        assertThat(filter, instanceOf(NumericRangeFilter.class));, +        NumericRangeFilter<Long> rangeFilter = (NumericRangeFilter<Long>) filter;, +        assertThat(rangeFilter.getMax(), equalTo(new DateTime(TimeValue.timeValueHours(11).millis() + 999).getMillis())); // +999 to include the 00-01 minute, +        assertThat(rangeFilter.getMin(), equalTo(new DateTime(TimeValue.timeValueHours(10).millis()).getMillis()));, +    }, +, +    @Test]