[+++ b/src/main/java/org/elasticsearch/search/aggregations/bucket/terms/DoubleTerms.java, +            InternalTerms terms = (InternalTerms) aggregations.get(0);, +            terms.trimExcessEntries();, +            return terms;, +        Recycler.V<DoubleObjectOpenHashMap<List<Bucket>>> buckets = null;, +            if (buckets == null) {, +                buckets = reduceContext.cacheRecycler().doubleObjectMap(terms.buckets.size());, +            }, +++ b/src/main/java/org/elasticsearch/search/aggregations/bucket/terms/DoubleTerms.java, +            InternalTerms terms = (InternalTerms) aggregations.get(0);, +            terms.trimExcessEntries();, +            return terms;, +        Recycler.V<DoubleObjectOpenHashMap<List<Bucket>>> buckets = null;, +            if (buckets == null) {, +                buckets = reduceContext.cacheRecycler().doubleObjectMap(terms.buckets.size());, +            }, +++ b/src/main/java/org/elasticsearch/search/aggregations/bucket/terms/DoubleTermsAggregator.java, +    private final int shardSize;, +                               InternalOrder order, int requiredSize, int shardSize, AggregationContext aggregationContext, Aggregator parent) {, +        this.shardSize = shardSize;, +        final int size = (int) Math.min(bucketOrds.size(), shardSize);, +++ b/src/main/java/org/elasticsearch/search/aggregations/bucket/terms/DoubleTerms.java, +            InternalTerms terms = (InternalTerms) aggregations.get(0);, +            terms.trimExcessEntries();, +            return terms;, +        Recycler.V<DoubleObjectOpenHashMap<List<Bucket>>> buckets = null;, +            if (buckets == null) {, +                buckets = reduceContext.cacheRecycler().doubleObjectMap(terms.buckets.size());, +            }, +++ b/src/main/java/org/elasticsearch/search/aggregations/bucket/terms/DoubleTermsAggregator.java, +    private final int shardSize;, +                               InternalOrder order, int requiredSize, int shardSize, AggregationContext aggregationContext, Aggregator parent) {, +        this.shardSize = shardSize;, +        final int size = (int) Math.min(bucketOrds.size(), shardSize);, +++ b/src/main/java/org/elasticsearch/search/aggregations/bucket/terms/InternalTerms.java, +            InternalTerms terms = (InternalTerms) aggregations.get(0);, +            terms.trimExcessEntries();, +            return terms;, +        Map<Text, List<InternalTerms.Bucket>> buckets = null;, +            if (buckets == null) {, +                buckets = new HashMap<Text, List<Bucket>>(terms.buckets.size());, +            }, +    protected void trimExcessEntries() {, +        if (requiredSize >= buckets.size()) {, +            return;, +        }, +, +        if (buckets instanceof List) {, +            buckets = ((List) buckets).subList(0, requiredSize);, +            return;, +        }, +, +        int i = 0;, +        for (Iterator<Bucket> iter  = buckets.iterator(); iter.hasNext();) {, +            iter.next();, +            if (i++ >= requiredSize) {, +                iter.remove();, +            }, +        }, +    }, +, +++ b/src/main/java/org/elasticsearch/search/aggregations/bucket/terms/DoubleTerms.java, +            InternalTerms terms = (InternalTerms) aggregations.get(0);, +            terms.trimExcessEntries();, +            return terms;, +        Recycler.V<DoubleObjectOpenHashMap<List<Bucket>>> buckets = null;, +            if (buckets == null) {, +                buckets = reduceContext.cacheRecycler().doubleObjectMap(terms.buckets.size());, +            }, +++ b/src/main/java/org/elasticsearch/search/aggregations/bucket/terms/DoubleTermsAggregator.java, +    private final int shardSize;, +                               InternalOrder order, int requiredSize, int shardSize, AggregationContext aggregationContext, Aggregator parent) {, +        this.shardSize = shardSize;, +        final int size = (int) Math.min(bucketOrds.size(), shardSize);, +++ b/src/main/java/org/elasticsearch/search/aggregations/bucket/terms/InternalTerms.java, +            InternalTerms terms = (InternalTerms) aggregations.get(0);, +            terms.trimExcessEntries();, +            return terms;, +        Map<Text, List<InternalTerms.Bucket>> buckets = null;, +            if (buckets == null) {, +                buckets = new HashMap<Text, List<Bucket>>(terms.buckets.size());, +            }, +    protected void trimExcessEntries() {, +        if (requiredSize >= buckets.size()) {, +            return;, +        }, +, +        if (buckets instanceof List) {, +            buckets = ((List) buckets).subList(0, requiredSize);, +            return;, +        }, +, +        int i = 0;, +        for (Iterator<Bucket> iter  = buckets.iterator(); iter.hasNext();) {, +            iter.next();, +            if (i++ >= requiredSize) {, +                iter.remove();, +            }, +        }, +    }]