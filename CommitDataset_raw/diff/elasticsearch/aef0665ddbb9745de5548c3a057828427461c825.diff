[+++ b/core/src/main/java/org/elasticsearch/action/search/AbstractSearchAsyncAction.java, +import org.apache.lucene.util.SetOnce;, +import org.elasticsearch.ElasticsearchException;, +import org.elasticsearch.ExceptionsHelper;, +import org.elasticsearch.action.ShardOperationFailedException;, +import java.util.StringJoiner;, +import java.util.stream.Collectors;, +abstract class AbstractSearchAsyncAction<Result extends SearchPhaseResult> extends InitialSearchPhase<Result>, +    implements SearchPhaseContext {, +    private final Logger logger;, +    private final SearchTransportService searchTransportService;, +    private final ActionListener<SearchResponse> listener;, +    private final SearchRequest request;, +    /**, +     * Used by subclasses to resolve node ids to DiscoveryNodes., +     **/, +    private final Function<String, Transport.Connection> nodeIdToConnection;, +    private final SearchTask task;, +    private final AtomicArray<Result> results;, +    private final long clusterStateVersion;, +    private final SetOnce<AtomicArray<ShardSearchFailure>> shardFailures = new SetOnce<>();, +    private final AtomicInteger successfulOps = new AtomicInteger();, +    private final long startTime;, +, +    protected AbstractSearchAsyncAction(String name, Logger logger, SearchTransportService searchTransportService,, +                                        Executor executor, SearchRequest request,, +        super(name, request, shardsIts, logger);, +        this.startTime = startTime;, +        results = new AtomicArray<>(shardsIts.size());, +        this.aliasFilter = aliasFilter;, +    /**, +     * Builds how long it took to execute the search., +     */, +    private long buildTookInMillis() {, +        // protect ourselves against time going backwards, +        // negative values don't make sense and we want to be able to serialize that thing as a vLong, +        return Math.max(1, System.currentTimeMillis() - startTime);, +    }, +, +    /**, +     * This is the main entry point for a search. This method starts the search execution of the initial phase., +     */, +    public final void start() {, +        if (results.length() == 0) {, +        executePhase(this);, +    public final void executeNextPhase(SearchPhase currentPhase, SearchPhase nextPhase) {, +        /* This is the main search phase transition where we move to the next phase. At this point we check if there is, +         * at least one successful operation left and if so we move to the next phase. If not we immediately fail the, +         * search phase as "all shards failed"*/, +        if (successfulOps.get() == 0) { // we have 0 successful results that means we shortcut stuff and return a failure, +            if (logger.isDebugEnabled()) {, +                final ShardOperationFailedException[] shardSearchFailures = ExceptionsHelper.groupBy(buildShardFailures());, +                Throwable cause = ElasticsearchException.guessRootCauses(shardSearchFailures[0].getCause())[0];, +                logger.debug((Supplier<?>) () -> new ParameterizedMessage("All shards failed for phase: [{}]", getName()),, +                    cause);, +            onPhaseFailure(currentPhase, "all shards failed", null);, +        } else {, +            if (logger.isTraceEnabled()) {, +                final String resultsFrom = results.asList().stream(), +                    .map(r -> r.value.shardTarget().toString()).collect(Collectors.joining(","));, +                logger.trace("[{}] Moving to next phase: [{}], based on results from: {} (cluster state version: {})",, +                    currentPhase.getName(), nextPhase.getName(), resultsFrom, clusterStateVersion);, +            executePhase(nextPhase);, +    private void executePhase(SearchPhase phase) {, +                        "Failed to execute [{}] while moving to [{}] phase", request, phase.getName()),, +            onPhaseFailure(phase, "", e);, +    private ShardSearchFailure[] buildShardFailures() {, +        AtomicArray<ShardSearchFailure> shardFailures = this.shardFailures.get();, +    public final void onShardFailure(final int shardIndex, @Nullable SearchShardTarget shardTarget, Exception e) {, +        AtomicArray<ShardSearchFailure> shardFailures = this.shardFailures.get();, +        if (shardFailures == null) { // this is double checked locking but it's fine since SetOnce uses a volatile read internally, +                shardFailures = this.shardFailures.get(); // read again otherwise somebody else has created it?, +                if (shardFailures == null) { // still null so we are the first and create a new instance, +                    shardFailures = new AtomicArray<>(results.length());, +                    this.shardFailures.set(shardFailures);, +, +        if (results.get(shardIndex) != null) {, +            assert failure == null : "shard failed before but shouldn't: " + failure;, +            successfulOps.decrementAndGet(); // if this shard was successful before (initial phase) we have to adjust the counter, +        }, +     *, +    private void raisePhaseFailure(SearchPhaseExecutionException exception) {, +        for (AtomicArray.Entry<Result> entry : results.asList()) {, +    @Override, +    public final void onShardSuccess(int shardIndex, Result result) {, +        successfulOps.incrementAndGet();, +        results.set(shardIndex, result);, +        AtomicArray<ShardSearchFailure> shardFailures = this.shardFailures.get();, +    @Override, +    public final void onPhaseDone() {, +        executeNextPhase(this, getNextPhase(results, this));, +    public final int getNumShards() {, +        return results.length();, +    public final Logger getLogger() {, +        return logger;, +    public final SearchTask getTask() {, +        return task;, +, +    @Override, +    public final SearchRequest getRequest() {]