[+++ b/server/src/main/java/org/elasticsearch/common/settings/AbstractScopedSettings.java, +    /**, +     * Adds a affix settings consumer that accepts the settings for a group of settings. The consumer is only, +     * notified if at least one of the settings change., +     * <p>, +     * Note: Only settings registered in {@link SettingsModule} can be changed dynamically., +     * </p>, +     */, +    public synchronized void addAffixGroupUpdateConsumer(List<Setting.AffixSetting<?>> settings, BiConsumer<String, Settings> consumer) {, +        List<SettingUpdater> affixUpdaters = new ArrayList<>(settings.size());, +        for (Setting.AffixSetting<?> setting : settings) {, +            ensureSettingIsRegistered(setting);, +            affixUpdaters.add(setting.newAffixUpdater((a,b)-> {}, logger, (a,b)-> {}));, +        }, +, +        addSettingsUpdater(new SettingUpdater<Map<String, Settings>>() {, +, +            @Override, +            public boolean hasChanged(Settings current, Settings previous) {, +                return affixUpdaters.stream().anyMatch(au -> au.hasChanged(current, previous));, +            }, +, +            @Override, +            public Map<String, Settings> getValue(Settings current, Settings previous) {, +                Set<String> namespaces = new HashSet<>();, +                for (Setting.AffixSetting<?> setting : settings) {, +                    SettingUpdater affixUpdaterA = setting.newAffixUpdater((k, v) -> namespaces.add(k), logger, (a, b) ->{});, +                    affixUpdaterA.apply(current, previous);, +                }, +                Map<String, Settings> namespaceToSettings = new HashMap<>(namespaces.size());, +                for (String namespace : namespaces) {, +                    Set<String> concreteSettings = new HashSet<>(settings.size());, +                    for (Setting.AffixSetting<?> setting : settings) {, +                        concreteSettings.add(setting.getConcreteSettingForNamespace(namespace).getKey());, +                    }, +                    namespaceToSettings.put(namespace, current.filter(concreteSettings::contains));, +                }, +                return namespaceToSettings;, +            }, +, +            @Override, +            public void apply(Map<String, Settings> values, Settings current, Settings previous) {, +                for (Map.Entry<String, Settings> entry : values.entrySet()) {, +                    consumer.accept(entry.getKey(), entry.getValue());, +                }, +            }, +        });, +    }, +, +++ b/server/src/main/java/org/elasticsearch/common/settings/AbstractScopedSettings.java, +    /**, +     * Adds a affix settings consumer that accepts the settings for a group of settings. The consumer is only, +     * notified if at least one of the settings change., +     * <p>, +     * Note: Only settings registered in {@link SettingsModule} can be changed dynamically., +     * </p>, +     */, +    public synchronized void addAffixGroupUpdateConsumer(List<Setting.AffixSetting<?>> settings, BiConsumer<String, Settings> consumer) {, +        List<SettingUpdater> affixUpdaters = new ArrayList<>(settings.size());, +        for (Setting.AffixSetting<?> setting : settings) {, +            ensureSettingIsRegistered(setting);, +            affixUpdaters.add(setting.newAffixUpdater((a,b)-> {}, logger, (a,b)-> {}));, +        }, +, +        addSettingsUpdater(new SettingUpdater<Map<String, Settings>>() {, +, +            @Override, +            public boolean hasChanged(Settings current, Settings previous) {, +                return affixUpdaters.stream().anyMatch(au -> au.hasChanged(current, previous));, +            }, +, +            @Override, +            public Map<String, Settings> getValue(Settings current, Settings previous) {, +                Set<String> namespaces = new HashSet<>();, +                for (Setting.AffixSetting<?> setting : settings) {, +                    SettingUpdater affixUpdaterA = setting.newAffixUpdater((k, v) -> namespaces.add(k), logger, (a, b) ->{});, +                    affixUpdaterA.apply(current, previous);, +                }, +                Map<String, Settings> namespaceToSettings = new HashMap<>(namespaces.size());, +                for (String namespace : namespaces) {, +                    Set<String> concreteSettings = new HashSet<>(settings.size());, +                    for (Setting.AffixSetting<?> setting : settings) {, +                        concreteSettings.add(setting.getConcreteSettingForNamespace(namespace).getKey());, +                    }, +                    namespaceToSettings.put(namespace, current.filter(concreteSettings::contains));, +                }, +                return namespaceToSettings;, +            }, +, +            @Override, +            public void apply(Map<String, Settings> values, Settings current, Settings previous) {, +                for (Map.Entry<String, Settings> entry : values.entrySet()) {, +                    consumer.accept(entry.getKey(), entry.getValue());, +                }, +            }, +        });, +    }, +, +++ b/server/src/test/java/org/elasticsearch/common/settings/ScopedSettingsTests.java, +    public void testAffixGroupUpdateConsumer() {]