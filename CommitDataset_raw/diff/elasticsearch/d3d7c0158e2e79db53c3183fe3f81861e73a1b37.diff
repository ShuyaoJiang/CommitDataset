[+++ b/server/src/main/java/org/elasticsearch/action/support/replication/TransportReplicationAction.java, +                || TransportActions.isShardNotAvailableException(e);, +                    DiscoveryNode relocatingNode = clusterService.state().nodes().get(primary.relocatingNodeId());, +            if (handleBlockExceptions(state)) {, +                return;, +, +            final String concreteIndex = concreteIndex(state);, +            assert request.waitForActiveShards() != ActiveShardCount.DEFAULT : "request waitForActiveShards must be set in resolveRequest";, +        private String concreteIndex(ClusterState state) {, +            return resolveIndex() ? indexNameExpressionResolver.concreteSingleIndex(state, request).getName() : request.index();, +        }, +, +        private boolean handleBlockExceptions(ClusterState state) {, +            ClusterBlockLevel globalBlockLevel = globalBlockLevel();, +            if (globalBlockLevel != null) {, +                ClusterBlockException blockException = state.blocks().globalBlockedException(globalBlockLevel);, +                if (blockException != null) {, +                    handleBlockException(blockException);, +                    return true;, +                }, +            }, +            ClusterBlockLevel indexBlockLevel = indexBlockLevel();, +            if (indexBlockLevel != null) {, +                ClusterBlockException blockException = state.blocks().indexBlockedException(indexBlockLevel, concreteIndex(state));, +                if (blockException != null) {, +                    handleBlockException(blockException);, +                    return true;, +                }, +            }, +            return false;, +        }, +, +        private void handleBlockException(ClusterBlockException blockException) {, +            if (blockException.retryable()) {, +                logger.trace("cluster is blocked, scheduling a retry", blockException);, +                retry(blockException);, +            } else {, +                finishAsFailed(blockException);, +            }, +        }, +, +++ b/server/src/main/java/org/elasticsearch/action/support/replication/TransportReplicationAction.java, +                || TransportActions.isShardNotAvailableException(e);, +                    DiscoveryNode relocatingNode = clusterService.state().nodes().get(primary.relocatingNodeId());, +            if (handleBlockExceptions(state)) {, +                return;, +, +            final String concreteIndex = concreteIndex(state);, +            assert request.waitForActiveShards() != ActiveShardCount.DEFAULT : "request waitForActiveShards must be set in resolveRequest";, +        private String concreteIndex(ClusterState state) {, +            return resolveIndex() ? indexNameExpressionResolver.concreteSingleIndex(state, request).getName() : request.index();, +        }, +, +        private boolean handleBlockExceptions(ClusterState state) {, +            ClusterBlockLevel globalBlockLevel = globalBlockLevel();, +            if (globalBlockLevel != null) {, +                ClusterBlockException blockException = state.blocks().globalBlockedException(globalBlockLevel);, +                if (blockException != null) {, +                    handleBlockException(blockException);, +                    return true;, +                }, +            }, +            ClusterBlockLevel indexBlockLevel = indexBlockLevel();, +            if (indexBlockLevel != null) {, +                ClusterBlockException blockException = state.blocks().indexBlockedException(indexBlockLevel, concreteIndex(state));, +                if (blockException != null) {, +                    handleBlockException(blockException);, +                    return true;, +                }, +            }, +            return false;, +        }, +, +        private void handleBlockException(ClusterBlockException blockException) {, +            if (blockException.retryable()) {, +                logger.trace("cluster is blocked, scheduling a retry", blockException);, +                retry(blockException);, +            } else {, +                finishAsFailed(blockException);, +            }, +        }, +, +++ b/server/src/test/java/org/elasticsearch/action/support/replication/TransportReplicationActionTests.java, +    <T> void assertListenerThrows(String msg, PlainActionFuture<T> listener, Class<?> klass) throws InterruptedException {, +        try {, +            listener.get();, +            fail(msg);, +        } catch (ExecutionException ex) {, +            assertThat(ex.getCause(), instanceOf(klass));, +        }, +    public void testBlocks() throws ExecutionException, InterruptedException {, +        Request request = new Request();, +        PlainActionFuture<TestResponse> listener = new PlainActionFuture<>();, +        ReplicationTask task = maybeTask();, +        TestAction action = new TestAction(Settings.EMPTY, "internal:testActionWithBlocks",, +                return ClusterBlockLevel.WRITE;, +        ClusterBlocks.Builder block = ClusterBlocks.builder().addGlobalBlock(new ClusterBlock(1, "non retryable", false, true,, +            false, RestStatus.SERVICE_UNAVAILABLE, ClusterBlockLevel.ALL));, +        setState(clusterService, ClusterState.builder(clusterService.state()).blocks(block));, +        assertListenerThrows("primary phase should fail operation", listener, ClusterBlockException.class);]