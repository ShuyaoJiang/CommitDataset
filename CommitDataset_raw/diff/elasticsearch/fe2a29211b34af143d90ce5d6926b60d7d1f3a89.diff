[+++ b/core/src/main/java/org/elasticsearch/action/support/replication/TransportReplicationAction.java, +            if (handleBlockExceptions(state)) {, +            final String concreteIndex = concreteIndex(state);, +            final ShardRouting primary = primary(state);, +            if (retryIfUnavailable(state, primary)) {, +                performLocalAction(state, primary, node);, +            } else {, +                performRemoteAction(state, primary, node);, +            }, +        }, +, +        private void performLocalAction(ClusterState state, ShardRouting primary, DiscoveryNode node) {, +        }, +, +        private void performRemoteAction(ClusterState state, ShardRouting primary, DiscoveryNode node) {, +, +        private boolean retryIfUnavailable(ClusterState state, ShardRouting primary) {, +            if (primary == null || primary.active() == false) {, +                logger.trace("primary shard [{}] is not yet active, scheduling a retry: action [{}], request [{}], cluster state version [{}]", request.shardId(), actionName, request, state.version());, +                retryBecauseUnavailable(request.shardId(), "primary shard is not active");, +                return true;, +            }, +            if (state.nodes().nodeExists(primary.currentNodeId()) == false) {, +                logger.trace("primary shard [{}] is assigned to an unknown node [{}], scheduling a retry: action [{}], request [{}], cluster state version [{}]", request.shardId(), primary.currentNodeId(), actionName, request, state.version());, +                retryBecauseUnavailable(request.shardId(), "primary shard isn't assigned to a known node.");, +                return true;, +            }, +            return false;, +        }, +, +        private String concreteIndex(ClusterState state) {, +            return resolveIndex() ? indexNameExpressionResolver.concreteSingleIndex(state, request) : request.index();, +        }, +, +        private ShardRouting primary(ClusterState state) {, +            IndexShardRoutingTable indexShard = state.getRoutingTable().shardRoutingTable(request.shardId());, +            return indexShard.primaryShard();, +        }, +, +        private boolean handleBlockExceptions(ClusterState state) {, +            ClusterBlockException blockException = state.blocks().globalBlockedException(globalBlockLevel());, +            if (blockException != null) {, +                handleBlockException(blockException);, +                return true;, +            }, +            blockException = state.blocks().indexBlockedException(indexBlockLevel(), concreteIndex(state));, +            if (blockException != null) {, +                handleBlockException(blockException);, +                return true;, +            }, +            return false;]