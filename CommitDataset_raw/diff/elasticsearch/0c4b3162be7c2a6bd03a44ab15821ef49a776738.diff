[+++ b/x-pack/plugin/sql/jdbc/src/main/java/org/elasticsearch/xpack/sql/jdbc/jdbc/JdbcResultSet.java, +        return column(columnIndex) != null ? getObject(columnIndex, Boolean.class) : false; , +        return column(columnIndex) != null ? getObject(columnIndex, Byte.class) : 0;, +        return column(columnIndex) != null ? getObject(columnIndex, Short.class) : 0;, +        return column(columnIndex) != null ? getObject(columnIndex, Integer.class) : 0;, +        return column(columnIndex) != null ? getObject(columnIndex, Long.class) : 0;, +        return column(columnIndex) != null ? getObject(columnIndex, Float.class) : 0;, +        return column(columnIndex) != null ? getObject(columnIndex, Double.class) : 0;, +        // TODO: the error message in case the value in the column cannot be converted to a Date refers to a column index, +        // (for example - "unable to convert column 4 to a long") and not to the column name, which is a bit confusing., +        // Should we reconsider this? Maybe by catching the exception here and rethrowing it with the columnLabel instead., +        JDBCType type = cursor.columns().get(columnIndex - 1).type;, +            // TODO: the B6 appendix of the jdbc spec does mention CHAR, VARCHAR, LONGVARCHAR, DATE, TIMESTAMP as supported, +            // jdbc types that should be handled by getDate and getTime methods. From all of those we support VARCHAR and, +            // TIMESTAMP. Should we consider the VARCHAR conversion as a later enhancement?, +            if (JDBCType.TIMESTAMP.equals(type)) {, +                // the cursor can return an Integer if the date-since-epoch is small enough, XContentParser (Jackson) will, +                // return the "smallest" data type for numbers when parsing, +                // TODO: this should probably be handled server side, +                return val == null ? null : ((Number) val).longValue();, +            };, +            throw new SQLException(, +                    format(Locale.ROOT, "Unable to convert value [%.128s] of type [%s] to a Long", val, type.getName()), cce);, +++ b/x-pack/plugin/sql/jdbc/src/main/java/org/elasticsearch/xpack/sql/jdbc/jdbc/JdbcResultSet.java, +        return column(columnIndex) != null ? getObject(columnIndex, Boolean.class) : false; , +        return column(columnIndex) != null ? getObject(columnIndex, Byte.class) : 0;, +        return column(columnIndex) != null ? getObject(columnIndex, Short.class) : 0;, +        return column(columnIndex) != null ? getObject(columnIndex, Integer.class) : 0;, +        return column(columnIndex) != null ? getObject(columnIndex, Long.class) : 0;, +        return column(columnIndex) != null ? getObject(columnIndex, Float.class) : 0;, +        return column(columnIndex) != null ? getObject(columnIndex, Double.class) : 0;, +        // TODO: the error message in case the value in the column cannot be converted to a Date refers to a column index, +        // (for example - "unable to convert column 4 to a long") and not to the column name, which is a bit confusing., +        // Should we reconsider this? Maybe by catching the exception here and rethrowing it with the columnLabel instead., +        JDBCType type = cursor.columns().get(columnIndex - 1).type;, +            // TODO: the B6 appendix of the jdbc spec does mention CHAR, VARCHAR, LONGVARCHAR, DATE, TIMESTAMP as supported, +            // jdbc types that should be handled by getDate and getTime methods. From all of those we support VARCHAR and, +            // TIMESTAMP. Should we consider the VARCHAR conversion as a later enhancement?, +            if (JDBCType.TIMESTAMP.equals(type)) {, +                // the cursor can return an Integer if the date-since-epoch is small enough, XContentParser (Jackson) will, +                // return the "smallest" data type for numbers when parsing, +                // TODO: this should probably be handled server side, +                return val == null ? null : ((Number) val).longValue();, +            };, +            throw new SQLException(, +                    format(Locale.ROOT, "Unable to convert value [%.128s] of type [%s] to a Long", val, type.getName()), cce);, +++ b/x-pack/plugin/sql/jdbc/src/main/java/org/elasticsearch/xpack/sql/jdbc/jdbc/TypeConverter.java, +    private static final long DAY_IN_MILLIS = 60 * 60 * 24 * 1000;, +, +, +        // converting a Long to a Timestamp shouldn't be possible according to the spec,, +        // it feels a little brittle to check this scenario here and I don't particularly like it, +        // TODO: can we do any better or should we go over the spec and allow getLong(date) to be valid?, +        if (!(type == Long.class && columnType == JDBCType.TIMESTAMP) && type.isInstance(val)) {, +                throw new SQLException(format(Locale.ROOT, "Unable to convert value [%.128s] of type [%s] to a %s", val, , +                        columnType.getName(), type.getName()), cce);, +        throw new SQLException(format(Locale.ROOT, "Unable to convert value [%.128s] of type [%s] to a %s", val, , +                columnType.getName(), type.getName()));, +            case VARCHAR:, +                return Boolean.valueOf((String) val);, +                throw new SQLException(, +                        format(Locale.ROOT, "Unable to convert value [%.128s] of type [%s] to a Boolean", val, columnType.getName()));, +            case VARCHAR:, +                try {, +                    return Byte.valueOf((String) val);, +                } catch (NumberFormatException e) {, +                    throw new SQLException(format(Locale.ROOT, "Unable to convert value [%.128s] of type [VARCHAR] to a Byte", val), e);, +                }, +        throw new SQLException(format(Locale.ROOT, "Unable to convert value [%.128s] of type [%s] to a Byte", val, columnType.getName()));, +            case VARCHAR:, +                try {, +                    return Short.valueOf((String) val);, +                } catch (NumberFormatException e) {, +                    throw new SQLException(format(Locale.ROOT, "Unable to convert value [%.128s] of type [VARCHAR] to a Short", val), e);, +                }, +        throw new SQLException(format(Locale.ROOT, "Unable to convert value [%.128s] of type [%s] to a Short", val, columnType.getName()));, +            case VARCHAR:, +                try {, +                    return Integer.valueOf((String) val);, +                } catch (NumberFormatException e) {, +                    throw new SQLException(, +                            format(Locale.ROOT, "Unable to convert value [%.128s] of type [VARCHAR] to an Integer", val), e);, +                }, +        throw new SQLException(, +                format(Locale.ROOT, "Unable to convert value [%.128s] of type [%s] to an Integer", val, columnType.getName()));, +            //TODO: should we support conversion to TIMESTAMP?, +            //The spec says that getLong() should support the following types conversions:, +            //TINYINT, SMALLINT, INTEGER, BIGINT, REAL, FLOAT, DOUBLE, DECIMAL, NUMERIC, BIT, BOOLEAN, CHAR, VARCHAR, LONGVARCHAR, +            //case TIMESTAMP:, +            //    return ((Number) val).longValue();, +            case VARCHAR:, +                try {, +                    return Long.valueOf((String) val);, +                } catch (NumberFormatException e) {, +                    throw new SQLException(format(Locale.ROOT, "Unable to convert value [%.128s] of type [VARCHAR] to a Long", val), e);, +                }, +        throw new SQLException(format(Locale.ROOT, "Unable to convert value [%.128s] of type [%s] to a Long", val, columnType.getName()));, +            case VARCHAR:, +                try {, +                    return Float.valueOf((String) val);]