[+++ b/core/src/main/java/org/elasticsearch/index/shard/IndexShard.java, +        // We set active because we are now writing operations to the engine; this way, if we go idle after some time and become inactive,, +        // we still invoke any onShardInactive listeners ... we won't sync'd flush in this case because we only do that on primary and this, +        // is a replica, +        active.set(true);, +        if (skipTranslogRecovery == false) {, +            // We set active because we are now writing operations to the engine; this way, if we go idle after some time and become inactive,, +            // we still give sync'd flush a chance to run:, +            active.set(true);, +        }, +    public boolean isActive() {, +        return active.get();, +    }, +, +, +        // time elapses after the engine is created above (pulling the config settings) until we set the engine reference, during which, +        // settings changes could possibly have happened, so here we forcefully push any config changes to the new engine:, +        Engine engine = getEngineOrNull();, +, +        // engine could perhaps be null if we were e.g. concurrently closed:, +        if (engine != null) {, +            engine.onSettingsChanged();, +        }, +++ b/core/src/main/java/org/elasticsearch/index/shard/IndexShard.java, +        // We set active because we are now writing operations to the engine; this way, if we go idle after some time and become inactive,, +        // we still invoke any onShardInactive listeners ... we won't sync'd flush in this case because we only do that on primary and this, +        // is a replica, +        active.set(true);, +        if (skipTranslogRecovery == false) {, +            // We set active because we are now writing operations to the engine; this way, if we go idle after some time and become inactive,, +            // we still give sync'd flush a chance to run:, +            active.set(true);, +        }, +    public boolean isActive() {, +        return active.get();, +    }, +, +, +        // time elapses after the engine is created above (pulling the config settings) until we set the engine reference, during which, +        // settings changes could possibly have happened, so here we forcefully push any config changes to the new engine:, +        Engine engine = getEngineOrNull();, +, +        // engine could perhaps be null if we were e.g. concurrently closed:, +        if (engine != null) {, +            engine.onSettingsChanged();, +        }, +++ b/core/src/test/java/org/elasticsearch/index/shard/IndexShardTests.java, +, +    public void testIndexingBufferDuringInternalRecovery() throws IOException {, +        createIndex("index");, +        client().admin().indices().preparePutMapping("index").setType("testtype").setSource(jsonBuilder().startObject(), +                .startObject("testtype"), +                .startObject("properties"), +                .startObject("foo"), +                .field("type", "string"), +                .endObject(), +                .endObject().endObject().endObject()).get();, +        ensureGreen();, +        IndicesService indicesService = getInstanceFromNode(IndicesService.class);, +        IndexService test = indicesService.indexService("index");, +        IndexShard shard = test.getShardOrNull(0);, +        ShardRouting routing = new ShardRouting(shard.routingEntry());, +        test.removeShard(0, "b/c britta says so");, +        IndexShard newShard = test.createShard(routing);, +        newShard.shardRouting = routing;, +        DiscoveryNode localNode = new DiscoveryNode("foo", DummyTransportAddress.INSTANCE, Version.CURRENT);, +        newShard.markAsRecovering("for testing", new RecoveryState(newShard.shardId(), routing.primary(), RecoveryState.Type.REPLICA, localNode, localNode));, +        // Shard is still inactive since we haven't started recovering yet, +        assertFalse(newShard.isActive());, +        newShard.prepareForIndexRecovery();, +        // Shard is still inactive since we haven't started recovering yet, +        assertFalse(newShard.isActive());, +        newShard.performTranslogRecovery(true);, +        // Shard should now be active since we did recover:, +        assertTrue(newShard.isActive());, +    }, +, +    public void testIndexingBufferDuringPeerRecovery() throws IOException {, +        createIndex("index");, +        client().admin().indices().preparePutMapping("index").setType("testtype").setSource(jsonBuilder().startObject(), +                .startObject("testtype"), +                .startObject("properties"), +                .startObject("foo"), +                .field("type", "string"), +                .endObject(), +                .endObject().endObject().endObject()).get();, +        ensureGreen();, +        IndicesService indicesService = getInstanceFromNode(IndicesService.class);, +        IndexService test = indicesService.indexService("index");, +        IndexShard shard = test.getShardOrNull(0);, +        ShardRouting routing = new ShardRouting(shard.routingEntry());, +        test.removeShard(0, "b/c britta says so");, +        IndexShard newShard = test.createShard(routing);, +        newShard.shardRouting = routing;, +        DiscoveryNode localNode = new DiscoveryNode("foo", DummyTransportAddress.INSTANCE, Version.CURRENT);, +        newShard.markAsRecovering("for testing", new RecoveryState(newShard.shardId(), routing.primary(), RecoveryState.Type.REPLICA, localNode, localNode));, +        // Shard is still inactive since we haven't started recovering yet, +        assertFalse(newShard.isActive());, +        List<Translog.Operation> operations = new ArrayList<>();, +        operations.add(new Translog.Index("testtype", "1", jsonBuilder().startObject().field("foo", "bar").endObject().bytes().toBytes()));]