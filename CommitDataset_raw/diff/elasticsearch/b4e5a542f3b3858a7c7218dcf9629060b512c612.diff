[+++ b/modules/benchmark/micro/src/main/java/org/elasticsearch/benchmark/percolator/EmbeddedPercolatorBenchmarkTest.java, +        PercolatorExecutor.Response percolate = percolatorExecutor.percolate(new PercolatorExecutor.SourceRequest(source));, +            percolate = percolatorExecutor.percolate(new PercolatorExecutor.SourceRequest(source));, +                        PercolatorExecutor.Response percolate = percolatorExecutor.percolate(new PercolatorExecutor.SourceRequest(source));, +++ b/modules/benchmark/micro/src/main/java/org/elasticsearch/benchmark/percolator/EmbeddedPercolatorBenchmarkTest.java, +        PercolatorExecutor.Response percolate = percolatorExecutor.percolate(new PercolatorExecutor.SourceRequest(source));, +            percolate = percolatorExecutor.percolate(new PercolatorExecutor.SourceRequest(source));, +                        PercolatorExecutor.Response percolate = percolatorExecutor.percolate(new PercolatorExecutor.SourceRequest(source));, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/action/percolate/TransportPercolateAction.java, +        PercolatorExecutor.Response percolate = percolatorService.percolate(new PercolatorExecutor.SourceRequest(request.source()));, +++ b/modules/benchmark/micro/src/main/java/org/elasticsearch/benchmark/percolator/EmbeddedPercolatorBenchmarkTest.java, +        PercolatorExecutor.Response percolate = percolatorExecutor.percolate(new PercolatorExecutor.SourceRequest(source));, +            percolate = percolatorExecutor.percolate(new PercolatorExecutor.SourceRequest(source));, +                        PercolatorExecutor.Response percolate = percolatorExecutor.percolate(new PercolatorExecutor.SourceRequest(source));, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/action/percolate/TransportPercolateAction.java, +        PercolatorExecutor.Response percolate = percolatorService.percolate(new PercolatorExecutor.SourceRequest(request.source()));, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/index/percolator/PercolatorExecutor.java, +import org.elasticsearch.index.cache.IndexCache;, +import org.elasticsearch.index.shard.ShardId;, +import org.elasticsearch.indices.IndicesLifecycle;, +    public static class SourceRequest {, +        public SourceRequest(byte[] source) {, +        public SourceRequest(byte[] source, int offset, int length) {, +, +        public int offset() {, +            return this.offset;, +        }, +, +        public int length() {, +            return this.length;, +        }, +    }, +, +    public static class DocAndQueryRequest {, +        private final ParsedDocument doc;, +        @Nullable private final Query query;, +, +        public DocAndQueryRequest(ParsedDocument doc, @Nullable Query query) {, +            this.doc = doc;, +            this.query = query;, +        }, +, +        public ParsedDocument doc() {, +            return this.doc;, +        }, +, +        @Nullable Query query() {, +            return this.query;, +        }, +    private final IndexCache indexCache;, +, +, +    private final PercolatorIndexAndShardListener percolatorIndexAndShardListener = new PercolatorIndexAndShardListener();, +, +    private volatile IndicesLifecycle indicesLifecycle;, +, +    private volatile IndexService percolatorIndex;, +, +    private volatile IndexShard percolatorShard;, +, +                                      MapperService mapperService, IndexQueryParserService queryParserService,, +                                      IndexCache indexCache) {, +        this.indexCache = indexCache;, +    }, +, +    public void setIndicesLifecycle(IndicesLifecycle indicesLifecycle) {, +        this.indicesLifecycle = indicesLifecycle;, +        if (indicesLifecycle != null) {, +            indicesLifecycle.addListener(percolatorIndexAndShardListener);, +        }, +        if (indicesLifecycle != null) {, +            indicesLifecycle.removeListener(percolatorIndexAndShardListener);, +        }, +    public Response percolate(final SourceRequest request) throws ElasticSearchException {, +            parser = XContentFactory.xContent(request.source(), request.offset(), request.length()).createParser(request.source(), request.offset(), request.length());, +        return percolate(new DocAndQueryRequest(doc, query));, +    }, +    public Response percolate(DocAndQueryRequest request) throws ElasticSearchException {, +        for (Fieldable field : request.doc().doc().getFields()) {, +                        memoryIndex.addField(field.name(), request.doc().analyzer().reusableTokenStream(field.name(), reader), field.getBoost() * request.doc().doc().getBoost());, +                            memoryIndex.addField(field.name(), request.doc().analyzer().reusableTokenStream(field.name(), new FastStringReader(value)), field.getBoost() * request.doc().doc().getBoost());, +        if (request.query() == null) {, +            if (percolatorIndex == null || percolatorShard == null) {, +                throw new PercolateIndexUnavailable(new Index(PercolatorService.INDEX_NAME));, +            }, +                percolatorSearcher.searcher().search(request.query(), new QueryCollector(logger, queries, searcher, percolatorIndex, matches));, +        indexCache.clear(searcher.getIndexReader());, +, +        return new Response(matches, request.doc().mappersAdded());, +    }, +, +    class PercolatorIndexAndShardListener extends IndicesLifecycle.Listener {, +        @Override public void afterIndexCreated(IndexService indexService) {, +            if (indexService.index().name().equals(PercolatorService.INDEX_NAME)) {, +                percolatorIndex = indexService;, +            }, +        }, +, +        @Override public void afterIndexClosed(Index index, boolean delete) {, +            if (index.name().equals(PercolatorService.INDEX_NAME)) {]