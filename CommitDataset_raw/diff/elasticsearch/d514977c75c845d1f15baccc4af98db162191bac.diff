[+++ b/core/src/main/java/org/elasticsearch/index/mapper/object/DynamicTemplate.java, +import org.elasticsearch.Version;, +import org.elasticsearch.common.xcontent.ToXContent;, +import org.elasticsearch.common.xcontent.XContentBuilder;, +import java.io.IOException;, +public class DynamicTemplate implements ToXContent {, +        SIMPLE {, +            @Override, +            public String toString() {, +                return "simple";, +            }, +        },, +        REGEX {, +            @Override, +            public String toString() {, +                return "regex";, +            }, +        };, +            for (MatchType v : values()) {, +                if (v.toString().equals(value)) {, +                    return v;, +                }, +    public static DynamicTemplate parse(String name, Map<String, Object> conf,, +            Version indexVersionCreated) throws MapperParsingException {, +        String matchPattern = MatchType.SIMPLE.toString();, +            } else if (indexVersionCreated.onOrAfter(Version.V_5_0_0)) {, +                // unknown parameters were ignored before but still carried through serialization, +                // so we need to ignore them at parsing time for old indices, +                throw new IllegalArgumentException("Illegal dynamic template parameter: [" + propName + "]");, +        return new DynamicTemplate(name, pathMatch, pathUnmatch, match, unmatch, matchMappingType, MatchType.fromString(matchPattern), mapping);, +    public DynamicTemplate(String name, String pathMatch, String pathUnmatch, String match, String unmatch, String matchMappingType, MatchType matchType, Map<String, Object> mapping) {, +        if (match == null && pathMatch == null && matchMappingType == null) {, +            throw new MapperParsingException("template must have match, path_match or match_mapping_type set");, +        }, +        if (mapping == null) {, +            throw new MapperParsingException("template must have mapping set");, +        }, +    public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {, +        builder.startObject();, +        if (match != null) {, +            builder.field("match", match);, +        if (pathMatch != null) {, +            builder.field("path_match", pathMatch);, +        if (unmatch != null) {, +            builder.field("unmatch", unmatch);, +        if (pathUnmatch != null) {, +            builder.field("path_unmatch", pathUnmatch);, +        if (matchMappingType != null) {, +            builder.field("match_mapping_type", matchMappingType);, +        if (matchType != MatchType.SIMPLE) {, +            builder.field("match_pattern", matchType);, +        // use a sorted map for consistent serialization, +        builder.field("mapping", new TreeMap<>(mapping));, +        builder.endObject();, +        return builder;, +++ b/core/src/main/java/org/elasticsearch/index/mapper/object/DynamicTemplate.java, +import org.elasticsearch.Version;, +import org.elasticsearch.common.xcontent.ToXContent;, +import org.elasticsearch.common.xcontent.XContentBuilder;, +import java.io.IOException;, +public class DynamicTemplate implements ToXContent {, +        SIMPLE {, +            @Override, +            public String toString() {, +                return "simple";, +            }, +        },, +        REGEX {, +            @Override, +            public String toString() {, +                return "regex";, +            }, +        };, +            for (MatchType v : values()) {, +                if (v.toString().equals(value)) {, +                    return v;, +                }, +    public static DynamicTemplate parse(String name, Map<String, Object> conf,, +            Version indexVersionCreated) throws MapperParsingException {, +        String matchPattern = MatchType.SIMPLE.toString();, +            } else if (indexVersionCreated.onOrAfter(Version.V_5_0_0)) {, +                // unknown parameters were ignored before but still carried through serialization, +                // so we need to ignore them at parsing time for old indices, +                throw new IllegalArgumentException("Illegal dynamic template parameter: [" + propName + "]");, +        return new DynamicTemplate(name, pathMatch, pathUnmatch, match, unmatch, matchMappingType, MatchType.fromString(matchPattern), mapping);, +    public DynamicTemplate(String name, String pathMatch, String pathUnmatch, String match, String unmatch, String matchMappingType, MatchType matchType, Map<String, Object> mapping) {, +        if (match == null && pathMatch == null && matchMappingType == null) {, +            throw new MapperParsingException("template must have match, path_match or match_mapping_type set");, +        }, +        if (mapping == null) {, +            throw new MapperParsingException("template must have mapping set");, +        }, +    public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {, +        builder.startObject();, +        if (match != null) {, +            builder.field("match", match);, +        if (pathMatch != null) {, +            builder.field("path_match", pathMatch);, +        if (unmatch != null) {, +            builder.field("unmatch", unmatch);]