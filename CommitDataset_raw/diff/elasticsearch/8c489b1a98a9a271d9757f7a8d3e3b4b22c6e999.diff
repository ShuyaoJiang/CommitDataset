[+++ b/plugin/src/main/java/org/elasticsearch/xpack/security/Security.java, +import org.elasticsearch.cluster.metadata.IndexMetaData;, +import static org.elasticsearch.cluster.metadata.IndexMetaData.INDEX_FORMAT_SETTING;, +import static org.elasticsearch.xpack.security.SecurityLifecycleService.SECURITY_INDEX_NAME;, +import static org.elasticsearch.xpack.security.support.IndexLifecycleManager.INTERNAL_INDEX_FORMAT;, +import static org.elasticsearch.xpack.security.support.IndexLifecycleManager.INTERNAL_SECURITY_INDEX;, +        if (enabled) {, +            return new ValidateTLSOnJoin(XPackSettings.TRANSPORT_SSL_ENABLED.get(settings)), +                .andThen(new ValidateUpgradedSecurityIndex());, +        }, +        return null;, +, +    static final class ValidateUpgradedSecurityIndex implements BiConsumer<DiscoveryNode, ClusterState> {, +        @Override, +        public void accept(DiscoveryNode node, ClusterState state) {, +            if (state.getNodes().getMinNodeVersion().before(Version.V_7_0_0_alpha1)) {, +                IndexMetaData indexMetaData = state.getMetaData().getIndices().get(SECURITY_INDEX_NAME);, +                if (indexMetaData != null && INDEX_FORMAT_SETTING.get(indexMetaData.getSettings()) < INTERNAL_INDEX_FORMAT) {, +                    throw new IllegalStateException("Security index is not on the current version [" + INTERNAL_INDEX_FORMAT + "] - " +, +                        "The Upgrade API must be run for 7.x nodes to join the cluster");, +                }, +            }, +        }, +    }, +++ b/plugin/src/main/java/org/elasticsearch/xpack/security/Security.java, +import org.elasticsearch.cluster.metadata.IndexMetaData;, +import static org.elasticsearch.cluster.metadata.IndexMetaData.INDEX_FORMAT_SETTING;, +import static org.elasticsearch.xpack.security.SecurityLifecycleService.SECURITY_INDEX_NAME;, +import static org.elasticsearch.xpack.security.support.IndexLifecycleManager.INTERNAL_INDEX_FORMAT;, +import static org.elasticsearch.xpack.security.support.IndexLifecycleManager.INTERNAL_SECURITY_INDEX;, +        if (enabled) {, +            return new ValidateTLSOnJoin(XPackSettings.TRANSPORT_SSL_ENABLED.get(settings)), +                .andThen(new ValidateUpgradedSecurityIndex());, +        }, +        return null;, +, +    static final class ValidateUpgradedSecurityIndex implements BiConsumer<DiscoveryNode, ClusterState> {, +        @Override, +        public void accept(DiscoveryNode node, ClusterState state) {, +            if (state.getNodes().getMinNodeVersion().before(Version.V_7_0_0_alpha1)) {, +                IndexMetaData indexMetaData = state.getMetaData().getIndices().get(SECURITY_INDEX_NAME);, +                if (indexMetaData != null && INDEX_FORMAT_SETTING.get(indexMetaData.getSettings()) < INTERNAL_INDEX_FORMAT) {, +                    throw new IllegalStateException("Security index is not on the current version [" + INTERNAL_INDEX_FORMAT + "] - " +, +                        "The Upgrade API must be run for 7.x nodes to join the cluster");, +                }, +            }, +        }, +    }, +++ b/plugin/src/test/java/org/elasticsearch/xpack/security/SecurityTests.java, +import org.elasticsearch.cluster.metadata.IndexMetaData;, +import org.elasticsearch.cluster.node.DiscoveryNodes;, +import static org.elasticsearch.cluster.metadata.IndexMetaData.INDEX_FORMAT_SETTING;, +import static org.elasticsearch.xpack.security.SecurityLifecycleService.SECURITY_INDEX_NAME;, +import static org.elasticsearch.xpack.security.support.IndexLifecycleManager.INTERNAL_INDEX_FORMAT;, +import static org.hamcrest.Matchers.equalTo;, +    public void testJoinValidatorOnDisabledSecurity() throws Exception {, +, +    public void testIndexJoinValidator_Old_And_Rolling() throws Exception {, +        createComponents(Settings.EMPTY);, +        BiConsumer<DiscoveryNode, ClusterState> joinValidator = security.getJoinValidator();, +        assertNotNull(joinValidator);, +        DiscoveryNode node = new DiscoveryNode("foo", buildNewFakeTransportAddress(), Version.CURRENT);, +        IndexMetaData indexMetaData = IndexMetaData.builder(SECURITY_INDEX_NAME), +            .settings(settings(Version.V_6_1_0).put(INDEX_FORMAT_SETTING.getKey(), INTERNAL_INDEX_FORMAT - 1)), +            .numberOfShards(1).numberOfReplicas(0), +            .build();, +        DiscoveryNode existingOtherNode = new DiscoveryNode("bar", buildNewFakeTransportAddress(), Version.V_6_1_0);, +        DiscoveryNodes discoveryNodes = DiscoveryNodes.builder().add(existingOtherNode).build();, +        ClusterState clusterState =  ClusterState.builder(ClusterName.DEFAULT), +            .nodes(discoveryNodes), +            .metaData(MetaData.builder().put(indexMetaData, true).build()).build();, +        IllegalStateException e = expectThrows(IllegalStateException.class,, +            () -> joinValidator.accept(node, clusterState));, +        assertThat(e.getMessage(), equalTo("Security index is not on the current version [6] - " +, +            "The Upgrade API must be run for 7.x nodes to join the cluster"));, +    }, +, +    public void testIndexJoinValidator_FullyCurrentCluster() throws Exception {, +        createComponents(Settings.EMPTY);, +        BiConsumer<DiscoveryNode, ClusterState> joinValidator = security.getJoinValidator();, +        assertNotNull(joinValidator);, +        DiscoveryNode node = new DiscoveryNode("foo", buildNewFakeTransportAddress(), Version.CURRENT);, +        int indexFormat = randomBoolean() ? INTERNAL_INDEX_FORMAT : INTERNAL_INDEX_FORMAT - 1;, +        IndexMetaData indexMetaData = IndexMetaData.builder(SECURITY_INDEX_NAME), +            .settings(settings(Version.V_6_1_0).put(INDEX_FORMAT_SETTING.getKey(), indexFormat)), +            .numberOfShards(1).numberOfReplicas(0), +            .build();, +        DiscoveryNode existingOtherNode = new DiscoveryNode("bar", buildNewFakeTransportAddress(), Version.CURRENT);, +        DiscoveryNodes discoveryNodes = DiscoveryNodes.builder().add(existingOtherNode).build();, +        ClusterState clusterState =  ClusterState.builder(ClusterName.DEFAULT), +            .nodes(discoveryNodes), +            .metaData(MetaData.builder().put(indexMetaData, true).build()).build();, +        joinValidator.accept(node, clusterState);, +    }, +, +    public void testIndexUpgradeValidatorWithUpToDateIndex() throws Exception {, +        createComponents(Settings.EMPTY);, +        BiConsumer<DiscoveryNode, ClusterState> joinValidator = security.getJoinValidator();, +        assertNotNull(joinValidator);, +        Version version = randomBoolean() ? Version.CURRENT : Version.V_6_1_0;]