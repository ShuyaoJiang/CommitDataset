[+++ b/core/src/main/java/org/elasticsearch/cluster/metadata/MetaDataIndexUpgradeService.java, +import org.apache.logging.log4j.message.ParameterizedMessage;, +import org.apache.logging.log4j.util.Supplier;, +import org.elasticsearch.index.analysis.IndexAnalyzers;, +        final Settings upgrade = indexScopedSettings.archiveUnknownOrInvalidSettings(, +            settings,, +            e -> logger.warn("{} ignoring unknown index setting: [{}] with value [{}]; archiving", indexMetaData.getIndex(), e.getKey(), e.getValue()),, +            (e, ex) -> logger.warn((Supplier<?>) () -> new ParameterizedMessage("{} ignoring invalid index setting: [{}] with value [{}]; archiving", indexMetaData.getIndex(), e.getKey(), e.getValue()), ex));, +++ b/core/src/main/java/org/elasticsearch/cluster/metadata/MetaDataIndexUpgradeService.java, +import org.apache.logging.log4j.message.ParameterizedMessage;, +import org.apache.logging.log4j.util.Supplier;, +import org.elasticsearch.index.analysis.IndexAnalyzers;, +        final Settings upgrade = indexScopedSettings.archiveUnknownOrInvalidSettings(, +            settings,, +            e -> logger.warn("{} ignoring unknown index setting: [{}] with value [{}]; archiving", indexMetaData.getIndex(), e.getKey(), e.getValue()),, +            (e, ex) -> logger.warn((Supplier<?>) () -> new ParameterizedMessage("{} ignoring invalid index setting: [{}] with value [{}]; archiving", indexMetaData.getIndex(), e.getKey(), e.getValue()), ex));, +++ b/core/src/main/java/org/elasticsearch/common/settings/AbstractScopedSettings.java, +     * Archives invalid or unknown settings. Any setting that is not recognized or fails validation, +     * will be archived. This means the setting is prefixed with {@value ARCHIVED_SETTINGS_PREFIX}, +     * and remains in the settings object. This can be used to detect invalid settings via APIs., +     *, +     * @param settings        the {@link Settings} instance to scan for unknown or invalid settings, +     * @param unknownConsumer callback on unknown settings (consumer receives unknown key and its, +     *                        associated value), +     * @param invalidConsumer callback on invalid settings (consumer receives invalid key, its, +     *                        associated value and an exception), +     * @return a {@link Settings} instance with the unknown or invalid settings archived, +    public Settings archiveUnknownOrInvalidSettings(, +        final Settings settings,, +        final Consumer<Map.Entry<String, String>> unknownConsumer,, +        final BiConsumer<Map.Entry<String, String>, IllegalArgumentException> invalidConsumer) {, +                        unknownConsumer.accept(entry);, +                         * We put them back in here such that tools can check from the outside if there are any indices with invalid, +                         * settings. The setting can remain there but we want users to be aware that some of their setting are invalid and, +                invalidConsumer.accept(entry, ex);, +                 * We put them back in here such that tools can check from the outside if there are any indices with invalid settings. The, +                 * setting can remain there but we want users to be aware that some of their setting are invalid and they can research why, +++ b/core/src/main/java/org/elasticsearch/cluster/metadata/MetaDataIndexUpgradeService.java, +import org.apache.logging.log4j.message.ParameterizedMessage;, +import org.apache.logging.log4j.util.Supplier;, +import org.elasticsearch.index.analysis.IndexAnalyzers;, +        final Settings upgrade = indexScopedSettings.archiveUnknownOrInvalidSettings(, +            settings,, +            e -> logger.warn("{} ignoring unknown index setting: [{}] with value [{}]; archiving", indexMetaData.getIndex(), e.getKey(), e.getValue()),, +            (e, ex) -> logger.warn((Supplier<?>) () -> new ParameterizedMessage("{} ignoring invalid index setting: [{}] with value [{}]; archiving", indexMetaData.getIndex(), e.getKey(), e.getValue()), ex));, +++ b/core/src/main/java/org/elasticsearch/common/settings/AbstractScopedSettings.java, +     * Archives invalid or unknown settings. Any setting that is not recognized or fails validation, +     * will be archived. This means the setting is prefixed with {@value ARCHIVED_SETTINGS_PREFIX}, +     * and remains in the settings object. This can be used to detect invalid settings via APIs., +     *, +     * @param settings        the {@link Settings} instance to scan for unknown or invalid settings, +     * @param unknownConsumer callback on unknown settings (consumer receives unknown key and its, +     *                        associated value), +     * @param invalidConsumer callback on invalid settings (consumer receives invalid key, its, +     *                        associated value and an exception), +     * @return a {@link Settings} instance with the unknown or invalid settings archived, +    public Settings archiveUnknownOrInvalidSettings(, +        final Settings settings,, +        final Consumer<Map.Entry<String, String>> unknownConsumer,, +        final BiConsumer<Map.Entry<String, String>, IllegalArgumentException> invalidConsumer) {, +                        unknownConsumer.accept(entry);, +                         * We put them back in here such that tools can check from the outside if there are any indices with invalid, +                         * settings. The setting can remain there but we want users to be aware that some of their setting are invalid and, +                invalidConsumer.accept(entry, ex);, +                 * We put them back in here such that tools can check from the outside if there are any indices with invalid settings. The, +                 * setting can remain there but we want users to be aware that some of their setting are invalid and they can research why, +++ b/core/src/main/java/org/elasticsearch/gateway/Gateway.java, +import java.util.Map;, +        metaDataBuilder.persistentSettings(, +            clusterSettings.archiveUnknownOrInvalidSettings(, +                metaDataBuilder.persistentSettings(),, +                e -> logUnknownSetting("persistent", e),, +                (e, ex) -> logInvalidSetting("persistent", e, ex)));, +        metaDataBuilder.transientSettings(, +            clusterSettings.archiveUnknownOrInvalidSettings(, +                metaDataBuilder.transientSettings(),, +                e -> logUnknownSetting("transient", e),, +                (e, ex) -> logInvalidSetting("transient", e, ex)));, +    private void logUnknownSetting(String settingType, Map.Entry<String, String> e) {, +        logger.warn("ignoring unknown {} setting: [{}] with value [{}]; archiving", settingType, e.getKey(), e.getValue());, +    }, +, +    private void logInvalidSetting(String settingType, Map.Entry<String, String> e, IllegalArgumentException ex) {, +        logger.warn(, +            (org.apache.logging.log4j.util.Supplier<?>), +                () -> new ParameterizedMessage("ignoring invalid {} setting: [{}] with value [{}]; archiving",, +                    settingType,, +                    e.getKey(),, +                    e.getValue()),, +            ex);, +    }, +, +++ b/core/src/main/java/org/elasticsearch/cluster/metadata/MetaDataIndexUpgradeService.java, +import org.apache.logging.log4j.message.ParameterizedMessage;, +import org.apache.logging.log4j.util.Supplier;, +import org.elasticsearch.index.analysis.IndexAnalyzers;, +        final Settings upgrade = indexScopedSettings.archiveUnknownOrInvalidSettings(, +            settings,, +            e -> logger.warn("{} ignoring unknown index setting: [{}] with value [{}]; archiving", indexMetaData.getIndex(), e.getKey(), e.getValue()),, +            (e, ex) -> logger.warn((Supplier<?>) () -> new ParameterizedMessage("{} ignoring invalid index setting: [{}] with value [{}]; archiving", indexMetaData.getIndex(), e.getKey(), e.getValue()), ex));]