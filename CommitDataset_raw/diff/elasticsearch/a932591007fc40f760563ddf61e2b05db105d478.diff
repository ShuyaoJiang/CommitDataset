[+++ b/core/src/main/java/org/elasticsearch/cluster/metadata/IndexNameExpressionResolver.java, +        final boolean failClosed = options.forbidClosedIndices() && options.ignoreUnavailable() == false;, +        final boolean failNoIndices = indexExpressions.length == 1 ? !options.allowNoIndices() : !options.ignoreUnavailable();, +                return resolveEmptyOrTrivialWildcard(options, metaData);, +                if (Strings.isEmpty(expression)) {, +                    throw infe(expression);, +                }, +                if (aliasOrIndexExists(options, metaData, expression)) {, +                final boolean add;, +                if (expression.charAt(0) == '-' && wildcardSeen) {, +                if (options.allowNoIndices() == false && matches.isEmpty()) {, +        private static boolean unavailableIgnoredOrExists(IndicesOptions options, MetaData metaData, String expression) {, +            return options.ignoreUnavailable() || aliasOrIndexExists(options, metaData, expression);, +        private static boolean aliasOrIndexExists(IndicesOptions options, MetaData metaData, String expression) {, +            AliasOrIndex aliasOrIndex = metaData.getAliasAndIndexLookup().get(expression);, +            //treat aliases as unavailable indices when ignoreAliases is set to true (e.g. delete index and update aliases api), +            return aliasOrIndex != null && (options.ignoreAliases() == false || aliasOrIndex.isAlias() == false);, +        private static List<String> resolveEmptyOrTrivialWildcard(IndicesOptions options, MetaData metaData) {, +++ b/core/src/main/java/org/elasticsearch/cluster/metadata/IndexNameExpressionResolver.java, +        final boolean failClosed = options.forbidClosedIndices() && options.ignoreUnavailable() == false;, +        final boolean failNoIndices = indexExpressions.length == 1 ? !options.allowNoIndices() : !options.ignoreUnavailable();, +                return resolveEmptyOrTrivialWildcard(options, metaData);, +                if (Strings.isEmpty(expression)) {, +                    throw infe(expression);, +                }, +                if (aliasOrIndexExists(options, metaData, expression)) {, +                final boolean add;, +                if (expression.charAt(0) == '-' && wildcardSeen) {, +                if (options.allowNoIndices() == false && matches.isEmpty()) {, +        private static boolean unavailableIgnoredOrExists(IndicesOptions options, MetaData metaData, String expression) {, +            return options.ignoreUnavailable() || aliasOrIndexExists(options, metaData, expression);, +        private static boolean aliasOrIndexExists(IndicesOptions options, MetaData metaData, String expression) {, +            AliasOrIndex aliasOrIndex = metaData.getAliasAndIndexLookup().get(expression);, +            //treat aliases as unavailable indices when ignoreAliases is set to true (e.g. delete index and update aliases api), +            return aliasOrIndex != null && (options.ignoreAliases() == false || aliasOrIndex.isAlias() == false);, +        private static List<String> resolveEmptyOrTrivialWildcard(IndicesOptions options, MetaData metaData) {, +++ b/core/src/test/java/org/elasticsearch/cluster/metadata/IndexNameExpressionResolverTests.java, +            {, +                IndexNotFoundException infe = expectThrows(IndexNotFoundException.class,, +                        () -> indexNameExpressionResolver.concreteIndexNames(context, "bar"));, +                assertThat(infe.getIndex().getName(), equalTo("bar"));, +            {, +                IndexNotFoundException infe = expectThrows(IndexNotFoundException.class,, +                        () -> indexNameExpressionResolver.concreteIndexNames(context, "bar"));, +                assertThat(infe.getIndex().getName(), equalTo("bar"));, +            {, +                IndexNotFoundException infe = expectThrows(IndexNotFoundException.class,, +                        () -> indexNameExpressionResolver.concreteIndexNames(context, "foo", "bar"));, +                assertThat(infe.getIndex().getName(), equalTo("bar"));, +            {, +                IndexNotFoundException infe = expectThrows(IndexNotFoundException.class,, +                        () -> indexNameExpressionResolver.concreteIndexNames(context, "barbaz", "bar"));, +                assertThat(infe.getIndex().getName(), equalTo("bar"));, +            {, +                IndexNotFoundException infe = expectThrows(IndexNotFoundException.class,, +                        () -> indexNameExpressionResolver.concreteIndexNames(context, "bar"));, +                assertThat(infe.getIndex().getName(), equalTo("bar"));, +            {, +                IndexNotFoundException infe = expectThrows(IndexNotFoundException.class,, +                        () -> indexNameExpressionResolver.concreteIndexNames(context, "baz*"));, +                assertThat(infe.getIndex().getName(), equalTo("baz*"));, +            {, +                IndexNotFoundException infe = expectThrows(IndexNotFoundException.class,, +                        () -> indexNameExpressionResolver.concreteIndexNames(context, "foo", "baz*"));, +                assertThat(infe.getIndex().getName(), equalTo("baz*"));, +        results = indexNameExpressionResolver.concreteIndexNames(context, "*", "-foo", "-foobar");, +        assertEquals(1, results.length);, +        assertEquals("bar", results[0]);, +, +        IndexNameExpressionResolver.Context context2 = new IndexNameExpressionResolver.Context(state, options);, +        IndexNotFoundException infe = expectThrows(IndexNotFoundException.class,, +                () -> indexNameExpressionResolver.concreteIndexNames(context2, "-*"));, +        assertThat(infe.getResourceId().toString(), equalTo("[-*]"));, +, +            {, +                IndexNotFoundException infe = expectThrows(IndexNotFoundException.class,, +                        () -> indexNameExpressionResolver.concreteIndexNames(context, "baz*"));, +                assertThat(infe.getIndex().getName(), equalTo("baz*"));, +, +            {, +                //unavailable indices are ignored but no indices are disallowed, +                expectThrows(IndexNotFoundException.class, () -> indexNameExpressionResolver.concreteIndexNames(context, "bar", "baz"));, +            }, +            {, +            {, +                IndexNotFoundException infe = expectThrows(IndexNotFoundException.class,, +                        () -> indexNameExpressionResolver.concreteIndexNames(context, "foo", "baz*"));, +                assertThat(infe.getIndex().getName(), equalTo("baz*"));, +            }, +            {, +                //unavailable indices are not ignored, hence the error on the first unavailable indices encountered, +                IndexNotFoundException infe = expectThrows(IndexNotFoundException.class,, +                        () -> indexNameExpressionResolver.concreteIndexNames(context, "bar", "baz"));, +                assertThat(infe.getIndex().getName(), equalTo("bar"));, +            }, +            {, +                String[] results = indexNameExpressionResolver.concreteIndexNames(context, "foofoobar");, +        }, +            IndexNotFoundException infe = expectThrows(IndexNotFoundException.class,, +                    () -> indexNameExpressionResolver.concreteIndexNames(context, "baz*"));]