[+++ b/core/src/main/java/org/elasticsearch/indices/memory/IndexingMemoryController.java, +import org.elasticsearch.common.Nullable;, +    private final ShardsIndicesStatusChecker statusChecker;, +, +        this(settings, threadPool, indicesService, JvmInfo.jvmInfo().getMem().getHeapMax().bytes());, +    }, +, +    // for testing, +    protected IndexingMemoryController(Settings settings, ThreadPool threadPool, IndicesService indicesService, long jvmMemoryInBytes) {, +            indexingBuffer = new ByteSizeValue((long) (((double) jvmMemoryInBytes) * (percent / 100)));, +            translogBuffer = new ByteSizeValue((long) (((double) jvmMemoryInBytes) * (percent / 100)));, +            translogBuffer = ByteSizeValue.parseBytesSizeValue(translogBufferSetting, TRANSLOG_BUFFER_SIZE_SETTING);, +        this.statusChecker = new ShardsIndicesStatusChecker();, +, +, +        this.scheduler = threadPool.scheduleWithFixedDelay(statusChecker, interval);, +    /**, +     * returns the current budget for the total amount of translog buffers of, +     * active shards on this node, +     */, +    public ByteSizeValue translogBufferSize() {, +        return translogBuffer;, +    }, +, +, +    protected List<ShardId> availableShards() {, +        ArrayList<ShardId> list = new ArrayList<>();, +, +        for (IndexService indexService : indicesService) {, +            for (IndexShard indexShard : indexService) {, +                if (shardAvailable(indexShard)) {, +                    list.add(indexShard.shardId());, +                }, +            }, +        }, +        return list;, +    }, +, +    /** returns true if shard exists and is availabe for updates */, +    protected boolean shardAvailable(ShardId shardId) {, +        return shardAvailable(getShard(shardId));, +    }, +, +    /** returns true if shard exists and is availabe for updates */, +    protected boolean shardAvailable(@Nullable IndexShard shard) {, +        // shadow replica doesn't have an indexing buffer, +        return shard != null && shard.canIndex() && CAN_UPDATE_INDEX_BUFFER_STATES.contains(shard.state());, +    }, +, +    /** gets an {@link IndexShard} instance for the given shard. returns null if the shard doesn't exist */, +    protected IndexShard getShard(ShardId shardId) {, +        IndexService indexService = indicesService.indexService(shardId.index().name());, +        if (indexService != null) {, +            IndexShard indexShard = indexService.shard(shardId.id());, +            return indexShard;, +        }, +        return null;, +    }, +, +    protected void updateShardBuffers(ShardId shardId, ByteSizeValue shardIndexingBufferSize, ByteSizeValue shardTranslogBufferSize) {, +        final IndexShard shard = getShard(shardId);, +        if (shard != null) {, +            try {, +                shard.updateBufferSize(shardIndexingBufferSize, shardTranslogBufferSize);, +            } catch (EngineClosedException e) {, +                // ignore, +            } catch (FlushNotAllowedEngineException e) {, +                // ignore, +            } catch (Exception e) {, +                logger.warn("failed to set shard {} index buffer to [{}]", shardId, shardIndexingBufferSize);, +            }, +        }, +    }, +, +, +    /** returns the current translog status (generation id + ops) for the given shard id. Returns null if unavailable. */, +    protected ShardIndexingStatus getTranslogStatus(ShardId shardId) {, +        final IndexShard indexShard = getShard(shardId);, +        if (indexShard == null) {, +            return null;, +        }, +        final Translog translog;, +        try {, +            translog = indexShard.engine().getTranslog();, +        } catch (EngineClosedException e) {, +            // not ready yet to be checked for activity, +            return null;, +        }, +, +        ShardIndexingStatus status = new ShardIndexingStatus();, +        status.translogId = translog.currentFileGeneration();, +        status.translogNumberOfOperations = translog.totalOperations();, +        return status;, +    }, +, +    // used for tests, +    void forceCheck() {, +        statusChecker.run();, +    }, +]