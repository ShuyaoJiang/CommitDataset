[+++ b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ml/utils/XContentObjectTransformer.java, +            XContentParser.Token token = p.nextToken();, +            assert(XContentParser.Token.START_OBJECT.equals(token));, +++ b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ml/utils/XContentObjectTransformer.java, +            XContentParser.Token token = p.nextToken();, +            assert(XContentParser.Token.START_OBJECT.equals(token));, +++ b/x-pack/plugin/core/src/test/java/org/elasticsearch/xpack/core/ml/datafeed/DatafeedConfigTests.java, +import org.elasticsearch.Version;, +import org.elasticsearch.common.bytes.BytesReference;, +import org.elasticsearch.common.io.stream.BytesStreamOutput;, +import org.elasticsearch.common.io.stream.NamedWriteableAwareStreamInput;, +import org.elasticsearch.common.io.stream.StreamInput;, +import org.elasticsearch.common.xcontent.XContentHelper;, +import org.elasticsearch.index.query.QueryBuilder;, +import org.elasticsearch.search.aggregations.PipelineAggregatorBuilders;, +import org.elasticsearch.search.aggregations.pipeline.BucketScriptPipelineAggregationBuilder;, +import org.elasticsearch.search.aggregations.pipeline.DerivativePipelineAggregationBuilder;, +            // Testing with a single agg is ok as we don't have special list writeable / xcontent logic, +    public void testSerializationOfComplexAggs() throws IOException {, +        MaxAggregationBuilder maxTime = AggregationBuilders.max("timestamp").field("timestamp");, +        AvgAggregationBuilder avgAggregationBuilder = AggregationBuilders.avg("bytes_in_avg").field("system.network.in.bytes");, +        DerivativePipelineAggregationBuilder derivativePipelineAggregationBuilder =, +            PipelineAggregatorBuilders.derivative("bytes_in_derivative", "bytes_in_avg");, +        BucketScriptPipelineAggregationBuilder bucketScriptPipelineAggregationBuilder =, +            PipelineAggregatorBuilders.bucketScript("non_negative_bytes",, +                Collections.singletonMap("bytes", "bytes_in_derivative"),, +                new Script("params.bytes > 0 ? params.bytes : null"));, +        DateHistogramAggregationBuilder dateHistogram =, +            AggregationBuilders.dateHistogram("histogram_buckets"), +                .field("timestamp").interval(300000).timeZone(DateTimeZone.UTC), +                .subAggregation(maxTime), +                .subAggregation(avgAggregationBuilder), +                .subAggregation(derivativePipelineAggregationBuilder), +                .subAggregation(bucketScriptPipelineAggregationBuilder);, +        DatafeedConfig.Builder datafeedConfigBuilder = createDatafeedBuilderWithDateHistogram(dateHistogram);, +        QueryBuilder terms =, +            new BoolQueryBuilder().filter(new TermQueryBuilder(randomAlphaOfLengthBetween(1, 10), randomAlphaOfLengthBetween(1, 10)));, +        datafeedConfigBuilder.setParsedQuery(terms);, +        DatafeedConfig datafeedConfig = datafeedConfigBuilder.build();, +        AggregatorFactories.Builder aggBuilder = new AggregatorFactories.Builder().addAggregator(dateHistogram);, +, +, +        XContentType xContentType = XContentType.JSON;, +        BytesReference bytes = XContentHelper.toXContent(datafeedConfig, xContentType, false);, +        XContentParser parser = XContentHelper.createParser(xContentRegistry(),, +            DeprecationHandler.THROW_UNSUPPORTED_OPERATION,, +            bytes,, +            xContentType);, +, +        DatafeedConfig parsedDatafeedConfig = doParseInstance(parser);, +        assertEquals(datafeedConfig, parsedDatafeedConfig);, +, +        // Assert that the parsed versions of our aggs and queries work as well, +        assertEquals(aggBuilder, parsedDatafeedConfig.getParsedAggregations());, +        assertEquals(terms, parsedDatafeedConfig.getParsedQuery());, +, +        try(BytesStreamOutput output = new BytesStreamOutput()) {, +            datafeedConfig.writeTo(output);, +            try(StreamInput streamInput = output.bytes().streamInput()) {, +                DatafeedConfig streamedDatafeedConfig = new DatafeedConfig(streamInput);, +                assertEquals(datafeedConfig, streamedDatafeedConfig);, +, +                // Assert that the parsed versions of our aggs and queries work as well, +                assertEquals(aggBuilder, streamedDatafeedConfig.getParsedAggregations());, +                assertEquals(terms, streamedDatafeedConfig.getParsedQuery());, +            }, +        }, +    }, +, +    public void testSerializationOfComplexAggsBetweenVersions() throws IOException {, +        MaxAggregationBuilder maxTime = AggregationBuilders.max("timestamp").field("timestamp");, +        AvgAggregationBuilder avgAggregationBuilder = AggregationBuilders.avg("bytes_in_avg").field("system.network.in.bytes");, +        DerivativePipelineAggregationBuilder derivativePipelineAggregationBuilder =, +            PipelineAggregatorBuilders.derivative("bytes_in_derivative", "bytes_in_avg");, +        BucketScriptPipelineAggregationBuilder bucketScriptPipelineAggregationBuilder =, +            PipelineAggregatorBuilders.bucketScript("non_negative_bytes",, +                Collections.singletonMap("bytes", "bytes_in_derivative"),, +                new Script("params.bytes > 0 ? params.bytes : null"));, +        DateHistogramAggregationBuilder dateHistogram =, +            AggregationBuilders.dateHistogram("histogram_buckets"), +                .field("timestamp").interval(300000).timeZone(DateTimeZone.UTC), +                .subAggregation(maxTime), +                .subAggregation(avgAggregationBuilder), +                .subAggregation(derivativePipelineAggregationBuilder), +                .subAggregation(bucketScriptPipelineAggregationBuilder);, +        DatafeedConfig.Builder datafeedConfigBuilder = createDatafeedBuilderWithDateHistogram(dateHistogram);, +        QueryBuilder terms =, +            new BoolQueryBuilder().filter(new TermQueryBuilder(randomAlphaOfLengthBetween(1, 10), randomAlphaOfLengthBetween(1, 10)));, +        datafeedConfigBuilder.setParsedQuery(terms);, +        DatafeedConfig datafeedConfig = datafeedConfigBuilder.build();, +, +        SearchModule searchModule = new SearchModule(Settings.EMPTY, false, Collections.emptyList());, +        NamedWriteableRegistry namedWriteableRegistry = new NamedWriteableRegistry(searchModule.getNamedWriteables());, +, +        try (BytesStreamOutput output = new BytesStreamOutput()) {, +            output.setVersion(Version.V_6_0_0);, +            datafeedConfig.writeTo(output);, +            try (StreamInput in = new NamedWriteableAwareStreamInput(output.bytes().streamInput(), namedWriteableRegistry)) {, +                in.setVersion(Version.V_6_0_0);, +                DatafeedConfig streamedDatafeedConfig = new DatafeedConfig(in);]