[+++ b/src/main/java/org/elasticsearch/index/fielddata/ordinals/OrdinalsBuilder.java, +import org.apache.lucene.util.*;, +import org.apache.lucene.util.packed.GrowableWriter;, +import org.apache.lucene.util.packed.PackedInts;, +import java.io.Closeable;, +import java.io.IOException;, +import java.util.ArrayList;, +import java.util.Comparator;, +, +    private final int maxDoc;, +    private int[] mvOrds;, +    private GrowableWriter svOrds;, +, +    public OrdinalsBuilder(Terms terms, boolean preDefineBitsRequired, int maxDoc, Allocator allocator) throws IOException {, +        this.maxDoc = maxDoc;, +        // TODO: Make configurable..., +        float acceptableOverheadRatio = PackedInts.FAST;, +        if (preDefineBitsRequired) {, +            int numTerms = (int) terms.size();, +            if (numTerms == -1) {, +                svOrds = new GrowableWriter(1, maxDoc, acceptableOverheadRatio);, +            } else {, +                svOrds = new GrowableWriter(PackedInts.bitsRequired(numTerms), maxDoc, acceptableOverheadRatio);, +            }, +        } else {, +            svOrds = new GrowableWriter(1, maxDoc, acceptableOverheadRatio);, +        }, +    public OrdinalsBuilder(int maxDoc) throws IOException {, +        this(null, false, maxDoc);, +    public OrdinalsBuilder(Terms terms, boolean preDefineBitsRequired, int maxDoc) throws IOException {, +        this(terms, preDefineBitsRequired, maxDoc, new DirectAllocator());, +    }, +, +    public OrdinalsBuilder(Terms terms, int maxDoc) throws IOException {, +        this(terms, true, maxDoc, new DirectAllocator());, +        if (svOrds != null) {, +            int docsOrd = (int) svOrds.get(doc);, +                svOrds.set(doc, currentOrd);, +                numDocsWithValue++;, +            } else {, +                // Rebuilding ords that supports mv based on sv ords., +                mvOrds = new int[maxDoc];, +                for (int docId = 0; docId < maxDoc; docId++) {, +                    mvOrds[docId] = (int) svOrds.get(docId);, +                }, +                svOrds = null;, +            }, +        }, +, +        if (mvOrds != null) {, +            int docsOrd = mvOrds[doc];, +            if (docsOrd == 0) {, +                mvOrds[doc] = currentOrd;, +                    offsets = new int[mvOrds.length];, +                mvOrds[doc] = (-1 * offset) - 1;, +        }, +        if (numDocsWithValue == maxDoc) {, +        }, +        final FixedBitSet bitSet = new FixedBitSet(maxDoc);, +        if (svOrds != null) {, +            for (int docId = 0; docId < maxDoc; docId++) {, +                int ord = (int) svOrds.get(docId);, +                if (ord != 0) {, +                    bitSet.set(docId);, +                }, +            }, +        } else {, +            for (int docId = 0; docId < maxDoc; docId++) {, +                if (mvOrds[docId] != 0) {, +                    bitSet.set(docId);, +                }, +            return new SinglePackedOrdinals(svOrds.getMutable(), getNumOrds());, +            for (int i = 0; i < mvOrds.length; i++) {, +                    ordinalBuffer.add(new int[mvOrds.length]);, +        if (svOrds != null) {, +            int docsOrd = (int) svOrds.get(doc);, +                intsRef.ints[0] = docsOrd;, +                intsRef.length = 1;, +            }, +        } else {, +            int docsOrd = mvOrds[doc];, +            intsRef.offset = 0;, +            if (docsOrd == 0) {, +                intsRef.length = 0;, +            } else if (docsOrd > 0) {, +                intsRef.ints[0] = mvOrds[doc];, +                reader.reset(-1 * (mvOrds[doc] + 1), offsets[doc]);, +        }, +        return maxDoc;, +++ b/src/main/java/org/elasticsearch/index/fielddata/ordinals/OrdinalsBuilder.java, +import org.apache.lucene.util.*;, +import org.apache.lucene.util.packed.GrowableWriter;, +import org.apache.lucene.util.packed.PackedInts;, +import java.io.Closeable;, +import java.io.IOException;, +import java.util.ArrayList;, +import java.util.Comparator;, +, +    private final int maxDoc;, +    private int[] mvOrds;]