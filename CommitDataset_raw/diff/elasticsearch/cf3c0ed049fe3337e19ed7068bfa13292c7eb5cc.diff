[+++ b/buildSrc/src/main/groovy/org/elasticsearch/gradle/test/ClusterConfiguration.groovy, +        ant.echo(message: "[${LocalDateTime.now()}] Waiting for elasticsearch node ${node.httpUri()}", level: "info"), +        ant.get(src: "http://${node.httpUri()}",, +        ant.echo(message: "[${LocalDateTime.now()}] Finished waiting for elasticsearch node ${node.httpUri()}. Reachable? ${tmpFile.exists()}", level: "info"), +++ b/buildSrc/src/main/groovy/org/elasticsearch/gradle/test/ClusterConfiguration.groovy, +        ant.echo(message: "[${LocalDateTime.now()}] Waiting for elasticsearch node ${node.httpUri()}", level: "info"), +        ant.get(src: "http://${node.httpUri()}",, +        ant.echo(message: "[${LocalDateTime.now()}] Finished waiting for elasticsearch node ${node.httpUri()}. Reachable? ${tmpFile.exists()}", level: "info"), +++ b/core/src/main/java/org/elasticsearch/action/percolate/PercolateShardRequest.java, +    public PercolateShardRequest(ShardId shardId, OriginalIndices originalIndices) {, +        super(shardId, originalIndices);, +    }, +, +++ b/buildSrc/src/main/groovy/org/elasticsearch/gradle/test/ClusterConfiguration.groovy, +        ant.echo(message: "[${LocalDateTime.now()}] Waiting for elasticsearch node ${node.httpUri()}", level: "info"), +        ant.get(src: "http://${node.httpUri()}",, +        ant.echo(message: "[${LocalDateTime.now()}] Finished waiting for elasticsearch node ${node.httpUri()}. Reachable? ${tmpFile.exists()}", level: "info"), +++ b/core/src/main/java/org/elasticsearch/action/percolate/PercolateShardRequest.java, +    public PercolateShardRequest(ShardId shardId, OriginalIndices originalIndices) {, +        super(shardId, originalIndices);, +    }, +, +++ b/core/src/main/java/org/elasticsearch/action/percolate/TransportShardMultiPercolateAction.java, +                OriginalIndices originalIndices = OriginalIndices.readOriginalIndices(in);, +                PercolateShardRequest shardRequest = new PercolateShardRequest(new ShardId(index, shardId), originalIndices);, +                shardRequest.documentType(in.readString());, +                shardRequest.source(in.readBytesReference());, +                shardRequest.docSource(in.readBytesReference());, +                shardRequest.onlyCount(in.readBoolean());, +                OriginalIndices.writeOriginalIndices(item.request.originalIndices(), out);, +                out.writeString(item.request.documentType());, +                out.writeBytesReference(item.request.source());, +                out.writeBytesReference(item.request.docSource());, +                out.writeBoolean(item.request.onlyCount());, +++ b/buildSrc/src/main/groovy/org/elasticsearch/gradle/test/ClusterConfiguration.groovy, +        ant.echo(message: "[${LocalDateTime.now()}] Waiting for elasticsearch node ${node.httpUri()}", level: "info"), +        ant.get(src: "http://${node.httpUri()}",, +        ant.echo(message: "[${LocalDateTime.now()}] Finished waiting for elasticsearch node ${node.httpUri()}. Reachable? ${tmpFile.exists()}", level: "info"), +++ b/core/src/main/java/org/elasticsearch/action/percolate/PercolateShardRequest.java, +    public PercolateShardRequest(ShardId shardId, OriginalIndices originalIndices) {, +        super(shardId, originalIndices);, +    }, +, +++ b/core/src/main/java/org/elasticsearch/action/percolate/TransportShardMultiPercolateAction.java, +                OriginalIndices originalIndices = OriginalIndices.readOriginalIndices(in);, +                PercolateShardRequest shardRequest = new PercolateShardRequest(new ShardId(index, shardId), originalIndices);, +                shardRequest.documentType(in.readString());, +                shardRequest.source(in.readBytesReference());, +                shardRequest.docSource(in.readBytesReference());, +                shardRequest.onlyCount(in.readBoolean());, +                OriginalIndices.writeOriginalIndices(item.request.originalIndices(), out);, +                out.writeString(item.request.documentType());, +                out.writeBytesReference(item.request.source());, +                out.writeBytesReference(item.request.docSource());, +                out.writeBoolean(item.request.onlyCount());, +++ b/core/src/main/java/org/elasticsearch/action/support/replication/TransportReplicationAction.java, +import java.util.Locale;, +                replicationPhase = new ReplicationPhase(primaryResponse.v2(), primaryResponse.v1(), shardId, channel, indexShardReference);, +                                TransportChannel channel, Releasable indexShardReference) {, +                                String message = String.format(Locale.ROOT, "failed to perform %s on replica on node %s", transportReplicaAction, node);, +                                logger.warn("{} {}", exp, shardId, message);, +                                shardStateAction.shardFailed(, +                                    shard,, +                                    indexUUID,, +                                    message,, +                                    exp,, +                                    new ShardStateAction.Listener() {, +                                        @Override, +                                        public void onSuccess() {, +                                            onReplicaFailure(nodeId, exp);, +                                        }, +, +                                        @Override, +                                        public void onShardFailedFailure(Exception e) {, +                                            // TODO: handle catastrophic non-channel failures, +                                            onReplicaFailure(nodeId, exp);, +                                        }, +                                    }, +                                );, +++ b/buildSrc/src/main/groovy/org/elasticsearch/gradle/test/ClusterConfiguration.groovy, +        ant.echo(message: "[${LocalDateTime.now()}] Waiting for elasticsearch node ${node.httpUri()}", level: "info"), +        ant.get(src: "http://${node.httpUri()}",, +        ant.echo(message: "[${LocalDateTime.now()}] Finished waiting for elasticsearch node ${node.httpUri()}. Reachable? ${tmpFile.exists()}", level: "info"), +++ b/core/src/main/java/org/elasticsearch/action/percolate/PercolateShardRequest.java, +    public PercolateShardRequest(ShardId shardId, OriginalIndices originalIndices) {, +        super(shardId, originalIndices);, +    }, +, +++ b/core/src/main/java/org/elasticsearch/action/percolate/TransportShardMultiPercolateAction.java, +                OriginalIndices originalIndices = OriginalIndices.readOriginalIndices(in);, +                PercolateShardRequest shardRequest = new PercolateShardRequest(new ShardId(index, shardId), originalIndices);, +                shardRequest.documentType(in.readString());, +                shardRequest.source(in.readBytesReference());, +                shardRequest.docSource(in.readBytesReference());, +                shardRequest.onlyCount(in.readBoolean());, +                OriginalIndices.writeOriginalIndices(item.request.originalIndices(), out);, +                out.writeString(item.request.documentType());, +                out.writeBytesReference(item.request.source());, +                out.writeBytesReference(item.request.docSource());, +                out.writeBoolean(item.request.onlyCount());]