[+++ b/plugin/src/main/java/org/elasticsearch/xpack/ml/action/UpdateJobAction.java, +import org.elasticsearch.common.util.concurrent.ConcurrentCollections;, +import org.elasticsearch.xpack.ml.job.config.JobState;, +import org.elasticsearch.xpack.ml.job.metadata.MlMetadata;, +import org.elasticsearch.xpack.persistent.PersistentTasksInProgress;, +import java.util.concurrent.ConcurrentMap;, +import java.util.concurrent.Semaphore;, +        private final ConcurrentMap<String, Semaphore> semaphoreByJob = ConcurrentCollections.newConcurrentMap();, +            PersistentTasksInProgress tasks = clusterService.state().custom(PersistentTasksInProgress.TYPE);, +            boolean jobIsOpen = MlMetadata.getJobState(request.getJobId(), tasks) == JobState.OPENED;, +, +            semaphoreByJob.computeIfAbsent(request.getJobId(), id -> new Semaphore(1)).acquire();, +, +            ActionListener<PutJobAction.Response> wrappedListener;, +            if (jobIsOpen && request.getJobUpdate().isAutodetectProcessUpdate()) {, +                        e -> {, +                            releaseJobSemaphore(request.getJobId());, +                            listener.onFailure(e);, +                        });, +            }, +            else {, +                wrappedListener = ActionListener.wrap(, +                        response -> {, +                            releaseJobSemaphore(request.getJobId());, +                            listener.onResponse(response);, +                        },, +                        e -> {, +                            releaseJobSemaphore(request.getJobId());, +                            listener.onFailure(e);, +                        });, +            jobManager.updateJob(request.getJobId(), request.getJobUpdate(), request, client, wrappedListener);, +, +                    releaseJobSemaphore(request.getJobId());, +                    releaseJobSemaphore(request.getJobId());, +        private void releaseJobSemaphore(String jobId) {, +            semaphoreByJob.remove(jobId).release();, +        }, +, +++ b/plugin/src/main/java/org/elasticsearch/xpack/ml/action/UpdateJobAction.java, +import org.elasticsearch.common.util.concurrent.ConcurrentCollections;, +import org.elasticsearch.xpack.ml.job.config.JobState;, +import org.elasticsearch.xpack.ml.job.metadata.MlMetadata;, +import org.elasticsearch.xpack.persistent.PersistentTasksInProgress;, +import java.util.concurrent.ConcurrentMap;, +import java.util.concurrent.Semaphore;, +        private final ConcurrentMap<String, Semaphore> semaphoreByJob = ConcurrentCollections.newConcurrentMap();, +            PersistentTasksInProgress tasks = clusterService.state().custom(PersistentTasksInProgress.TYPE);, +            boolean jobIsOpen = MlMetadata.getJobState(request.getJobId(), tasks) == JobState.OPENED;, +, +            semaphoreByJob.computeIfAbsent(request.getJobId(), id -> new Semaphore(1)).acquire();, +, +            ActionListener<PutJobAction.Response> wrappedListener;, +            if (jobIsOpen && request.getJobUpdate().isAutodetectProcessUpdate()) {, +                        e -> {, +                            releaseJobSemaphore(request.getJobId());, +                            listener.onFailure(e);, +                        });, +            }, +            else {, +                wrappedListener = ActionListener.wrap(, +                        response -> {, +                            releaseJobSemaphore(request.getJobId());, +                            listener.onResponse(response);, +                        },, +                        e -> {, +                            releaseJobSemaphore(request.getJobId());, +                            listener.onFailure(e);, +                        });, +            jobManager.updateJob(request.getJobId(), request.getJobUpdate(), request, client, wrappedListener);, +, +                    releaseJobSemaphore(request.getJobId());, +                    releaseJobSemaphore(request.getJobId());, +        private void releaseJobSemaphore(String jobId) {, +            semaphoreByJob.remove(jobId).release();, +        }, +, +++ b/plugin/src/main/java/org/elasticsearch/xpack/ml/action/UpdateProcessAction.java, +                    processManager.writeUpdateProcessMessage(request.getJobId(), request.getDetectorUpdates(),, +                            request.getModelDebugConfig());, +++ b/plugin/src/main/java/org/elasticsearch/xpack/ml/action/UpdateJobAction.java, +import org.elasticsearch.common.util.concurrent.ConcurrentCollections;, +import org.elasticsearch.xpack.ml.job.config.JobState;, +import org.elasticsearch.xpack.ml.job.metadata.MlMetadata;, +import org.elasticsearch.xpack.persistent.PersistentTasksInProgress;, +import java.util.concurrent.ConcurrentMap;, +import java.util.concurrent.Semaphore;, +        private final ConcurrentMap<String, Semaphore> semaphoreByJob = ConcurrentCollections.newConcurrentMap();, +            PersistentTasksInProgress tasks = clusterService.state().custom(PersistentTasksInProgress.TYPE);, +            boolean jobIsOpen = MlMetadata.getJobState(request.getJobId(), tasks) == JobState.OPENED;, +, +            semaphoreByJob.computeIfAbsent(request.getJobId(), id -> new Semaphore(1)).acquire();, +, +            ActionListener<PutJobAction.Response> wrappedListener;, +            if (jobIsOpen && request.getJobUpdate().isAutodetectProcessUpdate()) {, +                        e -> {, +                            releaseJobSemaphore(request.getJobId());, +                            listener.onFailure(e);, +                        });, +            }, +            else {]