[+++ b/src/main/java/org/elasticsearch/action/percolate/TransportMultiPercolateAction.java, +        final List<Object> percolateRequests = new ArrayList<Object>(request.requests().size());, +        final TIntArrayList getRequestSlots = new TIntArrayList();, +        List<GetRequest> existingDocsRequests = new ArrayList<GetRequest>();, +        for (int slot = 0;  slot < request.requests().size(); slot++) {, +            PercolateRequest percolateRequest = request.requests().get(slot);, +            percolateRequest.startTime = System.currentTimeMillis();, +            percolateRequests.add(percolateRequest);, +            if (percolateRequest.getRequest() != null) {, +                existingDocsRequests.add(percolateRequest.getRequest());, +                getRequestSlots.add(slot);, +            }, +        }, +                        int slot = getRequestSlots.get(i);, +                                logger.trace("mpercolate existing doc, item[{}] doesn't exist", slot);, +                            logger.trace("mpercolate existing doc, item[{}] failure {}", slot, itemResponse.getFailure());, +        final ActionListener<MultiPercolateResponse> finalListener;, +        final List<Object> percolateRequests;, +        final Map<ShardId, TIntArrayList> shardToSlots;, +        ASyncAction(List<Object> percolateRequests, ActionListener<MultiPercolateResponse> finalListener, ClusterState clusterState) {, +            this.finalListener = finalListener;, +            responsesByItemAndShard = new AtomicReferenceArray<AtomicReferenceArray>(percolateRequests.size());, +            expectedOperationsPerItem = new AtomicReferenceArray<AtomicInteger>(percolateRequests.size());, +            reducedResponses = new AtomicArray<Object>(percolateRequests.size());, +            shardToSlots = new HashMap<ShardId, TIntArrayList>();, +            for (int slot = 0;  slot < percolateRequests.size(); slot++) {, +                            clusterState, percolateRequest.indices(), concreteIndices, routing, null, +                        logger.trace("Adding shard[{}] percolate request for item[{}]", shardId, slot);, +                        TIntArrayList items = shardToSlots.get(shardId);, +                            shardToSlots.put(shardId, items = new TIntArrayList());, +                    logger.trace("item[{}] won't be executed, reason: {}", slot, element);, +            logger.trace("mpercolate executing for shards {}", requestsByShard.keySet());, +                final ShardId shardId = entry.getKey();, +                        onShardResponse(shardId, response);, +                        onShardFailure(shardId, e);, +            logger.debug("{} Percolate shard response", shardId);, +                finalListener.onFailure(e);, +            logger.debug("{} Shard multi percolate failure", e, shardId);, +                TIntArrayList slots = shardToSlots.get(shardId);, +                for (int i = 0; i < slots.size(); i++) {, +                finalListener.onFailure(t);, +            finalListener.onResponse(new MultiPercolateResponse(finalResponse));, +++ b/src/main/java/org/elasticsearch/action/percolate/TransportMultiPercolateAction.java, +        final List<Object> percolateRequests = new ArrayList<Object>(request.requests().size());, +        final TIntArrayList getRequestSlots = new TIntArrayList();, +        List<GetRequest> existingDocsRequests = new ArrayList<GetRequest>();, +        for (int slot = 0;  slot < request.requests().size(); slot++) {, +            PercolateRequest percolateRequest = request.requests().get(slot);, +            percolateRequest.startTime = System.currentTimeMillis();, +            percolateRequests.add(percolateRequest);, +            if (percolateRequest.getRequest() != null) {, +                existingDocsRequests.add(percolateRequest.getRequest());, +                getRequestSlots.add(slot);, +            }, +        }, +                        int slot = getRequestSlots.get(i);, +                                logger.trace("mpercolate existing doc, item[{}] doesn't exist", slot);, +                            logger.trace("mpercolate existing doc, item[{}] failure {}", slot, itemResponse.getFailure());, +        final ActionListener<MultiPercolateResponse> finalListener;, +        final List<Object> percolateRequests;, +        final Map<ShardId, TIntArrayList> shardToSlots;, +        ASyncAction(List<Object> percolateRequests, ActionListener<MultiPercolateResponse> finalListener, ClusterState clusterState) {, +            this.finalListener = finalListener;, +            responsesByItemAndShard = new AtomicReferenceArray<AtomicReferenceArray>(percolateRequests.size());, +            expectedOperationsPerItem = new AtomicReferenceArray<AtomicInteger>(percolateRequests.size());, +            reducedResponses = new AtomicArray<Object>(percolateRequests.size());, +            shardToSlots = new HashMap<ShardId, TIntArrayList>();, +            for (int slot = 0;  slot < percolateRequests.size(); slot++) {, +                            clusterState, percolateRequest.indices(), concreteIndices, routing, null, +                        logger.trace("Adding shard[{}] percolate request for item[{}]", shardId, slot);, +                        TIntArrayList items = shardToSlots.get(shardId);, +                            shardToSlots.put(shardId, items = new TIntArrayList());, +                    logger.trace("item[{}] won't be executed, reason: {}", slot, element);, +            logger.trace("mpercolate executing for shards {}", requestsByShard.keySet());, +                final ShardId shardId = entry.getKey();, +                        onShardResponse(shardId, response);, +                        onShardFailure(shardId, e);, +            logger.debug("{} Percolate shard response", shardId);, +                finalListener.onFailure(e);, +            logger.debug("{} Shard multi percolate failure", e, shardId);, +                TIntArrayList slots = shardToSlots.get(shardId);, +                for (int i = 0; i < slots.size(); i++) {, +                finalListener.onFailure(t);, +            finalListener.onResponse(new MultiPercolateResponse(finalResponse));, +++ b/src/main/java/org/elasticsearch/action/percolate/TransportShardMultiPercolateAction.java, +++ b/src/main/java/org/elasticsearch/action/percolate/TransportMultiPercolateAction.java, +        final List<Object> percolateRequests = new ArrayList<Object>(request.requests().size());, +        final TIntArrayList getRequestSlots = new TIntArrayList();, +        List<GetRequest> existingDocsRequests = new ArrayList<GetRequest>();, +        for (int slot = 0;  slot < request.requests().size(); slot++) {, +            PercolateRequest percolateRequest = request.requests().get(slot);, +            percolateRequest.startTime = System.currentTimeMillis();, +            percolateRequests.add(percolateRequest);, +            if (percolateRequest.getRequest() != null) {, +                existingDocsRequests.add(percolateRequest.getRequest());, +                getRequestSlots.add(slot);, +            }, +        }, +                        int slot = getRequestSlots.get(i);, +                                logger.trace("mpercolate existing doc, item[{}] doesn't exist", slot);]