[+++ b/core/src/main/java/org/elasticsearch/cluster/ClusterState.java, +                for (Map.Entry<String, ImmutableSet<ClusterBlock>> entry : blocks().indices().entrySet()) {, +++ b/core/src/main/java/org/elasticsearch/cluster/ClusterState.java, +                for (Map.Entry<String, ImmutableSet<ClusterBlock>> entry : blocks().indices().entrySet()) {, +++ b/core/src/main/java/org/elasticsearch/cluster/block/ClusterBlockException.java, +import com.google.common.collect.ImmutableSet;, +    private final ImmutableSet<ClusterBlock> blocks;, +, +    public ClusterBlockException(ImmutableSet<ClusterBlock> blocks) {, +        int num = in.readVInt();, +        ImmutableSet.Builder<ClusterBlock> builder = ImmutableSet.builder();, +        for (int i = 0; i < num; i++) {, +            builder.add(ClusterBlock.readClusterBlock(in));, +        blocks = builder.build();, +    public ImmutableSet<ClusterBlock> blocks() {, +    private static String buildMessage(ImmutableSet<ClusterBlock> blocks) {, +++ b/core/src/main/java/org/elasticsearch/cluster/ClusterState.java, +                for (Map.Entry<String, ImmutableSet<ClusterBlock>> entry : blocks().indices().entrySet()) {, +++ b/core/src/main/java/org/elasticsearch/cluster/block/ClusterBlockException.java, +import com.google.common.collect.ImmutableSet;, +    private final ImmutableSet<ClusterBlock> blocks;, +, +    public ClusterBlockException(ImmutableSet<ClusterBlock> blocks) {, +        int num = in.readVInt();, +        ImmutableSet.Builder<ClusterBlock> builder = ImmutableSet.builder();, +        for (int i = 0; i < num; i++) {, +            builder.add(ClusterBlock.readClusterBlock(in));, +        blocks = builder.build();, +    public ImmutableSet<ClusterBlock> blocks() {, +    private static String buildMessage(ImmutableSet<ClusterBlock> blocks) {, +++ b/core/src/main/java/org/elasticsearch/cluster/block/ClusterBlocks.java, +import com.google.common.collect.ImmutableSet;, +, +    public static final ClusterBlocks EMPTY_CLUSTER_BLOCK = new ClusterBlocks(ImmutableSet.<ClusterBlock>of(), ImmutableMap.<String, ImmutableSet<ClusterBlock>>of());, +    private final ImmutableSet<ClusterBlock> global;, +    private final Map<String, ImmutableSet<ClusterBlock>> indicesBlocks;, +    ClusterBlocks(ImmutableSet<ClusterBlock> global, Map<String, ImmutableSet<ClusterBlock>> indicesBlocks) {, +        for (ClusterBlockLevel level : ClusterBlockLevel.values()) {, +            ImmutableSet.Builder<ClusterBlock> globalBuilder = ImmutableSet.builder();, +            for (ClusterBlock block : global) {, +                if (block.contains(level)) {, +                    globalBuilder.add(block);, +, +            ImmutableMap.Builder<String, ImmutableSet<ClusterBlock>> indicesBuilder = ImmutableMap.builder();, +            for (Map.Entry<String, ImmutableSet<ClusterBlock>> entry : indicesBlocks.entrySet()) {, +                ImmutableSet.Builder<ClusterBlock> indexBuilder = ImmutableSet.builder();, +                for (ClusterBlock block : entry.getValue()) {, +                    if (block.contains(level)) {, +                        indexBuilder.add(block);, +                    }, +                }, +, +                indicesBuilder.put(entry.getKey(), indexBuilder.build());, +            }, +, +            levelHolders[level.id()] = new ImmutableLevelHolder(globalBuilder.build(), indicesBuilder.build());, +        }, +    }, +, +    public ImmutableSet<ClusterBlock> global() {, +    public Map<String, ImmutableSet<ClusterBlock>> indices() {, +    public ImmutableSet<ClusterBlock> global(ClusterBlockLevel level) {, +    public Map<String, ImmutableSet<ClusterBlock>> indices(ClusterBlockLevel level) {, +        return new ClusterBlockException(ImmutableSet.copyOf(global(level)));, +        ImmutableSet.Builder<ClusterBlock> builder = ImmutableSet.builder();, +        builder.addAll(global(level));, +        ImmutableSet<ClusterBlock> indexBlocks = indices(level).get(index);, +        if (indexBlocks != null) {, +            builder.addAll(indexBlocks);, +        }, +        return new ClusterBlockException(builder.build());, +        ImmutableSet<ClusterBlock> indexBlocks = indices(level).get(index);, +        if (indexBlocks != null && !indexBlocks.isEmpty()) {, +            return true;, +        }, +        return false;, +        ImmutableSet.Builder<ClusterBlock> builder = ImmutableSet.builder();, +        builder.addAll(global(level));, +        for (String index : indices) {, +            ImmutableSet<ClusterBlock> indexBlocks = indices(level).get(index);, +            if (indexBlocks != null) {, +                builder.addAll(indexBlocks);, +            }, +        }, +        return new ClusterBlockException(builder.build());, +        for (Map.Entry<String, ImmutableSet<ClusterBlock>> entry : indicesBlocks.entrySet()) {, +    private static void writeBlockSet(ImmutableSet<ClusterBlock> blocks, StreamOutput out) throws IOException {, +        ImmutableSet<ClusterBlock> global = readBlockSet(in);, +        ImmutableMap.Builder<String, ImmutableSet<ClusterBlock>> indicesBuilder = ImmutableMap.builder();, +    private static ImmutableSet<ClusterBlock> readBlockSet(StreamInput in) throws IOException {, +        ImmutableSet.Builder<ClusterBlock> builder = ImmutableSet.builder();, +        int size = in.readVInt();, +        for (int i = 0; i < size; i++) {, +            builder.add(ClusterBlock.readClusterBlock(in));, +        return builder.build();, +        static final ImmutableLevelHolder EMPTY = new ImmutableLevelHolder(ImmutableSet.<ClusterBlock>of(), ImmutableMap.<String, ImmutableSet<ClusterBlock>>of());, +        private final ImmutableSet<ClusterBlock> global;, +        private final ImmutableMap<String, ImmutableSet<ClusterBlock>> indices;, +        ImmutableLevelHolder(ImmutableSet<ClusterBlock> global, ImmutableMap<String, ImmutableSet<ClusterBlock>> indices) {, +        public ImmutableSet<ClusterBlock> global() {]