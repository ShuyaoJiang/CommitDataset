[+++ b/modules/elasticsearch/src/main/java/org/elasticsearch/action/admin/indices/create/TransportCreateIndexAction.java, +        createIndexService.createIndex(new MetaDataCreateIndexService.Request(cause, request.index()).settings(request.settings()).mappings(request.mappings()).timeout(request.timeout()), new MetaDataCreateIndexService.Listener() {, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/action/admin/indices/create/TransportCreateIndexAction.java, +        createIndexService.createIndex(new MetaDataCreateIndexService.Request(cause, request.index()).settings(request.settings()).mappings(request.mappings()).timeout(request.timeout()), new MetaDataCreateIndexService.Listener() {, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/cluster/metadata/IndexMetaData.java, +        public Builder putMapping(String type, String source) throws IOException {, +            XContentParser parser = XContentFactory.xContent(source).createParser(source);, +            try {, +                putMapping(new MappingMetaData(type, parser.map()));, +            } finally {, +                parser.close();, +            }, +        public Builder putMapping(MappingMetaData mappingMd) {, +            mappings.put(mappingMd.type(), mappingMd);, +            return this;, +                                builder.putMapping(new MappingMetaData(mappingType, mapping));, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/action/admin/indices/create/TransportCreateIndexAction.java, +        createIndexService.createIndex(new MetaDataCreateIndexService.Request(cause, request.index()).settings(request.settings()).mappings(request.mappings()).timeout(request.timeout()), new MetaDataCreateIndexService.Listener() {, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/cluster/metadata/IndexMetaData.java, +        public Builder putMapping(String type, String source) throws IOException {, +            XContentParser parser = XContentFactory.xContent(source).createParser(source);, +            try {, +                putMapping(new MappingMetaData(type, parser.map()));, +            } finally {, +                parser.close();, +            }, +        public Builder putMapping(MappingMetaData mappingMd) {, +            mappings.put(mappingMd.type(), mappingMd);, +            return this;, +                                builder.putMapping(new MappingMetaData(mappingType, mapping));, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/cluster/metadata/MappingMetaData.java, +import org.elasticsearch.common.logging.ESLogger;, +import org.elasticsearch.common.logging.ESLoggerFactory;, +import org.elasticsearch.common.xcontent.XContentFactory;, +import java.util.Map;, +, +import static org.elasticsearch.common.xcontent.support.XContentMapValues.*;, +    private static ESLogger logger = ESLoggerFactory.getLogger(MappingMetaData.class.getName());, +, +    public MappingMetaData(String type, Map<String, Object> mapping) throws IOException {, +        this.source = new CompressedString(XContentFactory.jsonBuilder().map(mapping).string());, +        Map<String, Object> withoutType = mapping;, +        if (mapping.size() == 1 && mapping.containsKey(type)) {, +            withoutType = (Map<String, Object>) mapping.get(type);, +        }, +        if (withoutType.containsKey("_routing")) {, +            boolean required = false;, +            String path = null;, +            Map<String, Object> routingNode = (Map<String, Object>) withoutType.get("_routing");, +            for (Map.Entry<String, Object> entry : routingNode.entrySet()) {, +                String fieldName = Strings.toUnderscoreCase(entry.getKey());, +                Object fieldNode = entry.getValue();, +                if (fieldName.equals("required")) {, +                    required = nodeBooleanValue(fieldNode);, +                } else if (fieldName.equals("path")) {, +                    path = fieldNode.toString();, +                }, +            }, +            this.routing = new Routing(required, path);, +        } else {, +    }, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/action/admin/indices/create/TransportCreateIndexAction.java, +        createIndexService.createIndex(new MetaDataCreateIndexService.Request(cause, request.index()).settings(request.settings()).mappings(request.mappings()).timeout(request.timeout()), new MetaDataCreateIndexService.Listener() {, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/cluster/metadata/IndexMetaData.java, +        public Builder putMapping(String type, String source) throws IOException {, +            XContentParser parser = XContentFactory.xContent(source).createParser(source);, +            try {, +                putMapping(new MappingMetaData(type, parser.map()));, +            } finally {, +                parser.close();, +            }, +        public Builder putMapping(MappingMetaData mappingMd) {, +            mappings.put(mappingMd.type(), mappingMd);, +            return this;, +                                builder.putMapping(new MappingMetaData(mappingType, mapping));, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/cluster/metadata/MappingMetaData.java, +import org.elasticsearch.common.logging.ESLogger;, +import org.elasticsearch.common.logging.ESLoggerFactory;, +import org.elasticsearch.common.xcontent.XContentFactory;, +import java.util.Map;, +, +import static org.elasticsearch.common.xcontent.support.XContentMapValues.*;, +    private static ESLogger logger = ESLoggerFactory.getLogger(MappingMetaData.class.getName());, +, +    public MappingMetaData(String type, Map<String, Object> mapping) throws IOException {, +        this.source = new CompressedString(XContentFactory.jsonBuilder().map(mapping).string());, +        Map<String, Object> withoutType = mapping;, +        if (mapping.size() == 1 && mapping.containsKey(type)) {, +            withoutType = (Map<String, Object>) mapping.get(type);, +        }, +        if (withoutType.containsKey("_routing")) {, +            boolean required = false;, +            String path = null;, +            Map<String, Object> routingNode = (Map<String, Object>) withoutType.get("_routing");, +            for (Map.Entry<String, Object> entry : routingNode.entrySet()) {, +                String fieldName = Strings.toUnderscoreCase(entry.getKey());, +                Object fieldNode = entry.getValue();, +                if (fieldName.equals("required")) {, +                    required = nodeBooleanValue(fieldNode);, +                } else if (fieldName.equals("path")) {]