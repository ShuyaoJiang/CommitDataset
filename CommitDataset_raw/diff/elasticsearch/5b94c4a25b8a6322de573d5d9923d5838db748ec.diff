[+++ b/modules/reindex/src/main/java/org/elasticsearch/index/reindex/AbstractAsyncBulkByScrollAction.java, +            onScrollResponse(timeValueNanos(System.nanoTime()), 0, response);, +     * @param lastBatchStartTime the time when the last batch started. Used to calculate the throttling delay., +     * @param lastBatchSize the size of the last batch. Used to calculate the throttling delay., +    void onScrollResponse(TimeValue lastBatchStartTime, int lastBatchSize, SearchResponse searchResponse) {, +                /*, +                 * It is important that the batch start time be calculated from here, scroll response to scroll response. That way the time, +                 * waiting on the scroll doesn't count against this batch in the throttle., +                 */, +                prepareBulkRequest(timeValueNanos(System.nanoTime()), searchResponse);, +        task.delayPrepareBulkRequest(threadPool, lastBatchStartTime, lastBatchSize, prepareBulkRequestRunnable);, +    void prepareBulkRequest(TimeValue thisBatchStartTime, SearchResponse searchResponse) {, +            startNextScroll(thisBatchStartTime, 0);, +        sendBulkRequest(thisBatchStartTime, request);, +    void sendBulkRequest(TimeValue thisBatchStartTime, BulkRequest request) {, +                onBulkResponse(thisBatchStartTime, response);, +    void onBulkResponse(TimeValue thisBatchStartTime, BulkResponse response) {, +            startNextScroll(thisBatchStartTime, response.getItems().length);, +    void startNextScroll(TimeValue lastBatchStartTime, int lastBatchSize) {, +        request.scrollId(scroll.get()).scroll(timeValueNanos(, +                firstSearchRequest.scroll().keepAlive().nanos() + task.throttleWaitTime(lastBatchStartTime, lastBatchSize).nanos()));, +            onScrollResponse(lastBatchStartTime, lastBatchSize, response);, +++ b/modules/reindex/src/main/java/org/elasticsearch/index/reindex/AbstractAsyncBulkByScrollAction.java, +            onScrollResponse(timeValueNanos(System.nanoTime()), 0, response);, +     * @param lastBatchStartTime the time when the last batch started. Used to calculate the throttling delay., +     * @param lastBatchSize the size of the last batch. Used to calculate the throttling delay., +    void onScrollResponse(TimeValue lastBatchStartTime, int lastBatchSize, SearchResponse searchResponse) {, +                /*, +                 * It is important that the batch start time be calculated from here, scroll response to scroll response. That way the time, +                 * waiting on the scroll doesn't count against this batch in the throttle., +                 */, +                prepareBulkRequest(timeValueNanos(System.nanoTime()), searchResponse);, +        task.delayPrepareBulkRequest(threadPool, lastBatchStartTime, lastBatchSize, prepareBulkRequestRunnable);, +    void prepareBulkRequest(TimeValue thisBatchStartTime, SearchResponse searchResponse) {, +            startNextScroll(thisBatchStartTime, 0);, +        sendBulkRequest(thisBatchStartTime, request);, +    void sendBulkRequest(TimeValue thisBatchStartTime, BulkRequest request) {, +                onBulkResponse(thisBatchStartTime, response);, +    void onBulkResponse(TimeValue thisBatchStartTime, BulkResponse response) {, +            startNextScroll(thisBatchStartTime, response.getItems().length);, +    void startNextScroll(TimeValue lastBatchStartTime, int lastBatchSize) {, +        request.scrollId(scroll.get()).scroll(timeValueNanos(, +                firstSearchRequest.scroll().keepAlive().nanos() + task.throttleWaitTime(lastBatchStartTime, lastBatchSize).nanos()));, +            onScrollResponse(lastBatchStartTime, lastBatchSize, response);, +++ b/modules/reindex/src/main/java/org/elasticsearch/index/reindex/BulkByScrollTask.java, +    private static final ESLogger logger = ESLoggerFactory.getLogger(BulkByScrollTask.class.getPackage().getName());, +    void delayPrepareBulkRequest(ThreadPool threadPool, TimeValue lastBatchStartTime, int lastBatchSize,, +            AbstractRunnable prepareBulkRequestRunnable) {, +            TimeValue delay = throttleWaitTime(lastBatchStartTime, lastBatchSize);, +    TimeValue throttleWaitTime(TimeValue lastBatchStartTime, int lastBatchSize) {, +        long earliestNextBatchStartTime = lastBatchStartTime.nanos() + (long) perfectlyThrottledBatchTime(lastBatchSize);, +        return timeValueNanos(max(0, earliestNextBatchStartTime - System.nanoTime()));, +    }, +, +    /**, +     * How many nanoseconds should a batch of lastBatchSize have taken if it were perfectly throttled? Package private for testing., +     */, +    float perfectlyThrottledBatchTime(int lastBatchSize) {, +        if (requestsPerSecond == Float.POSITIVE_INFINITY) {, +            return 0;, +        }, +        //       requests, +        // ------------------- == seconds, +        // request per seconds, +        float targetBatchTimeInSeconds = lastBatchSize / requestsPerSecond;, +        // nanoseconds per seconds * seconds == nanoseconds, +        return TimeUnit.SECONDS.toNanos(1) * targetBatchTimeInSeconds;, +    }, +, +++ b/modules/reindex/src/main/java/org/elasticsearch/index/reindex/AbstractAsyncBulkByScrollAction.java, +            onScrollResponse(timeValueNanos(System.nanoTime()), 0, response);, +     * @param lastBatchStartTime the time when the last batch started. Used to calculate the throttling delay., +     * @param lastBatchSize the size of the last batch. Used to calculate the throttling delay., +    void onScrollResponse(TimeValue lastBatchStartTime, int lastBatchSize, SearchResponse searchResponse) {, +                /*, +                 * It is important that the batch start time be calculated from here, scroll response to scroll response. That way the time, +                 * waiting on the scroll doesn't count against this batch in the throttle., +                 */, +                prepareBulkRequest(timeValueNanos(System.nanoTime()), searchResponse);, +        task.delayPrepareBulkRequest(threadPool, lastBatchStartTime, lastBatchSize, prepareBulkRequestRunnable);, +    void prepareBulkRequest(TimeValue thisBatchStartTime, SearchResponse searchResponse) {, +            startNextScroll(thisBatchStartTime, 0);, +        sendBulkRequest(thisBatchStartTime, request);, +    void sendBulkRequest(TimeValue thisBatchStartTime, BulkRequest request) {, +                onBulkResponse(thisBatchStartTime, response);, +    void onBulkResponse(TimeValue thisBatchStartTime, BulkResponse response) {, +            startNextScroll(thisBatchStartTime, response.getItems().length);, +    void startNextScroll(TimeValue lastBatchStartTime, int lastBatchSize) {, +        request.scrollId(scroll.get()).scroll(timeValueNanos(, +                firstSearchRequest.scroll().keepAlive().nanos() + task.throttleWaitTime(lastBatchStartTime, lastBatchSize).nanos()));, +            onScrollResponse(lastBatchStartTime, lastBatchSize, response);, +++ b/modules/reindex/src/main/java/org/elasticsearch/index/reindex/BulkByScrollTask.java, +    private static final ESLogger logger = ESLoggerFactory.getLogger(BulkByScrollTask.class.getPackage().getName());, +    void delayPrepareBulkRequest(ThreadPool threadPool, TimeValue lastBatchStartTime, int lastBatchSize,, +            AbstractRunnable prepareBulkRequestRunnable) {, +            TimeValue delay = throttleWaitTime(lastBatchStartTime, lastBatchSize);, +    TimeValue throttleWaitTime(TimeValue lastBatchStartTime, int lastBatchSize) {, +        long earliestNextBatchStartTime = lastBatchStartTime.nanos() + (long) perfectlyThrottledBatchTime(lastBatchSize);, +        return timeValueNanos(max(0, earliestNextBatchStartTime - System.nanoTime()));, +    }]