[+++ b/modules/elasticsearch/src/main/java/org/elasticsearch/index/store/memory/ByteBufferDirectory.java, +import java.util.concurrent.ConcurrentHashMap;, + * A memory based directory that uses {@link java.nio.ByteBuffer} in order to store the directory content., + *, + * <p>The benefit of using {@link java.nio.ByteBuffer} is the fact that it can be stored in "native" memory, + * outside of the JVM heap, thus not incurring the GC overhead of large in memory index., + *, + * <p>Each "file" is segmented into one or more byte buffers., + *, + * <p>Since its good practice to cache byte buffers, it also provide a simple mechanism to define a cache, + * of byte buffers that are reused when possible., + *, + * @author kimchy (shay.banon), +    private final Map<String, ByteBufferFile> files = new ConcurrentHashMap<String, ByteBufferFile>();, +    private final int cacheSizeInBytes;, +    /**, +     * Constructs a new byte buffer directory., +     *, +     * @param bufferSizeInBytes The size of a byte buffer, +     * @param cacheSizeInBytes  The size of the cache, set to <code>0</code> to disable caching, +     * @param direct            Should the byte buffers be stored outside the heap (<code>true</code) or in head (<code>false</code>), +     * @param warmCache         Should the cache be warmed, +     */, +    public ByteBufferDirectory(int bufferSizeInBytes, int cacheSizeInBytes, boolean direct, boolean warmCache) {, +        disableCache = cacheSizeInBytes == 0;, +        if (!disableCache && cacheSizeInBytes < bufferSizeInBytes) {, +            throw new IllegalArgumentException("Cache size [" + cacheSizeInBytes + "] is smaller than buffer size [" + bufferSizeInBytes + "]");, +        this.bufferSizeInBytes = bufferSizeInBytes;, +        int numberOfCacheEntries = cacheSizeInBytes / bufferSizeInBytes;, +        this.cacheSizeInBytes = disableCache ? 0 : numberOfCacheEntries * bufferSizeInBytes;, +    public int cacheSizeInBytes() {, +        return this.cacheSizeInBytes;, +    public int bufferSizeInBytes() {, +    public boolean isCacheEnabled() {, +        return !disableCache;, +    }, +, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/index/store/memory/ByteBufferDirectory.java, +import java.util.concurrent.ConcurrentHashMap;, + * A memory based directory that uses {@link java.nio.ByteBuffer} in order to store the directory content., + *, + * <p>The benefit of using {@link java.nio.ByteBuffer} is the fact that it can be stored in "native" memory, + * outside of the JVM heap, thus not incurring the GC overhead of large in memory index., + *, + * <p>Each "file" is segmented into one or more byte buffers., + *, + * <p>Since its good practice to cache byte buffers, it also provide a simple mechanism to define a cache, + * of byte buffers that are reused when possible., + *, + * @author kimchy (shay.banon), +    private final Map<String, ByteBufferFile> files = new ConcurrentHashMap<String, ByteBufferFile>();, +    private final int cacheSizeInBytes;, +    /**, +     * Constructs a new byte buffer directory., +     *, +     * @param bufferSizeInBytes The size of a byte buffer, +     * @param cacheSizeInBytes  The size of the cache, set to <code>0</code> to disable caching, +     * @param direct            Should the byte buffers be stored outside the heap (<code>true</code) or in head (<code>false</code>), +     * @param warmCache         Should the cache be warmed, +     */, +    public ByteBufferDirectory(int bufferSizeInBytes, int cacheSizeInBytes, boolean direct, boolean warmCache) {, +        disableCache = cacheSizeInBytes == 0;, +        if (!disableCache && cacheSizeInBytes < bufferSizeInBytes) {, +            throw new IllegalArgumentException("Cache size [" + cacheSizeInBytes + "] is smaller than buffer size [" + bufferSizeInBytes + "]");, +        this.bufferSizeInBytes = bufferSizeInBytes;, +        int numberOfCacheEntries = cacheSizeInBytes / bufferSizeInBytes;, +        this.cacheSizeInBytes = disableCache ? 0 : numberOfCacheEntries * bufferSizeInBytes;, +    public int cacheSizeInBytes() {, +        return this.cacheSizeInBytes;, +    public int bufferSizeInBytes() {, +    public boolean isCacheEnabled() {, +        return !disableCache;, +    }, +, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/index/store/memory/ByteBufferFile.java, + * @author kimchy (shay.banon), +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/index/store/memory/ByteBufferDirectory.java, +import java.util.concurrent.ConcurrentHashMap;, + * A memory based directory that uses {@link java.nio.ByteBuffer} in order to store the directory content., + *, + * <p>The benefit of using {@link java.nio.ByteBuffer} is the fact that it can be stored in "native" memory, + * outside of the JVM heap, thus not incurring the GC overhead of large in memory index., + *, + * <p>Each "file" is segmented into one or more byte buffers., + *, + * <p>Since its good practice to cache byte buffers, it also provide a simple mechanism to define a cache, + * of byte buffers that are reused when possible., + *, + * @author kimchy (shay.banon), +    private final Map<String, ByteBufferFile> files = new ConcurrentHashMap<String, ByteBufferFile>();, +    private final int cacheSizeInBytes;, +    /**, +     * Constructs a new byte buffer directory., +     *, +     * @param bufferSizeInBytes The size of a byte buffer, +     * @param cacheSizeInBytes  The size of the cache, set to <code>0</code> to disable caching, +     * @param direct            Should the byte buffers be stored outside the heap (<code>true</code) or in head (<code>false</code>), +     * @param warmCache         Should the cache be warmed, +     */, +    public ByteBufferDirectory(int bufferSizeInBytes, int cacheSizeInBytes, boolean direct, boolean warmCache) {]