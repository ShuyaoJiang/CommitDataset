[+++ b/core/src/test/java/org/elasticsearch/index/query/AbstractQueryTestCase.java, +, +            XContentBuilder shuffled = shuffleXContent(builder, shuffleProtectedFields());, +            assertParsedQuery(shuffled.bytes(), testQuery);, +    /**, +     * Subclasses can override this method and return a set of fields which should be protected from, +     * recursive random shuffling in the {@link #testFromXContent()} test case, +     */, +    protected Set<String> shuffleProtectedFields() {, +        return Collections.emptySet();, +    }, +, +++ b/core/src/test/java/org/elasticsearch/index/query/AbstractQueryTestCase.java, +, +            XContentBuilder shuffled = shuffleXContent(builder, shuffleProtectedFields());, +            assertParsedQuery(shuffled.bytes(), testQuery);, +    /**, +     * Subclasses can override this method and return a set of fields which should be protected from, +     * recursive random shuffling in the {@link #testFromXContent()} test case, +     */, +    protected Set<String> shuffleProtectedFields() {, +        return Collections.emptySet();, +    }, +, +++ b/core/src/test/java/org/elasticsearch/index/query/PercolatorQueryBuilderTests.java, +, +import java.util.Set;, +    private static final Set<String> SHUFFLE_PROTECTED_FIELDS =, +            Collections.singleton(PercolatorQueryParser.DOCUMENT_FIELD.getPreferredName());, +    /**, +     * we don't want to shuffle the "document" field internally in {@link #testFromXContent()} because even though the, +     * documents would be functionally the same, their {@link BytesReference} representation isn't and thats what we, +     * compare when check for equality of the original and the shuffled builder, +     */, +    @Override, +    protected Set<String> shuffleProtectedFields() {, +        return SHUFFLE_PROTECTED_FIELDS;, +    }, +, +    @Override, +++ b/core/src/test/java/org/elasticsearch/index/query/AbstractQueryTestCase.java, +, +            XContentBuilder shuffled = shuffleXContent(builder, shuffleProtectedFields());, +            assertParsedQuery(shuffled.bytes(), testQuery);, +    /**, +     * Subclasses can override this method and return a set of fields which should be protected from, +     * recursive random shuffling in the {@link #testFromXContent()} test case, +     */, +    protected Set<String> shuffleProtectedFields() {, +        return Collections.emptySet();, +    }, +, +++ b/core/src/test/java/org/elasticsearch/index/query/PercolatorQueryBuilderTests.java, +, +import java.util.Set;, +    private static final Set<String> SHUFFLE_PROTECTED_FIELDS =, +            Collections.singleton(PercolatorQueryParser.DOCUMENT_FIELD.getPreferredName());, +    /**, +     * we don't want to shuffle the "document" field internally in {@link #testFromXContent()} because even though the, +     * documents would be functionally the same, their {@link BytesReference} representation isn't and thats what we, +     * compare when check for equality of the original and the shuffled builder, +     */, +    @Override, +    protected Set<String> shuffleProtectedFields() {, +        return SHUFFLE_PROTECTED_FIELDS;, +    }, +, +    @Override, +++ b/core/src/test/java/org/elasticsearch/search/SearchModuleTests.java, +import java.io.IOException;, +, +++ b/core/src/test/java/org/elasticsearch/index/query/AbstractQueryTestCase.java, +, +            XContentBuilder shuffled = shuffleXContent(builder, shuffleProtectedFields());, +            assertParsedQuery(shuffled.bytes(), testQuery);, +    /**, +     * Subclasses can override this method and return a set of fields which should be protected from, +     * recursive random shuffling in the {@link #testFromXContent()} test case, +     */, +    protected Set<String> shuffleProtectedFields() {, +        return Collections.emptySet();, +    }, +, +++ b/core/src/test/java/org/elasticsearch/index/query/PercolatorQueryBuilderTests.java, +, +import java.util.Set;, +    private static final Set<String> SHUFFLE_PROTECTED_FIELDS =, +            Collections.singleton(PercolatorQueryParser.DOCUMENT_FIELD.getPreferredName());, +    /**, +     * we don't want to shuffle the "document" field internally in {@link #testFromXContent()} because even though the, +     * documents would be functionally the same, their {@link BytesReference} representation isn't and thats what we, +     * compare when check for equality of the original and the shuffled builder, +     */, +    @Override, +    protected Set<String> shuffleProtectedFields() {, +        return SHUFFLE_PROTECTED_FIELDS;, +    }, +, +    @Override, +++ b/core/src/test/java/org/elasticsearch/search/SearchModuleTests.java]