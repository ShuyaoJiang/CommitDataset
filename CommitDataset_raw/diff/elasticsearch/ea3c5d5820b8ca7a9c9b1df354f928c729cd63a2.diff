[+++ b/src/main/java/org/elasticsearch/action/admin/indices/mapping/get/TransportGetFieldMappingsIndexAction.java, +                    if (Regex.simpleMatch(field, fieldMapper.names().shortName())) {, +                        addFieldMapper(fieldMapper.names().shortName(), fieldMapper, fieldMappings, request.includeDefaults());, +++ b/src/main/java/org/elasticsearch/action/admin/indices/mapping/get/TransportGetFieldMappingsIndexAction.java, +                    if (Regex.simpleMatch(field, fieldMapper.names().shortName())) {, +                        addFieldMapper(fieldMapper.names().shortName(), fieldMapper, fieldMappings, request.includeDefaults());, +++ b/src/main/java/org/elasticsearch/index/fielddata/plain/DisabledIndexFieldData.java, +        return new IllegalStateException("Field data loading is forbidden on " + getFieldNames().fullName());, +++ b/src/main/java/org/elasticsearch/action/admin/indices/mapping/get/TransportGetFieldMappingsIndexAction.java, +                    if (Regex.simpleMatch(field, fieldMapper.names().shortName())) {, +                        addFieldMapper(fieldMapper.names().shortName(), fieldMapper, fieldMappings, request.includeDefaults());, +++ b/src/main/java/org/elasticsearch/index/fielddata/plain/DisabledIndexFieldData.java, +        return new IllegalStateException("Field data loading is forbidden on " + getFieldNames().fullName());, +++ b/src/main/java/org/elasticsearch/index/fielddata/plain/DocValuesIndexFieldData.java, +                throw new IllegalArgumentException("Doc values field data doesn't support filters [" + fieldNames.fullName() + "]");, +++ b/src/main/java/org/elasticsearch/action/admin/indices/mapping/get/TransportGetFieldMappingsIndexAction.java, +                    if (Regex.simpleMatch(field, fieldMapper.names().shortName())) {, +                        addFieldMapper(fieldMapper.names().shortName(), fieldMapper, fieldMappings, request.includeDefaults());, +++ b/src/main/java/org/elasticsearch/index/fielddata/plain/DisabledIndexFieldData.java, +        return new IllegalStateException("Field data loading is forbidden on " + getFieldNames().fullName());, +++ b/src/main/java/org/elasticsearch/index/fielddata/plain/DocValuesIndexFieldData.java, +                throw new IllegalArgumentException("Doc values field data doesn't support filters [" + fieldNames.fullName() + "]");, +++ b/src/main/java/org/elasticsearch/index/mapper/ContentPath.java, +    public enum Type {, +++ b/src/main/java/org/elasticsearch/action/admin/indices/mapping/get/TransportGetFieldMappingsIndexAction.java, +                    if (Regex.simpleMatch(field, fieldMapper.names().shortName())) {, +                        addFieldMapper(fieldMapper.names().shortName(), fieldMapper, fieldMappings, request.includeDefaults());, +++ b/src/main/java/org/elasticsearch/index/fielddata/plain/DisabledIndexFieldData.java, +        return new IllegalStateException("Field data loading is forbidden on " + getFieldNames().fullName());, +++ b/src/main/java/org/elasticsearch/index/fielddata/plain/DocValuesIndexFieldData.java, +                throw new IllegalArgumentException("Doc values field data doesn't support filters [" + fieldNames.fullName() + "]");, +++ b/src/main/java/org/elasticsearch/index/mapper/ContentPath.java, +    public enum Type {, +++ b/src/main/java/org/elasticsearch/index/mapper/FieldMapper.java, +    String DOC_VALUES_FORMAT = "doc_values_format";, +    class Names {, +        private final String shortName;, +        private final String originalIndexName;, +        public Names(String shortName, String indexName, String originalIndexName, String fullName) {, +            this.shortName = shortName;, +            this.originalIndexName = originalIndexName;, +        public String shortName() {, +            return shortName;, +         * The original index name, before any "path" modifications performed on it., +        public String originalIndexName() {, +            return originalIndexName;, +            if (!originalIndexName.equals(names.originalIndexName)) return false;, +            if (!shortName.equals(names.shortName)) return false;, +            int result = shortName.hashCode();, +            result = 31 * result + originalIndexName.hashCode();, +    enum Loading {, +    AbstractFieldMapper.CopyTo copyTo();, +    boolean isGenerated();, +++ b/src/main/java/org/elasticsearch/action/admin/indices/mapping/get/TransportGetFieldMappingsIndexAction.java, +                    if (Regex.simpleMatch(field, fieldMapper.names().shortName())) {, +                        addFieldMapper(fieldMapper.names().shortName(), fieldMapper, fieldMappings, request.includeDefaults());, +++ b/src/main/java/org/elasticsearch/index/fielddata/plain/DisabledIndexFieldData.java, +        return new IllegalStateException("Field data loading is forbidden on " + getFieldNames().fullName());, +++ b/src/main/java/org/elasticsearch/index/fielddata/plain/DocValuesIndexFieldData.java, +                throw new IllegalArgumentException("Doc values field data doesn't support filters [" + fieldNames.fullName() + "]");, +++ b/src/main/java/org/elasticsearch/index/mapper/ContentPath.java, +    public enum Type {, +++ b/src/main/java/org/elasticsearch/index/mapper/FieldMapper.java, +    String DOC_VALUES_FORMAT = "doc_values_format";, +    class Names {, +        private final String shortName;, +        private final String originalIndexName;, +        public Names(String shortName, String indexName, String originalIndexName, String fullName) {, +            this.shortName = shortName;, +            this.originalIndexName = originalIndexName;, +        public String shortName() {, +            return shortName;, +         * The original index name, before any "path" modifications performed on it., +        public String originalIndexName() {, +            return originalIndexName;, +            if (!originalIndexName.equals(names.originalIndexName)) return false;, +            if (!shortName.equals(names.shortName)) return false;, +            int result = shortName.hashCode();, +            result = 31 * result + originalIndexName.hashCode();, +    enum Loading {, +    AbstractFieldMapper.CopyTo copyTo();, +    boolean isGenerated();, +++ b/src/main/java/org/elasticsearch/index/mapper/core/AbstractFieldMapper.java, +            return new Names(name, buildIndexName(context), buildIndexNameClean(context), buildFullName(context));, +        // TODO: cleanup names so Mapper knows about paths, so that it is always clear whether we are using short or full name, +        return names.shortName();, +        return new TermQuery(createTerm(value));, +        return new FuzzyQuery(createTerm(value), fuzziness.asDistance(value), prefixLength, maxExpansions, transpositions);, +        PrefixQuery query = new PrefixQuery(createTerm(value));, +        RegexpQuery query = new RegexpQuery(createTerm(value), flags, maxDeterminizedStates);, +    protected Term createTerm(Object value) {, +        return new Term(names.indexName(), indexedValueForSearch(value));, +    }, +, +        builder.startObject(names.shortName());, +        if (indexCreatedBefore2x && (includeDefaults || !names.shortName().equals(names.originalIndexName()))) {, +            builder.field("index_name", names.originalIndexName());, +            context.path().add(mainField.names().shortName());, +                Mapper mergeIntoMapper = mappers.get(mergeWithMapper.names().shortName());, +                        newMappersBuilder.put(mergeWithMapper.names().shortName(), mergeWithMapper);]