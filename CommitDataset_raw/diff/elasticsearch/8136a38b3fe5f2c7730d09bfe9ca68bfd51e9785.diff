[+++ b/src/main/java/org/elasticsearch/common/hash/MurmurHash3.java, +     *, +     * Note, this hashing function might be used to persist hashes, so if the way hashes are computed, +     * changes for some reason, it needs to be addressed (like in BloomFilter and MurmurHashField)., +++ b/src/main/java/org/elasticsearch/common/hash/MurmurHash3.java, +     *, +     * Note, this hashing function might be used to persist hashes, so if the way hashes are computed, +     * changes for some reason, it needs to be addressed (like in BloomFilter and MurmurHashField)., +++ b/src/main/java/org/elasticsearch/common/util/BloomFilter.java, +import org.elasticsearch.ElasticsearchIllegalArgumentException;, +import org.elasticsearch.common.hash.MurmurHash3;, +            return new BloomFilter(new BitArray(numBits), numHashFunctions, Hashing.DEFAULT);, +        int hashType = in.readInt();, +        return new BloomFilter(new BitArray(data), numberOfHashFunctions, Hashing.fromType(hashType));, +        out.writeInt(filter.hashing.type()); // hashType, +        return new BloomFilter(new BitArray(data), numberOfHashFunctions, Hashing.fromType(hashType));, +        out.writeVInt(filter.hashing.type()); // hashType, +    final Hashing hashing;, +, +    BloomFilter(BitArray bits, int numHashFunctions, Hashing hashing) {, +        this.hashing = hashing;, +        return hashing.put(value, numHashFunctions, bits);, +        return hashing.mightContain(value, numHashFunctions, bits);, +        return bits.bitSize() + 8;, +    // Note: We use this instead of java.util.BitSet because we need access to the long[] data field, +    static final class BitArray {, +        final long[] data;, +        final long bitSize;, +        long bitCount;, +, +        BitArray(long bits) {, +            this(new long[Ints.checkedCast(LongMath.divide(bits, 64, RoundingMode.CEILING))]);, +        }, +, +        // Used by serialization, +        BitArray(long[] data) {, +            this.data = data;, +            long bitCount = 0;, +            for (long value : data) {, +                bitCount += Long.bitCount(value);, +            }, +            this.bitCount = bitCount;, +            this.bitSize = data.length * Long.SIZE;, +        }, +, +        /** Returns true if the bit changed value. */, +        boolean set(long index) {, +            if (!get(index)) {, +                data[(int) (index >>> 6)] |= (1L << index);, +                bitCount++;, +                return true;, +            }, +            return false;, +        }, +, +        boolean get(long index) {, +            return (data[(int) (index >>> 6)] & (1L << index)) != 0;, +        }, +, +        /** Number of bits */, +        long bitSize() {, +            return bitSize;, +        }, +, +        /** Number of set bits (1s) */, +        long bitCount() {, +            return bitCount;, +        }, +, +        BitArray copy() {, +            return new BitArray(data.clone());, +        }, +, +        /** Combines the two BitArrays using bitwise OR. */, +        void putAll(BitArray array) {, +            bitCount = 0;, +            for (int i = 0; i < data.length; i++) {, +                data[i] |= array.data[i];, +                bitCount += Long.bitCount(data[i]);, +            }, +        }, +, +        @Override public boolean equals(Object o) {, +            if (o instanceof BitArray) {, +                BitArray bitArray = (BitArray) o;, +                return Arrays.equals(data, bitArray.data);, +            }, +            return false;, +        }, +, +        @Override public int hashCode() {, +            return Arrays.hashCode(data);, +        }, +    }, +, +    static enum Hashing {, +, +        V0() {, +            @Override, +            protected boolean put(BytesRef value, int numHashFunctions, BitArray bits) {]