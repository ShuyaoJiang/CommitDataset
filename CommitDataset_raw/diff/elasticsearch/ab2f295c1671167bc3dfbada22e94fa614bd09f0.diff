[+++ b/core/src/main/java/org/elasticsearch/search/aggregations/pipeline/bucketmetrics/BucketMetricsParser.java, +import java.text.ParseException;, +import java.util.HashMap;, +import java.util.Map;, +        Map<String, Object> leftover = new HashMap<>(5);, +                    leftover.put(currentFieldName, parser.text());, +                    leftover.put(currentFieldName, parser.list());, +                leftover.put(currentFieldName, parser.objectText());, +                    + "] for aggregation [" + pipelineAggregatorName + "]", parser.getTokenLocation());, +        PipelineAggregatorFactory factory = null;, +        try {, +            factory = buildFactory(pipelineAggregatorName, bucketsPaths, gapPolicy, formatter, leftover);, +        } catch (ParseException exception) {, +            throw new SearchParseException(context, "Could not parse settings for aggregation [", +                    + pipelineAggregatorName + "].", null, exception);, +        }, +, +        if (leftover.size() > 0) {, +            throw new SearchParseException(context, "Unexpected tokens " + leftover.keySet() + " in [" + pipelineAggregatorName + "].", null);, +        }, +        assert(factory != null);, +, +        return factory;, +            ValueFormatter formatter, Map<String, Object> unparsedParams) throws ParseException;, +++ b/core/src/main/java/org/elasticsearch/search/aggregations/pipeline/bucketmetrics/BucketMetricsParser.java, +import java.text.ParseException;, +import java.util.HashMap;, +import java.util.Map;, +        Map<String, Object> leftover = new HashMap<>(5);, +                    leftover.put(currentFieldName, parser.text());, +                    leftover.put(currentFieldName, parser.list());, +                leftover.put(currentFieldName, parser.objectText());, +                    + "] for aggregation [" + pipelineAggregatorName + "]", parser.getTokenLocation());, +        PipelineAggregatorFactory factory = null;, +        try {, +            factory = buildFactory(pipelineAggregatorName, bucketsPaths, gapPolicy, formatter, leftover);, +        } catch (ParseException exception) {, +            throw new SearchParseException(context, "Could not parse settings for aggregation [", +                    + pipelineAggregatorName + "].", null, exception);, +        }, +, +        if (leftover.size() > 0) {, +            throw new SearchParseException(context, "Unexpected tokens " + leftover.keySet() + " in [" + pipelineAggregatorName + "].", null);, +        }, +        assert(factory != null);, +, +        return factory;, +            ValueFormatter formatter, Map<String, Object> unparsedParams) throws ParseException;, +++ b/core/src/main/java/org/elasticsearch/search/aggregations/pipeline/bucketmetrics/avg/AvgBucketParser.java, +import java.util.Map;, +, +            ValueFormatter formatter, Map<String, Object> unparsedParams) {, +++ b/core/src/main/java/org/elasticsearch/search/aggregations/pipeline/bucketmetrics/BucketMetricsParser.java, +import java.text.ParseException;, +import java.util.HashMap;, +import java.util.Map;, +        Map<String, Object> leftover = new HashMap<>(5);, +                    leftover.put(currentFieldName, parser.text());, +                    leftover.put(currentFieldName, parser.list());, +                leftover.put(currentFieldName, parser.objectText());, +                    + "] for aggregation [" + pipelineAggregatorName + "]", parser.getTokenLocation());, +        PipelineAggregatorFactory factory = null;, +        try {, +            factory = buildFactory(pipelineAggregatorName, bucketsPaths, gapPolicy, formatter, leftover);, +        } catch (ParseException exception) {, +            throw new SearchParseException(context, "Could not parse settings for aggregation [", +                    + pipelineAggregatorName + "].", null, exception);, +        }, +, +        if (leftover.size() > 0) {, +            throw new SearchParseException(context, "Unexpected tokens " + leftover.keySet() + " in [" + pipelineAggregatorName + "].", null);, +        }, +        assert(factory != null);, +, +        return factory;, +            ValueFormatter formatter, Map<String, Object> unparsedParams) throws ParseException;, +++ b/core/src/main/java/org/elasticsearch/search/aggregations/pipeline/bucketmetrics/avg/AvgBucketParser.java, +import java.util.Map;, +, +            ValueFormatter formatter, Map<String, Object> unparsedParams) {, +++ b/core/src/main/java/org/elasticsearch/search/aggregations/pipeline/bucketmetrics/max/MaxBucketParser.java, +import java.util.Map;, +, +    protected PipelineAggregatorFactory buildFactory(String pipelineAggregatorName, String[] bucketsPaths, GapPolicy gapPolicy,, +                                                     ValueFormatter formatter, Map<String, Object> unparsedParams) {, +++ b/core/src/main/java/org/elasticsearch/search/aggregations/pipeline/bucketmetrics/BucketMetricsParser.java, +import java.text.ParseException;, +import java.util.HashMap;, +import java.util.Map;, +        Map<String, Object> leftover = new HashMap<>(5);, +                    leftover.put(currentFieldName, parser.text());, +                    leftover.put(currentFieldName, parser.list());, +                leftover.put(currentFieldName, parser.objectText());, +                    + "] for aggregation [" + pipelineAggregatorName + "]", parser.getTokenLocation());, +        PipelineAggregatorFactory factory = null;, +        try {, +            factory = buildFactory(pipelineAggregatorName, bucketsPaths, gapPolicy, formatter, leftover);, +        } catch (ParseException exception) {, +            throw new SearchParseException(context, "Could not parse settings for aggregation [", +                    + pipelineAggregatorName + "].", null, exception);]