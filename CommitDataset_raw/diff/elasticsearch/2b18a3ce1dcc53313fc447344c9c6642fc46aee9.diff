[+++ b/core/src/main/java/org/elasticsearch/env/NodeEnvironment.java, +        public NodePath(Path path) throws IOException {, +         * ${data.paths}/nodes/{node.id}/indices/{index.uuid}/{shard.id}, +         * Resolves index directory against this NodePath, +         * ${data.paths}/nodes/{node.id}/indices/{index.uuid}, +            return indicesPath.resolve(index.getUUID());, +    private final Map<ShardId, InternalShardLock> shardLocks = new HashMap<>();, +                            nodePaths[dirIndex] = new NodePath(dir);, +        final Path[] indexPaths = indexPaths(index);, +            Path customLocation = resolveIndexCustomLocation(indexSettings);, +            if (shardLocks.containsKey(shardId)) {, +                shardLock = shardLocks.get(shardId);, +                shardLock = new InternalShardLock(shardId);, +                shardLocks.put(shardId, shardLock);, +                logger.trace("released shard lock for [{}]", shardId);, +            return unmodifiableSet(new HashSet<>(shardLocks.keySet()));, +        private final ShardId shardId;, +        InternalShardLock(ShardId shardId) {, +            this.shardId = shardId;, +                logger.trace("shard lock wait count for {} is now [{}]", shardId, waitCount);, +                    logger.trace("last shard lock wait decremented, removing lock for {}", shardId);, +                    InternalShardLock remove = shardLocks.remove(shardId);, +                    throw new LockObtainFailedException("Can't lock shard " + shardId + ", timed out after " + timeoutInMillis + "ms");, +                throw new LockObtainFailedException("Can't lock shard " + shardId + ", interrupted", e);, +    public Path[] indexPaths(Index index) {, +            indexPaths[i] = nodePaths[i].resolve(index);, +    /**, +     * Returns all folder names in ${data.paths}/nodes/{node.id}/indices folder, +     */, +    public Set<String> availableIndexFolders() throws IOException {, +        Set<String> indexFolders = new HashSet<>();, +                            indexFolders.add(index.getFileName().toString());, +        return indexFolders;, +, +    }, +, +    /**, +     * Resolves all existing paths to <code>indexFolderName</code> in ${data.paths}/nodes/{node.id}/indices, +     */, +    public Path[] resolveIndexFolder(String indexFolderName) throws IOException {, +        if (nodePaths == null || locks == null) {, +            throw new IllegalStateException("node is not configured to store local location");, +        }, +        assert assertEnvIsLocked();, +        List<Path> paths = new ArrayList<>(nodePaths.length);, +        for (NodePath nodePath : nodePaths) {, +            Path indexFolder = nodePath.indicesPath.resolve(indexFolderName);, +            if (Files.exists(indexFolder)) {, +                paths.add(indexFolder);, +            }, +        }, +        return paths.toArray(new Path[paths.size()]);, +        final String indexUniquePathId = index.getUUID();, +                        if (indexUniquePathId.equals(indexPath.getFileName().toString())) {, +        assert indexPath.getFileName().toString().equals(index.getUUID());, +    public Path resolveBaseCustomLocation(IndexSettings indexSettings) {, +    private Path resolveIndexCustomLocation(IndexSettings indexSettings) {, +        return resolveBaseCustomLocation(indexSettings).resolve(indexSettings.getUUID());, +        return resolveIndexCustomLocation(indexSettings).resolve(Integer.toString(shardId.id()));, +        for (String indexFolderName : this.availableIndexFolders()) {, +            for (Path indexPath : this.resolveIndexFolder(indexFolderName)) { // check index paths are writable, +                Path indexStatePath = indexPath.resolve(MetaDataStateFormat.STATE_DIR_NAME);, +                tryWriteTempFile(indexStatePath);, +                tryWriteTempFile(indexPath);, +                try (DirectoryStream<Path> stream = Files.newDirectoryStream(indexPath)) {, +                    for (Path shardPath : stream) {, +                        String fileName = shardPath.getFileName().toString();, +                        if (Files.isDirectory(shardPath) && fileName.chars().allMatch(Character::isDigit)) {, +                            Path indexDir = shardPath.resolve(ShardPath.INDEX_FOLDER_NAME);, +                            Path statePath = shardPath.resolve(MetaDataStateFormat.STATE_DIR_NAME);, +                            Path translogDir = shardPath.resolve(ShardPath.TRANSLOG_FOLDER_NAME);, +                            tryWriteTempFile(shardPath);, +                        }, +                    }, +++ b/core/src/main/java/org/elasticsearch/env/NodeEnvironment.java, +        public NodePath(Path path) throws IOException {, +         * ${data.paths}/nodes/{node.id}/indices/{index.uuid}/{shard.id}, +         * Resolves index directory against this NodePath, +         * ${data.paths}/nodes/{node.id}/indices/{index.uuid}, +            return indicesPath.resolve(index.getUUID());, +    private final Map<ShardId, InternalShardLock> shardLocks = new HashMap<>();, +                            nodePaths[dirIndex] = new NodePath(dir);, +        final Path[] indexPaths = indexPaths(index);, +            Path customLocation = resolveIndexCustomLocation(indexSettings);, +            if (shardLocks.containsKey(shardId)) {, +                shardLock = shardLocks.get(shardId);, +                shardLock = new InternalShardLock(shardId);, +                shardLocks.put(shardId, shardLock);, +                logger.trace("released shard lock for [{}]", shardId);, +            return unmodifiableSet(new HashSet<>(shardLocks.keySet()));, +        private final ShardId shardId;, +        InternalShardLock(ShardId shardId) {, +            this.shardId = shardId;, +                logger.trace("shard lock wait count for {} is now [{}]", shardId, waitCount);, +                    logger.trace("last shard lock wait decremented, removing lock for {}", shardId);, +                    InternalShardLock remove = shardLocks.remove(shardId);, +                    throw new LockObtainFailedException("Can't lock shard " + shardId + ", timed out after " + timeoutInMillis + "ms");, +                throw new LockObtainFailedException("Can't lock shard " + shardId + ", interrupted", e);, +    public Path[] indexPaths(Index index) {, +            indexPaths[i] = nodePaths[i].resolve(index);]