[+++ b/buildSrc/src/main/resources/checkstyle_suppressions.xml, +++ b/buildSrc/src/main/resources/checkstyle_suppressions.xml, +++ b/core/src/main/java/org/elasticsearch/action/get/TransportMultiGetAction.java, +                                   ActionFilters actionFilters, IndexNameExpressionResolver resolver) {, +        super(settings, MultiGetAction.NAME, threadPool, transportService, actionFilters, resolver, MultiGetRequest::new);, +        final Map<ShardId, MultiGetShardRequest> shardRequests = new HashMap<>();, +, +                responses.set(i, newItemFailure(item.index(), item.type(), item.id(), new IndexNotFoundException(item.index())));, +, +            String concreteSingleIndex;, +            try {, +                concreteSingleIndex = indexNameExpressionResolver.concreteSingleIndex(clusterState, item).getName();, +, +                if ((item.routing() == null) && (clusterState.getMetaData().routingRequired(concreteSingleIndex, item.type()))) {, +                    String message = "routing is required for [" + concreteSingleIndex + "]/[" + item.type() + "]/[" + item.id() + "]";, +                    responses.set(i, newItemFailure(concreteSingleIndex, item.type(), item.id(), new IllegalArgumentException(message)));, +            } catch (Exception e) {, +                responses.set(i, newItemFailure(item.index(), item.type(), item.id(), e));, +                continue;, +            }, +, +                    .getShards(clusterState, concreteSingleIndex, item.id(), item.routing(), null), +                    .shardId();, +, +                shardRequest = new MultiGetShardRequest(request, shardId.getIndexName(), shardId.getId());, +        if (shardRequests.isEmpty()) {, +                        MultiGetItemResponse itemResponse = new MultiGetItemResponse(response.responses.get(i), response.failures.get(i));, +                        responses.set(response.locations.get(i), itemResponse);, +                        responses.set(shardRequest.locations.get(i), newItemFailure(shardRequest.index(), item.type(), item.id(), e));, +, +    private static MultiGetItemResponse newItemFailure(String index, String type, String id, Exception exception) {, +        return new MultiGetItemResponse(null, new MultiGetResponse.Failure(index, type, id, exception));, +    }, +++ b/buildSrc/src/main/resources/checkstyle_suppressions.xml, +++ b/core/src/main/java/org/elasticsearch/action/get/TransportMultiGetAction.java, +                                   ActionFilters actionFilters, IndexNameExpressionResolver resolver) {, +        super(settings, MultiGetAction.NAME, threadPool, transportService, actionFilters, resolver, MultiGetRequest::new);, +        final Map<ShardId, MultiGetShardRequest> shardRequests = new HashMap<>();, +, +                responses.set(i, newItemFailure(item.index(), item.type(), item.id(), new IndexNotFoundException(item.index())));, +, +            String concreteSingleIndex;, +            try {, +                concreteSingleIndex = indexNameExpressionResolver.concreteSingleIndex(clusterState, item).getName();, +, +                if ((item.routing() == null) && (clusterState.getMetaData().routingRequired(concreteSingleIndex, item.type()))) {, +                    String message = "routing is required for [" + concreteSingleIndex + "]/[" + item.type() + "]/[" + item.id() + "]";, +                    responses.set(i, newItemFailure(concreteSingleIndex, item.type(), item.id(), new IllegalArgumentException(message)));, +            } catch (Exception e) {, +                responses.set(i, newItemFailure(item.index(), item.type(), item.id(), e));, +                continue;, +            }, +, +                    .getShards(clusterState, concreteSingleIndex, item.id(), item.routing(), null), +                    .shardId();, +, +                shardRequest = new MultiGetShardRequest(request, shardId.getIndexName(), shardId.getId());, +        if (shardRequests.isEmpty()) {, +                        MultiGetItemResponse itemResponse = new MultiGetItemResponse(response.responses.get(i), response.failures.get(i));, +                        responses.set(response.locations.get(i), itemResponse);, +                        responses.set(shardRequest.locations.get(i), newItemFailure(shardRequest.index(), item.type(), item.id(), e));, +, +    private static MultiGetItemResponse newItemFailure(String index, String type, String id, Exception exception) {, +        return new MultiGetItemResponse(null, new MultiGetResponse.Failure(index, type, id, exception));, +    }, +++ b/rest-api-spec/src/main/resources/rest-api-spec/test/mget/14_alias_to_multiple_indices.yaml, +---, +"Multi Get with alias that resolves to multiple indices":, +, +  - do:, +      bulk:, +        refresh: true, +        body: |, +          {"index": {"_index": "test_1", "_type": "test", "_id": 1}}, +          { "foo": "bar" }, +          {"index": {"_index": "test_2", "_type": "test", "_id": 2}}, +          { "foo": "bar" }, +          {"index": {"_index": "test_3", "_type": "test", "_id": 3}}, +          { "foo": "bar" }, +, +  - do:, +      indices.put_alias:, +        index: test_2, +        name:  test_two_and_three, +, +  - do:, +      indices.put_alias:, +        index: test_3, +        name:  test_two_and_three, +, +  - do:, +      mget:, +        body:, +          docs:, +            - { _index: test_1, _type: test, _id: 1}, +            - { _index: test_two_and_three, _type: test, _id: 2}, +, +  - is_true: docs.0.found, +  - match: { docs.0._index:     test_1      }, +  - match: { docs.0._type:      test        }]