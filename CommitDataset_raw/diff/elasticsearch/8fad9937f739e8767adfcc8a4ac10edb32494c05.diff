[+++ b/src/main/java/org/elasticsearch/watcher/input/search/ExecutableSearchInput.java, +import org.elasticsearch.common.bytes.BytesReference;, +    public ExecutableSearchInput(SearchInput input, ESLogger logger, ClientProxy client) {, +        SearchRequest request = WatcherUtils.createSearchRequestFromPrototype(input.getSearchRequest(), ctx, null);, +            BytesReference source = request.source() != null ? request.source() : request.templateSource();, +            logger.trace("[{}] running query for [{}] [{}]", ctx.id(), ctx.watch().id(), XContentHelper.convertToJson(source, false, true));, +++ b/src/main/java/org/elasticsearch/watcher/input/search/ExecutableSearchInput.java, +import org.elasticsearch.common.bytes.BytesReference;, +    public ExecutableSearchInput(SearchInput input, ESLogger logger, ClientProxy client) {, +        SearchRequest request = WatcherUtils.createSearchRequestFromPrototype(input.getSearchRequest(), ctx, null);, +            BytesReference source = request.source() != null ? request.source() : request.templateSource();, +            logger.trace("[{}] running query for [{}] [{}]", ctx.id(), ctx.watch().id(), XContentHelper.convertToJson(source, false, true));, +++ b/src/main/java/org/elasticsearch/watcher/input/search/SearchInputFactory.java, +    public SearchInputFactory(Settings settings, ClientProxy client) {, +        return new ExecutableSearchInput(input, inputLogger, client);, +++ b/src/main/java/org/elasticsearch/watcher/input/search/ExecutableSearchInput.java, +import org.elasticsearch.common.bytes.BytesReference;, +    public ExecutableSearchInput(SearchInput input, ESLogger logger, ClientProxy client) {, +        SearchRequest request = WatcherUtils.createSearchRequestFromPrototype(input.getSearchRequest(), ctx, null);, +            BytesReference source = request.source() != null ? request.source() : request.templateSource();, +            logger.trace("[{}] running query for [{}] [{}]", ctx.id(), ctx.watch().id(), XContentHelper.convertToJson(source, false, true));, +++ b/src/main/java/org/elasticsearch/watcher/input/search/SearchInputFactory.java, +    public SearchInputFactory(Settings settings, ClientProxy client) {, +        return new ExecutableSearchInput(input, inputLogger, client);, +++ b/src/main/java/org/elasticsearch/watcher/support/WatcherUtils.java, +import org.elasticsearch.common.bytes.BytesArray;, +import org.elasticsearch.common.xcontent.*;, +import org.elasticsearch.watcher.support.template.Template;, +    public static SearchRequest createSearchRequestFromPrototype(SearchRequest requestPrototype, WatchExecutionContext ctx, Payload payload) throws IOException {, +        // TODO: Revise this search template conversion code once search templates in core have been refactored once ES 2.0 is released., +        // Due the inconsistency with templates in ES 1.x, we maintain our own template format., +        // This template format we use now, will become the template structure in ES 2.0, +        Map<String, Object> watcherContextParams = Variables.createCtxModel(ctx, payload);, +            // Here we convert a watch search request body into an inline search template,, +            // this way if any Watcher related context variables are used, they will get resolved,, +            // by ES search template support, +            XContentBuilder builder = jsonBuilder();, +            builder.startObject();, +            XContentHelper.writeRawField("template", requestPrototype.source(), builder, ToXContent.EMPTY_PARAMS);, +            builder.field("params", watcherContextParams);, +            builder.endObject();, +            request.templateSource(builder.bytes(), false);, +            // Here we convert watcher template into a ES core templates. Due to the different format we use, we, +            // convert to the template format used in ES core, +            BytesReference templateSource = requestPrototype.templateSource();, +            try (XContentParser sourceParser = XContentFactory.xContent(templateSource).createParser(templateSource)) {, +                sourceParser.nextToken();, +                Template template = Template.parse(sourceParser);, +, +                // Convert to the ES template format:, +                XContentBuilder builder = jsonBuilder();, +                builder.startObject();, +                switch (template.getType()) {, +                    case INDEXED:, +                        builder.startObject("template");, +                        builder.field("id", template.getTemplate());, +                        builder.endObject();, +                        break;, +                    case FILE:, +                        builder.startObject("template");, +                        builder.field("file", template.getTemplate());, +                        builder.endObject();, +                        break;, +                    case INLINE:, +                        XContentHelper.writeRawField("template", new BytesArray(template.getTemplate()), builder, ToXContent.EMPTY_PARAMS);, +                        break;, +                }, +                Map<String, Object> params = new HashMap<>();, +                params.putAll(watcherContextParams);, +                params.putAll(template.getParams());, +                builder.field("params", params);, +                builder.endObject();, +, +                request.templateSource(builder.bytes(), false);, +            }, +            // In Watcher templates on all places can be defined in one format, +            // Can only be set via the Java api, +            throw new WatcherException("SearchRequest#templateName() isn't supported, templates should be defined in the request body");, +        BytesReference searchBody = null;, +        BytesReference templateBody = null;, +        SearchRequest searchRequest = new SearchRequest();, +, +                    XContentBuilder builder = XContentBuilder.builder(parser.contentType().xContent());, +                    searchBody = builder.bytes();, +                    XContentBuilder builder = XContentBuilder.builder(parser.contentType().xContent());, +                    builder.copyCurrentStructure(parser);, +                    templateBody = builder.bytes();, +        if (searchBody != null) {, +            searchRequest.source(searchBody, false);, +        }, +        if (templateBody != null) {, +            searchRequest.templateSource(templateBody, false);, +        }, +        if (Strings.hasLength(searchRequest.templateSource())) {, +            XContentHelper.writeRawField(TEMPLATE_FIELD.getPreferredName(), searchRequest.templateSource(), builder, params);, +++ b/src/main/java/org/elasticsearch/watcher/input/search/ExecutableSearchInput.java, +import org.elasticsearch.common.bytes.BytesReference;, +    public ExecutableSearchInput(SearchInput input, ESLogger logger, ClientProxy client) {, +        SearchRequest request = WatcherUtils.createSearchRequestFromPrototype(input.getSearchRequest(), ctx, null);, +            BytesReference source = request.source() != null ? request.source() : request.templateSource();]