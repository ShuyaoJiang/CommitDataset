[+++ b/src/test/java/org/elasticsearch/update/UpdateTests.java, +import org.apache.lucene.document.Field;, +import org.apache.lucene.index.MergePolicy;, +import org.apache.lucene.index.NoMergePolicy;, +import org.elasticsearch.ElasticsearchException;, +import org.elasticsearch.common.inject.Inject;, +import org.elasticsearch.common.settings.ImmutableSettings;, +import org.elasticsearch.index.merge.policy.AbstractMergePolicyProvider;, +import org.elasticsearch.index.merge.policy.MergePolicyModule;, +import org.elasticsearch.index.merge.policy.TieredMergePolicyProvider;, +import org.elasticsearch.index.store.CorruptedFileTest;, +import org.elasticsearch.index.store.Store;, +    public static class NoMergePolicyProvider  extends AbstractMergePolicyProvider<MergePolicy> {, +, +        @Inject, +        public NoMergePolicyProvider(Store store) {, +            super(store);, +        }, +, +        @Override, +        public MergePolicy newMergePolicy() {, +            return NoMergePolicy.INSTANCE;, +        }, +, +        @Override, +        public void close() throws ElasticsearchException {, +        }, +    }, +, +        //We create an index with merging disabled so that deletes don't get merged away, +        client().admin().indices().prepareCreate("test"), +                .addMapping("type1", XContentFactory.jsonBuilder(), +                        .startObject(), +                        .startObject("type1"), +                        .startObject("_timestamp").field("enabled", true).field("store", "yes").endObject(), +                        .startObject("_ttl").field("enabled", true).field("store", "yes").endObject(), +                        .endObject(), +                        .endObject()), +                .setSettings(ImmutableSettings.builder().put(MergePolicyModule.MERGE_POLICY_TYPE_KEY, NoMergePolicyProvider.class)), +                .execute().actionGet();, +]