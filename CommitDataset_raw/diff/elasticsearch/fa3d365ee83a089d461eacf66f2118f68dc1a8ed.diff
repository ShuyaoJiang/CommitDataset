[+++ b/server/src/main/java/org/elasticsearch/common/bytes/CompositeBytesReference.java, +import org.apache.lucene.util.FutureObjects;, +        FutureObjects.checkFromIndexSize(from, length, this.length);, +, +        if (length == 0) {, +            return BytesArray.EMPTY;, +        }, +, +        final int limit = getOffsetIndex(to - 1);, +++ b/server/src/main/java/org/elasticsearch/common/bytes/CompositeBytesReference.java, +import org.apache.lucene.util.FutureObjects;, +        FutureObjects.checkFromIndexSize(from, length, this.length);, +, +        if (length == 0) {, +            return BytesArray.EMPTY;, +        }, +, +        final int limit = getOffsetIndex(to - 1);, +++ b/server/src/test/java/org/elasticsearch/common/bytes/CompositeBytesReferenceTests.java, +import org.hamcrest.Matchers;, +, +    public void testSliceIsNotCompositeIfMatchesSingleSubSlice() {, +        CompositeBytesReference bytesRef = new CompositeBytesReference(, +                new BytesArray(new byte[12]),, +                new BytesArray(new byte[15]),, +                new BytesArray(new byte[13]));, +, +        // Slices that cross boundaries are composite too, +        assertThat(bytesRef.slice(5, 8), Matchers.instanceOf(CompositeBytesReference.class));, +, +        // But not slices that cover a single sub reference, +        assertThat(bytesRef.slice(13, 10), Matchers.not(Matchers.instanceOf(CompositeBytesReference.class))); // strictly within sub, +        assertThat(bytesRef.slice(12, 15), Matchers.not(Matchers.instanceOf(CompositeBytesReference.class))); // equal to sub, +    }, +++ b/server/src/main/java/org/elasticsearch/common/bytes/CompositeBytesReference.java, +import org.apache.lucene.util.FutureObjects;, +        FutureObjects.checkFromIndexSize(from, length, this.length);, +, +        if (length == 0) {, +            return BytesArray.EMPTY;, +        }, +, +        final int limit = getOffsetIndex(to - 1);, +++ b/server/src/test/java/org/elasticsearch/common/bytes/CompositeBytesReferenceTests.java, +import org.hamcrest.Matchers;, +, +    public void testSliceIsNotCompositeIfMatchesSingleSubSlice() {, +        CompositeBytesReference bytesRef = new CompositeBytesReference(, +                new BytesArray(new byte[12]),, +                new BytesArray(new byte[15]),, +                new BytesArray(new byte[13]));, +, +        // Slices that cross boundaries are composite too, +        assertThat(bytesRef.slice(5, 8), Matchers.instanceOf(CompositeBytesReference.class));, +, +        // But not slices that cover a single sub reference, +        assertThat(bytesRef.slice(13, 10), Matchers.not(Matchers.instanceOf(CompositeBytesReference.class))); // strictly within sub, +        assertThat(bytesRef.slice(12, 15), Matchers.not(Matchers.instanceOf(CompositeBytesReference.class))); // equal to sub, +    }, +++ b/test/framework/src/main/java/org/elasticsearch/common/bytes/AbstractBytesReferenceTestCase.java, +        for (int length : new int[] {0, 1, randomIntBetween(2, PAGE_SIZE), randomIntBetween(PAGE_SIZE + 1, 3 * PAGE_SIZE)}) {, +    }]