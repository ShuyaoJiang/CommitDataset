[+++ b/pom.xml, +++ b/pom.xml, +++ b/src/main/java/org/elasticsearch/action/bulk/TransportBulkAction.java, +import java.util.List;, +import java.util.Locale;, +import java.util.Map;, +import java.util.Set;, +    /**, +     * This method executes the {@link BulkRequest} and calls the given listener once the request returns., +     * This method will not create any indices even if auto-create indices is enabled., +     *, +     * @see #doExecute(BulkRequest, org.elasticsearch.action.ActionListener), +     */, +    public void executeBulk(final BulkRequest bulkRequest, final ActionListener<BulkResponse> listener) {, +        final long startTime = System.currentTimeMillis();, +        executeBulk(bulkRequest, startTime, listener, new AtomicArray<BulkItemResponse>(bulkRequest.requests.size()));, +    }, +, +++ b/pom.xml, +++ b/src/main/java/org/elasticsearch/action/bulk/TransportBulkAction.java, +import java.util.List;, +import java.util.Locale;, +import java.util.Map;, +import java.util.Set;, +    /**, +     * This method executes the {@link BulkRequest} and calls the given listener once the request returns., +     * This method will not create any indices even if auto-create indices is enabled., +     *, +     * @see #doExecute(BulkRequest, org.elasticsearch.action.ActionListener), +     */, +    public void executeBulk(final BulkRequest bulkRequest, final ActionListener<BulkResponse> listener) {, +        final long startTime = System.currentTimeMillis();, +        executeBulk(bulkRequest, startTime, listener, new AtomicArray<BulkItemResponse>(bulkRequest.requests.size()));, +    }, +, +++ b/src/main/java/org/elasticsearch/indices/ttl/IndicesTTLService.java, +import org.elasticsearch.action.bulk.*;, +import java.util.concurrent.CountDownLatch;, +import java.util.concurrent.TimeUnit;, +import java.util.concurrent.atomic.AtomicBoolean;, +import java.util.concurrent.locks.Condition;, +import java.util.concurrent.locks.ReentrantLock;, +    private final TransportBulkAction bulkAction;, +    public IndicesTTLService(Settings settings, ClusterService clusterService, IndicesService indicesService, NodeSettingsService nodeSettingsService, TransportBulkAction bulkAction) {, +        TimeValue interval = componentSettings.getAsTime("interval", TimeValue.timeValueSeconds(60));, +        this.bulkAction = bulkAction;, +        this.purgerThread = new PurgerThread(EsExecutors.threadName(settings, "[ttl_expire]"), interval);, +        try {, +            this.purgerThread.shutdown();, +        } catch (InterruptedException e) {, +            Thread.interrupted();, +        }, +        private final AtomicBoolean running = new AtomicBoolean(true);, +        private final Notifier notifier;, +        private final CountDownLatch shutdownLatch = new CountDownLatch(1);, +, +        public PurgerThread(String name, TimeValue interval) {, +            this.notifier = new Notifier(interval);, +        public void shutdown() throws InterruptedException {, +            if (running.compareAndSet(true, false)) {, +                notifier.doNotify();, +                shutdownLatch.await();, +            }, +, +        }, +, +        public void resetInterval(TimeValue interval) {, +            notifier.setTimeout(interval);, +            try {, +                while (running.get()) {, +                        if (running.get()) {, +                    if (running.get()) {, +                        notifier.await();, +                }, +            } finally {, +                shutdownLatch.countDown();, +, +        public TimeValue getInterval() {, +            return notifier.getTimeout();, +        }, +                ExpiredDocsCollector expiredDocsCollector = new ExpiredDocsCollector();, +, +                BulkRequest bulkRequest = new BulkRequest();, +, +        public ExpiredDocsCollector() {, +    private BulkRequest processBulkIfNeeded(BulkRequest bulkRequest, boolean force) {, +                bulkAction.executeBulk(bulkRequest, new ActionListener<BulkResponse>() {, +            bulkRequest = new BulkRequest();, +            final TimeValue currentInterval = IndicesTTLService.this.purgerThread.getInterval();, +            final TimeValue interval = settings.getAsTime(INDICES_TTL_INTERVAL, currentInterval);, +            if (!interval.equals(currentInterval)) {, +                logger.info("updating indices.ttl.interval from [{}] to [{}]",currentInterval, interval);, +                IndicesTTLService.this.purgerThread.resetInterval(interval);, +, +            }, +        }, +    }, +, +, +    private static final class Notifier {]