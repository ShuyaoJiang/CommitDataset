[+++ b/core/src/main/java/org/elasticsearch/search/aggregations/bucket/terms/TermsAggregatorFactory.java, +                // Additionally, if using partitioned terms the regular global , +                // ordinals would be sparse so we opt for hash, +                if (Aggregator.descendsFromBucketAggregator(parent) ||, +                        (includeExclude != null && includeExclude.isPartitionBased())) {, +++ b/core/src/main/java/org/elasticsearch/search/aggregations/bucket/terms/TermsAggregatorFactory.java, +                // Additionally, if using partitioned terms the regular global , +                // ordinals would be sparse so we opt for hash, +                if (Aggregator.descendsFromBucketAggregator(parent) ||, +                        (includeExclude != null && includeExclude.isPartitionBased())) {, +++ b/core/src/main/java/org/elasticsearch/search/aggregations/bucket/terms/support/IncludeExclude.java, +import com.carrotsearch.hppc.BitMixer;, +import org.elasticsearch.Version;, +import java.nio.ByteBuffer;, +    private static final ParseField PARTITION_FIELD = new ParseField("partition");, +    private static final ParseField NUM_PARTITIONS_FIELD = new ParseField("num_partitions");, +    public abstract static class LongFilter {, +        public abstract boolean accept(long value);, +   , +    }, +    , +    public class PartitionedLongFilter extends LongFilter {, +        private final ByteBuffer buffer = ByteBuffer.allocate(Long.BYTES);, +, +        @Override, +        public boolean accept(long value) {, +            // hash the value to keep even distributions, +            final long hashCode = BitMixer.mix64(value);, +            return Math.floorMod(hashCode, incNumPartitions) == incZeroBasedPartition;, +        }, +    }, +    , +    , +    public static class SetBackedLongFilter extends LongFilter {, +        private SetBackedLongFilter(int numValids, int numInvalids) {, +    class PartitionedStringFilter extends StringFilter {, +        @Override, +        public boolean accept(BytesRef value) {, +            return Math.floorMod(value.hashCode(), incNumPartitions) == incZeroBasedPartition;, +        }, +    }    , +    , +    class PartitionedOrdinalsFilter extends OrdinalsFilter {, +, +        @Override, +        public LongBitSet acceptedGlobalOrdinals(RandomAccessOrds globalOrdinals) throws IOException {, +            final long numOrds = globalOrdinals.getValueCount();, +            final LongBitSet acceptedGlobalOrdinals = new LongBitSet(numOrds);, +            final TermsEnum termEnum = globalOrdinals.termsEnum();, +, +            BytesRef term = termEnum.next();, +            while (term != null) {, +                if (Math.floorMod(term.hashCode(), incNumPartitions) == incZeroBasedPartition) {, +                    acceptedGlobalOrdinals.set(termEnum.ord());, +                }, +                term = termEnum.next();, +            }, +            return acceptedGlobalOrdinals;, +        }, +    }, +, +    private final int incZeroBasedPartition;, +    private final int incNumPartitions;, +        this.incZeroBasedPartition = 0;, +        this.incNumPartitions = 0;, +        this.incZeroBasedPartition = 0;, +        this.incNumPartitions = 0;        , +    public IncludeExclude(int partition, int numPartitions) {, +        if (partition < 0 || partition >= numPartitions) {, +            throw new IllegalArgumentException("Partition must be >=0 and < numPartition which is "+numPartitions);, +        }, +        this.incZeroBasedPartition = partition;, +        this.incNumPartitions = numPartitions;, +        this.include = null;, +        this.exclude = null;, +        this.includeValues = null;, +        this.excludeValues = null;, +        , +    }, +, +    , +    , +            incZeroBasedPartition = 0;, +            incNumPartitions = 0;, +        if (in.getVersion().onOrAfter(Version.V_5_2_0_UNRELEASED)) {, +            incNumPartitions = in.readVInt();, +            incZeroBasedPartition = in.readVInt();, +        } else {, +            incNumPartitions = 0;, +            incZeroBasedPartition = 0;, +        }, +            if (out.getVersion().onOrAfter(Version.V_5_2_0_UNRELEASED)) {, +                out.writeVInt(incNumPartitions);, +                out.writeVInt(incZeroBasedPartition);, +            }, +                        , +                        // This "include":{"pattern":"foo.*"} syntax is undocumented since 2.0, +                        // Regexes should be "include":"foo.*" , +                            } else {, +                                throw new ElasticsearchParseException(]