[+++ b/modules/elasticsearch/src/main/java/org/elasticsearch/index/store/DirectoryService.java, +    Directory[] build() throws IOException;, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/index/store/DirectoryService.java, +    Directory[] build() throws IOException;, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/index/store/Store.java, +import org.apache.lucene.store.FSDirectory;, +import org.elasticsearch.common.collect.ImmutableList;, +import org.elasticsearch.common.collect.Maps;, +import java.util.ArrayList;, +        for (Directory delegate : directory.delegates()) {, +            directoryService.fullDelete(delegate);, +        }, +            if (fromMetaData == null) {, +                throw new FileNotFoundException(from);, +            }, +            directoryService.renameFile(fromMetaData.directory(), from, to);, +            StoreFileMetaData toMetaData = new StoreFileMetaData(to, fromMetaData.length(), fromMetaData.lastModified(), fromMetaData.checksum(), fromMetaData.directory());, +            metaData = new StoreFileMetaData(metaData.name(), metaData.length(), metaData.lastModified(), checksum, metaData.directory());, +                metaData = new StoreFileMetaData(metaData.name(), metaData.length(), metaData.lastModified(), entry.getValue(), metaData.directory());, +        private final Directory[] delegates;, +        StoreDirectory(Directory[] delegates) throws IOException {, +            this.delegates = delegates;, +                Map<String, String> checksums = readChecksums(delegates[0]);, +                for (Directory delegate : delegates) {, +                        builder.put(file, new StoreFileMetaData(file, delegate.fileLength(file), delegate.fileModified(file), checksum, delegate));, +                    }, +        public Directory[] delegates() {, +            return delegates;, +            return metaData.directory().fileModified(name);, +                    metaData.directory().touchFile(name);, +                    metaData = new StoreFileMetaData(metaData.name(), metaData.length(), metaData.directory().fileModified(name), metaData.checksum(), metaData.directory());, +                delegates[0].deleteFile(name);, +                if (delegates[0].fileExists(name)) {, +            StoreFileMetaData metaData = filesMetadata.get(name);, +            if (metaData != null) {, +                    metaData.directory().deleteFile(name);, +                    if (metaData.directory().fileExists(name)) {, +            }, +            return metaData.directory().fileLength(name);, +            Directory directory = null;, +            if (isChecksum(name)) {, +                directory = delegates[0];, +            } else {, +                if (delegates.length == 1) {, +                    directory = delegates[0];, +                } else {, +                    long size = Long.MAX_VALUE;, +                    for (Directory delegate : delegates) {, +                        if (delegate instanceof FSDirectory) {, +                            long currentSize = ((FSDirectory) delegate).getDirectory().getFreeSpace();, +                            if (currentSize < size) {, +                                size = currentSize;, +                                directory = delegate;, +                            }, +                        } else {, +                            directory = delegate; // really, make sense to have multiple directories for FS, +                        }, +                    }, +                }, +            }, +            IndexOutput out = directory.createOutput(name);, +                StoreFileMetaData metaData = new StoreFileMetaData(name, -1, -1, null, directory);, +                return new StoreIndexOutput(metaData, out, name, computeChecksum);, +            StoreFileMetaData metaData = filesMetadata.get(name);, +            if (metaData == null) {, +                throw new FileNotFoundException(name);, +            }, +            return metaData.directory().openInput(name);, +            for (Directory delegate : delegates) {, +            }, +            return delegates[0].makeLock(name);, +            StoreFileMetaData metaData = filesMetadata.get(name);, +            if (metaData == null) {, +                throw new FileNotFoundException(name);, +            }, +            return metaData.directory().openInput(name, bufferSize);, +            delegates[0].clearLock(name);, +            delegates[0].setLockFactory(lockFactory);, +            return delegates[0].getLockFactory();, +            return delegates[0].getLockID();, +                Map<Directory, Collection<String>> map = Maps.newHashMap();, +                for (String name : names) {, +                    StoreFileMetaData metaData = filesMetadata.get(name);, +                    if (metaData == null) {, +                        throw new FileNotFoundException(name);, +                    }, +                    Collection<String> dirNames = map.get(metaData.directory());, +                    if (dirNames == null) {, +                        dirNames = new ArrayList<String>();, +                        map.put(metaData.directory(), dirNames);, +                    }, +                    dirNames.add(name);, +                }, +                for (Map.Entry<Directory, Collection<String>> entry : map.entrySet()) {, +                    entry.getKey().sync(entry.getValue());, +                }, +                sync(ImmutableList.of(name));, +            sync(ImmutableList.of(name));, +        private final StoreFileMetaData metaData;, +]