[+++ b/docs/reference/docs/delete-by-query.asciidoc, +document that matches a query. Here is the API:, +parameter in the same way as the search API., +If you'd like to count version conflicts rather than cause them to abort, then, +In addition to the standard parameters like `pretty`, the delete by query API, +also supports `refresh`, `wait_for_completion`, `wait_for_active_shards`, `timeout`,, +once the request completes. This is different than the delete API's `refresh`, +to be refreshed. Also unlike the delete API it does not support `wait_for`., +e.g. `?scroll=10m`. By default it's 5 minutes., +`1000`, etc.) and throttles the rate at which delete by query issues batches of, +Since the batch is issued as a single `_bulk` request, large batch sizes will, +so that delete by query, update by query, and reindex APIs return responses, +of bulk actions retried, and `search` is the number of search actions retried., +Delete by query is implemented using batches, and any failure causes the entire, +You can fetch the status of any running delete by query requests with the, +The response looks like:, +<1> This object contains the actual status. It is just like the response JSON, +Any delete by query can be canceled using the <<tasks,task cancel API>>:, +Just like when setting it on the delete by query API, `requests_per_second`, +take effect after completing the current batch. This prevents scroll, +Delete by query supports <<sliced-scroll, sliced scroll>> to parallelize the deleting process., +==== Manual slicing, +Slice a delete by query manually by providing a slice id and total number of, +<<sliced-scroll, sliced scroll>> to slice on `_id`. Use `slices` to specify the number of, +deleted., +* Each sub-request gets a slightly different snapshot of the source index, +number of shards in the index. If that number is large (for example,, +500), choose a lower number as too many `slices` will hurt performance. Setting]