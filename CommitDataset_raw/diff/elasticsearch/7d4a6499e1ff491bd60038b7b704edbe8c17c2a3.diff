[+++ b/test/framework/src/main/java/org/elasticsearch/test/AbstractQueryTestCase.java, +     * parse exception. Some specific objects do not cause any exception as they can hold arbitrary content; they can be, +    /**, +     * Traverses the json tree of the valid query provided as argument and mutates it by adding one object within each object, +     * encountered. Every mutation is a separate iteration, which will be followed by its corresponding assertions to verify that, +     * a parse exception is thrown when parsing the modified query. Some specific objects do not cause any exception as they can, +     * hold arbitrary content; they can be declared by overriding {@link #getObjectsHoldingArbitraryContent()}, and for those we, +     * will verify that no exception gets thrown instead., +     *, +     * For instance given the following valid term query:, +     * {, +     *     "term" : {, +     *         "field" : {, +     *             "value" : "foo", +     *         }, +     *     }, +     * }, +     *, +     * The following two mutations will be generated, and an exception is expected when trying to parse them:, +     * {, +     *     "term" : {, +     *         "newField" : {, +     *             "field" : {, +     *                 "value" : "foo", +     *             }, +     *         }, +     *     }, +     * }, +     *, +     * {, +     *     "term" : {, +     *         "field" : {, +     *             "newField" : {, +     *                 "value" : "foo", +     *             }, +     *         }, +     *     }, +     * }, +     */, +        //track whether we are within quotes as we may have randomly generated strings containing curly brackets, +                //keep track of which level we are within the json so that we can properly close the additional object, +                //if we don't expect an exception, it means that we are within an object that can contain arbitrary content., +                //in that case we ignore the whole object including its children, no need to even check where we are., +                    int startCurrentObjectName = -1;, +                    int endCurrentObjectName = -1;, +                    //look backwards for the current object name, to find out whether we expect an exception following its mutation, +                            if (endCurrentObjectName == -1) {, +                                endCurrentObjectName = i;, +                            } else if (startCurrentObjectName == -1) {, +                                startCurrentObjectName = i + 1;, +                    if (startCurrentObjectName >= 0  && endCurrentObjectName > 0) {, +                        String currentObjectName = validQuery.substring(startCurrentObjectName, endCurrentObjectName);, +                        expectedException = getObjectsHoldingArbitraryContent().contains(currentObjectName) == false;, +                //inject the start of the new object, +                            //close the additional object in the right place]