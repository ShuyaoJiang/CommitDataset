[+++ b/server/src/main/java/org/elasticsearch/cluster/coordination/JoinTaskExecutor.java, +        tmpState = PersistentTasksCustomMetaData.disassociateDeadNodes(tmpState);, +        return ClusterState.builder(allocationService.disassociateDeadNodes(tmpState, false, "removed dead nodes on election"));, +++ b/server/src/main/java/org/elasticsearch/cluster/coordination/JoinTaskExecutor.java, +        tmpState = PersistentTasksCustomMetaData.disassociateDeadNodes(tmpState);, +        return ClusterState.builder(allocationService.disassociateDeadNodes(tmpState, false, "removed dead nodes on election"));, +++ b/server/src/main/java/org/elasticsearch/cluster/coordination/NodeRemovalClusterStateTaskExecutor.java, +        ClusterState ptasksDisassociatedState = PersistentTasksCustomMetaData.disassociateDeadNodes(remainingNodesClusterState);, +        return resultBuilder.build(allocationService.disassociateDeadNodes(ptasksDisassociatedState, true, describeTasks(tasks)));, +++ b/server/src/main/java/org/elasticsearch/cluster/coordination/JoinTaskExecutor.java, +        tmpState = PersistentTasksCustomMetaData.disassociateDeadNodes(tmpState);, +        return ClusterState.builder(allocationService.disassociateDeadNodes(tmpState, false, "removed dead nodes on election"));, +++ b/server/src/main/java/org/elasticsearch/cluster/coordination/NodeRemovalClusterStateTaskExecutor.java, +        ClusterState ptasksDisassociatedState = PersistentTasksCustomMetaData.disassociateDeadNodes(remainingNodesClusterState);, +        return resultBuilder.build(allocationService.disassociateDeadNodes(ptasksDisassociatedState, true, describeTasks(tasks)));, +++ b/server/src/main/java/org/elasticsearch/cluster/routing/DelayedAllocationService.java, + * (see {@link AllocationService#disassociateDeadNodes(RoutingAllocation)}., +++ b/server/src/main/java/org/elasticsearch/cluster/coordination/JoinTaskExecutor.java, +        tmpState = PersistentTasksCustomMetaData.disassociateDeadNodes(tmpState);, +        return ClusterState.builder(allocationService.disassociateDeadNodes(tmpState, false, "removed dead nodes on election"));, +++ b/server/src/main/java/org/elasticsearch/cluster/coordination/NodeRemovalClusterStateTaskExecutor.java, +        ClusterState ptasksDisassociatedState = PersistentTasksCustomMetaData.disassociateDeadNodes(remainingNodesClusterState);, +        return resultBuilder.build(allocationService.disassociateDeadNodes(ptasksDisassociatedState, true, describeTasks(tasks)));, +++ b/server/src/main/java/org/elasticsearch/cluster/routing/DelayedAllocationService.java, + * (see {@link AllocationService#disassociateDeadNodes(RoutingAllocation)}., +++ b/server/src/main/java/org/elasticsearch/cluster/routing/RoutingNodes.java, +        // It's possible for replicaNodeVersion to be null, when disassociating dead nodes, +++ b/server/src/main/java/org/elasticsearch/cluster/coordination/JoinTaskExecutor.java, +        tmpState = PersistentTasksCustomMetaData.disassociateDeadNodes(tmpState);, +        return ClusterState.builder(allocationService.disassociateDeadNodes(tmpState, false, "removed dead nodes on election"));, +++ b/server/src/main/java/org/elasticsearch/cluster/coordination/NodeRemovalClusterStateTaskExecutor.java, +        ClusterState ptasksDisassociatedState = PersistentTasksCustomMetaData.disassociateDeadNodes(remainingNodesClusterState);, +        return resultBuilder.build(allocationService.disassociateDeadNodes(ptasksDisassociatedState, true, describeTasks(tasks)));, +++ b/server/src/main/java/org/elasticsearch/cluster/routing/DelayedAllocationService.java, + * (see {@link AllocationService#disassociateDeadNodes(RoutingAllocation)}., +++ b/server/src/main/java/org/elasticsearch/cluster/routing/RoutingNodes.java, +        // It's possible for replicaNodeVersion to be null, when disassociating dead nodes, +++ b/server/src/main/java/org/elasticsearch/cluster/routing/allocation/AllocationService.java, +    public ClusterState disassociateDeadNodes(ClusterState clusterState, boolean reroute, String reason) {, +        disassociateDeadNodes(allocation);, +        assert hasDeadNodes(allocation) == false : "dead nodes should be explicitly cleaned up. See disassociateDeadNodes";, +    private void disassociateDeadNodes(RoutingAllocation allocation) {, +++ b/server/src/main/java/org/elasticsearch/cluster/coordination/JoinTaskExecutor.java, +        tmpState = PersistentTasksCustomMetaData.disassociateDeadNodes(tmpState);, +        return ClusterState.builder(allocationService.disassociateDeadNodes(tmpState, false, "removed dead nodes on election"));, +++ b/server/src/main/java/org/elasticsearch/cluster/coordination/NodeRemovalClusterStateTaskExecutor.java, +        ClusterState ptasksDisassociatedState = PersistentTasksCustomMetaData.disassociateDeadNodes(remainingNodesClusterState);, +        return resultBuilder.build(allocationService.disassociateDeadNodes(ptasksDisassociatedState, true, describeTasks(tasks)));, +++ b/server/src/main/java/org/elasticsearch/cluster/routing/DelayedAllocationService.java, + * (see {@link AllocationService#disassociateDeadNodes(RoutingAllocation)}., +++ b/server/src/main/java/org/elasticsearch/cluster/routing/RoutingNodes.java, +        // It's possible for replicaNodeVersion to be null, when disassociating dead nodes, +++ b/server/src/main/java/org/elasticsearch/cluster/routing/allocation/AllocationService.java, +    public ClusterState disassociateDeadNodes(ClusterState clusterState, boolean reroute, String reason) {, +        disassociateDeadNodes(allocation);, +        assert hasDeadNodes(allocation) == false : "dead nodes should be explicitly cleaned up. See disassociateDeadNodes";, +    private void disassociateDeadNodes(RoutingAllocation allocation) {, +++ b/server/src/main/java/org/elasticsearch/persistent/PersistentTasksCustomMetaData.java, +    public static ClusterState disassociateDeadNodes(ClusterState clusterState) {, +++ b/server/src/main/java/org/elasticsearch/cluster/coordination/JoinTaskExecutor.java, +        tmpState = PersistentTasksCustomMetaData.disassociateDeadNodes(tmpState);, +        return ClusterState.builder(allocationService.disassociateDeadNodes(tmpState, false, "removed dead nodes on election"));, +++ b/server/src/main/java/org/elasticsearch/cluster/coordination/NodeRemovalClusterStateTaskExecutor.java, +        ClusterState ptasksDisassociatedState = PersistentTasksCustomMetaData.disassociateDeadNodes(remainingNodesClusterState);, +        return resultBuilder.build(allocationService.disassociateDeadNodes(ptasksDisassociatedState, true, describeTasks(tasks)));, +++ b/server/src/main/java/org/elasticsearch/cluster/routing/DelayedAllocationService.java, + * (see {@link AllocationService#disassociateDeadNodes(RoutingAllocation)}., +++ b/server/src/main/java/org/elasticsearch/cluster/routing/RoutingNodes.java, +        // It's possible for replicaNodeVersion to be null, when disassociating dead nodes, +++ b/server/src/main/java/org/elasticsearch/cluster/routing/allocation/AllocationService.java, +    public ClusterState disassociateDeadNodes(ClusterState clusterState, boolean reroute, String reason) {, +        disassociateDeadNodes(allocation);, +        assert hasDeadNodes(allocation) == false : "dead nodes should be explicitly cleaned up. See disassociateDeadNodes";, +    private void disassociateDeadNodes(RoutingAllocation allocation) {, +++ b/server/src/main/java/org/elasticsearch/persistent/PersistentTasksCustomMetaData.java, +    public static ClusterState disassociateDeadNodes(ClusterState clusterState) {, +++ b/server/src/test/java/org/elasticsearch/cluster/coordination/NodeRemovalClusterStateTaskExecutorTests.java, +        when(allocationService.disassociateDeadNodes(any(ClusterState.class), eq(true), any(String.class))), +        verify(allocationService).disassociateDeadNodes(eq(remainingNodesClusterState.get()), eq(true), any(String.class));, +++ b/server/src/main/java/org/elasticsearch/cluster/coordination/JoinTaskExecutor.java, +        tmpState = PersistentTasksCustomMetaData.disassociateDeadNodes(tmpState);, +        return ClusterState.builder(allocationService.disassociateDeadNodes(tmpState, false, "removed dead nodes on election"));, +++ b/server/src/main/java/org/elasticsearch/cluster/coordination/NodeRemovalClusterStateTaskExecutor.java, +        ClusterState ptasksDisassociatedState = PersistentTasksCustomMetaData.disassociateDeadNodes(remainingNodesClusterState);, +        return resultBuilder.build(allocationService.disassociateDeadNodes(ptasksDisassociatedState, true, describeTasks(tasks)));, +++ b/server/src/main/java/org/elasticsearch/cluster/routing/DelayedAllocationService.java, + * (see {@link AllocationService#disassociateDeadNodes(RoutingAllocation)}., +++ b/server/src/main/java/org/elasticsearch/cluster/routing/RoutingNodes.java, +        // It's possible for replicaNodeVersion to be null, when disassociating dead nodes, +++ b/server/src/main/java/org/elasticsearch/cluster/routing/allocation/AllocationService.java, +    public ClusterState disassociateDeadNodes(ClusterState clusterState, boolean reroute, String reason) {, +        disassociateDeadNodes(allocation);, +        assert hasDeadNodes(allocation) == false : "dead nodes should be explicitly cleaned up. See disassociateDeadNodes";, +    private void disassociateDeadNodes(RoutingAllocation allocation) {, +++ b/server/src/main/java/org/elasticsearch/persistent/PersistentTasksCustomMetaData.java, +    public static ClusterState disassociateDeadNodes(ClusterState clusterState) {, +++ b/server/src/test/java/org/elasticsearch/cluster/coordination/NodeRemovalClusterStateTaskExecutorTests.java, +        when(allocationService.disassociateDeadNodes(any(ClusterState.class), eq(true), any(String.class))), +        verify(allocationService).disassociateDeadNodes(eq(remainingNodesClusterState.get()), eq(true), any(String.class));, +++ b/server/src/test/java/org/elasticsearch/cluster/routing/DelayedAllocationServiceTests.java]