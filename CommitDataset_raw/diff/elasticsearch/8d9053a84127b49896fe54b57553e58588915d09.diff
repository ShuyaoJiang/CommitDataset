[+++ b/core/src/main/java/org/elasticsearch/index/mapper/FieldMapper.java, +import com.carrotsearch.hppc.cursors.ObjectCursor;, +import com.carrotsearch.hppc.cursors.ObjectObjectCursor;, +import com.google.common.base.Function;, +import com.google.common.collect.ImmutableList;, +import com.google.common.collect.Iterators;, +import org.apache.lucene.document.Field;, +import org.apache.lucene.document.FieldType;, +import org.apache.lucene.index.IndexOptions;, +import org.elasticsearch.Version;, +import org.elasticsearch.common.Nullable;, +import org.elasticsearch.common.collect.ImmutableOpenMap;, +import org.elasticsearch.common.lucene.Lucene;, +import org.elasticsearch.common.settings.Settings;, +import org.elasticsearch.common.xcontent.XContentBuilder;, +import org.elasticsearch.index.analysis.NamedAnalyzer;, +import org.elasticsearch.index.fielddata.FieldDataType;, +import org.elasticsearch.index.mapper.core.TypeParsers;, +import org.elasticsearch.index.mapper.internal.AllFieldMapper;, +import org.elasticsearch.index.similarity.SimilarityLookupService;, +import org.elasticsearch.index.similarity.SimilarityProvider;, +import java.util.ArrayList;, +import java.util.Arrays;, +import java.util.Collections;, +import java.util.Comparator;, +import java.util.Iterator;, +import java.util.List;, +import java.util.Locale;, +    public abstract static class Builder<T extends Builder, Y extends FieldMapper> extends Mapper.Builder<T, Y> {, +, +        protected final MappedFieldType fieldType;, +        protected final MappedFieldType defaultFieldType;, +        private final IndexOptions defaultOptions;, +        protected boolean omitNormsSet = false;, +        protected String indexName;, +        protected Boolean includeInAll;, +        protected boolean indexOptionsSet = false;, +        protected boolean docValuesSet = false;, +        @Nullable, +        protected Settings fieldDataSettings;, +        protected final MultiFields.Builder multiFieldsBuilder;, +        protected CopyTo copyTo;, +, +        protected Builder(String name, MappedFieldType fieldType) {, +            super(name);, +            this.fieldType = fieldType.clone();, +            this.defaultFieldType = fieldType.clone();, +            this.defaultOptions = fieldType.indexOptions(); // we have to store it the fieldType is mutable, +            multiFieldsBuilder = new MultiFields.Builder();, +        public MappedFieldType fieldType() {, +            return fieldType;, +        }, +, +        public T index(boolean index) {, +            if (index) {, +                if (fieldType.indexOptions() == IndexOptions.NONE) {, +                    /*, +                     * the logic here is to reset to the default options only if we are not indexed ie. options are null, +                     * if the fieldType has a non-null option we are all good it might have been set through a different, +                     * call., +                     */, +                    final IndexOptions options = getDefaultIndexOption();, +                    assert options != IndexOptions.NONE : "default IndexOptions is NONE can't enable indexing";, +                    fieldType.setIndexOptions(options);, +                }, +            } else {, +                fieldType.setIndexOptions(IndexOptions.NONE);, +            }, +            return builder;, +        }, +, +        protected IndexOptions getDefaultIndexOption() {, +            return defaultOptions;, +        }, +, +        public T store(boolean store) {, +            this.fieldType.setStored(store);, +            return builder;, +        }, +, +        public T docValues(boolean docValues) {, +            this.fieldType.setHasDocValues(docValues);, +            this.docValuesSet = true;, +            return builder;, +        }, +, +        public T storeTermVectors(boolean termVectors) {, +            if (termVectors != this.fieldType.storeTermVectors()) {, +                this.fieldType.setStoreTermVectors(termVectors);, +            } // don't set it to false, it is default and might be flipped by a more specific option, +            return builder;, +        }, +, +        public T storeTermVectorOffsets(boolean termVectorOffsets) {, +            if (termVectorOffsets) {, +                this.fieldType.setStoreTermVectors(termVectorOffsets);, +            }, +            this.fieldType.setStoreTermVectorOffsets(termVectorOffsets);, +            return builder;, +        }]