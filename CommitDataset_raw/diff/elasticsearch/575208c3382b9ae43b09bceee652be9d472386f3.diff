[+++ b/src/main/java/org/elasticsearch/watcher/actions/ActionStatus.java, +import static org.elasticsearch.watcher.support.WatcherDateTimeUtils.dateTimeFormatter;, +++ b/src/main/java/org/elasticsearch/watcher/actions/ActionStatus.java, +import static org.elasticsearch.watcher.support.WatcherDateTimeUtils.dateTimeFormatter;, +++ b/src/main/java/org/elasticsearch/watcher/actions/ActionWrapper.java, +import org.elasticsearch.watcher.support.WatcherDateTimeUtils;, +                    try {, +                        throttlePeriod = WatcherDateTimeUtils.parseTimeValue(parser, null);, +                    } catch (WatcherDateTimeUtils.ParseException pe) {, +                        throw new ActionException("could not parse action [{}/{}]. failed to parse field [{}] as time value", pe, watchId, actionId, currentFieldName);, +++ b/src/main/java/org/elasticsearch/watcher/actions/ActionStatus.java, +import static org.elasticsearch.watcher.support.WatcherDateTimeUtils.dateTimeFormatter;, +++ b/src/main/java/org/elasticsearch/watcher/actions/ActionWrapper.java, +import org.elasticsearch.watcher.support.WatcherDateTimeUtils;, +                    try {, +                        throttlePeriod = WatcherDateTimeUtils.parseTimeValue(parser, null);, +                    } catch (WatcherDateTimeUtils.ParseException pe) {, +                        throw new ActionException("could not parse action [{}/{}]. failed to parse field [{}] as time value", pe, watchId, actionId, currentFieldName);, +++ b/src/main/java/org/elasticsearch/watcher/actions/throttler/AckThrottler.java, +import static org.elasticsearch.watcher.support.WatcherDateTimeUtils.formatDate;, +++ b/src/main/java/org/elasticsearch/watcher/actions/ActionStatus.java, +import static org.elasticsearch.watcher.support.WatcherDateTimeUtils.dateTimeFormatter;, +++ b/src/main/java/org/elasticsearch/watcher/actions/ActionWrapper.java, +import org.elasticsearch.watcher.support.WatcherDateTimeUtils;, +                    try {, +                        throttlePeriod = WatcherDateTimeUtils.parseTimeValue(parser, null);, +                    } catch (WatcherDateTimeUtils.ParseException pe) {, +                        throw new ActionException("could not parse action [{}/{}]. failed to parse field [{}] as time value", pe, watchId, actionId, currentFieldName);, +++ b/src/main/java/org/elasticsearch/watcher/actions/throttler/AckThrottler.java, +import static org.elasticsearch.watcher.support.WatcherDateTimeUtils.formatDate;, +++ b/src/main/java/org/elasticsearch/watcher/execution/WatchExecutionResult.java, +import org.elasticsearch.watcher.support.WatcherDateTimeUtils;, +        WatcherDateTimeUtils.writeDate(Field.EXECUTION_TIME.getPreferredName(), builder, executionTime);, +                        executionTime = WatcherDateTimeUtils.parseDate(currentFieldName, parser, UTC);, +                    } catch (WatcherDateTimeUtils.ParseException pe) {, +++ b/src/main/java/org/elasticsearch/watcher/actions/ActionStatus.java, +import static org.elasticsearch.watcher.support.WatcherDateTimeUtils.dateTimeFormatter;, +++ b/src/main/java/org/elasticsearch/watcher/actions/ActionWrapper.java, +import org.elasticsearch.watcher.support.WatcherDateTimeUtils;, +                    try {, +                        throttlePeriod = WatcherDateTimeUtils.parseTimeValue(parser, null);, +                    } catch (WatcherDateTimeUtils.ParseException pe) {, +                        throw new ActionException("could not parse action [{}/{}]. failed to parse field [{}] as time value", pe, watchId, actionId, currentFieldName);, +++ b/src/main/java/org/elasticsearch/watcher/actions/throttler/AckThrottler.java, +import static org.elasticsearch.watcher.support.WatcherDateTimeUtils.formatDate;, +++ b/src/main/java/org/elasticsearch/watcher/execution/WatchExecutionResult.java, +import org.elasticsearch.watcher.support.WatcherDateTimeUtils;, +        WatcherDateTimeUtils.writeDate(Field.EXECUTION_TIME.getPreferredName(), builder, executionTime);, +                        executionTime = WatcherDateTimeUtils.parseDate(currentFieldName, parser, UTC);, +                    } catch (WatcherDateTimeUtils.ParseException pe) {, +++ b/src/main/java/org/elasticsearch/watcher/support/WatcherDateTimeUtils.java, +/*, + * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one, + * or more contributor license agreements. Licensed under the Elastic License;, + * you may not use this file except in compliance with the Elastic License., + */, +package org.elasticsearch.watcher.support;, +, +import org.elasticsearch.ElasticsearchParseException;, +import org.elasticsearch.common.io.stream.StreamInput;, +import org.elasticsearch.common.io.stream.StreamOutput;, +import org.elasticsearch.common.joda.DateMathParser;, +import org.elasticsearch.common.joda.FormatDateTimeFormatter;, +import org.elasticsearch.common.joda.time.DateTime;, +import org.elasticsearch.common.joda.time.DateTimeZone;, +import org.elasticsearch.common.joda.time.PeriodType;, +import org.elasticsearch.common.unit.TimeValue;, +import org.elasticsearch.common.xcontent.XContentBuilder;, +import org.elasticsearch.common.xcontent.XContentParser;, +import org.elasticsearch.index.mapper.core.DateFieldMapper;, +import org.elasticsearch.watcher.WatcherException;, +import org.elasticsearch.watcher.actions.ActionException;, +import org.elasticsearch.watcher.rest.action.RestExecuteWatchAction;, +import org.elasticsearch.watcher.support.clock.Clock;, +, +import java.io.IOException;, +import java.util.concurrent.Callable;, +import java.util.concurrent.TimeUnit;, +/**, + *, + */, +public class WatcherDateTimeUtils {, +, +    public static final FormatDateTimeFormatter dateTimeFormatter = DateFieldMapper.Defaults.DATE_TIME_FORMATTER;, +    public static final DateMathParser dateMathParser = new DateMathParser(dateTimeFormatter, TimeUnit.SECONDS);, +, +    private WatcherDateTimeUtils() {, +    }, +, +    public static DateTime parseDate(String dateAsText) {, +        return parseDate(dateAsText, null);, +    }, +, +    public static DateTime parseDate(String format, DateTimeZone timeZone) {, +        DateTime dateTime = dateTimeFormatter.parser().parseDateTime(format);, +        return timeZone != null ? dateTime.toDateTime(timeZone) : dateTime;, +    }, +, +    public static String formatDate(DateTime date) {, +        return dateTimeFormatter.printer().print(date);]