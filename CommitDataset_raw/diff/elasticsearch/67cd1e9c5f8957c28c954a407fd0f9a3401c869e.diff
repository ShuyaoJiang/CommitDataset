[+++ b/core/src/main/java/org/elasticsearch/index/engine/DeleteVersionValue.java, +    public boolean equals(Object o) {, +        if (this == o) return true;, +        if (o == null || getClass() != o.getClass()) return false;, +        if (!super.equals(o)) return false;, +, +        DeleteVersionValue that = (DeleteVersionValue) o;, +, +        return time == that.time;, +    }, +, +    @Override, +    public int hashCode() {, +        int result = super.hashCode();, +        result = 31 * result + (int) (time ^ (time >>> 32));, +        return result;, +    }, +, +    @Override, +++ b/core/src/main/java/org/elasticsearch/index/engine/DeleteVersionValue.java, +    public boolean equals(Object o) {, +        if (this == o) return true;, +        if (o == null || getClass() != o.getClass()) return false;, +        if (!super.equals(o)) return false;, +, +        DeleteVersionValue that = (DeleteVersionValue) o;, +, +        return time == that.time;, +    }, +, +    @Override, +    public int hashCode() {, +        int result = super.hashCode();, +        result = 31 * result + (int) (time ^ (time >>> 32));, +        return result;, +    }, +, +    @Override, +++ b/core/src/main/java/org/elasticsearch/index/engine/InternalEngine.java, +                VersionValue versionValue = versionMap.getUnderLock(get.uid().bytes());, +        final VersionValue versionValue = versionMap.getUnderLock(op.uid().bytes());, +        VersionValue versionValue = versionMap.getUnderLock(op.uid().bytes());, +        final VersionValue versionValue = versionMap.getUnderLock(index.uid().bytes());, +            // we are guaranteed to have no operations in the version map here!, +            versionMap.adjustMapSizeUnderLock();, +++ b/core/src/main/java/org/elasticsearch/index/engine/DeleteVersionValue.java, +    public boolean equals(Object o) {, +        if (this == o) return true;, +        if (o == null || getClass() != o.getClass()) return false;, +        if (!super.equals(o)) return false;, +, +        DeleteVersionValue that = (DeleteVersionValue) o;, +, +        return time == that.time;, +    }, +, +    @Override, +    public int hashCode() {, +        int result = super.hashCode();, +        result = 31 * result + (int) (time ^ (time >>> 32));, +        return result;, +    }, +, +    @Override, +++ b/core/src/main/java/org/elasticsearch/index/engine/InternalEngine.java, +                VersionValue versionValue = versionMap.getUnderLock(get.uid().bytes());, +        final VersionValue versionValue = versionMap.getUnderLock(op.uid().bytes());, +        VersionValue versionValue = versionMap.getUnderLock(op.uid().bytes());, +        final VersionValue versionValue = versionMap.getUnderLock(index.uid().bytes());, +            // we are guaranteed to have no operations in the version map here!, +            versionMap.adjustMapSizeUnderLock();, +++ b/core/src/main/java/org/elasticsearch/index/engine/LiveVersionMap.java, +    /**, +     * Resets the internal map and adjusts it's capacity as if there were no indexing operations., +     * This must be called under write lock in the engine, +     */, +    void adjustMapSizeUnderLock() {, +        if (maps.current.isEmpty() == false || maps.old.isEmpty() == false) {, +            assert false : "map must be empty"; // fail hard if not empty and fail with assertion in tests to ensure we never swallow it, +            throw new IllegalStateException("map must be empty");, +        }, +        maps = new Maps();, +    }, +, +                 Collections.emptyMap());, +    VersionValue getUnderLock(final BytesRef uid) {, +        VersionValue value = currentMaps.current.get(uid);, +        value = currentMaps.old.get(uid);, +        return tombstones.get(uid);, +, +    /** Returns the current internal versions as a point in time snapshot*/, +    Map<BytesRef, VersionValue> getAllCurrent() {, +        return maps.current;, +    }}, +++ b/core/src/main/java/org/elasticsearch/index/engine/DeleteVersionValue.java, +    public boolean equals(Object o) {, +        if (this == o) return true;, +        if (o == null || getClass() != o.getClass()) return false;, +        if (!super.equals(o)) return false;, +]