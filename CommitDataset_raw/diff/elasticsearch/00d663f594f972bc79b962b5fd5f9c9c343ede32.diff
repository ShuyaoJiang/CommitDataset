[+++ b/src/main/java/org/elasticsearch/cluster/ClusterChangedEvent.java, +, +        // if the new cluster state has a new master then we cannot know if an index which is not in the cluster state, +        // is actually supposed to be deleted or imported as dangling instead. for example a new master might not have, +        // the index in its cluster state because it was started with an empty data folder and in this case we want to, +        // import as dangling. we check here for new master too to be on the safe side in this case., +        // norelease because we are not sure this is actually a good solution, +        // See discussion on https://github.com/elastic/elasticsearch/pull/9952, +        if (hasNewMaster() || previousState == null) {, +, +    /**, +     * Checks if this cluster state comes from a different master than the previous one., +     * This is a workaround for the scenario where a node misses a cluster state  that has either, +     * no master block or state not recovered flag set. In this case we must make sure that, +     * if an index is missing from the cluster state is not deleted immediately but instead imported, +     * as dangling. See discussion on https://github.com/elastic/elasticsearch/pull/9952, +     */, +    private boolean hasNewMaster() {, +        String oldMaster = previousState().getNodes().masterNodeId();, +        String newMaster = state().getNodes().masterNodeId();, +        if (oldMaster == null && newMaster == null) {, +            return false;, +        }, +        if (oldMaster == null && newMaster != null) {, +            return true;, +        }, +        return oldMaster.equals(newMaster) == false;, +    }, +++ b/src/main/java/org/elasticsearch/cluster/ClusterChangedEvent.java, +, +        // if the new cluster state has a new master then we cannot know if an index which is not in the cluster state, +        // is actually supposed to be deleted or imported as dangling instead. for example a new master might not have, +        // the index in its cluster state because it was started with an empty data folder and in this case we want to, +        // import as dangling. we check here for new master too to be on the safe side in this case., +        // norelease because we are not sure this is actually a good solution, +        // See discussion on https://github.com/elastic/elasticsearch/pull/9952, +        if (hasNewMaster() || previousState == null) {, +, +    /**, +     * Checks if this cluster state comes from a different master than the previous one., +     * This is a workaround for the scenario where a node misses a cluster state  that has either, +     * no master block or state not recovered flag set. In this case we must make sure that, +     * if an index is missing from the cluster state is not deleted immediately but instead imported, +     * as dangling. See discussion on https://github.com/elastic/elasticsearch/pull/9952, +     */, +    private boolean hasNewMaster() {, +        String oldMaster = previousState().getNodes().masterNodeId();, +        String newMaster = state().getNodes().masterNodeId();, +        if (oldMaster == null && newMaster == null) {, +            return false;, +        }, +        if (oldMaster == null && newMaster != null) {, +            return true;, +        }, +        return oldMaster.equals(newMaster) == false;, +    }, +++ b/src/main/java/org/elasticsearch/gateway/GatewayMetaState.java, +import com.google.common.collect.ImmutableSet;, +import org.elasticsearch.cluster.routing.*;, +import java.util.*;, +    private volatile MetaData previousMetaData;, +, +    private volatile ImmutableSet<String> previouslyWrittenIndices = ImmutableSet.of();, +        if (DiscoveryNode.masterNode(settings) || DiscoveryNode.dataNode(settings)) {, +        Set<String> relevantIndices = new HashSet<>();, +            this.previousMetaData = null;, +            previouslyWrittenIndices = ImmutableSet.of();, +        // write the state if this node is a master eligible node or if it is a data node and has shards allocated on it, +        if (state.nodes().localNode().masterNode() || state.nodes().localNode().dataNode()) {, +            if (previousMetaData == null) {, +                try {, +                    // we determine if or if not we write meta data on data only nodes by looking at the shard routing, +                    // and only write if a shard of this index is allocated on this node, +                    // however, closed indices do not appear in the shard routing. if the meta data for a closed index is, +                    // updated it will therefore not be written in case the list of previouslyWrittenIndices is empty (because state, +                    // persistence was disabled or the node was restarted), see getRelevantIndicesOnDataOnlyNode()., +                    // we therefore have to check here if we have shards on disk and add their indices to the previouslyWrittenIndices list, +                    if (isDataOnlyNode(state)) {, +                        ImmutableSet.Builder<String> previouslyWrittenIndicesBuilder = ImmutableSet.builder();, +                        for (IndexMetaData indexMetaData : newMetaData) {, +                            IndexMetaData indexMetaDataOnDisk = null;, +                            if (indexMetaData.state().equals(IndexMetaData.State.CLOSE)) {, +                                indexMetaDataOnDisk = metaStateService.loadIndexState(indexMetaData.index());, +                            }, +                            if (indexMetaDataOnDisk != null) {, +                                previouslyWrittenIndicesBuilder.add(indexMetaDataOnDisk.index());, +                            }, +                        }, +                        previouslyWrittenIndices = previouslyWrittenIndicesBuilder.addAll(previouslyWrittenIndices).build();, +                    }, +                } catch (Throwable e) {, +                    success = false;, +                }, +            }, +            if (previousMetaData == null || !MetaData.isGlobalStateEquals(previousMetaData, newMetaData)) {, +            Iterable<IndexMetaWriteInfo> writeInfo;, +            relevantIndices = getRelevantIndices(event.state(), previouslyWrittenIndices);, +            writeInfo = resolveStatesToBeWritten(previouslyWrittenIndices, relevantIndices, previousMetaData, event.state().metaData());, +            for (IndexMetaWriteInfo indexMetaWrite : writeInfo) {, +                    metaStateService.writeIndex(indexMetaWrite.reason, indexMetaWrite.newMetaData, indexMetaWrite.previousMetaData);]