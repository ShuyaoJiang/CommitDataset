[+++ b/core/src/main/java/org/apache/lucene/queryparser/classic/ExistsFieldQueryExtension.java, +import org.elasticsearch.index.query.ExistsQueryParser;, +        return new ConstantScoreQuery(ExistsQueryParser.newFilter(parseContext, queryText, null));, +++ b/core/src/main/java/org/apache/lucene/queryparser/classic/ExistsFieldQueryExtension.java, +import org.elasticsearch.index.query.ExistsQueryParser;, +        return new ConstantScoreQuery(ExistsQueryParser.newFilter(parseContext, queryText, null));, +++ b/core/src/main/java/org/elasticsearch/action/admin/indices/validate/query/ValidateQueryRequestBuilder.java, +import org.elasticsearch.action.ActionListener;, +++ b/core/src/main/java/org/apache/lucene/queryparser/classic/ExistsFieldQueryExtension.java, +import org.elasticsearch.index.query.ExistsQueryParser;, +        return new ConstantScoreQuery(ExistsQueryParser.newFilter(parseContext, queryText, null));, +++ b/core/src/main/java/org/elasticsearch/action/admin/indices/validate/query/ValidateQueryRequestBuilder.java, +import org.elasticsearch.action.ActionListener;, +++ b/core/src/main/java/org/elasticsearch/action/index/IndexRequest.java, +import org.elasticsearch.Version;, +            Version version = Version.indexCreated(metaData.getIndices().get(concreteIndex).settings());, +                    mappingMd != null ? mappingMd.timestamp().dateTimeFormatter() : TimestampFieldMapper.Defaults.DATE_TIME_FORMATTER,, +                    version);, +                            Version version = Version.indexCreated(metaData.getIndices().get(concreteIndex).settings());, +                            timestamp = MappingMetaData.Timestamp.parseStringTimestamp(timestamp, mappingMd.timestamp().dateTimeFormatter(), version);, +                Version version = Version.indexCreated(metaData.getIndices().get(concreteIndex).settings());, +                timestamp = MappingMetaData.Timestamp.parseStringTimestamp(defaultTimestamp, mappingMd.timestamp().dateTimeFormatter(), version);, +++ b/core/src/main/java/org/apache/lucene/queryparser/classic/ExistsFieldQueryExtension.java, +import org.elasticsearch.index.query.ExistsQueryParser;, +        return new ConstantScoreQuery(ExistsQueryParser.newFilter(parseContext, queryText, null));, +++ b/core/src/main/java/org/elasticsearch/action/admin/indices/validate/query/ValidateQueryRequestBuilder.java, +import org.elasticsearch.action.ActionListener;, +++ b/core/src/main/java/org/elasticsearch/action/index/IndexRequest.java, +import org.elasticsearch.Version;, +            Version version = Version.indexCreated(metaData.getIndices().get(concreteIndex).settings());, +                    mappingMd != null ? mappingMd.timestamp().dateTimeFormatter() : TimestampFieldMapper.Defaults.DATE_TIME_FORMATTER,, +                    version);, +                            Version version = Version.indexCreated(metaData.getIndices().get(concreteIndex).settings());, +                            timestamp = MappingMetaData.Timestamp.parseStringTimestamp(timestamp, mappingMd.timestamp().dateTimeFormatter(), version);, +                Version version = Version.indexCreated(metaData.getIndices().get(concreteIndex).settings());, +                timestamp = MappingMetaData.Timestamp.parseStringTimestamp(defaultTimestamp, mappingMd.timestamp().dateTimeFormatter(), version);, +++ b/core/src/main/java/org/elasticsearch/cluster/metadata/MappingMetaData.java, +import org.elasticsearch.Version;, +        private static final FormatDateTimeFormatter EPOCH_MILLIS_PARSER = Joda.forPattern("epoch_millis");, +, +        public static String parseStringTimestamp(String timestampAsString, FormatDateTimeFormatter dateTimeFormatter,, +                                                  Version version) throws TimestampParsingException {, +            try {, +                // no need for unix timestamp parsing in 2.x, +                FormatDateTimeFormatter formatter = version.onOrAfter(Version.V_2_0_0) ? dateTimeFormatter : EPOCH_MILLIS_PARSER;, +                return Long.toString(formatter.parser().parseMillis(timestampAsString));, +            } catch (RuntimeException e) {, +                if (version.before(Version.V_2_0_0)) {, +                    } catch (RuntimeException e1) {, +                        throw new TimestampParsingException(timestampAsString, e1);, +                    }, +                }, +++ b/core/src/main/java/org/apache/lucene/queryparser/classic/ExistsFieldQueryExtension.java, +import org.elasticsearch.index.query.ExistsQueryParser;, +        return new ConstantScoreQuery(ExistsQueryParser.newFilter(parseContext, queryText, null));, +++ b/core/src/main/java/org/elasticsearch/action/admin/indices/validate/query/ValidateQueryRequestBuilder.java, +import org.elasticsearch.action.ActionListener;, +++ b/core/src/main/java/org/elasticsearch/action/index/IndexRequest.java, +import org.elasticsearch.Version;, +            Version version = Version.indexCreated(metaData.getIndices().get(concreteIndex).settings());, +                    mappingMd != null ? mappingMd.timestamp().dateTimeFormatter() : TimestampFieldMapper.Defaults.DATE_TIME_FORMATTER,, +                    version);, +                            Version version = Version.indexCreated(metaData.getIndices().get(concreteIndex).settings());, +                            timestamp = MappingMetaData.Timestamp.parseStringTimestamp(timestamp, mappingMd.timestamp().dateTimeFormatter(), version);, +                Version version = Version.indexCreated(metaData.getIndices().get(concreteIndex).settings());, +                timestamp = MappingMetaData.Timestamp.parseStringTimestamp(defaultTimestamp, mappingMd.timestamp().dateTimeFormatter(), version);, +++ b/core/src/main/java/org/elasticsearch/cluster/metadata/MappingMetaData.java, +import org.elasticsearch.Version;, +        private static final FormatDateTimeFormatter EPOCH_MILLIS_PARSER = Joda.forPattern("epoch_millis");, +, +        public static String parseStringTimestamp(String timestampAsString, FormatDateTimeFormatter dateTimeFormatter,, +                                                  Version version) throws TimestampParsingException {, +            try {, +                // no need for unix timestamp parsing in 2.x, +                FormatDateTimeFormatter formatter = version.onOrAfter(Version.V_2_0_0) ? dateTimeFormatter : EPOCH_MILLIS_PARSER;, +                return Long.toString(formatter.parser().parseMillis(timestampAsString));, +            } catch (RuntimeException e) {, +                if (version.before(Version.V_2_0_0)) {, +                    } catch (RuntimeException e1) {, +                        throw new TimestampParsingException(timestampAsString, e1);, +                    }, +                }, +++ /dev/null, +++ b/core/src/main/java/org/apache/lucene/queryparser/classic/ExistsFieldQueryExtension.java, +import org.elasticsearch.index.query.ExistsQueryParser;, +        return new ConstantScoreQuery(ExistsQueryParser.newFilter(parseContext, queryText, null));, +++ b/core/src/main/java/org/elasticsearch/action/admin/indices/validate/query/ValidateQueryRequestBuilder.java, +import org.elasticsearch.action.ActionListener;, +++ b/core/src/main/java/org/elasticsearch/action/index/IndexRequest.java, +import org.elasticsearch.Version;, +            Version version = Version.indexCreated(metaData.getIndices().get(concreteIndex).settings());, +                    mappingMd != null ? mappingMd.timestamp().dateTimeFormatter() : TimestampFieldMapper.Defaults.DATE_TIME_FORMATTER,, +                    version);, +                            Version version = Version.indexCreated(metaData.getIndices().get(concreteIndex).settings());, +                            timestamp = MappingMetaData.Timestamp.parseStringTimestamp(timestamp, mappingMd.timestamp().dateTimeFormatter(), version);, +                Version version = Version.indexCreated(metaData.getIndices().get(concreteIndex).settings());, +                timestamp = MappingMetaData.Timestamp.parseStringTimestamp(defaultTimestamp, mappingMd.timestamp().dateTimeFormatter(), version);, +++ b/core/src/main/java/org/elasticsearch/cluster/metadata/MappingMetaData.java, +import org.elasticsearch.Version;, +        private static final FormatDateTimeFormatter EPOCH_MILLIS_PARSER = Joda.forPattern("epoch_millis");]