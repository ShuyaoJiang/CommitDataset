[+++ b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/analysis/analyzer/Verifier.java, +import org.elasticsearch.xpack.sql.expression.predicate.conditional.ConditionalFunction;, +                                        if ((a.dataType() != DataType.UNSUPPORTED) && a.dataType().isPrimitive()) {, +                validateConditional(p, localFailures);, +        return checkGroupByAgg(p, localFailures, resolvedFunctions), +                && checkGroupByOrder(p, localFailures, groupingFailures), +    private static boolean checkGroupByOrder(LogicalPlan p, Set<Failure> localFailures, Set<LogicalPlan> groupingFailures) {, +    private static boolean checkGroupByAgg(LogicalPlan p, Set<Failure> localFailures, Map<String, Function> functions) {, +                        if (areTypesCompatible(dt, value.dataType()) == false) {, +    private static void validateConditional(LogicalPlan p, Set<Failure> localFailures) {, +        p.forEachExpressions(e ->, +            e.forEachUp((ConditionalFunction cf) -> {, +                    DataType dt = DataType.NULL;, +, +                    for (Expression child : cf.children()) {, +                        if (dt == DataType.NULL) {, +                            if (Expressions.isNull(child) == false) {, +                                dt = child.dataType();, +                            }, +                        } else {, +                            if (areTypesCompatible(dt, child.dataType()) == false) {, +                                localFailures.add(fail(child, "expected data type [%s], value provided is of type [%s]",, +                                    dt, child.dataType()));, +                                return;, +                            }, +                        }, +                    }, +                },, +                ConditionalFunction.class));, +    }, +, +++ b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/analysis/analyzer/Verifier.java, +import org.elasticsearch.xpack.sql.expression.predicate.conditional.ConditionalFunction;, +                                        if ((a.dataType() != DataType.UNSUPPORTED) && a.dataType().isPrimitive()) {, +                validateConditional(p, localFailures);, +        return checkGroupByAgg(p, localFailures, resolvedFunctions), +                && checkGroupByOrder(p, localFailures, groupingFailures), +    private static boolean checkGroupByOrder(LogicalPlan p, Set<Failure> localFailures, Set<LogicalPlan> groupingFailures) {, +    private static boolean checkGroupByAgg(LogicalPlan p, Set<Failure> localFailures, Map<String, Function> functions) {, +                        if (areTypesCompatible(dt, value.dataType()) == false) {, +    private static void validateConditional(LogicalPlan p, Set<Failure> localFailures) {, +        p.forEachExpressions(e ->, +            e.forEachUp((ConditionalFunction cf) -> {, +                    DataType dt = DataType.NULL;, +, +                    for (Expression child : cf.children()) {, +                        if (dt == DataType.NULL) {, +                            if (Expressions.isNull(child) == false) {, +                                dt = child.dataType();, +                            }, +                        } else {, +                            if (areTypesCompatible(dt, child.dataType()) == false) {, +                                localFailures.add(fail(child, "expected data type [%s], value provided is of type [%s]",, +                                    dt, child.dataType()));, +                                return;, +                            }, +                        }, +                    }, +                },, +                ConditionalFunction.class));, +    }, +, +++ b/x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/analysis/analyzer/VerifierErrorMessagesTests.java, +import org.elasticsearch.xpack.sql.expression.predicate.conditional.Coalesce;, +import org.elasticsearch.xpack.sql.expression.predicate.conditional.Greatest;, +import org.elasticsearch.xpack.sql.expression.predicate.conditional.IfNull;, +import org.elasticsearch.xpack.sql.expression.predicate.conditional.Least;, +import org.elasticsearch.xpack.sql.expression.predicate.conditional.NullIf;, +, +    public void testConditionalWithDifferentDataTypes_SelectClause() {, +        @SuppressWarnings("unchecked"), +        String function = randomFrom(IfNull.class, NullIf.class).getSimpleName();, +        assertEquals("1:" + (22 + function.length()) +, +                ": expected data type [INTEGER], value provided is of type [KEYWORD]",, +            error("SELECT 1 = 1  OR " + function + "(3, '4') > 1"));, +, +        @SuppressWarnings("unchecked"), +        String arbirtraryArgsfunction = randomFrom(Coalesce.class, Greatest.class, Least.class).getSimpleName();, +        assertEquals("1:" + (34 + arbirtraryArgsfunction.length()) +, +                ": expected data type [INTEGER], value provided is of type [KEYWORD]",, +            error("SELECT 1 = 1  OR " + arbirtraryArgsfunction + "(null, null, 3, '4') > 1"));, +    }, +, +    public void testConditionalWithDifferentDataTypes_WhereClause() {, +        @SuppressWarnings("unchecked"), +        String function = randomFrom(IfNull.class, NullIf.class).getSimpleName();, +        assertEquals("1:" + (34 + function.length()) +, +                ": expected data type [KEYWORD], value provided is of type [INTEGER]",, +            error("SELECT * FROM test WHERE " + function + "('foo', 4) > 1"));, +, +        @SuppressWarnings("unchecked"), +        String arbirtraryArgsfunction = randomFrom(Coalesce.class, Greatest.class, Least.class).getSimpleName();, +        assertEquals("1:" + (46 + arbirtraryArgsfunction.length()) +, +                ": expected data type [KEYWORD], value provided is of type [INTEGER]",, +            error("SELECT * FROM test WHERE " + arbirtraryArgsfunction + "(null, null, 'foo', 4) > 1"));, +    }]