[+++ b/buildSrc/src/main/resources/forbidden/es-core-signatures.txt, +++ b/buildSrc/src/main/resources/forbidden/es-core-signatures.txt, +++ b/modules/lang-painless/src/main/antlr/PainlessParser.g4, +    : TYPE REF ID, +++ b/buildSrc/src/main/resources/forbidden/es-core-signatures.txt, +++ b/modules/lang-painless/src/main/antlr/PainlessParser.g4, +    : TYPE REF ID, +++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/AnalyzerCaster.java, +import org.elasticsearch.painless.node.ANode;, +++ b/buildSrc/src/main/resources/forbidden/es-core-signatures.txt, +++ b/modules/lang-painless/src/main/antlr/PainlessParser.g4, +    : TYPE REF ID, +++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/AnalyzerCaster.java, +import org.elasticsearch.painless.node.ANode;, +++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/Def.java, +     * Looks up handle for a dynamic method call., +     * @param type Callsite signature. Need not match exactly, except the number of parameters., +     static MethodHandle lookupMethod(Class<?> receiverClass, String name, MethodType type) {, +         // we don't consider receiver an argument/counting towards arity, +         type = type.dropParameterTypes(0, 1);, +         Definition.MethodKey key = new Definition.MethodKey(name, type.parameterCount());, +         // check whitelist for matching method, +         for (Class<?> clazz = receiverClass; clazz != null; clazz = clazz.getSuperclass()) {, +             RuntimeClass struct = Definition.getRuntimeClass(clazz);, +             if (struct != null) {, +                 Method method = struct.methods.get(key);, +                 if (method != null) {, +                     return method.handle;, +             for (final Class<?> iface : clazz.getInterfaces()) {, +                 struct = Definition.getRuntimeClass(iface);, +, +                 if (struct != null) {, +                     Method method = struct.methods.get(key);, +                     if (method != null) {, +                         return method.handle;, +                     }, +                 }, +             }, +         // no matching methods in whitelist found, +         throw new IllegalArgumentException("Unable to find dynamic method [" + name + "] with signature [" + type + "] " +, +                 "for class [" + receiverClass.getCanonicalName() + "].");, +++ b/buildSrc/src/main/resources/forbidden/es-core-signatures.txt, +++ b/modules/lang-painless/src/main/antlr/PainlessParser.g4, +    : TYPE REF ID, +++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/AnalyzerCaster.java, +import org.elasticsearch.painless.node.ANode;, +++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/Def.java, +     * Looks up handle for a dynamic method call., +     * @param type Callsite signature. Need not match exactly, except the number of parameters., +     static MethodHandle lookupMethod(Class<?> receiverClass, String name, MethodType type) {, +         // we don't consider receiver an argument/counting towards arity, +         type = type.dropParameterTypes(0, 1);, +         Definition.MethodKey key = new Definition.MethodKey(name, type.parameterCount());, +         // check whitelist for matching method, +         for (Class<?> clazz = receiverClass; clazz != null; clazz = clazz.getSuperclass()) {, +             RuntimeClass struct = Definition.getRuntimeClass(clazz);, +             if (struct != null) {, +                 Method method = struct.methods.get(key);, +                 if (method != null) {, +                     return method.handle;, +             for (final Class<?> iface : clazz.getInterfaces()) {, +                 struct = Definition.getRuntimeClass(iface);, +, +                 if (struct != null) {, +                     Method method = struct.methods.get(key);, +                     if (method != null) {, +                         return method.handle;, +                     }, +                 }, +             }, +         // no matching methods in whitelist found, +         throw new IllegalArgumentException("Unable to find dynamic method [" + name + "] with signature [" + type + "] " +, +                 "for class [" + receiverClass.getCanonicalName() + "].");, +++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/DefBootstrap.java, +        PIC(String name, MethodType type, int flavor) {, +        private static MethodHandle lookup(int flavor, Class<?> clazz, String name, MethodType type) {, +                    return Def.lookupMethod(clazz, name, type);, +            final MethodHandle target = lookup(flavor, receiverClass, name, type).asType(type);, +    public static CallSite bootstrap(Lookup lookup, String name, MethodType type, int flavor) {, +        return new PIC(name, type, flavor);, +++ b/buildSrc/src/main/resources/forbidden/es-core-signatures.txt, +++ b/modules/lang-painless/src/main/antlr/PainlessParser.g4, +    : TYPE REF ID, +++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/AnalyzerCaster.java, +import org.elasticsearch.painless.node.ANode;, +++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/Def.java, +     * Looks up handle for a dynamic method call., +     * @param type Callsite signature. Need not match exactly, except the number of parameters., +     static MethodHandle lookupMethod(Class<?> receiverClass, String name, MethodType type) {, +         // we don't consider receiver an argument/counting towards arity, +         type = type.dropParameterTypes(0, 1);, +         Definition.MethodKey key = new Definition.MethodKey(name, type.parameterCount());, +         // check whitelist for matching method, +         for (Class<?> clazz = receiverClass; clazz != null; clazz = clazz.getSuperclass()) {, +             RuntimeClass struct = Definition.getRuntimeClass(clazz);, +             if (struct != null) {, +                 Method method = struct.methods.get(key);, +                 if (method != null) {, +                     return method.handle;, +             for (final Class<?> iface : clazz.getInterfaces()) {]