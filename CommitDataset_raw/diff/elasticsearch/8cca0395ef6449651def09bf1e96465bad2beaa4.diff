[+++ b/core/src/main/java/org/elasticsearch/search/sort/GeoDistanceSortBuilder.java, +public class GeoDistanceSortBuilder extends SortBuilder {, +    final String fieldName;, +    private final List<String> geohashes = new ArrayList<>();, +    private GeoDistance geoDistance;, +    private DistanceUnit unit;, +    private SortOrder order;, +    private String sortMode;, +    private Boolean coerce;, +    private Boolean ignoreMalformed;, +    public GeoDistanceSortBuilder(String fieldName) {, +        this.geohashes.addAll(Arrays.asList(geohashes));, +    public SortBuilder missing(Object missing) {, +        builder.startObject("_geo_distance");, +        if (geohashes.size() == 0 && points.size() == 0) {, +            throw new ElasticsearchParseException("No points provided for _geo_distance sort.");, +        }, +        for (String geohash : geohashes) {, +            builder.value(geohash);, +        }, +        if (unit != null) {, +        }, +        if (geoDistance != null) {, +        }, +        if (coerce != null) {, +        }, +        if (ignoreMalformed != null) {, +        }, +++ b/core/src/main/java/org/elasticsearch/search/sort/GeoDistanceSortBuilder.java, +public class GeoDistanceSortBuilder extends SortBuilder {, +    final String fieldName;, +    private final List<String> geohashes = new ArrayList<>();, +    private GeoDistance geoDistance;, +    private DistanceUnit unit;, +    private SortOrder order;, +    private String sortMode;, +    private Boolean coerce;, +    private Boolean ignoreMalformed;, +    public GeoDistanceSortBuilder(String fieldName) {, +        this.geohashes.addAll(Arrays.asList(geohashes));, +    public SortBuilder missing(Object missing) {, +        builder.startObject("_geo_distance");, +        if (geohashes.size() == 0 && points.size() == 0) {, +            throw new ElasticsearchParseException("No points provided for _geo_distance sort.");, +        }, +        for (String geohash : geohashes) {, +            builder.value(geohash);, +        }, +        if (unit != null) {, +        }, +        if (geoDistance != null) {, +        }, +        if (coerce != null) {, +        }, +        if (ignoreMalformed != null) {, +        }, +++ b/core/src/main/java/org/elasticsearch/search/sort/GeoDistanceSortParser.java, +        boolean coerce = false;, +        boolean ignoreMalformed = false;, +                parseGeoPoints(parser, geoPoints);, +    private void parseGeoPoints(XContentParser parser, List<GeoPoint> geoPoints) throws IOException {, +        while (!parser.nextToken().equals(XContentParser.Token.END_ARRAY)) {, +            if (parser.currentToken() == XContentParser.Token.VALUE_NUMBER) {, +                // we might get here if the geo point is " number, number] " and the parser already moved over the opening bracket, +                // in this case we cannot use GeoUtils.parseGeoPoint(..) because this expects an opening bracket, +                double lon = parser.doubleValue();, +                parser.nextToken();, +                if (!parser.currentToken().equals(XContentParser.Token.VALUE_NUMBER)) {, +                    throw new ElasticsearchParseException("geo point parsing: expected second number but got [{}] instead", parser.currentToken());, +                }, +                double lat = parser.doubleValue();, +                GeoPoint point = new GeoPoint();, +                point.reset(lat, lon);, +                geoPoints.add(point);, +            } else {, +                GeoPoint point = new GeoPoint();, +                GeoUtils.parseGeoPoint(parser, point);, +                geoPoints.add(point);, +            }, +, +        }, +    }, +++ b/core/src/main/java/org/elasticsearch/search/sort/GeoDistanceSortBuilder.java, +public class GeoDistanceSortBuilder extends SortBuilder {, +    final String fieldName;, +    private final List<String> geohashes = new ArrayList<>();, +    private GeoDistance geoDistance;, +    private DistanceUnit unit;, +    private SortOrder order;, +    private String sortMode;, +    private Boolean coerce;, +    private Boolean ignoreMalformed;, +    public GeoDistanceSortBuilder(String fieldName) {, +        this.geohashes.addAll(Arrays.asList(geohashes));, +    public SortBuilder missing(Object missing) {, +        builder.startObject("_geo_distance");, +        if (geohashes.size() == 0 && points.size() == 0) {, +            throw new ElasticsearchParseException("No points provided for _geo_distance sort.");, +        }, +        for (String geohash : geohashes) {]