[+++ b/src/main/java/org/elasticsearch/bootstrap/Bootstrap.java, +    private static volatile Bootstrap INSTANCE;, +    private Node node;, +    private final CountDownLatch keepAliveLatch = new CountDownLatch(1);, +    private final Thread keepAliveThread;, +, +    /** creates a new instance */, +    Bootstrap() {, +        keepAliveThread = new Thread(new Runnable() {, +            @Override, +            public void run() {, +                try {, +                    keepAliveLatch.await();, +                } catch (InterruptedException e) {, +                    // bail out, +                }, +            }, +        }, "elasticsearch[keepAlive/" + Version.CURRENT + "]");, +        keepAliveThread.setDaemon(false);, +        // keep this thread alive (non daemon thread) until we shutdown, +        Runtime.getRuntime().addShutdownHook(new Thread() {, +            @Override, +            public void run() {, +                keepAliveLatch.countDown();, +            }, +        });, +    }, +                        Bootstrap.INSTANCE.stop();, +    private void start() {, +        keepAliveThread.start();, +    private void stop() {, +        try {, +        } finally {, +    }, +        INSTANCE = new Bootstrap();, +            INSTANCE.setup(true, settings, environment);, +            INSTANCE.start();, +            if (INSTANCE.node != null) {, +                logger = Loggers.getLogger(Bootstrap.class, INSTANCE.node.settings().get("name"));, +++ b/src/main/java/org/elasticsearch/bootstrap/Bootstrap.java, +    private static volatile Bootstrap INSTANCE;, +    private Node node;, +    private final CountDownLatch keepAliveLatch = new CountDownLatch(1);, +    private final Thread keepAliveThread;, +, +    /** creates a new instance */, +    Bootstrap() {, +        keepAliveThread = new Thread(new Runnable() {, +            @Override, +            public void run() {, +                try {, +                    keepAliveLatch.await();, +                } catch (InterruptedException e) {, +                    // bail out, +                }, +            }, +        }, "elasticsearch[keepAlive/" + Version.CURRENT + "]");, +        keepAliveThread.setDaemon(false);, +        // keep this thread alive (non daemon thread) until we shutdown, +        Runtime.getRuntime().addShutdownHook(new Thread() {, +            @Override, +            public void run() {, +                keepAliveLatch.countDown();, +            }, +        });, +    }, +                        Bootstrap.INSTANCE.stop();, +    private void start() {, +        keepAliveThread.start();, +    private void stop() {, +        try {, +        } finally {, +    }, +        INSTANCE = new Bootstrap();, +            INSTANCE.setup(true, settings, environment);, +            INSTANCE.start();, +            if (INSTANCE.node != null) {, +                logger = Loggers.getLogger(Bootstrap.class, INSTANCE.node.settings().get("name"));, +++ b/src/main/java/org/elasticsearch/bootstrap/Elasticsearch.java, +++ b/src/main/java/org/elasticsearch/bootstrap/Bootstrap.java, +    private static volatile Bootstrap INSTANCE;, +    private Node node;, +    private final CountDownLatch keepAliveLatch = new CountDownLatch(1);, +    private final Thread keepAliveThread;, +, +    /** creates a new instance */, +    Bootstrap() {, +        keepAliveThread = new Thread(new Runnable() {, +            @Override, +            public void run() {, +                try {, +                    keepAliveLatch.await();, +                } catch (InterruptedException e) {, +                    // bail out, +                }, +            }, +        }, "elasticsearch[keepAlive/" + Version.CURRENT + "]");, +        keepAliveThread.setDaemon(false);, +        // keep this thread alive (non daemon thread) until we shutdown, +        Runtime.getRuntime().addShutdownHook(new Thread() {]