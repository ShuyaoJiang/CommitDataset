[+++ b/modules/elasticsearch/src/main/java/org/elasticsearch/action/support/replication/TransportShardReplicationOperationAction.java, +                        // just to be on the safe side, see if we can start it now?, +                        if (start(true)) {, +                            clusterService.remove(this);, +                            return;, +                        }, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/action/support/replication/TransportShardReplicationOperationAction.java, +                        // just to be on the safe side, see if we can start it now?, +                        if (start(true)) {, +                            clusterService.remove(this);, +                            return;, +                        }, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/cluster/routing/RoutingNodes.java, +    public List<MutableShardRouting> shardsWithState(ShardRoutingState... state) {, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/action/support/replication/TransportShardReplicationOperationAction.java, +                        // just to be on the safe side, see if we can start it now?, +                        if (start(true)) {, +                            clusterService.remove(this);, +                            return;, +                        }, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/cluster/routing/RoutingNodes.java, +    public List<MutableShardRouting> shardsWithState(ShardRoutingState... state) {, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/cluster/routing/strategy/ShardsRoutingStrategy.java, +import org.elasticsearch.cluster.node.DiscoveryNodes;, +        reroute(routingNodes, clusterState.nodes());, +        // If we reroute again, the failed shard will try and be assigned to the same node, which we do no do in the applyFailedShards, +//        reroute(routingNodes, clusterState.nodes());, +        if (!reroute(routingNodes, clusterState.nodes())) {, +            return clusterState.routingTable();, +        }, +        return new RoutingTable.Builder().updateNodes(routingNodes).build().validateRaiseException(clusterState.metaData());, +    }, +    private boolean reroute(RoutingNodes routingNodes, DiscoveryNodes nodes) {, +        Iterable<DiscoveryNode> dataNodes = nodes.dataNodes().values();, +        return changed;, +            if (!shard.primary()) {, +                // if its a backup, only allocate it if the primary is active, +                MutableShardRouting primary = routingNodes.findPrimaryForBackup(shard);, +                if (primary == null || !primary.active()) {, +                    continue;, +                }, +            }, +            MutableShardRouting shard = it.next();, +            if (!shard.primary()) {, +                // if its a backup, only allocate it if the primary is active, +                MutableShardRouting primary = routingNodes.findPrimaryForBackup(shard);, +                if (primary == null || !primary.active()) {, +                    continue;, +                }, +            }, +                if (routingNode.canAllocate(routingNodes.metaData(), routingNodes.routingTable()) && routingNode.canAllocate(shard)) {, +                    routingNode.add(shard);, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/action/support/replication/TransportShardReplicationOperationAction.java, +                        // just to be on the safe side, see if we can start it now?, +                        if (start(true)) {, +                            clusterService.remove(this);, +                            return;, +                        }, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/cluster/routing/RoutingNodes.java, +    public List<MutableShardRouting> shardsWithState(ShardRoutingState... state) {, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/cluster/routing/strategy/ShardsRoutingStrategy.java, +import org.elasticsearch.cluster.node.DiscoveryNodes;, +        reroute(routingNodes, clusterState.nodes());, +        // If we reroute again, the failed shard will try and be assigned to the same node, which we do no do in the applyFailedShards, +//        reroute(routingNodes, clusterState.nodes());, +        if (!reroute(routingNodes, clusterState.nodes())) {, +            return clusterState.routingTable();, +        }, +        return new RoutingTable.Builder().updateNodes(routingNodes).build().validateRaiseException(clusterState.metaData());, +    }, +    private boolean reroute(RoutingNodes routingNodes, DiscoveryNodes nodes) {, +        Iterable<DiscoveryNode> dataNodes = nodes.dataNodes().values();, +        return changed;, +            if (!shard.primary()) {, +                // if its a backup, only allocate it if the primary is active, +                MutableShardRouting primary = routingNodes.findPrimaryForBackup(shard);, +                if (primary == null || !primary.active()) {, +                    continue;, +                }, +            }, +            MutableShardRouting shard = it.next();, +            if (!shard.primary()) {, +                // if its a backup, only allocate it if the primary is active, +                MutableShardRouting primary = routingNodes.findPrimaryForBackup(shard);, +                if (primary == null || !primary.active()) {, +                    continue;, +                }, +            }, +                if (routingNode.canAllocate(routingNodes.metaData(), routingNodes.routingTable()) && routingNode.canAllocate(shard)) {, +                    routingNode.add(shard);, +++ b/modules/elasticsearch/src/test/java/org/elasticsearch/cluster/routing/strategy/BackupAllocatedAfterPrimaryTests.java, +/*, + * Licensed to Elastic Search and Shay Banon under one, + * or more contributor license agreements.  See the NOTICE file, + * distributed with this work for additional information, + * regarding copyright ownership. Elastic Search licenses this, + * file to you under the Apache License, Version 2.0 (the, + * "License"); you may not use this file except in compliance, + * with the License.  You may obtain a copy of the License at, + *]