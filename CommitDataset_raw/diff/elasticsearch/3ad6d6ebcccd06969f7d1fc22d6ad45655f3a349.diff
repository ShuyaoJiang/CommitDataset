[+++ b/core/src/main/java/org/elasticsearch/index/engine/InternalEngine.java, +    @Override, +    public IndexResult index(Index index) throws IOException {, +        final boolean doThrottle = index.origin().isRecovery() == false;, +        try (ReleasableLock releasableLock = readLock.acquire()) {, +            ensureOpen();, +            try (Releasable ignored = acquireLock(index.uid());, +                Releasable indexThrottle = doThrottle ? () -> {} : throttle.acquireThrottle()) {, +                    forceUpdateDocument = isForceUpdateDocument(index);, +                    indexResult = indexIntoLucene(index, seqNo, currentVersion, deleted, forceUpdateDocument, canOptimizeAddDocument, expectedVersion);, +                if (indexResult.hasFailure() == false) {, +        } catch (RuntimeException | IOException e) {, +            try {, +                maybeFailEngine("index", e);, +            } catch (Exception inner) {, +                e.addSuppressed(inner);, +            }, +            throw e;, +        }, +    }, +, +    private IndexResult indexIntoLucene(Index index, long seqNo, long currentVersion, boolean deleted, boolean forceUpdateDocument, boolean canOptimizeAddDocument, long expectedVersion) throws IOException {, +        /* Update the document's sequence number and primary term; the sequence number here is derived here from either the sequence, +         * number service if this is on the primary, or the existing document's sequence number if this is on the replica. The, +         * primary term here has already been set, see IndexShard#prepareIndex where the Engine$Index operation is created., +         */, +        index.parsedDoc().updateSeqID(seqNo, index.primaryTerm());, +        final long updatedVersion = index.versionType().updateVersion(currentVersion, expectedVersion);, +        index.parsedDoc().version().setLongValue(updatedVersion);, +        try {, +            if (currentVersion == Versions.NOT_FOUND && forceUpdateDocument == false) {, +                // document does not exists, we can optimize for create, but double check if assertions are running, +                assert assertDocDoesNotExist(index, canOptimizeAddDocument == false);, +                index(index.docs(), indexWriter);, +            } else {, +                update(index.uid(), index.docs(), indexWriter);, +            }, +            versionMap.putUnderLock(index.uid().bytes(), new VersionValue(updatedVersion));, +            return new IndexResult(updatedVersion, seqNo, deleted);, +        } catch (Exception ex) {, +            if (indexWriter.getTragicException() == null) {, +                /* There is no tragic event recorded so this must be a document failure., +                 *, +                 * The handling inside IW doesn't guarantee that an tragic / aborting exception, +                 * will be used as THE tragicEventException since if there are multiple exceptions causing an abort in IW, +                 * only one wins. Yet, only the one that wins will also close the IW and in turn fail the engine such that, +                 * we can potentially handle the exception before the engine is failed., +                 * Bottom line is that we can only rely on the fact that if it's a document failure then, +                 * `indexWriter.getTragicException()` will be null otherwise we have to rethrow and treat it as fatal or rather, +                 * non-document failure, +                 */, +                return new IndexResult(ex, currentVersion, index.seqNo());, +            } else {, +                throw ex;, +            }, +        }, +    }, +, +    private boolean isForceUpdateDocument(Index index) {, +        boolean forceUpdateDocument;, +        long deOptimizeTimestamp = maxUnsafeAutoIdTimestamp.get();, +        if (index.isRetry()) {, +            forceUpdateDocument = true;, +            do {, +                deOptimizeTimestamp = maxUnsafeAutoIdTimestamp.get();, +                if (deOptimizeTimestamp >= index.getAutoGeneratedIdTimestamp()) {, +                    break;, +                }, +            } while (maxUnsafeAutoIdTimestamp.compareAndSet(deOptimizeTimestamp,, +                index.getAutoGeneratedIdTimestamp()) == false);, +            assert maxUnsafeAutoIdTimestamp.get() >= index.getAutoGeneratedIdTimestamp();, +        } else {, +            // in this case we force, +            forceUpdateDocument = deOptimizeTimestamp >= index.getAutoGeneratedIdTimestamp();, +        }, +        return forceUpdateDocument;]