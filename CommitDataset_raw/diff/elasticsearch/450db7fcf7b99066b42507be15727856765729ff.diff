[+++ b/server/src/main/java/org/elasticsearch/search/aggregations/bucket/histogram/package-info.java, +/*, + * Licensed to Elasticsearch under one or more contributor, + * license agreements. See the NOTICE file distributed with, + * this work for additional information regarding copyright, + * ownership. Elasticsearch licenses this file to you under, + * the Apache License, Version 2.0 (the "License"); you may, + * not use this file except in compliance with the License., + * You may obtain a copy of the License at, + *, + *    http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing,, + * software distributed under the License is distributed on an, + * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY, + * KIND, either express or implied.  See the License for the, + * specific language governing permissions and limitations, + * under the License., + */, +, +/**, + * Histogram module for different bucket specifications used in aggregation., + */, +package org.elasticsearch.search.aggregations.bucket.histogram;, +++ b/server/src/main/java/org/elasticsearch/search/aggregations/bucket/histogram/package-info.java, +/*, + * Licensed to Elasticsearch under one or more contributor, + * license agreements. See the NOTICE file distributed with, + * this work for additional information regarding copyright, + * ownership. Elasticsearch licenses this file to you under, + * the Apache License, Version 2.0 (the "License"); you may, + * not use this file except in compliance with the License., + * You may obtain a copy of the License at, + *, + *    http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing,, + * software distributed under the License is distributed on an, + * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY, + * KIND, either express or implied.  See the License for the, + * specific language governing permissions and limitations, + * under the License., + */, +, +/**, + * Histogram module for different bucket specifications used in aggregation., + */, +package org.elasticsearch.search.aggregations.bucket.histogram;, +++ b/server/src/test/java/org/elasticsearch/search/aggregations/bucket/histogram/AutoDateHistogramAggregatorTests.java, +import org.junit.Assert;, +import java.util.HashMap;, +import java.util.Map;, +import java.util.stream.Collectors;, +    private static final List<DateTime> DATES_WITH_TIME = Arrays.asList(, +        new DateTime(2010, 3, 12, 1, 7, 45, DateTimeZone.UTC),, +        new DateTime(2010, 4, 27, 3, 43, 34, DateTimeZone.UTC),, +        new DateTime(2012, 5, 18, 4, 11, 0, DateTimeZone.UTC),, +        new DateTime(2013, 5, 29, 5, 11, 31, DateTimeZone.UTC),, +        new DateTime(2013, 10, 31, 8, 24, 5, DateTimeZone.UTC),, +        new DateTime(2015, 2, 13, 13, 9, 32, DateTimeZone.UTC),, +        new DateTime(2015, 6, 24, 13, 47, 43, DateTimeZone.UTC),, +        new DateTime(2015, 11, 13, 16, 14, 34, DateTimeZone.UTC),, +        new DateTime(2016, 3, 4, 17, 9, 50, DateTimeZone.UTC),, +        new DateTime(2017, 12, 12, 22, 55, 46, DateTimeZone.UTC));, +, +    private static final Query DEFAULT_QUERY = new MatchAllDocsQuery();, +        testBothCases(new MatchNoDocsQuery(), DATES_WITH_TIME,, +        testSearchCase(DEFAULT_QUERY, DATES_WITH_TIME,, +        testSearchAndReduceCase(DEFAULT_QUERY, DATES_WITH_TIME,, +        testSearchAndReduceCase(DEFAULT_QUERY, DATES_WITH_TIME,, +                final List<? extends Histogram.Bucket> buckets = histogram.getBuckets();, +        final List<DateTime> dates = Collections.emptyList();, +        final Consumer<AutoDateHistogramAggregationBuilder> aggregation = agg -> agg.setNumBuckets(10).field(DATE_FIELD);, +        testSearchCase(DEFAULT_QUERY, dates, aggregation,, +        testSearchAndReduceCase(DEFAULT_QUERY, dates, aggregation,, +            Assert::assertNull, +        testBothCases(DEFAULT_QUERY, DATES_WITH_TIME,, +        final long start = new DateTime(DateTimeZone.UTC).withDate(2015, 1, 1).getMillis();, +        final long end = new DateTime(DateTimeZone.UTC).withDate(2017, 12, 31).getMillis();, +        final Query rangeQuery = LongPoint.newRangeQuery(INSTANT_FIELD, start, end);, +        testSearchCase(rangeQuery, DATES_WITH_TIME,, +                final List<? extends Histogram.Bucket> buckets = histogram.getBuckets();, +                for (int i = 0; i < buckets.size(); i++) {, +                    final Histogram.Bucket bucket = buckets.get(i);, +                    assertEquals(DATES_WITH_TIME.get(5 + i), bucket.getKey());, +            }, +        testSearchAndReduceCase(rangeQuery, DATES_WITH_TIME,, +                final DateTime startDate = new DateTime(2015, 1, 1, 0, 0, DateTimeZone.UTC);, +                final Map<DateTime, Integer> expectedDocCount = new HashMap<>();, +                expectedDocCount.put(startDate, 3);, +                expectedDocCount.put(startDate.plusYears(1), 1);, +                expectedDocCount.put(startDate.plusYears(2), 1);, +                final List<? extends Histogram.Bucket> buckets = histogram.getBuckets();, +                assertEquals(expectedDocCount.size(), buckets.size());, +                buckets.forEach(bucket ->, +                    assertEquals(expectedDocCount.getOrDefault(bucket.getKey(), 0).longValue(), bucket.getDocCount()));, +        final List<DateTime> datesForMonthInterval = Arrays.asList(, +            new DateTime(2017, 1, 1, 0, 0, 0, DateTimeZone.UTC),, +            new DateTime(2017, 2, 2, 0, 0, 0, DateTimeZone.UTC),, +            new DateTime(2017, 2, 3, 0, 0, 0, DateTimeZone.UTC),]