[+++ b/buildSrc/src/main/groovy/org/elasticsearch/gradle/BuildPlugin.groovy, +++ b/buildSrc/src/main/groovy/org/elasticsearch/gradle/BuildPlugin.groovy, +++ b/core/src/main/java/org/elasticsearch/bootstrap/ESPolicy.java, +++ b/buildSrc/src/main/groovy/org/elasticsearch/gradle/BuildPlugin.groovy, +++ b/core/src/main/java/org/elasticsearch/bootstrap/ESPolicy.java, +++ b/core/src/main/java/org/elasticsearch/common/blobstore/fs/FsBlobContainer.java, +import org.elasticsearch.common.bytes.BytesReference;, +    public void writeBlob(String blobName, BytesReference data) throws IOException {, +        final Path file = path.resolve(blobName);, +        try (OutputStream outputStream = Files.newOutputStream(file)) {, +            data.writeTo(outputStream);, +        }, +        IOUtils.fsync(file, false);, +        IOUtils.fsync(path, true);, +    }, +, +    @Override, +++ b/buildSrc/src/main/groovy/org/elasticsearch/gradle/BuildPlugin.groovy, +++ b/core/src/main/java/org/elasticsearch/bootstrap/ESPolicy.java, +++ b/core/src/main/java/org/elasticsearch/common/blobstore/fs/FsBlobContainer.java, +import org.elasticsearch.common.bytes.BytesReference;, +    public void writeBlob(String blobName, BytesReference data) throws IOException {, +        final Path file = path.resolve(blobName);, +        try (OutputStream outputStream = Files.newOutputStream(file)) {, +            data.writeTo(outputStream);, +        }, +        IOUtils.fsync(file, false);, +        IOUtils.fsync(path, true);, +    }, +, +    @Override, +++ b/core/src/main/java/org/elasticsearch/common/blobstore/support/AbstractBlobContainer.java, +++ b/buildSrc/src/main/groovy/org/elasticsearch/gradle/BuildPlugin.groovy, +++ b/core/src/main/java/org/elasticsearch/bootstrap/ESPolicy.java, +++ b/core/src/main/java/org/elasticsearch/common/blobstore/fs/FsBlobContainer.java, +import org.elasticsearch.common.bytes.BytesReference;, +    public void writeBlob(String blobName, BytesReference data) throws IOException {, +        final Path file = path.resolve(blobName);, +        try (OutputStream outputStream = Files.newOutputStream(file)) {, +            data.writeTo(outputStream);, +        }, +        IOUtils.fsync(file, false);, +        IOUtils.fsync(path, true);, +    }, +, +    @Override, +++ b/core/src/main/java/org/elasticsearch/common/blobstore/support/AbstractBlobContainer.java, +++ b/core/src/main/java/org/elasticsearch/index/mapper/DocumentParser.java, +        final String path = context.path().pathAsText(currentFieldName);, +        final MappedFieldType existingFieldType = context.mapperService().fullName(path);, +        if (existingFieldType != null) {, +            // try to not introduce a conflict, +            mapper = mapper.updateFieldType(Collections.singletonMap(path, existingFieldType));, +        }, +++ b/buildSrc/src/main/groovy/org/elasticsearch/gradle/BuildPlugin.groovy, +++ b/core/src/main/java/org/elasticsearch/bootstrap/ESPolicy.java, +++ b/core/src/main/java/org/elasticsearch/common/blobstore/fs/FsBlobContainer.java, +import org.elasticsearch.common.bytes.BytesReference;, +    public void writeBlob(String blobName, BytesReference data) throws IOException {, +        final Path file = path.resolve(blobName);, +        try (OutputStream outputStream = Files.newOutputStream(file)) {, +            data.writeTo(outputStream);, +        }, +        IOUtils.fsync(file, false);, +        IOUtils.fsync(path, true);, +    }, +, +    @Override, +++ b/core/src/main/java/org/elasticsearch/common/blobstore/support/AbstractBlobContainer.java, +++ b/core/src/main/java/org/elasticsearch/index/mapper/DocumentParser.java, +        final String path = context.path().pathAsText(currentFieldName);, +        final MappedFieldType existingFieldType = context.mapperService().fullName(path);, +        if (existingFieldType != null) {, +            // try to not introduce a conflict, +            mapper = mapper.updateFieldType(Collections.singletonMap(path, existingFieldType));, +        }, +++ b/core/src/main/java/org/elasticsearch/index/mapper/FieldMapper.java, +        } else if (fieldType.getClass() != newFieldType.getClass()) {, +            throw new IllegalStateException("Mixing up field types: " + fieldType.getClass() + " != " + newFieldType.getClass());, +++ b/buildSrc/src/main/groovy/org/elasticsearch/gradle/BuildPlugin.groovy, +++ b/core/src/main/java/org/elasticsearch/bootstrap/ESPolicy.java, +++ b/core/src/main/java/org/elasticsearch/common/blobstore/fs/FsBlobContainer.java, +import org.elasticsearch.common.bytes.BytesReference;, +    public void writeBlob(String blobName, BytesReference data) throws IOException {, +        final Path file = path.resolve(blobName);, +        try (OutputStream outputStream = Files.newOutputStream(file)) {, +            data.writeTo(outputStream);, +        }, +        IOUtils.fsync(file, false);, +        IOUtils.fsync(path, true);, +    }, +, +    @Override, +++ b/core/src/main/java/org/elasticsearch/common/blobstore/support/AbstractBlobContainer.java, +++ b/core/src/main/java/org/elasticsearch/index/mapper/DocumentParser.java, +        final String path = context.path().pathAsText(currentFieldName);, +        final MappedFieldType existingFieldType = context.mapperService().fullName(path);, +        if (existingFieldType != null) {, +            // try to not introduce a conflict, +            mapper = mapper.updateFieldType(Collections.singletonMap(path, existingFieldType));]