[+++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/Def.java, +                 Definition.Type interfaceType = definition.ClassToType(method.arguments.get(i - 1 - replaced));, +++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/Def.java, +                 Definition.Type interfaceType = definition.ClassToType(method.arguments.get(i - 1 - replaced));, +++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/Definition.java, +        public final Class<?> rtn;, +        public final List<Class<?>> arguments;, +        public Method(String name, Struct owner, Class<?> augmentation, Class<?> rtn, List<Class<?>> arguments,, +                    params[i + 1] = defClassToObjectClass(arguments.get(i));, +                returnValue = defClassToObjectClass(rtn);, +                    params[i] = defClassToObjectClass(arguments.get(i));, +                returnValue = defClassToObjectClass(rtn);, +                    params[i] = defClassToObjectClass(arguments.get(i));, +                    params[i + 1] = defClassToObjectClass(arguments.get(i));, +                returnValue = defClassToObjectClass(rtn);, +        public final Class<?> clazz;, +        private Field(String name, String javaName, Struct owner, Class<?> clazz, int modifiers, MethodHandle getter, MethodHandle setter) {, +            this.clazz = clazz;, +    private static String buildMethodCacheKey(String structName, String methodName, List<Class<?>> arguments) {, +        for (Class<?> argument : arguments) {, +            key.append(argument.getName());, +        List<Class<?>> painlessParametersTypes = new ArrayList<>(whitelistConstructor.painlessParameterTypeNames.size());, +                Class<?> painlessParameterClass = TypeToClass(getTypeInternal(painlessParameterTypeName));, +                painlessParametersTypes.add(painlessParameterClass);, +                javaClassParameters[parameterCount] = defClassToObjectClass(painlessParameterClass);, +                    key -> new Method("<init>", ownerStruct, null, void.class, painlessParametersTypes,, +        List<Class<?>> painlessParametersTypes = new ArrayList<>(whitelistMethod.painlessParameterTypeNames.size());, +                Class<?> painlessParameterClass = TypeToClass(getTypeInternal(painlessParameterTypeName));, +                painlessParametersTypes.add(painlessParameterClass);, +                javaClassParameters[parameterCount + augmentedOffset] = defClassToObjectClass(painlessParameterClass);, +        Class<?> painlessReturnClass;, +            painlessReturnClass = TypeToClass(getTypeInternal(whitelistMethod.painlessReturnTypeName));, +        if (javaMethod.getReturnType() != defClassToObjectClass(painlessReturnClass)) {, +            throw new IllegalArgumentException("specified return type class [" + painlessReturnClass + "] " +, +                        key -> new Method(whitelistMethod.javaMethodName, ownerStruct, null, painlessReturnClass, painlessParametersTypes,, +            } else if ((painlessMethod.name.equals(whitelistMethod.javaMethodName) && painlessMethod.rtn == painlessReturnClass &&, +                        "return types [" + painlessReturnClass + "] and [" + painlessMethod.rtn + "], " +, +                        key -> new Method(whitelistMethod.javaMethodName, ownerStruct, javaAugmentedClass, painlessReturnClass,, +            } else if ((painlessMethod.name.equals(whitelistMethod.javaMethodName) && painlessMethod.rtn.equals(painlessReturnClass) &&, +                    "return types [" + painlessReturnClass + "] and [" + painlessMethod.rtn + "], " +, +        Class<?> painlessFieldClass;, +            painlessFieldClass = TypeToClass(getTypeInternal(whitelistField.painlessFieldTypeName));, +                        buildFieldCacheKey(ownerStruct.name, whitelistField.javaFieldName, painlessFieldClass.getName()),, +                                ownerStruct, painlessFieldClass, javaField.getModifiers(), null, null));, +            } else if (painlessField.clazz != painlessFieldClass) {, +                        buildFieldCacheKey(ownerStruct.name, whitelistField.javaFieldName, painlessFieldClass.getName()),, +                                ownerStruct, painlessFieldClass, javaField.getModifiers(), javaMethodHandleGetter, javaMethodHandleSetter));, +            } else if (painlessField.clazz != painlessFieldClass) {, +                        new Field(field.name, field.javaName, owner, field.clazz, field.modifiers, field.getter, field.setter));, +++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/Def.java, +                 Definition.Type interfaceType = definition.ClassToType(method.arguments.get(i - 1 - replaced));, +++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/Definition.java, +        public final Class<?> rtn;, +        public final List<Class<?>> arguments;, +        public Method(String name, Struct owner, Class<?> augmentation, Class<?> rtn, List<Class<?>> arguments,, +                    params[i + 1] = defClassToObjectClass(arguments.get(i));, +                returnValue = defClassToObjectClass(rtn);, +                    params[i] = defClassToObjectClass(arguments.get(i));, +                returnValue = defClassToObjectClass(rtn);, +                    params[i] = defClassToObjectClass(arguments.get(i));, +                    params[i + 1] = defClassToObjectClass(arguments.get(i));, +                returnValue = defClassToObjectClass(rtn);, +        public final Class<?> clazz;, +        private Field(String name, String javaName, Struct owner, Class<?> clazz, int modifiers, MethodHandle getter, MethodHandle setter) {, +            this.clazz = clazz;, +    private static String buildMethodCacheKey(String structName, String methodName, List<Class<?>> arguments) {, +        for (Class<?> argument : arguments) {, +            key.append(argument.getName());, +        List<Class<?>> painlessParametersTypes = new ArrayList<>(whitelistConstructor.painlessParameterTypeNames.size());, +                Class<?> painlessParameterClass = TypeToClass(getTypeInternal(painlessParameterTypeName));, +                painlessParametersTypes.add(painlessParameterClass);, +                javaClassParameters[parameterCount] = defClassToObjectClass(painlessParameterClass);, +                    key -> new Method("<init>", ownerStruct, null, void.class, painlessParametersTypes,, +        List<Class<?>> painlessParametersTypes = new ArrayList<>(whitelistMethod.painlessParameterTypeNames.size());, +                Class<?> painlessParameterClass = TypeToClass(getTypeInternal(painlessParameterTypeName));, +                painlessParametersTypes.add(painlessParameterClass);, +                javaClassParameters[parameterCount + augmentedOffset] = defClassToObjectClass(painlessParameterClass);, +        Class<?> painlessReturnClass;, +            painlessReturnClass = TypeToClass(getTypeInternal(whitelistMethod.painlessReturnTypeName));, +        if (javaMethod.getReturnType() != defClassToObjectClass(painlessReturnClass)) {, +            throw new IllegalArgumentException("specified return type class [" + painlessReturnClass + "] " +, +                        key -> new Method(whitelistMethod.javaMethodName, ownerStruct, null, painlessReturnClass, painlessParametersTypes,, +            } else if ((painlessMethod.name.equals(whitelistMethod.javaMethodName) && painlessMethod.rtn == painlessReturnClass &&, +                        "return types [" + painlessReturnClass + "] and [" + painlessMethod.rtn + "], " +, +                        key -> new Method(whitelistMethod.javaMethodName, ownerStruct, javaAugmentedClass, painlessReturnClass,, +            } else if ((painlessMethod.name.equals(whitelistMethod.javaMethodName) && painlessMethod.rtn.equals(painlessReturnClass) &&, +                    "return types [" + painlessReturnClass + "] and [" + painlessMethod.rtn + "], " +, +        Class<?> painlessFieldClass;, +            painlessFieldClass = TypeToClass(getTypeInternal(whitelistField.painlessFieldTypeName));, +                        buildFieldCacheKey(ownerStruct.name, whitelistField.javaFieldName, painlessFieldClass.getName()),, +                                ownerStruct, painlessFieldClass, javaField.getModifiers(), null, null));, +            } else if (painlessField.clazz != painlessFieldClass) {, +                        buildFieldCacheKey(ownerStruct.name, whitelistField.javaFieldName, painlessFieldClass.getName()),, +                                ownerStruct, painlessFieldClass, javaField.getModifiers(), javaMethodHandleGetter, javaMethodHandleSetter));, +            } else if (painlessField.clazz != painlessFieldClass) {, +                        new Field(field.name, field.javaName, owner, field.clazz, field.modifiers, field.getter, field.setter));, +++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/ECallLocal.java, +            expression.expected = method.arguments.get(argument);, +        actual = method.rtn;, +++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/Def.java]