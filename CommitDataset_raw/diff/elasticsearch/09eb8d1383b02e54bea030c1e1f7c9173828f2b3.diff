[+++ b/src/main/java/org/elasticsearch/indices/recovery/RecoveryTarget.java, +import org.apache.lucene.index.CorruptIndexException;, +import org.apache.lucene.index.IndexFormatTooNewException;, +import org.apache.lucene.index.IndexFormatTooOldException;, +                } catch (CorruptIndexException | IndexFormatTooNewException | IndexFormatTooOldException ex) {, +                    // this is a fatal exception at this stage., +                    // this means we transferred files from the remote that have not be checksummed and they are, +                    // broken. We have to clean up this shard entirely, remove all files and bubble it up to the, +                    // source shard since this index might be broken there as well? The Source can handle this and checks, +                    // its content on disk if possible., +                    store.deleteContent(); // clean up and delete all files, +                    throw new RecoveryFailedException(recoveryStatus.state(), "failed to clean after recovery", ex);, +++ b/src/main/java/org/elasticsearch/indices/recovery/RecoveryTarget.java, +import org.apache.lucene.index.CorruptIndexException;, +import org.apache.lucene.index.IndexFormatTooNewException;, +import org.apache.lucene.index.IndexFormatTooOldException;, +                } catch (CorruptIndexException | IndexFormatTooNewException | IndexFormatTooOldException ex) {, +                    // this is a fatal exception at this stage., +                    // this means we transferred files from the remote that have not be checksummed and they are, +                    // broken. We have to clean up this shard entirely, remove all files and bubble it up to the, +                    // source shard since this index might be broken there as well? The Source can handle this and checks, +                    // its content on disk if possible., +                    store.deleteContent(); // clean up and delete all files, +                    throw new RecoveryFailedException(recoveryStatus.state(), "failed to clean after recovery", ex);, +++ b/src/main/java/org/elasticsearch/indices/recovery/ShardRecoveryHandler.java, +import org.apache.lucene.util.ArrayUtil;, +import org.elasticsearch.common.util.ArrayUtils;, +import java.io.IOException;, +import java.util.ArrayList;, +import java.util.Comparator;, +                    try {, +                    } catch (RemoteTransportException remoteException) {, +                        final IOException corruptIndexException;, +                        // we realized that after the index was copied and we wanted to finalize the recovery, +                        // the index was corrupted:, +                        //   - maybe due to a broken segments file on an empty index (transferred with no checksum), +                        //   - maybe due to old segments without checksums or length only checks, +                        if ((corruptIndexException = ExceptionsHelper.unwrapCorruption(remoteException)) != null) {, +                            try {, +                                final Store.MetadataSnapshot recoverySourceMetadata = store.getMetadata(snapshot);, +                                StoreFileMetaData[] metadata = Iterables.toArray(recoverySourceMetadata, StoreFileMetaData.class);, +                                ArrayUtil.timSort(metadata, new Comparator<StoreFileMetaData>() {, +                                    @Override, +                                    public int compare(StoreFileMetaData o1, StoreFileMetaData o2) {, +                                        return Long.compare(o1.length(), o2.length()); // check small files first, +                                for (StoreFileMetaData md : metadata) {, +                                    logger.debug("{} checking integrity for file {} after remove corruption exception", shard.shardId(), md);, +                                    if (store.checkIntegrityNoException(md) == false) { // we are corrupted on the primary -- fail!, +                                        logger.warn("{} Corrupted file detected {} checksum mismatch", shard.shardId(), md);, +                                        throw corruptIndexException;, +                                    }, +                                }, +                            } catch (IOException ex) {, +                                remoteException.addSuppressed(ex);, +                                throw remoteException;, +                            }, +                            // corruption has happened on the way to replica, +                            RemoteTransportException exception = new RemoteTransportException("File corruption occurred on recovery but checksums are ok", null);, +                            exception.addSuppressed(remoteException);, +                            logger.warn("{} Remote file corruption during finalization on node {}, recovering {}. local checksum OK",, +                                    corruptIndexException, shard.shardId(), request.targetNode());, +                        } else {, +                            throw remoteException;, +                        }, +                    }, +                }, +            });, +++ b/src/main/java/org/elasticsearch/indices/recovery/RecoveryTarget.java, +import org.apache.lucene.index.CorruptIndexException;, +import org.apache.lucene.index.IndexFormatTooNewException;, +import org.apache.lucene.index.IndexFormatTooOldException;, +                } catch (CorruptIndexException | IndexFormatTooNewException | IndexFormatTooOldException ex) {, +                    // this is a fatal exception at this stage., +                    // this means we transferred files from the remote that have not be checksummed and they are, +                    // broken. We have to clean up this shard entirely, remove all files and bubble it up to the, +                    // source shard since this index might be broken there as well? The Source can handle this and checks, +                    // its content on disk if possible., +                    store.deleteContent(); // clean up and delete all files, +                    throw new RecoveryFailedException(recoveryStatus.state(), "failed to clean after recovery", ex);, +++ b/src/main/java/org/elasticsearch/indices/recovery/ShardRecoveryHandler.java, +import org.apache.lucene.util.ArrayUtil;, +import org.elasticsearch.common.util.ArrayUtils;, +import java.io.IOException;, +import java.util.ArrayList;, +import java.util.Comparator;, +                    try {, +                    } catch (RemoteTransportException remoteException) {, +                        final IOException corruptIndexException;, +                        // we realized that after the index was copied and we wanted to finalize the recovery, +                        // the index was corrupted:, +                        //   - maybe due to a broken segments file on an empty index (transferred with no checksum), +                        //   - maybe due to old segments without checksums or length only checks, +                        if ((corruptIndexException = ExceptionsHelper.unwrapCorruption(remoteException)) != null) {, +                            try {, +                                final Store.MetadataSnapshot recoverySourceMetadata = store.getMetadata(snapshot);, +                                StoreFileMetaData[] metadata = Iterables.toArray(recoverySourceMetadata, StoreFileMetaData.class);, +                                ArrayUtil.timSort(metadata, new Comparator<StoreFileMetaData>() {, +                                    @Override, +                                    public int compare(StoreFileMetaData o1, StoreFileMetaData o2) {, +                                        return Long.compare(o1.length(), o2.length()); // check small files first]