[+++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/core/pom.xml, +                            <pattern>jsr166e</pattern>, +                   <exclude>jsr166e/**</exclude>, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/core/pom.xml, +                            <pattern>jsr166e</pattern>, +                   <exclude>jsr166e/**</exclude>, +++ b/core/src/main/assemblies/common-bin.xml, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/core/pom.xml, +                            <pattern>jsr166e</pattern>, +                   <exclude>jsr166e/**</exclude>, +++ b/core/src/main/assemblies/common-bin.xml, +++ b/core/src/main/java/jsr166e/DoubleAdder.java, +/*, + * Written by Doug Lea with assistance from members of JCP JSR-166, + * Expert Group and released to the public domain, as explained at, + * http://creativecommons.org/publicdomain/zero/1.0/, + */, +, +package jsr166e;, +import java.io.Serializable;, +, +/**, + * One or more variables that together maintain an initially zero, + * {@code double} sum.  When updates (method {@link #add}) are, + * contended across threads, the set of variables may grow dynamically, + * to reduce contention.  Method {@link #sum} (or, equivalently {@link, + * #doubleValue}) returns the current total combined across the, + * variables maintaining the sum., + *, + * <p>This class extends {@link Number}, but does <em>not</em> define, + * methods such as {@code equals}, {@code hashCode} and {@code, + * compareTo} because instances are expected to be mutated, and so are, + * not useful as collection keys., + *, + * <p><em>jsr166e note: This class is targeted to be placed in, + * java.util.concurrent.atomic.</em>, + *, + * @since 1.8, + * @author Doug Lea, + */, +public class DoubleAdder extends Striped64 implements Serializable {, +    private static final long serialVersionUID = 7249069246863182397L;, +, +    /**, +     * Update function. Note that we must use "long" for underlying, +     * representations, because there is no compareAndSet for double,, +     * due to the fact that the bitwise equals used in any CAS, +     * implementation is not the same as double-precision equals., +     * However, we use CAS only to detect and alleviate contention,, +     * for which bitwise equals works best anyway. In principle, the, +     * long/double conversions used here should be essentially free on, +     * most platforms since they just re-interpret bits., +     *, +     * Similar conversions are used in other methods., +     */, +    final long fn(long v, long x) {, +        return Double.doubleToRawLongBits, +            (Double.longBitsToDouble(v) +, +             Double.longBitsToDouble(x));, +    }, +, +    /**, +     * Creates a new adder with initial sum of zero., +     */, +    public DoubleAdder() {, +    }, +, +    /**, +     * Adds the given value., +     *, +     * @param x the value to add, +     */, +    public void add(double x) {, +        Cell[] as; long b, v; HashCode hc; Cell a; int n;, +        if ((as = cells) != null ||, +            !casBase(b = base,, +                     Double.doubleToRawLongBits, +                     (Double.longBitsToDouble(b) + x))) {, +            boolean uncontended = true;, +            int h = (hc = threadHashCode.get()).code;, +            if (as == null || (n = as.length) < 1 ||, +                (a = as[(n - 1) & h]) == null ||, +                !(uncontended = a.cas(v = a.value,, +                                      Double.doubleToRawLongBits, +                                      (Double.longBitsToDouble(v) + x))))]