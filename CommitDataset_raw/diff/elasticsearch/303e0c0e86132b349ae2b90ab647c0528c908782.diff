[+++ b/core/src/main/java/org/elasticsearch/index/shard/ShardSplittingQuery.java, +import org.apache.lucene.index.IndexReaderContext;, +import org.apache.lucene.index.ReaderUtil;, +import org.apache.lucene.search.join.BitSetProducer;, +import org.apache.lucene.util.BitSet;, +import org.elasticsearch.common.lucene.search.Queries;, +import java.util.function.Function;, +import java.util.function.IntPredicate;, +    private final BitSetProducer nestedParentBitSetProducer;, +    ShardSplittingQuery(IndexMetaData indexMetaData, int shardId, boolean hasNested) {, +        this.nestedParentBitSetProducer =  hasNested ? newParentDocBitSetProducer() : null;, +                if (terms == null) {, +                    // this is the common case - no partitioning and no _routing values, +                    // in this case we also don't do anything special with regards to nested docs since we basically delete, +                    // by ID and parent and nested all have the same id., +                    final BitSet parentBitSet;, +                    if (nestedParentBitSetProducer == null) {, +                        parentBitSet = null;, +                    } else {, +                        parentBitSet = nestedParentBitSetProducer.getBitSet(context);, +                        if (parentBitSet == null) {, +                            return null; // no matches, +                        }, +                    }, +                        Visitor visitor = new Visitor(leafReader);, +                        TwoPhaseIterator twoPhaseIterator =, +                            parentBitSet == null ? new RoutingPartitionedDocIdSetIterator(visitor) :, +                                new NestedRoutingPartitionedDocIdSetIterator(visitor, parentBitSet);, +                        return new ConstantScoreScorer(this, score(), twoPhaseIterator);, +                        // here we potentially guard the docID consumers with our parent bitset if we have one., +                        // this ensures that we are only marking root documents in the nested case and if necessary, +                        // we do a second pass to mark the corresponding children in markChildDocs, +                        Function<IntConsumer, IntConsumer> maybeWrapConsumer = consumer -> {, +                            if (parentBitSet != null) {, +                                return docId -> {, +                                    if (parentBitSet.get(docId)) {, +                                        consumer.accept(docId);, +                                    }, +                                };, +                            }, +                            return consumer;, +                        };, +                        }, leafReader, maybeWrapConsumer.apply(bitSet::set));, +, +                            findSplitDocs(RoutingFieldMapper.NAME, ref -> false, leafReader, maybeWrapConsumer.apply(hasRoutingValue::set));, +                            IntConsumer bitSetConsumer = maybeWrapConsumer.apply(bitSet::set);, +                                    bitSetConsumer.accept(docId);, +                    if (parentBitSet != null) {, +                        // if nested docs are involved we also need to mark all child docs that belong to a matching parent doc., +                        markChildDocs(parentBitSet, bitSet);, +                }, +, +    private void markChildDocs(BitSet parentDocs, BitSet matchingDocs) {, +        int currentDeleted = 0;, +        while (currentDeleted < matchingDocs.length() &&, +            (currentDeleted = matchingDocs.nextSetBit(currentDeleted)) != DocIdSetIterator.NO_MORE_DOCS) {, +            int previousParent = parentDocs.prevSetBit(Math.max(0, currentDeleted-1));, +            for (int i = previousParent + 1; i < currentDeleted; i++) {, +                matchingDocs.set(i);, +            }, +            currentDeleted++;, +        }, +    }, +, +    private static void findSplitDocs(String idField, Predicate<BytesRef> includeInShard, LeafReader leafReader,, +                                      IntConsumer consumer) throws IOException {, +    /* this class is a stored fields visitor that reads _id and/or _routing from the stored fields which is necessary in the case, +       of a routing partitioned index sine otherwise we would need to un-invert the _id and _routing field which is memory heavy */, +    private final class Visitor extends StoredFieldVisitor {, +        final LeafReader leafReader;, +        private int leftToVisit = 2;, +        private final BytesRef spare = new BytesRef();, +        private String routing;, +        private String id;, +        Visitor(LeafReader leafReader) {, +            this.leafReader = leafReader;, +, +        boolean matches(int doc) throws IOException {, +            routing = id = null;, +            leftToVisit = 2;, +            leafReader.document(doc, this);, +            assert id != null : "docID must not be null - we might have hit a nested document";, +            int targetShardId = OperationRouting.generateShardId(indexMetaData, id, routing);, +            return targetShardId != shardId;, +        }, +    private static final class RoutingPartitionedDocIdSetIterator extends TwoPhaseIterator {, +        RoutingPartitionedDocIdSetIterator(Visitor visitor) {, +            super(DocIdSetIterator.all(visitor.leafReader.maxDoc())); // we iterate all live-docs, +            return visitor.matches(approximation.docID());, +, +    /**, +     * This TwoPhaseIterator marks all nested docs of matching parents as matches as well., +     */, +    private static final class NestedRoutingPartitionedDocIdSetIterator extends TwoPhaseIterator {, +        private final Visitor visitor;, +        private final BitSet parentDocs;, +        private int nextParent = -1;, +        private boolean nextParentMatches;, +, +        NestedRoutingPartitionedDocIdSetIterator(Visitor visitor, BitSet parentDocs) {]