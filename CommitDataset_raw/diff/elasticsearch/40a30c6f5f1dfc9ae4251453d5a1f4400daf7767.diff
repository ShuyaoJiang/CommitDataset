[+++ b/x-pack/plugin/sql/sql-client/src/main/java/org/elasticsearch/xpack/sql/client/SslConfig.java, +    private KeyStore loadKeyStore(String source, char[] pass, String keyStoreType) throws GeneralSecurityException, IOException {, +        Path path = Paths.get(source);, +                    "Expected to find keystore file at [" + source + "] but was unable to. Make sure you have specified a valid URI.");, +        try (InputStream in = Files.newInputStream(Paths.get(source), StandardOpenOption.READ)) {, +            throw new ClientException("Cannot open keystore [" + source + "] - " + ex.getMessage(), ex);, +    @Override, +++ b/x-pack/plugin/sql/sql-client/src/main/java/org/elasticsearch/xpack/sql/client/SslConfig.java, +    private KeyStore loadKeyStore(String source, char[] pass, String keyStoreType) throws GeneralSecurityException, IOException {, +        Path path = Paths.get(source);, +                    "Expected to find keystore file at [" + source + "] but was unable to. Make sure you have specified a valid URI.");, +        try (InputStream in = Files.newInputStream(Paths.get(source), StandardOpenOption.READ)) {, +            throw new ClientException("Cannot open keystore [" + source + "] - " + ex.getMessage(), ex);, +    @Override, +++ b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/analysis/AnalysisException.java, +        if (source != null && source.source() != null) {, +            loc = source.source().source();, +        if (source != null && source.source() != null) {, +            loc = source.source().source();, +++ b/x-pack/plugin/sql/sql-client/src/main/java/org/elasticsearch/xpack/sql/client/SslConfig.java, +    private KeyStore loadKeyStore(String source, char[] pass, String keyStoreType) throws GeneralSecurityException, IOException {, +        Path path = Paths.get(source);, +                    "Expected to find keystore file at [" + source + "] but was unable to. Make sure you have specified a valid URI.");, +        try (InputStream in = Files.newInputStream(Paths.get(source), StandardOpenOption.READ)) {, +            throw new ClientException("Cannot open keystore [" + source + "] - " + ex.getMessage(), ex);, +    @Override, +++ b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/analysis/AnalysisException.java, +        if (source != null && source.source() != null) {, +            loc = source.source().source();, +        if (source != null && source.source() != null) {, +            loc = source.source().source();, +++ b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/analysis/analyzer/Analyzer.java, +                    matches.add(attribute.withLocation(u.source()));, +                        return new SubQueryAlias(ur.source(), subQueryAlias, ur.alias());, +                return plan.unresolvedMessage().equals(indexResolution.toString()) ? plan : new UnresolvedRelation(plan.source(),, +            LogicalPlan logicalPlan = new EsRelation(plan.source(), indexResolution.get());, +            SubQueryAlias sa = new SubQueryAlias(plan.source(), logicalPlan, table.index());, +                sa = new SubQueryAlias(plan.source(), sa, plan.alias());, +                    return new Project(p.source(), p.child(), expandProjections(p.projections(), p.child()));, +                    return new Aggregate(a.source(), a.child(), a.groupings(),, +                    return changed ? new Aggregate(a.source(), a.child(), newGroupings, a.aggregates()) : a;, +                    return new Join(j.source(), j.left(), deduped, j.type(), j.condition());, +                    return new OrderBy(o.source(), o.child(), resolvedOrder);, +                                expanded.add(fa.withLocation(attr.source()));, +                                expanded.add(fa.withLocation(attr.source()));, +                            newOrder.add(new Order(order.source(), orderBy.child().output().get(ordinal - 1), order.direction(),, +                return changed ? new OrderBy(orderBy.source(), orderBy.child(), newOrder) : orderBy;, +                return changed ? new Aggregate(agg.source(), agg.child(), newGroupings, aggregates) : agg;, +                        return o.order().equals(newOrders) ? o : new OrderBy(o.source(), o.child(), newOrders);, +                    return new Project(o.source(), new OrderBy(o.source(), newChild, maybeResolved), o.child().output());, +                    return new OrderBy(o.source(), o.child(), maybeResolved);, +                        return f.condition().equals(transformed) ? f : new Filter(f.source(), f.child(), transformed);, +                    return new Project(f.source(), new Filter(f.source(), newChild, maybeResolved), f.child().output());, +                    return new Filter(f.source(), f.child(), maybeResolved);, +                return new Project(p.source(), propagateMissing(p.child(), diff, failed), combine(p.projections(), missing));, +                            m = new UnresolvedAttribute(m.source(), m.name(), m.qualifier(), null, null,, +                return new Aggregate(a.source(), a.child(), a.groupings(), combine(a.aggregates(), missing));, +                    return new Project(p.source(), p.child(), assignAliases(p.projections()));, +                    return new Aggregate(a.source(), a.child(), a.groupings(), assignAliases(a.aggregates()));, +                            return new Alias(c.source(), ((NamedExpression) c.field()).name(), c);, +                    return new Alias(child.source(), child.toString(), child);, +                return new Aggregate(p.source(), p.child(), emptyList(), p.projections());, +                        Aggregate tryResolvingCondition = new Aggregate(agg.source(), agg.child(), agg.groupings(),, +                                combine(agg.aggregates(), new Alias(f.source(), ".having", condition)));, +                        Aggregate newAgg = new Aggregate(agg.source(), agg.child(), agg.groupings(),, +                        Filter newFilter = new Filter(f.source(), newAgg, condition);, +                        return new Project(f.source(), newFilter, f.output());, +                    return new Filter(f.source(), f.child(), condition);, +                    left = l == common ? left : new Cast(left.source(), left, common);, +                    right = r == common ? right : new Cast(right.source(), right, common);, +                return new Project(p.source(), p.child(), cleanExpressions(p.projections()));, +                return new Aggregate(a.source(), a.child(), cleanedGroups, cleanExpressions(a.aggregates()));, +                return new Alias(a.source(), a.name(), a.qualifier(), trimAliases(a.child()), a.id());, +++ b/x-pack/plugin/sql/sql-client/src/main/java/org/elasticsearch/xpack/sql/client/SslConfig.java, +    private KeyStore loadKeyStore(String source, char[] pass, String keyStoreType) throws GeneralSecurityException, IOException {, +        Path path = Paths.get(source);, +                    "Expected to find keystore file at [" + source + "] but was unable to. Make sure you have specified a valid URI.");, +        try (InputStream in = Files.newInputStream(Paths.get(source), StandardOpenOption.READ)) {, +            throw new ClientException("Cannot open keystore [" + source + "] - " + ex.getMessage(), ex);, +    @Override, +++ b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/analysis/AnalysisException.java, +        if (source != null && source.source() != null) {, +            loc = source.source().source();, +        if (source != null && source.source() != null) {, +            loc = source.source().source();, +++ b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/analysis/analyzer/Analyzer.java, +                    matches.add(attribute.withLocation(u.source()));, +                        return new SubQueryAlias(ur.source(), subQueryAlias, ur.alias());, +                return plan.unresolvedMessage().equals(indexResolution.toString()) ? plan : new UnresolvedRelation(plan.source(),, +            LogicalPlan logicalPlan = new EsRelation(plan.source(), indexResolution.get());, +            SubQueryAlias sa = new SubQueryAlias(plan.source(), logicalPlan, table.index());, +                sa = new SubQueryAlias(plan.source(), sa, plan.alias());, +                    return new Project(p.source(), p.child(), expandProjections(p.projections(), p.child()));, +                    return new Aggregate(a.source(), a.child(), a.groupings(),, +                    return changed ? new Aggregate(a.source(), a.child(), newGroupings, a.aggregates()) : a;, +                    return new Join(j.source(), j.left(), deduped, j.type(), j.condition());, +                    return new OrderBy(o.source(), o.child(), resolvedOrder);, +                                expanded.add(fa.withLocation(attr.source()));, +                                expanded.add(fa.withLocation(attr.source()));, +                            newOrder.add(new Order(order.source(), orderBy.child().output().get(ordinal - 1), order.direction(),]