[+++ b/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/authz/accesscontrol/DocumentSubsetReader.java, +import org.apache.lucene.index.IndexReader;, +import org.apache.lucene.store.AlreadyClosedException;, +import org.elasticsearch.common.cache.Cache;, +import org.elasticsearch.common.cache.CacheBuilder;, +import java.io.UncheckedIOException;, +import java.util.Map;, +import java.util.concurrent.ConcurrentHashMap;, +import java.util.concurrent.ExecutionException;, +    /**, +     * Cache of the number of live docs for a given (segment, role query) pair., +     * This is useful because numDocs() is called eagerly by BaseCompositeReader so computing, +     * numDocs() lazily doesn't help. Plus it helps reuse the result of the computation either, +     * between refreshes, or across refreshes if no more documents were deleted in the, +     * considered segment. The size of the top-level map is bounded by the number of segments, +     * on the node., +     */, +    static final Map<IndexReader.CacheKey, Cache<Query, Integer>> NUM_DOCS_CACHE = new ConcurrentHashMap<>();, +, +    /**, +     * Compute the number of live documents. This method is SLOW., +     */, +    private static int computeNumDocs(LeafReader reader, Query roleQuery, BitSet roleQueryBits) {, +        final Bits liveDocs = reader.getLiveDocs();, +        if (roleQueryBits == null) {, +            return 0;, +        } else if (liveDocs == null) {, +            // slow, +            return roleQueryBits.cardinality();, +        } else {, +            // very slow, but necessary in order to be correct, +            int numDocs = 0;, +            DocIdSetIterator it = new BitSetIterator(roleQueryBits, 0L); // we don't use the cost, +            try {, +                for (int doc = it.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = it.nextDoc()) {, +                    if (liveDocs.get(doc)) {, +                        numDocs++;, +                    }, +                }, +                return numDocs;, +            } catch (IOException e) {, +                throw new UncheckedIOException(e);, +            }, +        }, +    }, +, +    /**, +     * Like {@link #computeNumDocs} but caches results., +     */, +    private static int getNumDocs(LeafReader reader, Query roleQuery, BitSet roleQueryBits) throws IOException, ExecutionException {, +        IndexReader.CacheHelper cacheHelper = reader.getReaderCacheHelper(); // this one takes deletes into account, +        if (cacheHelper == null) {, +            throw new IllegalStateException("Reader " + reader + " does not support caching");, +        }, +        final boolean[] added = new boolean[] { false };, +        Cache<Query, Integer> perReaderCache = NUM_DOCS_CACHE.computeIfAbsent(cacheHelper.getKey(),, +                key -> {, +                    added[0] = true;, +                    return CacheBuilder.<Query, Integer>builder(), +                            // Not configurable, this limit only exists so that if a role query is updated, +                            // then we won't risk OOME because of old role queries that are not used anymore, +                            .setMaximumWeight(1000), +                            .weigher((k, v) -> 1) // just count, +                            .build();, +                });, +        if (added[0]) {, +            IndexReader.ClosedListener closedListener = NUM_DOCS_CACHE::remove;, +            try {, +                cacheHelper.addClosedListener(closedListener);, +            } catch (AlreadyClosedException e) {, +                closedListener.onClose(cacheHelper.getKey());, +                throw e;, +            }, +        }, +        return perReaderCache.computeIfAbsent(roleQuery, q -> computeNumDocs(reader, roleQuery, roleQueryBits));, +    }, +, +    private final int numDocs;, +        this.numDocs = getNumDocs(in, roleQuery, roleQueryBits);, +        // Not delegated since we change the live docs, +        return null;, +++ b/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/authz/accesscontrol/DocumentSubsetReader.java, +import org.apache.lucene.index.IndexReader;, +import org.apache.lucene.store.AlreadyClosedException;, +import org.elasticsearch.common.cache.Cache;, +import org.elasticsearch.common.cache.CacheBuilder;, +import java.io.UncheckedIOException;, +import java.util.Map;, +import java.util.concurrent.ConcurrentHashMap;, +import java.util.concurrent.ExecutionException;, +    /**, +     * Cache of the number of live docs for a given (segment, role query) pair., +     * This is useful because numDocs() is called eagerly by BaseCompositeReader so computing, +     * numDocs() lazily doesn't help. Plus it helps reuse the result of the computation either, +     * between refreshes, or across refreshes if no more documents were deleted in the, +     * considered segment. The size of the top-level map is bounded by the number of segments, +     * on the node., +     */, +    static final Map<IndexReader.CacheKey, Cache<Query, Integer>> NUM_DOCS_CACHE = new ConcurrentHashMap<>();, +]