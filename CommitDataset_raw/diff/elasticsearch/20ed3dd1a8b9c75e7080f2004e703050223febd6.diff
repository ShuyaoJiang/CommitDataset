[+++ b/server/src/main/java/org/elasticsearch/indices/recovery/RecoverySourceHandler.java, +import org.elasticsearch.common.CheckedSupplier;, +import java.util.concurrent.atomic.AtomicInteger;, +        final AtomicInteger skippedOps = new AtomicInteger();, +        final AtomicInteger totalSentOps = new AtomicInteger();, +        final AtomicInteger lastBatchCount = new AtomicInteger(); // used to estimate the count of the subsequent batch., +        final CheckedSupplier<List<Translog.Operation>, IOException> readNextBatch = () -> {, +            // We need to synchronized Snapshot#next() because it's called by different threads through sendBatch., +            // Even though those calls are not concurrent, Snapshot#next() uses non-synchronized state and is not multi-thread-compatible., +            synchronized (snapshot) {, +                final List<Translog.Operation> ops = lastBatchCount.get() > 0 ? new ArrayList<>(lastBatchCount.get()) : new ArrayList<>();, +                long batchSizeInBytes = 0L;, +                        skippedOps.incrementAndGet();, +                    ops.add(operation);, +                    batchSizeInBytes += operation.estimateSize();, +                    totalSentOps.incrementAndGet();, +                    if (batchSizeInBytes >= chunkSizeInBytes) {, +                        break;, +                lastBatchCount.set(ops.size());, +                return ops;, +            }, +        };, +        final StopWatch stopWatch = new StopWatch().start();, +        final ActionListener<Long> batchedListener = ActionListener.wrap(, +            targetLocalCheckpoint -> {, +                assert snapshot.totalOperations() == snapshot.skippedOperations() + skippedOps.get() + totalSentOps.get(), +                    snapshot.totalOperations(), snapshot.skippedOperations(), skippedOps.get(), totalSentOps.get());, +                listener.onResponse(new SendSnapshotResult(targetLocalCheckpoint, totalSentOps.get(), tookTime));, +            },, +            listener::onFailure, +        );, +, +        sendBatch(readNextBatch, true, SequenceNumbers.UNASSIGNED_SEQ_NO, snapshot.totalOperations(),, +            maxSeenAutoIdTimestamp, maxSeqNoOfUpdatesOrDeletes, batchedListener);, +    }, +, +    private void sendBatch(CheckedSupplier<List<Translog.Operation>, IOException> nextBatch, boolean firstBatch,, +                           long targetLocalCheckpoint, int totalTranslogOps, long maxSeenAutoIdTimestamp,, +                           long maxSeqNoOfUpdatesOrDeletes, ActionListener<Long> listener) throws IOException {, +        final List<Translog.Operation> operations = nextBatch.get();, +        // send the leftover operations or if no operations were sent, request the target to respond with its local checkpoint, +        if (operations.isEmpty() == false || firstBatch) {, +            cancellableThreads.execute(() -> {, +                recoveryTarget.indexTranslogOperations(operations, totalTranslogOps, maxSeenAutoIdTimestamp, maxSeqNoOfUpdatesOrDeletes,, +                    ActionListener.wrap(, +                        newCheckpoint -> {, +                            sendBatch(nextBatch, false, SequenceNumbers.max(targetLocalCheckpoint, newCheckpoint),, +                                totalTranslogOps, maxSeenAutoIdTimestamp, maxSeqNoOfUpdatesOrDeletes, listener);, +                        },, +                        listener::onFailure, +                    ));, +            });, +        } else {, +            listener.onResponse(targetLocalCheckpoint);, +        }, +++ b/server/src/main/java/org/elasticsearch/indices/recovery/RecoverySourceHandler.java, +import org.elasticsearch.common.CheckedSupplier;, +import java.util.concurrent.atomic.AtomicInteger;, +        final AtomicInteger skippedOps = new AtomicInteger();, +        final AtomicInteger totalSentOps = new AtomicInteger();, +        final AtomicInteger lastBatchCount = new AtomicInteger(); // used to estimate the count of the subsequent batch., +        final CheckedSupplier<List<Translog.Operation>, IOException> readNextBatch = () -> {, +            // We need to synchronized Snapshot#next() because it's called by different threads through sendBatch., +            // Even though those calls are not concurrent, Snapshot#next() uses non-synchronized state and is not multi-thread-compatible., +            synchronized (snapshot) {, +                final List<Translog.Operation> ops = lastBatchCount.get() > 0 ? new ArrayList<>(lastBatchCount.get()) : new ArrayList<>();, +                long batchSizeInBytes = 0L;, +                        skippedOps.incrementAndGet();, +                    ops.add(operation);, +                    batchSizeInBytes += operation.estimateSize();, +                    totalSentOps.incrementAndGet();, +                    if (batchSizeInBytes >= chunkSizeInBytes) {, +                        break;, +                lastBatchCount.set(ops.size());, +                return ops;, +            }, +        };, +        final StopWatch stopWatch = new StopWatch().start();, +        final ActionListener<Long> batchedListener = ActionListener.wrap(, +            targetLocalCheckpoint -> {, +                assert snapshot.totalOperations() == snapshot.skippedOperations() + skippedOps.get() + totalSentOps.get(), +                    snapshot.totalOperations(), snapshot.skippedOperations(), skippedOps.get(), totalSentOps.get());, +                listener.onResponse(new SendSnapshotResult(targetLocalCheckpoint, totalSentOps.get(), tookTime));, +            },, +            listener::onFailure, +        );, +, +        sendBatch(readNextBatch, true, SequenceNumbers.UNASSIGNED_SEQ_NO, snapshot.totalOperations(),, +            maxSeenAutoIdTimestamp, maxSeqNoOfUpdatesOrDeletes, batchedListener);, +    }, +, +    private void sendBatch(CheckedSupplier<List<Translog.Operation>, IOException> nextBatch, boolean firstBatch,, +                           long targetLocalCheckpoint, int totalTranslogOps, long maxSeenAutoIdTimestamp,, +                           long maxSeqNoOfUpdatesOrDeletes, ActionListener<Long> listener) throws IOException {, +        final List<Translog.Operation> operations = nextBatch.get();, +        // send the leftover operations or if no operations were sent, request the target to respond with its local checkpoint, +        if (operations.isEmpty() == false || firstBatch) {, +            cancellableThreads.execute(() -> {, +                recoveryTarget.indexTranslogOperations(operations, totalTranslogOps, maxSeenAutoIdTimestamp, maxSeqNoOfUpdatesOrDeletes,, +                    ActionListener.wrap(]