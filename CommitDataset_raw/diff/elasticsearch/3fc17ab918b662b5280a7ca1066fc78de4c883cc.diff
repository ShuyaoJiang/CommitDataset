[+++ b/plugin/src/main/java/org/elasticsearch/xpack/security/audit/logfile/LoggingAuditTrail.java, +import org.elasticsearch.action.IndicesRequest;, +import org.elasticsearch.xpack.security.support.Automatons;, +import java.util.HashMap;, +import java.util.Map;, +import java.util.function.Predicate;, +import java.util.function.Supplier;, +import java.util.stream.Collectors;, +import java.util.stream.Stream;, +    private static final String FILTER_POLICY_PREFIX = setting("audit.logfile.events.ignore_filters.");, +    // because of the default wildcard value (*) for the field filter, a policy with, +    // an unspecified filter field will match events that have any value for that, +    // particular field, as well as events with that particular field missing, +    private static final Setting.AffixSetting<List<String>> FILTER_POLICY_IGNORE_PRINCIPALS =, +            Setting.affixKeySetting(FILTER_POLICY_PREFIX, "users", (key) -> Setting.listSetting(key, Collections.singletonList("*"),, +                    Function.identity(), Setting.Property.NodeScope, Setting.Property.Dynamic));, +    private static final Setting.AffixSetting<List<String>> FILTER_POLICY_IGNORE_REALMS =, +            Setting.affixKeySetting(FILTER_POLICY_PREFIX, "realms", (key) -> Setting.listSetting(key, Collections.singletonList("*"),, +                    Function.identity(), Setting.Property.NodeScope, Setting.Property.Dynamic));, +    private static final Setting.AffixSetting<List<String>> FILTER_POLICY_IGNORE_ROLES =, +            Setting.affixKeySetting(FILTER_POLICY_PREFIX, "roles", (key) -> Setting.listSetting(key, Collections.singletonList("*"),, +                    Function.identity(), Setting.Property.NodeScope, Setting.Property.Dynamic));, +    private static final Setting.AffixSetting<List<String>> FILTER_POLICY_IGNORE_INDICES =, +            Setting.affixKeySetting(FILTER_POLICY_PREFIX, "indices", (key) -> Setting.listSetting(key, Collections.singletonList("*"),, +                    Function.identity(), Setting.Property.NodeScope, Setting.Property.Dynamic));, +    // protected for testing, +    protected final Predicate<AuditEventMetaInfo> filterPolicyPredicate;, +        this.filterPolicyPredicate = new EventFilterPolicyRegistry(settings).ignorePredicate();, +        if (events.contains(AUTHENTICATION_SUCCESS) && filterPolicyPredicate, +                .test(new AuditEventMetaInfo(Optional.of(user), Optional.of(realm), Optional.empty(), Optional.empty())) == false) {, +            final Optional<String[]> indices = indices(message);, +            if (filterPolicyPredicate, +                    .test(new AuditEventMetaInfo(Optional.of(user), Optional.of(realm), Optional.empty(), indices)) == false) {, +                if (indices.isPresent()) {, +                    logger.info("{}[transport] [authentication_success]\t{}, {}, realm=[{}], action=[{}], indices=[{}], request=[{}]",, +                            localNodeInfo.prefix, originAttributes(threadContext, message, localNodeInfo), principal(user), realm, action,, +                            arrayToCommaDelimitedString(indices.get()), message.getClass().getSimpleName());, +                } else {, +        }, +    }, +            final Optional<String[]> indices = indices(message);, +            if (filterPolicyPredicate.test(new AuditEventMetaInfo(Optional.empty(), Optional.empty(), indices)) == false) {, +                if (indices.isPresent()) {, +                            localNodeInfo.prefix, originAttributes(threadContext, message, localNodeInfo), action,, +                            arrayToCommaDelimitedString(indices.get()), message.getClass().getSimpleName());, +    }, +        if (events.contains(ANONYMOUS_ACCESS_DENIED) && filterPolicyPredicate.test(AuditEventMetaInfo.EMPTY) == false) {, +            final Optional<String[]> indices = indices(message);, +            if (filterPolicyPredicate.test(new AuditEventMetaInfo(Optional.of(token), Optional.empty(), indices)) == false) {, +                if (indices.isPresent()) {, +                            localNodeInfo.prefix, originAttributes(threadContext, message, localNodeInfo), token.principal(), action,, +                            arrayToCommaDelimitedString(indices.get()), message.getClass().getSimpleName());, +            }, +        if (events.contains(AUTHENTICATION_FAILED) && filterPolicyPredicate.test(AuditEventMetaInfo.EMPTY) == false) {, +                logger.info("{}[rest] [authentication_failed]\t{}, uri=[{}]", localNodeInfo.prefix, hostAttributes(request), request.uri());, +            final Optional<String[]> indices = indices(message);, +            if (filterPolicyPredicate.test(new AuditEventMetaInfo(Optional.empty(), Optional.empty(), indices)) == false) {, +                if (indices.isPresent()) {, +                            originAttributes(threadContext, message, localNodeInfo), action, arrayToCommaDelimitedString(indices.get()),, +                            message.getClass().getSimpleName());, +    }, +        if (events.contains(AUTHENTICATION_FAILED), +                && filterPolicyPredicate.test(new AuditEventMetaInfo(Optional.of(token), Optional.empty(), Optional.empty())) == false) {, +                logger.info("{}[rest] [authentication_failed]\t{}, principal=[{}], uri=[{}]", localNodeInfo.prefix, hostAttributes(request),, +                        token.principal(), request.uri());, +            final Optional<String[]> indices = indices(message);, +            if (filterPolicyPredicate.test(new AuditEventMetaInfo(Optional.of(token), Optional.of(realm), indices)) == false) {, +                if (indices.isPresent()) {, +                    logger.info(, +                            "{}[transport] [realm_authentication_failed]\trealm=[{}], {}, principal=[{}], action=[{}], indices=[{}], ", +                                    + "request=[{}]",, +                            localNodeInfo.prefix, realm, originAttributes(threadContext, message, localNodeInfo), token.principal(), action,, +                            arrayToCommaDelimitedString(indices.get()), message.getClass().getSimpleName());, +    }, +        if (events.contains(REALM_AUTHENTICATION_FAILED), +                && filterPolicyPredicate.test(new AuditEventMetaInfo(Optional.of(token), Optional.of(realm), Optional.empty())) == false) {, +                logger.info("{}[rest] [realm_authentication_failed]\trealm=[{}], {}, principal=[{}], uri=[{}]", localNodeInfo.prefix, realm,, +                        hostAttributes(request), token.principal(), request.uri());, +        if ((isSystem && events.contains(SYSTEM_ACCESS_GRANTED)) || (isSystem == false && events.contains(ACCESS_GRANTED))) {, +            final Optional<String[]> indices = indices(message);, +            if (filterPolicyPredicate, +                    .test(new AuditEventMetaInfo(Optional.of(user), Optional.empty(), Optional.of(roleNames), indices)) == false) {, +                if (indices.isPresent()) {, +                            arrayToCommaDelimitedString(roleNames), action, arrayToCommaDelimitedString(indices.get()),, +                            message.getClass().getSimpleName());, +                            originAttributes(threadContext, message, localNodeInfo), principal(user),, +                            arrayToCommaDelimitedString(roleNames), action, message.getClass().getSimpleName());, +                }, +            final Optional<String[]> indices = indices(message);, +            if (filterPolicyPredicate, +                    .test(new AuditEventMetaInfo(Optional.of(user), Optional.empty(), Optional.of(roleNames), indices)) == false) {, +                if (indices.isPresent()) {, +                            arrayToCommaDelimitedString(roleNames), action, arrayToCommaDelimitedString(indices.get()),, +                            message.getClass().getSimpleName());, +                            originAttributes(threadContext, message, localNodeInfo), principal(user),, +                            arrayToCommaDelimitedString(roleNames), action, message.getClass().getSimpleName());, +                }, +        if (events.contains(TAMPERED_REQUEST) && filterPolicyPredicate.test(AuditEventMetaInfo.EMPTY) == false) {, +                logger.info("{}[rest] [tampered_request]\t{}, uri=[{}], request_body=[{}]", localNodeInfo.prefix, hostAttributes(request),, +                        request.uri(), restRequestContent(request));]