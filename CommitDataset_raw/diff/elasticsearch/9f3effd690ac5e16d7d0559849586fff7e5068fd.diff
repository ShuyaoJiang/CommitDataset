[+++ b/x-pack/plugin/watcher/src/main/java/org/elasticsearch/xpack/watcher/trigger/schedule/tool/CronEvalTool.java, +import org.elasticsearch.cli.UserException;, +import java.util.Arrays;, +import java.util.List;, +import java.util.Locale;, +import java.util.TimeZone;, +, +    private static final DateTimeFormatter UTC_FORMATTER = DateTimeFormat.forPattern("EEE, d MMM yyyy HH:mm:ss"), +        .withZone(DateTimeZone.UTC).withLocale(Locale.ROOT);, +    private static final DateTimeFormatter LOCAL_FORMATTER = DateTimeFormat.forPattern("EEE, d MMM yyyy HH:mm:ss Z"), +        .withZone(DateTimeZone.forTimeZone(TimeZone.getDefault()));, +    private final OptionSpec<Integer> countOption;, +            .withRequiredArg().ofType(Integer.class).defaultsTo(10);, +        int count = countOption.value(options);, +        final DateTime date = DateTime.now(DateTimeZone.UTC);, +        final boolean isLocalTimeUTC = UTC_FORMATTER.getZone().equals(LOCAL_FORMATTER.getZone());, +        if (isLocalTimeUTC) {, +            terminal.println("Now is [" + UTC_FORMATTER.print(date) + "] in UTC");, +        } else {, +            terminal.println("Now is [" + UTC_FORMATTER.print(date) + "] in UTC, local time is [" + LOCAL_FORMATTER.print(date) + "]");, +, +        }, +                            + UTC_FORMATTER.print(prevTime) + "] " + "(perhaps the cron expression only points to times in the past?)");, +, +            if (isLocalTimeUTC) {, +                terminal.println((i + 1) + ".\t" + UTC_FORMATTER.print(time));, +            } else {, +                terminal.println((i + 1) + ".\t" + UTC_FORMATTER.print(time));, +                terminal.println("\t" + LOCAL_FORMATTER.print(time));, +            }, +++ b/x-pack/plugin/watcher/src/main/java/org/elasticsearch/xpack/watcher/trigger/schedule/tool/CronEvalTool.java, +import org.elasticsearch.cli.UserException;, +import java.util.Arrays;, +import java.util.List;, +import java.util.Locale;, +import java.util.TimeZone;, +, +    private static final DateTimeFormatter UTC_FORMATTER = DateTimeFormat.forPattern("EEE, d MMM yyyy HH:mm:ss"), +        .withZone(DateTimeZone.UTC).withLocale(Locale.ROOT);, +    private static final DateTimeFormatter LOCAL_FORMATTER = DateTimeFormat.forPattern("EEE, d MMM yyyy HH:mm:ss Z"), +        .withZone(DateTimeZone.forTimeZone(TimeZone.getDefault()));, +    private final OptionSpec<Integer> countOption;, +            .withRequiredArg().ofType(Integer.class).defaultsTo(10);, +        int count = countOption.value(options);, +        final DateTime date = DateTime.now(DateTimeZone.UTC);, +        final boolean isLocalTimeUTC = UTC_FORMATTER.getZone().equals(LOCAL_FORMATTER.getZone());, +        if (isLocalTimeUTC) {, +            terminal.println("Now is [" + UTC_FORMATTER.print(date) + "] in UTC");, +        } else {, +            terminal.println("Now is [" + UTC_FORMATTER.print(date) + "] in UTC, local time is [" + LOCAL_FORMATTER.print(date) + "]");, +, +        }, +                            + UTC_FORMATTER.print(prevTime) + "] " + "(perhaps the cron expression only points to times in the past?)");, +, +            if (isLocalTimeUTC) {, +                terminal.println((i + 1) + ".\t" + UTC_FORMATTER.print(time));, +            } else {, +                terminal.println((i + 1) + ".\t" + UTC_FORMATTER.print(time));, +                terminal.println("\t" + LOCAL_FORMATTER.print(time));, +            }, +++ b/x-pack/plugin/watcher/src/test/java/org/elasticsearch/xpack/watcher/trigger/schedule/tool/CronEvalToolTests.java, +import org.joda.time.DateTimeZone;, +import java.util.Arrays;, +import static org.hamcrest.Matchers.is;, +, +, +    // randomized testing sets arbitrary locales and timezones, and we do not care, +    // we always have to output in standard locale and independent from timezone, +    public void testEnsureDateIsShownInRootLocale() throws Exception {, +        String output = execute("-c","1", "0 0 11 ? * MON-SAT 2040");, +        if (TimeZone.getDefault().equals(DateTimeZone.UTC.toTimeZone())) {, +            assertThat(output, not(containsString("local time is")));, +            long linesStartingWithOne = Arrays.stream(output.split("\n")).filter(s -> s.startsWith("\t")).count();, +            assertThat(linesStartingWithOne, is(0L));, +        } else {, +            // check for header line, +            assertThat(output, containsString("] in UTC, local time is"));, +            assertThat(output, containsString("Mon, 2 Jan 2040 11:00:00"));, +            logger.info(output);, +            long linesStartingWithOne = Arrays.stream(output.split("\n")).filter(s -> s.startsWith("\t")).count();, +            assertThat(linesStartingWithOne, is(1L));, +        }, +    }]