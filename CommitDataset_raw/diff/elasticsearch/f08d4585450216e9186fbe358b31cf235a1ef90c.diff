[+++ b/src/main/java/org/elasticsearch/common/geo/GeoUtils.java, +import org.apache.lucene.spatial.prefix.tree.GeohashPrefixTree;, +import org.apache.lucene.spatial.prefix.tree.QuadPrefixTree;, +import org.elasticsearch.common.unit.DistanceUnit;, +, +    /** Earth ellipsoid major axis defined by WGS 84 in meters */, +    public static final double EARTH_SEMI_MAJOR_AXIS = 6378137.0;      // meters (WGS 84), +, +    /** Earth ellipsoid minor axis defined by WGS 84 in meters */, +    public static final double EARTH_SEMI_MINOR_AXIS = 6356752.314245; // meters (WGS 84), +    , +    /** Earth ellipsoid equator length in meters */, +    public static final double EARTH_EQUATOR = 2*Math.PI * EARTH_SEMI_MAJOR_AXIS;, +, +    /** Earth ellipsoid polar distance in meters */, +    public static final double EARTH_POLAR_DISTANCE = Math.PI * EARTH_SEMI_MINOR_AXIS;, +    , +    /**, +     * Calculate the width (in meters) of geohash cells at a specific level , +     * @param level geohash level must be greater or equal to zero , +     * @return the width of cells at level in meters  , +     */, +    public static double geoHashCellWidth(int level) {, +        assert level>=0;, +        // Geohash cells are split into 32 cells at each level. the grid, +        // alternates at each level between a 8x4 and a 4x8 grid , +        return EARTH_EQUATOR / (1L<<((((level+1)/2)*3) + ((level/2)*2)));, +    }, +, +    /**, +     * Calculate the width (in meters) of quadtree cells at a specific level , +     * @param level quadtree level must be greater or equal to zero , +     * @return the width of cells at level in meters  , +     */, +    public static double quadTreeCellWidth(int level) {, +        assert level >=0;, +        return EARTH_EQUATOR / (1L<<level);, +    }, +    , +    /**, +     * Calculate the height (in meters) of geohash cells at a specific level , +     * @param level geohash level must be greater or equal to zero , +     * @return the height of cells at level in meters  , +     */, +    public static double geoHashCellHeight(int level) {, +        assert level>=0;, +        // Geohash cells are split into 32 cells at each level. the grid, +        // alternates at each level between a 8x4 and a 4x8 grid , +        return EARTH_POLAR_DISTANCE / (1L<<((((level+1)/2)*2) + ((level/2)*3)));, +    }, +    , +    /**, +     * Calculate the height (in meters) of quadtree cells at a specific level , +     * @param level quadtree level must be greater or equal to zero , +     * @return the height of cells at level in meters  , +     */, +    public static double quadTreeCellHeight(int level) {, +        assert level>=0;, +        return EARTH_POLAR_DISTANCE / (1L<<level);, +    }, +    , +    /**, +     * Calculate the size (in meters) of geohash cells at a specific level , +     * @param level geohash level must be greater or equal to zero , +     * @return the size of cells at level in meters  , +     */, +    public static double geoHashCellSize(int level) {, +        assert level>=0;, +        final double w = geoHashCellWidth(level);, +        final double h = geoHashCellHeight(level);, +        return Math.sqrt(w*w + h*h);, +    }, +, +    /**, +     * Calculate the size (in meters) of quadtree cells at a specific level , +     * @param level quadtree level must be greater or equal to zero , +     * @return the size of cells at level in meters  , +     */, +    public static double quadTreeCellSize(int level) {, +        assert level>=0;, +        return Math.sqrt(EARTH_POLAR_DISTANCE*EARTH_POLAR_DISTANCE + EARTH_EQUATOR*EARTH_EQUATOR) / (1L<<level);, +    }, +    , +    /**, +     * Calculate the number of levels needed for a specific precision. Quadtree, +     * cells will not exceed the specified size (diagonal) of the precision., +     * @param meters Maximum size of cells in meters (must greater than zero), +     * @return levels need to achieve precision  , +     */, +    public static int quadTreeLevelsForPrecision(double meters) {, +        assert meters >= 0;, +        if(meters == 0) {, +            return QuadPrefixTree.MAX_LEVELS_POSSIBLE;, +        } else {, +            final double ratio = 1+(EARTH_POLAR_DISTANCE / EARTH_EQUATOR); // cell ratio, +            final double width = Math.sqrt((meters*meters)/(ratio*ratio)); // convert to cell width, +            final long part = Math.round(Math.ceil(EARTH_EQUATOR / width));, +            final int level = Long.SIZE - Long.numberOfLeadingZeros(part)-1; // (log_2), +            return (part<=(1l<<level)) ?level :(level+1); // adjust level, +        }]