[+++ b/test/framework/src/main/java/org/elasticsearch/test/InternalTestCluster.java, +    private static final Predicate<NodeAndClient> DATA_NODE_PREDICATE =, +        nodeAndClient -> DiscoveryNode.isDataNode(nodeAndClient.node.settings());, +, +    private static final Predicate<NodeAndClient> NO_DATA_NO_MASTER_PREDICATE = nodeAndClient ->, +        DiscoveryNode.isMasterNode(nodeAndClient.node.settings()) == false, +            && DiscoveryNode.isDataNode(nodeAndClient.node.settings()) == false;, +, +    private static final Predicate<NodeAndClient> MASTER_NODE_PREDICATE =, +        nodeAndClient -> DiscoveryNode.isMasterNode(nodeAndClient.node.settings());, +, +    /* Sorted map to make traverse order reproducible., +     * The map of nodes is never mutated so individual reads are safe without synchronization., +     * Updates are intended to follow a copy-on-write approach. */, +    private volatile NavigableMap<String, NodeAndClient> nodes = Collections.emptyNavigableMap();, +    private final AtomicInteger nextNodeId = new AtomicInteger(0);, +    private final Function<Client, Client> clientWrapper;, +    private static Settings getRandomNodeSettings(long seed) {, +    private NodeAndClient getOrBuildRandomNode() {, +        assert Thread.holdsLock(this);, +    private NodeAndClient getRandomNodeAndClient() {, +                        .filter(DATA_NODE_PREDICATE.and(new NodeNamePredicate(getMasterName()).negate()));, +    private synchronized NodeAndClient buildNode(int nodeId, Settings settings,, +        final NodeAndClient nodeAndClient = nodes.get(name);, +        if (reuseExisting && nodeAndClient != null) {, +            return nodeAndClient;, +        assert reuseExisting == true || nodeAndClient == null : "node name [" + name + "] already exists but not allowed to use it";, +    private static String getRoleSuffix(Settings settings) {, +    public Client dataNodeClient() {, +        return getRandomNodeAndClient(DATA_NODE_PREDICATE).client(random);, +    public Client masterClient() {, +        throw new AssertionError("No master client found");, +    public Client nonMasterClient() {, +        throw new AssertionError("No non-master client found");, +        NodeAndClient randomNodeAndClient = getRandomNodeAndClient(NO_DATA_NO_MASTER_PREDICATE);, +        return getRandomNodeAndClient(NO_DATA_NO_MASTER_PREDICATE).client(random);, +    public Client client(String nodeName) {, +        throw new AssertionError("No node found with name: [" + nodeName + "]");, +    public Client smartClient() {, +        throw new AssertionError("No smart client found");, +                nodes = Collections.emptyNavigableMap();, +    private static final int REMOVED_MINIMUM_MASTER_NODES = Integer.MAX_VALUE;, +            markNodeDataDirsAsNotEligibleForWipe(node);, +            synchronized (InternalTestCluster.this) {, +                if (closed.get()) {, +                    throw new RuntimeException("already closed");, +                }, +        }, +            synchronized (InternalTestCluster.this) {, +                if (closed.get()) {, +                    throw new RuntimeException("already closed");, +                }, +                    transportClient = new TransportClientFactory(nodeConfigurationSource.transportClientSettings(),, +        }, +            markNodeDataDirsAsNotEligibleForWipe(node);, +            assert Thread.holdsLock(InternalTestCluster.this);, +, +        private void markNodeDataDirsAsPendingForWipe(Node node) {, +            assert Thread.holdsLock(InternalTestCluster.this);, +            NodeEnvironment nodeEnv = node.getNodeEnvironment();, +            if (nodeEnv.hasNodeFile()) {, +                dataDirToClean.addAll(Arrays.asList(nodeEnv.nodeDataPaths()));, +            }, +        }, +, +        private void markNodeDataDirsAsNotEligibleForWipe(Node node) {, +            assert Thread.holdsLock(InternalTestCluster.this);, +            NodeEnvironment nodeEnv = node.getNodeEnvironment();, +            if (nodeEnv.hasNodeFile()) {, +                dataDirToClean.removeAll(Arrays.asList(nodeEnv.nodeDataPaths()));, +            }, +        }, +    private static class TransportClientFactory {, +        TransportClientFactory(Settings settings, Path baseDir, Collection<Class<? extends Plugin>> plugins) {, +                .put(ClusterName.CLUSTER_NAME_SETTING.getKey(), clusterName).put("client.transport.sniff", false), +        for (NodeAndClient nodeAndClient : nodes.values()) {, +    private synchronized void validateClusterFormed(String viaNode) {, +    public synchronized void afterTest() {, +            for (NodeAndClient nodeAndClient : nodes.values()) {, +                                    String.join("\n --> ", operations), +            for (NodeAndClient nodeAndClient : nodes.values()) {, +            for (NodeAndClient nodeAndClient : nodes.values()) {, +        for (NodeAndClient nodeAndClient : nodes.values()) {, +        assert Thread.holdsLock(this);, +    public ClusterService clusterService(@Nullable String node) {, +    public <T> Iterable<T> getInstances(Class<T> clazz) {, +        return nodes.values().stream().map(node -> getInstanceFromNode(clazz, node.node)).collect(Collectors.toList());, +    public <T> Iterable<T> getDataNodeInstances(Class<T> clazz) {, +        return getInstances(clazz, DATA_NODE_PREDICATE);, +    public <T> Iterable<T> getDataOrMasterNodeInstances(Class<T> clazz) {, +        return getInstances(clazz, DATA_NODE_PREDICATE.or(MASTER_NODE_PREDICATE));, +    private <T> Iterable<T> getInstances(Class<T> clazz, Predicate<NodeAndClient> predicate) {, +    public <T> T getInstance(Class<T> clazz, final String node) {, +    public <T> T getDataNodeInstance(Class<T> clazz) {, +        return getInstance(clazz, DATA_NODE_PREDICATE);, +    public <T> T getMasterNodeInstance(Class<T> clazz) {, +        return getInstance(clazz, MASTER_NODE_PREDICATE);, +    public <T> T getInstance(Class<T> clazz) {, +    private static <T> T getInstanceFromNode(Class<T> clazz, Node node) {, +    public int size() {]