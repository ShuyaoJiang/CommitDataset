[+++ b/src/main/java/org/elasticsearch/indices/recovery/RecoverySource.java, +                                try (final IndexInput indexInput = store.directory().openInput(name, IOContext.READONCE)) {, +                                    final byte[] buf = new byte[BUFFER_SIZE];, +++ b/src/main/java/org/elasticsearch/indices/recovery/RecoverySource.java, +                                try (final IndexInput indexInput = store.directory().openInput(name, IOContext.READONCE)) {, +                                    final byte[] buf = new byte[BUFFER_SIZE];, +++ b/src/main/java/org/elasticsearch/transport/TransportService.java, +import java.util.concurrent.atomic.AtomicBoolean;, +    private final AtomicBoolean started = new AtomicBoolean(false);, +        boolean setStarted = started.compareAndSet(false, true);, +        assert setStarted : "service was already started";, +        final boolean setStopped = started.compareAndSet(true, false);, +        assert setStopped : "service has already been stopped";, +            clientHandlers.put(requestId, new RequestHolder<>(handler, node, action, timeoutHandler));, +            if (started.get() == false) {, +                // if we are not started the exception handling will remove the RequestHolder again and calls the handler to notify the caller., +                // it will only notify if the toStop code hasn't done the work yet., +                throw new TransportException("TransportService is closed stopped can't send request");, +            }]