[+++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/LambdaBootstrap.java, +import static org.elasticsearch.painless.WriterConstants.CTOR_METHOD_NAME;, + *         private $$Lambda0(List arg$0) {, + *         public static Consumer create$lambda(List arg$0) {, + *             return new $$Lambda0(arg$0);, + *         }, + *, + * changing values other than the arguments, the lambda is a singleton., + * If there are captures, a new instance of the generated lambda class, + * will be returned each time with the captures passed into the, + * Instead of calling the ctor, a static factory method is created, + * in the lambda class, because a method handle to the ctor directly, + * is (currently) preventing Hotspot optimizer from correctly doing, + * escape analysis. Escape analysis is important to optimize the, + * code in a way, that a new instance is not created on each lambda, + * invocation with captures, stressing garbage collector (thanks, + * to Rémi Forax for the explanation about this on Jaxcon 2017!)., +     * This method name is used to generate the static factory for capturing lambdas., +     */, +    private static final String LAMBDA_FACTORY_METHOD_NAME = "create$lambda";, +, +    /**, +            assert CTOR_METHOD_NAME.equals(delegateMethodName);, +            generateStaticCtorDelegator(cw, ACC_PRIVATE, DELEGATED_CTOR_WRAPPER_NAME, delegateClassType, delegateMethodType);, +        Method conMeth = new Method(CTOR_METHOD_NAME, conDesc);, +        Method baseConMeth = new Method(CTOR_METHOD_NAME,, +        int modifiers = (captures.length > 0) ? ACC_PRIVATE : ACC_PUBLIC;, +            cw.visitMethod(modifiers, CTOR_METHOD_NAME, conDesc, null, null));, +        , +        // Add a factory method, if lambda takes captures., +        // @uschindler says: I talked with Rémi Forax about this. Technically, a plain ctor, +        // and a MethodHandle to the ctor would be enough - BUT: Hotspot is unable to, +        // do escape analysis through a MethodHandles.findConstructor generated handle., +        // Because of this we create a factory method. With this factory method, the, +        // escape analysis can figure out that everything is final and we don't need, +        // an instance, so it can omit object creation on heap!, +        if (captures.length > 0) {, +            generateStaticCtorDelegator(cw, ACC_PUBLIC, LAMBDA_FACTORY_METHOD_NAME, lambdaClassType, factoryMethodType);, +        }, +     * Generates a factory method to delegate to constructors., +    private static void generateStaticCtorDelegator(ClassWriter cw, int access, String delegatorMethodName, , +            Type delegateClassType, MethodType delegateMethodType) {, +        Method wrapperMethod = new Method(delegatorMethodName, delegateMethodType.toMethodDescriptorString());, +            new Method(CTOR_METHOD_NAME, delegateMethodType.changeReturnType(void.class).toMethodDescriptorString());, +        int modifiers = access | ACC_STATIC;, +            cw.visitMethod(modifiers, delegatorMethodName, delegateMethodType.toMethodDescriptorString(), null, null));, +     * Generates the interface method that will delegate (call) to the delegate method, +     * with {@code INVOKEDYNAMIC} using the {@link #delegateBootstrap} type converter., +                lookup.findStatic(lambdaClass, LAMBDA_FACTORY_METHOD_NAME, factoryMethodType));, +++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/LambdaBootstrap.java, +import static org.elasticsearch.painless.WriterConstants.CTOR_METHOD_NAME;, + *         private $$Lambda0(List arg$0) {, + *         public static Consumer create$lambda(List arg$0) {, + *             return new $$Lambda0(arg$0);, + *         }, + *, + * changing values other than the arguments, the lambda is a singleton., + * If there are captures, a new instance of the generated lambda class, + * will be returned each time with the captures passed into the, + * Instead of calling the ctor, a static factory method is created, + * in the lambda class, because a method handle to the ctor directly, + * is (currently) preventing Hotspot optimizer from correctly doing, + * escape analysis. Escape analysis is important to optimize the, + * code in a way, that a new instance is not created on each lambda, + * invocation with captures, stressing garbage collector (thanks, + * to Rémi Forax for the explanation about this on Jaxcon 2017!)., +     * This method name is used to generate the static factory for capturing lambdas., +     */, +    private static final String LAMBDA_FACTORY_METHOD_NAME = "create$lambda";, +, +    /**, +            assert CTOR_METHOD_NAME.equals(delegateMethodName);, +            generateStaticCtorDelegator(cw, ACC_PRIVATE, DELEGATED_CTOR_WRAPPER_NAME, delegateClassType, delegateMethodType);, +        Method conMeth = new Method(CTOR_METHOD_NAME, conDesc);, +        Method baseConMeth = new Method(CTOR_METHOD_NAME,, +        int modifiers = (captures.length > 0) ? ACC_PRIVATE : ACC_PUBLIC;, +            cw.visitMethod(modifiers, CTOR_METHOD_NAME, conDesc, null, null));, +        , +        // Add a factory method, if lambda takes captures., +        // @uschindler says: I talked with Rémi Forax about this. Technically, a plain ctor, +        // and a MethodHandle to the ctor would be enough - BUT: Hotspot is unable to, +        // do escape analysis through a MethodHandles.findConstructor generated handle., +        // Because of this we create a factory method. With this factory method, the, +        // escape analysis can figure out that everything is final and we don't need, +        // an instance, so it can omit object creation on heap!, +        if (captures.length > 0) {, +            generateStaticCtorDelegator(cw, ACC_PUBLIC, LAMBDA_FACTORY_METHOD_NAME, lambdaClassType, factoryMethodType);, +        }, +     * Generates a factory method to delegate to constructors., +    private static void generateStaticCtorDelegator(ClassWriter cw, int access, String delegatorMethodName, , +            Type delegateClassType, MethodType delegateMethodType) {, +        Method wrapperMethod = new Method(delegatorMethodName, delegateMethodType.toMethodDescriptorString());, +            new Method(CTOR_METHOD_NAME, delegateMethodType.changeReturnType(void.class).toMethodDescriptorString());, +        int modifiers = access | ACC_STATIC;, +            cw.visitMethod(modifiers, delegatorMethodName, delegateMethodType.toMethodDescriptorString(), null, null));, +     * Generates the interface method that will delegate (call) to the delegate method, +     * with {@code INVOKEDYNAMIC} using the {@link #delegateBootstrap} type converter., +                lookup.findStatic(lambdaClass, LAMBDA_FACTORY_METHOD_NAME, factoryMethodType));, +++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/WriterConstants.java, +    public static final String CTOR_METHOD_NAME = "<init>";]