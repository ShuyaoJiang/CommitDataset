[+++ b/docs/reference/ingest/ingest-node.asciidoc, +| `exclude_keys`   | no        | `null`   | List of keys to exclude from document, +++ b/docs/reference/ingest/ingest-node.asciidoc, +| `exclude_keys`   | no        | `null`   | List of keys to exclude from document, +++ b/modules/ingest-common/src/main/java/org/elasticsearch/ingest/common/KeyValueProcessor.java, +import org.elasticsearch.common.util.set.Sets;, +import java.util.HashSet;, +import java.util.Set;, +    private final Set<String> includeKeys;, +    private final Set<String> excludeKeys;, +    KeyValueProcessor(String tag, String field, String fieldSplit, String valueSplit, Set<String> includeKeys,, +                      Set<String> excludeKeys, String targetField, boolean ignoreMissing) {, +        this.excludeKeys = excludeKeys;, +    Set<String> getIncludeKeys() {, +    Set<String> getExcludeKeys() {, +        return excludeKeys;, +    }, +, +            .filter((p) ->, +                (includeKeys == null || includeKeys.contains(p[0])) &&, +                    (excludeKeys == null || excludeKeys.contains(p[0]) == false)), +            Set<String> includeKeys = null;, +            Set<String> excludeKeys = null;, +            List<String> includeKeysList = ConfigurationUtils.readOptionalList(TYPE, processorTag, config, "include_keys");, +            if (includeKeysList != null) {, +                includeKeys = Collections.unmodifiableSet(Sets.newHashSet(includeKeysList));, +            }, +            List<String> excludeKeysList = ConfigurationUtils.readOptionalList(TYPE, processorTag, config, "exclude_keys");, +            if (excludeKeysList != null) {, +                excludeKeys = Collections.unmodifiableSet(Sets.newHashSet(excludeKeysList));, +            return new KeyValueProcessor(processorTag, field, fieldSplit, valueSplit, includeKeys, excludeKeys, targetField, ignoreMissing);, +++ b/docs/reference/ingest/ingest-node.asciidoc, +| `exclude_keys`   | no        | `null`   | List of keys to exclude from document, +++ b/modules/ingest-common/src/main/java/org/elasticsearch/ingest/common/KeyValueProcessor.java, +import org.elasticsearch.common.util.set.Sets;, +import java.util.HashSet;, +import java.util.Set;, +    private final Set<String> includeKeys;, +    private final Set<String> excludeKeys;, +    KeyValueProcessor(String tag, String field, String fieldSplit, String valueSplit, Set<String> includeKeys,, +                      Set<String> excludeKeys, String targetField, boolean ignoreMissing) {, +        this.excludeKeys = excludeKeys;, +    Set<String> getIncludeKeys() {, +    Set<String> getExcludeKeys() {, +        return excludeKeys;, +    }, +, +            .filter((p) ->, +                (includeKeys == null || includeKeys.contains(p[0])) &&, +                    (excludeKeys == null || excludeKeys.contains(p[0]) == false)), +            Set<String> includeKeys = null;, +            Set<String> excludeKeys = null;, +            List<String> includeKeysList = ConfigurationUtils.readOptionalList(TYPE, processorTag, config, "include_keys");, +            if (includeKeysList != null) {, +                includeKeys = Collections.unmodifiableSet(Sets.newHashSet(includeKeysList));, +            }, +            List<String> excludeKeysList = ConfigurationUtils.readOptionalList(TYPE, processorTag, config, "exclude_keys");, +            if (excludeKeysList != null) {, +                excludeKeys = Collections.unmodifiableSet(Sets.newHashSet(excludeKeysList));, +            return new KeyValueProcessor(processorTag, field, fieldSplit, valueSplit, includeKeys, excludeKeys, targetField, ignoreMissing);, +++ b/modules/ingest-common/src/test/java/org/elasticsearch/ingest/common/KeyValueProcessorFactoryTests.java, +import org.elasticsearch.common.util.set.Sets;, +import java.util.Collections;, +        config.put("exclude_keys", Collections.emptyList());, +        assertThat(processor.getIncludeKeys(), equalTo(Sets.newHashSet("a", "b")));, +        assertThat(processor.getExcludeKeys(), equalTo(Collections.emptySet()));, +++ b/docs/reference/ingest/ingest-node.asciidoc, +| `exclude_keys`   | no        | `null`   | List of keys to exclude from document, +++ b/modules/ingest-common/src/main/java/org/elasticsearch/ingest/common/KeyValueProcessor.java, +import org.elasticsearch.common.util.set.Sets;, +import java.util.HashSet;, +import java.util.Set;, +    private final Set<String> includeKeys;, +    private final Set<String> excludeKeys;, +    KeyValueProcessor(String tag, String field, String fieldSplit, String valueSplit, Set<String> includeKeys,, +                      Set<String> excludeKeys, String targetField, boolean ignoreMissing) {, +        this.excludeKeys = excludeKeys;, +    Set<String> getIncludeKeys() {, +    Set<String> getExcludeKeys() {, +        return excludeKeys;, +    }, +, +            .filter((p) ->, +                (includeKeys == null || includeKeys.contains(p[0])) &&, +                    (excludeKeys == null || excludeKeys.contains(p[0]) == false)), +            Set<String> includeKeys = null;, +            Set<String> excludeKeys = null;, +            List<String> includeKeysList = ConfigurationUtils.readOptionalList(TYPE, processorTag, config, "include_keys");, +            if (includeKeysList != null) {, +                includeKeys = Collections.unmodifiableSet(Sets.newHashSet(includeKeysList));, +            }, +            List<String> excludeKeysList = ConfigurationUtils.readOptionalList(TYPE, processorTag, config, "exclude_keys");, +            if (excludeKeysList != null) {, +                excludeKeys = Collections.unmodifiableSet(Sets.newHashSet(excludeKeysList));, +            return new KeyValueProcessor(processorTag, field, fieldSplit, valueSplit, includeKeys, excludeKeys, targetField, ignoreMissing);, +++ b/modules/ingest-common/src/test/java/org/elasticsearch/ingest/common/KeyValueProcessorFactoryTests.java, +import org.elasticsearch.common.util.set.Sets;, +import java.util.Collections;, +        config.put("exclude_keys", Collections.emptyList());, +        assertThat(processor.getIncludeKeys(), equalTo(Sets.newHashSet("a", "b")));]