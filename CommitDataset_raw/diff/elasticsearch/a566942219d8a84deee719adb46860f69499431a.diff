[+++ b/core/src/main/java/org/elasticsearch/index/engine/Engine.java, +    /**, +     * The sequence number service for this engine., +     *, +     * @return the sequence number service, +     */, +++ b/core/src/main/java/org/elasticsearch/index/engine/Engine.java, +    /**, +     * The sequence number service for this engine., +     *, +     * @return the sequence number service, +     */, +++ b/core/src/main/java/org/elasticsearch/index/engine/InternalEngine.java, +        this(engineConfig, InternalEngine::sequenceNumberService);, +    }, +, +    InternalEngine(, +            final EngineConfig engineConfig,, +            final BiFunction<EngineConfig, SeqNoStats, SequenceNumbersService> seqNoServiceSupplier) {, +                seqNoService = seqNoServiceSupplier.apply(engineConfig, seqNoStats);, +                translog = openTranslog(engineConfig, writer, translogDeletionPolicy, () -> seqNoService.getGlobalCheckpoint());, +            final long localCheckpoint = seqNoService.getLocalCheckpoint();, +                        seqNoService.markSeqNoAsCompleted(operation.seqNo());, +            final long localCheckpoint = seqNoService.getLocalCheckpoint();, +            final long maxSeqNo = seqNoService.getMaxSeqNo();, +                    seqNo = seqNoService.getLocalCheckpoint() + 1 /* the local checkpoint might have advanced so we leap-frog */) {, +                assert seqNo <= seqNoService.getLocalCheckpoint(), +                        : "local checkpoint did not advance; was [" + seqNo + "], now [" + seqNoService.getLocalCheckpoint() + "]";, +    static SequenceNumbersService sequenceNumberService(, +        final EngineConfig engineConfig,, +            engineConfig.getShardId(),, +            engineConfig.getAllocationId(),, +            engineConfig.getIndexSettings(),, +            assert assertOriginPrimarySequenceNumber(seqNo);, +    protected boolean assertOriginPrimarySequenceNumber(final long seqNo) {, +        // sequence number should not be set when operation origin is primary, +        assert seqNo == SequenceNumbers.UNASSIGNED_SEQ_NO, +                : "primary operations must never have an assigned sequence number but was [" + seqNo + "]";, +        return true;, +    }, +, +    private long generateSeqNoForOperation(final Operation operation) {, +        assert operation.origin() == Operation.Origin.PRIMARY;, +        return doGenerateSeqNoForOperation(operation);, +    }, +, +    /**, +     * Generate the sequence number for the specified operation., +     *, +     * @param operation the operation, +     * @return the sequence number, +     */, +    protected long doGenerateSeqNoForOperation(final Operation operation) {, +        return seqNoService.generateSeqNo();, +    }, +                    seqNoService.markSeqNoAsCompleted(indexResult.getSeqNo());, +            assert index.version() == 1L : "can optimize on replicas but incoming version is [" + index.version() + "]";, +                "resolving out of order delivery based on versioning but version type isn't fit for it. got [" + index.versionType() + "]";, +        assert index.origin() == Operation.Origin.PRIMARY : "planing as primary but origin isn't. got " + index.origin();, +                plan = IndexingStrategy.overrideExistingAsIfNotThere(generateSeqNoForOperation(index), 1L);, +                plan = IndexingStrategy.optimizedAppendOnly(generateSeqNoForOperation(index));, +                    generateSeqNoForOperation(index),, +                seqNoService.markSeqNoAsCompleted(deleteResult.getSeqNo());, +        assert delete.origin() != Operation.Origin.PRIMARY : "planing as primary but got " + delete.origin();, +        assert delete.origin() == Operation.Origin.PRIMARY : "planing as primary but got " + delete.origin();, +            plan = DeletionStrategy.processNormally(, +                    currentlyDeleted,, +                    generateSeqNoForOperation(delete),, +                seqNoService.markSeqNoAsCompleted(seqNo);, +            final long localCheckpoint = seqNoService.getLocalCheckpoint();, +                commitData.put(SequenceNumbers.MAX_SEQ_NO, Long.toString(seqNoService.getMaxSeqNo()));, +    public final SequenceNumbersService seqNoService() {, +++ b/core/src/main/java/org/elasticsearch/index/engine/Engine.java, +    /**, +     * The sequence number service for this engine., +     *, +     * @return the sequence number service, +     */, +++ b/core/src/main/java/org/elasticsearch/index/engine/InternalEngine.java, +        this(engineConfig, InternalEngine::sequenceNumberService);, +    }, +, +    InternalEngine(, +            final EngineConfig engineConfig,, +            final BiFunction<EngineConfig, SeqNoStats, SequenceNumbersService> seqNoServiceSupplier) {, +                seqNoService = seqNoServiceSupplier.apply(engineConfig, seqNoStats);, +                translog = openTranslog(engineConfig, writer, translogDeletionPolicy, () -> seqNoService.getGlobalCheckpoint());, +            final long localCheckpoint = seqNoService.getLocalCheckpoint();, +                        seqNoService.markSeqNoAsCompleted(operation.seqNo());, +            final long localCheckpoint = seqNoService.getLocalCheckpoint();, +            final long maxSeqNo = seqNoService.getMaxSeqNo();, +                    seqNo = seqNoService.getLocalCheckpoint() + 1 /* the local checkpoint might have advanced so we leap-frog */) {, +                assert seqNo <= seqNoService.getLocalCheckpoint(), +                        : "local checkpoint did not advance; was [" + seqNo + "], now [" + seqNoService.getLocalCheckpoint() + "]";, +    static SequenceNumbersService sequenceNumberService(, +        final EngineConfig engineConfig,, +            engineConfig.getShardId(),, +            engineConfig.getAllocationId(),, +            engineConfig.getIndexSettings(),, +            assert assertOriginPrimarySequenceNumber(seqNo);]