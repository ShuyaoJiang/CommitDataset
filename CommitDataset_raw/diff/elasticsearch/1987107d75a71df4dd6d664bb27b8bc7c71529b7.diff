[+++ b/core/src/main/java/org/elasticsearch/action/admin/cluster/allocation/ClusterAllocationExplanation.java, +import org.elasticsearch.ExceptionsHelper;, +import org.elasticsearch.action.admin.indices.shards.IndicesShardStoresResponse;, +import org.elasticsearch.index.shard.ShardStateMetaData;, +import java.util.ArrayList;, +import java.util.HashSet;, +import java.util.List;, +import java.util.Set;, +    private final List<IndicesShardStoresResponse.StoreStatus> shardStores;, +    private final Set<String> activeAllocationIds;, +, +    private Map<DiscoveryNode, IndicesShardStoresResponse.StoreStatus> nodeStoreStatus = null;, +                                        Map<DiscoveryNode, Float> nodeWeights, long remainingDelayNanos,, +                                        List<IndicesShardStoresResponse.StoreStatus> shardStores, Set<String> activeAllocationIds) {, +        this.shardStores = shardStores;, +        this.activeAllocationIds = activeAllocationIds;, +        size = in.readVInt();, +        List<IndicesShardStoresResponse.StoreStatus> stores = new ArrayList<>(size);, +        for (int i = 0; i < size; i++) {, +            stores.add(IndicesShardStoresResponse.StoreStatus.readStoreStatus(in));, +        this.shardStores = stores;, +        size = in.readVInt();, +        Set<String> activeIds = new HashSet<>(size);, +        for (int i = 0; i < size; i++) {, +            activeIds.add(in.readString());, +        this.activeAllocationIds = activeIds;, +    /** Return a map of {@code DiscoveryNode} to store status for the explained shard */, +    public Map<DiscoveryNode, IndicesShardStoresResponse.StoreStatus> getNodeStoreStatus() {, +        if (nodeStoreStatus == null) {, +            Map<DiscoveryNode, IndicesShardStoresResponse.StoreStatus> nodeToStatus = new HashMap<>(shardStores.size());, +            for (IndicesShardStoresResponse.StoreStatus status : shardStores) {, +                nodeToStatus.put(status.getNode(), status);, +            }, +            nodeStoreStatus = nodeToStatus;, +        }, +        return nodeStoreStatus;, +    }, +, +    /** Return a set of the active allocation ids for this shard */, +    public Set<String> getActiveAllocationIds() {, +        return this.activeAllocationIds;, +    }, +, +                    String finalDecision = node.getId().equals(assignedNodeId) ? "CURRENTLY_ASSIGNED" : d.type().toString();, +                    IndicesShardStoresResponse.StoreStatus storeStatus = getNodeStoreStatus().get(node);, +                    builder.startObject("store"); {, +                        if (storeStatus != null) {, +                            final Throwable storeErr = storeStatus.getStoreException();, +                            if (storeErr != null) {, +                                builder.field("store_exception", ExceptionsHelper.detailedMessage(storeErr));, +                                // Cannot allocate, final decision is "STORE_ERROR", +                                finalDecision = "STORE_ERROR";, +                            if (activeAllocationIds.isEmpty() || activeAllocationIds.contains(storeStatus.getAllocationId())) {, +                                // If either we don't have allocation IDs, or they contain the store allocation id, show the allocation, +                                // status, +                                builder.field("shard_copy", storeStatus.getAllocationStatus());, +                            } else{, +                                // Otherwise, this is a stale copy of the data (allocation ids don't match), +                                builder.field("shard_copy", "STALE_COPY");, +                                // Cannot allocate, final decision is "STORE_STALE", +                                finalDecision = "STORE_STALE";, +                            }, +                        }, +                    }, +                    builder.endObject(); // end store, +                    builder.field("final_decision", finalDecision);, +, +    @Override, +    public void writeTo(StreamOutput out) throws IOException {, +        this.getShard().writeTo(out);, +        out.writeBoolean(this.isPrimary());, +        out.writeOptionalString(this.getAssignedNodeId());, +        out.writeOptionalWriteable(this.getUnassignedInfo());, +, +        Map<DiscoveryNode, Decision> ntd = this.getNodeDecisions();, +        out.writeVInt(ntd.size());, +        for (Map.Entry<DiscoveryNode, Decision> entry : ntd.entrySet()) {, +            entry.getKey().writeTo(out);, +            Decision.writeTo(entry.getValue(), out);, +        }, +        Map<DiscoveryNode, Float> ntw = this.getNodeWeights();, +        out.writeVInt(ntw.size());, +        for (Map.Entry<DiscoveryNode, Float> entry : ntw.entrySet()) {, +            entry.getKey().writeTo(out);, +            out.writeFloat(entry.getValue());, +        }, +        out.writeVLong(remainingDelayNanos);, +        out.writeVInt(shardStores.size());, +        for (IndicesShardStoresResponse.StoreStatus status : shardStores) {, +            status.writeTo(out);, +        }, +        out.writeVInt(activeAllocationIds.size());, +        for (String id : activeAllocationIds) {, +            out.writeString(id);, +        }, +    }, +++ b/core/src/main/java/org/elasticsearch/action/admin/cluster/allocation/ClusterAllocationExplanation.java, +import org.elasticsearch.ExceptionsHelper;, +import org.elasticsearch.action.admin.indices.shards.IndicesShardStoresResponse;, +import org.elasticsearch.index.shard.ShardStateMetaData;]