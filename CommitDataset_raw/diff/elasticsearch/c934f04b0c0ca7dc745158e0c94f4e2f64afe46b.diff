[+++ b/modules/elasticsearch/src/main/java/org/elasticsearch/common/lucene/docset/SlicedOpenBitSet.java, +/*, + * Licensed to Elastic Search and Shay Banon under one, + * or more contributor license agreements.  See the NOTICE file, + * distributed with this work for additional information, + * regarding copyright ownership. Elastic Search licenses this, + * file to you under the Apache License, Version 2.0 (the, + * "License"); you may not use this file except in compliance, + * with the License.  You may obtain a copy of the License at, + *, + *    http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing,, + * software distributed under the License is distributed on an, + * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY, + * KIND, either express or implied.  See the License for the, + * specific language governing permissions and limitations, + * under the License., + */, +, +package org.elasticsearch.common.lucene.docset;, +, +import org.apache.lucene.search.DocIdSetIterator;, +import org.apache.lucene.util.BitUtil;, +import org.elasticsearch.common.RamUsage;, +, +import java.io.IOException;, +, +/**, + * Derived from {@link org.apache.lucene.util.OpenBitSet} but works from a slice out of a provided long[] array., + * It does not expand, as it assumes that the slice is from a cached long[] array, so we can't really expand..., + */, +public class SlicedOpenBitSet extends DocSet {, +, +    private final long[] bits;, +    private final int wlen;   // number of words (elements) used in the array, +    private final int from; // the from index in the array, +, +    public SlicedOpenBitSet(long[] bits, int wlen, int from) {, +        this.bits = bits;, +        this.wlen = wlen;, +        this.from = from;, +    }, +, +    @Override public boolean isCacheable() {, +        return true;, +    }, +, +    @Override public long sizeInBytes() {, +        return wlen * RamUsage.NUM_BYTES_LONG + RamUsage.NUM_BYTES_ARRAY_HEADER + RamUsage.NUM_BYTES_INT /* wlen */;, +    }, +, +    /**, +     * Returns the current capacity in bits (1 greater than the index of the last bit), +     */, +    public long capacity() {, +        return (bits.length - from) << 6;, +    }, +, +    /**, +     * Returns the current capacity of this set.  Included for, +     * compatibility.  This is *not* equal to {@link #cardinality}, +     */, +    public long size() {, +        return capacity();, +    }, +, +    /**, +     * @return the number of set bits, +     */, +    public long cardinality() {, +        return BitUtil.pop_array(bits, from, wlen);, +    }, +, +    /**, +     * Returns true or false for the specified bit index., +     */, +    public boolean get(int index) {, +        return fastGet(index);, +//        int i = index >> 6;               // div 64, +//        // signed shift will keep a negative index and force an, +//        // array-index-out-of-bounds-exception, removing the need for an explicit check., +//        if (from + i >= wlen) return false;, +//, +//        int bit = index & 0x3f;           // mod 64, +//        long bitmask = 1L << bit;, +//        return (bits[from + i] & bitmask) != 0;, +    }, +, +    /**, +     * Returns true or false for the specified bit index., +     * The index should be less than the OpenBitSet size, +     */, +    public boolean fastGet(int index) {, +        int i = index >> 6;               // div 64, +        // signed shift will keep a negative index and force an, +        // array-index-out-of-bounds-exception, removing the need for an explicit check., +        int bit = index & 0x3f;           // mod 64, +        long bitmask = 1L << bit;, +        return (bits[from + i] & bitmask) != 0;]