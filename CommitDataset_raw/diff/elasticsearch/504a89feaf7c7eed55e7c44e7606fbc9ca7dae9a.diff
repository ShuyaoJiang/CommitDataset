[+++ b/docs/reference/modules/discovery/adding-removing-nodes.asciidoc, +voting configuration and will not be reinstated. If it's the active master that, +was removed from the voting configuration, then it will abdicate to another, +master-eligible node that's still in the voting configuration, if such a node, +is available., +++ b/docs/reference/modules/discovery/adding-removing-nodes.asciidoc, +voting configuration and will not be reinstated. If it's the active master that, +was removed from the voting configuration, then it will abdicate to another, +master-eligible node that's still in the voting configuration, if such a node, +is available., +++ b/server/src/main/java/org/elasticsearch/cluster/coordination/Coordinator.java, +    private final Random random;, +        this.random = random;, +    private void abdicateTo(DiscoveryNode newMaster) {, +        assert Thread.holdsLock(mutex);, +        assert mode == Mode.LEADER : "expected to be leader on abdication but was " + mode;, +        assert newMaster.isMasterNode() : "should only abdicate to master-eligible node but was " + newMaster;, +        final StartJoinRequest startJoinRequest = new StartJoinRequest(newMaster, Math.max(getCurrentTerm(), maxTermSeen) + 1);, +        logger.info("abdicating to {} with term {}", newMaster, startJoinRequest.getTerm());, +        getLastAcceptedState().nodes().mastersFirstStream().forEach(node -> {, +            if (isZen1Node(node) == false) {, +                joinHelper.sendStartJoinRequest(startJoinRequest, node);, +            }, +        });, +        // handling of start join messages on the local node will be dispatched to the generic thread-pool, +        assert mode == Mode.LEADER : "should still be leader after sending abdication messages " + mode;, +        // explicitly move node to candidate state so that the next cluster state update task yields an onNoLongerMaster event, +        becomeCandidate("after abdicating to " + newMaster);, +    }, +, +        final DiscoveryNode localNode = lastAcceptedState.nodes().getLocalNode();, +        assert localNode != null;, +        return electionQuorumContains(lastAcceptedState, localNode);, +    }, +, +    private static boolean electionQuorumContains(ClusterState lastAcceptedState, DiscoveryNode node) {, +        final String nodeId = node.getId();, +        return lastAcceptedState.getLastCommittedConfiguration().getNodeIds().contains(nodeId), +            || lastAcceptedState.getLastAcceptedConfiguration().getNodeIds().contains(nodeId);, +            getLocalNode(), clusterState.getLastAcceptedConfiguration());, +                                        final ClusterState state = getLastAcceptedState(); // committed state, +                                        if (electionQuorumContainsLocalNode(state) == false) {, +                                            final List<DiscoveryNode> masterCandidates = completedNodes().stream(), +                                                .filter(DiscoveryNode::isMasterNode), +                                                .filter(node -> electionQuorumContains(state, node)), +                                                .collect(Collectors.toList());, +                                            if (masterCandidates.isEmpty() == false) {, +                                                abdicateTo(masterCandidates.get(random.nextInt(masterCandidates.size())));, +                                            }, +                                        } else {, +                                    }, +++ b/docs/reference/modules/discovery/adding-removing-nodes.asciidoc, +voting configuration and will not be reinstated. If it's the active master that, +was removed from the voting configuration, then it will abdicate to another, +master-eligible node that's still in the voting configuration, if such a node, +is available., +++ b/server/src/main/java/org/elasticsearch/cluster/coordination/Coordinator.java, +    private final Random random;, +        this.random = random;, +    private void abdicateTo(DiscoveryNode newMaster) {, +        assert Thread.holdsLock(mutex);, +        assert mode == Mode.LEADER : "expected to be leader on abdication but was " + mode;, +        assert newMaster.isMasterNode() : "should only abdicate to master-eligible node but was " + newMaster;, +        final StartJoinRequest startJoinRequest = new StartJoinRequest(newMaster, Math.max(getCurrentTerm(), maxTermSeen) + 1);, +        logger.info("abdicating to {} with term {}", newMaster, startJoinRequest.getTerm());, +        getLastAcceptedState().nodes().mastersFirstStream().forEach(node -> {, +            if (isZen1Node(node) == false) {, +                joinHelper.sendStartJoinRequest(startJoinRequest, node);, +            }, +        });, +        // handling of start join messages on the local node will be dispatched to the generic thread-pool, +        assert mode == Mode.LEADER : "should still be leader after sending abdication messages " + mode;, +        // explicitly move node to candidate state so that the next cluster state update task yields an onNoLongerMaster event, +        becomeCandidate("after abdicating to " + newMaster);, +    }, +, +        final DiscoveryNode localNode = lastAcceptedState.nodes().getLocalNode();, +        assert localNode != null;, +        return electionQuorumContains(lastAcceptedState, localNode);, +    }, +, +    private static boolean electionQuorumContains(ClusterState lastAcceptedState, DiscoveryNode node) {, +        final String nodeId = node.getId();, +        return lastAcceptedState.getLastCommittedConfiguration().getNodeIds().contains(nodeId), +            || lastAcceptedState.getLastAcceptedConfiguration().getNodeIds().contains(nodeId);, +            getLocalNode(), clusterState.getLastAcceptedConfiguration());, +                                        final ClusterState state = getLastAcceptedState(); // committed state, +                                        if (electionQuorumContainsLocalNode(state) == false) {, +                                            final List<DiscoveryNode> masterCandidates = completedNodes().stream(), +                                                .filter(DiscoveryNode::isMasterNode), +                                                .filter(node -> electionQuorumContains(state, node)), +                                                .collect(Collectors.toList());, +                                            if (masterCandidates.isEmpty() == false) {, +                                                abdicateTo(masterCandidates.get(random.nextInt(masterCandidates.size())));, +                                            }, +                                        } else {, +                                    }, +++ b/server/src/main/java/org/elasticsearch/cluster/coordination/Publication.java, +import java.util.stream.Collectors;, +    public List<DiscoveryNode> completedNodes() {]