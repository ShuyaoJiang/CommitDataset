[+++ b/plugins/ingest/src/main/java/org/elasticsearch/plugin/ingest/IngestPlugin.java, +    public static final String INGEST_PAREM_CONTEXT_KEY = "__ingest__";, +    public static final String INGEST_ALREADY_PROCESSED = "ingest_already_processed";, +++ b/plugins/ingest/src/main/java/org/elasticsearch/plugin/ingest/IngestPlugin.java, +    public static final String INGEST_PAREM_CONTEXT_KEY = "__ingest__";, +    public static final String INGEST_ALREADY_PROCESSED = "ingest_already_processed";, +++ b/plugins/ingest/src/main/java/org/elasticsearch/plugin/ingest/rest/IngestRestFilter.java, +import static org.elasticsearch.plugin.ingest.IngestPlugin.INGEST_PAREM_CONTEXT_KEY;, +        request.putInContext(INGEST_PAREM_CONTEXT_KEY, request.param(INGEST_PARAM));, +++ b/plugins/ingest/src/main/java/org/elasticsearch/plugin/ingest/IngestPlugin.java, +    public static final String INGEST_PAREM_CONTEXT_KEY = "__ingest__";, +    public static final String INGEST_ALREADY_PROCESSED = "ingest_already_processed";, +++ b/plugins/ingest/src/main/java/org/elasticsearch/plugin/ingest/rest/IngestRestFilter.java, +import static org.elasticsearch.plugin.ingest.IngestPlugin.INGEST_PAREM_CONTEXT_KEY;, +        request.putInContext(INGEST_PAREM_CONTEXT_KEY, request.param(INGEST_PARAM));, +++ b/plugins/ingest/src/main/java/org/elasticsearch/plugin/ingest/transport/IngestActionFilter.java, +        String pipelineId = request.getFromContext(IngestPlugin.INGEST_PAREM_CONTEXT_KEY);, +        // The IndexRequest has the same type on the node that receives the request and the node that, +        // processes the primary action. This could lead to a pipeline being executed twice for the same, +        // index request, hence this check, +        if (indexRequest.hasHeader(IngestPlugin.INGEST_ALREADY_PROCESSED)) {, +            chain.proceed(action, indexRequest, listener);, +            return;, +        }, +, +                indexRequest.putHeader(IngestPlugin.INGEST_ALREADY_PROCESSED, true);, +++ b/plugins/ingest/src/main/java/org/elasticsearch/plugin/ingest/IngestPlugin.java, +    public static final String INGEST_PAREM_CONTEXT_KEY = "__ingest__";, +    public static final String INGEST_ALREADY_PROCESSED = "ingest_already_processed";, +++ b/plugins/ingest/src/main/java/org/elasticsearch/plugin/ingest/rest/IngestRestFilter.java, +import static org.elasticsearch.plugin.ingest.IngestPlugin.INGEST_PAREM_CONTEXT_KEY;, +        request.putInContext(INGEST_PAREM_CONTEXT_KEY, request.param(INGEST_PARAM));, +++ b/plugins/ingest/src/main/java/org/elasticsearch/plugin/ingest/transport/IngestActionFilter.java, +        String pipelineId = request.getFromContext(IngestPlugin.INGEST_PAREM_CONTEXT_KEY);, +        // The IndexRequest has the same type on the node that receives the request and the node that, +        // processes the primary action. This could lead to a pipeline being executed twice for the same, +        // index request, hence this check, +        if (indexRequest.hasHeader(IngestPlugin.INGEST_ALREADY_PROCESSED)) {, +            chain.proceed(action, indexRequest, listener);, +            return;, +        }, +, +                indexRequest.putHeader(IngestPlugin.INGEST_ALREADY_PROCESSED, true);, +++ b/plugins/ingest/src/test/java/org/elasticsearch/plugin/ingest/transport/IngestActionFilterTests.java, +        indexRequest.putInContext(IngestPlugin.INGEST_PAREM_CONTEXT_KEY, "_id");, +    public void testApplyAlreadyProcessed() throws Exception {, +        IndexRequest indexRequest = new IndexRequest("_index", "_type", "_id");, +        indexRequest.source("field", "value");, +        indexRequest.putHeader(IngestPlugin.INGEST_PARAM, "_id");, +        indexRequest.putHeader(IngestPlugin.INGEST_ALREADY_PROCESSED, true);, +        ActionListener actionListener = mock(ActionListener.class);, +        ActionFilterChain actionFilterChain = mock(ActionFilterChain.class);, +, +        filter.apply("_action", indexRequest, actionListener, actionFilterChain);, +, +        verify(actionFilterChain).proceed("_action", indexRequest, actionListener);, +        verifyZeroInteractions(executionService, actionListener);, +    }, +]