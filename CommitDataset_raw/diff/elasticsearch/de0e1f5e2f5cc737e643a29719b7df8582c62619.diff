[+++ b/core/src/main/java/org/elasticsearch/action/support/broadcast/node/TransportBroadcastByNodeAction.java, +            if (logger.isTraceEnabled()) {, +            }, +            if (logger.isTraceEnabled()) {, +            }, +            if (logger.isTraceEnabled()) {, +            }, +                if (logger.isTraceEnabled()) {, +                }, +                if (logger.isTraceEnabled()) {, +                }, +++ b/core/src/main/java/org/elasticsearch/action/support/broadcast/node/TransportBroadcastByNodeAction.java, +            if (logger.isTraceEnabled()) {, +            }, +            if (logger.isTraceEnabled()) {, +            }, +            if (logger.isTraceEnabled()) {, +            }, +                if (logger.isTraceEnabled()) {, +                }, +                if (logger.isTraceEnabled()) {, +                }, +++ b/core/src/main/java/org/elasticsearch/cluster/action/shard/ShardStateAction.java, +import org.elasticsearch.common.util.concurrent.ConcurrentCollections;, +import java.util.concurrent.BlockingQueue;, +    private final BlockingQueue<ShardRoutingEntry> startedShardsQueue = ConcurrentCollections.newBlockingQueue();, +, +                task.processed = true;, +        // buffer shard started requests, and the state update tasks will simply drain it, +        // this is to optimize the number of "started" events we generate, and batch them, +        // possibly, we can do time based batching as well, but usually, we would want to, +        // process started events as fast as possible, to make shards available, +        startedShardsQueue.add(shardRoutingEntry);, +        clusterService.submitStateUpdateTask("shard-started (" + shardRoutingEntry.shardRouting + "), reason [" + shardRoutingEntry.message + "]",, +                new ClusterStateUpdateTask() {, +                    public Priority priority() {, +                        return Priority.URGENT;, +                    @Override, +                    public ClusterState execute(ClusterState currentState) {, +, +                        if (shardRoutingEntry.processed) {, +                            return currentState;, +                        }, +, +                        List<ShardRoutingEntry> shardRoutingEntries = new ArrayList<>();, +                        startedShardsQueue.drainTo(shardRoutingEntries);, +, +                        // nothing to process (a previous event has processed it already), +                        if (shardRoutingEntries.isEmpty()) {, +                            return currentState;, +                        }, +, +                        List<ShardRouting> shardRoutingToBeApplied = new ArrayList<>(shardRoutingEntries.size());, +, +                        // mark all entries as processed, +                        for (ShardRoutingEntry entry : shardRoutingEntries) {, +                            entry.processed = true;, +                            shardRoutingToBeApplied.add(entry.shardRouting);, +                        }, +, +                        if (shardRoutingToBeApplied.isEmpty()) {, +                            return currentState;, +                        }, +, +                        RoutingAllocation.Result routingResult = allocationService.applyStartedShards(currentState, shardRoutingToBeApplied, true);, +                        if (!routingResult.changed()) {, +                            return currentState;, +                        }, +                        return ClusterState.builder(currentState).routingResult(routingResult).build();, +                });, +        volatile boolean processed; // state field, no need to serialize, +]