[+++ b/docs/reference/indices/get-field-mapping.asciidoc, +`{index}`, `{type}` and `{field}` can stand for comma-separated list of names or wild cards. To, +, +curl -XGET 'http://localhost:9200/_all/tw*/_mapping/field/*.id', +The get mapping api allows you to specify one or more fields separated with by a comma., +You can also use wildcards. The field names can be any of the following:, +++ b/docs/reference/indices/get-field-mapping.asciidoc, +`{index}`, `{type}` and `{field}` can stand for comma-separated list of names or wild cards. To, +, +curl -XGET 'http://localhost:9200/_all/tw*/_mapping/field/*.id', +The get mapping api allows you to specify one or more fields separated with by a comma., +You can also use wildcards. The field names can be any of the following:, +++ b/src/main/java/org/elasticsearch/action/admin/indices/mapping/get/TransportGetFieldMappingsAction.java, +import com.google.common.collect.ImmutableList;, +        ImmutableList<FieldMapper> allFieldMappers = documentMapper.mappers().mappers();, +            if (Regex.isMatchAllPattern(field)) {, +                for (FieldMapper fieldMapper : allFieldMappers) {, +                    addFieldMapper(fieldMapper.names().fullName(), fieldMapper, fieldMappings, includeDefaults);, +                }, +            } else if (Regex.isSimpleMatchPattern(field)) {, +                // go through the field mappers 3 times, to make sure we give preference to the resolve order: full name, index name, name., +                // also make sure we only store each mapper once., +                boolean[] resolved = new boolean[allFieldMappers.size()];, +                for (int i = 0; i < allFieldMappers.size(); i++) {, +                    FieldMapper fieldMapper = allFieldMappers.get(i);, +                    if (Regex.simpleMatch(field, fieldMapper.names().fullName())) {, +                        addFieldMapper(fieldMapper.names().fullName(), fieldMapper, fieldMappings, includeDefaults);, +                        resolved[i] = true;, +                    }, +                }, +                for (int i = 0; i < allFieldMappers.size(); i++) {, +                    if (resolved[i]) {, +                        continue;, +                    }, +                    FieldMapper fieldMapper = allFieldMappers.get(i);, +                    if (Regex.simpleMatch(field, fieldMapper.names().indexName())) {, +                        addFieldMapper(fieldMapper.names().indexName(), fieldMapper, fieldMappings, includeDefaults);, +                        resolved[i] = true;, +                    }, +                }, +                for (int i = 0; i < allFieldMappers.size(); i++) {, +                    if (resolved[i]) {, +                        continue;, +                    }, +                    FieldMapper fieldMapper = allFieldMappers.get(i);, +                    if (Regex.simpleMatch(field, fieldMapper.names().name())) {, +                        addFieldMapper(fieldMapper.names().name(), fieldMapper, fieldMappings, includeDefaults);, +                        resolved[i] = true;, +                    }, +                }, +, +            } else {, +                // not a pattern, +                    addFieldMapper(field, fieldMapper, fieldMappings, includeDefaults);, +                }, +            }, +        }, +        return fieldMappings.immutableMap();, +    }, +, +    private void addFieldMapper(String field, FieldMapper fieldMapper, MapBuilder<String, FieldMappingMetaData> fieldMappings, boolean includeDefaults) {, +        if (fieldMappings.containsKey(field)) {, +            return;, +        }]