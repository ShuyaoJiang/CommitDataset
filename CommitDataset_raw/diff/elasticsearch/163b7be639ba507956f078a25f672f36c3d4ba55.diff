[+++ b/modules/elasticsearch/src/main/java/org/elasticsearch/gateway/Gateway.java, +    void performStateRecovery(GatewayStateRecoveredListener listener) throws GatewayException;, +, +    interface GatewayStateRecoveredListener {, +        void onSuccess();, +, +        void onFailure(Throwable t);, +    }, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/gateway/Gateway.java, +    void performStateRecovery(GatewayStateRecoveredListener listener) throws GatewayException;, +, +    interface GatewayStateRecoveredListener {, +        void onSuccess();, +, +        void onFailure(Throwable t);, +    }, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/gateway/GatewayService.java, +import org.elasticsearch.ElasticSearchInterruptedException;, +    private final AtomicBoolean performedStateRecovery = new AtomicBoolean();, +    @Inject public GatewayService(Settings settings, Gateway gateway, ClusterService clusterService, DiscoveryService discoveryService, ThreadPool threadPool) {, +                } else if (recoverAfterTime != null) {, +                    updateClusterStateBlockedOnNotRecovered();, +                    logger.debug("not recovering from gateway, recover_after_time [{}]", recoverAfterTime);, +                    if (performedStateRecovery.compareAndSet(false, true)) {, +                        performStateRecovery(initialStateTimeout);, +                    if (performedStateRecovery.compareAndSet(false, true)) {, +                        threadPool.cached().execute(new Runnable() {, +                                performStateRecovery(null);, +    private void performStateRecovery(@Nullable TimeValue timeout) {, +        final CountDownLatch latch = new CountDownLatch(1);, +        final Gateway.GatewayStateRecoveredListener recoveryListener = new Gateway.GatewayStateRecoveredListener() {, +            @Override public void onSuccess() {, +                markMetaDataAsReadFromGateway("success");, +                latch.countDown();, +            @Override public void onFailure(Throwable t) {, +                markMetaDataAsReadFromGateway("failure [" + t.getMessage() + "]");, +                latch.countDown();, +        };, +, +            logger.debug("delaying initial state recovery for [{}]", recoverAfterTime);, +                    gateway.performStateRecovery(recoveryListener);, +            gateway.performStateRecovery(recoveryListener);, +, +        if (timeout != null) {, +                latch.await(timeout.millis(), TimeUnit.MILLISECONDS);, +                throw new ElasticSearchInterruptedException(e.getMessage(), e);, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/gateway/Gateway.java, +    void performStateRecovery(GatewayStateRecoveredListener listener) throws GatewayException;, +, +    interface GatewayStateRecoveredListener {, +        void onSuccess();, +, +        void onFailure(Throwable t);, +    }, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/gateway/GatewayService.java, +import org.elasticsearch.ElasticSearchInterruptedException;, +    private final AtomicBoolean performedStateRecovery = new AtomicBoolean();, +    @Inject public GatewayService(Settings settings, Gateway gateway, ClusterService clusterService, DiscoveryService discoveryService, ThreadPool threadPool) {, +                } else if (recoverAfterTime != null) {, +                    updateClusterStateBlockedOnNotRecovered();, +                    logger.debug("not recovering from gateway, recover_after_time [{}]", recoverAfterTime);, +                    if (performedStateRecovery.compareAndSet(false, true)) {, +                        performStateRecovery(initialStateTimeout);, +                    if (performedStateRecovery.compareAndSet(false, true)) {, +                        threadPool.cached().execute(new Runnable() {, +                                performStateRecovery(null);, +    private void performStateRecovery(@Nullable TimeValue timeout) {, +        final CountDownLatch latch = new CountDownLatch(1);, +        final Gateway.GatewayStateRecoveredListener recoveryListener = new Gateway.GatewayStateRecoveredListener() {, +            @Override public void onSuccess() {, +                markMetaDataAsReadFromGateway("success");, +                latch.countDown();, +            @Override public void onFailure(Throwable t) {, +                markMetaDataAsReadFromGateway("failure [" + t.getMessage() + "]");, +                latch.countDown();, +        };, +, +            logger.debug("delaying initial state recovery for [{}]", recoverAfterTime);, +                    gateway.performStateRecovery(recoveryListener);, +            gateway.performStateRecovery(recoveryListener);, +, +        if (timeout != null) {, +                latch.await(timeout.millis(), TimeUnit.MILLISECONDS);, +                throw new ElasticSearchInterruptedException(e.getMessage(), e);, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/gateway/blobstore/BlobStoreGateway.java, +import org.elasticsearch.cluster.ClusterService;, +import org.elasticsearch.cluster.metadata.MetaDataCreateIndexService;, +import org.elasticsearch.gateway.shared.SharedStorageGateway;, +public abstract class BlobStoreGateway extends SharedStorageGateway {, +    protected BlobStoreGateway(Settings settings, ClusterService clusterService, MetaDataCreateIndexService createIndexService) {, +        super(settings, clusterService, createIndexService);, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/gateway/Gateway.java, +    void performStateRecovery(GatewayStateRecoveredListener listener) throws GatewayException;, +, +    interface GatewayStateRecoveredListener {, +        void onSuccess();, +, +        void onFailure(Throwable t);, +    }, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/gateway/GatewayService.java]