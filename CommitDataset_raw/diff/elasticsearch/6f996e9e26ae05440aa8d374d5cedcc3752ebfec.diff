[+++ b/core/src/main/java/org/elasticsearch/action/bulk/TransportShardBulkAction.java, +import org.elasticsearch.action.delete.TransportDeleteAction;, +import org.elasticsearch.action.index.TransportIndexAction;, +                    final WriteResult<DeleteResponse> writeResult = TransportDeleteAction.executeDeleteRequestOnPrimary(deleteRequest, indexShard);, +        processAfterWrite(request.refresh(), indexShard, location);, +    private WriteResult<IndexResponse> shardIndexOperation(BulkShardRequest request, IndexRequest indexRequest, ClusterState clusterState,, +        return TransportIndexAction.executeIndexRequestOnPrimary(indexRequest, indexShard, mappingUpdatedAction);, +                    WriteResult<DeleteResponse> result = TransportDeleteAction.executeDeleteRequestOnPrimary(deleteRequest, indexShard);, +                    Engine.Index operation = TransportIndexAction.executeIndexRequestOnReplica(indexRequest, indexShard);, +                    Engine.Delete delete = TransportDeleteAction.executeDeleteRequestOnReplica(deleteRequest, indexShard);, +        processAfterWrite(request.refresh(), indexShard, location);, +++ b/core/src/main/java/org/elasticsearch/action/bulk/TransportShardBulkAction.java, +import org.elasticsearch.action.delete.TransportDeleteAction;, +import org.elasticsearch.action.index.TransportIndexAction;, +                    final WriteResult<DeleteResponse> writeResult = TransportDeleteAction.executeDeleteRequestOnPrimary(deleteRequest, indexShard);, +        processAfterWrite(request.refresh(), indexShard, location);, +    private WriteResult<IndexResponse> shardIndexOperation(BulkShardRequest request, IndexRequest indexRequest, ClusterState clusterState,, +        return TransportIndexAction.executeIndexRequestOnPrimary(indexRequest, indexShard, mappingUpdatedAction);, +                    WriteResult<DeleteResponse> result = TransportDeleteAction.executeDeleteRequestOnPrimary(deleteRequest, indexShard);, +                    Engine.Index operation = TransportIndexAction.executeIndexRequestOnReplica(indexRequest, indexShard);, +                    Engine.Delete delete = TransportDeleteAction.executeDeleteRequestOnReplica(deleteRequest, indexShard);, +        processAfterWrite(request.refresh(), indexShard, location);, +++ b/core/src/main/java/org/elasticsearch/action/delete/TransportDeleteAction.java, +        final WriteResult<DeleteResponse> result = executeDeleteRequestOnPrimary(request, indexShard);, +        processAfterWrite(request.refresh(), indexShard, result.location);, +        return new Tuple<>(result.response, shardRequest.request);, +    }, +, +    public static WriteResult<DeleteResponse> executeDeleteRequestOnPrimary(DeleteRequest request, IndexShard indexShard) {, +        Engine.Delete delete = indexShard.prepareDeleteOnPrimary(request.type(), request.id(), request.version(), request.versionType());, +        return new WriteResult<>(, +            new DeleteResponse(indexShard.shardId().getIndex(), request.type(), request.id(), delete.version(), delete.found()),, +            delete.getTranslogLocation());, +    public static Engine.Delete executeDeleteRequestOnReplica(DeleteRequest request, IndexShard indexShard) {, +        Engine.Delete delete = indexShard.prepareDeleteOnReplica(request.type(), request.id(), request.version(), request.versionType());, +        indexShard.delete(delete);, +        return delete;, +    }, +, +, +        Engine.Delete delete = executeDeleteRequestOnReplica(request, indexShard);, +        processAfterWrite(request.refresh(), indexShard, delete.getTranslogLocation());, +++ b/core/src/main/java/org/elasticsearch/action/bulk/TransportShardBulkAction.java, +import org.elasticsearch.action.delete.TransportDeleteAction;, +import org.elasticsearch.action.index.TransportIndexAction;, +                    final WriteResult<DeleteResponse> writeResult = TransportDeleteAction.executeDeleteRequestOnPrimary(deleteRequest, indexShard);, +        processAfterWrite(request.refresh(), indexShard, location);, +    private WriteResult<IndexResponse> shardIndexOperation(BulkShardRequest request, IndexRequest indexRequest, ClusterState clusterState,, +        return TransportIndexAction.executeIndexRequestOnPrimary(indexRequest, indexShard, mappingUpdatedAction);, +                    WriteResult<DeleteResponse> result = TransportDeleteAction.executeDeleteRequestOnPrimary(deleteRequest, indexShard);, +                    Engine.Index operation = TransportIndexAction.executeIndexRequestOnReplica(indexRequest, indexShard);, +                    Engine.Delete delete = TransportDeleteAction.executeDeleteRequestOnReplica(deleteRequest, indexShard);, +        processAfterWrite(request.refresh(), indexShard, location);, +++ b/core/src/main/java/org/elasticsearch/action/delete/TransportDeleteAction.java, +        final WriteResult<DeleteResponse> result = executeDeleteRequestOnPrimary(request, indexShard);, +        processAfterWrite(request.refresh(), indexShard, result.location);, +        return new Tuple<>(result.response, shardRequest.request);, +    }, +, +    public static WriteResult<DeleteResponse> executeDeleteRequestOnPrimary(DeleteRequest request, IndexShard indexShard) {, +        Engine.Delete delete = indexShard.prepareDeleteOnPrimary(request.type(), request.id(), request.version(), request.versionType());, +        return new WriteResult<>(, +            new DeleteResponse(indexShard.shardId().getIndex(), request.type(), request.id(), delete.version(), delete.found()),, +            delete.getTranslogLocation());, +    public static Engine.Delete executeDeleteRequestOnReplica(DeleteRequest request, IndexShard indexShard) {, +        Engine.Delete delete = indexShard.prepareDeleteOnReplica(request.type(), request.id(), request.version(), request.versionType());, +        indexShard.delete(delete);, +        return delete;, +    }, +, +, +        Engine.Delete delete = executeDeleteRequestOnReplica(request, indexShard);, +        processAfterWrite(request.refresh(), indexShard, delete.getTranslogLocation());, +++ b/core/src/main/java/org/elasticsearch/action/index/TransportIndexAction.java, +        final WriteResult<IndexResponse> result = executeIndexRequestOnPrimary(request, indexShard, mappingUpdatedAction);, +        processAfterWrite(request.refresh(), indexShard, location);, +        final Engine.Index operation = executeIndexRequestOnReplica(request, indexShard);, +        processAfterWrite(request.refresh(), indexShard, operation.getTranslogLocation());, +    }, +, +    /**, +     * Execute the given {@link IndexRequest} on a replica shard, throwing a, +     * {@link RetryOnReplicaException} if the operation needs to be re-tried., +     */, +    public static Engine.Index executeIndexRequestOnReplica(IndexRequest request, IndexShard indexShard) {, +        final ShardId shardId = indexShard.shardId();, +        final Engine.Index operation = indexShard.prepareIndexOnReplica(sourceToParse, request.version(), request.versionType());, +        return operation;, +    }, +, +    /** Utility method to prepare an index operation on primary shards */, +    public static Engine.Index prepareIndexOperationOnPrimary(IndexRequest request, IndexShard indexShard) {, +        SourceToParse sourceToParse = SourceToParse.source(SourceToParse.Origin.PRIMARY, request.source()).index(request.index()).type(request.type()).id(request.id()), +            .routing(request.routing()).parent(request.parent()).timestamp(request.timestamp()).ttl(request.ttl());, +        return indexShard.prepareIndexOnPrimary(sourceToParse, request.version(), request.versionType());, +    }, +, +    /**, +     * Execute the given {@link IndexRequest} on a primary shard, throwing a, +     * {@link RetryOnPrimaryException} if the operation needs to be re-tried.]