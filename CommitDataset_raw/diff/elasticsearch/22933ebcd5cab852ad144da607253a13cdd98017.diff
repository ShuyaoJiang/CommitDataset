[+++ b/buildSrc/src/main/resources/checkstyle_suppressions.xml, +++ b/buildSrc/src/main/resources/checkstyle_suppressions.xml, +++ b/server/src/main/java/org/elasticsearch/action/admin/cluster/health/TransportClusterHealthAction.java, +        final ClusterStateObserver observer = new ClusterStateObserver(state, clusterService,, +            null, logger, threadPool.getThreadContext());, +    private ClusterHealthResponse getResponse(final ClusterHealthRequest request, ClusterState clusterState,, +                                              final int waitFor, boolean timedOut) {, +++ b/buildSrc/src/main/resources/checkstyle_suppressions.xml, +++ b/server/src/main/java/org/elasticsearch/action/admin/cluster/health/TransportClusterHealthAction.java, +        final ClusterStateObserver observer = new ClusterStateObserver(state, clusterService,, +            null, logger, threadPool.getThreadContext());, +    private ClusterHealthResponse getResponse(final ClusterHealthRequest request, ClusterState clusterState,, +                                              final int waitFor, boolean timedOut) {, +++ b/server/src/main/java/org/elasticsearch/action/admin/cluster/stats/ClusterStatsNodeResponse.java, +    public ClusterStatsNodeResponse(DiscoveryNode node, @Nullable ClusterHealthStatus clusterStatus,, +                                    NodeInfo nodeInfo, NodeStats nodeStats, ShardStats[] shardsStats) {, +++ b/buildSrc/src/main/resources/checkstyle_suppressions.xml, +++ b/server/src/main/java/org/elasticsearch/action/admin/cluster/health/TransportClusterHealthAction.java, +        final ClusterStateObserver observer = new ClusterStateObserver(state, clusterService,, +            null, logger, threadPool.getThreadContext());, +    private ClusterHealthResponse getResponse(final ClusterHealthRequest request, ClusterState clusterState,, +                                              final int waitFor, boolean timedOut) {, +++ b/server/src/main/java/org/elasticsearch/action/admin/cluster/stats/ClusterStatsNodeResponse.java, +    public ClusterStatsNodeResponse(DiscoveryNode node, @Nullable ClusterHealthStatus clusterStatus,, +                                    NodeInfo nodeInfo, NodeStats nodeStats, ShardStats[] shardsStats) {, +++ b/server/src/main/java/org/elasticsearch/action/search/SearchPhaseController.java, +                // make sure we set the shard index before we add it - the consumer didn't do that yet, +                if (td.topDocs.scoreDocs.length > 0) {, +                                        Collection<? extends SearchPhaseResult> fetchResults,, +                                        IntFunction<SearchPhaseResult> resultsLookup) {, +    public ReducedQueryPhase reducedQueryPhase(Collection<? extends SearchPhaseResult> queryResults,, +                                               boolean isScrollRequest, boolean trackTotalHits) {, +                timedOut, terminatedEarly, null, null, null, EMPTY_DOCS, null,, +                null, numReducePhases, false, 0, 0, true);, +                        // we have to merge here in the same way we collect on a shard, +                        querySearchResult.from() + querySearchResult.size(), +++ b/buildSrc/src/main/resources/checkstyle_suppressions.xml, +++ b/server/src/main/java/org/elasticsearch/action/admin/cluster/health/TransportClusterHealthAction.java, +        final ClusterStateObserver observer = new ClusterStateObserver(state, clusterService,, +            null, logger, threadPool.getThreadContext());, +    private ClusterHealthResponse getResponse(final ClusterHealthRequest request, ClusterState clusterState,, +                                              final int waitFor, boolean timedOut) {, +++ b/server/src/main/java/org/elasticsearch/action/admin/cluster/stats/ClusterStatsNodeResponse.java, +    public ClusterStatsNodeResponse(DiscoveryNode node, @Nullable ClusterHealthStatus clusterStatus,, +                                    NodeInfo nodeInfo, NodeStats nodeStats, ShardStats[] shardsStats) {, +++ b/server/src/main/java/org/elasticsearch/action/search/SearchPhaseController.java, +                // make sure we set the shard index before we add it - the consumer didn't do that yet, +                if (td.topDocs.scoreDocs.length > 0) {, +                                        Collection<? extends SearchPhaseResult> fetchResults,, +                                        IntFunction<SearchPhaseResult> resultsLookup) {, +    public ReducedQueryPhase reducedQueryPhase(Collection<? extends SearchPhaseResult> queryResults,, +                                               boolean isScrollRequest, boolean trackTotalHits) {, +                timedOut, terminatedEarly, null, null, null, EMPTY_DOCS, null,, +                null, numReducePhases, false, 0, 0, true);, +                        // we have to merge here in the same way we collect on a shard, +                        querySearchResult.from() + querySearchResult.size(), +++ b/server/src/main/java/org/elasticsearch/action/termvectors/MultiTermVectorsRequest.java, +public class MultiTermVectorsRequest extends ActionRequest, +        implements Iterable<TermVectorsRequest>, CompositeIndicesRequest, RealtimeRequest {, +++ b/buildSrc/src/main/resources/checkstyle_suppressions.xml, +++ b/server/src/main/java/org/elasticsearch/action/admin/cluster/health/TransportClusterHealthAction.java, +        final ClusterStateObserver observer = new ClusterStateObserver(state, clusterService,, +            null, logger, threadPool.getThreadContext());, +    private ClusterHealthResponse getResponse(final ClusterHealthRequest request, ClusterState clusterState,, +                                              final int waitFor, boolean timedOut) {, +++ b/server/src/main/java/org/elasticsearch/action/admin/cluster/stats/ClusterStatsNodeResponse.java, +    public ClusterStatsNodeResponse(DiscoveryNode node, @Nullable ClusterHealthStatus clusterStatus,, +                                    NodeInfo nodeInfo, NodeStats nodeStats, ShardStats[] shardsStats) {, +++ b/server/src/main/java/org/elasticsearch/action/search/SearchPhaseController.java, +                // make sure we set the shard index before we add it - the consumer didn't do that yet, +                if (td.topDocs.scoreDocs.length > 0) {, +                                        Collection<? extends SearchPhaseResult> fetchResults,, +                                        IntFunction<SearchPhaseResult> resultsLookup) {, +    public ReducedQueryPhase reducedQueryPhase(Collection<? extends SearchPhaseResult> queryResults,, +                                               boolean isScrollRequest, boolean trackTotalHits) {, +                timedOut, terminatedEarly, null, null, null, EMPTY_DOCS, null,, +                null, numReducePhases, false, 0, 0, true);, +                        // we have to merge here in the same way we collect on a shard, +                        querySearchResult.from() + querySearchResult.size(), +++ b/server/src/main/java/org/elasticsearch/action/termvectors/MultiTermVectorsRequest.java, +public class MultiTermVectorsRequest extends ActionRequest, +        implements Iterable<TermVectorsRequest>, CompositeIndicesRequest, RealtimeRequest {, +++ b/server/src/main/java/org/elasticsearch/action/termvectors/TermVectorsRequest.java, +                } else if (INDEX.match(currentFieldName, parser.getDeprecationHandler())) {, +                    // the following is important for multi request parsing., +                        throw new ElasticsearchParseException("failed to parse term vectors request. " +, +                            "either [id] or [doc] can be specified, but not both!");, +                        throw new ElasticsearchParseException("failed to parse term vectors request. " +, +                            "either [id] or [doc] can be specified, but not both!");, +                throw new ElasticsearchParseException("expecting the analyzer at [{}] to be a String, but found [{}] instead",, +                    e.getKey(), e.getValue().getClass());, +                    throw new ElasticsearchParseException("failed to parse term vectors request. " +, +                        "the field [{}] is not valid for filter parameter for term vector request", currentFieldName);, +++ b/buildSrc/src/main/resources/checkstyle_suppressions.xml, +++ b/server/src/main/java/org/elasticsearch/action/admin/cluster/health/TransportClusterHealthAction.java, +        final ClusterStateObserver observer = new ClusterStateObserver(state, clusterService,, +            null, logger, threadPool.getThreadContext());, +    private ClusterHealthResponse getResponse(final ClusterHealthRequest request, ClusterState clusterState,, +                                              final int waitFor, boolean timedOut) {, +++ b/server/src/main/java/org/elasticsearch/action/admin/cluster/stats/ClusterStatsNodeResponse.java]