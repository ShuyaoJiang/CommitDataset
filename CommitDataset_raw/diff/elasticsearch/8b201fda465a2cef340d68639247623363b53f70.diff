[+++ b/core/src/main/java/org/elasticsearch/search/sort/FieldSortBuilder.java, +import org.apache.lucene.util.BytesRef;, +import org.elasticsearch.common.ParseField;, +import org.elasticsearch.common.ParsingException;, +import org.elasticsearch.common.io.stream.StreamInput;, +import org.elasticsearch.common.io.stream.StreamOutput;, +import org.elasticsearch.common.lucene.BytesRefs;, +import org.elasticsearch.common.xcontent.XContentParser;, +import org.elasticsearch.index.query.QueryParseContext;, +import java.util.Objects;, +public class FieldSortBuilder extends SortBuilder<FieldSortBuilder> implements SortBuilderParser<FieldSortBuilder> {, +    static final FieldSortBuilder PROTOTYPE = new FieldSortBuilder("");, +    public static final String NAME = "field_sort";, +    public static final ParseField NESTED_PATH = new ParseField("nested_path");, +    public static final ParseField NESTED_FILTER = new ParseField("nested_filter");, +    public static final ParseField MISSING = new ParseField("missing");, +    public static final ParseField ORDER = new ParseField("order");, +    public static final ParseField REVERSE = new ParseField("reverse");, +    public static final ParseField SORT_MODE = new ParseField("mode");, +    public static final ParseField UNMAPPED_TYPE = new ParseField("unmapped_type");, +    /** Copy constructor. */, +    public FieldSortBuilder(FieldSortBuilder template) {, +        this(template.fieldName);, +        this.order(template.order());, +        this.missing(template.missing());, +        this.unmappedType(template.unmappedType());, +        this.sortMode(template.sortMode());, +        this.setNestedFilter(template.getNestedFilter());, +        this.setNestedPath(template.getNestedPath());, +    }, +, +     * @param fieldName, +     *            The field name., +    /** Returns the document field this sort should be based on. */, +    public String getFieldName() {, +        return this.fieldName;, +    }, +, +        if (missing instanceof String) {, +            this.missing = BytesRefs.toBytesRef(missing);, +        } else {, +        }, +    /** Returns the value used when a field is missing in a doc. */, +    public Object missing() {, +        if (missing instanceof BytesRef) {, +            return ((BytesRef) missing).utf8ToString();, +        }, +        return missing;, +    }, +, +     * Specifying a type tells Elasticsearch what type the sort values should, +     * have, which is important for cross-index search, if there are sort fields, +     * that exist on some indices only. If the unmapped type is <tt>null</tt>, +     * then query execution will fail if one or more indices don't have a, +     * mapping for the current field., +     * Returns the type to use in case the current field is not mapped in an, +     * index., +     */, +    public String unmappedType() {, +        return this.unmappedType;, +    }, +, +    /**, +     * Defines what values to pick in the case a document contains multiple, +     * values for the targeted sort field. Possible values: min, max, sum and, +     * avg, +     * , +     * TODO would love to see an enum here, +     * Returns what values to pick in the case a document contains multiple, +     * values for the targeted sort field., +     */, +    public String sortMode() {, +        return this.sortMode;, +    }, +, +    /**, +     * Sets the nested filter that the nested objects should match with in order, +     * to be taken into account for sorting., +     * , +     * TODO should the above getters and setters be deprecated/ changed in, +     * favour of real getters and setters?, +    /**, +     * Returns the nested filter that the nested objects should match with in, +     * order to be taken into account for sorting., +     */, +    public QueryBuilder getNestedFilter() {, +        return this.nestedFilter;, +    }, +     * Sets the nested path if sorting occurs on a field that is inside a nested, +     * object. By default when sorting on a field inside a nested object, the, +     * nearest upper nested object is selected as nested path., +    /**, +     * Returns the nested path if sorting occurs in a field that is inside a, +     * nested object., +     */, +    public String getNestedPath() {, +        return this.nestedPath;, +    }, +, +            if (missing instanceof BytesRef) {]