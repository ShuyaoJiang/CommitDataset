[+++ b/modules/elasticsearch/src/main/java/org/elasticsearch/cluster/routing/RoutingNodes.java, +import org.elasticsearch.common.trove.map.hash.TObjectIntHashMap;, +import java.util.HashMap;, +    private final Map<String, TObjectIntHashMap<String>> nodesPerAttributeNames = new HashMap<String, TObjectIntHashMap<String>>();, +, +    public TObjectIntHashMap<String> nodesPerAttributesCounts(String attributeName) {, +        TObjectIntHashMap<String> nodesPerAttributesCounts = nodesPerAttributeNames.get(attributeName);, +        if (nodesPerAttributesCounts != null) {, +            return nodesPerAttributesCounts;, +        }, +        nodesPerAttributesCounts = new TObjectIntHashMap<String>();, +        for (RoutingNode routingNode : this) {, +            String attrValue = routingNode.node().attributes().get(attributeName);, +            nodesPerAttributesCounts.adjustOrPutValue(attrValue, 1, 1);, +        }, +        nodesPerAttributeNames.put(attributeName, nodesPerAttributesCounts);, +        return nodesPerAttributesCounts;, +    }, +, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/cluster/routing/RoutingNodes.java, +import org.elasticsearch.common.trove.map.hash.TObjectIntHashMap;, +import java.util.HashMap;, +    private final Map<String, TObjectIntHashMap<String>> nodesPerAttributeNames = new HashMap<String, TObjectIntHashMap<String>>();, +, +    public TObjectIntHashMap<String> nodesPerAttributesCounts(String attributeName) {, +        TObjectIntHashMap<String> nodesPerAttributesCounts = nodesPerAttributeNames.get(attributeName);, +        if (nodesPerAttributesCounts != null) {, +            return nodesPerAttributesCounts;, +        }, +        nodesPerAttributesCounts = new TObjectIntHashMap<String>();, +        for (RoutingNode routingNode : this) {, +            String attrValue = routingNode.node().attributes().get(attributeName);, +            nodesPerAttributesCounts.adjustOrPutValue(attrValue, 1, 1);, +        }, +        nodesPerAttributeNames.put(attributeName, nodesPerAttributesCounts);, +        return nodesPerAttributesCounts;, +    }, +, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/cluster/routing/allocation/AllocationService.java, +import java.util.ArrayList;, +, +        // create a copy of the shards interleaving between nodes, and check if they can remain, +        List<MutableShardRouting> shards = new ArrayList<MutableShardRouting>();, +        int index = 0;, +        boolean found = true;, +        while (found) {, +            found = false;, +                if (index >= routingNode.shards().size()) {, +                    continue;, +                }, +                found = true;, +                shards.add(routingNode.shards().get(index));, +            }, +            index++;, +        }, +        for (int i = 0; i < shards.size(); i++) {, +            MutableShardRouting shardRouting = shards.get(i);, +            RoutingNode routingNode = allocation.routingNodes().node(shardRouting.currentNodeId());, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/cluster/routing/RoutingNodes.java, +import org.elasticsearch.common.trove.map.hash.TObjectIntHashMap;, +import java.util.HashMap;, +    private final Map<String, TObjectIntHashMap<String>> nodesPerAttributeNames = new HashMap<String, TObjectIntHashMap<String>>();, +, +    public TObjectIntHashMap<String> nodesPerAttributesCounts(String attributeName) {, +        TObjectIntHashMap<String> nodesPerAttributesCounts = nodesPerAttributeNames.get(attributeName);, +        if (nodesPerAttributesCounts != null) {, +            return nodesPerAttributesCounts;, +        }, +        nodesPerAttributesCounts = new TObjectIntHashMap<String>();, +        for (RoutingNode routingNode : this) {, +            String attrValue = routingNode.node().attributes().get(attributeName);, +            nodesPerAttributesCounts.adjustOrPutValue(attrValue, 1, 1);, +        }, +        nodesPerAttributeNames.put(attributeName, nodesPerAttributesCounts);, +        return nodesPerAttributesCounts;, +    }, +, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/cluster/routing/allocation/AllocationService.java, +import java.util.ArrayList;, +, +        // create a copy of the shards interleaving between nodes, and check if they can remain, +        List<MutableShardRouting> shards = new ArrayList<MutableShardRouting>();, +        int index = 0;, +        boolean found = true;, +        while (found) {, +            found = false;, +                if (index >= routingNode.shards().size()) {, +                    continue;, +                }, +                found = true;, +                shards.add(routingNode.shards().get(index));, +            }, +            index++;, +        }, +        for (int i = 0; i < shards.size(); i++) {, +            MutableShardRouting shardRouting = shards.get(i);, +            RoutingNode routingNode = allocation.routingNodes().node(shardRouting.currentNodeId());, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/cluster/routing/allocation/decider/AllocationDeciders.java, +                .add(new AwarenessAllocationDecider(settings)), +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/cluster/routing/RoutingNodes.java]