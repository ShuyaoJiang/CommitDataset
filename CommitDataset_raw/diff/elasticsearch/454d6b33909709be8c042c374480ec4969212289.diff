[+++ b/plugin/src/main/java/org/elasticsearch/xpack/ml/action/CloseJobAction.java, +import org.elasticsearch.common.util.concurrent.AbstractRunnable;, +import org.elasticsearch.xpack.ml.job.config.JobTaskStatus;, +            // We fork in innerTaskOperation(...), so we can use ThreadPool.Names.SAME here:, +                    indexNameExpressionResolver, Request::new, Response::new, ThreadPool.Names.SAME);, +        protected void taskOperation(Request request, OpenJobAction.JobTask jobTask, ActionListener<Response> listener) {, +            JobTaskStatus taskStatus = new JobTaskStatus(JobState.CLOSING, jobTask.getAllocationId());, +            jobTask.updatePersistentStatus(taskStatus, ActionListener.wrap(task -> {, +                // we need to fork because we are now on a network threadpool and closeJob method may take a while to complete:, +                threadPool.executor(ThreadPool.Names.MANAGEMENT).execute(new AbstractRunnable() {, +                    @Override, +                    public void onFailure(Exception e) {, +                        listener.onFailure(e);, +                    }, +, +                    @Override, +                    protected void doRun() throws Exception {, +                        jobTask.closeJob("close job (api)");, +                });, +            }, listener::onFailure));, +        }, +            if (MlMetadata.getJobState(resolvedJobId, tasks).isAnyOf(JobState.OPENED, JobState.FAILED) == false) {, +        if (jobTask == null || jobTask.getStatus() == null) {, +            throw new ElasticsearchStatusException("cannot close job, because job [" + jobId + "] is not open", RestStatus.CONFLICT);, +        }, +        JobTaskStatus jobTaskStatus = (JobTaskStatus) jobTask.getStatus();, +        if (jobTaskStatus.getState().isAnyOf(JobState.OPENED, JobState.FAILED) == false) {, +++ b/plugin/src/main/java/org/elasticsearch/xpack/ml/action/CloseJobAction.java, +import org.elasticsearch.common.util.concurrent.AbstractRunnable;, +import org.elasticsearch.xpack.ml.job.config.JobTaskStatus;, +            // We fork in innerTaskOperation(...), so we can use ThreadPool.Names.SAME here:, +                    indexNameExpressionResolver, Request::new, Response::new, ThreadPool.Names.SAME);, +        protected void taskOperation(Request request, OpenJobAction.JobTask jobTask, ActionListener<Response> listener) {, +            JobTaskStatus taskStatus = new JobTaskStatus(JobState.CLOSING, jobTask.getAllocationId());, +            jobTask.updatePersistentStatus(taskStatus, ActionListener.wrap(task -> {, +                // we need to fork because we are now on a network threadpool and closeJob method may take a while to complete:, +                threadPool.executor(ThreadPool.Names.MANAGEMENT).execute(new AbstractRunnable() {, +                    @Override, +                    public void onFailure(Exception e) {, +                        listener.onFailure(e);, +                    }, +, +                    @Override, +                    protected void doRun() throws Exception {, +                        jobTask.closeJob("close job (api)");, +                });, +            }, listener::onFailure));, +        }, +            if (MlMetadata.getJobState(resolvedJobId, tasks).isAnyOf(JobState.OPENED, JobState.FAILED) == false) {, +        if (jobTask == null || jobTask.getStatus() == null) {, +            throw new ElasticsearchStatusException("cannot close job, because job [" + jobId + "] is not open", RestStatus.CONFLICT);, +        }, +        JobTaskStatus jobTaskStatus = (JobTaskStatus) jobTask.getStatus();, +        if (jobTaskStatus.getState().isAnyOf(JobState.OPENED, JobState.FAILED) == false) {, +++ b/plugin/src/main/java/org/elasticsearch/xpack/ml/job/config/JobState.java, +    CLOSING, CLOSED, OPENED, FAILED;, +++ b/plugin/src/main/java/org/elasticsearch/xpack/ml/action/CloseJobAction.java, +import org.elasticsearch.common.util.concurrent.AbstractRunnable;, +import org.elasticsearch.xpack.ml.job.config.JobTaskStatus;, +            // We fork in innerTaskOperation(...), so we can use ThreadPool.Names.SAME here:, +                    indexNameExpressionResolver, Request::new, Response::new, ThreadPool.Names.SAME);, +        protected void taskOperation(Request request, OpenJobAction.JobTask jobTask, ActionListener<Response> listener) {, +            JobTaskStatus taskStatus = new JobTaskStatus(JobState.CLOSING, jobTask.getAllocationId());, +            jobTask.updatePersistentStatus(taskStatus, ActionListener.wrap(task -> {, +                // we need to fork because we are now on a network threadpool and closeJob method may take a while to complete:, +                threadPool.executor(ThreadPool.Names.MANAGEMENT).execute(new AbstractRunnable() {, +                    @Override, +                    public void onFailure(Exception e) {, +                        listener.onFailure(e);, +                    }, +, +                    @Override, +                    protected void doRun() throws Exception {, +                        jobTask.closeJob("close job (api)");, +                });, +            }, listener::onFailure));, +        }, +            if (MlMetadata.getJobState(resolvedJobId, tasks).isAnyOf(JobState.OPENED, JobState.FAILED) == false) {, +        if (jobTask == null || jobTask.getStatus() == null) {, +            throw new ElasticsearchStatusException("cannot close job, because job [" + jobId + "] is not open", RestStatus.CONFLICT);, +        }, +        JobTaskStatus jobTaskStatus = (JobTaskStatus) jobTask.getStatus();, +        if (jobTaskStatus.getState().isAnyOf(JobState.OPENED, JobState.FAILED) == false) {, +++ b/plugin/src/main/java/org/elasticsearch/xpack/ml/job/config/JobState.java, +    CLOSING, CLOSED, OPENED, FAILED;, +++ b/plugin/src/test/java/org/elasticsearch/xpack/ml/job/config/JobStateTests.java, +        assertEquals(JobState.fromString("closing"), JobState.CLOSING);, +        assertEquals(JobState.fromString("CLOSING"), JobState.CLOSING);, +        assertEquals("closing", JobState.CLOSING.toString());, +        assertEquals(0, JobState.CLOSING.ordinal());, +        assertEquals(1, JobState.CLOSED.ordinal());, +        assertEquals(2, JobState.OPENED.ordinal());, +        assertEquals(3, JobState.FAILED.ordinal());, +        assertFalse(JobState.CLOSING.isAnyOf(JobState.FAILED, JobState.OPENED));, +        assertTrue(JobState.CLOSING.isAnyOf(JobState.CLOSING));]