[+++ b/core/src/main/java/org/elasticsearch/common/regex/Regex.java, +import org.apache.lucene.util.automaton.Automata;, +import org.apache.lucene.util.automaton.Automaton;, +import org.apache.lucene.util.automaton.Operations;, +import java.util.ArrayList;, +import java.util.List;, +    /** Return an {@link Automaton} that matches the given pattern. */, +    public static Automaton simpleMatchToAutomaton(String pattern) {, +        List<Automaton> automata = new ArrayList<>();, +        int previous = 0;, +        for (int i = pattern.indexOf('*'); i != -1; i = pattern.indexOf('*', i + 1)) {, +            automata.add(Automata.makeString(pattern.substring(previous, i)));, +            automata.add(Automata.makeAnyString());, +            previous = i + 1;, +        }, +        automata.add(Automata.makeString(pattern.substring(previous)));, +        return Operations.concatenate(automata);, +    }, +, +    /**, +     * Return an Automaton that matches the union of the provided patterns., +     */, +    public static Automaton simpleMatchToAutomaton(String... patterns) {, +        if (patterns.length < 1) {, +            throw new IllegalArgumentException("There must be at least one pattern, zero given");, +        }, +        List<Automaton> automata = new ArrayList<>();, +        for (String pattern : patterns) {, +            automata.add(simpleMatchToAutomaton(pattern));, +        }, +        return Operations.union(automata);, +    }, +, +++ b/core/src/main/java/org/elasticsearch/common/regex/Regex.java, +import org.apache.lucene.util.automaton.Automata;, +import org.apache.lucene.util.automaton.Automaton;, +import org.apache.lucene.util.automaton.Operations;, +import java.util.ArrayList;, +import java.util.List;, +    /** Return an {@link Automaton} that matches the given pattern. */, +    public static Automaton simpleMatchToAutomaton(String pattern) {, +        List<Automaton> automata = new ArrayList<>();, +        int previous = 0;, +        for (int i = pattern.indexOf('*'); i != -1; i = pattern.indexOf('*', i + 1)) {, +            automata.add(Automata.makeString(pattern.substring(previous, i)));, +            automata.add(Automata.makeAnyString());, +            previous = i + 1;, +        }, +        automata.add(Automata.makeString(pattern.substring(previous)));, +        return Operations.concatenate(automata);, +    }, +, +    /**, +     * Return an Automaton that matches the union of the provided patterns., +     */, +    public static Automaton simpleMatchToAutomaton(String... patterns) {, +        if (patterns.length < 1) {, +            throw new IllegalArgumentException("There must be at least one pattern, zero given");, +        }, +        List<Automaton> automata = new ArrayList<>();, +        for (String pattern : patterns) {, +            automata.add(simpleMatchToAutomaton(pattern));, +        }, +        return Operations.union(automata);, +    }, +, +++ b/core/src/main/java/org/elasticsearch/common/xcontent/support/XContentMapValues.java, +import org.apache.lucene.util.automaton.Automata;, +import org.apache.lucene.util.automaton.Automaton;, +import org.apache.lucene.util.automaton.CharacterRunAutomaton;, +import org.apache.lucene.util.automaton.Operations;, +import java.util.Arrays;, +    /**, +     * Only keep properties in {@code map} that match the {@code includes} but, +     * not the {@code excludes}. An empty list of includes is interpreted as a, +     * wildcard while an empty list of excludes does not match anything., +     *, +     * If a property matches both an include and an exclude, then the exclude, +     * wins., +     *, +     * If an object matches, then any of its sub properties are automatically, +     * considered as matching as well, both for includes and excludes., +     *, +     * Dots in field names are treated as sub objects. So for instance if a, +     * document contains {@code a.b} as a property and {@code a} is an include,, +     * then {@code a.b} will be kept in the filtered map., +     */, +    public static Map<String, Object> filter(Map<String, ?> map, String[] includes, String[] excludes) {, +        CharacterRunAutomaton matchAllAutomaton = new CharacterRunAutomaton(Automata.makeAnyString());, +, +        CharacterRunAutomaton include;, +        if (includes == null || includes.length == 0) {, +            include = matchAllAutomaton;, +        } else {, +            Automaton includeA = Regex.simpleMatchToAutomaton(includes);, +            includeA = makeMatchDotsInFieldNames(includeA);, +            include = new CharacterRunAutomaton(includeA);, +        Automaton excludeA;, +        if (excludes == null || excludes.length == 0) {, +            excludeA = Automata.makeEmpty();]