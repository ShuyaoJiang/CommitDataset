[+++ b/elasticsearch-transport-client/build.gradle, +++ b/elasticsearch-transport-client/build.gradle, +++ b/elasticsearch/src/main/java/org/elasticsearch/xpack/security/authz/accesscontrol/SecurityIndexSearcherWrapper.java, +                            failIfQueryUsesClient(scriptService, queryBuilder.get(), queryShardContext);, +     * Fall back validation that verifies that queries during rewrite don't use, +     * the client to make remote calls. In the case of DLS this can cause a dead, +     * lock if DLS is also applied on these remote calls. For example in the, +     * case of terms query with lookup, this can cause recursive execution of, +     * the DLS query until the get thread pool has been exhausted:, +     * https://github.com/elastic/x-plugins/issues/3145, +    static void failIfQueryUsesClient(ScriptService scriptService, QueryBuilder queryBuilder, QueryRewriteContext original), +            throws IOException {, +        QueryRewriteContext copy = new QueryRewriteContext(original.getIndexSettings(), original.getMapperService(), scriptService, null,, +                client, original.getIndexReader(), original.getClusterState());, +++ b/elasticsearch-transport-client/build.gradle, +++ b/elasticsearch/src/main/java/org/elasticsearch/xpack/security/authz/accesscontrol/SecurityIndexSearcherWrapper.java, +                            failIfQueryUsesClient(scriptService, queryBuilder.get(), queryShardContext);, +     * Fall back validation that verifies that queries during rewrite don't use, +     * the client to make remote calls. In the case of DLS this can cause a dead, +     * lock if DLS is also applied on these remote calls. For example in the, +     * case of terms query with lookup, this can cause recursive execution of, +     * the DLS query until the get thread pool has been exhausted:, +     * https://github.com/elastic/x-plugins/issues/3145, +    static void failIfQueryUsesClient(ScriptService scriptService, QueryBuilder queryBuilder, QueryRewriteContext original), +            throws IOException {, +        QueryRewriteContext copy = new QueryRewriteContext(original.getIndexSettings(), original.getMapperService(), scriptService, null,, +                client, original.getIndexReader(), original.getClusterState());, +++ b/elasticsearch/src/main/java/org/elasticsearch/xpack/watcher/Watcher.java, +import org.elasticsearch.threadpool.ScalingExecutorBuilder;, +            final ScalingExecutorBuilder builder =, +                    new ScalingExecutorBuilder(, +                            0,, +                            // watcher threads can block on I/O for a long time, so we let this, +                            // pool be large so that execution of unblocked watches can proceed, +                            TimeValue.timeValueMinutes(5),, +++ b/elasticsearch-transport-client/build.gradle, +++ b/elasticsearch/src/main/java/org/elasticsearch/xpack/security/authz/accesscontrol/SecurityIndexSearcherWrapper.java, +                            failIfQueryUsesClient(scriptService, queryBuilder.get(), queryShardContext);, +     * Fall back validation that verifies that queries during rewrite don't use, +     * the client to make remote calls. In the case of DLS this can cause a dead, +     * lock if DLS is also applied on these remote calls. For example in the, +     * case of terms query with lookup, this can cause recursive execution of, +     * the DLS query until the get thread pool has been exhausted:, +     * https://github.com/elastic/x-plugins/issues/3145, +    static void failIfQueryUsesClient(ScriptService scriptService, QueryBuilder queryBuilder, QueryRewriteContext original), +            throws IOException {, +        QueryRewriteContext copy = new QueryRewriteContext(original.getIndexSettings(), original.getMapperService(), scriptService, null,, +                client, original.getIndexReader(), original.getClusterState());, +++ b/elasticsearch/src/main/java/org/elasticsearch/xpack/watcher/Watcher.java, +import org.elasticsearch.threadpool.ScalingExecutorBuilder;, +            final ScalingExecutorBuilder builder =, +                    new ScalingExecutorBuilder(, +                            0,, +                            // watcher threads can block on I/O for a long time, so we let this, +                            // pool be large so that execution of unblocked watches can proceed, +                            TimeValue.timeValueMinutes(5),, +++ b/elasticsearch/src/test/java/org/elasticsearch/xpack/security/SecurityTribeIT.java, +        tribeClient = tribeNode.client();, +        if (shouldBeSuccessfulUsers.isEmpty()) {, +            // there is no security index so these users can authenticate..., +            for (String username : shouldFailUsers) {, +                ClusterHealthResponse response = tribeClient.filterWithHeader(Collections.singletonMap("Authorization",, +                        UsernamePasswordToken.basicAuthHeaderValue(username, new SecuredString("password".toCharArray())))), +                        .admin().cluster().prepareHealth().get();, +                assertNoTimeout(response);, +            }, +        } else {, +        SecurityClient securityClient = securityClient(getClientWrapper().apply(tribeClient));, +        SecurityClient securityClient = securityClient(getClientWrapper().apply(tribeClient));, +++ b/elasticsearch-transport-client/build.gradle, +++ b/elasticsearch/src/main/java/org/elasticsearch/xpack/security/authz/accesscontrol/SecurityIndexSearcherWrapper.java, +                            failIfQueryUsesClient(scriptService, queryBuilder.get(), queryShardContext);, +     * Fall back validation that verifies that queries during rewrite don't use, +     * the client to make remote calls. In the case of DLS this can cause a dead, +     * lock if DLS is also applied on these remote calls. For example in the, +     * case of terms query with lookup, this can cause recursive execution of, +     * the DLS query until the get thread pool has been exhausted:, +     * https://github.com/elastic/x-plugins/issues/3145, +    static void failIfQueryUsesClient(ScriptService scriptService, QueryBuilder queryBuilder, QueryRewriteContext original), +            throws IOException {, +        QueryRewriteContext copy = new QueryRewriteContext(original.getIndexSettings(), original.getMapperService(), scriptService, null,, +                client, original.getIndexReader(), original.getClusterState());, +++ b/elasticsearch/src/main/java/org/elasticsearch/xpack/watcher/Watcher.java, +import org.elasticsearch.threadpool.ScalingExecutorBuilder;, +            final ScalingExecutorBuilder builder =, +                    new ScalingExecutorBuilder(, +                            0,, +                            // watcher threads can block on I/O for a long time, so we let this, +                            // pool be large so that execution of unblocked watches can proceed, +                            TimeValue.timeValueMinutes(5),, +++ b/elasticsearch/src/test/java/org/elasticsearch/xpack/security/SecurityTribeIT.java, +        tribeClient = tribeNode.client();, +        if (shouldBeSuccessfulUsers.isEmpty()) {, +            // there is no security index so these users can authenticate..., +            for (String username : shouldFailUsers) {, +                ClusterHealthResponse response = tribeClient.filterWithHeader(Collections.singletonMap("Authorization",, +                        UsernamePasswordToken.basicAuthHeaderValue(username, new SecuredString("password".toCharArray())))), +                        .admin().cluster().prepareHealth().get();, +                assertNoTimeout(response);, +            }]