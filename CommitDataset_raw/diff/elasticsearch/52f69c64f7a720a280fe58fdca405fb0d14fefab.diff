[+++ b/src/main/java/org/elasticsearch/cluster/settings/ClusterDynamicSettingsModule.java, +        clusterDynamicSettings.addDynamicSetting(DiscoverySettings.NO_MASTER_BLOCK);, +++ b/src/main/java/org/elasticsearch/cluster/settings/ClusterDynamicSettingsModule.java, +        clusterDynamicSettings.addDynamicSetting(DiscoverySettings.NO_MASTER_BLOCK);, +++ b/src/test/java/org/elasticsearch/discovery/DiscoveryWithNetworkFailuresTests.java, +import org.elasticsearch.action.ActionRequestBuilder;, +import static org.hamcrest.Matchers.equalTo;, +import static org.hamcrest.Matchers.is;, +    public void testVerifyApiBlocksDuringPartition() throws Exception {, +        internalCluster().startNodesAsync(3, nodeSettings).get();, +        createIndex("test");, +        // Reads on the wrong side of the split are allowed, +        client(isolatedNode).prepareSearch("test").setTypes("type"), +                .setPreference("_only_local"), +        client(isolatedNode).preparePercolate().setDocumentType("type").setIndices("test"), +                .setPreference("_only_local").setSource("{\"doc\" : {}}"), +                .get();, +        client(isolatedNode).prepareCount("test").setTypes("type"), +                .setPreference("_only_local"), +                .get();, +        client(isolatedNode).prepareGet("test", "type", "0").setPreference("_only_local"), +                .get();, +, +        // Writes on the wrong side of the split are *not* allowed, +        executeBlockedApi(, +                client(isolatedNode).prepareIndex("test", "type", "0").setSource("{}").setTimeout("1s") // Fail quick, otherwise we wait 60 seconds., +        );, +        executeBlockedApi(, +                client(isolatedNode).prepareUpdate("test", "type", "0").setDoc("{}").setTimeout("1s") // Fail quick, otherwise we wait 60 seconds., +        );, +        networkPartition.stopDisrupting();, +, +        // Wait until the master node sees all 3 nodes again., +        ensureStableCluster(3, new TimeValue(30000 + networkPartition.expectedTimeToHeal().millis()));, +, +        logger.info("Verify no master block with {} set to {}", DiscoverySettings.NO_MASTER_BLOCK, "all");, +        client().admin().cluster().prepareUpdateSettings(), +                .setTransientSettings(ImmutableSettings.builder().put(DiscoverySettings.NO_MASTER_BLOCK, "all")), +                .get();, +        networkPartition.startDisrupting();, +, +        logger.info("wait until elected master has removed [{}]", isolatedNode);, +        applied = awaitBusy(new Predicate<Object>() {, +            @Override, +            public boolean apply(Object input) {, +                return client(nonIsolatedNode).admin().cluster().prepareState().setLocal(true).get().getState().nodes().size() == 2;, +            }, +        }, 1, TimeUnit.MINUTES);, +        assertThat(applied, is(true));, +, +        // The unlucky node must report *no* master node, since it can't connect to master and in fact it should, +        // continuously ping until network failures have been resolved. However, +        // It may a take a bit before the node detects it has been cut off from the elected master, +        logger.info("waiting for isolated node [{}] to have no master", isolatedNode);, +        applied = awaitBusy(new Predicate<Object>() {, +            @Override, +            public boolean apply(Object input) {, +                ClusterState localClusterState = client(isolatedNode).admin().cluster().prepareState().setLocal(true).get().getState();, +                DiscoveryNodes localDiscoveryNodes = localClusterState.nodes();, +                logger.info("localDiscoveryNodes=" + localDiscoveryNodes.prettyPrint());, +                return localDiscoveryNodes.masterNode() == null;, +            }, +        }, 10, TimeUnit.SECONDS);, +        assertThat(applied, is(true));, +        ensureStableCluster(2, nonIsolatedNode);, +, +        // Now reads and writes on the wrong side of the split are allowed, +        executeBlockedApi(, +                client(isolatedNode).prepareSearch("test").setTypes("type").setPreference("_only_local"), +        );, +        executeBlockedApi(, +                client(isolatedNode).preparePercolate().setDocumentType("type").setIndices("test").setPreference("_only_local").setSource("{\"doc\" : {}}"), +        );, +        executeBlockedApi(, +                client(isolatedNode).prepareCount("test").setTypes("type").setPreference("_only_local"), +        );, +        executeBlockedApi(, +                client(isolatedNode).prepareGet("test", "type", "0").setPreference("_only_local"), +        );, +        executeBlockedApi(, +                client(isolatedNode).prepareIndex("test", "type", "0").setSource("{}").setTimeout("1s") // Fail quick, otherwise we wait 60 seconds., +        );, +        executeBlockedApi(, +                client(isolatedNode).prepareUpdate("test", "type", "0").setDoc("{}").setTimeout("1s") // Fail quick, otherwise we wait 60 seconds., +        );, +        networkPartition.stopDisrupting();, +, +        // Wait until the master node sees all 3 nodes again., +        ensureStableCluster(3, new TimeValue(30000 + networkPartition.expectedTimeToHeal().millis()));, +    private void executeBlockedApi(ActionRequestBuilder builder) {, +            logger.info("verifying request[{}] on isolated [{}] and fail", builder.getClass().getSimpleName());, +            builder.get();]