[+++ b/src/main/java/org/elasticsearch/action/update/TransportUpdateAction.java, +                    .percolate(request.percolate());, +++ b/src/main/java/org/elasticsearch/action/update/TransportUpdateAction.java, +                    .percolate(request.percolate());, +++ b/src/main/java/org/elasticsearch/action/update/UpdateRequest.java, +++ b/src/main/java/org/elasticsearch/action/update/TransportUpdateAction.java, +                    .percolate(request.percolate());, +++ b/src/main/java/org/elasticsearch/action/update/UpdateRequest.java, +++ b/src/main/java/org/elasticsearch/action/update/UpdateRequestBuilder.java, +++ b/src/main/java/org/elasticsearch/action/update/TransportUpdateAction.java, +                    .percolate(request.percolate());, +++ b/src/main/java/org/elasticsearch/action/update/UpdateRequest.java, +++ b/src/main/java/org/elasticsearch/action/update/UpdateRequestBuilder.java, +++ b/src/main/java/org/elasticsearch/cluster/routing/allocation/AllocationService.java, +import com.google.common.collect.Lists;, +import java.util.*;, +        // shuffle the unassigned nodes, just so we won't have things like poison failed shards, +        Collections.shuffle(routingNodes.unassigned());, +        // shuffle the unassigned nodes, just so we won't have things like poison failed shards, +        Collections.shuffle(routingNodes.unassigned());, +        // shuffle the unassigned nodes, just so we won't have things like poison failed shards, +        Collections.shuffle(routingNodes.unassigned());, +        // shuffle the unassigned nodes, just so we won't have things like poison failed shards, +        Collections.shuffle(routingNodes.unassigned());, +        // move all the shards matching the failed shard to the end of the unassigned list, +        // so we give a chance for other allocations and won't create poison failed allocations, +        // that can keep other shards from being allocated (because of limits applied on how many, +        // shards we can start per node), +        List<MutableShardRouting> shardsToMove = Lists.newArrayList();, +        for (Iterator<MutableShardRouting> it = allocation.routingNodes().unassigned().iterator(); it.hasNext(); ) {, +            MutableShardRouting shardRouting = it.next();, +            if (shardRouting.shardId().equals(failedShard.shardId())) {, +                it.remove();, +                shardsToMove.add(shardRouting);, +            }, +        }, +        if (!shardsToMove.isEmpty()) {, +            allocation.routingNodes().unassigned().addAll(shardsToMove);, +        }, +, +++ b/src/main/java/org/elasticsearch/action/update/TransportUpdateAction.java, +                    .percolate(request.percolate());, +++ b/src/main/java/org/elasticsearch/action/update/UpdateRequest.java, +++ b/src/main/java/org/elasticsearch/action/update/UpdateRequestBuilder.java, +++ b/src/main/java/org/elasticsearch/cluster/routing/allocation/AllocationService.java, +import com.google.common.collect.Lists;, +import java.util.*;, +        // shuffle the unassigned nodes, just so we won't have things like poison failed shards, +        Collections.shuffle(routingNodes.unassigned());, +        // shuffle the unassigned nodes, just so we won't have things like poison failed shards, +        Collections.shuffle(routingNodes.unassigned());, +        // shuffle the unassigned nodes, just so we won't have things like poison failed shards, +        Collections.shuffle(routingNodes.unassigned());, +        // shuffle the unassigned nodes, just so we won't have things like poison failed shards, +        Collections.shuffle(routingNodes.unassigned());, +        // move all the shards matching the failed shard to the end of the unassigned list, +        // so we give a chance for other allocations and won't create poison failed allocations, +        // that can keep other shards from being allocated (because of limits applied on how many, +        // shards we can start per node), +        List<MutableShardRouting> shardsToMove = Lists.newArrayList();, +        for (Iterator<MutableShardRouting> it = allocation.routingNodes().unassigned().iterator(); it.hasNext(); ) {, +            MutableShardRouting shardRouting = it.next();, +            if (shardRouting.shardId().equals(failedShard.shardId())) {, +                it.remove();, +                shardsToMove.add(shardRouting);, +            }, +        }, +        if (!shardsToMove.isEmpty()) {, +            allocation.routingNodes().unassigned().addAll(shardsToMove);, +        }, +, +++ b/src/main/java/org/elasticsearch/common/io/stream/AdapterStreamInput.java, +++ b/src/main/java/org/elasticsearch/action/update/TransportUpdateAction.java, +                    .percolate(request.percolate());, +++ b/src/main/java/org/elasticsearch/action/update/UpdateRequest.java, +++ b/src/main/java/org/elasticsearch/action/update/UpdateRequestBuilder.java, +++ b/src/main/java/org/elasticsearch/cluster/routing/allocation/AllocationService.java, +import com.google.common.collect.Lists;, +import java.util.*;, +        // shuffle the unassigned nodes, just so we won't have things like poison failed shards, +        Collections.shuffle(routingNodes.unassigned());, +        // shuffle the unassigned nodes, just so we won't have things like poison failed shards, +        Collections.shuffle(routingNodes.unassigned());, +        // shuffle the unassigned nodes, just so we won't have things like poison failed shards, +        Collections.shuffle(routingNodes.unassigned());, +        // shuffle the unassigned nodes, just so we won't have things like poison failed shards, +        Collections.shuffle(routingNodes.unassigned());, +        // move all the shards matching the failed shard to the end of the unassigned list, +        // so we give a chance for other allocations and won't create poison failed allocations, +        // that can keep other shards from being allocated (because of limits applied on how many, +        // shards we can start per node), +        List<MutableShardRouting> shardsToMove = Lists.newArrayList();, +        for (Iterator<MutableShardRouting> it = allocation.routingNodes().unassigned().iterator(); it.hasNext(); ) {, +            MutableShardRouting shardRouting = it.next();, +            if (shardRouting.shardId().equals(failedShard.shardId())) {, +                it.remove();, +                shardsToMove.add(shardRouting);, +            }, +        }, +        if (!shardsToMove.isEmpty()) {]