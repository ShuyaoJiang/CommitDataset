[+++ b/src/main/java/org/elasticsearch/index/store/fs/FsDirectoryService.java, +    public long throttleTimeInNanos() {, +    public StoreRateLimiting rateLimiting() {, +    public void onPause(long nanos) {, +++ b/src/main/java/org/elasticsearch/index/store/fs/FsDirectoryService.java, +    public long throttleTimeInNanos() {, +    public StoreRateLimiting rateLimiting() {, +    public void onPause(long nanos) {, +++ b/src/test/java/org/elasticsearch/indices/settings/UpdateSettingsTests.java, +import org.apache.lucene.util.LuceneTestCase.Slow;, +import org.elasticsearch.action.admin.cluster.node.stats.NodeStats;, +import org.elasticsearch.action.admin.cluster.node.stats.NodesStatsResponse;, +import org.elasticsearch.index.merge.policy.TieredMergePolicyProvider;, +import org.elasticsearch.index.store.support.AbstractIndexStore;, +import static org.elasticsearch.test.hamcrest.ElasticsearchAssertions.assertAcked;, +, +    // #6626: make sure we can update throttle settings and the changes take effect, +    @Test, +    @Slow, +    public void testUpdateThrottleSettings() {, +, +        // No throttling at first, only 1 non-replicated shard, force lots of merging:, +        assertAcked(prepareCreate("test"), +                    .setSettings(ImmutableSettings.builder(), +                                 .put(AbstractIndexStore.INDEX_STORE_THROTTLE_TYPE, "none"), +                                 .put(IndexMetaData.SETTING_NUMBER_OF_SHARDS, "1"), +                                 .put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, "0"), +                                 .put(TieredMergePolicyProvider.INDEX_MERGE_POLICY_MAX_MERGE_AT_ONCE, "2"), +                                 .put(TieredMergePolicyProvider.INDEX_MERGE_POLICY_SEGMENTS_PER_TIER, "2"), +                                 ));, +        ensureGreen();, +        long termUpto = 0;, +        for(int i=0;i<1000;i++) {, +            // Provoke slowish merging by making many unique terms:, +            StringBuilder sb = new StringBuilder();, +            for(int j=0;j<100;j++) {, +                sb.append(' ');, +                sb.append(termUpto++);, +            }, +            client().prepareIndex("test", "type", ""+termUpto).setSource("field" + (i%10), sb.toString()).get();, +            if (i % 2 == 0) {, +                refresh();, +            }, +        }, +, +        // No merge IO throttling should have happened:, +        NodesStatsResponse nodesStats = client().admin().cluster().prepareNodesStats().setIndices(true).get();, +        for(NodeStats stats : nodesStats.getNodes()) {, +            assertThat(stats.getIndices().getStore().getThrottleTime().getMillis(), equalTo(0l));, +        }, +, +        // Now updates settings to turn on merge throttling lowish rate, +        client(), +            .admin(), +            .indices(), +            .prepareUpdateSettings("test"), +            .setSettings(ImmutableSettings.builder(), +                         .put(AbstractIndexStore.INDEX_STORE_THROTTLE_TYPE, "merge"), +                         .put(AbstractIndexStore.INDEX_STORE_THROTTLE_MAX_BYTES_PER_SEC, "1mb")), +            .get();, +, +        // Make sure setting says it is in fact changed:, +        GetSettingsResponse getSettingsResponse = client().admin().indices().prepareGetSettings("test").get();, +        assertThat(getSettingsResponse.getSetting("test", AbstractIndexStore.INDEX_STORE_THROTTLE_TYPE), equalTo("merge"));, +, +        // Also make sure we see throttling kicking in:, +        boolean done = false;, +        while (done == false) {, +            // Provoke slowish merging by making many unique terms:, +            for(int i=0;i<5;i++) {, +                StringBuilder sb = new StringBuilder();, +                for(int j=0;j<100;j++) {, +                    sb.append(' ');, +                    sb.append(termUpto++);, +                    sb.append(" some random text that keeps repeating over and over again hambone");, +                }, +                client().prepareIndex("test", "type", ""+termUpto).setSource("field" + (i%10), sb.toString()).get();, +            }, +            refresh();, +            nodesStats = client().admin().cluster().prepareNodesStats().setIndices(true).get();, +            for(NodeStats stats : nodesStats.getNodes()) {, +                long throttleMillis = stats.getIndices().getStore().getThrottleTime().getMillis();, +                if (throttleMillis > 0) {, +                    done = true;, +                    break;, +                }, +            }, +        }, +, +        // Optimize does a waitForMerges, which we must do to make sure all in-flight (throttled) merges finish:, +        client().admin().indices().prepareOptimize("test").get();, +, +        // Now updates settings to disable merge throttling, +        client(), +            .admin(), +            .indices(), +            .prepareUpdateSettings("test"), +            .setSettings(ImmutableSettings.builder(), +                         .put(AbstractIndexStore.INDEX_STORE_THROTTLE_TYPE, "none")), +            .get();]