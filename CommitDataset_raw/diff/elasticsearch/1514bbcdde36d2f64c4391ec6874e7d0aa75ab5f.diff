[+++ b/x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authc/support/CachingUsernamePasswordRealm.java, +import org.elasticsearch.common.Nullable;, +    private final Cache<String, ListenableFuture<CachedResult>> cache;, +            cache = CacheBuilder.<String, ListenableFuture<CachedResult>>builder(), +            final ListenableFuture<CachedResult> listenableCacheEntry = cache.computeIfAbsent(token.principal(), k -> {, +                listenableCacheEntry.addListener(ActionListener.wrap(cachedResult -> {, +                    final boolean credsMatch = cachedResult.verify(token.credentials());, +                    if (cachedResult.authenticationResult.isAuthenticated()) {, +                        if (credsMatch) {, +                            handleCachedAuthentication(cachedResult.user, ActionListener.wrap(cacheResult -> {, +                            // its credential hash does not match the, +                    } else if (credsMatch) {, +                        // not authenticated but instead of hammering reuse the result. a new, +                        // request will trigger a retried auth, +                        listener.onResponse(cachedResult.authenticationResult);, +                    } else {, +                    }, +                }, listener::onFailure), threadPool.executor(ThreadPool.Names.GENERIC), threadPool.getThreadContext());, +                    if (authResult.isAuthenticated() == false || authResult.getUser().enabled() == false) {, +                        // a new request should trigger a new authentication, +                        cache.invalidate(token.principal(), listenableCacheEntry);, +                    // notify any forestalled request listeners; they will not reach to the, +                    // authentication request and instead will use this result if they contain, +                    // the same credentials, +                    listenableCacheEntry.onResponse(new CachedResult(authResult, cacheHasher, authResult.getUser(), token.credentials()));, +                    cache.invalidate(token.principal(), listenableCacheEntry);, +                    // notify any staved off listeners; they will propagate this error, +                    // notify the listener of the inflight authentication request, +            final ListenableFuture<CachedResult> listenableCacheEntry = cache.computeIfAbsent(username, key -> {, +                    final CachedResult result = new CachedResult(AuthenticationResult.notHandled(), cacheHasher, user, null);, +                    if (user == null) {, +                    // notify forestalled request listeners, +                    listenableCacheEntry.onResponse(result);, +            listenableCacheEntry.addListener(ActionListener.wrap(cachedResult -> {, +                if (cachedResult.user != null) {, +                    listener.onResponse(cachedResult.user);, +    private static class CachedResult {, +        private final AuthenticationResult authenticationResult;, +        private final User user;, +        private final char[] hash;, +        private CachedResult(AuthenticationResult result, Hasher hasher, @Nullable User user, @Nullable SecureString password) {, +            this.authenticationResult = Objects.requireNonNull(result);, +            if (authenticationResult.isAuthenticated() && user == null) {, +                throw new IllegalArgumentException("authentication cannot be successful with a null user");, +            }, +            this.user = user;, +        private boolean verify(SecureString password) {, +++ b/x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authc/support/CachingUsernamePasswordRealm.java, +import org.elasticsearch.common.Nullable;, +    private final Cache<String, ListenableFuture<CachedResult>> cache;, +            cache = CacheBuilder.<String, ListenableFuture<CachedResult>>builder(), +            final ListenableFuture<CachedResult> listenableCacheEntry = cache.computeIfAbsent(token.principal(), k -> {, +                listenableCacheEntry.addListener(ActionListener.wrap(cachedResult -> {, +                    final boolean credsMatch = cachedResult.verify(token.credentials());, +                    if (cachedResult.authenticationResult.isAuthenticated()) {, +                        if (credsMatch) {, +                            handleCachedAuthentication(cachedResult.user, ActionListener.wrap(cacheResult -> {, +                            // its credential hash does not match the, +                    } else if (credsMatch) {, +                        // not authenticated but instead of hammering reuse the result. a new, +                        // request will trigger a retried auth, +                        listener.onResponse(cachedResult.authenticationResult);, +                    } else {, +                    }, +                }, listener::onFailure), threadPool.executor(ThreadPool.Names.GENERIC), threadPool.getThreadContext());, +                    if (authResult.isAuthenticated() == false || authResult.getUser().enabled() == false) {, +                        // a new request should trigger a new authentication, +                        cache.invalidate(token.principal(), listenableCacheEntry);, +                    // notify any forestalled request listeners; they will not reach to the, +                    // authentication request and instead will use this result if they contain, +                    // the same credentials, +                    listenableCacheEntry.onResponse(new CachedResult(authResult, cacheHasher, authResult.getUser(), token.credentials()));, +                    cache.invalidate(token.principal(), listenableCacheEntry);, +                    // notify any staved off listeners; they will propagate this error, +                    // notify the listener of the inflight authentication request, +            final ListenableFuture<CachedResult> listenableCacheEntry = cache.computeIfAbsent(username, key -> {, +                    final CachedResult result = new CachedResult(AuthenticationResult.notHandled(), cacheHasher, user, null);, +                    if (user == null) {, +                    // notify forestalled request listeners, +                    listenableCacheEntry.onResponse(result);, +            listenableCacheEntry.addListener(ActionListener.wrap(cachedResult -> {, +                if (cachedResult.user != null) {, +                    listener.onResponse(cachedResult.user);, +    private static class CachedResult {, +        private final AuthenticationResult authenticationResult;, +        private final User user;, +        private final char[] hash;, +        private CachedResult(AuthenticationResult result, Hasher hasher, @Nullable User user, @Nullable SecureString password) {, +            this.authenticationResult = Objects.requireNonNull(result);, +            if (authenticationResult.isAuthenticated() && user == null) {, +                throw new IllegalArgumentException("authentication cannot be successful with a null user");, +            }, +            this.user = user;, +        private boolean verify(SecureString password) {, +++ b/x-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/authc/support/CachingUsernamePasswordRealmTests.java, +    public void stop() {, +    public void testCacheSettings() {, +    public void testAuthenticateContract() {, +    public void testLookupContract() {, +    public void testReturnDifferentObjectFromCache() {]