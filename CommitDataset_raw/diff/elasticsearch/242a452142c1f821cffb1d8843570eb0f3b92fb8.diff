[+++ b/src/main/java/org/elasticsearch/index/engine/InternalEngine.java, +                if (indexWriter.hasUncommittedChanges() || force) {, +++ b/src/main/java/org/elasticsearch/index/engine/InternalEngine.java, +                if (indexWriter.hasUncommittedChanges() || force) {, +++ b/src/test/java/org/elasticsearch/index/store/CorruptedFileTest.java, +import org.elasticsearch.test.InternalTestCluster;, +import java.io.OutputStream;, +import java.nio.file.DirectoryStream;, +import java.nio.file.Files;, +import java.nio.file.Path;, +import java.nio.file.StandardOpenOption;, +    /**, +     * This test verifies that if we corrupt a replica, we can still get to green, even though, +     * listing its store fails. Note, we need to make sure that replicas are allocated on all data, +     * nodes, so that replica won't be sneaky and allocated on a node that doesn't have a corrupted, +     * replica., +     */, +    @Test, +    @AwaitsFix(bugUrl = "https://github.com/elastic/elasticsearch/issues/11226"), +    public void testReplicaCorruption() throws Exception {, +        int numDocs = scaledRandomIntBetween(100, 1000);, +        internalCluster().ensureAtLeastNumDataNodes(2);, +, +        assertAcked(prepareCreate("test").setSettings(ImmutableSettings.builder(), +                        .put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, cluster().numDataNodes() - 1), +                        .put(MergePolicyModule.MERGE_POLICY_TYPE_KEY, NoMergePolicyProvider.class), +                        .put(MockFSDirectoryService.CHECK_INDEX_ON_CLOSE, false) // no checkindex - we corrupt shards on purpose, +                        .put(TranslogService.INDEX_TRANSLOG_DISABLE_FLUSH, true) // no translog based flush - it might change the .liv / segments.N files, +                        .put("indices.recovery.concurrent_streams", 10), +        ));, +        ensureGreen();, +        IndexRequestBuilder[] builders = new IndexRequestBuilder[numDocs];, +        for (int i = 0; i < builders.length; i++) {, +            builders[i] = client().prepareIndex("test", "type").setSource("field", "value");, +        }, +        indexRandom(true, builders);, +        ensureGreen();, +        assertAllSuccessful(client().admin().indices().prepareFlush().setForce(true).setWaitIfOngoing(true).execute().actionGet());, +        // we have to flush at least once here since we don't corrupt the translog, +        CountResponse countResponse = client().prepareCount().get();, +        assertHitCount(countResponse, numDocs);, +, +        final Map<String, List<Path>> filesToCorrupt = findFilesToCorruptForReplica();, +        internalCluster().fullRestart(new InternalTestCluster.RestartCallback() {, +            @Override, +            public Settings onNodeStopped(String nodeName) throws Exception {, +                List<Path> paths = filesToCorrupt.get(nodeName);, +                if (paths != null) {, +                    for (Path path : paths) {, +                        try (OutputStream os = Files.newOutputStream(path)) {, +                            os.write(0);, +                        }, +                        logger.info("corrupting file {} on node {}", path, nodeName);, +                    }, +                }, +                return null;, +            }, +        });, +        ensureGreen();, +    }, +, +    private Map<String, List<Path>> findFilesToCorruptForReplica() throws IOException {, +        Map<String, List<Path>> filesToNodes = new HashMap<>();, +        ClusterState state = client().admin().cluster().prepareState().get().getState();, +        for (ShardRouting shardRouting : state.getRoutingTable().allShards("test")) {, +            if (shardRouting.primary() == true) {, +                continue;, +            }, +            assertTrue(shardRouting.assignedToNode());, +            NodesStatsResponse nodeStatses = client().admin().cluster().prepareNodesStats(shardRouting.currentNodeId()).setFs(true).get();, +            NodeStats nodeStats = nodeStatses.getNodes()[0];, +            List<Path> files = new ArrayList<>();, +            filesToNodes.put(nodeStats.getNode().getName(), files);, +            for (FsStats.Info info : nodeStats.getFs()) {, +                String path = info.getPath();, +                final String relativeDataLocationPath = "indices/test/" + Integer.toString(shardRouting.getId()) + "/index";, +                Path file = PathUtils.get(path).resolve(relativeDataLocationPath);, +                if (Files.exists(file)) { // multi data path might only have one path in use, +                    try (DirectoryStream<Path> stream = Files.newDirectoryStream(file)) {, +                        for (Path item : stream) {, +                            if (item.getFileName().toString().startsWith("segments_")) {, +                                files.add(item);, +                            }, +                        }, +                    }, +                }, +            }, +        }, +        return filesToNodes;, +    }]