[+++ b/buildSrc/src/main/groovy/org/elasticsearch/gradle/test/ClusterConfiguration.groovy, +     * A closure to call which returns a map of settings., +     *, +     * This can be used to pass settings to a cluster that are not available at evaluation time ie., +     * the address of a remote cluster etc., +     */, +    @Input, +    Closure dynamicSettings = {  -> Collections.emptyMap() }, +, +    /**, +++ b/buildSrc/src/main/groovy/org/elasticsearch/gradle/test/ClusterConfiguration.groovy, +     * A closure to call which returns a map of settings., +     *, +     * This can be used to pass settings to a cluster that are not available at evaluation time ie., +     * the address of a remote cluster etc., +     */, +    @Input, +    Closure dynamicSettings = {  -> Collections.emptyMap() }, +, +    /**, +++ b/buildSrc/src/main/groovy/org/elasticsearch/gradle/test/ClusterFormationTasks.groovy, +            Map dynamicSettings = node.config.dynamicSettings();, +            esConfig.putAll(dynamicSettings), +++ b/buildSrc/src/main/groovy/org/elasticsearch/gradle/test/ClusterConfiguration.groovy, +     * A closure to call which returns a map of settings., +     *, +     * This can be used to pass settings to a cluster that are not available at evaluation time ie., +     * the address of a remote cluster etc., +     */, +    @Input, +    Closure dynamicSettings = {  -> Collections.emptyMap() }, +, +    /**, +++ b/buildSrc/src/main/groovy/org/elasticsearch/gradle/test/ClusterFormationTasks.groovy, +            Map dynamicSettings = node.config.dynamicSettings();, +            esConfig.putAll(dynamicSettings), +++ b/core/src/main/java/org/elasticsearch/action/search/SearchTransportService.java, +import org.elasticsearch.Version;, +import org.elasticsearch.action.admin.cluster.shards.ClusterSearchShardsAction;, +import org.elasticsearch.action.admin.cluster.shards.ClusterSearchShardsRequest;, +import org.elasticsearch.action.admin.cluster.shards.ClusterSearchShardsResponse;, +import org.elasticsearch.common.Randomness;, +import org.elasticsearch.common.settings.ClusterSettings;, +import org.elasticsearch.common.settings.Setting;, +import org.elasticsearch.common.transport.TransportAddress;, +import org.elasticsearch.common.util.concurrent.CountDown;, +import org.elasticsearch.transport.ConnectTransportException;, +import org.elasticsearch.transport.TransportException;, +import org.elasticsearch.transport.TransportResponseHandler;, +import java.net.InetAddress;, +import java.net.InetSocketAddress;, +import java.net.UnknownHostException;, +import java.util.ArrayList;, +import java.util.HashMap;, +import java.util.List;, +import java.util.Map;, +import java.util.concurrent.ConcurrentHashMap;, +import java.util.concurrent.atomic.AtomicReference;, +    //TODO what should the setting name be?, +    public static final Setting<Settings> REMOTE_CLUSTERS_SEEDS = Setting.groupSetting("action.search.remote.",, +            SearchTransportService::validateRemoteClustersSeeds,, +            Setting.Property.NodeScope,, +            Setting.Property.Dynamic);, +    private final TransportService transportService;, +    private volatile Map<String, List<DiscoveryNode>> remoteClustersSeeds;, +, +    public SearchTransportService(Settings settings, ClusterSettings clusterSettings, TransportService transportService) {, +        setRemoteClustersSeeds(REMOTE_CLUSTERS_SEEDS.get(settings));, +        clusterSettings.addSettingsUpdateConsumer(REMOTE_CLUSTERS_SEEDS, this::setRemoteClustersSeeds,, +                SearchTransportService::validateRemoteClustersSeeds);, +    }, +, +    private static void validateRemoteClustersSeeds(Settings settings) {, +        //TODO add a static whitelist like in reindex from remote, +        for (String clusterName : settings.names()) {, +            String[] remoteHosts = settings.getAsArray(clusterName);, +            if (remoteHosts.length == 0) {, +                throw new IllegalArgumentException("no hosts set for remote cluster [" + clusterName + "], at least one host is required");, +            }, +            for (String remoteHost : remoteHosts) {, +                int portSeparator = remoteHost.lastIndexOf(':'); // in case we have a IPv6 address ie. [::1]:9300, +                if (portSeparator == -1 || portSeparator == remoteHost.length()) {, +                    throw new IllegalArgumentException("remote hosts need to be configured as [host:port], found [" + remoteHost + "] " +, +                        "instead for remote cluster [" + clusterName + "]");, +                }, +                String host = remoteHost.substring(0, portSeparator);, +                try {, +                    InetAddress.getByName(host);, +                } catch (UnknownHostException e) {, +                    throw new IllegalArgumentException("unknown host [" + host + "]", e);, +                }, +                String port = remoteHost.substring(portSeparator + 1);, +                try {, +                    Integer portValue = Integer.valueOf(port);, +                    if (portValue <= 0) {, +                        throw new IllegalArgumentException("port number must be > 0 but was: [" + portValue + "]");, +                    }, +                } catch(NumberFormatException e) {, +                    throw new IllegalArgumentException("port must be a number, found [" + port + "] instead for remote cluster [" +, +                            clusterName + "]");]