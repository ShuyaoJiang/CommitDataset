[+++ b/server/src/main/java/org/elasticsearch/index/shard/IndexShard.java, +import org.elasticsearch.common.util.concurrent.RunOnce;, +                        }, null);, +    private <E extends Exception> void bumpPrimaryTerm(final long newPrimaryTerm,, +                                                       final CheckedRunnable<E> onBlocked,, +                                                       @Nullable ActionListener<Releasable> combineWithAction) {, +        assert newPrimaryTerm > pendingPrimaryTerm || (newPrimaryTerm >= pendingPrimaryTerm && combineWithAction != null);, +                    innerFail(e);, +                } finally {, +                    if (combineWithAction != null) {, +                        combineWithAction.onFailure(e);, +                    }, +                }, +            }, +, +            private void innerFail(final Exception e) {, +                try {, +                final RunOnce releaseOnce = new RunOnce(releasable::close);, +                try {, +                    if (combineWithAction == null) {, +                        // otherwise leave it to combineWithAction to release the permit, +                        releaseOnce.run();, +                    }, +                    innerFail(e);, +                } finally {, +                    if (combineWithAction != null) {, +                        combineWithAction.onResponse(releasable);, +                    } else {, +                        releaseOnce.run();, +                    }, +        innerAcquireReplicaOperationPermit(opPrimaryTerm, globalCheckpoint, maxSeqNoOfUpdatesOrDeletes, onPermitAcquired, false,, +        innerAcquireReplicaOperationPermit(opPrimaryTerm, globalCheckpoint, maxSeqNoOfUpdatesOrDeletes, onPermitAcquired, true,, +                                                    final boolean allowCombineOperationWithPrimaryTermUpdate,, +                                                    final Consumer<ActionListener<Releasable>> operationExecutor) {, +        // This listener is used for the execution of the operation. If the operation requires all the permits for its, +        // execution and the primary term must be updated first, we can combine the operation execution with the, +        // primary term update. Since indexShardOperationPermits doesn't guarantee that async submissions are executed, +        // in the order submitted, combining both operations ensure that the term is updated before the operation is, +        // executed. It also has the side effect of acquiring all the permits one time instead of two., +        final ActionListener<Releasable> operationListener = new ActionListener<Releasable>() {, +        };, +, +        if (requirePrimaryTermUpdate(opPrimaryTerm, allowCombineOperationWithPrimaryTermUpdate)) {, +            synchronized (mutex) {, +                if (requirePrimaryTermUpdate(opPrimaryTerm, allowCombineOperationWithPrimaryTermUpdate)) {, +                    final IndexShardState shardState = state();, +                    // only roll translog and update primary term if shard has made it past recovery, +                    // Having a new primary term here means that the old primary failed and that there is a new primary, which again, +                    // means that the master will fail this shard as all initializing shards are failed when a primary is selected, +                    // We abort early here to prevent an ongoing recovery from the failed primary to mess with the global / local checkpoint, +                    if (shardState != IndexShardState.POST_RECOVERY &&, +                        shardState != IndexShardState.STARTED) {, +                        throw new IndexShardNotStartedException(shardId, shardState);, +                    }, +, +                    bumpPrimaryTerm(opPrimaryTerm, () -> {, +                        updateGlobalCheckpointOnReplica(globalCheckpoint, "primary term transition");, +                        final long currentGlobalCheckpoint = getGlobalCheckpoint();, +                        final long maxSeqNo = seqNoStats().getMaxSeqNo();, +                        logger.info("detected new primary with primary term [{}], global checkpoint [{}], max_seq_no [{}]",, +                            opPrimaryTerm, currentGlobalCheckpoint, maxSeqNo);, +                        if (currentGlobalCheckpoint < maxSeqNo) {, +                            resetEngineToGlobalCheckpoint();, +                        } else {, +                            getEngine().rollTranslogGeneration();, +                        }, +                    }, allowCombineOperationWithPrimaryTermUpdate ? operationListener : null);, +, +                    if (allowCombineOperationWithPrimaryTermUpdate) {, +                        logger.debug("operation execution has been combined with primary term update");, +                        return;, +                    }, +                }, +            }, +        }, +        assert opPrimaryTerm <= pendingPrimaryTerm, +            : "operation primary term [" + opPrimaryTerm + "] should be at most [" + pendingPrimaryTerm + "]";, +        operationExecutor.accept(operationListener);, +    }, +, +    private boolean requirePrimaryTermUpdate(final long opPrimaryTerm, final boolean allPermits) {, +        return (opPrimaryTerm > pendingPrimaryTerm) || (allPermits && opPrimaryTerm > operationPrimaryTerm);, +++ b/server/src/main/java/org/elasticsearch/index/shard/IndexShard.java, +import org.elasticsearch.common.util.concurrent.RunOnce;, +                        }, null);, +    private <E extends Exception> void bumpPrimaryTerm(final long newPrimaryTerm,, +                                                       final CheckedRunnable<E> onBlocked,, +                                                       @Nullable ActionListener<Releasable> combineWithAction) {, +        assert newPrimaryTerm > pendingPrimaryTerm || (newPrimaryTerm >= pendingPrimaryTerm && combineWithAction != null);, +                    innerFail(e);, +                } finally {, +                    if (combineWithAction != null) {, +                        combineWithAction.onFailure(e);, +                    }, +                }, +            }, +, +            private void innerFail(final Exception e) {, +                try {, +                final RunOnce releaseOnce = new RunOnce(releasable::close);]