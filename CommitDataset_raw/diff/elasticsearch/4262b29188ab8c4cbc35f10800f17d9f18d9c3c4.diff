[+++ b/plugin/src/main/java/org/elasticsearch/xpack/security/authz/store/CompositeRolesStore.java, +import java.util.Collection;, +import org.apache.logging.log4j.message.ParameterizedMessage;, +import org.elasticsearch.action.ActionListener;, +import org.elasticsearch.cluster.health.ClusterHealthStatus;, +import org.elasticsearch.cluster.health.ClusterIndexHealth;, +import org.elasticsearch.common.Strings;, +import org.elasticsearch.common.bytes.BytesReference;, +import org.elasticsearch.common.cache.Cache;, +import org.elasticsearch.common.cache.CacheBuilder;, +import org.elasticsearch.common.component.AbstractComponent;, +import org.elasticsearch.common.inject.internal.Nullable;, +import org.elasticsearch.common.settings.Setting;, +import org.elasticsearch.common.settings.Setting.Property;, +import org.elasticsearch.common.settings.Settings;, +import org.elasticsearch.common.util.concurrent.ConcurrentCollections;, +import org.elasticsearch.common.util.concurrent.ReleasableLock;, +import org.elasticsearch.common.util.concurrent.ThreadContext;, +import org.elasticsearch.common.util.set.Sets;, +import org.elasticsearch.license.XPackLicenseState;, +import org.elasticsearch.xpack.common.IteratingActionListener;, +import org.elasticsearch.xpack.security.authz.RoleDescriptor;, +import org.elasticsearch.xpack.security.authz.RoleDescriptor.IndicesPrivileges;, +import org.elasticsearch.xpack.security.authz.permission.FieldPermissionsCache;, +import org.elasticsearch.xpack.security.authz.permission.FieldPermissionsDefinition;, +import org.elasticsearch.xpack.security.authz.permission.FieldPermissionsDefinition.FieldGrantExcludeGroup;, +import org.elasticsearch.xpack.security.authz.permission.Role;, +import org.elasticsearch.xpack.security.authz.privilege.ClusterPrivilege;, +import org.elasticsearch.xpack.security.authz.privilege.IndexPrivilege;, +import org.elasticsearch.xpack.security.authz.privilege.Privilege;, +, +        final Set<String> filteredRoleNames = roleNames.stream().filter((s) -> {, +            if (negativeLookupCache.contains(s)) {, +                logger.debug("Requested role [{}] does not exist (cached)", s);, +                return false;, +            } else {, +                return true;, +            }, +        }).collect(Collectors.toSet());, +                logger.debug(() -> new ParameterizedMessage("Roles [{}] were resolved from the native index store", names(descriptors)));, +                        logger.debug(() ->, +                                new ParameterizedMessage("Roles [{}] were resolved by [{}]", names(resolvedDescriptors), rolesProvider));, +                logger.debug(() ->, +                        new ParameterizedMessage("Requested roles [{}] do not exist", Strings.collectionToCommaDelimitedString(missing)));, +        if (descriptors.size() > 0) {, +            logger.debug(() -> new ParameterizedMessage("Roles [{}] are builtin roles", names(descriptors)));, +        }, +            final Set<RoleDescriptor> fileRoles = fileRolesStore.roleDescriptors(difference);, +            logger.debug(() ->, +                    new ParameterizedMessage("Roles [{}] were resolved from [{}]", names(fileRoles), fileRolesStore.getFile()));, +            descriptors.addAll(fileRoles);, +    private String names(Collection<RoleDescriptor> descriptors) {, +        return descriptors.stream().map(RoleDescriptor::getName).collect(Collectors.joining(","));, +    }, +, +++ b/plugin/src/main/java/org/elasticsearch/xpack/security/authz/store/CompositeRolesStore.java, +import java.util.Collection;, +import org.apache.logging.log4j.message.ParameterizedMessage;, +import org.elasticsearch.action.ActionListener;, +import org.elasticsearch.cluster.health.ClusterHealthStatus;, +import org.elasticsearch.cluster.health.ClusterIndexHealth;, +import org.elasticsearch.common.Strings;, +import org.elasticsearch.common.bytes.BytesReference;, +import org.elasticsearch.common.cache.Cache;, +import org.elasticsearch.common.cache.CacheBuilder;, +import org.elasticsearch.common.component.AbstractComponent;, +import org.elasticsearch.common.inject.internal.Nullable;, +import org.elasticsearch.common.settings.Setting;, +import org.elasticsearch.common.settings.Setting.Property;, +import org.elasticsearch.common.settings.Settings;, +import org.elasticsearch.common.util.concurrent.ConcurrentCollections;, +import org.elasticsearch.common.util.concurrent.ReleasableLock;, +import org.elasticsearch.common.util.concurrent.ThreadContext;, +import org.elasticsearch.common.util.set.Sets;, +import org.elasticsearch.license.XPackLicenseState;, +import org.elasticsearch.xpack.common.IteratingActionListener;, +import org.elasticsearch.xpack.security.authz.RoleDescriptor;, +import org.elasticsearch.xpack.security.authz.RoleDescriptor.IndicesPrivileges;, +import org.elasticsearch.xpack.security.authz.permission.FieldPermissionsCache;, +import org.elasticsearch.xpack.security.authz.permission.FieldPermissionsDefinition;, +import org.elasticsearch.xpack.security.authz.permission.FieldPermissionsDefinition.FieldGrantExcludeGroup;, +import org.elasticsearch.xpack.security.authz.permission.Role;, +import org.elasticsearch.xpack.security.authz.privilege.ClusterPrivilege;, +import org.elasticsearch.xpack.security.authz.privilege.IndexPrivilege;, +import org.elasticsearch.xpack.security.authz.privilege.Privilege;, +, +        final Set<String> filteredRoleNames = roleNames.stream().filter((s) -> {, +            if (negativeLookupCache.contains(s)) {, +                logger.debug("Requested role [{}] does not exist (cached)", s);, +                return false;, +            } else {, +                return true;, +            }, +        }).collect(Collectors.toSet());, +                logger.debug(() -> new ParameterizedMessage("Roles [{}] were resolved from the native index store", names(descriptors)));, +                        logger.debug(() ->, +                                new ParameterizedMessage("Roles [{}] were resolved by [{}]", names(resolvedDescriptors), rolesProvider));, +                logger.debug(() ->, +                        new ParameterizedMessage("Requested roles [{}] do not exist", Strings.collectionToCommaDelimitedString(missing)));, +        if (descriptors.size() > 0) {]