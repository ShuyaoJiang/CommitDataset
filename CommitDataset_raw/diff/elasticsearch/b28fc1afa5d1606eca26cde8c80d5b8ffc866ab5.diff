[+++ b/src/main/java/org/elasticsearch/index/engine/internal/InternalEngine.java, +import org.apache.lucene.store.Directory;, +import java.io.Closeable;, +    private volatile Closeable storeReference;, +        throw new UnsupportedOperationException("addFailedEngineListener is not supported by InternalEngine. Use InternalEngineHolder.");, +        /*, +         * This might look weird but it's in-fact needed since if we close, +         * the engine due to a corruption on IW startup the reference is decremented in the close, +         * method and this must not happen more than once, +         */, +        final Closeable storeRef = new Closeable() {, +            private final AtomicBoolean closed = new AtomicBoolean(false);, +            @Override, +            public void close() throws IOException {, +                if (closed.compareAndSet(false, true)) {, +                    store.decRef();, +                }, +            }, +        };, +        final List<Closeable> closeOnFailure = new ArrayList<>(Arrays.asList(storeRef));, +            IndexWriter indexWriter = this.indexWriter;, +            storeReference = storeRef;, +                indexWriter = createWriter();, +                closeOnFailure.add(indexWriter);, +                final long translogId = Math.max(0, translog.findLargestPresentTranslogId()) + 1;, +                    indexWriter.setCommitData(Collections.singletonMap(Translog.TRANSLOG_ID_KEY, Long.toString(translogId)));, +, +                translog.newTranslog(translogId);, +                final SearcherManager searcherManager = buildSearchManager(indexWriter);, +                closeOnFailure.add(searcherManager);, +                this.lastCommittedSegmentInfos = store.readLastCommittedSegmentsInfo();, +                this.searcherManager = searcherManager;, +                translogIdGenerator.set(translogId);, +                this.indexWriter = indexWriter;, +                closeOnFailure.clear(); // all is well, +                    if (indexWriter != null) {, +                    }, +                } catch (IOException e1) { // iw is closed below, +                    e.addSuppressed(e1);, +            if (closeOnFailure.isEmpty() == false) { // release everything we created on a failure, +                IOUtils.closeWhileHandlingException(closeOnFailure);, +            }, +        throw new UnsupportedOperationException("stop() is not supported by InternalEngine. Use InternalEngineHolder.");, +                lastCommittedSegmentInfos = store.readLastCommittedSegmentsInfo();, +                    IOUtils.closeWhileHandlingException(storeReference);, +++ b/src/main/java/org/elasticsearch/index/engine/internal/InternalEngine.java, +import org.apache.lucene.store.Directory;, +import java.io.Closeable;, +    private volatile Closeable storeReference;, +        throw new UnsupportedOperationException("addFailedEngineListener is not supported by InternalEngine. Use InternalEngineHolder.");, +        /*, +         * This might look weird but it's in-fact needed since if we close, +         * the engine due to a corruption on IW startup the reference is decremented in the close, +         * method and this must not happen more than once, +         */, +        final Closeable storeRef = new Closeable() {, +            private final AtomicBoolean closed = new AtomicBoolean(false);, +            @Override, +            public void close() throws IOException {, +                if (closed.compareAndSet(false, true)) {, +                    store.decRef();, +                }, +            }, +        };, +        final List<Closeable> closeOnFailure = new ArrayList<>(Arrays.asList(storeRef));, +            IndexWriter indexWriter = this.indexWriter;, +            storeReference = storeRef;, +                indexWriter = createWriter();, +                closeOnFailure.add(indexWriter);, +                final long translogId = Math.max(0, translog.findLargestPresentTranslogId()) + 1;, +                    indexWriter.setCommitData(Collections.singletonMap(Translog.TRANSLOG_ID_KEY, Long.toString(translogId)));, +, +                translog.newTranslog(translogId);, +                final SearcherManager searcherManager = buildSearchManager(indexWriter);, +                closeOnFailure.add(searcherManager);, +                this.lastCommittedSegmentInfos = store.readLastCommittedSegmentsInfo();, +                this.searcherManager = searcherManager;, +                translogIdGenerator.set(translogId);, +                this.indexWriter = indexWriter;, +                closeOnFailure.clear(); // all is well, +                    if (indexWriter != null) {, +                    }, +                } catch (IOException e1) { // iw is closed below, +                    e.addSuppressed(e1);, +            if (closeOnFailure.isEmpty() == false) { // release everything we created on a failure, +                IOUtils.closeWhileHandlingException(closeOnFailure);, +            }, +        throw new UnsupportedOperationException("stop() is not supported by InternalEngine. Use InternalEngineHolder.");, +                lastCommittedSegmentInfos = store.readLastCommittedSegmentsInfo();, +                    IOUtils.closeWhileHandlingException(storeReference);, +++ b/src/main/java/org/elasticsearch/index/engine/internal/InternalEngineHolder.java, +        store.incRef();, +        InternalEngine newEngine = createEngine();, +        store.incRef();, +        try {, +        } finally {, +            store.decRef();, +        }, +        if (closed) {, +            return;]