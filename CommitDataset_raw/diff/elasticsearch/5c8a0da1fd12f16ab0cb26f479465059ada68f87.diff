[+++ b/buildSrc/src/main/groovy/com/carrotsearch/gradle/junit4/RandomizedTestingTask.groovy, +    Map<String, Object> systemProperties = new HashMap<>(), +    void systemProperty(String property, Object value) {, +                for (Map.Entry<String, Object> prop : systemProperties) {, +                    sysproperty key: prop.getKey(), value: prop.getValue().toString(), +++ b/buildSrc/src/main/groovy/com/carrotsearch/gradle/junit4/RandomizedTestingTask.groovy, +    Map<String, Object> systemProperties = new HashMap<>(), +    void systemProperty(String property, Object value) {, +                for (Map.Entry<String, Object> prop : systemProperties) {, +                    sysproperty key: prop.getKey(), value: prop.getValue().toString(), +++ b/buildSrc/src/main/groovy/org/elasticsearch/gradle/test/ClusterConfiguration.groovy, +    int httpPort = 0, +    int transportPort = 0, +        ant.get(src: "http://${node.httpUri()}",, +++ b/buildSrc/src/main/groovy/com/carrotsearch/gradle/junit4/RandomizedTestingTask.groovy, +    Map<String, Object> systemProperties = new HashMap<>(), +    void systemProperty(String property, Object value) {, +                for (Map.Entry<String, Object> prop : systemProperties) {, +                    sysproperty key: prop.getKey(), value: prop.getValue().toString(), +++ b/buildSrc/src/main/groovy/org/elasticsearch/gradle/test/ClusterConfiguration.groovy, +    int httpPort = 0, +    int transportPort = 0, +        ant.get(src: "http://${node.httpUri()}",, +++ b/buildSrc/src/main/groovy/org/elasticsearch/gradle/test/ClusterFormationTasks.groovy, +     *, +     * Returns an object that will resolve at execution time of the given task to a uri for the cluster., +    static Object setup(Project project, Task task, ClusterConfiguration config) {, +, +        // delay the resolution of the uri by wrapping in a closure, so it is not used until read for tests, +        return "${-> nodes[0].transportUri()}", +        if (node.config.numNodes == 1) {, +            esConfig['http.port'] = node.config.httpPort, +            esConfig['transport.tcp.port'] =  node.config.transportPort, +        } else {, +            // TODO: fix multi node so it doesn't use hardcoded prots, +            esConfig['http.port'] = 9400 + node.nodeNum, +            esConfig['transport.tcp.port'] =  9500 + node.nodeNum, +            esConfig['discovery.zen.ping.unicast.hosts'] = (0..<node.config.numNodes).collect{"localhost:${9500 + it}"}.join(','), +, +        }, +                            resourceexists {, +                                file(file: node.httpPortsFile.toString()), +                            }, +                            resourceexists {, +                                file(file: node.transportPortsFile.toString()), +                            }, +            logger.error("|  http ports file exists: ${node.httpPortsFile.exists()}"), +            logger.error("|  transport ports file exists: ${node.transportPortsFile.exists()}"), +++ b/buildSrc/src/main/groovy/com/carrotsearch/gradle/junit4/RandomizedTestingTask.groovy, +    Map<String, Object> systemProperties = new HashMap<>(), +    void systemProperty(String property, Object value) {, +                for (Map.Entry<String, Object> prop : systemProperties) {, +                    sysproperty key: prop.getKey(), value: prop.getValue().toString(), +++ b/buildSrc/src/main/groovy/org/elasticsearch/gradle/test/ClusterConfiguration.groovy, +    int httpPort = 0, +    int transportPort = 0, +        ant.get(src: "http://${node.httpUri()}",, +++ b/buildSrc/src/main/groovy/org/elasticsearch/gradle/test/ClusterFormationTasks.groovy, +     *, +     * Returns an object that will resolve at execution time of the given task to a uri for the cluster., +    static Object setup(Project project, Task task, ClusterConfiguration config) {, +, +        // delay the resolution of the uri by wrapping in a closure, so it is not used until read for tests, +        return "${-> nodes[0].transportUri()}", +        if (node.config.numNodes == 1) {, +            esConfig['http.port'] = node.config.httpPort, +            esConfig['transport.tcp.port'] =  node.config.transportPort, +        } else {, +            // TODO: fix multi node so it doesn't use hardcoded prots, +            esConfig['http.port'] = 9400 + node.nodeNum, +            esConfig['transport.tcp.port'] =  9500 + node.nodeNum, +            esConfig['discovery.zen.ping.unicast.hosts'] = (0..<node.config.numNodes).collect{"localhost:${9500 + it}"}.join(','), +, +        }, +                            resourceexists {, +                                file(file: node.httpPortsFile.toString()), +                            }, +                            resourceexists {, +                                file(file: node.transportPortsFile.toString()), +                            }, +            logger.error("|  http ports file exists: ${node.httpPortsFile.exists()}"), +            logger.error("|  transport ports file exists: ${node.transportPortsFile.exists()}"), +++ b/buildSrc/src/main/groovy/org/elasticsearch/gradle/test/NodeInfo.groovy, +    /** a file written by elasticsearch containing the ports of each bound address for http */, +    File httpPortsFile, +, +    /** a file written by elasticsearch containing the ports of each bound address for transport */, +    File transportPortsFile, +, +        // even for rpm/deb, the logs are under home because we dont start with real services, +        File logsDir = new File(homeDir, 'logs'), +        httpPortsFile = new File(logsDir, 'http.ports'), +        transportPortsFile = new File(logsDir, 'transport.ports'), +        args.add("-Des.tests.portsfile=true"), +    /** Returns an address and port suitable for a uri to connect to this node over http */, +    String httpUri() {, +        return httpPortsFile.readLines("UTF-8").get(0), +    /** Returns an address and port suitable for a uri to connect to this node over transport protocol */, +    String transportUri() {, +        return transportPortsFile.readLines("UTF-8").get(0)]