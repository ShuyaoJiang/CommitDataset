[+++ b/x-pack/plugin/ccr/src/main/java/org/elasticsearch/xpack/ccr/action/ShardChangesAction.java, +import org.apache.logging.log4j.message.ParameterizedMessage;, +import org.elasticsearch.action.ActionListener;, +import org.elasticsearch.common.unit.TimeValue;, +import java.util.concurrent.TimeoutException;, +import static org.elasticsearch.index.seqno.SequenceNumbers.UNASSIGNED_SEQ_NO;, +        private TimeValue pollTimeout = FollowIndexAction.DEFAULT_POLL_TIMEOUT;, +        public TimeValue getPollTimeout() {, +            return pollTimeout;, +        }, +, +        public void setPollTimeout(final TimeValue pollTimeout) {, +            this.pollTimeout = Objects.requireNonNull(pollTimeout, "pollTimeout");, +        }, +, +            pollTimeout = in.readTimeValue();, +            out.writeTimeValue(pollTimeout);, +                    Objects.equals(pollTimeout, request.pollTimeout) &&, +            return Objects.hash(fromSeqNo, maxOperationCount, shardId, expectedHistoryUUID, pollTimeout, maxOperationSizeInBytes);, +                    ", pollTimeout=" + pollTimeout +, +            final IndexService indexService = indicesService.indexServiceSafe(request.getShard().getIndex());, +            final IndexShard indexShard = indexService.getShard(request.getShard().id());, +                    request.getFromSeqNo(),, +                    request.getMaxOperationCount(),, +                    request.getExpectedHistoryUUID(),, +                    request.getMaxOperationSizeInBytes());, +            return getResponse(mappingVersion, seqNoStats, operations);, +        }, +, +        @Override, +        protected void asyncShardOperation(, +                final Request request,, +                final ShardId shardId,, +                final ActionListener<Response> listener) throws IOException {, +            final IndexService indexService = indicesService.indexServiceSafe(request.getShard().getIndex());, +            final IndexShard indexShard = indexService.getShard(request.getShard().id());, +            final SeqNoStats seqNoStats = indexShard.seqNoStats();, +, +            if (request.getFromSeqNo() > seqNoStats.getGlobalCheckpoint()) {, +                logger.trace(, +                        "{} waiting for global checkpoint advancement from [{}] to [{}]",, +                        shardId,, +                        seqNoStats.getGlobalCheckpoint(),, +                        request.getFromSeqNo());, +                indexShard.addGlobalCheckpointListener(, +                        request.getFromSeqNo(),, +                        (g, e) -> {, +                            if (g != UNASSIGNED_SEQ_NO) {, +                                assert request.getFromSeqNo() <= g, +                                        : shardId + " only advanced to [" + g + "] while waiting for [" + request.getFromSeqNo() + "]";, +                                globalCheckpointAdvanced(shardId, g, request, listener);, +                            } else {, +                                assert e != null;, +                                globalCheckpointAdvancementFailure(shardId, e, request, listener, indexShard);, +                            }, +                        },, +                        request.getPollTimeout());, +            } else {, +                super.asyncShardOperation(request, shardId, listener);, +            }, +        }, +, +        private void globalCheckpointAdvanced(, +                final ShardId shardId,, +                final long globalCheckpoint,, +                final Request request,, +                final ActionListener<Response> listener) {, +            logger.trace("{} global checkpoint advanced to [{}] after waiting for [{}]", shardId, globalCheckpoint, request.getFromSeqNo());, +            try {, +                super.asyncShardOperation(request, shardId, listener);, +            } catch (final IOException caught) {, +                listener.onFailure(caught);, +            }, +        }, +, +        private void globalCheckpointAdvancementFailure(, +                final ShardId shardId,, +                final Exception e,, +                final Request request,, +                final ActionListener<Response> listener,, +                final IndexShard indexShard) {, +            logger.trace(, +                    () -> new ParameterizedMessage(, +                            "{} exception waiting for global checkpoint advancement to [{}]", shardId, request.getFromSeqNo()),, +                    e);, +            if (e instanceof TimeoutException) {, +                try {, +                    final long mappingVersion =, +                            clusterService.state().metaData().index(shardId.getIndex()).getMappingVersion();, +                    final SeqNoStats latestSeqNoStats = indexShard.seqNoStats();, +                    listener.onResponse(getResponse(mappingVersion, latestSeqNoStats, EMPTY_OPERATIONS_ARRAY));, +                } catch (final Exception caught) {, +                    caught.addSuppressed(e);, +                    listener.onFailure(caught);, +                }, +            } else {, +                listener.onFailure(e);, +            }, +    static final Translog.Operation[] EMPTY_OPERATIONS_ARRAY = new Translog.Operation[0];, +            throw new IllegalStateException(]