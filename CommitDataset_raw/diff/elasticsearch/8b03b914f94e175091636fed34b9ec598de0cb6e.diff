[+++ b/.idea/dictionaries/kimchy.xml, +      <w>firehose</w>, +++ b/.idea/dictionaries/kimchy.xml, +      <w>firehose</w>, +++ b/.idea/modules/plugin-river-twitter.iml, +          <root url="jar://$GRADLE_REPOSITORY$/org.twitter4j/twitter4j-core/jars/twitter4j-core-2.1.6.jar!/" />, +++ b/.idea/dictionaries/kimchy.xml, +      <w>firehose</w>, +++ b/.idea/modules/plugin-river-twitter.iml, +          <root url="jar://$GRADLE_REPOSITORY$/org.twitter4j/twitter4j-core/jars/twitter4j-core-2.1.6.jar!/" />, +++ b/plugins/river/twitter/build.gradle, +    compile('org.twitter4j:twitter4j-core:2.1.6') { transitive = false }, +    distLib('org.twitter4j:twitter4j-core:2.1.6') { transitive = false }, +++ b/.idea/dictionaries/kimchy.xml, +      <w>firehose</w>, +++ b/.idea/modules/plugin-river-twitter.iml, +          <root url="jar://$GRADLE_REPOSITORY$/org.twitter4j/twitter4j-core/jars/twitter4j-core-2.1.6.jar!/" />, +++ b/plugins/river/twitter/build.gradle, +    compile('org.twitter4j:twitter4j-core:2.1.6') { transitive = false }, +    distLib('org.twitter4j:twitter4j-core:2.1.6') { transitive = false }, +++ b/plugins/river/twitter/src/main/java/org/elasticsearch/river/twitter/TwitterRiver.java, +import org.elasticsearch.common.Strings;, +import java.util.List;, +    private FilterQuery filterQuery;, +, +    private String streamType;, +, +            streamType = XContentMapValues.nodeStringValue(twitterSettings.get("type"), "sample");, +            Map<String, Object> filterSettings = (Map<String, Object>) twitterSettings.get("filter");, +            if (filterSettings != null) {, +                filterQuery = new FilterQuery();, +                filterQuery.count(XContentMapValues.nodeIntegerValue(filterSettings.get("count"), 0));, +                Object tracks = filterSettings.get("tracks");, +                if (tracks != null) {, +                    if (tracks instanceof List) {, +                        List<String> lTracks = (List<String>) tracks;, +                        filterQuery.track(lTracks.toArray(new String[lTracks.size()]));, +                    } else {, +                        filterQuery.track(Strings.commaDelimitedListToStringArray(tracks.toString()));, +                    }, +                }, +                Object follow = filterSettings.get("follow");, +                if (follow != null) {, +                    if (follow instanceof List) {, +                        List lFollow = (List) follow;, +                        int[] followIds = new int[lFollow.size()];, +                        for (int i = 0; i < lFollow.size(); i++) {, +                            Object o = lFollow.get(i);, +                            if (o instanceof Number) {, +                                followIds[i] = ((Number) o).intValue();, +                            } else {, +                                followIds[i] = Integer.parseInt(o.toString());, +                            }, +                        }, +                        filterQuery.follow(followIds);, +                    } else {, +                        String[] ids = Strings.commaDelimitedListToStringArray(follow.toString());, +                        int[] followIds = new int[ids.length];, +                        for (int i = 0; i < ids.length; i++) {, +                            followIds[i] = Integer.parseInt(ids[i]);, +                        }, +                    }, +                }, +                Object locations = filterSettings.get("locations");, +                if (locations != null) {, +                    if (locations instanceof List) {, +                        List lLocations = (List) locations;, +                        double[][] dLocations = new double[lLocations.size()][];, +                        for (int i = 0; i < lLocations.size(); i++) {, +                            Object loc = lLocations.get(i);, +                            double lat;, +                            double lon;, +                            if (loc instanceof List) {, +                                List lLoc = (List) loc;, +                                if (lLoc.get(0) instanceof Number) {, +                                    lat = ((Number) lLoc.get(0)).doubleValue();, +                                } else {, +                                    lat = Double.parseDouble(lLoc.get(0).toString());, +                                }, +                                if (lLoc.get(1) instanceof Number) {, +                                    lon = ((Number) lLoc.get(1)).doubleValue();, +                                } else {, +                                    lon = Double.parseDouble(lLoc.get(1).toString());, +                                }, +                            } else {, +                                String[] sLoc = Strings.commaDelimitedListToStringArray(loc.toString());, +                                lat = Double.parseDouble(sLoc[0]);, +                                lon = Double.parseDouble(sLoc[1]);, +                            }, +                            dLocations[i] = new double[]{lat, lon};, +                        }, +                        filterQuery.locations(dLocations);, +                    } else {, +                        String[] sLocations = Strings.commaDelimitedListToStringArray(locations.toString());, +                        double[][] dLocations = new double[sLocations.length / 2][];, +                        int dCounter = 0;, +                        for (int i = 0; i < sLocations.length; i++) {, +                            double lat = Double.parseDouble(sLocations[i]);, +                            double lon = Double.parseDouble(sLocations[++i]);, +                            dLocations[dCounter++] = new double[]{lat, lon};]