[+++ b/core/src/main/java/org/elasticsearch/common/rounding/DateTimeUnit.java, +import org.joda.time.DateTimeZone;, +import java.util.function.Function;, +, +    WEEK_OF_WEEKYEAR(   (byte) 1, tz -> ISOChronology.getInstance(tz).weekOfWeekyear()),, +    YEAR_OF_CENTURY(    (byte) 2, tz -> ISOChronology.getInstance(tz).yearOfCentury()),, +    QUARTER(            (byte) 3, tz -> Joda.QuarterOfYear.getField(ISOChronology.getInstance(tz))),, +    MONTH_OF_YEAR(      (byte) 4, tz -> ISOChronology.getInstance(tz).monthOfYear()),, +    DAY_OF_MONTH(       (byte) 5, tz -> ISOChronology.getInstance(tz).dayOfMonth()),, +    HOUR_OF_DAY(        (byte) 6, tz -> ISOChronology.getInstance(tz).hourOfDay()),, +    MINUTES_OF_HOUR(    (byte) 7, tz -> ISOChronology.getInstance(tz).minuteOfHour()),, +    SECOND_OF_MINUTE(   (byte) 8, tz -> ISOChronology.getInstance(tz).secondOfMinute());, +    private final Function<DateTimeZone, DateTimeField> fieldFunction;, +    private DateTimeUnit(byte id, Function<DateTimeZone, DateTimeField> fieldFunction) {, +        this.fieldFunction = fieldFunction;, +     * @return the {@link DateTimeField} for the provided {@link DateTimeZone} for this time unit, +    public DateTimeField field(DateTimeZone tz) {, +        return fieldFunction.apply(tz);, +++ b/core/src/main/java/org/elasticsearch/common/rounding/DateTimeUnit.java, +import org.joda.time.DateTimeZone;, +import java.util.function.Function;, +, +    WEEK_OF_WEEKYEAR(   (byte) 1, tz -> ISOChronology.getInstance(tz).weekOfWeekyear()),, +    YEAR_OF_CENTURY(    (byte) 2, tz -> ISOChronology.getInstance(tz).yearOfCentury()),, +    QUARTER(            (byte) 3, tz -> Joda.QuarterOfYear.getField(ISOChronology.getInstance(tz))),, +    MONTH_OF_YEAR(      (byte) 4, tz -> ISOChronology.getInstance(tz).monthOfYear()),, +    DAY_OF_MONTH(       (byte) 5, tz -> ISOChronology.getInstance(tz).dayOfMonth()),, +    HOUR_OF_DAY(        (byte) 6, tz -> ISOChronology.getInstance(tz).hourOfDay()),, +    MINUTES_OF_HOUR(    (byte) 7, tz -> ISOChronology.getInstance(tz).minuteOfHour()),, +    SECOND_OF_MINUTE(   (byte) 8, tz -> ISOChronology.getInstance(tz).secondOfMinute());, +    private final Function<DateTimeZone, DateTimeField> fieldFunction;, +    private DateTimeUnit(byte id, Function<DateTimeZone, DateTimeField> fieldFunction) {, +        this.fieldFunction = fieldFunction;, +     * @return the {@link DateTimeField} for the provided {@link DateTimeZone} for this time unit, +    public DateTimeField field(DateTimeZone tz) {, +        return fieldFunction.apply(tz);, +++ b/core/src/main/java/org/elasticsearch/common/rounding/TimeZoneRounding.java, +            this.field = unit.field(timeZone);, +            long rounded = field.roundFloor(utcMillis);, +            if (timeZone.isFixed() == false && timeZone.getOffset(utcMillis) != timeZone.getOffset(rounded)) {, +                // in this case, we crossed a time zone transition. In some edge cases this will, +                // result in a value that is not a rounded value itself. We need to round again, +                // to make sure. This will have no affect in cases where 'rounded' was already a proper, +                // rounded value, +                rounded = field.roundFloor(rounded);, +            }, +            assert rounded == field.roundFloor(rounded);, +            return rounded;, +        public long nextRoundingValue(long utcMillis) {, +            long floor = roundKey(utcMillis);, +            // add one unit and round to get to next rounded value, +            long next = roundKey(field.add(floor, 1));, +            if (next == floor) {, +                // in rare case we need to add more than one unit, +                next = roundKey(field.add(floor, 2));, +            field = unit.field(timeZone);, +, +        @Override, +        public String toString() {, +            return "[" + timeZone + "][" + unit +"]";, +        }, +++ b/core/src/main/java/org/elasticsearch/common/rounding/DateTimeUnit.java, +import org.joda.time.DateTimeZone;, +import java.util.function.Function;, +, +    WEEK_OF_WEEKYEAR(   (byte) 1, tz -> ISOChronology.getInstance(tz).weekOfWeekyear()),, +    YEAR_OF_CENTURY(    (byte) 2, tz -> ISOChronology.getInstance(tz).yearOfCentury()),, +    QUARTER(            (byte) 3, tz -> Joda.QuarterOfYear.getField(ISOChronology.getInstance(tz))),, +    MONTH_OF_YEAR(      (byte) 4, tz -> ISOChronology.getInstance(tz).monthOfYear()),, +    DAY_OF_MONTH(       (byte) 5, tz -> ISOChronology.getInstance(tz).dayOfMonth()),, +    HOUR_OF_DAY(        (byte) 6, tz -> ISOChronology.getInstance(tz).hourOfDay()),, +    MINUTES_OF_HOUR(    (byte) 7, tz -> ISOChronology.getInstance(tz).minuteOfHour()),, +    SECOND_OF_MINUTE(   (byte) 8, tz -> ISOChronology.getInstance(tz).secondOfMinute());, +    private final Function<DateTimeZone, DateTimeField> fieldFunction;, +    private DateTimeUnit(byte id, Function<DateTimeZone, DateTimeField> fieldFunction) {, +        this.fieldFunction = fieldFunction;, +     * @return the {@link DateTimeField} for the provided {@link DateTimeZone} for this time unit, +    public DateTimeField field(DateTimeZone tz) {, +        return fieldFunction.apply(tz);, +++ b/core/src/main/java/org/elasticsearch/common/rounding/TimeZoneRounding.java, +            this.field = unit.field(timeZone);, +            long rounded = field.roundFloor(utcMillis);, +            if (timeZone.isFixed() == false && timeZone.getOffset(utcMillis) != timeZone.getOffset(rounded)) {, +                // in this case, we crossed a time zone transition. In some edge cases this will, +                // result in a value that is not a rounded value itself. We need to round again, +                // to make sure. This will have no affect in cases where 'rounded' was already a proper, +                // rounded value, +                rounded = field.roundFloor(rounded);, +            }, +            assert rounded == field.roundFloor(rounded);, +            return rounded;, +        public long nextRoundingValue(long utcMillis) {, +            long floor = roundKey(utcMillis);, +            // add one unit and round to get to next rounded value, +            long next = roundKey(field.add(floor, 1));, +            if (next == floor) {, +                // in rare case we need to add more than one unit, +                next = roundKey(field.add(floor, 2));, +            field = unit.field(timeZone);, +]