[+++ b/core/src/main/java/org/elasticsearch/action/admin/cluster/node/liveness/TransportLivenessAction.java, +        transportService.registerRequestHandler(NAME, LivenessRequest::new, ThreadPool.Names.SAME,, +            false, false /*can not trip circuit breaker*/, this);, +++ b/core/src/main/java/org/elasticsearch/action/admin/cluster/node/liveness/TransportLivenessAction.java, +        transportService.registerRequestHandler(NAME, LivenessRequest::new, ThreadPool.Names.SAME,, +            false, false /*can not trip circuit breaker*/, this);, +++ b/core/src/main/java/org/elasticsearch/index/fielddata/ScriptDocValues.java, +        public MutableDateTime getDate() {, +++ b/core/src/main/java/org/elasticsearch/action/admin/cluster/node/liveness/TransportLivenessAction.java, +        transportService.registerRequestHandler(NAME, LivenessRequest::new, ThreadPool.Names.SAME,, +            false, false /*can not trip circuit breaker*/, this);, +++ b/core/src/main/java/org/elasticsearch/index/fielddata/ScriptDocValues.java, +        public MutableDateTime getDate() {, +++ b/core/src/main/java/org/elasticsearch/index/mapper/ip/LegacyIpFieldMapper.java, +import org.elasticsearch.index.IndexSettings;, +import org.elasticsearch.index.fielddata.IndexFieldDataCache;, +import org.elasticsearch.index.mapper.MapperService;, +import org.elasticsearch.indices.breaker.CircuitBreakerService;, +            return new IndexFieldData.Builder() {, +                @Override, +                public IndexFieldData<?> build(IndexSettings indexSettings,, +                        MappedFieldType fieldType, IndexFieldDataCache cache,, +                        CircuitBreakerService breakerService, MapperService mapperService) {, +                    return new LegacyIpIndexFieldData(indexSettings.getIndex(), name());, +                }, +            };, +++ b/core/src/main/java/org/elasticsearch/action/admin/cluster/node/liveness/TransportLivenessAction.java, +        transportService.registerRequestHandler(NAME, LivenessRequest::new, ThreadPool.Names.SAME,, +            false, false /*can not trip circuit breaker*/, this);, +++ b/core/src/main/java/org/elasticsearch/index/fielddata/ScriptDocValues.java, +        public MutableDateTime getDate() {, +++ b/core/src/main/java/org/elasticsearch/index/mapper/ip/LegacyIpFieldMapper.java, +import org.elasticsearch.index.IndexSettings;, +import org.elasticsearch.index.fielddata.IndexFieldDataCache;, +import org.elasticsearch.index.mapper.MapperService;, +import org.elasticsearch.indices.breaker.CircuitBreakerService;, +            return new IndexFieldData.Builder() {, +                @Override, +                public IndexFieldData<?> build(IndexSettings indexSettings,, +                        MappedFieldType fieldType, IndexFieldDataCache cache,, +                        CircuitBreakerService breakerService, MapperService mapperService) {, +                    return new LegacyIpIndexFieldData(indexSettings.getIndex(), name());, +                }, +            };, +++ b/core/src/main/java/org/elasticsearch/index/mapper/ip/LegacyIpIndexFieldData.java, +/*, + * Licensed to Elasticsearch under one or more contributor, + * license agreements. See the NOTICE file distributed with, + * this work for additional information regarding copyright, + * ownership. Elasticsearch licenses this file to you under, + * the Apache License, Version 2.0 (the "License"); you may, + * not use this file except in compliance with the License., + * You may obtain a copy of the License at, + *, + *    http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing,, + * software distributed under the License is distributed on an, + * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY, + * KIND, either express or implied.  See the License for the, + * specific language governing permissions and limitations, + * under the License., + */, +package org.elasticsearch.index.mapper.ip;, +, +import java.io.IOException;, +import java.net.InetAddress;, +import java.net.UnknownHostException;, +import java.nio.ByteBuffer;, +, +import org.apache.lucene.document.InetAddressPoint;, +import org.apache.lucene.index.DocValues;, +import org.apache.lucene.index.IndexReader;, +import org.apache.lucene.index.LeafReaderContext;, +import org.apache.lucene.index.SortedNumericDocValues;, +import org.apache.lucene.util.BytesRef;, +import org.elasticsearch.common.logging.ESLogger;, +import org.elasticsearch.common.logging.Loggers;, +import org.elasticsearch.index.Index;, +import org.elasticsearch.index.fielddata.AtomicFieldData;, +import org.elasticsearch.index.fielddata.IndexFieldData;, +import org.elasticsearch.index.fielddata.ScriptDocValues;, +import org.elasticsearch.index.fielddata.SortedBinaryDocValues;, +import org.elasticsearch.index.fielddata.IndexFieldData.XFieldComparatorSource.Nested;, +import org.elasticsearch.index.fielddata.fieldcomparator.BytesRefFieldComparatorSource;, +import org.elasticsearch.search.MultiValueMode;, +, +final class LegacyIpIndexFieldData implements IndexFieldData<AtomicFieldData> {, +, +    protected final Index index;, +    protected final String fieldName;, +    protected final ESLogger logger;, +, +    public LegacyIpIndexFieldData(Index index, String fieldName) {, +        this.index = index;, +        this.fieldName = fieldName;, +        this.logger = Loggers.getLogger(getClass());, +    }, +, +    public final String getFieldName() {]