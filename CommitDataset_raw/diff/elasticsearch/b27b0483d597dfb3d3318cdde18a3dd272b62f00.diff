[+++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/MethodWriter.java, +import java.util.ArrayDeque;, +import java.util.ArrayList;, +import java.util.Deque;, +import java.util.List;, +, +import static org.elasticsearch.painless.WriterConstants.INDY_STRING_CONCAT_BOOTSTRAP_HANDLE;, +import static org.elasticsearch.painless.WriterConstants.MAX_INDY_STRING_CONCAT_ARGS;, +import static org.elasticsearch.painless.WriterConstants.STRING_TYPE;, +    private final Deque<List<org.objectweb.asm.Type>> stringConcatArgs = (INDY_STRING_CONCAT_BOOTSTRAP_HANDLE == null) ? null : new ArrayDeque<>();, +, +        if (INDY_STRING_CONCAT_BOOTSTRAP_HANDLE != null) {, +            // Java 9+: we just push our argument collector onto deque, +            stringConcatArgs.push(new ArrayList<>());, +        } else {, +            // Java 8: create a StringBuilder in bytecode, +    }, +    public void writeAppendStrings(final Type type) {, +        if (INDY_STRING_CONCAT_BOOTSTRAP_HANDLE != null) {, +            // Java 9+: record type information, +            stringConcatArgs.peek().add(type.type);, +            // prevent too many concat args., +            // If there are too many, do the actual concat:, +            if (stringConcatArgs.peek().size() >= MAX_INDY_STRING_CONCAT_ARGS) {, +                writeToStrings();, +                writeNewStrings();, +                // add the return value type as new first param for next concat:, +                stringConcatArgs.peek().add(STRING_TYPE);, +            }, +        } else {, +            // Java 8: push a StringBuilder append, +            switch (type.sort) {, +    }, +        if (INDY_STRING_CONCAT_BOOTSTRAP_HANDLE != null) {, +            // Java 9+: use type information and push invokeDynamic, +            final String desc = org.objectweb.asm.Type.getMethodDescriptor(STRING_TYPE,, +                    stringConcatArgs.pop().stream().toArray(org.objectweb.asm.Type[]::new));, +            invokeDynamic("concat", desc, INDY_STRING_CONCAT_BOOTSTRAP_HANDLE);, +        } else {, +            // Java 8: call toString() on StringBuilder, +    }, +++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/MethodWriter.java, +import java.util.ArrayDeque;, +import java.util.ArrayList;, +import java.util.Deque;, +import java.util.List;, +, +import static org.elasticsearch.painless.WriterConstants.INDY_STRING_CONCAT_BOOTSTRAP_HANDLE;, +import static org.elasticsearch.painless.WriterConstants.MAX_INDY_STRING_CONCAT_ARGS;, +import static org.elasticsearch.painless.WriterConstants.STRING_TYPE;, +    private final Deque<List<org.objectweb.asm.Type>> stringConcatArgs = (INDY_STRING_CONCAT_BOOTSTRAP_HANDLE == null) ? null : new ArrayDeque<>();, +, +        if (INDY_STRING_CONCAT_BOOTSTRAP_HANDLE != null) {, +            // Java 9+: we just push our argument collector onto deque, +            stringConcatArgs.push(new ArrayList<>());, +        } else {, +            // Java 8: create a StringBuilder in bytecode, +    }, +    public void writeAppendStrings(final Type type) {, +        if (INDY_STRING_CONCAT_BOOTSTRAP_HANDLE != null) {, +            // Java 9+: record type information, +            stringConcatArgs.peek().add(type.type);, +            // prevent too many concat args., +            // If there are too many, do the actual concat:, +            if (stringConcatArgs.peek().size() >= MAX_INDY_STRING_CONCAT_ARGS) {, +                writeToStrings();, +                writeNewStrings();, +                // add the return value type as new first param for next concat:, +                stringConcatArgs.peek().add(STRING_TYPE);, +            }, +        } else {, +            // Java 8: push a StringBuilder append, +            switch (type.sort) {, +    }, +        if (INDY_STRING_CONCAT_BOOTSTRAP_HANDLE != null) {, +            // Java 9+: use type information and push invokeDynamic, +            final String desc = org.objectweb.asm.Type.getMethodDescriptor(STRING_TYPE,, +                    stringConcatArgs.pop().stream().toArray(org.objectweb.asm.Type[]::new));, +            invokeDynamic("concat", desc, INDY_STRING_CONCAT_BOOTSTRAP_HANDLE);, +        } else {, +            // Java 8: call toString() on StringBuilder, +    }, +++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/WriterConstants.java, +import java.lang.invoke.MethodHandle;, +    /** dynamic invokedynamic bootstrap for indy string concats (Java 9+) */, +    public final static Handle INDY_STRING_CONCAT_BOOTSTRAP_HANDLE;, +    static {, +        Handle bs;, +        try {, +            final Class<?> factory = Class.forName("java.lang.invoke.StringConcatFactory");, +            final String methodName = "makeConcat";, +            final MethodType type = MethodType.methodType(CallSite.class, MethodHandles.Lookup.class, String.class, MethodType.class);, +            // ensure it is there:, +            MethodHandles.publicLookup().findStatic(factory, methodName, type);, +            bs = new Handle(Opcodes.H_INVOKESTATIC, Type.getInternalName(factory), methodName, type.toMethodDescriptorString());, +        } catch (ReflectiveOperationException e) {, +            // not Java 9 - we set it null, so MethodWriter uses StringBuilder:, +            bs = null;, +        }, +        INDY_STRING_CONCAT_BOOTSTRAP_HANDLE = bs;]