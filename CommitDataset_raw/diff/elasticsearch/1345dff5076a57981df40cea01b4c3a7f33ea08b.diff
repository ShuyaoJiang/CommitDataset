[+++ b/buildSrc/src/main/resources/checkstyle_suppressions.xml, +++ b/buildSrc/src/main/resources/checkstyle_suppressions.xml, +++ b/server/src/main/java/org/elasticsearch/snapshots/RestoreInfo.java, +    private static final ObjectParser<RestoreInfo, Void> PARSER = new ObjectParser<>(RestoreInfo.class.getName(),, +        true, RestoreInfo::new);, +++ b/buildSrc/src/main/resources/checkstyle_suppressions.xml, +++ b/server/src/main/java/org/elasticsearch/snapshots/RestoreInfo.java, +    private static final ObjectParser<RestoreInfo, Void> PARSER = new ObjectParser<>(RestoreInfo.class.getName(),, +        true, RestoreInfo::new);, +++ b/server/src/main/java/org/elasticsearch/snapshots/RestoreService.java, + * to be restored and adds this shard to the routing table using, + * {@link RoutingTable.Builder#addAsRestore(IndexMetaData, SnapshotRecoverySource)} method., +                            SnapshotRecoverySource recoverySource =, +                                new SnapshotRecoverySource(restoreUUID, snapshot, snapshotInfo.version(), index);, +                            snapshotIndexMetaData = updateIndexSettings(snapshotIndexMetaData,, +                                                                        request.indexSettings, request.ignoreIndexSettings);, +                                throw new SnapshotRestoreException(snapshot, "cannot restore index [" + index + "] because it cannot be " +, +                                    "upgraded", ex);, +                                createIndexService.validateIndexSettings(renamedIndexName,, +                                                                        snapshotIndexMetaData.getSettings(),, +                                                                        currentState,, +                                                                        false);, +                                IndexMetaData.Builder indexMdBuilder = IndexMetaData.builder(snapshotIndexMetaData), +                                                                                    .state(IndexMetaData.State.OPEN), +                                                                                    .index(renamedIndexName);, +                                indexMdBuilder.settings(Settings.builder(), +                                                                .put(snapshotIndexMetaData.getSettings()), +                                                                .put(IndexMetaData.SETTING_INDEX_UUID, UUIDs.randomBase64UUID()));, +                                IndexMetaData.Builder indexMdBuilder = IndexMetaData.builder(snapshotIndexMetaData), +                                                                                    .state(IndexMetaData.State.OPEN);, +                                indexMdBuilder.mappingVersion(Math.max(snapshotIndexMetaData.getMappingVersion(),, +                                                                        currentIndexMetaData.getMappingVersion() + 1));, +                                indexMdBuilder.settingsVersion(Math.max(snapshotIndexMetaData.getSettingsVersion(),, +                                                                        currentIndexMetaData.getSettingsVersion() + 1));, +                                indexMdBuilder.settings(Settings.builder(), +                                                                .put(snapshotIndexMetaData.getSettings()), +                                                                .put(IndexMetaData.SETTING_INDEX_UUID,, +                                                                    currentIndexMetaData.getIndexUUID()));, +                                    shardsBuilder.put(new ShardId(renamedIndex, shard),, +                                            new RestoreInProgress.ShardRestoreStatus(clusterService.state().nodes().getLocalNodeId()));, +                                    shardsBuilder.put(new ShardId(renamedIndex, shard),, +                                            new RestoreInProgress.ShardRestoreStatus(clusterService.state().nodes().getLocalNodeId(),, +                                                RestoreInProgress.State.FAILURE));, +                            throw new SnapshotRestoreException(snapshot,, +                                "cannot rename index [" + renamedIndex.getValue() + "] into [" + renamedIndex.getKey() + "] because of " +, +                                    "conflict with an alias with the same name");, +                            throw new SnapshotRestoreException(snapshot, "index [" + index + "] wasn't fully snapshotted - cannot " +, +                                "restore");, +                private void validateExistingIndex(IndexMetaData currentIndexMetaData, IndexMetaData snapshotIndexMetaData,, +                                                   String renamedIndex, boolean partial) {, +                        throw new SnapshotRestoreException(snapshot, "cannot restore index [" + renamedIndex + "] because an open index " +, +                            "with same name already exists in the cluster. Either close or delete the existing index or restore the " +, +                            "index under a different name by providing a rename pattern and replacement name");, +                        throw new SnapshotRestoreException(snapshot, "cannot restore partial index [" + renamedIndex + "] because such " +, +                            "index already exists");, +                        throw new SnapshotRestoreException(snapshot,, +                            "cannot restore index [" + renamedIndex + "] with [" + currentIndexMetaData.getNumberOfShards() + "] shards " +, +                                "from a snapshot of index [" + snapshotIndexMetaData.getIndex().getName() + "] with [" +, +                                snapshotIndexMetaData.getNumberOfShards() + "] shards");, +                    Settings normalizedChangeSettings = Settings.builder(), +                                                                .put(changeSettings), +                                                                .normalizePrefix(IndexMetaData.INDEX_SETTING_PREFIX), +                                                                .build();, +            logger.warn(() -> new ParameterizedMessage("[{}] failed to restore snapshot",, +                request.repositoryName + ":" + request.snapshotName), e);, +                    shardsBuilder.put(shardId,, +                        new ShardRestoreStatus(null, RestoreInProgress.State.FAILURE, "index was deleted"));, +                builder.add(new RestoreInProgress.Entry(entry.uuid(), entry.snapshot(),, +                    overallState(RestoreInProgress.State.STARTED, shards), entry.indices(), shards));, +                    new ShardRestoreStatus(null, RestoreInProgress.State.FAILURE,, +                        "recovery source type changed from snapshot to " + initializedShard.recoverySource()), +    static class CleanRestoreStateTaskExecutor implements ClusterStateTaskExecutor<CleanRestoreStateTaskExecutor.Task>,, +        ClusterStateTaskListener {, +++ b/buildSrc/src/main/resources/checkstyle_suppressions.xml, +++ b/server/src/main/java/org/elasticsearch/snapshots/RestoreInfo.java, +    private static final ObjectParser<RestoreInfo, Void> PARSER = new ObjectParser<>(RestoreInfo.class.getName(),, +        true, RestoreInfo::new);, +++ b/server/src/main/java/org/elasticsearch/snapshots/RestoreService.java, + * to be restored and adds this shard to the routing table using, + * {@link RoutingTable.Builder#addAsRestore(IndexMetaData, SnapshotRecoverySource)} method., +                            SnapshotRecoverySource recoverySource =, +                                new SnapshotRecoverySource(restoreUUID, snapshot, snapshotInfo.version(), index);, +                            snapshotIndexMetaData = updateIndexSettings(snapshotIndexMetaData,, +                                                                        request.indexSettings, request.ignoreIndexSettings);, +                                throw new SnapshotRestoreException(snapshot, "cannot restore index [" + index + "] because it cannot be " +, +                                    "upgraded", ex);, +                                createIndexService.validateIndexSettings(renamedIndexName,, +                                                                        snapshotIndexMetaData.getSettings(),, +                                                                        currentState,, +                                                                        false);, +                                IndexMetaData.Builder indexMdBuilder = IndexMetaData.builder(snapshotIndexMetaData), +                                                                                    .state(IndexMetaData.State.OPEN), +                                                                                    .index(renamedIndexName);, +                                indexMdBuilder.settings(Settings.builder(), +                                                                .put(snapshotIndexMetaData.getSettings()), +                                                                .put(IndexMetaData.SETTING_INDEX_UUID, UUIDs.randomBase64UUID()));, +                                IndexMetaData.Builder indexMdBuilder = IndexMetaData.builder(snapshotIndexMetaData), +                                                                                    .state(IndexMetaData.State.OPEN);, +                                indexMdBuilder.mappingVersion(Math.max(snapshotIndexMetaData.getMappingVersion(),, +                                                                        currentIndexMetaData.getMappingVersion() + 1));]