[+++ b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/analysis/analyzer/Analyzer.java, +import org.elasticsearch.xpack.sql.type.InvalidMappedField;, +, +            // incompatible mappings, +            if (fa.field() instanceof InvalidMappedField) {, +                named = u.withUnresolvedMessage("Cannot use field [" + fa.name() + "] due to ambiguities being ", +                        + ((InvalidMappedField) fa.field()).errorMessage());, +            }, +            else if (DataTypes.isUnsupported(fa.dataType())) {, +++ b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/analysis/analyzer/Analyzer.java, +import org.elasticsearch.xpack.sql.type.InvalidMappedField;, +, +            // incompatible mappings, +            if (fa.field() instanceof InvalidMappedField) {, +                named = u.withUnresolvedMessage("Cannot use field [" + fa.name() + "] due to ambiguities being ", +                        + ((InvalidMappedField) fa.field()).errorMessage());, +            }, +            else if (DataTypes.isUnsupported(fa.dataType())) {, +++ b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/analysis/index/IndexResolver.java, +import org.elasticsearch.xpack.sql.type.InvalidMappedField;, +import java.util.function.Function;, +, +            InvalidMappedField invalidField = null;, +            FieldCapabilities fieldCap = null;, +            errorMessage.setLength(0);, +, +, +                    // build the error message, +                    // and create a MultiTypeField, +                    , +                    errorMessage.insert(0, "mapped as [" + types.size() + "] incompatible types: ");, +                    invalidField = new InvalidMappedField(name, errorMessage.toString());, +                }, +                // type is okay, check aggregation, +                else {, +                    fieldCap = types.values().iterator().next();, +                        errorMessage.append("mapped as aggregatable except in ");, +                        errorMessage.append("mapped as searchable except in ");, +, +                        invalidField = new InvalidMappedField(name, errorMessage.toString());, +                    }, +                // if the name wasn't added before, +                final InvalidMappedField invalidF = invalidField;, +                final FieldCapabilities fieldCapab = fieldCap;, +                    createField(name, fieldCaps, hierarchicalMapping, flattedMapping, s -> {, +                        return invalidF != null ? invalidF : createField(s, fieldCapab.getType(), emptyMap(), fieldCapab.isAggregatable());, +                    });, +    private static EsField createField(String fieldName, Map<String, Map<String, FieldCapabilities>> globalCaps,, +            Map<String, EsField> hierarchicalMapping, Map<String, EsField> flattedMapping,, +            Function<String, EsField> field) {, +                parent = createField(parentName, globalCaps, hierarchicalMapping, flattedMapping,, +                        s -> createField(s, parentCap.getType(), new TreeMap<>(), parentCap.isAggregatable()));, +        EsField esField = field.apply(fieldName);, +        parentProps.put(fieldName, esField);, +        flattedMapping.put(fullFieldName, esField);, +, +        return esField;, +    }, +    , +    private static EsField createField(String fieldName, String typeName, Map<String, EsField> props, boolean isAggregateable) {, +        DataType esType = DataType.fromTypeName(typeName);, +                return new TextEsField(fieldName, props, false);, +                return new KeywordEsField(fieldName, props, isAggregateable, length, normalized);, +                return new DateEsField(fieldName, props, isAggregateable);, +                return new UnsupportedEsField(fieldName, typeName);, +                return new EsField(fieldName, esType, props, isAggregateable);, +++ b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/analysis/analyzer/Analyzer.java, +import org.elasticsearch.xpack.sql.type.InvalidMappedField;, +, +            // incompatible mappings, +            if (fa.field() instanceof InvalidMappedField) {, +                named = u.withUnresolvedMessage("Cannot use field [" + fa.name() + "] due to ambiguities being ", +                        + ((InvalidMappedField) fa.field()).errorMessage());, +            }, +            else if (DataTypes.isUnsupported(fa.dataType())) {, +++ b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/analysis/index/IndexResolver.java, +import org.elasticsearch.xpack.sql.type.InvalidMappedField;, +import java.util.function.Function;, +, +            InvalidMappedField invalidField = null;, +            FieldCapabilities fieldCap = null;, +            errorMessage.setLength(0);, +, +, +                    // build the error message, +                    // and create a MultiTypeField, +                    , +                    errorMessage.insert(0, "mapped as [" + types.size() + "] incompatible types: ");, +                    invalidField = new InvalidMappedField(name, errorMessage.toString());, +                }, +                // type is okay, check aggregation, +                else {, +                    fieldCap = types.values().iterator().next();, +                        errorMessage.append("mapped as aggregatable except in ");, +                        errorMessage.append("mapped as searchable except in ");, +, +                        invalidField = new InvalidMappedField(name, errorMessage.toString());, +                    }, +                // if the name wasn't added before, +                final InvalidMappedField invalidF = invalidField;]