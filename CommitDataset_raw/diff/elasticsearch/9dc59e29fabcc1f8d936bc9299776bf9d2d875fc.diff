[+++ b/src/main/java/org/elasticsearch/common/collect/Tuple.java, +, +    @Override, +    public String toString() {, +        return "Tuple [v1=" + v1 + ", v2=" + v2 + "]";, +    }, +++ b/src/main/java/org/elasticsearch/common/collect/Tuple.java, +, +    @Override, +    public String toString() {, +        return "Tuple [v1=" + v1 + ", v2=" + v2 + "]";, +    }, +++ b/src/test/java/org/elasticsearch/test/AbstractIntegrationTest.java, +import org.elasticsearch.ExceptionsHelper;, +import org.elasticsearch.common.collect.Tuple;, +import org.elasticsearch.common.util.concurrent.EsRejectedExecutionException;, +        , +        final CopyOnWriteArrayList<Tuple<IndexRequestBuilder, Throwable>> errors = new CopyOnWriteArrayList<Tuple<IndexRequestBuilder, Throwable>>();, +                indexRequestBuilder.execute(new PayloadLatchedActionListener<IndexResponse, IndexRequestBuilder>(indexRequestBuilder, latch, errors));, +                        client().admin().indices().prepareRefresh(indices).setIgnoreIndices(IgnoreIndices.MISSING).execute(new LatchedActionListener<RefreshResponse>(newLatch(latches)));, +                        client().admin().indices().prepareFlush(indices).setIgnoreIndices(IgnoreIndices.MISSING).execute(new LatchedActionListener<FlushResponse>(newLatch(latches)));, +                        client().admin().indices().prepareOptimize(indices).setIgnoreIndices(IgnoreIndices.MISSING).setMaxNumSegments(between(1, 10)).setFlush(random.nextBoolean()).execute(new LatchedActionListener<OptimizeResponse>(newLatch(latches)));, +                        client().admin().indices().prepareRefresh(indices).setIgnoreIndices(IgnoreIndices.MISSING).execute(new LatchedActionListener<RefreshResponse>(newLatch(latches)));, +                        client().admin().indices().prepareFlush(indices).setIgnoreIndices(IgnoreIndices.MISSING).execute(new LatchedActionListener<FlushResponse>(newLatch(latches)));, +                        client().admin().indices().prepareOptimize(indices).setIgnoreIndices(IgnoreIndices.MISSING).setMaxNumSegments(between(1, 10)).setFlush(random.nextBoolean()).execute(new LatchedActionListener<OptimizeResponse>(newLatch(latches)));, +        final List<Throwable> actualErrors = new ArrayList<Throwable>();, +        for (Tuple<IndexRequestBuilder, Throwable> tuple : errors) {, +            if (ExceptionsHelper.unwrapCause(tuple.v2()) instanceof EsRejectedExecutionException) {, +                tuple.v1().execute().actionGet(); // re-index if rejected, +            } else {, +                actualErrors.add(tuple.v2());, +            }, +        }, +        assertThat(actualErrors, emptyIterable());, +, +    private class LatchedActionListener<Response> implements ActionListener<Response> {, +        private final CountDownLatch latch;, +, +        public LatchedActionListener(CountDownLatch latch) {, +        public final void onResponse(Response response) {, +        public final void onFailure(Throwable t) {, +                logger.info("Action Failed", t);, +                addError(t);, +        protected void addError(Throwable t) {, +        }, +, +    }, +    , +    private class PayloadLatchedActionListener<Response, T> extends LatchedActionListener<Response> {, +        private final CopyOnWriteArrayList<Tuple<T, Throwable>> errors;, +        private final T builder;, +, +        public PayloadLatchedActionListener(T builder, CountDownLatch latch, CopyOnWriteArrayList<Tuple<T, Throwable>> errors) {, +            super(latch);, +            this.errors = errors;, +            this.builder = builder;, +        }, +, +        protected void addError(Throwable t) {, +            errors.add(new Tuple<T, Throwable>(builder, t));, +        }, +]