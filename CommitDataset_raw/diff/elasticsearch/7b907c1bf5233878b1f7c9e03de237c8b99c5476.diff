[+++ b/server/src/main/java/org/elasticsearch/rest/action/cat/RestIndicesAction.java, +import org.elasticsearch.common.collect.ImmutableOpenMap;, +                final ClusterState clusterState = clusterStateResponse.getState();, +                final IndexMetaData[] indicesMetaData = getOrderedIndexMetaData(indices, clusterState, strictExpandIndicesOptions);, +                final ClusterHealthRequest clusterHealthRequest = Requests.clusterHealthRequest(indices);, +, +                        final IndicesStatsRequest indicesStatsRequest = new IndicesStatsRequest();, +, +                                final Table tab = buildTable(request, indicesMetaData, clusterHealthResponse, indicesStatsResponse);, +    Table buildTable(RestRequest request, IndexMetaData[] indicesMetaData, ClusterHealthResponse response, IndicesStatsResponse stats) {, +        for (IndexMetaData indexMetaData : indicesMetaData) {, +            final String indexName = indexMetaData.getIndex().getName();, +                        (indexHealth == null && false == ClusterHealthStatus.RED.equals(status)) ||, +                        false == indexHealth.getStatus().equals(status)) {, +            // the open index is present in the cluster state but is not returned in the indices stats API, +            if (indexStats == null && state != IndexMetaData.State.CLOSE) {, +                // the index stats API is called last, after cluster state and cluster health. If the index stats, +                // has not resolved the same open indices as the initial cluster state call, then the indices might, +                // have been removed in the meantime or, more likely, are unauthorized. This is because the cluster, +                // state exposes everything, even unauthorized indices, which are not exposed in APIs., +                // We ignore such an index instead of displaying it with an empty stats., +                continue;, +            }, +, +            final CommonStats primaryStats;, +            final CommonStats totalStats;, +, +            if (state == IndexMetaData.State.CLOSE) {, +                // empty stats for closed indices, but their names are displayed, +                assert indexStats == null;, +                primaryStats = new CommonStats();, +                totalStats = new CommonStats();, +            } else {, +                primaryStats = indexStats.getPrimaries();, +                totalStats = indexStats.getTotal();, +            }, +            table.addCell(indexMetaData.getIndexUUID());, +            table.addCell(totalStats.getTotalMemory());, +            table.addCell(primaryStats.getTotalMemory());, +, +    // package private for testing, +    IndexMetaData[] getOrderedIndexMetaData(String[] indicesExpression, ClusterState clusterState, IndicesOptions indicesOptions) {, +        final Index[] concreteIndices = indexNameExpressionResolver.concreteIndices(clusterState, indicesOptions, indicesExpression);, +        // concreteIndices should contain exactly the indices in state.metaData() that were selected by clusterStateRequest using the, +        // same indices option (IndicesOptions.strictExpand()). We select the indices again here so that they can be displayed in the, +        // resulting table in the requesting order., +        assert concreteIndices.length == clusterState.metaData().getIndices().size();, +        final ImmutableOpenMap<String, IndexMetaData> indexMetaDataMap = clusterState.metaData().getIndices();, +        final IndexMetaData[] indicesMetaData = new IndexMetaData[concreteIndices.length];, +        // select the index metadata in the requested order, so that the response can display the indices in the resulting table, +        // in the requesting order., +        for (int i = 0; i < concreteIndices.length; i++) {, +            indicesMetaData[i] = indexMetaDataMap.get(concreteIndices[i].getName());, +        }, +        return indicesMetaData;, +    }, +++ b/server/src/main/java/org/elasticsearch/rest/action/cat/RestIndicesAction.java, +import org.elasticsearch.common.collect.ImmutableOpenMap;, +                final ClusterState clusterState = clusterStateResponse.getState();, +                final IndexMetaData[] indicesMetaData = getOrderedIndexMetaData(indices, clusterState, strictExpandIndicesOptions);, +                final ClusterHealthRequest clusterHealthRequest = Requests.clusterHealthRequest(indices);, +, +                        final IndicesStatsRequest indicesStatsRequest = new IndicesStatsRequest();, +, +                                final Table tab = buildTable(request, indicesMetaData, clusterHealthResponse, indicesStatsResponse);, +    Table buildTable(RestRequest request, IndexMetaData[] indicesMetaData, ClusterHealthResponse response, IndicesStatsResponse stats) {, +        for (IndexMetaData indexMetaData : indicesMetaData) {, +            final String indexName = indexMetaData.getIndex().getName();, +                        (indexHealth == null && false == ClusterHealthStatus.RED.equals(status)) ||, +                        false == indexHealth.getStatus().equals(status)) {, +            // the open index is present in the cluster state but is not returned in the indices stats API, +            if (indexStats == null && state != IndexMetaData.State.CLOSE) {, +                // the index stats API is called last, after cluster state and cluster health. If the index stats, +                // has not resolved the same open indices as the initial cluster state call, then the indices might, +                // have been removed in the meantime or, more likely, are unauthorized. This is because the cluster, +                // state exposes everything, even unauthorized indices, which are not exposed in APIs., +                // We ignore such an index instead of displaying it with an empty stats., +                continue;, +            }, +, +            final CommonStats primaryStats;, +            final CommonStats totalStats;, +, +            if (state == IndexMetaData.State.CLOSE) {, +                // empty stats for closed indices, but their names are displayed, +                assert indexStats == null;, +                primaryStats = new CommonStats();, +                totalStats = new CommonStats();, +            } else {, +                primaryStats = indexStats.getPrimaries();, +                totalStats = indexStats.getTotal();, +            }, +            table.addCell(indexMetaData.getIndexUUID());, +            table.addCell(totalStats.getTotalMemory());, +            table.addCell(primaryStats.getTotalMemory());, +, +    // package private for testing, +    IndexMetaData[] getOrderedIndexMetaData(String[] indicesExpression, ClusterState clusterState, IndicesOptions indicesOptions) {, +        final Index[] concreteIndices = indexNameExpressionResolver.concreteIndices(clusterState, indicesOptions, indicesExpression);, +        // concreteIndices should contain exactly the indices in state.metaData() that were selected by clusterStateRequest using the]