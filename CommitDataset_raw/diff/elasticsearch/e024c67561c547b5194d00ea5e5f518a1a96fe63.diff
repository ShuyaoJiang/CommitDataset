[+++ b/core/src/main/java/org/elasticsearch/common/util/AbstractArray.java, +                bigArrays.adjustBreaker(-ramBytesUsed(), true);, +++ b/core/src/main/java/org/elasticsearch/common/util/AbstractArray.java, +                bigArrays.adjustBreaker(-ramBytesUsed(), true);, +++ b/core/src/main/java/org/elasticsearch/common/util/AbstractBigArray.java, +        return ramBytesEstimated(size);, +    }, +, +    /** Given the size of the array, estimate the number of bytes it will use. */, +    public final long ramBytesEstimated(final long size) {, +++ b/core/src/main/java/org/elasticsearch/common/util/AbstractArray.java, +                bigArrays.adjustBreaker(-ramBytesUsed(), true);, +++ b/core/src/main/java/org/elasticsearch/common/util/AbstractBigArray.java, +        return ramBytesEstimated(size);, +    }, +, +    /** Given the size of the array, estimate the number of bytes it will use. */, +    public final long ramBytesEstimated(final long size) {, +++ b/core/src/main/java/org/elasticsearch/common/util/BigArrays.java, +        static final long SHALLOW_SIZE = RamUsageEstimator.shallowSizeOfInstance(ByteArrayWrapper.class);, +, +     * without tripping.  If the data was already created before calling, +     * this method, and the breaker trips, we add the delta without breaking, +     * to account for the created data.  If the data has not been created yet,, +     * we do not add the delta to the breaker if it trips., +    void adjustBreaker(final long delta, final boolean isDataAlreadyCreated) {, +                        if (isDataAlreadyCreated) {, +                        }, +        assert oldMemSize == array.ramBytesEstimated(array.size) :, +            "ram bytes used should equal that which was previously estimated: ramBytesUsed=" +, +                oldMemSize + ", ramBytesEstimated=" + array.ramBytesEstimated(array.size);, +        final long estimatedIncreaseInBytes = array.ramBytesEstimated(newSize) - oldMemSize;, +        assert estimatedIncreaseInBytes >= 0 :, +            "estimated increase in bytes for resizing should not be negative: " + estimatedIncreaseInBytes;, +        adjustBreaker(estimatedIncreaseInBytes, false);, +            adjustBreaker(array.ramBytesUsed(), true);, +            // when allocating big arrays, we want to first ensure we have the capacity by, +            // checking with the circuit breaker before attempting to allocate, +            adjustBreaker(BigByteArray.estimateRamBytes(size), false);, +            return new BigByteArray(size, this, clearOnResize);, +            return validate(new ByteArrayWrapper(this, page.v(), size, page, clearOnResize));, +            return validate(new ByteArrayWrapper(this, new byte[(int) size], size, null, clearOnResize));, +            // when allocating big arrays, we want to first ensure we have the capacity by, +            // checking with the circuit breaker before attempting to allocate, +            adjustBreaker(BigIntArray.estimateRamBytes(size), false);, +            return new BigIntArray(size, this, clearOnResize);, +            return validate(new IntArrayWrapper(this, page.v(), size, page, clearOnResize));, +            return validate(new IntArrayWrapper(this, new int[(int) size], size, null, clearOnResize));, +            // when allocating big arrays, we want to first ensure we have the capacity by, +            // checking with the circuit breaker before attempting to allocate, +            adjustBreaker(BigLongArray.estimateRamBytes(size), false);, +            return new BigLongArray(size, this, clearOnResize);, +            return validate(new LongArrayWrapper(this, page.v(), size, page, clearOnResize));, +            return validate(new LongArrayWrapper(this, new long[(int) size], size, null, clearOnResize));, +            // when allocating big arrays, we want to first ensure we have the capacity by, +            // checking with the circuit breaker before attempting to allocate, +            adjustBreaker(BigDoubleArray.estimateRamBytes(size), false);, +            return new BigDoubleArray(size, this, clearOnResize);, +            return validate(new DoubleArrayWrapper(this, page.v(), size, page, clearOnResize));, +            return validate(new DoubleArrayWrapper(this, new long[(int) size], size, null, clearOnResize));, +            // when allocating big arrays, we want to first ensure we have the capacity by, +            // checking with the circuit breaker before attempting to allocate, +            adjustBreaker(BigFloatArray.estimateRamBytes(size), false);, +            return new BigFloatArray(size, this, clearOnResize);, +            return validate(new FloatArrayWrapper(this, page.v(), size, page, clearOnResize));, +            return validate(new FloatArrayWrapper(this, new int[(int) size], size, null, clearOnResize));, +            // when allocating big arrays, we want to first ensure we have the capacity by, +            // checking with the circuit breaker before attempting to allocate, +            adjustBreaker(BigObjectArray.estimateRamBytes(size), false);, +            return new BigObjectArray<>(size, this);, +            return validate(new ObjectArrayWrapper<>(this, page.v(), size, page));, +            return validate(new ObjectArrayWrapper<>(this, new Object[(int) size], size, null));, +++ b/core/src/main/java/org/elasticsearch/common/util/AbstractArray.java, +                bigArrays.adjustBreaker(-ramBytesUsed(), true);, +++ b/core/src/main/java/org/elasticsearch/common/util/AbstractBigArray.java, +        return ramBytesEstimated(size);, +    }, +, +    /** Given the size of the array, estimate the number of bytes it will use. */, +    public final long ramBytesEstimated(final long size) {, +++ b/core/src/main/java/org/elasticsearch/common/util/BigArrays.java, +        static final long SHALLOW_SIZE = RamUsageEstimator.shallowSizeOfInstance(ByteArrayWrapper.class);, +, +     * without tripping.  If the data was already created before calling, +     * this method, and the breaker trips, we add the delta without breaking, +     * to account for the created data.  If the data has not been created yet,, +     * we do not add the delta to the breaker if it trips., +    void adjustBreaker(final long delta, final boolean isDataAlreadyCreated) {, +                        if (isDataAlreadyCreated) {, +                        }, +        assert oldMemSize == array.ramBytesEstimated(array.size) :, +            "ram bytes used should equal that which was previously estimated: ramBytesUsed=" +, +                oldMemSize + ", ramBytesEstimated=" + array.ramBytesEstimated(array.size);, +        final long estimatedIncreaseInBytes = array.ramBytesEstimated(newSize) - oldMemSize;, +        assert estimatedIncreaseInBytes >= 0 :, +            "estimated increase in bytes for resizing should not be negative: " + estimatedIncreaseInBytes;, +        adjustBreaker(estimatedIncreaseInBytes, false);, +            adjustBreaker(array.ramBytesUsed(), true);, +            // when allocating big arrays, we want to first ensure we have the capacity by, +            // checking with the circuit breaker before attempting to allocate]