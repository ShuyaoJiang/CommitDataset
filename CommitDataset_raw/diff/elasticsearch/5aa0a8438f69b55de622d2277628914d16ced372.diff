[+++ b/src/main/java/org/elasticsearch/common/geo/GeoHashUtils.java, +import org.elasticsearch.ElasticSearchIllegalArgumentException;, +, +import java.util.ArrayList;, +import java.util.List;, +, +    private static final char encode(int x, int y) {, +        return BASE_32[((x&1) + ((y&1)*2) + ((x&2)*2) + ((y&2)*4) + ((x&4)*4)) % 32];, +    }, +, +    /**, +     * Calculate all neighbors of a given geohash cell., +     * @param geohash Geohash of the defines cell, +     * @return geohashes of all neighbor cells, +     */, +    public static String[] neighbors(String geohash) {, +        List<String> neighbors = addNeighbors(geohash, geohash.length(), new ArrayList<String>(8));, +        return neighbors.toArray(new String[neighbors.size()]);, +    }, +, +    /**, +     * Calculate the geohash of a neighbor of a geohash, +     * , +     * @param geohash the geohash of a cell, +     * @param level level of the geohash, +     * @param dx delta of the first grid coordinate (must be -1, 0 or +1), +     * @param dy delta of the second grid coordinate (must be -1, 0 or +1), +     * @return geohash of the defined cell, +     */, +    private final static String neighbor(String geohash, int level, int dx, int dy) {, +        int cell = decode(geohash.charAt(level-1));, +, +        // Decoding the Geohash bit pattern to determine grid coordinates, +        int x0 = cell & 1;  // first bit of x, +        int y0 = cell & 2;  // first bit of y, +        int x1 = cell & 4;  // second bit of x, +        int y1 = cell & 8;  // second bit of y, +        int x2 = cell & 16; // third bit of x, +, +        // combine the bitpattern to grid coordinates., +        // note that the semantics of x and y are swapping, +        // on each level, +        int x = x0 + (x1/2) + (x2 / 4);, +        int y = (y0/2) + (y1/4);, +, +        if(level == 1) {, +            // Root cells at north (namely "bcfguvyz") or at, +            // south (namely "0145hjnp") do not have neighbors, +            // in north/south direction, +            if((dy < 0 && y == 0) || (dy > 0 && y == 3)) {, +                return null;, +            } else {, +                return Character.toString(encode(x + dx, y + dy));, +            }, +        } else {, +            // define grid coordinates for next level, +            final int nx = ((level % 2) == 1) ?(x + dx) :(x + dy);, +            final int ny = ((level % 2) == 1) ?(y + dy) :(y + dx);, +, +            // define grid limits for current level, +            final int xLimit = ((level % 2) == 0) ?7 :3;, +            final int yLimit = ((level % 2) == 0) ?3 :7;, +, +            // if the defined neighbor has the same parent a the current cell, +            // encode the cell direcly. Otherwise find the cell next to this, +            // cell recursively. Since encoding wraps around within a cell, +            // it can be encoded here., +            if(nx >= 0 && nx<=xLimit && ny>=0 && ny<yLimit) {, +                return geohash.substring(0, level - 1) + encode(nx, ny);, +            } else {, +                return neighbor(geohash, level - 1, dx, dy) + encode(nx, ny);, +            }, +        }, +    }, +, +    /**, +     * Add all geohashes of the cells next to a given geohash to a list., +     * , +     * @param geohash Geohash of a specified cell, +     * @param length level of the given geohash, +     * @param neighbors list to add the neighbors to, +     * @return the given list, +     */, +    private static final List<String> addNeighbors(String geohash, int length, List<String> neighbors) {, +        String south = neighbor(geohash, length, 0, -1);, +        String north = neighbor(geohash, length, 0, +1);, +, +        if(north != null) {, +            neighbors.add(neighbor(north, length, -1, 0));, +            neighbors.add(north);, +            neighbors.add(neighbor(north, length, +1, 0));, +        }, +, +        neighbors.add(neighbor(geohash, length, -1, 0));, +        neighbors.add(neighbor(geohash, length, +1, 0));, +, +        if(south != null) {, +            neighbors.add(neighbor(south, length, -1, 0));, +            neighbors.add(south);, +            neighbors.add(neighbor(south, length, +1, 0));]