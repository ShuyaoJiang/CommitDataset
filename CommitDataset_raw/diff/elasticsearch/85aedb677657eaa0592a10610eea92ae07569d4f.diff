[+++ b/plugin/src/main/java/org/elasticsearch/xpack/security/authc/ldap/LdapRealm.java, +import org.elasticsearch.ElasticsearchTimeoutException;, +import org.elasticsearch.common.settings.Setting.Property;, +import org.elasticsearch.common.unit.TimeValue;, +import org.elasticsearch.common.util.concurrent.AbstractRunnable;, +import org.elasticsearch.threadpool.ThreadPool.Names;, +    static final Setting<TimeValue> EXECUTION_TIMEOUT =, +            Setting.timeSetting("timeout.execution", TimeValue.timeValueSeconds(30L), Property.NodeScope);, +    private final TimeValue executionTimeout;, +        this.executionTimeout = EXECUTION_TIMEOUT.get(config.settings());, +        settings.add(EXECUTION_TIMEOUT);, +        final CancellableLdapRunnable cancellableLdapRunnable = new CancellableLdapRunnable(listener,, +                () -> sessionFactory.session(token.principal(), token.credentials(),, +                        new LdapSessionActionListener("authenticate", token.principal(), listener, roleMapper, logger)), logger);, +        threadPool.generic().execute(cancellableLdapRunnable);, +        threadPool.schedule(executionTimeout, Names.SAME, cancellableLdapRunnable::maybeTimeout);, +            final CancellableLdapRunnable cancellableLdapRunnable = new CancellableLdapRunnable(listener,, +                    () -> sessionFactory.unauthenticatedSession(username,, +                            new LdapSessionActionListener("lookup", username, listener, roleMapper, logger)), logger);, +            threadPool.generic().execute(cancellableLdapRunnable);, +            threadPool.schedule(executionTimeout, Names.SAME, cancellableLdapRunnable::maybeTimeout);, +, +    /**, +     * A runnable that allows us to terminate and call the listener. We use this as a runnable can, +     * be queued and not executed for a long time or ever and this causes user requests to appear, +     * to hang. In these cases at least we can provide a response., +     */, +    static class CancellableLdapRunnable extends AbstractRunnable {, +, +        private final Runnable in;, +        private final ActionListener<User> listener;, +        private final Logger logger;, +        private final AtomicReference<LdapRunnableState> state = new AtomicReference<>(LdapRunnableState.AWAITING_EXECUTION);, +, +        CancellableLdapRunnable(ActionListener<User> listener, Runnable in, Logger logger) {, +            this.listener = listener;, +            this.in = in;, +            this.logger = logger;, +        }, +, +        @Override, +        public void onFailure(Exception e) {, +            logger.error("execution of ldap runnable failed", e);, +            // this is really a exceptional state but just call the listener and maybe another realm can authenticate, otherwise, +            // something as simple as a down ldap server/network error takes down auth, +            listener.onResponse(null);, +        }, +, +        @Override, +        protected void doRun() throws Exception {, +            if (state.compareAndSet(LdapRunnableState.AWAITING_EXECUTION, LdapRunnableState.EXECUTING)) {, +                in.run();, +            } else {, +                logger.trace("skipping execution of ldap runnable as the current state is [{}]", state.get());, +            }, +        }, +, +        @Override, +        public void onRejection(Exception e) {, +            listener.onFailure(e);, +        }, +, +        /**, +         * If the execution of this runnable has not already started, the runnable is cancelled and we pass an exception to the user, +         * listener, +         */, +        void maybeTimeout() {, +            if (state.compareAndSet(LdapRunnableState.AWAITING_EXECUTION, LdapRunnableState.TIMED_OUT)) {, +                logger.warn("skipping execution of ldap runnable as it has been waiting for " +, +                        "execution too long");, +                listener.onFailure(new ElasticsearchTimeoutException("timed out waiting for " +, +                        "execution of ldap runnable"));, +            }, +        }, +, +        enum LdapRunnableState {, +            AWAITING_EXECUTION,, +            EXECUTING,, +            TIMED_OUT, +        }, +    }, +++ b/plugin/src/main/java/org/elasticsearch/xpack/security/authc/ldap/LdapRealm.java, +import org.elasticsearch.ElasticsearchTimeoutException;, +import org.elasticsearch.common.settings.Setting.Property;, +import org.elasticsearch.common.unit.TimeValue;, +import org.elasticsearch.common.util.concurrent.AbstractRunnable;, +import org.elasticsearch.threadpool.ThreadPool.Names;, +    static final Setting<TimeValue> EXECUTION_TIMEOUT =, +            Setting.timeSetting("timeout.execution", TimeValue.timeValueSeconds(30L), Property.NodeScope);, +    private final TimeValue executionTimeout;, +        this.executionTimeout = EXECUTION_TIMEOUT.get(config.settings());, +        settings.add(EXECUTION_TIMEOUT);, +        final CancellableLdapRunnable cancellableLdapRunnable = new CancellableLdapRunnable(listener,, +                () -> sessionFactory.session(token.principal(), token.credentials(),, +                        new LdapSessionActionListener("authenticate", token.principal(), listener, roleMapper, logger)), logger);, +        threadPool.generic().execute(cancellableLdapRunnable);, +        threadPool.schedule(executionTimeout, Names.SAME, cancellableLdapRunnable::maybeTimeout);, +            final CancellableLdapRunnable cancellableLdapRunnable = new CancellableLdapRunnable(listener,, +                    () -> sessionFactory.unauthenticatedSession(username,, +                            new LdapSessionActionListener("lookup", username, listener, roleMapper, logger)), logger);]