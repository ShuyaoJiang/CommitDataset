[+++ b/core/src/main/java/org/elasticsearch/cluster/metadata/MetaDataIndexStateService.java, +import com.carrotsearch.hppc.cursors.ObjectObjectCursor;, +import org.elasticsearch.cluster.RestoreInProgress;, +import org.elasticsearch.index.shard.ShardId;, +import java.util.HashSet;, +import java.util.Set;, +                Set<String> indicesToClose = new HashSet<>();, +                // Check if any of the indices to be closed are currently being restored from a snapshot and fail closing if such an index, +                // is found as closing an index that is being restored makes the index unusable (it cannot be recovered)., +                RestoreInProgress restore = currentState.custom(RestoreInProgress.TYPE);, +                if (restore != null) {, +                    Set<String> indicesToFail = null;, +                    for (RestoreInProgress.Entry entry : restore.entries()) {, +                        for (ObjectObjectCursor<ShardId, RestoreInProgress.ShardRestoreStatus> shard : entry.shards()) {, +                            if (!shard.value.state().completed()) {, +                                if (indicesToClose.contains(shard.key.getIndexName())) {, +                                    if (indicesToFail == null) {, +                                        indicesToFail = new HashSet<>();, +                                    }, +                                    indicesToFail.add(shard.key.getIndexName());, +                                }, +                            }, +                        }, +                    }, +                    if (indicesToFail != null) {, +                        throw new IllegalArgumentException("Cannot close indices that are being restored: " + indicesToFail);, +                    }, +                }, +, +++ b/core/src/main/java/org/elasticsearch/cluster/metadata/MetaDataIndexStateService.java, +import com.carrotsearch.hppc.cursors.ObjectObjectCursor;, +import org.elasticsearch.cluster.RestoreInProgress;, +import org.elasticsearch.index.shard.ShardId;, +import java.util.HashSet;, +import java.util.Set;, +                Set<String> indicesToClose = new HashSet<>();, +                // Check if any of the indices to be closed are currently being restored from a snapshot and fail closing if such an index, +                // is found as closing an index that is being restored makes the index unusable (it cannot be recovered)., +                RestoreInProgress restore = currentState.custom(RestoreInProgress.TYPE);, +                if (restore != null) {, +                    Set<String> indicesToFail = null;, +                    for (RestoreInProgress.Entry entry : restore.entries()) {, +                        for (ObjectObjectCursor<ShardId, RestoreInProgress.ShardRestoreStatus> shard : entry.shards()) {, +                            if (!shard.value.state().completed()) {, +                                if (indicesToClose.contains(shard.key.getIndexName())) {, +                                    if (indicesToFail == null) {, +                                        indicesToFail = new HashSet<>();, +                                    }, +                                    indicesToFail.add(shard.key.getIndexName());, +                                }, +                            }, +                        }, +                    }, +                    if (indicesToFail != null) {, +                        throw new IllegalArgumentException("Cannot close indices that are being restored: " + indicesToFail);, +                    }, +                }, +, +++ b/core/src/main/java/org/elasticsearch/index/fielddata/IndexFieldData.java, +            private final Weight innerFilter;, +            public Nested(BitSetProducer rootFilter, Weight innerFilter) {, +                this.innerFilter = innerFilter;, +                Scorer s = innerFilter.scorer(ctx);, +++ b/core/src/main/java/org/elasticsearch/cluster/metadata/MetaDataIndexStateService.java, +import com.carrotsearch.hppc.cursors.ObjectObjectCursor;, +import org.elasticsearch.cluster.RestoreInProgress;, +import org.elasticsearch.index.shard.ShardId;, +import java.util.HashSet;, +import java.util.Set;, +                Set<String> indicesToClose = new HashSet<>();, +                // Check if any of the indices to be closed are currently being restored from a snapshot and fail closing if such an index, +                // is found as closing an index that is being restored makes the index unusable (it cannot be recovered)., +                RestoreInProgress restore = currentState.custom(RestoreInProgress.TYPE);, +                if (restore != null) {, +                    Set<String> indicesToFail = null;, +                    for (RestoreInProgress.Entry entry : restore.entries()) {, +                        for (ObjectObjectCursor<ShardId, RestoreInProgress.ShardRestoreStatus> shard : entry.shards()) {, +                            if (!shard.value.state().completed()) {, +                                if (indicesToClose.contains(shard.key.getIndexName())) {, +                                    if (indicesToFail == null) {, +                                        indicesToFail = new HashSet<>();, +                                    }, +                                    indicesToFail.add(shard.key.getIndexName());, +                                }, +                            }, +                        }, +                    }, +                    if (indicesToFail != null) {, +                        throw new IllegalArgumentException("Cannot close indices that are being restored: " + indicesToFail);, +                    }, +                }, +, +++ b/core/src/main/java/org/elasticsearch/index/fielddata/IndexFieldData.java, +            private final Weight innerFilter;, +            public Nested(BitSetProducer rootFilter, Weight innerFilter) {, +                this.innerFilter = innerFilter;, +                Scorer s = innerFilter.scorer(ctx);, +++ b/core/src/main/java/org/elasticsearch/index/query/support/NestedInnerQueryParseSupport.java, +import org.elasticsearch.search.internal.SearchContext;, +    public NestedInnerQueryParseSupport(XContentParser parser, SearchContext searchContext) {]