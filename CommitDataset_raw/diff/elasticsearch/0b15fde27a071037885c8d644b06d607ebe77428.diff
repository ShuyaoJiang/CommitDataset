[+++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/Compiler.java, +        Definition definition = Definition.BUILTINS;, +        ScriptInterface scriptInterface = new ScriptInterface(definition, iface);, +        SSource root = Walker.buildPainlessTree(scriptInterface, name, source, settings, definition,, +                null);, +        root.analyze(definition);, +            clazz.getField("$DEFINITION").set(null, definition);, +        Definition definition = Definition.BUILTINS;, +        ScriptInterface scriptInterface = new ScriptInterface(definition, iface);, +        SSource root = Walker.buildPainlessTree(scriptInterface, name, source, settings, definition,, +                debugStream);, +        root.analyze(definition);, +++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/Compiler.java, +        Definition definition = Definition.BUILTINS;, +        ScriptInterface scriptInterface = new ScriptInterface(definition, iface);, +        SSource root = Walker.buildPainlessTree(scriptInterface, name, source, settings, definition,, +                null);, +        root.analyze(definition);, +            clazz.getField("$DEFINITION").set(null, definition);, +        Definition definition = Definition.BUILTINS;, +        ScriptInterface scriptInterface = new ScriptInterface(definition, iface);, +        SSource root = Walker.buildPainlessTree(scriptInterface, name, source, settings, definition,, +                debugStream);, +        root.analyze(definition);, +++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/Def.java, +     * @params definition the whitelist, +    static Method lookupMethodInternal(Definition definition, Class<?> receiverClass, String name, int arity) {, +            RuntimeClass struct = definition.getRuntimeClass(clazz);, +                struct = definition.getRuntimeClass(iface);, +     * @param definition the whitelist, +    static MethodHandle lookupMethod(Definition definition, Lookup lookup, MethodType callSiteType,, +             return lookupMethodInternal(definition, receiverClass, name, numArguments - 1).handle;, +         Method method = lookupMethodInternal(definition, receiverClass, name, arity);, +                     filter = lookupReferenceInternal(definition,, +                                                      lookup,, +                     CallSite nested = DefBootstrap.bootstrap(definition,, +                                                              lookup,, +    static MethodHandle lookupReference(Definition definition, Lookup lookup, String interfaceClass,, +         Definition.Type interfaceType = definition.getType(interfaceClass);, +         Method implMethod = lookupMethodInternal(definition, receiverClass, name, arity);, +        return lookupReferenceInternal(definition, lookup, interfaceType, implMethod.owner.name,, +                implMethod.name, receiverClass);, +    private static MethodHandle lookupReferenceInternal(Definition definition, Lookup lookup,, +            Definition.Type clazz, String type, String call, Class<?>... captures), +            throws Throwable {, +             ref = new FunctionRef(definition, clazz, type, call, captures.length);, +     * @param definition the whitelist, +    static MethodHandle lookupGetter(Definition definition, Class<?> receiverClass, String name) {, +            RuntimeClass struct = definition.getRuntimeClass(clazz);, +                struct = definition.getRuntimeClass(iface);, +     * @param definition the whitelist, +    static MethodHandle lookupSetter(Definition definition, Class<?> receiverClass, String name) {, +            RuntimeClass struct = definition.getRuntimeClass(clazz);, +                struct = definition.getRuntimeClass(iface);, +++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/Compiler.java, +        Definition definition = Definition.BUILTINS;, +        ScriptInterface scriptInterface = new ScriptInterface(definition, iface);, +        SSource root = Walker.buildPainlessTree(scriptInterface, name, source, settings, definition,, +                null);, +        root.analyze(definition);, +            clazz.getField("$DEFINITION").set(null, definition);, +        Definition definition = Definition.BUILTINS;, +        ScriptInterface scriptInterface = new ScriptInterface(definition, iface);, +        SSource root = Walker.buildPainlessTree(scriptInterface, name, source, settings, definition,, +                debugStream);, +        root.analyze(definition);, +++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/Def.java, +     * @params definition the whitelist, +    static Method lookupMethodInternal(Definition definition, Class<?> receiverClass, String name, int arity) {, +            RuntimeClass struct = definition.getRuntimeClass(clazz);, +                struct = definition.getRuntimeClass(iface);, +     * @param definition the whitelist, +    static MethodHandle lookupMethod(Definition definition, Lookup lookup, MethodType callSiteType,, +             return lookupMethodInternal(definition, receiverClass, name, numArguments - 1).handle;, +         Method method = lookupMethodInternal(definition, receiverClass, name, arity);, +                     filter = lookupReferenceInternal(definition,, +                                                      lookup,, +                     CallSite nested = DefBootstrap.bootstrap(definition,, +                                                              lookup,, +    static MethodHandle lookupReference(Definition definition, Lookup lookup, String interfaceClass,, +         Definition.Type interfaceType = definition.getType(interfaceClass);, +         Method implMethod = lookupMethodInternal(definition, receiverClass, name, arity);, +        return lookupReferenceInternal(definition, lookup, interfaceType, implMethod.owner.name,, +                implMethod.name, receiverClass);, +    private static MethodHandle lookupReferenceInternal(Definition definition, Lookup lookup,, +            Definition.Type clazz, String type, String call, Class<?>... captures), +            throws Throwable {, +             ref = new FunctionRef(definition, clazz, type, call, captures.length);, +     * @param definition the whitelist, +    static MethodHandle lookupGetter(Definition definition, Class<?> receiverClass, String name) {, +            RuntimeClass struct = definition.getRuntimeClass(clazz);, +                struct = definition.getRuntimeClass(iface);, +     * @param definition the whitelist, +    static MethodHandle lookupSetter(Definition definition, Class<?> receiverClass, String name) {, +            RuntimeClass struct = definition.getRuntimeClass(clazz);, +                struct = definition.getRuntimeClass(iface);, +++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/DefBootstrap.java, +        private final Definition definition;, +        PIC(Definition definition, Lookup lookup, String name, MethodType type, int initialDepth, int flavor, Object[] args) {, +            this.definition = definition;]