[+++ b/plugin/src/main/java/org/elasticsearch/xpack/ml/action/TransportJobTaskAction.java, +            // Note that DatafeedJob relies on this exception being thrown to detect the state, +            // conflict and stop the datafeed. If this exception type/status changes, DatafeedJob, +            // also needs to change., +++ b/plugin/src/main/java/org/elasticsearch/xpack/ml/action/TransportJobTaskAction.java, +            // Note that DatafeedJob relies on this exception being thrown to detect the state, +            // conflict and stop the datafeed. If this exception type/status changes, DatafeedJob, +            // also needs to change., +++ b/plugin/src/main/java/org/elasticsearch/xpack/ml/datafeed/DatafeedJob.java, +import org.elasticsearch.ElasticsearchStatusException;, +import org.elasticsearch.rest.RestStatus;, +, +                    // a conflict exception means the job state is not open any more., +                    // we should therefore stop the datafeed., +                    boolean shouldStop = isConflictException(e);, +, +                    error = new AnalysisProblemException(shouldStop, e);, +            flushJob(flushRequest);, +    private boolean isConflictException(Exception e) {, +        return e instanceof ElasticsearchStatusException, +                && ((ElasticsearchStatusException) e).status() == RestStatus.CONFLICT;, +    }, +, +    private void flushJob(FlushJobAction.Request flushRequest) {, +        try {, +            client.execute(FlushJobAction.INSTANCE, flushRequest).actionGet();, +        } catch (Exception e) {, +            LOGGER.debug("[" + jobId + "] error while flushing job", e);, +, +            // a conflict exception means the job state is not open any more., +            // we should therefore stop the datafeed., +            boolean shouldStop = isConflictException(e);, +, +            // When an analysis problem occurs, it means something catastrophic has, +            // happened to the c++ process. We sent a batch of data to the c++ process, +            // yet we do not know how many of those were processed. It is better to, +            // advance time in order to avoid importing duplicate data., +            throw new AnalysisProblemException(shouldStop, e);, +        }, +    }, +, +        final boolean shouldStop;, +        AnalysisProblemException(boolean shouldStop, Throwable cause) {, +            this.shouldStop = shouldStop;, +++ b/plugin/src/main/java/org/elasticsearch/xpack/ml/action/TransportJobTaskAction.java, +            // Note that DatafeedJob relies on this exception being thrown to detect the state, +            // conflict and stop the datafeed. If this exception type/status changes, DatafeedJob, +            // also needs to change., +++ b/plugin/src/main/java/org/elasticsearch/xpack/ml/datafeed/DatafeedJob.java, +import org.elasticsearch.ElasticsearchStatusException;, +import org.elasticsearch.rest.RestStatus;, +, +                    // a conflict exception means the job state is not open any more., +                    // we should therefore stop the datafeed., +                    boolean shouldStop = isConflictException(e);, +, +                    error = new AnalysisProblemException(shouldStop, e);, +            flushJob(flushRequest);, +    private boolean isConflictException(Exception e) {, +        return e instanceof ElasticsearchStatusException, +                && ((ElasticsearchStatusException) e).status() == RestStatus.CONFLICT;, +    }, +, +    private void flushJob(FlushJobAction.Request flushRequest) {, +        try {, +            client.execute(FlushJobAction.INSTANCE, flushRequest).actionGet();, +        } catch (Exception e) {, +            LOGGER.debug("[" + jobId + "] error while flushing job", e);, +, +            // a conflict exception means the job state is not open any more., +            // we should therefore stop the datafeed., +            boolean shouldStop = isConflictException(e);, +, +            // When an analysis problem occurs, it means something catastrophic has, +            // happened to the c++ process. We sent a batch of data to the c++ process, +            // yet we do not know how many of those were processed. It is better to, +            // advance time in order to avoid importing duplicate data., +            throw new AnalysisProblemException(shouldStop, e);, +        }, +    }, +, +        final boolean shouldStop;, +        AnalysisProblemException(boolean shouldStop, Throwable cause) {, +            this.shouldStop = shouldStop;, +++ b/plugin/src/main/java/org/elasticsearch/xpack/ml/datafeed/DatafeedManager.java, +                    if (e.shouldStop) {, +                        holder.stop("lookback_analysis_error", TimeValue.timeValueSeconds(20), e);, +                        return;, +                    }, +                        if (e.shouldStop) {, +                            holder.stop("realtime_analysis_error", TimeValue.timeValueSeconds(20), e);, +                            return;, +                        }, +    /**, +     * Visible for testing, +     */, +    boolean isRunning(String datafeedId) {, +        return runningDatafeeds.containsKey(datafeedId);, +    }, +]