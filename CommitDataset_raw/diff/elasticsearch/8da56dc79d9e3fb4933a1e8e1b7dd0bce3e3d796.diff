[+++ /dev/null, +++ /dev/null, +++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/Locals.java, +        Locals locals = new Locals(programScope, programScope.painlessLookup, programScope.baseClass, returnType, KEYWORDS);, +        Locals locals = new Locals(programScope, programScope.painlessLookup, programScope.baseClass, returnType, KEYWORDS);, +        Locals locals = new Locals(programScope, programScope.painlessLookup,, +                scriptClassInfo.getBaseClass(), scriptClassInfo.getExecuteMethodReturnType(), KEYWORDS);, +    public static Locals newProgramScope(ScriptClassInfo scriptClassInfo, PainlessLookup painlessLookup, Collection<LocalMethod> methods) {, +        Locals locals = new Locals(null, painlessLookup, scriptClassInfo.getBaseClass(), null, null);, +    /** Base class for the compiled script. */, +    public Class<?> getBaseClass() {, +        return baseClass;, +    }, +, +    /** Base class for the compiled script. */, +    private final Class<?> baseClass;, +        this(parent, parent.painlessLookup, parent.baseClass, parent.returnType, parent.keywords);, +    private Locals(Locals parent, PainlessLookup painlessLookup, Class<?> baseClass, Class<?> returnType, Set<String> keywords) {, +        this.baseClass = baseClass;, +++ /dev/null, +++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/Locals.java, +        Locals locals = new Locals(programScope, programScope.painlessLookup, programScope.baseClass, returnType, KEYWORDS);, +        Locals locals = new Locals(programScope, programScope.painlessLookup, programScope.baseClass, returnType, KEYWORDS);, +        Locals locals = new Locals(programScope, programScope.painlessLookup,, +                scriptClassInfo.getBaseClass(), scriptClassInfo.getExecuteMethodReturnType(), KEYWORDS);, +    public static Locals newProgramScope(ScriptClassInfo scriptClassInfo, PainlessLookup painlessLookup, Collection<LocalMethod> methods) {, +        Locals locals = new Locals(null, painlessLookup, scriptClassInfo.getBaseClass(), null, null);, +    /** Base class for the compiled script. */, +    public Class<?> getBaseClass() {, +        return baseClass;, +    }, +, +    /** Base class for the compiled script. */, +    private final Class<?> baseClass;, +        this(parent, parent.painlessLookup, parent.baseClass, parent.returnType, parent.keywords);, +    private Locals(Locals parent, PainlessLookup painlessLookup, Class<?> baseClass, Class<?> returnType, Set<String> keywords) {, +        this.baseClass = baseClass;, +++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/ECallLocal.java, +    private int classBindingOffset = 0;, +                // check to see if this class binding requires an implicit this reference, +                if (classBinding != null && classBinding.typeParameters.isEmpty() == false &&, +                        classBinding.typeParameters.get(0) == locals.getBaseClass()) {, +                    classBinding = null;, +                }, +, +                if (classBinding == null) {, +                    // This extra check looks for a possible match where the class binding requires an implicit this, +                    // reference.  This is a temporary solution to allow the class binding access to data from the, +                    // base script class without need for a user to add additional arguments.  A long term solution, +                    // will likely involve adding a class instance binding where any instance can have a class binding, +                    // as part of its API.  However, the situation at run-time is difficult and will modifications that, +                    // are a substantial change if even possible to do., +                    classBinding = locals.getPainlessLookup().lookupPainlessClassBinding(name, arguments.size() + 1);, +, +                    if (classBinding != null) {, +                        if (classBinding.typeParameters.isEmpty() == false &&, +                                classBinding.typeParameters.get(0) == locals.getBaseClass()) {, +                            classBindingOffset = 1;, +                        } else {, +                            classBinding = null;, +                        }, +                    }, +, +                            throw createError(new IllegalArgumentException(, +                                    "Unknown call [" + name + "] with [" + arguments.size() + "] arguments."));, +                        }, +        // if the class binding is using an implicit this reference then the arguments counted must, +        // be incremented by 1 as the this reference will not be part of the arguments passed into, +        // the class binding call, +            expression.expected = typeParameters.get(argument + classBindingOffset);, +            int javaConstructorParameterCount = classBinding.javaConstructor.getParameterCount() - classBindingOffset;, +            if (classBindingOffset == 1) {, +                writer.loadThis();, +            }, +, +++ /dev/null, +++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/Locals.java, +        Locals locals = new Locals(programScope, programScope.painlessLookup, programScope.baseClass, returnType, KEYWORDS);, +        Locals locals = new Locals(programScope, programScope.painlessLookup, programScope.baseClass, returnType, KEYWORDS);, +        Locals locals = new Locals(programScope, programScope.painlessLookup,, +                scriptClassInfo.getBaseClass(), scriptClassInfo.getExecuteMethodReturnType(), KEYWORDS);, +    public static Locals newProgramScope(ScriptClassInfo scriptClassInfo, PainlessLookup painlessLookup, Collection<LocalMethod> methods) {, +        Locals locals = new Locals(null, painlessLookup, scriptClassInfo.getBaseClass(), null, null);, +    /** Base class for the compiled script. */, +    public Class<?> getBaseClass() {, +        return baseClass;, +    }, +, +    /** Base class for the compiled script. */, +    private final Class<?> baseClass;, +        this(parent, parent.painlessLookup, parent.baseClass, parent.returnType, parent.keywords);, +    private Locals(Locals parent, PainlessLookup painlessLookup, Class<?> baseClass, Class<?> returnType, Set<String> keywords) {, +        this.baseClass = baseClass;, +++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/ECallLocal.java, +    private int classBindingOffset = 0;, +                // check to see if this class binding requires an implicit this reference, +                if (classBinding != null && classBinding.typeParameters.isEmpty() == false &&, +                        classBinding.typeParameters.get(0) == locals.getBaseClass()) {, +                    classBinding = null;, +                }]