[+++ b/src/main/java/org/elasticsearch/search/suggest/completion/CompletionTokenStream.java, +import org.apache.lucene.analysis.tokenattributes.*;, +import org.apache.lucene.util.*;, +    private final PayloadAttribute payloadAttr = addAttribute(PayloadAttribute.class);, +    private final ByteTermAttribute bytesAtt = addAttribute(ByteTermAttribute.class);;, +, +    private CharTermAttribute charTermAttribute;, +        // Don't call the super(input) ctor - this is a true delegate and has a new attribute source since we consume, +        // the input stream entirely in toFiniteStrings(input), +            Util.toBytesRef(finiteStrings.next(), bytesAtt.getBytesRef()); // now we have UTF-8, +            if (charTermAttribute != null) {, +                charTermAttribute.setLength(0);, +                charTermAttribute.append(bytesAtt.toUTF16());, +            }, +        if (hasAttribute(CharTermAttribute.class)) {, +            // we only create this if we really need it to safe the UTF-8 to UTF-16 conversion, +            charTermAttribute = getAttribute(CharTermAttribute.class);, +        }, +        // marker interface, +, +        public CharSequence toUTF16();, +        private final BytesRef bytes = new BytesRef();, +        private CharsRef charsRef;, +            bytes.length = 0;, +            other.bytes.copyBytes(bytes);, +        }, +, +        @Override, +        public CharSequence toUTF16() {, +            if (charsRef == null) {, +                charsRef = new CharsRef();, +            }, +            UnicodeUtil.UTF8toUTF16(bytes, charsRef);, +            return charsRef;, +++ b/src/main/java/org/elasticsearch/search/suggest/completion/CompletionTokenStream.java, +import org.apache.lucene.analysis.tokenattributes.*;, +import org.apache.lucene.util.*;, +    private final PayloadAttribute payloadAttr = addAttribute(PayloadAttribute.class);, +    private final ByteTermAttribute bytesAtt = addAttribute(ByteTermAttribute.class);;, +, +    private CharTermAttribute charTermAttribute;, +        // Don't call the super(input) ctor - this is a true delegate and has a new attribute source since we consume, +        // the input stream entirely in toFiniteStrings(input), +            Util.toBytesRef(finiteStrings.next(), bytesAtt.getBytesRef()); // now we have UTF-8, +            if (charTermAttribute != null) {, +                charTermAttribute.setLength(0);, +                charTermAttribute.append(bytesAtt.toUTF16());, +            }, +        if (hasAttribute(CharTermAttribute.class)) {, +            // we only create this if we really need it to safe the UTF-8 to UTF-16 conversion, +            charTermAttribute = getAttribute(CharTermAttribute.class);, +        }, +        // marker interface, +, +        public CharSequence toUTF16();, +        private final BytesRef bytes = new BytesRef();, +        private CharsRef charsRef;, +            bytes.length = 0;, +            other.bytes.copyBytes(bytes);, +        }, +, +        @Override, +        public CharSequence toUTF16() {, +            if (charsRef == null) {, +                charsRef = new CharsRef();, +            }, +            UnicodeUtil.UTF8toUTF16(bytes, charsRef);, +            return charsRef;, +++ b/src/test/java/org/elasticsearch/search/suggest/CompletionSuggestSearchTests.java, +import org.elasticsearch.action.percolate.PercolateResponse;, +import org.elasticsearch.client.Requests;, +import org.elasticsearch.percolator.PercolatorService;, +import static org.elasticsearch.index.query.QueryBuilders.matchAllQuery;, +    public void testSuggestFieldWithPercolateApi() throws Exception {, +        createIndexAndMapping();, +        String[][] input = {{"Foo Fighters"}, {"Foo Fighters"}, {"Foo Fighters"}, {"Foo Fighters"},, +                {"Generator", "Foo Fighters Generator"}, {"Learn to Fly", "Foo Fighters Learn to Fly"},, +                {"The Prodigy"}, {"The Prodigy"}, {"The Prodigy"}, {"Firestarter", "The Prodigy Firestarter"},, +                {"Turbonegro"}, {"Turbonegro"}, {"Get it on", "Turbonegro Get it on"}}; // work with frequencies, +        for (int i = 0; i < input.length; i++) {, +            client().prepareIndex(INDEX, TYPE, "" + i), +                    .setSource(jsonBuilder(), +                            .startObject().startObject(FIELD), +                            .startArray("input").value(input[i]).endArray(), +                            .endObject(), +                            .endObject(), +                    ), +                    .execute().actionGet();, +        }, +, +        client().prepareIndex(INDEX, PercolatorService.TYPE_NAME, "4"), +                .setSource(jsonBuilder().startObject().field("query", matchAllQuery()).endObject()), +                .execute().actionGet();, +, +        refresh();, +, +        PercolateResponse response = client().preparePercolate().setIndices(INDEX).setDocumentType(TYPE), +                .setGetRequest(Requests.getRequest(INDEX).type(TYPE).id("1")), +                .execute().actionGet();, +        assertThat(response.getCount(), equalTo(1l));]