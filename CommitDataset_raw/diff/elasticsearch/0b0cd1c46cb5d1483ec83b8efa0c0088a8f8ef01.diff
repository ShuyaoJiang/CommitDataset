[+++ b/src/main/java/org/elasticsearch/index/engine/InternalEngine.java, +        /*, +         * Unfortunately the lock order is important here. We have to acquire the readlock fist otherwise, +         * if we are flushing at the end of the recovery while holding the write lock we can deadlock if:, +         *  Thread 1: flushes via API and gets the flush lock but blocks on the readlock since Thread 2 has the writeLock, +         *  Thread 2: flushes at the end of the recovery holding the writeLock and blocks on the flushLock owned by Thread 1, +         */, +            updateIndexWriterSettings();, +            if (flushLock.tryLock() == false) {, +                // if we can't get the lock right away we block if needed otherwise barf, +                if (waitIfOngoing) {, +                    logger.trace("waiting fore in-flight flush to finish");, +                    flushLock.lock();, +                    logger.trace("acquired flush lock after blocking");, +                } else {, +                    throw new FlushNotAllowedEngineException(shardId, "already flushing...");, +                }, +            } else {, +                logger.trace("acquired flush lock immediately");, +            }, +            try {, +                if (commitTranslog) {, +                try {, +            }, +        }, +        // We don't have to do this here; we do it defensively to make sure that even if wall clock time is misbehaving, +        // (e.g., moves backwards) we will at least still sometimes prune deleted tombstones:, +        if (engineConfig.isEnableGcDeletes()) {, +            pruneDeletedTombstones();, +++ b/src/main/java/org/elasticsearch/index/engine/InternalEngine.java, +        /*, +         * Unfortunately the lock order is important here. We have to acquire the readlock fist otherwise, +         * if we are flushing at the end of the recovery while holding the write lock we can deadlock if:, +         *  Thread 1: flushes via API and gets the flush lock but blocks on the readlock since Thread 2 has the writeLock, +         *  Thread 2: flushes at the end of the recovery holding the writeLock and blocks on the flushLock owned by Thread 1, +         */, +            updateIndexWriterSettings();, +            if (flushLock.tryLock() == false) {, +                // if we can't get the lock right away we block if needed otherwise barf, +                if (waitIfOngoing) {, +                    logger.trace("waiting fore in-flight flush to finish");, +                    flushLock.lock();, +                    logger.trace("acquired flush lock after blocking");, +                } else {, +                    throw new FlushNotAllowedEngineException(shardId, "already flushing...");, +                }, +            } else {, +                logger.trace("acquired flush lock immediately");, +            }, +            try {, +                if (commitTranslog) {, +                try {, +            }, +        }, +        // We don't have to do this here; we do it defensively to make sure that even if wall clock time is misbehaving, +        // (e.g., moves backwards) we will at least still sometimes prune deleted tombstones:, +        if (engineConfig.isEnableGcDeletes()) {, +            pruneDeletedTombstones();, +++ b/src/main/java/org/elasticsearch/index/shard/IndexShard.java, +        if (store.tryIncRef()) {, +            } finally {, +                store.decRef();, +            }]