[+++ b/modules/repository-url/build.gradle, +forbiddenApisTest {, +    // we are using jdk-internal instead of jdk-non-portable to allow for com.sun.net.httpserver.* usage, +    bundledSignatures -= 'jdk-non-portable', +    bundledSignatures += 'jdk-internal', +}, +, +++ b/modules/repository-url/build.gradle, +forbiddenApisTest {, +    // we are using jdk-internal instead of jdk-non-portable to allow for com.sun.net.httpserver.* usage, +    bundledSignatures -= 'jdk-non-portable', +    bundledSignatures += 'jdk-internal', +}, +, +++ b/modules/repository-url/src/test/java/org/elasticsearch/repositories/url/URLFixture.java, +import com.sun.net.httpserver.HttpExchange;, +import com.sun.net.httpserver.HttpHandler;, +import com.sun.net.httpserver.HttpServer;, +import org.elasticsearch.mocksocket.MockHttpServer;, +import java.lang.management.ManagementFactory;, +import java.net.Inet6Address;, +import java.net.InetAddress;, +import java.net.InetSocketAddress;, +import java.net.SocketAddress;, +import java.nio.charset.StandardCharsets;, +import java.nio.file.StandardCopyOption;, +import java.util.Objects;, +, +import static java.nio.charset.StandardCharsets.UTF_8;, +import static java.util.Collections.emptyMap;, +import static java.util.Collections.singleton;, +import static java.util.Collections.singletonMap;, +public class URLFixture {, +        final InetSocketAddress socketAddress = new InetSocketAddress(InetAddress.getLoopbackAddress(), 0);, +        final HttpServer httpServer = MockHttpServer.createHttp(socketAddress, 0);, +, +        try {, +            final Path workingDirectory = dir(args[0]);, +            /// Writes the PID of the current Java process in a `pid` file located in the working directory, +            writeFile(workingDirectory, "pid", ManagementFactory.getRuntimeMXBean().getName().split("@")[0]);, +, +            final String addressAndPort = addressToString(httpServer.getAddress());, +            // Writes the address and port of the http server in a `ports` file located in the working directory, +            writeFile(workingDirectory, "ports", addressAndPort);, +, +            // Exposes the repository over HTTP, +            httpServer.createContext("/", new ResponseHandler(dir(args[1])));, +            httpServer.start();, +, +            // Wait to be killed, +            Thread.sleep(Long.MAX_VALUE);, +, +        } finally {, +            httpServer.stop(0);, +        }, +    }, +, +    @SuppressForbidden(reason = "Paths#get is fine - we don't have environment here"), +    private static Path dir(final String dir) {, +        return Paths.get(dir);, +    }, +, +    private static void writeFile(final Path dir, final String fileName, final String content) throws IOException {, +        final Path tempPidFile = Files.createTempFile(dir, null, null);, +        Files.write(tempPidFile, singleton(content));, +        Files.move(tempPidFile, dir.resolve(fileName), StandardCopyOption.ATOMIC_MOVE);, +    }, +, +    private static String addressToString(final SocketAddress address) {, +        final InetSocketAddress inetSocketAddress = (InetSocketAddress) address;, +        if (inetSocketAddress.getAddress() instanceof Inet6Address) {, +            return "[" + inetSocketAddress.getHostString() + "]:" + inetSocketAddress.getPort();, +        } else {, +            return inetSocketAddress.getHostString() + ":" + inetSocketAddress.getPort();, +        }, +    }, +, +    static class ResponseHandler implements HttpHandler {, +, +        private final Path repositoryDir;, +, +        ResponseHandler(final Path repositoryDir) {, +            this.repositoryDir = repositoryDir;, +        public void handle(HttpExchange exchange) throws IOException {, +            Response response;, +, +            final String userAgent = exchange.getRequestHeaders().getFirst("User-Agent");, +            if (userAgent != null && userAgent.startsWith("Apache Ant")) {, +                // This is a request made by the AntFixture, just reply "OK", +                response = new Response(RestStatus.OK, emptyMap(), "text/plain; charset=utf-8", "OK".getBytes(UTF_8));, +, +            } else if ("GET".equalsIgnoreCase(exchange.getRequestMethod())) {, +                String path = exchange.getRequestURI().toString();, +                        Map<String, String> headers = singletonMap("Content-Length", String.valueOf(content.length));, +                        response = new Response(RestStatus.OK, headers, "application/octet-stream", content);, +                        response = new Response(RestStatus.NOT_FOUND, emptyMap(), "text/plain; charset=utf-8", new byte[0]);, +                    response = new Response(RestStatus.FORBIDDEN, emptyMap(), "text/plain; charset=utf-8", new byte[0]);, +            } else {, +                response = new Response(RestStatus.INTERNAL_SERVER_ERROR, emptyMap(), "text/plain; charset=utf-8",, +                    "Unsupported HTTP method".getBytes(StandardCharsets.UTF_8));]