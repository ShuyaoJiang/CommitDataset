[+++ b/core/src/main/java/org/elasticsearch/client/transport/support/TransportProxyClient.java, +import java.util.Collections;, +++ b/core/src/main/java/org/elasticsearch/client/transport/support/TransportProxyClient.java, +import java.util.Collections;, +++ b/core/src/main/java/org/elasticsearch/cluster/routing/RecoverySource.java, +++ b/core/src/main/java/org/elasticsearch/client/transport/support/TransportProxyClient.java, +import java.util.Collections;, +++ b/core/src/main/java/org/elasticsearch/cluster/routing/RecoverySource.java, +++ b/core/src/main/java/org/elasticsearch/cluster/routing/allocation/decider/FilterAllocationDecider.java, +            if (shardRouting.recoverySource().getType() != RecoverySource.Type.EXISTING_STORE &&, +                initialRecoveryFilters != null &&, +++ b/core/src/main/java/org/elasticsearch/client/transport/support/TransportProxyClient.java, +import java.util.Collections;, +++ b/core/src/main/java/org/elasticsearch/cluster/routing/RecoverySource.java, +++ b/core/src/main/java/org/elasticsearch/cluster/routing/allocation/decider/FilterAllocationDecider.java, +            if (shardRouting.recoverySource().getType() != RecoverySource.Type.EXISTING_STORE &&, +                initialRecoveryFilters != null &&, +++ b/core/src/test/java/org/elasticsearch/action/admin/indices/create/CreateIndexIT.java, +            .setSettings(Settings.builder().put("index.number_of_replicas", 0).build()).get());, +++ b/core/src/main/java/org/elasticsearch/client/transport/support/TransportProxyClient.java, +import java.util.Collections;, +++ b/core/src/main/java/org/elasticsearch/cluster/routing/RecoverySource.java, +++ b/core/src/main/java/org/elasticsearch/cluster/routing/allocation/decider/FilterAllocationDecider.java, +            if (shardRouting.recoverySource().getType() != RecoverySource.Type.EXISTING_STORE &&, +                initialRecoveryFilters != null &&, +++ b/core/src/test/java/org/elasticsearch/action/admin/indices/create/CreateIndexIT.java, +            .setSettings(Settings.builder().put("index.number_of_replicas", 0).build()).get());, +++ b/core/src/test/java/org/elasticsearch/cluster/routing/allocation/FilterAllocationDeciderTests.java, +import java.util.Collections;, +    public void testFilterInitialAllocation() {, +            Collections.singleton(filterAllocationDecider));, +        assertEquals(filterAllocationDecider.canAllocate(routingTable.index("idx").shard(0).shards().get(0),, +        assertEquals(filterAllocationDecider.canAllocate(routingTable.index("idx").shard(0).shards().get(0),, +        // after failing the shard we are unassigned since the node is blacklisted and we can't initialize on the other node, +        assertEquals(routingTable.index("idx").shard(0).shards().get(0).state(), INITIALIZING);, +        assertEquals(routingTable.index("idx").shard(0).shards().get(0).currentNodeId(), "node2");, +        state = service.applyStartedShards(state, routingTable.index("idx").shard(0).shards());, +        assertEquals(routingTable.index("idx").shard(0).shards().get(0).state(), STARTED);, +        assertEquals(routingTable.index("idx").shard(0).shards().get(0).currentNodeId(), "node2");, +        MetaData.Builder metaBuilder = MetaData.builder();, +        metaBuilder.put(IndexMetaData.builder("idx").settings(settings(Version.CURRENT).put(settings)), +            .numberOfShards(1).numberOfReplicas(0));, +        MetaData metaData = metaBuilder.build();, +        routingTableBuilder.addAsNew(metaData.index("idx"));, +        routingTable = service.reroute(clusterState, "reroute", false).routingTable();, +        clusterState = ClusterState.builder(clusterState).routingTable(routingTable).build();, +        return clusterState;, +++ b/core/src/main/java/org/elasticsearch/client/transport/support/TransportProxyClient.java, +import java.util.Collections;, +++ b/core/src/main/java/org/elasticsearch/cluster/routing/RecoverySource.java, +++ b/core/src/main/java/org/elasticsearch/cluster/routing/allocation/decider/FilterAllocationDecider.java, +            if (shardRouting.recoverySource().getType() != RecoverySource.Type.EXISTING_STORE &&, +                initialRecoveryFilters != null &&, +++ b/core/src/test/java/org/elasticsearch/action/admin/indices/create/CreateIndexIT.java, +            .setSettings(Settings.builder().put("index.number_of_replicas", 0).build()).get());, +++ b/core/src/test/java/org/elasticsearch/cluster/routing/allocation/FilterAllocationDeciderTests.java, +import java.util.Collections;, +    public void testFilterInitialAllocation() {, +            Collections.singleton(filterAllocationDecider));, +        assertEquals(filterAllocationDecider.canAllocate(routingTable.index("idx").shard(0).shards().get(0),, +        assertEquals(filterAllocationDecider.canAllocate(routingTable.index("idx").shard(0).shards().get(0),, +        // after failing the shard we are unassigned since the node is blacklisted and we can't initialize on the other node, +        assertEquals(routingTable.index("idx").shard(0).shards().get(0).state(), INITIALIZING);, +        assertEquals(routingTable.index("idx").shard(0).shards().get(0).currentNodeId(), "node2");, +        state = service.applyStartedShards(state, routingTable.index("idx").shard(0).shards());, +        assertEquals(routingTable.index("idx").shard(0).shards().get(0).state(), STARTED);, +        assertEquals(routingTable.index("idx").shard(0).shards().get(0).currentNodeId(), "node2");, +        MetaData.Builder metaBuilder = MetaData.builder();, +        metaBuilder.put(IndexMetaData.builder("idx").settings(settings(Version.CURRENT).put(settings)), +            .numberOfShards(1).numberOfReplicas(0));, +        MetaData metaData = metaBuilder.build();, +        routingTableBuilder.addAsNew(metaData.index("idx"));, +        routingTable = service.reroute(clusterState, "reroute", false).routingTable();, +        clusterState = ClusterState.builder(clusterState).routingTable(routingTable).build();, +        return clusterState;, +++ b/modules/rank-eval/build.gradle, +/*, + * Licensed to Elasticsearch under one or more contributor, + * license agreements. See the NOTICE file distributed with, + * this work for additional information regarding copyright, + * ownership. Elasticsearch licenses this file to you under, + * the Apache License, Version 2.0 (the "License"); you may, + * not use this file except in compliance with the License., + * You may obtain a copy of the License at, + *, + *    http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing,, + * software distributed under the License is distributed on an, + * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY, + * KIND, either express or implied.  See the License for the, + * specific language governing permissions and limitations, + * under the License., + */, +, +esplugin {, +  description 'The Rank Eval module adds APIs to evaluate ranking quality.', +  classname 'org.elasticsearch.index.rankeval.RankEvalPlugin', +}, +]