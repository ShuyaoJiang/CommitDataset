[+++ b/plugins/repository-azure/src/main/java/org/elasticsearch/repositories/azure/AzureRepositoryPlugin.java, +        this.azureStoreService = new AzureStorageService(settings);, +++ b/plugins/repository-azure/src/main/java/org/elasticsearch/repositories/azure/AzureRepositoryPlugin.java, +        this.azureStoreService = new AzureStorageService(settings);, +++ b/plugins/repository-azure/src/main/java/org/elasticsearch/repositories/azure/AzureStorageService.java, +import com.microsoft.azure.storage.AccessCondition;, +import com.microsoft.azure.storage.CloudStorageAccount;, +import com.microsoft.azure.storage.RetryExponentialRetry;, +import com.microsoft.azure.storage.RetryPolicy;, +import com.microsoft.azure.storage.StorageErrorCodeStrings;, +import com.microsoft.azure.storage.blob.BlobInputStream;, +import com.microsoft.azure.storage.blob.BlobListingDetails;, +import com.microsoft.azure.storage.blob.BlobProperties;, +import com.microsoft.azure.storage.blob.CloudBlobContainer;, +import com.microsoft.azure.storage.blob.CloudBlockBlob;, +import com.microsoft.azure.storage.blob.DeleteSnapshotsOption;, +import com.microsoft.azure.storage.blob.ListBlobItem;, +import org.apache.logging.log4j.message.ParameterizedMessage;, +import org.elasticsearch.common.blobstore.support.PlainBlobMetaData;, +import org.elasticsearch.common.collect.MapBuilder;, +import org.elasticsearch.common.component.AbstractComponent;, +import org.elasticsearch.common.settings.Settings;, +import org.elasticsearch.common.settings.SettingsException;, +import java.net.HttpURLConnection;, +import java.net.URI;, +import java.security.InvalidKeyException;, +import java.util.EnumSet;, +import static java.util.Collections.emptyMap;, +, +public class AzureStorageService extends AbstractComponent {, +, +    public static final ByteSizeValue MIN_CHUNK_SIZE = new ByteSizeValue(1, ByteSizeUnit.BYTES);, +    public static final ByteSizeValue MAX_CHUNK_SIZE = new ByteSizeValue(64, ByteSizeUnit.MB);, +, +    // 'package' for testing, +    volatile Map<String, AzureStorageSettings> storageSettings = emptyMap();, +, +    public AzureStorageService(Settings settings) {, +        super(settings);, +        // eagerly load client settings so that secure settings are read, +        final Map<String, AzureStorageSettings> clientsSettings = AzureStorageSettings.load(settings);, +        refreshAndClearCache(clientsSettings);, +    }, +    public Tuple<CloudBlobClient, Supplier<OperationContext>> client(String clientName) {, +        final AzureStorageSettings azureStorageSettings = this.storageSettings.get(clientName);, +        if (azureStorageSettings == null) {, +            throw new SettingsException("Unable to find client with name [" + clientName + "]");, +        }, +        try {, +            return new Tuple<>(buildClient(azureStorageSettings), () -> buildOperationContext(azureStorageSettings));, +        } catch (InvalidKeyException | URISyntaxException | IllegalArgumentException e) {, +            throw new SettingsException("Invalid azure client settings with name [" + clientName + "]", e);, +        }, +    }, +, +    protected CloudBlobClient buildClient(AzureStorageSettings azureStorageSettings) throws InvalidKeyException, URISyntaxException {, +        final CloudBlobClient client = createClient(azureStorageSettings);, +        // Set timeout option if the user sets cloud.azure.storage.timeout or, +        // cloud.azure.storage.xxx.timeout (it's negative by default), +        final long timeout = azureStorageSettings.getTimeout().getMillis();, +        if (timeout > 0) {, +            if (timeout > Integer.MAX_VALUE) {, +                throw new IllegalArgumentException("Timeout [" + azureStorageSettings.getTimeout() + "] exceeds 2,147,483,647ms.");, +            }, +            client.getDefaultRequestOptions().setTimeoutIntervalInMs((int) timeout);, +        }, +        // We define a default exponential retry policy, +        client.getDefaultRequestOptions(), +                .setRetryPolicyFactory(new RetryExponentialRetry(RetryPolicy.DEFAULT_CLIENT_BACKOFF, azureStorageSettings.getMaxRetries()));, +        client.getDefaultRequestOptions().setLocationMode(azureStorageSettings.getLocationMode());, +        return client;, +    }, +, +    protected CloudBlobClient createClient(AzureStorageSettings azureStorageSettings) throws InvalidKeyException, URISyntaxException {, +        final String connectionString = azureStorageSettings.buildConnectionString();, +        return CloudStorageAccount.parse(connectionString).createCloudBlobClient();, +    }, +, +    protected OperationContext buildOperationContext(AzureStorageSettings azureStorageSettings) {, +        final OperationContext context = new OperationContext();, +        context.setProxy(azureStorageSettings.getProxy());, +        return context;, +    }, +    public Map<String, AzureStorageSettings> refreshAndClearCache(Map<String, AzureStorageSettings> clientsSettings) {, +        final Map<String, AzureStorageSettings> prevSettings = this.storageSettings;, +        this.storageSettings = MapBuilder.newMapBuilder(clientsSettings).immutableMap();, +        // clients are built lazily by {@link client(String)}, +        return prevSettings;, +    }, +    public boolean doesContainerExist(String account, String container) throws URISyntaxException, StorageException {, +        final Tuple<CloudBlobClient, Supplier<OperationContext>> client = client(account);, +        final CloudBlobContainer blobContainer = client.v1().getContainerReference(container);, +        return SocketAccess.doPrivilegedException(() -> blobContainer.exists(null, null, client.v2().get()));, +    }, +    public void deleteFiles(String account, String container, String path) throws URISyntaxException, StorageException {, +        final Tuple<CloudBlobClient, Supplier<OperationContext>> client = client(account);, +        // container name must be lower case., +        logger.trace(() -> new ParameterizedMessage("delete files container [{}], path [{}]", container, path));, +        SocketAccess.doPrivilegedVoidException(() -> {, +            // list the blobs using a flat blob listing mode]