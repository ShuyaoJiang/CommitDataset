[+++ b/src/main/java/org/elasticsearch/gateway/AsyncShardFetch.java, +    protected AsyncShardFetch(ESLogger logger, ShardId shardId, List<? extends NodesOperationResponse<T>, T> action) {, +                reroute(shardId, "at_least_one_node_failed");, +                        logger.warn("{}: failed to list shard for {} on node [{}]", failure, shardId, getClass().getSimpleName(), failure.nodeId());, +++ b/src/main/java/org/elasticsearch/gateway/AsyncShardFetch.java, +    protected AsyncShardFetch(ESLogger logger, ShardId shardId, List<? extends NodesOperationResponse<T>, T> action) {, +                reroute(shardId, "at_least_one_node_failed");, +                        logger.warn("{}: failed to list shard for {} on node [{}]", failure, shardId, getClass().getSimpleName(), failure.nodeId());, +++ b/src/main/java/org/elasticsearch/gateway/GatewayAllocator.java, +                fetch = new InternalAsyncFetch<>(logger, shard.shardId(), startedAction, clusterService, allocationService);, +                // still fetching data, remove from the unassigned, and try the next, +                // still fetching data, remove from the unassigned, and try the next, +                fetch = new InternalAsyncFetch<>(logger, shard.shardId(), storeAction, clusterService, allocationService);, +                // still fetching data, remove from the unassigned, and try the next, +        public InternalAsyncFetch(ESLogger logger, ShardId shardId, List<? extends NodesOperationResponse<T>, T> action,, +            super(logger, shardId, action);, +            clusterService.submitStateUpdateTask("async_shard_fetch(" + getClass().getSimpleName() + ") " + shardId + ", reasons (" + reason + ")", Priority.HIGH, new ClusterStateUpdateTask() {, +++ b/src/main/java/org/elasticsearch/gateway/AsyncShardFetch.java, +    protected AsyncShardFetch(ESLogger logger, ShardId shardId, List<? extends NodesOperationResponse<T>, T> action) {, +                reroute(shardId, "at_least_one_node_failed");, +                        logger.warn("{}: failed to list shard for {} on node [{}]", failure, shardId, getClass().getSimpleName(), failure.nodeId());, +++ b/src/main/java/org/elasticsearch/gateway/GatewayAllocator.java, +                fetch = new InternalAsyncFetch<>(logger, shard.shardId(), startedAction, clusterService, allocationService);, +                // still fetching data, remove from the unassigned, and try the next, +                // still fetching data, remove from the unassigned, and try the next, +                fetch = new InternalAsyncFetch<>(logger, shard.shardId(), storeAction, clusterService, allocationService);, +                // still fetching data, remove from the unassigned, and try the next, +        public InternalAsyncFetch(ESLogger logger, ShardId shardId, List<? extends NodesOperationResponse<T>, T> action,, +            super(logger, shardId, action);, +            clusterService.submitStateUpdateTask("async_shard_fetch(" + getClass().getSimpleName() + ") " + shardId + ", reasons (" + reason + ")", Priority.HIGH, new ClusterStateUpdateTask() {, +++ b/src/main/java/org/elasticsearch/index/query/AndQueryBuilder.java, +, +    public static final String NAME = "and";, +, +        builder.startObject(NAME);, +, +    @Override, +    public String queryId() {, +        return NAME;, +    }, +++ b/src/main/java/org/elasticsearch/gateway/AsyncShardFetch.java, +    protected AsyncShardFetch(ESLogger logger, ShardId shardId, List<? extends NodesOperationResponse<T>, T> action) {, +                reroute(shardId, "at_least_one_node_failed");, +                        logger.warn("{}: failed to list shard for {} on node [{}]", failure, shardId, getClass().getSimpleName(), failure.nodeId());, +++ b/src/main/java/org/elasticsearch/gateway/GatewayAllocator.java, +                fetch = new InternalAsyncFetch<>(logger, shard.shardId(), startedAction, clusterService, allocationService);, +                // still fetching data, remove from the unassigned, and try the next, +                // still fetching data, remove from the unassigned, and try the next, +                fetch = new InternalAsyncFetch<>(logger, shard.shardId(), storeAction, clusterService, allocationService);, +                // still fetching data, remove from the unassigned, and try the next, +        public InternalAsyncFetch(ESLogger logger, ShardId shardId, List<? extends NodesOperationResponse<T>, T> action,, +            super(logger, shardId, action);, +            clusterService.submitStateUpdateTask("async_shard_fetch(" + getClass().getSimpleName() + ") " + shardId + ", reasons (" + reason + ")", Priority.HIGH, new ClusterStateUpdateTask() {, +++ b/src/main/java/org/elasticsearch/index/query/AndQueryBuilder.java, +, +    public static final String NAME = "and";, +, +        builder.startObject(NAME);, +, +    @Override, +    public String queryId() {, +        return NAME;, +    }, +++ b/src/main/java/org/elasticsearch/index/query/AndQueryParser.java, +public class AndQueryParser extends BaseQueryParserTemp {, +        return new String[]{AndQueryBuilder.NAME};, +++ b/src/main/java/org/elasticsearch/gateway/AsyncShardFetch.java, +    protected AsyncShardFetch(ESLogger logger, ShardId shardId, List<? extends NodesOperationResponse<T>, T> action) {, +                reroute(shardId, "at_least_one_node_failed");, +                        logger.warn("{}: failed to list shard for {} on node [{}]", failure, shardId, getClass().getSimpleName(), failure.nodeId());, +++ b/src/main/java/org/elasticsearch/gateway/GatewayAllocator.java, +                fetch = new InternalAsyncFetch<>(logger, shard.shardId(), startedAction, clusterService, allocationService);, +                // still fetching data, remove from the unassigned, and try the next, +                // still fetching data, remove from the unassigned, and try the next, +                fetch = new InternalAsyncFetch<>(logger, shard.shardId(), storeAction, clusterService, allocationService);, +                // still fetching data, remove from the unassigned, and try the next, +        public InternalAsyncFetch(ESLogger logger, ShardId shardId, List<? extends NodesOperationResponse<T>, T> action,, +            super(logger, shardId, action);, +            clusterService.submitStateUpdateTask("async_shard_fetch(" + getClass().getSimpleName() + ") " + shardId + ", reasons (" + reason + ")", Priority.HIGH, new ClusterStateUpdateTask() {, +++ b/src/main/java/org/elasticsearch/index/query/AndQueryBuilder.java, +, +    public static final String NAME = "and";, +, +        builder.startObject(NAME);, +, +    @Override, +    public String queryId() {, +        return NAME;, +    }, +++ b/src/main/java/org/elasticsearch/index/query/AndQueryParser.java, +public class AndQueryParser extends BaseQueryParserTemp {, +        return new String[]{AndQueryBuilder.NAME};, +++ b/src/main/java/org/elasticsearch/index/query/BaseQueryParser.java, +/*, + * Licensed to Elasticsearch under one or more contributor, + * license agreements. See the NOTICE file distributed with, + * this work for additional information regarding copyright, + * ownership. Elasticsearch licenses this file to you under, + * the Apache License, Version 2.0 (the "License"); you may, + * not use this file except in compliance with the License.]