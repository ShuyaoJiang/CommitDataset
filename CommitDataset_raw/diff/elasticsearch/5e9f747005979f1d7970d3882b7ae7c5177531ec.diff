[+++ b/src/main/java/org/elasticsearch/watcher/execution/ExecutionService.java, +            logger.debug("failed to execute triggered watch [{}]", watchRecord.watchId());, +            watchRecord.update(WatchRecord.State.FAILED, "failed to run triggered watch [" + watchRecord.watchId() + "] due to thread pool capacity");, +            Watch watch = watchStore.get(record.watchId());, +                String message = "unable to find watch for record [" + record.watchId() + "]/[" + record.id() + "], perhaps it has been deleted, ignoring...";, +                logger.debug("checking watch [{}]", watchRecord.watchId());, +                    logger.warn("failed to execute watch [{}]/[{}], failure [{}]", watchRecord.watchId(), ctx.id(), detailedMessage);, +                        logger.error("failed to update watch record [{}]/[{}], failure [{}], original failure [{}]", watchRecord.watchId(), ctx.id(), ExceptionsHelper.detailedMessage(e2), detailedMessage);, +++ b/src/main/java/org/elasticsearch/watcher/execution/ExecutionService.java, +            logger.debug("failed to execute triggered watch [{}]", watchRecord.watchId());, +            watchRecord.update(WatchRecord.State.FAILED, "failed to run triggered watch [" + watchRecord.watchId() + "] due to thread pool capacity");, +            Watch watch = watchStore.get(record.watchId());, +                String message = "unable to find watch for record [" + record.watchId() + "]/[" + record.id() + "], perhaps it has been deleted, ignoring...";, +                logger.debug("checking watch [{}]", watchRecord.watchId());, +                    logger.warn("failed to execute watch [{}]/[{}], failure [{}]", watchRecord.watchId(), ctx.id(), detailedMessage);, +                        logger.error("failed to update watch record [{}]/[{}], failure [{}], original failure [{}]", watchRecord.watchId(), ctx.id(), ExceptionsHelper.detailedMessage(e2), detailedMessage);, +++ b/src/main/java/org/elasticsearch/watcher/history/WatchRecord.java, +    private String watchId;, +        this.watchId = watch.id();, +    public String watchId() {, +        return watchId;, +        builder.field(Parser.WATCH_ID_FIELD.getPreferredName(), watchId);, +                        record.watchId = parser.text();, +            assert record.id() != null : "watch record [" + id +"] is missing watch_id";, +++ b/src/main/java/org/elasticsearch/watcher/execution/ExecutionService.java, +            logger.debug("failed to execute triggered watch [{}]", watchRecord.watchId());, +            watchRecord.update(WatchRecord.State.FAILED, "failed to run triggered watch [" + watchRecord.watchId() + "] due to thread pool capacity");, +            Watch watch = watchStore.get(record.watchId());, +                String message = "unable to find watch for record [" + record.watchId() + "]/[" + record.id() + "], perhaps it has been deleted, ignoring...";, +                logger.debug("checking watch [{}]", watchRecord.watchId());, +                    logger.warn("failed to execute watch [{}]/[{}], failure [{}]", watchRecord.watchId(), ctx.id(), detailedMessage);, +                        logger.error("failed to update watch record [{}]/[{}], failure [{}], original failure [{}]", watchRecord.watchId(), ctx.id(), ExceptionsHelper.detailedMessage(e2), detailedMessage);, +++ b/src/main/java/org/elasticsearch/watcher/history/WatchRecord.java, +    private String watchId;, +        this.watchId = watch.id();, +    public String watchId() {, +        return watchId;, +        builder.field(Parser.WATCH_ID_FIELD.getPreferredName(), watchId);, +                        record.watchId = parser.text();, +            assert record.id() != null : "watch record [" + id +"] is missing watch_id";, +++ b/src/main/java/org/elasticsearch/watcher/support/http/HttpRequestTemplate.java, +import org.elasticsearch.common.bytes.BytesArray;, +import org.elasticsearch.common.netty.handler.codec.http.HttpHeaders;, +import org.elasticsearch.common.xcontent.*;, +    private final XContentType xContentType;, +                               Template body, XContentType xContentType) {, +        this.xContentType = xContentType;, +        if ((headers == null || headers.isEmpty()) && xContentType != null) {, +            request.setHeaders(ImmutableMap.of(HttpHeaders.Names.CONTENT_TYPE, xContentType.restContentType()));, +        } else if (headers != null && !headers.isEmpty()) {, +            if (xContentType != null) {, +                // putting the content type first, so it can be overridden by custom headers, +                mapBuilder.put(HttpHeaders.Names.CONTENT_TYPE, xContentType.restContentType());, +            }, +            if (xContentType != null) {, +                builder.rawField(Parser.XBODY_FIELD.getPreferredName(), new BytesArray(body.getTemplate()));, +            } else {, +        }, +        if (scheme != that.scheme) return false;, +        if (params != null ? !params.equals(that.params) : that.params != null) return false;, +        if (headers != null ? !headers.equals(that.headers) : that.headers != null) return false;, +        if (auth != null ? !auth.equals(that.auth) : that.auth != null) return false;, +        if (body != null ? !body.equals(that.body) : that.body != null) return false;, +        return xContentType == that.xContentType;, +        int result = scheme != null ? scheme.hashCode() : 0;, +        result = 31 * result + (host != null ? host.hashCode() : 0);, +        result = 31 * result + (xContentType != null ? xContentType.hashCode() : 0);, +        public static final ParseField XBODY_FIELD = new ParseField("xbody");, +            boolean seenBody = false;, +            boolean seenXBody = false;, +                    if (seenXBody) {, +                        throw new ParseException("could not parse http request template. both [{}] and [{}] are set, only one of the two is allowed", XBODY_FIELD.getPreferredName(), BODY_FIELD.getPreferredName());, +                    }, +                    seenBody = true;, +                } else if (XBODY_FIELD.match(currentFieldName)) {, +                    if (seenBody) {, +                        throw new ParseException("could not parse http request template. both [{}] and [{}] are set, only one of the two is allowed", XBODY_FIELD.getPreferredName(), BODY_FIELD.getPreferredName());, +                    }, +                    seenXBody = true;, +                    XContentBuilder contentBuilder = XContentBuilder.builder(parser.contentType().xContent());, +                    XContentHelper.copyCurrentStructure(contentBuilder.generator(), parser);, +                    builder.body(contentBuilder);, +                        throw new ParseException("could not parse http request template. unexpected object field [{}]", currentFieldName);, +                        throw new ParseException("could not parse http request template. unexpected string field [{}]", currentFieldName);, +                        throw new ParseException("could not parse http request template. unexpected numeric field [{}]", currentFieldName);, +                    throw new ParseException("could not parse http request template. unexpected token [{}] for field [{}]", token, currentFieldName);, +                throw new ParseException("could not parse http request template. missing required [{}] string field", HOST_FIELD.getPreferredName());, +                throw new ParseException("could not parse http request template. missing required [{}] numeric field", PORT_FIELD.getPreferredName());, +                throw new ParseException("could not parse http request template. could not parse value for [{}] field", pe, field);, +        public ParseException(String msg, Object... args) {, +            super(msg, args);, +        public ParseException(String msg, Throwable cause, Object... args) {, +            super(msg, cause, args);, +        private XContentType xContentType;, +            return body(body, null);, +            return body(body, null);, +        }, +, +        public Builder body(String body, XContentType xContentType) {, +            return body(new Template(body), xContentType);]