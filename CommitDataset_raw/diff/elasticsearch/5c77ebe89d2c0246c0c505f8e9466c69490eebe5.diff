[+++ b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ml/calendars/ScheduledEvent.java, +        builder.setActions(RuleAction.SKIP_RESULT, RuleAction.SKIP_MODEL_UPDATE);, +++ b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ml/calendars/ScheduledEvent.java, +        builder.setActions(RuleAction.SKIP_RESULT, RuleAction.SKIP_MODEL_UPDATE);, +++ /dev/null, +++ b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ml/calendars/ScheduledEvent.java, +        builder.setActions(RuleAction.SKIP_RESULT, RuleAction.SKIP_MODEL_UPDATE);, +++ /dev/null, +++ /dev/null, +++ b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ml/calendars/ScheduledEvent.java, +        builder.setActions(RuleAction.SKIP_RESULT, RuleAction.SKIP_MODEL_UPDATE);, +++ /dev/null, +++ /dev/null, +++ b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ml/job/config/DetectionRule.java, +    public static final Version VERSION_INTRODUCED = Version.V_6_4_0;, +, +    public static final ParseField ACTIONS_FIELD = new ParseField("actions");, +    public static final ParseField SCOPE_FIELD = new ParseField("scope");, +    public static final ParseField CONDITIONS_FIELD = new ParseField("conditions");, +            parser.declareObject(Builder::setScope, RuleScope.parser(parserType), SCOPE_FIELD);, +    private final RuleScope scope;, +    private DetectionRule(EnumSet<RuleAction> actions, RuleScope scope, List<RuleCondition> conditions) {, +        this.scope = Objects.requireNonNull(scope);, +        actions = in.readEnumSet(RuleAction.class);, +        scope = new RuleScope(in);, +        conditions = in.readList(RuleCondition::new);, +        out.writeEnumSet(actions);, +        scope.writeTo(out);, +        out.writeList(conditions);, +        if (scope.isEmpty() == false) {, +            builder.field(SCOPE_FIELD.getPreferredName(), scope);, +        if (conditions.isEmpty() == false) {, +            builder.field(CONDITIONS_FIELD.getPreferredName(), conditions);, +    public RuleScope getScope() {, +        return scope;, +        return scope.getReferencedFilters();, +                && Objects.equals(scope, other.scope), +        return Objects.hash(actions, scope, conditions);, +        private EnumSet<RuleAction> actions = EnumSet.of(RuleAction.SKIP_RESULT);, +        private RuleScope scope = new RuleScope();, +        public Builder(RuleScope.Builder scope) {, +            this.scope = scope.build();, +        }, +, +        Builder() {, +        public Builder setScope(RuleScope scope) {, +            this.scope = Objects.requireNonNull(scope);, +            if (scope.isEmpty() && conditions.isEmpty()) {, +                String msg = Messages.getMessage(Messages.JOB_CONFIG_DETECTION_RULE_REQUIRES_SCOPE_OR_CONDITION);, +            return new DetectionRule(actions, scope, conditions);, +++ b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ml/calendars/ScheduledEvent.java, +        builder.setActions(RuleAction.SKIP_RESULT, RuleAction.SKIP_MODEL_UPDATE);, +++ /dev/null, +++ /dev/null, +++ b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ml/job/config/DetectionRule.java, +    public static final Version VERSION_INTRODUCED = Version.V_6_4_0;, +, +    public static final ParseField ACTIONS_FIELD = new ParseField("actions");, +    public static final ParseField SCOPE_FIELD = new ParseField("scope");, +    public static final ParseField CONDITIONS_FIELD = new ParseField("conditions");, +            parser.declareObject(Builder::setScope, RuleScope.parser(parserType), SCOPE_FIELD);, +    private final RuleScope scope;, +    private DetectionRule(EnumSet<RuleAction> actions, RuleScope scope, List<RuleCondition> conditions) {, +        this.scope = Objects.requireNonNull(scope);, +        actions = in.readEnumSet(RuleAction.class);, +        scope = new RuleScope(in);, +        conditions = in.readList(RuleCondition::new);, +        out.writeEnumSet(actions);, +        scope.writeTo(out);, +        out.writeList(conditions);, +        if (scope.isEmpty() == false) {, +            builder.field(SCOPE_FIELD.getPreferredName(), scope);, +        if (conditions.isEmpty() == false) {, +            builder.field(CONDITIONS_FIELD.getPreferredName(), conditions);, +    public RuleScope getScope() {, +        return scope;, +        return scope.getReferencedFilters();, +                && Objects.equals(scope, other.scope), +        return Objects.hash(actions, scope, conditions);, +        private EnumSet<RuleAction> actions = EnumSet.of(RuleAction.SKIP_RESULT);, +        private RuleScope scope = new RuleScope();, +        public Builder(RuleScope.Builder scope) {, +            this.scope = scope.build();, +        }, +, +        Builder() {, +        public Builder setScope(RuleScope scope) {, +            this.scope = Objects.requireNonNull(scope);, +            if (scope.isEmpty() && conditions.isEmpty()) {, +                String msg = Messages.getMessage(Messages.JOB_CONFIG_DETECTION_RULE_REQUIRES_SCOPE_OR_CONDITION);, +            return new DetectionRule(actions, scope, conditions);, +++ b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ml/job/config/Detector.java, +import java.util.TreeSet;, +    public static final ParseField CUSTOM_RULES_FIELD = new ParseField("custom_rules");, +                    DetectionRule.PARSERS.get(parserType).apply(p, c).build(), CUSTOM_RULES_FIELD);, +     * Functions that do not support rule conditions:, +     * <ul>, +     * <li>lat_long - because it is a multivariate feature, +     * <li>metric - because having the same conditions on min,max,mean is, +     * error-prone]