[+++ b/core/src/main/java/org/elasticsearch/search/aggregations/support/MissingValues.java, +        final boolean missingIsFloat = missing.doubleValue() % 1 != 0;, +++ b/core/src/main/java/org/elasticsearch/search/aggregations/support/MissingValues.java, +        final boolean missingIsFloat = missing.doubleValue() % 1 != 0;, +++ b/core/src/main/java/org/elasticsearch/search/aggregations/support/ValuesSourceParserHelper.java, +, +        if (formattable) {, +            objectParser.declareField(ValuesSourceAggregationBuilder::format, XContentParser::text,, +                    new ParseField("format"), ObjectParser.ValueType.STRING);, +        }, +, +        if (scriptable) {, +            objectParser.declareField(ValuesSourceAggregationBuilder::script, org.elasticsearch.script.Script::parse,, +                    Script.SCRIPT_PARSE_FIELD, ObjectParser.ValueType.OBJECT_OR_STRING);, +++ b/core/src/main/java/org/elasticsearch/search/aggregations/support/MissingValues.java, +        final boolean missingIsFloat = missing.doubleValue() % 1 != 0;, +++ b/core/src/main/java/org/elasticsearch/search/aggregations/support/ValuesSourceParserHelper.java, +, +        if (formattable) {, +            objectParser.declareField(ValuesSourceAggregationBuilder::format, XContentParser::text,, +                    new ParseField("format"), ObjectParser.ValueType.STRING);, +        }, +, +        if (scriptable) {, +            objectParser.declareField(ValuesSourceAggregationBuilder::script, org.elasticsearch.script.Script::parse,, +                    Script.SCRIPT_PARSE_FIELD, ObjectParser.ValueType.OBJECT_OR_STRING);, +++ b/core/src/test/java/org/elasticsearch/search/aggregations/support/MissingValuesTests.java, +, +    public void testFloatingPointDetection() {, +        assertFalse(MissingValues.replaceMissing(ValuesSource.Numeric.EMPTY, 3).isFloatingPoint());, +        assertTrue(MissingValues.replaceMissing(ValuesSource.Numeric.EMPTY, 3.5).isFloatingPoint());, +    }, +++ b/core/src/main/java/org/elasticsearch/search/aggregations/support/MissingValues.java, +        final boolean missingIsFloat = missing.doubleValue() % 1 != 0;, +++ b/core/src/main/java/org/elasticsearch/search/aggregations/support/ValuesSourceParserHelper.java, +, +        if (formattable) {, +            objectParser.declareField(ValuesSourceAggregationBuilder::format, XContentParser::text,, +                    new ParseField("format"), ObjectParser.ValueType.STRING);, +        }, +, +        if (scriptable) {, +            objectParser.declareField(ValuesSourceAggregationBuilder::script, org.elasticsearch.script.Script::parse,, +                    Script.SCRIPT_PARSE_FIELD, ObjectParser.ValueType.OBJECT_OR_STRING);, +++ b/core/src/test/java/org/elasticsearch/search/aggregations/support/MissingValuesTests.java, +, +    public void testFloatingPointDetection() {, +        assertFalse(MissingValues.replaceMissing(ValuesSource.Numeric.EMPTY, 3).isFloatingPoint());, +        assertTrue(MissingValues.replaceMissing(ValuesSource.Numeric.EMPTY, 3.5).isFloatingPoint());, +    }, +++ b/docs/reference/aggregations.asciidoc, +Elasticsearch uses the type of the field in the mapping in order to figure out, +how to run the aggregation and format the response. However there are two cases, +in which Elasticsearch cannot figure out this information: unmapped fields (for, +instance in the case of a search request across multiple indices, and only some, +of them have a mapping for the field) and pure scripts. For those cases, it is, +possible to give Elasticsearch a hint using the `value_type` option, which, +accepts the following values: `string`, `long` (works for all integer types),, +`double` (works for all decimal types like `float` or `scaled_float`), `date`,, +`ip` and `boolean`., +++ b/core/src/main/java/org/elasticsearch/search/aggregations/support/MissingValues.java, +        final boolean missingIsFloat = missing.doubleValue() % 1 != 0;, +++ b/core/src/main/java/org/elasticsearch/search/aggregations/support/ValuesSourceParserHelper.java, +, +        if (formattable) {, +            objectParser.declareField(ValuesSourceAggregationBuilder::format, XContentParser::text,, +                    new ParseField("format"), ObjectParser.ValueType.STRING);, +        }, +, +        if (scriptable) {, +            objectParser.declareField(ValuesSourceAggregationBuilder::script, org.elasticsearch.script.Script::parse,, +                    Script.SCRIPT_PARSE_FIELD, ObjectParser.ValueType.OBJECT_OR_STRING);, +++ b/core/src/test/java/org/elasticsearch/search/aggregations/support/MissingValuesTests.java, +, +    public void testFloatingPointDetection() {, +        assertFalse(MissingValues.replaceMissing(ValuesSource.Numeric.EMPTY, 3).isFloatingPoint());, +        assertTrue(MissingValues.replaceMissing(ValuesSource.Numeric.EMPTY, 3.5).isFloatingPoint());, +    }, +++ b/docs/reference/aggregations.asciidoc, +Elasticsearch uses the type of the field in the mapping in order to figure out, +how to run the aggregation and format the response. However there are two cases, +in which Elasticsearch cannot figure out this information: unmapped fields (for, +instance in the case of a search request across multiple indices, and only some, +of them have a mapping for the field) and pure scripts. For those cases, it is, +possible to give Elasticsearch a hint using the `value_type` option, which, +accepts the following values: `string`, `long` (works for all integer types),, +`double` (works for all decimal types like `float` or `scaled_float`), `date`,, +`ip` and `boolean`., +++ b/rest-api-spec/src/main/resources/rest-api-spec/test/search.aggregation/20_terms.yaml, +, +---, +"Unmapped strings":, +, +  - do:, +      index:, +        index: test_1, +        type: test, +        id: 1, +        body: {}, +]