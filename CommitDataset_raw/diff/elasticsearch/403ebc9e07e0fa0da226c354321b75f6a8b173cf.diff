[+++ b/src/main/java/org/elasticsearch/discovery/zen/ZenDiscovery.java, +import java.util.concurrent.atomic.AtomicInteger;, +    /** how many pings from *another* master to tolerate before forcing a rejoin on other or local master */, +    private final int maxPingsFromAnotherMaster;, +        this.maxPingsFromAnotherMaster = settings.getAsInt("discovery.zen.max_pings_from_another_master", 3);, +        this.nodesFD.addListener(new NodeFaultDetectionListener());, +        nodesFD.updateNodes(latestDiscoNodes, -1);, +        nodesFD.updateNodes(clusterState.nodes(), clusterState.version());, +                    return handleAnotherMaster(currentState, newState.nodes().masterNode(), newState.version(), "via a new cluster state");, +    private ClusterState handleAnotherMaster(ClusterState localClusterState, final DiscoveryNode otherMaster, long otherClusterStateVersion, String reason) {, +        assert master : "handleAnotherMaster called but current node is not a master";, +        if (otherClusterStateVersion > localClusterState.version()) {, +            return rejoin(localClusterState, "zen-disco-discovered another master with a new cluster_state [" + otherMaster + "][" + reason + "]");, +        } else {, +            logger.warn("discovered [{}] which is also master but with an older cluster_state, telling [{}] to rejoin the cluster ([{}])", otherMaster, otherMaster, reason);, +            try {, +                // make sure we're connected to this node (connect to node does nothing if we're already connected), +                // since the network connections are asymmetric, it may be that we received a state but have disconnected from the node, +                // in the past (after a master failure, for example), +                transportService.connectToNode(otherMaster);, +                transportService.sendRequest(otherMaster, DISCOVERY_REJOIN_ACTION_NAME, new RejoinClusterRequest(localClusterState.nodes().localNodeId()), new EmptyTransportResponseHandler(ThreadPool.Names.SAME) {, +, +                    @Override, +                    public void handleException(TransportException exp) {, +                        logger.warn("failed to send rejoin request to [{}]", exp, otherMaster);, +                    }, +                });, +            } catch (Exception e) {, +                logger.warn("failed to send rejoin request to [{}]", e, otherMaster);, +            }, +            return localClusterState;, +        }, +    }, +, +    private class NodeFaultDetectionListener extends NodesFaultDetection.Listener {, +, +        private final AtomicInteger pingsWhileMaster = new AtomicInteger(0);, +, +        @Override, +        public void onPingReceived(final NodesFaultDetection.PingRequest pingRequest) {, +            // if we are master, we don't expect any fault detection from another node. If we get it, +            // means we potentially have two masters in the cluster., +            if (!master) {, +                pingsWhileMaster.set(0);, +                return;, +            }, +, +            // nodes pre 1.4.0 do not send this information, +            if (pingRequest.masterNode() == null) {, +                return;, +            }, +, +            if (pingsWhileMaster.incrementAndGet() < maxPingsFromAnotherMaster) {, +                logger.trace("got a ping from another master {}. current ping count: [{}]", pingRequest.masterNode(), pingsWhileMaster.get());, +                return;, +            }, +            logger.debug("got a ping from another master {}. resolving who should rejoin. current ping count: [{}]", pingRequest.masterNode(), pingsWhileMaster.get());, +            clusterService.submitStateUpdateTask("ping from another master", Priority.URGENT, new ClusterStateUpdateTask() {, +, +                @Override, +                public ClusterState execute(ClusterState currentState) throws Exception {, +                    pingsWhileMaster.set(0);, +                    return handleAnotherMaster(currentState, pingRequest.masterNode(), pingRequest.clusterStateVersion(), "node fd ping");, +                }, +, +                @Override, +                public void onFailure(String source, Throwable t) {, +                    logger.debug("unexpected error during cluster state update task after pings from another master", t);, +                }, +            });, +        }, +++ b/src/main/java/org/elasticsearch/discovery/zen/ZenDiscovery.java, +import java.util.concurrent.atomic.AtomicInteger;, +    /** how many pings from *another* master to tolerate before forcing a rejoin on other or local master */, +    private final int maxPingsFromAnotherMaster;, +        this.maxPingsFromAnotherMaster = settings.getAsInt("discovery.zen.max_pings_from_another_master", 3);, +        this.nodesFD.addListener(new NodeFaultDetectionListener());, +        nodesFD.updateNodes(latestDiscoNodes, -1);, +        nodesFD.updateNodes(clusterState.nodes(), clusterState.version());, +                    return handleAnotherMaster(currentState, newState.nodes().masterNode(), newState.version(), "via a new cluster state");, +    private ClusterState handleAnotherMaster(ClusterState localClusterState, final DiscoveryNode otherMaster, long otherClusterStateVersion, String reason) {, +        assert master : "handleAnotherMaster called but current node is not a master";, +        if (otherClusterStateVersion > localClusterState.version()) {, +            return rejoin(localClusterState, "zen-disco-discovered another master with a new cluster_state [" + otherMaster + "][" + reason + "]");, +        } else {, +            logger.warn("discovered [{}] which is also master but with an older cluster_state, telling [{}] to rejoin the cluster ([{}])", otherMaster, otherMaster, reason);, +            try {, +                // make sure we're connected to this node (connect to node does nothing if we're already connected), +                // since the network connections are asymmetric, it may be that we received a state but have disconnected from the node, +                // in the past (after a master failure, for example), +                transportService.connectToNode(otherMaster);, +                transportService.sendRequest(otherMaster, DISCOVERY_REJOIN_ACTION_NAME, new RejoinClusterRequest(localClusterState.nodes().localNodeId()), new EmptyTransportResponseHandler(ThreadPool.Names.SAME) {, +, +                    @Override, +                    public void handleException(TransportException exp) {, +                        logger.warn("failed to send rejoin request to [{}]", exp, otherMaster);, +                    }, +                });, +            } catch (Exception e) {, +                logger.warn("failed to send rejoin request to [{}]", e, otherMaster);]