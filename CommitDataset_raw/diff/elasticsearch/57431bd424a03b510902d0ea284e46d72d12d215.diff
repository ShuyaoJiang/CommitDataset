[+++ b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/SecurityFeatureSetUsage.java, +        } else if (sslUsage.isEmpty() == false) {, +            // A trial (or basic) license can have SSL without security., +            // This is because security defaults to disabled on that license, but that dynamic-default does not disable SSL., +            builder.field(SSL_XFIELD, sslUsage);, +++ b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/SecurityFeatureSetUsage.java, +        } else if (sslUsage.isEmpty() == false) {, +            // A trial (or basic) license can have SSL without security., +            // This is because security defaults to disabled on that license, but that dynamic-default does not disable SSL., +            builder.field(SSL_XFIELD, sslUsage);, +++ b/x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/SecurityFeatureSet.java, +        // If security has been explicitly disabled in the settings, then SSL is also explicitly disabled, and we don't want to report, +        //  these http/transport settings as they would be misleading (they could report `true` even though they were ignored), +        // But, if security has not been explicitly configured, but has defaulted to off due to the current license type,, +        // then these SSL settings are still respected (that is SSL might be enabled, while the rest of security is disabled)., +        if (XPackSettings.SECURITY_ENABLED.get(settings)) {, +        } else {, +            return Collections.emptyMap();, +        }, +++ b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/SecurityFeatureSetUsage.java, +        } else if (sslUsage.isEmpty() == false) {, +            // A trial (or basic) license can have SSL without security., +            // This is because security defaults to disabled on that license, but that dynamic-default does not disable SSL., +            builder.field(SSL_XFIELD, sslUsage);, +++ b/x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/SecurityFeatureSet.java, +        // If security has been explicitly disabled in the settings, then SSL is also explicitly disabled, and we don't want to report, +        //  these http/transport settings as they would be misleading (they could report `true` even though they were ignored), +        // But, if security has not been explicitly configured, but has defaulted to off due to the current license type,, +        // then these SSL settings are still respected (that is SSL might be enabled, while the rest of security is disabled)., +        if (XPackSettings.SECURITY_ENABLED.get(settings)) {, +        } else {, +            return Collections.emptyMap();, +        }, +++ b/x-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/SecurityFeatureSetTests.java, +import java.io.IOException;, +        configureRoleStoreUsage(rolesStoreEnabled);, +        configureRoleMappingStoreUsage(roleMappingStoreEnabled);, +        configureRealmsUsage(realmsUsageStats);, +            XContentSource source = getXContentSource(usage);, +, +    public void testUsageOnTrialLicenseWithSecurityDisabledByDefault() throws Exception {, +        when(licenseState.isSecurityAvailable()).thenReturn(true);, +        when(licenseState.isSecurityDisabledByTrialLicense()).thenReturn(true);, +, +        Settings.Builder settings = Settings.builder().put(this.settings);, +, +        final boolean httpSSLEnabled = randomBoolean();, +        settings.put("xpack.security.http.ssl.enabled", httpSSLEnabled);, +        final boolean transportSSLEnabled = randomBoolean();, +        settings.put("xpack.security.transport.ssl.enabled", transportSSLEnabled);, +, +        final boolean auditingEnabled = randomBoolean();, +        settings.put(XPackSettings.AUDIT_ENABLED.getKey(), auditingEnabled);, +, +        final boolean rolesStoreEnabled = randomBoolean();, +        configureRoleStoreUsage(rolesStoreEnabled);, +, +        final boolean roleMappingStoreEnabled = randomBoolean();, +        configureRoleMappingStoreUsage(roleMappingStoreEnabled);, +, +        configureRealmsUsage(Collections.emptyMap());, +, +        SecurityFeatureSet featureSet = new SecurityFeatureSet(settings.build(), licenseState,, +                realms, rolesStore, roleMappingStore, ipFilter);, +        PlainActionFuture<XPackFeatureSet.Usage> future = new PlainActionFuture<>();, +        featureSet.usage(future);, +        XPackFeatureSet.Usage securityUsage = future.get();, +        BytesStreamOutput out = new BytesStreamOutput();, +        securityUsage.writeTo(out);, +        XPackFeatureSet.Usage serializedUsage = new SecurityFeatureSetUsage(out.bytes().streamInput());, +        for (XPackFeatureSet.Usage usage : Arrays.asList(securityUsage, serializedUsage)) {, +            assertThat(usage, is(notNullValue()));, +            assertThat(usage.name(), is(XPackField.SECURITY));, +            assertThat(usage.enabled(), is(false));, +            assertThat(usage.available(), is(true));, +            XContentSource source = getXContentSource(usage);, +, +            // check SSL : This is permitted even though security has been dynamically disabled by the trial license., +            assertThat(source.getValue("ssl"), is(notNullValue()));, +            assertThat(source.getValue("ssl.http.enabled"), is(httpSSLEnabled));, +            assertThat(source.getValue("ssl.transport.enabled"), is(transportSSLEnabled));, +, +            // everything else is missing because security is disabled, +            assertThat(source.getValue("realms"), is(nullValue()));, +            assertThat(source.getValue("token_service"), is(nullValue()));, +            assertThat(source.getValue("api_key_service"), is(nullValue()));, +            assertThat(source.getValue("audit"), is(nullValue()));, +            assertThat(source.getValue("anonymous"), is(nullValue()));, +            assertThat(source.getValue("ipfilter"), is(nullValue()));, +            assertThat(source.getValue("roles"), is(nullValue()));, +        }, +    }, +, +    private XContentSource getXContentSource(XPackFeatureSet.Usage usage) throws IOException {, +        XContentSource source;, +        try (XContentBuilder builder = XContentFactory.jsonBuilder()) {, +            usage.toXContent(builder, ToXContent.EMPTY_PARAMS);, +            source = new XContentSource(builder);, +        }, +        return source;]