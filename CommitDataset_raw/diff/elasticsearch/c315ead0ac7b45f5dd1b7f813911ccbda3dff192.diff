[+++ b/server/src/main/java/org/elasticsearch/cluster/coordination/Coordinator.java, +import org.elasticsearch.common.io.stream.NamedWriteableRegistry;, +import org.elasticsearch.discovery.zen.PendingClusterStateStats;, +                       NamedWriteableRegistry namedWriteableRegistry, AllocationService allocationService, MasterService masterService,, +        this.publicationHandler = new PublicationTransportHandler(transportService, namedWriteableRegistry,, +            this::handlePublishRequest, this::handleApplyCommit);, +        return new DiscoveryStats(new PendingClusterStateStats(0, 0, 0), publicationHandler.stats());, +                final PublicationTransportHandler.PublicationContext publicationContext =, +                    publicationHandler.newPublicationContext(clusterChangedEvent);, +                final CoordinatorPublication publication = new CoordinatorPublication(publishRequest, publicationContext,, +                    new ListenableFuture<>(), ackListener, publishListener);, +        private final PublicationTransportHandler.PublicationContext publicationContext;, +        CoordinatorPublication(PublishRequest publishRequest, PublicationTransportHandler.PublicationContext publicationContext,, +                               ListenableFuture<Void> localNodeAckEvent, AckListener ackListener, ActionListener<Void> publishListener) {, +            this.publicationContext = publicationContext;, +            publicationContext.sendPublishRequest(destination, publishRequest, wrapWithMutex(responseActionListener));, +++ b/server/src/main/java/org/elasticsearch/cluster/coordination/Coordinator.java, +import org.elasticsearch.common.io.stream.NamedWriteableRegistry;, +import org.elasticsearch.discovery.zen.PendingClusterStateStats;, +                       NamedWriteableRegistry namedWriteableRegistry, AllocationService allocationService, MasterService masterService,, +        this.publicationHandler = new PublicationTransportHandler(transportService, namedWriteableRegistry,, +            this::handlePublishRequest, this::handleApplyCommit);, +        return new DiscoveryStats(new PendingClusterStateStats(0, 0, 0), publicationHandler.stats());, +                final PublicationTransportHandler.PublicationContext publicationContext =, +                    publicationHandler.newPublicationContext(clusterChangedEvent);, +                final CoordinatorPublication publication = new CoordinatorPublication(publishRequest, publicationContext,, +                    new ListenableFuture<>(), ackListener, publishListener);, +        private final PublicationTransportHandler.PublicationContext publicationContext;, +        CoordinatorPublication(PublishRequest publishRequest, PublicationTransportHandler.PublicationContext publicationContext,, +                               ListenableFuture<Void> localNodeAckEvent, AckListener ackListener, ActionListener<Void> publishListener) {, +            this.publicationContext = publicationContext;, +            publicationContext.sendPublishRequest(destination, publishRequest, wrapWithMutex(responseActionListener));, +++ b/server/src/main/java/org/elasticsearch/cluster/coordination/PublicationTransportHandler.java, +import org.apache.logging.log4j.message.ParameterizedMessage;, +import org.elasticsearch.ElasticsearchException;, +import org.elasticsearch.Version;, +import org.elasticsearch.cluster.ClusterChangedEvent;, +import org.elasticsearch.cluster.ClusterState;, +import org.elasticsearch.cluster.Diff;, +import org.elasticsearch.cluster.IncompatibleClusterStateVersionException;, +import org.elasticsearch.cluster.node.DiscoveryNodes;, +import org.elasticsearch.common.bytes.BytesReference;, +import org.elasticsearch.common.compress.Compressor;, +import org.elasticsearch.common.compress.CompressorFactory;, +import org.elasticsearch.common.io.stream.BytesStreamOutput;, +import org.elasticsearch.common.io.stream.NamedWriteableAwareStreamInput;, +import org.elasticsearch.common.io.stream.NamedWriteableRegistry;, +import org.elasticsearch.common.io.stream.StreamOutput;, +import org.elasticsearch.common.util.concurrent.AbstractRunnable;, +import org.elasticsearch.core.internal.io.IOUtils;, +import org.elasticsearch.discovery.zen.PublishClusterStateStats;, +import org.elasticsearch.transport.BytesTransportRequest;, +import org.elasticsearch.transport.TransportChannel;, +import java.util.HashMap;, +import java.util.Map;, +import java.util.concurrent.atomic.AtomicLong;, +import java.util.concurrent.atomic.AtomicReference;, +    private final NamedWriteableRegistry namedWriteableRegistry;, +    private final Function<PublishRequest, PublishWithJoinResponse> handlePublishRequest;, +    private AtomicReference<ClusterState> lastSeenClusterState = new AtomicReference<>();, +, +    private final AtomicLong fullClusterStateReceivedCount = new AtomicLong();, +    private final AtomicLong incompatibleClusterStateDiffReceivedCount = new AtomicLong();, +    private final AtomicLong compatibleClusterStateDiffReceivedCount = new AtomicLong();, +, +    public PublicationTransportHandler(TransportService transportService, NamedWriteableRegistry namedWriteableRegistry,, +        this.namedWriteableRegistry = namedWriteableRegistry;, +        this.handlePublishRequest = handlePublishRequest;, +        transportService.registerRequestHandler(PUBLISH_STATE_ACTION_NAME, BytesTransportRequest::new, ThreadPool.Names.GENERIC,, +            false, false, (request, channel, task) -> handleIncomingPublishRequest(request, channel));, +    public PublishClusterStateStats stats() {, +        return new PublishClusterStateStats(, +            fullClusterStateReceivedCount.get(),, +            incompatibleClusterStateDiffReceivedCount.get(),, +            compatibleClusterStateDiffReceivedCount.get());, +    }, +, +    public interface PublicationContext {, +, +        void sendPublishRequest(DiscoveryNode destination, PublishRequest publishRequest,, +                                ActionListener<PublishWithJoinResponse> responseActionListener);, +, +    }, +, +    public PublicationContext newPublicationContext(ClusterChangedEvent clusterChangedEvent) {, +        final DiscoveryNodes nodes = clusterChangedEvent.state().nodes();, +        final ClusterState newState = clusterChangedEvent.state();, +        final ClusterState previousState = clusterChangedEvent.previousState();, +        final boolean sendFullVersion = clusterChangedEvent.previousState().getBlocks().disableStatePersistence();, +        final Map<Version, BytesReference> serializedStates = new HashMap<>();, +        final Map<Version, BytesReference> serializedDiffs = new HashMap<>();, +, +        // we build these early as a best effort not to commit in the case of error., +        // sadly this is not water tight as it may that a failed diff based publishing to a node, +        // will cause a full serialization based on an older version, which may fail after the, +        // change has been committed., +        buildDiffAndSerializeStates(clusterChangedEvent.state(), clusterChangedEvent.previousState(),, +            nodes, sendFullVersion, serializedStates, serializedDiffs);, +, +        return (destination, publishRequest, responseActionListener) -> {]