[+++ b/modules/elasticsearch/src/main/java/org/elasticsearch/cluster/ClusterState.java, +            CachedStreamOutput.Entry cachedEntry = CachedStreamOutput.popEntry();, +            try {, +                BytesStreamOutput os = cachedEntry.cachedBytes();, +            } finally {, +                CachedStreamOutput.pushEntry(cachedEntry);, +            }, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/cluster/ClusterState.java, +            CachedStreamOutput.Entry cachedEntry = CachedStreamOutput.popEntry();, +            try {, +                BytesStreamOutput os = cachedEntry.cachedBytes();, +            } finally {, +                CachedStreamOutput.pushEntry(cachedEntry);, +            }, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/common/compress/lzf/ChunkEncoder.java, +    // ES: Added recycler as a parameter so we can control its caching, +    public ChunkEncoder(int totalLength, BufferRecycler recycler) {, +        _recycler = recycler;, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/cluster/ClusterState.java, +            CachedStreamOutput.Entry cachedEntry = CachedStreamOutput.popEntry();, +            try {, +                BytesStreamOutput os = cachedEntry.cachedBytes();, +            } finally {, +                CachedStreamOutput.pushEntry(cachedEntry);, +            }, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/common/compress/lzf/ChunkEncoder.java, +    // ES: Added recycler as a parameter so we can control its caching, +    public ChunkEncoder(int totalLength, BufferRecycler recycler) {, +        _recycler = recycler;, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/common/compress/lzf/LZFEncoder.java, +        ChunkEncoder enc = new ChunkEncoder(length, BufferRecycler.instance());, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/cluster/ClusterState.java, +            CachedStreamOutput.Entry cachedEntry = CachedStreamOutput.popEntry();, +            try {, +                BytesStreamOutput os = cachedEntry.cachedBytes();, +            } finally {, +                CachedStreamOutput.pushEntry(cachedEntry);, +            }, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/common/compress/lzf/ChunkEncoder.java, +    // ES: Added recycler as a parameter so we can control its caching, +    public ChunkEncoder(int totalLength, BufferRecycler recycler) {, +        _recycler = recycler;, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/common/compress/lzf/LZFEncoder.java, +        ChunkEncoder enc = new ChunkEncoder(length, BufferRecycler.instance());, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/common/compress/lzf/LZFOutputStream.java, +        _encoder = new ChunkEncoder(OUTPUT_BUFFER_SIZE, _recycler);, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/cluster/ClusterState.java, +            CachedStreamOutput.Entry cachedEntry = CachedStreamOutput.popEntry();, +            try {, +                BytesStreamOutput os = cachedEntry.cachedBytes();, +            } finally {, +                CachedStreamOutput.pushEntry(cachedEntry);, +            }, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/common/compress/lzf/ChunkEncoder.java, +    // ES: Added recycler as a parameter so we can control its caching, +    public ChunkEncoder(int totalLength, BufferRecycler recycler) {, +        _recycler = recycler;, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/common/compress/lzf/LZFEncoder.java, +        ChunkEncoder enc = new ChunkEncoder(length, BufferRecycler.instance());, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/common/compress/lzf/LZFOutputStream.java, +        _encoder = new ChunkEncoder(OUTPUT_BUFFER_SIZE, _recycler);, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/common/io/stream/CachedStreamOutput.java, +import org.elasticsearch.common.util.concurrent.jsr166y.LinkedTransferQueue;, +, +import java.util.Queue;, +import java.util.concurrent.atomic.AtomicInteger;, +    private static Entry newEntry() {, +        BytesStreamOutput bytes = new BytesStreamOutput();, +        HandlesStreamOutput handles = new HandlesStreamOutput(bytes);, +        LZFStreamOutput lzf = new LZFStreamOutput(bytes, true);, +        return new Entry(bytes, handles, lzf);, +    }, +, +    public static class Entry {, +        private final BytesStreamOutput bytes;, +        private final HandlesStreamOutput handles;, +        private final LZFStreamOutput lzf;, +        /**, +         * Returns the underlying bytes without any resetting., +         */, +        public BytesStreamOutput bytes() {, +            return bytes;, +         * Returns cached bytes that are also reset., +        public BytesStreamOutput cachedBytes() {, +            bytes.reset();, +            return bytes;, +        public LZFStreamOutput cachedLZFBytes() throws IOException {, +        public HandlesStreamOutput cachedHandlesLzfBytes() throws IOException {, +            handles.reset(lzf);, +            return handles;, +        public HandlesStreamOutput cachedHandlesBytes() throws IOException {, +            handles.reset(bytes);, +            return handles;, +        }, +    }, +, +    static class SoftWrapper<T> {, +        private SoftReference<T> ref;, +, +        public SoftWrapper() {]