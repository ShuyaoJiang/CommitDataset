[+++ b/plugin/src/main/java/org/elasticsearch/xpack/ml/MachineLearning.java, +        JobProvider jobProvider = new JobProvider(client, settings);, +++ b/plugin/src/main/java/org/elasticsearch/xpack/ml/MachineLearning.java, +        JobProvider jobProvider = new JobProvider(client, settings);, +++ b/plugin/src/main/java/org/elasticsearch/xpack/ml/job/persistence/ElasticsearchMappings.java, +    static XContentBuilder termFieldsMapping(String type, Collection<String> termFields) {, +        try {, +            XContentBuilder builder = jsonBuilder().startObject();, +            if (type != null) {, +                builder.startObject(type);, +            }, +            builder.startObject(PROPERTIES);, +            builder.endObject();, +            if (type != null) {, +                builder.endObject();, +            }, +            return builder.endObject();, +        } catch (IOException e) {, +            throw new RuntimeException(e);, +        }, +++ b/plugin/src/main/java/org/elasticsearch/xpack/ml/MachineLearning.java, +        JobProvider jobProvider = new JobProvider(client, settings);, +++ b/plugin/src/main/java/org/elasticsearch/xpack/ml/job/persistence/ElasticsearchMappings.java, +    static XContentBuilder termFieldsMapping(String type, Collection<String> termFields) {, +        try {, +            XContentBuilder builder = jsonBuilder().startObject();, +            if (type != null) {, +                builder.startObject(type);, +            }, +            builder.startObject(PROPERTIES);, +            builder.endObject();, +            if (type != null) {, +                builder.endObject();, +            }, +            return builder.endObject();, +        } catch (IOException e) {, +            throw new RuntimeException(e);, +        }, +++ b/plugin/src/main/java/org/elasticsearch/xpack/ml/job/persistence/JobProvider.java, +import org.elasticsearch.cluster.metadata.IndexMetaData;, +import org.elasticsearch.cluster.metadata.MappingMetaData;, +    public JobProvider(Client client, Settings settings) {, +    public void createJobResultIndex(Job job, ClusterState state, final ActionListener<Boolean> finalListener) {, +        final ActionListener<Boolean> createAliasListener = ActionListener.wrap(success -> {, +                            // we could return 'sucess && r.isAcknowledged()' instead of 'true', but that makes, +                            // testing not possible as we can't create IndicesAliasesResponse instance or, +                            // mock IndicesAliasesResponse#isAcknowledged(), +                            .execute(ActionListener.wrap(r -> finalListener.onResponse(true),, +                                    finalListener::onFailure));, +                finalListener::onFailure);, +            String type = Result.TYPE.getPreferredName();, +            createIndexRequest.mapping(type, ElasticsearchMappings.termFieldsMapping(type, termFields));, +                            r -> createAliasListener.onResponse(r.isAcknowledged()),, +                                    createAliasListener.onResponse(true);, +                                    finalListener.onFailure(e);, +            long fieldCountLimit = MapperService.INDEX_MAPPING_TOTAL_FIELDS_LIMIT_SETTING.get(settings);, +            if (violatedFieldCountLimit(indexName, termFields.size(), fieldCountLimit, state)) {, +                String message = "Cannot create job in index '" + indexName + "' as the " +, +                        MapperService.INDEX_MAPPING_TOTAL_FIELDS_LIMIT_SETTING.getKey() + " setting will be violated";, +                finalListener.onFailure(new IllegalArgumentException(message));, +            } else {, +                updateIndexMappingWithTermFields(indexName, termFields,, +                        ActionListener.wrap(createAliasListener::onResponse, finalListener::onFailure));, +    }, +, +    static boolean violatedFieldCountLimit(String indexName, long additionalFieldCount, long fieldCountLimit, ClusterState clusterState) {, +        long numFields = 0;, +        IndexMetaData indexMetaData = clusterState.metaData().index(indexName);, +        Iterator<MappingMetaData> mappings = indexMetaData.getMappings().valuesIt();, +        while (mappings.hasNext()) {, +            MappingMetaData mapping = mappings.next();, +            try {, +                numFields += countFields(mapping.sourceAsMap());, +            } catch (IOException e) {, +                throw new RuntimeException(e);, +            }, +        }, +        if (numFields + additionalFieldCount > fieldCountLimit) {, +            return true;, +        } else {, +            return false;, +        }, +    }, +, +    @SuppressWarnings("unchecked"), +    static int countFields(Map<String, Object> mapping) {, +        Object propertiesNode = mapping.get("properties");, +        if (propertiesNode != null && propertiesNode instanceof Map) {, +            mapping = (Map<String, Object>) propertiesNode;, +        } else {, +            return 0;, +        }, +, +        int count = 0;, +        for (Map.Entry<String, Object> entry : mapping.entrySet()) {, +            if (entry.getValue() instanceof Map) {, +                Map<String, Object> fieldMapping = (Map<String, Object>) entry.getValue();, +                // take into account object and nested fields:, +                count += countFields(fieldMapping);, +            }]