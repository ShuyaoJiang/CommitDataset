[+++ b/src/main/java/org/elasticsearch/Version.java, +public class Version {, +     *, +++ b/src/main/java/org/elasticsearch/Version.java, +public class Version {, +     *, +++ b/src/main/java/org/elasticsearch/cluster/action/shard/ShardStateAction.java, +import org.elasticsearch.cluster.ProcessedClusterStateUpdateTask;, +import org.elasticsearch.cluster.routing.*;, +    private final RoutingService routingService;, +                            AllocationService allocationService, RoutingService routingService) {, +        this.routingService = routingService;, +        clusterService.submitStateUpdateTask("shard-failed (" + shardRoutingEntry.shardRouting + "), reason [" + shardRoutingEntry.reason + "]", Priority.HIGH, new ProcessedClusterStateUpdateTask() {, +, +, +            @Override, +            public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {, +                if (oldState != newState && newState.getRoutingNodes().hasUnassigned()) {, +                    logger.trace("unassigned shards after shard failures. scheduling a reroute.");, +                    routingService.scheduleReroute();, +                }, +            }, +++ b/src/main/java/org/elasticsearch/Version.java, +public class Version {, +     *, +++ b/src/main/java/org/elasticsearch/cluster/action/shard/ShardStateAction.java, +import org.elasticsearch.cluster.ProcessedClusterStateUpdateTask;, +import org.elasticsearch.cluster.routing.*;, +    private final RoutingService routingService;, +                            AllocationService allocationService, RoutingService routingService) {, +        this.routingService = routingService;, +        clusterService.submitStateUpdateTask("shard-failed (" + shardRoutingEntry.shardRouting + "), reason [" + shardRoutingEntry.reason + "]", Priority.HIGH, new ProcessedClusterStateUpdateTask() {, +, +, +            @Override, +            public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {, +                if (oldState != newState && newState.getRoutingNodes().hasUnassigned()) {, +                    logger.trace("unassigned shards after shard failures. scheduling a reroute.");, +                    routingService.scheduleReroute();, +                }, +            }, +++ b/src/main/java/org/elasticsearch/cluster/node/DiscoveryNode.java, +import org.elasticsearch.common.io.stream.*;, +     *, +     *, +     *, +        if (!(obj instanceof DiscoveryNode)) {, +        }, +, +    // we need this custom serialization logic because Version is not serializable (because org.apache.lucene.util.Version is not serializable), +    private void writeObject(java.io.ObjectOutputStream out), +            throws IOException {, +        StreamOutput streamOutput = new OutputStreamStreamOutput(out);, +        streamOutput.setVersion(Version.CURRENT.minimumCompatibilityVersion());, +        this.writeTo(streamOutput);, +    }, +, +    private void readObject(java.io.ObjectInputStream in), +            throws IOException, ClassNotFoundException {, +        StreamInput streamInput = new InputStreamStreamInput(in);, +        streamInput.setVersion(Version.CURRENT.minimumCompatibilityVersion());, +        this.readFrom(streamInput);, +    }, +++ b/src/main/java/org/elasticsearch/Version.java, +public class Version {, +     *, +++ b/src/main/java/org/elasticsearch/cluster/action/shard/ShardStateAction.java, +import org.elasticsearch.cluster.ProcessedClusterStateUpdateTask;, +import org.elasticsearch.cluster.routing.*;, +    private final RoutingService routingService;, +                            AllocationService allocationService, RoutingService routingService) {, +        this.routingService = routingService;, +        clusterService.submitStateUpdateTask("shard-failed (" + shardRoutingEntry.shardRouting + "), reason [" + shardRoutingEntry.reason + "]", Priority.HIGH, new ProcessedClusterStateUpdateTask() {, +, +, +            @Override, +            public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {, +                if (oldState != newState && newState.getRoutingNodes().hasUnassigned()) {, +                    logger.trace("unassigned shards after shard failures. scheduling a reroute.");, +                    routingService.scheduleReroute();, +                }, +            }, +++ b/src/main/java/org/elasticsearch/cluster/node/DiscoveryNode.java, +import org.elasticsearch.common.io.stream.*;, +     *, +     *, +     *, +        if (!(obj instanceof DiscoveryNode)) {, +        }, +, +    // we need this custom serialization logic because Version is not serializable (because org.apache.lucene.util.Version is not serializable), +    private void writeObject(java.io.ObjectOutputStream out), +            throws IOException {, +        StreamOutput streamOutput = new OutputStreamStreamOutput(out);, +        streamOutput.setVersion(Version.CURRENT.minimumCompatibilityVersion());, +        this.writeTo(streamOutput);, +    }, +, +    private void readObject(java.io.ObjectInputStream in), +            throws IOException, ClassNotFoundException {]