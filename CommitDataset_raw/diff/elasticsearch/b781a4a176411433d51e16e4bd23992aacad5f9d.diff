[+++ b/core/src/main/java/org/elasticsearch/action/delete/DeleteResponse.java, +        builder.field("found", result == Result.DELETED);, +++ b/core/src/main/java/org/elasticsearch/action/delete/DeleteResponse.java, +        builder.field("found", result == Result.DELETED);, +++ b/core/src/main/java/org/elasticsearch/search/SearchModule.java, +        if (false == transportClient) {, +        }, +++ b/core/src/main/java/org/elasticsearch/action/delete/DeleteResponse.java, +        builder.field("found", result == Result.DELETED);, +++ b/core/src/main/java/org/elasticsearch/search/SearchModule.java, +        if (false == transportClient) {, +        }, +++ /dev/null, +++ b/core/src/main/java/org/elasticsearch/action/delete/DeleteResponse.java, +        builder.field("found", result == Result.DELETED);, +++ b/core/src/main/java/org/elasticsearch/search/SearchModule.java, +        if (false == transportClient) {, +        }, +++ /dev/null, +++ b/core/src/test/java/org/elasticsearch/search/aggregations/AggregatorTestCase.java, +import org.apache.lucene.index.CompositeReaderContext;, +import org.apache.lucene.index.IndexReaderContext;, +import org.apache.lucene.index.LeafReaderContext;, +import org.apache.lucene.search.Collector;, +import org.apache.lucene.search.Weight;, +import java.util.ArrayList;, +import java.util.Collections;, +import java.util.List;, + * Provides helpers for constructing and searching an {@link Aggregator} implementation based on a provided, + * {@link AggregationBuilder} instance., +                                                                                      IndexSearcher indexSearcher,, +                                                                                      MappedFieldType... fieldTypes) throws IOException {, +        for (MappedFieldType fieldType : fieldTypes) {, +            when(queryShardContext.fieldMapper(fieldType.name())).thenReturn(fieldType);, +            when(queryShardContext.getForField(fieldType)).thenReturn(fieldData);, +        }, +    protected <A extends InternalAggregation, C extends Aggregator> A search(IndexSearcher searcher,, +                                                                             Query query,, +                                                                             AggregationBuilder builder,, +                                                                             MappedFieldType... fieldTypes) throws IOException {, +        try (C a = createAggregator(builder, searcher, fieldTypes)) {, +            a.preCollection();, +            searcher.search(query, a);, +            a.postCollection();, +            @SuppressWarnings("unchecked"), +            A internalAgg = (A) a.buildAggregation(0L);, +            return internalAgg;, +        }, +    }, +, +    /**, +     * Divides the provided {@link IndexSearcher} in sub-searcher, one for each segment,, +     * builds an aggregator for each sub-searcher filtered by the provided {@link Query} and, +     * returns the reduced {@link InternalAggregation}., +     */, +    protected <A extends InternalAggregation, C extends Aggregator> A searchAndReduce(IndexSearcher searcher,, +                                                                                      Query query,, +                                                                                      AggregationBuilder builder,, +                                                                                      MappedFieldType... fieldTypes) throws IOException {, +        final IndexReaderContext ctx = searcher.getTopReaderContext();, +, +        final ShardSearcher[] subSearchers;, +        if (ctx instanceof LeafReaderContext) {, +            subSearchers = new ShardSearcher[1];, +            subSearchers[0] = new ShardSearcher((LeafReaderContext) ctx, ctx);, +        } else {, +            final CompositeReaderContext compCTX = (CompositeReaderContext) ctx;, +            final int size = compCTX.leaves().size();, +            subSearchers = new ShardSearcher[size];, +            for(int searcherIDX=0;searcherIDX<subSearchers.length;searcherIDX++) {, +                final LeafReaderContext leave = compCTX.leaves().get(searcherIDX);, +                subSearchers[searcherIDX] = new ShardSearcher(leave, compCTX);, +            }, +        }, +, +        List<InternalAggregation> aggs = new ArrayList<> ();, +        Query rewritten = searcher.rewrite(query);, +        Weight weight = searcher.createWeight(rewritten, true);, +        try (C root = createAggregator(builder, searcher, fieldTypes)) {, +            for (ShardSearcher subSearcher : subSearchers) {, +                try (C a = createAggregator(builder, subSearcher, fieldTypes)) {, +                    a.preCollection();, +                    subSearcher.search(weight, a);, +                    a.postCollection();, +                    aggs.add(a.buildAggregation(0L));, +                }, +            }, +            @SuppressWarnings("unchecked"), +            A internalAgg = (A) aggs.get(0).doReduce(aggs,, +                new InternalAggregation.ReduceContext(root.context().bigArrays(), null));, +            return internalAgg;, +        }, +    }, +, +    private static class ShardSearcher extends IndexSearcher {, +        private final List<LeafReaderContext> ctx;, +, +        public ShardSearcher(LeafReaderContext ctx, IndexReaderContext parent) {, +            super(parent);, +            this.ctx = Collections.singletonList(ctx);]