[+++ b/dev-tools/create-bwc-index.py, +import glob, +import os, +import random, +import subprocess, +import tempfile, +import time, +if sys.version_info[0] < 3:, +  print('%s must use python 3.x (for the ES python client)' % sys.argv[0]), +  print('Can\'t import elasticsearch please install `sudo pip3 install elasticsearch`'), +  if version.startswith('0.') or version in ('1.0.0.Beta1', '1.0.0.Beta2'):, +def generate_index(client, version, index_name):, +  client.indices.delete(index=index_name, ignore=404), +  client.indices.create(index=index_name, body={, +    num_docs = int(num_docs / 10), +  index_documents(client, index_name, 'doc', num_docs), +  run_basic_asserts(client, index_name, 'doc', num_docs), +def snapshot_index(client, cfg, version, repo_dir):, +      'cluster.routing.allocation.exclude.version_attr': version, +  client.indices.put_template(name='template_' + version.lower(), order=0, body={, +          "term": {"version" : version }, +      'location': repo_dir, +  required = parser.add_mutually_exclusive_group(required=True), +  required.add_argument('versions', metavar='X.Y.Z', nargs='*', default=[],, +  required.add_argument('--all', action='store_true', default=False,, +                        help='Recreate all existing backwards compatibility indexes'), +  if not cfg.versions:, +    # --all, +    for bwc_index in glob.glob(os.path.join(cfg.output_dir, 'index-*.zip')):, +      version = os.path.basename(bwc_index)[len('index-'):-len('.zip')], +      cfg.versions.append(version), +def create_bwc_index(cfg, version):, +  logging.info('--> Creating bwc index for %s' % version), +  release_dir = os.path.join(cfg.releases_dir, 'elasticsearch-%s' % version), +  if not os.path.exists(release_dir):, +    parser.error('ES version %s does not exist in %s' % (version, cfg.releases_dir)) , +  snapshot_supported = not (version.startswith('0.') or version == '1.0.0.Beta1'), +  tmp_dir = tempfile.mkdtemp(), +  data_dir = os.path.join(tmp_dir, 'data'), +  repo_dir = os.path.join(tmp_dir, 'repo'), +  logging.info('Temp data dir: %s' % data_dir), +  logging.info('Temp repo dir: %s' % repo_dir), +, +  try:, +    node = start_node(version, release_dir, data_dir, cfg.tcp_port, cfg.http_port), +    client = create_client(cfg.http_port), +    index_name = 'index-%s' % version.lower(), +    generate_index(client, version, index_name), +    if snapshot_supported:, +      snapshot_index(client, cfg, version, repo_dir), +, +    # 10067: get a delete-by-query into the translog on upgrade.  We must do, +    # this after the snapshot, because it calls flush.  Otherwise the index, +    # will already have the deletions applied on upgrade., +    delete_by_query(client, version, index_name, 'doc'), +    , +  finally:, +    if 'node' in vars():, +      logging.info('Shutting down node with pid %d', node.pid), +      node.terminate(), +      time.sleep(1) # some nodes take time to terminate, +  compress_index(version, tmp_dir, cfg.output_dir), +  if snapshot_supported:, +    compress_repo(version, tmp_dir, cfg.output_dir), +, +  for version in cfg.versions:, +    create_bwc_index(cfg, version)]