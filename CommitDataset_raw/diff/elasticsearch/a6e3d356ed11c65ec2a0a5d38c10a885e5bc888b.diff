[+++ b/core/src/main/java/org/elasticsearch/search/aggregations/bucket/range/AbstractRangeBuilder.java, +import java.util.function.Function;, +    protected Range[] processRanges(Function<Range, Range> rangeProcessor) {, +            ranges[i] = rangeProcessor.apply(this.ranges.get(i));, +++ b/core/src/main/java/org/elasticsearch/search/aggregations/bucket/range/AbstractRangeBuilder.java, +import java.util.function.Function;, +    protected Range[] processRanges(Function<Range, Range> rangeProcessor) {, +            ranges[i] = rangeProcessor.apply(this.ranges.get(i));, +++ b/core/src/main/java/org/elasticsearch/search/aggregations/bucket/range/DateRangeAggregationBuilder.java, +import org.elasticsearch.search.DocValueFormat;, +    private static Double convertDateTime(DateTime dateTime) {, +        RangeAggregator.Range[] ranges = processRanges(range -> {, +            DocValueFormat parser = config.format();, +            assert parser != null;, +            double from = range.getFrom();, +            double to = range.getTo();, +            String fromAsString = range.getFromAsString();, +            String toAsString = range.getToAsString();, +            if (fromAsString != null) {, +                from = parser.parseDouble(fromAsString, false, context.getQueryShardContext()::nowInMillis);, +            } else if (Double.isFinite(from)) {, +                // from/to provided as double should be converted to string and parsed regardless to support, +                // different formats like `epoch_millis` vs. `epoch_second` with numeric input, +                from = parser.parseDouble(Long.toString((long) from), false, context.getQueryShardContext()::nowInMillis);, +            }, +            if (toAsString != null) {, +                to = parser.parseDouble(toAsString, false, context.getQueryShardContext()::nowInMillis);, +            } else if (Double.isFinite(to)) {, +                to = parser.parseDouble(Long.toString((long) to), false, context.getQueryShardContext()::nowInMillis);, +            }, +            return new RangeAggregator.Range(range.getKey(), from, fromAsString, to, toAsString);, +        });, +++ b/core/src/main/java/org/elasticsearch/search/aggregations/bucket/range/AbstractRangeBuilder.java, +import java.util.function.Function;, +    protected Range[] processRanges(Function<Range, Range> rangeProcessor) {, +            ranges[i] = rangeProcessor.apply(this.ranges.get(i));, +++ b/core/src/main/java/org/elasticsearch/search/aggregations/bucket/range/DateRangeAggregationBuilder.java, +import org.elasticsearch.search.DocValueFormat;, +    private static Double convertDateTime(DateTime dateTime) {, +        RangeAggregator.Range[] ranges = processRanges(range -> {, +            DocValueFormat parser = config.format();, +            assert parser != null;, +            double from = range.getFrom();, +            double to = range.getTo();, +            String fromAsString = range.getFromAsString();, +            String toAsString = range.getToAsString();, +            if (fromAsString != null) {, +                from = parser.parseDouble(fromAsString, false, context.getQueryShardContext()::nowInMillis);, +            } else if (Double.isFinite(from)) {, +                // from/to provided as double should be converted to string and parsed regardless to support, +                // different formats like `epoch_millis` vs. `epoch_second` with numeric input, +                from = parser.parseDouble(Long.toString((long) from), false, context.getQueryShardContext()::nowInMillis);, +            }, +            if (toAsString != null) {, +                to = parser.parseDouble(toAsString, false, context.getQueryShardContext()::nowInMillis);, +            } else if (Double.isFinite(to)) {, +                to = parser.parseDouble(Long.toString((long) to), false, context.getQueryShardContext()::nowInMillis);, +            }, +            return new RangeAggregator.Range(range.getKey(), from, fromAsString, to, toAsString);, +        });, +++ b/core/src/main/java/org/elasticsearch/search/aggregations/bucket/range/RangeAggregationBuilder.java, +import org.elasticsearch.search.DocValueFormat;, +        Range[] ranges = processRanges(range -> {, +            DocValueFormat parser = config.format();, +            assert parser != null;, +            Double from = range.from;, +            Double to = range.to;, +            if (range.fromAsStr != null) {, +                from = parser.parseDouble(range.fromAsStr, false, context.getQueryShardContext()::nowInMillis);, +            }, +            if (range.toAsStr != null) {, +                to = parser.parseDouble(range.toAsStr, false, context.getQueryShardContext()::nowInMillis);, +            }, +            return new Range(range.key, from, range.fromAsStr, to, range.toAsStr);, +        });, +++ b/core/src/main/java/org/elasticsearch/search/aggregations/bucket/range/AbstractRangeBuilder.java, +import java.util.function.Function;, +    protected Range[] processRanges(Function<Range, Range> rangeProcessor) {, +            ranges[i] = rangeProcessor.apply(this.ranges.get(i));, +++ b/core/src/main/java/org/elasticsearch/search/aggregations/bucket/range/DateRangeAggregationBuilder.java, +import org.elasticsearch.search.DocValueFormat;, +    private static Double convertDateTime(DateTime dateTime) {, +        RangeAggregator.Range[] ranges = processRanges(range -> {, +            DocValueFormat parser = config.format();, +            assert parser != null;, +            double from = range.getFrom();, +            double to = range.getTo();, +            String fromAsString = range.getFromAsString();, +            String toAsString = range.getToAsString();, +            if (fromAsString != null) {, +                from = parser.parseDouble(fromAsString, false, context.getQueryShardContext()::nowInMillis);, +            } else if (Double.isFinite(from)) {, +                // from/to provided as double should be converted to string and parsed regardless to support, +                // different formats like `epoch_millis` vs. `epoch_second` with numeric input, +                from = parser.parseDouble(Long.toString((long) from), false, context.getQueryShardContext()::nowInMillis);, +            }, +            if (toAsString != null) {, +                to = parser.parseDouble(toAsString, false, context.getQueryShardContext()::nowInMillis);, +            } else if (Double.isFinite(to)) {, +                to = parser.parseDouble(Long.toString((long) to), false, context.getQueryShardContext()::nowInMillis);]