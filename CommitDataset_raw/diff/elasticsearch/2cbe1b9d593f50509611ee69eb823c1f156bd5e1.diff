[+++ b/src/main/java/org/elasticsearch/snapshots/RestoreService.java, +import java.util.*;, +import static com.google.common.collect.Sets.newHashSet;, +                    Set<String> aliases = newHashSet();, +                                } else {, +                                    for (ObjectCursor<String> alias : snapshotIndexMetaData.aliases().keys()) {, +                                        aliases.add(alias.value);, +                                    }, +                                } else {, +                                    for (ObjectCursor<String> alias : snapshotIndexMetaData.aliases().keys()) {, +                                        aliases.add(alias.value);, +                                    }, +                    checkAliasNameConflicts(renamedIndices, aliases);, +, +                        restoreInfo = new RestoreInfo(request.name(), ImmutableList.copyOf(renamedIndices.keySet()),, +                private void checkAliasNameConflicts(Map<String, String> renamedIndices, Set<String> aliases) {, +                    for(Map.Entry<String, String> renamedIndex: renamedIndices.entrySet()) {, +                        if (aliases.contains(renamedIndex.getKey())) {, +                            throw new SnapshotRestoreException(snapshotId, "cannot rename index [" + renamedIndex.getValue() + "] into [" + renamedIndex.getKey() + "] because of conflict with an alias with the same name");, +                        }, +                    }, +                }, +, +++ b/src/main/java/org/elasticsearch/snapshots/RestoreService.java, +import java.util.*;, +import static com.google.common.collect.Sets.newHashSet;, +                    Set<String> aliases = newHashSet();, +                                } else {, +                                    for (ObjectCursor<String> alias : snapshotIndexMetaData.aliases().keys()) {, +                                        aliases.add(alias.value);, +                                    }, +                                } else {, +                                    for (ObjectCursor<String> alias : snapshotIndexMetaData.aliases().keys()) {, +                                        aliases.add(alias.value);, +                                    }, +                    checkAliasNameConflicts(renamedIndices, aliases);, +, +                        restoreInfo = new RestoreInfo(request.name(), ImmutableList.copyOf(renamedIndices.keySet()),, +                private void checkAliasNameConflicts(Map<String, String> renamedIndices, Set<String> aliases) {, +                    for(Map.Entry<String, String> renamedIndex: renamedIndices.entrySet()) {, +                        if (aliases.contains(renamedIndex.getKey())) {, +                            throw new SnapshotRestoreException(snapshotId, "cannot rename index [" + renamedIndex.getValue() + "] into [" + renamedIndex.getKey() + "] because of conflict with an alias with the same name");, +                        }, +                    }, +                }, +, +++ b/src/test/java/org/elasticsearch/snapshots/SharedClusterSnapshotRestoreTests.java, +        createIndex("test-idx-1", "test-idx-2", "test-idx-3");, +        assertAcked(client.admin().indices().prepareAliases(), +                        .addAlias("test-idx-1", "alias-1"), +                        .addAlias("test-idx-2", "alias-2"), +                        .addAlias("test-idx-3", "alias-3"), +        );, +, +        logger.info("--> delete indices");, +        cluster().wipeIndices("test-idx-1", "test-idx-1-copy", "test-idx-2", "test-idx-2-copy");, +, +, +        logger.info("--> try renaming indices into existing alias name");, +        try {, +            client.admin().cluster().prepareRestoreSnapshot("test-repo", "test-snap").setIndices("test-idx-1").setRenamePattern(".+").setRenameReplacement("alias-3").setWaitForCompletion(true).execute().actionGet();, +            fail("Shouldn't be here");, +        } catch (InvalidIndexNameException ex) {, +            // Expected, +        }, +, +        logger.info("--> try renaming indices into existing alias of itself");, +        try {, +            client.admin().cluster().prepareRestoreSnapshot("test-repo", "test-snap").setIndices("test-idx-1").setRenamePattern("test-idx").setRenameReplacement("alias").setWaitForCompletion(true).execute().actionGet();, +            fail("Shouldn't be here");, +        } catch (SnapshotRestoreException ex) {, +            // Expected, +        }, +, +        logger.info("--> try renaming indices into existing alias of another restored index");, +        try {, +            client.admin().cluster().prepareRestoreSnapshot("test-repo", "test-snap").setIndices("test-idx-1", "test-idx-2").setRenamePattern("test-idx-1").setRenameReplacement("alias-2").setWaitForCompletion(true).execute().actionGet();, +            fail("Shouldn't be here");, +        } catch (SnapshotRestoreException ex) {, +            // Expected, +        }, +, +        logger.info("--> try renaming indices into existing alias of itself, but don't restore aliases ");, +        restoreSnapshotResponse = client.admin().cluster().prepareRestoreSnapshot("test-repo", "test-snap"), +                .setIndices("test-idx-1").setRenamePattern("test-idx").setRenameReplacement("alias"), +                .setWaitForCompletion(true).setIncludeAliases(false).execute().actionGet();, +        assertThat(restoreSnapshotResponse.getRestoreInfo().totalShards(), greaterThan(0));, +, +]