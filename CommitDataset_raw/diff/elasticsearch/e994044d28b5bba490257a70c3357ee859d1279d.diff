[+++ b/src/main/java/org/elasticsearch/common/lucene/search/FilteredCollector.java, +public class FilteredCollector implements XCollector {, +    public void postCollection() throws IOException {, +        if (collector instanceof XCollector) {, +            ((XCollector) collector).postCollection();, +        }, +    }, +, +    @Override, +        final Bits bits = set == null ? null : set.bits();, +        if (bits != null) {, +            // the filter supports random-access, +        // No random-access support, use the iterator and force in-order scoring, +        final DocIdSetIterator iterator;, +        if (DocIdSets.isEmpty(set)) {, +            iterator = null;, +        } else {, +            // DIS.iterator might still return null here, +            iterator = set.iterator();, +        }, +, +        if (iterator == null) {, +            return new FilterLeafCollector(in) {, +                @Override, +                public void collect(int doc) throws IOException {, +                    // no-op, +                }, +            };, +        }, +, +        return new FilterLeafCollector(in) {, +            @Override, +            public void collect(int doc) throws IOException {, +                final int itDoc = iterator.docID();, +                if (itDoc > doc) {, +                    return;, +                } else if (itDoc < doc) {, +                    if (iterator.advance(doc) == doc) {, +                        in.collect(doc);, +                    }, +                } else {, +                    in.collect(doc);, +                }, +            }, +        };, +    }, +, +++ b/src/main/java/org/elasticsearch/common/lucene/search/FilteredCollector.java, +public class FilteredCollector implements XCollector {, +    public void postCollection() throws IOException {, +        if (collector instanceof XCollector) {, +            ((XCollector) collector).postCollection();, +        }, +    }, +, +    @Override, +        final Bits bits = set == null ? null : set.bits();, +        if (bits != null) {, +            // the filter supports random-access, +        // No random-access support, use the iterator and force in-order scoring, +        final DocIdSetIterator iterator;, +        if (DocIdSets.isEmpty(set)) {, +            iterator = null;, +        } else {, +            // DIS.iterator might still return null here, +            iterator = set.iterator();, +        }, +, +        if (iterator == null) {, +            return new FilterLeafCollector(in) {, +                @Override, +                public void collect(int doc) throws IOException {, +                    // no-op, +                }, +            };, +        }, +, +        return new FilterLeafCollector(in) {, +            @Override, +            public void collect(int doc) throws IOException {, +                final int itDoc = iterator.docID();, +                if (itDoc > doc) {, +                    return;, +                } else if (itDoc < doc) {, +                    if (iterator.advance(doc) == doc) {, +                        in.collect(doc);, +                    }, +                } else {, +                    in.collect(doc);, +                }, +            }, +        };, +    }, +, +++ b/src/main/java/org/elasticsearch/common/lucene/search/XCollector.java, +/*, + * Licensed to Elasticsearch under one or more contributor, + * license agreements. See the NOTICE file distributed with, + * this work for additional information regarding copyright, + * ownership. Elasticsearch licenses this file to you under]