[+++ b/buildSrc/src/main/groovy/org/elasticsearch/gradle/test/ClusterFormationTasks.groovy, +        if (Version.fromString(node.nodeVersion).major > 6) {, +          esConfig['script.max_compilations_rate'] = '2048/1m', +        } else {, +        }, +++ b/buildSrc/src/main/groovy/org/elasticsearch/gradle/test/ClusterFormationTasks.groovy, +        if (Version.fromString(node.nodeVersion).major > 6) {, +          esConfig['script.max_compilations_rate'] = '2048/1m', +        } else {, +        }, +++ b/core/src/main/java/org/elasticsearch/common/settings/ClusterSettings.java, +                    ScriptService.SCRIPT_MAX_COMPILATIONS_RATE,, +++ b/buildSrc/src/main/groovy/org/elasticsearch/gradle/test/ClusterFormationTasks.groovy, +        if (Version.fromString(node.nodeVersion).major > 6) {, +          esConfig['script.max_compilations_rate'] = '2048/1m', +        } else {, +        }, +++ b/core/src/main/java/org/elasticsearch/common/settings/ClusterSettings.java, +                    ScriptService.SCRIPT_MAX_COMPILATIONS_RATE,, +++ b/core/src/main/java/org/elasticsearch/script/ScriptService.java, +import org.elasticsearch.common.collect.Tuple;, +    // a parsing function that requires a non negative int and a timevalue as arguments split by a slash, +    // this allows you to easily define rates, +    static final Function<String, Tuple<Integer, TimeValue>> MAX_COMPILATION_RATE_FUNCTION =, +            (String value) -> {, +                if (value.contains("/") == false || value.startsWith("/") || value.endsWith("/")) {, +                    throw new IllegalArgumentException("parameter must contain a positive integer and a timevalue, i.e. 10/1m, but was [" +, +                            value + "]");, +                }, +                int idx = value.indexOf("/");, +                String count = value.substring(0, idx);, +                String time = value.substring(idx + 1);, +                try {, +, +                    int rate = Integer.parseInt(count);, +                    if (rate < 0) {, +                        throw new IllegalArgumentException("rate [" + rate + "] must be positive");, +                    }, +                    TimeValue timeValue = TimeValue.parseTimeValue(time, "script.max_compilations_rate");, +                    if (timeValue.nanos() <= 0) {, +                        throw new IllegalArgumentException("time value [" + time + "] must be positive");, +                    }, +                    // protect against a too hard to check limit, like less than a minute, +                    if (timeValue.seconds() < 60) {, +                        throw new IllegalArgumentException("time value [" + time + "] must be at least on a one minute resolution");, +                    }, +                    return Tuple.tuple(rate, timeValue);, +                } catch (NumberFormatException e) {, +                    // the number format exception message is so confusing, that it makes more sense to wrap it with a useful one, +                    throw new IllegalArgumentException("could not parse [" + count + "] as integer in value [" + value + "]", e);, +                }, +            };, +, +    // public Setting(String key, Function<Settings, String> defaultValue, Function<String, T> parser, Property... properties) {, +    public static final Setting<Tuple<Integer, TimeValue>> SCRIPT_MAX_COMPILATIONS_RATE =, +            new Setting<>("script.max_compilations_rate", "75/5m", MAX_COMPILATION_RATE_FUNCTION, Property.Dynamic, Property.NodeScope);, +    private Tuple<Integer, TimeValue> rate;, +    private double scriptsPerTimeWindow;, +        this.setMaxCompilationRate(SCRIPT_MAX_COMPILATIONS_RATE.get(settings));, +        clusterSettings.addSettingsUpdateConsumer(SCRIPT_MAX_COMPILATIONS_RATE, this::setMaxCompilationRate);, +    /**, +     * This configures the maximum script compilations per five minute window., +     *, +     * @param newRate the new expected maximum number of compilations per five minute window, +     */, +    void setMaxCompilationRate(Tuple<Integer, TimeValue> newRate) {, +        this.rate = newRate;, +        this.scriptsPerTimeWindow = rate.v1();, +        this.compilesAllowedPerNano = ((double) rate.v1()) / newRate.v2().nanos();, +        scriptsPerTimeWindow += (timePassed) * compilesAllowedPerNano;, +        if (scriptsPerTimeWindow > rate.v1()) {, +            scriptsPerTimeWindow = rate.v1();, +        if (scriptsPerTimeWindow >= 1) {, +            scriptsPerTimeWindow -= 1.0;, +            throw new CircuitBreakingException("[script] Too many dynamic script compilations within, max: [" +, +                    rate.v1() + "/" + rate.v2() +"]; please use indexed, or scripts with parameters instead; " +, +                            "this limit can be changed by the [" + SCRIPT_MAX_COMPILATIONS_RATE.getKey() + "] setting");, +++ b/buildSrc/src/main/groovy/org/elasticsearch/gradle/test/ClusterFormationTasks.groovy, +        if (Version.fromString(node.nodeVersion).major > 6) {, +          esConfig['script.max_compilations_rate'] = '2048/1m', +        } else {, +        }, +++ b/core/src/main/java/org/elasticsearch/common/settings/ClusterSettings.java, +                    ScriptService.SCRIPT_MAX_COMPILATIONS_RATE,, +++ b/core/src/main/java/org/elasticsearch/script/ScriptService.java, +import org.elasticsearch.common.collect.Tuple;, +    // a parsing function that requires a non negative int and a timevalue as arguments split by a slash, +    // this allows you to easily define rates, +    static final Function<String, Tuple<Integer, TimeValue>> MAX_COMPILATION_RATE_FUNCTION =, +            (String value) -> {, +                if (value.contains("/") == false || value.startsWith("/") || value.endsWith("/")) {, +                    throw new IllegalArgumentException("parameter must contain a positive integer and a timevalue, i.e. 10/1m, but was [" +, +                            value + "]");, +                }, +                int idx = value.indexOf("/");, +                String count = value.substring(0, idx);, +                String time = value.substring(idx + 1);, +                try {, +, +                    int rate = Integer.parseInt(count);]