[+++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/Def.java, +             // user written method, +             int arity = interfaceMethod.arguments.size() + captures.length;, +             final MethodHandle handle;, +             try {, +                 MethodHandle accessor = lookup.findStaticGetter(lookup.lookupClass(), , +                                                                 "handle$" + call + "$" + arity, , +                                                                 MethodHandle.class);, +                 handle = (MethodHandle) accessor.invokeExact();, +             } catch (NoSuchFieldException | IllegalAccessException e) {, +                 throw new IllegalArgumentException("Unknown call [" + call + "] with [" + arity + "] arguments.");, +             } catch (Throwable t) {, +                 rethrow(t);, +                 throw new AssertionError();, +             }, +             ref = new FunctionRef(clazz, interfaceMethod, handle, captures);, +++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/Def.java, +             // user written method, +             int arity = interfaceMethod.arguments.size() + captures.length;, +             final MethodHandle handle;, +             try {, +                 MethodHandle accessor = lookup.findStaticGetter(lookup.lookupClass(), , +                                                                 "handle$" + call + "$" + arity, , +                                                                 MethodHandle.class);, +                 handle = (MethodHandle) accessor.invokeExact();, +             } catch (NoSuchFieldException | IllegalAccessException e) {, +                 throw new IllegalArgumentException("Unknown call [" + call + "] with [" + arity + "] arguments.");, +             } catch (Throwable t) {, +                 rethrow(t);, +                 throw new AssertionError();, +             }, +             ref = new FunctionRef(clazz, interfaceMethod, handle, captures);, +++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/FunctionRef.java, +     * Creates a new FunctionRef (low level). , +     * <p>, +     * This will <b>not</b> set implMethodASM. It is for runtime use only., +     */, +    public FunctionRef(Definition.Type expected, Definition.Method method, MethodHandle impl, Class<?>... captures) {, +        // e.g. compareTo, +        invokedName = method.name;, +        // e.g. (Object)Comparator, +        invokedType = MethodType.methodType(expected.clazz, captures);, +        // e.g. (Object,Object)int, +        interfaceMethodType = method.getMethodType().dropParameterTypes(0, 1);, +, +        implMethod = impl;, +        , +        implMethodASM = null;, +        , +        // remove any prepended captured arguments for the 'natural' signature., +        samMethodType = impl.type().dropParameterTypes(0, captures.length);, +    }, +, +    /** , +++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/Def.java, +             // user written method, +             int arity = interfaceMethod.arguments.size() + captures.length;, +             final MethodHandle handle;, +             try {, +                 MethodHandle accessor = lookup.findStaticGetter(lookup.lookupClass(), , +                                                                 "handle$" + call + "$" + arity, , +                                                                 MethodHandle.class);, +                 handle = (MethodHandle) accessor.invokeExact();, +             } catch (NoSuchFieldException | IllegalAccessException e) {, +                 throw new IllegalArgumentException("Unknown call [" + call + "] with [" + arity + "] arguments.");, +             } catch (Throwable t) {, +                 rethrow(t);, +                 throw new AssertionError();, +             }, +             ref = new FunctionRef(clazz, interfaceMethod, handle, captures);, +++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/FunctionRef.java, +     * Creates a new FunctionRef (low level). , +     * <p>, +     * This will <b>not</b> set implMethodASM. It is for runtime use only., +     */, +    public FunctionRef(Definition.Type expected, Definition.Method method, MethodHandle impl, Class<?>... captures) {, +        // e.g. compareTo, +        invokedName = method.name;, +        // e.g. (Object)Comparator, +        invokedType = MethodType.methodType(expected.clazz, captures);, +        // e.g. (Object,Object)int, +        interfaceMethodType = method.getMethodType().dropParameterTypes(0, 1);, +, +        implMethod = impl;, +        , +        implMethodASM = null;, +        , +        // remove any prepended captured arguments for the 'natural' signature., +        samMethodType = impl.type().dropParameterTypes(0, captures.length);, +    }, +, +    /** , +++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/EFunctionRef.java, +++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/Def.java, +             // user written method, +             int arity = interfaceMethod.arguments.size() + captures.length;, +             final MethodHandle handle;, +             try {, +                 MethodHandle accessor = lookup.findStaticGetter(lookup.lookupClass(), , +                                                                 "handle$" + call + "$" + arity, ]