[+++ b/src/main/java/org/elasticsearch/search/facet/FacetParseElement.java, +                            FacetParser facetParser = facetParsers.parser(fieldName);, +, +++ b/src/main/java/org/elasticsearch/search/facet/FacetParseElement.java, +                            FacetParser facetParser = facetParsers.parser(fieldName);, +, +++ b/src/main/java/org/elasticsearch/search/facet/FacetParsers.java, +    private final ImmutableMap<String, FacetParser> parsers;, +    public FacetParsers(Set<FacetParser> parsers) {, +        for (FacetParser parser : parsers) {, +            for (String type : parser.types()) {, +                builder.put(type, parser);, +        this.parsers = builder.immutableMap();, +    public FacetParser parser(String type) {, +        return parsers.get(type);, +++ b/src/main/java/org/elasticsearch/search/facet/FacetParseElement.java, +                            FacetParser facetParser = facetParsers.parser(fieldName);, +, +++ b/src/main/java/org/elasticsearch/search/facet/FacetParsers.java, +    private final ImmutableMap<String, FacetParser> parsers;, +    public FacetParsers(Set<FacetParser> parsers) {, +        for (FacetParser parser : parsers) {, +            for (String type : parser.types()) {, +                builder.put(type, parser);, +        this.parsers = builder.immutableMap();, +    public FacetParser parser(String type) {, +        return parsers.get(type);, +++ b/src/main/java/org/elasticsearch/search/facet/histogram/HistogramFacetParser.java, +                } else if ("time_interval".equals(fieldName) || "timeInterval".equals(fieldName)) {, +++ b/src/main/java/org/elasticsearch/search/facet/FacetParseElement.java, +                            FacetParser facetParser = facetParsers.parser(fieldName);, +, +++ b/src/main/java/org/elasticsearch/search/facet/FacetParsers.java, +    private final ImmutableMap<String, FacetParser> parsers;, +    public FacetParsers(Set<FacetParser> parsers) {, +        for (FacetParser parser : parsers) {, +            for (String type : parser.types()) {, +                builder.put(type, parser);, +        this.parsers = builder.immutableMap();, +    public FacetParser parser(String type) {, +        return parsers.get(type);, +++ b/src/main/java/org/elasticsearch/search/facet/histogram/HistogramFacetParser.java, +                } else if ("time_interval".equals(fieldName) || "timeInterval".equals(fieldName)) {, +++ b/src/main/java/org/elasticsearch/search/facet/range/RangeFacetParser.java, +                throw new FacetPhaseExecutionException(facetName, "No mapping found for value_field [" + valueField + "]");, +++ b/src/main/java/org/elasticsearch/search/facet/FacetParseElement.java, +                            FacetParser facetParser = facetParsers.parser(fieldName);, +, +++ b/src/main/java/org/elasticsearch/search/facet/FacetParsers.java, +    private final ImmutableMap<String, FacetParser> parsers;, +    public FacetParsers(Set<FacetParser> parsers) {, +        for (FacetParser parser : parsers) {, +            for (String type : parser.types()) {, +                builder.put(type, parser);, +        this.parsers = builder.immutableMap();, +    public FacetParser parser(String type) {, +        return parsers.get(type);, +++ b/src/main/java/org/elasticsearch/search/facet/histogram/HistogramFacetParser.java, +                } else if ("time_interval".equals(fieldName) || "timeInterval".equals(fieldName)) {, +++ b/src/main/java/org/elasticsearch/search/facet/range/RangeFacetParser.java, +                throw new FacetPhaseExecutionException(facetName, "No mapping found for value_field [" + valueField + "]");, +++ b/src/main/java/org/elasticsearch/search/facet/terms/TermsFacetParser.java, +import org.elasticsearch.search.facet.terms.unmapped.UnmappedFieldExecutor;, +import java.util.ArrayList;, +                } else if ("script_field".equals(currentFieldName) || "scriptField".equals(currentFieldName)) {, +, +            // in case of multi files, we only collect the fields that are mapped and facet on them., +            ArrayList<FieldMapper> mappers = new ArrayList<FieldMapper>(fieldsNames.length);, +            for (int i = 0; i < fieldsNames.length; i++) {, +                FieldMapper mapper = context.smartNameFieldMapper(fieldsNames[i]);, +                if (mapper != null) {, +                    mappers.add(mapper);, +                }, +            }, +            if (mappers.isEmpty()) {, +                // non of the fields is mapped, +                return new UnmappedFieldExecutor(size, comparatorType);, +            }, +            return new FieldsTermsStringFacetExecutor(facetName, mappers.toArray(new FieldMapper[mappers.size()]), size, comparatorType, allTerms, context, excluded, pattern, searchScript);, +            return new UnmappedFieldExecutor(size, comparatorType);, +++ b/src/main/java/org/elasticsearch/search/facet/FacetParseElement.java, +                            FacetParser facetParser = facetParsers.parser(fieldName);, +, +++ b/src/main/java/org/elasticsearch/search/facet/FacetParsers.java, +    private final ImmutableMap<String, FacetParser> parsers;, +    public FacetParsers(Set<FacetParser> parsers) {, +        for (FacetParser parser : parsers) {, +            for (String type : parser.types()) {, +                builder.put(type, parser);, +        this.parsers = builder.immutableMap();, +    public FacetParser parser(String type) {, +        return parsers.get(type);, +++ b/src/main/java/org/elasticsearch/search/facet/histogram/HistogramFacetParser.java, +                } else if ("time_interval".equals(fieldName) || "timeInterval".equals(fieldName)) {, +++ b/src/main/java/org/elasticsearch/search/facet/range/RangeFacetParser.java, +                throw new FacetPhaseExecutionException(facetName, "No mapping found for value_field [" + valueField + "]");, +++ b/src/main/java/org/elasticsearch/search/facet/terms/TermsFacetParser.java, +import org.elasticsearch.search.facet.terms.unmapped.UnmappedFieldExecutor;, +import java.util.ArrayList;, +                } else if ("script_field".equals(currentFieldName) || "scriptField".equals(currentFieldName)) {]