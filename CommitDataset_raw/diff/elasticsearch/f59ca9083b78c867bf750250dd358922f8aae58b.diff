[+++ b/core/src/main/java/org/elasticsearch/common/blobstore/fs/FsBlobContainer.java, +import java.nio.file.FileVisitResult;, +import java.nio.file.SimpleFileVisitor;, +        if (Files.isDirectory(blobPath)) {, +            // delete directory recursively as long as it is empty (only contains empty directories),, +            // which is the reason we aren't deleting any files, only the directories on the post-visit, +            Files.walkFileTree(blobPath, new SimpleFileVisitor<Path>() {, +                @Override, +                public FileVisitResult postVisitDirectory(Path dir, IOException exc) throws IOException {, +                    Files.delete(dir);, +                    return FileVisitResult.CONTINUE;, +                }, +            });, +        } else {, +    }, +++ b/core/src/main/java/org/elasticsearch/common/blobstore/fs/FsBlobContainer.java, +import java.nio.file.FileVisitResult;, +import java.nio.file.SimpleFileVisitor;, +        if (Files.isDirectory(blobPath)) {, +            // delete directory recursively as long as it is empty (only contains empty directories),, +            // which is the reason we aren't deleting any files, only the directories on the post-visit, +            Files.walkFileTree(blobPath, new SimpleFileVisitor<Path>() {, +                @Override, +                public FileVisitResult postVisitDirectory(Path dir, IOException exc) throws IOException {, +                    Files.delete(dir);, +                    return FileVisitResult.CONTINUE;, +                }, +            });, +        } else {, +    }, +++ b/core/src/main/java/org/elasticsearch/repositories/IndexId.java, +    private final int hashCode;, +        this.hashCode = computeHashCode();, +, +        this.hashCode = computeHashCode();, +        return hashCode;, +    }, +, +    private int computeHashCode() {, +++ b/core/src/main/java/org/elasticsearch/common/blobstore/fs/FsBlobContainer.java, +import java.nio.file.FileVisitResult;, +import java.nio.file.SimpleFileVisitor;, +        if (Files.isDirectory(blobPath)) {, +            // delete directory recursively as long as it is empty (only contains empty directories),, +            // which is the reason we aren't deleting any files, only the directories on the post-visit, +            Files.walkFileTree(blobPath, new SimpleFileVisitor<Path>() {, +                @Override, +                public FileVisitResult postVisitDirectory(Path dir, IOException exc) throws IOException {, +                    Files.delete(dir);, +                    return FileVisitResult.CONTINUE;, +                }, +            });, +        } else {, +    }, +++ b/core/src/main/java/org/elasticsearch/repositories/IndexId.java, +    private final int hashCode;, +        this.hashCode = computeHashCode();, +, +        this.hashCode = computeHashCode();, +        return hashCode;, +    }, +, +    private int computeHashCode() {, +++ b/core/src/main/java/org/elasticsearch/repositories/blobstore/BlobStoreRepository.java, +import java.nio.file.DirectoryNotEmptyException;, +            final RepositoryData updatedRepositoryData = repositoryData.removeSnapshot(snapshotId);, +            writeIndexGen(updatedRepositoryData);, +, +            // cleanup indices that are no longer part of the repository, +            final Collection<IndexId> indicesToCleanUp = Sets.newHashSet(repositoryData.getIndices().values());, +            indicesToCleanUp.removeAll(updatedRepositoryData.getIndices().values());, +            final BlobContainer indicesBlobContainer = blobStore().blobContainer(basePath().add("indices"));, +            for (final IndexId indexId : indicesToCleanUp) {, +                try {, +                    indicesBlobContainer.deleteBlob(indexId.getId());, +                } catch (DirectoryNotEmptyException dnee) {, +                    // if the directory isn't empty for some reason, it will fail to clean up;, +                    // we'll ignore that and accept that cleanup didn't fully succeed., +                    // since we are using UUIDs for path names, this won't be an issue for, +                    // snapshotting indices of the same name, +                    logger.debug("[{}] index [{}] no longer part of any snapshots in the repository, but failed to clean up " +, +                                 "its index folder due to the directory not being empty.", dnee, metadata.name(), indexId);, +                } catch (IOException ioe) {, +                    // a different IOException occurred while trying to delete - will just log the issue for now, +                    logger.debug("[{}] index [{}] no longer part of any snapshots in the repository, but failed to clean up " +, +                                 "its index folder.", ioe, metadata.name(), indexId);, +                }, +            }, +++ b/core/src/main/java/org/elasticsearch/common/blobstore/fs/FsBlobContainer.java, +import java.nio.file.FileVisitResult;, +import java.nio.file.SimpleFileVisitor;, +        if (Files.isDirectory(blobPath)) {, +            // delete directory recursively as long as it is empty (only contains empty directories),, +            // which is the reason we aren't deleting any files, only the directories on the post-visit, +            Files.walkFileTree(blobPath, new SimpleFileVisitor<Path>() {, +                @Override, +                public FileVisitResult postVisitDirectory(Path dir, IOException exc) throws IOException {, +                    Files.delete(dir);, +                    return FileVisitResult.CONTINUE;, +                }]