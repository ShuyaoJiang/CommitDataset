[+++ b/TESTING.asciidoc, +run it using Gradle:, +  -Dtests.class=org.elasticsearch.test.rest.*Yaml*IT, +  -Dtests.class=org.elasticsearch.test.rest.*Yaml*IT \, +`*Yaml*IT` are the executable test classes that runs all the, +destructive. When working with a single package it's generally faster to run its, +tests in a tighter loop than gradle provides. In one window:, +++ b/TESTING.asciidoc, +run it using Gradle:, +  -Dtests.class=org.elasticsearch.test.rest.*Yaml*IT, +  -Dtests.class=org.elasticsearch.test.rest.*Yaml*IT \, +`*Yaml*IT` are the executable test classes that runs all the, +destructive. When working with a single package it's generally faster to run its, +tests in a tighter loop than gradle provides. In one window:, +++ b/buildSrc/src/main/groovy/org/elasticsearch/gradle/BuildPlugin.groovy, +++ b/TESTING.asciidoc, +run it using Gradle:, +  -Dtests.class=org.elasticsearch.test.rest.*Yaml*IT, +  -Dtests.class=org.elasticsearch.test.rest.*Yaml*IT \, +`*Yaml*IT` are the executable test classes that runs all the, +destructive. When working with a single package it's generally faster to run its, +tests in a tighter loop than gradle provides. In one window:, +++ b/buildSrc/src/main/groovy/org/elasticsearch/gradle/BuildPlugin.groovy, +++ b/buildSrc/src/main/groovy/org/elasticsearch/gradle/plugin/PluginBuildPlugin.groovy, +                addClientJarPomGeneration(project), +    protected static void addClientJarPomGeneration(Project project) {, +                    artifactId = artifactId + '-client', +++ b/TESTING.asciidoc, +run it using Gradle:, +  -Dtests.class=org.elasticsearch.test.rest.*Yaml*IT, +  -Dtests.class=org.elasticsearch.test.rest.*Yaml*IT \, +`*Yaml*IT` are the executable test classes that runs all the, +destructive. When working with a single package it's generally faster to run its, +tests in a tighter loop than gradle provides. In one window:, +++ b/buildSrc/src/main/groovy/org/elasticsearch/gradle/BuildPlugin.groovy, +++ b/buildSrc/src/main/groovy/org/elasticsearch/gradle/plugin/PluginBuildPlugin.groovy, +                addClientJarPomGeneration(project), +    protected static void addClientJarPomGeneration(Project project) {, +                    artifactId = artifactId + '-client', +++ b/buildSrc/src/main/resources/checkstyle_suppressions.xml, +  <suppress files="core[/\\]src[/\\]test[/\\]java[/\\]org[/\\]elasticsearch[/\\]action[/\\]support[/\\]WaitActiveShardCountIT.java" checks="LineLength" />, +++ b/TESTING.asciidoc, +run it using Gradle:, +  -Dtests.class=org.elasticsearch.test.rest.*Yaml*IT, +  -Dtests.class=org.elasticsearch.test.rest.*Yaml*IT \, +`*Yaml*IT` are the executable test classes that runs all the, +destructive. When working with a single package it's generally faster to run its, +tests in a tighter loop than gradle provides. In one window:, +++ b/buildSrc/src/main/groovy/org/elasticsearch/gradle/BuildPlugin.groovy, +++ b/buildSrc/src/main/groovy/org/elasticsearch/gradle/plugin/PluginBuildPlugin.groovy, +                addClientJarPomGeneration(project), +    protected static void addClientJarPomGeneration(Project project) {, +                    artifactId = artifactId + '-client', +++ b/buildSrc/src/main/resources/checkstyle_suppressions.xml, +  <suppress files="core[/\\]src[/\\]test[/\\]java[/\\]org[/\\]elasticsearch[/\\]action[/\\]support[/\\]WaitActiveShardCountIT.java" checks="LineLength" />, +++ b/buildSrc/src/main/resources/forbidden/jdk-signatures.txt, +@defaultMessage Stopping threads explicitly leads to inconsistent states. Use interrupt() instead., +java.lang.Thread#stop(), +java.lang.Thread#stop(java.lang.Throwable), +, +++ b/TESTING.asciidoc, +run it using Gradle:, +  -Dtests.class=org.elasticsearch.test.rest.*Yaml*IT, +  -Dtests.class=org.elasticsearch.test.rest.*Yaml*IT \, +`*Yaml*IT` are the executable test classes that runs all the, +destructive. When working with a single package it's generally faster to run its, +tests in a tighter loop than gradle provides. In one window:, +++ b/buildSrc/src/main/groovy/org/elasticsearch/gradle/BuildPlugin.groovy, +++ b/buildSrc/src/main/groovy/org/elasticsearch/gradle/plugin/PluginBuildPlugin.groovy, +                addClientJarPomGeneration(project), +    protected static void addClientJarPomGeneration(Project project) {, +                    artifactId = artifactId + '-client', +++ b/buildSrc/src/main/resources/checkstyle_suppressions.xml, +  <suppress files="core[/\\]src[/\\]test[/\\]java[/\\]org[/\\]elasticsearch[/\\]action[/\\]support[/\\]WaitActiveShardCountIT.java" checks="LineLength" />, +++ b/buildSrc/src/main/resources/forbidden/jdk-signatures.txt, +@defaultMessage Stopping threads explicitly leads to inconsistent states. Use interrupt() instead., +java.lang.Thread#stop(), +java.lang.Thread#stop(java.lang.Throwable), +, +++ b/client/benchmark/README.md, +3. Build an uberjar with `gradle :client:benchmark:shadowJar` and execute it., +rest 192.168.2.2 /home/your_user_name/.rally/benchmarks/data/geonames/documents.json geonames type 8647880 5000 "{ \"query\": { \"match_phrase\": { \"name\": \"Sankt Georgen\" } } }\"", +* Client type: Use either "rest" or "transport", +++ b/TESTING.asciidoc, +run it using Gradle:, +  -Dtests.class=org.elasticsearch.test.rest.*Yaml*IT, +  -Dtests.class=org.elasticsearch.test.rest.*Yaml*IT \, +`*Yaml*IT` are the executable test classes that runs all the, +destructive. When working with a single package it's generally faster to run its, +tests in a tighter loop than gradle provides. In one window:, +++ b/buildSrc/src/main/groovy/org/elasticsearch/gradle/BuildPlugin.groovy, +++ b/buildSrc/src/main/groovy/org/elasticsearch/gradle/plugin/PluginBuildPlugin.groovy, +                addClientJarPomGeneration(project), +    protected static void addClientJarPomGeneration(Project project) {, +                    artifactId = artifactId + '-client', +++ b/buildSrc/src/main/resources/checkstyle_suppressions.xml, +  <suppress files="core[/\\]src[/\\]test[/\\]java[/\\]org[/\\]elasticsearch[/\\]action[/\\]support[/\\]WaitActiveShardCountIT.java" checks="LineLength" />, +++ b/buildSrc/src/main/resources/forbidden/jdk-signatures.txt, +@defaultMessage Stopping threads explicitly leads to inconsistent states. Use interrupt() instead., +java.lang.Thread#stop()]