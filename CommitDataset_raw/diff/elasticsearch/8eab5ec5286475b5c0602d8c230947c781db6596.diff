[+++ b/modules/elasticsearch/src/main/java/org/elasticsearch/common/lab/LongsLAB.java, +/*, + * Licensed to Elastic Search and Shay Banon under one, + * or more contributor license agreements.  See the NOTICE file, + * distributed with this work for additional information, + * regarding copyright ownership. Elastic Search licenses this, + * file to you under the Apache License, Version 2.0 (the, + * "License"); you may not use this file except in compliance, + * with the License.  You may obtain a copy of the License at, + *, + *    http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing,, + * software distributed under the License is distributed on an, + * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY, + * KIND, either express or implied.  See the License for the, + * specific language governing permissions and limitations, + * under the License., + */, +, +package org.elasticsearch.common.lab;, +, +import org.elasticsearch.common.Preconditions;, +, +import java.util.concurrent.atomic.AtomicInteger;, +import java.util.concurrent.atomic.AtomicReference;, +, +public class LongsLAB {, +, +    private AtomicReference<Chunk> curChunk = new AtomicReference<Chunk>();, +, +    final int chunkSize;, +    final int maxAlloc;, +, +    public LongsLAB(int chunkSize, int maxAlloc) {, +        this.chunkSize = chunkSize;, +        this.maxAlloc = maxAlloc;, +        // if we don't exclude allocations >CHUNK_SIZE, we'd infiniteloop on one!, +        Preconditions.checkArgument(maxAlloc <= chunkSize);, +    }, +, +    /**, +     * Allocate a slice of the given length., +     *, +     * If the size is larger than the maximum size specified for this, +     * allocator, returns null., +     */, +    public Allocation allocateLongs(int size) {, +        Preconditions.checkArgument(size >= 0, "negative size");, +, +        // Callers should satisfy large allocations directly from JVM since they, +        // don't cause fragmentation as badly., +        if (size > maxAlloc) {, +            return null;, +        }, +, +        while (true) {, +            Chunk c = getOrMakeChunk();, +, +            // Try to allocate from this chunk, +            int allocOffset = c.alloc(size);, +            if (allocOffset != -1) {, +                // We succeeded - this is the common case - small alloc, +                // from a big buffer, +                return new Allocation(c.data, allocOffset);, +            }, +, +            // not enough space!, +            // try to retire this chunk, +            tryRetireChunk(c);, +        }, +    }, +, +    /**, +     * Try to retire the current chunk if it is still, +     * <code>c</code>. Postcondition is that curChunk.get(), +     * != c, +     */, +    private void tryRetireChunk(Chunk c) {, +        @SuppressWarnings("unused"), +        boolean weRetiredIt = curChunk.compareAndSet(c, null);, +        // If the CAS succeeds, that means that we won the race, +        // to retire the chunk. We could use this opportunity to, +        // update metrics on external fragmentation., +        //, +        // If the CAS fails, that means that someone else already, +        // retired the chunk for us., +    }, +, +    /**, +     * Get the current chunk, or, if there is no current chunk,, +     * allocate a new one from the JVM., +     */, +    private Chunk getOrMakeChunk() {, +        while (true) {, +            // Try to get the chunk, +            Chunk c = curChunk.get();, +            if (c != null) {, +                return c;, +            }]