[+++ b/src/main/java/org/elasticsearch/discovery/zen/ZenDiscovery.java, +        nodesFD.updateNodesAndPing(clusterState);, +                        nodesFD.updateNodesAndPing(newState); // start the nodes FD, +                    nodesFD.updateNodesAndPing(newState);, +++ b/src/main/java/org/elasticsearch/discovery/zen/ZenDiscovery.java, +        nodesFD.updateNodesAndPing(clusterState);, +                        nodesFD.updateNodesAndPing(newState); // start the nodes FD, +                    nodesFD.updateNodesAndPing(newState);, +++ b/src/main/java/org/elasticsearch/discovery/zen/fd/NodesFaultDetection.java, +    private volatile DiscoveryNode localNode;, +    /**, +     * make sure that nodes in clusterState are pinged. Any pinging to nodes which are not, +     * part of the cluster will be stopped, +     */, +    public void updateNodesAndPing(ClusterState clusterState) {, +        // remove any nodes we don't need, this will cause their FD to stop, +        for (DiscoveryNode monitoredNode : nodesFD.keySet()) {, +            if (!clusterState.nodes().nodeExists(monitoredNode.id())) {, +                nodesFD.remove(monitoredNode);, +        }, +        // add any missing nodes, +, +        for (DiscoveryNode node : clusterState.nodes()) {, +            if (node.equals(localNode)) {, +            if (!nodesFD.containsKey(node)) {, +                NodeFD fd = new NodeFD(node);, +                // it's OK to overwrite an existing nodeFD - it will just stop and the new one will pick things up., +                nodesFD.put(node, fd);, +                threadPool.schedule(TimeValue.timeValueMillis(0), ThreadPool.Names.SAME, fd);, +    /** stops all pinging **/, +        nodesFD.clear();, +            NodeFD fd = new NodeFD(node);, +                nodesFD.put(node, fd);, +                threadPool.schedule(TimeValue.timeValueMillis(0), ThreadPool.Names.SAME, fd);, +                // clean up if needed, just to be safe.., +                nodesFD.remove(node, fd);, +, +    private class NodeFD implements Runnable {, +        volatile int retryCount;, +        private NodeFD(DiscoveryNode node) {, +        private boolean running() {, +            return NodeFD.this.equals(nodesFD.get(node));, +        }, +, +            if (!running()) {, +                            if (!running()) {, +                            retryCount = 0;, +                            threadPool.schedule(pingInterval, ThreadPool.Names.SAME, NodeFD.this);, +                            if (!running()) {, +                            retryCount++;, +                                if (nodesFD.remove(node, NodeFD.this)) {, +++ b/src/main/java/org/elasticsearch/discovery/zen/ZenDiscovery.java, +        nodesFD.updateNodesAndPing(clusterState);, +                        nodesFD.updateNodesAndPing(newState); // start the nodes FD, +                    nodesFD.updateNodesAndPing(newState);, +++ b/src/main/java/org/elasticsearch/discovery/zen/fd/NodesFaultDetection.java, +    private volatile DiscoveryNode localNode;, +    /**, +     * make sure that nodes in clusterState are pinged. Any pinging to nodes which are not, +     * part of the cluster will be stopped, +     */, +    public void updateNodesAndPing(ClusterState clusterState) {, +        // remove any nodes we don't need, this will cause their FD to stop, +        for (DiscoveryNode monitoredNode : nodesFD.keySet()) {, +            if (!clusterState.nodes().nodeExists(monitoredNode.id())) {, +                nodesFD.remove(monitoredNode);, +        }, +        // add any missing nodes, +, +        for (DiscoveryNode node : clusterState.nodes()) {, +            if (node.equals(localNode)) {, +            if (!nodesFD.containsKey(node)) {, +                NodeFD fd = new NodeFD(node);, +                // it's OK to overwrite an existing nodeFD - it will just stop and the new one will pick things up., +                nodesFD.put(node, fd);, +                threadPool.schedule(TimeValue.timeValueMillis(0), ThreadPool.Names.SAME, fd);, +    /** stops all pinging **/, +        nodesFD.clear();, +            NodeFD fd = new NodeFD(node);, +                nodesFD.put(node, fd);, +                threadPool.schedule(TimeValue.timeValueMillis(0), ThreadPool.Names.SAME, fd);, +                // clean up if needed, just to be safe.., +                nodesFD.remove(node, fd);, +, +    private class NodeFD implements Runnable {, +        volatile int retryCount;, +        private NodeFD(DiscoveryNode node) {, +        private boolean running() {, +            return NodeFD.this.equals(nodesFD.get(node));, +        }, +, +            if (!running()) {, +                            if (!running()) {, +                            retryCount = 0;, +                            threadPool.schedule(pingInterval, ThreadPool.Names.SAME, NodeFD.this);, +                            if (!running()) {, +                            retryCount++;, +                                if (nodesFD.remove(node, NodeFD.this)) {, +++ b/src/test/java/org/elasticsearch/discovery/DiscoveryWithServiceDisruptions.java, +]