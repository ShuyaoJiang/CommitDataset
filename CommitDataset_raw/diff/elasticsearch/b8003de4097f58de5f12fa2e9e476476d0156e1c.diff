[+++ b/core/src/main/java/org/elasticsearch/search/SearchModule.java, +import org.elasticsearch.search.aggregations.pipeline.bucketscript.BucketScriptPipelineAggregatorBuilder;, +import org.elasticsearch.search.aggregations.pipeline.bucketselector.BucketSelectorPipelineAggregatorBuilder;, +        registerPipelineAggregation(BucketScriptPipelineAggregatorBuilder::new, BucketScriptPipelineAggregatorBuilder::parse,, +                BucketScriptPipelineAggregatorBuilder.AGGREGATION_NAME_FIELD);, +        registerPipelineAggregation(BucketSelectorPipelineAggregatorBuilder::new, BucketSelectorPipelineAggregatorBuilder::parse,, +                BucketSelectorPipelineAggregatorBuilder.AGGREGATION_NAME_FIELD);, +++ b/core/src/main/java/org/elasticsearch/search/SearchModule.java, +import org.elasticsearch.search.aggregations.pipeline.bucketscript.BucketScriptPipelineAggregatorBuilder;, +import org.elasticsearch.search.aggregations.pipeline.bucketselector.BucketSelectorPipelineAggregatorBuilder;, +        registerPipelineAggregation(BucketScriptPipelineAggregatorBuilder::new, BucketScriptPipelineAggregatorBuilder::parse,, +                BucketScriptPipelineAggregatorBuilder.AGGREGATION_NAME_FIELD);, +        registerPipelineAggregation(BucketSelectorPipelineAggregatorBuilder::new, BucketSelectorPipelineAggregatorBuilder::parse,, +                BucketSelectorPipelineAggregatorBuilder.AGGREGATION_NAME_FIELD);, +++ /dev/null, +++ b/core/src/main/java/org/elasticsearch/search/SearchModule.java, +import org.elasticsearch.search.aggregations.pipeline.bucketscript.BucketScriptPipelineAggregatorBuilder;, +import org.elasticsearch.search.aggregations.pipeline.bucketselector.BucketSelectorPipelineAggregatorBuilder;, +        registerPipelineAggregation(BucketScriptPipelineAggregatorBuilder::new, BucketScriptPipelineAggregatorBuilder::parse,, +                BucketScriptPipelineAggregatorBuilder.AGGREGATION_NAME_FIELD);, +        registerPipelineAggregation(BucketSelectorPipelineAggregatorBuilder::new, BucketSelectorPipelineAggregatorBuilder::parse,, +                BucketSelectorPipelineAggregatorBuilder.AGGREGATION_NAME_FIELD);, +++ /dev/null, +++ b/core/src/main/java/org/elasticsearch/search/aggregations/pipeline/bucketscript/BucketScriptPipelineAggregatorBuilder.java, +import org.elasticsearch.common.ParseField;, +import org.elasticsearch.common.ParsingException;, +import org.elasticsearch.common.xcontent.XContentParser;, +import org.elasticsearch.index.query.QueryParseContext;, +import org.elasticsearch.search.DocValueFormat;, +import java.util.ArrayList;, +import java.util.List;, +import static org.elasticsearch.search.aggregations.pipeline.PipelineAggregator.Parser.BUCKETS_PATH;, +import static org.elasticsearch.search.aggregations.pipeline.PipelineAggregator.Parser.FORMAT;, +import static org.elasticsearch.search.aggregations.pipeline.PipelineAggregator.Parser.GAP_POLICY;, +public class BucketScriptPipelineAggregatorBuilder extends PipelineAggregatorBuilder<BucketScriptPipelineAggregatorBuilder> {, +    public static final String NAME = BucketScriptPipelineAggregator.TYPE.name();, +    public static final ParseField AGGREGATION_NAME_FIELD = new ParseField(NAME);, +    /**, +     * Read from a stream., +     */, +    public BucketScriptPipelineAggregatorBuilder(StreamInput in) throws IOException {, +        super(in, BucketScriptPipelineAggregator.TYPE.name());, +        int mapSize = in.readVInt();, +        bucketsPathsMap = new HashMap<String, String>(mapSize);, +        for (int i = 0; i < mapSize; i++) {, +            bucketsPathsMap.put(in.readString(), in.readString());, +        }, +        script = Script.readScript(in);, +        format = in.readOptionalString();, +        gapPolicy = GapPolicy.readFrom(in);, +    }, +, +    @Override, +    protected void doWriteTo(StreamOutput out) throws IOException {, +        out.writeVInt(bucketsPathsMap.size());, +        for (Entry<String, String> e : bucketsPathsMap.entrySet()) {, +            out.writeString(e.getKey());, +            out.writeString(e.getValue());, +        }, +        script.writeTo(out);, +        out.writeOptionalString(format);, +        gapPolicy.writeTo(out);, +    }, +, +    @Override, +    protected boolean usesNewStyleSerialization() {, +        return true;, +    }, +, +        builder.field(BUCKETS_PATH.getPreferredName(), bucketsPathsMap);, +            builder.field(FORMAT.getPreferredName(), format);, +        builder.field(GAP_POLICY.getPreferredName(), gapPolicy.getName());, +    public static BucketScriptPipelineAggregatorBuilder parse(String reducerName, QueryParseContext context) throws IOException {, +        XContentParser parser = context.parser();, +        XContentParser.Token token;, +        Script script = null;, +        String currentFieldName = null;, +        Map<String, String> bucketsPathsMap = null;, +        String format = null;, +        GapPolicy gapPolicy = null;, +, +        while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {, +            if (token == XContentParser.Token.FIELD_NAME) {, +                currentFieldName = parser.currentName();, +            } else if (token == XContentParser.Token.VALUE_STRING) {, +                if (context.getParseFieldMatcher().match(currentFieldName, FORMAT)) {, +                    format = parser.text();, +                } else if (context.getParseFieldMatcher().match(currentFieldName, BUCKETS_PATH)) {, +                    bucketsPathsMap = new HashMap<>();, +                    bucketsPathsMap.put("_value", parser.text());, +                } else if (context.getParseFieldMatcher().match(currentFieldName, GAP_POLICY)) {, +                    gapPolicy = GapPolicy.parse(context, parser.text(), parser.getTokenLocation());, +                } else if (context.getParseFieldMatcher().match(currentFieldName, ScriptField.SCRIPT)) {, +                    script = Script.parse(parser, context.getParseFieldMatcher());, +                } else {, +                    throw new ParsingException(parser.getTokenLocation(),, +                            "Unknown key for a " + token + " in [" + reducerName + "]: [" + currentFieldName + "].");, +                }, +            } else if (token == XContentParser.Token.START_ARRAY) {, +                if (context.getParseFieldMatcher().match(currentFieldName, BUCKETS_PATH)) {]