[+++ b/server/src/test/java/org/elasticsearch/discovery/AbstractDisruptionTestCase.java, +            internalCluster().assertSeqNos();, +            internalCluster().assertSameDocIdsOnShards();, +++ b/server/src/test/java/org/elasticsearch/discovery/AbstractDisruptionTestCase.java, +            internalCluster().assertSeqNos();, +            internalCluster().assertSameDocIdsOnShards();, +++ b/server/src/test/java/org/elasticsearch/recovery/RelocationIT.java, +        internalCluster().assertSeqNos();, +        internalCluster().assertSameDocIdsOnShards();, +++ b/server/src/test/java/org/elasticsearch/discovery/AbstractDisruptionTestCase.java, +            internalCluster().assertSeqNos();, +            internalCluster().assertSameDocIdsOnShards();, +++ b/server/src/test/java/org/elasticsearch/recovery/RelocationIT.java, +        internalCluster().assertSeqNos();, +        internalCluster().assertSameDocIdsOnShards();, +++ b/test/framework/src/main/java/org/elasticsearch/test/ESIntegTestCase.java, +++ b/server/src/test/java/org/elasticsearch/discovery/AbstractDisruptionTestCase.java, +            internalCluster().assertSeqNos();, +            internalCluster().assertSameDocIdsOnShards();, +++ b/server/src/test/java/org/elasticsearch/recovery/RelocationIT.java, +        internalCluster().assertSeqNos();, +        internalCluster().assertSameDocIdsOnShards();, +++ b/test/framework/src/main/java/org/elasticsearch/test/ESIntegTestCase.java, +++ b/test/framework/src/main/java/org/elasticsearch/test/InternalTestCluster.java, +import com.carrotsearch.hppc.ObjectLongMap;, +import com.carrotsearch.hppc.cursors.IntObjectCursor;, +import com.carrotsearch.hppc.cursors.ObjectObjectCursor;, +import org.elasticsearch.cluster.routing.IndexRoutingTable;, +import org.elasticsearch.cluster.routing.IndexShardRoutingTable;, +import org.elasticsearch.index.engine.DocIdSeqNoAndTerm;, +import org.elasticsearch.index.seqno.SeqNoStats;, +import org.elasticsearch.index.seqno.SequenceNumbers;, +import java.util.function.BiFunction;, +import static org.hamcrest.Matchers.not;, +    public void assertSeqNos() throws Exception {, +        final BiFunction<ClusterState, ShardRouting, IndexShard> getInstanceShardInstance = (clusterState, shardRouting) -> {, +            if (shardRouting.assignedToNode() == false) {, +                return null;, +            }, +            final DiscoveryNode assignedNode = clusterState.nodes().get(shardRouting.currentNodeId());, +            if (assignedNode == null) {, +                return null;, +            }, +            return getInstance(IndicesService.class, assignedNode.getName()).getShardOrNull(shardRouting.shardId());, +        };, +        assertBusy(() -> {, +            final ClusterState state = clusterService().state();, +            for (ObjectObjectCursor<String, IndexRoutingTable> indexRoutingTable : state.routingTable().indicesRouting()) {, +                for (IntObjectCursor<IndexShardRoutingTable> indexShardRoutingTable : indexRoutingTable.value.shards()) {, +                    ShardRouting primaryShardRouting = indexShardRoutingTable.value.primaryShard();, +                    if (primaryShardRouting == null) {, +                        continue;, +                    }, +                    final IndexShard primaryShard = getInstanceShardInstance.apply(state, primaryShardRouting);, +                    if (primaryShard == null) {, +                        continue; //just ignore - shard movement, +                    }, +                    final SeqNoStats primarySeqNoStats;, +                    final ObjectLongMap<String> syncGlobalCheckpoints;, +                    try {, +                        primarySeqNoStats = primaryShard.seqNoStats();, +                        syncGlobalCheckpoints = primaryShard.getInSyncGlobalCheckpoints();, +                    } catch (AlreadyClosedException ex) {, +                        continue; // shard is closed - just ignore, +                    }, +                    assertThat(primaryShardRouting + " should have set the global checkpoint",, +                        primarySeqNoStats.getGlobalCheckpoint(), not(equalTo(SequenceNumbers.UNASSIGNED_SEQ_NO)));, +                    for (ShardRouting replicaShardRouting : indexShardRoutingTable.value.replicaShards()) {, +                        final IndexShard replicaShard = getInstanceShardInstance.apply(state, replicaShardRouting);, +                        if (replicaShard == null) {, +                            continue; //just ignore - shard movement, +                        }, +                        final SeqNoStats seqNoStats;, +                        try {, +                            seqNoStats = replicaShard.seqNoStats();, +                        } catch (AlreadyClosedException e) {, +                            continue; // shard is closed - just ignore, +                        }, +                        assertThat(replicaShardRouting + " local checkpoint mismatch",, +                            seqNoStats.getLocalCheckpoint(), equalTo(primarySeqNoStats.getLocalCheckpoint()));, +                        assertThat(replicaShardRouting + " global checkpoint mismatch",, +                            seqNoStats.getGlobalCheckpoint(), equalTo(primarySeqNoStats.getGlobalCheckpoint()));, +                        assertThat(replicaShardRouting + " max seq no mismatch",, +                            seqNoStats.getMaxSeqNo(), equalTo(primarySeqNoStats.getMaxSeqNo()));, +                        // the local knowledge on the primary of the global checkpoint equals the global checkpoint on the shard, +                        assertThat(replicaShardRouting + " global checkpoint syncs mismatch", seqNoStats.getGlobalCheckpoint(),, +                            equalTo(syncGlobalCheckpoints.get(replicaShardRouting.allocationId().getId())));, +                    }, +                }, +            }, +        });, +    }, +, +    /**, +     * Asserts that all shards with the same shardId should have document Ids., +     */, +    public void assertSameDocIdsOnShards() throws Exception {, +        assertBusy(() -> {, +            ClusterState state = client().admin().cluster().prepareState().get().getState();, +            for (ObjectObjectCursor<String, IndexRoutingTable> indexRoutingTable : state.routingTable().indicesRouting()) {]