[+++ b/core/src/main/java/org/elasticsearch/cluster/ClusterModule.java, +    private final ExtensionPoint.SelectedType<ShardsAllocator> shardsAllocators = new ExtensionPoint.SelectedType<>("shards_allocator", ShardsAllocator.class);, +    private final ExtensionPoint.ClassSet<AllocationDecider> allocationDeciders = new ExtensionPoint.ClassSet<>("allocation_decider", AllocationDecider.class, AllocationDeciders.class);, +    private final ExtensionPoint.ClassSet<IndexTemplateFilter> indexTemplateFilters = new ExtensionPoint.ClassSet<>("index_template_filter", IndexTemplateFilter.class);, +++ b/core/src/main/java/org/elasticsearch/cluster/ClusterModule.java, +    private final ExtensionPoint.SelectedType<ShardsAllocator> shardsAllocators = new ExtensionPoint.SelectedType<>("shards_allocator", ShardsAllocator.class);, +    private final ExtensionPoint.ClassSet<AllocationDecider> allocationDeciders = new ExtensionPoint.ClassSet<>("allocation_decider", AllocationDecider.class, AllocationDeciders.class);, +    private final ExtensionPoint.ClassSet<IndexTemplateFilter> indexTemplateFilters = new ExtensionPoint.ClassSet<>("index_template_filter", IndexTemplateFilter.class);, +++ b/core/src/main/java/org/elasticsearch/common/geo/ShapesAvailability.java, +    private ShapesAvailability() {}, +++ b/core/src/main/java/org/elasticsearch/cluster/ClusterModule.java, +    private final ExtensionPoint.SelectedType<ShardsAllocator> shardsAllocators = new ExtensionPoint.SelectedType<>("shards_allocator", ShardsAllocator.class);, +    private final ExtensionPoint.ClassSet<AllocationDecider> allocationDeciders = new ExtensionPoint.ClassSet<>("allocation_decider", AllocationDecider.class, AllocationDeciders.class);, +    private final ExtensionPoint.ClassSet<IndexTemplateFilter> indexTemplateFilters = new ExtensionPoint.ClassSet<>("index_template_filter", IndexTemplateFilter.class);, +++ b/core/src/main/java/org/elasticsearch/common/geo/ShapesAvailability.java, +    private ShapesAvailability() {}, +++ b/core/src/main/java/org/elasticsearch/common/inject/spi/ProviderLookup.java, +, +    // NOTE: this class is not part of guice and was added so the provder lookup's key can be acessible for tests, +    public static class ProviderImpl<T> implements Provider<T> {, +        private ProviderLookup<T> lookup;, +, +        private ProviderImpl(ProviderLookup<T> lookup) {, +            this.lookup = lookup;, +        }, +, +        @Override, +        public T get() {, +            checkState(lookup.delegate != null,, +                "This Provider cannot be used until the Injector has been created.");, +            return lookup.delegate.get();, +        }, +, +        @Override, +        public String toString() {, +            return "Provider<" + lookup.key.getTypeLiteral() + ">";, +        }, +, +        public Key<T> getKey() {, +            return lookup.getKey();, +        }, +    }, +        return new ProviderImpl<>(this);, +++ b/core/src/main/java/org/elasticsearch/cluster/ClusterModule.java, +    private final ExtensionPoint.SelectedType<ShardsAllocator> shardsAllocators = new ExtensionPoint.SelectedType<>("shards_allocator", ShardsAllocator.class);, +    private final ExtensionPoint.ClassSet<AllocationDecider> allocationDeciders = new ExtensionPoint.ClassSet<>("allocation_decider", AllocationDecider.class, AllocationDeciders.class);, +    private final ExtensionPoint.ClassSet<IndexTemplateFilter> indexTemplateFilters = new ExtensionPoint.ClassSet<>("index_template_filter", IndexTemplateFilter.class);, +++ b/core/src/main/java/org/elasticsearch/common/geo/ShapesAvailability.java, +    private ShapesAvailability() {}, +++ b/core/src/main/java/org/elasticsearch/common/inject/spi/ProviderLookup.java, +, +    // NOTE: this class is not part of guice and was added so the provder lookup's key can be acessible for tests, +    public static class ProviderImpl<T> implements Provider<T> {, +        private ProviderLookup<T> lookup;, +, +        private ProviderImpl(ProviderLookup<T> lookup) {, +            this.lookup = lookup;, +        }, +, +        @Override, +        public T get() {, +            checkState(lookup.delegate != null,, +                "This Provider cannot be used until the Injector has been created.");, +            return lookup.delegate.get();, +        }, +, +        @Override, +        public String toString() {, +            return "Provider<" + lookup.key.getTypeLiteral() + ">";, +        }, +, +        public Key<T> getKey() {, +            return lookup.getKey();, +        }, +    }, +        return new ProviderImpl<>(this);, +++ b/core/src/main/java/org/elasticsearch/common/util/ExtensionPoint.java, +public abstract class ExtensionPoint {, +    public ExtensionPoint(String name, Class<?>... singletons) {, +     * Subclasses can bind their type, map or set extensions here., +    public static class ClassMap<T> extends ExtensionPoint {, +        protected final Class<T> extensionClass;, +         * Creates a new {@link ClassMap}, +        public ClassMap(String name, Class<T> extensionClass, Set<String> reservedKeys, Class<?>... singletons) {, +            super(name, singletons);, +            this.extensionClass = extensionClass;, +     * A Type extension point which basically allows to registerd keyed extensions like {@link ClassMap}, +    public static final class SelectedType<T> extends ClassMap<T> {, +        public SelectedType(String name, Class<T> extensionClass) {, +    public final static class ClassSet<T> extends ExtensionPoint {, +        protected final Class<T> extensionClass;, +         * Creates a new {@link ClassSet}, +        public ClassSet(String name, Class<T> extensionClass, Class<?>... singletons) {, +            super(name, singletons);, +            this.extensionClass = extensionClass;, +, +    /**, +     * A an instance of a map, mapping one instance value to another. Both key and value are instances, not classes, +     * like with other extension points., +     */]