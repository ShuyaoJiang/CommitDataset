[+++ b/server/src/main/java/org/elasticsearch/index/engine/InternalEngine.java, +import org.elasticsearch.common.util.concurrent.KeyedLock;, +    private final KeyedLock<Long> noOpKeyedLock = new KeyedLock<>();, +        try (Releasable ignored = noOpKeyedLock.acquire(seqNo)) {, +            final NoOpResult noOpResult;, +            final Optional<Exception> preFlightError = preFlightCheckForNoOp(noOp);, +            if (preFlightError.isPresent()) {, +                noOpResult = new NoOpResult(getPrimaryTerm(), noOp.seqNo(), preFlightError.get());, +            } else {, +                if (failure == null) {, +                    noOpResult = new NoOpResult(getPrimaryTerm(), noOp.seqNo());, +                } else {, +                    noOpResult = new NoOpResult(getPrimaryTerm(), noOp.seqNo(), failure);, +                }, +                if (noOp.origin().isFromTranslog() == false && noOpResult.getResultType() == Result.Type.SUCCESS) {, +            }, +    /**, +     * Executes a pre-flight check for a given NoOp., +     * If this method returns a non-empty result, the engine won't process this NoOp and returns a failure., +     */, +    protected Optional<Exception> preFlightCheckForNoOp(final NoOp noOp) throws IOException {, +        return Optional.empty();, +    }, +, +        if (Assertions.ENABLED) {, +            if (op.operationType() == Operation.TYPE.NO_OP) {, +                assert noOpKeyedLock.isHeldByCurrentThread(op.seqNo());, +            } else {, +            }, +        }, +++ b/server/src/main/java/org/elasticsearch/index/engine/InternalEngine.java, +import org.elasticsearch.common.util.concurrent.KeyedLock;, +    private final KeyedLock<Long> noOpKeyedLock = new KeyedLock<>();, +        try (Releasable ignored = noOpKeyedLock.acquire(seqNo)) {, +            final NoOpResult noOpResult;, +            final Optional<Exception> preFlightError = preFlightCheckForNoOp(noOp);, +            if (preFlightError.isPresent()) {, +                noOpResult = new NoOpResult(getPrimaryTerm(), noOp.seqNo(), preFlightError.get());, +            } else {, +                if (failure == null) {, +                    noOpResult = new NoOpResult(getPrimaryTerm(), noOp.seqNo());, +                } else {, +                    noOpResult = new NoOpResult(getPrimaryTerm(), noOp.seqNo(), failure);, +                }, +                if (noOp.origin().isFromTranslog() == false && noOpResult.getResultType() == Result.Type.SUCCESS) {, +            }, +    /**, +     * Executes a pre-flight check for a given NoOp., +     * If this method returns a non-empty result, the engine won't process this NoOp and returns a failure., +     */, +    protected Optional<Exception> preFlightCheckForNoOp(final NoOp noOp) throws IOException {, +        return Optional.empty();, +    }, +, +        if (Assertions.ENABLED) {, +            if (op.operationType() == Operation.TYPE.NO_OP) {, +                assert noOpKeyedLock.isHeldByCurrentThread(op.seqNo());, +            } else {, +            }, +        }, +++ b/server/src/test/java/org/elasticsearch/index/engine/InternalEngineTests.java, +                clearFailure(); // one shot, +++ b/server/src/main/java/org/elasticsearch/index/engine/InternalEngine.java, +import org.elasticsearch.common.util.concurrent.KeyedLock;, +    private final KeyedLock<Long> noOpKeyedLock = new KeyedLock<>();, +        try (Releasable ignored = noOpKeyedLock.acquire(seqNo)) {, +            final NoOpResult noOpResult;, +            final Optional<Exception> preFlightError = preFlightCheckForNoOp(noOp);, +            if (preFlightError.isPresent()) {, +                noOpResult = new NoOpResult(getPrimaryTerm(), noOp.seqNo(), preFlightError.get());, +            } else {, +                if (failure == null) {, +                    noOpResult = new NoOpResult(getPrimaryTerm(), noOp.seqNo());, +                } else {, +                    noOpResult = new NoOpResult(getPrimaryTerm(), noOp.seqNo(), failure);, +                }, +                if (noOp.origin().isFromTranslog() == false && noOpResult.getResultType() == Result.Type.SUCCESS) {, +            }, +    /**, +     * Executes a pre-flight check for a given NoOp., +     * If this method returns a non-empty result, the engine won't process this NoOp and returns a failure., +     */, +    protected Optional<Exception> preFlightCheckForNoOp(final NoOp noOp) throws IOException {, +        return Optional.empty();, +    }, +, +        if (Assertions.ENABLED) {, +            if (op.operationType() == Operation.TYPE.NO_OP) {, +                assert noOpKeyedLock.isHeldByCurrentThread(op.seqNo());, +            } else {, +            }, +        }, +++ b/server/src/test/java/org/elasticsearch/index/engine/InternalEngineTests.java, +                clearFailure(); // one shot, +++ b/x-pack/plugin/ccr/src/main/java/org/elasticsearch/xpack/ccr/index/engine/FollowingEngine.java, +import java.util.Optional;, +    protected Optional<Exception> preFlightCheckForNoOp(NoOp noOp) throws IOException {, +        if (noOp.origin() == Operation.Origin.PRIMARY && hasBeenProcessedBefore(noOp)) {, +            // See the comment in #indexingStrategyForOperation for the explanation why we can safely skip this operation., +            final OptionalLong existingTerm = lookupPrimaryTerm(noOp.seqNo());]