[+++ b/server/src/main/java/org/elasticsearch/action/admin/cluster/reroute/TransportClusterRerouteAction.java, +                            if (indexStatus == null) {, +                                // The index in the stale primary allocation request was green and hence filtered out by the store status, +                                // request. We ignore it here since the relevant exception will be thrown by the reroute action later on., +                                continue;, +                            }, +++ b/server/src/main/java/org/elasticsearch/action/admin/cluster/reroute/TransportClusterRerouteAction.java, +                            if (indexStatus == null) {, +                                // The index in the stale primary allocation request was green and hence filtered out by the store status, +                                // request. We ignore it here since the relevant exception will be thrown by the reroute action later on., +                                continue;, +                            }, +++ b/server/src/test/java/org/elasticsearch/cluster/routing/PrimaryAllocationIT.java, +        // Ensure the stopped primary's data is deleted so that it doesn't get picked up by the next datanode we start, +        internalCluster().wipePendingDataDirectories();, +        internalCluster().startDataOnlyNodes(1);, +        ensureStableCluster(3, master);, +    public void testForceStaleReplicaToBePromotedForGreenIndex() {, +        internalCluster().startMasterOnlyNode(Settings.EMPTY);, +        final List<String> dataNodes = internalCluster().startDataOnlyNodes(2);, +        final String idxName = "test";, +        assertAcked(client().admin().indices().prepareCreate(idxName), +            .setSettings(Settings.builder().put("index.number_of_shards", 1), +                .put("index.number_of_replicas", 1)).get());, +        ensureGreen();, +        final String nodeWithoutData = randomFrom(dataNodes);, +        final int shardId = 0;, +        IllegalArgumentException iae = expectThrows(, +            IllegalArgumentException.class,, +            () -> client().admin().cluster().prepareReroute(), +                .add(new AllocateStalePrimaryAllocationCommand(idxName, shardId, nodeWithoutData, true)).get());, +        assertThat(, +            iae.getMessage(),, +            equalTo("[allocate_stale_primary] primary [" + idxName+ "][" + shardId + "] is already assigned"));, +    }, +, +++ b/server/src/main/java/org/elasticsearch/action/admin/cluster/reroute/TransportClusterRerouteAction.java, +                            if (indexStatus == null) {, +                                // The index in the stale primary allocation request was green and hence filtered out by the store status, +                                // request. We ignore it here since the relevant exception will be thrown by the reroute action later on., +                                continue;, +                            }, +++ b/server/src/test/java/org/elasticsearch/cluster/routing/PrimaryAllocationIT.java, +        // Ensure the stopped primary's data is deleted so that it doesn't get picked up by the next datanode we start, +        internalCluster().wipePendingDataDirectories();, +        internalCluster().startDataOnlyNodes(1);, +        ensureStableCluster(3, master);, +    public void testForceStaleReplicaToBePromotedForGreenIndex() {, +        internalCluster().startMasterOnlyNode(Settings.EMPTY);, +        final List<String> dataNodes = internalCluster().startDataOnlyNodes(2);, +        final String idxName = "test";, +        assertAcked(client().admin().indices().prepareCreate(idxName), +            .setSettings(Settings.builder().put("index.number_of_shards", 1), +                .put("index.number_of_replicas", 1)).get());, +        ensureGreen();, +        final String nodeWithoutData = randomFrom(dataNodes);, +        final int shardId = 0;, +        IllegalArgumentException iae = expectThrows(, +            IllegalArgumentException.class,, +            () -> client().admin().cluster().prepareReroute(), +                .add(new AllocateStalePrimaryAllocationCommand(idxName, shardId, nodeWithoutData, true)).get());, +        assertThat(, +            iae.getMessage(),, +            equalTo("[allocate_stale_primary] primary [" + idxName+ "][" + shardId + "] is already assigned"));, +    }, +, +++ b/test/framework/src/main/java/org/elasticsearch/test/InternalTestCluster.java, +    public synchronized void wipePendingDataDirectories() {]