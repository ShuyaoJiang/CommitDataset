[+++ b/core/src/main/java/org/elasticsearch/ElasticsearchException.java, +        // 28 was DeleteFailedEngineException, +        // 80 used to be for IndexFailedEngineException, removed in 6.0, +++ b/core/src/main/java/org/elasticsearch/ElasticsearchException.java, +        // 28 was DeleteFailedEngineException, +        // 80 used to be for IndexFailedEngineException, removed in 6.0, +++ b/core/src/main/java/org/elasticsearch/action/bulk/TransportShardBulkAction.java, +import org.elasticsearch.index.mapper.MapperParsingException;, +import static org.elasticsearch.action.delete.TransportDeleteAction.executeDeleteRequestOnPrimary;, +import static org.elasticsearch.action.delete.TransportDeleteAction.executeDeleteRequestOnReplica;, +import static org.elasticsearch.action.index.TransportIndexAction.executeIndexRequestOnPrimary;, +import static org.elasticsearch.action.index.TransportIndexAction.executeIndexRequestOnReplica;, +public class TransportShardBulkAction extends TransportWriteAction<BulkShardRequest, BulkShardRequest, BulkShardResponse> {, +                indexNameExpressionResolver, BulkShardRequest::new, BulkShardRequest::new, ThreadPool.Names.BULK);, +    protected WritePrimaryResult shardOperationOnPrimary(BulkShardRequest request, IndexShard primary) throws Exception {, +        return new WritePrimaryResult(request, response, location, null, primary);, +    private Translog.Location executeBulkItemRequest(IndexMetaData metaData, IndexShard primary,, +                                                     Translog.Location location, int requestIndex) throws Exception {, +        final DocWriteRequest itemRequest = request.items()[requestIndex].request();, +        preVersions[requestIndex] = itemRequest.version();, +        preVersionTypes[requestIndex] = itemRequest.versionType();, +        DocWriteRequest.OpType opType = itemRequest.opType();, +            // execute item request, +            final Engine.Result operationResult;, +            final DocWriteResponse response;, +            BulkItemRequest replicaRequest = request.items()[requestIndex];, +            switch (itemRequest.opType()) {, +                case CREATE:, +                case INDEX:, +                    final IndexRequest indexRequest = (IndexRequest) itemRequest;, +                    Engine.IndexResult indexResult = executeIndexRequestOnPrimary(indexRequest, primary, mappingUpdatedAction);, +                    operationResult = indexResult;, +                    response = indexResult.hasFailure() ? null, +                            : new IndexResponse(primary.shardId(), indexRequest.type(), indexRequest.id(),, +                                indexResult.getVersion(), indexResult.isCreated());, +                    break;, +                case UPDATE:, +                    UpdateResultHolder updateResultHolder = executeUpdateRequest(((UpdateRequest) itemRequest),, +                            primary, metaData, request, requestIndex);, +                    operationResult = updateResultHolder.operationResult;, +                    response = updateResultHolder.response;, +                    replicaRequest = updateResultHolder.replicaRequest;, +                    break;, +                case DELETE:, +                    final DeleteRequest deleteRequest = (DeleteRequest) itemRequest;, +                    Engine.DeleteResult deleteResult = executeDeleteRequestOnPrimary(deleteRequest, primary);, +                    operationResult = deleteResult;, +                    response = deleteResult.hasFailure() ? null :, +                            new DeleteResponse(request.shardId(), deleteRequest.type(), deleteRequest.id(),, +                                deleteResult.getVersion(), deleteResult.isFound());, +                    break;, +                default: throw new IllegalStateException("unexpected opType [" + itemRequest.opType() + "] found");, +            request.items()[requestIndex] = replicaRequest;, +            if (operationResult == null) { // in case of noop update operation, +                assert response.getResult() == DocWriteResponse.Result.NOOP, +                        : "only noop update can have null operation";, +                replicaRequest.setIgnoreOnReplica();, +                replicaRequest.setPrimaryResponse(new BulkItemResponse(replicaRequest.id(), opType, response));, +            } else if (operationResult.hasFailure() == false) {, +                location = locationToSync(location, operationResult.getTranslogLocation());, +                BulkItemResponse primaryResponse = new BulkItemResponse(replicaRequest.id(), opType, response);, +                replicaRequest.setPrimaryResponse(primaryResponse);, +                // set the ShardInfo to 0 so we can safely send it to the replicas. We won't use it in the real response though., +                primaryResponse.getResponse().setShardInfo(new ShardInfo());, +            } else {, +                DocWriteRequest docWriteRequest = replicaRequest.request();, +                Exception failure = operationResult.getFailure();, +                if (isConflictException(failure)) {, +                    logger.trace((Supplier<?>) () -> new ParameterizedMessage("{} failed to execute bulk item ({}) {}",, +                            request.shardId(), docWriteRequest.opType().getLowercase(), request), failure);, +                } else {, +                    logger.debug((Supplier<?>) () -> new ParameterizedMessage("{} failed to execute bulk item ({}) {}",, +                            request.shardId(), docWriteRequest.opType().getLowercase(), request), failure);, +                }, +                // if its a conflict failure, and we already executed the request on a primary (and we execute it, +                // again, due to primary relocation and only processing up to N bulk items when the shard gets closed), +                // then just use the response we got from the successful execution, +                if (replicaRequest.getPrimaryResponse() == null || isConflictException(failure) == false) {, +                    replicaRequest.setIgnoreOnReplica();, +                    replicaRequest.setPrimaryResponse(new BulkItemResponse(replicaRequest.id(), docWriteRequest.opType(),, +                            new BulkItemResponse.Failure(request.index(), docWriteRequest.type(), docWriteRequest.id(), failure)));, +                }, +            }, +            assert replicaRequest.getPrimaryResponse() != null;, +            assert preVersionTypes[requestIndex] != null;, +            throw e;, +    private static class UpdateResultHolder {, +        final BulkItemRequest replicaRequest;, +        final Engine.Result operationResult;, +        final DocWriteResponse response;, +        private UpdateResultHolder(BulkItemRequest replicaRequest, Engine.Result operationResult,, +                                   DocWriteResponse response) {, +            this.replicaRequest = replicaRequest;, +            this.operationResult = operationResult;, +            this.response = response;, +     * Executes update request, delegating to a index or delete operation after translation,, +     * handles retries on version conflict and constructs update response, +     * NOTE: reassigns bulk item request at <code>requestIndex</code> for replicas to, +     * execute translated update request (NOOP update is an exception). NOOP updates are, +     * indicated by returning a <code>null</code> operation in {@link UpdateResultHolder}]