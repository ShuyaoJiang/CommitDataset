[+++ b/core/src/main/java/org/elasticsearch/common/lucene/search/function/FiltersFunctionScoreQuery.java, +        if (needsScores == false) {, +            return subQuery.createWeight(searcher, needsScores);, +        }, +, +        boolean subQueryNeedsScores = combineFunction != CombineFunction.REPLACE;, +            subQueryNeedsScores |= filterFunctions[i].function.needsScores();, +        Weight subQueryWeight = subQuery.createWeight(searcher, subQueryNeedsScores);, +        return new CustomBoostFactorWeight(this, subQueryWeight, filterWeights, subQueryNeedsScores);, +        final boolean needsScores;, +        public CustomBoostFactorWeight(Query parent, Weight subQueryWeight, Weight[] filterWeights, boolean needsScores) throws IOException {, +            this.needsScores = needsScores;, +            return new FiltersFunctionFactorScorer(this, subQueryScorer, scoreMode, filterFunctions, maxBoost, functions, docSets, combineFunction, minScore, needsScores);, +        private final boolean needsScores;, +                                            float maxBoost, LeafScoreFunction[] functions, Bits[] docSets, CombineFunction scoreCombiner, Float minScore, boolean needsScores) throws IOException {, +            this.needsScores = needsScores;, +            // Even if the weight is created with needsScores=false, it might, +            // be costly to call score(), so we explicitly check if scores, +            // are needed, +            float subQueryScore = needsScores ? scorer.score() : 0f;, +++ b/core/src/main/java/org/elasticsearch/common/lucene/search/function/FiltersFunctionScoreQuery.java, +        if (needsScores == false) {, +            return subQuery.createWeight(searcher, needsScores);, +        }, +, +        boolean subQueryNeedsScores = combineFunction != CombineFunction.REPLACE;, +            subQueryNeedsScores |= filterFunctions[i].function.needsScores();, +        Weight subQueryWeight = subQuery.createWeight(searcher, subQueryNeedsScores);, +        return new CustomBoostFactorWeight(this, subQueryWeight, filterWeights, subQueryNeedsScores);, +        final boolean needsScores;, +        public CustomBoostFactorWeight(Query parent, Weight subQueryWeight, Weight[] filterWeights, boolean needsScores) throws IOException {, +            this.needsScores = needsScores;, +            return new FiltersFunctionFactorScorer(this, subQueryScorer, scoreMode, filterFunctions, maxBoost, functions, docSets, combineFunction, minScore, needsScores);, +        private final boolean needsScores;, +                                            float maxBoost, LeafScoreFunction[] functions, Bits[] docSets, CombineFunction scoreCombiner, Float minScore, boolean needsScores) throws IOException {, +            this.needsScores = needsScores;, +            // Even if the weight is created with needsScores=false, it might, +            // be costly to call score(), so we explicitly check if scores, +            // are needed, +            float subQueryScore = needsScores ? scorer.score() : 0f;, +++ b/dev-tools/src/main/resources/ant/integration-tests.xml, +      <element name="nested.args" optional="true"/>, +          <nested.args/>, +      <startup-elasticsearch spawn="false" home="${home}">, +        <nested.args>, +          <env key="JAVA_OPTS" value="-agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=8000"/>, +        </nested.args>, +      </startup-elasticsearch>, +++ b/core/src/main/java/org/elasticsearch/common/lucene/search/function/FiltersFunctionScoreQuery.java, +        if (needsScores == false) {, +            return subQuery.createWeight(searcher, needsScores);, +        }, +, +        boolean subQueryNeedsScores = combineFunction != CombineFunction.REPLACE;, +            subQueryNeedsScores |= filterFunctions[i].function.needsScores();, +        Weight subQueryWeight = subQuery.createWeight(searcher, subQueryNeedsScores);, +        return new CustomBoostFactorWeight(this, subQueryWeight, filterWeights, subQueryNeedsScores);, +        final boolean needsScores;, +        public CustomBoostFactorWeight(Query parent, Weight subQueryWeight, Weight[] filterWeights, boolean needsScores) throws IOException {, +            this.needsScores = needsScores;, +            return new FiltersFunctionFactorScorer(this, subQueryScorer, scoreMode, filterFunctions, maxBoost, functions, docSets, combineFunction, minScore, needsScores);, +        private final boolean needsScores;, +                                            float maxBoost, LeafScoreFunction[] functions, Bits[] docSets, CombineFunction scoreCombiner, Float minScore, boolean needsScores) throws IOException {, +            this.needsScores = needsScores;, +            // Even if the weight is created with needsScores=false, it might, +            // be costly to call score(), so we explicitly check if scores, +            // are needed, +            float subQueryScore = needsScores ? scorer.score() : 0f;, +++ b/dev-tools/src/main/resources/ant/integration-tests.xml, +      <element name="nested.args" optional="true"/>, +          <nested.args/>, +      <startup-elasticsearch spawn="false" home="${home}">, +        <nested.args>, +          <env key="JAVA_OPTS" value="-agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=8000"/>, +        </nested.args>, +      </startup-elasticsearch>, +++ b/distribution/deb/pom.xml, +                                <ant antfile="${elasticsearch.integ.antfile}" target="start-external-cluster-deb"/>, +++ b/core/src/main/java/org/elasticsearch/common/lucene/search/function/FiltersFunctionScoreQuery.java, +        if (needsScores == false) {, +            return subQuery.createWeight(searcher, needsScores);, +        }, +, +        boolean subQueryNeedsScores = combineFunction != CombineFunction.REPLACE;, +            subQueryNeedsScores |= filterFunctions[i].function.needsScores();, +        Weight subQueryWeight = subQuery.createWeight(searcher, subQueryNeedsScores);, +        return new CustomBoostFactorWeight(this, subQueryWeight, filterWeights, subQueryNeedsScores);, +        final boolean needsScores;, +        public CustomBoostFactorWeight(Query parent, Weight subQueryWeight, Weight[] filterWeights, boolean needsScores) throws IOException {, +            this.needsScores = needsScores;, +            return new FiltersFunctionFactorScorer(this, subQueryScorer, scoreMode, filterFunctions, maxBoost, functions, docSets, combineFunction, minScore, needsScores);, +        private final boolean needsScores;, +                                            float maxBoost, LeafScoreFunction[] functions, Bits[] docSets, CombineFunction scoreCombiner, Float minScore, boolean needsScores) throws IOException {, +            this.needsScores = needsScores;, +            // Even if the weight is created with needsScores=false, it might, +            // be costly to call score(), so we explicitly check if scores, +            // are needed, +            float subQueryScore = needsScores ? scorer.score() : 0f;, +++ b/dev-tools/src/main/resources/ant/integration-tests.xml, +      <element name="nested.args" optional="true"/>]