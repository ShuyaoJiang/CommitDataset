[+++ b/x-pack/plugin/watcher/src/main/java/org/elasticsearch/xpack/watcher/trigger/schedule/CronnableSchedule.java, +    private static final Comparator<Cron> CRON_COMPARATOR = Comparator.comparing(Cron::expression);, +    CronnableSchedule(String... expressions) {, +    private CronnableSchedule(Cron... crons) {, +            long nextValidTimeAfter = cron.getNextValidTimeAfter(time);, +, +            boolean previousCronExpired = nextTime == -1;, +            boolean currentCronValid = nextValidTimeAfter > -1;, +            if (previousCronExpired && currentCronValid) {, +                nextTime = nextValidTimeAfter;, +            } else {, +                nextTime = Math.min(nextTime, nextValidTimeAfter);, +            }, +++ b/x-pack/plugin/watcher/src/main/java/org/elasticsearch/xpack/watcher/trigger/schedule/CronnableSchedule.java, +    private static final Comparator<Cron> CRON_COMPARATOR = Comparator.comparing(Cron::expression);, +    CronnableSchedule(String... expressions) {, +    private CronnableSchedule(Cron... crons) {, +            long nextValidTimeAfter = cron.getNextValidTimeAfter(time);, +, +            boolean previousCronExpired = nextTime == -1;, +            boolean currentCronValid = nextValidTimeAfter > -1;, +            if (previousCronExpired && currentCronValid) {, +                nextTime = nextValidTimeAfter;, +            } else {, +                nextTime = Math.min(nextTime, nextValidTimeAfter);, +            }, +++ b/x-pack/plugin/watcher/src/test/java/org/elasticsearch/xpack/watcher/trigger/schedule/CronScheduleTests.java, +import java.time.ZoneOffset;, +import java.time.ZonedDateTime;, +, +import static org.hamcrest.Matchers.not;, +    public void testMultipleCronsNextScheduledAfter() {, +        CronSchedule schedule = new CronSchedule("0 5 9 1 1 ? 2019", "0 5 9 1 1 ? 2020", "0 5 9 1 1 ? 2017");, +        ZonedDateTime start2019 = ZonedDateTime.of(2019, 1, 1, 0, 0, 0, 0, ZoneOffset.UTC);, +        ZonedDateTime start2020 = ZonedDateTime.of(2020, 1, 1, 0, 0, 0, 0, ZoneOffset.UTC);, +        long firstSchedule = schedule.nextScheduledTimeAfter(0, start2019.toInstant().toEpochMilli());, +        long secondSchedule = schedule.nextScheduledTimeAfter(0, start2020.toInstant().toEpochMilli());, +, +        assertThat(firstSchedule, is(not(-1L)));, +        assertThat(secondSchedule, is(not(-1L)));, +        assertThat(firstSchedule, is(not(secondSchedule)));, +    }, +, +        ElasticsearchParseException e = expectThrows(ElasticsearchParseException.class, () -> new CronSchedule.Parser().parse(parser));, +        assertThat(e.getCause(), instanceOf(IllegalArgumentException.class));]