[+++ b/core/src/main/java/org/elasticsearch/client/transport/TransportClientNodesService.java, +import org.apache.lucene.util.IOUtils;, +import org.elasticsearch.common.util.concurrent.AbstractRunnable;, +import org.elasticsearch.transport.PlainTransportFuture;, +import org.elasticsearch.transport.Transport;, +                try (Transport.Connection connection = transportService.openConnection(listedNode, LISTED_NODES_PROFILE)){, +                    final PlainTransportFuture<LivenessResponse> handler = new PlainTransportFuture<>(, +                        });, +                    transportService.sendRequest(connection, TransportLivenessAction.NAME, new LivenessRequest(),, +                        TransportRequestOptions.builder().withType(TransportRequestOptions.Type.STATE).withTimeout(pingTimeout).build(),, +                        handler);, +                    final LivenessResponse livenessResponse = handler.txGet();, +                    } else {, +                } catch (ConnectTransportException e) {, +                    logger.debug(, +                        (Supplier<?>), +                            () -> new ParameterizedMessage("failed to connect to node [{}], ignoring...", listedNode), e);, +                    hostFailureListener.onNodeDisconnected(listedNode, e);, +                for (final DiscoveryNode nodeToPing : nodesToPing) {, +                    threadPool.executor(ThreadPool.Names.MANAGEMENT).execute(new AbstractRunnable() {, +                        /**, +                         * we try to reuse existing connections but if needed we will open a temporary connection, +                         * that will be closed at the end of the execution., +                         */, +                        Transport.Connection connectionToClose = null;, +, +                        @Override, +                        public void onAfter() {, +                            IOUtils.closeWhileHandlingException(connectionToClose);, +, +                        @Override, +                        public void onFailure(Exception e) {, +                            if (e instanceof ConnectTransportException) {, +                                logger.debug((Supplier<?>), +                                    () -> new ParameterizedMessage("failed to connect to node [{}], ignoring...", nodeToPing), e);, +                                hostFailureListener.onNodeDisconnected(nodeToPing, e);, +                            } else {, +                                logger.info(, +                                    (Supplier<?>) () -> new ParameterizedMessage(, +                                        "failed to get local cluster state info for {}, disconnecting...", nodeToPing), e);, +, +                        @Override, +                        protected void doRun() throws Exception {, +                            Transport.Connection pingConnection = null;, +                            if (nodes.contains(nodeToPing)) {, +                                try {, +                                    pingConnection = transportService.getConnection(nodeToPing);, +                                } catch (NodeNotConnectedException e) {, +                                    // will use a temp connection, +                                }, +                            }, +                            if (pingConnection == null) {, +                                logger.trace("connecting to cluster node [{}]", nodeToPing);, +                                connectionToClose = transportService.openConnection(nodeToPing, LISTED_NODES_PROFILE);, +                                pingConnection = connectionToClose;, +                            }, +                            transportService.sendRequest(pingConnection, ClusterStateAction.NAME,, +                                        clusterStateResponses.put(nodeToPing, response);, +                                                "failed to get local cluster state for {}, disconnecting...", nodeToPing), e);, +                                            hostFailureListener.onNodeDisconnected(nodeToPing, e);, +                                        }, +                                        finally {, +                                            latch.countDown();, +                                        }, +                                    }, +                                });, +                        }, +                    });, +                }, +                Thread.currentThread().interrupt();, +++ b/core/src/main/java/org/elasticsearch/client/transport/TransportClientNodesService.java, +import org.apache.lucene.util.IOUtils;, +import org.elasticsearch.common.util.concurrent.AbstractRunnable;, +import org.elasticsearch.transport.PlainTransportFuture;, +import org.elasticsearch.transport.Transport;, +                try (Transport.Connection connection = transportService.openConnection(listedNode, LISTED_NODES_PROFILE)){, +                    final PlainTransportFuture<LivenessResponse> handler = new PlainTransportFuture<>(, +                        });, +                    transportService.sendRequest(connection, TransportLivenessAction.NAME, new LivenessRequest(),, +                        TransportRequestOptions.builder().withType(TransportRequestOptions.Type.STATE).withTimeout(pingTimeout).build(),, +                        handler);, +                    final LivenessResponse livenessResponse = handler.txGet();, +                    } else {, +                } catch (ConnectTransportException e) {, +                    logger.debug(, +                        (Supplier<?>), +                            () -> new ParameterizedMessage("failed to connect to node [{}], ignoring...", listedNode), e);, +                    hostFailureListener.onNodeDisconnected(listedNode, e);, +                for (final DiscoveryNode nodeToPing : nodesToPing) {, +                    threadPool.executor(ThreadPool.Names.MANAGEMENT).execute(new AbstractRunnable() {, +                        /**, +                         * we try to reuse existing connections but if needed we will open a temporary connection, +                         * that will be closed at the end of the execution., +                         */, +                        Transport.Connection connectionToClose = null;, +, +                        @Override, +                        public void onAfter() {, +                            IOUtils.closeWhileHandlingException(connectionToClose);, +]