[+++ b/plugin/src/main/java/org/elasticsearch/xpack/sql/plugin/SecurityCatalogFilter.java, +        IndicesAccessControl control = getIndicesAccessControl();, +        if (control == null) {, +            // Looks like we're in a delayed response request so lets try that., +            BiFunction<IndicesOptions, String[], IndicesAccessControl> resolver = getAccessControlResolver();, +            if (resolver == null) {, +                // Looks like we're borked., +                throw new IllegalStateException("SQL request wasn't recognized properly by security");, +            }, +            control = resolver.apply(OPTIONS, new String[] {index.name()});, +        }, +        IndexAccessControl permissions = control.getIndexPermissions(index.name());, +    /**, +     * Get the {@link IndicesAccessControl} for this request. This will return null for, +     * requests that are not indices requests, like SQL's main action., +     */, +    private IndicesAccessControl getIndicesAccessControl() {, +        return threadContext.getTransient(AuthorizationService.INDICES_PERMISSIONS_KEY);, +, +    /**, +     * Return a function that resolves permissions to the indices. This will return null, +     * all actions other than "delayed" actions like the main SQL action., +     */, +    private BiFunction<IndicesOptions, String[], IndicesAccessControl> getAccessControlResolver() {, +        return threadContext.getTransient(AuthorizationService.INDICES_PERMISSIONS_RESOLVER_KEY);, +++ b/plugin/src/main/java/org/elasticsearch/xpack/sql/plugin/SecurityCatalogFilter.java, +        IndicesAccessControl control = getIndicesAccessControl();, +        if (control == null) {, +            // Looks like we're in a delayed response request so lets try that., +            BiFunction<IndicesOptions, String[], IndicesAccessControl> resolver = getAccessControlResolver();, +            if (resolver == null) {, +                // Looks like we're borked., +                throw new IllegalStateException("SQL request wasn't recognized properly by security");, +            }, +            control = resolver.apply(OPTIONS, new String[] {index.name()});, +        }, +        IndexAccessControl permissions = control.getIndexPermissions(index.name());, +    /**, +     * Get the {@link IndicesAccessControl} for this request. This will return null for, +     * requests that are not indices requests, like SQL's main action., +     */, +    private IndicesAccessControl getIndicesAccessControl() {, +        return threadContext.getTransient(AuthorizationService.INDICES_PERMISSIONS_KEY);, +, +    /**, +     * Return a function that resolves permissions to the indices. This will return null, +     * all actions other than "delayed" actions like the main SQL action., +     */, +    private BiFunction<IndicesOptions, String[], IndicesAccessControl> getAccessControlResolver() {, +        return threadContext.getTransient(AuthorizationService.INDICES_PERMISSIONS_RESOLVER_KEY);, +++ b/qa/sql/multinode/src/test/java/org/elasticsearch/xpack/qa/sql/multinode/JdbcDatabaseMetaDataIT.java, +/*, + * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one, + * or more contributor license agreements. Licensed under the Elastic License;, + * you may not use this file except in compliance with the Elastic License., + */, +package org.elasticsearch.xpack.qa.sql.multinode;, +, +import org.elasticsearch.xpack.qa.sql.jdbc.DatabaseMetaDataTestCase;, +, +public class JdbcDatabaseMetaDataIT extends DatabaseMetaDataTestCase {, +}, +++ b/plugin/src/main/java/org/elasticsearch/xpack/sql/plugin/SecurityCatalogFilter.java, +        IndicesAccessControl control = getIndicesAccessControl();, +        if (control == null) {, +            // Looks like we're in a delayed response request so lets try that., +            BiFunction<IndicesOptions, String[], IndicesAccessControl> resolver = getAccessControlResolver();, +            if (resolver == null) {, +                // Looks like we're borked., +                throw new IllegalStateException("SQL request wasn't recognized properly by security");, +            }, +            control = resolver.apply(OPTIONS, new String[] {index.name()});, +        }, +        IndexAccessControl permissions = control.getIndexPermissions(index.name());, +    /**, +     * Get the {@link IndicesAccessControl} for this request. This will return null for, +     * requests that are not indices requests, like SQL's main action., +     */, +    private IndicesAccessControl getIndicesAccessControl() {, +        return threadContext.getTransient(AuthorizationService.INDICES_PERMISSIONS_KEY);, +, +    /**, +     * Return a function that resolves permissions to the indices. This will return null, +     * all actions other than "delayed" actions like the main SQL action., +     */, +    private BiFunction<IndicesOptions, String[], IndicesAccessControl> getAccessControlResolver() {, +        return threadContext.getTransient(AuthorizationService.INDICES_PERMISSIONS_RESOLVER_KEY);, +++ b/qa/sql/multinode/src/test/java/org/elasticsearch/xpack/qa/sql/multinode/JdbcDatabaseMetaDataIT.java, +/*, + * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one, + * or more contributor license agreements. Licensed under the Elastic License;, + * you may not use this file except in compliance with the Elastic License., + */, +package org.elasticsearch.xpack.qa.sql.multinode;, +, +import org.elasticsearch.xpack.qa.sql.jdbc.DatabaseMetaDataTestCase;, +, +public class JdbcDatabaseMetaDataIT extends DatabaseMetaDataTestCase {, +}, +++ b/qa/sql/no-security/src/test/java/org/elasticsearch/xpack/qa/sql/nosecurity/JdbcDatabaseMetaDataIT.java]