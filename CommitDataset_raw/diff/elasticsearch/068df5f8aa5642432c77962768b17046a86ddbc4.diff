[+++ b/core/src/main/java/org/elasticsearch/search/SearchModule.java, +import org.elasticsearch.search.aggregations.bucket.terms.TermsAggregatorBuilder;, +        registerAggregation(TermsAggregatorBuilder::new, new TermsParser(), TermsAggregatorBuilder.AGGREGATION_NAME_FIELD);, +++ b/core/src/main/java/org/elasticsearch/search/SearchModule.java, +import org.elasticsearch.search.aggregations.bucket.terms.TermsAggregatorBuilder;, +        registerAggregation(TermsAggregatorBuilder::new, new TermsParser(), TermsAggregatorBuilder.AGGREGATION_NAME_FIELD);, +++ b/core/src/main/java/org/elasticsearch/search/aggregations/bucket/significant/SignificantTermsParser.java, +++ b/core/src/main/java/org/elasticsearch/search/SearchModule.java, +import org.elasticsearch.search.aggregations.bucket.terms.TermsAggregatorBuilder;, +        registerAggregation(TermsAggregatorBuilder::new, new TermsParser(), TermsAggregatorBuilder.AGGREGATION_NAME_FIELD);, +++ b/core/src/main/java/org/elasticsearch/search/aggregations/bucket/significant/SignificantTermsParser.java, +++ b/core/src/main/java/org/elasticsearch/search/aggregations/bucket/terms/TermsAggregatorBuilder.java, +    public static final String NAME = StringTerms.TYPE.name();, +    public static final ParseField AGGREGATION_NAME_FIELD = new ParseField(NAME);, +    /**, +     * Read from a stream., +     */, +    public TermsAggregatorBuilder(StreamInput in) throws IOException {, +        super(in, StringTerms.TYPE, ValuesSourceType.ANY);, +        bucketCountThresholds = BucketCountThresholds.readFromStream(in);, +        collectMode = SubAggCollectionMode.BREADTH_FIRST.readFrom(in);, +        executionHint = in.readOptionalString();, +        if (in.readBoolean()) {, +            includeExclude = IncludeExclude.readFromStream(in);, +        }, +        order = InternalOrder.Streams.readOrder(in);, +        showTermDocCountError = in.readBoolean();, +    }, +, +    @Override, +    protected boolean serializeTargetValueType() {, +        return true;, +    }, +, +    @Override, +    protected void innerWriteTo(StreamOutput out) throws IOException {, +        bucketCountThresholds.writeTo(out);, +        collectMode.writeTo(out);, +        out.writeOptionalString(executionHint);, +        boolean hasIncExc = includeExclude != null;, +        out.writeBoolean(hasIncExc);, +        if (hasIncExc) {, +            includeExclude.writeTo(out);, +        }, +        InternalOrder.Streams.writeOrder(order, out);, +        out.writeBoolean(showTermDocCountError);, +    }, +, +    @Override, +    protected boolean usesNewStyleSerialization() {, +        return true;, +    }, +, +    @Override, +    public String getWriteableName() {, +        return NAME;, +    }, +++ b/core/src/main/java/org/elasticsearch/search/SearchModule.java, +import org.elasticsearch.search.aggregations.bucket.terms.TermsAggregatorBuilder;, +        registerAggregation(TermsAggregatorBuilder::new, new TermsParser(), TermsAggregatorBuilder.AGGREGATION_NAME_FIELD);, +++ b/core/src/main/java/org/elasticsearch/search/aggregations/bucket/significant/SignificantTermsParser.java, +++ b/core/src/main/java/org/elasticsearch/search/aggregations/bucket/terms/TermsAggregatorBuilder.java, +    public static final String NAME = StringTerms.TYPE.name();, +    public static final ParseField AGGREGATION_NAME_FIELD = new ParseField(NAME);, +    /**, +     * Read from a stream., +     */, +    public TermsAggregatorBuilder(StreamInput in) throws IOException {, +        super(in, StringTerms.TYPE, ValuesSourceType.ANY);, +        bucketCountThresholds = BucketCountThresholds.readFromStream(in);, +        collectMode = SubAggCollectionMode.BREADTH_FIRST.readFrom(in);, +        executionHint = in.readOptionalString();, +        if (in.readBoolean()) {, +            includeExclude = IncludeExclude.readFromStream(in);, +        }, +        order = InternalOrder.Streams.readOrder(in);, +        showTermDocCountError = in.readBoolean();, +    }, +, +    @Override, +    protected boolean serializeTargetValueType() {, +        return true;, +    }, +, +    @Override, +    protected void innerWriteTo(StreamOutput out) throws IOException {, +        bucketCountThresholds.writeTo(out);, +        collectMode.writeTo(out);, +        out.writeOptionalString(executionHint);, +        boolean hasIncExc = includeExclude != null;, +        out.writeBoolean(hasIncExc);, +        if (hasIncExc) {, +            includeExclude.writeTo(out);, +        }, +        InternalOrder.Streams.writeOrder(order, out);, +        out.writeBoolean(showTermDocCountError);, +    }, +, +    @Override, +    protected boolean usesNewStyleSerialization() {]