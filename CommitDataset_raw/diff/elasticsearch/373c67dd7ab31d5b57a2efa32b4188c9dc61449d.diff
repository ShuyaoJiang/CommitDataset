[+++ b/libs/nio/src/main/java/org/elasticsearch/nio/BytesChannelContext.java, +        int bytesRead = readFromChannel(channelBuffer);, +        flushToChannel(flushOperation);, +++ b/libs/nio/src/main/java/org/elasticsearch/nio/BytesChannelContext.java, +        int bytesRead = readFromChannel(channelBuffer);, +        flushToChannel(flushOperation);, +++ b/libs/nio/src/main/java/org/elasticsearch/nio/NioSelector.java, +import java.nio.ByteBuffer;, +    private final ByteBuffer ioBuffer;, +        this.ioBuffer = ByteBuffer.allocateDirect(1 << 16);, +    }, +, +    /**, +     * Returns a cached direct byte buffer for network operations. It is cleared on every get call., +     *, +     * @return the byte buffer, +     */, +    public ByteBuffer getIoBuffer() {, +        assertOnSelectorThread();, +        ioBuffer.clear();, +        return ioBuffer;, +++ b/libs/nio/src/main/java/org/elasticsearch/nio/BytesChannelContext.java, +        int bytesRead = readFromChannel(channelBuffer);, +        flushToChannel(flushOperation);, +++ b/libs/nio/src/main/java/org/elasticsearch/nio/NioSelector.java, +import java.nio.ByteBuffer;, +    private final ByteBuffer ioBuffer;, +        this.ioBuffer = ByteBuffer.allocateDirect(1 << 16);, +    }, +, +    /**, +     * Returns a cached direct byte buffer for network operations. It is cleared on every get call., +     *, +     * @return the byte buffer, +     */, +    public ByteBuffer getIoBuffer() {, +        assertOnSelectorThread();, +        ioBuffer.clear();, +        return ioBuffer;, +++ b/libs/nio/src/main/java/org/elasticsearch/nio/SocketChannelContext.java, +    protected static final Predicate<NioSocketChannel> ALWAYS_ALLOW_CHANNEL = (c) -> true;, +, +    // When you read or write to a nio socket in java, the heap memory passed down must be copied to/from, +    // direct memory. The JVM internally does some buffering of the direct memory, however we can save space, +    // by reusing a thread-local direct buffer (provided by the NioSelector)., +    //, +    // Each network event loop is given a 64kb DirectByteBuffer. When we read we use this buffer and copy the, +    // data after the read. When we go to write, we copy the data to the direct memory before calling write., +    // The choice of 64KB is rather arbitrary. We can explore different sizes in the future. However, any, +    // data that is copied to the buffer for a write, but not successfully flushed immediately, must be, +    // copied again on the next call., +, +        ByteBuffer ioBuffer = getSelector().getIoBuffer();, +        ioBuffer.limit(Math.min(buffer.remaining(), ioBuffer.limit()));, +        int bytesRead;, +            bytesRead = rawChannel.read(ioBuffer);, +        if (bytesRead < 0) {, +            closeNow = true;, +            return 0;, +        } else {, +            ioBuffer.flip();, +            buffer.put(ioBuffer);, +            return bytesRead;, +        }, +    protected int readFromChannel(InboundChannelBuffer channelBuffer) throws IOException {, +        ByteBuffer ioBuffer = getSelector().getIoBuffer();, +        int bytesRead;, +            bytesRead = rawChannel.read(ioBuffer);, +        if (bytesRead < 0) {, +            closeNow = true;, +            return 0;, +        } else {, +            ioBuffer.flip();, +            channelBuffer.ensureCapacity(channelBuffer.getIndex() + ioBuffer.remaining());, +            ByteBuffer[] buffers = channelBuffer.sliceBuffersFrom(channelBuffer.getIndex());, +            int j = 0;, +            while (j < buffers.length && ioBuffer.remaining() > 0) {, +                ByteBuffer buffer = buffers[j++];, +                copyBytes(ioBuffer, buffer);, +            }, +            channelBuffer.incrementIndex(bytesRead);, +            return bytesRead;, +        }, +        int initialPosition = buffer.position();, +        ByteBuffer ioBuffer = getSelector().getIoBuffer();, +        copyBytes(buffer, ioBuffer);, +        ioBuffer.flip();, +        int bytesWritten;, +            bytesWritten = rawChannel.write(ioBuffer);, +            buffer.position(initialPosition);, +        buffer.position(initialPosition + bytesWritten);, +        return bytesWritten;, +    protected int flushToChannel(FlushOperation flushOperation) throws IOException {, +        ByteBuffer ioBuffer = getSelector().getIoBuffer();, +, +        boolean continueFlush = flushOperation.isFullyFlushed() == false;, +        int totalBytesFlushed = 0;, +        while (continueFlush) {, +            ioBuffer.clear();, +            int j = 0;]