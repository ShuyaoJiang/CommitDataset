[+++ b/src/main/java/org/elasticsearch/gateway/blobstore/BlobStoreGateway.java, +import org.elasticsearch.ElasticSearchException;, +import org.elasticsearch.cluster.metadata.IndexMetaData;, +    @Override, +    protected void delete(IndexMetaData indexMetaData) throws ElasticSearchException {, +        BlobPath indexPath = basePath().add("indices").add(indexMetaData.index());, +        blobStore.delete(indexPath);, +    }, +++ b/src/main/java/org/elasticsearch/gateway/blobstore/BlobStoreGateway.java, +import org.elasticsearch.ElasticSearchException;, +import org.elasticsearch.cluster.metadata.IndexMetaData;, +    @Override, +    protected void delete(IndexMetaData indexMetaData) throws ElasticSearchException {, +        BlobPath indexPath = basePath().add("indices").add(indexMetaData.index());, +        blobStore.delete(indexPath);, +    }, +++ b/src/main/java/org/elasticsearch/gateway/local/state/meta/LocalGatewayMetaState.java, +    @Nullable, +    public MetaData loadMetaState() throws Exception {, +        return loadState();, +            // reset the current metadata, we need to start fresh..., +            this.currentMetaData = null;, +        MetaData newMetaData = event.state().metaData();, +            if (currentMetaData == null || !MetaData.isGlobalStateEquals(currentMetaData, newMetaData)) {, +                    writeGlobalState("changed", newMetaData, currentMetaData);, +            for (IndexMetaData indexMetaData : newMetaData) {, +                IndexMetaData currentIndexMetaData;, +                if (currentMetaData == null) {, +                    // a new event..., check from the state stored, +                    currentIndexMetaData = loadIndex(indexMetaData.index());, +                } else {, +                    currentIndexMetaData = currentMetaData.index(indexMetaData.index());, +                }, +        // delete indices that were there before, but are deleted now, +        // we need to do it so they won't be detected as dangling, +        if (nodeEnv.hasNodeFile()) {, +            if (currentMetaData != null) {, +                // only delete indices when we already received a state (currentMetaData != null), +                // and we had a go at processing dangling indices at least once, +                // this will also delete the _state of the index itself, +                for (IndexMetaData current : currentMetaData) {, +                    if (danglingIndices.containsKey(current.index())) {, +                        continue;, +                    }, +                    if (!newMetaData.hasIndex(current.index())) {, +                        logger.debug("[{}] deleting index that is no longer part of the metadata");, +                        FileSystemUtils.deleteRecursively(nodeEnv.indexLocations(new Index(current.index())));, +                    }, +                }, +            }, +        }, +, +                        if (newMetaData.hasIndex(danglingIndex)) {, +                            if (newMetaData.hasIndex(indexName)) {, +                            IndexMetaData indexMetaData = loadIndex(indexName);, +                            if (indexMetaData != null) {, +                        }, +                    if (indexMetaData == null) {, +                        logger.debug("failed to find state for dangling index [{}]", indexName);, +                        continue;, +                    }, +            currentMetaData = newMetaData;, +            if (previousMetaData != null && previousMetaData.version() != metaData.version()) {, +    private MetaData loadState() throws Exception {, +        return metaDataBuilder.build();, +    @Nullable, +++ b/src/main/java/org/elasticsearch/gateway/blobstore/BlobStoreGateway.java, +import org.elasticsearch.ElasticSearchException;, +import org.elasticsearch.cluster.metadata.IndexMetaData;, +    @Override, +    protected void delete(IndexMetaData indexMetaData) throws ElasticSearchException {, +        BlobPath indexPath = basePath().add("indices").add(indexMetaData.index());, +        blobStore.delete(indexPath);, +    }, +++ b/src/main/java/org/elasticsearch/gateway/local/state/meta/LocalGatewayMetaState.java, +    @Nullable, +    public MetaData loadMetaState() throws Exception {, +        return loadState();, +            // reset the current metadata, we need to start fresh..., +            this.currentMetaData = null;, +        MetaData newMetaData = event.state().metaData();, +            if (currentMetaData == null || !MetaData.isGlobalStateEquals(currentMetaData, newMetaData)) {, +                    writeGlobalState("changed", newMetaData, currentMetaData);, +            for (IndexMetaData indexMetaData : newMetaData) {, +                IndexMetaData currentIndexMetaData;, +                if (currentMetaData == null) {, +                    // a new event..., check from the state stored, +                    currentIndexMetaData = loadIndex(indexMetaData.index());, +                } else {, +                    currentIndexMetaData = currentMetaData.index(indexMetaData.index());, +                }, +        // delete indices that were there before, but are deleted now, +        // we need to do it so they won't be detected as dangling, +        if (nodeEnv.hasNodeFile()) {, +            if (currentMetaData != null) {, +                // only delete indices when we already received a state (currentMetaData != null), +                // and we had a go at processing dangling indices at least once, +                // this will also delete the _state of the index itself, +                for (IndexMetaData current : currentMetaData) {, +                    if (danglingIndices.containsKey(current.index())) {]