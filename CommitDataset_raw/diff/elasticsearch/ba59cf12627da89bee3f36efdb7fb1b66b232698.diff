[+++ b/server/src/main/java/org/elasticsearch/action/support/replication/TransportReplicationAction.java, +     * {@link IndexShard#acquireReplicaOperationPermit(long, long, ActionListener, String, Object)}., +            acquirePrimaryShardReference(request.shardId(), targetAllocationID, primaryTerm, this, request);, +            replica.acquireReplicaOperationPermit(primaryTerm, globalCheckpoint, this, executor, request);, +                                              ActionListener<PrimaryShardReference> onReferenceAcquired, Object debugInfo) {, +        indexShard.acquirePrimaryOperationPermit(onAcquired, executor, debugInfo);, +++ b/server/src/main/java/org/elasticsearch/action/support/replication/TransportReplicationAction.java, +     * {@link IndexShard#acquireReplicaOperationPermit(long, long, ActionListener, String, Object)}., +            acquirePrimaryShardReference(request.shardId(), targetAllocationID, primaryTerm, this, request);, +            replica.acquireReplicaOperationPermit(primaryTerm, globalCheckpoint, this, executor, request);, +                                              ActionListener<PrimaryShardReference> onReferenceAcquired, Object debugInfo) {, +        indexShard.acquirePrimaryOperationPermit(onAcquired, executor, debugInfo);, +++ b/server/src/main/java/org/elasticsearch/index/IndexService.java, +                                    ThreadPool.Names.SAME, "background global checkpoint sync");, +++ b/server/src/main/java/org/elasticsearch/action/support/replication/TransportReplicationAction.java, +     * {@link IndexShard#acquireReplicaOperationPermit(long, long, ActionListener, String, Object)}., +            acquirePrimaryShardReference(request.shardId(), targetAllocationID, primaryTerm, this, request);, +            replica.acquireReplicaOperationPermit(primaryTerm, globalCheckpoint, this, executor, request);, +                                              ActionListener<PrimaryShardReference> onReferenceAcquired, Object debugInfo) {, +        indexShard.acquirePrimaryOperationPermit(onAcquired, executor, debugInfo);, +++ b/server/src/main/java/org/elasticsearch/index/IndexService.java, +                                    ThreadPool.Names.SAME, "background global checkpoint sync");, +++ b/server/src/main/java/org/elasticsearch/index/shard/IndexShard.java, +     *, +     * @param debugInfo an extra information that can be useful when tracing an unreleased permit. When assertions are enabled, +     *                  the tracing will capture the supplied object's {@link Object#toString()} value. Otherwise the object, +     *                  isn't used, +    public void acquirePrimaryOperationPermit(ActionListener<Releasable> onPermitAcquired, String executorOnDelay, Object debugInfo) {, +        indexShardOperationPermits.acquire(onPermitAcquired, executorOnDelay, false, debugInfo);, +     * {@link #acquirePrimaryOperationPermit(ActionListener, String, Object)}). If the given primary term is lower than then one in, +     * @param debugInfo            an extra information that can be useful when tracing an unreleased permit. When assertions are enabled, +     *                             the tracing will capture the supplied object's {@link Object#toString()} value. Otherwise the object, +     *                             isn't used, +                                              final ActionListener<Releasable> onPermitAcquired, final String executorOnDelay,, +                                              final Object debugInfo) {, +                true, debugInfo);, +    /**, +     * @return a list of containing an exception for each operation permit that wasn't released yet. The stack traces of the exceptions, +     *         was captured when the operation acquired the permit and their message contains the debug information supplied at the time., +     */, +    public List<Throwable> getActiveOperations() {, +        return indexShardOperationPermits.getActiveOperations();, +    }, +, +++ b/server/src/main/java/org/elasticsearch/action/support/replication/TransportReplicationAction.java, +     * {@link IndexShard#acquireReplicaOperationPermit(long, long, ActionListener, String, Object)}., +            acquirePrimaryShardReference(request.shardId(), targetAllocationID, primaryTerm, this, request);, +            replica.acquireReplicaOperationPermit(primaryTerm, globalCheckpoint, this, executor, request);, +                                              ActionListener<PrimaryShardReference> onReferenceAcquired, Object debugInfo) {, +        indexShard.acquirePrimaryOperationPermit(onAcquired, executor, debugInfo);, +++ b/server/src/main/java/org/elasticsearch/index/IndexService.java, +                                    ThreadPool.Names.SAME, "background global checkpoint sync");, +++ b/server/src/main/java/org/elasticsearch/index/shard/IndexShard.java, +     *, +     * @param debugInfo an extra information that can be useful when tracing an unreleased permit. When assertions are enabled, +     *                  the tracing will capture the supplied object's {@link Object#toString()} value. Otherwise the object, +     *                  isn't used, +    public void acquirePrimaryOperationPermit(ActionListener<Releasable> onPermitAcquired, String executorOnDelay, Object debugInfo) {, +        indexShardOperationPermits.acquire(onPermitAcquired, executorOnDelay, false, debugInfo);, +     * {@link #acquirePrimaryOperationPermit(ActionListener, String, Object)}). If the given primary term is lower than then one in, +     * @param debugInfo            an extra information that can be useful when tracing an unreleased permit. When assertions are enabled, +     *                             the tracing will capture the supplied object's {@link Object#toString()} value. Otherwise the object, +     *                             isn't used, +                                              final ActionListener<Releasable> onPermitAcquired, final String executorOnDelay,, +                                              final Object debugInfo) {, +                true, debugInfo);, +    /**, +     * @return a list of containing an exception for each operation permit that wasn't released yet. The stack traces of the exceptions, +     *         was captured when the operation acquired the permit and their message contains the debug information supplied at the time., +     */, +    public List<Throwable> getActiveOperations() {, +        return indexShardOperationPermits.getActiveOperations();, +    }, +, +++ b/server/src/main/java/org/elasticsearch/index/shard/IndexShardOperationPermits.java, +import java.util.Map;, +import java.util.concurrent.ConcurrentHashMap;, +    private final List<DelayedOperation> delayedOperations = new ArrayList<>(); // operations that are delayed, +    // only valid when assertions are enabled. Key is AtomicBoolean associated with each permit to ensure close once semantics. Value is an, +    // exception with some extra info in the message + a stack trace of the acquirer, +    private final Map<AtomicBoolean, Throwable> issuedPermits;, +, +        if (Assertions.ENABLED) {, +            issuedPermits = new ConcurrentHashMap<>();, +        } else {, +            issuedPermits = null;, +        }, +        final List<DelayedOperation> queuedActions;, +                for (DelayedOperation queuedAction : queuedActions) {, +                    acquire(queuedAction.listener, null, false, queuedAction.debugInfo);, +     * @param debugInfo       an extra information that can be useful when tracing an unreleased permit. When assertions are enabled, +     *                        the tracing will capture the supplied object's {@link Object#toString()} value. Otherwise the object, +     *                        isn't used, +     *, +    public void acquire(final ActionListener<Releasable> onAcquired, final String executorOnDelay, final boolean forceExecution,, +                        final Object debugInfo) {, +        final Throwable debugInfoWithStackTrace;, +        if (Assertions.ENABLED) {, +            debugInfoWithStackTrace = new Throwable(debugInfo.toString());, +        } else {]