[+++ b/core/src/main/java/org/elasticsearch/common/lucene/uid/PerThreadIDAndVersionLookup.java, +import org.elasticsearch.common.lucene.uid.VersionsResolver.DocIdAndVersion;, +, +    /** used for assertions to make sure class usage meets assumptions */, +    private final Object readerKey;, +, +        if (termsEnum == null) {, +            throw new IllegalArgumentException("reader misses the [" + UidFieldMapper.NAME +, +                "] field");, +        }, +        if (versions == null) {, +            throw new IllegalArgumentException("reader misses the [" + VersionFieldMapper.NAME +, +                "] field");, +        Object readerKey = null;, +        assert (readerKey = reader.getCoreCacheKey()) != null;, +        this.readerKey = readerKey;, +    public DocIdAndVersion lookupVersion(BytesRef id, Bits liveDocs, LeafReaderContext context), +        throws IOException {, +        assert context.reader().getCoreCacheKey().equals(readerKey) :, +            "context's reader is not the same as the reader class was initialized on.";, +        int docID = getDocID(id, liveDocs);, +, +        if (docID != DocIdSetIterator.NO_MORE_DOCS) {, +            return new DocIdAndVersion(docID, versions.get(docID), context);, +        } else {, +            return null;, +        }, +    }, +, +    /**, +     * returns the internal lucene doc id for the given id bytes., +     * {@link DocIdSetIterator#NO_MORE_DOCS} is returned if not found, +     * */, +    private int getDocID(BytesRef id, Bits liveDocs) throws IOException {, +            int docID = DocIdSetIterator.NO_MORE_DOCS;, +            return docID;, +        } else {, +            return DocIdSetIterator.NO_MORE_DOCS;, +++ b/core/src/main/java/org/elasticsearch/common/lucene/uid/PerThreadIDAndVersionLookup.java, +import org.elasticsearch.common.lucene.uid.VersionsResolver.DocIdAndVersion;, +, +    /** used for assertions to make sure class usage meets assumptions */, +    private final Object readerKey;, +, +        if (termsEnum == null) {, +            throw new IllegalArgumentException("reader misses the [" + UidFieldMapper.NAME +, +                "] field");, +        }, +        if (versions == null) {, +            throw new IllegalArgumentException("reader misses the [" + VersionFieldMapper.NAME +, +                "] field");, +        Object readerKey = null;, +        assert (readerKey = reader.getCoreCacheKey()) != null;, +        this.readerKey = readerKey;, +    public DocIdAndVersion lookupVersion(BytesRef id, Bits liveDocs, LeafReaderContext context), +        throws IOException {, +        assert context.reader().getCoreCacheKey().equals(readerKey) :, +            "context's reader is not the same as the reader class was initialized on.";, +        int docID = getDocID(id, liveDocs);, +, +        if (docID != DocIdSetIterator.NO_MORE_DOCS) {, +            return new DocIdAndVersion(docID, versions.get(docID), context);, +        } else {, +            return null;, +        }, +    }, +, +    /**, +     * returns the internal lucene doc id for the given id bytes., +     * {@link DocIdSetIterator#NO_MORE_DOCS} is returned if not found, +     * */, +    private int getDocID(BytesRef id, Bits liveDocs) throws IOException {, +            int docID = DocIdSetIterator.NO_MORE_DOCS;, +            return docID;, +        } else {, +            return DocIdSetIterator.NO_MORE_DOCS;, +++ b/core/src/main/java/org/elasticsearch/common/lucene/uid/Versions.java, +public final class Versions {, +++ b/core/src/main/java/org/elasticsearch/common/lucene/uid/PerThreadIDAndVersionLookup.java, +import org.elasticsearch.common.lucene.uid.VersionsResolver.DocIdAndVersion;, +, +    /** used for assertions to make sure class usage meets assumptions */, +    private final Object readerKey;, +, +        if (termsEnum == null) {, +            throw new IllegalArgumentException("reader misses the [" + UidFieldMapper.NAME +, +                "] field");, +        }, +        if (versions == null) {, +            throw new IllegalArgumentException("reader misses the [" + VersionFieldMapper.NAME +, +                "] field");, +        Object readerKey = null;, +        assert (readerKey = reader.getCoreCacheKey()) != null;, +        this.readerKey = readerKey;, +    public DocIdAndVersion lookupVersion(BytesRef id, Bits liveDocs, LeafReaderContext context), +        throws IOException {, +        assert context.reader().getCoreCacheKey().equals(readerKey) :, +            "context's reader is not the same as the reader class was initialized on.";, +        int docID = getDocID(id, liveDocs);, +]