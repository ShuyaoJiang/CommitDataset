[+++ b/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/analysis/analyzer/Analyzer.java, +import org.elasticsearch.common.util.Comparators;, +import java.util.Comparator;, +    private static <E extends Expression> E resolveExpression(E expression, LogicalPlan plan) {, +                Attribute a = resolveAgainstList(ua, plan.output());, +    private static Attribute resolveAgainstList(UnresolvedAttribute u, List<Attribute> attrList) {, +        // first take into account the qualified version, +                        // if the field is unqualified, +                        // first check the names directly, +                        (Objects.equals(u.name(), attribute.name()), +                             // but also if the qualifier might not be quoted and if there's any ambiguity with nested fields, +                             || Objects.equals(u.name(), attribute.qualifiedName()));, +        return u.withUnresolvedMessage("Reference [" + u.qualifiedName(), +                + "] is ambiguous (to disambiguate use quotes or qualifiers); matches any of " + , +                 matches.stream(), +                 .map(a -> "\"" + a.qualifier() + "\".\"" + a.name() + "\""), +                 .sorted(), +                 .collect(toList()), +                );, +                            Attribute maybeResolved = resolveAgainstList((UnresolvedAttribute) grouping, resolved);, +                            .map(or -> resolveExpression(or, o.child())), +                    NamedExpression named = resolveAgainstList(u, childrenOutput);, +                Attribute q = resolveAgainstList(us.qualifier(), output);, +            E resolved = resolveExpression(exp, plan);, +++ b/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/analysis/analyzer/Analyzer.java, +import org.elasticsearch.common.util.Comparators;, +import java.util.Comparator;, +    private static <E extends Expression> E resolveExpression(E expression, LogicalPlan plan) {, +                Attribute a = resolveAgainstList(ua, plan.output());, +    private static Attribute resolveAgainstList(UnresolvedAttribute u, List<Attribute> attrList) {, +        // first take into account the qualified version, +                        // if the field is unqualified, +                        // first check the names directly, +                        (Objects.equals(u.name(), attribute.name()), +                             // but also if the qualifier might not be quoted and if there's any ambiguity with nested fields, +                             || Objects.equals(u.name(), attribute.qualifiedName()));, +        return u.withUnresolvedMessage("Reference [" + u.qualifiedName(), +                + "] is ambiguous (to disambiguate use quotes or qualifiers); matches any of " + , +                 matches.stream(), +                 .map(a -> "\"" + a.qualifier() + "\".\"" + a.name() + "\""), +                 .sorted(), +                 .collect(toList()), +                );, +                            Attribute maybeResolved = resolveAgainstList((UnresolvedAttribute) grouping, resolved);, +                            .map(or -> resolveExpression(or, o.child())), +                    NamedExpression named = resolveAgainstList(u, childrenOutput);, +                Attribute q = resolveAgainstList(us.qualifier(), output);, +            E resolved = resolveExpression(exp, plan);, +++ b/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/analysis/analyzer/FieldAttributeTests.java, +        // test multiple version of the attribute name, +        // to make sure all match the same thing, +, +        // NB: the equality is done on the same since each plan bumps the expression counter, +, +        // unqualified, +        FieldAttribute unqualified = parseQueryFor(fieldName);, +        // unquoted qualifier, +        FieldAttribute unquotedQualifier = parseQueryFor("test." + fieldName);, +        assertEquals(unqualified.name(), unquotedQualifier.name());, +        assertEquals(unqualified.qualifiedName(), unquotedQualifier.qualifiedName());, +        // quoted qualifier, +        FieldAttribute quotedQualifier = parseQueryFor("\"test\"." + fieldName);, +        assertEquals(unqualified.name(), quotedQualifier.name());, +        assertEquals(unqualified.qualifiedName(), quotedQualifier.qualifiedName());, +, +        return randomFrom(unqualified, unquotedQualifier, quotedQualifier);, +    }, +, +    private FieldAttribute parseQueryFor(String fieldName) {, +, +    public void testFieldAmbiguity() {, +        Map<String, EsField> mapping = TypesTests.loadMapping("mapping-dotted-field.json");, +, +        EsIndex index = new EsIndex("test", mapping);, +        getIndexResult = IndexResolution.valid(index);, +        analyzer = new Analyzer(functionRegistry, getIndexResult, DateTimeZone.UTC);, +, +        VerificationException ex = expectThrows(VerificationException.class, () -> plan("SELECT test.bar FROM test"));, +        assertEquals(, +                "Found 1 problem(s)\nline 1:8: Reference [test.bar] is ambiguous (to disambiguate use quotes or qualifiers); ", +                        + "matches any of [\"test\".\"bar\", \"test\".\"test.bar\"]",, +                ex.getMessage());, +, +        ex = expectThrows(VerificationException.class, () -> plan("SELECT test.test FROM test"));, +        assertEquals(, +                "Found 1 problem(s)\nline 1:8: Reference [test.test] is ambiguous (to disambiguate use quotes or qualifiers); ", +                        + "matches any of [\"test\".\"test\", \"test\".\"test.test\"]",, +                ex.getMessage());, +, +        LogicalPlan plan = plan("SELECT test.test FROM test AS x");, +        assertThat(plan, instanceOf(Project.class));, +, +        plan = plan("SELECT \"test\".test.test FROM test");, +        assertThat(plan, instanceOf(Project.class));, +, +        Project p = (Project) plan;, +        List<? extends NamedExpression> projections = p.projections();, +        assertThat(projections, hasSize(1));, +        Attribute attribute = projections.get(0).toAttribute();, +        assertThat(attribute, instanceOf(FieldAttribute.class));]