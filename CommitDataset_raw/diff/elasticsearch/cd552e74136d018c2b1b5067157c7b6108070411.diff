[+++ b/src/main/java/org/elasticsearch/common/bytes/PagedBytesReference.java, +            final int numBytesToCopy = Math.min(len, length - pos); // copy the full lenth or the remaining part, +            long byteArrayOffset = offset + pos;, +            int copiedBytes = 0;, +            while (copiedBytes < numBytesToCopy) {, +                long pageFragment = PAGE_SIZE - (byteArrayOffset % PAGE_SIZE); // how much can we read until hitting N*PAGE_SIZE?, +                int bulkSize = (int)Math.min(pageFragment, numBytesToCopy - copiedBytes); // we cannot copy more than a page fragment, +                boolean copied = bytearray.get(byteArrayOffset, bulkSize, ref); // get the fragment, +                System.arraycopy(ref.bytes, ref.offset, b, bOffset + copiedBytes, bulkSize); // copy fragment contents, +                copiedBytes += bulkSize; // count how much we copied, +                byteArrayOffset += bulkSize; // advance ByteArray index, +            pos += copiedBytes; // finally advance our stream position, +            return copiedBytes;, +++ b/src/main/java/org/elasticsearch/common/bytes/PagedBytesReference.java, +            final int numBytesToCopy = Math.min(len, length - pos); // copy the full lenth or the remaining part, +            long byteArrayOffset = offset + pos;, +            int copiedBytes = 0;, +            while (copiedBytes < numBytesToCopy) {, +                long pageFragment = PAGE_SIZE - (byteArrayOffset % PAGE_SIZE); // how much can we read until hitting N*PAGE_SIZE?, +                int bulkSize = (int)Math.min(pageFragment, numBytesToCopy - copiedBytes); // we cannot copy more than a page fragment, +                boolean copied = bytearray.get(byteArrayOffset, bulkSize, ref); // get the fragment, +                System.arraycopy(ref.bytes, ref.offset, b, bOffset + copiedBytes, bulkSize); // copy fragment contents, +                copiedBytes += bulkSize; // count how much we copied, +                byteArrayOffset += bulkSize; // advance ByteArray index, +            pos += copiedBytes; // finally advance our stream position, +            return copiedBytes;, +++ b/src/test/java/org/elasticsearch/common/bytes/PagedBytesReferenceTest.java, +    public void testRandomReads() throws IOException {, +        int length = randomIntBetween(10, scaledRandomIntBetween(PAGE_SIZE * 2, PAGE_SIZE * 20));, +        BytesReference pbr = getRandomizedPagedBytesReference(length);, +        StreamInput streamInput = pbr.streamInput();, +        BytesRef target = new BytesRef();, +        while(target.length < pbr.length()) {, +            switch (randomIntBetween(0, 10)) {, +                case 6:, +                case 5:, +                    target.append(new BytesRef(new byte[] {streamInput.readByte()}));, +                    break;, +                case 4:, +                case 3:, +                    BytesRef bytesRef = streamInput.readBytesRef(scaledRandomIntBetween(1, pbr.length() - target.length));, +                    target.append(bytesRef);, +                    break;, +                default:, +                    byte[] buffer = new byte[scaledRandomIntBetween(1, pbr.length() - target.length)];, +                    int offset = scaledRandomIntBetween(0, buffer.length - 1);, +                    int read = streamInput.read(buffer, offset, buffer.length - offset);, +                    target.append(new BytesRef(buffer, offset, read));, +                    break;, +            }, +        }, +        assertEquals(pbr.length(), target.length);, +        assertArrayEquals(pbr.toBytes(), Arrays.copyOfRange(target.bytes, target.offset, target.length));, +    }, +, +, +        sliceInput.reset();, +        byte[] buffer = new byte[sliceLength + scaledRandomIntBetween(1, 100)];, +        int offset  = scaledRandomIntBetween(0, Math.max(1, buffer.length - sliceLength - 1));, +        int read = sliceInput.read(buffer, offset, sliceLength / 2);, +        sliceInput.read(buffer, offset + read, sliceLength);, +        assertArrayEquals(sliceBytes, Arrays.copyOfRange(buffer, offset, offset + sliceLength));, +++ b/src/main/java/org/elasticsearch/common/bytes/PagedBytesReference.java, +            final int numBytesToCopy = Math.min(len, length - pos); // copy the full lenth or the remaining part, +            long byteArrayOffset = offset + pos;, +            int copiedBytes = 0;, +            while (copiedBytes < numBytesToCopy) {, +                long pageFragment = PAGE_SIZE - (byteArrayOffset % PAGE_SIZE); // how much can we read until hitting N*PAGE_SIZE?, +                int bulkSize = (int)Math.min(pageFragment, numBytesToCopy - copiedBytes); // we cannot copy more than a page fragment, +                boolean copied = bytearray.get(byteArrayOffset, bulkSize, ref); // get the fragment, +                System.arraycopy(ref.bytes, ref.offset, b, bOffset + copiedBytes, bulkSize); // copy fragment contents, +                copiedBytes += bulkSize; // count how much we copied, +                byteArrayOffset += bulkSize; // advance ByteArray index, +            pos += copiedBytes; // finally advance our stream position, +            return copiedBytes;, +++ b/src/test/java/org/elasticsearch/common/bytes/PagedBytesReferenceTest.java, +    public void testRandomReads() throws IOException {, +        int length = randomIntBetween(10, scaledRandomIntBetween(PAGE_SIZE * 2, PAGE_SIZE * 20));, +        BytesReference pbr = getRandomizedPagedBytesReference(length);, +        StreamInput streamInput = pbr.streamInput();, +        BytesRef target = new BytesRef();, +        while(target.length < pbr.length()) {, +            switch (randomIntBetween(0, 10)) {, +                case 6:, +                case 5:, +                    target.append(new BytesRef(new byte[] {streamInput.readByte()}));, +                    break;, +                case 4:, +                case 3:, +                    BytesRef bytesRef = streamInput.readBytesRef(scaledRandomIntBetween(1, pbr.length() - target.length));, +                    target.append(bytesRef);, +                    break;, +                default:, +                    byte[] buffer = new byte[scaledRandomIntBetween(1, pbr.length() - target.length)];, +                    int offset = scaledRandomIntBetween(0, buffer.length - 1);, +                    int read = streamInput.read(buffer, offset, buffer.length - offset);, +                    target.append(new BytesRef(buffer, offset, read));, +                    break;, +            }, +        }]