[+++ b/src/test/java/org/elasticsearch/AbstractSharedClusterTest.java, +import org.elasticsearch.action.ActionListener;, +import org.hamcrest.Matchers;, +import java.util.concurrent.CopyOnWriteArrayList;, +import java.util.concurrent.CountDownLatch;, +        final CopyOnWriteArrayList<Throwable> errors = new CopyOnWriteArrayList<Throwable>();, +        List<CountDownLatch> latches = new ArrayList<CountDownLatch>();, +        if (frequently()) {, +            logger.info("Index [{}] docs async: [{}]", list.size(), true);, +            final CountDownLatch latch = new CountDownLatch(list.size());, +            latches.add(latch);, +            for (IndexRequestBuilder indexRequestBuilder : list) {, +                indexRequestBuilder.execute(new LatchedActionListener<IndexResponse>(latch, errors));, +                if (rarely()) {, +                    if (rarely()) {, +                        client().admin().indices().prepareRefresh(index).execute(new LatchedActionListener<RefreshResponse>(newLatch(latches), errors));, +                    } else if (rarely()) {, +                        client().admin().indices().prepareFlush(index).execute(new LatchedActionListener<FlushResponse>(newLatch(latches), errors));, +                    } else if (rarely()) {, +                        client().admin().indices().prepareOptimize(index).setMaxNumSegments(between(1, 10)).setFlush(random.nextBoolean()).execute(new LatchedActionListener<OptimizeResponse>(newLatch(latches), errors));, +                    }, +                }, +            }, +            , +        } else {, +            logger.info("Index [{}] docs async: [{}]", list.size(), false);, +                        client().admin().indices().prepareRefresh(index).execute(new LatchedActionListener<RefreshResponse>(newLatch(latches), errors));, +                        client().admin().indices().prepareFlush(index).execute(new LatchedActionListener<FlushResponse>(newLatch(latches), errors));, +                        client().admin().indices().prepareOptimize(index).setMaxNumSegments(between(1, 10)).setFlush(random.nextBoolean()).execute(new LatchedActionListener<OptimizeResponse>(newLatch(latches), errors));, +        }, +        for (CountDownLatch countDownLatch : latches) {, +            countDownLatch.await();, +        }, +        assertThat(errors, Matchers.emptyIterable());, +    private static final CountDownLatch newLatch(List<CountDownLatch> latches) {, +        CountDownLatch l = new CountDownLatch(1);, +        latches.add(l);, +        return l;, +    }, +    , +    private static class LatchedActionListener<Response> implements ActionListener<Response> {, +        private final CountDownLatch latch;, +        private final CopyOnWriteArrayList<Throwable> errors;, +        , +        public LatchedActionListener(CountDownLatch latch, CopyOnWriteArrayList<Throwable> errors) {, +            this.latch = latch;, +            this.errors = errors;, +        }, +, +        @Override, +        public void onResponse(Response response) {, +            latch.countDown();, +        }, +, +        @Override, +        public void onFailure(Throwable e) {, +            try {, +            errors.add(e);, +            } finally {, +            latch.countDown();, +            }, +        }, +        , +    }, +]