[+++ b/x-pack/plugin/ccr/src/main/java/org/elasticsearch/xpack/ccr/CcrLicenseChecker.java, +                    final Client remoteClient = client.getRemoteClusterClient(clusterAlias);, +                    hasPrivilegesToFollowIndices(remoteClient, new String[] {leaderIndex}, e -> {, +                            fetchLeaderHistoryUUIDs(remoteClient, leaderIndexMetaData, onFailure, historyUUIDs ->, +     * @param remoteClient               the remote client to use to execute cluster state API, +            final Client remoteClient,, +                            remoteClient.admin().cluster().state(request, clusterStateListener);, +     * Fetches the history UUIDs for leader index on per shard basis using the specified remoteClient., +     * @param remoteClient                              the remote client, +        final Client remoteClient,, +        remoteClient.admin().indices().stats(request, ActionListener.wrap(indicesStatsHandler, onFailure));, +     * @param remoteClient the remote client, +    public void hasPrivilegesToFollowIndices(final Client remoteClient, final String[] indices, final Consumer<Exception> handler) {, +        Objects.requireNonNull(remoteClient, "remoteClient");, +        ThreadContext threadContext = remoteClient.threadPool().getThreadContext();, +        remoteClient.execute(HasPrivilegesAction.INSTANCE, request, ActionListener.wrap(responseHandler, handler));, +++ b/x-pack/plugin/ccr/src/main/java/org/elasticsearch/xpack/ccr/CcrLicenseChecker.java, +                    final Client remoteClient = client.getRemoteClusterClient(clusterAlias);, +                    hasPrivilegesToFollowIndices(remoteClient, new String[] {leaderIndex}, e -> {, +                            fetchLeaderHistoryUUIDs(remoteClient, leaderIndexMetaData, onFailure, historyUUIDs ->, +     * @param remoteClient               the remote client to use to execute cluster state API, +            final Client remoteClient,, +                            remoteClient.admin().cluster().state(request, clusterStateListener);, +     * Fetches the history UUIDs for leader index on per shard basis using the specified remoteClient., +     * @param remoteClient                              the remote client, +        final Client remoteClient,, +        remoteClient.admin().indices().stats(request, ActionListener.wrap(indicesStatsHandler, onFailure));, +     * @param remoteClient the remote client, +    public void hasPrivilegesToFollowIndices(final Client remoteClient, final String[] indices, final Consumer<Exception> handler) {, +        Objects.requireNonNull(remoteClient, "remoteClient");, +        ThreadContext threadContext = remoteClient.threadPool().getThreadContext();, +        remoteClient.execute(HasPrivilegesAction.INSTANCE, request, ActionListener.wrap(responseHandler, handler));, +++ b/x-pack/plugin/ccr/src/main/java/org/elasticsearch/xpack/ccr/action/ShardFollowTasksExecutor.java, +        final Client remoteClient;, +            remoteClient = wrapClient(client.getRemoteClusterClient(params.getRemoteCluster()), params.getHeaders());, +            remoteClient = wrapClient(client, params.getHeaders());, +                remoteClient.admin().cluster().state(clusterStateRequest, ActionListener.wrap(clusterStateResponse -> {, +                remoteClient.admin().cluster().state(clusterStateRequest, ActionListener.wrap(onResponse, errorHandler));, +                remoteClient.execute(ShardChangesAction.INSTANCE, request, ActionListener.wrap(handler::accept, errorHandler));, +++ b/x-pack/plugin/ccr/src/main/java/org/elasticsearch/xpack/ccr/CcrLicenseChecker.java, +                    final Client remoteClient = client.getRemoteClusterClient(clusterAlias);, +                    hasPrivilegesToFollowIndices(remoteClient, new String[] {leaderIndex}, e -> {, +                            fetchLeaderHistoryUUIDs(remoteClient, leaderIndexMetaData, onFailure, historyUUIDs ->, +     * @param remoteClient               the remote client to use to execute cluster state API, +            final Client remoteClient,, +                            remoteClient.admin().cluster().state(request, clusterStateListener);, +     * Fetches the history UUIDs for leader index on per shard basis using the specified remoteClient., +     * @param remoteClient                              the remote client, +        final Client remoteClient,, +        remoteClient.admin().indices().stats(request, ActionListener.wrap(indicesStatsHandler, onFailure));, +     * @param remoteClient the remote client, +    public void hasPrivilegesToFollowIndices(final Client remoteClient, final String[] indices, final Consumer<Exception> handler) {, +        Objects.requireNonNull(remoteClient, "remoteClient");, +        ThreadContext threadContext = remoteClient.threadPool().getThreadContext();, +        remoteClient.execute(HasPrivilegesAction.INSTANCE, request, ActionListener.wrap(responseHandler, handler));, +++ b/x-pack/plugin/ccr/src/main/java/org/elasticsearch/xpack/ccr/action/ShardFollowTasksExecutor.java, +        final Client remoteClient;, +            remoteClient = wrapClient(client.getRemoteClusterClient(params.getRemoteCluster()), params.getHeaders());, +            remoteClient = wrapClient(client, params.getHeaders());, +                remoteClient.admin().cluster().state(clusterStateRequest, ActionListener.wrap(clusterStateResponse -> {, +                remoteClient.admin().cluster().state(clusterStateRequest, ActionListener.wrap(onResponse, errorHandler));, +                remoteClient.execute(ShardChangesAction.INSTANCE, request, ActionListener.wrap(handler::accept, errorHandler));, +++ b/x-pack/plugin/ccr/src/main/java/org/elasticsearch/xpack/ccr/action/TransportPutAutoFollowPatternAction.java, +        final Client remoteClient = client.getRemoteClusterClient(request.getRemoteCluster());, +        ccrLicenseChecker.hasPrivilegesToFollowIndices(remoteClient, indices, e -> {, +                remoteClient.admin().cluster().state(]