[+++ b/build.gradle, +      javadoc = false, +  gradle.projectsEvaluated {, +  tasks.cleanIdea {, +    delete '.idea', +  }, +++ b/build.gradle, +      javadoc = false, +  gradle.projectsEvaluated {, +  tasks.cleanIdea {, +    delete '.idea', +  }, +++ b/buildSrc/src/main/groovy/com/carrotsearch/gradle/junit4/RandomizedTestingTask.groovy, +            haltOnFailure: haltOnFailure,, +        def junit4 = NamespaceBuilder.newInstance(ant, 'junit4'), +++ b/build.gradle, +      javadoc = false, +  gradle.projectsEvaluated {, +  tasks.cleanIdea {, +    delete '.idea', +  }, +++ b/buildSrc/src/main/groovy/com/carrotsearch/gradle/junit4/RandomizedTestingTask.groovy, +            haltOnFailure: haltOnFailure,, +        def junit4 = NamespaceBuilder.newInstance(ant, 'junit4'), +++ b/buildSrc/src/main/groovy/com/carrotsearch/gradle/junit4/TestReportLogger.groovy, +        outStream = new LoggingOutputStream(logger: logger, level: LogLevel.ERROR, prefix: "  1> "), +            emitSuiteStart(LogLevel.INFO, evt.getDescription());, +        if (isPassthrough() && logger.isInfoEnabled()) {, +        try {, +        LogLevel level = e.isSuccessful() ? LogLevel.INFO : LogLevel.ERROR, +    } catch (Exception exc) {, +            logger.lifecycle('EXCEPTION: ', exc), +        }, +    /** Returns true if output should be logged immediately. Only relevant when running with INFO log level. */, +        return forkedJvmCount == 1 && config.outputMode == OutputMode.ALWAYS && logger.isInfoEnabled(), +++ b/build.gradle, +      javadoc = false, +  gradle.projectsEvaluated {, +  tasks.cleanIdea {, +    delete '.idea', +  }, +++ b/buildSrc/src/main/groovy/com/carrotsearch/gradle/junit4/RandomizedTestingTask.groovy, +            haltOnFailure: haltOnFailure,, +        def junit4 = NamespaceBuilder.newInstance(ant, 'junit4'), +++ b/buildSrc/src/main/groovy/com/carrotsearch/gradle/junit4/TestReportLogger.groovy, +        outStream = new LoggingOutputStream(logger: logger, level: LogLevel.ERROR, prefix: "  1> "), +            emitSuiteStart(LogLevel.INFO, evt.getDescription());, +        if (isPassthrough() && logger.isInfoEnabled()) {, +        try {, +        LogLevel level = e.isSuccessful() ? LogLevel.INFO : LogLevel.ERROR, +    } catch (Exception exc) {, +            logger.lifecycle('EXCEPTION: ', exc), +        }, +    /** Returns true if output should be logged immediately. Only relevant when running with INFO log level. */, +        return forkedJvmCount == 1 && config.outputMode == OutputMode.ALWAYS && logger.isInfoEnabled(), +++ b/buildSrc/src/main/groovy/org/elasticsearch/gradle/BuildPlugin.groovy, +import org.gradle.process.ExecResult, +, +    /** Performs checks on the build environment and prints information about the build environment. */, +            String javaHome = findJavaHome(), +            File gradleJavaHome = Jvm.current().javaHome, +            String gradleJavaVersionDetails = "${System.getProperty('java.vendor')} ${System.getProperty('java.version')}" +, +                " [${System.getProperty('java.vm.name')} ${System.getProperty('java.vm.version')}]", +, +            String javaVersionDetails = gradleJavaVersionDetails, +            String javaVersion = System.getProperty('java.version'), +            JavaVersion javaVersionEnum = JavaVersion.current(), +            if (new File(javaHome).canonicalPath != gradleJavaHome.canonicalPath) {, +                javaVersionDetails = findJavaVersionDetails(project, javaHome), +                javaVersionEnum = JavaVersion.toVersion(findJavaSpecificationVersion(project, javaHome)), +                javaVersion = findJavaVersion(project, javaHome), +            }, +            if (gradleJavaVersionDetails != javaVersionDetails) {, +                println "  JDK Version (gradle)  : ${gradleJavaVersionDetails}", +                println "  JDK Version (compile) : ${javaVersionDetails}", +            } else {, +                println "  JDK Version           : ${gradleJavaVersionDetails}", +            }, +            if (javaVersionEnum < minimumJava) {, +            project.rootProject.ext.javaHome = javaHome, +            project.rootProject.ext.javaVersion = javaVersion, +            project.rootProject.ext.buildChecksDone = true, +        }, +        project.targetCompatibility = minimumJava, +        project.sourceCompatibility = minimumJava, +        // set java home for each project, so they dont have to find it in the root project, +        project.ext.javaHome = project.rootProject.ext.javaHome, +        project.ext.javaVersion = project.rootProject.ext.javaVersion, +    }, +, +    /** Finds and enforces JAVA_HOME is set */, +    private static String findJavaHome() {, +        String javaHome = System.getenv('JAVA_HOME'), +        return javaHome, +    /** Finds printable java version of the given JAVA_HOME */, +    private static String findJavaVersionDetails(Project project, String javaHome) {, +        String versionInfoScript = 'print(' +, +            'java.lang.System.getProperty("java.vendor") + " " + java.lang.System.getProperty("java.version") + ' +, +            '" [" + java.lang.System.getProperty("java.vm.name") + " " + java.lang.System.getProperty("java.vm.version") + "]");', +        return runJavascript(project, javaHome, versionInfoScript).trim()]