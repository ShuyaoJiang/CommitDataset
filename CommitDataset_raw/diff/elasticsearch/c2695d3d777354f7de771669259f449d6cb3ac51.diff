[+++ b/src/main/java/org/elasticsearch/search/aggregations/bucket/histogram/HistogramAggregator.java, +        CollectionUtil.introSort(buckets, order.comparator());, +++ b/src/main/java/org/elasticsearch/search/aggregations/bucket/histogram/HistogramAggregator.java, +        CollectionUtil.introSort(buckets, order.comparator());, +++ b/src/main/java/org/elasticsearch/search/aggregations/bucket/histogram/InternalHistogram.java, +    @Override, +    public InternalAggregation reduce(ReduceContext reduceContext) {, +        LongObjectPagedHashMap<List<B>> bucketsByKey = new LongObjectPagedHashMap<>(reduceContext.bigArrays());, +            for (B bucket : histogram.buckets) {, +                List<B> bucketList = bucketsByKey.get(bucket.key);, +                if (bucketList == null) {, +                    bucketList = new ArrayList<>(aggregations.size());, +                    bucketsByKey.put(bucket.key, bucketList);, +                }, +                bucketList.add(bucket);, +        List<B> reducedBuckets = new ArrayList<>((int) bucketsByKey.size());, +        for (LongObjectPagedHashMap.Cursor<List<B>> cursor : bucketsByKey) {, +            List<B> sameTermBuckets = cursor.value;, +            B bucket = sameTermBuckets.get(0).reduce(sameTermBuckets, reduceContext);, +            if (bucket.getDocCount() >= minDocCount) {, +                reducedBuckets.add(bucket);, +        bucketsByKey.close();, +        // adding empty buckets in needed, +        if (minDocCount == 0) {, +            CollectionUtil.introSort(reducedBuckets, order.asc ? InternalOrder.KEY_ASC.comparator() : InternalOrder.KEY_DESC.comparator());, +            List<B> list = order.asc ? reducedBuckets : Lists.reverse(reducedBuckets);, +, +            if (order != InternalOrder.KEY_ASC && order != InternalOrder.KEY_DESC) {, +                CollectionUtil.introSort(reducedBuckets, order.comparator());]