[+++ b/src/main/java/org/elasticsearch/gateway/TransportNodesListGatewayStartedShards.java, +import org.elasticsearch.index.shard.ShardPath;, +import org.elasticsearch.index.store.Store;, +                final IndexMetaData metaData = clusterService.state().metaData().index(shardId.index().name()); // it's a mystery why this is sometimes null, +                if (metaData != null && canOpenIndex(request.getShardId(), metaData) == false) {, +                    logger.trace("{} can't open index for shard", shardId);, +                    return new NodeGatewayStartedShards(clusterService.localNode(), -1);, +                }, +    private boolean canOpenIndex(ShardId shardId, IndexMetaData metaData) throws IOException {, +        // try and see if we an list unallocated, +        if (metaData == null) {, +            return false;, +        }, +        final ShardPath shardPath = ShardPath.loadShardPath(logger, nodeEnv, shardId, metaData.settings());, +        if (shardPath == null) {, +            return false;, +        }, +        return Store.canOpenIndex(logger, shardPath.resolveIndex());, +    }, +, +++ b/src/main/java/org/elasticsearch/gateway/TransportNodesListGatewayStartedShards.java, +import org.elasticsearch.index.shard.ShardPath;, +import org.elasticsearch.index.store.Store;, +                final IndexMetaData metaData = clusterService.state().metaData().index(shardId.index().name()); // it's a mystery why this is sometimes null, +                if (metaData != null && canOpenIndex(request.getShardId(), metaData) == false) {, +                    logger.trace("{} can't open index for shard", shardId);, +                    return new NodeGatewayStartedShards(clusterService.localNode(), -1);, +                }, +    private boolean canOpenIndex(ShardId shardId, IndexMetaData metaData) throws IOException {, +        // try and see if we an list unallocated, +        if (metaData == null) {, +            return false;, +        }, +        final ShardPath shardPath = ShardPath.loadShardPath(logger, nodeEnv, shardId, metaData.settings());, +        if (shardPath == null) {, +            return false;, +        }, +        return Store.canOpenIndex(logger, shardPath.resolveIndex());, +    }, +, +++ b/src/main/java/org/elasticsearch/index/store/Store.java, +     * Returns <code>true</code> iff the given location contains an index an the index, +     * can be successfully opened. This includes reading the segment infos and possible, +     * corruption markers., +     */, +    public static boolean canOpenIndex(ESLogger logger, Path indexLocation) throws IOException {, +        try (Directory dir = new SimpleFSDirectory(indexLocation)) {, +            failIfCorrupted(dir, new ShardId("", 1));, +            Lucene.readSegmentInfos(dir);, +            return true;, +        } catch (Exception ex) {, +            logger.trace("Can't open index for path [{}]", ex, indexLocation);, +            return false;, +        }, +    }, +, +    /**, +++ b/src/main/java/org/elasticsearch/gateway/TransportNodesListGatewayStartedShards.java, +import org.elasticsearch.index.shard.ShardPath;, +import org.elasticsearch.index.store.Store;, +                final IndexMetaData metaData = clusterService.state().metaData().index(shardId.index().name()); // it's a mystery why this is sometimes null, +                if (metaData != null && canOpenIndex(request.getShardId(), metaData) == false) {, +                    logger.trace("{} can't open index for shard", shardId);, +                    return new NodeGatewayStartedShards(clusterService.localNode(), -1);, +                }, +    private boolean canOpenIndex(ShardId shardId, IndexMetaData metaData) throws IOException {, +        // try and see if we an list unallocated, +        if (metaData == null) {, +            return false;, +        }, +        final ShardPath shardPath = ShardPath.loadShardPath(logger, nodeEnv, shardId, metaData.settings());, +        if (shardPath == null) {, +            return false;, +        }, +        return Store.canOpenIndex(logger, shardPath.resolveIndex());, +    }, +, +++ b/src/main/java/org/elasticsearch/index/store/Store.java, +     * Returns <code>true</code> iff the given location contains an index an the index, +     * can be successfully opened. This includes reading the segment infos and possible, +     * corruption markers., +     */, +    public static boolean canOpenIndex(ESLogger logger, Path indexLocation) throws IOException {, +        try (Directory dir = new SimpleFSDirectory(indexLocation)) {, +            failIfCorrupted(dir, new ShardId("", 1));, +            Lucene.readSegmentInfos(dir);, +            return true;, +        } catch (Exception ex) {, +            logger.trace("Can't open index for path [{}]", ex, indexLocation);, +            return false;, +        }, +    }, +, +    /**, +++ b/src/test/java/org/elasticsearch/index/store/StoreTest.java, +import java.nio.file.Path;, +, +    public void testCanOpenIndex() throws IOException {, +        IndexWriterConfig iwc = newIndexWriterConfig();, +        Path tempDir = createTempDir();]