[+++ b/core/src/main/java/org/elasticsearch/action/search/ClearScrollController.java, +        SearchScrollAsyncAction.collectNodesAndRun(parsedScrollIds, nodes, searchTransportService, ActionListener.wrap(, +            lookup -> {, +                    final DiscoveryNode node = lookup.apply(target.getClusterAlias(), target.getNode());, +                            Transport.Connection connection = searchTransportService.getConnection(target.getClusterAlias(), node);, +                                ActionListener.wrap(freed -> onFreedContext(freed.isFreed()), e -> onFailedFreedContext(e, node)));, +            }, listener::onFailure));, +++ b/core/src/main/java/org/elasticsearch/action/search/ClearScrollController.java, +        SearchScrollAsyncAction.collectNodesAndRun(parsedScrollIds, nodes, searchTransportService, ActionListener.wrap(, +            lookup -> {, +                    final DiscoveryNode node = lookup.apply(target.getClusterAlias(), target.getNode());, +                            Transport.Connection connection = searchTransportService.getConnection(target.getClusterAlias(), node);, +                                ActionListener.wrap(freed -> onFreedContext(freed.isFreed()), e -> onFailedFreedContext(e, node)));, +            }, listener::onFailure));, +++ b/core/src/main/java/org/elasticsearch/action/search/ScrollIdForNode.java, +import org.elasticsearch.common.inject.internal.Nullable;, +, +    private final String clusterAlias;, +    ScrollIdForNode(@Nullable String clusterAlias, String node, long scrollId) {, +        this.clusterAlias = clusterAlias;, +    public String getClusterAlias() {, +        return clusterAlias;, +    }, +, +, +    @Override, +    public String toString() {, +        return "ScrollIdForNode{" +, +            "node='" + node + '\'' +, +            ", scrollId=" + scrollId +, +            ", clusterAlias='" + clusterAlias + '\'' +, +            '}';, +    }, +++ b/core/src/main/java/org/elasticsearch/action/search/ClearScrollController.java, +        SearchScrollAsyncAction.collectNodesAndRun(parsedScrollIds, nodes, searchTransportService, ActionListener.wrap(, +            lookup -> {, +                    final DiscoveryNode node = lookup.apply(target.getClusterAlias(), target.getNode());, +                            Transport.Connection connection = searchTransportService.getConnection(target.getClusterAlias(), node);, +                                ActionListener.wrap(freed -> onFreedContext(freed.isFreed()), e -> onFailedFreedContext(e, node)));, +            }, listener::onFailure));, +++ b/core/src/main/java/org/elasticsearch/action/search/ScrollIdForNode.java, +import org.elasticsearch.common.inject.internal.Nullable;, +, +    private final String clusterAlias;, +    ScrollIdForNode(@Nullable String clusterAlias, String node, long scrollId) {, +        this.clusterAlias = clusterAlias;, +    public String getClusterAlias() {, +        return clusterAlias;, +    }, +, +, +    @Override, +    public String toString() {, +        return "ScrollIdForNode{" +, +            "node='" + node + '\'' +, +            ", scrollId=" + scrollId +, +            ", clusterAlias='" + clusterAlias + '\'' +, +            '}';, +    }, +++ b/core/src/main/java/org/elasticsearch/action/search/SearchScrollAsyncAction.java, +import org.elasticsearch.transport.RemoteClusterService;, +import org.elasticsearch.transport.Transport;, +import java.util.Arrays;, +import java.util.HashSet;, +import java.util.Set;, +import java.util.function.BiFunction;, +    protected final SearchTransportService searchTransportService;, +                                      SearchScrollRequest request,, +                                      SearchTransportService searchTransportService) {, +        this.searchTransportService = searchTransportService;, +        } else {, +            collectNodesAndRun(Arrays.asList(context), nodes, searchTransportService, ActionListener.wrap(lookup -> run(lookup, context),, +                listener::onFailure));, +    }, +, +    /**, +     * This method collects nodes from the remote clusters asynchronously if any of the scroll IDs references a remote cluster., +     * Otherwise the action listener will be invoked immediately with a function based on the given discovery nodes., +     */, +    static void collectNodesAndRun(final Iterable<ScrollIdForNode> scrollIds, DiscoveryNodes nodes,, +                                   SearchTransportService searchTransportService,, +                                   ActionListener<BiFunction<String, String, DiscoveryNode>> listener) {, +        Set<String> clusters = new HashSet<>();, +        for (ScrollIdForNode target : scrollIds) {, +            if (target.getClusterAlias() != null) {, +                clusters.add(target.getClusterAlias());, +            }, +        }, +        if (clusters.isEmpty()) { // no remote clusters, +            listener.onResponse((cluster, node) -> nodes.get(node));, +        } else {, +            RemoteClusterService remoteClusterService = searchTransportService.getRemoteClusterService();, +            remoteClusterService.collectNodes(clusters, ActionListener.wrap(nodeFunction -> {, +                final BiFunction<String, String, DiscoveryNode> clusterNodeLookup = (clusterAlias, node) -> {, +                    if (clusterAlias == null) {, +                        return nodes.get(node);, +                    } else {, +                        return nodeFunction.apply(clusterAlias, node);, +                    }, +                };]