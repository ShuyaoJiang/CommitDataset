[+++ b/core/src/main/java/org/elasticsearch/action/support/replication/TransportReplicationAction.java, +import org.elasticsearch.index.mapper.MapperService;, +import org.elasticsearch.river.RiverIndexName;, +        final boolean created;, +            if (indexName.equals(RiverIndexName.Conf.indexName(settings))) {, +                // With rivers, we have a chicken and egg problem if indexing, +                // the _meta document triggers a mapping update. Because we would, +                // like to validate the mapping update first, but on the other, +                // hand putting the mapping would start the river, which expects, +                // to find a _meta document, +                // So we have no choice but to index first and send mappings afterwards, +                MapperService mapperService = indexShard.indexService().mapperService();, +                mapperService.merge(request.type(), new CompressedXContent(update.toBytes()), true);, +                created = operation.execute(indexShard);, +                mappingUpdatedAction.updateMappingOnMasterAsynchronously(indexName, request.type(), update);, +            } else {, +                created = operation.execute(indexShard);, +        } else {, +            created = operation.execute(indexShard);, +        }, +++ b/core/src/main/java/org/elasticsearch/action/support/replication/TransportReplicationAction.java, +import org.elasticsearch.index.mapper.MapperService;, +import org.elasticsearch.river.RiverIndexName;, +        final boolean created;, +            if (indexName.equals(RiverIndexName.Conf.indexName(settings))) {, +                // With rivers, we have a chicken and egg problem if indexing, +                // the _meta document triggers a mapping update. Because we would, +                // like to validate the mapping update first, but on the other, +                // hand putting the mapping would start the river, which expects, +                // to find a _meta document, +                // So we have no choice but to index first and send mappings afterwards, +                MapperService mapperService = indexShard.indexService().mapperService();, +                mapperService.merge(request.type(), new CompressedXContent(update.toBytes()), true);, +                created = operation.execute(indexShard);, +                mappingUpdatedAction.updateMappingOnMasterAsynchronously(indexName, request.type(), update);, +            } else {, +                created = operation.execute(indexShard);, +        } else {, +            created = operation.execute(indexShard);, +        }, +++ b/core/src/main/java/org/elasticsearch/cluster/metadata/MetaDataCreateIndexService.java, +import org.elasticsearch.env.Environment;, +import org.elasticsearch.river.RiverIndexName;, +    private final String riverIndexName;, +                                      Version version, @RiverIndexName String riverIndexName, AliasValidator aliasValidator,, +        this.riverIndexName = riverIndexName;, +        if (!index.equals(riverIndexName) && index.charAt(0) == '_') {, +                            if (request.index().equals(riverIndexName)) {, +                                indexSettingsBuilder.put(SETTING_NUMBER_OF_SHARDS, settings.getAsInt(SETTING_NUMBER_OF_SHARDS, 1));, +                            } else {, +                    }, +                            if (request.index().equals(riverIndexName)) {, +                            } else {, +                                indexSettingsBuilder.put(SETTING_NUMBER_OF_REPLICAS, settings.getAsInt(SETTING_NUMBER_OF_REPLICAS, 1));, +                            }, +++ b/core/src/main/java/org/elasticsearch/action/support/replication/TransportReplicationAction.java, +import org.elasticsearch.index.mapper.MapperService;, +import org.elasticsearch.river.RiverIndexName;, +        final boolean created;, +            if (indexName.equals(RiverIndexName.Conf.indexName(settings))) {, +                // With rivers, we have a chicken and egg problem if indexing, +                // the _meta document triggers a mapping update. Because we would, +                // like to validate the mapping update first, but on the other, +                // hand putting the mapping would start the river, which expects, +                // to find a _meta document, +                // So we have no choice but to index first and send mappings afterwards, +                MapperService mapperService = indexShard.indexService().mapperService();, +                mapperService.merge(request.type(), new CompressedXContent(update.toBytes()), true);, +                created = operation.execute(indexShard);, +                mappingUpdatedAction.updateMappingOnMasterAsynchronously(indexName, request.type(), update);, +            } else {, +                created = operation.execute(indexShard);, +        } else {, +            created = operation.execute(indexShard);, +        }, +++ b/core/src/main/java/org/elasticsearch/cluster/metadata/MetaDataCreateIndexService.java, +import org.elasticsearch.env.Environment;, +import org.elasticsearch.river.RiverIndexName;, +    private final String riverIndexName;, +                                      Version version, @RiverIndexName String riverIndexName, AliasValidator aliasValidator,, +        this.riverIndexName = riverIndexName;, +        if (!index.equals(riverIndexName) && index.charAt(0) == '_') {, +                            if (request.index().equals(riverIndexName)) {, +                                indexSettingsBuilder.put(SETTING_NUMBER_OF_SHARDS, settings.getAsInt(SETTING_NUMBER_OF_SHARDS, 1));, +                            } else {, +                    }, +                            if (request.index().equals(riverIndexName)) {, +                            } else {, +                                indexSettingsBuilder.put(SETTING_NUMBER_OF_REPLICAS, settings.getAsInt(SETTING_NUMBER_OF_REPLICAS, 1));, +                            }, +++ b/core/src/main/java/org/elasticsearch/common/io/stream/FilterStreamInput.java, +/*, + * Licensed to Elasticsearch under one or more contributor, + * license agreements. See the NOTICE file distributed with, + * this work for additional information regarding copyright, + * ownership. Elasticsearch licenses this file to you under, + * the Apache License, Version 2.0 (the "License"); you may, + * not use this file except in compliance with the License., + * You may obtain a copy of the License at, + *]