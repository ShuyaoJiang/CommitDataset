[+++ b/src/main/java/org/elasticsearch/env/NodeEnvironment.java, +import org.apache.lucene.store.*;, +import java.util.concurrent.Semaphore;, +import java.util.concurrent.TimeUnit;, +     * @param lockTimeoutMS how long to wait for acquiring the indices shard locks, +    public void deleteIndexDirectorySafe(Index index, long lockTimeoutMS) throws IOException {, +        final List<ShardLock> locks = lockAllForIndex(index, lockTimeoutMS);, +     * @param lockTimeoutMS how long to wait for acquiring the indices shard locks, +    public List<ShardLock> lockAllForIndex(Index index, long lockTimeoutMS) throws IOException {, +        long startTime = System.currentTimeMillis();, +                long timeoutLeft = Math.max(0, lockTimeoutMS - (System.currentTimeMillis() - startTime));, +                allLocks.add(shardLock(shardId, timeoutLeft));, +++ b/src/main/java/org/elasticsearch/env/NodeEnvironment.java, +import org.apache.lucene.store.*;, +import java.util.concurrent.Semaphore;, +import java.util.concurrent.TimeUnit;, +     * @param lockTimeoutMS how long to wait for acquiring the indices shard locks, +    public void deleteIndexDirectorySafe(Index index, long lockTimeoutMS) throws IOException {, +        final List<ShardLock> locks = lockAllForIndex(index, lockTimeoutMS);, +     * @param lockTimeoutMS how long to wait for acquiring the indices shard locks, +    public List<ShardLock> lockAllForIndex(Index index, long lockTimeoutMS) throws IOException {, +        long startTime = System.currentTimeMillis();, +                long timeoutLeft = Math.max(0, lockTimeoutMS - (System.currentTimeMillis() - startTime));, +                allLocks.add(shardLock(shardId, timeoutLeft));, +++ b/src/main/java/org/elasticsearch/gateway/GatewayMetaState.java, +import org.elasticsearch.common.xcontent.ToXContent;, +import org.elasticsearch.common.xcontent.XContentBuilder;, +import org.elasticsearch.common.xcontent.XContentParser;, +import org.elasticsearch.common.xcontent.XContentType;, +    public static final String GATEWAY_DELETE_TIMEOUT = "gateway.delete_timeout";, +    private final TimeValue deleteTimeout;, +        this.deleteTimeout = settings.getAsTime(GATEWAY_DELETE_TIMEOUT, TimeValue.timeValueSeconds(30));, +        logger.debug("using {} [{}],  {} [{}], with {} [{}]",, +                GATEWAY_AUTO_IMPORT_DANGLED, this.autoImportDangled,, +                GATEWAY_DELETE_TIMEOUT, this.deleteTimeout,, +                GATEWAY_DANGLING_TIMEOUT, this.danglingTimeout);, +                            // it may take a couple of seconds for outstanding shard reference, +                            // to release their refs (for example, on going recoveries), +                            // we are working on a better solution see: https://github.com/elasticsearch/elasticsearch/pull/8608, +                            nodeEnv.deleteIndexDirectorySafe(idx, deleteTimeout.millis());, +                                    //  - we acquired all shards locks here --> we can import the dangling index, +                                    final List<ShardLock> shardLocks = nodeEnv.lockAllForIndex(index, 0);, +                                        nodeEnv.deleteIndexDirectorySafe(index, 0);, +                                        nodeEnv.deleteIndexDirectorySafe(index, 0);, +                    nodeEnv.deleteIndexDirectorySafe(index, 0);, +++ b/src/main/java/org/elasticsearch/env/NodeEnvironment.java, +import org.apache.lucene.store.*;, +import java.util.concurrent.Semaphore;, +import java.util.concurrent.TimeUnit;, +     * @param lockTimeoutMS how long to wait for acquiring the indices shard locks, +    public void deleteIndexDirectorySafe(Index index, long lockTimeoutMS) throws IOException {, +        final List<ShardLock> locks = lockAllForIndex(index, lockTimeoutMS);, +     * @param lockTimeoutMS how long to wait for acquiring the indices shard locks, +    public List<ShardLock> lockAllForIndex(Index index, long lockTimeoutMS) throws IOException {, +        long startTime = System.currentTimeMillis();, +                long timeoutLeft = Math.max(0, lockTimeoutMS - (System.currentTimeMillis() - startTime));, +                allLocks.add(shardLock(shardId, timeoutLeft));, +++ b/src/main/java/org/elasticsearch/gateway/GatewayMetaState.java, +import org.elasticsearch.common.xcontent.ToXContent;, +import org.elasticsearch.common.xcontent.XContentBuilder;, +import org.elasticsearch.common.xcontent.XContentParser;, +import org.elasticsearch.common.xcontent.XContentType;, +    public static final String GATEWAY_DELETE_TIMEOUT = "gateway.delete_timeout";, +    private final TimeValue deleteTimeout;, +        this.deleteTimeout = settings.getAsTime(GATEWAY_DELETE_TIMEOUT, TimeValue.timeValueSeconds(30));, +        logger.debug("using {} [{}],  {} [{}], with {} [{}]",, +                GATEWAY_AUTO_IMPORT_DANGLED, this.autoImportDangled,, +                GATEWAY_DELETE_TIMEOUT, this.deleteTimeout,, +                GATEWAY_DANGLING_TIMEOUT, this.danglingTimeout);, +                            // it may take a couple of seconds for outstanding shard reference, +                            // to release their refs (for example, on going recoveries), +                            // we are working on a better solution see: https://github.com/elasticsearch/elasticsearch/pull/8608, +                            nodeEnv.deleteIndexDirectorySafe(idx, deleteTimeout.millis());, +                                    //  - we acquired all shards locks here --> we can import the dangling index, +                                    final List<ShardLock> shardLocks = nodeEnv.lockAllForIndex(index, 0);, +                                        nodeEnv.deleteIndexDirectorySafe(index, 0);, +                                        nodeEnv.deleteIndexDirectorySafe(index, 0);, +                    nodeEnv.deleteIndexDirectorySafe(index, 0);, +++ b/src/main/java/org/elasticsearch/index/IndexService.java, +    public synchronized void close(final String reason) {, +                    removeShard(shardId, reason);, +    public synchronized void removeShard(int shardId, String reason) throws ElasticsearchException {, +++ b/src/main/java/org/elasticsearch/env/NodeEnvironment.java, +import org.apache.lucene.store.*;, +import java.util.concurrent.Semaphore;, +import java.util.concurrent.TimeUnit;, +     * @param lockTimeoutMS how long to wait for acquiring the indices shard locks, +    public void deleteIndexDirectorySafe(Index index, long lockTimeoutMS) throws IOException {, +        final List<ShardLock> locks = lockAllForIndex(index, lockTimeoutMS);, +     * @param lockTimeoutMS how long to wait for acquiring the indices shard locks, +    public List<ShardLock> lockAllForIndex(Index index, long lockTimeoutMS) throws IOException {, +        long startTime = System.currentTimeMillis();, +                long timeoutLeft = Math.max(0, lockTimeoutMS - (System.currentTimeMillis() - startTime));, +                allLocks.add(shardLock(shardId, timeoutLeft));, +++ b/src/main/java/org/elasticsearch/gateway/GatewayMetaState.java, +import org.elasticsearch.common.xcontent.ToXContent;, +import org.elasticsearch.common.xcontent.XContentBuilder;, +import org.elasticsearch.common.xcontent.XContentParser;, +import org.elasticsearch.common.xcontent.XContentType;, +    public static final String GATEWAY_DELETE_TIMEOUT = "gateway.delete_timeout";]