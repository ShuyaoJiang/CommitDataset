[+++ b/server/src/main/java/org/elasticsearch/persistent/PersistentTasksCustomMetaData.java, +import org.elasticsearch.cluster.ClusterState;, +    @SuppressWarnings("unchecked"), +    public static <Request extends PersistentTaskRequest> PersistentTask<Request> getTaskWithId(ClusterState clusterState, long taskId) {, +        PersistentTasksCustomMetaData tasks = clusterState.metaData().custom(PersistentTasksCustomMetaData.TYPE);, +        if (tasks != null) {, +            return (PersistentTask<Request>)tasks.getTask(taskId);, +        }, +        return null;, +    }, +, +++ b/server/src/main/java/org/elasticsearch/persistent/PersistentTasksCustomMetaData.java, +import org.elasticsearch.cluster.ClusterState;, +    @SuppressWarnings("unchecked"), +    public static <Request extends PersistentTaskRequest> PersistentTask<Request> getTaskWithId(ClusterState clusterState, long taskId) {, +        PersistentTasksCustomMetaData tasks = clusterState.metaData().custom(PersistentTasksCustomMetaData.TYPE);, +        if (tasks != null) {, +            return (PersistentTask<Request>)tasks.getTask(taskId);, +        }, +        return null;, +    }, +, +++ b/server/src/main/java/org/elasticsearch/persistent/PersistentTasksService.java, +import org.elasticsearch.cluster.ClusterState;, +import org.elasticsearch.cluster.ClusterStateObserver;, +import org.elasticsearch.common.Nullable;, +import org.elasticsearch.common.unit.TimeValue;, +import org.elasticsearch.node.NodeClosedException;, +import org.elasticsearch.threadpool.ThreadPool;, +import org.elasticsearch.persistent.PersistentTasksCustomMetaData.PersistentTask;, +, +import java.util.function.Predicate;, +    private final ThreadPool threadPool;, +    public PersistentTasksService(Settings settings, ClusterService clusterService, ThreadPool threadPool, Client client) {, +        this.threadPool = threadPool;, +     * Waits for the persistent task with giving id (taskId) to achieve the desired status., +    public void waitForPersistentTaskStatus(long taskId, Predicate<PersistentTask<?>> predicate, @Nullable TimeValue timeout,, +                                            WaitForPersistentTaskStatusListener listener) {, +        ClusterStateObserver stateObserver = new ClusterStateObserver(clusterService, timeout, logger, threadPool.getThreadContext());, +        stateObserver.waitForNextChange(new ClusterStateObserver.Listener() {, +            @Override, +            public void onNewClusterState(ClusterState state) {, +                listener.onResponse(taskId);, +            }, +, +            @Override, +            public void onClusterServiceClose() {, +                listener.onFailure(new NodeClosedException(clusterService.localNode()));, +, +            }, +, +            @Override, +            public void onTimeout(TimeValue timeout) {, +                listener.onTimeout(timeout);, +            }, +        }, clusterState -> predicate.test(PersistentTasksCustomMetaData.getTaskWithId(clusterState, taskId)));, +    }, +, +    public interface WaitForPersistentTaskStatusListener extends PersistentTaskOperationListener {, +        default void onTimeout(TimeValue timeout) {, +            onFailure(new IllegalStateException("timed out after " + timeout));, +++ b/server/src/main/java/org/elasticsearch/persistent/PersistentTasksCustomMetaData.java, +import org.elasticsearch.cluster.ClusterState;, +    @SuppressWarnings("unchecked"), +    public static <Request extends PersistentTaskRequest> PersistentTask<Request> getTaskWithId(ClusterState clusterState, long taskId) {, +        PersistentTasksCustomMetaData tasks = clusterState.metaData().custom(PersistentTasksCustomMetaData.TYPE);, +        if (tasks != null) {, +            return (PersistentTask<Request>)tasks.getTask(taskId);, +        }, +        return null;, +    }, +, +++ b/server/src/main/java/org/elasticsearch/persistent/PersistentTasksService.java, +import org.elasticsearch.cluster.ClusterState;, +import org.elasticsearch.cluster.ClusterStateObserver;, +import org.elasticsearch.common.Nullable;, +import org.elasticsearch.common.unit.TimeValue;, +import org.elasticsearch.node.NodeClosedException;, +import org.elasticsearch.threadpool.ThreadPool;, +import org.elasticsearch.persistent.PersistentTasksCustomMetaData.PersistentTask;, +, +import java.util.function.Predicate;, +    private final ThreadPool threadPool;, +    public PersistentTasksService(Settings settings, ClusterService clusterService, ThreadPool threadPool, Client client) {, +        this.threadPool = threadPool;, +     * Waits for the persistent task with giving id (taskId) to achieve the desired status., +    public void waitForPersistentTaskStatus(long taskId, Predicate<PersistentTask<?>> predicate, @Nullable TimeValue timeout,, +                                            WaitForPersistentTaskStatusListener listener) {, +        ClusterStateObserver stateObserver = new ClusterStateObserver(clusterService, timeout, logger, threadPool.getThreadContext());, +        stateObserver.waitForNextChange(new ClusterStateObserver.Listener() {, +            @Override, +            public void onNewClusterState(ClusterState state) {, +                listener.onResponse(taskId);, +            }, +, +            @Override, +            public void onClusterServiceClose() {, +                listener.onFailure(new NodeClosedException(clusterService.localNode()));, +, +            }]