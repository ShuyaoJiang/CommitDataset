[+++ b/core/src/main/java/org/elasticsearch/common/rounding/Rounding.java, +import org.elasticsearch.common.unit.TimeValue;, +import org.joda.time.DateTimeField;, +import org.joda.time.DateTimeZone;, +import org.joda.time.IllegalInstantException;, +    public static Builder builder(DateTimeUnit unit) {, +        return new Builder(unit);, +    }, +, +    public static Builder builder(TimeValue interval) {, +        return new Builder(interval);, +    }, +, +    public static class Builder {, +, +        private final DateTimeUnit unit;, +        private final long interval;, +, +        private DateTimeZone timeZone = DateTimeZone.UTC;, +, +        private long offset;, +, +        public Builder(DateTimeUnit unit) {, +            this.unit = unit;, +            this.interval = -1;, +        }, +, +        public Builder(TimeValue interval) {, +            this.unit = null;, +            if (interval.millis() < 1), +                throw new IllegalArgumentException("Zero or negative time interval not supported");, +            this.interval = interval.millis();, +        }, +, +        public Builder timeZone(DateTimeZone timeZone) {, +            if (timeZone == null) {, +                throw new IllegalArgumentException("Setting null as timezone is not supported");, +            }, +            this.timeZone = timeZone;, +            return this;, +        }, +, +        public Builder offset(long offset) {, +            this.offset = offset;, +            return this;, +        }, +, +        public Rounding build() {, +            Rounding timeZoneRounding;, +            if (unit != null) {, +                timeZoneRounding = new TimeUnitRounding(unit, timeZone);, +            } else {, +                timeZoneRounding = new TimeIntervalRounding(interval, timeZone);, +            }, +            if (offset != 0) {, +                timeZoneRounding = new OffsetRounding(timeZoneRounding, offset);, +            }, +            return timeZoneRounding;, +        }, +    }, +, +    static class TimeUnitRounding extends Rounding {, +, +        static final byte ID = 1;, +, +        private DateTimeUnit unit;, +        private DateTimeField field;, +        private DateTimeZone timeZone;, +, +        TimeUnitRounding() { // for serialization, +        }, +, +        TimeUnitRounding(DateTimeUnit unit, DateTimeZone timeZone) {, +            this.unit = unit;, +            this.field = unit.field(timeZone);, +            this.timeZone = timeZone;, +        }, +, +        @Override, +        public byte id() {, +            return ID;, +        }, +, +        @Override, +        public long round(long utcMillis) {, +            long rounded = field.roundFloor(utcMillis);, +            if (timeZone.isFixed() == false && timeZone.getOffset(utcMillis) != timeZone.getOffset(rounded)) {, +                // in this case, we crossed a time zone transition. In some edge, +                // cases this will, +                // result in a value that is not a rounded value itself. We need, +                // to round again, +                // to make sure. This will have no affect in cases where, +                // 'rounded' was already a proper, +                // rounded value, +                rounded = field.roundFloor(rounded);, +            }, +            assert rounded == field.roundFloor(rounded);, +            return rounded;, +        }, +]