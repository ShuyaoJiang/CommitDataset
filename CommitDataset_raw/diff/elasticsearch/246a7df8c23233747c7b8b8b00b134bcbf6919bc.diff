[+++ b/server/src/main/java/org/elasticsearch/common/time/DateFormatters.java, +import java.time.ZoneId;, +import java.time.format.DateTimeParseException;, +     * This one needs a custom implementation, because the standard date formatter can not parse negative values, +     * or anything +- 999 milliseconds around the epoch, +     *, +     * This implementation just resorts to parsing the input directly to an Instant by trying to parse a number., +    private static final DateTimeFormatter EPOCH_MILLIS_FORMATTER = new DateTimeFormatterBuilder(), +        .toFormatter(Locale.ROOT);, +, +    private static final class EpochDateTimeFormatter extends CompoundDateTimeFormatter {, +, +        private EpochDateTimeFormatter() {, +            super(EPOCH_MILLIS_FORMATTER);, +        }, +, +        private EpochDateTimeFormatter(ZoneId zoneId) {, +            super(EPOCH_MILLIS_FORMATTER.withZone(zoneId));, +        }, +, +        @Override, +        public TemporalAccessor parse(String input) {, +            try {, +                return Instant.ofEpochMilli(Long.valueOf(input)).atZone(ZoneOffset.UTC);, +            } catch (NumberFormatException e) {, +                throw new DateTimeParseException("invalid number", input, 0, e);, +            }, +        }, +, +        @Override, +        public CompoundDateTimeFormatter withZone(ZoneId zoneId) {, +            return new EpochDateTimeFormatter(zoneId);, +        }, +, +        @Override, +        public String format(TemporalAccessor accessor) {, +            return String.valueOf(Instant.from(accessor).toEpochMilli());, +        }, +    }, +, +    private static final CompoundDateTimeFormatter EPOCH_MILLIS = new EpochDateTimeFormatter();, +++ b/server/src/main/java/org/elasticsearch/common/time/DateFormatters.java, +import java.time.ZoneId;, +import java.time.format.DateTimeParseException;, +     * This one needs a custom implementation, because the standard date formatter can not parse negative values, +     * or anything +- 999 milliseconds around the epoch, +     *, +     * This implementation just resorts to parsing the input directly to an Instant by trying to parse a number., +    private static final DateTimeFormatter EPOCH_MILLIS_FORMATTER = new DateTimeFormatterBuilder(), +        .toFormatter(Locale.ROOT);, +, +    private static final class EpochDateTimeFormatter extends CompoundDateTimeFormatter {, +, +        private EpochDateTimeFormatter() {, +            super(EPOCH_MILLIS_FORMATTER);, +        }, +, +        private EpochDateTimeFormatter(ZoneId zoneId) {, +            super(EPOCH_MILLIS_FORMATTER.withZone(zoneId));, +        }, +, +        @Override, +        public TemporalAccessor parse(String input) {, +            try {, +                return Instant.ofEpochMilli(Long.valueOf(input)).atZone(ZoneOffset.UTC);, +            } catch (NumberFormatException e) {, +                throw new DateTimeParseException("invalid number", input, 0, e);, +            }, +        }, +, +        @Override, +        public CompoundDateTimeFormatter withZone(ZoneId zoneId) {, +            return new EpochDateTimeFormatter(zoneId);, +        }, +, +        @Override, +        public String format(TemporalAccessor accessor) {, +            return String.valueOf(Instant.from(accessor).toEpochMilli());, +        }, +    }, +, +    private static final CompoundDateTimeFormatter EPOCH_MILLIS = new EpochDateTimeFormatter();, +++ b/server/src/test/java/org/elasticsearch/common/joda/JavaJodaTimeDuellingTests.java, +        assertSameDate("0", "epoch_second");, +        assertSameDate("1", "epoch_second");, +        assertSameDate("-1", "epoch_second");, +        assertSameDate("-1522332219", "epoch_second");, +        assertSameDate("0", "epoch_millis");, +        assertSameDate("1", "epoch_millis");, +        assertSameDate("-1", "epoch_millis");, +        assertSameDate("-1522332219321", "epoch_millis");, +++ b/server/src/main/java/org/elasticsearch/common/time/DateFormatters.java, +import java.time.ZoneId;, +import java.time.format.DateTimeParseException;, +     * This one needs a custom implementation, because the standard date formatter can not parse negative values, +     * or anything +- 999 milliseconds around the epoch, +     *, +     * This implementation just resorts to parsing the input directly to an Instant by trying to parse a number., +    private static final DateTimeFormatter EPOCH_MILLIS_FORMATTER = new DateTimeFormatterBuilder(), +        .toFormatter(Locale.ROOT);]