[+++ b/distribution/archives/integ-test-zip/src/test/java/org/elasticsearch/test/rest/WaitForRefreshAndCloseIT.java, +import java.util.concurrent.ExecutionException;, +import java.util.concurrent.TimeUnit;, +, +import static org.hamcrest.Matchers.containsString;, +import static org.hamcrest.Matchers.instanceOf;, +        Request request = new Request("PUT", "/test");, +        client().performRequest(new Request("DELETE", "/test"));, +        return "test/_doc/1";, +        Request request = new Request("PUT", docPath());, +        request.setJsonEntity("{\"test\":\"test\"}");, +        closeWhileListenerEngaged(start(request));, +        Request createDoc = new Request("PUT", docPath());, +        createDoc.setJsonEntity("{\"test\":\"test\"}");, +        client().performRequest(createDoc);, +        Request updateDoc = new Request("POST", docPath() + "/_update");, +        updateDoc.setJsonEntity("{\"doc\":{\"name\":\"test\"}}");, +        closeWhileListenerEngaged(start(updateDoc));, +        closeWhileListenerEngaged(start(new Request("DELETE", docPath())));, +                stats = entityAsMap(client().performRequest(new Request("GET", "/test/_stats/refresh")));, +            Map<?, ?> indices = (Map<?, ?>) stats.get("indices");, +            Map<?, ?> theIndex = (Map<?, ?>) indices.get("test");, +            Map<?, ?> total = (Map<?, ?>) theIndex.get("total");, +            Map<?, ?> refresh = (Map<?, ?>) total.get("refresh");, +            int listeners = (Integer) refresh.get("listeners");, +        client().performRequest(new Request("POST", "/test/_close"));, +        /*, +         * The request may fail, but we really, really, really want to make, +         * sure that it doesn't time out., +         */, +        try {, +            future.get(1, TimeUnit.MINUTES);, +        } catch (ExecutionException ee) {, +            /*, +             * If it *does* fail it should fail with a FORBIDDEN error because, +             * it attempts to take an action on a closed index. Again, it'd be, +             * nice if all requests waiting for refresh came back even though, +             * the index is closed and most do, but sometimes they bump into, +             * the index being closed. At least they don't hang forever. That'd, +             * be a nightmare., +             */, +            assertThat(ee.getCause(), instanceOf(ResponseException.class));, +            ResponseException re = (ResponseException) ee.getCause();, +            assertEquals(403, re.getResponse().getStatusLine().getStatusCode());, +            assertThat(EntityUtils.toString(re.getResponse().getEntity()), containsString("FORBIDDEN/4/index closed"));, +        }, +    private ActionFuture<String> start(Request request) {, +                    future.onResponse(EntityUtils.toString(response.getEntity()));]