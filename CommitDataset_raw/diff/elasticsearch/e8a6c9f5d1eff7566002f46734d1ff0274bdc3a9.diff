[+++ b/plugin/rollup/src/main/java/org/elasticsearch/xpack/rollup/action/TransportGetRollupJobAction.java, +import org.elasticsearch.action.ActionListenerResponseHandler;, +import org.elasticsearch.cluster.ClusterState;, +import org.elasticsearch.cluster.node.DiscoveryNodes;, +import org.elasticsearch.discovery.MasterNotDiscoveredException;, +import org.elasticsearch.persistent.PersistentTasksCustomMetaData;, +import org.elasticsearch.tasks.Task;, +import org.elasticsearch.xpack.core.rollup.RollupField;, +    protected void doExecute(Task task, GetRollupJobsAction.Request request, ActionListener<GetRollupJobsAction.Response> listener) {, +        final ClusterState state = clusterService.state();, +        final DiscoveryNodes nodes = state.nodes();, +, +        if (nodes.isLocalNodeElectedMaster()) {, +            if (stateHasRollupJobs(request, state)) {, +                super.doExecute(task, request, listener);, +            } else {, +                // If we couldn't find the job in the persistent task CS, it means it was deleted prior to this GET, +                // and we can just send an empty response, no need to go looking for the allocated task, +                listener.onResponse(new GetRollupJobsAction.Response(Collections.emptyList()));, +            }, +, +        } else {, +            // Delegates GetJobs to elected master node, so it becomes the coordinating node., +            // Non-master nodes may have a stale cluster state that shows jobs which are cancelled, +            // on the master, which makes testing difficult., +            if (nodes.getMasterNode() == null) {, +                listener.onFailure(new MasterNotDiscoveredException("no known master nodes"));, +            } else {, +                transportService.sendRequest(nodes.getMasterNode(), actionName, request,, +                        new ActionListenerResponseHandler<>(listener, GetRollupJobsAction.Response::new));, +            }, +        }, +    }, +, +    /**, +     * Check to see if the PersistentTask's cluster state contains the rollup job(s) we are interested in, +     */, +    static boolean stateHasRollupJobs(GetRollupJobsAction.Request request, ClusterState state) {, +        boolean hasRollupJobs = false;, +        PersistentTasksCustomMetaData pTasksMeta = state.getMetaData().custom(PersistentTasksCustomMetaData.TYPE);, +, +        if (pTasksMeta != null) {, +            // If the request was for _all rollup jobs, we need to look through the list of, +            // persistent tasks and see if at least once has a RollupJob param, +            if (request.getId().equals(MetaData.ALL)) {, +                hasRollupJobs = pTasksMeta.tasks(), +                        .stream(), +                        .anyMatch(persistentTask -> persistentTask.getTaskName().equals(RollupField.TASK_NAME));, +, +            } else if (pTasksMeta.getTask(request.getId()) != null) {, +                // If we're looking for a single job, we can just check directly, +                hasRollupJobs = true;, +            }, +        }, +        return hasRollupJobs;, +    }, +, +    @Override, +, +        assert jobTask.getConfig().getId().equals(request.getId()) || request.getId().equals(MetaData.ALL);, +, +        // Little extra insurance, make sure we only return jobs that aren't cancelled, +        if (jobTask.isCancelled() == false) {, +, +++ b/plugin/rollup/src/main/java/org/elasticsearch/xpack/rollup/action/TransportGetRollupJobAction.java, +import org.elasticsearch.action.ActionListenerResponseHandler;, +import org.elasticsearch.cluster.ClusterState;, +import org.elasticsearch.cluster.node.DiscoveryNodes;, +import org.elasticsearch.discovery.MasterNotDiscoveredException;, +import org.elasticsearch.persistent.PersistentTasksCustomMetaData;, +import org.elasticsearch.tasks.Task;, +import org.elasticsearch.xpack.core.rollup.RollupField;, +    protected void doExecute(Task task, GetRollupJobsAction.Request request, ActionListener<GetRollupJobsAction.Response> listener) {, +        final ClusterState state = clusterService.state();, +        final DiscoveryNodes nodes = state.nodes();, +, +        if (nodes.isLocalNodeElectedMaster()) {, +            if (stateHasRollupJobs(request, state)) {, +                super.doExecute(task, request, listener);, +            } else {, +                // If we couldn't find the job in the persistent task CS, it means it was deleted prior to this GET, +                // and we can just send an empty response, no need to go looking for the allocated task, +                listener.onResponse(new GetRollupJobsAction.Response(Collections.emptyList()));, +            }, +, +        } else {, +            // Delegates GetJobs to elected master node, so it becomes the coordinating node., +            // Non-master nodes may have a stale cluster state that shows jobs which are cancelled, +            // on the master, which makes testing difficult., +            if (nodes.getMasterNode() == null) {, +                listener.onFailure(new MasterNotDiscoveredException("no known master nodes"));, +            } else {, +                transportService.sendRequest(nodes.getMasterNode(), actionName, request,, +                        new ActionListenerResponseHandler<>(listener, GetRollupJobsAction.Response::new));, +            }, +        }, +    }, +, +    /**, +     * Check to see if the PersistentTask's cluster state contains the rollup job(s) we are interested in]