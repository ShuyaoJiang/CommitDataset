[+++ b/buildSrc/src/main/resources/forbidden/es-all-signatures.txt, +++ b/buildSrc/src/main/resources/forbidden/es-all-signatures.txt, +++ b/core/src/main/java/org/apache/lucene/search/grouping/CollapseTopFieldDocs.java, +import java.io.IOException;, +public class CollapseTopFieldDocs extends TopFieldDocs {, +    private static class ShardRef {, +        ShardRef(int shardIndex) {, +    };, +        MergeSortQueue(Sort sort, CollapseTopFieldDocs[] shardHits) throws IOException {, +, +            // Tie break: earlier shard wins, +            if (first.shardIndex < second.shardIndex) {, +                return true;, +            } else if (first.shardIndex > second.shardIndex) {, +                return false;, +            } else {, +                // Tie break in same shard: resolve however the, +                // shard had resolved it:, +                assert first.hitIndex != second.hitIndex;, +                return first.hitIndex < second.hitIndex;, +            }, +                                             CollapseTopFieldDocs[] shardHits) throws IOException {, +                queue.add(new ShardRef(shardIDX));, +++ b/buildSrc/src/main/resources/forbidden/es-all-signatures.txt, +++ b/core/src/main/java/org/apache/lucene/search/grouping/CollapseTopFieldDocs.java, +import java.io.IOException;, +public class CollapseTopFieldDocs extends TopFieldDocs {, +    private static class ShardRef {, +        ShardRef(int shardIndex) {, +    };, +        MergeSortQueue(Sort sort, CollapseTopFieldDocs[] shardHits) throws IOException {, +, +            // Tie break: earlier shard wins, +            if (first.shardIndex < second.shardIndex) {, +                return true;, +            } else if (first.shardIndex > second.shardIndex) {, +                return false;, +            } else {, +                // Tie break in same shard: resolve however the, +                // shard had resolved it:, +                assert first.hitIndex != second.hitIndex;, +                return first.hitIndex < second.hitIndex;, +            }, +                                             CollapseTopFieldDocs[] shardHits) throws IOException {, +                queue.add(new ShardRef(shardIDX));, +++ b/core/src/main/java/org/elasticsearch/action/admin/cluster/stats/ClusterStatsNodes.java, +            TransportAddress publishAddress = nodeResponse.nodeInfo().getTransport().address().publishAddress();, +        public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {, +        public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {, +                // we still do min max calc on -1, so we'll have an indication of it not being supported on one of the nodes., +        public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {, +        public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {, +        private NetworkTypes(final List<NodeInfo> nodeInfos) {, +                    settings.get(NetworkModule.TRANSPORT_TYPE_KEY, NetworkModule.TRANSPORT_DEFAULT_TYPE_SETTING.get(settings));, +                    settings.get(NetworkModule.HTTP_TYPE_KEY, NetworkModule.HTTP_DEFAULT_TYPE_SETTING.get(settings));, +                transportTypes.computeIfAbsent(transportType, k -> new AtomicInteger()).incrementAndGet();, +                httpTypes.computeIfAbsent(httpType, k -> new AtomicInteger()).incrementAndGet();, +++ b/buildSrc/src/main/resources/forbidden/es-all-signatures.txt, +++ b/core/src/main/java/org/apache/lucene/search/grouping/CollapseTopFieldDocs.java, +import java.io.IOException;, +public class CollapseTopFieldDocs extends TopFieldDocs {, +    private static class ShardRef {, +        ShardRef(int shardIndex) {, +    };, +        MergeSortQueue(Sort sort, CollapseTopFieldDocs[] shardHits) throws IOException {, +, +            // Tie break: earlier shard wins, +            if (first.shardIndex < second.shardIndex) {, +                return true;, +            } else if (first.shardIndex > second.shardIndex) {, +                return false;, +            } else {, +                // Tie break in same shard: resolve however the, +                // shard had resolved it:, +                assert first.hitIndex != second.hitIndex;, +                return first.hitIndex < second.hitIndex;, +            }, +                                             CollapseTopFieldDocs[] shardHits) throws IOException {, +                queue.add(new ShardRef(shardIDX));, +++ b/core/src/main/java/org/elasticsearch/action/admin/cluster/stats/ClusterStatsNodes.java, +            TransportAddress publishAddress = nodeResponse.nodeInfo().getTransport().address().publishAddress();, +        public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {, +        public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {, +                // we still do min max calc on -1, so we'll have an indication of it not being supported on one of the nodes., +        public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {, +        public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {, +        private NetworkTypes(final List<NodeInfo> nodeInfos) {, +                    settings.get(NetworkModule.TRANSPORT_TYPE_KEY, NetworkModule.TRANSPORT_DEFAULT_TYPE_SETTING.get(settings));, +                    settings.get(NetworkModule.HTTP_TYPE_KEY, NetworkModule.HTTP_DEFAULT_TYPE_SETTING.get(settings));, +                transportTypes.computeIfAbsent(transportType, k -> new AtomicInteger()).incrementAndGet();, +                httpTypes.computeIfAbsent(httpType, k -> new AtomicInteger()).incrementAndGet();, +++ b/core/src/main/java/org/elasticsearch/action/fieldcaps/FieldCapabilities.java, +            Collections.sort(indiceList, Comparator.comparing(o -> o.name));, +++ b/buildSrc/src/main/resources/forbidden/es-all-signatures.txt, +++ b/core/src/main/java/org/apache/lucene/search/grouping/CollapseTopFieldDocs.java, +import java.io.IOException;, +public class CollapseTopFieldDocs extends TopFieldDocs {, +    private static class ShardRef {, +        ShardRef(int shardIndex) {, +    };]