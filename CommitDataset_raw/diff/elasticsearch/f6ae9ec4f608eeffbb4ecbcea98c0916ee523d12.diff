[+++ b/core/src/main/java/org/elasticsearch/cluster/routing/allocation/AllocationService.java, +import org.elasticsearch.cluster.routing.allocation.allocator.ShardsAllocator;, +import org.elasticsearch.gateway.GatewayAllocator;, +    private final GatewayAllocator gatewayAllocator;, +    private final ShardsAllocator shardsAllocator;, +    public AllocationService(Settings settings, AllocationDeciders allocationDeciders, GatewayAllocator gatewayAllocator,, +                             ShardsAllocator shardsAllocator, ClusterInfoService clusterInfoService) {, +        this.gatewayAllocator = gatewayAllocator;, +        this.shardsAllocator = shardsAllocator;, +        gatewayAllocator.applyStartedShards(allocation);, +        gatewayAllocator.applyFailedShards(allocation);, +            changed |= gatewayAllocator.allocateUnassigned(allocation);, +        changed |= shardsAllocator.allocate(allocation);, +++ b/core/src/main/java/org/elasticsearch/cluster/routing/allocation/AllocationService.java, +import org.elasticsearch.cluster.routing.allocation.allocator.ShardsAllocator;, +import org.elasticsearch.gateway.GatewayAllocator;, +    private final GatewayAllocator gatewayAllocator;, +    private final ShardsAllocator shardsAllocator;, +    public AllocationService(Settings settings, AllocationDeciders allocationDeciders, GatewayAllocator gatewayAllocator,, +                             ShardsAllocator shardsAllocator, ClusterInfoService clusterInfoService) {, +        this.gatewayAllocator = gatewayAllocator;, +        this.shardsAllocator = shardsAllocator;, +        gatewayAllocator.applyStartedShards(allocation);, +        gatewayAllocator.applyFailedShards(allocation);, +            changed |= gatewayAllocator.allocateUnassigned(allocation);, +        changed |= shardsAllocator.allocate(allocation);, +++ b/core/src/main/java/org/elasticsearch/cluster/routing/allocation/allocator/BalancedShardsAllocator.java, +    public boolean allocate(RoutingAllocation allocation) {, +        boolean changed = false;, +        if (allocation.routingNodes().unassigned().size() > 0) {, +            changed |= balancer.allocateUnassigned();, +        changed |= balancer.moveShards();, +        if (allocation.hasPendingAsyncFetch() == false) {, +            /*, +             * see https://github.com/elastic/elasticsearch/issues/14387, +             * if we allow rebalance operations while we are still fetching shard store data, +             * we might end up with unnecessary rebalance operations which can be super confusion/frustrating, +             * since once the fetches come back we might just move all the shards back again., +             * Therefore we only do a rebalance if we have fetched all information., +             */, +            changed |= balancer.balance();, +        } else {, +            logger.debug("skipping rebalance due to in-flight shard/store fetches");, +        return changed;, +++ b/core/src/main/java/org/elasticsearch/cluster/routing/allocation/AllocationService.java, +import org.elasticsearch.cluster.routing.allocation.allocator.ShardsAllocator;, +import org.elasticsearch.gateway.GatewayAllocator;, +    private final GatewayAllocator gatewayAllocator;, +    private final ShardsAllocator shardsAllocator;, +    public AllocationService(Settings settings, AllocationDeciders allocationDeciders, GatewayAllocator gatewayAllocator,, +                             ShardsAllocator shardsAllocator, ClusterInfoService clusterInfoService) {, +        this.gatewayAllocator = gatewayAllocator;, +        this.shardsAllocator = shardsAllocator;, +        gatewayAllocator.applyStartedShards(allocation);, +        gatewayAllocator.applyFailedShards(allocation);, +            changed |= gatewayAllocator.allocateUnassigned(allocation);, +        changed |= shardsAllocator.allocate(allocation);, +++ b/core/src/main/java/org/elasticsearch/cluster/routing/allocation/allocator/BalancedShardsAllocator.java, +    public boolean allocate(RoutingAllocation allocation) {, +        boolean changed = false;, +        if (allocation.routingNodes().unassigned().size() > 0) {, +            changed |= balancer.allocateUnassigned();, +        changed |= balancer.moveShards();, +        if (allocation.hasPendingAsyncFetch() == false) {, +            /*, +             * see https://github.com/elastic/elasticsearch/issues/14387, +             * if we allow rebalance operations while we are still fetching shard store data, +             * we might end up with unnecessary rebalance operations which can be super confusion/frustrating, +             * since once the fetches come back we might just move all the shards back again., +             * Therefore we only do a rebalance if we have fetched all information., +             */, +            changed |= balancer.balance();, +        } else {, +            logger.debug("skipping rebalance due to in-flight shard/store fetches");, +        return changed;, +++ b/core/src/main/java/org/elasticsearch/cluster/routing/allocation/allocator/ShardsAllocator.java, +     * Move started shards that can not be allocated to a node anymore, +    boolean allocate(RoutingAllocation allocation);, +++ b/core/src/main/java/org/elasticsearch/cluster/routing/allocation/AllocationService.java, +import org.elasticsearch.cluster.routing.allocation.allocator.ShardsAllocator;, +import org.elasticsearch.gateway.GatewayAllocator;, +    private final GatewayAllocator gatewayAllocator;, +    private final ShardsAllocator shardsAllocator;, +    public AllocationService(Settings settings, AllocationDeciders allocationDeciders, GatewayAllocator gatewayAllocator,, +                             ShardsAllocator shardsAllocator, ClusterInfoService clusterInfoService) {, +        this.gatewayAllocator = gatewayAllocator;, +        this.shardsAllocator = shardsAllocator;, +        gatewayAllocator.applyStartedShards(allocation);, +        gatewayAllocator.applyFailedShards(allocation);, +            changed |= gatewayAllocator.allocateUnassigned(allocation);, +        changed |= shardsAllocator.allocate(allocation);, +++ b/core/src/main/java/org/elasticsearch/cluster/routing/allocation/allocator/BalancedShardsAllocator.java, +    public boolean allocate(RoutingAllocation allocation) {, +        boolean changed = false;, +        if (allocation.routingNodes().unassigned().size() > 0) {, +            changed |= balancer.allocateUnassigned();, +        changed |= balancer.moveShards();, +        if (allocation.hasPendingAsyncFetch() == false) {, +            /*, +             * see https://github.com/elastic/elasticsearch/issues/14387]