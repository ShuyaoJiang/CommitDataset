[+++ b/docs/reference/release-notes/7.0.0-alpha1.asciidoc, +, +Aggregations::, +* The Percentiles and PercentileRanks aggregations now return `null` in the REST response,, +  instead of `NaN`.  This makes it consistent with the rest of the aggregations.  Note:, +  this only applies to the REST response, the java objects continue to return `NaN` (also, +  consistent with other aggregations), +++ b/docs/reference/release-notes/7.0.0-alpha1.asciidoc, +, +Aggregations::, +* The Percentiles and PercentileRanks aggregations now return `null` in the REST response,, +  instead of `NaN`.  This makes it consistent with the rest of the aggregations.  Note:, +  this only applies to the REST response, the java objects continue to return `NaN` (also, +  consistent with other aggregations), +++ b/server/src/main/java/org/elasticsearch/search/DocValueFormat.java, +            /**, +             * Explicitly check for NaN, since it formats to "�" or "NaN" depending on JDK version., +             *, +             * Decimal formatter uses the JRE's default symbol list (via Locale.ROOT above).  In JDK8,, +             * this translates into using {@link sun.util.locale.provider.JRELocaleProviderAdapter}, which loads, +             * {@link sun.text.resources.FormatData} for symbols.  There, `NaN` is defined as `\ufffd` (�), +             *, +             * In JDK9+, {@link sun.util.cldr.CLDRLocaleProviderAdapter} is used instead, which loads, +             * {@link sun.text.resources.cldr.FormatData}.  There, `NaN` is defined as `"NaN"`, +             *, +             * Since the character � isn't very useful, and makes the output change depending on JDK version,, +             * we manually check to see if the value is NaN and return the string directly., +             */, +            if (Double.isNaN(value)) {, +                return String.valueOf(Double.NaN);, +            }, +++ b/docs/reference/release-notes/7.0.0-alpha1.asciidoc, +, +Aggregations::, +* The Percentiles and PercentileRanks aggregations now return `null` in the REST response,, +  instead of `NaN`.  This makes it consistent with the rest of the aggregations.  Note:, +  this only applies to the REST response, the java objects continue to return `NaN` (also, +  consistent with other aggregations), +++ b/server/src/main/java/org/elasticsearch/search/DocValueFormat.java, +            /**, +             * Explicitly check for NaN, since it formats to "�" or "NaN" depending on JDK version., +             *, +             * Decimal formatter uses the JRE's default symbol list (via Locale.ROOT above).  In JDK8,, +             * this translates into using {@link sun.util.locale.provider.JRELocaleProviderAdapter}, which loads, +             * {@link sun.text.resources.FormatData} for symbols.  There, `NaN` is defined as `\ufffd` (�), +             *, +             * In JDK9+, {@link sun.util.cldr.CLDRLocaleProviderAdapter} is used instead, which loads, +             * {@link sun.text.resources.cldr.FormatData}.  There, `NaN` is defined as `"NaN"`, +             *, +             * Since the character � isn't very useful, and makes the output change depending on JDK version,, +             * we manually check to see if the value is NaN and return the string directly., +             */, +            if (Double.isNaN(value)) {, +                return String.valueOf(Double.NaN);, +            }, +++ b/server/src/main/java/org/elasticsearch/search/aggregations/metrics/percentiles/ParsedPercentiles.java, +                Double value = percentile.getValue();, +                builder.field(String.valueOf(key), value.isNaN() ? null : value);, +                if (valuesAsString && value.isNaN() == false) {, +                    Double value = percentile.getValue();, +                    builder.field(CommonFields.VALUE.getPreferredName(), value.isNaN() ? null : value);, +                    if (valuesAsString && value.isNaN() == false) {, +++ b/docs/reference/release-notes/7.0.0-alpha1.asciidoc, +, +Aggregations::, +* The Percentiles and PercentileRanks aggregations now return `null` in the REST response,, +  instead of `NaN`.  This makes it consistent with the rest of the aggregations.  Note:, +  this only applies to the REST response, the java objects continue to return `NaN` (also, +  consistent with other aggregations), +++ b/server/src/main/java/org/elasticsearch/search/DocValueFormat.java, +            /**, +             * Explicitly check for NaN, since it formats to "�" or "NaN" depending on JDK version., +             *, +             * Decimal formatter uses the JRE's default symbol list (via Locale.ROOT above).  In JDK8,, +             * this translates into using {@link sun.util.locale.provider.JRELocaleProviderAdapter}, which loads, +             * {@link sun.text.resources.FormatData} for symbols.  There, `NaN` is defined as `\ufffd` (�), +             *, +             * In JDK9+, {@link sun.util.cldr.CLDRLocaleProviderAdapter} is used instead, which loads, +             * {@link sun.text.resources.cldr.FormatData}.  There, `NaN` is defined as `"NaN"`, +             *, +             * Since the character � isn't very useful, and makes the output change depending on JDK version,, +             * we manually check to see if the value is NaN and return the string directly., +             */, +            if (Double.isNaN(value)) {, +                return String.valueOf(Double.NaN);, +            }, +++ b/server/src/main/java/org/elasticsearch/search/aggregations/metrics/percentiles/ParsedPercentiles.java, +                Double value = percentile.getValue();, +                builder.field(String.valueOf(key), value.isNaN() ? null : value);, +                if (valuesAsString && value.isNaN() == false) {, +                    Double value = percentile.getValue();, +                    builder.field(CommonFields.VALUE.getPreferredName(), value.isNaN() ? null : value);, +                    if (valuesAsString && value.isNaN() == false) {, +++ b/server/src/main/java/org/elasticsearch/search/aggregations/metrics/percentiles/hdr/AbstractInternalHDRPercentiles.java, +                builder.field(key, state.getTotalCount() == 0 ? null : value);, +                if (format != DocValueFormat.RAW && state.getTotalCount() > 0) {, +                    builder.field(key + "_as_string",  format.format(value).toString());, +                builder.field(CommonFields.VALUE.getPreferredName(), state.getTotalCount() == 0 ? null : value);, +                if (format != DocValueFormat.RAW && state.getTotalCount() > 0) {, +++ b/docs/reference/release-notes/7.0.0-alpha1.asciidoc]