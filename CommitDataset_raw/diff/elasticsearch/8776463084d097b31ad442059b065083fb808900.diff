[+++ b/core/src/main/java/org/apache/lucene/queryparser/classic/MissingFieldQueryExtension.java, +import org.elasticsearch.index.query.MissingQueryBuilder;, +        Query query = MissingQueryBuilder.newFilter(parseContext, queryText, MissingQueryBuilder.DEFAULT_EXISTENCE_VALUE, MissingQueryBuilder.DEFAULT_NULL_VALUE);, +++ b/core/src/main/java/org/apache/lucene/queryparser/classic/MissingFieldQueryExtension.java, +import org.elasticsearch.index.query.MissingQueryBuilder;, +        Query query = MissingQueryBuilder.newFilter(parseContext, queryText, MissingQueryBuilder.DEFAULT_EXISTENCE_VALUE, MissingQueryBuilder.DEFAULT_NULL_VALUE);, +++ b/core/src/main/java/org/elasticsearch/index/query/BaseTermQueryBuilder.java, +        return Objects.hash(fieldName, value);, +++ b/core/src/main/java/org/apache/lucene/queryparser/classic/MissingFieldQueryExtension.java, +import org.elasticsearch.index.query.MissingQueryBuilder;, +        Query query = MissingQueryBuilder.newFilter(parseContext, queryText, MissingQueryBuilder.DEFAULT_EXISTENCE_VALUE, MissingQueryBuilder.DEFAULT_NULL_VALUE);, +++ b/core/src/main/java/org/elasticsearch/index/query/BaseTermQueryBuilder.java, +        return Objects.hash(fieldName, value);, +++ b/core/src/main/java/org/elasticsearch/index/query/MissingQueryBuilder.java, +import org.apache.lucene.search.*;, +import org.elasticsearch.common.Strings;, +import org.elasticsearch.common.io.stream.StreamInput;, +import org.elasticsearch.common.io.stream.StreamOutput;, +import org.elasticsearch.common.lucene.search.Queries;, +import org.elasticsearch.index.mapper.MappedFieldType;, +import org.elasticsearch.index.mapper.internal.FieldNamesFieldMapper;, +import org.elasticsearch.index.mapper.object.ObjectMapper;, +import java.util.Collection;, +import java.util.Objects;, + * Constructs a filter that have only null values or no value in the original field., +    public static final boolean DEFAULT_NULL_VALUE = false;, +    public static final boolean DEFAULT_EXISTENCE_VALUE = true;, +    private final String fieldPattern;, +, +    private boolean nullValue = DEFAULT_NULL_VALUE;, +, +    private boolean existence = DEFAULT_EXISTENCE_VALUE;, +    public MissingQueryBuilder(String fieldPattern) {, +        this.fieldPattern = fieldPattern;, +    }, +    , +    public String fieldPattern() {, +        return this.fieldPattern;, +     * Returns true if the missing filter will include documents where the field contains a null value, otherwise, +     * these documents will not be included., +     */, +    public boolean nullValue() {, +        return this.nullValue;, +    }, +, +    /**, +     * Should the missing filter include documents where the field doesn't exist in the docs., +    /**, +     * Returns true if the missing filter will include documents where the field has no values, otherwise, +     * these documents will not be included., +     */, +    public boolean existence() {, +        return this.existence;, +    }, +, +        builder.field("field", fieldPattern);, +, +    @Override, +    protected Query doToQuery(QueryParseContext parseContext) throws IOException {, +        return newFilter(parseContext, fieldPattern, existence, nullValue);, +    }, +, +    public static Query newFilter(QueryParseContext parseContext, String fieldPattern, boolean existence, boolean nullValue) {, +        if (!existence && !nullValue) {, +            throw new QueryParsingException(parseContext, "missing must have either existence, or null_value, or both set to true");, +        }, +, +        final FieldNamesFieldMapper.FieldNamesFieldType fieldNamesFieldType = (FieldNamesFieldMapper.FieldNamesFieldType) parseContext.mapperService().fullName(FieldNamesFieldMapper.NAME);, +        if (fieldNamesFieldType == null) {, +            // can only happen when no types exist, so no docs exist either, +            return Queries.newMatchNoDocsQuery();, +        }, +, +        ObjectMapper objectMapper = parseContext.getObjectMapper(fieldPattern);, +        if (objectMapper != null) {, +            // automatic make the object mapper pattern, +            fieldPattern = fieldPattern + ".*";, +        }, +, +        Collection<String> fields = parseContext.simpleMatchToIndexNames(fieldPattern);, +        if (fields.isEmpty()) {, +            if (existence) {, +                // if we ask for existence of fields, and we found none, then we should match on all, +                return Queries.newMatchAllQuery();, +            }, +            return null;, +        }, +, +        Query existenceFilter = null;, +        Query nullFilter = null;, +, +        if (existence) {, +            BooleanQuery boolFilter = new BooleanQuery();, +            for (String field : fields) {, +                MappedFieldType fieldType = parseContext.fieldMapper(field);, +                Query filter = null;, +                if (fieldNamesFieldType.isEnabled()) {, +                    final String f;, +                    if (fieldType != null) {, +                        f = fieldType.names().indexName();]