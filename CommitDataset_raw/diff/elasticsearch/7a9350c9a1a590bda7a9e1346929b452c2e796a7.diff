[+++ b/src/main/java/org/elasticsearch/discovery/zen/fd/MasterFaultDetection.java, +            transportService.sendRequest(masterToPing, MasterPingRequestHandler.ACTION, new MasterPingRequest(nodesProvider.nodes().localNode().id(), masterToPing.id()), options().withPingType().withTimeout(pingRetryTimeout),, +                                        transportService.sendRequest(masterToPing, MasterPingRequestHandler.ACTION, new MasterPingRequest(nodesProvider.nodes().localNode().id(), masterToPing.id()), options().withPingType().withTimeout(pingRetryTimeout), this);, +++ b/src/main/java/org/elasticsearch/discovery/zen/fd/MasterFaultDetection.java, +            transportService.sendRequest(masterToPing, MasterPingRequestHandler.ACTION, new MasterPingRequest(nodesProvider.nodes().localNode().id(), masterToPing.id()), options().withPingType().withTimeout(pingRetryTimeout),, +                                        transportService.sendRequest(masterToPing, MasterPingRequestHandler.ACTION, new MasterPingRequest(nodesProvider.nodes().localNode().id(), masterToPing.id()), options().withPingType().withTimeout(pingRetryTimeout), this);, +++ b/src/main/java/org/elasticsearch/discovery/zen/fd/NodesFaultDetection.java, +            transportService.sendRequest(node, PingRequestHandler.ACTION, new PingRequest(node.id()), options().withPingType().withTimeout(pingRetryTimeout),, +                                            options().withPingType().withTimeout(pingRetryTimeout), this);, +++ b/src/main/java/org/elasticsearch/discovery/zen/fd/MasterFaultDetection.java, +            transportService.sendRequest(masterToPing, MasterPingRequestHandler.ACTION, new MasterPingRequest(nodesProvider.nodes().localNode().id(), masterToPing.id()), options().withPingType().withTimeout(pingRetryTimeout),, +                                        transportService.sendRequest(masterToPing, MasterPingRequestHandler.ACTION, new MasterPingRequest(nodesProvider.nodes().localNode().id(), masterToPing.id()), options().withPingType().withTimeout(pingRetryTimeout), this);, +++ b/src/main/java/org/elasticsearch/discovery/zen/fd/NodesFaultDetection.java, +            transportService.sendRequest(node, PingRequestHandler.ACTION, new PingRequest(node.id()), options().withPingType().withTimeout(pingRetryTimeout),, +                                            options().withPingType().withTimeout(pingRetryTimeout), this);, +++ b/src/main/java/org/elasticsearch/transport/TransportRequestOptions.java, +        HIGH,, +        PING;, +            } else if ("ping".equalsIgnoreCase(type)) {, +                return PING;, +     * A request that requires very low latency., +     */, +    public TransportRequestOptions withPingType() {, +        this.type = Type.PING;, +        return this;, +    }, +, +, +    /**, +     * A channel reserved for high prio requests., +++ b/src/main/java/org/elasticsearch/discovery/zen/fd/MasterFaultDetection.java, +            transportService.sendRequest(masterToPing, MasterPingRequestHandler.ACTION, new MasterPingRequest(nodesProvider.nodes().localNode().id(), masterToPing.id()), options().withPingType().withTimeout(pingRetryTimeout),, +                                        transportService.sendRequest(masterToPing, MasterPingRequestHandler.ACTION, new MasterPingRequest(nodesProvider.nodes().localNode().id(), masterToPing.id()), options().withPingType().withTimeout(pingRetryTimeout), this);, +++ b/src/main/java/org/elasticsearch/discovery/zen/fd/NodesFaultDetection.java, +            transportService.sendRequest(node, PingRequestHandler.ACTION, new PingRequest(node.id()), options().withPingType().withTimeout(pingRetryTimeout),, +                                            options().withPingType().withTimeout(pingRetryTimeout), this);, +++ b/src/main/java/org/elasticsearch/transport/TransportRequestOptions.java, +        HIGH,, +        PING;, +            } else if ("ping".equalsIgnoreCase(type)) {, +                return PING;, +     * A request that requires very low latency., +     */, +    public TransportRequestOptions withPingType() {, +        this.type = Type.PING;, +        return this;, +    }, +, +, +    /**, +     * A channel reserved for high prio requests., +++ b/src/main/java/org/elasticsearch/transport/netty/NettyTransport.java, + * There are 4 types of connections per node, low/med/high/ping. Low if for batch oriented APIs (like recovery or, + * longer. Med is for the typical search / single doc index. And High for things like cluster state. Ping is reserved for, + * sending out ping requests to other nodes., +    final int connectionsPerNodePing;, +        this.connectionsPerNodePing = componentSettings.getAsInt("connections_per_node.ping", settings.getAsInt("transport.connections_per_node.ping", 1));, +        logger.debug("using worker_count[{}], port[{}], bind_host[{}], publish_host[{}], compress[{}], connect_timeout[{}], connections_per_node[{}/{}/{}/{}], receive_predictor[{}->{}]",, +                workerCount, port, bindHost, publishHost, compress, connectTimeout, connectionsPerNodeLow, connectionsPerNodeMed, connectionsPerNodeHigh, connectionsPerNodePing, receivePredictorMin, receivePredictorMax);, +                        nodeChannels = new NodeChannels(new Channel[connectionsPerNodeLow], new Channel[connectionsPerNodeMed], new Channel[connectionsPerNodeHigh], new Channel[connectionsPerNodePing]);, +        return new NodeChannels(channels, channels, channels, channels);, +        ChannelFuture[] connectPing = new ChannelFuture[nodeChannels.ping.length];, +        for (int i = 0; i < connectPing.length; i++) {, +            connectPing[i] = clientBootstrap.connect(address);, +        }, +            for (int i = 0; i < connectPing.length; i++) {, +                connectPing[i].awaitUninterruptibly((long) (connectTimeout.millis() * 1.5));, +                if (!connectPing[i].isSuccess()) {, +                    throw new ConnectTransportException(node, "connect_timeout[" + connectTimeout + "]", connectPing[i].getCause());, +                }, +                nodeChannels.ping[i] = connectPing[i].getChannel();, +                nodeChannels.ping[i].getCloseFuture().addListener(new ChannelCloseListener(node));, +            }, +, +            if (nodeChannels.ping.length == 0) {, +                if (nodeChannels.high.length > 0) {, +                    nodeChannels.ping = nodeChannels.high;, +                } else {, +                    nodeChannels.ping = nodeChannels.med;, +                }, +            }, +        private Channel[] ping;, +        private final AtomicInteger pingCounter = new AtomicInteger();, +        public NodeChannels(Channel[] low, Channel[] med, Channel[] high, Channel[] ping) {, +            this.ping = ping;, +            return hasChannel(channel, low) || hasChannel(channel, med) || hasChannel(channel, high) || hasChannel(channel, ping);, +            } else if (type == TransportRequestOptions.Type.PING) {, +                return ping[Math.abs(pingCounter.incrementAndGet()) % ping.length];, +            closeChannelsAndWait(ping, futures);]