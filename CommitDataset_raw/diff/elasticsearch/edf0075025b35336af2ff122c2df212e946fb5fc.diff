[+++ b/config/logging.yml, +, +  # gateway, +  #gateway: DEBUG, +  #index.gateway: DEBUG, +, +  # peer shard recovery, +  #index.shard.recovery: DEBUG, +++ b/config/logging.yml, +, +  # gateway, +  #gateway: DEBUG, +  #index.gateway: DEBUG, +, +  # peer shard recovery, +  #index.shard.recovery: DEBUG, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/index/gateway/IndexShardGatewayService.java, +                    sb.append("    index    : recovered_files [").append(recoveryStatus.index().numberOfFiles()).append("] with total_size [").append(recoveryStatus.index().totalSize()).append("], throttling_wait [").append(recoveryStatus.index().throttlingWaitTime()).append("]\n");, +++ b/config/logging.yml, +, +  # gateway, +  #gateway: DEBUG, +  #index.gateway: DEBUG, +, +  # peer shard recovery, +  #index.shard.recovery: DEBUG, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/index/gateway/IndexShardGatewayService.java, +                    sb.append("    index    : recovered_files [").append(recoveryStatus.index().numberOfFiles()).append("] with total_size [").append(recoveryStatus.index().totalSize()).append("], throttling_wait [").append(recoveryStatus.index().throttlingWaitTime()).append("]\n");, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/index/gateway/blobstore/BlobStoreIndexShardGateway.java, +                indexShard.performRecoveryPrepareForTranslog();, +                indexShard.performRecoveryOperations(operations);, +                indexShard.performRecoveryFinalization();, +                // clean all the other translog, +++ b/config/logging.yml, +, +  # gateway, +  #gateway: DEBUG, +  #index.gateway: DEBUG, +, +  # peer shard recovery, +  #index.shard.recovery: DEBUG, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/index/gateway/IndexShardGatewayService.java, +                    sb.append("    index    : recovered_files [").append(recoveryStatus.index().numberOfFiles()).append("] with total_size [").append(recoveryStatus.index().totalSize()).append("], throttling_wait [").append(recoveryStatus.index().throttlingWaitTime()).append("]\n");, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/index/gateway/blobstore/BlobStoreIndexShardGateway.java, +                indexShard.performRecoveryPrepareForTranslog();, +                indexShard.performRecoveryOperations(operations);, +                indexShard.performRecoveryFinalization();, +                // clean all the other translog, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/index/shard/recovery/RecoveryAction.java, +import org.elasticsearch.common.collect.Lists;, +import org.elasticsearch.common.collect.Maps;, +import org.elasticsearch.common.collect.Sets;, +import org.elasticsearch.index.translog.TranslogStreams;, +import java.util.Arrays;, +import java.util.Map;, +import java.util.Set;, +    private final String cleanFilesTransportAction;, +, +    private final String prepareForTranslogOperationsTransportAction;, +, +    private final String translogOperationsTransportAction;, +, +    private final String finalizeRecoveryTransportAction;, +, +, +        cleanFilesTransportAction = shardId.index().name() + "/" + shardId.id() + "/recovery/cleanFiles";, +        transportService.registerHandler(cleanFilesTransportAction, new CleanFilesRequestHandler());, +, +        prepareForTranslogOperationsTransportAction = shardId.index().name() + "/" + shardId.id() + "/recovery/prepareForTranslog";, +        transportService.registerHandler(prepareForTranslogOperationsTransportAction, new PrepareForTranslogOperationsRequestHandler());, +, +        translogOperationsTransportAction = shardId.index().name() + "/" + shardId.id() + "/recovery/translogOperations";, +        transportService.registerHandler(translogOperationsTransportAction, new TranslogOperationsRequestHandler());, +, +        finalizeRecoveryTransportAction = shardId.index().name() + "/" + shardId.id() + "/recovery/finalizeRecovery";, +        transportService.registerHandler(finalizeRecoveryTransportAction, new FinalizeRecoveryRequestHandler());, +        logger.trace("recovery action registered, using file_chunk_size[{}]", fileChunkSize);, +        transportService.removeHandler(cleanFilesTransportAction);, +        transportService.removeHandler(prepareForTranslogOperationsTransportAction);, +        transportService.removeHandler(translogOperationsTransportAction);, +        transportService.removeHandler(finalizeRecoveryTransportAction);, +            logger.debug("starting recovery from {}", targetNode);, +, +                // build a list of the current files located locally, maybe we don't need to recover them..., +                StartRecoveryRequest startRecoveryRequest = new StartRecoveryRequest(node, markAsRelocated);, +                for (String storeFile : store.directory().listAll()) {, +                    startRecoveryRequest.existingFiles.put(storeFile, store.directory().fileLength(storeFile));, +                }, +, +                    recoveryStatus = transportService.submitRequest(targetNode, startTransportAction, startRecoveryRequest, new FutureTransportResponseHandler<RecoveryStatus>() {, +                    sb.append("recovery completed from ").append(targetNode).append(", took[").append(stopWatch.totalTime()).append("], throttling_wait [").append(throttlingWaitTime.totalTime()).append("]\n");, +                    sb.append("   phase1: recovered_files [").append(recoveryStatus.phase1FileNames.size()).append("]").append(" with total_size of [").append(new ByteSizeValue(recoveryStatus.phase1TotalSize)).append("]"), +                    sb.append("         : reusing_files   [").append(recoveryStatus.phase1ExistingFileNames.size()).append("] with total_size of [").append(new ByteSizeValue(recoveryStatus.phase1ExistingTotalSize)).append("]\n");, +                    sb.append("   phase2: recovered [").append(recoveryStatus.phase2Operations).append("]").append(" transaction log operations"), +                    sb.append("   phase3: recovered [").append(recoveryStatus.phase3Operations).append("]").append(" transaction log operations"), +    static class StartRecoveryRequest implements Streamable {, +        DiscoveryNode node;, +        boolean markAsRelocated;, +, +        Map<String, Long> existingFiles = Maps.newHashMap();]