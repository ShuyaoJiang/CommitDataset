[+++ b/core/src/main/java/org/apache/lucene/queryparser/classic/MapperQueryParser.java, +                    rangeQuery = dateFieldType.rangeQuery(part1, part2, startInclusive, endInclusive, settings.timeZone(), null);, +                    rangeQuery = currentFieldType.rangeQuery(part1, part2, startInclusive, endInclusive);, +++ b/core/src/main/java/org/apache/lucene/queryparser/classic/MapperQueryParser.java, +                    rangeQuery = dateFieldType.rangeQuery(part1, part2, startInclusive, endInclusive, settings.timeZone(), null);, +                    rangeQuery = currentFieldType.rangeQuery(part1, part2, startInclusive, endInclusive);, +++ b/core/src/main/java/org/elasticsearch/gateway/ReplicaShardAllocator.java, +        final MetaData metaData = routingNodes.metaData();, +, +            boolean canBeAllocatedToAtLeastOneNode = false;, +            for (ObjectCursor<DiscoveryNode> cursor : allocation.nodes().dataNodes().values()) {, +                RoutingNode node = routingNodes.node(cursor.value.id());, +                if (node == null) {, +                    continue;, +                }, +                // if we can't allocate it on a node, ignore it, for example, this handles, +                // cases for only allocating a replica after a primary, +                Decision decision = allocation.deciders().canAllocate(shard, node, allocation);, +                if (decision.type() == Decision.Type.YES) {, +                    canBeAllocatedToAtLeastOneNode = true;, +                    break;, +                }, +            }, +, +            if (!canBeAllocatedToAtLeastOneNode) {, +            long lastSizeMatched = 0;, +            DiscoveryNode lastDiscoNodeMatched = null;, +            RoutingNode lastNodeMatched = null;, +            boolean hasReplicaData = false;, +            IndexMetaData indexMetaData = metaData.index(shard.getIndex());, +, +            for (Map.Entry<DiscoveryNode, TransportNodesListShardStoreMetaData.NodeStoreFilesMetaData> nodeStoreEntry : shardStores.getData().entrySet()) {, +                DiscoveryNode discoNode = nodeStoreEntry.getKey();, +                TransportNodesListShardStoreMetaData.StoreFilesMetaData storeFilesMetaData = nodeStoreEntry.getValue().storeFilesMetaData();, +                logger.trace("{}: checking node [{}]", shard, discoNode);, +, +                if (storeFilesMetaData == null) {, +                    // already allocated on that node..., +                RoutingNode node = routingNodes.node(discoNode.id());, +                if (node == null) {, +                    continue;, +                }, +                // check if we can allocate on that node..., +                // we only check for NO, since if this node is THROTTLING and it has enough "same data", +                // then we will try and assign it next time, +                Decision decision = allocation.deciders().canAllocate(shard, node, allocation);, +                if (decision.type() == Decision.Type.NO) {, +                    continue;, +                }, +, +                // if it is already allocated, we can't assign to it..., +                if (storeFilesMetaData.allocated()) {, +                    continue;, +                }, +, +                if (!shard.primary()) {, +                    hasReplicaData |= storeFilesMetaData.iterator().hasNext();, +                    ShardRouting primaryShard = routingNodes.activePrimary(shard);, +                    if (primaryShard != null) {, +                        assert primaryShard.active();, +                        DiscoveryNode primaryNode = allocation.nodes().get(primaryShard.currentNodeId());, +                        if (primaryNode != null) {, +                            TransportNodesListShardStoreMetaData.NodeStoreFilesMetaData primaryNodeFilesStore = shardStores.getData().get(primaryNode);, +                            if (primaryNodeFilesStore != null) {, +                                TransportNodesListShardStoreMetaData.StoreFilesMetaData primaryNodeStore = primaryNodeFilesStore.storeFilesMetaData();, +                                if (primaryNodeStore != null && primaryNodeStore.allocated()) {, +                                    long sizeMatched = 0;, +, +                                    String primarySyncId = primaryNodeStore.syncId();, +                                    String replicaSyncId = storeFilesMetaData.syncId();, +                                    // see if we have a sync id we can make use of, +                                    if (replicaSyncId != null && replicaSyncId.equals(primarySyncId)) {, +                                        logger.trace("{}: node [{}] has same sync id {} as primary", shard, discoNode.name(), replicaSyncId);, +                                        lastNodeMatched = node;, +                                        lastSizeMatched = Long.MAX_VALUE;, +                                        lastDiscoNodeMatched = discoNode;, +                                    } else {, +                                        for (StoreFileMetaData storeFileMetaData : storeFilesMetaData) {, +                                            String metaDataFileName = storeFileMetaData.name();, +                                            if (primaryNodeStore.fileExists(metaDataFileName) && primaryNodeStore.file(metaDataFileName).isSame(storeFileMetaData)) {, +                                                sizeMatched += storeFileMetaData.length();, +                                            }, +                                        }, +                                        logger.trace("{}: node [{}] has [{}/{}] bytes of re-usable data",, +                                                shard, discoNode.name(), new ByteSizeValue(sizeMatched), sizeMatched);, +                                        if (sizeMatched > lastSizeMatched) {, +                                            lastSizeMatched = sizeMatched;, +                                            lastDiscoNodeMatched = discoNode;, +                                            lastNodeMatched = node;, +                                        }, +                                    }, +                                }, +                            }, +                        }, +                    }, +                }, +            }, +, +            if (lastNodeMatched != null) {, +                Decision decision = allocation.deciders().canAllocate(shard, lastNodeMatched, allocation);]