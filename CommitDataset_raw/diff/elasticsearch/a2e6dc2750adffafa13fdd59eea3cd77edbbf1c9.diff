[+++ b/modules/rank-eval/src/main/java/org/elasticsearch/index/rankeval/RankEvalAction.java, +++ b/modules/rank-eval/src/main/java/org/elasticsearch/index/rankeval/RankEvalAction.java, +++ b/modules/rank-eval/src/main/java/org/elasticsearch/index/rankeval/RankEvalResponse.java, +    public String getSpecId() {, +        out.writeString(specId);, +        out.writeDouble(qualityLevel);, +        this.specId = in.readString();, +        this.qualityLevel = in.readDouble();, +        this.unknownDocs = (Map<String, Collection<RatedDocumentKey>>) in.readGenericValue();, +++ b/modules/rank-eval/src/main/java/org/elasticsearch/index/rankeval/RankEvalAction.java, +++ b/modules/rank-eval/src/main/java/org/elasticsearch/index/rankeval/RankEvalResponse.java, +    public String getSpecId() {, +        out.writeString(specId);, +        out.writeDouble(qualityLevel);, +        this.specId = in.readString();, +        this.qualityLevel = in.readDouble();, +        this.unknownDocs = (Map<String, Collection<RatedDocumentKey>>) in.readGenericValue();, +++ b/modules/rank-eval/src/main/java/org/elasticsearch/index/rankeval/ReciprocalRank.java, +            // TODO here we use index/type/id triple not for a rated document but an unrated document in the search hits. Maybe rename?, +++ b/modules/rank-eval/src/main/java/org/elasticsearch/index/rankeval/RankEvalAction.java, +++ b/modules/rank-eval/src/main/java/org/elasticsearch/index/rankeval/RankEvalResponse.java, +    public String getSpecId() {, +        out.writeString(specId);, +        out.writeDouble(qualityLevel);, +        this.specId = in.readString();, +        this.qualityLevel = in.readDouble();, +        this.unknownDocs = (Map<String, Collection<RatedDocumentKey>>) in.readGenericValue();, +++ b/modules/rank-eval/src/main/java/org/elasticsearch/index/rankeval/ReciprocalRank.java, +            // TODO here we use index/type/id triple not for a rated document but an unrated document in the search hits. Maybe rename?, +++ b/modules/rank-eval/src/main/java/org/elasticsearch/index/rankeval/TransportRankEvalAction.java, +        AtomicInteger responseCounter = new AtomicInteger(specifications.size());, +                    partialResults, unknownDocs, responseCounter);, +            if (responseCounter.decrementAndGet() < 1) {, +++ b/modules/rank-eval/src/main/java/org/elasticsearch/index/rankeval/RankEvalAction.java, +++ b/modules/rank-eval/src/main/java/org/elasticsearch/index/rankeval/RankEvalResponse.java, +    public String getSpecId() {, +        out.writeString(specId);, +        out.writeDouble(qualityLevel);, +        this.specId = in.readString();, +        this.qualityLevel = in.readDouble();, +        this.unknownDocs = (Map<String, Collection<RatedDocumentKey>>) in.readGenericValue();, +++ b/modules/rank-eval/src/main/java/org/elasticsearch/index/rankeval/ReciprocalRank.java, +            // TODO here we use index/type/id triple not for a rated document but an unrated document in the search hits. Maybe rename?, +++ b/modules/rank-eval/src/main/java/org/elasticsearch/index/rankeval/TransportRankEvalAction.java, +        AtomicInteger responseCounter = new AtomicInteger(specifications.size());, +                    partialResults, unknownDocs, responseCounter);, +            if (responseCounter.decrementAndGet() < 1) {, +++ b/modules/rank-eval/src/test/java/org/elasticsearch/index/rankeval/RankEvalRequestTests.java, +import org.elasticsearch.action.search.SearchPhaseExecutionException;, +import org.elasticsearch.index.query.RangeQueryBuilder;, +import java.util.Arrays;, +        List<String> indices = Arrays.asList(new String[] { "test" });, +        List<String> types = Arrays.asList(new String[] { "testtype" });, +        RankEvalRequestBuilder builder = new RankEvalRequestBuilder(client(), RankEvalAction.INSTANCE, new RankEvalRequest());, +    /**, +     * test that running a bad query (e.g. one that will target a non existing field) will error, +     */, +    public void testBadQuery() {, +        List<String> indices = Arrays.asList(new String[] { "test" });, +        List<String> types = Arrays.asList(new String[] { "testtype" });, +, +        String specId = randomAsciiOfLength(10);, +        List<QuerySpec> specifications = new ArrayList<>();, +        SearchSourceBuilder amsterdamQuery = new SearchSourceBuilder();, +        amsterdamQuery.query(new MatchAllQueryBuilder());, +        specifications.add(new QuerySpec("amsterdam_query", amsterdamQuery, indices, types, createRelevant("2", "3", "4", "5")));, +        SearchSourceBuilder brokenQuery = new SearchSourceBuilder();, +        RangeQueryBuilder brokenRangeQuery = new RangeQueryBuilder("text").timeZone("CET");, +        brokenQuery.query(brokenRangeQuery);, +        specifications.add(new QuerySpec("broken_query", brokenQuery, indices, types, createRelevant("1")));, +, +        RankEvalSpec task = new RankEvalSpec(specId, specifications, new PrecisionAtN(10));, +, +        RankEvalRequestBuilder builder = new RankEvalRequestBuilder(client(), RankEvalAction.INSTANCE, new RankEvalRequest());, +        builder.setRankEvalSpec(task);, +, +        expectThrows(SearchPhaseExecutionException.class, () -> client().execute(RankEvalAction.INSTANCE, builder.request()).actionGet());, +    }, +]