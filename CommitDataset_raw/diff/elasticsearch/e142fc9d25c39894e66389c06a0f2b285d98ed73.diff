[+++ b/src/main/java/org/elasticsearch/cluster/ClusterChangedEvent.java, +        if (previousState == null) {, +++ b/src/main/java/org/elasticsearch/cluster/ClusterChangedEvent.java, +        if (previousState == null) {, +++ b/src/main/java/org/elasticsearch/gateway/GatewayMetaState.java, +import org.elasticsearch.cluster.routing.DjbHashFunction;, +import org.elasticsearch.cluster.routing.HashFunction;, +import org.elasticsearch.cluster.routing.SimpleHashFunction;, +    private volatile MetaData currentMetaData;, +        if (DiscoveryNode.masterNode(settings)) {, +            this.currentMetaData = null;, +        // only applied to master node, writing the global and index level states, +        if (state.nodes().localNode().masterNode()) {, +            if (currentMetaData == null || !MetaData.isGlobalStateEquals(currentMetaData, newMetaData)) {, +            for (IndexMetaData indexMetaData : newMetaData) {, +                String writeReason = null;, +                IndexMetaData currentIndexMetaData;, +                if (currentMetaData == null) {, +                    // a new event..., check from the state stored, +                        currentIndexMetaData = metaStateService.loadIndexState(indexMetaData.index());, +                    } catch (IOException ex) {, +                        throw new ElasticsearchException("failed to load index state", ex);, +                    }, +                } else {, +                    currentIndexMetaData = currentMetaData.index(indexMetaData.index());, +                }, +                if (currentIndexMetaData == null) {, +                    writeReason = "freshly created";, +                } else if (currentIndexMetaData.version() != indexMetaData.version()) {, +                    writeReason = "version changed from [" + currentIndexMetaData.version() + "] to [" + indexMetaData.version() + "]";, +                }, +, +                // we update the writeReason only if we really need to write it, +                if (writeReason == null) {, +                    continue;, +                }, +, +                try {, +                    metaStateService.writeIndex(writeReason, indexMetaData, currentIndexMetaData);, +            currentMetaData = newMetaData;, +++ b/src/main/java/org/elasticsearch/cluster/ClusterChangedEvent.java, +        if (previousState == null) {, +++ b/src/main/java/org/elasticsearch/gateway/GatewayMetaState.java, +import org.elasticsearch.cluster.routing.DjbHashFunction;, +import org.elasticsearch.cluster.routing.HashFunction;, +import org.elasticsearch.cluster.routing.SimpleHashFunction;, +    private volatile MetaData currentMetaData;, +        if (DiscoveryNode.masterNode(settings)) {, +            this.currentMetaData = null;, +        // only applied to master node, writing the global and index level states, +        if (state.nodes().localNode().masterNode()) {, +            if (currentMetaData == null || !MetaData.isGlobalStateEquals(currentMetaData, newMetaData)) {, +            for (IndexMetaData indexMetaData : newMetaData) {, +                String writeReason = null;, +                IndexMetaData currentIndexMetaData;, +                if (currentMetaData == null) {, +                    // a new event..., check from the state stored, +                        currentIndexMetaData = metaStateService.loadIndexState(indexMetaData.index());, +                    } catch (IOException ex) {, +                        throw new ElasticsearchException("failed to load index state", ex);, +                    }, +                } else {, +                    currentIndexMetaData = currentMetaData.index(indexMetaData.index());, +                }, +                if (currentIndexMetaData == null) {, +                    writeReason = "freshly created";, +                } else if (currentIndexMetaData.version() != indexMetaData.version()) {, +                    writeReason = "version changed from [" + currentIndexMetaData.version() + "] to [" + indexMetaData.version() + "]";, +                }, +, +                // we update the writeReason only if we really need to write it, +                if (writeReason == null) {, +                    continue;, +                }, +, +                try {, +                    metaStateService.writeIndex(writeReason, indexMetaData, currentIndexMetaData);, +            currentMetaData = newMetaData;, +++ b/src/main/java/org/elasticsearch/index/query/AndFilterBuilder.java, +, +    @Override, +    protected String parserName() {, +        return AndFilterParser.NAME;, +    }, +++ b/src/main/java/org/elasticsearch/cluster/ClusterChangedEvent.java, +        if (previousState == null) {, +++ b/src/main/java/org/elasticsearch/gateway/GatewayMetaState.java, +import org.elasticsearch.cluster.routing.DjbHashFunction;, +import org.elasticsearch.cluster.routing.HashFunction;, +import org.elasticsearch.cluster.routing.SimpleHashFunction;, +    private volatile MetaData currentMetaData;, +        if (DiscoveryNode.masterNode(settings)) {, +            this.currentMetaData = null;, +        // only applied to master node, writing the global and index level states, +        if (state.nodes().localNode().masterNode()) {, +            if (currentMetaData == null || !MetaData.isGlobalStateEquals(currentMetaData, newMetaData)) {, +            for (IndexMetaData indexMetaData : newMetaData) {, +                String writeReason = null;, +                IndexMetaData currentIndexMetaData;, +                if (currentMetaData == null) {]