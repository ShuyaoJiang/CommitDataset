[+++ b/core/src/main/java/org/elasticsearch/ElasticsearchException.java, +import org.apache.logging.log4j.message.ParameterizedMessage;, +        DELETE_FAILED_ENGINE_EXCEPTION(org.elasticsearch.index.engine.DeleteFailedEngineException.class,, +                org.elasticsearch.index.engine.DeleteFailedEngineException::new, 28),, +        INDEX_FAILED_ENGINE_EXCEPTION(org.elasticsearch.index.engine.IndexFailedEngineException.class,, +                org.elasticsearch.index.engine.IndexFailedEngineException::new, 80),, +++ b/core/src/main/java/org/elasticsearch/ElasticsearchException.java, +import org.apache.logging.log4j.message.ParameterizedMessage;, +        DELETE_FAILED_ENGINE_EXCEPTION(org.elasticsearch.index.engine.DeleteFailedEngineException.class,, +                org.elasticsearch.index.engine.DeleteFailedEngineException::new, 28),, +        INDEX_FAILED_ENGINE_EXCEPTION(org.elasticsearch.index.engine.IndexFailedEngineException.class,, +                org.elasticsearch.index.engine.IndexFailedEngineException::new, 80),, +++ b/core/src/main/java/org/elasticsearch/action/bulk/TransportShardBulkAction.java, +import org.elasticsearch.ElasticsearchException;, +import org.elasticsearch.ExceptionsHelper;, +import org.elasticsearch.action.delete.TransportDeleteAction;, +import org.elasticsearch.index.engine.Engine;, +import org.elasticsearch.index.translog.Translog.Location;, +public class TransportShardBulkAction extends TransportWriteAction<BulkShardRequest, BulkShardResponse> {, +                indexNameExpressionResolver, BulkShardRequest::new, ThreadPool.Names.BULK);, +    protected WriteResult<BulkShardResponse> onPrimaryShard(BulkShardRequest request, IndexShard primary) throws Exception {, +        return new WriteResult<>(response, location);, +    private Translog.Location executeBulkItemRequest(IndexMetaData metaData, IndexShard indexShard,, +                                                     Translog.Location location, int requestIndex) {, +            WriteResult<? extends DocWriteResponse> writeResult = innerExecuteBulkItemRequest(metaData, indexShard,, +                request, requestIndex);, +            if (writeResult.getLocation() != null) {, +                location = locationToSync(location, writeResult.getLocation());, +                assert writeResult.getResponse().getResult() == DocWriteResponse.Result.NOOP, +            setResponse(item, new BulkItemResponse(item.id(), opType, writeResult.getResponse()));, +                throw (ElasticsearchException) e;, +            BulkItemRequest item = request.items()[requestIndex];, +            DocWriteRequest docWriteRequest = item.request();, +            if (isConflictException(e)) {, +                logger.trace((Supplier<?>) () -> new ParameterizedMessage("{} failed to execute bulk item ({}) {}",, +                        request.shardId(), docWriteRequest.opType().getLowercase(), request), e);, +            } else {, +                logger.debug((Supplier<?>) () -> new ParameterizedMessage("{} failed to execute bulk item ({}) {}",, +                        request.shardId(), docWriteRequest.opType().getLowercase(), request), e);, +            }, +            // if its a conflict failure, and we already executed the request on a primary (and we execute it, +            // again, due to primary relocation and only processing up to N bulk items when the shard gets closed), +            // then just use the response we got from the successful execution, +            if (item.getPrimaryResponse() != null && isConflictException(e)) {, +                setResponse(item, item.getPrimaryResponse());, +            } else {, +                setResponse(item, new BulkItemResponse(item.id(), docWriteRequest.opType(),, +                    new BulkItemResponse.Failure(request.index(), docWriteRequest.type(), docWriteRequest.id(), e)));, +            }, +    private WriteResult<? extends DocWriteResponse> innerExecuteBulkItemRequest(IndexMetaData metaData, IndexShard indexShard,, +                                                            BulkShardRequest request, int requestIndex) throws Exception {, +        DocWriteRequest itemRequest = request.items()[requestIndex].request();, +        switch (itemRequest.opType()) {, +            case CREATE:, +            case INDEX:, +                return TransportIndexAction.executeIndexRequestOnPrimary(((IndexRequest) itemRequest), indexShard, mappingUpdatedAction);, +            case UPDATE:, +                int maxAttempts = ((UpdateRequest) itemRequest).retryOnConflict();, +                for (int attemptCount = 0; attemptCount <= maxAttempts; attemptCount++) {, +                    try {, +                        return shardUpdateOperation(metaData, indexShard, request, requestIndex, ((UpdateRequest) itemRequest));, +                    } catch (Exception e) {, +                        final Throwable cause = ExceptionsHelper.unwrapCause(e);, +                        if (attemptCount == maxAttempts  // bubble up exception when we run out of attempts, +                                || (cause instanceof VersionConflictEngineException) == false) { // or when exception is not a version conflict, +                            throw e;, +                        }, +                    }, +                }, +                throw new IllegalStateException("version conflict exception should bubble up on last attempt");, +            case DELETE:, +                return TransportDeleteAction.executeDeleteRequestOnPrimary(((DeleteRequest) itemRequest), indexShard);, +            default: throw new IllegalStateException("unexpected opType [" + itemRequest.opType() + "] found");, +        }, +    }, +, +    private WriteResult<? extends DocWriteResponse> shardUpdateOperation(IndexMetaData metaData, IndexShard indexShard,, +        // Todo: capture read version conflicts, missing documents and malformed script errors in the write result due to get request, +        UpdateHelper.Result translate = updateHelper.prepare(updateRequest, indexShard, threadPool::estimatedTimeInMillis);, +                WriteResult<IndexResponse> writeResult = TransportIndexAction.executeIndexRequestOnPrimary(indexRequest, indexShard, mappingUpdatedAction);, +                return new WriteResult<>(update, writeResult.getLocation());, +                WriteResult<DeleteResponse> deleteResult = TransportDeleteAction.executeDeleteRequestOnPrimary(deleteRequest, indexShard);, +                return new WriteResult<>(deleteUpdateResponse, deleteResult.getLocation());, +                indexShard.noopUpdate(updateRequest.type());, +                return new WriteResult<>(translate.action(), null);, +    protected Location onReplicaShard(BulkShardRequest request, IndexShard indexShard) {, +            final Engine.Operation operation;, +                        operation = TransportIndexAction.executeIndexRequestOnReplica(((IndexRequest) docWriteRequest), indexShard);, +                        operation = TransportDeleteAction.executeDeleteRequestOnReplica(((DeleteRequest) docWriteRequest), indexShard);, +                location = locationToSync(location, operation.getTranslogLocation());, +        return location;, +++ b/core/src/main/java/org/elasticsearch/ElasticsearchException.java, +import org.apache.logging.log4j.message.ParameterizedMessage;, +        DELETE_FAILED_ENGINE_EXCEPTION(org.elasticsearch.index.engine.DeleteFailedEngineException.class,, +                org.elasticsearch.index.engine.DeleteFailedEngineException::new, 28),, +        INDEX_FAILED_ENGINE_EXCEPTION(org.elasticsearch.index.engine.IndexFailedEngineException.class,, +                org.elasticsearch.index.engine.IndexFailedEngineException::new, 80),, +++ b/core/src/main/java/org/elasticsearch/action/bulk/TransportShardBulkAction.java, +import org.elasticsearch.ElasticsearchException;, +import org.elasticsearch.ExceptionsHelper;]