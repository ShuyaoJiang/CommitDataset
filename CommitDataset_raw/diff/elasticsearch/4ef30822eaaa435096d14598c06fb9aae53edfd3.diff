[+++ b/src/test/java/org/elasticsearch/watcher/test/integration/BootStrapTests.java, +import org.elasticsearch.action.search.SearchResponse;, +import org.elasticsearch.common.xcontent.XContentType;, +import org.elasticsearch.watcher.WatcherService;, +import org.elasticsearch.watcher.client.WatchSourceBuilder;, +import static org.elasticsearch.test.hamcrest.ElasticsearchAssertions.assertHitCount;, +import static org.elasticsearch.watcher.actions.ActionBuilders.indexAction;, +import static org.elasticsearch.watcher.client.WatchSourceBuilders.watchBuilder;, +import static org.elasticsearch.watcher.condition.ConditionBuilders.alwaysCondition;, +import static org.elasticsearch.watcher.condition.ConditionBuilders.scriptCondition;, +import static org.elasticsearch.watcher.input.InputBuilders.searchInput;, +import static org.elasticsearch.watcher.test.WatcherTestUtils.newInputSearchRequest;, +import static org.elasticsearch.watcher.transform.TransformBuilders.searchTransform;, +import static org.elasticsearch.watcher.trigger.TriggerBuilders.schedule;, +import static org.elasticsearch.watcher.trigger.schedule.Schedules.cron;, +    @Override, +    protected boolean timeWarped() {, +        return false;, +    }, +    @Test, +    public void testLoadExistingWatchesUponStartup() throws Exception {, +        int numWatches = scaledRandomIntBetween(16, 128);, +        SearchRequest searchRequest = newInputSearchRequest("my-index").source(searchSource().query(termQuery("field", "value")));, +        for (int i = 0; i < numWatches; i++) {, +            client().prepareIndex(WatchStore.INDEX, WatchStore.DOC_TYPE, "_id" + i), +                    .setSource(watchBuilder(), +                                    .trigger(schedule(cron("0 0/5 * * * ? 2050"))), +                                    .input(searchInput(searchRequest)), +                                    .condition(scriptCondition("ctx.payload.hits.total == 1")), +                                    .buildAsBytes(XContentType.JSON), +                    ), +        }, +        refresh();, +        assertThat(response.getWatchesCount(), equalTo((long) numWatches));, +    public void testWatchRecordLoading() throws Exception {, +        String watchId = "_id";, +        SearchRequest searchRequest = newInputSearchRequest("my-index").source(searchSource().query(termQuery("field", "value")));, +        watcherClient().preparePutWatch(watchId).setSource(watchBuilder(), +                .trigger(schedule(cron("0/5 * * * * ? 2050"))), +                .input(searchInput(searchRequest)), +                .condition(alwaysCondition()), +                .addAction("_id", indexAction("output", "test")), +                .throttlePeriod(TimeValue.timeValueMillis(0)), +        ).get();, +        int numRecords = scaledRandomIntBetween(2, 128);, +        for (int i = 0; i < numRecords; i++) {, +            now = now.plusMinutes(1);, +            ScheduleTriggerEvent event = new ScheduleTriggerEvent(watchId, now, now);, +            Wid wid = new Wid(watchId, randomLong(), now);, +            WatchRecord watchRecord = new WatchRecord(wid, watchService().getWatch(watchId), event);, +            String index = HistoryStore.getHistoryIndexNameForTime(now);, +            client().prepareIndex(index, HistoryStore.DOC_TYPE, watchRecord.id().value()), +                    .setConsistencyLevel(WriteConsistencyLevel.ALL), +        }, +        // We need to wait until all the records are processed from the internal execution queue, only then we can assert, +        // that numRecords watch records have been processed as part of starting up., +        assertBusy(new Runnable() {, +, +            @Override, +            public void run() {, +                WatcherStatsResponse response = watcherClient().prepareWatcherStats().get();, +                assertThat(response.getExecutionQueueSize(), equalTo(0l));, +            }, +        });, +        refresh();, +        SearchResponse searchResponse = client().prepareSearch("output").get();, +        assertHitCount(searchResponse, numRecords);, +        SearchRequest searchRequest = newInputSearchRequest("my-index").source(searchSource().query(termQuery("field", "value")));, +                String watchId = "_id" + i + "-" + j;, +                WatchSourceBuilder watchSource = watchBuilder(), +                        .trigger(schedule(cron("0/5 * * * * ? 2050"))), +                        .input(searchInput(searchRequest)), +                        .condition(alwaysCondition()), +                        .transform(searchTransform(searchRequest));, +                PutWatchResponse putWatchResponse = watcherClient().preparePutWatch(watchId).setSource(watchSource).get();, +                ScheduleTriggerEvent event = new ScheduleTriggerEvent(watchId, historyIndexDate, historyIndexDate);, +                Wid wid = new Wid(watchId, randomLong(), DateTime.now(UTC));, +                WatchRecord watchRecord = new WatchRecord(wid, watchService().getWatch(watchId), event);]