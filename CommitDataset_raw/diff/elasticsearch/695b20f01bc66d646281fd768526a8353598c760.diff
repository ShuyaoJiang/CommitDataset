[+++ b/server/src/main/java/org/elasticsearch/index/IndexService.java, +        if (indexSettings.isSoftDeleteEnabled()) {, +    }, +++ b/server/src/main/java/org/elasticsearch/index/IndexService.java, +        if (indexSettings.isSoftDeleteEnabled()) {, +    }, +++ b/server/src/main/java/org/elasticsearch/index/shard/IndexShard.java, +    private void ensureSoftDeletesEnabled(String feature) {, +        if (indexSettings.isSoftDeleteEnabled() == false) {, +            String message = feature + " requires soft deletes but " + indexSettings.getIndex() + " does not have soft deletes enabled";, +            assert false : message;, +            throw new IllegalStateException(message);, +        }, +    }, +, +        ensureSoftDeletesEnabled("retention leases");, +        ensureSoftDeletesEnabled("retention leases");, +        ensureSoftDeletesEnabled("retention leases");, +        ensureSoftDeletesEnabled("retention leases");, +++ b/server/src/main/java/org/elasticsearch/index/IndexService.java, +        if (indexSettings.isSoftDeleteEnabled()) {, +    }, +++ b/server/src/main/java/org/elasticsearch/index/shard/IndexShard.java, +    private void ensureSoftDeletesEnabled(String feature) {, +        if (indexSettings.isSoftDeleteEnabled() == false) {, +            String message = feature + " requires soft deletes but " + indexSettings.getIndex() + " does not have soft deletes enabled";, +            assert false : message;, +            throw new IllegalStateException(message);, +        }, +    }, +, +        ensureSoftDeletesEnabled("retention leases");, +        ensureSoftDeletesEnabled("retention leases");, +        ensureSoftDeletesEnabled("retention leases");, +        ensureSoftDeletesEnabled("retention leases");, +++ b/server/src/test/java/org/elasticsearch/index/seqno/RetentionLeaseIT.java, +import org.elasticsearch.test.transport.MockTransportService;, +import org.elasticsearch.transport.TransportService;, +                Stream.of(RetentionLeaseSyncIntervalSettingPlugin.class, MockTransportService.TestPlugin.class)), +    public void testRetentionLeasesBackgroundSyncWithSoftDeletesDisabled() throws Exception {, +        final int numberOfReplicas = 2 - scaledRandomIntBetween(0, 2);, +        internalCluster().ensureAtLeastNumDataNodes(1 + numberOfReplicas);, +        TimeValue syncIntervalSetting = TimeValue.timeValueMillis(between(1, 100));, +        final Settings settings = Settings.builder(), +            .put("index.number_of_shards", 1), +            .put("index.number_of_replicas", numberOfReplicas), +            .put(IndexService.RETENTION_LEASE_SYNC_INTERVAL_SETTING.getKey(), syncIntervalSetting.getStringRep()), +            .put(IndexSettings.INDEX_SOFT_DELETES_SETTING.getKey(), false), +            .build();, +        createIndex("index", settings);, +        final String primaryShardNodeId = clusterService().state().routingTable().index("index").shard(0).primaryShard().currentNodeId();, +        final String primaryShardNodeName = clusterService().state().nodes().get(primaryShardNodeId).getName();, +        final MockTransportService primaryTransportService = (MockTransportService) internalCluster().getInstance(, +            TransportService.class, primaryShardNodeName);, +        final AtomicBoolean backgroundSyncRequestSent = new AtomicBoolean();, +        primaryTransportService.addSendBehavior((connection, requestId, action, request, options) -> {, +            if (action.startsWith(RetentionLeaseBackgroundSyncAction.ACTION_NAME)) {, +                backgroundSyncRequestSent.set(true);, +            }, +            connection.sendRequest(requestId, action, request, options);, +        });, +        final long start = System.nanoTime();, +        ensureGreen("index");, +        final long syncEnd = System.nanoTime();, +        // We sleep long enough for the retention leases background sync to be triggered, +        Thread.sleep(Math.max(0, randomIntBetween(2, 3) * syncIntervalSetting.millis() - TimeUnit.NANOSECONDS.toMillis(syncEnd - start)));, +        assertFalse("retention leases background sync must be a noop if soft deletes is disabled", backgroundSyncRequestSent.get());, +    }, +, +++ b/server/src/main/java/org/elasticsearch/index/IndexService.java, +        if (indexSettings.isSoftDeleteEnabled()) {, +    }, +++ b/server/src/main/java/org/elasticsearch/index/shard/IndexShard.java, +    private void ensureSoftDeletesEnabled(String feature) {, +        if (indexSettings.isSoftDeleteEnabled() == false) {, +            String message = feature + " requires soft deletes but " + indexSettings.getIndex() + " does not have soft deletes enabled";, +            assert false : message;, +            throw new IllegalStateException(message);, +        }, +    }, +, +        ensureSoftDeletesEnabled("retention leases");, +        ensureSoftDeletesEnabled("retention leases");, +        ensureSoftDeletesEnabled("retention leases");, +        ensureSoftDeletesEnabled("retention leases");, +++ b/server/src/test/java/org/elasticsearch/index/seqno/RetentionLeaseIT.java, +import org.elasticsearch.test.transport.MockTransportService;, +import org.elasticsearch.transport.TransportService;, +                Stream.of(RetentionLeaseSyncIntervalSettingPlugin.class, MockTransportService.TestPlugin.class)), +    public void testRetentionLeasesBackgroundSyncWithSoftDeletesDisabled() throws Exception {, +        final int numberOfReplicas = 2 - scaledRandomIntBetween(0, 2);, +        internalCluster().ensureAtLeastNumDataNodes(1 + numberOfReplicas);, +        TimeValue syncIntervalSetting = TimeValue.timeValueMillis(between(1, 100));, +        final Settings settings = Settings.builder(), +            .put("index.number_of_shards", 1), +            .put("index.number_of_replicas", numberOfReplicas), +            .put(IndexService.RETENTION_LEASE_SYNC_INTERVAL_SETTING.getKey(), syncIntervalSetting.getStringRep()), +            .put(IndexSettings.INDEX_SOFT_DELETES_SETTING.getKey(), false), +            .build();, +        createIndex("index", settings);]