[+++ b/docs/reference/cluster/nodes-stats.asciidoc, +++ b/docs/reference/cluster/nodes-stats.asciidoc, +++ b/docs/reference/cluster/stats.asciidoc, +++ b/docs/reference/cluster/nodes-stats.asciidoc, +++ b/docs/reference/cluster/stats.asciidoc, +++ b/docs/reference/cluster/update-settings.asciidoc, +++ b/docs/reference/cluster/nodes-stats.asciidoc, +++ b/docs/reference/cluster/stats.asciidoc, +++ b/docs/reference/cluster/update-settings.asciidoc, +++ b/docs/reference/index-modules/merge.asciidoc, +`Math.max(1, Math.min(4, Runtime.getRuntime().availableProcessors() / 2))`, +`index.merge.scheduler.auto_throttle`::, +, +If this is true (the default), then the merge scheduler will, +rate-limit IO (writes) for merges to an adaptive value depending on, +how many merges are requested over time.  An application with a low, +indexing rate that unluckily suddenly requires a large merge will see, +that merge aggressively throttled, while an application doing heavy, +indexing will see the throttle move higher to allow merges to keep up, +with ongoing indexing.  This is a dynamic setting (you can <<../indices/update-settings,change it, +at any time on a running index>>)., +, +++ b/docs/reference/cluster/nodes-stats.asciidoc, +++ b/docs/reference/cluster/stats.asciidoc, +++ b/docs/reference/cluster/update-settings.asciidoc, +++ b/docs/reference/index-modules/merge.asciidoc, +`Math.max(1, Math.min(4, Runtime.getRuntime().availableProcessors() / 2))`, +`index.merge.scheduler.auto_throttle`::, +, +If this is true (the default), then the merge scheduler will, +rate-limit IO (writes) for merges to an adaptive value depending on, +how many merges are requested over time.  An application with a low, +indexing rate that unluckily suddenly requires a large merge will see, +that merge aggressively throttled, while an application doing heavy, +indexing will see the throttle move higher to allow merges to keep up, +with ongoing indexing.  This is a dynamic setting (you can <<../indices/update-settings,change it, +at any time on a running index>>)., +, +++ b/docs/reference/indices/update-settings.asciidoc, +`index.merge.scheduler.*`::, +    All the settings for the merge scheduler., +, +++ b/docs/reference/cluster/nodes-stats.asciidoc, +++ b/docs/reference/cluster/stats.asciidoc, +++ b/docs/reference/cluster/update-settings.asciidoc, +++ b/docs/reference/index-modules/merge.asciidoc, +`Math.max(1, Math.min(4, Runtime.getRuntime().availableProcessors() / 2))`, +`index.merge.scheduler.auto_throttle`::, +, +If this is true (the default), then the merge scheduler will, +rate-limit IO (writes) for merges to an adaptive value depending on, +how many merges are requested over time.  An application with a low, +indexing rate that unluckily suddenly requires a large merge will see, +that merge aggressively throttled, while an application doing heavy, +indexing will see the throttle move higher to allow merges to keep up, +with ongoing indexing.  This is a dynamic setting (you can <<../indices/update-settings,change it, +at any time on a running index>>)., +, +++ b/docs/reference/indices/update-settings.asciidoc, +`index.merge.scheduler.*`::, +    All the settings for the merge scheduler., +, +++ b/docs/reference/modules/indices.asciidoc, +++ b/docs/reference/cluster/nodes-stats.asciidoc, +++ b/docs/reference/cluster/stats.asciidoc, +++ b/docs/reference/cluster/update-settings.asciidoc, +++ b/docs/reference/index-modules/merge.asciidoc, +`Math.max(1, Math.min(4, Runtime.getRuntime().availableProcessors() / 2))`, +`index.merge.scheduler.auto_throttle`::, +, +If this is true (the default), then the merge scheduler will, +rate-limit IO (writes) for merges to an adaptive value depending on, +how many merges are requested over time.  An application with a low, +indexing rate that unluckily suddenly requires a large merge will see, +that merge aggressively throttled, while an application doing heavy, +indexing will see the throttle move higher to allow merges to keep up, +with ongoing indexing.  This is a dynamic setting (you can <<../indices/update-settings,change it, +at any time on a running index>>)., +, +++ b/docs/reference/indices/update-settings.asciidoc, +`index.merge.scheduler.*`::, +    All the settings for the merge scheduler., +, +++ b/docs/reference/modules/indices.asciidoc, +++ b/src/main/java/org/apache/lucene/index/TrackingConcurrentMergeScheduler.java, +            long stoppedMS = merge.rateLimiter.getTotalStoppedNS()/1000000;, +            long throttledMS = merge.rateLimiter.getTotalPausedNS()/1000000;, +, +            totalMergeStoppedTime.inc(stoppedMS);, +            totalMergeThrottledTime.inc(throttledMS);, +                                           "merge segment [%s] done: took [%s], [%,.1f MB], [%,d docs], [%s stopped], [%s throttled], [%,.1f MB written], [%,.1f MB/sec throttle]",, +                                           totalNumDocs,, +                                           TimeValue.timeValueMillis(stoppedMS),, +                                           TimeValue.timeValueMillis(throttledMS),, +                                           merge.rateLimiter.getTotalBytesWritten()/1024f/1024f,, +                                           merge.rateLimiter.getMBPerSec());, +++ b/docs/reference/cluster/nodes-stats.asciidoc, +++ b/docs/reference/cluster/stats.asciidoc, +++ b/docs/reference/cluster/update-settings.asciidoc, +++ b/docs/reference/index-modules/merge.asciidoc]