[+++ b/x-pack/plugin/sql/qa/src/main/java/org/elasticsearch/xpack/sql/qa/jdbc/JdbcTestUtils.java, +    public static String of(long millis, String zoneId) {, +        return StringUtils.toString(ZonedDateTime.ofInstant(Instant.ofEpochMilli(millis), ZoneId.of(zoneId)));, +++ b/x-pack/plugin/sql/qa/src/main/java/org/elasticsearch/xpack/sql/qa/jdbc/JdbcTestUtils.java, +    public static String of(long millis, String zoneId) {, +        return StringUtils.toString(ZonedDateTime.ofInstant(Instant.ofEpochMilli(millis), ZoneId.of(zoneId)));, +++ b/x-pack/plugin/sql/qa/src/main/java/org/elasticsearch/xpack/sql/qa/jdbc/ResultSetTestCase.java, +import org.junit.Before;, +    private String timeZoneId;, +, +    @Before, +    public void chooseRandomTimeZone() {, +        this.timeZoneId = randomKnownTimeZone();, +    }, +, +            assertEquals(format(Locale.ROOT, "Unable to convert value [%.128s] of type [DATETIME] to [Byte]", asDateString(randomDate)),, +            assertEquals(format(Locale.ROOT, "Unable to convert value [%.128s] of type [DATETIME] to [Byte]", asDateString(randomDate)),, +            assertEquals(format(Locale.ROOT, "Unable to convert value [%.128s] of type [DATETIME] to [Short]", asDateString(randomDate)),, +            assertEquals(format(Locale.ROOT, "Unable to convert value [%.128s] of type [DATETIME] to [Short]", asDateString(randomDate)),, +            assertEquals(format(Locale.ROOT, "Unable to convert value [%.128s] of type [DATETIME] to [Integer]",, +                asDateString(randomDate)), sqle.getMessage());, +            assertEquals(format(Locale.ROOT, "Unable to convert value [%.128s] of type [DATETIME] to [Integer]",, +                asDateString(randomDate)), sqle.getMessage());, +            assertEquals(format(Locale.ROOT, "Unable to convert value [%.128s] of type [DATETIME] to [Long]", asDateString(randomDate)),, +            assertEquals(format(Locale.ROOT, "Unable to convert value [%.128s] of type [DATETIME] to [Long]", asDateString(randomDate)),, +            assertEquals(format(Locale.ROOT, "Unable to convert value [%.128s] of type [DATETIME] to [Double]", asDateString(randomDate)),, +            assertEquals(format(Locale.ROOT, "Unable to convert value [%.128s] of type [DATETIME] to [Double]", asDateString(randomDate)),, +            assertEquals(format(Locale.ROOT, "Unable to convert value [%.128s] of type [DATETIME] to [Float]", asDateString(randomDate)),, +            assertEquals(format(Locale.ROOT, "Unable to convert value [%.128s] of type [DATETIME] to [Float]", asDateString(randomDate)),, +            assertEquals(format(Locale.ROOT, "Unable to convert value [%.128s] of type [DATETIME] to [Boolean]",, +                asDateString(randomDate1)), sqle.getMessage());, +            assertEquals(format(Locale.ROOT, "Unable to convert value [%.128s] of type [DATETIME] to [Boolean]",, +                asDateString(randomDate2)), sqle.getMessage());, +            assertEquals(format(Locale.ROOT, "Unable to convert value [%.128s] of type [DATETIME] to [Boolean]",, +                asDateString(randomDate2)), sqle.getMessage());, +        doWithQuery(SELECT_ALL_FIELDS, (results) -> {, +            java.sql.Date expectedDate = new java.sql.Date(connCalendar.getTimeInMillis());, +, +            assertEquals(expectedDate, results.getDate("test_date"));, +            assertEquals(expectedDate, results.getDate(9));, +            assertEquals(expectedDate, results.getObject("test_date", java.sql.Date.class));, +            assertEquals(expectedDate, results.getObject(9, java.sql.Date.class));, +        doWithQuery(SELECT_ALL_FIELDS, (results) -> {, +        doWithQuery(SELECT_ALL_FIELDS, (results) -> {, +        doWithQuery(SELECT_ALL_FIELDS, (results) -> {, +        doWithQuery(SELECT_ALL_FIELDS, (results) -> {, +            java.sql.Date expectedDate = new java.sql.Date(connCalendar1.getTimeInMillis());, +            assertEquals(expectedDate, results.getDate("test_date"));, +            assertEquals(expectedDate, results.getDate(1));, +            assertEquals(expectedDate, results.getObject("test_date", java.sql.Date.class));, +            assertEquals(expectedDate, results.getObject(1, java.sql.Date.class));, +            java.sql.Date expectedDate = new java.sql.Date(connCalendar2.getTimeInMillis());, +            assertEquals(expectedDate, results.getDate("test_date"));, +            assertEquals(expectedDate, results.getDate(1));, +            assertEquals(expectedDate, results.getObject("test_date", java.sql.Date.class));, +            assertEquals(expectedDate, results.getObject(1, java.sql.Date.class));, +        doWithQuery(() -> esJdbc(timeZoneId), query, consumer);, +, +    private String asDateString(long millis) {, +        return of(millis, timeZoneId);, +    }, +++ b/x-pack/plugin/sql/qa/src/main/java/org/elasticsearch/xpack/sql/qa/jdbc/JdbcTestUtils.java, +    public static String of(long millis, String zoneId) {, +        return StringUtils.toString(ZonedDateTime.ofInstant(Instant.ofEpochMilli(millis), ZoneId.of(zoneId)));, +++ b/x-pack/plugin/sql/qa/src/main/java/org/elasticsearch/xpack/sql/qa/jdbc/ResultSetTestCase.java, +import org.junit.Before;, +    private String timeZoneId;, +, +    @Before, +    public void chooseRandomTimeZone() {, +        this.timeZoneId = randomKnownTimeZone();, +    }, +, +            assertEquals(format(Locale.ROOT, "Unable to convert value [%.128s] of type [DATETIME] to [Byte]", asDateString(randomDate)),, +            assertEquals(format(Locale.ROOT, "Unable to convert value [%.128s] of type [DATETIME] to [Byte]", asDateString(randomDate)),, +            assertEquals(format(Locale.ROOT, "Unable to convert value [%.128s] of type [DATETIME] to [Short]", asDateString(randomDate)),, +            assertEquals(format(Locale.ROOT, "Unable to convert value [%.128s] of type [DATETIME] to [Short]", asDateString(randomDate)),, +            assertEquals(format(Locale.ROOT, "Unable to convert value [%.128s] of type [DATETIME] to [Integer]",, +                asDateString(randomDate)), sqle.getMessage());, +            assertEquals(format(Locale.ROOT, "Unable to convert value [%.128s] of type [DATETIME] to [Integer]",, +                asDateString(randomDate)), sqle.getMessage());, +            assertEquals(format(Locale.ROOT, "Unable to convert value [%.128s] of type [DATETIME] to [Long]", asDateString(randomDate)),, +            assertEquals(format(Locale.ROOT, "Unable to convert value [%.128s] of type [DATETIME] to [Long]", asDateString(randomDate)),, +            assertEquals(format(Locale.ROOT, "Unable to convert value [%.128s] of type [DATETIME] to [Double]", asDateString(randomDate)),, +            assertEquals(format(Locale.ROOT, "Unable to convert value [%.128s] of type [DATETIME] to [Double]", asDateString(randomDate)),, +            assertEquals(format(Locale.ROOT, "Unable to convert value [%.128s] of type [DATETIME] to [Float]", asDateString(randomDate)),, +            assertEquals(format(Locale.ROOT, "Unable to convert value [%.128s] of type [DATETIME] to [Float]", asDateString(randomDate)),, +            assertEquals(format(Locale.ROOT, "Unable to convert value [%.128s] of type [DATETIME] to [Boolean]",, +                asDateString(randomDate1)), sqle.getMessage());, +            assertEquals(format(Locale.ROOT, "Unable to convert value [%.128s] of type [DATETIME] to [Boolean]",, +                asDateString(randomDate2)), sqle.getMessage());, +            assertEquals(format(Locale.ROOT, "Unable to convert value [%.128s] of type [DATETIME] to [Boolean]",, +                asDateString(randomDate2)), sqle.getMessage());, +        doWithQuery(SELECT_ALL_FIELDS, (results) -> {, +            java.sql.Date expectedDate = new java.sql.Date(connCalendar.getTimeInMillis());, +, +            assertEquals(expectedDate, results.getDate("test_date"));, +            assertEquals(expectedDate, results.getDate(9));, +            assertEquals(expectedDate, results.getObject("test_date", java.sql.Date.class));, +            assertEquals(expectedDate, results.getObject(9, java.sql.Date.class));]