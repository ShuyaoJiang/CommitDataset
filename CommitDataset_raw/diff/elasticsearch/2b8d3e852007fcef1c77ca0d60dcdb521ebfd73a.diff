[+++ b/x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authz/IndicesAndAliasesResolver.java, +import org.elasticsearch.cluster.metadata.AliasMetaData;, +import org.elasticsearch.common.Strings;, +import org.elasticsearch.common.collect.ImmutableOpenMap;, +import java.util.Optional;, +class IndicesAndAliasesResolver {, +    IndicesAndAliasesResolver(Settings settings, ClusterService clusterService) {, +    ResolvedIndices resolve(TransportRequest request, MetaData metaData, AuthorizedIndices authorizedIndices) {, +            resolvedIndicesBuilder.addLocal(getPutMappingIndexOrAlias((PutMappingRequest) indicesRequest, authorizedIndices, metaData));, +    /**, +     * Special handling of the value to authorize for a put mapping request. Dynamic put mapping, +     * requests use a concrete index, but we allow permissions to be defined on aliases so if the, +     * request's concrete index is not in the list of authorized indices, then we need to look to, +     * see if this can be authorized against an alias, +     */, +    static String getPutMappingIndexOrAlias(PutMappingRequest request, AuthorizedIndices authorizedIndices, MetaData metaData) {, +        final String concreteIndexName = request.getConcreteIndex().getName();, +        final List<String> authorizedIndicesList = authorizedIndices.get();, +, +        // validate that the concrete index exists, otherwise there is no remapping that we could do, +        final AliasOrIndex aliasOrIndex = metaData.getAliasAndIndexLookup().get(concreteIndexName);, +        final String resolvedAliasOrIndex;, +        if (aliasOrIndex == null) {, +            resolvedAliasOrIndex = concreteIndexName;, +        } else if (aliasOrIndex.isAlias()) {, +            throw new IllegalStateException("concrete index [" + concreteIndexName + "] is an alias but should not be");, +        } else if (authorizedIndicesList.contains(concreteIndexName)) {, +            // user is authorized to put mappings for this index, +            resolvedAliasOrIndex = concreteIndexName;, +        } else {, +            // the user is not authorized to put mappings for this index, but could have been, +            // authorized for a write using an alias that triggered a dynamic mapping update, +            ImmutableOpenMap<String, List<AliasMetaData>> foundAliases =, +                metaData.findAliases(Strings.EMPTY_ARRAY, new String[] { concreteIndexName });, +            List<AliasMetaData> aliasMetaData = foundAliases.get(concreteIndexName);, +            if (aliasMetaData != null) {, +                Optional<String> foundAlias = aliasMetaData.stream(), +                    .map(AliasMetaData::alias), +                    .filter(authorizedIndicesList::contains), +                    .filter(aliasName -> metaData.getAliasAndIndexLookup().get(aliasName).getIndices().size() == 1), +                    .findFirst();, +                resolvedAliasOrIndex = foundAlias.orElse(concreteIndexName);, +            } else {, +                resolvedAliasOrIndex = concreteIndexName;, +            }, +        }, +, +        return resolvedAliasOrIndex;, +    }, +, +    static boolean allowsRemoteIndices(IndicesRequest request) {, +++ b/x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authz/IndicesAndAliasesResolver.java, +import org.elasticsearch.cluster.metadata.AliasMetaData;, +import org.elasticsearch.common.Strings;, +import org.elasticsearch.common.collect.ImmutableOpenMap;, +import java.util.Optional;, +class IndicesAndAliasesResolver {, +    IndicesAndAliasesResolver(Settings settings, ClusterService clusterService) {, +    ResolvedIndices resolve(TransportRequest request, MetaData metaData, AuthorizedIndices authorizedIndices) {, +            resolvedIndicesBuilder.addLocal(getPutMappingIndexOrAlias((PutMappingRequest) indicesRequest, authorizedIndices, metaData));, +    /**, +     * Special handling of the value to authorize for a put mapping request. Dynamic put mapping, +     * requests use a concrete index, but we allow permissions to be defined on aliases so if the, +     * request's concrete index is not in the list of authorized indices, then we need to look to, +     * see if this can be authorized against an alias, +     */, +    static String getPutMappingIndexOrAlias(PutMappingRequest request, AuthorizedIndices authorizedIndices, MetaData metaData) {, +        final String concreteIndexName = request.getConcreteIndex().getName();, +        final List<String> authorizedIndicesList = authorizedIndices.get();, +, +        // validate that the concrete index exists, otherwise there is no remapping that we could do, +        final AliasOrIndex aliasOrIndex = metaData.getAliasAndIndexLookup().get(concreteIndexName);, +        final String resolvedAliasOrIndex;, +        if (aliasOrIndex == null) {, +            resolvedAliasOrIndex = concreteIndexName;, +        } else if (aliasOrIndex.isAlias()) {, +            throw new IllegalStateException("concrete index [" + concreteIndexName + "] is an alias but should not be");, +        } else if (authorizedIndicesList.contains(concreteIndexName)) {, +            // user is authorized to put mappings for this index, +            resolvedAliasOrIndex = concreteIndexName;, +        } else {, +            // the user is not authorized to put mappings for this index, but could have been, +            // authorized for a write using an alias that triggered a dynamic mapping update, +            ImmutableOpenMap<String, List<AliasMetaData>> foundAliases =, +                metaData.findAliases(Strings.EMPTY_ARRAY, new String[] { concreteIndexName });, +            List<AliasMetaData> aliasMetaData = foundAliases.get(concreteIndexName);, +            if (aliasMetaData != null) {, +                Optional<String> foundAlias = aliasMetaData.stream(), +                    .map(AliasMetaData::alias), +                    .filter(authorizedIndicesList::contains), +                    .filter(aliasName -> metaData.getAliasAndIndexLookup().get(aliasName).getIndices().size() == 1), +                    .findFirst();, +                resolvedAliasOrIndex = foundAlias.orElse(concreteIndexName);, +            } else {, +                resolvedAliasOrIndex = concreteIndexName;, +            }, +        }, +, +        return resolvedAliasOrIndex;, +    }]