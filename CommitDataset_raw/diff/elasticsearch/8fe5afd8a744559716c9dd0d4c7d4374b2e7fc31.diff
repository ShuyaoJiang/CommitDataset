[+++ /dev/null, +++ /dev/null, +++ b/elasticsearch/x-pack/shield/dev-tools/esvm/.esvmrc, +          "multicast.enabled": false,, +++ /dev/null, +++ b/elasticsearch/x-pack/shield/dev-tools/esvm/.esvmrc, +          "multicast.enabled": false,, +++ b/elasticsearch/x-pack/shield/src/main/java/org/elasticsearch/shield/InternalShieldUser.java, +            .cluster(ClusterPrivilege.get(new Privilege.Name(PutIndexTemplateAction.NAME, "cluster:admin/shield/realm/cache/clear*", "cluster:admin/shield/roles/cache/clear*"))), +++ /dev/null, +++ b/elasticsearch/x-pack/shield/dev-tools/esvm/.esvmrc, +          "multicast.enabled": false,, +++ b/elasticsearch/x-pack/shield/src/main/java/org/elasticsearch/shield/InternalShieldUser.java, +            .cluster(ClusterPrivilege.get(new Privilege.Name(PutIndexTemplateAction.NAME, "cluster:admin/shield/realm/cache/clear*", "cluster:admin/shield/roles/cache/clear*"))), +++ b/elasticsearch/x-pack/shield/src/main/java/org/elasticsearch/shield/action/ShieldActionFilter.java, +                // FIXME yet another hack. Needed to work around something like, +                /*, +                FailedNodeException[total failure in fetching]; nested: ElasticsearchSecurityException[action [internal:gateway/local/started_shards] is unauthorized for user [test_user]];, +                    at org.elasticsearch.gateway.AsyncShardFetch$1.onFailure(AsyncShardFetch.java:284), +                    at org.elasticsearch.action.support.TransportAction$1.onFailure(TransportAction.java:84), +                    at org.elasticsearch.shield.action.ShieldActionFilter.apply(ShieldActionFilter.java:121), +                    at org.elasticsearch.action.support.TransportAction$RequestFilterChain.proceed(TransportAction.java:133), +                    at org.elasticsearch.action.support.TransportAction.execute(TransportAction.java:107), +                    at org.elasticsearch.action.support.TransportAction.execute(TransportAction.java:74), +                    at org.elasticsearch.gateway.TransportNodesListGatewayStartedShards.list(TransportNodesListGatewayStartedShards.java:78), +                    at org.elasticsearch.gateway.AsyncShardFetch.asyncFetch(AsyncShardFetch.java:274), +                    at org.elasticsearch.gateway.AsyncShardFetch.fetchData(AsyncShardFetch.java:124), +                    at org.elasticsearch.gateway.GatewayAllocator$InternalPrimaryShardAllocator.fetchData(GatewayAllocator.java:156), +                    at org.elasticsearch.gateway.PrimaryShardAllocator.allocateUnassigned(PrimaryShardAllocator.java:83), +                    at org.elasticsearch.gateway.GatewayAllocator.allocateUnassigned(GatewayAllocator.java:120), +                    at org.elasticsearch.cluster.routing.allocation.allocator.ShardsAllocators.allocateUnassigned(ShardsAllocators.java:72), +                    at org.elasticsearch.cluster.routing.allocation.AllocationService.reroute(AllocationService.java:309), +                    at org.elasticsearch.cluster.routing.allocation.AllocationService.reroute(AllocationService.java:273), +                    at org.elasticsearch.cluster.routing.allocation.AllocationService.reroute(AllocationService.java:259), +                    at org.elasticsearch.cluster.routing.RoutingService$2.execute(RoutingService.java:158), +                    at org.elasticsearch.cluster.ClusterStateUpdateTask.execute(ClusterStateUpdateTask.java:45), +                    at org.elasticsearch.cluster.service.InternalClusterService.runTasksForExecutor(InternalClusterService.java:447), +                    at org.elasticsearch.cluster.service.InternalClusterService$UpdateTask.run(InternalClusterService.java:757), +                    at org.elasticsearch.common.util.concurrent.EsThreadPoolExecutor$FilterRunnable.run(EsThreadPoolExecutor.java:211), +                    at org.elasticsearch.common.util.concurrent.PrioritizedEsThreadPoolExecutor$TieBreakingPrioritizedRunnable.runAndClean(PrioritizedEsThreadPoolExecutor.java:237), +                    at org.elasticsearch.common.util.concurrent.PrioritizedEsThreadPoolExecutor$TieBreakingPrioritizedRunnable.run(PrioritizedEsThreadPoolExecutor.java:200), +                    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142), +                    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617), +                    at java.lang.Thread.run(Thread.java:745), +                 */, +                if (INTERNAL_PREDICATE.test(action)) {, +, +, +++ /dev/null, +++ b/elasticsearch/x-pack/shield/dev-tools/esvm/.esvmrc, +          "multicast.enabled": false,, +++ b/elasticsearch/x-pack/shield/src/main/java/org/elasticsearch/shield/InternalShieldUser.java, +            .cluster(ClusterPrivilege.get(new Privilege.Name(PutIndexTemplateAction.NAME, "cluster:admin/shield/realm/cache/clear*", "cluster:admin/shield/roles/cache/clear*"))), +++ b/elasticsearch/x-pack/shield/src/main/java/org/elasticsearch/shield/action/ShieldActionFilter.java, +                // FIXME yet another hack. Needed to work around something like, +                /*, +                FailedNodeException[total failure in fetching]; nested: ElasticsearchSecurityException[action [internal:gateway/local/started_shards] is unauthorized for user [test_user]];, +                    at org.elasticsearch.gateway.AsyncShardFetch$1.onFailure(AsyncShardFetch.java:284), +                    at org.elasticsearch.action.support.TransportAction$1.onFailure(TransportAction.java:84), +                    at org.elasticsearch.shield.action.ShieldActionFilter.apply(ShieldActionFilter.java:121), +                    at org.elasticsearch.action.support.TransportAction$RequestFilterChain.proceed(TransportAction.java:133), +                    at org.elasticsearch.action.support.TransportAction.execute(TransportAction.java:107), +                    at org.elasticsearch.action.support.TransportAction.execute(TransportAction.java:74), +                    at org.elasticsearch.gateway.TransportNodesListGatewayStartedShards.list(TransportNodesListGatewayStartedShards.java:78), +                    at org.elasticsearch.gateway.AsyncShardFetch.asyncFetch(AsyncShardFetch.java:274), +                    at org.elasticsearch.gateway.AsyncShardFetch.fetchData(AsyncShardFetch.java:124), +                    at org.elasticsearch.gateway.GatewayAllocator$InternalPrimaryShardAllocator.fetchData(GatewayAllocator.java:156), +                    at org.elasticsearch.gateway.PrimaryShardAllocator.allocateUnassigned(PrimaryShardAllocator.java:83), +                    at org.elasticsearch.gateway.GatewayAllocator.allocateUnassigned(GatewayAllocator.java:120), +                    at org.elasticsearch.cluster.routing.allocation.allocator.ShardsAllocators.allocateUnassigned(ShardsAllocators.java:72), +                    at org.elasticsearch.cluster.routing.allocation.AllocationService.reroute(AllocationService.java:309), +                    at org.elasticsearch.cluster.routing.allocation.AllocationService.reroute(AllocationService.java:273), +                    at org.elasticsearch.cluster.routing.allocation.AllocationService.reroute(AllocationService.java:259), +                    at org.elasticsearch.cluster.routing.RoutingService$2.execute(RoutingService.java:158), +                    at org.elasticsearch.cluster.ClusterStateUpdateTask.execute(ClusterStateUpdateTask.java:45), +                    at org.elasticsearch.cluster.service.InternalClusterService.runTasksForExecutor(InternalClusterService.java:447), +                    at org.elasticsearch.cluster.service.InternalClusterService$UpdateTask.run(InternalClusterService.java:757), +                    at org.elasticsearch.common.util.concurrent.EsThreadPoolExecutor$FilterRunnable.run(EsThreadPoolExecutor.java:211), +                    at org.elasticsearch.common.util.concurrent.PrioritizedEsThreadPoolExecutor$TieBreakingPrioritizedRunnable.runAndClean(PrioritizedEsThreadPoolExecutor.java:237), +                    at org.elasticsearch.common.util.concurrent.PrioritizedEsThreadPoolExecutor$TieBreakingPrioritizedRunnable.run(PrioritizedEsThreadPoolExecutor.java:200), +                    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142), +                    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617), +                    at java.lang.Thread.run(Thread.java:745), +                 */, +                if (INTERNAL_PREDICATE.test(action)) {, +, +, +++ /dev/null, +++ /dev/null, +++ b/elasticsearch/x-pack/shield/dev-tools/esvm/.esvmrc, +          "multicast.enabled": false,, +++ b/elasticsearch/x-pack/shield/src/main/java/org/elasticsearch/shield/InternalShieldUser.java, +            .cluster(ClusterPrivilege.get(new Privilege.Name(PutIndexTemplateAction.NAME, "cluster:admin/shield/realm/cache/clear*", "cluster:admin/shield/roles/cache/clear*"))), +++ b/elasticsearch/x-pack/shield/src/main/java/org/elasticsearch/shield/action/ShieldActionFilter.java, +                // FIXME yet another hack. Needed to work around something like, +                /*, +                FailedNodeException[total failure in fetching]; nested: ElasticsearchSecurityException[action [internal:gateway/local/started_shards] is unauthorized for user [test_user]];, +                    at org.elasticsearch.gateway.AsyncShardFetch$1.onFailure(AsyncShardFetch.java:284), +                    at org.elasticsearch.action.support.TransportAction$1.onFailure(TransportAction.java:84), +                    at org.elasticsearch.shield.action.ShieldActionFilter.apply(ShieldActionFilter.java:121)]