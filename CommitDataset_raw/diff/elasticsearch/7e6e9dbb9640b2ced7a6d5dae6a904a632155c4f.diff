[+++ b/src/main/java/org/elasticsearch/search/aggregations/bucket/nested/NestedAggregator.java, +            // We need to reset the current root doc, otherwise we may emit incorrect child docs if the next segment happen to start with the same root doc id value, +            currentRootDoc = -1;, +            childDocIdBuffers.clear();, +++ b/src/main/java/org/elasticsearch/search/aggregations/bucket/nested/NestedAggregator.java, +            // We need to reset the current root doc, otherwise we may emit incorrect child docs if the next segment happen to start with the same root doc id value, +            currentRootDoc = -1;, +            childDocIdBuffers.clear();, +++ b/src/test/java/org/elasticsearch/search/aggregations/bucket/nested/NestedAggregatorTest.java, +/*, + * Licensed to Elasticsearch under one or more contributor, + * license agreements. See the NOTICE file distributed with, + * this work for additional information regarding copyright, + * ownership. Elasticsearch licenses this file to you under, + * the Apache License, Version 2.0 (the "License"); you may, + * not use this file except in compliance with the License., + * You may obtain a copy of the License at, + *, + *    http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing,, + * software distributed under the License is distributed on an, + * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY, + * KIND, either express or implied.  See the License for the, + * specific language governing permissions and limitations, + * under the License., + */, +, +package org.elasticsearch.search.aggregations.bucket.nested;, +, +import org.apache.lucene.document.Document;, +import org.apache.lucene.document.Field;, +import org.apache.lucene.index.*;, +import org.apache.lucene.queries.TermFilter;, +import org.apache.lucene.search.ConstantScoreQuery;, +import org.apache.lucene.search.FilterCachingPolicy;, +import org.apache.lucene.search.IndexSearcher;, +import org.apache.lucene.store.Directory;, +import org.elasticsearch.action.admin.indices.mapping.put.PutMappingRequest;, +import org.elasticsearch.common.compress.CompressedString;, +import org.elasticsearch.common.lucene.search.AndFilter;, +import org.elasticsearch.common.lucene.search.NotFilter;, +import org.elasticsearch.index.IndexService;, +import org.elasticsearch.index.mapper.internal.TypeFieldMapper;, +import org.elasticsearch.index.mapper.internal.UidFieldMapper;, +import org.elasticsearch.index.search.nested.NonNestedDocsFilter;, +import org.elasticsearch.search.aggregations.AggregationPhase;, +import org.elasticsearch.search.aggregations.Aggregator;, +import org.elasticsearch.search.aggregations.AggregatorFactories;, +import org.elasticsearch.search.aggregations.support.AggregationContext;, +import org.elasticsearch.test.ElasticsearchSingleNodeLuceneTestCase;, +import org.junit.Test;, +, +import java.util.ArrayList;, +import java.util.Arrays;, +import java.util.List;, +, +import static org.hamcrest.Matchers.equalTo;, +, +/**, + */, +public class NestedAggregatorTest extends ElasticsearchSingleNodeLuceneTestCase {, +, +    @Test, +    public void testResetRootDocId() throws Exception {, +        Directory directory = newDirectory();, +        IndexWriterConfig iwc = new IndexWriterConfig(null);, +        iwc.setMergePolicy(NoMergePolicy.INSTANCE);, +        RandomIndexWriter indexWriter = new RandomIndexWriter(random(), directory, iwc);, +, +        List<Document> documents = new ArrayList<>();, +, +        // 1 segment with, 1 root document, with 3 nested sub docs, +        Document document = new Document();, +        document.add(new Field(UidFieldMapper.NAME, "type#1", UidFieldMapper.Defaults.NESTED_FIELD_TYPE));, +        document.add(new Field(TypeFieldMapper.NAME, "__nested_field", TypeFieldMapper.Defaults.FIELD_TYPE));, +        documents.add(document);, +        document = new Document();, +        document.add(new Field(UidFieldMapper.NAME, "type#1", UidFieldMapper.Defaults.NESTED_FIELD_TYPE));, +        document.add(new Field(TypeFieldMapper.NAME, "__nested_field", TypeFieldMapper.Defaults.FIELD_TYPE));, +        documents.add(document);, +        document = new Document();, +        document.add(new Field(UidFieldMapper.NAME, "type#1", UidFieldMapper.Defaults.NESTED_FIELD_TYPE));, +        document.add(new Field(TypeFieldMapper.NAME, "__nested_field", TypeFieldMapper.Defaults.FIELD_TYPE));, +        documents.add(document);, +        document = new Document();, +        document.add(new Field(UidFieldMapper.NAME, "type#1", UidFieldMapper.Defaults.FIELD_TYPE));, +        document.add(new Field(TypeFieldMapper.NAME, "test", TypeFieldMapper.Defaults.FIELD_TYPE));, +        documents.add(document);, +        indexWriter.addDocuments(documents);, +        indexWriter.commit();, +, +        documents.clear();, +        // 1 segment with:, +        // 1 document, with 1 nested subdoc, +        document = new Document();, +        document.add(new Field(UidFieldMapper.NAME, "type#2", UidFieldMapper.Defaults.NESTED_FIELD_TYPE));, +        document.add(new Field(TypeFieldMapper.NAME, "__nested_field", TypeFieldMapper.Defaults.FIELD_TYPE));, +        documents.add(document);, +        document = new Document();]