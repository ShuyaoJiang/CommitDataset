[+++ b/src/main/java/org/elasticsearch/index/mapper/FieldMapper.java, +, +        @Override, +        public boolean equals(Object o) {, +            if (o == null || getClass() != o.getClass()) return false;, +, +            Names names = (Names) o;, +, +            if (!fullName.equals(names.fullName)) return false;, +            if (!indexName.equals(names.indexName)) return false;, +            if (!indexNameClean.equals(names.indexNameClean)) return false;, +            if (!name.equals(names.name)) return false;, +            if (!sourcePath.equals(names.sourcePath)) return false;, +, +            return true;, +        }, +, +        @Override, +        public int hashCode() {, +            int result = name.hashCode();, +            result = 31 * result + indexName.hashCode();, +            result = 31 * result + indexNameClean.hashCode();, +            result = 31 * result + fullName.hashCode();, +            result = 31 * result + sourcePath.hashCode();, +            return result;, +        }, +++ b/src/main/java/org/elasticsearch/index/mapper/FieldMapper.java, +, +        @Override, +        public boolean equals(Object o) {, +            if (o == null || getClass() != o.getClass()) return false;, +, +            Names names = (Names) o;, +, +            if (!fullName.equals(names.fullName)) return false;, +            if (!indexName.equals(names.indexName)) return false;, +            if (!indexNameClean.equals(names.indexNameClean)) return false;, +            if (!name.equals(names.name)) return false;, +            if (!sourcePath.equals(names.sourcePath)) return false;, +, +            return true;, +        }, +, +        @Override, +        public int hashCode() {, +            int result = name.hashCode();, +            result = 31 * result + indexName.hashCode();, +            result = 31 * result + indexNameClean.hashCode();, +            result = 31 * result + fullName.hashCode();, +            result = 31 * result + sourcePath.hashCode();, +            return result;, +        }, +++ b/src/main/java/org/elasticsearch/index/mapper/core/AbstractFieldMapper.java, +        if (!this.names().equals(fieldMergeWith.names())) {, +            mergeContext.addConflict("mapper [" + names.fullName() + "] has different index_name");, +        }, +++ b/src/main/java/org/elasticsearch/index/mapper/FieldMapper.java, +, +        @Override, +        public boolean equals(Object o) {, +            if (o == null || getClass() != o.getClass()) return false;, +, +            Names names = (Names) o;, +, +            if (!fullName.equals(names.fullName)) return false;, +            if (!indexName.equals(names.indexName)) return false;, +            if (!indexNameClean.equals(names.indexNameClean)) return false;, +            if (!name.equals(names.name)) return false;, +            if (!sourcePath.equals(names.sourcePath)) return false;, +, +            return true;, +        }, +, +        @Override, +        public int hashCode() {, +            int result = name.hashCode();, +            result = 31 * result + indexName.hashCode();, +            result = 31 * result + indexNameClean.hashCode();, +            result = 31 * result + fullName.hashCode();, +            result = 31 * result + sourcePath.hashCode();, +            return result;, +        }, +++ b/src/main/java/org/elasticsearch/index/mapper/core/AbstractFieldMapper.java, +        if (!this.names().equals(fieldMergeWith.names())) {, +            mergeContext.addConflict("mapper [" + names.fullName() + "] has different index_name");, +        }, +++ b/src/main/java/org/elasticsearch/index/mapper/core/BinaryFieldMapper.java, +        if (!(mergeWith instanceof BinaryFieldMapper)) {, +            String mergedType = mergeWith.getClass().getSimpleName();, +            if (mergeWith instanceof AbstractFieldMapper) {, +                mergedType = ((AbstractFieldMapper) mergeWith).contentType();, +            }, +            mergeContext.addConflict("mapper [" + names.fullName() + "] of different type, current_type [" + contentType() + "], merged_type [" + mergedType + "]");, +            // different types, return, +            return;, +        }, +, +, +        if (this.fieldType().stored() != sourceMergeWith.fieldType().stored()) {, +            mergeContext.addConflict("mapper [" + names.fullName() + "] has different store values");]