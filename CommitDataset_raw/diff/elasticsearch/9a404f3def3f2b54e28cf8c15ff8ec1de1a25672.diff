[+++ b/qa/ccs-unavailable-clusters/src/test/java/org/elasticsearch/search/CrossClusterSearchUnavailableClusterIT.java, +                        containsString("missing required setting [cluster.remote.remote1.seeds] " +, +                assertThat(responseException.getMessage(), containsString("missing required setting [cluster.remote.remote1.seeds] " +, +++ b/qa/ccs-unavailable-clusters/src/test/java/org/elasticsearch/search/CrossClusterSearchUnavailableClusterIT.java, +                        containsString("missing required setting [cluster.remote.remote1.seeds] " +, +                assertThat(responseException.getMessage(), containsString("missing required setting [cluster.remote.remote1.seeds] " +, +++ b/server/src/main/java/org/elasticsearch/common/settings/AbstractScopedSettings.java, +import java.util.Locale;, +            Set<Setting<?>> settingsDependencies = setting.getSettingsDependencies(key);, +                for (final Setting<?> settingDependency : settingsDependencies) {, +                    if (settingDependency.existsOrFallbackExists(settings) == false) {, +                        final String message = String.format(, +                                Locale.ROOT,, +                                "missing required setting [%s] for setting [%s]",, +                                settingDependency.getKey(),, +                                setting.getKey());, +                        throw new IllegalArgumentException(message);, +++ b/qa/ccs-unavailable-clusters/src/test/java/org/elasticsearch/search/CrossClusterSearchUnavailableClusterIT.java, +                        containsString("missing required setting [cluster.remote.remote1.seeds] " +, +                assertThat(responseException.getMessage(), containsString("missing required setting [cluster.remote.remote1.seeds] " +, +++ b/server/src/main/java/org/elasticsearch/common/settings/AbstractScopedSettings.java, +import java.util.Locale;, +            Set<Setting<?>> settingsDependencies = setting.getSettingsDependencies(key);, +                for (final Setting<?> settingDependency : settingsDependencies) {, +                    if (settingDependency.existsOrFallbackExists(settings) == false) {, +                        final String message = String.format(, +                                Locale.ROOT,, +                                "missing required setting [%s] for setting [%s]",, +                                settingDependency.getKey(),, +                                setting.getKey());, +                        throw new IllegalArgumentException(message);, +++ b/server/src/main/java/org/elasticsearch/common/settings/Setting.java, +     * Returns true if and only if this setting is present in the given settings instance. Note that fallback settings are excluded., +     *, +     * @param settings the settings, +     * @return true if the setting is present in the given settings instance, otherwise false, +    public boolean exists(final Settings settings) {, +     * Returns true if and only if this setting including fallback settings is present in the given settings instance., +     *, +     * @param settings the settings, +     * @return true if the setting including fallback settings is present in the given settings instance, otherwise false, +     */, +    public boolean existsOrFallbackExists(final Settings settings) {, +        return settings.keySet().contains(getKey()) || (fallbackSetting != null && fallbackSetting.existsOrFallbackExists(settings));, +    }, +, +    /**, +    public Set<Setting<?>> getSettingsDependencies(String key) {, +        public Set<Setting<?>> getSettingsDependencies(String settingsKey) {, +                return dependencies.stream().map(s -> (Setting<?>)s.getConcreteSettingForNamespace(namespace)).collect(Collectors.toSet());, +    public static <T> Setting<List<T>> listSetting(, +            final String key,, +            final List<String> defaultStringValue,, +            final Function<String, T> singleValueParser,, +            final Property... properties) {, +        return listSetting(key, null, singleValueParser, (s) -> defaultStringValue, properties);, +    public static <T> Setting<List<T>> listSetting(, +            final String key,, +            final Setting<List<T>> fallbackSetting,, +            final Function<String, T> singleValueParser,, +            final Property... properties) {, +        return listSetting(key, fallbackSetting, singleValueParser, (s) -> parseableStringToList(fallbackSetting.getRaw(s)), properties);, +    public static <T> Setting<List<T>> listSetting(, +            final String key,, +            final Function<String, T> singleValueParser,, +            final Function<Settings, List<String>> defaultStringValue,, +            final Property... properties) {, +        return listSetting(key, null, singleValueParser, defaultStringValue, properties);, +    }, +, +    public static <T> Setting<List<T>> listSetting(, +            final String key,, +            final @Nullable Setting<List<T>> fallbackSetting,, +            final Function<String, T> singleValueParser,, +            final Function<Settings, List<String>> defaultStringValue,, +            final Property... properties) {, +        return new ListSetting<>(key, fallbackSetting, defaultStringValue, parser, properties);, +    private static class ListSetting<T> extends Setting<List<T>> {, +, +        private final Function<Settings, List<String>> defaultStringValue;, +, +        private ListSetting(, +                final String key,, +                final @Nullable Setting<List<T>> fallbackSetting,, +                final Function<Settings, List<String>> defaultStringValue,, +                final Function<String, List<T>> parser,, +                final Property... properties) {, +            super(, +                    new ListKey(key),, +                    fallbackSetting,, +                    (s) -> Setting.arrayToParsableString(defaultStringValue.apply(s)),, +                    parser,, +                    (v,s) -> {},, +                    properties);, +            this.defaultStringValue = defaultStringValue;, +        }, +, +        @Override, +        String innerGetRaw(final Settings settings) {, +            List<String> array = settings.getAsList(getKey(), null);]