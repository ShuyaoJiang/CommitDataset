[+++ b/core/src/main/java/org/elasticsearch/discovery/zen/UnicastZenPing.java, +import java.util.HashSet;, +        final Set<TransportAddress> localAddresses = new HashSet<>();, +        localAddresses.add(transportService.boundAddress().publishAddress());, +        localAddresses.addAll(Arrays.asList(transportService.boundAddress().boundAddresses()));, +                        final TransportAddress address = addresses[addressId];, +                        // no point in pinging ourselves, +                        if (localAddresses.contains(address) == false) {, +                                    address,, +                    }, +++ b/core/src/main/java/org/elasticsearch/discovery/zen/UnicastZenPing.java, +import java.util.HashSet;, +        final Set<TransportAddress> localAddresses = new HashSet<>();, +        localAddresses.add(transportService.boundAddress().publishAddress());, +        localAddresses.addAll(Arrays.asList(transportService.boundAddress().boundAddresses()));, +                        final TransportAddress address = addresses[addressId];, +                        // no point in pinging ourselves, +                        if (localAddresses.contains(address) == false) {, +                                    address,, +                    }, +++ b/core/src/test/java/org/elasticsearch/discovery/zen/UnicastZenPingTests.java, +import org.elasticsearch.common.transport.BoundTransportAddress;, +import java.net.InetAddress;, +            Version.CURRENT) {, +, +            @Override, +            public BoundTransportAddress boundAddress() {, +                return new BoundTransportAddress(, +                    new TransportAddress[]{new TransportAddress(InetAddress.getLoopbackAddress(), 9500)},, +                    new TransportAddress(InetAddress.getLoopbackAddress(), 9500), +                );, +            }, +        };, +    public void testRemovingLocalAddresses() throws InterruptedException {, +        final NetworkService networkService = new NetworkService(Settings.EMPTY, Collections.emptyList());, +        final InetAddress loopbackAddress = InetAddress.getLoopbackAddress();, +        final Transport transport = new MockTcpTransport(, +            Settings.EMPTY,, +            threadPool,, +            BigArrays.NON_RECYCLING_INSTANCE,, +            new NoneCircuitBreakerService(),, +            new NamedWriteableRegistry(Collections.emptyList()),, +            networkService,, +            Version.CURRENT) {, +, +            @Override, +            public BoundTransportAddress boundAddress() {, +                return new BoundTransportAddress(, +                    new TransportAddress[]{, +                        new TransportAddress(loopbackAddress, 9300),, +                        new TransportAddress(loopbackAddress, 9301), +                    },, +                    new TransportAddress(loopbackAddress, 9302), +                );, +            }, +        };, +        closeables.push(transport);, +        final TransportService transportService =, +            new TransportService(Settings.EMPTY, transport, threadPool, TransportService.NOOP_TRANSPORT_INTERCEPTOR, x -> null, null);, +        closeables.push(transportService);, +        final List<DiscoveryNode> discoveryNodes = TestUnicastZenPing.resolveHostsLists(, +            executorService,, +            logger,, +            Collections.singletonList(NetworkAddress.format(loopbackAddress)),, +            10,, +            transportService,, +            "test_",, +            TimeValue.timeValueSeconds(1));, +        assertThat(discoveryNodes, hasSize(7));, +        final Set<Integer> ports = new HashSet<>();, +        for (final DiscoveryNode discoveryNode : discoveryNodes) {, +            assertTrue(discoveryNode.getAddress().address().getAddress().isLoopbackAddress());, +            ports.add(discoveryNode.getAddress().getPort());, +        }, +        assertThat(ports, equalTo(IntStream.range(9303, 9310).mapToObj(m -> m).collect(Collectors.toSet())));, +    }, +, +            public BoundTransportAddress boundAddress() {, +                return new BoundTransportAddress(, +                    new TransportAddress[]{new TransportAddress(InetAddress.getLoopbackAddress(), 9300)},, +                    new TransportAddress(InetAddress.getLoopbackAddress(), 9300), +                );, +            }, +, +            @Override, +            public BoundTransportAddress boundAddress() {, +                return new BoundTransportAddress(, +                    new TransportAddress[]{new TransportAddress(InetAddress.getLoopbackAddress(), 9500)},, +                    new TransportAddress(InetAddress.getLoopbackAddress(), 9500), +                );, +            }, +, +            @Override, +            Version.CURRENT) {, +            @Override, +            public BoundTransportAddress boundAddress() {, +                return new BoundTransportAddress(, +                    new TransportAddress[]{new TransportAddress(InetAddress.getLoopbackAddress(), 9300)},, +                    new TransportAddress(InetAddress.getLoopbackAddress(), 9300), +                );]