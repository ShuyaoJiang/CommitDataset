[+++ b/test/framework/src/main/java/org/elasticsearch/index/replication/ESIndexLevelReplicationTestCase.java, +            recoverPrimary(primary);, +        protected synchronized void recoverPrimary(IndexShard primary) {, +            final DiscoveryNode pNode = getDiscoveryNode(primary.routingEntry().currentNodeId());, +            primary.markAsRecovering("store", new RecoveryState(primary.routingEntry(), pNode, null));, +            primary.recoverFromStore();, +        }, +++ b/test/framework/src/main/java/org/elasticsearch/index/replication/ESIndexLevelReplicationTestCase.java, +            recoverPrimary(primary);, +        protected synchronized void recoverPrimary(IndexShard primary) {, +            final DiscoveryNode pNode = getDiscoveryNode(primary.routingEntry().currentNodeId());, +            primary.markAsRecovering("store", new RecoveryState(primary.routingEntry(), pNode, null));, +            primary.recoverFromStore();, +        }, +++ b/x-pack/plugin/ccr/src/test/java/org/elasticsearch/xpack/ccr/action/ShardFollowTaskReplicationTests.java, +import org.apache.lucene.store.IOContext;, +import org.elasticsearch.cluster.node.DiscoveryNode;, +import org.elasticsearch.cluster.routing.RecoverySource;, +import org.elasticsearch.cluster.routing.ShardRoutingHelper;, +import org.elasticsearch.common.UUIDs;, +import org.elasticsearch.common.lucene.Lucene;, +import org.elasticsearch.index.shard.RestoreOnlyRepository;, +import org.elasticsearch.index.store.Store;, +import org.elasticsearch.index.store.StoreFileMetaData;, +import org.elasticsearch.indices.recovery.RecoveryState;, +import org.elasticsearch.repositories.IndexId;, +import org.elasticsearch.snapshots.Snapshot;, +import org.elasticsearch.snapshots.SnapshotId;, +import static java.util.Collections.emptyMap;, +import static java.util.Collections.emptySet;, +        try (ReplicationGroup leaderGroup = createLeaderGroup(randomInt(2))) {, +            try (ReplicationGroup followerGroup = createFollowGroup(leaderGroup, randomInt(2))) {, +    }, +        try (ReplicationGroup leaderGroup = createLeaderGroup(1 + randomInt(1))) {, +            try (ReplicationGroup followerGroup = createFollowGroup(leaderGroup, randomInt(2))) {, +    }, +        try (ReplicationGroup leaderGroup = createLeaderGroup(0)) {, +            try (ReplicationGroup followerGroup = createFollowGroup(leaderGroup, 0)) {, +    }, +        try (ReplicationGroup leaderGroup = createLeaderGroup(0)) {, +            try(ReplicationGroup followerGroup = createFollowGroup(leaderGroup, 0)) {, +    }, +        try (ReplicationGroup leaderGroup = createLeaderGroup(between(0, 1))) {, +            try(ReplicationGroup followerGroup = createFollowGroup(leaderGroup, between(1, 3))) {, +                shardFollowTask.start(followerGroup.getPrimary().getHistoryUUID(),, +                    leadingPrimary.getGlobalCheckpoint(),, +                    leadingPrimary.getMaxSeqNoOfUpdatesOrDeletes(),, +                    followerSeqNoStats.getGlobalCheckpoint(),, +                    followerSeqNoStats.getMaxSeqNo());, +    }, +        Settings settings = Settings.builder().put(CcrSettings.CCR_FOLLOWING_INDEX_SETTING.getKey(), true), +            .put(IndexSettings.INDEX_SOFT_DELETES_SETTING.getKey(), true), +            .put(IndexSettings.INDEX_TRANSLOG_FLUSH_THRESHOLD_SIZE_SETTING.getKey(), new ByteSizeValue(between(1, 1000), ByteSizeUnit.KB)), +            .build();, +        IndexMetaData indexMetaData = buildIndexMetaData(between(0, 1), settings, indexMapping);, +        try (ReplicationGroup group = new ReplicationGroup(indexMetaData) {, +            @Override, +            protected EngineFactory getEngineFactory(ShardRouting routing) {, +                return new FollowingEngineFactory();, +            }, +        }) {, +    public void testSimpleRemoteRecovery() throws Exception {, +        try (ReplicationGroup leader = createLeaderGroup(between(0, 1))) {, +            leader.startAll();, +            leader.appendDocs(between(0, 100));, +            leader.flush();, +            leader.syncGlobalCheckpoint();, +            try (ReplicationGroup follower = createFollowGroup(leader, 0)) {, +                follower.startAll();, +                ShardFollowNodeTask followTask = createShardFollowTask(leader, follower);, +                followTask.start(, +                    follower.getPrimary().getHistoryUUID(),, +                    leader.getPrimary().getGlobalCheckpoint(),, +                    leader.getPrimary().seqNoStats().getMaxSeqNo(),, +                    follower.getPrimary().getGlobalCheckpoint(),, +                    follower.getPrimary().seqNoStats().getMaxSeqNo(), +                );, +                leader.appendDocs(between(0, 100));, +                if (randomBoolean()) {, +                    follower.recoverReplica(follower.addReplica());, +                }, +                assertBusy(() -> assertConsistentHistoryBetweenLeaderAndFollower(leader, follower, false));, +                followTask.markAsCompleted();, +            }, +        }, +    }, +, +    private ReplicationGroup createLeaderGroup(int replicas) throws IOException {, +        Settings settings = Settings.builder(), +        return createGroup(replicas, settings);, +    }, +    private ReplicationGroup createFollowGroup(ReplicationGroup leaderGroup, int replicas) throws IOException {, +        Settings settings = Settings.builder().put(CcrSettings.CCR_FOLLOWING_INDEX_SETTING.getKey(), true), +            .put(IndexSettings.INDEX_SOFT_DELETES_SETTING.getKey(), true), +            .put(IndexSettings.INDEX_TRANSLOG_FLUSH_THRESHOLD_SIZE_SETTING.getKey(), new ByteSizeValue(between(1, 1000), ByteSizeUnit.KB)), +            .build();, +        IndexMetaData indexMetaData = buildIndexMetaData(replicas, settings, indexMapping);, +        return new ReplicationGroup(indexMetaData) {, +            @Override, +            protected synchronized void recoverPrimary(IndexShard primary) {]