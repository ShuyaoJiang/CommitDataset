[+++ b/core/src/main/java/org/elasticsearch/cluster/metadata/MetaDataUpdateSettingsService.java, +                    // we do *not* update the in sync allocation ids as they will be removed upon the first index, +                    // operation which make these copies stale, +                    // TODO: update the list once the data is deleted by the node?, +++ b/core/src/main/java/org/elasticsearch/cluster/metadata/MetaDataUpdateSettingsService.java, +                    // we do *not* update the in sync allocation ids as they will be removed upon the first index, +                    // operation which make these copies stale, +                    // TODO: update the list once the data is deleted by the node?, +++ b/core/src/main/java/org/elasticsearch/cluster/routing/RoutingNode.java, +            throw new IllegalStateException("Trying to add a shard " + shard.shardId() + " to a node [" + nodeId, +                + "] where it already exists. current [" + shards.get(shard.shardId()) + "]. new [" + shard + "]");, +++ b/core/src/main/java/org/elasticsearch/cluster/metadata/MetaDataUpdateSettingsService.java, +                    // we do *not* update the in sync allocation ids as they will be removed upon the first index, +                    // operation which make these copies stale, +                    // TODO: update the list once the data is deleted by the node?, +++ b/core/src/main/java/org/elasticsearch/cluster/routing/RoutingNode.java, +            throw new IllegalStateException("Trying to add a shard " + shard.shardId() + " to a node [" + nodeId, +                + "] where it already exists. current [" + shards.get(shard.shardId()) + "]. new [" + shard + "]");, +++ b/core/src/main/java/org/elasticsearch/cluster/routing/allocation/allocator/BalancedShardsAllocator.java, +                        logger.debug("Relocate shard [{}] from node [{}] to node [{}]", candidate, maxNode.getNodeId(),, +++ b/core/src/main/java/org/elasticsearch/cluster/metadata/MetaDataUpdateSettingsService.java, +                    // we do *not* update the in sync allocation ids as they will be removed upon the first index, +                    // operation which make these copies stale, +                    // TODO: update the list once the data is deleted by the node?, +++ b/core/src/main/java/org/elasticsearch/cluster/routing/RoutingNode.java, +            throw new IllegalStateException("Trying to add a shard " + shard.shardId() + " to a node [" + nodeId, +                + "] where it already exists. current [" + shards.get(shard.shardId()) + "]. new [" + shard + "]");, +++ b/core/src/main/java/org/elasticsearch/cluster/routing/allocation/allocator/BalancedShardsAllocator.java, +                        logger.debug("Relocate shard [{}] from node [{}] to node [{}]", candidate, maxNode.getNodeId(),, +++ b/core/src/main/java/org/elasticsearch/index/shard/IndexShard.java, +                // Note that due to cluster state batching an initializing primary shard term can failed and re-assigned, +                // in one state causing it's term to be incremented. Note that if both current shard state and new, +                // shard state are initializing, we could replace the current shard and reinitialize it. It is however, +                // possible that this shard is being started. This can happen if:, +                // 1) Shard is post recovery and sends shard started to the master, +                // 2) Node gets disconnected and rejoins, +                // 3) Master assigns the shard back to the node, +                // 4) Master processes the shard started and starts the shard, +                // 5) The node process the cluster state where the shard is both started and primary term is incremented., +                //, +                // We could fail the shard in that case, but this will cause it to be removed from the insync allocations list, +                // potentially preventing re-allocation., +                assert shardRouting.primary() == false || shardRouting.initializing() == false :, +                    "a started primary shard should never update it's term. shard: " + shardRouting, +++ b/core/src/main/java/org/elasticsearch/cluster/metadata/MetaDataUpdateSettingsService.java, +                    // we do *not* update the in sync allocation ids as they will be removed upon the first index, +                    // operation which make these copies stale, +                    // TODO: update the list once the data is deleted by the node?, +++ b/core/src/main/java/org/elasticsearch/cluster/routing/RoutingNode.java, +            throw new IllegalStateException("Trying to add a shard " + shard.shardId() + " to a node [" + nodeId, +                + "] where it already exists. current [" + shards.get(shard.shardId()) + "]. new [" + shard + "]");, +++ b/core/src/main/java/org/elasticsearch/cluster/routing/allocation/allocator/BalancedShardsAllocator.java, +                        logger.debug("Relocate shard [{}] from node [{}] to node [{}]", candidate, maxNode.getNodeId(),, +++ b/core/src/main/java/org/elasticsearch/index/shard/IndexShard.java, +                // Note that due to cluster state batching an initializing primary shard term can failed and re-assigned, +                // in one state causing it's term to be incremented. Note that if both current shard state and new, +                // shard state are initializing, we could replace the current shard and reinitialize it. It is however, +                // possible that this shard is being started. This can happen if:, +                // 1) Shard is post recovery and sends shard started to the master, +                // 2) Node gets disconnected and rejoins, +                // 3) Master assigns the shard back to the node, +                // 4) Master processes the shard started and starts the shard, +                // 5) The node process the cluster state where the shard is both started and primary term is incremented., +                //, +                // We could fail the shard in that case, but this will cause it to be removed from the insync allocations list, +                // potentially preventing re-allocation., +                assert shardRouting.primary() == false || shardRouting.initializing() == false :, +                    "a started primary shard should never update it's term. shard: " + shardRouting, +++ b/core/src/main/java/org/elasticsearch/indices/cluster/IndicesClusterStateService.java, +        removeShards(state);   // removes any local shards that doesn't match what the master expects, +                if (newShardRouting == null) {, +                } else if (newShardRouting.isSameAllocation(currentRoutingEntry) == false) {, +                    logger.debug("{} removing shard (stale allocation id, stale {}, new {})", shardId,, +                        currentRoutingEntry, newShardRouting);, +                    indexService.removeShard(shardId.id(), "removing shard (stale copy)");, +                } else if (newShardRouting.initializing() && currentRoutingEntry.active()) {, +                    // this can happen if the node was isolated/gc-ed, rejoins the cluster and a new shard with the same allocation id, +                    // is assigned to it. Batch cluster state processing or if shard fetching completes before the node gets a new cluster, +                    // state may result in a new shard being initialized while having the same allocation id as the currently started shard., +                    logger.debug("{} removing shard (not active, current {}, new {})", shardId, currentRoutingEntry, newShardRouting);, +                    indexService.removeShard(shardId.id(), "removing shard (stale copy)");, +++ b/core/src/main/java/org/elasticsearch/cluster/metadata/MetaDataUpdateSettingsService.java, +                    // we do *not* update the in sync allocation ids as they will be removed upon the first index, +                    // operation which make these copies stale, +                    // TODO: update the list once the data is deleted by the node?, +++ b/core/src/main/java/org/elasticsearch/cluster/routing/RoutingNode.java, +            throw new IllegalStateException("Trying to add a shard " + shard.shardId() + " to a node [" + nodeId, +                + "] where it already exists. current [" + shards.get(shard.shardId()) + "]. new [" + shard + "]");, +++ b/core/src/main/java/org/elasticsearch/cluster/routing/allocation/allocator/BalancedShardsAllocator.java, +                        logger.debug("Relocate shard [{}] from node [{}] to node [{}]", candidate, maxNode.getNodeId(),, +++ b/core/src/main/java/org/elasticsearch/index/shard/IndexShard.java, +                // Note that due to cluster state batching an initializing primary shard term can failed and re-assigned, +                // in one state causing it's term to be incremented. Note that if both current shard state and new, +                // shard state are initializing, we could replace the current shard and reinitialize it. It is however, +                // possible that this shard is being started. This can happen if:, +                // 1) Shard is post recovery and sends shard started to the master, +                // 2) Node gets disconnected and rejoins, +                // 3) Master assigns the shard back to the node, +                // 4) Master processes the shard started and starts the shard, +                // 5) The node process the cluster state where the shard is both started and primary term is incremented.]