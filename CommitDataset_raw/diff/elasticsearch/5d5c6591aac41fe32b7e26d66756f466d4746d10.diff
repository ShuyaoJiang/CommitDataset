[+++ b/core/src/main/java/org/elasticsearch/action/support/replication/TransportReplicationAction.java, +                logger.trace("Retrying operation on replica, action [{}], request [{}]", t, actionName, request);, +                        threadPool.executor(executor).execute(AsyncReplicaAction.this);, +++ b/core/src/main/java/org/elasticsearch/action/support/replication/TransportReplicationAction.java, +                logger.trace("Retrying operation on replica, action [{}], request [{}]", t, actionName, request);, +                        threadPool.executor(executor).execute(AsyncReplicaAction.this);, +++ b/core/src/main/java/org/elasticsearch/cluster/metadata/MetaDataMappingService.java, +import org.elasticsearch.index.mapper.MergeResult;, +                        MergeResult mergeResult = existingMapper.merge(newMapper.mapping(), true, request.updateAllTypes());, +                        // if we have conflicts, throw an exception, +                        if (mergeResult.hasConflicts()) {, +                            throw new IllegalArgumentException("Merge failed with failures {" + Arrays.toString(mergeResult.buildConflicts()) + "}");, +                        }, +++ b/core/src/main/java/org/elasticsearch/action/support/replication/TransportReplicationAction.java, +                logger.trace("Retrying operation on replica, action [{}], request [{}]", t, actionName, request);, +                        threadPool.executor(executor).execute(AsyncReplicaAction.this);, +++ b/core/src/main/java/org/elasticsearch/cluster/metadata/MetaDataMappingService.java, +import org.elasticsearch.index.mapper.MergeResult;, +                        MergeResult mergeResult = existingMapper.merge(newMapper.mapping(), true, request.updateAllTypes());, +                        // if we have conflicts, throw an exception, +                        if (mergeResult.hasConflicts()) {, +                            throw new IllegalArgumentException("Merge failed with failures {" + Arrays.toString(mergeResult.buildConflicts()) + "}");, +                        }, +++ b/core/src/main/java/org/elasticsearch/index/mapper/DocumentMapper.java, +    private final Mapping mapping;, +    public MergeResult merge(Mapping mapping, boolean simulate, boolean updateAllTypes) {, +            final MergeResult mergeResult = new MergeResult(simulate, updateAllTypes);, +            this.mapping.merge(mapping, mergeResult);, +                addMappers(mergeResult.getNewObjectMappers(), mergeResult.getNewFieldMappers(), updateAllTypes);, +            return mergeResult;, +++ b/core/src/main/java/org/elasticsearch/action/support/replication/TransportReplicationAction.java, +                logger.trace("Retrying operation on replica, action [{}], request [{}]", t, actionName, request);, +                        threadPool.executor(executor).execute(AsyncReplicaAction.this);, +++ b/core/src/main/java/org/elasticsearch/cluster/metadata/MetaDataMappingService.java, +import org.elasticsearch.index.mapper.MergeResult;, +                        MergeResult mergeResult = existingMapper.merge(newMapper.mapping(), true, request.updateAllTypes());, +                        // if we have conflicts, throw an exception, +                        if (mergeResult.hasConflicts()) {, +                            throw new IllegalArgumentException("Merge failed with failures {" + Arrays.toString(mergeResult.buildConflicts()) + "}");, +                        }, +++ b/core/src/main/java/org/elasticsearch/index/mapper/DocumentMapper.java, +    private final Mapping mapping;, +    public MergeResult merge(Mapping mapping, boolean simulate, boolean updateAllTypes) {, +            final MergeResult mergeResult = new MergeResult(simulate, updateAllTypes);, +            this.mapping.merge(mapping, mergeResult);, +                addMappers(mergeResult.getNewObjectMappers(), mergeResult.getNewFieldMappers(), updateAllTypes);, +            return mergeResult;, +++ b/core/src/main/java/org/elasticsearch/index/mapper/DocumentParser.java, +                    MapperUtils.merge(update, newUpdate);, +            MapperUtils.merge(mapper, update);, +++ b/core/src/main/java/org/elasticsearch/action/support/replication/TransportReplicationAction.java, +                logger.trace("Retrying operation on replica, action [{}], request [{}]", t, actionName, request);, +                        threadPool.executor(executor).execute(AsyncReplicaAction.this);, +++ b/core/src/main/java/org/elasticsearch/cluster/metadata/MetaDataMappingService.java, +import org.elasticsearch.index.mapper.MergeResult;, +                        MergeResult mergeResult = existingMapper.merge(newMapper.mapping(), true, request.updateAllTypes());, +                        // if we have conflicts, throw an exception, +                        if (mergeResult.hasConflicts()) {, +                            throw new IllegalArgumentException("Merge failed with failures {" + Arrays.toString(mergeResult.buildConflicts()) + "}");, +                        }, +++ b/core/src/main/java/org/elasticsearch/index/mapper/DocumentMapper.java, +    private final Mapping mapping;, +    public MergeResult merge(Mapping mapping, boolean simulate, boolean updateAllTypes) {, +            final MergeResult mergeResult = new MergeResult(simulate, updateAllTypes);, +            this.mapping.merge(mapping, mergeResult);, +                addMappers(mergeResult.getNewObjectMappers(), mergeResult.getNewFieldMappers(), updateAllTypes);, +            return mergeResult;, +++ b/core/src/main/java/org/elasticsearch/index/mapper/DocumentParser.java, +                    MapperUtils.merge(update, newUpdate);, +            MapperUtils.merge(mapper, update);, +++ b/core/src/main/java/org/elasticsearch/index/mapper/FieldMapper.java, +public abstract class FieldMapper extends Mapper {, +                    final IndexOptions options = getDefaultIndexOption();, +                    assert options != IndexOptions.NONE : "default IndexOptions is NONE can't enable indexing";, +    protected final MultiFields multiFields;, +    public void merge(Mapper mergeWith, MergeResult mergeResult) {, +            mergeResult.addConflict("mapper [" + fieldType().names().fullName() + "] of different type, current_type [" + contentType() + "], merged_type [" + mergedType + "]");, +            // different types, return, +            return;, +        multiFields.merge(mergeWith, mergeResult);, +        if (mergeResult.simulate() == false && mergeResult.hasConflicts() == false) {, +    }, +        private volatile ImmutableOpenMap<String, FieldMapper> mappers;, +        public MultiFields(ContentPath.Type pathType, ImmutableOpenMap<String, FieldMapper> mappers) {, +            this.mappers = mappers;, +            for (ObjectCursor<FieldMapper> cursor : mappers.values()) {, +                    ((AllFieldMapper.IncludeInAll) mapper).unsetIncludeInAll();, +        // No need for locking, because locking is taken care of in ObjectMapper#merge and DocumentMapper#merge, +        public void merge(Mapper mergeWith, MergeResult mergeResult) {, +            FieldMapper mergeWithMultiField = (FieldMapper) mergeWith;, +            List<FieldMapper> newFieldMappers = null;, +            ImmutableOpenMap.Builder<String, FieldMapper> newMappersBuilder = null;, +, +            for (ObjectCursor<FieldMapper> cursor : mergeWithMultiField.multiFields.mappers.values()) {, +                Mapper mergeIntoMapper = mappers.get(mergeWithMapper.simpleName());, +                    // no mapping, simply add it if not simulating, +                    if (!mergeResult.simulate()) {, +                            ((AllFieldMapper.IncludeInAll) mergeWithMapper).unsetIncludeInAll();, +                        }, +                        if (newMappersBuilder == null) {]