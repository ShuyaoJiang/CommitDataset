[+++ b/core/src/main/java/org/elasticsearch/action/support/AutoCreateIndex.java, +import org.elasticsearch.common.collect.Tuple;, +import java.util.ArrayList;, +import java.util.List;, +, +    private final boolean dynamicMappingDisabled;, +    private final IndexNameExpressionResolver resolver;, +    private final AutoCreate autoCreate;, +, +        this.autoCreate = AUTO_CREATE_INDEX_SETTING.get(settings);, +        return this.autoCreate.autoCreateIndex;, +        if (autoCreate.autoCreateIndex == false) {, +        if (dynamicMappingDisabled) {, +        if (resolver.hasIndexOrAlias(index, state)) {, +        if (autoCreate.expressions.isEmpty()) {, +        for (Tuple<String, Boolean> expression : autoCreate.expressions) {, +            String indexExpression = expression.v1();, +            boolean include = expression.v2();, +            if (Regex.simpleMatch(indexExpression, index)) {, +                return include;, +    private static class AutoCreate {, +        private final List<Tuple<String, Boolean>> expressions;, +        private AutoCreate(String value) {, +            List<Tuple<String, Boolean>> expressions = new ArrayList<>();, +                    String[] patterns = Strings.commaDelimitedListToStringArray(value);, +                    for (String pattern : patterns) {, +                        if (pattern == null || pattern.length() == 0) {, +                            throw new IllegalArgumentException("Can't parse [" + value + "] for setting [action.auto_create_index] must be either [true, false, or a comma separated list of index patterns]");, +                        Tuple<String, Boolean> expression;, +                        if (pattern.startsWith("-")) {, +                            if (pattern.length() == 1) {, +                                throw new IllegalArgumentException("Can't parse [" + value + "] for setting [action.auto_create_index] must contain an index name after [-]");, +                            }, +                            expression = new Tuple<>(pattern.substring(1), false);, +                        } else if(pattern.startsWith("+")) {, +                            if (pattern.length() == 1) {, +                                throw new IllegalArgumentException("Can't parse [" + value + "] for setting [action.auto_create_index] must contain an index name after [+]");, +                            }, +                            expression = new Tuple<>(pattern.substring(1), true);, +                        } else {, +                            expression = new Tuple<>(pattern, true);, +                        }, +                        expressions.add(expression);, +            this.expressions = expressions;, +++ b/core/src/main/java/org/elasticsearch/action/support/AutoCreateIndex.java, +import org.elasticsearch.common.collect.Tuple;, +import java.util.ArrayList;, +import java.util.List;, +, +    private final boolean dynamicMappingDisabled;, +    private final IndexNameExpressionResolver resolver;, +    private final AutoCreate autoCreate;, +, +        this.autoCreate = AUTO_CREATE_INDEX_SETTING.get(settings);, +        return this.autoCreate.autoCreateIndex;, +        if (autoCreate.autoCreateIndex == false) {, +        if (dynamicMappingDisabled) {, +        if (resolver.hasIndexOrAlias(index, state)) {, +        if (autoCreate.expressions.isEmpty()) {, +        for (Tuple<String, Boolean> expression : autoCreate.expressions) {, +            String indexExpression = expression.v1();, +            boolean include = expression.v2();, +            if (Regex.simpleMatch(indexExpression, index)) {, +                return include;, +    private static class AutoCreate {, +        private final List<Tuple<String, Boolean>> expressions;, +        private AutoCreate(String value) {, +            List<Tuple<String, Boolean>> expressions = new ArrayList<>();, +                    String[] patterns = Strings.commaDelimitedListToStringArray(value);, +                    for (String pattern : patterns) {, +                        if (pattern == null || pattern.length() == 0) {, +                            throw new IllegalArgumentException("Can't parse [" + value + "] for setting [action.auto_create_index] must be either [true, false, or a comma separated list of index patterns]");, +                        Tuple<String, Boolean> expression;, +                        if (pattern.startsWith("-")) {, +                            if (pattern.length() == 1) {, +                                throw new IllegalArgumentException("Can't parse [" + value + "] for setting [action.auto_create_index] must contain an index name after [-]");, +                            }, +                            expression = new Tuple<>(pattern.substring(1), false);, +                        } else if(pattern.startsWith("+")) {, +                            if (pattern.length() == 1) {, +                                throw new IllegalArgumentException("Can't parse [" + value + "] for setting [action.auto_create_index] must contain an index name after [+]");, +                            }, +                            expression = new Tuple<>(pattern.substring(1), true);, +                        } else {, +                            expression = new Tuple<>(pattern, true);, +                        }, +                        expressions.add(expression);, +            this.expressions = expressions;, +++ b/core/src/main/java/org/elasticsearch/action/support/ThreadedActionListener.java, +            this.threadedListener = DiscoveryNode.clientNode(settings) || TransportClient.CLIENT_TYPE.equals(settings.get(Client.CLIENT_TYPE_SETTING));, +++ b/core/src/main/java/org/elasticsearch/action/support/AutoCreateIndex.java, +import org.elasticsearch.common.collect.Tuple;, +import java.util.ArrayList;, +import java.util.List;, +, +    private final boolean dynamicMappingDisabled;, +    private final IndexNameExpressionResolver resolver;, +    private final AutoCreate autoCreate;, +, +        this.autoCreate = AUTO_CREATE_INDEX_SETTING.get(settings);]