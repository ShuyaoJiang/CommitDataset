[+++ b/core/src/main/java/org/elasticsearch/cluster/routing/IndexShardRoutingTable.java, +            for (ShardRouting shard : shards) {, +                // don't add two that map to the same node id, +                // we rely on the fact that a node does not have primary and backup of the same shard, +                if (shard.assignedToNode() && shardEntry.assignedToNode(), +                        && shard.currentNodeId().equals(shardEntry.currentNodeId())) {, +                    return this;, +                }, +            }, +++ b/core/src/main/java/org/elasticsearch/cluster/routing/IndexShardRoutingTable.java, +            for (ShardRouting shard : shards) {, +                // don't add two that map to the same node id, +                // we rely on the fact that a node does not have primary and backup of the same shard, +                if (shard.assignedToNode() && shardEntry.assignedToNode(), +                        && shard.currentNodeId().equals(shardEntry.currentNodeId())) {, +                    return this;, +                }, +            }, +++ b/core/src/test/java/org/elasticsearch/cluster/ClusterStateDiffIT.java, +                        TestShardRouting.newShardRouting(index, i, randomFrom(nodeIds), null, j == 0,, +                final ShardRouting updatedShardRouting = randomChange(shardRouting, nodes);, +++ b/core/src/main/java/org/elasticsearch/cluster/routing/IndexShardRoutingTable.java, +            for (ShardRouting shard : shards) {, +                // don't add two that map to the same node id, +                // we rely on the fact that a node does not have primary and backup of the same shard, +                if (shard.assignedToNode() && shardEntry.assignedToNode(), +                        && shard.currentNodeId().equals(shardEntry.currentNodeId())) {, +                    return this;, +                }, +            }, +++ b/core/src/test/java/org/elasticsearch/cluster/ClusterStateDiffIT.java, +                        TestShardRouting.newShardRouting(index, i, randomFrom(nodeIds), null, j == 0,, +                final ShardRouting updatedShardRouting = randomChange(shardRouting, nodes);, +++ b/core/src/test/java/org/elasticsearch/cluster/health/ClusterStateHealthTests.java, +        final List<String> nodeIds = new ArrayList<>();, +                        shardRouting.initialize(nodeIds.get(randomIntBetween(0, numNodes - 1)), null, shardRouting.getExpectedShardSize()), +                    final String primaryNodeId = shardRoutingTable.primaryShard().currentNodeId();, +                    String replicaNodeId;, +                    do {, +                        replicaNodeId = nodeIds.get(randomIntBetween(0, numNodes - 1));, +                    } while (primaryNodeId.equals(replicaNodeId));, +                    newIndexRoutingTable.addShard(, +                        shardRouting.initialize(replicaNodeId, null, shardRouting.getExpectedShardSize()), +                    );, +++ b/core/src/main/java/org/elasticsearch/cluster/routing/IndexShardRoutingTable.java, +            for (ShardRouting shard : shards) {, +                // don't add two that map to the same node id, +                // we rely on the fact that a node does not have primary and backup of the same shard, +                if (shard.assignedToNode() && shardEntry.assignedToNode(), +                        && shard.currentNodeId().equals(shardEntry.currentNodeId())) {, +                    return this;, +                }, +            }, +++ b/core/src/test/java/org/elasticsearch/cluster/ClusterStateDiffIT.java, +                        TestShardRouting.newShardRouting(index, i, randomFrom(nodeIds), null, j == 0,, +                final ShardRouting updatedShardRouting = randomChange(shardRouting, nodes);, +++ b/core/src/test/java/org/elasticsearch/cluster/health/ClusterStateHealthTests.java, +        final List<String> nodeIds = new ArrayList<>();, +                        shardRouting.initialize(nodeIds.get(randomIntBetween(0, numNodes - 1)), null, shardRouting.getExpectedShardSize()), +                    final String primaryNodeId = shardRoutingTable.primaryShard().currentNodeId();, +                    String replicaNodeId;, +                    do {, +                        replicaNodeId = nodeIds.get(randomIntBetween(0, numNodes - 1));, +                    } while (primaryNodeId.equals(replicaNodeId));, +                    newIndexRoutingTable.addShard(, +                        shardRouting.initialize(replicaNodeId, null, shardRouting.getExpectedShardSize()), +                    );, +++ b/core/src/test/java/org/elasticsearch/cluster/routing/RandomShardRoutingMutator.java, +    public static ShardRouting randomChange(ShardRouting shardRouting, String[] nodes) {, +                if (shardRouting.unassigned()) {, +++ b/core/src/main/java/org/elasticsearch/cluster/routing/IndexShardRoutingTable.java, +            for (ShardRouting shard : shards) {, +                // don't add two that map to the same node id, +                // we rely on the fact that a node does not have primary and backup of the same shard, +                if (shard.assignedToNode() && shardEntry.assignedToNode(), +                        && shard.currentNodeId().equals(shardEntry.currentNodeId())) {, +                    return this;, +                }, +            }, +++ b/core/src/test/java/org/elasticsearch/cluster/ClusterStateDiffIT.java, +                        TestShardRouting.newShardRouting(index, i, randomFrom(nodeIds), null, j == 0,, +                final ShardRouting updatedShardRouting = randomChange(shardRouting, nodes);, +++ b/core/src/test/java/org/elasticsearch/cluster/health/ClusterStateHealthTests.java, +        final List<String> nodeIds = new ArrayList<>();, +                        shardRouting.initialize(nodeIds.get(randomIntBetween(0, numNodes - 1)), null, shardRouting.getExpectedShardSize()), +                    final String primaryNodeId = shardRoutingTable.primaryShard().currentNodeId();, +                    String replicaNodeId;, +                    do {, +                        replicaNodeId = nodeIds.get(randomIntBetween(0, numNodes - 1));, +                    } while (primaryNodeId.equals(replicaNodeId));, +                    newIndexRoutingTable.addShard(, +                        shardRouting.initialize(replicaNodeId, null, shardRouting.getExpectedShardSize()), +                    );, +++ b/core/src/test/java/org/elasticsearch/cluster/routing/RandomShardRoutingMutator.java, +    public static ShardRouting randomChange(ShardRouting shardRouting, String[] nodes) {, +                if (shardRouting.unassigned()) {, +++ b/core/src/test/java/org/elasticsearch/indices/store/IndicesStoreTests.java, +        int numShards = randomIntBetween(1, 7);, +        int numReplicas = randomInt(2);, +]