[+++ b/core/src/main/java/org/elasticsearch/index/mapper/MapperService.java, +    private boolean allEnabled = false; // updated dynamically to true when _all is enabled, +     * Returns true if the "_all" field is enabled for the type, +     */, +    public boolean allEnabled() {, +        return this.allEnabled;, +    }, +, +    /**, +        this.allEnabled = mapper.allFieldMapper().enabled();, +++ b/core/src/main/java/org/elasticsearch/index/mapper/MapperService.java, +    private boolean allEnabled = false; // updated dynamically to true when _all is enabled, +     * Returns true if the "_all" field is enabled for the type, +     */, +    public boolean allEnabled() {, +        return this.allEnabled;, +    }, +, +    /**, +        this.allEnabled = mapper.allFieldMapper().enabled();, +++ b/core/src/main/java/org/elasticsearch/index/query/QueryShardContext.java, +    /**, +     * Returns all the fields that match a given pattern. If prefixed with a, +     * type then the fields will be returned with a type prefix., +     */, +++ b/core/src/main/java/org/elasticsearch/index/mapper/MapperService.java, +    private boolean allEnabled = false; // updated dynamically to true when _all is enabled, +     * Returns true if the "_all" field is enabled for the type, +     */, +    public boolean allEnabled() {, +        return this.allEnabled;, +    }, +, +    /**, +        this.allEnabled = mapper.allFieldMapper().enabled();, +++ b/core/src/main/java/org/elasticsearch/index/query/QueryShardContext.java, +    /**, +     * Returns all the fields that match a given pattern. If prefixed with a, +     * type then the fields will be returned with a type prefix., +     */, +++ b/core/src/main/java/org/elasticsearch/index/query/QueryStringQueryBuilder.java, +import org.elasticsearch.index.mapper.DateFieldMapper;, +import org.elasticsearch.index.mapper.IpFieldMapper;, +import org.elasticsearch.index.mapper.KeywordFieldMapper;, +import org.elasticsearch.index.mapper.MappedFieldType;, +import org.elasticsearch.index.mapper.MapperService;, +import org.elasticsearch.index.mapper.NumberFieldMapper;, +import org.elasticsearch.index.mapper.ScaledFloatFieldMapper;, +import org.elasticsearch.index.mapper.StringFieldMapper;, +import org.elasticsearch.index.mapper.TextFieldMapper;, +import org.elasticsearch.index.mapper.TimestampFieldMapper;, +import java.util.Collection;, +import java.util.HashSet;, +import java.util.Set;, +    private static final ParseField ALL_FIELDS_FIELD = new ParseField("all_fields");, +, +    // Mapping types the "all-ish" query can be executed against, +    private static final Set<String> ALLOWED_QUERY_MAPPER_TYPES;, +, +    static {, +        ALLOWED_QUERY_MAPPER_TYPES = new HashSet<>();, +        ALLOWED_QUERY_MAPPER_TYPES.add(DateFieldMapper.CONTENT_TYPE);, +        ALLOWED_QUERY_MAPPER_TYPES.add(IpFieldMapper.CONTENT_TYPE);, +        ALLOWED_QUERY_MAPPER_TYPES.add(KeywordFieldMapper.CONTENT_TYPE);, +        for (NumberFieldMapper.NumberType nt : NumberFieldMapper.NumberType.values()) {, +            ALLOWED_QUERY_MAPPER_TYPES.add(nt.typeName());, +        }, +        ALLOWED_QUERY_MAPPER_TYPES.add(ScaledFloatFieldMapper.CONTENT_TYPE);, +        ALLOWED_QUERY_MAPPER_TYPES.add(StringFieldMapper.CONTENT_TYPE);, +        ALLOWED_QUERY_MAPPER_TYPES.add(TextFieldMapper.CONTENT_TYPE);, +        ALLOWED_QUERY_MAPPER_TYPES.add(TimestampFieldMapper.CONTENT_TYPE);, +    }, +    private Boolean useAllFields;, +, +            useAllFields = in.readOptionalBoolean();, +            out.writeOptionalBoolean(this.useAllFields);, +     * Tell the query_string query to use all fields explicitly, even if _all is, +     * enabled. If the "default_field" parameter or "fields" are specified, they, +     * will be ignored., +     */, +    public QueryStringQueryBuilder useAllFields(Boolean useAllFields) {, +        this.useAllFields = useAllFields;, +        return this;, +    }, +, +    public Boolean useAllFields() {, +        return this.useAllFields;, +    }, +, +    /**, +        if (this.useAllFields != null) {, +            builder.field(ALL_FIELDS_FIELD.getPreferredName(), this.useAllFields);, +        }, +        Boolean useAllFields = null;, +                } else if (parseContext.getParseFieldMatcher().match(currentFieldName, ALL_FIELDS_FIELD)) {, +                    useAllFields = parser.booleanValue();, +        if ((useAllFields != null && useAllFields) &&, +                (defaultField != null || fieldsAndWeights.size() != 0)) {, +            throw new ParsingException(parser.getTokenLocation(),, +                    "cannot use [all_fields] parameter in conjunction with [default_field] or [fields]");]