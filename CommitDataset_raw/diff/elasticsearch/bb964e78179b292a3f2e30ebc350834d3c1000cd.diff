[+++ b/src/main/java/org/elasticsearch/cluster/routing/RoutingNodes.java, +++ b/src/main/java/org/elasticsearch/cluster/routing/RoutingNodes.java, +++ b/src/main/java/org/elasticsearch/cluster/routing/allocation/AllocationService.java, +        changed |= electPrimariesAndUnassignDanglingReplicas(allocation);, +        changed |= electPrimariesAndUnassignDanglingReplicas(allocation);, +            changed |= electPrimariesAndUnassignDanglingReplicas(allocation);, +    private boolean electPrimariesAndUnassignDanglingReplicas(RoutingAllocation allocation) {, +        // go over and remove dangling replicas that are initializing, but we couldn't elect primary ones..., +        List<ShardRouting> shardsToFail = null;, +        if (routingNodes.hasUnassignedPrimaries()) {, +            for (MutableShardRouting shardEntry : routingNodes.unassigned()) {, +                if (shardEntry.primary()) {, +                    for (MutableShardRouting routing : routingNodes.assignedShards(shardEntry)) {, +                        if (!routing.primary()) {, +                            changed = true;, +                            if (shardsToFail == null) {, +                                shardsToFail = new ArrayList<>();, +                            }, +                            shardsToFail.add(routing);, +                        }, +                    }, +                }, +            }, +            if (shardsToFail != null) {, +                for (ShardRouting shardToFail : shardsToFail) {, +                    applyFailedShard(allocation, shardToFail, false);, +                }, +            }, +        }, +        if (failedShard.primary()) {, +            // we have to fail the initializing replicas if the primary fails, +            // since they might now yet have started the recovery and then they will, +            // stick in the cluster-state forever since the replica has a retry logic that, +            // retries infinitely in that case., +            List<MutableShardRouting> initializingReplicas = new ArrayList<>();, +            for (MutableShardRouting shard : routingNodes.assignedShards(failedShard)){, +                if (!shard.primary() && shard.initializing()) {, +                    initializingReplicas.add(shard);, +                }, +            }, +            // we can't do this in the loop above since we modify the iterator and will get, +            // concurrent modification exceptions, +            for (MutableShardRouting shard : initializingReplicas) {, +                dirty |= applyFailedShard(allocation, shard, addToIgnoreList);, +            }, +        }, +++ b/src/main/java/org/elasticsearch/cluster/routing/RoutingNodes.java, +++ b/src/main/java/org/elasticsearch/cluster/routing/allocation/AllocationService.java, +        changed |= electPrimariesAndUnassignDanglingReplicas(allocation);, +        changed |= electPrimariesAndUnassignDanglingReplicas(allocation);, +            changed |= electPrimariesAndUnassignDanglingReplicas(allocation);, +    private boolean electPrimariesAndUnassignDanglingReplicas(RoutingAllocation allocation) {, +        // go over and remove dangling replicas that are initializing, but we couldn't elect primary ones..., +        List<ShardRouting> shardsToFail = null;, +        if (routingNodes.hasUnassignedPrimaries()) {, +            for (MutableShardRouting shardEntry : routingNodes.unassigned()) {, +                if (shardEntry.primary()) {, +                    for (MutableShardRouting routing : routingNodes.assignedShards(shardEntry)) {, +                        if (!routing.primary()) {, +                            changed = true;, +                            if (shardsToFail == null) {, +                                shardsToFail = new ArrayList<>();, +                            }, +                            shardsToFail.add(routing);, +                        }, +                    }, +                }, +            }, +            if (shardsToFail != null) {, +                for (ShardRouting shardToFail : shardsToFail) {, +                    applyFailedShard(allocation, shardToFail, false);, +                }, +            }, +        }, +        if (failedShard.primary()) {, +            // we have to fail the initializing replicas if the primary fails, +            // since they might now yet have started the recovery and then they will, +            // stick in the cluster-state forever since the replica has a retry logic that, +            // retries infinitely in that case., +            List<MutableShardRouting> initializingReplicas = new ArrayList<>();, +            for (MutableShardRouting shard : routingNodes.assignedShards(failedShard)){, +                if (!shard.primary() && shard.initializing()) {, +                    initializingReplicas.add(shard);, +                }, +            }, +            // we can't do this in the loop above since we modify the iterator and will get, +            // concurrent modification exceptions, +            for (MutableShardRouting shard : initializingReplicas) {, +                dirty |= applyFailedShard(allocation, shard, addToIgnoreList);, +            }, +        }, +++ b/src/test/java/org/elasticsearch/cluster/routing/allocation/FailedShardsRoutingTests.java]