[+++ b/src/main/java/org/elasticsearch/client/transport/TransportClient.java, +     * The list of filtered nodes that were not connected to, for example, due to, +     * mismatch in cluster name., +     */, +    public ImmutableList<DiscoveryNode> filteredNodes() {, +        return nodesService.filteredNodes();, +    }, +, +    /**, +++ b/src/main/java/org/elasticsearch/client/transport/TransportClient.java, +     * The list of filtered nodes that were not connected to, for example, due to, +     * mismatch in cluster name., +     */, +    public ImmutableList<DiscoveryNode> filteredNodes() {, +        return nodesService.filteredNodes();, +    }, +, +    /**, +++ b/src/main/java/org/elasticsearch/client/transport/TransportClientNodesService.java, +import java.util.concurrent.ConcurrentMap;, +    private volatile ImmutableList<DiscoveryNode> filteredNodes = ImmutableList.of();, +    public ImmutableList<DiscoveryNode> filteredNodes() {, +        return this.filteredNodes;, +    }, +, +            HashSet<DiscoveryNode> newFilteredNodes = new HashSet<DiscoveryNode>();, +                        newFilteredNodes.add(listedNode);, +                        // use discovered information but do keep the original transport address, so people can control which address is exactly used., +                        // although we asked for one node, our target may not have completed initialization yet and doesn't have cluster nodes, +                } catch (Throwable e) {, +            filteredNodes = ImmutableList.copyOf(newFilteredNodes);, +            final ConcurrentMap<DiscoveryNode, ClusterStateResponse> clusterStateResponses = ConcurrentCollections.newConcurrentMap();, +                                            clusterStateResponses.put(listedNode, response);, +                        } catch (Throwable e) {, +            HashSet<DiscoveryNode> newFilteredNodes = new HashSet<DiscoveryNode>();, +            for (Map.Entry<DiscoveryNode, ClusterStateResponse> entry : clusterStateResponses.entrySet()) {, +                if (!ignoreClusterName && !clusterName.equals(entry.getValue().getClusterName())) {, +                    logger.warn("node {} not part of the cluster {}, ignoring...", entry.getValue().getState().nodes().localNode(), clusterName);, +                    newFilteredNodes.add(entry.getKey());, +                    continue;, +                for (ObjectCursor<DiscoveryNode> cursor : entry.getValue().getState().nodes().dataNodes().values()) {, +            filteredNodes = ImmutableList.copyOf(newFilteredNodes);]