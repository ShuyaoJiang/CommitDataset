[+++ b/docs/reference/migration/migrate_2_0.asciidoc, +, +The `date_histogram` options for `pre_zone` and `post_zone` are replaced by the `time_zone` option. The behavior of `time_zone` is, +equivalent to the former `pre_zone` option. Setting `time_zone` to a value like "+01:00" now will lead to the bucket calculations, +being applied in the specified time zone but In addition to this, also the `pre_zone_adjust_large_interval` is removed because we, +now always return dates and bucket keys in UTC., +++ b/docs/reference/migration/migrate_2_0.asciidoc, +, +The `date_histogram` options for `pre_zone` and `post_zone` are replaced by the `time_zone` option. The behavior of `time_zone` is, +equivalent to the former `pre_zone` option. Setting `time_zone` to a value like "+01:00" now will lead to the bucket calculations, +being applied in the specified time zone but In addition to this, also the `pre_zone_adjust_large_interval` is removed because we, +now always return dates and bucket keys in UTC., +++ b/docs/reference/search/aggregations/bucket/datehistogram-aggregation.asciidoc, +done on UTC. It is possible to provide a time zone value, which will cause all bucket, +computations to take place in the specified zone. The time returned for each bucket/entry is milliseconds since the, +epoch in UTC. The parameters is called `time_zone`. It accepts either a numeric value for the hours offset, for example:, +`"time_zone" : -2`. It also accepts a format of hours and minutes, like `"time_zone" : "-02:30"`., +Another option is to provide a time zone accepted as one of the values listed here., +Lets take an example. For `2012-04-01T04:15:30Z` (UTC), with a `time_zone` of `"-08:00"`. For day interval, the actual time by, +`2012-03-31T08:00:00Z` (UTC). For hour interval, internally applying the time zone results in `2012-03-31T20:15:30`, so rounding it, +in the time zone results in `2012-03-31T20:00:00`, but we return that rounded value converted back in UTC so be consistent as, +`2012-04-01T04:00:00Z` (UTC)., +++ b/docs/reference/migration/migrate_2_0.asciidoc, +, +The `date_histogram` options for `pre_zone` and `post_zone` are replaced by the `time_zone` option. The behavior of `time_zone` is, +equivalent to the former `pre_zone` option. Setting `time_zone` to a value like "+01:00" now will lead to the bucket calculations, +being applied in the specified time zone but In addition to this, also the `pre_zone_adjust_large_interval` is removed because we, +now always return dates and bucket keys in UTC., +++ b/docs/reference/search/aggregations/bucket/datehistogram-aggregation.asciidoc, +done on UTC. It is possible to provide a time zone value, which will cause all bucket, +computations to take place in the specified zone. The time returned for each bucket/entry is milliseconds since the, +epoch in UTC. The parameters is called `time_zone`. It accepts either a numeric value for the hours offset, for example:, +`"time_zone" : -2`. It also accepts a format of hours and minutes, like `"time_zone" : "-02:30"`., +Another option is to provide a time zone accepted as one of the values listed here., +Lets take an example. For `2012-04-01T04:15:30Z` (UTC), with a `time_zone` of `"-08:00"`. For day interval, the actual time by, +`2012-03-31T08:00:00Z` (UTC). For hour interval, internally applying the time zone results in `2012-03-31T20:15:30`, so rounding it, +in the time zone results in `2012-03-31T20:00:00`, but we return that rounded value converted back in UTC so be consistent as, +`2012-04-01T04:00:00Z` (UTC)., +++ b/src/main/java/org/elasticsearch/common/rounding/Rounding.java, +                case TimeZoneRounding.TimeUnitRounding.ID: rounding = new TimeZoneRounding.TimeUnitRounding(); break;, +                case TimeZoneRounding.TimeIntervalRounding.ID: rounding = new TimeZoneRounding.TimeIntervalRounding(); break;, +++ b/docs/reference/migration/migrate_2_0.asciidoc, +, +The `date_histogram` options for `pre_zone` and `post_zone` are replaced by the `time_zone` option. The behavior of `time_zone` is, +equivalent to the former `pre_zone` option. Setting `time_zone` to a value like "+01:00" now will lead to the bucket calculations, +being applied in the specified time zone but In addition to this, also the `pre_zone_adjust_large_interval` is removed because we, +now always return dates and bucket keys in UTC., +++ b/docs/reference/search/aggregations/bucket/datehistogram-aggregation.asciidoc, +done on UTC. It is possible to provide a time zone value, which will cause all bucket, +computations to take place in the specified zone. The time returned for each bucket/entry is milliseconds since the, +epoch in UTC. The parameters is called `time_zone`. It accepts either a numeric value for the hours offset, for example:, +`"time_zone" : -2`. It also accepts a format of hours and minutes, like `"time_zone" : "-02:30"`., +Another option is to provide a time zone accepted as one of the values listed here., +Lets take an example. For `2012-04-01T04:15:30Z` (UTC), with a `time_zone` of `"-08:00"`. For day interval, the actual time by, +`2012-03-31T08:00:00Z` (UTC). For hour interval, internally applying the time zone results in `2012-03-31T20:15:30`, so rounding it, +in the time zone results in `2012-03-31T20:00:00`, but we return that rounded value converted back in UTC so be consistent as, +`2012-04-01T04:00:00Z` (UTC)., +++ b/src/main/java/org/elasticsearch/common/rounding/Rounding.java, +                case TimeZoneRounding.TimeUnitRounding.ID: rounding = new TimeZoneRounding.TimeUnitRounding(); break;, +                case TimeZoneRounding.TimeIntervalRounding.ID: rounding = new TimeZoneRounding.TimeIntervalRounding(); break;, +++ b/src/main/java/org/elasticsearch/common/rounding/TimeZoneRounding.java, +        private DateTimeZone timeZone = DateTimeZone.UTC;, +        public Builder timeZone(DateTimeZone timeZone) {, +            this.timeZone = timeZone;, +                    timeZoneRounding = new TimeUnitRounding(unit, timeZone);, +                    timeZoneRounding = new TimeIntervalRounding(interval, timeZone);, +    static class TimeUnitRounding extends TimeZoneRounding {, +        private DateTimeZone timeZone;, +        TimeUnitRounding() { // for serialization, +        TimeUnitRounding(DateTimeUnit unit, DateTimeZone timeZone) {, +            this.field = unit.field();, +            this.durationField = field.getDurationField();, +            this.timeZone = timeZone;, +            long timeLocal = utcMillis;, +            timeLocal = timeZone.convertUTCToLocal(utcMillis);, +            long rounded = field.roundFloor(timeLocal);, +            return timeZone.convertLocalToUTC(rounded, true, utcMillis);, +            assert roundKey(time) == time;, +        public long nextRoundingValue(long time) {, +            long timeLocal = time;, +            timeLocal = timeZone.convertUTCToLocal(time);, +            long nextInLocalTime = durationField.add(timeLocal, 1);, +            return timeZone.convertLocalToUTC(nextInLocalTime, true);, +            timeZone = DateTimeZone.forID(in.readString());, +            out.writeString(timeZone.getID());, +    static class TimeIntervalRounding extends TimeZoneRounding {, +        private long interval;, +        private DateTimeZone timeZone;, +        TimeIntervalRounding() { // for serialization, +        TimeIntervalRounding(long interval, DateTimeZone timeZone) {, +            if (interval < 1), +                throw new ElasticsearchIllegalArgumentException("Zero or negative time interval not supported");, +            this.interval = interval;, +            this.timeZone = timeZone;, +            long timeLocal = utcMillis;, +            timeLocal = timeZone.convertUTCToLocal(utcMillis);, +            long rounded = Rounding.Interval.roundValue(Rounding.Interval.roundKey(timeLocal, interval), interval);, +            return timeZone.convertLocalToUTC(rounded, true);, +            assert roundKey(time) == time;, +        public long nextRoundingValue(long time) {]