[+++ b/server/src/main/java/org/elasticsearch/index/mapper/NumberFieldMapper.java, +            public Number parsePoint(byte[] value) {, +                return HalfFloatPoint.decodeDimension(value, 0);, +            }, +, +            @Override, +            public Number parsePoint(byte[] value) {, +                return FloatPoint.decodeDimension(value, 0);, +            }, +, +            @Override, +            public Number parsePoint(byte[] value) {, +                return DoublePoint.decodeDimension(value, 0);, +            }, +, +            @Override, +            public Number parsePoint(byte[] value) {, +                return INTEGER.parsePoint(value).byteValue();, +            }, +, +            @Override, +            public Number parsePoint(byte[] value) {, +                return INTEGER.parsePoint(value).shortValue();, +            }, +, +            @Override, +            public Number parsePoint(byte[] value) {, +                return IntPoint.decodeDimension(value, 0);, +            }, +, +            @Override, +            public Number parsePoint(byte[] value) {, +                return LongPoint.decodeDimension(value, 0);, +            }, +, +            @Override, +        public abstract Number parsePoint(byte[] value);, +        public Number parsePoint(byte[] value) {, +            return type.parsePoint(value);, +        }, +, +++ b/server/src/main/java/org/elasticsearch/index/mapper/NumberFieldMapper.java, +            public Number parsePoint(byte[] value) {, +                return HalfFloatPoint.decodeDimension(value, 0);, +            }, +, +            @Override, +            public Number parsePoint(byte[] value) {, +                return FloatPoint.decodeDimension(value, 0);, +            }, +, +            @Override, +            public Number parsePoint(byte[] value) {, +                return DoublePoint.decodeDimension(value, 0);, +            }, +, +            @Override, +            public Number parsePoint(byte[] value) {, +                return INTEGER.parsePoint(value).byteValue();, +            }, +, +            @Override, +            public Number parsePoint(byte[] value) {, +                return INTEGER.parsePoint(value).shortValue();, +            }, +, +            @Override, +            public Number parsePoint(byte[] value) {, +                return IntPoint.decodeDimension(value, 0);, +            }, +, +            @Override, +            public Number parsePoint(byte[] value) {, +                return LongPoint.decodeDimension(value, 0);, +            }, +, +            @Override, +        public abstract Number parsePoint(byte[] value);, +        public Number parsePoint(byte[] value) {, +            return type.parsePoint(value);, +        }, +, +++ b/server/src/main/java/org/elasticsearch/search/aggregations/metrics/MaxAggregator.java, +import org.apache.lucene.index.LeafReader;, +import org.apache.lucene.index.PointValues;, +import org.apache.lucene.search.CollectionTerminatedException;, +import org.apache.lucene.util.Bits;, +import org.apache.lucene.util.FutureArrays;, +import org.elasticsearch.search.aggregations.support.ValuesSourceConfig;, +import java.util.function.Function;, +, +import static org.elasticsearch.search.aggregations.metrics.MinAggregator.getPointReaderOrNull;, +    final String pointField;, +    final Function<byte[], Number> pointConverter;, +, +    MaxAggregator(String name,, +                    ValuesSourceConfig<ValuesSource.Numeric> config,, +                    ValuesSource.Numeric valuesSource,, +        this.formatter = config.format();, +        this.pointConverter = getPointReaderOrNull(context, parent, config);]