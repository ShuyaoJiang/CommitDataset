[+++ b/core/src/main/java/org/elasticsearch/client/transport/TransportProxyClient.java, +++ b/core/src/main/java/org/elasticsearch/client/transport/TransportProxyClient.java, +++ b/core/src/main/java/org/elasticsearch/common/settings/AbstractScopedSettings.java, +        for (String key : settings.getAsMap().keySet()) { // settings iterate in deterministic fashion, +                validate(key, settings);, +++ b/core/src/main/java/org/elasticsearch/client/transport/TransportProxyClient.java, +++ b/core/src/main/java/org/elasticsearch/common/settings/AbstractScopedSettings.java, +        for (String key : settings.getAsMap().keySet()) { // settings iterate in deterministic fashion, +                validate(key, settings);, +++ b/core/src/main/java/org/elasticsearch/common/settings/Setting.java, +                        if (logger.isInfoEnabled()) { // getRaw can create quite some objects, +                        }, +++ b/core/src/main/java/org/elasticsearch/client/transport/TransportProxyClient.java, +++ b/core/src/main/java/org/elasticsearch/common/settings/AbstractScopedSettings.java, +        for (String key : settings.getAsMap().keySet()) { // settings iterate in deterministic fashion, +                validate(key, settings);, +++ b/core/src/main/java/org/elasticsearch/common/settings/Setting.java, +                        if (logger.isInfoEnabled()) { // getRaw can create quite some objects, +                        }, +++ b/core/src/main/java/org/elasticsearch/common/settings/Settings.java, +import java.util.AbstractMap;, +import java.util.AbstractSet;, +import java.util.NoSuchElementException;, +    private Map<String, String> settings;, +        this.settings = Collections.unmodifiableMap(settings);, +        // settings is always unmodifiable, +        return this.settings;, +        return new Settings(new FilteredMap(this.settings, (k) -> k.startsWith(prefix), prefix));, +        return new Settings(new FilteredMap(this.settings, predicate, null));, +, +        // we use a sorted map for consistent serialization when using getAsMap(), +        private final Map<String, String> map = new TreeMap<>();, +            return new Settings(map);, +        }, +    }, +, +    // TODO We could use an FST internally to make things even faster and more compact, +    private static final class FilteredMap extends AbstractMap<String, String> {, +        private final Map<String, String> delegate;, +        private final Predicate<String> filter;, +        private final String prefix;, +        // we cache that size since we have to iterate the entire set, +        // this is safe to do since this map is only used with unmodifiable maps, +        private int size = -1;, +        @Override, +        public Set<Entry<String, String>> entrySet() {, +            Set<Entry<String, String>> delegateSet = delegate.entrySet();, +            AbstractSet<Entry<String, String>> filterSet = new AbstractSet<Entry<String, String>>() {, +, +                @Override, +                public Iterator<Entry<String, String>> iterator() {, +                    Iterator<Entry<String, String>> iter = delegateSet.iterator();, +, +                    return new Iterator<Entry<String, String>>() {, +                        private int numIterated;, +                        private Entry<String, String> currentElement;, +                        @Override, +                        public boolean hasNext() {, +                            if (currentElement != null) {, +                                return true; // protect against calling hasNext twice, +                            } else {, +                                if (numIterated == size) { // early terminate, +                                    assert size != -1 : "size was never set: " + numIterated + " vs. " + size;, +                                    return false;, +                                }, +                                while (iter.hasNext()) {, +                                    if (filter.test((currentElement = iter.next()).getKey())) {, +                                        numIterated++;, +                                        return true;, +                                    }, +                                }, +                                // we didn't find anything, +                                currentElement = null;, +                                return false;, +                            }, +                        }, +, +                        @Override, +                        public Entry<String, String> next() {, +                            if (currentElement == null && hasNext() == false) { // protect against no #hasNext call or not respecting it, +, +                                throw new NoSuchElementException("make sure to call hasNext first");, +                            }, +                            final Entry<String, String> current = this.currentElement;, +                            this.currentElement = null;, +                            if (prefix == null) {, +                                return current;, +                            }, +                            return new Entry<String, String>() {, +                                @Override, +                                public String getKey() {, +                                    return current.getKey().substring(prefix.length());, +                                }, +, +                                @Override, +                                public String getValue() {, +                                    return current.getValue();, +                                }, +, +                                @Override]