[+++ b/core/src/main/java/org/elasticsearch/ingest/PipelineStore.java, +import java.util.HashSet;, +import java.util.Set;, +        Set<String> toRemove = new HashSet<>();, +        for (String pipelineKey : pipelines.keySet()) {, +            if (Regex.simpleMatch(request.getId(), pipelineKey)) {, +                toRemove.add(pipelineKey);, +            }, +        }, +        if (toRemove.isEmpty() && Regex.isMatchAllPattern(request.getId()) == false) {, +        } else if (toRemove.isEmpty()) {, +            return currentState;, +        }, +        final Map<String, PipelineConfiguration> pipelinesCopy = new HashMap<>(pipelines);, +        for (String key : toRemove) {, +            pipelinesCopy.remove(key);, +        }, +                .putCustom(IngestMetadata.TYPE, new IngestMetadata(pipelinesCopy)), +++ b/core/src/main/java/org/elasticsearch/ingest/PipelineStore.java, +import java.util.HashSet;, +import java.util.Set;, +        Set<String> toRemove = new HashSet<>();, +        for (String pipelineKey : pipelines.keySet()) {, +            if (Regex.simpleMatch(request.getId(), pipelineKey)) {, +                toRemove.add(pipelineKey);, +            }, +        }, +        if (toRemove.isEmpty() && Regex.isMatchAllPattern(request.getId()) == false) {, +        } else if (toRemove.isEmpty()) {, +            return currentState;, +        }, +        final Map<String, PipelineConfiguration> pipelinesCopy = new HashMap<>(pipelines);, +        for (String key : toRemove) {, +            pipelinesCopy.remove(key);, +        }, +                .putCustom(IngestMetadata.TYPE, new IngestMetadata(pipelinesCopy)), +++ b/core/src/test/java/org/elasticsearch/ingest/PipelineStoreTests.java, +    public void testDeleteUsingWildcard() {, +        HashMap<String, PipelineConfiguration> pipelines = new HashMap<>();, +        BytesArray definition = new BytesArray(, +            "{\"processors\": [{\"set\" : {\"field\": \"_field\", \"value\": \"_value\"}}]}", +        );, +        pipelines.put("p1", new PipelineConfiguration("p1", definition));, +        pipelines.put("p2", new PipelineConfiguration("p2", definition));, +        pipelines.put("q1", new PipelineConfiguration("q1", definition));, +        IngestMetadata ingestMetadata = new IngestMetadata(pipelines);, +        ClusterState clusterState = ClusterState.builder(new ClusterName("_name")).build();, +        ClusterState previousClusterState = clusterState;, +        clusterState = ClusterState.builder(clusterState).metaData(MetaData.builder(), +            .putCustom(IngestMetadata.TYPE, ingestMetadata)).build();, +        store.innerUpdatePipelines(previousClusterState, clusterState);, +        assertThat(store.get("p1"), notNullValue());, +        assertThat(store.get("p2"), notNullValue());, +        assertThat(store.get("q1"), notNullValue());, +, +        // Delete pipeline matching wildcard, +        DeletePipelineRequest deleteRequest = new DeletePipelineRequest("p*");, +        previousClusterState = clusterState;, +        clusterState = store.innerDelete(deleteRequest, clusterState);, +        store.innerUpdatePipelines(previousClusterState, clusterState);, +        assertThat(store.get("p1"), nullValue());, +        assertThat(store.get("p2"), nullValue());, +        assertThat(store.get("q1"), notNullValue());, +, +        // Exception if we used name which does not exist, +        try {, +            store.innerDelete(new DeletePipelineRequest("unknown"), clusterState);, +            fail("exception expected");, +        } catch (ResourceNotFoundException e) {, +            assertThat(e.getMessage(), equalTo("pipeline [unknown] is missing"));, +        }, +, +        // match all wildcard works on last remaining pipeline, +        DeletePipelineRequest matchAllDeleteRequest = new DeletePipelineRequest("*");, +        previousClusterState = clusterState;, +        clusterState = store.innerDelete(matchAllDeleteRequest, clusterState);, +        store.innerUpdatePipelines(previousClusterState, clusterState);, +        assertThat(store.get("p1"), nullValue());, +        assertThat(store.get("p2"), nullValue());, +        assertThat(store.get("q1"), nullValue());, +, +        // match all wildcard does not throw exception if none match, +        store.innerDelete(matchAllDeleteRequest, clusterState);, +    }, +, +    public void testDeleteWithExistingUnmatchedPipelines() {, +        HashMap<String, PipelineConfiguration> pipelines = new HashMap<>();, +        BytesArray definition = new BytesArray(, +            "{\"processors\": [{\"set\" : {\"field\": \"_field\", \"value\": \"_value\"}}]}", +        );, +        pipelines.put("p1", new PipelineConfiguration("p1", definition));, +        IngestMetadata ingestMetadata = new IngestMetadata(pipelines);, +        ClusterState clusterState = ClusterState.builder(new ClusterName("_name")).build();, +        ClusterState previousClusterState = clusterState;, +        clusterState = ClusterState.builder(clusterState).metaData(MetaData.builder(), +            .putCustom(IngestMetadata.TYPE, ingestMetadata)).build();, +        store.innerUpdatePipelines(previousClusterState, clusterState);, +        assertThat(store.get("p1"), notNullValue());, +, +        DeletePipelineRequest deleteRequest = new DeletePipelineRequest("z*");]