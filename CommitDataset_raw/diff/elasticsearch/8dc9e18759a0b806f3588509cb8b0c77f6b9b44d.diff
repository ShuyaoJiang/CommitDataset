[+++ b/server/src/main/java/org/elasticsearch/action/search/SearchResponseMerger.java, +            int shardIdCompare = shardId1.compareTo(shardId2);, +            //we could assume that the same shard id cannot come back from multiple clusters as even with same index name and shard index,, +            //the index uuid does not match. But the same cluster can be registered multiple times with different aliases, in which case, +            //we may get failures from the same index, yet with a different cluster alias in their shard target., +            if (shardIdCompare != 0) {, +                return shardIdCompare;, +            }, +            String clusterAlias1 = o1.shard() == null ? null : o1.shard().getClusterAlias();, +            String clusterAlias2 = o2.shard() == null ? null : o2.shard().getClusterAlias();, +            if (clusterAlias1 == null && clusterAlias2 == null) {, +                return 0;, +            }, +            if (clusterAlias1 == null) {, +                return -1;, +            }, +            if (clusterAlias2 == null) {, +                return 1;, +            }, +            return clusterAlias1.compareTo(clusterAlias2);, +++ b/server/src/main/java/org/elasticsearch/action/search/SearchResponseMerger.java, +            int shardIdCompare = shardId1.compareTo(shardId2);, +            //we could assume that the same shard id cannot come back from multiple clusters as even with same index name and shard index,, +            //the index uuid does not match. But the same cluster can be registered multiple times with different aliases, in which case, +            //we may get failures from the same index, yet with a different cluster alias in their shard target., +            if (shardIdCompare != 0) {, +                return shardIdCompare;, +            }, +            String clusterAlias1 = o1.shard() == null ? null : o1.shard().getClusterAlias();, +            String clusterAlias2 = o2.shard() == null ? null : o2.shard().getClusterAlias();, +            if (clusterAlias1 == null && clusterAlias2 == null) {, +                return 0;, +            }, +            if (clusterAlias1 == null) {, +                return -1;, +            }, +            if (clusterAlias2 == null) {, +                return 1;, +            }, +            return clusterAlias1.compareTo(clusterAlias2);, +++ b/server/src/test/java/org/elasticsearch/action/search/SearchResponseMergerTests.java, +        PriorityQueue<Tuple<SearchShardTarget, ShardSearchFailure>> priorityQueue = new PriorityQueue<>(Comparator.comparing(Tuple::v1,, +            (o1, o2) -> {, +                int compareTo = o1.getShardId().compareTo(o2.getShardId());, +                if (compareTo != 0) {, +                    return compareTo;, +                }, +                return o1.getClusterAlias().compareTo(o2.getClusterAlias());, +            }));, +                ShardSearchFailure failure = new ShardSearchFailure(new IllegalArgumentException(), searchShardTarget);, +                shardSearchFailures[j] = failure;, +                priorityQueue.add(Tuple.tuple(searchShardTarget, failure));, +            }, +            SearchResponse searchResponse = new SearchResponse(InternalSearchResponse.empty(), null,, +                1, 1, 0, 100L, shardSearchFailures, SearchResponse.Clusters.EMPTY);, +            addResponse(merger, searchResponse);, +        }, +        awaitResponsesAdded();, +        assertEquals(numResponses, merger.numResponses());, +        SearchResponse.Clusters clusters = SearchResponseTests.randomClusters();, +        SearchResponse mergedResponse = merger.getMergedResponse(clusters);, +        assertSame(clusters, mergedResponse.getClusters());, +        assertEquals(numResponses, mergedResponse.getTotalShards());, +        assertEquals(numResponses, mergedResponse.getSuccessfulShards());, +        assertEquals(0, mergedResponse.getSkippedShards());, +        assertEquals(priorityQueue.size(), mergedResponse.getFailedShards());, +        ShardSearchFailure[] shardFailures = mergedResponse.getShardFailures();, +        assertEquals(priorityQueue.size(), shardFailures.length);, +        for (ShardSearchFailure shardFailure : shardFailures) {, +            ShardSearchFailure expected = priorityQueue.poll().v2();, +            assertSame(expected, shardFailure);, +        }, +    }, +, +    public void testMergeShardFailuresNullShardTarget() throws InterruptedException {, +        SearchTimeProvider searchTimeProvider = new SearchTimeProvider(0, 0, () -> 0);, +        SearchResponseMerger merger = new SearchResponseMerger(0, 0, SearchContext.TRACK_TOTAL_HITS_ACCURATE,, +            searchTimeProvider, flag -> null);, +        PriorityQueue<Tuple<ShardId, ShardSearchFailure>> priorityQueue = new PriorityQueue<>(Comparator.comparing(Tuple::v1));, +        for (int i = 0; i < numResponses; i++) {, +            int numFailures = randomIntBetween(1, 10);, +            ShardSearchFailure[] shardSearchFailures = new ShardSearchFailure[numFailures];, +            for (int j = 0; j < numFailures; j++) {, +                String index = "index-" + i;, +                ShardId shardId = new ShardId(index, index + "-uuid", j);, +                ShardSearchFailure failure = new ShardSearchFailure(elasticsearchException);]