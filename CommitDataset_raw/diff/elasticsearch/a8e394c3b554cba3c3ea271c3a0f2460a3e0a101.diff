[+++ b/plugin/src/main/java/org/elasticsearch/xpack/ml/MlMetadata.java, +                // Job still exists but is already being deleted, +                throw new JobAlreadyMarkedAsDeletedException();, +    public static class JobAlreadyMarkedAsDeletedException extends RuntimeException {, +    }, +++ b/plugin/src/main/java/org/elasticsearch/xpack/ml/MlMetadata.java, +                // Job still exists but is already being deleted, +                throw new JobAlreadyMarkedAsDeletedException();, +    public static class JobAlreadyMarkedAsDeletedException extends RuntimeException {, +    }, +++ b/plugin/src/main/java/org/elasticsearch/xpack/ml/action/DeleteJobAction.java, +import java.util.concurrent.TimeoutException;, +                    e -> {, +                        if (e instanceof MlMetadata.JobAlreadyMarkedAsDeletedException) {, +                            // Don't kick off a parallel deletion task, but just wait for, +                            // the in-progress request to finish.  This is much safer in the, +                            // case where the job with the same name might be immediately, +                            // recreated after the delete returns.  However, if a force, +                            // delete times out then eventually kick off a parallel delete, +                            // in case the original completely failed for some reason., +                            waitForDeletingJob(request.getJobId(), MachineLearning.STATE_PERSIST_RESTORE_TIMEOUT, ActionListener.wrap(, +                                    listener::onResponse,, +                                    e2 -> {, +                                        if (request.isForce() && e2 instanceof TimeoutException) {, +                                            forceDeleteJob(request, (JobStorageDeletionTask) task, listener);, +                                        } else {, +                                            listener.onFailure(e2);, +                                        }, +                                    }, +                            ));, +                        } else {, +                            listener.onFailure(e);, +                        }, +                    });, +                        listener.onFailure(new TimeoutException("timed out after " + timeout));, +++ b/plugin/src/main/java/org/elasticsearch/xpack/ml/MlMetadata.java, +                // Job still exists but is already being deleted, +                throw new JobAlreadyMarkedAsDeletedException();, +    public static class JobAlreadyMarkedAsDeletedException extends RuntimeException {, +    }, +++ b/plugin/src/main/java/org/elasticsearch/xpack/ml/action/DeleteJobAction.java, +import java.util.concurrent.TimeoutException;, +                    e -> {, +                        if (e instanceof MlMetadata.JobAlreadyMarkedAsDeletedException) {, +                            // Don't kick off a parallel deletion task, but just wait for, +                            // the in-progress request to finish.  This is much safer in the, +                            // case where the job with the same name might be immediately, +                            // recreated after the delete returns.  However, if a force, +                            // delete times out then eventually kick off a parallel delete, +                            // in case the original completely failed for some reason., +                            waitForDeletingJob(request.getJobId(), MachineLearning.STATE_PERSIST_RESTORE_TIMEOUT, ActionListener.wrap(, +                                    listener::onResponse,, +                                    e2 -> {, +                                        if (request.isForce() && e2 instanceof TimeoutException) {, +                                            forceDeleteJob(request, (JobStorageDeletionTask) task, listener);, +                                        } else {, +                                            listener.onFailure(e2);, +                                        }, +                                    }, +                            ));, +                        } else {, +                            listener.onFailure(e);, +                        }, +                    });, +                        listener.onFailure(new TimeoutException("timed out after " + timeout));, +++ b/plugin/src/test/java/org/elasticsearch/xpack/ml/integration/MlJobIT.java, +import java.util.concurrent.atomic.AtomicInteger;, +    private Response createFarequoteJob(String jobId) throws IOException {, +        AtomicInteger recreationGuard = new AtomicInteger(0);, +        AtomicReference<Response> recreationResponse = new AtomicReference<>();, +        AtomicReference<ResponseException> recreationException = new AtomicReference<>();, +            // Immediately after the first deletion finishes, recreate the job.  This should pick up, +            // race conditions where another delete request deletes part of the newly created job., +            if (recreationGuard.getAndIncrement() == 0) {, +                try {, +                    recreationResponse.set(createFarequoteJob(jobId));, +                } catch (ResponseException re) {, +                    recreationException.set(re);, +                } catch (IOException e) {, +                    ioe.set(e);, +                }, +            }, +, +        assertNotNull(recreationResponse.get());, +        assertEquals(responseEntityToString(recreationResponse.get()), 200, recreationResponse.get().getStatusLine().getStatusCode());, +, +        if (recreationException.get() != null) {, +            assertNull(recreationException.get().getMessage(), recreationException.get());, +        }, +, +        // Check that the job aliases exist.  These are the last thing to be deleted when a job is deleted, so, +        // if there's been a race between deletion and recreation these are what will be missing., +        Response response = client().performRequest("get", "_aliases");, +        assertEquals(200, response.getStatusLine().getStatusCode());, +        String responseAsString = responseEntityToString(response);, +, +        assertThat(responseAsString, containsString("\"" + AnomalyDetectorsIndex.jobResultsAliasedName(jobId), +                + "\":{\"filter\":{\"term\":{\"job_id\":{\"value\":\"" + jobId + "\",\"boost\":1.0}}}}"));, +        assertThat(responseAsString, containsString("\"" + AnomalyDetectorsIndex.resultsWriteAlias(jobId) + "\":{}"));, +]