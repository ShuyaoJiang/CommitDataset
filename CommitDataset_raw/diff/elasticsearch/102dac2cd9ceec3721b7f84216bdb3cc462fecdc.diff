[+++ b/core/src/main/java/org/elasticsearch/action/admin/cluster/node/stats/NodeStats.java, +            jvm = new JvmStats(in);, +++ b/core/src/main/java/org/elasticsearch/action/admin/cluster/node/stats/NodeStats.java, +            jvm = new JvmStats(in);, +++ b/core/src/main/java/org/elasticsearch/monitor/jvm/JvmStats.java, +import org.elasticsearch.common.inject.internal.Nullable;, +import org.elasticsearch.common.io.stream.Writeable;, +import java.util.Collections;, +public class JvmStats implements Writeable, ToXContent {, +        long heapUsed = memUsage.getUsed() < 0 ? 0 : memUsage.getUsed();, +        long heapCommitted = memUsage.getCommitted() < 0 ? 0 : memUsage.getCommitted();, +        long heapMax = memUsage.getMax() < 0 ? 0 : memUsage.getMax();, +        long nonHeapUsed = memUsage.getUsed() < 0 ? 0 : memUsage.getUsed();, +        long nonHeapCommitted = memUsage.getCommitted() < 0 ? 0 : memUsage.getCommitted();, +        for (MemoryPoolMXBean memoryPoolMXBean : memoryPoolMXBeans) {, +        MemoryPool[] memoryPools = pools.toArray(new MemoryPool[pools.size()]);, +        Mem mem = new Mem(heapCommitted, heapUsed, heapMax, nonHeapCommitted, nonHeapUsed, memoryPools);, +        Threads threads = new Threads(threadMXBean.getThreadCount(), threadMXBean.getPeakThreadCount());, +        GarbageCollector[] collectors = new GarbageCollector[gcMxBeans.size()];, +        for (int i = 0; i < collectors.length; i++) {, +            collectors[i] = new GarbageCollector(GcNames.getByGcName(gcMxBean.getName(), gcMxBean.getName()),, +                    gcMxBean.getCollectionCount(), gcMxBean.getCollectionTime());, +        GarbageCollectors garbageCollectors = new GarbageCollectors(collectors);, +        List<BufferPool> bufferPoolsList = null;, +            bufferPoolsList = new ArrayList<>(bufferPools.size());, +                bufferPoolsList.add(new BufferPool(bufferPool.getName(), bufferPool.getCount(),, +                        bufferPool.getTotalCapacity(), bufferPool.getMemoryUsed()));, +        Classes classes = new Classes(classLoadingMXBean.getLoadedClassCount(), classLoadingMXBean.getTotalLoadedClassCount(),, +                classLoadingMXBean.getUnloadedClassCount());, +        return new JvmStats(System.currentTimeMillis(), runtimeMXBean.getUptime(), mem, threads,, +                garbageCollectors, bufferPoolsList, classes);, +    private final long timestamp;, +    private final long uptime;, +    private final Mem mem;, +    private final Threads threads;, +    private final GarbageCollectors gc;, +    private final List<BufferPool> bufferPools;, +    private final Classes classes;, +    public JvmStats(long timestamp, long uptime, Mem mem, Threads threads, GarbageCollectors gc,, +                    @Nullable List<BufferPool> bufferPools, Classes classes) {, +        this.mem = mem;, +        this.threads = threads;, +        this.gc = gc;, +        this.bufferPools = bufferPools;, +        this.classes = classes;, +    }, +, +    public JvmStats(StreamInput in) throws IOException {, +        timestamp = in.readVLong();, +        uptime = in.readVLong();, +        mem = new Mem(in);, +        threads = new Threads(in);, +        gc = new GarbageCollectors(in);, +        if (in.readBoolean()) {, +            bufferPools = in.readList(BufferPool::new);, +        } else {, +            bufferPools = Collections.emptyList();, +        }, +        classes = new Classes(in);, +    }, +, +    @Override, +    public void writeTo(StreamOutput out) throws IOException {, +        out.writeVLong(timestamp);, +        out.writeVLong(uptime);, +        mem.writeTo(out);, +        threads.writeTo(out);, +        gc.writeTo(out);, +        if (bufferPools == null) {, +            out.writeBoolean(false);, +        } else {, +            out.writeBoolean(true);, +            out.writeList(bufferPools);, +        }, +        classes.writeTo(out);, +, +, +, +    public static class GarbageCollectors implements Writeable, Iterable<GarbageCollector> {, +        private final GarbageCollector[] collectors;, +, +        public GarbageCollectors(GarbageCollector[] collectors) {, +            this.collectors = collectors;, +        public GarbageCollectors(StreamInput in) throws IOException {, +            collectors = in.readArray(GarbageCollector::new, GarbageCollector[]::new);, +            out.writeArray(collectors);, +    public static class GarbageCollector implements Writeable {, +        private final String name;, +        private final long collectionCount;, +        private final long collectionTime;, +        public GarbageCollector(String name, long collectionCount, long collectionTime) {, +            this.name = name;, +            this.collectionCount = collectionCount;, +            this.collectionTime = collectionTime;, +        public GarbageCollector(StreamInput in) throws IOException {, +    public static class Threads implements Writeable {, +        private final int count;, +        private final int peakCount;, +        public Threads(int count, int peakCount) {, +            this.count = count;]