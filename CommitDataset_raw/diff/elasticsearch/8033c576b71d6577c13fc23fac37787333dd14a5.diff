[+++ b/core/src/main/java/org/elasticsearch/bootstrap/Security.java, +        /*, +         * If path.data and default.path.data are set, we need read access to the paths in default.path.data to check for the existence of, +         * index directories there that could have arisen from a bug in the handling of simultaneous configuration of path.data and, +         * default.path.data that was introduced in Elasticsearch 5.3.0., +         *, +         * If path.data is not set then default.path.data would take precedence in setting the data paths for the environment and, +         * permissions would have been granted above., +         *, +         * If path.data is not set and default.path.data is not set, then we would fallback to the default data directory under, +         * Elasticsearch home and again permissions would have been granted above., +         *, +         * If path.data is set and default.path.data is not set, there is nothing to do here., +         */, +        if (Environment.PATH_DATA_SETTING.exists(environment.settings()), +                && Environment.DEFAULT_PATH_DATA_SETTING.exists(environment.settings())) {, +            for (final String path : Environment.DEFAULT_PATH_DATA_SETTING.get(environment.settings())) {, +                // write permissions are not needed here, we are not going to be writing to any paths here, +                addPath(policy, Environment.DEFAULT_PATH_DATA_SETTING.getKey(), getPath(path), "read,readlink");, +            }, +        }, +    @SuppressForbidden(reason = "read path that is not configured in environment"), +    private static Path getPath(final String path) {, +        return PathUtils.get(path);, +    }, +, +++ b/core/src/main/java/org/elasticsearch/bootstrap/Security.java, +        /*, +         * If path.data and default.path.data are set, we need read access to the paths in default.path.data to check for the existence of, +         * index directories there that could have arisen from a bug in the handling of simultaneous configuration of path.data and, +         * default.path.data that was introduced in Elasticsearch 5.3.0., +         *, +         * If path.data is not set then default.path.data would take precedence in setting the data paths for the environment and, +         * permissions would have been granted above., +         *, +         * If path.data is not set and default.path.data is not set, then we would fallback to the default data directory under, +         * Elasticsearch home and again permissions would have been granted above., +         *, +         * If path.data is set and default.path.data is not set, there is nothing to do here., +         */, +        if (Environment.PATH_DATA_SETTING.exists(environment.settings()), +                && Environment.DEFAULT_PATH_DATA_SETTING.exists(environment.settings())) {, +            for (final String path : Environment.DEFAULT_PATH_DATA_SETTING.get(environment.settings())) {, +                // write permissions are not needed here, we are not going to be writing to any paths here, +                addPath(policy, Environment.DEFAULT_PATH_DATA_SETTING.getKey(), getPath(path), "read,readlink");, +            }, +        }, +    @SuppressForbidden(reason = "read path that is not configured in environment"), +    private static Path getPath(final String path) {, +        return PathUtils.get(path);, +    }, +, +++ b/core/src/main/java/org/elasticsearch/env/NodeEnvironment.java, +                    Path dir = resolveNodePath(dataDir, possibleLockId);, +    /**, +     * Resolve a specific nodes/{node.id} path for the specified path and node lock id., +     *, +     * @param path       the path, +     * @param nodeLockId the node lock id, +     * @return the resolved path, +     */, +    public static Path resolveNodePath(final Path path, final int nodeLockId) {, +        return path.resolve(NODES_FOLDER).resolve(Integer.toString(nodeLockId));, +    }, +, +    public int getNodeLockId() {, +        assertEnvIsLocked();, +        if (nodePaths == null || locks == null) {, +            throw new IllegalStateException("node is not configured to store local location");, +        }, +        return nodeLockId;, +    }, +, +, +, +            indexFolders.addAll(availableIndexFoldersForPath(nodePath));, +        }, +        return indexFolders;, +, +    }, +, +    /**, +     * Return all directory names in the nodes/{node.id}/indices directory for the given node path., +     *, +     * @param nodePath the path, +     * @return all directories that could be indices for the given node path., +     * @throws IOException if an I/O exception occurs traversing the filesystem, +     */, +    public Set<String> availableIndexFoldersForPath(final NodePath nodePath) throws IOException {, +        if (nodePaths == null || locks == null) {, +            throw new IllegalStateException("node is not configured to store local location");, +        }, +        assertEnvIsLocked();, +        final Set<String> indexFolders = new HashSet<>();, +++ b/core/src/main/java/org/elasticsearch/bootstrap/Security.java, +        /*, +         * If path.data and default.path.data are set, we need read access to the paths in default.path.data to check for the existence of, +         * index directories there that could have arisen from a bug in the handling of simultaneous configuration of path.data and, +         * default.path.data that was introduced in Elasticsearch 5.3.0., +         *]