[+++ b/modules/rank-eval/src/main/java/org/elasticsearch/index/rankeval/RankEvalSpec.java, +    private final Map<String, Script> templates = new HashMap<>();, +                if (request.getEvaluationRequest() == null) {, +                    throw new IllegalStateException("Cannot evaluate ranking if neither template nor evaluation request is ", +++ b/modules/rank-eval/src/main/java/org/elasticsearch/index/rankeval/RankEvalSpec.java, +    private final Map<String, Script> templates = new HashMap<>();, +                if (request.getEvaluationRequest() == null) {, +                    throw new IllegalStateException("Cannot evaluate ranking if neither template nor evaluation request is ", +++ b/modules/rank-eval/src/main/java/org/elasticsearch/index/rankeval/RatedRequest.java, +    /**, +     * Search request to execute for this rated request. This can be null in, +     * case the query is supplied as a template with corresponding parameters, +     */, +    private final SearchSourceBuilder evaluationRequest;, +    /**, +     * Create a rated request with template ids and parameters., +     *, +     * @param id a unique name for this rated request, +     * @param ratedDocs a list of document ratings, +     * @param params template parameters, +     * @param templateId a templare id, +     */, +    public RatedRequest(String id, List<RatedDocument> ratedDocs, Map<String, Object> params,, +            String templateId) {, +        this(id, ratedDocs, null, params, templateId);, +    }, +, +    /**, +     * Create a rated request using a {@link SearchSourceBuilder} to define the, +     * evaluated query., +     *, +     * @param id a unique name for this rated request, +     * @param ratedDocs a list of document ratings, +     * @param evaluatedQuery the query that is evaluated, +     */, +    public RatedRequest(String id, List<RatedDocument> ratedDocs, SearchSourceBuilder evaluatedQuery) {, +        this(id, ratedDocs, evaluatedQuery, new HashMap<>(), null);, +    }, +, +    private RatedRequest(String id, List<RatedDocument> ratedDocs, SearchSourceBuilder evaluatedQuery,, +        if (params != null && (params.size() > 0 && evaluatedQuery != null)) {, +                    "Ambiguous rated request: Set both, verbatim test request and test request " + "template parameters.");, +        if (templateId != null && evaluatedQuery != null) {, +                    "Ambiguous rated request: Set both, verbatim test request and test request " + "template parameters.");, +        if ((params == null || params.size() < 1) && evaluatedQuery == null) {, +            throw new IllegalArgumentException("Need to set at least test request or test request template parameters.");, +            throw new IllegalArgumentException("If template parameters are supplied need to set id of template to apply " + "them to too.");, +        validateEvaluatedQuery(evaluatedQuery);, +, +        this.evaluationRequest = evaluatedQuery;, +    static void validateEvaluatedQuery(SearchSourceBuilder evaluationRequest) {, +        // ensure that testRequest, if set, does not contain aggregation, suggest or highlighting section, +        if (evaluationRequest != null) {, +            if (evaluationRequest.suggest() != null) {, +                throw new IllegalArgumentException("Query in rated requests should not contain a suggest section.");, +            }, +            if (evaluationRequest.aggregations() != null) {, +                throw new IllegalArgumentException("Query in rated requests should not contain aggregations.");, +            }, +            if (evaluationRequest.highlighter() != null) {, +                throw new IllegalArgumentException("Query in rated requests should not contain a highlighter section.");, +            }, +            if (evaluationRequest.explain() != null && evaluationRequest.explain()) {, +                throw new IllegalArgumentException("Query in rated requests should not use explain.");, +            }, +            if (evaluationRequest.profile()) {, +                throw new IllegalArgumentException("Query in rated requests should not use profile.");, +            }, +        }, +    RatedRequest(StreamInput in) throws IOException {, +        evaluationRequest = in.readOptionalWriteable(SearchSourceBuilder::new);, +        out.writeOptionalWriteable(evaluationRequest);, +    public SearchSourceBuilder getEvaluationRequest() {, +        return evaluationRequest;, +        if (evaluationRequest != null) {, +            builder.field(REQUEST_FIELD.getPreferredName(), this.evaluationRequest);, +        return Objects.equals(id, other.id) && Objects.equals(evaluationRequest, other.evaluationRequest), +        return Objects.hash(id, evaluationRequest, summaryFields, ratedDocs, params,, +++ b/modules/rank-eval/src/main/java/org/elasticsearch/index/rankeval/RankEvalSpec.java, +    private final Map<String, Script> templates = new HashMap<>();, +                if (request.getEvaluationRequest() == null) {, +                    throw new IllegalStateException("Cannot evaluate ranking if neither template nor evaluation request is ", +++ b/modules/rank-eval/src/main/java/org/elasticsearch/index/rankeval/RatedRequest.java, +    /**, +     * Search request to execute for this rated request. This can be null in, +     * case the query is supplied as a template with corresponding parameters, +     */, +    private final SearchSourceBuilder evaluationRequest;, +    /**, +     * Create a rated request with template ids and parameters., +     *, +     * @param id a unique name for this rated request, +     * @param ratedDocs a list of document ratings, +     * @param params template parameters, +     * @param templateId a templare id, +     */, +    public RatedRequest(String id, List<RatedDocument> ratedDocs, Map<String, Object> params,, +            String templateId) {, +        this(id, ratedDocs, null, params, templateId);, +    }]