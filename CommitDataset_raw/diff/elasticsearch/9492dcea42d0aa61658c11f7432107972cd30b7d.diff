[+++ b/client/rest-high-level/src/main/java/org/elasticsearch/client/indices/IndexTemplateMetaData.java, +import org.elasticsearch.common.ParseField;, +import org.elasticsearch.common.xcontent.ConstructingObjectParser;, +import java.util.AbstractMap;, +import java.util.stream.Collectors;, +, +import static org.elasticsearch.common.xcontent.ConstructingObjectParser.optionalConstructorArg;, +    @SuppressWarnings("unchecked"), +    private static final ConstructingObjectParser<IndexTemplateMetaData, String> PARSER = new ConstructingObjectParser<>(, +        "IndexTemplateMetaData", true, (a, name) -> {, +        List<Map.Entry<String, AliasMetaData>> alias = (List<Map.Entry<String, AliasMetaData>>) a[5];, +        ImmutableOpenMap<String, AliasMetaData> aliasMap =, +            new ImmutableOpenMap.Builder<String, AliasMetaData>(), +                .putAll(alias.stream().collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue))), +                .build();, +        return new IndexTemplateMetaData(, +            name,, +            (Integer) a[0],, +            (Integer) a[1],, +            (List<String>) a[2],, +            (Settings) a[3],, +            (MappingMetaData) a[4],, +            aliasMap);, +    });, +, +    static {, +        PARSER.declareInt(optionalConstructorArg(), new ParseField("order"));, +        PARSER.declareInt(optionalConstructorArg(), new ParseField("version"));, +        PARSER.declareStringArray(optionalConstructorArg(), new ParseField("index_patterns"));, +        PARSER.declareObject(optionalConstructorArg(), (p, c) -> {, +            Settings.Builder templateSettingsBuilder = Settings.builder();, +            templateSettingsBuilder.put(Settings.fromXContent(p));, +            templateSettingsBuilder.normalizePrefix(IndexMetaData.INDEX_SETTING_PREFIX);, +            return templateSettingsBuilder.build();, +        }, new ParseField("settings"));, +        PARSER.declareObject(optionalConstructorArg(), (p, c) -> {, +            Map<String, Object> mapping = p.map();, +            if (mapping.isEmpty()) {, +                return null;, +            }, +            return new MappingMetaData(MapperService.SINGLE_MAPPING_NAME, mapping);, +        }, new ParseField("mappings"));, +        PARSER.declareNamedObjects(optionalConstructorArg(),, +            (p, c, name) -> new AbstractMap.SimpleEntry<>(name, AliasMetaData.Builder.fromXContent(p)), new ParseField("aliases"));, +    }, +        return order == that.order &&, +            Objects.equals(name, that.name) &&, +            Objects.equals(version, that.version) &&, +            Objects.equals(patterns, that.patterns) &&, +            Objects.equals(settings, that.settings) &&, +            Objects.equals(mappings, that.mappings) &&, +            Objects.equals(aliases, that.aliases);, +        return Objects.hash(name, order, version, patterns, settings, mappings, aliases);, +            return PARSER.parse(parser, templateName);, +++ b/client/rest-high-level/src/main/java/org/elasticsearch/client/indices/IndexTemplateMetaData.java, +import org.elasticsearch.common.ParseField;, +import org.elasticsearch.common.xcontent.ConstructingObjectParser;, +import java.util.AbstractMap;, +import java.util.stream.Collectors;, +, +import static org.elasticsearch.common.xcontent.ConstructingObjectParser.optionalConstructorArg;, +    @SuppressWarnings("unchecked"), +    private static final ConstructingObjectParser<IndexTemplateMetaData, String> PARSER = new ConstructingObjectParser<>(, +        "IndexTemplateMetaData", true, (a, name) -> {, +        List<Map.Entry<String, AliasMetaData>> alias = (List<Map.Entry<String, AliasMetaData>>) a[5];, +        ImmutableOpenMap<String, AliasMetaData> aliasMap =, +            new ImmutableOpenMap.Builder<String, AliasMetaData>(), +                .putAll(alias.stream().collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue))), +                .build();, +        return new IndexTemplateMetaData(, +            name,, +            (Integer) a[0],, +            (Integer) a[1],, +            (List<String>) a[2],, +            (Settings) a[3],, +            (MappingMetaData) a[4],, +            aliasMap);, +    });, +, +    static {, +        PARSER.declareInt(optionalConstructorArg(), new ParseField("order"));, +        PARSER.declareInt(optionalConstructorArg(), new ParseField("version"));, +        PARSER.declareStringArray(optionalConstructorArg(), new ParseField("index_patterns"));, +        PARSER.declareObject(optionalConstructorArg(), (p, c) -> {, +            Settings.Builder templateSettingsBuilder = Settings.builder();, +            templateSettingsBuilder.put(Settings.fromXContent(p));, +            templateSettingsBuilder.normalizePrefix(IndexMetaData.INDEX_SETTING_PREFIX);, +            return templateSettingsBuilder.build();, +        }, new ParseField("settings"));, +        PARSER.declareObject(optionalConstructorArg(), (p, c) -> {, +            Map<String, Object> mapping = p.map();, +            if (mapping.isEmpty()) {, +                return null;, +            }, +            return new MappingMetaData(MapperService.SINGLE_MAPPING_NAME, mapping);, +        }, new ParseField("mappings"));, +        PARSER.declareNamedObjects(optionalConstructorArg(),, +            (p, c, name) -> new AbstractMap.SimpleEntry<>(name, AliasMetaData.Builder.fromXContent(p)), new ParseField("aliases"));, +    }, +        return order == that.order &&]