[+++ b/core/src/main/java/org/elasticsearch/index/engine/InternalEngine.java, +                    flush(true, true);, +++ b/core/src/main/java/org/elasticsearch/index/engine/InternalEngine.java, +                    flush(true, true);, +++ b/core/src/main/java/org/elasticsearch/indices/IndicesService.java, +           if (nodeEnv.hasNodeFile()) {, +                final boolean isAllocated = indexService != null && indexService.hasShard(shardId.id());, +                if (isAllocated) {, +                    return false; // we are allocated - can't delete the shard, +                } else if (indexSettings.hasCustomDataPath()) {, +                    // lets see if it's on a custom path (return false if the shared doesn't exist), +                    // we don't need to delete anything that is not there, +                    // lets see if it's path is available (return false if the shared doesn't exist), +                    // we don't need to delete anything that is not there, +++ b/core/src/main/java/org/elasticsearch/index/engine/InternalEngine.java, +                    flush(true, true);, +++ b/core/src/main/java/org/elasticsearch/indices/IndicesService.java, +           if (nodeEnv.hasNodeFile()) {, +                final boolean isAllocated = indexService != null && indexService.hasShard(shardId.id());, +                if (isAllocated) {, +                    return false; // we are allocated - can't delete the shard, +                } else if (indexSettings.hasCustomDataPath()) {, +                    // lets see if it's on a custom path (return false if the shared doesn't exist), +                    // we don't need to delete anything that is not there, +                    // lets see if it's path is available (return false if the shared doesn't exist), +                    // we don't need to delete anything that is not there, +++ b/core/src/main/java/org/elasticsearch/search/sort/FieldSortBuilder.java, +public class FieldSortBuilder extends SortBuilder<FieldSortBuilder> {, +     * @param fieldName The field name., +     * Specifying a type tells Elasticsearch what type the sort values should have, which is important, +     * for cross-index search, if there are sort fields that exist on some indices only., +     * If the unmapped type is <tt>null</tt> then query execution will fail if one or more indices, +     * don't have a mapping for the current field., +     * Defines what values to pick in the case a document contains multiple values for the targeted sort field., +     * Possible values: min, max, sum and avg, +     * Sets the nested filter that the nested objects should match with in order to be taken into account, +     * for sorting., +     * Sets the nested path if sorting occurs on a field that is inside a nested object. By default when sorting on a, +     * field inside a nested object, the nearest upper nested object is selected as nested path., +            builder.field("missing", missing);, +            builder.field(SortParseElement.UNMAPPED_TYPE.getPreferredName(), unmappedType);, +            builder.field("mode", sortMode);, +            builder.field("nested_filter", nestedFilter, params);, +            builder.field("nested_path", nestedPath);, +++ b/core/src/main/java/org/elasticsearch/index/engine/InternalEngine.java, +                    flush(true, true);, +++ b/core/src/main/java/org/elasticsearch/indices/IndicesService.java, +           if (nodeEnv.hasNodeFile()) {, +                final boolean isAllocated = indexService != null && indexService.hasShard(shardId.id());, +                if (isAllocated) {, +                    return false; // we are allocated - can't delete the shard, +                } else if (indexSettings.hasCustomDataPath()) {, +                    // lets see if it's on a custom path (return false if the shared doesn't exist), +                    // we don't need to delete anything that is not there, +                    // lets see if it's path is available (return false if the shared doesn't exist), +                    // we don't need to delete anything that is not there, +++ b/core/src/main/java/org/elasticsearch/search/sort/FieldSortBuilder.java, +public class FieldSortBuilder extends SortBuilder<FieldSortBuilder> {, +     * @param fieldName The field name., +     * Specifying a type tells Elasticsearch what type the sort values should have, which is important, +     * for cross-index search, if there are sort fields that exist on some indices only., +     * If the unmapped type is <tt>null</tt> then query execution will fail if one or more indices, +     * don't have a mapping for the current field., +     * Defines what values to pick in the case a document contains multiple values for the targeted sort field., +     * Possible values: min, max, sum and avg, +     * Sets the nested filter that the nested objects should match with in order to be taken into account, +     * for sorting., +     * Sets the nested path if sorting occurs on a field that is inside a nested object. By default when sorting on a, +     * field inside a nested object, the nearest upper nested object is selected as nested path., +            builder.field("missing", missing);, +            builder.field(SortParseElement.UNMAPPED_TYPE.getPreferredName(), unmappedType);, +            builder.field("mode", sortMode);, +            builder.field("nested_filter", nestedFilter, params);, +            builder.field("nested_path", nestedPath);, +++ b/core/src/main/java/org/elasticsearch/search/sort/GeoDistanceSortBuilder.java, +import org.elasticsearch.common.io.stream.NamedWriteable;, +import org.elasticsearch.common.xcontent.ToXContent;, +public class GeoDistanceSortBuilder extends SortBuilder<GeoDistanceSortBuilder>, +        implements ToXContent, NamedWriteable<GeoDistanceSortBuilder>, SortElementParserTemp<GeoDistanceSortBuilder> {, +++ b/core/src/main/java/org/elasticsearch/index/engine/InternalEngine.java, +                    flush(true, true);, +++ b/core/src/main/java/org/elasticsearch/indices/IndicesService.java, +           if (nodeEnv.hasNodeFile()) {, +                final boolean isAllocated = indexService != null && indexService.hasShard(shardId.id());, +                if (isAllocated) {, +                    return false; // we are allocated - can't delete the shard, +                } else if (indexSettings.hasCustomDataPath()) {, +                    // lets see if it's on a custom path (return false if the shared doesn't exist), +                    // we don't need to delete anything that is not there, +                    // lets see if it's path is available (return false if the shared doesn't exist), +                    // we don't need to delete anything that is not there, +++ b/core/src/main/java/org/elasticsearch/search/sort/FieldSortBuilder.java, +public class FieldSortBuilder extends SortBuilder<FieldSortBuilder> {, +     * @param fieldName The field name., +     * Specifying a type tells Elasticsearch what type the sort values should have, which is important, +     * for cross-index search, if there are sort fields that exist on some indices only., +     * If the unmapped type is <tt>null</tt> then query execution will fail if one or more indices, +     * don't have a mapping for the current field., +     * Defines what values to pick in the case a document contains multiple values for the targeted sort field., +     * Possible values: min, max, sum and avg]