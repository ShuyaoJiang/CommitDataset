[+++ b/docs/en/rest-api/watcher/ack-watch.asciidoc, +IMPORTANT: If the specified watch is currently being executed, this API will return, +an error. The reason for this is to prevent overwriting of the watch status from a watch, +execution., +, +++ b/docs/en/rest-api/watcher/ack-watch.asciidoc, +IMPORTANT: If the specified watch is currently being executed, this API will return, +an error. The reason for this is to prevent overwriting of the watch status from a watch, +execution., +, +++ b/plugin/watcher/src/main/java/org/elasticsearch/xpack/watcher/transport/actions/ack/TransportAckWatchAction.java, +import org.elasticsearch.ElasticsearchStatusException;, +import org.elasticsearch.rest.RestStatus;, +import org.elasticsearch.xpack.core.watcher.execution.WatchExecutionSnapshot;, +import org.elasticsearch.xpack.watcher.execution.ExecutionService;, +    private ExecutionService executionService;, +                                   WatchParser parser, ExecutionService executionService, Client client) {, +        this.executionService = executionService;, +        // if the watch to be acked is running currently, reject this request, +        List<WatchExecutionSnapshot> snapshots = executionService.currentExecutions();, +        boolean isWatchRunning = snapshots.stream().anyMatch(s -> s.watchId().equals(request.getWatchId()));, +        if (isWatchRunning) {, +            listener.onFailure(new ElasticsearchStatusException("watch[{}] is running currently, cannot ack until finished",, +                    RestStatus.CONFLICT, request.getWatchId()));, +            return;, +        }, +, +++ b/docs/en/rest-api/watcher/ack-watch.asciidoc, +IMPORTANT: If the specified watch is currently being executed, this API will return, +an error. The reason for this is to prevent overwriting of the watch status from a watch, +execution., +, +++ b/plugin/watcher/src/main/java/org/elasticsearch/xpack/watcher/transport/actions/ack/TransportAckWatchAction.java, +import org.elasticsearch.ElasticsearchStatusException;, +import org.elasticsearch.rest.RestStatus;, +import org.elasticsearch.xpack.core.watcher.execution.WatchExecutionSnapshot;, +import org.elasticsearch.xpack.watcher.execution.ExecutionService;, +    private ExecutionService executionService;, +                                   WatchParser parser, ExecutionService executionService, Client client) {, +        this.executionService = executionService;, +        // if the watch to be acked is running currently, reject this request, +        List<WatchExecutionSnapshot> snapshots = executionService.currentExecutions();, +        boolean isWatchRunning = snapshots.stream().anyMatch(s -> s.watchId().equals(request.getWatchId()));, +        if (isWatchRunning) {, +            listener.onFailure(new ElasticsearchStatusException("watch[{}] is running currently, cannot ack until finished",, +                    RestStatus.CONFLICT, request.getWatchId()));, +            return;, +        }, +, +++ b/plugin/watcher/src/test/java/org/elasticsearch/xpack/watcher/transport/actions/ack/TransportAckWatchActionTests.java, +/*, + * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one, + * or more contributor license agreements. Licensed under the Elastic License;, + * you may not use this file except in compliance with the Elastic License., + */, +package org.elasticsearch.xpack.watcher.transport.actions.ack;, +, +import org.elasticsearch.ElasticsearchException;, +import org.elasticsearch.action.ActionListener;, +import org.elasticsearch.action.get.GetResponse;, +import org.elasticsearch.action.support.ActionFilters;, +import org.elasticsearch.action.support.PlainActionFuture;, +import org.elasticsearch.client.Client;, +import org.elasticsearch.cluster.metadata.IndexNameExpressionResolver;, +import org.elasticsearch.common.bytes.BytesArray;, +import org.elasticsearch.common.settings.Settings;, +import org.elasticsearch.common.util.concurrent.ThreadContext;, +import org.elasticsearch.index.get.GetResult;, +import org.elasticsearch.license.XPackLicenseState;, +import org.elasticsearch.rest.RestStatus;, +import org.elasticsearch.test.ESTestCase;, +import org.elasticsearch.threadpool.ThreadPool;, +import org.elasticsearch.transport.TransportService;, +import org.elasticsearch.xpack.core.watcher.execution.WatchExecutionSnapshot;, +import org.elasticsearch.xpack.core.watcher.transport.actions.ack.AckWatchRequest;, +import org.elasticsearch.xpack.core.watcher.transport.actions.ack.AckWatchResponse;, +import org.elasticsearch.xpack.core.watcher.watch.Watch;, +import org.elasticsearch.xpack.watcher.execution.ExecutionService;, +import org.elasticsearch.xpack.watcher.watch.WatchParser;, +import org.junit.Before;, +, +import java.time.Clock;, +import java.util.Collections;, +import java.util.concurrent.ExecutionException;, +, +import static org.hamcrest.Matchers.is;, +import static org.mockito.Matchers.anyObject;, +import static org.mockito.Mockito.doAnswer;, +import static org.mockito.Mockito.mock;, +import static org.mockito.Mockito.when;, +, +public class TransportAckWatchActionTests extends ESTestCase {, +, +    private TransportAckWatchAction action;, +    private ExecutionService executionService;, +    private Client client;, +, +    @Before, +    public void setupAction() {, +        TransportService transportService = mock(TransportService.class);]