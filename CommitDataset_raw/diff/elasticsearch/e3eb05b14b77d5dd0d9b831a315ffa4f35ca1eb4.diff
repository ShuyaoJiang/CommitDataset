[+++ b/server/src/main/java/org/elasticsearch/search/aggregations/bucket/histogram/InternalDateHistogram.java, +    final EmptyBucketInfo emptyBucketInfo;, +++ b/server/src/main/java/org/elasticsearch/search/aggregations/bucket/histogram/InternalDateHistogram.java, +    final EmptyBucketInfo emptyBucketInfo;, +++ b/server/src/test/java/org/elasticsearch/search/aggregations/bucket/histogram/InternalDateHistogramTests.java, +import org.elasticsearch.common.rounding.Rounding;, +import org.elasticsearch.common.unit.TimeValue;, +import org.elasticsearch.test.InternalMultiBucketAggregationTestCase;, +    private long intervalMillis;, +    private long baseMillis;, +    private long minDocCount;, +    private InternalDateHistogram.EmptyBucketInfo emptyBucketInfo;, +        //in order for reduction to work properly (and be realistic) we need to use the same interval, minDocCount, emptyBucketInfo, +        //and base in all randomly created aggs as part of the same test run. This is particularly important when minDocCount is, +        //set to 0 as empty buckets need to be added to fill the holes., +        long interval = randomIntBetween(1, 3);, +        intervalMillis = randomFrom(timeValueSeconds(interval), timeValueMinutes(interval), timeValueHours(interval)).getMillis();, +        Rounding rounding = Rounding.builder(TimeValue.timeValueMillis(intervalMillis)).build();, +        baseMillis = rounding.round(System.currentTimeMillis());, +        if (randomBoolean()) {, +            minDocCount = randomIntBetween(1, 10);, +            emptyBucketInfo = null;, +        } else {, +            minDocCount = 0;, +            ExtendedBounds extendedBounds = null;, +            if (randomBoolean()) {, +                //it's ok if min and max are outside the range of the generated buckets, that will just mean that, +                //empty buckets won't be added before the first bucket and/or after the last one, +                long min = baseMillis - intervalMillis * randomNumberOfBuckets();, +                long max = baseMillis + randomNumberOfBuckets() * intervalMillis + randomNumberOfBuckets();, +                extendedBounds = new ExtendedBounds(min, max);, +            }, +            emptyBucketInfo = new InternalDateHistogram.EmptyBucketInfo(rounding, InternalAggregations.EMPTY, extendedBounds);, +        }, +        //avoid having different random instance start from exactly the same base, +        long startingDate = baseMillis - intervalMillis * randomIntBetween(0, 100);, +            //rarely leave some holes to be filled up with empty buckets in case minDocCount is set to 0, +            if (frequently()) {, +                long key = startingDate + intervalMillis * i;, +                buckets.add(new InternalDateHistogram.Bucket(key, randomIntBetween(1, 100), keyed, format, aggregations));, +        }, +        BucketOrder order = BucketOrder.key(randomBoolean());, +        return new InternalDateHistogram(name, buckets, order, minDocCount, 0L, emptyBucketInfo, format, keyed,, +            pipelineAggregators, metaData);, +        TreeMap<Long, Long> expectedCounts = new TreeMap<>();, +        if (minDocCount == 0) {, +            long minBound = -1;, +            long maxBound = -1;, +            if (emptyBucketInfo.bounds != null) {, +                minBound = emptyBucketInfo.rounding.round(emptyBucketInfo.bounds.getMin());, +                maxBound = emptyBucketInfo.rounding.round(emptyBucketInfo.bounds.getMax());, +                if (expectedCounts.isEmpty() && minBound <= maxBound) {, +                    expectedCounts.put(minBound, 0L);, +                }, +            }, +            if (expectedCounts.isEmpty() == false) {, +                Long nextKey = expectedCounts.firstKey();, +                while (nextKey < expectedCounts.lastKey()) {, +                    expectedCounts.putIfAbsent(nextKey, 0L);, +                    nextKey += intervalMillis;, +                }, +                if (emptyBucketInfo.bounds != null) {, +                    while (minBound < expectedCounts.firstKey()) {, +                        expectedCounts.put(expectedCounts.firstKey() - intervalMillis, 0L);, +                    }, +                    while (expectedCounts.lastKey() < maxBound) {, +                        expectedCounts.put(expectedCounts.lastKey() + intervalMillis, 0L);, +                    }, +                }, +            }, +        } else {, +            expectedCounts.entrySet().removeIf(doubleLongEntry -> doubleLongEntry.getValue() < minDocCount);, +        }, +, +        InternalDateHistogram.EmptyBucketInfo emptyBucketInfo = instance.emptyBucketInfo;, +            emptyBucketInfo = null;, +        return new InternalDateHistogram(name, buckets, order, minDocCount, offset, emptyBucketInfo, format, keyed, pipelineAggregators,, +++ b/server/src/main/java/org/elasticsearch/search/aggregations/bucket/histogram/InternalDateHistogram.java, +    final EmptyBucketInfo emptyBucketInfo;, +++ b/server/src/test/java/org/elasticsearch/search/aggregations/bucket/histogram/InternalDateHistogramTests.java, +import org.elasticsearch.common.rounding.Rounding;, +import org.elasticsearch.common.unit.TimeValue;, +import org.elasticsearch.test.InternalMultiBucketAggregationTestCase;, +    private long intervalMillis;, +    private long baseMillis;, +    private long minDocCount;, +    private InternalDateHistogram.EmptyBucketInfo emptyBucketInfo;, +        //in order for reduction to work properly (and be realistic) we need to use the same interval, minDocCount, emptyBucketInfo, +        //and base in all randomly created aggs as part of the same test run. This is particularly important when minDocCount is, +        //set to 0 as empty buckets need to be added to fill the holes., +        long interval = randomIntBetween(1, 3);, +        intervalMillis = randomFrom(timeValueSeconds(interval), timeValueMinutes(interval), timeValueHours(interval)).getMillis();, +        Rounding rounding = Rounding.builder(TimeValue.timeValueMillis(intervalMillis)).build();, +        baseMillis = rounding.round(System.currentTimeMillis());, +        if (randomBoolean()) {, +            minDocCount = randomIntBetween(1, 10);, +            emptyBucketInfo = null;, +        } else {, +            minDocCount = 0;, +            ExtendedBounds extendedBounds = null;]