[+++ b/core/src/main/java/org/elasticsearch/cluster/ClusterModule.java, +        registerIndexDynamicSetting(IndexSettings.INDEX_FLUSH_ON_CLOSE, Validator.BOOLEAN);, +++ b/core/src/main/java/org/elasticsearch/cluster/ClusterModule.java, +        registerIndexDynamicSetting(IndexSettings.INDEX_FLUSH_ON_CLOSE, Validator.BOOLEAN);, +++ b/core/src/main/java/org/elasticsearch/common/cache/Cache.java, +     * @param key    the key whose associated value is to be returned or computed for if non-existent, +++ b/core/src/main/java/org/elasticsearch/cluster/ClusterModule.java, +        registerIndexDynamicSetting(IndexSettings.INDEX_FLUSH_ON_CLOSE, Validator.BOOLEAN);, +++ b/core/src/main/java/org/elasticsearch/common/cache/Cache.java, +     * @param key    the key whose associated value is to be returned or computed for if non-existent, +++ b/core/src/main/java/org/elasticsearch/index/IndexSettings.java, +     * Index setting to control if a flush is executed before engine is closed, +     * This setting is realtime updateable., +    private volatile boolean flushOnClose = true;, +        final boolean flushOnClose = settings.getAsBoolean(INDEX_FLUSH_ON_CLOSE, this.flushOnClose);, +        if (flushOnClose != this.flushOnClose) {, +            logger.info("updating {} from [{}] to [{}]", INDEX_FLUSH_ON_CLOSE, this.flushOnClose, flushOnClose);, +            this.flushOnClose = flushOnClose;, +        }, +, +++ b/core/src/main/java/org/elasticsearch/cluster/ClusterModule.java, +        registerIndexDynamicSetting(IndexSettings.INDEX_FLUSH_ON_CLOSE, Validator.BOOLEAN);, +++ b/core/src/main/java/org/elasticsearch/common/cache/Cache.java, +     * @param key    the key whose associated value is to be returned or computed for if non-existent, +++ b/core/src/main/java/org/elasticsearch/index/IndexSettings.java, +     * Index setting to control if a flush is executed before engine is closed, +     * This setting is realtime updateable., +    private volatile boolean flushOnClose = true;, +        final boolean flushOnClose = settings.getAsBoolean(INDEX_FLUSH_ON_CLOSE, this.flushOnClose);, +        if (flushOnClose != this.flushOnClose) {, +            logger.info("updating {} from [{}] to [{}]", INDEX_FLUSH_ON_CLOSE, this.flushOnClose, flushOnClose);, +            this.flushOnClose = flushOnClose;, +        }, +, +++ b/core/src/test/java/org/elasticsearch/index/shard/IndexShardTests.java, +        boolean initValue = randomBoolean();, +        createIndex("test", settingsBuilder().put(IndexSettings.INDEX_FLUSH_ON_CLOSE, initValue).build());, +        assertEquals(initValue, shard.getIndexSettings().isFlushOnClose());, +        final boolean newValue = !initValue;, +        assertAcked(client().admin().indices().prepareUpdateSettings("test").setSettings(settingsBuilder().put(IndexSettings.INDEX_FLUSH_ON_CLOSE, newValue).build()));, +        assertEquals(newValue, shard.getIndexSettings().isFlushOnClose());, +, +        try {, +            assertAcked(client().admin().indices().prepareUpdateSettings("test").setSettings(settingsBuilder().put(IndexSettings.INDEX_FLUSH_ON_CLOSE, "FOOBAR").build()));, +            fail("exception expected");, +        } catch (IllegalArgumentException ex) {, +, +        }, +        assertEquals(newValue, shard.getIndexSettings().isFlushOnClose());, +]