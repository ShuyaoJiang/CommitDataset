[+++ b/modules/elasticsearch/src/main/java/org/elasticsearch/cluster/metadata/MappingMetaData.java, +import org.elasticsearch.common.xcontent.XContentHelper;, +    /**, +     * Converts the serialized compressed form of the mappings into a parsed map., +     */, +    public Map<String, Object> sourceAsMap() throws IOException {, +        Map<String, Object> mapping = XContentHelper.convertToMap(source.compressed(), 0, source.compressed().length).v2();, +        if (mapping.size() == 1 && mapping.containsKey(type())) {, +            // the type name is the root value, reduce it, +            mapping = (Map<String, Object>) mapping.get(type());, +        }, +        return mapping;, +    }, +, +    /**, +     * Converts the serialized compressed form of the mappings into a parsed map., +     */, +    public Map<String, Object> getSourceAsMap() throws IOException {, +        return sourceAsMap();, +    }, +, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/cluster/metadata/MappingMetaData.java, +import org.elasticsearch.common.xcontent.XContentHelper;, +    /**, +     * Converts the serialized compressed form of the mappings into a parsed map., +     */, +    public Map<String, Object> sourceAsMap() throws IOException {, +        Map<String, Object> mapping = XContentHelper.convertToMap(source.compressed(), 0, source.compressed().length).v2();, +        if (mapping.size() == 1 && mapping.containsKey(type())) {, +            // the type name is the root value, reduce it, +            mapping = (Map<String, Object>) mapping.get(type());, +        }, +        return mapping;, +    }, +, +    /**, +     * Converts the serialized compressed form of the mappings into a parsed map., +     */, +    public Map<String, Object> getSourceAsMap() throws IOException {, +        return sourceAsMap();, +    }, +, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/common/xcontent/XContentHelper.java, +import org.elasticsearch.ElasticSearchParseException;, +import org.elasticsearch.common.collect.Tuple;, +import org.elasticsearch.common.compress.lzf.LZF;, +import org.elasticsearch.common.io.stream.BytesStreamInput;, +import org.elasticsearch.common.io.stream.CachedStreamInput;, +import org.elasticsearch.common.io.stream.LZFStreamInput;, +    public static XContentParser createParser(byte[] data, int offset, int length) throws IOException {, +        if (LZF.isCompressed(data, offset, length)) {, +            BytesStreamInput siBytes = new BytesStreamInput(data, offset, length);, +            LZFStreamInput siLzf = CachedStreamInput.cachedLzf(siBytes);, +            XContentType contentType = XContentFactory.xContentType(siLzf);, +            siLzf.resetToBufferStart();, +            return XContentFactory.xContent(contentType).createParser(siLzf);, +        } else {, +            return XContentFactory.xContent(data, offset, length).createParser(data, offset, length);, +        }, +    }, +, +    public static Tuple<XContentType, Map<String, Object>> convertToMap(byte[] data, int offset, int length) throws ElasticSearchParseException {, +        try {, +            if (LZF.isCompressed(data, offset, length)) {, +                BytesStreamInput siBytes = new BytesStreamInput(data, offset, length);, +                LZFStreamInput siLzf = CachedStreamInput.cachedLzf(siBytes);, +                XContentType contentType = XContentFactory.xContentType(siLzf);, +                siLzf.resetToBufferStart();, +                return Tuple.create(contentType, XContentFactory.xContent(contentType).createParser(siLzf).mapAndClose());, +            } else {, +                XContentType contentType = XContentFactory.xContentType(data, offset, length);, +                return Tuple.create(contentType, XContentFactory.xContent(contentType).createParser(data, offset, length).mapAndClose());, +            }, +        } catch (IOException e) {, +            throw new ElasticSearchParseException("Failed to parse content to map", e);, +        }, +    }, +, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/cluster/metadata/MappingMetaData.java, +import org.elasticsearch.common.xcontent.XContentHelper;, +    /**, +     * Converts the serialized compressed form of the mappings into a parsed map., +     */, +    public Map<String, Object> sourceAsMap() throws IOException {, +        Map<String, Object> mapping = XContentHelper.convertToMap(source.compressed(), 0, source.compressed().length).v2();, +        if (mapping.size() == 1 && mapping.containsKey(type())) {, +            // the type name is the root value, reduce it, +            mapping = (Map<String, Object>) mapping.get(type());, +        }, +        return mapping;, +    }, +, +    /**, +     * Converts the serialized compressed form of the mappings into a parsed map., +     */, +    public Map<String, Object> getSourceAsMap() throws IOException {, +        return sourceAsMap();, +    }, +, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/common/xcontent/XContentHelper.java]