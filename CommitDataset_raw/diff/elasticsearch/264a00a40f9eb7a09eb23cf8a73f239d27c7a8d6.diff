[+++ b/docs/reference/query-dsl/filters/regexp-filter.asciidoc, +See <<regexp-syntax>> for details of the supported regular expression language., +, +++ b/docs/reference/query-dsl/filters/regexp-filter.asciidoc, +See <<regexp-syntax>> for details of the supported regular expression language., +, +++ b/docs/reference/query-dsl/queries.asciidoc, +++ b/docs/reference/query-dsl/filters/regexp-filter.asciidoc, +See <<regexp-syntax>> for details of the supported regular expression language., +, +++ b/docs/reference/query-dsl/queries.asciidoc, +++ b/docs/reference/query-dsl/queries/query-string-query.asciidoc, +|`query` |The actual query to be parsed. See <<query-string-syntax>>., +include::query-string-syntax.asciidoc[], +++ b/docs/reference/query-dsl/filters/regexp-filter.asciidoc, +See <<regexp-syntax>> for details of the supported regular expression language., +, +++ b/docs/reference/query-dsl/queries.asciidoc, +++ b/docs/reference/query-dsl/queries/query-string-query.asciidoc, +|`query` |The actual query to be parsed. See <<query-string-syntax>>., +include::query-string-syntax.asciidoc[], +++ b/docs/reference/query-dsl/queries/query-string-syntax.asciidoc, +[[query-string-syntax]], +, +==== Query string syntax, +, +The query string ``mini-language'' is used by the, +<<query-dsl-query-string-query>> and <<query-dsl-field-query>>, by the, +`q` query string parameter in the <<search-search,`search` API>> and, +by the `percolate` parameter  in the <<docs-index_,`index`>> and, +<<docs-bulk,`bulk`>> APIs., +, +The query string is parsed into a series of _terms_ and _operators_. A, +term can be a single word -- `quick` or `brown` -- or a phrase, surrounded by, +double quotes -- `"quick brown"` -- which searches for all the words in the, +phrase, in the same order., +, +Operators allow you to customize the search -- the available options are, +explained below., +, +===== Field names, +, +As mentioned in <<query-dsl-query-string-query>>, the `default_field` is searched for the, +search terms, but it is possible to specify other fields in the query syntax:, +, +* where the `status` field contains `active`, +, +    status:active, +, +* where the `title` field contains `quick` or `brown`, +, +    title:(quick brown), +, +* where the `author` field contains the exact phrase `"john smith"`, +, +    author:"John Smith", +, +* where any of the fields `book.title`, `book.content` or `book.date` contains, +  `quick` or `brown` (note how we need to escape the `*` with a backslash):, +, +    book.\*:(quick brown), +, +* where the field `title` has no value (or is missing):, +, +    _missing_:title, +, +* where the field `title` has any non-null value:, +, +    _exists_:title, +, +===== Wildcards, +, +Wildcard searches can be run on individual terms, using `?` to replace, +a single character, and `*` to replace zero or more characters:, +, +    qu?ck bro*, +, +Be aware that wildcard queries can use an enormous amount of memory and, +perform very badly -- just think how many terms need to be queried to, +match the query string `"a* b* c*"`., +, +[WARNING], +======, +Allowing a wildcard at the beginning of a word (eg `"*ing"`) is particularly, +heavy, because all terms in the index need to be examined, just in case, +they match.  Leading wildcards can be disabled by setting, +`allow_leading_wildcard` to `false`., +======, +, +Wildcarded terms are not analyzed by default -- they are lowercased, +(`lowercase_expanded_terms` defaults to `true`) but no further analysis, +is done, mainly because it is impossible to accurately analyze a word that, +is missing some of its letters.  However, by setting `analyze_wildcard` to, +`true`, an attempt will be made to analyze wildcarded words before searching, +the term list for matching terms., +, +===== Regular expressions, +, +Regular expression patterns can be embedded in the query string by, +wrapping them in forward-slashes (`"/"`):]