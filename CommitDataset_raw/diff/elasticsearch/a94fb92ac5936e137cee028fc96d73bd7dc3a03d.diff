[+++ b/src/main/java/org/elasticsearch/index/fielddata/SortingNumericDocValues.java, +    private int count;, +     * Set the {@link #count()} and ensure that the {@link #values} array can, +     * store at least that many entries., +    protected final void resize(int newSize) {, +        count = newSize;, +++ b/src/main/java/org/elasticsearch/index/fielddata/SortingNumericDocValues.java, +    private int count;, +     * Set the {@link #count()} and ensure that the {@link #values} array can, +     * store at least that many entries., +    protected final void resize(int newSize) {, +        count = newSize;, +++ b/src/main/java/org/elasticsearch/search/aggregations/bucket/geogrid/GeoHashGridParser.java, +                resize(geoValues.count());, +                for (int i = 0; i < count(); ++i) {, +++ b/src/main/java/org/elasticsearch/index/fielddata/SortingNumericDocValues.java, +    private int count;, +     * Set the {@link #count()} and ensure that the {@link #values} array can, +     * store at least that many entries., +    protected final void resize(int newSize) {, +        count = newSize;, +++ b/src/main/java/org/elasticsearch/search/aggregations/bucket/geogrid/GeoHashGridParser.java, +                resize(geoValues.count());, +                for (int i = 0; i < count(); ++i) {, +++ b/src/main/java/org/elasticsearch/search/aggregations/support/ValuesSource.java, +                    resize(source.longValues().count());, +                    for (int i = 0; i < count(); ++i) {, +++ b/src/main/java/org/elasticsearch/index/fielddata/SortingNumericDocValues.java, +    private int count;, +     * Set the {@link #count()} and ensure that the {@link #values} array can, +     * store at least that many entries., +    protected final void resize(int newSize) {, +        count = newSize;, +++ b/src/main/java/org/elasticsearch/search/aggregations/bucket/geogrid/GeoHashGridParser.java, +                resize(geoValues.count());, +                for (int i = 0; i < count(); ++i) {, +++ b/src/main/java/org/elasticsearch/search/aggregations/support/ValuesSource.java, +                    resize(source.longValues().count());, +                    for (int i = 0; i < count(); ++i) {, +++ b/src/main/java/org/elasticsearch/search/aggregations/support/values/ScriptLongValues.java, +            resize(0);, +            resize(1);, +            resize(Array.getLength(value));, +            for (int i = 0; i < count(); ++i) {, +            resize(((Collection<?>) value).size());, +            assert i == count();, +++ b/src/main/java/org/elasticsearch/index/fielddata/SortingNumericDocValues.java, +    private int count;, +     * Set the {@link #count()} and ensure that the {@link #values} array can, +     * store at least that many entries., +    protected final void resize(int newSize) {, +        count = newSize;, +++ b/src/main/java/org/elasticsearch/search/aggregations/bucket/geogrid/GeoHashGridParser.java, +                resize(geoValues.count());, +                for (int i = 0; i < count(); ++i) {, +++ b/src/main/java/org/elasticsearch/search/aggregations/support/ValuesSource.java, +                    resize(source.longValues().count());, +                    for (int i = 0; i < count(); ++i) {, +++ b/src/main/java/org/elasticsearch/search/aggregations/support/values/ScriptLongValues.java, +            resize(0);, +            resize(1);, +            resize(Array.getLength(value));, +            for (int i = 0; i < count(); ++i) {, +            resize(((Collection<?>) value).size());, +            assert i == count();, +++ b/src/test/java/org/elasticsearch/search/aggregations/bucket/GeoHashGridTests.java, +import java.util.Arrays;, +import java.util.HashSet;, +import java.util.Set;, +    static ObjectIntMap<String> expectedDocCountsForGeoHash = null;, +    static ObjectIntMap<String> multiValuedExpectedDocCountsForGeoHash = null;, +    static int highestPrecisionGeohash = 12;, +    static int numDocs = 100;, +, +    static String smallestGeoHash = null;, +, +    private static IndexRequestBuilder indexCity(String index, String name, List<String> latLon) throws Exception {, +        return client().prepareIndex(index, "type").setSource(source);, +    private static IndexRequestBuilder indexCity(String index, String name, String latLon) throws Exception {, +        return indexCity(index, name, Arrays.<String>asList(latLon));, +    }, +        createIndex("idx_unmapped");, +, +        expectedDocCountsForGeoHash = new ObjectIntOpenHashMap<>(numDocs * 2);, +        for (int i = 0; i < numDocs; i++) {, +            cities.add(indexCity("idx", randomGeoHash, lat + ", " + lng));, +, +        assertAcked(prepareCreate("multi_valued_idx"), +                .addMapping("type", "location", "type=geo_point", "city", "type=string,index=not_analyzed"));, +, +        cities = new ArrayList<>();, +        multiValuedExpectedDocCountsForGeoHash = new ObjectIntOpenHashMap<>(numDocs * 2);, +        for (int i = 0; i < numDocs; i++) {, +            final int numPoints = random.nextInt(4);, +            List<String> points = new ArrayList<>();, +            // TODO (#8512): this should be a Set, not a List. Currently if a document has two positions that have, +            // the same geo hash, it will increase the doc_count for this geo hash by 2 instead of 1, +            List<String> geoHashes = new ArrayList<>();, +            for (int j = 0; j < numPoints; ++j) {, +                double lat = (180d * random.nextDouble()) - 90d;]