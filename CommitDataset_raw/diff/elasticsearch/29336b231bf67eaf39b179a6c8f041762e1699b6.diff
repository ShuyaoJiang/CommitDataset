[+++ b/core/src/main/java/org/elasticsearch/search/SearchService.java, +        context.incRef();, +        context.incRef();, +        context.incRef();, +        context.incRef();, +            contextProcessing(context);, +            context.searcher().setAggregatedDfs(request.dfs());, +, +        context.incRef();, +            contextProcessing(context);, +        context.incRef();, +        try {, +        context.incRef();, +            contextProcessing(context);, +        context.incRef();, +            contextProcessing(context);, +            assert context.refCount() > 0 : " refCount must be > 0: " + context.refCount();, +        try {, +        } finally {, +            context.decRef();, +        }, +++ b/core/src/main/java/org/elasticsearch/search/SearchService.java, +        context.incRef();, +        context.incRef();, +        context.incRef();, +        context.incRef();, +            contextProcessing(context);, +            context.searcher().setAggregatedDfs(request.dfs());, +, +        context.incRef();, +            contextProcessing(context);, +        context.incRef();, +        try {, +        context.incRef();, +            contextProcessing(context);, +        context.incRef();, +            contextProcessing(context);, +            assert context.refCount() > 0 : " refCount must be > 0: " + context.refCount();, +        try {, +        } finally {, +            context.decRef();, +        }, +++ b/core/src/main/java/org/elasticsearch/search/internal/SearchContext.java, +import org.apache.lucene.store.AlreadyClosedException;, +import org.apache.lucene.util.RefCount;, +import org.elasticsearch.common.util.concurrent.AbstractRefCounted;, +import org.elasticsearch.common.util.concurrent.RefCounted;, +/**, + * This class encapsulates the state needed to execute a search. It holds a reference to the, + * shards point in time snapshot (IndexReader / ContextIndexSearcher) and allows passing on, + * state from one query / fetch phase to another., + *, + * This class also implements {@link RefCounted} since in some situations like in {@link org.elasticsearch.search.SearchService}, + * a SearchContext can be closed concurrently due to independent events ie. when an index gets removed. To prevent accessing closed, + * IndexReader / IndexSearcher instances the SearchContext can be guarded by a reference count and fail if it's been closed by, + * an external event., + */, +// For reference why we use RefCounted here see #20095, +public abstract class SearchContext extends AbstractRefCounted implements Releasable {, +        super("search_context");, +        if (closed.compareAndSet(false, true)) { // prevent double closing, +            decRef();, +        }, +    }, +, +    private boolean nowInMillisUsed;, +, +    @Override, +    protected final void closeInternal() {, +    @Override, +    protected void alreadyClosed() {, +        throw new IllegalStateException("search context is already closed can't increment refCount current count [" + refCount() + "]");, +    }, +++ b/core/src/main/java/org/elasticsearch/search/SearchService.java, +        context.incRef();, +        context.incRef();, +        context.incRef();, +        context.incRef();, +            contextProcessing(context);, +            context.searcher().setAggregatedDfs(request.dfs());, +, +        context.incRef();, +            contextProcessing(context);, +        context.incRef();, +        try {, +        context.incRef();, +            contextProcessing(context);, +        context.incRef();, +            contextProcessing(context);, +            assert context.refCount() > 0 : " refCount must be > 0: " + context.refCount();, +        try {, +        } finally {, +            context.decRef();, +        }, +++ b/core/src/main/java/org/elasticsearch/search/internal/SearchContext.java, +import org.apache.lucene.store.AlreadyClosedException;, +import org.apache.lucene.util.RefCount;, +import org.elasticsearch.common.util.concurrent.AbstractRefCounted;, +import org.elasticsearch.common.util.concurrent.RefCounted;, +/**]