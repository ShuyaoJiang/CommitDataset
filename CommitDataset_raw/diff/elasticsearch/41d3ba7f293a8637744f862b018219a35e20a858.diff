[+++ b/src/test/java/org/elasticsearch/cluster/ack/AckTests.java, +        createIndex("test");, +        createIndex("test");, +        createIndex("test");, +        createIndex("test");, +        createIndex("test");, +        ensureGreen("test"); // make sure that recovery from disk has completed, so that check index doesn't fail., +++ b/src/test/java/org/elasticsearch/cluster/ack/AckTests.java, +        createIndex("test");, +        createIndex("test");, +        createIndex("test");, +        createIndex("test");, +        createIndex("test");, +        ensureGreen("test"); // make sure that recovery from disk has completed, so that check index doesn't fail., +++ b/src/test/java/org/elasticsearch/gateway/local/SimpleRecoveryLocalGatewayTests.java, +import org.elasticsearch.test.store.MockFSDirectoryService;, +                .put(MockFSDirectoryService.CHECK_INDEX_ON_CLOSE, false), +++ b/src/test/java/org/elasticsearch/cluster/ack/AckTests.java, +        createIndex("test");, +        createIndex("test");, +        createIndex("test");, +        createIndex("test");, +        createIndex("test");, +        ensureGreen("test"); // make sure that recovery from disk has completed, so that check index doesn't fail., +++ b/src/test/java/org/elasticsearch/gateway/local/SimpleRecoveryLocalGatewayTests.java, +import org.elasticsearch.test.store.MockFSDirectoryService;, +                .put(MockFSDirectoryService.CHECK_INDEX_ON_CLOSE, false), +++ b/src/test/java/org/elasticsearch/test/store/MockFSDirectoryService.java, +import org.elasticsearch.index.engine.Engine;, +import org.elasticsearch.index.shard.IndexShardState;, +import java.util.EnumSet;, +    private static final EnumSet<IndexShardState> validCheckIndexStates = EnumSet.of(, +            IndexShardState.STARTED, IndexShardState.RELOCATED , IndexShardState.POST_RECOVERY, +    );, +, +        checkIndexOnClose = indexSettings.getAsBoolean(CHECK_INDEX_ON_CLOSE, true);, +, +                boolean canRun = false;, +, +                @Override, +                public void beforeIndexShardClosed(ShardId sid, @Nullable IndexShard indexShard) {, +                    if (indexShard != null && shardId.equals(sid)) {, +                        logger.info("Shard state before potentially flushing is {}", indexShard.state());, +                        if (validCheckIndexStates.contains(indexShard.state())) {, +                            canRun = true;, +                            // When the the internal engine closes we do a rollback, which removes uncommitted segments, +                            // By doing a commit flush we perform a Lucene commit, but don't clear the translog,, +                            // so that even in tests where don't flush we can check the integrity of the Lucene index, +                            indexShard.flush(, +                                    new Engine.Flush(), +                                            .type(Engine.Flush.Type.COMMIT) // Keep translog for tests that rely on replaying it, +                                            .waitIfOngoing(true), +                            );, +                        }, +                    }, +                }, +, +                    if (shardId.equals(sid) && indexShard != null && canRun) {, +                        assert indexShard.state() == IndexShardState.CLOSED : "Current state must be closed";]