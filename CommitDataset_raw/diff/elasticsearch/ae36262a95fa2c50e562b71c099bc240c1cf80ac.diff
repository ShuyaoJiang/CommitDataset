[+++ b/core/src/main/java/org/elasticsearch/index/mapper/DocumentParser.java, +import java.io.Closeable;, +import java.io.IOException;, +import java.util.ArrayList;, +import java.util.Collections;, +import java.util.HashSet;, +import java.util.Iterator;, +import java.util.List;, +import java.util.Set;, +, +import org.elasticsearch.common.settings.Settings;, +final class DocumentParser implements Closeable {, +        ParsedDocument doc = parsedDocument(source, context, createDynamicUpdate(mapping, docMapper, context.getDynamicMappers()));, +            parseObjectOrNested(context, mapping.root, true);, +    /** Creates a Mapping containing any dynamically added fields, or returns null if there were no dynamic mappings. */, +    static Mapping createDynamicUpdate(Mapping mapping, DocumentMapper docMapper, List<Mapper> dynamicMappers) {, +        if (dynamicMappers.isEmpty()) {, +            return null;, +        }, +        // We build a mapping by first sorting the mappers, so that all mappers containing a common prefix, +        // will be processed in a contiguous block. When the prefix is no longer seen, we pop the extra elements, +        // off the stack, merging them upwards into the existing mappers., +        Collections.sort(dynamicMappers, (Mapper o1, Mapper o2) -> o1.name().compareTo(o2.name()));, +        Iterator<Mapper> dynamicMapperItr = dynamicMappers.iterator();, +        List<ObjectMapper> parentMappers = new ArrayList<>();, +        Mapper firstUpdate = dynamicMapperItr.next();, +        parentMappers.add(createUpdate(mapping.root(), firstUpdate.name().split("\\."), 0, firstUpdate));, +        Mapper previousMapper = null;, +        while (dynamicMapperItr.hasNext()) {, +            Mapper newMapper = dynamicMapperItr.next();, +            if (previousMapper != null && newMapper.name().equals(previousMapper.name())) {, +                // We can see the same mapper more than once, for example, if we had foo.bar and foo.baz, where, +                // foo did not yet exist. This will create 2 copies in dynamic mappings, which should be identical., +                // Here we just skip over the duplicates, but we merge them to ensure there are no conflicts., +                newMapper.merge(previousMapper, false);, +                continue;, +            }, +            previousMapper = newMapper;, +            String[] nameParts = newMapper.name().split("\\.");, +            // find common elements with the previously processed dynamic mapper, +            int keepBefore = 1;, +            while (keepBefore < parentMappers.size() &&, +                   parentMappers.get(keepBefore).simpleName().equals(nameParts[keepBefore - 1])) {, +                ++keepBefore;, +            }, +            popMappers(parentMappers, keepBefore, true);, +, +            if (keepBefore < nameParts.length) {, +                String updateParentName = nameParts[keepBefore - 1];, +                final ObjectMapper lastParent = parentMappers.get(parentMappers.size() - 1);, +                Mapper updateParent = lastParent.getMapper(updateParentName);, +                if (updateParent == null) {, +                    // the parent we need is not on the stack, so look it up in the full mappings, +                    if (keepBefore > 1) {, +                        // only prefix with parent mapper if the parent mapper isn't the root (which has a fake name), +                        updateParentName = lastParent.name() + '.' + updateParentName;, +                    }, +                    updateParent = docMapper.objectMappers().get(updateParentName);, +                }, +                assert updateParent instanceof ObjectMapper;, +                newMapper = createUpdate((ObjectMapper)updateParent, nameParts, keepBefore, newMapper);, +            }, +, +            if (newMapper instanceof ObjectMapper) {, +                parentMappers.add((ObjectMapper)newMapper);, +            } else {, +                addToLastMapper(parentMappers, newMapper, true);, +            }, +        }, +        popMappers(parentMappers, 1, true);, +        assert parentMappers.size() == 1;, +, +        return mapping.mappingUpdate(parentMappers.get(0));, +    }, +, +    private static void popMappers(List<ObjectMapper> parentMappers, int keepBefore, boolean merge) {, +        assert keepBefore >= 1; // never remove the root mapper, +        // pop off parent mappers not needed by the current mapper,, +        // merging them backwards since they are immutable, +        for (int i = parentMappers.size() - 1; i >= keepBefore; --i) {, +            addToLastMapper(parentMappers, parentMappers.remove(i), merge);, +        }, +    }, +, +    /**, +     * Adds a mapper as an update into the last mapper. If merge is true, the new mapper, +     * will be merged in with other child mappers of the last parent, otherwise it will be a new update., +     */, +    private static void addToLastMapper(List<ObjectMapper> parentMappers, Mapper mapper, boolean merge) {, +        assert parentMappers.size() >= 1;, +        int lastIndex = parentMappers.size() - 1;, +        ObjectMapper withNewMapper = parentMappers.get(lastIndex).mappingUpdate(mapper);, +        if (merge) {, +            withNewMapper = parentMappers.get(lastIndex).merge(withNewMapper, false);, +        }, +        parentMappers.set(lastIndex, withNewMapper);, +    }, +, +    /** Build an update for the parent which will contain the given mapper and any intermediate fields. */, +    private static ObjectMapper createUpdate(ObjectMapper parent, String[] nameParts, int i, Mapper mapper) {]