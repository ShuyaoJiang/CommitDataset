[+++ b/marvel/src/main/java/org/elasticsearch/marvel/MarvelPlugin.java, +import org.elasticsearch.marvel.shield.MarvelInternalUserHolder;, +import org.elasticsearch.marvel.shield.MarvelShieldIntegration;, +import org.elasticsearch.shield.authz.AuthorizationModule;, +    // NOTE: The fact this signature takes a module is a hack, and effectively like the previous, +    // processModule in the plugin api. The problem is tight coupling between marvel and shield., +    // We need to avoid trying to load the AuthorizationModule class unless we know shield integration, +    // is enabled. This is a temporary solution until inter-plugin-communication can be worked out., +    public void onModule(Module module) {, +        if (enabled && MarvelShieldIntegration.enabled(settings) && module instanceof AuthorizationModule) {, +            ((AuthorizationModule)module).registerReservedRole(MarvelInternalUserHolder.ROLE);, +        }, +    }, +, +++ b/marvel/src/main/java/org/elasticsearch/marvel/MarvelPlugin.java, +import org.elasticsearch.marvel.shield.MarvelInternalUserHolder;, +import org.elasticsearch.marvel.shield.MarvelShieldIntegration;, +import org.elasticsearch.shield.authz.AuthorizationModule;, +    // NOTE: The fact this signature takes a module is a hack, and effectively like the previous, +    // processModule in the plugin api. The problem is tight coupling between marvel and shield., +    // We need to avoid trying to load the AuthorizationModule class unless we know shield integration, +    // is enabled. This is a temporary solution until inter-plugin-communication can be worked out., +    public void onModule(Module module) {, +        if (enabled && MarvelShieldIntegration.enabled(settings) && module instanceof AuthorizationModule) {, +            ((AuthorizationModule)module).registerReservedRole(MarvelInternalUserHolder.ROLE);, +        }, +    }, +, +++ b/marvel/src/main/java/org/elasticsearch/marvel/license/LicenseService.java, +import org.elasticsearch.common.logging.support.LoggerMessageFormat;, +    static final TimeValue GRACE_PERIOD = days(7);, +, +                new LicensesService.ExpirationCallback.Post(days(0), GRACE_PERIOD, minutes(10)) {, +                        long endOfGracePeriod = license.expiryDate() + GRACE_PERIOD.getMillis();, +                                "# MARVEL LICENSE HAS EXPIRED ON [{}].\n" +, +                                "# MARVEL WILL STOP COLLECTING DATA ON [{}].\n" +, +                                "#", DATE_FORMATTER.printer().print(endOfGracePeriod), DATE_FORMATTER.printer().print(license.expiryDate()));, +                switch (newLicense.type()) {, +, +                    case "trial":, +                    case "gold":, +                    case "platinum":, +, +                    default: // "basic" - we also fall back to basic for an unknown type, +                        return Collections.singletonList(LoggerMessageFormat.format(, +                                "Marvel: Multi-cluster support is disabled for clusters with [{}] licenses.\n" +, +                                "If you are running multiple customers, users won't be able to access this\n" +, +                                "all the clusters with [{}] licenses from a single Marvel instance. To access them\n" +, +                                "a dedicated and separated marvel instance will be required for each cluster",, +                                newLicense.type(), newLicense.type()));, +                }, +++ b/marvel/src/main/java/org/elasticsearch/marvel/MarvelPlugin.java, +import org.elasticsearch.marvel.shield.MarvelInternalUserHolder;, +import org.elasticsearch.marvel.shield.MarvelShieldIntegration;, +import org.elasticsearch.shield.authz.AuthorizationModule;, +    // NOTE: The fact this signature takes a module is a hack, and effectively like the previous, +    // processModule in the plugin api. The problem is tight coupling between marvel and shield., +    // We need to avoid trying to load the AuthorizationModule class unless we know shield integration, +    // is enabled. This is a temporary solution until inter-plugin-communication can be worked out., +    public void onModule(Module module) {, +        if (enabled && MarvelShieldIntegration.enabled(settings) && module instanceof AuthorizationModule) {, +            ((AuthorizationModule)module).registerReservedRole(MarvelInternalUserHolder.ROLE);, +        }, +    }, +, +++ b/marvel/src/main/java/org/elasticsearch/marvel/license/LicenseService.java, +import org.elasticsearch.common.logging.support.LoggerMessageFormat;, +    static final TimeValue GRACE_PERIOD = days(7);, +, +                new LicensesService.ExpirationCallback.Post(days(0), GRACE_PERIOD, minutes(10)) {, +                        long endOfGracePeriod = license.expiryDate() + GRACE_PERIOD.getMillis();, +                                "# MARVEL LICENSE HAS EXPIRED ON [{}].\n" +, +                                "# MARVEL WILL STOP COLLECTING DATA ON [{}].\n" +, +                                "#", DATE_FORMATTER.printer().print(endOfGracePeriod), DATE_FORMATTER.printer().print(license.expiryDate()));, +                switch (newLicense.type()) {, +, +                    case "trial":, +                    case "gold":, +                    case "platinum":, +, +                    default: // "basic" - we also fall back to basic for an unknown type, +                        return Collections.singletonList(LoggerMessageFormat.format(, +                                "Marvel: Multi-cluster support is disabled for clusters with [{}] licenses.\n" +, +                                "If you are running multiple customers, users won't be able to access this\n" +, +                                "all the clusters with [{}] licenses from a single Marvel instance. To access them\n" +, +                                "a dedicated and separated marvel instance will be required for each cluster",, +                                newLicense.type(), newLicense.type()));, +                }, +++ b/marvel/src/main/java/org/elasticsearch/marvel/shield/MarvelShieldModule.java, +++ b/marvel/src/main/java/org/elasticsearch/marvel/MarvelPlugin.java, +import org.elasticsearch.marvel.shield.MarvelInternalUserHolder;, +import org.elasticsearch.marvel.shield.MarvelShieldIntegration;, +import org.elasticsearch.shield.authz.AuthorizationModule;, +    // NOTE: The fact this signature takes a module is a hack, and effectively like the previous, +    // processModule in the plugin api. The problem is tight coupling between marvel and shield., +    // We need to avoid trying to load the AuthorizationModule class unless we know shield integration, +    // is enabled. This is a temporary solution until inter-plugin-communication can be worked out., +    public void onModule(Module module) {, +        if (enabled && MarvelShieldIntegration.enabled(settings) && module instanceof AuthorizationModule) {, +            ((AuthorizationModule)module).registerReservedRole(MarvelInternalUserHolder.ROLE);]