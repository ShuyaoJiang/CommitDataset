[+++ b/core/src/main/java/org/elasticsearch/action/percolate/TransportPercolateAction.java, +import org.elasticsearch.action.ShardOperationFailedException;, +import org.elasticsearch.action.search.ShardSearchFailure;, +import org.elasticsearch.action.support.DefaultShardOperationFailedException;, +import java.util.ArrayList;, +import java.util.List;, +        PercolatorQueryBuilder percolatorQueryBuilder =, +                new PercolatorQueryBuilder("query", percolateRequest.documentType(), documentSource);, +        List<ShardOperationFailedException> shardFailures = new ArrayList<>(searchResponse.getShardFailures().length);, +        for (ShardSearchFailure shardSearchFailure : searchResponse.getShardFailures()) {, +            shardFailures.add(new DefaultShardOperationFailedException(shardSearchFailure.index(), shardSearchFailure.shardId(),, +                    shardSearchFailure.getCause()));, +        }, +, +            shardFailures, matches, hits.getTotalHits(), searchResponse.getTookInMillis(), (InternalAggregations) searchResponse.getAggregations(), +++ b/core/src/main/java/org/elasticsearch/action/percolate/TransportPercolateAction.java, +import org.elasticsearch.action.ShardOperationFailedException;, +import org.elasticsearch.action.search.ShardSearchFailure;, +import org.elasticsearch.action.support.DefaultShardOperationFailedException;, +import java.util.ArrayList;, +import java.util.List;, +        PercolatorQueryBuilder percolatorQueryBuilder =, +                new PercolatorQueryBuilder("query", percolateRequest.documentType(), documentSource);, +        List<ShardOperationFailedException> shardFailures = new ArrayList<>(searchResponse.getShardFailures().length);, +        for (ShardSearchFailure shardSearchFailure : searchResponse.getShardFailures()) {, +            shardFailures.add(new DefaultShardOperationFailedException(shardSearchFailure.index(), shardSearchFailure.shardId(),, +                    shardSearchFailure.getCause()));, +        }, +, +            shardFailures, matches, hits.getTotalHits(), searchResponse.getTookInMillis(), (InternalAggregations) searchResponse.getAggregations(), +++ b/core/src/main/java/org/elasticsearch/index/mapper/MapperService.java, +import org.apache.lucene.document.FieldType;, +import org.elasticsearch.Version;, +            logger.trace("using dynamic[{}], default mapping source[{}]", dynamic, defaultMappingSource);, +            checkPercolatorFieldLimit(fieldTypes);, +        boolean legacyIndex = getIndexSettings().getIndexVersionCreated().before(Version.V_5_0_0_alpha1);, +        if (legacyIndex) {, +            return mapper.type().startsWith(".") && !PercolatorFieldMapper.LEGACY_TYPE_NAME.equals(mapper.type());, +        } else {, +            return mapper.type().startsWith(".");, +        }, +    /**, +     * We only allow upto 1 percolator field per index., +     *, +     * Reasoning here is that the PercolatorQueryCache only supports a single document having a percolator query., +     * Also specifying multiple queries per document feels like an anti pattern, +     */, +    private void checkPercolatorFieldLimit(Iterable<MappedFieldType> fieldTypes) {, +        List<String> percolatorFieldTypes = new ArrayList<>();, +        for (MappedFieldType fieldType : fieldTypes) {, +            if (fieldType instanceof PercolatorFieldMapper.PercolatorFieldType) {, +                percolatorFieldTypes.add(fieldType.name());, +        }, +        if (percolatorFieldTypes.size() > 1) {, +            throw new IllegalArgumentException("Up to one percolator field type is allowed per index, " +, +                    "found the following percolator fields [" + percolatorFieldTypes + "]");, +        }, +    }, +, +    public DocumentMapper parse(String mappingType, CompressedXContent mappingSource, boolean applyDefault) throws MapperParsingException {, +++ b/core/src/main/java/org/elasticsearch/action/percolate/TransportPercolateAction.java, +import org.elasticsearch.action.ShardOperationFailedException;, +import org.elasticsearch.action.search.ShardSearchFailure;, +import org.elasticsearch.action.support.DefaultShardOperationFailedException;, +import java.util.ArrayList;, +import java.util.List;, +        PercolatorQueryBuilder percolatorQueryBuilder =, +                new PercolatorQueryBuilder("query", percolateRequest.documentType(), documentSource);, +        List<ShardOperationFailedException> shardFailures = new ArrayList<>(searchResponse.getShardFailures().length);, +        for (ShardSearchFailure shardSearchFailure : searchResponse.getShardFailures()) {, +            shardFailures.add(new DefaultShardOperationFailedException(shardSearchFailure.index(), shardSearchFailure.shardId(),, +                    shardSearchFailure.getCause()));, +        }, +, +            shardFailures, matches, hits.getTotalHits(), searchResponse.getTookInMillis(), (InternalAggregations) searchResponse.getAggregations(), +++ b/core/src/main/java/org/elasticsearch/index/mapper/MapperService.java, +import org.apache.lucene.document.FieldType;, +import org.elasticsearch.Version;, +            logger.trace("using dynamic[{}], default mapping source[{}]", dynamic, defaultMappingSource);, +            checkPercolatorFieldLimit(fieldTypes);, +        boolean legacyIndex = getIndexSettings().getIndexVersionCreated().before(Version.V_5_0_0_alpha1);, +        if (legacyIndex) {, +            return mapper.type().startsWith(".") && !PercolatorFieldMapper.LEGACY_TYPE_NAME.equals(mapper.type());, +        } else {, +            return mapper.type().startsWith(".");, +        }, +    /**, +     * We only allow upto 1 percolator field per index., +     *, +     * Reasoning here is that the PercolatorQueryCache only supports a single document having a percolator query., +     * Also specifying multiple queries per document feels like an anti pattern, +     */, +    private void checkPercolatorFieldLimit(Iterable<MappedFieldType> fieldTypes) {, +        List<String> percolatorFieldTypes = new ArrayList<>();, +        for (MappedFieldType fieldType : fieldTypes) {, +            if (fieldType instanceof PercolatorFieldMapper.PercolatorFieldType) {, +                percolatorFieldTypes.add(fieldType.name());, +        }, +        if (percolatorFieldTypes.size() > 1) {, +            throw new IllegalArgumentException("Up to one percolator field type is allowed per index, " +]