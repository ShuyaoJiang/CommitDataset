[+++ b/src/main/java/org/elasticsearch/action/bulk/BulkProcessor.java, +            boolean afterCalled = false;, +                BulkResponse bulkItemResponses = client.bulk(bulkRequest).actionGet();, +                afterCalled = true;, +                listener.afterBulk(executionId, bulkRequest, bulkItemResponses);, +                if (!afterCalled) {, +            }, +                semaphore.acquire();, +            } catch (Throwable t) {, +                listener.afterBulk(executionId, bulkRequest, t);, +++ b/src/main/java/org/elasticsearch/action/bulk/BulkProcessor.java, +            boolean afterCalled = false;, +                BulkResponse bulkItemResponses = client.bulk(bulkRequest).actionGet();, +                afterCalled = true;, +                listener.afterBulk(executionId, bulkRequest, bulkItemResponses);, +                if (!afterCalled) {, +            }, +                semaphore.acquire();, +            } catch (Throwable t) {, +                listener.afterBulk(executionId, bulkRequest, t);, +++ b/src/test/java/org/elasticsearch/action/bulk/BulkProcessorTests.java, +/*, + * Licensed to Elasticsearch under one or more contributor, + * license agreements. See the NOTICE file distributed with, + * this work for additional information regarding copyright, + * ownership. Elasticsearch licenses this file to you under, + * the Apache License, Version 2.0 (the "License"); you may, + * not use this file except in compliance with the License., + * You may obtain a copy of the License at, + *, + *    http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing,, + * software distributed under the License is distributed on an, + * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY, + * KIND, either express or implied.  See the License for the, + * specific language governing permissions and limitations, + * under the License., + */, +, +package org.elasticsearch.action.bulk;, +, +import org.elasticsearch.action.get.MultiGetItemResponse;, +import org.elasticsearch.action.get.MultiGetRequestBuilder;, +import org.elasticsearch.action.get.MultiGetResponse;, +import org.elasticsearch.action.index.IndexRequest;, +import org.elasticsearch.client.Client;, +import org.elasticsearch.client.transport.TransportClient;, +import org.elasticsearch.common.settings.ImmutableSettings;, +import org.elasticsearch.common.unit.ByteSizeUnit;, +import org.elasticsearch.common.unit.ByteSizeValue;, +import org.elasticsearch.common.unit.TimeValue;, +import org.elasticsearch.test.ElasticsearchIntegrationTest;, +import org.junit.Test;, +, +import java.util.Arrays;, +import java.util.HashSet;, +import java.util.List;, +import java.util.Set;, +import java.util.concurrent.CopyOnWriteArrayList;, +import java.util.concurrent.CountDownLatch;, +import java.util.concurrent.TimeUnit;, +import java.util.concurrent.atomic.AtomicInteger;, +, +import static org.elasticsearch.test.hamcrest.ElasticsearchAssertions.assertAcked;, +import static org.hamcrest.Matchers.*;, +, +public class BulkProcessorTests extends ElasticsearchIntegrationTest {, +, +    @Test, +    public void testThatBulkProcessorCountIsCorrect() throws InterruptedException {, +, +        final CountDownLatch latch = new CountDownLatch(1);, +        BulkProcessorTestListener listener = new BulkProcessorTestListener(latch);, +, +        int numDocs = randomIntBetween(10, 100);, +        try (BulkProcessor processor = BulkProcessor.builder(client(), listener).setName("foo"), +                //let's make sure that the bulk action limit trips, one single execution will index all the documents, +                .setConcurrentRequests(randomIntBetween(0, 1)).setBulkActions(numDocs), +                .setFlushInterval(TimeValue.timeValueHours(24)).setBulkSize(new ByteSizeValue(1, ByteSizeUnit.GB)), +                .build()) {, +, +            MultiGetRequestBuilder multiGetRequestBuilder = indexDocs(client(), processor, numDocs);, +, +            latch.await();, +, +            assertThat(listener.beforeCounts.get(), equalTo(1));, +            assertThat(listener.afterCounts.get(), equalTo(1));, +            assertThat(listener.bulkFailures.size(), equalTo(0));, +            assertResponseItems(listener.bulkItems, numDocs);, +            assertMultiGetResponse(multiGetRequestBuilder.get(), numDocs);, +        }, +    }, +, +    @Test, +    public void testBulkProcessorFlush() throws InterruptedException {, +        final CountDownLatch latch = new CountDownLatch(1);, +        BulkProcessorTestListener listener = new BulkProcessorTestListener(latch);, +, +        int numDocs = randomIntBetween(10, 100);]