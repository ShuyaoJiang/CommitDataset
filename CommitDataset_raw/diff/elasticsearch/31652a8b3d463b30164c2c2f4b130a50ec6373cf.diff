[+++ b/src/main/java/org/elasticsearch/gateway/GatewayAllocator.java, +                                logger.trace("{}: node [{}] has [{}/{}] bytes of re-usable data",, +                                        shard, discoNode.name(), new ByteSizeValue(sizeMatched), sizeMatched);, +                    if (logger.isDebugEnabled()) {, +            logger.trace("[{}] on node [{}] has version [{}] of shard",, +                    shard, nodeShardState.getNode(), nodeShardState.version());, +++ b/src/main/java/org/elasticsearch/gateway/GatewayAllocator.java, +                                logger.trace("{}: node [{}] has [{}/{}] bytes of re-usable data",, +                                        shard, discoNode.name(), new ByteSizeValue(sizeMatched), sizeMatched);, +                    if (logger.isDebugEnabled()) {, +            logger.trace("[{}] on node [{}] has version [{}] of shard",, +                    shard, nodeShardState.getNode(), nodeShardState.version());, +++ b/src/main/java/org/elasticsearch/gateway/MetaDataStateFormat.java, +                            PathAndVersion pav = new PathAndVersion(stateFile, version, legacy);, +                            logger.trace("found state file: {}", pav);, +                            files.add(pav);, +                    logger.trace("state version [{}] read from [{}]", version, stateFile.getFileName());, +, +        public String toString() {, +            return "[version:" + version + ", legacy:" + legacy + ", file:" + file.toAbsolutePath() + "]";, +        }, +++ b/src/main/java/org/elasticsearch/gateway/GatewayAllocator.java, +                                logger.trace("{}: node [{}] has [{}/{}] bytes of re-usable data",, +                                        shard, discoNode.name(), new ByteSizeValue(sizeMatched), sizeMatched);, +                    if (logger.isDebugEnabled()) {, +            logger.trace("[{}] on node [{}] has version [{}] of shard",, +                    shard, nodeShardState.getNode(), nodeShardState.version());, +++ b/src/main/java/org/elasticsearch/gateway/MetaDataStateFormat.java, +                            PathAndVersion pav = new PathAndVersion(stateFile, version, legacy);, +                            logger.trace("found state file: {}", pav);, +                            files.add(pav);, +                    logger.trace("state version [{}] read from [{}]", version, stateFile.getFileName());, +, +        public String toString() {, +            return "[version:" + version + ", legacy:" + legacy + ", file:" + file.toAbsolutePath() + "]";, +        }, +++ b/src/main/java/org/elasticsearch/indices/store/TransportNodesListShardStoreMetaData.java, +        Path[] shardLocations = nodeEnv.shardDataPaths(shardId, metaData.settings());, +++ b/src/main/java/org/elasticsearch/gateway/GatewayAllocator.java, +                                logger.trace("{}: node [{}] has [{}/{}] bytes of re-usable data",, +                                        shard, discoNode.name(), new ByteSizeValue(sizeMatched), sizeMatched);, +                    if (logger.isDebugEnabled()) {, +            logger.trace("[{}] on node [{}] has version [{}] of shard",, +                    shard, nodeShardState.getNode(), nodeShardState.version());, +++ b/src/main/java/org/elasticsearch/gateway/MetaDataStateFormat.java, +                            PathAndVersion pav = new PathAndVersion(stateFile, version, legacy);, +                            logger.trace("found state file: {}", pav);, +                            files.add(pav);, +                    logger.trace("state version [{}] read from [{}]", version, stateFile.getFileName());, +, +        public String toString() {, +            return "[version:" + version + ", legacy:" + legacy + ", file:" + file.toAbsolutePath() + "]";, +        }, +++ b/src/main/java/org/elasticsearch/indices/store/TransportNodesListShardStoreMetaData.java, +        Path[] shardLocations = nodeEnv.shardDataPaths(shardId, metaData.settings());, +++ b/src/test/java/org/elasticsearch/gateway/RecoveryFromGatewayTests.java, +        assertAcked(prepareCreate("test").setSettings(ImmutableSettings.builder().put(indexSettings())));, +        ensureGreen();, +        client().admin().indices().prepareFlush().setWaitIfOngoing(true).setForce(true).get();, +        logger.info("--> disabling allocation while the cluster is shut down");, +        logger.info("--> full cluster restart");, +        logger.info("--> waiting for cluster to return to green after first shutdown");, +, +        logger.info("--> disabling allocation while the cluster is shut down second time");, +        logger.info("--> full cluster restart");, +        logger.info("--> waiting for cluster to return to green after second shutdown");, +                logger.info("--> replica shard {} recovered from {} to {}, recovered {}, reuse {}",, +                        response.getShardId(), recoveryState.getSourceNode().name(), recoveryState.getTargetNode().name(),, +                        recoveryState.getIndex().recoveredTotalSize(), recoveryState.getIndex().reusedByteCount());, +                assertThat("no bytes should be recovered", recoveryState.getIndex().recoveredByteCount(), equalTo(0l));, +                assertThat("data should have been reused", recoveryState.getIndex().reusedByteCount(), greaterThan(0l));, +                assertThat("all bytes should be reused", recoveryState.getIndex().reusedByteCount(), equalTo(recoveryState.getIndex().totalByteCount()));, +                assertThat("no files should be recovered", recoveryState.getIndex().recoveredFileCount(), equalTo(0));, +                assertThat("all files should be reused", recoveryState.getIndex().reusedFileCount(), equalTo(recoveryState.getIndex().totalFileCount()));, +                assertThat("> 0 files should be reused", recoveryState.getIndex().reusedFileCount(), greaterThan(0));, +                assertThat("all bytes should be reused bytes",, +                        recoveryState.getIndex().reusedByteCount(), greaterThan(recoveryState.getIndex().numberOfRecoveredBytes()));]