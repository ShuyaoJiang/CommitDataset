[+++ b/modules/elasticsearch/src/main/java/org/elasticsearch/cluster/metadata/MetaDataCreateIndexService.java, +import org.elasticsearch.cluster.action.index.NodeIndexCreatedAction;, +import org.elasticsearch.cluster.routing.IndexShardRoutingTable;, +import org.elasticsearch.cluster.routing.ShardRouting;, +import org.elasticsearch.threadpool.ThreadPool;, +import java.util.concurrent.ScheduledFuture;, +import java.util.concurrent.atomic.AtomicBoolean;, +import java.util.concurrent.atomic.AtomicInteger;, +    private final ThreadPool threadPool;, +, +    private final NodeIndexCreatedAction nodeIndexCreatedAction;, +, +    @Inject public MetaDataCreateIndexService(Settings settings, Environment environment, ThreadPool threadPool, ClusterService clusterService, IndicesService indicesService,, +                                              ShardsAllocation shardsAllocation, NodeIndexCreatedAction nodeIndexCreatedAction, @RiverIndexName String riverIndexName) {, +        this.threadPool = threadPool;, +        this.nodeIndexCreatedAction = nodeIndexCreatedAction;, +    public void createIndex(final Request request, final Listener userListener) {, +        final CreateIndexListener listener = new CreateIndexListener(request, userListener);, +, +            final Set<String> allocatedNodes = Sets.newHashSet();, +, +                    // initialize the counter only for nodes the shards are allocated to, +                    if (updatedState.routingTable().hasIndex(request.index)) {, +                        for (IndexShardRoutingTable indexShardRoutingTable : updatedState.routingTable().index(request.index)) {, +                            for (ShardRouting shardRouting : indexShardRoutingTable) {, +                                // if we have a routing for this shard on a node, and its not the master node (since we already created, +                                // an index on it), then add it, +                                if (shardRouting.currentNodeId() != null && !updatedState.nodes().localNodeId().equals(shardRouting.currentNodeId())) {, +                                    allocatedNodes.add(shardRouting.currentNodeId());, +                                }, +                            }, +                        }, +                    }, +, +                    if (!allocatedNodes.isEmpty()) {, +                        final AtomicInteger counter = new AtomicInteger(allocatedNodes.size());, +, +                        final NodeIndexCreatedAction.Listener nodeIndexCreatedListener = new NodeIndexCreatedAction.Listener() {, +                            @Override public void onNodeIndexCreated(String index, String nodeId) {, +                                if (index.equals(request.index)) {, +                                    if (counter.decrementAndGet() == 0) {, +                                        listener.onResponse(new Response(true, indexMetaData));, +                                        nodeIndexCreatedAction.remove(this);, +                                    }, +                                }, +                            }, +                        };, +, +                        nodeIndexCreatedAction.add(nodeIndexCreatedListener);, +, +                        listener.future = threadPool.schedule(request.timeout, ThreadPool.Names.SAME, new Runnable() {, +                            @Override public void run() {, +                                listener.onResponse(new Response(false, indexMetaData));, +                                nodeIndexCreatedAction.remove(nodeIndexCreatedListener);, +                            }, +                        });, +                    }, +, +, +                if (allocatedNodes.isEmpty()) {, +            }, +    class CreateIndexListener implements Listener {, +, +        private AtomicBoolean notified = new AtomicBoolean();, +, +        private final Request request;, +, +        private final Listener listener;, +, +        volatile ScheduledFuture future;, +, +        private CreateIndexListener(Request request, Listener listener) {, +            this.request = request;, +            this.listener = listener;, +        }, +, +        @Override public void onResponse(final Response response) {, +            if (notified.compareAndSet(false, true)) {, +                if (future != null) {, +                    future.cancel(false);, +                }, +                listener.onResponse(response);, +            }, +        }, +, +        @Override public void onFailure(Throwable t) {, +            if (notified.compareAndSet(false, true)) {, +                if (future != null) {, +                    future.cancel(false);, +                }, +                listener.onFailure(t);, +            }, +        }, +    }, +, +]