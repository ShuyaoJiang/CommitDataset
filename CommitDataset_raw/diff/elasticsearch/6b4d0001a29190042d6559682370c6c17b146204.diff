[+++ b/buildSrc/src/main/resources/checkstyle_suppressions.xml, +++ b/buildSrc/src/main/resources/checkstyle_suppressions.xml, +++ b/core/src/main/java/org/elasticsearch/client/transport/TransportClient.java, +import java.util.Collection;, +import java.util.Collections;, +                Collection<Object> pluginComponents = pluginsService.createComponenents();, +                    pluginComponents.stream().forEach(p -> b.bind((Class)p.getClass()).toInstance(p));, +                List<LifecycleComponent> pluginLifecycleComponents = pluginComponents.stream(), +                    .filter(p -> p instanceof LifecycleComponent), +                    .map(p -> (LifecycleComponent)p).collect(Collectors.toList());, +                pluginLifecycleComponents.addAll(pluginsService.getGuiceServiceClasses().stream(), +                    .map(injector::getInstance).collect(Collectors.toList()));, +                resourcesToClose.addAll(pluginLifecycleComponents);, +, +, +                TransportClient transportClient = new TransportClient(injector, pluginLifecycleComponents, nodesService, proxy);, +    private final List<LifecycleComponent> pluginLifecycleComponents;, +    private TransportClient(Injector injector, List<LifecycleComponent> pluginLifecycleComponents,, +                            TransportClientNodesService nodesService, TransportProxyClient proxy) {, +        this.pluginLifecycleComponents = Collections.unmodifiableList(pluginLifecycleComponents);, +        for (LifecycleComponent plugin : pluginLifecycleComponents) {, +            closeables.add(plugin);, +++ b/buildSrc/src/main/resources/checkstyle_suppressions.xml, +++ b/core/src/main/java/org/elasticsearch/client/transport/TransportClient.java, +import java.util.Collection;, +import java.util.Collections;, +                Collection<Object> pluginComponents = pluginsService.createComponenents();, +                    pluginComponents.stream().forEach(p -> b.bind((Class)p.getClass()).toInstance(p));, +                List<LifecycleComponent> pluginLifecycleComponents = pluginComponents.stream(), +                    .filter(p -> p instanceof LifecycleComponent), +                    .map(p -> (LifecycleComponent)p).collect(Collectors.toList());, +                pluginLifecycleComponents.addAll(pluginsService.getGuiceServiceClasses().stream(), +                    .map(injector::getInstance).collect(Collectors.toList()));, +                resourcesToClose.addAll(pluginLifecycleComponents);, +, +, +                TransportClient transportClient = new TransportClient(injector, pluginLifecycleComponents, nodesService, proxy);, +    private final List<LifecycleComponent> pluginLifecycleComponents;, +    private TransportClient(Injector injector, List<LifecycleComponent> pluginLifecycleComponents,, +                            TransportClientNodesService nodesService, TransportProxyClient proxy) {, +        this.pluginLifecycleComponents = Collections.unmodifiableList(pluginLifecycleComponents);, +        for (LifecycleComponent plugin : pluginLifecycleComponents) {, +            closeables.add(plugin);, +++ b/core/src/main/java/org/elasticsearch/cluster/node/DiscoveryNode.java, +, +    /**, +     * Creates a new {@link DiscoveryNode}, +     * <p>, +     * <b>Note:</b> if the version of the node is unknown {@link Version#minimumCompatibilityVersion()} should be used for the current, +     * version. it corresponds to the minimum version this elasticsearch version can communicate with. If a higher version is used, +     * the node might not be able to communicate with the remove node. After initial handshakes node versions will be discovered, +     * and updated., +     * </p>, +     *, +     * @param id               the nodes unique (persistent) node id. This constructor will auto generate a random ephemeral id., +     * @param address          the nodes transport address, +     * @param version          the version of the node, +     */, +    public DiscoveryNode(final String id, TransportAddress address, Version version) {, +        this(id, address, Collections.emptyMap(), Collections.emptySet(), version);, +    }, +, +++ b/buildSrc/src/main/resources/checkstyle_suppressions.xml, +++ b/core/src/main/java/org/elasticsearch/client/transport/TransportClient.java, +import java.util.Collection;, +import java.util.Collections;, +                Collection<Object> pluginComponents = pluginsService.createComponenents();, +                    pluginComponents.stream().forEach(p -> b.bind((Class)p.getClass()).toInstance(p));, +                List<LifecycleComponent> pluginLifecycleComponents = pluginComponents.stream(), +                    .filter(p -> p instanceof LifecycleComponent), +                    .map(p -> (LifecycleComponent)p).collect(Collectors.toList());, +                pluginLifecycleComponents.addAll(pluginsService.getGuiceServiceClasses().stream(), +                    .map(injector::getInstance).collect(Collectors.toList()));, +                resourcesToClose.addAll(pluginLifecycleComponents);, +, +, +                TransportClient transportClient = new TransportClient(injector, pluginLifecycleComponents, nodesService, proxy);, +    private final List<LifecycleComponent> pluginLifecycleComponents;, +    private TransportClient(Injector injector, List<LifecycleComponent> pluginLifecycleComponents,, +                            TransportClientNodesService nodesService, TransportProxyClient proxy) {, +        this.pluginLifecycleComponents = Collections.unmodifiableList(pluginLifecycleComponents);, +        for (LifecycleComponent plugin : pluginLifecycleComponents) {, +            closeables.add(plugin);, +++ b/core/src/main/java/org/elasticsearch/cluster/node/DiscoveryNode.java, +, +    /**, +     * Creates a new {@link DiscoveryNode}, +     * <p>, +     * <b>Note:</b> if the version of the node is unknown {@link Version#minimumCompatibilityVersion()} should be used for the current, +     * version. it corresponds to the minimum version this elasticsearch version can communicate with. If a higher version is used, +     * the node might not be able to communicate with the remove node. After initial handshakes node versions will be discovered, +     * and updated., +     * </p>, +     *, +     * @param id               the nodes unique (persistent) node id. This constructor will auto generate a random ephemeral id., +     * @param address          the nodes transport address, +     * @param version          the version of the node, +     */, +    public DiscoveryNode(final String id, TransportAddress address, Version version) {, +        this(id, address, Collections.emptyMap(), Collections.emptySet(), version);]