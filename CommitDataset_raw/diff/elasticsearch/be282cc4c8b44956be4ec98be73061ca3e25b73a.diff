[+++ b/modules/elasticsearch/src/main/java/org/elasticsearch/search/fetch/FetchPhase.java, +                    hitContext.reset(searchHit, subReader, subDoc, context.searcher().getIndexReader(), docId, doc);, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/search/fetch/FetchPhase.java, +                    hitContext.reset(searchHit, subReader, subDoc, context.searcher().getIndexReader(), docId, doc);, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/search/fetch/FetchSubPhase.java, +import org.elasticsearch.common.collect.Maps;, +        private IndexReader topLevelReader;, +        private int topLevelDocId;, +        private Map<String, Object> cache;, +        public void reset(InternalSearchHit hit, IndexReader reader, int docId, IndexReader topLevelReader, int topLevelDocId, Document doc) {, +            this.topLevelReader = topLevelReader;, +            this.topLevelDocId = topLevelDocId;, +        public IndexReader topLevelReader() {, +            return topLevelReader;, +        }, +, +        public int topLevelDocId() {, +            return topLevelDocId;, +        }, +, +, +        public Map<String, Object> cache() {, +            if (cache == null) {, +                cache = Maps.newHashMap();, +            }, +            return cache;, +        }, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/search/fetch/FetchPhase.java, +                    hitContext.reset(searchHit, subReader, subDoc, context.searcher().getIndexReader(), docId, doc);, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/search/fetch/FetchSubPhase.java, +import org.elasticsearch.common.collect.Maps;, +        private IndexReader topLevelReader;, +        private int topLevelDocId;, +        private Map<String, Object> cache;, +        public void reset(InternalSearchHit hit, IndexReader reader, int docId, IndexReader topLevelReader, int topLevelDocId, Document doc) {, +            this.topLevelReader = topLevelReader;, +            this.topLevelDocId = topLevelDocId;, +        public IndexReader topLevelReader() {, +            return topLevelReader;, +        }, +, +        public int topLevelDocId() {, +            return topLevelDocId;, +        }, +, +, +        public Map<String, Object> cache() {, +            if (cache == null) {, +                cache = Maps.newHashMap();, +            }, +            return cache;, +        }, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/search/highlight/HighlightPhase.java, +import org.elasticsearch.common.collect.Maps;, +        // we use a cache to cache heavy things, mainly the rewrite in FieldQuery for FVH, +        Map<FieldMapper, HighlightEntry> cache = (Map<FieldMapper, HighlightEntry>) hitContext.cache().get("highlight");, +        if (cache == null) {, +            cache = Maps.newHashMap();, +            hitContext.cache().put("highlight", cache);, +        }, +, +                HighlightEntry entry = cache.get(mapper);, +                if (entry == null) {, +                    entry = new HighlightEntry();, +                    entry.highlighter = new Highlighter(formatter, encoder, queryScorer);, +                    entry.highlighter.setTextFragmenter(fragmenter);, +, +                    cache.put(mapper, entry);, +                }, +                        TextFragment[] bestTextFragments = entry.highlighter.getBestTextFragments(tokenStream, text, false, numberOfFragments);, +                try {, +                    HighlightEntry entry = cache.get(mapper);, +                    if (entry == null) {, +                        entry = new HighlightEntry();, +                        entry.fragListBuilder = fragListBuilder;, +                        entry.fragmentsBuilder = fragmentsBuilder;, +                        entry.fvh = new FastVectorHighlighter(true, false, fragListBuilder, fragmentsBuilder);, +                        CustomFieldQuery.highlightFilters.set(field.highlightFilter());, +                        // we use top level reader to rewrite the query against all readers, with use caching it across hits (and across readers...), +                        entry.fieldQuery = new CustomFieldQuery(context.parsedQuery().query(), hitContext.topLevelReader(), entry.fvh);, +, +                        cache.put(mapper, entry);, +                    }, +, +                    // we highlight against the low level reader and docId, because if we load source, we want to reuse it if possible, +                    fragments = entry.fvh.getBestFragments(entry.fieldQuery, hitContext.reader(), hitContext.docId(), mapper.names().indexName(), field.fragmentCharSize(), numberOfFragments,, +                            entry.fragListBuilder, entry.fragmentsBuilder, field.preTags(), field.postTags(), encoder);, +, +                } catch (Exception e) {, +                    throw new FetchPhaseExecutionException(context, "Failed to highlight field [" + field.field() + "]", e);, +                }, +    static class HighlightEntry {, +        public FastVectorHighlighter fvh;, +        public FieldQuery fieldQuery;, +        public FragListBuilder fragListBuilder;, +        public FragmentsBuilder fragmentsBuilder;, +, +        public Highlighter highlighter;, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/search/fetch/FetchPhase.java, +                    hitContext.reset(searchHit, subReader, subDoc, context.searcher().getIndexReader(), docId, doc);]