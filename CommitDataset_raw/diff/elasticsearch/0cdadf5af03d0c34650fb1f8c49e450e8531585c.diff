[+++ b/modules/transport-netty4/src/main/java/org/elasticsearch/transport/netty4/Netty4MessageChannelHandler.java, +import io.netty.channel.ChannelFuture;, +import io.netty.channel.ChannelPromise;, +import java.nio.channels.ClosedChannelException;, +import java.util.ArrayDeque;, +import java.util.Queue;, +    private final Queue<WriteOperation> queuedWrites = new ArrayDeque<>();, +, +    private WriteOperation currentWrite;, +, +    public void channelRead(ChannelHandlerContext ctx, Object msg) {, +        assert Transports.assertTransportThread();, +    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {, +, +    @Override, +    public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) {, +        assert msg instanceof ByteBuf;, +        final boolean queued = queuedWrites.offer(new WriteOperation((ByteBuf) msg, promise));, +        assert queued;, +    }, +, +    @Override, +    public void channelWritabilityChanged(ChannelHandlerContext ctx) {, +        if (ctx.channel().isWritable()) {, +            doFlush(ctx);, +        }, +        ctx.fireChannelWritabilityChanged();, +    }, +, +    @Override, +    public void flush(ChannelHandlerContext ctx) {, +        Channel channel = ctx.channel();, +        if (channel.isWritable() || channel.isActive() == false) {, +            doFlush(ctx);, +        }, +    }, +, +    @Override, +    public void channelInactive(ChannelHandlerContext ctx) throws Exception {, +        doFlush(ctx);, +        super.channelInactive(ctx);, +    }, +, +    private void doFlush(ChannelHandlerContext ctx) {, +        assert ctx.executor().inEventLoop();, +        final Channel channel = ctx.channel();, +        if (channel.isActive() == false) {, +            if (currentWrite != null) {, +                currentWrite.promise.tryFailure(new ClosedChannelException());, +            }, +            failQueuedWrites();, +            return;, +        }, +        while (channel.isWritable()) {, +            if (currentWrite == null) {, +                currentWrite = queuedWrites.poll();, +            }, +            if (currentWrite == null) {, +                break;, +            }, +            final WriteOperation write = currentWrite;, +            if (write.buf.readableBytes() == 0) {, +                write.promise.trySuccess();, +                currentWrite = null;, +                continue;, +            }, +            final int readableBytes = write.buf.readableBytes();, +            final int bufferSize = Math.min(readableBytes, 1 << 18);, +            final int readerIndex = write.buf.readerIndex();, +            final boolean sliced = readableBytes != bufferSize;, +            final ByteBuf writeBuffer;, +            if (sliced) {, +                writeBuffer = write.buf.retainedSlice(readerIndex, bufferSize);, +                write.buf.readerIndex(readerIndex + bufferSize);, +            } else {, +                writeBuffer = write.buf;, +            }, +            final ChannelFuture writeFuture = ctx.write(writeBuffer);, +            if (sliced == false || write.buf.readableBytes() == 0) {, +                currentWrite = null;, +                writeFuture.addListener(future -> {, +                    assert ctx.executor().inEventLoop();, +                    if (future.isSuccess()) {, +                        write.promise.trySuccess();, +                    } else {, +                        write.promise.tryFailure(future.cause());, +                    }, +                });, +            } else {, +                writeFuture.addListener(future -> {, +                    assert ctx.executor().inEventLoop();, +                    if (future.isSuccess() == false) {, +                        write.promise.tryFailure(future.cause());, +                    }, +                });, +            }, +            ctx.flush();, +            if (channel.isActive() == false) {, +                failQueuedWrites();, +                return;]