[+++ b/src/main/java/org/elasticsearch/search/aggregations/bucket/histogram/HistogramAggregator.java, +                               long initialCapacity,, +        super(name, BucketAggregationMode.PER_BUCKET, factories, initialCapacity, aggregationContext, parent);, +        bucketOrds = new LongHash(initialCapacity);, +            return new HistogramAggregator(name, factories, rounding, order, keyed, computeEmptyBuckets, null, 0, histogramFactory, aggregationContext, parent);, +            // todo if we'll keep track of min/max values in IndexFieldData, we could use the max here to come up with a better estimation for the buckets count, +            return new HistogramAggregator(name, factories, rounding, order, keyed, computeEmptyBuckets, valuesSource, 50, histogramFactory, aggregationContext, parent);, +++ b/src/main/java/org/elasticsearch/search/aggregations/bucket/histogram/HistogramAggregator.java, +                               long initialCapacity,, +        super(name, BucketAggregationMode.PER_BUCKET, factories, initialCapacity, aggregationContext, parent);, +        bucketOrds = new LongHash(initialCapacity);, +            return new HistogramAggregator(name, factories, rounding, order, keyed, computeEmptyBuckets, null, 0, histogramFactory, aggregationContext, parent);, +            // todo if we'll keep track of min/max values in IndexFieldData, we could use the max here to come up with a better estimation for the buckets count, +            return new HistogramAggregator(name, factories, rounding, order, keyed, computeEmptyBuckets, valuesSource, 50, histogramFactory, aggregationContext, parent);, +++ b/src/main/java/org/elasticsearch/search/aggregations/bucket/range/geodistance/GeoDistanceParser.java, +            FieldDataSource.Numeric distanceSource = new DistanceSource(distanceValues, valuesSource.metaData());, +            if (distanceSource.metaData().multiValued()) {, +                // we need to ensure uniqueness, +            }, +            private final MetaData metaData;, +            public DistanceSource(DoubleValues values, MetaData metaData) {, +                // even if the geo points are unique, there's no guarantee the distances are, +                this.metaData = MetaData.builder(metaData).uniqueness(MetaData.Uniqueness.UNKNOWN).build();, +            }, +, +            @Override, +            public MetaData metaData() {, +                return metaData;, +++ b/src/main/java/org/elasticsearch/search/aggregations/bucket/histogram/HistogramAggregator.java, +                               long initialCapacity,, +        super(name, BucketAggregationMode.PER_BUCKET, factories, initialCapacity, aggregationContext, parent);, +        bucketOrds = new LongHash(initialCapacity);, +            return new HistogramAggregator(name, factories, rounding, order, keyed, computeEmptyBuckets, null, 0, histogramFactory, aggregationContext, parent);, +            // todo if we'll keep track of min/max values in IndexFieldData, we could use the max here to come up with a better estimation for the buckets count, +            return new HistogramAggregator(name, factories, rounding, order, keyed, computeEmptyBuckets, valuesSource, 50, histogramFactory, aggregationContext, parent);, +++ b/src/main/java/org/elasticsearch/search/aggregations/bucket/range/geodistance/GeoDistanceParser.java, +            FieldDataSource.Numeric distanceSource = new DistanceSource(distanceValues, valuesSource.metaData());, +            if (distanceSource.metaData().multiValued()) {, +                // we need to ensure uniqueness, +            }, +            private final MetaData metaData;, +            public DistanceSource(DoubleValues values, MetaData metaData) {, +                // even if the geo points are unique, there's no guarantee the distances are, +                this.metaData = MetaData.builder(metaData).uniqueness(MetaData.Uniqueness.UNKNOWN).build();, +            }, +, +            @Override, +            public MetaData metaData() {, +                return metaData;, +++ b/src/main/java/org/elasticsearch/search/aggregations/bucket/terms/DoubleTermsAggregator.java, +    public DoubleTermsAggregator(String name, AggregatorFactories factories, NumericValuesSource valuesSource, long estimatedBucketCount,, +        super(name, BucketAggregationMode.PER_BUCKET, factories, estimatedBucketCount, aggregationContext, parent);, +        bucketOrds = new LongHash(estimatedBucketCount);, +++ b/src/main/java/org/elasticsearch/search/aggregations/bucket/histogram/HistogramAggregator.java, +                               long initialCapacity,, +        super(name, BucketAggregationMode.PER_BUCKET, factories, initialCapacity, aggregationContext, parent);, +        bucketOrds = new LongHash(initialCapacity);, +            return new HistogramAggregator(name, factories, rounding, order, keyed, computeEmptyBuckets, null, 0, histogramFactory, aggregationContext, parent);, +            // todo if we'll keep track of min/max values in IndexFieldData, we could use the max here to come up with a better estimation for the buckets count, +            return new HistogramAggregator(name, factories, rounding, order, keyed, computeEmptyBuckets, valuesSource, 50, histogramFactory, aggregationContext, parent);, +++ b/src/main/java/org/elasticsearch/search/aggregations/bucket/range/geodistance/GeoDistanceParser.java, +            FieldDataSource.Numeric distanceSource = new DistanceSource(distanceValues, valuesSource.metaData());, +            if (distanceSource.metaData().multiValued()) {, +                // we need to ensure uniqueness, +            }, +            private final MetaData metaData;, +            public DistanceSource(DoubleValues values, MetaData metaData) {, +                // even if the geo points are unique, there's no guarantee the distances are, +                this.metaData = MetaData.builder(metaData).uniqueness(MetaData.Uniqueness.UNKNOWN).build();, +            }, +, +            @Override, +            public MetaData metaData() {, +                return metaData;, +++ b/src/main/java/org/elasticsearch/search/aggregations/bucket/terms/DoubleTermsAggregator.java, +    public DoubleTermsAggregator(String name, AggregatorFactories factories, NumericValuesSource valuesSource, long estimatedBucketCount,, +        super(name, BucketAggregationMode.PER_BUCKET, factories, estimatedBucketCount, aggregationContext, parent);, +        bucketOrds = new LongHash(estimatedBucketCount);, +++ b/src/main/java/org/elasticsearch/search/aggregations/bucket/terms/LongTermsAggregator.java, +    public LongTermsAggregator(String name, AggregatorFactories factories, NumericValuesSource valuesSource, long estimatedBucketCount,, +        super(name, BucketAggregationMode.PER_BUCKET, factories, estimatedBucketCount, aggregationContext, parent);, +        bucketOrds = new LongHash(estimatedBucketCount);, +++ b/src/main/java/org/elasticsearch/search/aggregations/bucket/histogram/HistogramAggregator.java, +                               long initialCapacity,, +        super(name, BucketAggregationMode.PER_BUCKET, factories, initialCapacity, aggregationContext, parent);, +        bucketOrds = new LongHash(initialCapacity);, +            return new HistogramAggregator(name, factories, rounding, order, keyed, computeEmptyBuckets, null, 0, histogramFactory, aggregationContext, parent);, +            // todo if we'll keep track of min/max values in IndexFieldData, we could use the max here to come up with a better estimation for the buckets count, +            return new HistogramAggregator(name, factories, rounding, order, keyed, computeEmptyBuckets, valuesSource, 50, histogramFactory, aggregationContext, parent);, +++ b/src/main/java/org/elasticsearch/search/aggregations/bucket/range/geodistance/GeoDistanceParser.java, +            FieldDataSource.Numeric distanceSource = new DistanceSource(distanceValues, valuesSource.metaData());, +            if (distanceSource.metaData().multiValued()) {, +                // we need to ensure uniqueness, +            }, +            private final MetaData metaData;, +            public DistanceSource(DoubleValues values, MetaData metaData) {, +                // even if the geo points are unique, there's no guarantee the distances are, +                this.metaData = MetaData.builder(metaData).uniqueness(MetaData.Uniqueness.UNKNOWN).build();, +            }, +]