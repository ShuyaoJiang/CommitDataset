[+++ b/client/src/main/java/org/elasticsearch/client/RestClient.java, +import org.apache.commons.logging.Log;, +import org.apache.commons.logging.LogFactory;, +import org.apache.http.StatusLine;, +import org.apache.http.client.methods.CloseableHttpResponse;, +import org.apache.http.client.methods.HttpEntityEnclosingRequestBase;, +import org.apache.http.client.methods.HttpHead;, +import org.apache.http.client.methods.HttpPost;, +import org.apache.http.client.methods.HttpPut;, +import org.apache.http.client.methods.HttpRequestBase;, +import org.apache.http.client.utils.URIBuilder;, +import org.apache.http.util.EntityUtils;, +import java.net.URI;, +import java.net.URISyntaxException;, +import java.util.Iterator;, +import java.util.Locale;, +import java.util.Objects;, +import java.util.concurrent.TimeUnit;, +import java.util.stream.Stream;, +    private static final Log logger = LogFactory.getLog(RestClient.class);, +, +    private final CloseableHttpClient client;, +    private final ConnectionPool connectionPool;, +    private final long maxRetryTimeout;, +        Objects.requireNonNull(client, "client cannot be null");, +        Objects.requireNonNull(connectionPool, "connectionPool cannot be null");, +        if (maxRetryTimeout <= 0) {, +            throw new IllegalArgumentException("maxRetryTimeout must be greater than 0");, +        }, +        this.client = client;, +        this.connectionPool = connectionPool;, +        this.maxRetryTimeout = maxRetryTimeout;, +        URI uri = buildUri(endpoint, params);, +        HttpRequestBase request = createHttpRequest(method, uri, entity);, +        Iterator<Connection> connectionIterator = connectionPool.nextConnection().iterator();, +        if (connectionIterator.hasNext() == false) {, +            Connection connection = connectionPool.lastResortConnection();, +            logger.info("no healthy nodes available, trying " + connection.getHost());, +            return performRequest(request, Stream.of(connection).iterator());, +        }, +        return performRequest(request, connectionIterator);, +    }, +, +    private ElasticsearchResponse performRequest(HttpRequestBase request, Iterator<Connection> connectionIterator) throws IOException {, +        //we apply a soft margin so that e.g. if a request took 59 seconds and timeout is set to 60 we don't do another attempt, +        long retryTimeout = Math.round(this.maxRetryTimeout / (float)100 * 98);, +        IOException lastSeenException = null;, +        long startTime = System.nanoTime();, +, +        while (connectionIterator.hasNext()) {, +            Connection connection = connectionIterator.next();, +, +            if (lastSeenException != null) {, +                long timeElapsed = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startTime);, +                long timeout = retryTimeout - timeElapsed;, +                if (timeout <= 0) {, +                    IOException retryTimeoutException = new IOException(, +                            "request retries exceeded max retry timeout [" + retryTimeout + "]");, +                    retryTimeoutException.addSuppressed(lastSeenException);, +                    throw retryTimeoutException;, +                }, +            }, +, +            try {, +                connectionPool.beforeAttempt(connection);, +            } catch(IOException e) {, +                lastSeenException = addSuppressedException(lastSeenException, e);, +                continue;, +            }, +, +            try {, +                ElasticsearchResponse response = performRequest(request, connection);, +                connectionPool.onSuccess(connection);, +                return response;, +            } catch(ElasticsearchResponseException e) {, +                if (e.isRecoverable()) {, +                    connectionPool.onFailure(connection);, +                    lastSeenException = addSuppressedException(lastSeenException, e);, +                } else {, +                    //don't retry and call onSuccess as the error should be a request problem, +                    connectionPool.onSuccess(connection);, +                    throw e;, +                }, +            } catch(IOException e) {, +                connectionPool.onFailure(connection);, +                lastSeenException = addSuppressedException(lastSeenException, e);, +            }, +        }, +        assert lastSeenException != null;, +        throw lastSeenException;, +    }, +, +    private ElasticsearchResponse performRequest(HttpRequestBase request, Connection connection) throws IOException {, +        CloseableHttpResponse response;, +        try {, +            response = client.execute(connection.getHost(), request);, +        } catch(IOException e) {, +            RequestLogger.log(logger, "request failed", request.getRequestLine(), connection.getHost(), e);, +            throw e;, +        } finally {]