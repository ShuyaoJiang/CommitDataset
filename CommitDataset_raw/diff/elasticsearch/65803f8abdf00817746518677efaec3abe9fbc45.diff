[+++ b/core/src/main/java/org/elasticsearch/search/SearchModule.java, +import org.elasticsearch.search.aggregations.bucket.significant.SignificantTermsAggregatorBuilder;, +        registerAggregation(SignificantTermsAggregatorBuilder::new,, +                new SignificantTermsParser(significanceHeuristicParserMapper, queryParserRegistry),, +                SignificantTermsAggregatorBuilder.AGGREGATION_NAME_FIELD);, +++ b/core/src/main/java/org/elasticsearch/search/SearchModule.java, +import org.elasticsearch.search.aggregations.bucket.significant.SignificantTermsAggregatorBuilder;, +        registerAggregation(SignificantTermsAggregatorBuilder::new,, +                new SignificantTermsParser(significanceHeuristicParserMapper, queryParserRegistry),, +                SignificantTermsAggregatorBuilder.AGGREGATION_NAME_FIELD);, +++ b/core/src/main/java/org/elasticsearch/search/aggregations/bucket/significant/SignificantTermsAggregatorBuilder.java, +import org.elasticsearch.search.aggregations.AggregatorFactory;, +, +    public static final String NAME = SignificantStringTerms.TYPE.name();, +    public static final ParseField AGGREGATION_NAME_FIELD = new ParseField(NAME);, +    /**, +     * Read from a Stream., +     */, +    public SignificantTermsAggregatorBuilder(StreamInput in) throws IOException {, +        super(in, SignificantStringTerms.TYPE, ValuesSourceType.ANY);, +        bucketCountThresholds = BucketCountThresholds.readFromStream(in);, +        executionHint = in.readOptionalString();, +        if (in.readBoolean()) {, +            filterBuilder = in.readQuery();, +        }, +        if (in.readBoolean()) {, +            includeExclude = IncludeExclude.readFromStream(in);, +        }, +        significanceHeuristic = SignificanceHeuristicStreams.read(in);, +    }, +, +    @Override, +    protected void innerWriteTo(StreamOutput out) throws IOException {, +        bucketCountThresholds.writeTo(out);, +        out.writeOptionalString(executionHint);, +        boolean hasfilterBuilder = filterBuilder != null;, +        out.writeBoolean(hasfilterBuilder);, +        if (hasfilterBuilder) {, +            out.writeQuery(filterBuilder);, +        }, +        boolean hasIncExc = includeExclude != null;, +        out.writeBoolean(hasIncExc);, +        if (hasIncExc) {, +            includeExclude.writeTo(out);, +        }, +        SignificanceHeuristicStreams.writeTo(significanceHeuristic, out);, +    }, +, +    @Override, +    protected boolean usesNewStyleSerialization() {, +        return true;, +    }, +, +    @Override, +    protected boolean serializeTargetValueType() {, +        return true;, +    }, +, +    protected TermsAggregator.BucketCountThresholds getBucketCountThresholds() {, +        return new TermsAggregator.BucketCountThresholds(bucketCountThresholds);, +    }, +, +, +    @Override, +    public String getWriteableName() {, +        return NAME;, +    }, +++ b/core/src/main/java/org/elasticsearch/search/SearchModule.java, +import org.elasticsearch.search.aggregations.bucket.significant.SignificantTermsAggregatorBuilder;, +        registerAggregation(SignificantTermsAggregatorBuilder::new,, +                new SignificantTermsParser(significanceHeuristicParserMapper, queryParserRegistry),, +                SignificantTermsAggregatorBuilder.AGGREGATION_NAME_FIELD);, +++ b/core/src/main/java/org/elasticsearch/search/aggregations/bucket/significant/SignificantTermsAggregatorBuilder.java, +import org.elasticsearch.search.aggregations.AggregatorFactory;, +, +    public static final String NAME = SignificantStringTerms.TYPE.name();, +    public static final ParseField AGGREGATION_NAME_FIELD = new ParseField(NAME);, +    /**, +     * Read from a Stream., +     */, +    public SignificantTermsAggregatorBuilder(StreamInput in) throws IOException {, +        super(in, SignificantStringTerms.TYPE, ValuesSourceType.ANY);, +        bucketCountThresholds = BucketCountThresholds.readFromStream(in);, +        executionHint = in.readOptionalString();, +        if (in.readBoolean()) {, +            filterBuilder = in.readQuery();, +        }, +        if (in.readBoolean()) {, +            includeExclude = IncludeExclude.readFromStream(in);, +        }, +        significanceHeuristic = SignificanceHeuristicStreams.read(in);, +    }, +, +    @Override, +    protected void innerWriteTo(StreamOutput out) throws IOException {, +        bucketCountThresholds.writeTo(out);, +        out.writeOptionalString(executionHint);, +        boolean hasfilterBuilder = filterBuilder != null;, +        out.writeBoolean(hasfilterBuilder);, +        if (hasfilterBuilder) {]