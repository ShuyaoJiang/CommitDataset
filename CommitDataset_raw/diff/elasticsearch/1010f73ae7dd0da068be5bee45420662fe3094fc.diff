[+++ b/plugin/src/main/java/org/elasticsearch/xpack/ml/datafeed/DatafeedJobBuilder.java, +        // Step 3. Create data extractor factory, +++ b/plugin/src/main/java/org/elasticsearch/xpack/ml/datafeed/DatafeedJobBuilder.java, +        // Step 3. Create data extractor factory, +++ b/plugin/src/main/java/org/elasticsearch/xpack/ml/datafeed/extractor/scroll/ScrollDataExtractor.java, +import org.elasticsearch.common.inject.internal.Nullable;, +    private Long lastTimestamp;, +    private boolean searchHasShardFailure;, +        context = Objects.requireNonNull(dataExtractorContext);, +        hasNext = true;, +        searchHasShardFailure = false;, +        Optional<InputStream> stream = scrollId == null ?, +                Optional.ofNullable(initScroll(context.start)) : Optional.ofNullable(continueScroll());, +    protected InputStream initScroll(long startTimestamp) throws IOException {, +        SearchResponse searchResponse = executeSearchRequest(buildSearchRequest(startTimestamp));, +    private SearchRequestBuilder buildSearchRequest(long start) {, +                        context.query, context.extractedFields.timeField(), start, context.end));, +        if (searchResponse.getFailedShards() > 0 && searchHasShardFailure == false) {, +            // This could be a transient error with the scroll Id., +            // Reinitialise the scroll and try again but only once., +            LOGGER.debug("[{}] Resetting scroll search after shard failure", context.jobId);, +            resetScroll();, +            if (lastTimestamp != null) {, +                lastTimestamp++;, +            }, +            searchHasShardFailure = true;, +            return initScroll(lastTimestamp == null ? context.start : lastTimestamp);, +        }, +, +            SearchHit lastHit = searchResponse.getHits().getHits()[searchResponse.getHits().getHits().length -1];, +            lastTimestamp = context.extractedFields.timeFieldValue(lastHit);, +    private void resetScroll() {, +        clearScroll(scrollId);, +        scrollId = null;, +    }, +, +++ b/plugin/src/main/java/org/elasticsearch/xpack/ml/datafeed/DatafeedJobBuilder.java, +        // Step 3. Create data extractor factory, +++ b/plugin/src/main/java/org/elasticsearch/xpack/ml/datafeed/extractor/scroll/ScrollDataExtractor.java, +import org.elasticsearch.common.inject.internal.Nullable;, +    private Long lastTimestamp;, +    private boolean searchHasShardFailure;, +        context = Objects.requireNonNull(dataExtractorContext);, +        hasNext = true;, +        searchHasShardFailure = false;, +        Optional<InputStream> stream = scrollId == null ?, +                Optional.ofNullable(initScroll(context.start)) : Optional.ofNullable(continueScroll());, +    protected InputStream initScroll(long startTimestamp) throws IOException {, +        SearchResponse searchResponse = executeSearchRequest(buildSearchRequest(startTimestamp));, +    private SearchRequestBuilder buildSearchRequest(long start) {, +                        context.query, context.extractedFields.timeField(), start, context.end));, +        if (searchResponse.getFailedShards() > 0 && searchHasShardFailure == false) {, +            // This could be a transient error with the scroll Id., +            // Reinitialise the scroll and try again but only once., +            LOGGER.debug("[{}] Resetting scroll search after shard failure", context.jobId);, +            resetScroll();, +            if (lastTimestamp != null) {, +                lastTimestamp++;, +            }, +            searchHasShardFailure = true;, +            return initScroll(lastTimestamp == null ? context.start : lastTimestamp);, +        }, +, +            SearchHit lastHit = searchResponse.getHits().getHits()[searchResponse.getHits().getHits().length -1];, +            lastTimestamp = context.extractedFields.timeFieldValue(lastHit);, +    private void resetScroll() {, +        clearScroll(scrollId);, +        scrollId = null;, +    }, +, +++ b/plugin/src/test/java/org/elasticsearch/xpack/ml/datafeed/extractor/scroll/ScrollDataExtractorTests.java, +import java.util.LinkedList;, +import java.util.Queue;, +    private long initScrollStartTime;, +        private Queue<SearchResponse> responses = new LinkedList<>();, +        protected InputStream initScroll(long startTimestamp) throws IOException {, +            initScrollStartTime = startTimestamp;, +            return super.initScroll(startTimestamp);, +        }, +, +        @Override, +            return responses.remove();, +            return responses.remove();, +            responses.add(searchResponse);, +        }, +, +        public long getInitScrollStartTime() {, +            return initScrollStartTime;, +        extractor.setNextResponse(createResponseWithShardFailures());, +        extractor.setNextResponse(createResponseWithUnavailableShards(1));, +    public void testResetScrollAfterFailure() throws IOException {, +        TestDataExtractor extractor = new TestDataExtractor(1000L, 2000L);, +, +        SearchResponse goodResponse = createSearchResponse(, +                Arrays.asList(1100L, 1200L),, +                Arrays.asList("a1", "a2"),, +                Arrays.asList("b1", "b2"), +        );, +        extractor.setNextResponse(goodResponse);, +        extractor.setNextResponse(createResponseWithShardFailures());]