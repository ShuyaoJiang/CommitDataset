[+++ b/core/src/main/java/org/elasticsearch/action/search/type/TransportSearchScrollScanAction.java, +import java.util.ArrayList;, +import java.util.Objects;, +                    QueryFetchSearchResult shardResult = result.result();, +                    Objects.requireNonNull(shardResult, "QueryFetchSearchResult can't be null");, +                    queryFetchResults.setOnce(shardIndex, shardResult);, +            List<AtomicArray.Entry<QueryFetchSearchResult>> entries = queryFetchResults.asList();, +            for (AtomicArray.Entry<QueryFetchSearchResult> entry : entries) {, +            List<ScoreDoc> docs = new ArrayList<>(numberOfHits);, +            for (AtomicArray.Entry<QueryFetchSearchResult> entry : entries) {, +                    docs.add(scoreDoc);, +            final InternalSearchResponse internalResponse = searchPhaseController.merge(docs.toArray(new ScoreDoc[0]), queryFetchResults, queryFetchResults);, +            for (AtomicArray.Entry<QueryFetchSearchResult> entry : entries) {, +                    // we found more than we want for this round, remove this from our scrolling, so we don't go back to, +                    // this shard, since all hits have been processed., +                    // The SearchContext already gets freed on the node holding the shard, via a similar check., +++ b/core/src/main/java/org/elasticsearch/action/search/type/TransportSearchScrollScanAction.java, +import java.util.ArrayList;, +import java.util.Objects;, +                    QueryFetchSearchResult shardResult = result.result();, +                    Objects.requireNonNull(shardResult, "QueryFetchSearchResult can't be null");, +                    queryFetchResults.setOnce(shardIndex, shardResult);, +            List<AtomicArray.Entry<QueryFetchSearchResult>> entries = queryFetchResults.asList();, +            for (AtomicArray.Entry<QueryFetchSearchResult> entry : entries) {, +            List<ScoreDoc> docs = new ArrayList<>(numberOfHits);, +            for (AtomicArray.Entry<QueryFetchSearchResult> entry : entries) {, +                    docs.add(scoreDoc);, +            final InternalSearchResponse internalResponse = searchPhaseController.merge(docs.toArray(new ScoreDoc[0]), queryFetchResults, queryFetchResults);, +            for (AtomicArray.Entry<QueryFetchSearchResult> entry : entries) {, +                    // we found more than we want for this round, remove this from our scrolling, so we don't go back to, +                    // this shard, since all hits have been processed., +                    // The SearchContext already gets freed on the node holding the shard, via a similar check., +++ b/core/src/main/java/org/elasticsearch/common/util/concurrent/AtomicArray.java, +    public final void setOnce(int i, E value) {, +        if (array.compareAndSet(i, null, value) == false) {, +            throw new IllegalStateException("index [" + i + "] has already been set");, +        }, +        if (nonNullList != null) { // read first, lighter, and most times it will be null..., +            nonNullList = null;, +        }, +    }, +]