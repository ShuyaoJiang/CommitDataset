[+++ b/modules/elasticsearch/src/main/java/org/elasticsearch/action/admin/indices/mapping/create/TransportCreateMappingAction.java, +import org.elasticsearch.ExceptionsHelper;, +import org.elasticsearch.action.admin.indices.create.CreateIndexRequest;, +import org.elasticsearch.action.admin.indices.create.CreateIndexResponse;, +import org.elasticsearch.action.admin.indices.create.TransportCreateIndexAction;, +import org.elasticsearch.indices.IndexAlreadyExistsException;, +import java.util.concurrent.CountDownLatch;, +import java.util.concurrent.TimeUnit;, +    private final TransportCreateIndexAction createIndexAction;, +, +    private final boolean autoCreateIndex;, +, +                                                ThreadPool threadPool, MetaDataService metaDataService, TransportCreateIndexAction createIndexAction) {, +        this.createIndexAction = createIndexAction;, +        this.autoCreateIndex = settings.getAsBoolean("action.autoCreateIndex", true);, +        if (autoCreateIndex) {, +            final CountDownLatch latch = new CountDownLatch(indices.length);, +            for (String index : indices) {, +                if (!clusterService.state().metaData().hasIndex(index)) {, +                    createIndexAction.execute(new CreateIndexRequest(index), new ActionListener<CreateIndexResponse>() {, +                        @Override public void onResponse(CreateIndexResponse result) {, +                            latch.countDown();, +                        }, +, +                        @Override public void onFailure(Throwable e) {, +                            if (ExceptionsHelper.unwrapCause(e) instanceof IndexAlreadyExistsException) {, +                                latch.countDown();, +                            } else {, +                                listener.onFailure(e);, +                            }, +                        }, +                    });, +                } else {, +                    latch.countDown();, +                }, +            }, +            try {, +                latch.await(10, TimeUnit.SECONDS);, +            } catch (InterruptedException e) {, +                // ignore, +            }, +        }, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/action/admin/indices/mapping/create/TransportCreateMappingAction.java, +import org.elasticsearch.ExceptionsHelper;, +import org.elasticsearch.action.admin.indices.create.CreateIndexRequest;, +import org.elasticsearch.action.admin.indices.create.CreateIndexResponse;, +import org.elasticsearch.action.admin.indices.create.TransportCreateIndexAction;, +import org.elasticsearch.indices.IndexAlreadyExistsException;, +import java.util.concurrent.CountDownLatch;, +import java.util.concurrent.TimeUnit;, +    private final TransportCreateIndexAction createIndexAction;, +, +    private final boolean autoCreateIndex;, +, +                                                ThreadPool threadPool, MetaDataService metaDataService, TransportCreateIndexAction createIndexAction) {, +        this.createIndexAction = createIndexAction;, +        this.autoCreateIndex = settings.getAsBoolean("action.autoCreateIndex", true);, +        if (autoCreateIndex) {, +            final CountDownLatch latch = new CountDownLatch(indices.length);, +            for (String index : indices) {, +                if (!clusterService.state().metaData().hasIndex(index)) {, +                    createIndexAction.execute(new CreateIndexRequest(index), new ActionListener<CreateIndexResponse>() {, +                        @Override public void onResponse(CreateIndexResponse result) {, +                            latch.countDown();, +                        }, +, +                        @Override public void onFailure(Throwable e) {, +                            if (ExceptionsHelper.unwrapCause(e) instanceof IndexAlreadyExistsException) {, +                                latch.countDown();, +                            } else {, +                                listener.onFailure(e);, +                            }, +                        }, +                    });, +                } else {, +                    latch.countDown();, +                }, +            }, +            try {, +                latch.await(10, TimeUnit.SECONDS);, +            } catch (InterruptedException e) {, +                // ignore, +            }, +        }, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/action/index/TransportIndexAction.java, +        this.autoCreateIndex = settings.getAsBoolean("action.autoCreateIndex", true);]