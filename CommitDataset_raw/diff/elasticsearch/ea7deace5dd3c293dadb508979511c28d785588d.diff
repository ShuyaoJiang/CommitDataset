[+++ b/core/src/main/java/org/elasticsearch/common/xcontent/XContentHelper.java, +        return toXContent(toXContent, xContentType, ToXContent.EMPTY_PARAMS, humanReadable);, +    }, +, +    /**, +     * Returns the bytes that represent the XContent output of the provided {@link ToXContent} object, using the provided, +     * {@link XContentType}. Wraps the output into a new anonymous object., +     */, +    public static BytesReference toXContent(ToXContent toXContent, XContentType xContentType, Params params, boolean humanReadable) throws IOException {, +            toXContent.toXContent(builder, params);, +++ b/core/src/main/java/org/elasticsearch/common/xcontent/XContentHelper.java, +        return toXContent(toXContent, xContentType, ToXContent.EMPTY_PARAMS, humanReadable);, +    }, +, +    /**, +     * Returns the bytes that represent the XContent output of the provided {@link ToXContent} object, using the provided, +     * {@link XContentType}. Wraps the output into a new anonymous object., +     */, +    public static BytesReference toXContent(ToXContent toXContent, XContentType xContentType, Params params, boolean humanReadable) throws IOException {, +            toXContent.toXContent(builder, params);, +++ b/core/src/main/java/org/elasticsearch/search/suggest/Suggest.java, +import org.elasticsearch.common.ParsingException;, +import java.util.function.Function;, +import static org.elasticsearch.common.xcontent.XContentParserUtils.ensureExpectedToken;, +    static final String NAME = "suggest";, +    private Suggest() {, +    /**, +     * this parsing method assumes that the leading "suggest" field name has already been parsed by the caller, +     */, +    public static Suggest fromXContent(XContentParser parser) throws IOException {, +        ensureExpectedToken(XContentParser.Token.START_OBJECT, parser.currentToken(), parser::getTokenLocation);, +        List<Suggestion<? extends Entry<? extends Option>>> suggestions = new ArrayList<>();, +        while ((parser.nextToken()) != XContentParser.Token.END_OBJECT) {, +            suggestions.add(Suggestion.fromXContent(parser));, +        }, +        return new Suggest(suggestions);, +    }, +, +        protected Suggestion() {, +        public static Suggestion<? extends Entry<? extends Option>> fromXContent(XContentParser parser) throws IOException {, +            ensureExpectedToken(XContentParser.Token.FIELD_NAME, parser.currentToken(), parser::getTokenLocation);, +            String typeAndName = parser.currentName();, +            // we need to extract the type prefix from the name and throw error if it is not present, +            int delimiterPos = typeAndName.indexOf(InternalAggregation.TYPED_KEYS_DELIMITER);, +            String type = null;, +            String name = null;, +            if (delimiterPos > 0) {, +                type = typeAndName.substring(0, delimiterPos);, +                name = typeAndName.substring(delimiterPos + 1);, +            } else {, +                throw new ParsingException(parser.getTokenLocation(),, +                        "Cannot parse suggestion response without type information. Set [" + RestSearchAction.TYPED_KEYS_PARAM, +                                + "] parameter on the request to ensure the type information is added to the response output");, +            }, +            Suggestion suggestion = null;, +            Function<XContentParser, Entry> entryParser = null;, +            // the "size" parameter and the SortBy for TermSuggestion cannot be parsed from the response, use default values, +            // TODO investigate if we can use NamedXContentRegistry instead of this switch, +            switch (type) {, +                case Suggestion.NAME:, +                    suggestion = new Suggestion(name, -1);, +                    entryParser = Suggestion.Entry::fromXContent;, +                    break;, +                case PhraseSuggestion.NAME:, +                    suggestion = new PhraseSuggestion(name, -1);, +                    entryParser = PhraseSuggestion.Entry::fromXContent;, +                    break;, +                case TermSuggestion.NAME:, +                    suggestion = new TermSuggestion(name, -1, SortBy.SCORE);, +                    entryParser = TermSuggestion.Entry::fromXContent;, +                    break;, +                case CompletionSuggestion.NAME:, +                    suggestion = new CompletionSuggestion(name, -1);, +                    entryParser = CompletionSuggestion.Entry::fromXContent;, +                    break;, +                default:, +                    throw new ParsingException(parser.getTokenLocation(), "Unknown suggestion type [{}]", type);, +            }, +            ensureExpectedToken(XContentParser.Token.START_ARRAY, parser.nextToken(), parser::getTokenLocation);, +            while ((parser.nextToken()) != XContentParser.Token.END_ARRAY) {, +                suggestion.addTerm(entryParser.apply(parser));, +            }, +            return suggestion;, +        }, +, +++ b/core/src/main/java/org/elasticsearch/common/xcontent/XContentHelper.java, +        return toXContent(toXContent, xContentType, ToXContent.EMPTY_PARAMS, humanReadable);, +    }, +, +    /**, +     * Returns the bytes that represent the XContent output of the provided {@link ToXContent} object, using the provided, +     * {@link XContentType}. Wraps the output into a new anonymous object., +     */, +    public static BytesReference toXContent(ToXContent toXContent, XContentType xContentType, Params params, boolean humanReadable) throws IOException {, +            toXContent.toXContent(builder, params);, +++ b/core/src/main/java/org/elasticsearch/search/suggest/Suggest.java, +import org.elasticsearch.common.ParsingException;, +import java.util.function.Function;, +import static org.elasticsearch.common.xcontent.XContentParserUtils.ensureExpectedToken;, +    static final String NAME = "suggest";]