[+++ b/core/src/main/java/org/apache/lucene/search/vectorhighlight/CustomFieldQuery.java, +import org.elasticsearch.index.search.ESToParentBlockJoinQuery;, +        } else if (sourceQuery instanceof ESToParentBlockJoinQuery) {, +            ESToParentBlockJoinQuery blockJoinQuery = (ESToParentBlockJoinQuery) sourceQuery;, +++ b/core/src/main/java/org/apache/lucene/search/vectorhighlight/CustomFieldQuery.java, +import org.elasticsearch.index.search.ESToParentBlockJoinQuery;, +        } else if (sourceQuery instanceof ESToParentBlockJoinQuery) {, +            ESToParentBlockJoinQuery blockJoinQuery = (ESToParentBlockJoinQuery) sourceQuery;, +++ b/core/src/main/java/org/elasticsearch/common/lucene/search/Queries.java, +import org.apache.lucene.search.AutomatonQuery;, +import org.apache.lucene.util.automaton.Automata;, +import org.apache.lucene.util.automaton.Automaton;, +import org.apache.lucene.util.automaton.Operations;, +    private static final Automaton NON_NESTED_TYPE_AUTOMATON;, +    static {, +        Automaton nestedTypeAutomaton = Operations.concatenate(, +                Automata.makeString("__"),, +                Automata.makeAnyString());, +        NON_NESTED_TYPE_AUTOMATON = Operations.complement(nestedTypeAutomaton, Operations.DEFAULT_MAX_DETERMINIZED_STATES);, +    }, +, +    // We use a custom class rather than AutomatonQuery directly in order to, +    // have a better toString, +    private static class NonNestedQuery extends AutomatonQuery {, +, +        NonNestedQuery() {, +            super(new Term(TypeFieldMapper.NAME), NON_NESTED_TYPE_AUTOMATON);, +        }, +, +        @Override, +        public String toString(String field) {, +            return "_type:[^_].*";, +        }, +, +    }, +, +        // we use this automaton query rather than a negation of newNestedFilter, +        // since purely negative queries against high-cardinality clauses are costly, +        return new NonNestedQuery();, +++ b/core/src/main/java/org/apache/lucene/search/vectorhighlight/CustomFieldQuery.java, +import org.elasticsearch.index.search.ESToParentBlockJoinQuery;, +        } else if (sourceQuery instanceof ESToParentBlockJoinQuery) {, +            ESToParentBlockJoinQuery blockJoinQuery = (ESToParentBlockJoinQuery) sourceQuery;, +++ b/core/src/main/java/org/elasticsearch/common/lucene/search/Queries.java, +import org.apache.lucene.search.AutomatonQuery;, +import org.apache.lucene.util.automaton.Automata;, +import org.apache.lucene.util.automaton.Automaton;, +import org.apache.lucene.util.automaton.Operations;, +    private static final Automaton NON_NESTED_TYPE_AUTOMATON;, +    static {, +        Automaton nestedTypeAutomaton = Operations.concatenate(, +                Automata.makeString("__"),, +                Automata.makeAnyString());, +        NON_NESTED_TYPE_AUTOMATON = Operations.complement(nestedTypeAutomaton, Operations.DEFAULT_MAX_DETERMINIZED_STATES);, +    }, +, +    // We use a custom class rather than AutomatonQuery directly in order to, +    // have a better toString, +    private static class NonNestedQuery extends AutomatonQuery {, +, +        NonNestedQuery() {, +            super(new Term(TypeFieldMapper.NAME), NON_NESTED_TYPE_AUTOMATON);, +        }, +, +        @Override, +        public String toString(String field) {, +            return "_type:[^_].*";, +        }, +, +    }, +, +        // we use this automaton query rather than a negation of newNestedFilter, +        // since purely negative queries against high-cardinality clauses are costly, +        return new NonNestedQuery();, +++ b/core/src/main/java/org/elasticsearch/index/query/NestedQueryBuilder.java, +import org.elasticsearch.index.search.ESToParentBlockJoinQuery;, +import org.elasticsearch.index.search.NestedHelper;, +        Query innerQuery;, +, +, +        // ToParentBlockJoinQuery requires that the inner query only matches documents, +        // in its child space, +        if (new NestedHelper(context.getMapperService()).mightMatchNonNestedDocs(innerQuery, path)) {, +            innerQuery = Queries.filtered(innerQuery, nestedObjectMapper.nestedTypeFilter());, +        }, +, +        return new ESToParentBlockJoinQuery(innerQuery, parentFilter, scoreMode,, +                objectMapper == null ? null : objectMapper.fullPath());, +++ b/core/src/main/java/org/apache/lucene/search/vectorhighlight/CustomFieldQuery.java, +import org.elasticsearch.index.search.ESToParentBlockJoinQuery;, +        } else if (sourceQuery instanceof ESToParentBlockJoinQuery) {, +            ESToParentBlockJoinQuery blockJoinQuery = (ESToParentBlockJoinQuery) sourceQuery;, +++ b/core/src/main/java/org/elasticsearch/common/lucene/search/Queries.java, +import org.apache.lucene.search.AutomatonQuery;, +import org.apache.lucene.util.automaton.Automata;, +import org.apache.lucene.util.automaton.Automaton;, +import org.apache.lucene.util.automaton.Operations;, +    private static final Automaton NON_NESTED_TYPE_AUTOMATON;, +    static {, +        Automaton nestedTypeAutomaton = Operations.concatenate(]