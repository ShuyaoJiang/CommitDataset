[+++ b/src/main/java/org/elasticsearch/action/percolate/PercolateRequest.java, +import org.elasticsearch.client.Requests;, +    public static final XContentType contentType = Requests.CONTENT_TYPE;, +, +    private BytesReference source;, +    private boolean unsafe;, +, +    private BytesReference fetchedDoc;, +    public PercolateRequest(PercolateRequest request, BytesReference fetchedDoc) {, +        super(request.indices());, +        this.documentType = request.documentType();, +        this.routing = request.routing();, +        this.preference = request.preference();, +        this.source = request.source;, +        this.fetchedDoc = fetchedDoc;, +    }, +, +        if (unsafe) {, +            source = source.copyBytesArray();, +            unsafe = false;, +    public BytesReference source() {, +        return source;, +    public PercolateRequest source(Map document) throws ElasticSearchGenerationException {, +        return source(document, contentType);, +    public PercolateRequest source(Map document, XContentType contentType) throws ElasticSearchGenerationException {, +            return source(builder);, +    public PercolateRequest source(String document) {, +        this.source = new BytesArray(document);, +        this.unsafe = false;, +    public PercolateRequest source(XContentBuilder documentBuilder) {, +        source = documentBuilder.bytes();, +        unsafe = false;, +    public PercolateRequest source(byte[] document) {, +        return source(document, 0, document.length);, +    public PercolateRequest source(byte[] source, int offset, int length) {, +        return source(source, offset, length, false);, +    public PercolateRequest source(byte[] source, int offset, int length, boolean unsafe) {, +        return source(new BytesArray(source, offset, length), unsafe);, +    public PercolateRequest source(BytesReference source, boolean unsafe) {, +        this.source = source;, +        this.unsafe = unsafe;, +    public PercolateRequest source(PercolateSourceBuilder sourceBuilder) {, +        this.source = sourceBuilder.buildAsBytes(contentType);, +        this.unsafe = false;, +        return this;, +    }, +, +    BytesReference fetchedDoc() {, +        return fetchedDoc;, +    }, +, +        if (source == null) {, +            validationException = addValidationError("source is missing", validationException);, +        unsafe = false;, +        source = in.readBytesReference();, +        out.writeBytesReference(source);, +++ b/src/main/java/org/elasticsearch/action/percolate/PercolateRequest.java, +import org.elasticsearch.client.Requests;, +    public static final XContentType contentType = Requests.CONTENT_TYPE;, +, +    private BytesReference source;, +    private boolean unsafe;, +, +    private BytesReference fetchedDoc;, +    public PercolateRequest(PercolateRequest request, BytesReference fetchedDoc) {, +        super(request.indices());, +        this.documentType = request.documentType();, +        this.routing = request.routing();, +        this.preference = request.preference();, +        this.source = request.source;, +        this.fetchedDoc = fetchedDoc;, +    }, +, +        if (unsafe) {, +            source = source.copyBytesArray();, +            unsafe = false;, +    public BytesReference source() {, +        return source;, +    public PercolateRequest source(Map document) throws ElasticSearchGenerationException {, +        return source(document, contentType);, +    public PercolateRequest source(Map document, XContentType contentType) throws ElasticSearchGenerationException {, +            return source(builder);, +    public PercolateRequest source(String document) {, +        this.source = new BytesArray(document);, +        this.unsafe = false;, +    public PercolateRequest source(XContentBuilder documentBuilder) {, +        source = documentBuilder.bytes();, +        unsafe = false;, +    public PercolateRequest source(byte[] document) {, +        return source(document, 0, document.length);, +    public PercolateRequest source(byte[] source, int offset, int length) {, +        return source(source, offset, length, false);, +    public PercolateRequest source(byte[] source, int offset, int length, boolean unsafe) {, +        return source(new BytesArray(source, offset, length), unsafe);, +    public PercolateRequest source(BytesReference source, boolean unsafe) {, +        this.source = source;, +        this.unsafe = unsafe;, +    public PercolateRequest source(PercolateSourceBuilder sourceBuilder) {, +        this.source = sourceBuilder.buildAsBytes(contentType);, +        this.unsafe = false;]