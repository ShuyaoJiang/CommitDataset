[+++ b/config/logging.yml, +      conversionPattern: "[%d{ISO8601}][%-5p][%-25c] %.10000m%n", +++ b/config/logging.yml, +      conversionPattern: "[%d{ISO8601}][%-5p][%-25c] %.10000m%n", +++ b/dev-tools/forbidden/all-signatures.txt, +++ b/config/logging.yml, +      conversionPattern: "[%d{ISO8601}][%-5p][%-25c] %.10000m%n", +++ b/dev-tools/forbidden/all-signatures.txt, +++ b/dev-tools/forbidden/core-signatures.txt, +++ b/config/logging.yml, +      conversionPattern: "[%d{ISO8601}][%-5p][%-25c] %.10000m%n", +++ b/dev-tools/forbidden/all-signatures.txt, +++ b/dev-tools/forbidden/core-signatures.txt, +++ b/docs/reference/migration/migrate_2_0.asciidoc, +, +=== Logging, +, +Log messages are now truncated at 10,000 characters. This can be changed in the, +`logging.yml` configuration file., +++ b/config/logging.yml, +      conversionPattern: "[%d{ISO8601}][%-5p][%-25c] %.10000m%n", +++ b/dev-tools/forbidden/all-signatures.txt, +++ b/dev-tools/forbidden/core-signatures.txt, +++ b/docs/reference/migration/migrate_2_0.asciidoc, +, +=== Logging, +, +Log messages are now truncated at 10,000 characters. This can be changed in the, +`logging.yml` configuration file., +++ b/docs/reference/query-dsl/term-query.asciidoc, +The `term` query finds documents that contain the *exact* term specified, +in the inverted index.  For instance:, +    "term" : { "user" : "Kimchy" } <1>, +<1> Finds documents which contain the exact term `Kimchy` in the inverted index, +    of the `user` field., +A `boost` parameter can be specified to give this `term` query a higher, +relevance score than another query, for instance:, +GET /_search, +  "query": {, +    "bool": {, +      "should": [, +        {, +          "term": {, +            "status": {, +              "value": "urgent",, +              "boost": 2.0 <1>, +            }, +          }, +        },, +        {, +          "term": {, +            "status": "normal" <2>, +          }, +        }, +      ], +    }, +  }, +<1> The `urgent` query clause has a boost of `2.0`, meaning it is twice as important, +    as the query clause for `normal`., +<2> The `normal` clause has the default neutral boost of `1.0`., +, +.Why doesn't the `term` query match my document?, +**************************************************, +, +String fields can be `analyzed` (treated as full text, like the body of an, +email), or `not_analyzed` (treated as exact values, like an email address or a, +zip code).  Exact values (like numbers, dates, and `not_analyzed` strings) have, +the exact value specified in the field added to the inverted index in order, +to make them searchable., +, +By default, however, `string` fields are `analyzed`. This means that their, +values are first passed through an <<analysis,analyzer>> to produce a list of, +terms, which are then added to the inverted index., +, +There are many ways to analyze text: the default, +<<analysis-standard-analyzer,`standard` analyzer>> drops most punctuation,, +breaks up text into individual words, and lower cases them.    For instance,, +the `standard` analyzer would turn the string ``Quick Brown Fox!'' into the, +terms [`quick`, `brown`, `fox`]., +, +This analysis process makes it possible to search for individual words, +within a big block of full text., +, +The `term` query looks for the *exact* term in the field's inverted index --, +it doesn't know anything about the field's analyzer.  This makes it useful for, +looking up values in `not_analyzed` string fields, or in numeric or date, +fields.  When querying full text fields, use the, +<<query-dsl-match-query,`match` query>> instead, which understands how the field, +has been analyzed., +, +, +To demonstrate, try out the example below.  First, create an index, specifying the field mappings, and index a document:, +PUT my_index, +  "mappings": {, +    "my_type": {, +      "properties": {, +        "full_text": {, +          "type":  "string" <1>, +        },, +        "exact_value": {]