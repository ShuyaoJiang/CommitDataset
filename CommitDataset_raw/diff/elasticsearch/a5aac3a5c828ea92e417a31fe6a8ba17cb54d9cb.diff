[+++ b/modules/elasticsearch/src/main/java/org/elasticsearch/action/index/IndexRequest.java, +            MappingMetaData.ParseContext parseContext = mappingMd.createParseContext(routing, timestamp);, +            if (parseContext.shouldParse()) {, +                    mappingMd.parse(parser, parseContext);, +                    if (parseContext.shouldParseRouting()) {, +                        routing = parseContext.routing();, +                    if (parseContext.shouldParseTimestamp()) {, +                        timestamp = parseContext.timestamp();, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/action/index/IndexRequest.java, +            MappingMetaData.ParseContext parseContext = mappingMd.createParseContext(routing, timestamp);, +            if (parseContext.shouldParse()) {, +                    mappingMd.parse(parser, parseContext);, +                    if (parseContext.shouldParseRouting()) {, +                        routing = parseContext.routing();, +                    if (parseContext.shouldParseTimestamp()) {, +                        timestamp = parseContext.timestamp();, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/cluster/metadata/MappingMetaData.java, +    public ParseContext createParseContext(@Nullable String routing, @Nullable String timestamp) {, +        return new ParseContext(, +                routing == null && routing().hasPath(),, +                timestamp == null && timestamp().hasPath(), +        );, +    public void parse(XContentParser parser, ParseContext parseContext) throws IOException {, +        innerParse(parser, parseContext);, +    }, +, +    private void innerParse(XContentParser parser, ParseContext context) throws IOException {, +        if (!context.parsingStillNeeded()) {, +            return;, +        }, +, +        String routingPart = context.routingParsingStillNeeded() ? routing().pathElements()[context.locationRouting] : null;, +        String timestampPart = context.timestampParsingStillNeeded() ? timestamp().pathElements()[context.locationTimestamp] : null;, +            if (context.routingParsingStillNeeded() && fieldName.equals(routingPart)) {, +                if (context.locationRouting + 1 == routing.pathElements().length) {, +                    context.routing = parser.textOrNull();, +                    context.routingResolved = true;, +            if (context.timestampParsingStillNeeded() && fieldName.equals(timestampPart)) {, +                if (context.locationTimestamp + 1 == timestamp.pathElements().length) {, +                    context.timestamp = parser.textOrNull();, +                    context.timestampResolved = true;, +                    context.locationRouting += incLocationRouting ? 1 : 0;, +                    context.locationTimestamp += incLocationTimestamp ? 1 : 0;, +                    innerParse(parser, context);, +                    context.locationRouting -= incLocationRouting ? 1 : 0;, +                    context.locationTimestamp -= incLocationTimestamp ? 1 : 0;, +            if (!context.parsingStillNeeded()) {, +                return;, +, +    public static class ParseResult {, +        public final String routing;, +        public final boolean routingResolved;, +        public final String timestamp;, +        public final boolean timestampResolved;, +, +        public ParseResult(String routing, boolean routingResolved, String timestamp, boolean timestampResolved) {, +            this.routing = routing;, +            this.routingResolved = routingResolved;, +            this.timestamp = timestamp;, +            this.timestampResolved = timestampResolved;, +        }, +    }, +, +    public static class ParseContext {, +, +        final boolean shouldParseRouting;, +        final boolean shouldParseTimestamp;, +, +        int locationRouting = 0;, +        int locationTimestamp = 0;, +        boolean routingResolved;, +        boolean timestampResolved;, +        String routing;, +        String timestamp;, +, +        public ParseContext(boolean shouldParseRouting, boolean shouldParseTimestamp) {, +            this.shouldParseRouting = shouldParseRouting;, +            this.shouldParseTimestamp = shouldParseTimestamp;, +        }, +, +        /**, +         * The routing value parsed, <tt>null</tt> if does not require parsing, or not resolved., +         */, +        public String routing() {, +            return routing;, +        }, +, +        /**, +         * Does routing parsing really needed at all?, +         */, +        public boolean shouldParseRouting() {, +            return shouldParseRouting;, +        }, +, +        /**, +         * Has routing been resolved during the parsing phase., +         */, +        public boolean routingResolved() {, +            return routingResolved;, +        }]