[+++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/DefBootstrap.java, +                    MethodHandle unary = DefMath.lookupUnary(args[0].getClass(), name);, +                        unary = DefMath.cast(args[0].getClass(), unary);, +                    return unary;, +                case BINARY_OPERATOR:, +                        return lookupGeneric(); // can handle nulls, casts if supported, +                        MethodHandle binary = DefMath.lookupBinary(args[0].getClass(), args[1].getClass(), name);, +                        if ((flags & OPERATOR_COMPOUND_ASSIGNMENT) != 0) {, +                            binary = DefMath.cast(args[0].getClass(), binary);, +                        }, +                        return binary;, +++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/DefBootstrap.java, +                    MethodHandle unary = DefMath.lookupUnary(args[0].getClass(), name);, +                        unary = DefMath.cast(args[0].getClass(), unary);, +                    return unary;, +                case BINARY_OPERATOR:, +                        return lookupGeneric(); // can handle nulls, casts if supported, +                        MethodHandle binary = DefMath.lookupBinary(args[0].getClass(), args[1].getClass(), name);, +                        if ((flags & OPERATOR_COMPOUND_ASSIGNMENT) != 0) {, +                            binary = DefMath.cast(args[0].getClass(), binary);, +                        }, +                        return binary;, +++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/DefMath.java, +    /** Returns an appropriate method handle for a binary operator, based on promotion of the LHS and RHS arguments */, +            if (c == returnValue.getClass()) {, +                return returnValue;, +            }, +    , +    /** Forces a cast to class A for target (only if types differ) */, +    public static MethodHandle cast(Class<?> classA, MethodHandle target) {, +        MethodType newType = MethodType.methodType(classA).unwrap();, +        MethodType targetType = MethodType.methodType(target.type().returnType()).unwrap();, +        , +        if (newType.returnType() == targetType.returnType()) {, +            return target; // no conversion, +        }, +        , +        // this is safe for our uses of it here only, because we change just the return value,, +        // the original method itself does all the type checks correctly., +        return MethodHandles.explicitCastArguments(target, target.type().changeReturnType(newType.returnType()));, +    }]