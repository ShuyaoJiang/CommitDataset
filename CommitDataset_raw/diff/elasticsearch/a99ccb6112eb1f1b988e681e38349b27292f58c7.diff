[+++ b/core/src/main/java/org/elasticsearch/gateway/ReplicaShardAllocator.java, +                // if we are allocating a replica because of index creation, no need to go and find a copy, there isn't one..., +                if (shard.allocatedPostIndexCreate() == false) {, +                    continue;, +                }, +            // if we are allocating a replica because of index creation, no need to go and find a copy, there isn't one..., +            if (shard.allocatedPostIndexCreate() == false) {, +                continue;, +            }, +, +++ b/core/src/main/java/org/elasticsearch/gateway/ReplicaShardAllocator.java, +                // if we are allocating a replica because of index creation, no need to go and find a copy, there isn't one..., +                if (shard.allocatedPostIndexCreate() == false) {, +                    continue;, +                }, +            // if we are allocating a replica because of index creation, no need to go and find a copy, there isn't one..., +            if (shard.allocatedPostIndexCreate() == false) {, +                continue;, +            }, +, +++ b/core/src/main/java/org/elasticsearch/plugins/PluginsService.java, +++ b/core/src/main/java/org/elasticsearch/gateway/ReplicaShardAllocator.java, +                // if we are allocating a replica because of index creation, no need to go and find a copy, there isn't one..., +                if (shard.allocatedPostIndexCreate() == false) {, +                    continue;, +                }, +            // if we are allocating a replica because of index creation, no need to go and find a copy, there isn't one..., +            if (shard.allocatedPostIndexCreate() == false) {, +                continue;, +            }, +, +++ b/core/src/main/java/org/elasticsearch/plugins/PluginsService.java, +++ b/core/src/test/java/org/elasticsearch/gateway/ReplicaShardAllocatorTests.java, +import com.carrotsearch.randomizedtesting.generators.RandomPicks;, +import java.util.EnumSet;, +import java.util.concurrent.atomic.AtomicBoolean;, +     * Verifies that on index creation, we don't go and fetch data, but keep the replica shard unassigned to let, +     * the shard allocator to allocate it. There isn't a copy around to find anyhow., +     */, +    @Test, +    public void testNoAsyncFetchOnIndexCreation() {, +        RoutingAllocation allocation = onePrimaryOnNode1And1Replica(yesAllocationDeciders(), Settings.EMPTY, UnassignedInfo.Reason.INDEX_CREATED);, +        testAllocator.clean();, +        testAllocator.allocateUnassigned(allocation);, +        assertThat(testAllocator.getFetchDataCalledAndClean(), equalTo(false));, +        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.UNASSIGNED).size(), equalTo(1));, +        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.UNASSIGNED).get(0).shardId(), equalTo(shardId));, +    }, +, +    /**, +     * Verifies that for anything but index creation, fetch data ends up being called, since we need to go and try, +     * and find a better copy for the shard., +     */, +    @Test, +    public void testAsyncFetchOnAnythingButIndexCreation() {, +        UnassignedInfo.Reason reason = RandomPicks.randomFrom(getRandom(), EnumSet.complementOf(EnumSet.of(UnassignedInfo.Reason.INDEX_CREATED)));, +        RoutingAllocation allocation = onePrimaryOnNode1And1Replica(yesAllocationDeciders(), Settings.EMPTY, reason);, +        testAllocator.clean();, +        testAllocator.allocateUnassigned(allocation);, +        assertThat("failed with reason " + reason, testAllocator.getFetchDataCalledAndClean(), equalTo(true));, +    }, +, +    /**, +        return onePrimaryOnNode1And1Replica(deciders, Settings.EMPTY, UnassignedInfo.Reason.CLUSTER_RECOVERED);, +                                        .addShard(TestShardRouting.newShardRouting(shardId.getIndex(), shardId.getId(), node2.id(), null, null, false, ShardRoutingState.INITIALIZING, 10, new UnassignedInfo(UnassignedInfo.Reason.CLUSTER_RECOVERED, null))), +        private AtomicBoolean fetchDataCalled = new AtomicBoolean(false);, +        public boolean getFetchDataCalledAndClean() {, +            return fetchDataCalled.getAndSet(false);, +        }, +, +            fetchDataCalled.set(true);]