[+++ b/core/src/main/java/org/elasticsearch/cluster/routing/allocation/AllocationService.java, +        // as failing primaries also fail associated replicas, we fail replicas first here to avoid re-resolving replica ShardRouting, +        List<FailedRerouteAllocation.FailedShard> orderedFailedShards = new ArrayList<>(failedShards);, +        orderedFailedShards.sort(Comparator.comparing(failedShard -> failedShard.routingEntry.primary()));, +, +        for (FailedRerouteAllocation.FailedShard failedShardEntry : orderedFailedShards) {, +            ShardRouting failedShard = failedShardEntry.routingEntry;, +            final int failedAllocations = failedShard.unassignedInfo() != null ? failedShard.unassignedInfo().getNumFailedAllocations() : 0;, +            allocation.addIgnoreShardForNode(failedShard.shardId(), failedShard.currentNodeId());, +++ b/core/src/main/java/org/elasticsearch/cluster/routing/allocation/AllocationService.java, +        // as failing primaries also fail associated replicas, we fail replicas first here to avoid re-resolving replica ShardRouting, +        List<FailedRerouteAllocation.FailedShard> orderedFailedShards = new ArrayList<>(failedShards);, +        orderedFailedShards.sort(Comparator.comparing(failedShard -> failedShard.routingEntry.primary()));, +, +        for (FailedRerouteAllocation.FailedShard failedShardEntry : orderedFailedShards) {, +            ShardRouting failedShard = failedShardEntry.routingEntry;, +            final int failedAllocations = failedShard.unassignedInfo() != null ? failedShard.unassignedInfo().getNumFailedAllocations() : 0;, +            allocation.addIgnoreShardForNode(failedShard.shardId(), failedShard.currentNodeId());, +++ b/core/src/main/java/org/elasticsearch/search/aggregations/bucket/histogram/HistogramAggregationBuilder.java, +    private double minBound = Double.POSITIVE_INFINITY;, +    private double maxBound = Double.NEGATIVE_INFINITY;, +    /**, +     * Set extended bounds on this builder: buckets between {@code minBound} and, +     * {@code maxBound} will be created even if no documents fell into these, +     * buckets., +     *, +     * @throws IllegalArgumentException, +     *             if maxBound is less that minBound, or if either of the bounds, +     *             are not finite., +     */, +        if (Double.isFinite(minBound) == false) {, +            throw new IllegalArgumentException("minBound must be finite, got: " + minBound);, +        if (Double.isFinite(maxBound) == false) {, +            throw new IllegalArgumentException("maxBound must be finite, got: " + maxBound);, +        }, +        if (maxBound < minBound) {, +            throw new IllegalArgumentException("maxBound [" + maxBound + "] must be greater than minBound [" + minBound + "]");, +++ b/core/src/main/java/org/elasticsearch/cluster/routing/allocation/AllocationService.java, +        // as failing primaries also fail associated replicas, we fail replicas first here to avoid re-resolving replica ShardRouting, +        List<FailedRerouteAllocation.FailedShard> orderedFailedShards = new ArrayList<>(failedShards);, +        orderedFailedShards.sort(Comparator.comparing(failedShard -> failedShard.routingEntry.primary()));, +, +        for (FailedRerouteAllocation.FailedShard failedShardEntry : orderedFailedShards) {, +            ShardRouting failedShard = failedShardEntry.routingEntry;, +            final int failedAllocations = failedShard.unassignedInfo() != null ? failedShard.unassignedInfo().getNumFailedAllocations() : 0;, +            allocation.addIgnoreShardForNode(failedShard.shardId(), failedShard.currentNodeId());, +++ b/core/src/main/java/org/elasticsearch/search/aggregations/bucket/histogram/HistogramAggregationBuilder.java, +    private double minBound = Double.POSITIVE_INFINITY;, +    private double maxBound = Double.NEGATIVE_INFINITY;, +    /**, +     * Set extended bounds on this builder: buckets between {@code minBound} and, +     * {@code maxBound} will be created even if no documents fell into these, +     * buckets., +     *, +     * @throws IllegalArgumentException, +     *             if maxBound is less that minBound, or if either of the bounds, +     *             are not finite., +     */, +        if (Double.isFinite(minBound) == false) {, +            throw new IllegalArgumentException("minBound must be finite, got: " + minBound);, +        if (Double.isFinite(maxBound) == false) {, +            throw new IllegalArgumentException("maxBound must be finite, got: " + maxBound);, +        }, +        if (maxBound < minBound) {, +            throw new IllegalArgumentException("maxBound [" + maxBound + "] must be greater than minBound [" + minBound + "]");, +++ b/core/src/test/java/org/elasticsearch/search/aggregations/bucket/HistogramIT.java, +        } catch (IllegalArgumentException e) {, +        } catch (IllegalArgumentException e) {, +++ b/core/src/main/java/org/elasticsearch/cluster/routing/allocation/AllocationService.java, +        // as failing primaries also fail associated replicas, we fail replicas first here to avoid re-resolving replica ShardRouting, +        List<FailedRerouteAllocation.FailedShard> orderedFailedShards = new ArrayList<>(failedShards);, +        orderedFailedShards.sort(Comparator.comparing(failedShard -> failedShard.routingEntry.primary()));, +, +        for (FailedRerouteAllocation.FailedShard failedShardEntry : orderedFailedShards) {, +            ShardRouting failedShard = failedShardEntry.routingEntry;, +            final int failedAllocations = failedShard.unassignedInfo() != null ? failedShard.unassignedInfo().getNumFailedAllocations() : 0;, +            allocation.addIgnoreShardForNode(failedShard.shardId(), failedShard.currentNodeId());, +++ b/core/src/main/java/org/elasticsearch/search/aggregations/bucket/histogram/HistogramAggregationBuilder.java, +    private double minBound = Double.POSITIVE_INFINITY;, +    private double maxBound = Double.NEGATIVE_INFINITY;, +    /**, +     * Set extended bounds on this builder: buckets between {@code minBound} and, +     * {@code maxBound} will be created even if no documents fell into these, +     * buckets., +     *, +     * @throws IllegalArgumentException, +     *             if maxBound is less that minBound, or if either of the bounds, +     *             are not finite., +     */, +        if (Double.isFinite(minBound) == false) {, +            throw new IllegalArgumentException("minBound must be finite, got: " + minBound);, +        if (Double.isFinite(maxBound) == false) {, +            throw new IllegalArgumentException("maxBound must be finite, got: " + maxBound);, +        }, +        if (maxBound < minBound) {, +            throw new IllegalArgumentException("maxBound [" + maxBound + "] must be greater than minBound [" + minBound + "]");, +++ b/core/src/test/java/org/elasticsearch/search/aggregations/bucket/HistogramIT.java, +        } catch (IllegalArgumentException e) {, +        } catch (IllegalArgumentException e) {, +++ b/core/src/test/java/org/elasticsearch/search/aggregations/bucket/HistogramTests.java]