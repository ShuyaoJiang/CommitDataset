[+++ b/plugin/src/main/java/org/elasticsearch/xpack/ml/action/CloseJobAction.java, +            case OPENING:, +++ b/plugin/src/main/java/org/elasticsearch/xpack/ml/action/CloseJobAction.java, +            case OPENING:, +++ b/plugin/src/main/java/org/elasticsearch/xpack/ml/action/OpenJobAction.java, +import org.elasticsearch.xpack.ml.job.config.JobState;, +                JobState jobState = JobState.CLOSED;, +                if (persistentTask != null) {, +                    JobTaskStatus jobStateStatus = (JobTaskStatus) persistentTask.getStatus();, +                    jobState = jobStateStatus == null ? JobState.OPENING : jobStateStatus.getState();, +                switch (jobState) {, +                    case OPENING:, +                    case CLOSED:, +                    case CLOSING:, +                        throw ExceptionsHelper.conflictStatusException("The job has been " + JobState.CLOSED + " while waiting to be ", +                                + JobState.OPENED);, +                        throw new IllegalStateException("Unexpected job state [" + jobState, +                                + "] while waiting for job to be " + JobState.OPENED);, +++ b/plugin/src/main/java/org/elasticsearch/xpack/ml/action/CloseJobAction.java, +            case OPENING:, +++ b/plugin/src/main/java/org/elasticsearch/xpack/ml/action/OpenJobAction.java, +import org.elasticsearch.xpack.ml.job.config.JobState;, +                JobState jobState = JobState.CLOSED;, +                if (persistentTask != null) {, +                    JobTaskStatus jobStateStatus = (JobTaskStatus) persistentTask.getStatus();, +                    jobState = jobStateStatus == null ? JobState.OPENING : jobStateStatus.getState();, +                switch (jobState) {, +                    case OPENING:, +                    case CLOSED:, +                    case CLOSING:, +                        throw ExceptionsHelper.conflictStatusException("The job has been " + JobState.CLOSED + " while waiting to be ", +                                + JobState.OPENED);, +                        throw new IllegalStateException("Unexpected job state [" + jobState, +                                + "] while waiting for job to be " + JobState.OPENED);, +++ b/plugin/src/main/java/org/elasticsearch/xpack/ml/job/persistence/JobProvider.java, +++ b/plugin/src/main/java/org/elasticsearch/xpack/ml/action/CloseJobAction.java, +            case OPENING:, +++ b/plugin/src/main/java/org/elasticsearch/xpack/ml/action/OpenJobAction.java, +import org.elasticsearch.xpack.ml.job.config.JobState;, +                JobState jobState = JobState.CLOSED;, +                if (persistentTask != null) {, +                    JobTaskStatus jobStateStatus = (JobTaskStatus) persistentTask.getStatus();, +                    jobState = jobStateStatus == null ? JobState.OPENING : jobStateStatus.getState();, +                switch (jobState) {, +                    case OPENING:, +                    case CLOSED:, +                    case CLOSING:, +                        throw ExceptionsHelper.conflictStatusException("The job has been " + JobState.CLOSED + " while waiting to be ", +                                + JobState.OPENED);, +                        throw new IllegalStateException("Unexpected job state [" + jobState, +                                + "] while waiting for job to be " + JobState.OPENED);, +++ b/plugin/src/main/java/org/elasticsearch/xpack/ml/job/persistence/JobProvider.java, +++ b/plugin/src/main/java/org/elasticsearch/xpack/ml/job/persistence/StateStreamer.java, +/*, + * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one, + * or more contributor license agreements. Licensed under the Elastic License;, + * you may not use this file except in compliance with the Elastic License., + */, +package org.elasticsearch.xpack.ml.job.persistence;, +, +import org.apache.logging.log4j.Logger;, +import org.apache.lucene.util.BytesRef;, +import org.apache.lucene.util.BytesRefIterator;, +import org.elasticsearch.action.get.GetResponse;, +import org.elasticsearch.client.Client;, +import org.elasticsearch.common.bytes.BytesReference;, +import org.elasticsearch.common.logging.Loggers;, +import org.elasticsearch.xpack.ml.job.process.autodetect.state.CategorizerState;, +import org.elasticsearch.xpack.ml.job.process.autodetect.state.ModelSnapshot;, +, +import java.io.IOException;, +import java.io.OutputStream;, +import java.util.Objects;, +, +/**, + * A {@code StateStreamer} fetches the various state documents and, + * writes them into a stream. It allows cancellation via its, + *{@link #cancel()} method; cancellation is checked between writing, + * the various state documents., + */, +public class StateStreamer {, +, +    private static final Logger LOGGER = Loggers.getLogger(StateStreamer.class);, +, +    private final Client client;, +    private volatile boolean isCancelled;, +, +    public StateStreamer(Client client) {, +        this.client = Objects.requireNonNull(client);, +    }, +, +    /**, +     * Cancels the state streaming at the first opportunity., +     */, +    public void cancel() {, +        isCancelled = true;, +    }, +, +    /**, +     * Given a model snapshot, get the corresponding state and write it to the supplied]