[+++ b/src/main/java/org/elasticsearch/tribe/TribeService.java, +                            if (tribeIndex == null || tribeIndex.state() == IndexMetaData.State.CLOSE) {, +++ b/src/main/java/org/elasticsearch/tribe/TribeService.java, +                            if (tribeIndex == null || tribeIndex.state() == IndexMetaData.State.CLOSE) {, +++ b/src/test/java/org/elasticsearch/tribe/TribeTests.java, +import org.elasticsearch.action.admin.cluster.health.ClusterHealthResponse;, +import org.elasticsearch.client.Requests;, +import org.elasticsearch.common.Priority;, +import org.elasticsearch.test.TestCluster;, +import static org.elasticsearch.test.hamcrest.ElasticsearchAssertions.assertNoFailures;, +        assertAcked(cluster2.client().admin().indices().prepareCreate("test2"));, +        assertAcked(internalCluster().client().admin().indices().prepareCreate("test1"));, +        assertAcked(internalCluster().client().admin().indices().prepareCreate("block_test1"));, +        assertAcked(cluster2.client().admin().indices().prepareCreate("test2"));, +        assertAcked(cluster2.client().admin().indices().prepareCreate("block_test2"));, +        assertAcked(internalCluster().client().admin().indices().prepareCreate("conflict"));, +        assertAcked(cluster2.client().admin().indices().prepareCreate("conflict"));, +        assertAcked(internalCluster().client().admin().indices().prepareCreate("test1"));, +        assertAcked(cluster2.client().admin().indices().prepareCreate("test2"));, +        assertAcked(internalCluster().client().admin().indices().prepareCreate("test1"));, +        assertAcked(cluster2.client().admin().indices().prepareCreate("test2"));, +        assertNoFailures(tribeClient.admin().indices().prepareRefresh().get());, +        awaitIndicesNotInClusterState("test2");, +        try {, +        } finally {, +            cluster2.startNode();, +            awaitSameNodeCounts();, +        }, +    }, +, +    @Test, +    public void testCloseAndOpenIndex() throws Exception {, +        //create an index and close it even before starting the tribe node, +        assertAcked(internalCluster().client().admin().indices().prepareCreate("test1"));, +        ensureGreen(internalCluster());, +        assertAcked(internalCluster().client().admin().indices().prepareClose("test1"));, +, +        setupTribeNode(ImmutableSettings.EMPTY);, +        awaitSameNodeCounts();, +, +        //the closed index is not part of the tribe node cluster state, +        ClusterState tribeState = tribeNode.client().admin().cluster().prepareState().get().getState();, +        assertThat(tribeState.getMetaData().hasIndex("test1"), equalTo(false));, +, +        //open the index, it becomes part of the tribe node cluster state, +        assertAcked(internalCluster().client().admin().indices().prepareOpen("test1"));, +        awaitIndicesInClusterState("test1");, +        ensureGreen(internalCluster());, +, +        //create a second index, wait till it is seen from within the tribe node, +        assertAcked(cluster2.client().admin().indices().prepareCreate("test2"));, +        awaitIndicesInClusterState("test1", "test2");, +        ensureGreen(cluster2);, +, +        //close the second index, wait till it gets removed from the tribe node cluster state, +        assertAcked(cluster2.client().admin().indices().prepareClose("test2"));, +        awaitIndicesNotInClusterState("test2");, +, +        //open the second index, wait till it gets added back to the tribe node cluster state, +        assertAcked(cluster2.client().admin().indices().prepareOpen("test2"));, +        awaitIndicesInClusterState("test1", "test2");, +        ensureGreen(cluster2);, +    private void awaitIndicesNotInClusterState(final String... indices) throws Exception {, +        assertBusy(new Runnable() {, +            @Override, +            public void run() {, +                ClusterState tribeState = tribeNode.client().admin().cluster().prepareState().get().getState();, +                for (String index : indices) {, +                    assertFalse(tribeState.getMetaData().hasIndex(index));, +                    assertFalse(tribeState.getRoutingTable().hasIndex(index));, +                }, +            }, +        });, +    }, +, +    private void ensureGreen(TestCluster testCluster) {, +        ClusterHealthResponse actionGet = testCluster.client().admin().cluster(), +                .health(Requests.clusterHealthRequest().waitForGreenStatus().waitForEvents(Priority.LANGUID).waitForRelocatingShards(0)).actionGet();, +        if (actionGet.isTimedOut()) {, +            logger.info("ensureGreen timed out, cluster state:\n{}\n{}", testCluster.client().admin().cluster().prepareState().get().getState().prettyPrint(), testCluster.client().admin().cluster().preparePendingClusterTasks().get().prettyPrint());, +            assertThat("timed out waiting for green state", actionGet.isTimedOut(), equalTo(false));, +        }, +        assertThat(actionGet.getStatus(), equalTo(ClusterHealthStatus.GREEN));, +    }, +]