[+++ b/core/src/main/java/org/elasticsearch/common/io/stream/StreamInput.java, +                    String msg1 = readOptionalString();, +                    String resource1 = readOptionalString();, +                    return (T) readStackTrace(new CorruptIndexException(msg1, resource1, readThrowable()), this);, +                    String resource2 = readOptionalString();, +                    int version2 = readInt();, +                    int minVersion2 = readInt();, +                    int maxVersion2 = readInt();, +                    return (T) readStackTrace(new IndexFormatTooNewException(resource2, version2, minVersion2, maxVersion2), this);, +                    String resource3 = readOptionalString();, +                    if (readBoolean()) {, +                        int version3 = readInt();, +                        int minVersion3 = readInt();, +                        int maxVersion3 = readInt();, +                        return (T) readStackTrace(new IndexFormatTooOldException(resource3, version3, minVersion3, maxVersion3), this);, +                    } else {, +                        String version3 = readOptionalString();, +                        return (T) readStackTrace(new IndexFormatTooOldException(resource3, version3), this);, +                    }, +++ b/core/src/main/java/org/elasticsearch/common/io/stream/StreamInput.java, +                    String msg1 = readOptionalString();, +                    String resource1 = readOptionalString();, +                    return (T) readStackTrace(new CorruptIndexException(msg1, resource1, readThrowable()), this);, +                    String resource2 = readOptionalString();, +                    int version2 = readInt();, +                    int minVersion2 = readInt();, +                    int maxVersion2 = readInt();, +                    return (T) readStackTrace(new IndexFormatTooNewException(resource2, version2, minVersion2, maxVersion2), this);, +                    String resource3 = readOptionalString();, +                    if (readBoolean()) {, +                        int version3 = readInt();, +                        int minVersion3 = readInt();, +                        int maxVersion3 = readInt();, +                        return (T) readStackTrace(new IndexFormatTooOldException(resource3, version3, minVersion3, maxVersion3), this);, +                    } else {, +                        String version3 = readOptionalString();, +                        return (T) readStackTrace(new IndexFormatTooOldException(resource3, version3), this);, +                    }, +++ b/core/src/main/java/org/elasticsearch/common/io/stream/StreamOutput.java, +import org.elasticsearch.common.regex.Regex;, +import java.util.regex.Matcher;, +import java.util.regex.Pattern;, +    static {, +        assert Version.CURRENT.luceneVersion == org.apache.lucene.util.Version.LUCENE_5_2_1: "Remove these regex once we upgrade to Lucene 5.3 and get proper getters for these expections";, +    }, +    private final static Pattern CORRUPT_INDEX_EXCEPTION_REGEX = Regex.compile("^(.+) \\(resource=(.+)\\)$", "");, +    private final static Pattern INDEX_FORMAT_TOO_NEW_EXCEPTION_REGEX = Regex.compile("Format version is not supported \\(resource (.+)\\): (-?\\d+) \\(needs to be between (-?\\d+) and (-?\\d+)\\)", "");, +    private final static Pattern INDEX_FORMAT_TOO_OLD_EXCEPTION_REGEX_1 = Regex.compile("Format version is not supported \\(resource (.+)\\): (-?\\d+)(?: \\(needs to be between (-?\\d+) and (-?\\d+)\\)). This version of Lucene only supports indexes created with release 4.0 and later\\.", "");, +    private final static Pattern INDEX_FORMAT_TOO_OLD_EXCEPTION_REGEX_2 = Regex.compile("Format version is not supported \\(resource (.+)\\): (.+). This version of Lucene only supports indexes created with release 4.0 and later\\.", "");, +, +    private static int parseIntSafe(String val, int defaultVal) {, +        try {, +            return Integer.parseInt(val);, +        } catch (NumberFormatException ex) {, +            return defaultVal;, +        }, +    }, +, +            boolean writeMessage = true;, +                // Lucene 5.3 will have getters for all these, +                // we should switch to using getters instead of trying to parse the message:, +                // writeOptionalString(((CorruptIndexException)throwable).getDescription());, +                // writeOptionalString(((CorruptIndexException)throwable).getResource());, +                Matcher matcher = CORRUPT_INDEX_EXCEPTION_REGEX.matcher(throwable.getMessage());, +                if (matcher.find()) {, +                    writeOptionalString(matcher.group(1)); // message, +                    writeOptionalString(matcher.group(2)); // resource, +                } else {, +                    // didn't match, +                    writeOptionalString("???"); // message, +                    writeOptionalString("???"); // resource, +                }, +                writeMessage = false;, +                // Lucene 5.3 will have getters for all these, +                // we should switch to using getters instead of trying to parse the message:, +                // writeOptionalString(((CorruptIndexException)throwable).getResource());, +                // writeInt(((IndexFormatTooNewException)throwable).getVersion());, +                // writeInt(((IndexFormatTooNewException)throwable).getMinVersion());, +                // writeInt(((IndexFormatTooNewException)throwable).getMaxVersion());, +                Matcher matcher = INDEX_FORMAT_TOO_NEW_EXCEPTION_REGEX.matcher(throwable.getMessage());, +                if (matcher.find()) {, +                    writeOptionalString(matcher.group(1)); // resource, +                    writeInt(parseIntSafe(matcher.group(2), -1)); // version, +                    writeInt(parseIntSafe(matcher.group(3), -1)); // min version, +                    writeInt(parseIntSafe(matcher.group(4), -1)); // max version, +                } else {, +                    // didn't match, +                    writeOptionalString("???"); // resource, +                    writeInt(-1); // version, +                    writeInt(-1); // min version, +                    writeInt(-1); // max version, +                }, +                writeMessage = false;, +                // Lucene 5.3 will have getters for all these, +                // we should switch to using getters instead of trying to parse the message:, +                // writeOptionalString(((CorruptIndexException)throwable).getResource());, +                // writeInt(((IndexFormatTooNewException)throwable).getVersion());, +                // writeInt(((IndexFormatTooNewException)throwable).getMinVersion());, +                // writeInt(((IndexFormatTooNewException)throwable).getMaxVersion());, +                Matcher matcher = INDEX_FORMAT_TOO_OLD_EXCEPTION_REGEX_1.matcher(throwable.getMessage());]