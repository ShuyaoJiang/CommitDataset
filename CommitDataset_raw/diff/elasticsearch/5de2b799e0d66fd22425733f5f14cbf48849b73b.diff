[+++ b/shield/src/main/java/org/elasticsearch/shield/audit/index/IndexAuditTrail.java, +import java.net.SocketAddress;, +        SocketAddress address = request.getRemoteAddress();, +        if (address instanceof InetSocketAddress) {, +            msg.builder.field(Field.ORIGIN_ADDRESS, ((InetSocketAddress)request.getRemoteAddress()).getAddress().getHostAddress());, +        } else {, +        }, +, +            if (!indexToRemoteCluster) {, +                authenticationService.attachUserHeaderIfMissing(request, auditUser.user());, +            }, +                    if (!indexToRemoteCluster) {, +                    }, +                    if (!indexToRemoteCluster) {, +                    }, +++ b/shield/src/main/java/org/elasticsearch/shield/audit/index/IndexAuditTrail.java, +import java.net.SocketAddress;, +        SocketAddress address = request.getRemoteAddress();, +        if (address instanceof InetSocketAddress) {, +            msg.builder.field(Field.ORIGIN_ADDRESS, ((InetSocketAddress)request.getRemoteAddress()).getAddress().getHostAddress());, +        } else {, +        }, +, +            if (!indexToRemoteCluster) {, +                authenticationService.attachUserHeaderIfMissing(request, auditUser.user());, +            }, +                    if (!indexToRemoteCluster) {, +                    }, +                    if (!indexToRemoteCluster) {, +                    }, +++ b/shield/src/test/java/org/elasticsearch/shield/audit/index/IndexAuditTrailTests.java, +import org.elasticsearch.test.InternalTestCluster;, +import org.elasticsearch.test.ShieldSettingsSource;, +import java.util.Map;, +import static org.elasticsearch.test.InternalTestCluster.clusterName;, +import static org.hamcrest.Matchers.contains;, +import static org.hamcrest.Matchers.equalTo;, +import static org.hamcrest.Matchers.is;, +import static org.hamcrest.Matchers.notNullValue;, +import static org.hamcrest.Matchers.nullValue;, +import static org.mockito.Mockito.*;, +    public static final String SECOND_CLUSTER_NODE_PREFIX = "remote_" + SUITE_CLUSTER_NODE_PREFIX;, +    private InternalTestCluster cluster2;, +        AuthenticationService authService = mock(AuthenticationService.class);, +            // create another cluster, +            String cluster2Name = clusterName(Scope.SUITE.name(), randomLong());, +, +            // Setup a second test cluster with randomization for number of nodes, shield enabled, and SSL, +            final int numNodes = randomIntBetween(1, 2);, +            final boolean useShield = randomBoolean();, +            final boolean useSSL = useShield && randomBoolean();, +            logger.info("--> remote indexing enabled. shield enabled: [{}], SSL enabled: [{}]", useShield, useSSL);, +            ShieldSettingsSource cluster2SettingsSource = new ShieldSettingsSource(numNodes, useSSL, systemKey(), createTempDir(), Scope.SUITE) {, +                    @Override, +                    public Settings node(int nodeOrdinal) {, +                        return Settings.builder(), +                                .put(super.node(nodeOrdinal)), +                                .put(ShieldPlugin.ENABLED_SETTING_NAME, useShield), +                                .build();, +                    }, +            };, +            cluster2 = new InternalTestCluster(randomLong(), createTempDir(), numNodes, numNodes, cluster2Name, cluster2SettingsSource, 0, false, SECOND_CLUSTER_NODE_PREFIX);, +            cluster2.beforeTest(getRandom(), 0.5);, +            remoteClient = cluster2.client();, +            Settings.Builder builder = Settings.builder(), +                    .put(ShieldPlugin.ENABLED_SETTING_NAME, useShield), +                    .put(remoteSettings(inet.address().getAddress().getHostAddress(), inet.address().getPort(), cluster2Name)), +                    .put("shield.audit.index.client.shield.user", ShieldSettingsSource.DEFAULT_USER_NAME + ":" + ShieldSettingsSource.DEFAULT_PASSWORD);, +, +            if (useSSL) {, +                for (Map.Entry<String, String> entry : cluster2SettingsSource.getClientSSLSettings().getAsMap().entrySet()) {, +                    builder.put("shield.audit.index.client." + entry.getKey(), entry.getValue());, +                }, +            }, +            settings = builder.build();, +, +            doThrow(new IllegalStateException("indexing user should not be attached when sending remotely")).when(authService).attachUserHeaderIfMissing(any(TransportMessage.class), eq(user.user()));, +        if (remoteIndexing && cluster2 != null) {, +            cluster2.wipe();, +            cluster2.close();, +        assertThat("127.0.0.1", equalTo(hit.field("origin_address").getValue()));, +        assertThat("127.0.0.1", equalTo(hit.field("origin_address").getValue()));, +        assertThat("127.0.0.1", equalTo(hit.field("origin_address").getValue()));, +        assertThat("127.0.0.1", equalTo(hit.field("origin_address").getValue()));, +        when(request.getRemoteAddress()).thenReturn(new InetSocketAddress("127.0.0.1", 9200));, +++ b/shield/src/main/java/org/elasticsearch/shield/audit/index/IndexAuditTrail.java, +import java.net.SocketAddress;, +        SocketAddress address = request.getRemoteAddress();, +        if (address instanceof InetSocketAddress) {, +            msg.builder.field(Field.ORIGIN_ADDRESS, ((InetSocketAddress)request.getRemoteAddress()).getAddress().getHostAddress());, +        } else {, +        }, +, +            if (!indexToRemoteCluster) {, +                authenticationService.attachUserHeaderIfMissing(request, auditUser.user());, +            }, +                    if (!indexToRemoteCluster) {, +                    }, +                    if (!indexToRemoteCluster) {, +                    }]