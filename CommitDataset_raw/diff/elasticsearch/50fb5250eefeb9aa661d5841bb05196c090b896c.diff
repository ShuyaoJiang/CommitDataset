[+++ b/src/main/java/org/elasticsearch/license/plugin/core/LicensesManagerService.java, +++ b/src/main/java/org/elasticsearch/license/plugin/core/LicensesManagerService.java, +++ b/src/main/java/org/elasticsearch/license/plugin/core/LicensesService.java, +import java.util.concurrent.ScheduledFuture;, +    private final List<ListenerHolder> registeredListeners = new CopyOnWriteArrayList<>();, +    private final Queue<ListenerHolder> pendingListeners = new ConcurrentLinkedQueue<>();, +, +    private final Queue<ScheduledFuture> scheduledNotifications = new ConcurrentLinkedQueue<>();, +    private LicensesStatus checkLicenses(Set<ESLicense> licenses) {, +        final ImmutableMap<String, ESLicense> map = reduceAndMap(licenses);, +        return checkLicenses(map);, +    }, +, +    private LicensesStatus checkLicenses(Map<String, ESLicense> licenseMap) {, +        LicensesStatus status = LicensesStatus.VALID;, +        try {, +            licenseManager.verifyLicenses(licenseMap);, +        } catch (ExpiredLicenseException e) {, +            status = LicensesStatus.EXPIRED;, +        } catch (InvalidLicenseException e) {, +            status = LicensesStatus.INVALID;, +        }, +        return status;, +    }, +        // Should scheduledNotifications be cancelled on stop as well?, +        // cancel all notifications, +        for (ScheduledFuture scheduledNotification : scheduledNotifications) {, +            scheduledNotification.cancel(true);, +        }, +, +, +        // empty out notification queue, +        scheduledNotifications.clear();, +            if (!pendingListeners.isEmpty()) {, +                boolean masterAvailable = false;, +                while ((pendingRegistrationLister = pendingListeners.poll()) != null) {, +                    masterAvailable = registerListener(pendingRegistrationLister);, +                        // if the master is not available do not, break out of trying pendingListeners, +                        pendingListeners.add(pendingRegistrationLister);, +                if (masterAvailable) {, +                    // make sure to notify new registered feature, +                    // notifications could have been scheduled for it before it was registered, +                    notifyFeaturesAndScheduleNotification(currentLicensesMetaData);, +            }, +, +            clearFinishedNotifications();, +            if (event.previousState().blocks().hasGlobalBlock(GatewayService.STATE_NOT_RECOVERED_BLOCK)) {, +                notifyFeaturesAndScheduleNotification(currentLicensesMetaData);, +            } else {, +            }, +            return;, +    private long notifyFeatures(LicensesMetaData currentLicensesMetaData) {, +        long nextScheduleFrequency = -1l;, +        long offset = TimeValue.timeValueMillis(100).getMillis();, +        StringBuilder sb = new StringBuilder("Registered listeners: [ ");, +        for (ListenerHolder listenerHolder : registeredListeners) {, +, +            sb.append("( ");, +            sb.append("feature:");, +            sb.append(listenerHolder.feature);, +            sb.append(", ");, +, +            long expiryDate;, +            if ((expiryDate = expiryDateForFeature(listenerHolder.feature, currentLicensesMetaData)) != -1l) {, +                sb.append(" license expiry: ");, +                sb.append(expiryDate);, +                sb.append(", ");, +            }, +            long expiryDuration = expiryDate - System.currentTimeMillis();, +, +            if (expiryDate == -1l) {, +                sb.append("no trial/signed license found");, +                sb.append(", ");, +            } else {, +                sb.append("license expires in: ");, +                sb.append(TimeValue.timeValueMillis(expiryDuration).toString());, +                sb.append(", ");, +            }, +, +            if (expiryDuration > 0l) {, +                sb.append("calling enableFeatureIfNeeded");, +, +                listenerHolder.enableFeatureIfNeeded();, +                if (nextScheduleFrequency == -1l) {, +                    nextScheduleFrequency = expiryDuration + offset;, +                } else {, +                    nextScheduleFrequency = Math.min(expiryDuration + offset, nextScheduleFrequency);, +                }, +            } else {, +                sb.append("calling disableFeatureIfNeeded");, +                listenerHolder.disableFeatureIfNeeded();, +            }, +            sb.append(" )");, +        }, +        sb.append("]");, +        // Change to debug, +        logger.info(sb.toString());, +, +        logLicenseMetaDataStats("Setting last observed metaData", currentLicensesMetaData);, +        lastObservedLicensesState.set(currentLicensesMetaData);]