[+++ b/src/main/java/org/elasticsearch/cluster/metadata/AliasMetaData.java, +    public static Builder builder(String alias) {, +        return new Builder(alias);, +    }, +, +++ b/src/main/java/org/elasticsearch/cluster/metadata/AliasMetaData.java, +    public static Builder builder(String alias) {, +        return new Builder(alias);, +    }, +, +++ b/src/main/java/org/elasticsearch/cluster/metadata/IndexMetaData.java, +    public static Builder builder(String index) {, +        return new Builder(index);, +    }, +, +++ b/src/main/java/org/elasticsearch/cluster/metadata/AliasMetaData.java, +    public static Builder builder(String alias) {, +        return new Builder(alias);, +    }, +, +++ b/src/main/java/org/elasticsearch/cluster/metadata/IndexMetaData.java, +    public static Builder builder(String index) {, +        return new Builder(index);, +    }, +, +++ b/src/main/java/org/elasticsearch/cluster/metadata/MetaData.java, +import com.google.common.collect.ImmutableMap;, +import com.google.common.collect.ImmutableSet;, +import com.google.common.collect.Lists;, +import com.google.common.collect.UnmodifiableIterator;, +        return resolveSearchRouting(routing, convertFromWildcards(new String[]{aliasOrIndex}, true, true));, +        aliasesOrIndices = convertFromWildcards(aliasesOrIndices, true, true);, +, +                return resolveSearchRoutingSingleValue(routing, aliasesOrIndices[0]);, +        Set<String> norouting = new THashSet<String>();, +    private Map<String, Set<String>> resolveSearchRoutingSingleValue(@Nullable String routing, String aliasOrIndex) {, +        Map<String, Set<String>> routings = null;, +        Set<String> paramRouting = null;, +        if (routing != null) {, +            paramRouting = Strings.splitStringByCommaToSet(routing);, +        }, +, +        ImmutableMap<String, ImmutableSet<String>> indexToRoutingMap = aliasToIndexToSearchRoutingMap.get(aliasOrIndex);, +        if (indexToRoutingMap != null && !indexToRoutingMap.isEmpty()) {, +            // It's an alias, +            for (Map.Entry<String, ImmutableSet<String>> indexRouting : indexToRoutingMap.entrySet()) {, +                if (!indexRouting.getValue().isEmpty()) {, +                    // Routing alias, +                    Set<String> r = new THashSet<String>(indexRouting.getValue());, +                    if (paramRouting != null) {, +                        r.retainAll(paramRouting);, +                    }, +                    if (!r.isEmpty()) {, +                        if (routings == null) {, +                            routings = newHashMap();, +                        }, +                        routings.put(indexRouting.getKey(), r);, +                    }, +                } else {, +                    // Non-routing alias, +                    if (paramRouting != null) {, +                        Set<String> r = new THashSet<String>(paramRouting);, +                        if (routings == null) {, +                            routings = newHashMap();, +                        }, +                        routings.put(indexRouting.getKey(), r);, +                    }, +                }, +            }, +        } else {, +            // It's an index, +            if (paramRouting != null) {, +                routings = ImmutableMap.of(aliasOrIndex, paramRouting);, +            }, +        }, +        return routings;, +    }, +, +    /**, +     * Sets the same routing for all indices, +     */, +    private Map<String, Set<String>> resolveSearchRoutingAllIndices(String routing) {, +        if (routing != null) {, +            Set<String> r = Strings.splitStringByCommaToSet(routing);, +            Map<String, Set<String>> routings = newHashMap();, +            String[] concreteIndices = concreteAllIndices();, +            for (String index : concreteIndices) {, +                routings.put(index, r);, +            }, +            return routings;, +        }, +        return null;, +    }, +, +    public String[] concreteIndices(String[] indices) throws IndexMissingException {, +        return concreteIndices(indices, false, false);, +    }, +, +    /**, +     * Translates the provided indices (possibly aliased) into actual indices.]