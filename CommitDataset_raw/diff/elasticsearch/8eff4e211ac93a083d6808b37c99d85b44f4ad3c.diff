[+++ b/core/src/main/java/org/elasticsearch/cluster/ClusterState.java, +import org.elasticsearch.cluster.routing.*;, +import java.util.*;, +        sb.append(blocks().prettyPrint());, +++ b/core/src/main/java/org/elasticsearch/cluster/ClusterState.java, +import org.elasticsearch.cluster.routing.*;, +import java.util.*;, +        sb.append(blocks().prettyPrint());, +++ b/core/src/main/java/org/elasticsearch/cluster/block/ClusterBlocks.java, +    public String prettyPrint() {, +        if (global.isEmpty() && indices().isEmpty()) {, +            return "";, +        }, +        StringBuilder sb = new StringBuilder();, +        sb.append("blocks: \n");, +        if (global.isEmpty() == false) {, +            sb.append("   _global_:\n");, +            for (ClusterBlock block : global) {, +                sb.append("      ").append(block);, +            }, +        }, +        for (ObjectObjectCursor<String, Set<ClusterBlock>> entry : indices()) {, +            sb.append("   ").append(entry.key).append(":\n");, +            for (ClusterBlock block : entry.value) {, +                sb.append("      ").append(block);, +            }, +        }, +        sb.append("\n");, +        return sb.toString();, +    }, +, +++ b/core/src/main/java/org/elasticsearch/cluster/ClusterState.java, +import org.elasticsearch.cluster.routing.*;, +import java.util.*;, +        sb.append(blocks().prettyPrint());, +++ b/core/src/main/java/org/elasticsearch/cluster/block/ClusterBlocks.java, +    public String prettyPrint() {, +        if (global.isEmpty() && indices().isEmpty()) {, +            return "";, +        }, +        StringBuilder sb = new StringBuilder();, +        sb.append("blocks: \n");, +        if (global.isEmpty() == false) {, +            sb.append("   _global_:\n");, +            for (ClusterBlock block : global) {, +                sb.append("      ").append(block);, +            }, +        }, +        for (ObjectObjectCursor<String, Set<ClusterBlock>> entry : indices()) {, +            sb.append("   ").append(entry.key).append(":\n");, +            for (ClusterBlock block : entry.value) {, +                sb.append("      ").append(block);, +            }, +        }, +        sb.append("\n");, +        return sb.toString();, +    }, +, +++ b/core/src/main/java/org/elasticsearch/discovery/zen/NodeJoinController.java, +                    stopAccumulatingJoins("election closed");, +     * master or when {@link #stopAccumulatingJoins(String)} is called., +    public void stopAccumulatingJoins(String reason) {, +        logger.trace("stopping join accumulation ([{}])", reason);, +                processJoins("pending joins after accumulation stop [" + reason + "]");, +            if (context.pendingSetAsMasterTask.get() == false) {, +            }, +++ b/core/src/main/java/org/elasticsearch/cluster/ClusterState.java, +import org.elasticsearch.cluster.routing.*;, +import java.util.*;, +        sb.append(blocks().prettyPrint());, +++ b/core/src/main/java/org/elasticsearch/cluster/block/ClusterBlocks.java, +    public String prettyPrint() {, +        if (global.isEmpty() && indices().isEmpty()) {, +            return "";, +        }, +        StringBuilder sb = new StringBuilder();, +        sb.append("blocks: \n");, +        if (global.isEmpty() == false) {, +            sb.append("   _global_:\n");, +            for (ClusterBlock block : global) {, +                sb.append("      ").append(block);, +            }, +        }, +        for (ObjectObjectCursor<String, Set<ClusterBlock>> entry : indices()) {, +            sb.append("   ").append(entry.key).append(":\n");, +            for (ClusterBlock block : entry.value) {, +                sb.append("      ").append(block);, +            }, +        }, +        sb.append("\n");, +        return sb.toString();, +    }, +, +++ b/core/src/main/java/org/elasticsearch/discovery/zen/NodeJoinController.java, +                    stopAccumulatingJoins("election closed");, +     * master or when {@link #stopAccumulatingJoins(String)} is called., +    public void stopAccumulatingJoins(String reason) {, +        logger.trace("stopping join accumulation ([{}])", reason);, +                processJoins("pending joins after accumulation stop [" + reason + "]");, +            if (context.pendingSetAsMasterTask.get() == false) {]