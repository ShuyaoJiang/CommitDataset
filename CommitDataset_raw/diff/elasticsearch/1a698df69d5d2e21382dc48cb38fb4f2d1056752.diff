[+++ b/modules/elasticsearch/src/main/java/org/elasticsearch/index/gateway/fs/FsIndexShardGateway.java, +import static org.elasticsearch.util.io.FileSystemUtils.*;, +        // we reopen the RAF each snapshot and not keep an open one since we want to make sure we, +        // can sync it to disk later on (close it as well) , +        File translogFile = new File(locationTranslog, "translog-" + translogSnapshot.translogId());, +        RandomAccessFile translogRaf = null;, +, +        // if we have a different trnaslogId (or the file does not exists at all), we want to flush the full, +        // translog to a new file (based on the translogId). If we still work on existing translog, just, +        // append the latest translog operations, +, +        if (translogSnapshot.translogId() != lastTranslogId || !translogFile.exists()) {, +                translogRaf = new RandomAccessFile(translogFile, "rw");, +                StreamOutput out = new DataOutputStreamOutput(translogRaf);, +                translogRaf.seek(0);, +                if (translogRaf.readInt() != -1) {, +                    throw new ElasticSearchIllegalStateException("Wrote to snapshot file [" + translogFile + "] but did not read...");, +                    translogRaf.close();, +                translogRaf = new RandomAccessFile(translogFile, "rw");, +                // seek to the end, since we append, +                translogRaf.seek(translogRaf.length());, +                StreamOutput out = new DataOutputStreamOutput(translogRaf);, +                    translogRaf.close();, +                translogRaf.seek(0);, +                translogRaf.writeInt(translogSnapshot.size());, +                translogRaf.close();, +, +                // now, sync the translog, +                syncFile(translogFile);, +                translogRaf.close();]