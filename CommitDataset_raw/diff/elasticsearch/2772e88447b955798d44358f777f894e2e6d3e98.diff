[+++ b/core/src/main/java/org/elasticsearch/search/aggregations/bucket/geogrid/GeoHashGridParser.java, +import org.elasticsearch.common.ParseField;, +import org.elasticsearch.common.ParseFieldMatcher;, +import org.elasticsearch.common.io.stream.StreamInput;, +import org.elasticsearch.common.io.stream.StreamOutput;, +import org.elasticsearch.common.xcontent.XContentBuilder;, +import org.elasticsearch.common.xcontent.XContentParser.Token;, +import org.elasticsearch.search.aggregations.support.AbstractValuesSourceParser.GeoPointValuesSourceParser;, +import org.elasticsearch.search.aggregations.support.ValueType;, +import org.elasticsearch.search.aggregations.support.ValuesSourceType;, +import java.util.Objects;, +public class GeoHashGridParser extends GeoPointValuesSourceParser {, +, +    public static final int DEFAULT_PRECISION = 5;, +    public static final int DEFAULT_MAX_NUM_CELLS = 10000;, +, +    public GeoHashGridParser() {, +        super(false, false);, +    }, +    @Override, +    public AggregatorFactory getFactoryPrototype() {, +        return new GeoGridFactory(null);, +    }, +    protected ValuesSourceAggregatorFactory<org.elasticsearch.search.aggregations.support.ValuesSource.GeoPoint> createFactory(, +            String aggregationName, ValuesSourceType valuesSourceType,, +            ValueType targetValueType, Map<ParseField, Object> otherOptions) {, +        GeoGridFactory factory = new GeoGridFactory(aggregationName);, +        Integer precision = (Integer) otherOptions.get(GeoHashGridParams.FIELD_PRECISION);, +        if (precision != null) {, +            factory.precision(precision);, +        Integer size = (Integer) otherOptions.get(GeoHashGridParams.FIELD_SIZE);, +        if (size != null) {, +            factory.size(size);, +        Integer shardSize = (Integer) otherOptions.get(GeoHashGridParams.FIELD_SHARD_SIZE);, +        if (shardSize != null) {, +            factory.shardSize(shardSize);, +        }, +        return factory;, +    @Override, +    protected boolean token(String aggregationName, String currentFieldName, Token token, XContentParser parser,, +            ParseFieldMatcher parseFieldMatcher, Map<ParseField, Object> otherOptions) throws IOException {, +        if (token == XContentParser.Token.VALUE_NUMBER || token == XContentParser.Token.VALUE_STRING) {, +            if (parseFieldMatcher.match(currentFieldName, GeoHashGridParams.FIELD_PRECISION)) {, +                otherOptions.put(GeoHashGridParams.FIELD_PRECISION, parser.intValue());, +                return true;, +            } else if (parseFieldMatcher.match(currentFieldName, GeoHashGridParams.FIELD_SIZE)) {, +                otherOptions.put(GeoHashGridParams.FIELD_SIZE, parser.intValue());, +                return true;, +            } else if (parseFieldMatcher.match(currentFieldName, GeoHashGridParams.FIELD_SHARD_SIZE)) {, +                otherOptions.put(GeoHashGridParams.FIELD_SHARD_SIZE, parser.intValue());, +                return true;, +        }, +        }, +        return false;, +    public static class GeoGridFactory extends ValuesSourceAggregatorFactory<ValuesSource.GeoPoint> {, +, +        private int precision = DEFAULT_PRECISION;, +        private int requiredSize = DEFAULT_MAX_NUM_CELLS;, +        private int shardSize = -1;, +, +        public GeoGridFactory(String name) {, +            super(name, InternalGeoHashGrid.TYPE.name(), ValuesSourceType.GEOPOINT, ValueType.GEOPOINT);, +        public void precision(int precision) {, +            this.precision = GeoHashGridParams.checkPrecision(precision);, +        public void size(int size) {, +            this.requiredSize = size;, +        public void shardSize(int shardSize) {, +            if (shardSize == 0) {, +                shardSize = Integer.MAX_VALUE;, +            }, +, +            if (requiredSize == 0) {, +                requiredSize = Integer.MAX_VALUE;, +            }, +, +            if (shardSize < 0) {, +                // Use default heuristic to avoid any wrong-ranking caused by, +                // distributed counting, +                shardSize = BucketUtils.suggestShardSideQueueSize(requiredSize, aggregationContext.searchContext().numberOfShards());, +            }, +, +            if (shardSize < requiredSize) {, +                shardSize = requiredSize;, +            }, +        @Override, +        protected ValuesSourceAggregatorFactory<org.elasticsearch.search.aggregations.support.ValuesSource.GeoPoint> innerReadFrom(, +                String name, ValuesSourceType valuesSourceType,, +                ValueType targetValueType, StreamInput in) throws IOException {, +            GeoGridFactory factory = new GeoGridFactory(name);, +            factory.precision = in.readVInt();, +            factory.requiredSize = in.readVInt();, +            factory.shardSize = in.readVInt();, +            return factory;, +        }, +, +        @Override, +        protected void innerWriteTo(StreamOutput out) throws IOException {, +            out.writeVInt(precision);, +            out.writeVInt(requiredSize);, +            out.writeVInt(shardSize);]