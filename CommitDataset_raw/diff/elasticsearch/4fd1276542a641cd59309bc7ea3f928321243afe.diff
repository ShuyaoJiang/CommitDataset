[+++ b/core/src/main/java/org/elasticsearch/common/util/AbstractArray.java, +import java.util.concurrent.atomic.AtomicBoolean;, +    private final AtomicBoolean closed = new AtomicBoolean(false);, +        if (closed.compareAndSet(false, true)) {, +            try {, +            } finally {, +        }, +    }, +++ b/core/src/main/java/org/elasticsearch/common/util/AbstractArray.java, +import java.util.concurrent.atomic.AtomicBoolean;, +    private final AtomicBoolean closed = new AtomicBoolean(false);, +        if (closed.compareAndSet(false, true)) {, +            try {, +            } finally {, +        }, +    }, +++ b/core/src/main/java/org/elasticsearch/transport/TcpTransport.java, +                        sendMessage(channel, pingHeader, successfulPings::inc);, +                final Runnable closeChannel = () -> {, +                    try {, +                        closeChannels(Collections.singletonList(channel));, +                    } catch (IOException e1) {, +                        logger.debug("failed to close httpOnTransport channel", e1);, +                    }, +                };, +                boolean success = false;, +                try {, +                    sendMessage(channel, new BytesArray(e.getMessage().getBytes(StandardCharsets.UTF_8)), closeChannel);, +                    success = true;, +                } finally {, +                    if (success == false) {, +                        // it's fine to call this more than once, +                        closeChannel.run();, +                    }, +                }, +    protected abstract void sendMessage(Channel channel, BytesReference reference, Runnable sendListener) throws IOException;, +            sendMessage(targetChannel, message, onRequestSent);, +            sendMessage(channel, new CompositeBytesReference(header, bytes), onRequestSent);, +            try {, +            } finally {, +, +        }, +++ b/core/src/main/java/org/elasticsearch/common/util/AbstractArray.java, +import java.util.concurrent.atomic.AtomicBoolean;, +    private final AtomicBoolean closed = new AtomicBoolean(false);, +        if (closed.compareAndSet(false, true)) {, +            try {, +            } finally {, +        }, +    }, +++ b/core/src/main/java/org/elasticsearch/transport/TcpTransport.java, +                        sendMessage(channel, pingHeader, successfulPings::inc);, +                final Runnable closeChannel = () -> {, +                    try {, +                        closeChannels(Collections.singletonList(channel));, +                    } catch (IOException e1) {, +                        logger.debug("failed to close httpOnTransport channel", e1);, +                    }, +                };, +                boolean success = false;, +                try {, +                    sendMessage(channel, new BytesArray(e.getMessage().getBytes(StandardCharsets.UTF_8)), closeChannel);, +                    success = true;, +                } finally {, +                    if (success == false) {, +                        // it's fine to call this more than once, +                        closeChannel.run();, +                    }, +                }, +    protected abstract void sendMessage(Channel channel, BytesReference reference, Runnable sendListener) throws IOException;, +            sendMessage(targetChannel, message, onRequestSent);, +            sendMessage(channel, new CompositeBytesReference(header, bytes), onRequestSent);, +            try {, +            } finally {, +, +        }, +++ b/core/src/main/java/org/elasticsearch/transport/TcpTransportChannel.java, +            release(false);, +            release(true);, +    private void release(boolean isExceptionResponse) {, +        if (released.compareAndSet(false, true)) {, +        } else if (isExceptionResponse == false) {, +            // only fail if we are not sending an error - we might send the error triggered by the previous, +            // sendResponse call, +            throw new IllegalStateException("reserved bytes are already released", releaseBy);, +        }, +++ b/core/src/main/java/org/elasticsearch/common/util/AbstractArray.java, +import java.util.concurrent.atomic.AtomicBoolean;, +    private final AtomicBoolean closed = new AtomicBoolean(false);, +        if (closed.compareAndSet(false, true)) {, +            try {, +            } finally {, +        }, +    }, +++ b/core/src/main/java/org/elasticsearch/transport/TcpTransport.java, +                        sendMessage(channel, pingHeader, successfulPings::inc);, +                final Runnable closeChannel = () -> {, +                    try {, +                        closeChannels(Collections.singletonList(channel));, +                    } catch (IOException e1) {]