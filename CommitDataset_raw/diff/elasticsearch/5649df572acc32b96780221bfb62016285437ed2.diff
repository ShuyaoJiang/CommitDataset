[+++ b/modules/elasticsearch/src/main/java/org/elasticsearch/search/SearchService.java, +import org.elasticsearch.threadpool.ThreadPool;, +import java.util.concurrent.ScheduledFuture;, +    private final long defaultKeepAlive;, +, +    private final ScheduledFuture keepAliveReaper;, +    @Inject public SearchService(Settings settings, ClusterService clusterService, IndicesService indicesService, IndicesLifecycle indicesLifecycle, ThreadPool threadPool, TimerService timerService,, +        TimeValue keepAliveInterval = componentSettings.getAsTime("keep_alive_interval", timeValueMinutes(1));, +        this.defaultKeepAlive = componentSettings.getAsTime("default_keep_alive", timeValueMinutes(5)).millis();, +, +        this.keepAliveReaper = threadPool.scheduleWithFixedDelay(new Reaper(), keepAliveInterval);, +        keepAliveReaper.cancel(false);, +            long keepAlive = defaultKeepAlive;, +                keepAlive = request.scroll().keepAlive().millis();, +        // disable timeout while executing a search, +        context.accessed(-1);, +            context.keepAlive(request.scroll().keepAlive().millis());, +    class Reaper implements Runnable {, +        @Override public void run() {, +            for (SearchContext context : activeContexts.values()) {, +                if (context.lastAccessTime() == -1) { // its being processed or timeout is disabled, +                    continue;, +                if ((timerService.estimatedTimeInMillis() - context.lastAccessTime() > context.keepAlive())) {, +                    freeContext(context);, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/search/SearchService.java, +import org.elasticsearch.threadpool.ThreadPool;, +import java.util.concurrent.ScheduledFuture;, +    private final long defaultKeepAlive;, +, +    private final ScheduledFuture keepAliveReaper;, +    @Inject public SearchService(Settings settings, ClusterService clusterService, IndicesService indicesService, IndicesLifecycle indicesLifecycle, ThreadPool threadPool, TimerService timerService,, +        TimeValue keepAliveInterval = componentSettings.getAsTime("keep_alive_interval", timeValueMinutes(1));, +        this.defaultKeepAlive = componentSettings.getAsTime("default_keep_alive", timeValueMinutes(5)).millis();, +, +        this.keepAliveReaper = threadPool.scheduleWithFixedDelay(new Reaper(), keepAliveInterval);, +        keepAliveReaper.cancel(false);, +            long keepAlive = defaultKeepAlive;, +                keepAlive = request.scroll().keepAlive().millis();, +        // disable timeout while executing a search, +        context.accessed(-1);, +            context.keepAlive(request.scroll().keepAlive().millis());, +    class Reaper implements Runnable {, +        @Override public void run() {, +            for (SearchContext context : activeContexts.values()) {, +                if (context.lastAccessTime() == -1) { // its being processed or timeout is disabled, +                    continue;, +                if ((timerService.estimatedTimeInMillis() - context.lastAccessTime() > context.keepAlive())) {, +                    freeContext(context);, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/search/internal/SearchContext.java, +    private volatile long keepAlive;, +    public long keepAlive() {, +    public void keepAlive(long keepAlive) {]