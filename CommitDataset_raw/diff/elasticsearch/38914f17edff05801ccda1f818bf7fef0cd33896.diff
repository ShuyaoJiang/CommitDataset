[+++ b/core/src/test/java/org/elasticsearch/action/get/GetResponseTests.java, +import static org.elasticsearch.test.hamcrest.ElasticsearchAssertions.assertToXContentEquivalent;, +        assertToXContentEquivalent(originalBytes, finalBytes, xContentType);, +++ b/core/src/test/java/org/elasticsearch/action/get/GetResponseTests.java, +import static org.elasticsearch.test.hamcrest.ElasticsearchAssertions.assertToXContentEquivalent;, +        assertToXContentEquivalent(originalBytes, finalBytes, xContentType);, +++ b/core/src/test/java/org/elasticsearch/index/get/GetFieldTests.java, +import static org.elasticsearch.test.hamcrest.ElasticsearchAssertions.assertToXContentEquivalent;, +        assertToXContentEquivalent(originalBytes, finalBytes, xContentType);, +++ b/core/src/test/java/org/elasticsearch/action/get/GetResponseTests.java, +import static org.elasticsearch.test.hamcrest.ElasticsearchAssertions.assertToXContentEquivalent;, +        assertToXContentEquivalent(originalBytes, finalBytes, xContentType);, +++ b/core/src/test/java/org/elasticsearch/index/get/GetFieldTests.java, +import static org.elasticsearch.test.hamcrest.ElasticsearchAssertions.assertToXContentEquivalent;, +        assertToXContentEquivalent(originalBytes, finalBytes, xContentType);, +++ b/core/src/test/java/org/elasticsearch/index/get/GetResultTests.java, +import static org.elasticsearch.test.hamcrest.ElasticsearchAssertions.assertToXContentEquivalent;, +        assertToXContentEquivalent(originalBytes, finalBytes, xContentType);, +++ b/core/src/test/java/org/elasticsearch/action/get/GetResponseTests.java, +import static org.elasticsearch.test.hamcrest.ElasticsearchAssertions.assertToXContentEquivalent;, +        assertToXContentEquivalent(originalBytes, finalBytes, xContentType);, +++ b/core/src/test/java/org/elasticsearch/index/get/GetFieldTests.java, +import static org.elasticsearch.test.hamcrest.ElasticsearchAssertions.assertToXContentEquivalent;, +        assertToXContentEquivalent(originalBytes, finalBytes, xContentType);, +++ b/core/src/test/java/org/elasticsearch/index/get/GetResultTests.java, +import static org.elasticsearch.test.hamcrest.ElasticsearchAssertions.assertToXContentEquivalent;, +        assertToXContentEquivalent(originalBytes, finalBytes, xContentType);, +++ b/test/framework/src/main/java/org/elasticsearch/test/hamcrest/ElasticsearchAssertions.java, +import org.elasticsearch.common.xcontent.ToXContent;, +import org.elasticsearch.common.xcontent.XContentBuilder;, +import java.util.Iterator;, +     * Asserts that the provided {@link BytesReference}s created through, +     * {@link org.elasticsearch.common.xcontent.ToXContent#toXContent(XContentBuilder, ToXContent.Params)} hold the same content., +     * The comparison is done by parsing both into a map and comparing those two, so that keys ordering doesn't matter., +     * Also binary values (byte[]) are properly compared through arrays comparisons., +    public static void assertToXContentEquivalent(BytesReference expected, BytesReference actual, XContentType xContentType), +            throws IOException {, +        //Note that byte[] holding binary values need special treatment as they need to be properly compared item per item., +                assertMapEquals(expectedMap, actualMap);, +     * Compares two maps recursively, using arrays comparisons for byte[] through Arrays.equals(byte[], byte[]), +    private static void assertMapEquals(Map<String, Object> expected, Map<String, Object> actual) {, +        assertEquals(expected.size(), actual.size());, +        for (Map.Entry<String, Object> expectedEntry : expected.entrySet()) {, +            String expectedKey = expectedEntry.getKey();, +            Object expectedValue = expectedEntry.getValue();, +            if (expectedValue == null) {, +                assertTrue(actual.get(expectedKey) == null && actual.containsKey(expectedKey));, +            } else {, +                Object actualValue = actual.get(expectedKey);, +                assertObjectEquals(expectedValue, actualValue);, +     * Compares two lists recursively, but using arrays comparisons for byte[] through Arrays.equals(byte[], byte[]), +    private static void assertListEquals(List<Object> expected, List<Object> actual) {, +        assertEquals(expected.size(), actual.size());, +        Iterator<Object> actualIterator = actual.iterator();, +        for (Object expectedValue : expected) {, +            Object actualValue = actualIterator.next();, +            assertObjectEquals(expectedValue, actualValue);, +, +    /**, +     * Compares two objects, recursively walking eventual maps and lists encountered, and using arrays comparisons, +     * for byte[] through Arrays.equals(byte[], byte[]), +     */, +    @SuppressWarnings("unchecked"), +    private static void assertObjectEquals(Object expected, Object actual) {, +        if (expected instanceof Map) {, +            assertThat(actual, instanceOf(Map.class));, +            assertMapEquals((Map<String, Object>) expected, (Map<String, Object>) actual);, +        } else if (expected instanceof List) {, +            assertListEquals((List<Object>) expected, (List<Object>) actual);, +        } else if (expected instanceof byte[]) {, +            //byte[] is really a special case for binary values when comparing SMILE and CBOR, arrays of other types, +            //don't need to be handled. Ordinary arrays get parsed as lists., +            assertArrayEquals((byte[]) expected, (byte[]) actual);, +        } else {, +            assertEquals(expected, actual);, +        }]