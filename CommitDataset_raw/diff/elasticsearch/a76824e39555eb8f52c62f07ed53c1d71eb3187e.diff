[+++ b/modules/elasticsearch/src/main/java/org/elasticsearch/gateway/GatewayService.java, +import org.elasticsearch.cluster.routing.IndexRoutingTable;, +import org.elasticsearch.common.collect.ImmutableSet;, +import java.util.Map;, +    public static final ClusterBlock INDEX_NOT_RECOVERED_BLOCK = new ClusterBlock(3, "index not recovered", ClusterBlockLevel.READ_WRITE);, +            } else {, +                for (Map.Entry<String, ImmutableSet<ClusterBlock>> entry : event.state().blocks().indices().entrySet()) {, +                    final String index = entry.getKey();, +                    ImmutableSet<ClusterBlock> indexBlocks = entry.getValue();, +                    if (indexBlocks.contains(GatewayService.INDEX_NOT_RECOVERED_BLOCK)) {, +                        IndexRoutingTable indexRoutingTable = event.state().routingTable().index(index);, +                        if (indexRoutingTable != null && indexRoutingTable.allPrimaryShardsActive()) {, +                            clusterService.submitStateUpdateTask("remove-index-block (all primary shards active for [" + index + "])", new ClusterStateUpdateTask() {, +                                @Override public ClusterState execute(ClusterState currentState) {, +                                    ClusterBlocks.Builder blocks = ClusterBlocks.builder().blocks(currentState.blocks());, +                                    blocks.removeIndexBlock(index, GatewayService.INDEX_NOT_RECOVERED_BLOCK);, +                                    return ClusterState.builder().state(currentState).blocks(blocks).build();, +                                }, +                            });, +                        }, +                    }, +                }, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/gateway/GatewayService.java, +import org.elasticsearch.cluster.routing.IndexRoutingTable;, +import org.elasticsearch.common.collect.ImmutableSet;, +import java.util.Map;, +    public static final ClusterBlock INDEX_NOT_RECOVERED_BLOCK = new ClusterBlock(3, "index not recovered", ClusterBlockLevel.READ_WRITE);, +            } else {, +                for (Map.Entry<String, ImmutableSet<ClusterBlock>> entry : event.state().blocks().indices().entrySet()) {, +                    final String index = entry.getKey();, +                    ImmutableSet<ClusterBlock> indexBlocks = entry.getValue();, +                    if (indexBlocks.contains(GatewayService.INDEX_NOT_RECOVERED_BLOCK)) {, +                        IndexRoutingTable indexRoutingTable = event.state().routingTable().index(index);, +                        if (indexRoutingTable != null && indexRoutingTable.allPrimaryShardsActive()) {, +                            clusterService.submitStateUpdateTask("remove-index-block (all primary shards active for [" + index + "])", new ClusterStateUpdateTask() {, +                                @Override public ClusterState execute(ClusterState currentState) {, +                                    ClusterBlocks.Builder blocks = ClusterBlocks.builder().blocks(currentState.blocks());, +                                    blocks.removeIndexBlock(index, GatewayService.INDEX_NOT_RECOVERED_BLOCK);, +                                    return ClusterState.builder().state(currentState).blocks(blocks).build();, +                                }, +                            });, +                        }, +                    }, +                }, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/gateway/local/LocalGateway.java, +import org.elasticsearch.gateway.GatewayService;, +                                .blocks(ImmutableSet.of(GatewayService.INDEX_NOT_RECOVERED_BLOCK)), +        // nothing to do until we actually recover from the gateway, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/gateway/GatewayService.java, +import org.elasticsearch.cluster.routing.IndexRoutingTable;, +import org.elasticsearch.common.collect.ImmutableSet;, +import java.util.Map;, +    public static final ClusterBlock INDEX_NOT_RECOVERED_BLOCK = new ClusterBlock(3, "index not recovered", ClusterBlockLevel.READ_WRITE);, +            } else {, +                for (Map.Entry<String, ImmutableSet<ClusterBlock>> entry : event.state().blocks().indices().entrySet()) {, +                    final String index = entry.getKey();, +                    ImmutableSet<ClusterBlock> indexBlocks = entry.getValue();, +                    if (indexBlocks.contains(GatewayService.INDEX_NOT_RECOVERED_BLOCK)) {, +                        IndexRoutingTable indexRoutingTable = event.state().routingTable().index(index);, +                        if (indexRoutingTable != null && indexRoutingTable.allPrimaryShardsActive()) {, +                            clusterService.submitStateUpdateTask("remove-index-block (all primary shards active for [" + index + "])", new ClusterStateUpdateTask() {, +                                @Override public ClusterState execute(ClusterState currentState) {, +                                    ClusterBlocks.Builder blocks = ClusterBlocks.builder().blocks(currentState.blocks());, +                                    blocks.removeIndexBlock(index, GatewayService.INDEX_NOT_RECOVERED_BLOCK);, +                                    return ClusterState.builder().state(currentState).blocks(blocks).build();, +                                }, +                            });, +                        }, +                    }, +                }, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/gateway/local/LocalGateway.java, +import org.elasticsearch.gateway.GatewayService;, +                                .blocks(ImmutableSet.of(GatewayService.INDEX_NOT_RECOVERED_BLOCK)), +        // nothing to do until we actually recover from the gateway, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/gateway/local/LocalGatewayNodeAllocation.java, +import org.elasticsearch.gateway.GatewayService;, +            if (!allocation.routingNodes().blocks().hasIndexBlock(indexRoutingTable.index(), GatewayService.INDEX_NOT_RECOVERED_BLOCK)) {, +            if (!routingNodes.blocks().hasIndexBlock(indexRoutingTable.index(), GatewayService.INDEX_NOT_RECOVERED_BLOCK)) {, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/gateway/GatewayService.java, +import org.elasticsearch.cluster.routing.IndexRoutingTable;, +import org.elasticsearch.common.collect.ImmutableSet;, +import java.util.Map;, +    public static final ClusterBlock INDEX_NOT_RECOVERED_BLOCK = new ClusterBlock(3, "index not recovered", ClusterBlockLevel.READ_WRITE);, +            } else {, +                for (Map.Entry<String, ImmutableSet<ClusterBlock>> entry : event.state().blocks().indices().entrySet()) {, +                    final String index = entry.getKey();, +                    ImmutableSet<ClusterBlock> indexBlocks = entry.getValue();, +                    if (indexBlocks.contains(GatewayService.INDEX_NOT_RECOVERED_BLOCK)) {, +                        IndexRoutingTable indexRoutingTable = event.state().routingTable().index(index);, +                        if (indexRoutingTable != null && indexRoutingTable.allPrimaryShardsActive()) {, +                            clusterService.submitStateUpdateTask("remove-index-block (all primary shards active for [" + index + "])", new ClusterStateUpdateTask() {, +                                @Override public ClusterState execute(ClusterState currentState) {, +                                    ClusterBlocks.Builder blocks = ClusterBlocks.builder().blocks(currentState.blocks());, +                                    blocks.removeIndexBlock(index, GatewayService.INDEX_NOT_RECOVERED_BLOCK);, +                                    return ClusterState.builder().state(currentState).blocks(blocks).build();, +                                }, +                            });, +                        }, +                    }, +                }]