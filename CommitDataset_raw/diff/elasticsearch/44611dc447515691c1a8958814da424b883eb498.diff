[+++ b/pom.xml, +        <lucene.snapshot.revision>1681024</lucene.snapshot.revision>, +++ b/pom.xml, +        <lucene.snapshot.revision>1681024</lucene.snapshot.revision>, +++ b/src/main/java/org/elasticsearch/gateway/AsyncShardFetch.java, +    protected final String type;, +    protected AsyncShardFetch(ESLogger logger, String type, ShardId shardId, List<? extends NodesOperationResponse<T>, T> action) {, +        this.type = type;, +                reroute(shardId, "nodes failed [" + failedNodes.size() + "], ignored [" + allIgnoreNodes.size() + "]");, +                        logger.warn("{}: failed to list shard for {} on node [{}]", failure, shardId, type, failure.nodeId());, +++ b/pom.xml, +        <lucene.snapshot.revision>1681024</lucene.snapshot.revision>, +++ b/src/main/java/org/elasticsearch/gateway/AsyncShardFetch.java, +    protected final String type;, +    protected AsyncShardFetch(ESLogger logger, String type, ShardId shardId, List<? extends NodesOperationResponse<T>, T> action) {, +        this.type = type;, +                reroute(shardId, "nodes failed [" + failedNodes.size() + "], ignored [" + allIgnoreNodes.size() + "]");, +                        logger.warn("{}: failed to list shard for {} on node [{}]", failure, shardId, type, failure.nodeId());, +++ b/src/main/java/org/elasticsearch/gateway/GatewayAllocator.java, +                fetch = new InternalAsyncFetch<>(logger, "shard_started", shard.shardId(), startedAction, clusterService, allocationService);, +                logger.trace("{}: ignoring allocation, still fetching shard started state");, +                logger.trace("{}: ignoring allocation, can't be allocated on any node");, +                fetch = new InternalAsyncFetch<>(logger, "shard_store", shard.shardId(), storeAction, clusterService, allocationService);, +                logger.trace("{}: ignoring allocation, still fetching shard stores");, +        public InternalAsyncFetch(ESLogger logger, String type, ShardId shardId, List<? extends NodesOperationResponse<T>, T> action,, +            super(logger, type, shardId, action);, +            clusterService.submitStateUpdateTask("async_shard_fetch(" + type + ") " + shardId + ", reasons (" + reason + ")", Priority.HIGH, new ClusterStateUpdateTask() {, +++ b/pom.xml, +        <lucene.snapshot.revision>1681024</lucene.snapshot.revision>, +++ b/src/main/java/org/elasticsearch/gateway/AsyncShardFetch.java, +    protected final String type;, +    protected AsyncShardFetch(ESLogger logger, String type, ShardId shardId, List<? extends NodesOperationResponse<T>, T> action) {, +        this.type = type;, +                reroute(shardId, "nodes failed [" + failedNodes.size() + "], ignored [" + allIgnoreNodes.size() + "]");, +                        logger.warn("{}: failed to list shard for {} on node [{}]", failure, shardId, type, failure.nodeId());, +++ b/src/main/java/org/elasticsearch/gateway/GatewayAllocator.java, +                fetch = new InternalAsyncFetch<>(logger, "shard_started", shard.shardId(), startedAction, clusterService, allocationService);, +                logger.trace("{}: ignoring allocation, still fetching shard started state");, +                logger.trace("{}: ignoring allocation, can't be allocated on any node");, +                fetch = new InternalAsyncFetch<>(logger, "shard_store", shard.shardId(), storeAction, clusterService, allocationService);, +                logger.trace("{}: ignoring allocation, still fetching shard stores");, +        public InternalAsyncFetch(ESLogger logger, String type, ShardId shardId, List<? extends NodesOperationResponse<T>, T> action,, +            super(logger, type, shardId, action);, +            clusterService.submitStateUpdateTask("async_shard_fetch(" + type + ") " + shardId + ", reasons (" + reason + ")", Priority.HIGH, new ClusterStateUpdateTask() {, +++ b/src/main/java/org/elasticsearch/index/query/AndQueryBuilder.java, +        builder.startObject(AndQueryParser.NAME);, +++ b/pom.xml, +        <lucene.snapshot.revision>1681024</lucene.snapshot.revision>, +++ b/src/main/java/org/elasticsearch/gateway/AsyncShardFetch.java, +    protected final String type;, +    protected AsyncShardFetch(ESLogger logger, String type, ShardId shardId, List<? extends NodesOperationResponse<T>, T> action) {, +        this.type = type;, +                reroute(shardId, "nodes failed [" + failedNodes.size() + "], ignored [" + allIgnoreNodes.size() + "]");, +                        logger.warn("{}: failed to list shard for {} on node [{}]", failure, shardId, type, failure.nodeId());, +++ b/src/main/java/org/elasticsearch/gateway/GatewayAllocator.java, +                fetch = new InternalAsyncFetch<>(logger, "shard_started", shard.shardId(), startedAction, clusterService, allocationService);, +                logger.trace("{}: ignoring allocation, still fetching shard started state");, +                logger.trace("{}: ignoring allocation, can't be allocated on any node");, +                fetch = new InternalAsyncFetch<>(logger, "shard_store", shard.shardId(), storeAction, clusterService, allocationService);, +                logger.trace("{}: ignoring allocation, still fetching shard stores");, +        public InternalAsyncFetch(ESLogger logger, String type, ShardId shardId, List<? extends NodesOperationResponse<T>, T> action,, +            super(logger, type, shardId, action);, +            clusterService.submitStateUpdateTask("async_shard_fetch(" + type + ") " + shardId + ", reasons (" + reason + ")", Priority.HIGH, new ClusterStateUpdateTask() {, +++ b/src/main/java/org/elasticsearch/index/query/AndQueryBuilder.java, +        builder.startObject(AndQueryParser.NAME);, +++ b/src/main/java/org/elasticsearch/index/query/AndQueryParser.java, +public class AndQueryParser implements QueryParser {, +, +    public static final String NAME = "and";, +        return new String[]{NAME};, +++ b/pom.xml, +        <lucene.snapshot.revision>1681024</lucene.snapshot.revision>, +++ b/src/main/java/org/elasticsearch/gateway/AsyncShardFetch.java, +    protected final String type;, +    protected AsyncShardFetch(ESLogger logger, String type, ShardId shardId, List<? extends NodesOperationResponse<T>, T> action) {, +        this.type = type;, +                reroute(shardId, "nodes failed [" + failedNodes.size() + "], ignored [" + allIgnoreNodes.size() + "]");, +                        logger.warn("{}: failed to list shard for {} on node [{}]", failure, shardId, type, failure.nodeId());, +++ b/src/main/java/org/elasticsearch/gateway/GatewayAllocator.java, +                fetch = new InternalAsyncFetch<>(logger, "shard_started", shard.shardId(), startedAction, clusterService, allocationService);, +                logger.trace("{}: ignoring allocation, still fetching shard started state");, +                logger.trace("{}: ignoring allocation, can't be allocated on any node");, +                fetch = new InternalAsyncFetch<>(logger, "shard_store", shard.shardId(), storeAction, clusterService, allocationService);, +                logger.trace("{}: ignoring allocation, still fetching shard stores");, +        public InternalAsyncFetch(ESLogger logger, String type, ShardId shardId, List<? extends NodesOperationResponse<T>, T> action,, +            super(logger, type, shardId, action);, +            clusterService.submitStateUpdateTask("async_shard_fetch(" + type + ") " + shardId + ", reasons (" + reason + ")", Priority.HIGH, new ClusterStateUpdateTask() {, +++ b/src/main/java/org/elasticsearch/index/query/AndQueryBuilder.java, +        builder.startObject(AndQueryParser.NAME);, +++ b/src/main/java/org/elasticsearch/index/query/AndQueryParser.java, +public class AndQueryParser implements QueryParser {, +, +    public static final String NAME = "and";, +        return new String[]{NAME};, +++ /dev/null, +++ b/pom.xml, +        <lucene.snapshot.revision>1681024</lucene.snapshot.revision>, +++ b/src/main/java/org/elasticsearch/gateway/AsyncShardFetch.java, +    protected final String type;, +    protected AsyncShardFetch(ESLogger logger, String type, ShardId shardId, List<? extends NodesOperationResponse<T>, T> action) {]