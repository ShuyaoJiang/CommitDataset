[+++ b/core/src/main/java/org/elasticsearch/action/search/TransportMultiSearchAction.java, +            /*, +             * The number of times that we poll an item from the queue here is the minimum of the number of requests and the maximum number, +             * of concurrent requests. At first glance, it appears that we should never poll from the queue and not obtain a request given, +             * that we only poll here no more times than the number of requests. However, this is not the only consumer of this queue as, +             * earlier requests that have already completed will poll from the queue too and they could complete before later polls are, +             * invoked here. Thus, it can be the case that we poll here and and the queue was empty., +             */, +, +        /*, +         * With a request in hand, we are going to asynchronously execute the search request. When the search request returns, either with, +         * a success or with a failure, we set the response corresponding to the request. Then, we enter a loop that repeatedly pulls, +         * requests off the request queue, this time only setting the response corresponding to the request., +         */, +            public void onResponse(final SearchResponse searchResponse) {, +                handleResponse(request.responseSlot, new MultiSearchResponse.Item(searchResponse, null));, +                executeSearchLoop();, +            }, +, +            @Override, +            public void onFailure(final Exception e) {, +                handleResponse(request.responseSlot, new MultiSearchResponse.Item(null, e));, +                executeSearchLoop();, +            }, +, +            private void handleResponse(final int responseSlot, final MultiSearchResponse.Item item) {, +                responses.set(responseSlot, item);, +                if (responseCounter.decrementAndGet() == 0) {, +                    assert requests.isEmpty();, +                    finish();, +                }, +            }, +, +            private void finish() {, +                listener.onResponse(new MultiSearchResponse(responses.toArray(new MultiSearchResponse.Item[responses.length()])));, +            }, +, +            private void executeSearchLoop() {, +                SearchRequestSlot next;, +                while ((next = requests.poll()) != null) {, +                    final int nextResponseSlot = next.responseSlot;, +                    searchAction.execute(next.request, new ActionListener<SearchResponse>() {, +                        @Override, +                            handleResponse(nextResponseSlot, new MultiSearchResponse.Item(searchResponse, null));, +                            handleResponse(nextResponseSlot, new MultiSearchResponse.Item(null, e));, +                    });, +++ b/core/src/main/java/org/elasticsearch/action/search/TransportMultiSearchAction.java, +            /*, +             * The number of times that we poll an item from the queue here is the minimum of the number of requests and the maximum number, +             * of concurrent requests. At first glance, it appears that we should never poll from the queue and not obtain a request given, +             * that we only poll here no more times than the number of requests. However, this is not the only consumer of this queue as, +             * earlier requests that have already completed will poll from the queue too and they could complete before later polls are, +             * invoked here. Thus, it can be the case that we poll here and and the queue was empty., +             */, +, +        /*, +         * With a request in hand, we are going to asynchronously execute the search request. When the search request returns, either with, +         * a success or with a failure, we set the response corresponding to the request. Then, we enter a loop that repeatedly pulls, +         * requests off the request queue, this time only setting the response corresponding to the request., +         */, +            public void onResponse(final SearchResponse searchResponse) {, +                handleResponse(request.responseSlot, new MultiSearchResponse.Item(searchResponse, null));, +                executeSearchLoop();, +            }, +, +            @Override, +            public void onFailure(final Exception e) {, +                handleResponse(request.responseSlot, new MultiSearchResponse.Item(null, e));, +                executeSearchLoop();, +            }, +, +            private void handleResponse(final int responseSlot, final MultiSearchResponse.Item item) {, +                responses.set(responseSlot, item);, +                if (responseCounter.decrementAndGet() == 0) {, +                    assert requests.isEmpty();, +                    finish();, +                }, +            }, +, +            private void finish() {, +                listener.onResponse(new MultiSearchResponse(responses.toArray(new MultiSearchResponse.Item[responses.length()])));, +            }, +, +            private void executeSearchLoop() {, +                SearchRequestSlot next;, +                while ((next = requests.poll()) != null) {, +                    final int nextResponseSlot = next.responseSlot;, +                    searchAction.execute(next.request, new ActionListener<SearchResponse>() {, +                        @Override, +                            handleResponse(nextResponseSlot, new MultiSearchResponse.Item(searchResponse, null));, +                            handleResponse(nextResponseSlot, new MultiSearchResponse.Item(null, e));, +                    });, +++ b/core/src/test/java/org/elasticsearch/action/search/TransportMultiSearchActionTests.java, +        int maxAllowedConcurrentSearches = scaledRandomIntBetween(1, 16);, +            /*, +             * Allow for a large number of search requests in a single batch as previous implementations could stack overflow if the number, +             * of requests in a single batch was large, +             */, +            int numSearchRequests = scaledRandomIntBetween(1, 8192);]