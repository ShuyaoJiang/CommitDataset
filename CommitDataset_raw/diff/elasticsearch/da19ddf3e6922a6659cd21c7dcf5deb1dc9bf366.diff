[+++ b/core/src/main/java/org/elasticsearch/action/ingest/WriteableIngestDocument.java, +++ b/core/src/main/java/org/elasticsearch/action/ingest/WriteableIngestDocument.java, +++ b/core/src/main/java/org/elasticsearch/ingest/core/IngestDocument.java, +import org.elasticsearch.common.Base64;, +import java.io.IOException;, +import java.util.Arrays;, +import static java.nio.charset.StandardCharsets.UTF_8;, +, +     * Returns the value contained in the document for the provided path as a byte array., +     * If the path value is a string, a base64 decode operation will happen., +     * If the path value is a byte array, it is just returned, +     * @param path The path within the document in dot-notation, +     * @return the byte array for the provided path if existing, +     * @throws IllegalArgumentException if the path is null, empty, invalid, if the field doesn't exist, +     * or if the field that is found at the provided path is not of the expected type., +     */, +    public byte[] getFieldValueAsBytes(String path) {, +        Object object = getFieldValue(path, Object.class);, +        if (object instanceof byte[]) {, +            return (byte[]) object;, +        } else if (object instanceof String) {, +            try {, +                return Base64.decode(object.toString().getBytes(UTF_8));, +            } catch (IOException e) {, +                throw new IllegalArgumentException("Could not base64 decode path [ " + path + "]", e);, +            }, +        } else {, +            throw new IllegalArgumentException("Content field [" + path + "] of unknown type [" + object.getClass().getName() +, +                "], must be string or byte array");, +        }, +    }, +, +    /**, +        } else if (value instanceof byte[]) {, +            byte[] bytes = (byte[]) value;, +            return Arrays.copyOf(bytes, bytes.length);, +++ b/core/src/main/java/org/elasticsearch/action/ingest/WriteableIngestDocument.java, +++ b/core/src/main/java/org/elasticsearch/ingest/core/IngestDocument.java, +import org.elasticsearch.common.Base64;, +import java.io.IOException;, +import java.util.Arrays;, +import static java.nio.charset.StandardCharsets.UTF_8;, +, +     * Returns the value contained in the document for the provided path as a byte array., +     * If the path value is a string, a base64 decode operation will happen., +     * If the path value is a byte array, it is just returned, +     * @param path The path within the document in dot-notation, +     * @return the byte array for the provided path if existing, +     * @throws IllegalArgumentException if the path is null, empty, invalid, if the field doesn't exist, +     * or if the field that is found at the provided path is not of the expected type., +     */, +    public byte[] getFieldValueAsBytes(String path) {, +        Object object = getFieldValue(path, Object.class);, +        if (object instanceof byte[]) {, +            return (byte[]) object;, +        } else if (object instanceof String) {, +            try {, +                return Base64.decode(object.toString().getBytes(UTF_8));, +            } catch (IOException e) {, +                throw new IllegalArgumentException("Could not base64 decode path [ " + path + "]", e);, +            }, +        } else {, +            throw new IllegalArgumentException("Content field [" + path + "] of unknown type [" + object.getClass().getName() +, +                "], must be string or byte array");, +        }, +    }, +, +    /**, +        } else if (value instanceof byte[]) {, +            byte[] bytes = (byte[]) value;, +            return Arrays.copyOf(bytes, bytes.length);, +++ b/core/src/main/java/org/elasticsearch/ingest/core/ValueSource.java, +import java.util.Arrays;, +        } else if (value instanceof byte[]) {, +            return new ByteValue((byte[]) value);, +    final class ByteValue implements ValueSource {, +, +        private final byte[] value;, +, +        ByteValue(byte[] value) {, +            this.value = value;, +        }, +, +        @Override, +        public Object copyAndResolve(Map<String, Object> model) {, +            return value;, +        }, +, +        @Override, +        public boolean equals(Object o) {, +            if (this == o) return true;, +            if (o == null || getClass() != o.getClass()) return false;, +, +            ByteValue objectValue = (ByteValue) o;, +            return Arrays.equals(value, objectValue.value);, +        }, +, +        @Override, +        public int hashCode() {, +            return Arrays.hashCode(value);]