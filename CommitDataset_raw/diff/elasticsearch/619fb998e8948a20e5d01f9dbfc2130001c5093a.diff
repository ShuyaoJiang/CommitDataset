[+++ b/core/src/main/java/org/elasticsearch/index/mapper/FieldMapper.java, +        List<String> subConflicts = new ArrayList<>(); // TODO: just expose list from MergeResult?, +        fieldType().checkTypeName(fieldMergeWith.fieldType(), subConflicts);, +        if (subConflicts.isEmpty() == false) {, +            // return early if field types don't match, +            assert subConflicts.size() == 1;, +            mergeResult.addConflict(subConflicts.get(0));, +            return;, +        }, +, +++ b/core/src/main/java/org/elasticsearch/index/mapper/FieldMapper.java, +        List<String> subConflicts = new ArrayList<>(); // TODO: just expose list from MergeResult?, +        fieldType().checkTypeName(fieldMergeWith.fieldType(), subConflicts);, +        if (subConflicts.isEmpty() == false) {, +            // return early if field types don't match, +            assert subConflicts.size() == 1;, +            mergeResult.addConflict(subConflicts.get(0));, +            return;, +        }, +, +++ b/core/src/main/java/org/elasticsearch/index/mapper/FieldTypeLookup.java, +                ref.get().checkTypeName(fieldMapper.fieldType(), conflicts);, +                if (conflicts.isEmpty()) { // only check compat if they are the same type, +                }, +                indexNameRef.get().checkTypeName(fieldMapper.fieldType(), conflicts);, +                if (conflicts.isEmpty()) { // only check compat if they are the same type, +                }, +++ b/core/src/main/java/org/elasticsearch/index/mapper/FieldMapper.java, +        List<String> subConflicts = new ArrayList<>(); // TODO: just expose list from MergeResult?, +        fieldType().checkTypeName(fieldMergeWith.fieldType(), subConflicts);, +        if (subConflicts.isEmpty() == false) {, +            // return early if field types don't match, +            assert subConflicts.size() == 1;, +            mergeResult.addConflict(subConflicts.get(0));, +            return;, +        }, +, +++ b/core/src/main/java/org/elasticsearch/index/mapper/FieldTypeLookup.java, +                ref.get().checkTypeName(fieldMapper.fieldType(), conflicts);, +                if (conflicts.isEmpty()) { // only check compat if they are the same type, +                }, +                indexNameRef.get().checkTypeName(fieldMapper.fieldType(), conflicts);, +                if (conflicts.isEmpty()) { // only check compat if they are the same type, +                }, +++ b/core/src/main/java/org/elasticsearch/index/mapper/MappedFieldType.java, +    public final void checkTypeName(MappedFieldType other, List<String> conflicts) {, +            conflicts.add("mapper [" + names().fullName() + "] cannot be changed from type [" + typeName() + "] to [" + other.typeName() + "]");, +++ b/core/src/main/java/org/elasticsearch/index/mapper/FieldMapper.java, +        List<String> subConflicts = new ArrayList<>(); // TODO: just expose list from MergeResult?, +        fieldType().checkTypeName(fieldMergeWith.fieldType(), subConflicts);, +        if (subConflicts.isEmpty() == false) {, +            // return early if field types don't match, +            assert subConflicts.size() == 1;, +            mergeResult.addConflict(subConflicts.get(0));, +            return;, +        }, +, +++ b/core/src/main/java/org/elasticsearch/index/mapper/FieldTypeLookup.java, +                ref.get().checkTypeName(fieldMapper.fieldType(), conflicts);, +                if (conflicts.isEmpty()) { // only check compat if they are the same type, +                }, +                indexNameRef.get().checkTypeName(fieldMapper.fieldType(), conflicts);, +                if (conflicts.isEmpty()) { // only check compat if they are the same type, +                }, +++ b/core/src/main/java/org/elasticsearch/index/mapper/MappedFieldType.java, +    public final void checkTypeName(MappedFieldType other, List<String> conflicts) {, +            conflicts.add("mapper [" + names().fullName() + "] cannot be changed from type [" + typeName() + "] to [" + other.typeName() + "]");, +++ b/core/src/test/java/org/elasticsearch/index/mapper/FieldTypeTestCase.java, +        fieldType.checkTypeName(fieldType, conflicts);, +            fieldType.checkTypeName(bogus, conflicts);, +        fieldType.checkTypeName(other, conflicts);, +        assertFalse(conflicts.isEmpty());, +        assertTrue(conflicts.get(0).contains("cannot be changed from type"));, +        assertEquals(1, conflicts.size());, +++ b/core/src/main/java/org/elasticsearch/index/mapper/FieldMapper.java, +        List<String> subConflicts = new ArrayList<>(); // TODO: just expose list from MergeResult?, +        fieldType().checkTypeName(fieldMergeWith.fieldType(), subConflicts);, +        if (subConflicts.isEmpty() == false) {, +            // return early if field types don't match, +            assert subConflicts.size() == 1;, +            mergeResult.addConflict(subConflicts.get(0));, +            return;, +        }, +, +++ b/core/src/main/java/org/elasticsearch/index/mapper/FieldTypeLookup.java, +                ref.get().checkTypeName(fieldMapper.fieldType(), conflicts);, +                if (conflicts.isEmpty()) { // only check compat if they are the same type, +                }, +                indexNameRef.get().checkTypeName(fieldMapper.fieldType(), conflicts);, +                if (conflicts.isEmpty()) { // only check compat if they are the same type, +                }, +++ b/core/src/main/java/org/elasticsearch/index/mapper/MappedFieldType.java, +    public final void checkTypeName(MappedFieldType other, List<String> conflicts) {, +            conflicts.add("mapper [" + names().fullName() + "] cannot be changed from type [" + typeName() + "] to [" + other.typeName() + "]");, +++ b/core/src/test/java/org/elasticsearch/index/mapper/FieldTypeTestCase.java, +        fieldType.checkTypeName(fieldType, conflicts);, +            fieldType.checkTypeName(bogus, conflicts);, +        fieldType.checkTypeName(other, conflicts);, +        assertFalse(conflicts.isEmpty());, +        assertTrue(conflicts.get(0).contains("cannot be changed from type"));]