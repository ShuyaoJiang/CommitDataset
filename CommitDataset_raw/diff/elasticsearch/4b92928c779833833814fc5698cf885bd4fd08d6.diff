[+++ b/.idea/dictionaries/kimchy.xml, +      <w>checksums</w>, +++ b/.idea/dictionaries/kimchy.xml, +      <w>checksums</w>, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/index/store/support/AbstractStore.java, +import java.util.HashMap;, +import java.util.zip.CRC32;, +import java.util.zip.Checksum;, +    public static Map<String, String> readChecksums(Directory dir) throws IOException {, +        long lastFound = -1;, +        for (String name : dir.listAll()) {, +            if (!name.startsWith("_checksums-")) {, +                continue;, +            }, +            long current = Long.parseLong(name.substring("_checksums-".length()));, +            if (current > lastFound) {, +                lastFound = current;, +            }, +        }, +        if (lastFound == -1) {, +            return ImmutableMap.of();, +        }, +        IndexInput indexInput = dir.openInput("_checksums-" + lastFound);, +        try {, +            indexInput.readInt(); // version, +            return indexInput.readStringStringMap();, +        } finally {, +            indexInput.close();, +        }, +    }, +, +    public void writeChecksums() throws IOException {, +        writeChecksums((StoreDirectory) directory());, +    }, +, +    private void writeChecksums(StoreDirectory dir) throws IOException {, +        String checksumName = "_checksums-" + System.currentTimeMillis();, +        ImmutableMap<String, StoreFileMetaData> files = list();, +        synchronized (mutex) {, +            Map<String, String> checksums = new HashMap<String, String>();, +            for (StoreFileMetaData metaData : files.values()) {, +                if (metaData.checksum() != null) {, +                    checksums.put(metaData.name(), metaData.checksum());, +                }, +            }, +            IndexOutput output = dir.createOutput(checksumName, false);, +            output.writeInt(0); // version, +            output.writeStringStringMap(checksums);, +            output.close();, +        }, +        for (StoreFileMetaData metaData : files.values()) {, +            if (metaData.name().startsWith("_checksums") && !checksumName.equals(metaData.name())) {, +                try {, +                    directory().deleteFile(metaData.name());, +                } catch (Exception e) {, +                    // ignore, +                }, +            }, +        }, +    }, +, +        // update the metadata to include the checksum and write a new checksums file, +            writeChecksums();, +                Map<String, String> checksums = readChecksums(delegate);, +                    // BACKWARD CKS SUPPORT, +                    String checksum = checksums.get(file);, +, +                    // BACKWARD CKS SUPPORT, +                    if (checksum == null) {, +                    }, +            // write the checksums file when we sync on the segments file (committed), +            if (!name.equals("segments.gen") && name.startsWith("segments")) {, +                writeChecksums();, +            }, +        private final Checksum digest;, +                    this.digest = new CRC32();, +                checksum = Long.toString(digest.getValue(), Character.MAX_RADIX);, +++ b/.idea/dictionaries/kimchy.xml, +      <w>checksums</w>, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/index/store/support/AbstractStore.java, +import java.util.HashMap;, +import java.util.zip.CRC32;, +import java.util.zip.Checksum;, +    public static Map<String, String> readChecksums(Directory dir) throws IOException {, +        long lastFound = -1;, +        for (String name : dir.listAll()) {, +            if (!name.startsWith("_checksums-")) {, +                continue;, +            }, +            long current = Long.parseLong(name.substring("_checksums-".length()));, +            if (current > lastFound) {, +                lastFound = current;, +            }, +        }, +        if (lastFound == -1) {, +            return ImmutableMap.of();, +        }, +        IndexInput indexInput = dir.openInput("_checksums-" + lastFound);, +        try {, +            indexInput.readInt(); // version]