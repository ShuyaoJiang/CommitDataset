[+++ b/modules/elasticsearch/src/main/java/org/elasticsearch/common/io/stream/CachedStreamOutput.java, +    public static int BYTES_LIMIT = 1 * 1024 * 1024; // don't cache entries that are bigger than that..., +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/common/io/stream/CachedStreamOutput.java, +    public static int BYTES_LIMIT = 1 * 1024 * 1024; // don't cache entries that are bigger than that..., +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/transport/netty/MessageChannelHandler.java, +import org.elasticsearch.common.netty.buffer.ChannelBuffers;, +import org.elasticsearch.common.netty.channel.Channel;, +import org.elasticsearch.common.netty.channel.ChannelStateEvent;, +import java.io.StreamCorruptedException;, +import java.net.SocketAddress;, + * A handler (must be the last one!) that does size based frame decoding and forwards the actual message, + * to the relevant action., +    // from FrameDecoder, +    private ChannelBuffer cumulation;, +, +    // similar logic to FrameDecoder, we don't use FrameDecoder because we can use the data len header value, +    // to guess the size of the cumulation buffer to allocate, +    // Also strange, is that the FrameDecoder always allocated a cumulation, even if the input bufer is enough, +    // so we don't allocate a cumulation buffer unless we really need to here (need to post this to the mailing list), +    @Override public void messageReceived(ChannelHandlerContext ctx, MessageEvent e) throws Exception {, +        Object m = e.getMessage();, +        if (!(m instanceof ChannelBuffer)) {, +            ctx.sendUpstream(e);, +            return;, +        }, +        ChannelBuffer input = (ChannelBuffer) m;, +        if (!input.readable()) {, +            return;, +        }, +, +        ChannelBuffer cumulation = this.cumulation;, +        if (cumulation != null && cumulation.readable()) {, +            cumulation.discardReadBytes();, +            cumulation.writeBytes(input);, +            callDecode(ctx, e.getChannel(), cumulation, e.getRemoteAddress());, +        } else {, +            int actualSize = callDecode(ctx, e.getChannel(), input, e.getRemoteAddress());, +            if (input.readable()) {, +                if (actualSize > 0) {, +                    cumulation = ChannelBuffers.dynamicBuffer(actualSize, ctx.getChannel().getConfig().getBufferFactory());, +                } else {, +                    cumulation = ChannelBuffers.dynamicBuffer(ctx.getChannel().getConfig().getBufferFactory());, +                }, +                cumulation.writeBytes(input);, +                this.cumulation = cumulation;, +            }, +        }, +    }, +, +    @Override, +    public void channelDisconnected(, +            ChannelHandlerContext ctx, ChannelStateEvent e) throws Exception {, +        cleanup(ctx, e);, +    }, +, +    @Override, +    public void channelClosed(, +            ChannelHandlerContext ctx, ChannelStateEvent e) throws Exception {, +        cleanup(ctx, e);, +    }, +, +    private int callDecode(ChannelHandlerContext context, Channel channel, ChannelBuffer cumulation, SocketAddress remoteAddress) throws Exception {, +        while (cumulation.readable()) {, +            // Changes from Frame Decoder, to combine SizeHeader and this decoder into one..., +            if (cumulation.readableBytes() < 4) {, +                break; // we need more data, +            }, +, +            int dataLen = cumulation.getInt(cumulation.readerIndex());, +            if (dataLen <= 0) {, +                throw new StreamCorruptedException("invalid data length: " + dataLen);, +            }, +, +            int actualSize = dataLen + 4;, +            if (cumulation.readableBytes() < actualSize) {, +                return actualSize;, +            }, +, +            cumulation.skipBytes(4);, +, +            process(context, channel, cumulation, dataLen);, +        }, +, +        // TODO: we can potentially create a cumulation buffer cache, pop/push style, +        if (!cumulation.readable()) {, +            this.cumulation = null;, +        }, +, +        return 0;, +    }, +, +, +    private void cleanup(ChannelHandlerContext ctx, ChannelStateEvent e) throws Exception {, +        try {, +            ChannelBuffer cumulation = this.cumulation;, +            if (cumulation == null) {, +                return;, +            } else {, +                this.cumulation = null;, +            }]