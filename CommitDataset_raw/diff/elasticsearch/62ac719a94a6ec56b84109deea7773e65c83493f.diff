[+++ b/modules/reindex/src/main/java/org/elasticsearch/index/reindex/AbstractAsyncBulkByScrollAction.java, +                        TimeValue delay = retries.next();, +                        logger.trace("retrying rejected search after [{}]", e, delay);, +                        threadPool.schedule(delay, ThreadPool.Names.SAME, this);, +++ b/modules/reindex/src/main/java/org/elasticsearch/index/reindex/AbstractAsyncBulkByScrollAction.java, +                        TimeValue delay = retries.next();, +                        logger.trace("retrying rejected search after [{}]", e, delay);, +                        threadPool.schedule(delay, ThreadPool.Names.SAME, this);, +++ b/modules/reindex/src/test/java/org/elasticsearch/index/reindex/ReindexTestCase.java, +    public static BulkIndexByScrollResponseMatcher matcher() {, +++ b/modules/reindex/src/main/java/org/elasticsearch/index/reindex/AbstractAsyncBulkByScrollAction.java, +                        TimeValue delay = retries.next();, +                        logger.trace("retrying rejected search after [{}]", e, delay);, +                        threadPool.schedule(delay, ThreadPool.Names.SAME, this);, +++ b/modules/reindex/src/test/java/org/elasticsearch/index/reindex/ReindexTestCase.java, +    public static BulkIndexByScrollResponseMatcher matcher() {, +++ b/modules/reindex/src/test/java/org/elasticsearch/index/reindex/RetryTests.java, +import org.elasticsearch.action.admin.cluster.node.tasks.list.ListTasksResponse;, +import org.elasticsearch.test.ESSingleNodeTestCase;, +import org.elasticsearch.threadpool.ThreadPool;, +import org.junit.After;, +import org.junit.Before;, +import java.util.concurrent.CyclicBarrier;, +import static org.elasticsearch.index.reindex.ReindexTestCase.matcher;, +import static org.hamcrest.Matchers.hasSize;, +public class RetryTests extends ESSingleNodeTestCase {, +    private static final int DOC_COUNT = 20;, +, +    private List<CyclicBarrier> blockedExecutors = new ArrayList<>();, +, +    @Override, +    protected Collection<Class<? extends Plugin>> getPlugins() {, +        return pluginList(ReindexPlugin.class);, +    }, +    protected Settings nodeSettings() {, +        Settings.Builder settings = Settings.builder().put(super.nodeSettings());, +        // Use pools of size 1 so we can block them, +        // Use queues of size 1 because size 0 is broken and because search requests need the queue to function, +        settings.put("threadpool.bulk.queue_size", 1);, +        settings.put("threadpool.search.queue_size", 1);, +    @Before, +    public void setupSourceIndex() throws Exception {, +        createIndex("source");, +            bulk.add(client().prepareIndex("source", "test").setSource("foo", "bar " + i));, +        client().admin().indices().prepareRefresh("source").get();, +    }, +, +    @After, +    public void forceUnblockAllExecutors() {, +        for (CyclicBarrier barrier: blockedExecutors) {, +            barrier.reset();, +        }, +    }, +, +    public void testReindex() throws Exception {, +        testCase(ReindexAction.NAME, ReindexAction.INSTANCE.newRequestBuilder(client()).source("source").destination("dest"),, +                matcher().created(DOC_COUNT));, +    }, +, +    public void testUpdateByQuery() throws Exception {, +        testCase(UpdateByQueryAction.NAME, UpdateByQueryAction.INSTANCE.newRequestBuilder(client()).source("source"),, +                matcher().updated(DOC_COUNT));, +    }, +, +    private void testCase(String action, AbstractBulkIndexByScrollRequestBuilder<?, ?> request, BulkIndexByScrollResponseMatcher matcher), +            throws Exception {, +        logger.info("Blocking search");, +        CyclicBarrier initialSearchBlock = blockExecutor(ThreadPool.Names.SEARCH);, +, +        // Make sure we use more than one batch so we have to scroll, +        request.source().setSize(DOC_COUNT / randomIntBetween(2, 10));, +, +        logger.info("Starting request");, +        ListenableActionFuture<BulkIndexByScrollResponse> responseListener = request.execute();, +, +        logger.info("Waiting for search rejections on the initial search");, +        assertBusy(() -> assertThat(taskStatus(action).getSearchRetries(), greaterThan(0L)));, +, +        logger.info("Blocking bulk and unblocking search so we start to get bulk rejections");, +        CyclicBarrier bulkBlock = blockExecutor(ThreadPool.Names.BULK);, +        initialSearchBlock.await();, +, +        logger.info("Waiting for bulk rejections");, +        assertBusy(() -> assertThat(taskStatus(action).getBulkRetries(), greaterThan(0L)));, +, +        // Keep a copy of the current number of search rejections so we can assert that we get more when we block the scroll, +        long initialSearchRejections = taskStatus(action).getSearchRetries();, +, +        logger.info("Blocking search and unblocking bulk so we should get search rejections for the scroll");, +        CyclicBarrier scrollBlock = blockExecutor(ThreadPool.Names.SEARCH);, +        bulkBlock.await();, +, +        logger.info("Waiting for search rejections for the scroll");, +        assertBusy(() -> assertThat(taskStatus(action).getSearchRetries(), greaterThan(initialSearchRejections)));, +, +        logger.info("Unblocking the scroll");, +        scrollBlock.await();, +, +        logger.info("Waiting for the request to finish");, +        BulkIndexByScrollResponse response = responseListener.get();]