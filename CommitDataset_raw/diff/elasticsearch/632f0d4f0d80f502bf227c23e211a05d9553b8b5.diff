[+++ b/config/logging.yml, +++ b/config/logging.yml, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/action/support/broadcast/TransportBroadcastOperationAction.java, +import com.google.common.collect.ImmutableList;, +import org.elasticsearch.index.shard.ShardId;, +import org.elasticsearch.util.io.ThrowableObjectInputStream;, +import org.elasticsearch.util.io.ThrowableObjectOutputStream;, +import org.elasticsearch.util.io.stream.StreamInput;, +import org.elasticsearch.util.io.stream.StreamOutput;, +import org.elasticsearch.util.io.stream.Streamable;, +import java.io.IOException;, +import java.util.List;, +import static com.google.common.collect.Lists.*;, +, + * @author kimchy (shay.banon), +    class AsyncBroadcastAction {, +        AsyncBroadcastAction(Request request, ActionListener<Response> listener) {, +    class TransportHandler extends BaseTransportRequestHandler<Request> {, +    class ShardTransportHandler extends BaseTransportRequestHandler<ShardRequest> {, +, +    // FROM HERE: When we move to a single remote call with all shard requests to the same node, then, +    // the below classes can help, +, +    class ShardsTransportHandler extends BaseTransportRequestHandler<ShardsRequest> {, +, +        @Override public ShardsRequest newInstance() {, +            return new ShardsRequest();, +        }, +, +        @Override public void messageReceived(final ShardsRequest request, final TransportChannel channel) throws Exception {, +            if (request.operationThreading() == BroadcastOperationThreading.THREAD_PER_SHARD) {, +                final AtomicInteger counter = new AtomicInteger(request.requests().size());, +                final AtomicInteger index = new AtomicInteger();, +                final AtomicReferenceArray results = new AtomicReferenceArray(request.requests().size());, +                for (final ShardRequest singleRequest : request.requests()) {, +                    threadPool.execute(new Runnable() {, +                        @Override public void run() {, +                            int arrIndex = index.getAndIncrement();, +                            try {, +                                results.set(arrIndex, shardOperation(singleRequest));, +                            } catch (Exception e) {, +                                results.set(arrIndex, new BroadcastShardOperationFailedException(new ShardId(singleRequest.index(), singleRequest.shardId()), e));, +                            }, +                            if (counter.decrementAndGet() == 0) {, +                                // we are done, +                                List<ShardResponse> responses = newArrayListWithCapacity(request.requests().size());, +                                List<BroadcastShardOperationFailedException> exceptions = null;, +                                for (int i = 0; i < results.length(); i++) {, +                                    Object result = results.get(i);, +                                    if (result instanceof BroadcastShardOperationFailedException) {, +                                        if (exceptions == null) {, +                                            exceptions = newArrayList();, +                                        }, +                                        exceptions.add((BroadcastShardOperationFailedException) result);, +                                    } else {, +                                        responses.add((ShardResponse) result);, +                                    }, +                                }, +                                try {, +                                    channel.sendResponse(new ShardsResponse(responses, exceptions));, +                                } catch (IOException e) {, +                                    logger.warn("Failed to send broadcast response", e);, +                                }, +                            }, +                        }, +                    });, +                }, +            } else {, +                // single thread, +                threadPool.execute(new Runnable() {, +                    @Override public void run() {, +                        List<ShardResponse> responses = newArrayListWithCapacity(request.requests().size());, +                        List<BroadcastShardOperationFailedException> exceptions = null;, +                        for (ShardRequest singleRequest : request.requests()) {, +                            try {, +                                responses.add(shardOperation(singleRequest));, +                            } catch (Exception e) {, +                                if (exceptions == null) {, +                                    exceptions = newArrayList();, +                                }, +                                exceptions.add(new BroadcastShardOperationFailedException(new ShardId(singleRequest.index(), singleRequest.shardId()), e));, +                            }, +                        }, +                        try {, +                            channel.sendResponse(new ShardsResponse(responses, exceptions));, +                        } catch (IOException e) {, +                            logger.warn("Failed to send broadcast response", e);, +                        }, +                    }, +                });, +            }, +        }, +, +        @Override public boolean spawn() {, +            // we handle the forking here..., +            return false;, +        }, +    }, +, +    class ShardsResponse implements Streamable {]