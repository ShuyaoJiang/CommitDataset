[+++ b/src/main/java/org/elasticsearch/common/lucene/uid/PerThreadIDAndVersionLookup.java, +package org.elasticsearch.common.lucene.uid;, +, +/*, + * Licensed to Elasticsearch under one or more contributor, + * license agreements. See the NOTICE file distributed with, + * this work for additional information regarding copyright, + * ownership. Elasticsearch licenses this file to you under, + * the Apache License, Version 2.0 (the "License"); you may, + * not use this file except in compliance with the License., + * You may obtain a copy of the License at, + *, + *    http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing,, + * software distributed under the License is distributed on an, + * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY, + * KIND, either express or implied.  See the License for the, + * specific language governing permissions and limitations, + * under the License., + */, +, +import java.io.IOException;, +import java.util.ArrayList;, +import java.util.Collections;, +import java.util.Comparator;, +import java.util.List;, +, +import org.apache.lucene.index.AtomicReaderContext;, +import org.apache.lucene.index.DocsAndPositionsEnum;, +import org.apache.lucene.index.DocsEnum;, +import org.apache.lucene.index.Fields;, +import org.apache.lucene.index.IndexReader;, +import org.apache.lucene.index.NumericDocValues;, +import org.apache.lucene.index.Terms;, +import org.apache.lucene.index.TermsEnum;, +import org.apache.lucene.util.Bits;, +import org.apache.lucene.util.BytesRef;, +import org.apache.lucene.util.CollectionUtil;, +import org.elasticsearch.common.Numbers;, +import org.elasticsearch.common.lucene.uid.Versions.DocIdAndVersion;, +import org.elasticsearch.index.mapper.internal.UidFieldMapper;, +import org.elasticsearch.index.mapper.internal.VersionFieldMapper;, +, +, +/** Utility class to do efficient primary-key (only 1 doc contains the, + *  given term) lookups by segment, re-using the enums.  This class is, + *  not thread safe, so it is the caller's job to create and use one, + *  instance of this per thread.  Do not use this if a term may appear, + *  in more than one document!  It will only return the first one it, + *  finds. */, +, +final class PerThreadIDAndVersionLookup {, +, +    private final AtomicReaderContext[] readerContexts;, +    private final TermsEnum[] termsEnums;, +    private final DocsEnum[] docsEnums;, +    // Only used for back compat, to lookup a version from payload:, +    private final DocsAndPositionsEnum[] posEnums;, +    private final Bits[] liveDocs;, +    private final NumericDocValues[] versions;, +    private final int numSegs;, +    private final boolean hasDeletions;, +    private final boolean[] hasPayloads;, +, +    public PerThreadIDAndVersionLookup(IndexReader r) throws IOException {, +, +        List<AtomicReaderContext> leaves = new ArrayList<>(r.leaves());, +, +        readerContexts = leaves.toArray(new AtomicReaderContext[leaves.size()]);, +        termsEnums = new TermsEnum[leaves.size()];, +        docsEnums = new DocsEnum[leaves.size()];, +        posEnums = new DocsAndPositionsEnum[leaves.size()];, +        liveDocs = new Bits[leaves.size()];, +        versions = new NumericDocValues[leaves.size()];, +        hasPayloads = new boolean[leaves.size()];, +        int numSegs = 0;, +        boolean hasDeletions = false;, +        // iterate backwards to optimize for the frequently updated documents, +        // which are likely to be in the last segments, +        for(int i=leaves.size()-1;i>=0;i--) {, +            AtomicReaderContext readerContext = leaves.get(i);, +            Fields fields = readerContext.reader().fields();, +            if (fields != null) {, +                Terms terms = fields.terms(UidFieldMapper.NAME);, +                if (terms != null) {, +                    readerContexts[numSegs] = readerContext;, +                    hasPayloads[numSegs] = terms.hasPayloads();, +                    termsEnums[numSegs] = terms.iterator(null);, +                    assert termsEnums[numSegs] != null;, +                    liveDocs[numSegs] = readerContext.reader().getLiveDocs();, +                    hasDeletions |= readerContext.reader().hasDeletions();, +                    versions[numSegs] = readerContext.reader().getNumericDocValues(VersionFieldMapper.NAME);, +                    numSegs++;, +                }, +            }, +        }, +        this.numSegs = numSegs;, +        this.hasDeletions = hasDeletions;, +    }]