[+++ b/core/src/main/java/org/elasticsearch/common/cache/Cache.java, +        Map<K, Entry<K, V>> map = new HashMap<>();, +            Entry<K, V> entry;, +                entry = map.get(key);, +            if (entry != null) {, +                existing = map.put(key, entry);, +            Entry<K, V> entry;, +                entry = map.remove(key);, +            if (entry != null) {, +     * value using the given mapping function and enters it into this map unless null., +            // we synchronize against the segment lock; this is to avoid a scenario where another thread is inserting, +            // a value for the same key via put which would not be observed on this thread without a mechanism, +            // synchronizing the two threads; it is possible that the segment lock will be too expensive here (it blocks, +            // readers too!) so consider this as a possible place to optimize should contention be observed, +                value = get(key, now);, +                if (value == null) {, +                        value = loader.load(key);, +                    } catch (Exception e) {, +                        throw new ExecutionException(e);, +                    if (value == null) {, +                    put(key, value, now);, +            }, +++ b/core/src/main/java/org/elasticsearch/common/cache/Cache.java, +        Map<K, Entry<K, V>> map = new HashMap<>();, +            Entry<K, V> entry;, +                entry = map.get(key);, +            if (entry != null) {, +                existing = map.put(key, entry);, +            Entry<K, V> entry;, +                entry = map.remove(key);, +            if (entry != null) {, +     * value using the given mapping function and enters it into this map unless null., +            // we synchronize against the segment lock; this is to avoid a scenario where another thread is inserting, +            // a value for the same key via put which would not be observed on this thread without a mechanism, +            // synchronizing the two threads; it is possible that the segment lock will be too expensive here (it blocks, +            // readers too!) so consider this as a possible place to optimize should contention be observed, +                value = get(key, now);, +                if (value == null) {, +                        value = loader.load(key);, +                    } catch (Exception e) {, +                        throw new ExecutionException(e);, +                    if (value == null) {, +                    put(key, value, now);, +            }, +++ b/core/src/main/java/org/elasticsearch/common/lucene/index/ElasticsearchDirectoryReader.java, +import org.apache.lucene.index.DirectoryReader;, +import org.apache.lucene.index.FilterDirectoryReader;, +import org.apache.lucene.index.FilterLeafReader;, +import org.apache.lucene.index.LeafReader;, +++ b/core/src/main/java/org/elasticsearch/common/cache/Cache.java, +        Map<K, Entry<K, V>> map = new HashMap<>();, +            Entry<K, V> entry;, +                entry = map.get(key);, +            if (entry != null) {, +                existing = map.put(key, entry);, +            Entry<K, V> entry;, +                entry = map.remove(key);, +            if (entry != null) {, +     * value using the given mapping function and enters it into this map unless null., +            // we synchronize against the segment lock; this is to avoid a scenario where another thread is inserting, +            // a value for the same key via put which would not be observed on this thread without a mechanism, +            // synchronizing the two threads; it is possible that the segment lock will be too expensive here (it blocks, +            // readers too!) so consider this as a possible place to optimize should contention be observed, +                value = get(key, now);, +                if (value == null) {, +                        value = loader.load(key);, +                    } catch (Exception e) {, +                        throw new ExecutionException(e);, +                    if (value == null) {, +                    put(key, value, now);, +            }, +++ b/core/src/main/java/org/elasticsearch/common/lucene/index/ElasticsearchDirectoryReader.java, +import org.apache.lucene.index.DirectoryReader;, +import org.apache.lucene.index.FilterDirectoryReader;, +import org.apache.lucene.index.FilterLeafReader;, +import org.apache.lucene.index.LeafReader;, +++ b/core/src/main/java/org/elasticsearch/common/lucene/index/ElasticsearchLeafReader.java, +import org.apache.lucene.index.DirectoryReader;, +import org.apache.lucene.index.FilterDirectoryReader;, +import org.apache.lucene.index.FilterLeafReader;, +import org.apache.lucene.index.LeafReader;, +    ElasticsearchLeafReader(LeafReader in, ShardId shardId) {, +    @Override, +    public Object getCombinedCoreAndDeletesKey() {, +        return in.getCombinedCoreAndDeletesKey();, +++ b/core/src/main/java/org/elasticsearch/common/cache/Cache.java, +        Map<K, Entry<K, V>> map = new HashMap<>();, +            Entry<K, V> entry;, +                entry = map.get(key);, +            if (entry != null) {, +                existing = map.put(key, entry);, +            Entry<K, V> entry;, +                entry = map.remove(key);, +            if (entry != null) {, +     * value using the given mapping function and enters it into this map unless null., +            // we synchronize against the segment lock; this is to avoid a scenario where another thread is inserting, +            // a value for the same key via put which would not be observed on this thread without a mechanism, +            // synchronizing the two threads; it is possible that the segment lock will be too expensive here (it blocks, +            // readers too!) so consider this as a possible place to optimize should contention be observed, +                value = get(key, now);]