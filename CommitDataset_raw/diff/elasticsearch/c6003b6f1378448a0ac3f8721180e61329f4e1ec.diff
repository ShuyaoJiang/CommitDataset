[+++ b/core/src/main/java/org/elasticsearch/index/translog/BufferingTranslogWriter.java, +                try {, +                } catch (Throwable ex) {, +                    closeWithTragicEvent(ex);, +                    throw ex;, +                }, +            } else {, +            }, +            operationCounter++;, +            ensureOpen();, +            final int bufferSize = bufferCount;, +            try {, +                Channels.writeToChannel(buffer, 0, bufferSize, channel);, +            } catch (Throwable ex) {, +                closeWithTragicEvent(ex);, +                throw ex;, +            }, +            writtenOffset += bufferSize;, +    public synchronized void sync() throws IOException {, +        if (syncNeeded()) {, +            ensureOpen(); // this call gives a better exception that the incRef if we are closed by a tragic event, +                final long offsetToSync;, +                final int opsCounter;, +                    offsetToSync = totalOffset;, +                    opsCounter = operationCounter;, +                try {, +                    ensureOpen(); // just for kicks - the checkpoint happens or not either way, +                    checkpoint(offsetToSync, opsCounter, channelReference);, +                } catch (IOException ex) {, +                    closeWithTragicEvent(ex);, +                    throw ex;, +                }, +                lastSyncedOffset = offsetToSync;, +++ b/core/src/main/java/org/elasticsearch/index/translog/BufferingTranslogWriter.java, +                try {, +                } catch (Throwable ex) {, +                    closeWithTragicEvent(ex);, +                    throw ex;, +                }, +            } else {, +            }, +            operationCounter++;, +            ensureOpen();, +            final int bufferSize = bufferCount;, +            try {, +                Channels.writeToChannel(buffer, 0, bufferSize, channel);, +            } catch (Throwable ex) {, +                closeWithTragicEvent(ex);, +                throw ex;, +            }, +            writtenOffset += bufferSize;, +    public synchronized void sync() throws IOException {, +        if (syncNeeded()) {, +            ensureOpen(); // this call gives a better exception that the incRef if we are closed by a tragic event, +                final long offsetToSync;, +                final int opsCounter;, +                    offsetToSync = totalOffset;, +                    opsCounter = operationCounter;, +                try {, +                    ensureOpen(); // just for kicks - the checkpoint happens or not either way, +                    checkpoint(offsetToSync, opsCounter, channelReference);, +                } catch (IOException ex) {, +                    closeWithTragicEvent(ex);, +                    throw ex;, +                }, +                lastSyncedOffset = offsetToSync;, +++ b/core/src/main/java/org/elasticsearch/index/translog/Translog.java, +    private volatile long lastCommittedTranslogFileGeneration = -1; // -1 is safe as it will not cause an translog deletion., +                    current.sync();, +                } finally {, +                    try {, +                }, +            newFile = TranslogWriter.create(config.getType(), shardId, translogUUID, fileGeneration, location.resolve(getFilename(fileGeneration)), new OnCloseRunnable(), config.getBufferSize(), getChannelFactory());, +    TranslogWriter.ChannelFactory getChannelFactory() {, +        return TranslogWriter.ChannelFactory.DEFAULT;, +    }, +, +++ b/core/src/main/java/org/elasticsearch/index/translog/BufferingTranslogWriter.java, +                try {, +                } catch (Throwable ex) {, +                    closeWithTragicEvent(ex);, +                    throw ex;, +                }, +            } else {, +            }, +            operationCounter++;, +            ensureOpen();, +            final int bufferSize = bufferCount;, +            try {, +                Channels.writeToChannel(buffer, 0, bufferSize, channel);, +            } catch (Throwable ex) {, +                closeWithTragicEvent(ex);, +                throw ex;, +            }, +            writtenOffset += bufferSize;, +    public synchronized void sync() throws IOException {, +        if (syncNeeded()) {, +            ensureOpen(); // this call gives a better exception that the incRef if we are closed by a tragic event, +                final long offsetToSync;, +                final int opsCounter;]