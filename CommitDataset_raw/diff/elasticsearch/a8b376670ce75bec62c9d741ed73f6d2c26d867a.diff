[+++ b/core/src/main/java/org/elasticsearch/action/search/AbstractSearchAsyncAction.java, +    protected ShardFetchSearchRequest createFetchRequest(long queryId, int index, IntArrayList entry,, +        return new ShardFetchSearchRequest(request, queryId, entry, lastEmittedDoc);, +            getExecutor().execute(new ActionRunnable<SearchResponse>(listener) {, +                @Override, +                public void doRun() throws IOException {, +                    // we do the heavy lifting in this inner run method where we reduce aggs etc. that's why we fork this phase, +                    // off immediately instead of forking when we send back the response to the user since there we only need, +                    // to merge together the fetched results which is a linear operation., +                    innerRun();, +                }, +, +                @Override, +                public void onFailure(Exception e) {, +                    ReduceSearchPhaseException failure = new ReduceSearchPhaseException("fetch", "", e, buildShardFailures());, +                    if (logger.isDebugEnabled()) {, +                        logger.debug("failed to reduce search", failure);, +                    }, +                    super.onFailure(failure);, +                }, +            });, +        }, +, +        private void innerRun() throws IOException{, +            final int numShards = shardsIts.size();, +            String scrollId = isScrollRequest ? TransportSearchHelper.buildScrollId(queryResults) : null;, +            List<AtomicArray.Entry<QuerySearchResultProvider>> queryResultsAsList = queryResults.asList();, +            final SearchPhaseController.ReducedQueryPhase reducedQueryPhase = searchPhaseController.reducedQueryPhase(queryResultsAsList);, +            final boolean queryAndFetchOptimization = queryResults.length() == 1;, +            final IntConsumer finishPhase = successOpts, +                -> sendResponse(searchPhaseController, sortedShardDocs, scrollId, reducedQueryPhase, queryAndFetchOptimization ?, +                    queryResults : fetchResults);, +            if (queryAndFetchOptimization) {, +                finishPhase.accept(successfulOps.get());, +                final IntArrayList[] docIdsToLoad = searchPhaseController.fillDocIdsToLoad(numShards, sortedShardDocs);, +                    queryResultsAsList.stream(), +                        searchPhaseController.getLastEmittedDocPerShard(reducedQueryPhase, sortedShardDocs, numShards), +                            ShardFetchSearchRequest fetchSearchRequest = createFetchRequest(queryResult.queryResult().id(), i, entry,, +         * Sends back a result to the user., +        private void sendResponse(SearchPhaseController searchPhaseController, ScoreDoc[] sortedDocs,, +                                String scrollId, SearchPhaseController.ReducedQueryPhase reducedQueryPhase,, +            final InternalSearchResponse internalResponse = searchPhaseController.merge(isScrollRequest, sortedDocs, reducedQueryPhase,, +    }, +, +++ b/core/src/main/java/org/elasticsearch/action/search/AbstractSearchAsyncAction.java, +    protected ShardFetchSearchRequest createFetchRequest(long queryId, int index, IntArrayList entry,, +        return new ShardFetchSearchRequest(request, queryId, entry, lastEmittedDoc);, +            getExecutor().execute(new ActionRunnable<SearchResponse>(listener) {, +                @Override, +                public void doRun() throws IOException {, +                    // we do the heavy lifting in this inner run method where we reduce aggs etc. that's why we fork this phase, +                    // off immediately instead of forking when we send back the response to the user since there we only need, +                    // to merge together the fetched results which is a linear operation., +                    innerRun();, +                }, +, +                @Override, +                public void onFailure(Exception e) {, +                    ReduceSearchPhaseException failure = new ReduceSearchPhaseException("fetch", "", e, buildShardFailures());, +                    if (logger.isDebugEnabled()) {, +                        logger.debug("failed to reduce search", failure);, +                    }, +                    super.onFailure(failure);, +                }, +            });, +        }, +, +        private void innerRun() throws IOException{, +            final int numShards = shardsIts.size();, +            String scrollId = isScrollRequest ? TransportSearchHelper.buildScrollId(queryResults) : null;, +            List<AtomicArray.Entry<QuerySearchResultProvider>> queryResultsAsList = queryResults.asList();, +            final SearchPhaseController.ReducedQueryPhase reducedQueryPhase = searchPhaseController.reducedQueryPhase(queryResultsAsList);, +            final boolean queryAndFetchOptimization = queryResults.length() == 1;, +            final IntConsumer finishPhase = successOpts, +                -> sendResponse(searchPhaseController, sortedShardDocs, scrollId, reducedQueryPhase, queryAndFetchOptimization ?, +                    queryResults : fetchResults);, +            if (queryAndFetchOptimization) {, +                finishPhase.accept(successfulOps.get());, +                final IntArrayList[] docIdsToLoad = searchPhaseController.fillDocIdsToLoad(numShards, sortedShardDocs);, +                    queryResultsAsList.stream(), +                        searchPhaseController.getLastEmittedDocPerShard(reducedQueryPhase, sortedShardDocs, numShards), +                            ShardFetchSearchRequest fetchSearchRequest = createFetchRequest(queryResult.queryResult().id(), i, entry,, +         * Sends back a result to the user., +        private void sendResponse(SearchPhaseController searchPhaseController, ScoreDoc[] sortedDocs,, +                                String scrollId, SearchPhaseController.ReducedQueryPhase reducedQueryPhase,, +            final InternalSearchResponse internalResponse = searchPhaseController.merge(isScrollRequest, sortedDocs, reducedQueryPhase,, +    }, +, +++ b/core/src/main/java/org/elasticsearch/action/search/SearchPhaseController.java, +        int topN = firstResult.queryResult().size();, +    public ScoreDoc[] getLastEmittedDocPerShard(ReducedQueryPhase reducedQueryPhase,, +        if (reducedQueryPhase.isEmpty() == false) {, +            long size = Math.min(reducedQueryPhase.fetchHits, reducedQueryPhase.oneResult.size());, +                                        ReducedQueryPhase reducedQueryPhase,, +        if (reducedQueryPhase.isEmpty()) {, +        List<? extends AtomicArray.Entry<? extends QuerySearchResultProvider>> fetchResults = fetchResultsArr.asList();, +        InternalSearchHits hits = getHits(reducedQueryPhase, ignoreFrom, sortedDocs, fetchResultsArr);, +        if (reducedQueryPhase.suggest != null) {, +                int currentOffset = hits.getHits().length;, +                for (CompletionSuggestion suggestion : reducedQueryPhase.suggest.filter(CompletionSuggestion.class)) {]