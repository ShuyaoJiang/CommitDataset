[+++ b/core/src/main/java/org/elasticsearch/action/support/replication/TransportReplicationAction.java, +import org.elasticsearch.cluster.MasterNodeChangePredicate;, +import org.elasticsearch.cluster.NotMasterException;, +import org.elasticsearch.cluster.routing.RoutingNode;, +import java.util.Locale;, +                                ClusterStateObserver observer = new ClusterStateObserver(clusterService, null, logger);, +                                String message = String.format(Locale.ROOT, "failed to perform %s on replica on node %s", transportReplicaAction, node);, +                                ReplicationFailedShardStateListener listener = new ReplicationFailedShardStateListener(observer, shard, exp, message, nodeId);, +                                shardFailed(observer.observedState(), shard, exp, message, listener);, +        private void shardFailed(ClusterState clusterState, ShardRouting shard, TransportException exp, String message, ShardStateAction.Listener listener) {, +            logger.warn("{} {}", exp, shardId, message);, +            shardStateAction.shardFailed(, +                clusterState,, +                shard,, +                indexUUID,, +                message,, +                exp,, +                shardFailedTimeout,, +                listener);, +        }, +            private final ClusterStateObserver observer;, +            private final ShardRouting shard;, +            private final TransportException exp;, +            private final String message;, +            public ReplicationFailedShardStateListener(, +                ClusterStateObserver observer, ShardRouting shard, TransportException exp,, +                String message,, +                String nodeId) {, +                this.observer = observer;, +                this.shard = shard;, +                this.exp = exp;, +                this.message = message;, +                // TODO: validate the cluster state and retry?, +                onReplicaFailure(nodeId, exp);, +                waitForNewMasterAndRetry();, +                    // TODO: recheck the cluster state and retry indefinitely?, +                    onReplicaFailure(nodeId, exp);, +                } else if (e.getCause() instanceof NotMasterException) {, +                    waitForNewMasterAndRetry();, +            }, +, +            private void waitForNewMasterAndRetry() {, +                observer.waitForNextChange(new ClusterStateObserver.Listener() {, +                    @Override, +                    public void onNewClusterState(ClusterState state) {, +                        retry(state);, +                    }, +, +                    @Override, +                    public void onClusterServiceClose() {, +                        logger.error("{} node closed while handling failed shard [{}]", exp, shard.shardId(), shard);, +                        forceFinishAsFailed(new NodeClosedException(clusterService.localNode()));, +                    }, +, +                    @Override, +                    public void onTimeout(TimeValue timeout) {, +                        // we wait indefinitely for a new master, +                        assert false;, +                    }, +                }, MasterNodeChangePredicate.INSTANCE);, +            }, +, +            private void retry(ClusterState clusterState) {, +                if (!isFailed(shard, clusterState)) {, +                    shardFailed(clusterState, shard, exp, message, this);, +                } else {, +                    // the shard has already been failed, so just signal replica failure, +                    onReplicaFailure(nodeId, exp);, +                }, +            }, +, +            private boolean isFailed(ShardRouting shardRouting, ClusterState clusterState) {, +                // verify that the shard we requested to fail is no longer in the cluster state, +                RoutingNode routingNode = clusterState.getRoutingNodes().node(shardRouting.currentNodeId());, +                if (routingNode == null) {, +                    // the node left, +                    return true;, +                } else {, +                    // the same shard is gone, +                    ShardRouting sr = routingNode.get(shardRouting.getId());, +                    return sr == null || !sr.isSameAllocation(shardRouting);, +                }]