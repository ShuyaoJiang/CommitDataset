[+++ b/core/src/main/java/org/elasticsearch/discovery/zen/ZenDiscovery.java, +, +        // clean the pending cluster queue - we are currently master, so any pending cluster state should be failed, +        // note that we also clean the queue on master failure (see handleMasterGone) but a delayed cluster state publish, +        // from a stale master can still make it in the queue during the election (but not be committed), +        publishClusterState.pendingStatesQueue().failAllStatesAndClear(new ElasticsearchException("elected as master"));, +    PendingClusterStatesQueue pendingClusterStatesQueue() {, +        return publishClusterState.pendingStatesQueue();, +    }, +, +++ b/core/src/main/java/org/elasticsearch/discovery/zen/ZenDiscovery.java, +, +        // clean the pending cluster queue - we are currently master, so any pending cluster state should be failed, +        // note that we also clean the queue on master failure (see handleMasterGone) but a delayed cluster state publish, +        // from a stale master can still make it in the queue during the election (but not be committed), +        publishClusterState.pendingStatesQueue().failAllStatesAndClear(new ElasticsearchException("elected as master"));, +    PendingClusterStatesQueue pendingClusterStatesQueue() {, +        return publishClusterState.pendingStatesQueue();, +    }, +, +++ b/core/src/test/java/org/elasticsearch/discovery/zen/ZenDiscoveryUnitTests.java, +import static org.hamcrest.Matchers.arrayWithSize;, +import static org.hamcrest.Matchers.emptyArray;, +    public void testPendingCSQueueIsClearedWhenClusterStatePublished() throws Exception {, +        ThreadPool threadPool = new TestThreadPool(getClass().getName());, +        // randomly make minimum_master_nodes a value higher than we have nodes for, so it will force failure, +        int minMasterNodes =  randomBoolean() ? 3 : 1;, +        Settings settings = Settings.builder(), +            .put(DISCOVERY_ZEN_MINIMUM_MASTER_NODES_SETTING.getKey(), Integer.toString(minMasterNodes)).build();, +, +        ArrayList<Closeable> toClose = new ArrayList<>();, +        try {, +            final MockTransportService masterTransport = MockTransportService.createNewService(settings, Version.CURRENT, threadPool, null);, +            masterTransport.start();, +            DiscoveryNode masterNode = new DiscoveryNode("master",  masterTransport.boundAddress().publishAddress(), Version.CURRENT);, +            toClose.add(masterTransport);, +            masterTransport.setLocalNode(masterNode);, +            ClusterState state = ClusterStateCreationUtils.state(masterNode, null, masterNode);, +            // build the zen discovery and cluster service, +            ClusterService masterClusterService = createClusterService(threadPool, masterNode);, +            toClose.add(masterClusterService);, +            state = ClusterState.builder(masterClusterService.getClusterName()).nodes(state.nodes()).build();, +            setState(masterClusterService, state);, +            ZenDiscovery masterZen = buildZenDiscovery(settings, masterTransport, masterClusterService, threadPool);, +            toClose.add(masterZen);, +            masterTransport.acceptIncomingRequests();, +, +            // inject a pending cluster state, +            masterZen.pendingClusterStatesQueue().addPending(ClusterState.builder(new ClusterName("foreign")).build());, +, +            // a new cluster state with a new discovery node (we will test if the cluster state, +            // was updated by the presence of this node in NodesFaultDetection), +            ClusterState newState = ClusterState.builder(masterClusterService.state()).incrementVersion().nodes(, +                DiscoveryNodes.builder(masterClusterService.state().nodes()).masterNodeId(masterNode.getId()), +            ).build();, +, +, +            try {, +                // publishing a new cluster state, +                ClusterChangedEvent clusterChangedEvent = new ClusterChangedEvent("testing", newState, state);, +                AssertingAckListener listener = new AssertingAckListener(newState.nodes().getSize() - 1);, +                masterZen.publish(clusterChangedEvent, listener);, +                listener.await(1, TimeUnit.HOURS);, +                // publish was a success, check that queue as cleared, +                assertThat(masterZen.pendingClusterStates(), emptyArray());, +            } catch (Discovery.FailedToCommitClusterStateException e) {, +                // not successful, so the pending queue should stay, +                assertThat(masterZen.pendingClusterStates(), arrayWithSize(1));, +                assertThat(masterZen.pendingClusterStates()[0].getClusterName().value(), equalTo("foreign"));, +            }, +        } finally {, +            IOUtils.close(toClose);, +            terminate(threadPool);, +        }, +    }, +]