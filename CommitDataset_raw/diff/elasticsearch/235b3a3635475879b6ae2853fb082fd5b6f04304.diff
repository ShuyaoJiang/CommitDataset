[+++ b/src/main/java/org/elasticsearch/action/search/type/TransportSearchTypeAction.java, +        private volatile AtomicArray<ShardSearchFailure> shardFailures;, +        private final Object shardFailuresMutex = new Object();, +            AtomicArray<ShardSearchFailure> shardFailures = this.shardFailures;, +            // lazily create shard failures, so we can early build the empty shard failure list in most cases (no failures), +            if (shardFailures == null) {, +                synchronized (shardFailuresMutex) {, +                    if (shardFailures == null) {, +                        shardFailures = new AtomicArray<ShardSearchFailure>(shardsIts.size());, +                    }, +                }, +            }, +, +            // clean a previous error on this shard group (note, this code will be serialized on the same shardIndex value level, +            // so its ok concurrency wise to miss potentially the shard failures being created because of another failure, +            // in the #addShardFailure, because by definition, it will happen on *another* shardIndex, +            AtomicArray<ShardSearchFailure> shardFailures = this.shardFailures;, +            if (shardFailures != null) {, +        }, +++ b/src/main/java/org/elasticsearch/action/search/type/TransportSearchTypeAction.java, +        private volatile AtomicArray<ShardSearchFailure> shardFailures;, +        private final Object shardFailuresMutex = new Object();, +            AtomicArray<ShardSearchFailure> shardFailures = this.shardFailures;, +            // lazily create shard failures, so we can early build the empty shard failure list in most cases (no failures), +            if (shardFailures == null) {, +                synchronized (shardFailuresMutex) {, +                    if (shardFailures == null) {, +                        shardFailures = new AtomicArray<ShardSearchFailure>(shardsIts.size());, +                    }, +                }, +            }, +, +            // clean a previous error on this shard group (note, this code will be serialized on the same shardIndex value level, +            // so its ok concurrency wise to miss potentially the shard failures being created because of another failure, +            // in the #addShardFailure, because by definition, it will happen on *another* shardIndex, +            AtomicArray<ShardSearchFailure> shardFailures = this.shardFailures;, +            if (shardFailures != null) {, +        }, +++ b/src/main/java/org/elasticsearch/cluster/routing/ImmutableShardRouting.java, +++ b/src/main/java/org/elasticsearch/action/search/type/TransportSearchTypeAction.java, +        private volatile AtomicArray<ShardSearchFailure> shardFailures;, +        private final Object shardFailuresMutex = new Object();, +            AtomicArray<ShardSearchFailure> shardFailures = this.shardFailures;, +            // lazily create shard failures, so we can early build the empty shard failure list in most cases (no failures), +            if (shardFailures == null) {, +                synchronized (shardFailuresMutex) {, +                    if (shardFailures == null) {, +                        shardFailures = new AtomicArray<ShardSearchFailure>(shardsIts.size());, +                    }, +                }, +            }, +, +            // clean a previous error on this shard group (note, this code will be serialized on the same shardIndex value level, +            // so its ok concurrency wise to miss potentially the shard failures being created because of another failure, +            // in the #addShardFailure, because by definition, it will happen on *another* shardIndex, +            AtomicArray<ShardSearchFailure> shardFailures = this.shardFailures;, +            if (shardFailures != null) {, +        }, +++ b/src/main/java/org/elasticsearch/cluster/routing/ImmutableShardRouting.java, +++ b/src/main/java/org/elasticsearch/cluster/routing/IndexShardRoutingTable.java, +, +    /**, +     * The initializing list, including ones that are initializing on a target node because of relocation., +     * If we can come up with a better variable name, it would be nice..., +     */, +    final ImmutableList<ShardRouting> allInitializingShards;, +        ImmutableList.Builder<ShardRouting> allInitializingShards = ImmutableList.builder();, +                allInitializingShards.add(shard);, +            }, +            if (shard.relocating()) {, +                // create the target initializing shard routing on the node the shard is relocating to, +                allInitializingShards.add(new ImmutableShardRouting(shard.index(), shard.id(), shard.relocatingNodeId(), shard.currentNodeId(), shard.primary(), ShardRoutingState.INITIALIZING, shard.version()));, +        this.allInitializingShards = allInitializingShards.build();, +        if (allInitializingShards.isEmpty()) {, +        ArrayList<ShardRouting> ordered = new ArrayList<ShardRouting>(activeShards.size() + allInitializingShards.size());, +        ordered.addAll(allInitializingShards);, +        ArrayList<ShardRouting> ordered = new ArrayList<ShardRouting>(activeShards.size() + allInitializingShards.size());, +        if (!allInitializingShards.isEmpty()) {, +            ordered.addAll(allInitializingShards);, +        ArrayList<ShardRouting> ordered = new ArrayList<ShardRouting>(activeShards.size() + allInitializingShards.size());, +        for (int i = 0; i < allInitializingShards.size(); i++) {, +            ShardRouting shardRouting = allInitializingShards.get(i);, +        ArrayList<ShardRouting> ordered = new ArrayList<ShardRouting>(activeShards.size() + allInitializingShards.size());, +        if (!allInitializingShards.isEmpty()) {, +            ordered.addAll(allInitializingShards);, +                ArrayList<ShardRouting> from = new ArrayList<ShardRouting>(allInitializingShards);]