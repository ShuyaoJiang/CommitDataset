[+++ b/core/src/main/java/org/elasticsearch/common/util/concurrent/KeyedLock.java, +import java.util.concurrent.locks.Lock;, +import java.util.concurrent.locks.ReadWriteLock;, +import java.util.concurrent.locks.ReentrantReadWriteLock;, +    /**, +     * A {@link KeyedLock} that allows to acquire a global lock that guarantees, +     * exclusive access to the resource the KeyedLock is guarding., +     */, +    public final static class GlobalLockable<T> extends KeyedLock<T> {, +, +, +        private final ReadWriteLock lock;, +, +        public GlobalLockable(boolean fair){, +            super(fair);, +            lock = new ReentrantReadWriteLock(fair);, +        }, +, +        public GlobalLockable() {, +            this(false);, +        }, +, +        @Override, +        public void acquire(T key) {, +            boolean success = false;, +            lock.readLock().lock();, +            try {, +                super.acquire(key);, +                success = true;, +            } finally {, +                if (!success) {, +                    lock.readLock().unlock();, +                }, +            }, +        }, +, +        @Override, +        public void release(T key) {, +            KeyLock keyLock = threadLocal.get();, +            if (keyLock == null) {, +                throw new IllegalStateException("Lock not acquired");, +            }, +            try {, +                release(key, keyLock);, +            } finally {, +                lock.readLock().unlock();, +            }, +        }, +, +        /**, +         * Returns a global lock guaranteeing exclusive access to the resource, +         * this KeyedLock is guarding., +         */, +        public Lock globalLock() {, +            return lock.writeLock();, +        }, +    }, +, +++ b/core/src/main/java/org/elasticsearch/common/util/concurrent/KeyedLock.java, +import java.util.concurrent.locks.Lock;, +import java.util.concurrent.locks.ReadWriteLock;, +import java.util.concurrent.locks.ReentrantReadWriteLock;, +    /**, +     * A {@link KeyedLock} that allows to acquire a global lock that guarantees, +     * exclusive access to the resource the KeyedLock is guarding., +     */, +    public final static class GlobalLockable<T> extends KeyedLock<T> {, +, +, +        private final ReadWriteLock lock;, +, +        public GlobalLockable(boolean fair){, +            super(fair);, +            lock = new ReentrantReadWriteLock(fair);, +        }, +, +        public GlobalLockable() {, +            this(false);, +        }, +, +        @Override, +        public void acquire(T key) {, +            boolean success = false;, +            lock.readLock().lock();, +            try {, +                super.acquire(key);, +                success = true;, +            } finally {, +                if (!success) {, +                    lock.readLock().unlock();, +                }, +            }, +        }, +, +        @Override, +        public void release(T key) {, +            KeyLock keyLock = threadLocal.get();, +            if (keyLock == null) {, +                throw new IllegalStateException("Lock not acquired");, +            }]