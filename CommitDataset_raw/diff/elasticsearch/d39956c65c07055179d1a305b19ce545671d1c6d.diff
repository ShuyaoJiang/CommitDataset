[+++ b/docs/reference/ilm/using-policies-rollover.asciidoc, +The `index.lifecycle.indexing_complete` setting indicates to {ilm} whether this, +index has already been rolled over. If it is set to `true`, that indicates that, +this index has already been rolled over and does not need to be rolled over, +again. Therefore, {ilm} will skip any Rollover Action configured in the, +associated lifecycle policy for this index. This is useful if you need to make, +an exception to your normal Lifecycle Policy and switching the alias to a, +This setting is set to `true` automatically by ILM upon the successful, +completion of a Rollover Action. However, it will be removed if, +<<ilm-remove-policy,the policy is removed>> from the index., +, +++ b/docs/reference/ilm/using-policies-rollover.asciidoc, +The `index.lifecycle.indexing_complete` setting indicates to {ilm} whether this, +index has already been rolled over. If it is set to `true`, that indicates that, +this index has already been rolled over and does not need to be rolled over, +again. Therefore, {ilm} will skip any Rollover Action configured in the, +associated lifecycle policy for this index. This is useful if you need to make, +an exception to your normal Lifecycle Policy and switching the alias to a, +This setting is set to `true` automatically by ILM upon the successful, +completion of a Rollover Action. However, it will be removed if, +<<ilm-remove-policy,the policy is removed>> from the index., +, +++ b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/indexlifecycle/WaitForRolloverReadyStep.java, +        // The order of the following checks is important in ways which may not be obvious., +, +        // First, figure out if 1) The configured alias points to this index, and if so,, +        // whether this index is the write alias for this index, +        boolean aliasPointsToThisIndex = indexMetaData.getAliases().containsKey(rolloverAlias);, +, +        Boolean isWriteIndex = null;, +        if (aliasPointsToThisIndex) {, +            // The writeIndex() call returns a tri-state boolean:, +            // true  -> this index is the write index for this alias, +            // false -> this index is not the write index for this alias, +            // null  -> this alias is a "classic-style" alias and does not have a write index configured, but only points to one index, +            //          and is thus the write index by default, +            isWriteIndex = indexMetaData.getAliases().get(rolloverAlias).writeIndex();, +            // If this index is still the write index for this alias, skipping rollover and continuing with the policy almost certainly, +            // isn't what we want, as something likely still expects to be writing to this index., +            // If the alias doesn't point to this index, that's okay as that will be the result if this index is using a, +            // "classic-style" alias and has already rolled over, and we want to continue with the policy., +            if (aliasPointsToThisIndex && Boolean.TRUE.equals(isWriteIndex)) {, +        // If indexing_complete is *not* set, and the alias does not point to this index, we can't roll over this index, so error out., +        if (aliasPointsToThisIndex == false) {, +            listener.onFailure(new IllegalArgumentException(String.format(Locale.ROOT,, +                "%s [%s] does not point to index [%s]", RolloverAction.LIFECYCLE_ROLLOVER_ALIAS, rolloverAlias,, +                indexMetaData.getIndex().getName())));, +            return;, +        }, +, +        // Similarly, if isWriteIndex is false (see note above on false vs. null), we can't roll over this index, so error out., +        if (Boolean.FALSE.equals(isWriteIndex)) {, +            listener.onFailure(new IllegalArgumentException(String.format(Locale.ROOT,, +                "index [%s] is not the write index for alias [%s]", rolloverAlias, indexMetaData.getIndex().getName())));, +        }, +, +++ b/docs/reference/ilm/using-policies-rollover.asciidoc, +The `index.lifecycle.indexing_complete` setting indicates to {ilm} whether this, +index has already been rolled over. If it is set to `true`, that indicates that, +this index has already been rolled over and does not need to be rolled over, +again. Therefore, {ilm} will skip any Rollover Action configured in the, +associated lifecycle policy for this index. This is useful if you need to make, +an exception to your normal Lifecycle Policy and switching the alias to a, +This setting is set to `true` automatically by ILM upon the successful, +completion of a Rollover Action. However, it will be removed if, +<<ilm-remove-policy,the policy is removed>> from the index., +, +++ b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/indexlifecycle/WaitForRolloverReadyStep.java, +        // The order of the following checks is important in ways which may not be obvious., +, +        // First, figure out if 1) The configured alias points to this index, and if so,, +        // whether this index is the write alias for this index, +        boolean aliasPointsToThisIndex = indexMetaData.getAliases().containsKey(rolloverAlias);, +, +        Boolean isWriteIndex = null;, +        if (aliasPointsToThisIndex) {, +            // The writeIndex() call returns a tri-state boolean:, +            // true  -> this index is the write index for this alias, +            // false -> this index is not the write index for this alias, +            // null  -> this alias is a "classic-style" alias and does not have a write index configured, but only points to one index, +            //          and is thus the write index by default, +            isWriteIndex = indexMetaData.getAliases().get(rolloverAlias).writeIndex();, +            // If this index is still the write index for this alias, skipping rollover and continuing with the policy almost certainly, +            // isn't what we want, as something likely still expects to be writing to this index., +            // If the alias doesn't point to this index, that's okay as that will be the result if this index is using a, +            // "classic-style" alias and has already rolled over, and we want to continue with the policy., +            if (aliasPointsToThisIndex && Boolean.TRUE.equals(isWriteIndex)) {, +        // If indexing_complete is *not* set, and the alias does not point to this index, we can't roll over this index, so error out., +        if (aliasPointsToThisIndex == false) {, +            listener.onFailure(new IllegalArgumentException(String.format(Locale.ROOT,, +                "%s [%s] does not point to index [%s]", RolloverAction.LIFECYCLE_ROLLOVER_ALIAS, rolloverAlias,, +                indexMetaData.getIndex().getName())));, +            return;, +        }, +, +        // Similarly, if isWriteIndex is false (see note above on false vs. null), we can't roll over this index, so error out., +        if (Boolean.FALSE.equals(isWriteIndex)) {, +            listener.onFailure(new IllegalArgumentException(String.format(Locale.ROOT,, +                "index [%s] is not the write index for alias [%s]", rolloverAlias, indexMetaData.getIndex().getName())));, +        }]