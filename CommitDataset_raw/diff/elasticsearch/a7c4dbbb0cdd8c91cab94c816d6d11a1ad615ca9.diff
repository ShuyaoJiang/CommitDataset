[+++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/Compiler.java, +            found = painlessLookup.javaClassNameToClass(name);, +++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/Compiler.java, +            found = painlessLookup.javaClassNameToClass(name);, +++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/lookup/PainlessLookup.java, +    private final Map<String, Class<?>> javaClassNamesToClasses;, +    PainlessLookup(, +            Map<String, Class<?>> javaClassNamesToClasses,, +            Map<String, Class<?>> canonicalClassNamesToClasses,, +            Map<Class<?>, PainlessClass> classesToPainlessClasses,, +        Objects.requireNonNull(javaClassNamesToClasses);, +        this.javaClassNamesToClasses = javaClassNamesToClasses;, +    public Class<?> javaClassNameToClass(String javaClassName) {, +        return javaClassNamesToClasses.get(javaClassName);, +    }, +, +++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/Compiler.java, +            found = painlessLookup.javaClassNameToClass(name);, +++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/lookup/PainlessLookup.java, +    private final Map<String, Class<?>> javaClassNamesToClasses;, +    PainlessLookup(, +            Map<String, Class<?>> javaClassNamesToClasses,, +            Map<String, Class<?>> canonicalClassNamesToClasses,, +            Map<Class<?>, PainlessClass> classesToPainlessClasses,, +        Objects.requireNonNull(javaClassNamesToClasses);, +        this.javaClassNamesToClasses = javaClassNamesToClasses;, +    public Class<?> javaClassNameToClass(String javaClassName) {, +        return javaClassNamesToClasses.get(javaClassName);, +    }, +, +++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/lookup/PainlessLookupBuilder.java, +    // javaClassNamesToClasses is all the classes that need to be available to the custom classloader, +    // including classes used as part of imported methods and class bindings but not necessarily whitelisted, +    // individually. The values of javaClassNamesToClasses are a superset of the values of, +    // canonicalClassNamesToClasses., +    private final Map<String, Class<?>> javaClassNamesToClasses;, +    // canonicalClassNamesToClasses is all the whitelisted classes available in a Painless script including, +    // classes with imported canonical names but does not include classes from imported methods or class, +    // bindings unless also whitelisted separately. The values of canonicalClassNamesToClasses are a subset, +    // of the values of javaClassNamesToClasses., +        javaClassNamesToClasses = new HashMap<>();, +        Class<?> existingClass = javaClassNamesToClasses.get(clazz.getName());, +, +        if (existingClass == null) {, +            javaClassNamesToClasses.put(clazz.getName(), clazz);, +        } else if (existingClass != clazz) {, +            throw new IllegalArgumentException("class [" + canonicalClassName + "] " +, +                    "cannot represent multiple java classes with the same name from different class loaders");, +        }, +, +        existingClass = canonicalClassNamesToClasses.get(canonicalClassName);, +        Class<?> existingTargetClass = javaClassNamesToClasses.get(targetClass.getName());, +, +        if (existingTargetClass == null) {, +            javaClassNamesToClasses.put(targetClass.getName(), targetClass);, +        } else if (existingTargetClass != targetClass) {, +            throw new IllegalArgumentException("class [" + targetCanonicalClassName + "] " +, +                    "cannot represent multiple java classes with the same name from different class loaders");, +        }, +        Class<?> existingTargetClass = javaClassNamesToClasses.get(targetClass.getName());, +, +        if (existingTargetClass == null) {, +            javaClassNamesToClasses.put(targetClass.getName(), targetClass);, +        } else if (existingTargetClass != targetClass) {, +            throw new IllegalArgumentException("class [" + targetCanonicalClassName + "] " +, +                    "cannot represent multiple java classes with the same name from different class loaders");, +        }, +        if (javaClassNamesToClasses.values().containsAll(canonicalClassNamesToClasses.values()) == false) {, +            throw new IllegalArgumentException("the values of java class names to classes " +, +                    "must be a superset of the values of canonical class names to classes");, +        }, +, +        if (javaClassNamesToClasses.values().containsAll(classesToPainlessClasses.keySet()) == false) {, +            throw new IllegalArgumentException("the values of java class names to classes " +, +                    "must be a superset of the keys of classes to painless classes");, +        }, +, +        if (canonicalClassNamesToClasses.values().containsAll(classesToPainlessClasses.keySet()) == false ||, +                classesToPainlessClasses.keySet().containsAll(canonicalClassNamesToClasses.values()) == false) {, +            throw new IllegalArgumentException("the values of canonical class names to classes "  +, +                    "must have the same classes as the keys of classes to painless classes");, +        }, +, +        return new PainlessLookup(javaClassNamesToClasses, canonicalClassNamesToClasses, classesToPainlessClasses,, +++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/Compiler.java, +            found = painlessLookup.javaClassNameToClass(name);, +++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/lookup/PainlessLookup.java, +    private final Map<String, Class<?>> javaClassNamesToClasses;, +    PainlessLookup(, +            Map<String, Class<?>> javaClassNamesToClasses,, +            Map<String, Class<?>> canonicalClassNamesToClasses,, +            Map<Class<?>, PainlessClass> classesToPainlessClasses,, +        Objects.requireNonNull(javaClassNamesToClasses);, +        this.javaClassNamesToClasses = javaClassNamesToClasses;, +    public Class<?> javaClassNameToClass(String javaClassName) {, +        return javaClassNamesToClasses.get(javaClassName);, +    }, +, +++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/lookup/PainlessLookupBuilder.java, +    // javaClassNamesToClasses is all the classes that need to be available to the custom classloader]