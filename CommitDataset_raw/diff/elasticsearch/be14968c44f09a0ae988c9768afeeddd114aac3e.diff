[+++ b/src/main/java/org/elasticsearch/index/engine/internal/InternalEngine.java, +    private final ReentrantReadWriteLock rwl = new ReentrantReadWriteLock();, +    private final InternalLock readLock = new InternalLock(rwl.readLock());, +    private final InternalLock writeLock = new InternalLock(rwl.writeLock());, +    private final Lock failEngineLock = new ReentrantLock();, +        try (InternalLock  _ = readLock.acquire()) {, +        try (InternalLock _ = writeLock.acquire()) {, +        try (InternalLock  _ = readLock.acquire()) {, +        try (InternalLock  _ = readLock.acquire())  {, +        } catch (OutOfMemoryError | IllegalStateException | IOException t) {, +           maybeFailEngine(t);, +           throw new CreateFailedEngineException(shardId, create, t);, +    }, +, +    private void maybeFailEngine(Throwable t) {, +        if (t instanceof OutOfMemoryError || (t instanceof IllegalStateException && t.getMessage().contains("OutOfMemoryError"))) {, +            failEngine(t);, +        try (InternalLock  _ = readLock.acquire())  {, +        } catch (OutOfMemoryError | IllegalStateException | IOException t) {, +            maybeFailEngine(t);, +            throw new IndexFailedEngineException(shardId, index, t);, +        try (InternalLock  _ = readLock.acquire())  {, +        } catch (OutOfMemoryError | IllegalStateException | IOException t) {, +            maybeFailEngine(t);, +            throw new DeleteFailedEngineException(shardId, delete, t);, +        try (InternalLock  _ = readLock.acquire())  {, +        } catch (Throwable t) {, +            maybeFailEngine(t);, +            throw new DeleteByQueryFailedEngineException(shardId, delete, t);, +        try (InternalLock  _ = readLock.acquire()) {, +            ensureOpen();, +        } catch (EngineClosedException e) {, +            throw e;, +        } catch (Throwable t) {, +            failEngine(t);, +            throw new RefreshFailedEngineException(shardId, t);, +                try (InternalLock _ = writeLock.acquire()) {, +                        currentIndexWriter().close(false);, +                    } catch (Throwable t) {, +                        throw new FlushFailedEngineException(shardId, t);, +                try (InternalLock  _ = readLock.acquire()) {, +                    final IndexWriter indexWriter = currentIndexWriter();, +                try (InternalLock  _ = readLock.acquire()) {, +                    final IndexWriter indexWriter = currentIndexWriter();, +            try (InternalLock  _ = readLock.acquire()) {, +        } catch (FlushFailedEngineException ex){, +           maybeFailEngine(ex.getCause());, +           throw ex;, +    /**, +     * Returns the current index writer. This method will never return <code>null</code>, +     * @throws EngineClosedException if the engine is already closed, +     */, +    private IndexWriter currentIndexWriter() {, +        final IndexWriter writer = indexWriter;, +        if (writer == null) {, +            throw new EngineClosedException(shardId, failedEngine);, +        }, +        return writer;, +    }, +, +        try (InternalLock  _ = readLock.acquire()) {, +            Merges.maybeMerge(currentIndexWriter());, +        } catch (Throwable t) {, +            maybeFailEngine(t);, +            throw new OptimizeFailedEngineException(shardId, t);, +            try (InternalLock  _ = readLock.acquire()) {, +                final IndexWriter writer = currentIndexWriter();, +                if (writer.getConfig().getMergePolicy() instanceof ElasticsearchMergePolicy) {, +                    elasticsearchMergePolicy = (ElasticsearchMergePolicy) writer.getConfig().getMergePolicy();, +                            + ElasticsearchMergePolicy.class.getSimpleName() + ", got [" + writer.getConfig().getMergePolicy().getClass().getName() + "]");, +                    Merges.forceMergeDeletes(writer, false);, +                    Merges.maybeMerge(writer);, +                    Merges.forceMerge(writer, optimize.maxNumSegments(), false);, +            } catch (Throwable t) {, +                maybeFailEngine(t);, +                throw new OptimizeFailedEngineException(shardId, t);, +, +            currentIndexWriter().waitForMerges();, +        try (InternalLock  _ = readLock.acquire()) {, +        try (InternalLock _ = writeLock.acquire()) {, +            throw new RecoveryEngineException(shardId, 1, "Execution failed", wrapIfClosed(e));, +            throw new RecoveryEngineException(shardId, 2, "Snapshot failed", wrapIfClosed(e));, +            throw new RecoveryEngineException(shardId, 2, "Execution failed", wrapIfClosed(e));, +        writeLock.acquire();, +            throw new RecoveryEngineException(shardId, 3, "Execution failed", wrapIfClosed(e));, +            Releasables.close(success, onGoingRecoveries, writeLock, phase1Snapshot,, +                    phase2Snapshot, phase3Snapshot); // hmm why can't we use try-with here?, +    private Throwable wrapIfClosed(Throwable t) {, +        if (closed) {, +            return new EngineClosedException(shardId, t);, +        }, +        return t;, +    }, +, +        try (InternalLock  _ = readLock.acquire()) {, +        try (InternalLock  _ = readLock.acquire()) {, +        try (InternalLock _ = writeLock.acquire()) {, +    }, +, +    class FailEngineOnMergeFailure implements MergeSchedulerProvider.FailureListener {]