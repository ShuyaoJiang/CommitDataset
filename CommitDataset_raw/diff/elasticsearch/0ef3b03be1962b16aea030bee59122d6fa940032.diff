[+++ b/docs/reference/index-modules/merge.asciidoc, +supported, with the default being the `SerialMergeScheduler`., +, +Note, the default is the serial merge scheduler since there is a merge, +thread pool that explicitly schedules merges, and it makes sure that, +merges are serial within a shard, yet concurrent across multiple shards., +++ b/docs/reference/index-modules/merge.asciidoc, +supported, with the default being the `SerialMergeScheduler`., +, +Note, the default is the serial merge scheduler since there is a merge, +thread pool that explicitly schedules merges, and it makes sure that, +merges are serial within a shard, yet concurrent across multiple shards., +++ b/src/main/java/org/apache/lucene/index/TrackingSerialMergeScheduler.java, +    private final int maxMergeAtOnce;, +, +    public TrackingSerialMergeScheduler(ESLogger logger, int maxMergeAtOnce) {, +        this.maxMergeAtOnce = maxMergeAtOnce;, +        int cycle = 0;, +        while (cycle++ < maxMergeAtOnce) {, +++ b/docs/reference/index-modules/merge.asciidoc, +supported, with the default being the `SerialMergeScheduler`., +, +Note, the default is the serial merge scheduler since there is a merge, +thread pool that explicitly schedules merges, and it makes sure that, +merges are serial within a shard, yet concurrent across multiple shards., +++ b/src/main/java/org/apache/lucene/index/TrackingSerialMergeScheduler.java, +    private final int maxMergeAtOnce;, +, +    public TrackingSerialMergeScheduler(ESLogger logger, int maxMergeAtOnce) {, +        this.maxMergeAtOnce = maxMergeAtOnce;, +        int cycle = 0;, +        while (cycle++ < maxMergeAtOnce) {, +++ b/src/main/java/org/elasticsearch/index/engine/internal/InternalEngine.java, +        IndexWriter writer = this.indexWriter;, +        if (writer == null) {, +            return false;, +        }, +        // a merge scheduler might bail without going through all its pending merges, +        // so make sure we also check if there are pending merges, +        return this.possibleMergeNeeded || writer.hasPendingMerges();, +++ b/docs/reference/index-modules/merge.asciidoc, +supported, with the default being the `SerialMergeScheduler`., +, +Note, the default is the serial merge scheduler since there is a merge, +thread pool that explicitly schedules merges, and it makes sure that, +merges are serial within a shard, yet concurrent across multiple shards., +++ b/src/main/java/org/apache/lucene/index/TrackingSerialMergeScheduler.java, +    private final int maxMergeAtOnce;, +, +    public TrackingSerialMergeScheduler(ESLogger logger, int maxMergeAtOnce) {, +        this.maxMergeAtOnce = maxMergeAtOnce;, +        int cycle = 0;, +        while (cycle++ < maxMergeAtOnce) {, +++ b/src/main/java/org/elasticsearch/index/engine/internal/InternalEngine.java, +        IndexWriter writer = this.indexWriter;, +        if (writer == null) {, +            return false;, +        }, +        // a merge scheduler might bail without going through all its pending merges, +        // so make sure we also check if there are pending merges, +        return this.possibleMergeNeeded || writer.hasPendingMerges();, +++ b/src/main/java/org/elasticsearch/index/merge/scheduler/MergeSchedulerModule.java, +    public static final Class<? extends MergeSchedulerProvider> DEFAULT = SerialMergeSchedulerProvider.class;, +++ b/docs/reference/index-modules/merge.asciidoc, +supported, with the default being the `SerialMergeScheduler`., +, +Note, the default is the serial merge scheduler since there is a merge, +thread pool that explicitly schedules merges, and it makes sure that, +merges are serial within a shard, yet concurrent across multiple shards., +++ b/src/main/java/org/apache/lucene/index/TrackingSerialMergeScheduler.java, +    private final int maxMergeAtOnce;, +, +    public TrackingSerialMergeScheduler(ESLogger logger, int maxMergeAtOnce) {, +        this.maxMergeAtOnce = maxMergeAtOnce;, +        int cycle = 0;, +        while (cycle++ < maxMergeAtOnce) {, +++ b/src/main/java/org/elasticsearch/index/engine/internal/InternalEngine.java, +        IndexWriter writer = this.indexWriter;, +        if (writer == null) {, +            return false;, +        }, +        // a merge scheduler might bail without going through all its pending merges, +        // so make sure we also check if there are pending merges, +        return this.possibleMergeNeeded || writer.hasPendingMerges();, +++ b/src/main/java/org/elasticsearch/index/merge/scheduler/MergeSchedulerModule.java, +    public static final Class<? extends MergeSchedulerProvider> DEFAULT = SerialMergeSchedulerProvider.class;, +++ b/src/main/java/org/elasticsearch/index/merge/scheduler/SerialMergeSchedulerProvider.java, +    private final int maxMergeAtOnce;, +        this.maxMergeAtOnce = componentSettings.getAsInt("max_merge_at_once", 5);, +        logger.trace("using [serial] merge scheduler, max_merge_at_once [{}]", maxMergeAtOnce);, +            super(logger, provider.maxMergeAtOnce);, +++ b/docs/reference/index-modules/merge.asciidoc, +supported, with the default being the `SerialMergeScheduler`., +, +Note, the default is the serial merge scheduler since there is a merge, +thread pool that explicitly schedules merges, and it makes sure that, +merges are serial within a shard, yet concurrent across multiple shards., +++ b/src/main/java/org/apache/lucene/index/TrackingSerialMergeScheduler.java, +    private final int maxMergeAtOnce;, +]