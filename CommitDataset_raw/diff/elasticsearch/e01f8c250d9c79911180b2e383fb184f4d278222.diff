[+++ b/src/main/java/org/elasticsearch/cache/recycler/CacheRecycler.java, +import org.elasticsearch.common.recycler.Recycler;, +import org.elasticsearch.common.util.concurrent.EsExecutors;, +import static org.elasticsearch.common.recycler.Recyclers.*;, +, +        final int availableProcessors = EsExecutors.boundedNumberOfProcessors(settings);, +        hashMap = build(type, limit, smartSize, availableProcessors, new Recycler.C<ObjectObjectOpenHashMap>() {, +        hashSet = build(type, limit, smartSize, availableProcessors, new Recycler.C<ObjectOpenHashSet>() {, +        doubleObjectMap = build(type, limit, smartSize, availableProcessors, new Recycler.C<DoubleObjectOpenHashMap>() {, +        longObjectMap = build(type, limit, smartSize, availableProcessors, new Recycler.C<LongObjectOpenHashMap>() {, +        longLongMap = build(type, limit, smartSize, availableProcessors, new Recycler.C<LongLongOpenHashMap>() {, +        intIntMap = build(type, limit, smartSize, availableProcessors, new Recycler.C<IntIntOpenHashMap>() {, +        floatIntMap = build(type, limit, smartSize, availableProcessors, new Recycler.C<FloatIntOpenHashMap>() {, +        doubleIntMap = build(type, limit, smartSize, availableProcessors, new Recycler.C<DoubleIntOpenHashMap>() {, +        longIntMap = build(type, limit, smartSize, availableProcessors, new Recycler.C<LongIntOpenHashMap>() {, +        objectIntMap = build(type, limit, smartSize, availableProcessors, new Recycler.C<ObjectIntOpenHashMap>() {, +        intObjectMap = build(type, limit, smartSize, availableProcessors, new Recycler.C<IntObjectOpenHashMap>() {, +        objectFloatMap = build(type, limit, smartSize, availableProcessors, new Recycler.C<ObjectFloatOpenHashMap>() {, +    private <T> Recycler<T> build(Type type, int limit, int smartSize, int availableProcessors, Recycler.C<T> c) {, +            recycler = type.build(c, limit, availableProcessors);, +                recycler = sizing(recycler, none(c), smartSize);, +            <T> Recycler<T> build(Recycler.C<T> c, int limit, int availableProcessors) {, +                return threadLocal(softFactory(dequeFactory(c, limit)));, +            <T> Recycler<T> build(Recycler.C<T> c, int limit, int availableProcessors) {, +                return threadLocal(dequeFactory(c, limit));, +            <T> Recycler<T> build(Recycler.C<T> c, int limit, int availableProcessors) {, +                return concurrentDeque(c, limit);, +            }, +        },, +        SOFT_CONCURRENT {, +            @Override, +            <T> Recycler<T> build(Recycler.C<T> c, int limit, int availableProcessors) {, +                return concurrent(softFactory(dequeFactory(c, limit)), availableProcessors);, +            }, +        },, +        CONCURRENT {, +            @Override, +            <T> Recycler<T> build(Recycler.C<T> c, int limit, int availableProcessors) {, +                return concurrent(dequeFactory(c, limit), availableProcessors);, +            <T> Recycler<T> build(Recycler.C<T> c, int limit, int availableProcessors) {, +                return none(c);, +                return SOFT_CONCURRENT;, +        abstract <T> Recycler<T> build(Recycler.C<T> c, int limit, int availableProcessors);, +++ b/src/main/java/org/elasticsearch/cache/recycler/CacheRecycler.java, +import org.elasticsearch.common.recycler.Recycler;, +import org.elasticsearch.common.util.concurrent.EsExecutors;, +import static org.elasticsearch.common.recycler.Recyclers.*;, +, +        final int availableProcessors = EsExecutors.boundedNumberOfProcessors(settings);, +        hashMap = build(type, limit, smartSize, availableProcessors, new Recycler.C<ObjectObjectOpenHashMap>() {, +        hashSet = build(type, limit, smartSize, availableProcessors, new Recycler.C<ObjectOpenHashSet>() {, +        doubleObjectMap = build(type, limit, smartSize, availableProcessors, new Recycler.C<DoubleObjectOpenHashMap>() {, +        longObjectMap = build(type, limit, smartSize, availableProcessors, new Recycler.C<LongObjectOpenHashMap>() {, +        longLongMap = build(type, limit, smartSize, availableProcessors, new Recycler.C<LongLongOpenHashMap>() {, +        intIntMap = build(type, limit, smartSize, availableProcessors, new Recycler.C<IntIntOpenHashMap>() {, +        floatIntMap = build(type, limit, smartSize, availableProcessors, new Recycler.C<FloatIntOpenHashMap>() {, +        doubleIntMap = build(type, limit, smartSize, availableProcessors, new Recycler.C<DoubleIntOpenHashMap>() {, +        longIntMap = build(type, limit, smartSize, availableProcessors, new Recycler.C<LongIntOpenHashMap>() {, +        objectIntMap = build(type, limit, smartSize, availableProcessors, new Recycler.C<ObjectIntOpenHashMap>() {, +        intObjectMap = build(type, limit, smartSize, availableProcessors, new Recycler.C<IntObjectOpenHashMap>() {, +        objectFloatMap = build(type, limit, smartSize, availableProcessors, new Recycler.C<ObjectFloatOpenHashMap>() {, +    private <T> Recycler<T> build(Type type, int limit, int smartSize, int availableProcessors, Recycler.C<T> c) {, +            recycler = type.build(c, limit, availableProcessors);, +                recycler = sizing(recycler, none(c), smartSize);, +            <T> Recycler<T> build(Recycler.C<T> c, int limit, int availableProcessors) {, +                return threadLocal(softFactory(dequeFactory(c, limit)));, +            <T> Recycler<T> build(Recycler.C<T> c, int limit, int availableProcessors) {, +                return threadLocal(dequeFactory(c, limit));, +            <T> Recycler<T> build(Recycler.C<T> c, int limit, int availableProcessors) {, +                return concurrentDeque(c, limit);, +            }, +        },, +        SOFT_CONCURRENT {, +            @Override, +            <T> Recycler<T> build(Recycler.C<T> c, int limit, int availableProcessors) {, +                return concurrent(softFactory(dequeFactory(c, limit)), availableProcessors);, +            }, +        },, +        CONCURRENT {, +            @Override, +            <T> Recycler<T> build(Recycler.C<T> c, int limit, int availableProcessors) {, +                return concurrent(dequeFactory(c, limit), availableProcessors);, +            <T> Recycler<T> build(Recycler.C<T> c, int limit, int availableProcessors) {, +                return none(c);, +                return SOFT_CONCURRENT;, +        abstract <T> Recycler<T> build(Recycler.C<T> c, int limit, int availableProcessors);, +++ b/src/main/java/org/elasticsearch/cache/recycler/PageCacheRecycler.java, +import com.google.common.base.Strings;, +import org.elasticsearch.ElasticsearchIllegalArgumentException;, +import java.util.Locale;, +, +import static org.elasticsearch.common.recycler.Recyclers.*;, +        final long limit = componentSettings.getAsMemory(LIMIT_HEAP, "10%").bytes();, +        final int availableProcessors = EsExecutors.boundedNumberOfProcessors(settings);, +        final int searchThreadPoolSize = maximumSearchThreadPoolSize(threadPool, settings);, +        bytePage = build(type, maxCount(limit, BigArrays.BYTE_PAGE_SIZE, bytesWeight, totalWeight), searchThreadPoolSize, availableProcessors, new Recycler.C<byte[]>() {, +        intPage = build(type, maxCount(limit, BigArrays.INT_PAGE_SIZE, intsWeight, totalWeight), searchThreadPoolSize, availableProcessors, new Recycler.C<int[]>() {, +        longPage = build(type, maxCount(limit, BigArrays.LONG_PAGE_SIZE, longsWeight, totalWeight), searchThreadPoolSize, availableProcessors, new Recycler.C<long[]>() {, +        doublePage = build(type, maxCount(limit, BigArrays.DOUBLE_PAGE_SIZE, doublesWeight, totalWeight), searchThreadPoolSize, availableProcessors, new Recycler.C<double[]>() {, +        objectPage = build(type, maxCount(limit, BigArrays.OBJECT_PAGE_SIZE, objectsWeight, totalWeight), searchThreadPoolSize, availableProcessors, new Recycler.C<Object[]>() {]