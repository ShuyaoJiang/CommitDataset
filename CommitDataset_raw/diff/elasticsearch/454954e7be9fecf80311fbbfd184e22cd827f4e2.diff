[+++ b/src/main/java/org/elasticsearch/common/bytes/BytesArray.java, +import org.apache.lucene.util.BytesRef;, +    public BytesArray(BytesRef bytesRef) {, +        this(bytesRef, false);, +    }, +, +    public BytesArray(BytesRef bytesRef, boolean deepCopy) {, +        if (deepCopy) {, +            BytesRef copy = BytesRef.deepCopyOf(bytesRef);, +            bytes = copy.bytes;, +            offset = copy.offset;, +            length = copy.length;, +        } else {, +            bytes = bytesRef.bytes;, +            offset = bytesRef.offset;, +            length = bytesRef.length;, +        }, +    }, +, +++ b/src/main/java/org/elasticsearch/common/bytes/BytesArray.java, +import org.apache.lucene.util.BytesRef;, +    public BytesArray(BytesRef bytesRef) {, +        this(bytesRef, false);, +    }, +, +    public BytesArray(BytesRef bytesRef, boolean deepCopy) {, +        if (deepCopy) {, +            BytesRef copy = BytesRef.deepCopyOf(bytesRef);, +            bytes = copy.bytes;, +            offset = copy.offset;, +            length = copy.length;, +        } else {, +            bytes = bytesRef.bytes;, +            offset = bytesRef.offset;, +            length = bytesRef.length;, +        }, +    }, +, +++ b/src/main/java/org/elasticsearch/common/bytes/BytesReference.java, +import java.util.Comparator;, +, +, +    // LUCENE 4 UPGRADE: Used by facets to order. Perhaps make this call implement Comparable., +    public final static Comparator<BytesReference> utf8SortedAsUnicodeSortOrder = new UTF8SortedAsUnicodeComparator();, +, +    public static class UTF8SortedAsUnicodeComparator implements Comparator<BytesReference> {, +, +        // Only singleton, +        private UTF8SortedAsUnicodeComparator() {}, +, +        public int compare(BytesReference a, BytesReference b) {, +            if (a.hasArray() && b.hasArray()) {, +                final byte[] aBytes = a.array();, +                int aUpto = a.arrayOffset();, +                final byte[] bBytes = b.array();, +                int bUpto = b.arrayOffset();, +, +                final int aStop = aUpto + Math.min(a.length(), b.length());, +                while(aUpto < aStop) {, +                    int aByte = aBytes[aUpto++] & 0xff;, +                    int bByte = bBytes[bUpto++] & 0xff;, +, +                    int diff = aByte - bByte;, +                    if (diff != 0) {, +                        return diff;, +                    }, +                }, +, +                // One is a prefix of the other, or, they are equal:, +                return a.length() - b.length();, +            } else {, +                final byte[] aBytes = a.toBytes();, +                int aUpto = 0;, +                final byte[] bBytes = b.toBytes();, +                int bUpto = 0;, +, +                final int aStop = aUpto + Math.min(a.length(), b.length());, +                while(aUpto < aStop) {, +                    int aByte = aBytes[aUpto++] & 0xff;, +                    int bByte = bBytes[bUpto++] & 0xff;, +, +                    int diff = aByte - bByte;, +                    if (diff != 0) {, +                        return diff;, +                    }, +                }, +, +                // One is a prefix of the other, or, they are equal:, +                return a.length() - b.length();, +            }, +        }, +    }, +++ b/src/main/java/org/elasticsearch/common/bytes/BytesArray.java, +import org.apache.lucene.util.BytesRef;, +    public BytesArray(BytesRef bytesRef) {, +        this(bytesRef, false);, +    }, +, +    public BytesArray(BytesRef bytesRef, boolean deepCopy) {, +        if (deepCopy) {]