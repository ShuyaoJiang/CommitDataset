[+++ b/server/src/main/java/org/elasticsearch/transport/RemoteClusterConnection.java, +    private final ClusterName localClusterName;, +        this.localClusterName = ClusterName.CLUSTER_NAME_SETTING.get(settings);, +    private ConnectionProfile getRemoteProfile(ClusterName name) {, +        // we can only compare the cluster name to make a decision if we should use a remote profile, +        // we can't use a cluster UUID here since we could be connecting to that remote cluster before, +        // the remote node has joined its cluster  and have a cluster UUID. The fact that we just lose a, +        // rather smallish optimization on the connection layer under certain situations where remote clusters, +        // have the same name as the local one is minor here., +        // the alternative here is to complicate the remote infrastructure to also wait until we formed a cluster,, +        // gained a cluster UUID and then start connecting etc. we rather use this simplification in order to maintain simplicity, +        if (this.localClusterName.equals(name)) {, +            return null;, +        } else {, +            return remoteProfile;, +        }, +    }, +, +                        final TransportService.HandshakeResponse handshakeResponse;, +                                handshakeResponse = transportService.handshake(connection, remoteProfile.getHandshakeTimeout().millis(),, +, +                            final DiscoveryNode handshakeNode = handshakeResponse.getDiscoveryNode();, +                                transportService.connectToNode(handshakeNode, getRemoteProfile(handshakeResponse.getClusterName()));, +                                if (remoteClusterName.get() == null) {, +                                    assert handshakeResponse.getClusterName().value() != null;, +                                    remoteClusterName.set(handshakeResponse.getClusterName());, +                                }, +                                        transportService.connectToNode(node, getRemoteProfile(remoteClusterName.get())); // noop if node is, +                                        // connected, +++ b/server/src/main/java/org/elasticsearch/transport/RemoteClusterConnection.java, +    private final ClusterName localClusterName;, +        this.localClusterName = ClusterName.CLUSTER_NAME_SETTING.get(settings);, +    private ConnectionProfile getRemoteProfile(ClusterName name) {, +        // we can only compare the cluster name to make a decision if we should use a remote profile, +        // we can't use a cluster UUID here since we could be connecting to that remote cluster before, +        // the remote node has joined its cluster  and have a cluster UUID. The fact that we just lose a, +        // rather smallish optimization on the connection layer under certain situations where remote clusters, +        // have the same name as the local one is minor here., +        // the alternative here is to complicate the remote infrastructure to also wait until we formed a cluster,, +        // gained a cluster UUID and then start connecting etc. we rather use this simplification in order to maintain simplicity, +        if (this.localClusterName.equals(name)) {, +            return null;, +        } else {, +            return remoteProfile;, +        }, +    }, +, +                        final TransportService.HandshakeResponse handshakeResponse;, +                                handshakeResponse = transportService.handshake(connection, remoteProfile.getHandshakeTimeout().millis(),, +, +                            final DiscoveryNode handshakeNode = handshakeResponse.getDiscoveryNode();, +                                transportService.connectToNode(handshakeNode, getRemoteProfile(handshakeResponse.getClusterName()));, +                                if (remoteClusterName.get() == null) {, +                                    assert handshakeResponse.getClusterName().value() != null;, +                                    remoteClusterName.set(handshakeResponse.getClusterName());, +                                }, +                                        transportService.connectToNode(node, getRemoteProfile(remoteClusterName.get())); // noop if node is, +                                        // connected, +++ b/server/src/main/java/org/elasticsearch/transport/TransportService.java, +            final DiscoveryNode remote = handshake(newConnection, actualProfile.getHandshakeTimeout().millis(), cn -> true).discoveryNode;, +        return handshake(connection, handshakeTimeout, clusterName::equals).discoveryNode;, +     * @return the handshake response, +    public HandshakeResponse handshake(, +        return response;, +, +        public DiscoveryNode getDiscoveryNode() {, +            return discoveryNode;, +        }, +, +        public ClusterName getClusterName() {, +            return clusterName;, +        }, +++ b/server/src/main/java/org/elasticsearch/transport/RemoteClusterConnection.java, +    private final ClusterName localClusterName;, +        this.localClusterName = ClusterName.CLUSTER_NAME_SETTING.get(settings);, +    private ConnectionProfile getRemoteProfile(ClusterName name) {, +        // we can only compare the cluster name to make a decision if we should use a remote profile, +        // we can't use a cluster UUID here since we could be connecting to that remote cluster before, +        // the remote node has joined its cluster  and have a cluster UUID. The fact that we just lose a, +        // rather smallish optimization on the connection layer under certain situations where remote clusters, +        // have the same name as the local one is minor here., +        // the alternative here is to complicate the remote infrastructure to also wait until we formed a cluster,, +        // gained a cluster UUID and then start connecting etc. we rather use this simplification in order to maintain simplicity, +        if (this.localClusterName.equals(name)) {, +            return null;, +        } else {, +            return remoteProfile;, +        }, +    }, +, +                        final TransportService.HandshakeResponse handshakeResponse;, +                                handshakeResponse = transportService.handshake(connection, remoteProfile.getHandshakeTimeout().millis(),, +, +                            final DiscoveryNode handshakeNode = handshakeResponse.getDiscoveryNode();, +                                transportService.connectToNode(handshakeNode, getRemoteProfile(handshakeResponse.getClusterName()));, +                                if (remoteClusterName.get() == null) {, +                                    assert handshakeResponse.getClusterName().value() != null;, +                                    remoteClusterName.set(handshakeResponse.getClusterName());, +                                }, +                                        transportService.connectToNode(node, getRemoteProfile(remoteClusterName.get())); // noop if node is]