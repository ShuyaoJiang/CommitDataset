[+++ b/core/src/main/java/org/elasticsearch/action/search/AbstractSearchAsyncAction.java, +                                        SearchTask task, SearchPhaseResults<Result> resultConsumer, int maxConcurrentShardRequests) {, +        super(name, request, shardsIts, logger, maxConcurrentShardRequests);, +++ b/core/src/main/java/org/elasticsearch/action/search/AbstractSearchAsyncAction.java, +                                        SearchTask task, SearchPhaseResults<Result> resultConsumer, int maxConcurrentShardRequests) {, +        super(name, request, shardsIts, logger, maxConcurrentShardRequests);, +++ b/core/src/main/java/org/elasticsearch/action/search/CanMatchPreFilterSearchPhase.java, +        /*, +         * We set max concurrent shard requests to the number of shards to otherwise avoid deep recursing that would occur if the local node, +         * is the coordinating node for the query, holds all the shards for the request, and there are a lot of shards., +         */, +            listener, shardsIts, timeProvider, clusterStateVersion, task, new BitSetSearchPhaseResults(shardsIts.size()), shardsIts.size());, +++ b/core/src/main/java/org/elasticsearch/action/search/AbstractSearchAsyncAction.java, +                                        SearchTask task, SearchPhaseResults<Result> resultConsumer, int maxConcurrentShardRequests) {, +        super(name, request, shardsIts, logger, maxConcurrentShardRequests);, +++ b/core/src/main/java/org/elasticsearch/action/search/CanMatchPreFilterSearchPhase.java, +        /*, +         * We set max concurrent shard requests to the number of shards to otherwise avoid deep recursing that would occur if the local node, +         * is the coordinating node for the query, holds all the shards for the request, and there are a lot of shards., +         */, +            listener, shardsIts, timeProvider, clusterStateVersion, task, new BitSetSearchPhaseResults(shardsIts.size()), shardsIts.size());, +++ b/core/src/main/java/org/elasticsearch/action/search/InitialSearchPhase.java, +    InitialSearchPhase(String name, SearchRequest request, GroupShardsIterator<SearchShardIterator> shardsIts, Logger logger,, +                       int maxConcurrentShardRequests) {, +        this.maxConcurrentShardRequests = Math.min(maxConcurrentShardRequests, shardsIts.size());, +++ b/core/src/main/java/org/elasticsearch/action/search/AbstractSearchAsyncAction.java, +                                        SearchTask task, SearchPhaseResults<Result> resultConsumer, int maxConcurrentShardRequests) {, +        super(name, request, shardsIts, logger, maxConcurrentShardRequests);, +++ b/core/src/main/java/org/elasticsearch/action/search/CanMatchPreFilterSearchPhase.java, +        /*, +         * We set max concurrent shard requests to the number of shards to otherwise avoid deep recursing that would occur if the local node, +         * is the coordinating node for the query, holds all the shards for the request, and there are a lot of shards., +         */, +            listener, shardsIts, timeProvider, clusterStateVersion, task, new BitSetSearchPhaseResults(shardsIts.size()), shardsIts.size());, +++ b/core/src/main/java/org/elasticsearch/action/search/InitialSearchPhase.java, +    InitialSearchPhase(String name, SearchRequest request, GroupShardsIterator<SearchShardIterator> shardsIts, Logger logger,, +                       int maxConcurrentShardRequests) {, +        this.maxConcurrentShardRequests = Math.min(maxConcurrentShardRequests, shardsIts.size());, +++ b/core/src/main/java/org/elasticsearch/action/search/SearchDfsQueryThenFetchAsyncAction.java, +                shardsIts, timeProvider, clusterStateVersion, task, new ArraySearchPhaseResults<>(shardsIts.size()),, +                request.getMaxConcurrentShardRequests());, +++ b/core/src/main/java/org/elasticsearch/action/search/AbstractSearchAsyncAction.java, +                                        SearchTask task, SearchPhaseResults<Result> resultConsumer, int maxConcurrentShardRequests) {, +        super(name, request, shardsIts, logger, maxConcurrentShardRequests);, +++ b/core/src/main/java/org/elasticsearch/action/search/CanMatchPreFilterSearchPhase.java, +        /*, +         * We set max concurrent shard requests to the number of shards to otherwise avoid deep recursing that would occur if the local node, +         * is the coordinating node for the query, holds all the shards for the request, and there are a lot of shards., +         */, +            listener, shardsIts, timeProvider, clusterStateVersion, task, new BitSetSearchPhaseResults(shardsIts.size()), shardsIts.size());, +++ b/core/src/main/java/org/elasticsearch/action/search/InitialSearchPhase.java, +    InitialSearchPhase(String name, SearchRequest request, GroupShardsIterator<SearchShardIterator> shardsIts, Logger logger,, +                       int maxConcurrentShardRequests) {, +        this.maxConcurrentShardRequests = Math.min(maxConcurrentShardRequests, shardsIts.size());, +++ b/core/src/main/java/org/elasticsearch/action/search/SearchDfsQueryThenFetchAsyncAction.java, +                shardsIts, timeProvider, clusterStateVersion, task, new ArraySearchPhaseResults<>(shardsIts.size()),, +                request.getMaxConcurrentShardRequests());, +++ b/core/src/main/java/org/elasticsearch/action/search/SearchQueryThenFetchAsyncAction.java, +            shardsIts, timeProvider, clusterStateVersion, task, searchPhaseController.newSearchPhaseResults(request, shardsIts.size()),, +                request.getMaxConcurrentShardRequests());, +++ b/core/src/main/java/org/elasticsearch/action/search/AbstractSearchAsyncAction.java, +                                        SearchTask task, SearchPhaseResults<Result> resultConsumer, int maxConcurrentShardRequests) {, +        super(name, request, shardsIts, logger, maxConcurrentShardRequests);, +++ b/core/src/main/java/org/elasticsearch/action/search/CanMatchPreFilterSearchPhase.java, +        /*, +         * We set max concurrent shard requests to the number of shards to otherwise avoid deep recursing that would occur if the local node, +         * is the coordinating node for the query, holds all the shards for the request, and there are a lot of shards., +         */, +            listener, shardsIts, timeProvider, clusterStateVersion, task, new BitSetSearchPhaseResults(shardsIts.size()), shardsIts.size());, +++ b/core/src/main/java/org/elasticsearch/action/search/InitialSearchPhase.java, +    InitialSearchPhase(String name, SearchRequest request, GroupShardsIterator<SearchShardIterator> shardsIts, Logger logger,, +                       int maxConcurrentShardRequests) {, +        this.maxConcurrentShardRequests = Math.min(maxConcurrentShardRequests, shardsIts.size());, +++ b/core/src/main/java/org/elasticsearch/action/search/SearchDfsQueryThenFetchAsyncAction.java, +                shardsIts, timeProvider, clusterStateVersion, task, new ArraySearchPhaseResults<>(shardsIts.size()),, +                request.getMaxConcurrentShardRequests());, +++ b/core/src/main/java/org/elasticsearch/action/search/SearchQueryThenFetchAsyncAction.java, +            shardsIts, timeProvider, clusterStateVersion, task, searchPhaseController.newSearchPhaseResults(request, shardsIts.size()),, +                request.getMaxConcurrentShardRequests());, +++ b/core/src/main/java/org/elasticsearch/action/search/SearchTransportService.java, +import org.elasticsearch.transport.TaskAwareTransportRequestHandler;, +        // this is cheap, it does not fetch during the rewrite phase, so we can let it quickly execute on a networking thread, +++ b/core/src/main/java/org/elasticsearch/action/search/AbstractSearchAsyncAction.java, +                                        SearchTask task, SearchPhaseResults<Result> resultConsumer, int maxConcurrentShardRequests) {, +        super(name, request, shardsIts, logger, maxConcurrentShardRequests);, +++ b/core/src/main/java/org/elasticsearch/action/search/CanMatchPreFilterSearchPhase.java, +        /*, +         * We set max concurrent shard requests to the number of shards to otherwise avoid deep recursing that would occur if the local node, +         * is the coordinating node for the query, holds all the shards for the request, and there are a lot of shards., +         */, +            listener, shardsIts, timeProvider, clusterStateVersion, task, new BitSetSearchPhaseResults(shardsIts.size()), shardsIts.size());, +++ b/core/src/main/java/org/elasticsearch/action/search/InitialSearchPhase.java, +    InitialSearchPhase(String name, SearchRequest request, GroupShardsIterator<SearchShardIterator> shardsIts, Logger logger,, +                       int maxConcurrentShardRequests) {, +        this.maxConcurrentShardRequests = Math.min(maxConcurrentShardRequests, shardsIts.size());, +++ b/core/src/main/java/org/elasticsearch/action/search/SearchDfsQueryThenFetchAsyncAction.java, +                shardsIts, timeProvider, clusterStateVersion, task, new ArraySearchPhaseResults<>(shardsIts.size()),, +                request.getMaxConcurrentShardRequests());, +++ b/core/src/main/java/org/elasticsearch/action/search/SearchQueryThenFetchAsyncAction.java, +            shardsIts, timeProvider, clusterStateVersion, task, searchPhaseController.newSearchPhaseResults(request, shardsIts.size()),]