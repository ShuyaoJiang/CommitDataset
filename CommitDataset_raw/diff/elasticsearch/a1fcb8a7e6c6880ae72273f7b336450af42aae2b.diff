[+++ b/plugins/mapper-annotated-text/src/main/java/org/elasticsearch/index/mapper/annotatedtext/AnnotatedTextFieldMapper.java, +import org.elasticsearch.search.fetch.FetchSubPhase.HitContext;, +        private final Analyzer delegate;, +        private final HitContext hitContext;, +        public AnnotatedHighlighterAnalyzer(Analyzer delegate, HitContext hitContext){, +            this.hitContext = hitContext;, +            AnnotatedText[] annotations = (AnnotatedText[]) hitContext.cache().get(AnnotatedText.class.getName());, +                AnnotatedText at = annotations[readerNum.getAndIncrement()];, +++ b/plugins/mapper-annotated-text/src/main/java/org/elasticsearch/index/mapper/annotatedtext/AnnotatedTextFieldMapper.java, +import org.elasticsearch.search.fetch.FetchSubPhase.HitContext;, +        private final Analyzer delegate;, +        private final HitContext hitContext;, +        public AnnotatedHighlighterAnalyzer(Analyzer delegate, HitContext hitContext){, +            this.hitContext = hitContext;, +            AnnotatedText[] annotations = (AnnotatedText[]) hitContext.cache().get(AnnotatedText.class.getName());, +                AnnotatedText at = annotations[readerNum.getAndIncrement()];, +++ b/plugins/mapper-annotated-text/src/main/java/org/elasticsearch/search/fetch/subphase/highlight/AnnotatedPassageFormatter.java, +import org.elasticsearch.index.mapper.annotatedtext.AnnotatedTextFieldMapper.AnnotatedText;, +    AnnotatedText[] annotations;, +    public AnnotatedPassageFormatter(AnnotatedText[] annotations, Encoder encoder) {, +        this.annotations = annotations;, +            AnnotationToken [] annotations = getIntersectingAnnotations(passage.getStartOffset(), , +    public AnnotationToken[] getIntersectingAnnotations(int start, int end) {, +        List<AnnotationToken> intersectingAnnotations = new ArrayList<>();, +        int fieldValueOffset =0;, +        for (AnnotatedText fieldValueAnnotations : this.annotations) {, +            //This is called from a highlighter where all of the field values are concatenated, +            // so each annotation offset will need to be adjusted so that it takes into account , +            // the previous values AND the MULTIVAL delimiter, +            for (int i = 0; i < fieldValueAnnotations.numAnnotations(); i++) {, +                AnnotationToken token = fieldValueAnnotations.getAnnotation(i);, +                if (token.intersects(start - fieldValueOffset, end - fieldValueOffset)) {, +                    intersectingAnnotations, +                            .add(new AnnotationToken(token.offset + fieldValueOffset, token.endOffset + , +                                    fieldValueOffset, token.value));, +                }, +            }, +            //add 1 for the fieldvalue separator character, +            fieldValueOffset +=fieldValueAnnotations.textMinusMarkup.length() +1;, +        }, +        return intersectingAnnotations.toArray(new AnnotationToken[intersectingAnnotations.size()]);, +    }     , +, +++ b/plugins/mapper-annotated-text/src/main/java/org/elasticsearch/index/mapper/annotatedtext/AnnotatedTextFieldMapper.java, +import org.elasticsearch.search.fetch.FetchSubPhase.HitContext;, +        private final Analyzer delegate;, +        private final HitContext hitContext;, +        public AnnotatedHighlighterAnalyzer(Analyzer delegate, HitContext hitContext){, +            this.hitContext = hitContext;, +            AnnotatedText[] annotations = (AnnotatedText[]) hitContext.cache().get(AnnotatedText.class.getName());, +                AnnotatedText at = annotations[readerNum.getAndIncrement()];, +++ b/plugins/mapper-annotated-text/src/main/java/org/elasticsearch/search/fetch/subphase/highlight/AnnotatedPassageFormatter.java, +import org.elasticsearch.index.mapper.annotatedtext.AnnotatedTextFieldMapper.AnnotatedText;, +    AnnotatedText[] annotations;, +    public AnnotatedPassageFormatter(AnnotatedText[] annotations, Encoder encoder) {, +        this.annotations = annotations;, +            AnnotationToken [] annotations = getIntersectingAnnotations(passage.getStartOffset(), , +    public AnnotationToken[] getIntersectingAnnotations(int start, int end) {, +        List<AnnotationToken> intersectingAnnotations = new ArrayList<>();, +        int fieldValueOffset =0;, +        for (AnnotatedText fieldValueAnnotations : this.annotations) {, +            //This is called from a highlighter where all of the field values are concatenated, +            // so each annotation offset will need to be adjusted so that it takes into account , +            // the previous values AND the MULTIVAL delimiter, +            for (int i = 0; i < fieldValueAnnotations.numAnnotations(); i++) {, +                AnnotationToken token = fieldValueAnnotations.getAnnotation(i);, +                if (token.intersects(start - fieldValueOffset, end - fieldValueOffset)) {, +                    intersectingAnnotations, +                            .add(new AnnotationToken(token.offset + fieldValueOffset, token.endOffset + , +                                    fieldValueOffset, token.value));, +                }, +            }, +            //add 1 for the fieldvalue separator character, +            fieldValueOffset +=fieldValueAnnotations.textMinusMarkup.length() +1;, +        }, +        return intersectingAnnotations.toArray(new AnnotationToken[intersectingAnnotations.size()]);, +    }     , +, +++ b/plugins/mapper-annotated-text/src/main/java/org/elasticsearch/search/fetch/subphase/highlight/AnnotatedTextHighlighter.java, +import org.elasticsearch.index.mapper.annotatedtext.AnnotatedTextFieldMapper.AnnotatedText;, +import java.util.ArrayList;, +    protected Analyzer getAnalyzer(DocumentMapper docMapper, MappedFieldType type, HitContext hitContext) {, +        return new AnnotatedHighlighterAnalyzer(super.getAnalyzer(docMapper, type, hitContext), hitContext);, +        , +        AnnotatedText[] annotations = new AnnotatedText[fieldValuesAsString.length];, +        for (int i = 0; i < fieldValuesAsString.length; i++) {, +            annotations[i] = AnnotatedText.parse(fieldValuesAsString[i]);, +        }, +        // Store the annotations in the hitContext, +        hitContext.cache().put(AnnotatedText.class.getName(), annotations);, +        , +        ArrayList<Object> result = new ArrayList<>(annotations.length);, +        for (int i = 0; i < annotations.length; i++) {, +            result.add(annotations[i].textMinusMarkup);, +        }, +        return result;, +    protected PassageFormatter getPassageFormatter(HitContext hitContext,SearchContextHighlight.Field field, Encoder encoder) {, +        // Retrieve the annotations from the hitContext, +        AnnotatedText[] annotations = (AnnotatedText[]) hitContext.cache().get(AnnotatedText.class.getName());, +        return new AnnotatedPassageFormatter(annotations, encoder);]