[+++ b/modules/transport-netty4/src/main/java/org/elasticsearch/transport/netty4/Netty4Utils.java, +        final Logger logger = ESLoggerFactory.getLogger(Netty4Utils.class);, +        final Optional<Error> maybeError = ExceptionsHelper.maybeError(cause, logger);, +++ b/modules/transport-netty4/src/main/java/org/elasticsearch/transport/netty4/Netty4Utils.java, +        final Logger logger = ESLoggerFactory.getLogger(Netty4Utils.class);, +        final Optional<Error> maybeError = ExceptionsHelper.maybeError(cause, logger);, +++ b/modules/transport-netty4/src/test/java/org/elasticsearch/transport/netty4/Netty4UtilsTests.java, +++ b/modules/transport-netty4/src/main/java/org/elasticsearch/transport/netty4/Netty4Utils.java, +        final Logger logger = ESLoggerFactory.getLogger(Netty4Utils.class);, +        final Optional<Error> maybeError = ExceptionsHelper.maybeError(cause, logger);, +++ b/modules/transport-netty4/src/test/java/org/elasticsearch/transport/netty4/Netty4UtilsTests.java, +++ b/server/src/main/java/org/elasticsearch/ExceptionsHelper.java, +import java.util.Collections;, +import java.util.LinkedList;, +import java.util.Optional;, +import java.util.Queue;, +    static final int MAX_ITERATIONS = 1024;, +, +    /**, +     * Unwrap the specified throwable looking for any suppressed errors or errors as a root cause of the specified throwable., +     *, +     * @param cause the root throwable, +     *, +     * @return an optional error if one is found suppressed or a root cause in the tree rooted at the specified throwable, +     */, +    public static Optional<Error> maybeError(final Throwable cause, final Logger logger) {, +        // early terminate if the cause is already an error, +        if (cause instanceof Error) {, +            return Optional.of((Error) cause);, +        }, +, +        final Queue<Throwable> queue = new LinkedList<>();, +        queue.add(cause);, +        int iterations = 0;, +        while (!queue.isEmpty()) {, +            iterations++;, +            if (iterations > MAX_ITERATIONS) {, +                logger.warn("giving up looking for fatal errors", cause);, +                break;, +            }, +            final Throwable current = queue.remove();, +            if (current instanceof Error) {, +                return Optional.of((Error) current);, +            }, +            Collections.addAll(queue, current.getSuppressed());, +            if (current.getCause() != null) {, +                queue.add(current.getCause());, +            }, +        }, +        return Optional.empty();, +    }, +, +++ b/modules/transport-netty4/src/main/java/org/elasticsearch/transport/netty4/Netty4Utils.java, +        final Logger logger = ESLoggerFactory.getLogger(Netty4Utils.class);, +        final Optional<Error> maybeError = ExceptionsHelper.maybeError(cause, logger);, +++ b/modules/transport-netty4/src/test/java/org/elasticsearch/transport/netty4/Netty4UtilsTests.java, +++ b/server/src/main/java/org/elasticsearch/ExceptionsHelper.java, +import java.util.Collections;, +import java.util.LinkedList;, +import java.util.Optional;, +import java.util.Queue;, +    static final int MAX_ITERATIONS = 1024;, +, +    /**, +     * Unwrap the specified throwable looking for any suppressed errors or errors as a root cause of the specified throwable., +     *, +     * @param cause the root throwable, +     *, +     * @return an optional error if one is found suppressed or a root cause in the tree rooted at the specified throwable, +     */, +    public static Optional<Error> maybeError(final Throwable cause, final Logger logger) {, +        // early terminate if the cause is already an error, +        if (cause instanceof Error) {, +            return Optional.of((Error) cause);, +        }, +, +        final Queue<Throwable> queue = new LinkedList<>();, +        queue.add(cause);, +        int iterations = 0;, +        while (!queue.isEmpty()) {, +            iterations++;, +            if (iterations > MAX_ITERATIONS) {, +                logger.warn("giving up looking for fatal errors", cause);, +                break;, +            }, +            final Throwable current = queue.remove();, +            if (current instanceof Error) {, +                return Optional.of((Error) current);, +            }, +            Collections.addAll(queue, current.getSuppressed());, +            if (current.getCause() != null) {, +                queue.add(current.getCause());, +            }, +        }, +        return Optional.empty();, +    }, +, +++ b/server/src/test/java/org/elasticsearch/ExceptionsHelperTests.java, +/*, + * Licensed to Elasticsearch under one or more contributor]