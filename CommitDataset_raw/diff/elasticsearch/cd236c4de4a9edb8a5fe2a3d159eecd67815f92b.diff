[+++ b/core/src/main/java/org/elasticsearch/action/bulk/BulkItemResponse.java, +import org.elasticsearch.action.DocWriteResponse;, +        private final Exception cause;, +        public Failure(String index, String type, String id, Exception cause) {, +        public Exception getCause() {, +++ b/core/src/main/java/org/elasticsearch/action/bulk/BulkItemResponse.java, +import org.elasticsearch.action.DocWriteResponse;, +        private final Exception cause;, +        public Failure(String index, String type, String id, Exception cause) {, +        public Exception getCause() {, +++ b/core/src/main/java/org/elasticsearch/action/bulk/TransportBulkAction.java, +import org.elasticsearch.cluster.ClusterStateObserver;, +import org.elasticsearch.cluster.block.ClusterBlockException;, +import org.elasticsearch.common.unit.TimeValue;, +import org.elasticsearch.common.util.concurrent.AbstractRunnable;, +import org.elasticsearch.common.util.concurrent.ThreadContext;, +import org.elasticsearch.node.NodeClosedException;, +                                executeBulk(task, bulkRequest, startTime, ActionListener.wrap(listener::onResponse, inner -> {, +                                }), responses);, +    /**, +     * retries on retryable cluster blocks, resolves item requests,, +     * constructs shard bulk requests and delegates execution to shard bulk action, +     * */, +    private final class BulkOperation extends AbstractRunnable {, +        private final Task task;, +        private final BulkRequest bulkRequest;, +        private final ActionListener<BulkResponse> listener;, +        private final AtomicArray<BulkItemResponse> responses;, +        private final long startTimeNanos;, +        private final ClusterStateObserver observer;, +        BulkOperation(Task task, BulkRequest bulkRequest, ActionListener<BulkResponse> listener,, +                      AtomicArray<BulkItemResponse> responses, long startTimeNanos) {, +            this.task = task;, +            this.bulkRequest = bulkRequest;, +            this.listener = listener;, +            this.responses = responses;, +            this.startTimeNanos = startTimeNanos;, +            this.observer = new ClusterStateObserver(clusterService, bulkRequest.timeout(), logger, threadPool.getThreadContext());, +        }, +, +        @Override, +        public void onFailure(Exception e) {, +            listener.onFailure(e);, +        }, +, +        @Override, +        protected void doRun() throws Exception {, +            final ClusterState clusterState = observer.setAndGetObservedState();, +            if (handleBlockExceptions(clusterState)) {, +                return;, +            }, +                            docWriteRequest.routing(metaData.resolveIndexRouting(docWriteRequest.parent(), docWriteRequest.routing(), docWriteRequest.index()));, +                            // check if routing is required, if so, throw error if routing wasn't specified, +                            if (docWriteRequest.routing() == null && metaData.routingRequired(concreteIndex.getName(), docWriteRequest.type())) {, +                                throw new RoutingMissingException(concreteIndex.getName(), docWriteRequest.type(), docWriteRequest.id());, +                            }, +        private boolean handleBlockExceptions(ClusterState state) {, +            ClusterBlockException blockException = state.blocks().globalBlockedException(ClusterBlockLevel.WRITE);, +            if (blockException != null) {, +                if (blockException.retryable()) {, +                    logger.trace("cluster is blocked, scheduling a retry", blockException);, +                    retry(blockException);, +                } else {, +                    onFailure(blockException);, +                }, +                return true;, +            }, +            return false;, +        }, +, +        void retry(Exception failure) {, +            assert failure != null;, +            if (observer.isTimedOut()) {, +                // we running as a last attempt after a timeout has happened. don't retry, +                onFailure(failure);, +                return;, +            }, +            final ThreadContext.StoredContext context = threadPool.getThreadContext().newStoredContext();, +            observer.waitForNextChange(new ClusterStateObserver.Listener() {, +                @Override, +                public void onNewClusterState(ClusterState state) {, +                    context.close();, +                    run();, +                }, +, +                @Override, +                public void onClusterServiceClose() {, +                    onFailure(new NodeClosedException(clusterService.localNode()));, +                }, +, +                @Override, +                public void onTimeout(TimeValue timeout) {, +                    context.close();, +                    // Try one more time..., +                    run();, +                }, +            });, +        }, +    }, +]