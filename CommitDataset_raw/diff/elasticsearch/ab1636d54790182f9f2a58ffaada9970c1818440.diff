[+++ b/core/src/main/java/org/elasticsearch/index/engine/InternalEngine.java, +            if (index.seqNo() == SequenceNumbersService.UNASSIGNED_SEQ_NO) {, +            } else if (index.seqNo() <= seqNoService.getLocalCheckpoint()){, +                // the operation seq# is lower then the current local checkpoint and thus was already put into lucene, +                // this can happen during recovery where older operations are sent from the translog that are already, +                // part of the lucene commit (either from a peer recovery or a local translog), +                // or due to concurrent indexing & recovery. For the former it is important to skip lucene as the operation in, +                // question may have been deleted in an out of order op that is not replayed., +                // See testRecoverFromStoreWithOutOfOrderDelete for an example of local recovery, +                // See testRecoveryWithOutOfOrderDelete for an example of peer recovery, +                opVsLucene = OpVsLuceneDocStatus.OP_STALE_OR_EQUAL;, +            } else {, +                opVsLucene = compareOpToLuceneDocBasedOnSeqNo(index);, +        if (delete.seqNo() == SequenceNumbersService.UNASSIGNED_SEQ_NO) {, +        } else if (delete.seqNo() <= seqNoService.getLocalCheckpoint()) {, +            // the operation seq# is lower then the current local checkpoint and thus was already put into lucene, +            // this can happen during recovery where older operations are sent from the translog that are already, +            // part of the lucene commit (either from a peer recovery or a local translog), +            // or due to concurrent indexing & recovery. For the former it is important to skip lucene as the operation in, +            // question may have been deleted in an out of order op that is not replayed., +            // See testRecoverFromStoreWithOutOfOrderDelete for an example of local recovery, +            // See testRecoveryWithOutOfOrderDelete for an example of peer recovery, +            opVsLucene = OpVsLuceneDocStatus.OP_STALE_OR_EQUAL;, +        } else {, +            opVsLucene = compareOpToLuceneDocBasedOnSeqNo(delete);, +++ b/core/src/main/java/org/elasticsearch/index/engine/InternalEngine.java, +            if (index.seqNo() == SequenceNumbersService.UNASSIGNED_SEQ_NO) {, +            } else if (index.seqNo() <= seqNoService.getLocalCheckpoint()){, +                // the operation seq# is lower then the current local checkpoint and thus was already put into lucene, +                // this can happen during recovery where older operations are sent from the translog that are already, +                // part of the lucene commit (either from a peer recovery or a local translog), +                // or due to concurrent indexing & recovery. For the former it is important to skip lucene as the operation in, +                // question may have been deleted in an out of order op that is not replayed., +                // See testRecoverFromStoreWithOutOfOrderDelete for an example of local recovery, +                // See testRecoveryWithOutOfOrderDelete for an example of peer recovery, +                opVsLucene = OpVsLuceneDocStatus.OP_STALE_OR_EQUAL;, +            } else {, +                opVsLucene = compareOpToLuceneDocBasedOnSeqNo(index);, +        if (delete.seqNo() == SequenceNumbersService.UNASSIGNED_SEQ_NO) {, +        } else if (delete.seqNo() <= seqNoService.getLocalCheckpoint()) {, +            // the operation seq# is lower then the current local checkpoint and thus was already put into lucene, +            // this can happen during recovery where older operations are sent from the translog that are already, +            // part of the lucene commit (either from a peer recovery or a local translog), +            // or due to concurrent indexing & recovery. For the former it is important to skip lucene as the operation in, +            // question may have been deleted in an out of order op that is not replayed., +            // See testRecoverFromStoreWithOutOfOrderDelete for an example of local recovery, +            // See testRecoveryWithOutOfOrderDelete for an example of peer recovery, +            opVsLucene = OpVsLuceneDocStatus.OP_STALE_OR_EQUAL;, +        } else {, +            opVsLucene = compareOpToLuceneDocBasedOnSeqNo(delete);, +++ b/core/src/test/java/org/elasticsearch/index/shard/IndexShardTests.java, +import java.util.function.Consumer;, +import static org.elasticsearch.cluster.routing.TestShardRouting.newShardRouting;, +                newShardRouting(, +                newShardRouting(, +            indexShard = newShard(newShardRouting(shardId, "local_node", "other node",, +            ShardRouting primaryRouting = newShardRouting(replicaRouting.shardId(), replicaRouting.currentNodeId(), null,, +                ShardRouting routing = newShardRouting(shardId, "local_node",, +                routing = newShardRouting(routing.shardId(), routing.currentNodeId(), "otherNode",, +    public void testRecoverFromStoreWithOutOfOrderDelete() throws IOException {, +        final IndexShard shard = newStartedShard(false);, +        final Consumer<Mapping> mappingConsumer = getMappingUpdater(shard, "test");, +        shard.applyDeleteOperationOnReplica(1, 1, 2, "test", "id", VersionType.EXTERNAL, mappingConsumer);, +        shard.getEngine().rollTranslogGeneration(); // isolate the delete in it's own generation, +        shard.applyIndexOperationOnReplica(0, 1, 1, VersionType.EXTERNAL, IndexRequest.UNSET_AUTO_GENERATED_TIMESTAMP, false,, +            SourceToParse.source(shard.shardId().getIndexName(), "test", "id", new BytesArray("{}"), XContentType.JSON), mappingConsumer);, +, +        // index a second item into the second generation, skipping seq# 2. Local checkpoint is now 1, which will make this generation stick, +        // around, +        shard.applyIndexOperationOnReplica(3, 1, 1, VersionType.EXTERNAL, IndexRequest.UNSET_AUTO_GENERATED_TIMESTAMP, false,, +            SourceToParse.source(shard.shardId().getIndexName(), "test", "id2", new BytesArray("{}"), XContentType.JSON), mappingConsumer);, +, +        final int translogOps;, +        if (randomBoolean()) {, +            logger.info("--> flushing shard");, +            flushShard(shard);, +            translogOps = 2;, +        } else if (randomBoolean())  {, +            shard.getEngine().rollTranslogGeneration();, +            translogOps = 3;, +        } else {, +            translogOps = 3;, +        }, +, +        final ShardRouting replicaRouting = shard.routingEntry();, +        IndexShard newShard = reinitShard(shard,, +            newShardRouting(replicaRouting.shardId(), replicaRouting.currentNodeId(), true, ShardRoutingState.INITIALIZING,, +                RecoverySource.StoreRecoverySource.EXISTING_STORE_INSTANCE));, +        DiscoveryNode localNode = new DiscoveryNode("foo", buildNewFakeTransportAddress(), emptyMap(), emptySet(), Version.CURRENT);, +        newShard.markAsRecovering("store", new RecoveryState(newShard.routingEntry(), localNode, null));, +        assertTrue(newShard.recoverFromStore());, +        assertEquals(translogOps, newShard.recoveryState().getTranslog().recoveredOperations());, +        assertEquals(translogOps, newShard.recoveryState().getTranslog().totalOperations());, +        assertEquals(translogOps, newShard.recoveryState().getTranslog().totalOperationsOnStart());, +        assertEquals(100.0f, newShard.recoveryState().getTranslog().recoveredPercent(), 0.01f);, +        updateRoutingEntry(newShard, ShardRoutingHelper.moveToStarted(newShard.routingEntry()));, +        assertDocCount(newShard, 1);, +        closeShards(newShard);, +    }, +]