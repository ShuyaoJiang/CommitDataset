[+++ b/core/src/main/java/org/elasticsearch/common/util/concurrent/KeyedLock.java, +++ b/core/src/main/java/org/elasticsearch/common/util/concurrent/KeyedLock.java, +++ b/core/src/main/java/org/elasticsearch/index/fielddata/IndexFieldDataService.java, +, +import org.elasticsearch.Version;, +    // the below map needs to be modified under a lock, +    private final Map<String, IndexFieldDataCache> fieldDataCaches = Maps.newHashMap();, +    // We need to cache fielddata on the _parent field because of 1.x indices., +    // When we don't support 1.x anymore (3.0) then remove this caching, +    // This variable needs to be read/written under lock, +    private IndexFieldData<?> parentIndexFieldData;, +, +    public synchronized void clear() {, +        parentIndexFieldData = null;, +    public synchronized void clearField(final String fieldName) {, +        if (ParentFieldMapper.NAME.equals(fieldName)) {, +            parentIndexFieldData = null;, +        }, +        IndexFieldDataCache cache;, +        synchronized (this) {, +            cache = fieldDataCaches.get(fieldNames.indexName());, +            // Remove this in 3.0, +            final boolean isOldParentField = ParentFieldMapper.NAME.equals(fieldNames.indexName()), +                    && Version.indexCreated(indexSettings).before(Version.V_2_0_0_beta1);, +            if (isOldParentField) {, +                if (parentIndexFieldData == null) {, +                    parentIndexFieldData = builder.build(index, indexSettings, fieldType, cache, circuitBreakerService, indexService.mapperService());, +                return (IFD) parentIndexFieldData;, +            }, +        }, +, +        return (IFD) builder.build(index, indexSettings, fieldType, cache, circuitBreakerService, indexService.mapperService());, +++ b/core/src/main/java/org/elasticsearch/common/util/concurrent/KeyedLock.java, +++ b/core/src/main/java/org/elasticsearch/index/fielddata/IndexFieldDataService.java, +, +import org.elasticsearch.Version;, +    // the below map needs to be modified under a lock, +    private final Map<String, IndexFieldDataCache> fieldDataCaches = Maps.newHashMap();, +    // We need to cache fielddata on the _parent field because of 1.x indices., +    // When we don't support 1.x anymore (3.0) then remove this caching, +    // This variable needs to be read/written under lock, +    private IndexFieldData<?> parentIndexFieldData;, +, +    public synchronized void clear() {, +        parentIndexFieldData = null;, +    public synchronized void clearField(final String fieldName) {, +        if (ParentFieldMapper.NAME.equals(fieldName)) {, +            parentIndexFieldData = null;, +        }, +        IndexFieldDataCache cache;, +        synchronized (this) {, +            cache = fieldDataCaches.get(fieldNames.indexName());, +            // Remove this in 3.0, +            final boolean isOldParentField = ParentFieldMapper.NAME.equals(fieldNames.indexName()), +                    && Version.indexCreated(indexSettings).before(Version.V_2_0_0_beta1);, +            if (isOldParentField) {, +                if (parentIndexFieldData == null) {, +                    parentIndexFieldData = builder.build(index, indexSettings, fieldType, cache, circuitBreakerService, indexService.mapperService());, +                return (IFD) parentIndexFieldData;, +            }, +        }, +, +        return (IFD) builder.build(index, indexSettings, fieldType, cache, circuitBreakerService, indexService.mapperService());, +++ b/core/src/main/java/org/elasticsearch/index/fielddata/plain/ParentChildIndexFieldData.java, +, +        if (Version.indexCreated(indexSettings).before(Version.V_2_0_0_beta1)) {, +            parentTypes = new TreeSet<>();, +        } else {, +            ImmutableSortedSet.Builder<String> builder = ImmutableSortedSet.naturalOrder();, +            for (DocumentMapper mapper : mapperService.docMappers(false)) {, +                ParentFieldMapper parentFieldMapper = mapper.parentFieldMapper();, +                if (parentFieldMapper.active()) {, +                    builder.add(parentFieldMapper.type());, +                }, +            }, +            parentTypes = builder.build();, +        }, +        // Make this method throw an UnsupportedOperationException in 3.0, only, +        // needed for indices created BEFORE 2.0, +        // Remove in 3.0, +        if (Version.indexCreated(indexSettings).before(Version.V_2_0_0_beta1)) {, +        } else {, +            parentTypes = this.parentTypes;, +        }, +++ b/core/src/main/java/org/elasticsearch/common/util/concurrent/KeyedLock.java, +++ b/core/src/main/java/org/elasticsearch/index/fielddata/IndexFieldDataService.java, +, +import org.elasticsearch.Version;, +    // the below map needs to be modified under a lock, +    private final Map<String, IndexFieldDataCache> fieldDataCaches = Maps.newHashMap();, +    // We need to cache fielddata on the _parent field because of 1.x indices., +    // When we don't support 1.x anymore (3.0) then remove this caching, +    // This variable needs to be read/written under lock, +    private IndexFieldData<?> parentIndexFieldData;, +, +    public synchronized void clear() {, +        parentIndexFieldData = null;, +    public synchronized void clearField(final String fieldName) {, +        if (ParentFieldMapper.NAME.equals(fieldName)) {, +            parentIndexFieldData = null;]