[+++ b/x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/Security.java, +        securityIndex.set(new SecurityIndexManager(client, SecurityIndexManager.SECURITY_INDEX_NAME, clusterService));, +++ b/x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/Security.java, +        securityIndex.set(new SecurityIndexManager(client, SecurityIndexManager.SECURITY_INDEX_NAME, clusterService));, +++ b/x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authc/TokenService.java, +                            decryptTokenId(in, cipher, version, ActionListener.wrap(tokenId -> {, +                                if (securityIndex.isAvailable() == false) {, +                                    logger.warn("failed to get token [{}] since index is not available", tokenId);, +                                    listener.onResponse(null);, +                                } else {, +                                    securityIndex.checkIndexVersionThenExecute(, +                                        });, +                                }}, listener::onFailure));, +            final SecurityIndexManager frozenSecurityIndex = securityIndex.freeze();, +            if (frozenSecurityIndex.indexExists() == false) {, +                logger.warn("security index does not exist therefore refresh token [{}] cannot be validated", refreshToken);, +                listener.onFailure(invalidGrantException("could not refresh the requested token"));, +            } else if (frozenSecurityIndex.isAvailable() == false) {, +                logger.debug("security index is not available to find token from refresh token, retrying");, +                attemptCount.incrementAndGet();, +                findTokenFromRefreshToken(refreshToken, listener, attemptCount);, +            } else {, +                securityIndex.checkIndexVersionThenExecute(listener::onFailure, () ->, +    }, +        final SecurityIndexManager frozenSecurityIndex = securityIndex.freeze();, +        } else if (frozenSecurityIndex.indexExists() == false) {, +            listener.onResponse(Collections.emptyList());, +        } else if (frozenSecurityIndex.isAvailable() == false) {, +            listener.onFailure(frozenSecurityIndex.getUnavailableReason());, +        } else {, +            securityIndex.checkIndexVersionThenExecute(listener::onFailure,, +                () -> ScrollHelper.fetchAllByEntity(client, request, listener, this::parseHit));, +        }, +            // index doesn't exist so the token is considered valid. it is important to note that, +            // we do not use isAvailable as the lack of a shard being available is not equivalent, +            // to the index not existing in the case of revocation checking., +            securityIndex.checkIndexVersionThenExecute(listener::onFailure, () -> {, +++ b/x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/Security.java, +        securityIndex.set(new SecurityIndexManager(client, SecurityIndexManager.SECURITY_INDEX_NAME, clusterService));, +++ b/x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authc/TokenService.java, +                            decryptTokenId(in, cipher, version, ActionListener.wrap(tokenId -> {, +                                if (securityIndex.isAvailable() == false) {, +                                    logger.warn("failed to get token [{}] since index is not available", tokenId);, +                                    listener.onResponse(null);, +                                } else {, +                                    securityIndex.checkIndexVersionThenExecute(, +                                        });, +                                }}, listener::onFailure));, +            final SecurityIndexManager frozenSecurityIndex = securityIndex.freeze();, +            if (frozenSecurityIndex.indexExists() == false) {, +                logger.warn("security index does not exist therefore refresh token [{}] cannot be validated", refreshToken);, +                listener.onFailure(invalidGrantException("could not refresh the requested token"));, +            } else if (frozenSecurityIndex.isAvailable() == false) {, +                logger.debug("security index is not available to find token from refresh token, retrying");, +                attemptCount.incrementAndGet();, +                findTokenFromRefreshToken(refreshToken, listener, attemptCount);, +            } else {, +                securityIndex.checkIndexVersionThenExecute(listener::onFailure, () ->, +    }, +        final SecurityIndexManager frozenSecurityIndex = securityIndex.freeze();, +        } else if (frozenSecurityIndex.indexExists() == false) {, +            listener.onResponse(Collections.emptyList());, +        } else if (frozenSecurityIndex.isAvailable() == false) {, +            listener.onFailure(frozenSecurityIndex.getUnavailableReason());, +        } else {, +            securityIndex.checkIndexVersionThenExecute(listener::onFailure,, +                () -> ScrollHelper.fetchAllByEntity(client, request, listener, this::parseHit));, +        }, +            // index doesn't exist so the token is considered valid. it is important to note that, +            // we do not use isAvailable as the lack of a shard being available is not equivalent, +            // to the index not existing in the case of revocation checking., +            securityIndex.checkIndexVersionThenExecute(listener::onFailure, () -> {, +++ b/x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authc/esnative/NativeUsersStore.java, +            if (TransportActions.isShardNotAvailableException(t)) {, +                logger.trace("could not retrieve users because of a shard not available exception", t);, +                    // as the index doesn't exist. Could have been deleted between checks and execution, +            }, +            listener.onFailure(t);, +        final SecurityIndexManager frozenSecurityIndex = this.securityIndex.freeze();, +        if (frozenSecurityIndex.indexExists() == false) {, +        } else if (frozenSecurityIndex.isAvailable() == false) {, +            listener.onFailure(frozenSecurityIndex.getUnavailableReason());, +            securityIndex.checkIndexVersionThenExecute(listener::onFailure, () -> {, +                    final String[] users = Arrays.stream(userNames).map(s -> getIdForUser(USER_DOC_TYPE, s)).toArray(String[]::new);, +        final SecurityIndexManager frozenSecurityIndex = this.securityIndex.freeze();, +        if (frozenSecurityIndex.indexExists() == false) {, +        } else if (frozenSecurityIndex.isAvailable() == false) {, +            listener.onFailure(frozenSecurityIndex.getUnavailableReason());, +            securityIndex.checkIndexVersionThenExecute(listener::onFailure, () ->, +        final SecurityIndexManager frozenSecurityIndex = securityIndex.freeze();, +        if (frozenSecurityIndex.isAvailable() == false) {, +            if (frozenSecurityIndex.indexExists()) {, +                logger.trace("could not retrieve user [{}] because security index does not exist", user);, +            } else {, +                logger.error("security index is unavailable. short circuiting retrieval of user [{}]", user);, +            }, +            securityIndex.checkIndexVersionThenExecute(listener::onFailure, () ->, +        final SecurityIndexManager frozenSecurityIndex = securityIndex.freeze();, +        if (frozenSecurityIndex.indexExists() == false) {, +            listener.onResponse(false);]