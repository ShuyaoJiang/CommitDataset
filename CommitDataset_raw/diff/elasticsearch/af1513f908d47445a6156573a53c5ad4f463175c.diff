[+++ b/src/main/java/org/elasticsearch/search/aggregations/bucket/BytesRefHash.java, +            Releasables.release(success, bytes, hashes, startOffsets);, +++ b/src/main/java/org/elasticsearch/search/aggregations/bucket/BytesRefHash.java, +            Releasables.release(success, bytes, hashes, startOffsets);, +++ b/src/test/java/org/elasticsearch/cache/recycler/MockPageCacheRecycler.java, +import com.google.common.collect.Maps;, +import org.elasticsearch.ElasticsearchException;, +import java.util.concurrent.ConcurrentMap;, +    private static final ConcurrentMap<Object, Throwable> ACQUIRED_PAGES = Maps.newConcurrentMap();, +, +    public static void ensureAllPagesAreReleased() {, +        if (ACQUIRED_PAGES.size() > 0) {, +            final Throwable t = ACQUIRED_PAGES.entrySet().iterator().next().getValue();, +            throw new RuntimeException(ACQUIRED_PAGES.size() + " pages have not been released", t);, +        }, +        ACQUIRED_PAGES.clear();, +    }, +, +    private static <T> V<T> wrap(final V<T> v) {, +        ACQUIRED_PAGES.put(v, new Throwable());, +        final Thread t = Thread.currentThread();, +        return new V<T>() {, +, +            @Override, +            public boolean release() throws ElasticsearchException {, +                if (t != Thread.currentThread()) {, +                    // Releasing from a different thread doesn't break anything but this is bad practice as pages should be acquired, +                    // as late as possible and released as soon as possible in a try/finally fashion, +                    throw new RuntimeException("Page was allocated in " + t + " but released in " + Thread.currentThread());, +                }, +                final Throwable t = ACQUIRED_PAGES.remove(v);, +                if (t == null) {, +                    throw new IllegalStateException("Releasing a page that has not been acquired");, +                }, +                return v.release();, +            }, +, +            @Override, +            public T v() {, +                return v.v();, +            }, +, +            @Override, +            public boolean isRecycled() {, +                return v.isRecycled();, +            }, +, +        };, +    }, +, +        return wrap(page);, +        return wrap(page);, +        return wrap(page);, +        return wrap(page);, +    }, +, +    @Override, +    public V<Object[]> objectPage() {, +        return wrap(super.objectPage());, +++ b/src/main/java/org/elasticsearch/search/aggregations/bucket/BytesRefHash.java, +            Releasables.release(success, bytes, hashes, startOffsets);, +++ b/src/test/java/org/elasticsearch/cache/recycler/MockPageCacheRecycler.java, +import com.google.common.collect.Maps;, +import org.elasticsearch.ElasticsearchException;, +import java.util.concurrent.ConcurrentMap;, +    private static final ConcurrentMap<Object, Throwable> ACQUIRED_PAGES = Maps.newConcurrentMap();, +, +    public static void ensureAllPagesAreReleased() {, +        if (ACQUIRED_PAGES.size() > 0) {, +            final Throwable t = ACQUIRED_PAGES.entrySet().iterator().next().getValue();, +            throw new RuntimeException(ACQUIRED_PAGES.size() + " pages have not been released", t);, +        }, +        ACQUIRED_PAGES.clear();, +    }, +, +    private static <T> V<T> wrap(final V<T> v) {, +        ACQUIRED_PAGES.put(v, new Throwable());, +        final Thread t = Thread.currentThread();, +        return new V<T>() {, +, +            @Override, +            public boolean release() throws ElasticsearchException {, +                if (t != Thread.currentThread()) {, +                    // Releasing from a different thread doesn't break anything but this is bad practice as pages should be acquired, +                    // as late as possible and released as soon as possible in a try/finally fashion, +                    throw new RuntimeException("Page was allocated in " + t + " but released in " + Thread.currentThread());, +                }, +                final Throwable t = ACQUIRED_PAGES.remove(v);, +                if (t == null) {, +                    throw new IllegalStateException("Releasing a page that has not been acquired");, +                }, +                return v.release();, +            }, +, +            @Override, +            public T v() {, +                return v.v();, +            }, +, +            @Override]