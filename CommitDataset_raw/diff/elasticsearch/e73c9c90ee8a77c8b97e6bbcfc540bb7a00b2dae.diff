[+++ b/x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/Security.java, +        final ApiKeyService apiKeyService = new ApiKeyService(settings, Clock.systemUTC(), client, securityIndex.get(), clusterService,, +            threadPool);, +        settingsList.add(ApiKeyService.CACHE_HASH_ALGO_SETTING);, +        settingsList.add(ApiKeyService.CACHE_MAX_KEYS_SETTING);, +        settingsList.add(ApiKeyService.CACHE_TTL_SETTING);, +++ b/x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/Security.java, +        final ApiKeyService apiKeyService = new ApiKeyService(settings, Clock.systemUTC(), client, securityIndex.get(), clusterService,, +            threadPool);, +        settingsList.add(ApiKeyService.CACHE_HASH_ALGO_SETTING);, +        settingsList.add(ApiKeyService.CACHE_MAX_KEYS_SETTING);, +        settingsList.add(ApiKeyService.CACHE_TTL_SETTING);, +++ b/x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authc/ApiKeyService.java, +import org.elasticsearch.common.cache.Cache;, +import org.elasticsearch.common.cache.CacheBuilder;, +import org.elasticsearch.common.util.concurrent.FutureUtils;, +import org.elasticsearch.common.util.concurrent.ListenableFuture;, +import org.elasticsearch.threadpool.ThreadPool;, +import java.util.concurrent.ExecutionException;, +import java.util.concurrent.TimeUnit;, +import java.util.concurrent.atomic.AtomicBoolean;, +    public static final Setting<String> CACHE_HASH_ALGO_SETTING = Setting.simpleString("xpack.security.authc.api_key.cache.hash_algo",, +        "ssha256", Setting.Property.NodeScope);, +    public static final Setting<TimeValue> CACHE_TTL_SETTING = Setting.timeSetting("xpack.security.authc.api_key.cache.ttl",, +        TimeValue.timeValueHours(24L), Property.NodeScope);, +    public static final Setting<Integer> CACHE_MAX_KEYS_SETTING = Setting.intSetting("xpack.security.authc.api_key.cache.max_keys",, +        10000, Property.NodeScope);, +    private final Cache<String, ListenableFuture<CachedApiKeyHashResult>> apiKeyAuthCache;, +    private final Hasher cacheHasher;, +    private final ThreadPool threadPool;, +    public ApiKeyService(Settings settings, Clock clock, Client client, SecurityIndexManager securityIndex, ClusterService clusterService,, +                         ThreadPool threadPool) {, +        this.threadPool = threadPool;, +        this.cacheHasher = Hasher.resolve(CACHE_HASH_ALGO_SETTING.get(settings));, +        final TimeValue ttl = CACHE_TTL_SETTING.get(settings);, +        if (ttl.getNanos() > 0) {, +            this.apiKeyAuthCache = CacheBuilder.<String, ListenableFuture<CachedApiKeyHashResult>>builder(), +                .setExpireAfterWrite(ttl), +                .setMaximumWeight(CACHE_MAX_KEYS_SETTING.get(settings)), +                .build();, +        } else {, +            this.apiKeyAuthCache = null;, +        }, +    void validateApiKeyCredentials(Map<String, Object> source, ApiKeyCredentials credentials, Clock clock,, +            if (apiKeyAuthCache != null) {, +                final AtomicBoolean valueAlreadyInCache = new AtomicBoolean(true);, +                final ListenableFuture<CachedApiKeyHashResult> listenableCacheEntry;, +                try {, +                    listenableCacheEntry = apiKeyAuthCache.computeIfAbsent(credentials.getId(),, +                        k -> {, +                            valueAlreadyInCache.set(false);, +                            return new ListenableFuture<>();, +                        });, +                } catch (ExecutionException e) {, +                    listener.onFailure(e);, +                    return;, +                }, +, +                if (valueAlreadyInCache.get()) {, +                    listenableCacheEntry.addListener(ActionListener.wrap(result -> {, +                            if (result.success) {, +                                if (result.verify(credentials.getKey())) {, +                                    // move on, +                                    validateApiKeyExpiration(source, credentials, clock, listener);, +                                } else {, +                                    listener.onResponse(AuthenticationResult.unsuccessful("invalid credentials", null));, +                                }, +                            } else if (result.verify(credentials.getKey())) { // same key, pass the same result, +                                listener.onResponse(AuthenticationResult.unsuccessful("invalid credentials", null));, +                            } else {, +                                apiKeyAuthCache.invalidate(credentials.getId(), listenableCacheEntry);, +                                validateApiKeyCredentials(source, credentials, clock, listener);, +                            }, +                        }, listener::onFailure),, +                        threadPool.generic(), threadPool.getThreadContext());, +                } else {, +                    final boolean verified = verifyKeyAgainstHash(apiKeyHash, credentials);, +                    listenableCacheEntry.onResponse(new CachedApiKeyHashResult(verified, credentials.getKey()));, +                        // move on, +                        validateApiKeyExpiration(source, credentials, clock, listener);, +                    } else {, +                        listener.onResponse(AuthenticationResult.unsuccessful("invalid credentials", null));, +                    }, +                }, +            } else {, +                final boolean verified = verifyKeyAgainstHash(apiKeyHash, credentials);, +                if (verified) {, +                    // move on, +                    validateApiKeyExpiration(source, credentials, clock, listener);, +                } else {, +                    listener.onResponse(AuthenticationResult.unsuccessful("invalid credentials", null));, +                }, +            }, +        }, +    }, +, +    // pkg private for testing, +    CachedApiKeyHashResult getFromCache(String id) {, +        return apiKeyAuthCache == null ? null : FutureUtils.get(apiKeyAuthCache.get(id), 0L, TimeUnit.MILLISECONDS);, +    }]