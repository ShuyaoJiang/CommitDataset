[+++ b/buildSrc/src/main/resources/forbidden/es-all-signatures.txt, +, +@defaultMessage Don't use MethodHandles in slow ways, dont be lenient in tests., +# unfortunately, invoke() cannot be banned, because forbidden apis does not support signature polymorphic methods, +java.lang.invoke.MethodHandle#invokeWithArguments(java.lang.Object[]), +java.lang.invoke.MethodHandle#invokeWithArguments(java.util.List), +++ b/buildSrc/src/main/resources/forbidden/es-all-signatures.txt, +, +@defaultMessage Don't use MethodHandles in slow ways, dont be lenient in tests., +# unfortunately, invoke() cannot be banned, because forbidden apis does not support signature polymorphic methods, +java.lang.invoke.MethodHandle#invokeWithArguments(java.lang.Object[]), +java.lang.invoke.MethodHandle#invokeWithArguments(java.util.List), +++ b/buildSrc/src/main/resources/forbidden/es-core-signatures.txt, +++ b/buildSrc/src/main/resources/forbidden/es-all-signatures.txt, +, +@defaultMessage Don't use MethodHandles in slow ways, dont be lenient in tests., +# unfortunately, invoke() cannot be banned, because forbidden apis does not support signature polymorphic methods, +java.lang.invoke.MethodHandle#invokeWithArguments(java.lang.Object[]), +java.lang.invoke.MethodHandle#invokeWithArguments(java.util.List), +++ b/buildSrc/src/main/resources/forbidden/es-core-signatures.txt, +++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/AnalyzerCaster.java, +        if (sort0 == Sort.DEF || sort1 == Sort.DEF) {, +            return Definition.DEF_TYPE;, +        }, +, +++ b/buildSrc/src/main/resources/forbidden/es-all-signatures.txt, +, +@defaultMessage Don't use MethodHandles in slow ways, dont be lenient in tests., +# unfortunately, invoke() cannot be banned, because forbidden apis does not support signature polymorphic methods, +java.lang.invoke.MethodHandle#invokeWithArguments(java.lang.Object[]), +java.lang.invoke.MethodHandle#invokeWithArguments(java.util.List), +++ b/buildSrc/src/main/resources/forbidden/es-core-signatures.txt, +++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/AnalyzerCaster.java, +        if (sort0 == Sort.DEF || sort1 == Sort.DEF) {, +            return Definition.DEF_TYPE;, +        }, +, +++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/Def.java, +    static <T extends Throwable> void rethrow(Throwable t) throws T {, +++ b/buildSrc/src/main/resources/forbidden/es-all-signatures.txt, +, +@defaultMessage Don't use MethodHandles in slow ways, dont be lenient in tests., +# unfortunately, invoke() cannot be banned, because forbidden apis does not support signature polymorphic methods, +java.lang.invoke.MethodHandle#invokeWithArguments(java.lang.Object[]), +java.lang.invoke.MethodHandle#invokeWithArguments(java.util.List), +++ b/buildSrc/src/main/resources/forbidden/es-core-signatures.txt, +++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/AnalyzerCaster.java, +        if (sort0 == Sort.DEF || sort1 == Sort.DEF) {, +            return Definition.DEF_TYPE;, +        }, +, +++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/Def.java, +    static <T extends Throwable> void rethrow(Throwable t) throws T {, +++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/DefBootstrap.java, +    // constants for the flags parameter of operators, +    /** , +     * static bootstrap parameter indicating the binary operator allows nulls (e.g. == and +) , +     * <p>, +     * requires additional {@link MethodHandles#catchException} guard, which will invoke, +     * the fallback if a null is encountered., +     */, +    public static final int OPERATOR_ALLOWS_NULL = 1 << 0;, +    , +    /**, +     * static bootstrap parameter indicating the binary operator is part of compound assignment (e.g. +=)., +     * , +     */, +    public static final int OPERATOR_COMPOUND_ASSIGNMENT = 1 << 1;, +, +            if (type.parameterType(0) != Object.class) {, +                throw new BootstrapMethodError("The receiver type (1st arg) of invokedynamic descriptor must be Object.");, +            }, +            MethodHandle fallback = FALLBACK.bindTo(this), +        private MethodHandle lookup(int flavor, String name, Class<?> receiver, Object[] callArgs) throws Throwable {, +                    return Def.lookupMethod(lookup, type(), receiver, name, callArgs, (Long) this.args[0]);, +                    return Def.lookupGetter(receiver, name);, +                    return Def.lookupSetter(receiver, name);, +                    return Def.lookupArrayLoad(receiver);, +                    return Def.lookupArrayStore(receiver);, +                    return Def.lookupIterator(receiver);, +                    return Def.lookupReference(lookup, (String) this.args[0], receiver, name);, +         * Creates the {@link MethodHandle} for the megamorphic call site, +         * using {@link ClassValue} and {@link MethodHandles#exactInvoker(MethodType)}:, +         * <p>, +         * TODO: Remove the variable args and just use {@code type()}!, +        private MethodHandle createMegamorphicHandle(final Object[] callArgs) throws Throwable {, +            final MethodType type = type();, +            final ClassValue<MethodHandle> megamorphicCache = new ClassValue<MethodHandle>() {, +                @Override, +                protected MethodHandle computeValue(Class<?> receiverType) {, +                    // it's too stupid that we cannot throw checked exceptions... (use rethrow puzzler):, +                    try {, +                        return lookup(flavor, name, receiverType, callArgs).asType(type);, +                    } catch (Throwable t) {, +                        Def.rethrow(t);, +                        throw new AssertionError();, +                    }, +                }, +            };, +            MethodHandle cacheLookup = MEGAMORPHIC_LOOKUP.bindTo(megamorphicCache);]