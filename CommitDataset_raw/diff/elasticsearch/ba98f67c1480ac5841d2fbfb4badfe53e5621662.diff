[+++ b/modules/aggs-matrix-stats/src/main/java/org/elasticsearch/search/aggregations/matrix/stats/InternalMatrixStats.java, +        for (InternalAggregation agg : aggs) {, +            runningStats.merge(((InternalMatrixStats) agg).stats);, +        if (reduceContext.isFinalReduce()) {, +            MatrixStatsResults results = new MatrixStatsResults(runningStats);, +        return new InternalMatrixStats(name, runningStats.docCount, runningStats, null, pipelineAggregators(), getMetaData());, +    }, +++ b/modules/aggs-matrix-stats/src/main/java/org/elasticsearch/search/aggregations/matrix/stats/InternalMatrixStats.java, +        for (InternalAggregation agg : aggs) {, +            runningStats.merge(((InternalMatrixStats) agg).stats);, +        if (reduceContext.isFinalReduce()) {, +            MatrixStatsResults results = new MatrixStatsResults(runningStats);, +        return new InternalMatrixStats(name, runningStats.docCount, runningStats, null, pipelineAggregators(), getMetaData());, +    }, +++ b/modules/aggs-matrix-stats/src/test/java/org/elasticsearch/search/aggregations/matrix/stats/MatrixStatsAggregatorTests.java, +                InternalMatrixStats stats = search(searcher, new MatchAllDocsQuery(), aggBuilder, ftA, ftB);, +                // Since `search` doesn't do any reduction, and the InternalMatrixStats object will have a null `MatrixStatsResults`, +                // object.  That is created during the final reduction, which also does a final round of computations, +                // So we have to create a MatrixStatsResults object here manually so that the final `compute()` is called, +            }, +        }, +    }, +, +    public void testTwoFieldsReduce() throws Exception {, +        String fieldA = "a";, +        MappedFieldType ftA = new NumberFieldMapper.NumberFieldType(NumberFieldMapper.NumberType.DOUBLE);, +        ftA.setName(fieldA);, +        String fieldB = "b";, +        MappedFieldType ftB = new NumberFieldMapper.NumberFieldType(NumberFieldMapper.NumberType.DOUBLE);, +        ftB.setName(fieldB);, +, +        try (Directory directory = newDirectory();, +             RandomIndexWriter indexWriter = new RandomIndexWriter(random(), directory)) {, +, +            int numDocs = scaledRandomIntBetween(8192, 16384);, +            Double[] fieldAValues = new Double[numDocs];, +            Double[] fieldBValues = new Double[numDocs];, +            for (int docId = 0; docId < numDocs; docId++) {, +                Document document = new Document();, +                fieldAValues[docId] = randomDouble();, +                document.add(new SortedNumericDocValuesField(fieldA, NumericUtils.doubleToSortableLong(fieldAValues[docId])));, +, +                fieldBValues[docId] = randomDouble();, +                document.add(new SortedNumericDocValuesField(fieldB, NumericUtils.doubleToSortableLong(fieldBValues[docId])));, +                indexWriter.addDocument(document);, +            }, +, +            MultiPassStats multiPassStats = new MultiPassStats(fieldA, fieldB);, +            multiPassStats.computeStats(Arrays.asList(fieldAValues), Arrays.asList(fieldBValues));, +            try (IndexReader reader = indexWriter.getReader()) {, +                IndexSearcher searcher = new IndexSearcher(reader);, +                MatrixStatsAggregationBuilder aggBuilder = new MatrixStatsAggregationBuilder("my_agg"), +                    .fields(Arrays.asList(fieldA, fieldB));, +                InternalMatrixStats stats = searchAndReduce(searcher, new MatchAllDocsQuery(), aggBuilder, ftA, ftB);, +                // Unlike testTwoFields, `searchAndReduce` will execute reductions so the `MatrixStatsResults` object, +                // will be populated and fully computed.  We should use that value directly to test against, +                multiPassStats.assertNearlyEqual(stats);, +++ b/modules/aggs-matrix-stats/src/main/java/org/elasticsearch/search/aggregations/matrix/stats/InternalMatrixStats.java, +        for (InternalAggregation agg : aggs) {, +            runningStats.merge(((InternalMatrixStats) agg).stats);, +        if (reduceContext.isFinalReduce()) {, +            MatrixStatsResults results = new MatrixStatsResults(runningStats);, +        return new InternalMatrixStats(name, runningStats.docCount, runningStats, null, pipelineAggregators(), getMetaData());, +    }, +++ b/modules/aggs-matrix-stats/src/test/java/org/elasticsearch/search/aggregations/matrix/stats/MatrixStatsAggregatorTests.java, +                InternalMatrixStats stats = search(searcher, new MatchAllDocsQuery(), aggBuilder, ftA, ftB);, +                // Since `search` doesn't do any reduction, and the InternalMatrixStats object will have a null `MatrixStatsResults`, +                // object.  That is created during the final reduction, which also does a final round of computations, +                // So we have to create a MatrixStatsResults object here manually so that the final `compute()` is called, +            }, +        }, +    }, +, +    public void testTwoFieldsReduce() throws Exception {, +        String fieldA = "a";, +        MappedFieldType ftA = new NumberFieldMapper.NumberFieldType(NumberFieldMapper.NumberType.DOUBLE);, +        ftA.setName(fieldA);, +        String fieldB = "b";, +        MappedFieldType ftB = new NumberFieldMapper.NumberFieldType(NumberFieldMapper.NumberType.DOUBLE);, +        ftB.setName(fieldB);, +, +        try (Directory directory = newDirectory();, +             RandomIndexWriter indexWriter = new RandomIndexWriter(random(), directory)) {, +, +            int numDocs = scaledRandomIntBetween(8192, 16384);, +            Double[] fieldAValues = new Double[numDocs];, +            Double[] fieldBValues = new Double[numDocs];, +            for (int docId = 0; docId < numDocs; docId++) {, +                Document document = new Document();, +                fieldAValues[docId] = randomDouble();, +                document.add(new SortedNumericDocValuesField(fieldA, NumericUtils.doubleToSortableLong(fieldAValues[docId])));, +, +                fieldBValues[docId] = randomDouble();, +                document.add(new SortedNumericDocValuesField(fieldB, NumericUtils.doubleToSortableLong(fieldBValues[docId])));, +                indexWriter.addDocument(document);, +            }, +, +            MultiPassStats multiPassStats = new MultiPassStats(fieldA, fieldB);, +            multiPassStats.computeStats(Arrays.asList(fieldAValues), Arrays.asList(fieldBValues));, +            try (IndexReader reader = indexWriter.getReader()) {]