[+++ b/server/src/main/java/org/elasticsearch/cluster/NodeConnectionsService.java, +import org.apache.logging.log4j.Level;, +import org.elasticsearch.ElasticsearchException;, +import org.elasticsearch.action.ActionListener;, +import org.elasticsearch.action.support.GroupedActionListener;, +import org.elasticsearch.action.support.PlainListenableActionFuture;, +import org.elasticsearch.cluster.service.ClusterApplier;, +import org.elasticsearch.common.Nullable;, +import java.util.ArrayList;, +import java.util.Collection;, +import java.util.HashMap;, +import java.util.List;, +import java.util.Map;, +import java.util.concurrent.atomic.AtomicInteger;, + * This component is responsible for maintaining connections from this node to all the nodes listed in the cluster state, and for, + * disconnecting from nodes once they are removed from the cluster state. It periodically checks that all connections are still open and, + * restores them if needed. Note that this component is *not* responsible for removing nodes from the cluster state if they disconnect or, + * are unresponsive: this is the job of the master's fault detection components, particularly {@link FollowersChecker}., + * <p>, + * The {@link NodeConnectionsService#connectToNodes(DiscoveryNodes, Runnable)} and {@link, + * NodeConnectionsService#disconnectFromNodesExcept(DiscoveryNodes)} methods are called on the {@link ClusterApplier} thread. This component, + * allows the {@code ClusterApplier} to block on forming connections to _new_ nodes, because the rest of the system treats a missing, + * connection with another node in the cluster state as an exceptional condition and we don't want this to happen to new nodes. However we, + * need not block on re-establishing existing connections because if a connection is down then we are already in an exceptional situation, + * and it doesn't matter much if we stay in this situation a little longer., + * <p>, + * This component does not block on disconnections at all, because a disconnection might need to wait for an ongoing (background) connection, + * attempt to complete first., +, +    // Protects changes to targetsByNode and its values (i.e. ConnectionTarget#activityType and ConnectionTarget#listener)., +    // Crucially there are no blocking calls under this mutex: it is not held while connecting or disconnecting., +    private final Object mutex = new Object();, +    // contains an entry for every node in the latest cluster state, as well as for nodes from which we are in the process of, +    // disconnecting, +    private final Map<DiscoveryNode, ConnectionTarget> targetsByNode = new HashMap<>();, +    private volatile ConnectionChecker connectionChecker;, +    /**, +     * Connect to all the given nodes, but do not disconnect from any extra nodes. Calls the completion handler on completion of all, +     * connection attempts to _new_ nodes, but not on attempts to re-establish connections to nodes that are already known., +     */, +    public void connectToNodes(DiscoveryNodes discoveryNodes, Runnable onCompletion) {, +, +        if (discoveryNodes.getSize() == 0) {, +            onCompletion.run();, +            return;, +, +        final GroupedActionListener<Void> listener, +            = new GroupedActionListener<>(ActionListener.wrap(onCompletion), discoveryNodes.getSize());, +, +        final List<Runnable> runnables = new ArrayList<>(discoveryNodes.getSize());, +        synchronized (mutex) {, +            for (final DiscoveryNode discoveryNode : discoveryNodes) {, +                ConnectionTarget connectionTarget = targetsByNode.get(discoveryNode);, +                final boolean isNewNode;, +                if (connectionTarget == null) {, +                    // new node, set up target and listener, +                    connectionTarget = new ConnectionTarget(discoveryNode);, +                    targetsByNode.put(discoveryNode, connectionTarget);, +                    isNewNode = true;, +                    // existing node, but maybe we're disconnecting from it, in which case it was recently removed from the cluster, +                    // state and has now been re-added so we should wait for the re-connection, +                    isNewNode = connectionTarget.isPendingDisconnection();, +                if (isNewNode) {, +                    runnables.add(connectionTarget.connect(listener));, +                } else {, +                    // known node, try and ensure it's connected but do not wait, +                    runnables.add(connectionTarget.connect(null));, +                    runnables.add(() -> listener.onResponse(null));, +        runnables.forEach(Runnable::run);, +     * Disconnect from any nodes to which we are currently connected which do not appear in the given nodes. Does not wait for the, +     * disconnections to complete, because they might have to wait for ongoing connection attempts first., +    public void disconnectFromNodesExcept(DiscoveryNodes discoveryNodes) {, +        final List<Runnable> runnables = new ArrayList<>();, +        synchronized (mutex) {, +            final Set<DiscoveryNode> nodesToDisconnect = new HashSet<>(targetsByNode.keySet());, +            for (final DiscoveryNode discoveryNode : discoveryNodes) {, +                nodesToDisconnect.remove(discoveryNode);, +            for (final DiscoveryNode discoveryNode : nodesToDisconnect) {, +                runnables.add(targetsByNode.get(discoveryNode).disconnect());, +            }, +        }, +        runnables.forEach(Runnable::run);, +    }, +, +    /**, +     * Makes a single attempt to reconnect to any nodes which are disconnected but should be connected. Does not attempt to reconnect any, +     * nodes which are in the process of disconnecting. The onCompletion handler is called after all ongoing connection/disconnection, +     * attempts have completed., +     */, +    void ensureConnections(Runnable onCompletion) {, +        final List<Runnable> runnables = new ArrayList<>();, +        synchronized (mutex) {, +            final Collection<ConnectionTarget> connectionTargets = targetsByNode.values();, +            if (connectionTargets.isEmpty()) {, +                runnables.add(onCompletion);, +                logger.trace("ensuring connections to {}", targetsByNode);, +                final GroupedActionListener<Void> listener = new GroupedActionListener<>(, +                    ActionListener.wrap(onCompletion), connectionTargets.size());, +                for (final ConnectionTarget connectionTarget : connectionTargets) {, +                    runnables.add(connectionTarget.ensureConnected(listener));]