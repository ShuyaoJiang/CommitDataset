[+++ b/src/main/java/org/elasticsearch/index/fielddata/IndexFieldDataService.java, +                .put("short", new ShortArrayIndexFieldData.Builder()), +                .put(Tuple.tuple("short", "array"), new ShortArrayIndexFieldData.Builder()), +++ b/src/main/java/org/elasticsearch/index/fielddata/IndexFieldDataService.java, +                .put("short", new ShortArrayIndexFieldData.Builder()), +                .put(Tuple.tuple("short", "array"), new ShortArrayIndexFieldData.Builder()), +++ b/src/main/java/org/elasticsearch/index/fielddata/StringValues.java, +import org.elasticsearch.index.fielddata.util.*;, +    public static class ShortBased implements StringValues {, +, +        private final ShortValues values;, +, +        private final StringArrayRef arrayScratch = new StringArrayRef(new String[1], 1);, +        private final ValuesIter valuesIter = new ValuesIter();, +        private final Proc proc = new Proc();, +, +        public ShortBased(ShortValues values) {, +            this.values = values;, +        }, +, +        @Override, +        public boolean isMultiValued() {, +            return values.isMultiValued();, +        }, +, +        @Override, +        public boolean hasValue(int docId) {, +            return values.hasValue(docId);, +        }, +, +        @Override, +        public String getValue(int docId) {, +            if (!values.hasValue(docId)) {, +                return null;, +            }, +            return Short.toString(values.getValue(docId));, +        }, +, +        @Override, +        public StringArrayRef getValues(int docId) {, +            ShortArrayRef arrayRef = values.getValues(docId);, +            int size = arrayRef.size();, +            if (size == 0) return StringArrayRef.EMPTY;, +, +            arrayScratch.reset(size);, +            for (int i = arrayRef.start; i < arrayRef.end; i++) {, +                arrayScratch.values[arrayScratch.end++] = Short.toString(arrayRef.values[i]);, +            }, +            return arrayScratch;, +        }, +, +        @Override, +        public Iter getIter(int docId) {, +            return valuesIter.reset(values.getIter(docId));, +        }, +, +        @Override, +        public void forEachValueInDoc(int docId, ValueInDocProc proc) {, +            values.forEachValueInDoc(docId, this.proc.reset(proc));, +        }, +, +        static class ValuesIter implements Iter {, +, +            private ShortValues.Iter iter;, +, +            private ValuesIter reset(ShortValues.Iter iter) {, +                this.iter = iter;, +                return this;, +            }, +, +            @Override, +            public boolean hasNext() {, +                return iter.hasNext();, +            }, +, +            @Override, +            public String next() {, +                return Short.toString(iter.next());, +            }, +        }, +, +        static class Proc implements ShortValues.ValueInDocProc {, +, +            private ValueInDocProc proc;, +, +            private Proc reset(ValueInDocProc proc) {, +                this.proc = proc;, +                return this;, +            }, +, +            @Override, +            public void onValue(int docId, short value) {, +                proc.onValue(docId, Short.toString(value));, +            }, +, +            @Override, +            public void onMissing(int docId) {, +                proc.onMissing(docId);, +            }, +        }]