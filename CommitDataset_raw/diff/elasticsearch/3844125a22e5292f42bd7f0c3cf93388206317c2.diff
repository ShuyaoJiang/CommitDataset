[+++ b/x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/Security.java, +        securityIndex.set(SecurityIndexManager.buildSecurityIndexManager(client, clusterService));, +++ b/x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/Security.java, +        securityIndex.set(SecurityIndexManager.buildSecurityIndexManager(client, clusterService));, +++ b/x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/support/SecurityIndexManager.java, +import java.util.function.Supplier;, + * Manages the lifecycle of a single index, mapping and and data upgrades/migrations., +    private static final Logger logger = LogManager.getLogger(SecurityIndexManager.class);, +    private final String aliasName;, +    private final String internalIndexName;, +    private final int internalIndexFormat;, +    private final Supplier<byte[]> mappingSourceSupplier;, +    public static SecurityIndexManager buildSecurityIndexManager(Client client, ClusterService clusterService) {, +        return new SecurityIndexManager(client, SECURITY_INDEX_NAME, INTERNAL_SECURITY_INDEX, INTERNAL_INDEX_FORMAT,, +                SecurityIndexManager::readSecurityTemplateAsBytes, clusterService);, +    }, +, +    private SecurityIndexManager(Client client, String aliasName, String internalIndexName, int internalIndexFormat,, +            Supplier<byte[]> mappingSourceSupplier, ClusterService clusterService) {, +        this(client, aliasName, internalIndexName, internalIndexFormat, mappingSourceSupplier, State.UNRECOVERED_STATE);, +    private SecurityIndexManager(Client client, String aliasName, String internalIndexName, int internalIndexFormat,, +            Supplier<byte[]> mappingSourceSupplier, State indexState) {, +        this.aliasName = aliasName;, +        this.internalIndexName = internalIndexName;, +        this.internalIndexFormat = internalIndexFormat;, +        this.mappingSourceSupplier = mappingSourceSupplier;, +        this.client = client;, +        return new SecurityIndexManager(null, aliasName, internalIndexName, internalIndexFormat, mappingSourceSupplier, indexState);, +            return new UnavailableShardsException(null,, +                    "at least one primary shard for the index [" + localState.concreteIndexName + "] is unavailable");, +            return new IndexNotFoundException(localState.concreteIndexName);, +            logger.debug("security index manager waiting until state has been recovered");, +        final IndexMetaData indexMetaData = resolveConcreteIndex(aliasName, event.state().metaData());, +            INDEX_FORMAT_SETTING.get(indexMetaData.getSettings()).intValue() == internalIndexFormat;, +        final String concreteIndexName = indexMetaData == null ? internalIndexName : indexMetaData.getIndex().getName();, +        logger.debug("Index [{}] is not yet active", aliasName);, +        IndexMetaData metaData = resolveConcreteIndex(aliasName, clusterState.metaData());, +    public static boolean checkTemplateExistsAndVersionMatches(String templateName, ClusterState state, Logger logger,, +                                                               Predicate<Version> predicate) {, +        return TemplateUtils.checkTemplateExistsAndVersionMatches(templateName, SECURITY_VERSION_STRING, state, logger, predicate);, +    private boolean checkIndexMappingVersionMatches(ClusterState clusterState, Predicate<Version> predicate) {, +        return checkIndexMappingVersionMatches(aliasName, clusterState, logger, predicate);, +    public static boolean checkIndexMappingVersionMatches(String indexName, ClusterState clusterState, Logger logger,, +        return loadIndexMappingVersions(indexName, clusterState, logger).stream().allMatch(predicate);, +        final Set<Version> versions = loadIndexMappingVersions(aliasName, clusterState, logger);, +    private static Set<Version> loadIndexMappingVersions(String aliasName, ClusterState clusterState, Logger logger) {, +        IndexMetaData indexMetaData = resolveConcreteIndex(aliasName, clusterState.metaData());, +                versions.add(readMappingVersion(aliasName, mappingMetaData, logger));, +    private static Version readMappingVersion(String indexName, MappingMetaData mappingMetaData, Logger logger) {, +     * Validates that the index is up to date and does not need to be migrated. If it is not, the, +     * consumer is called with an exception. If the index is up to date, the runnable will, +                    "Index [" + indexState.concreteIndexName + "] is not on the current version. Security features relying on the index", +                            + " will not be available until the upgrade API is run on the index"));, +            consumer.accept(new ElasticsearchStatusException(, +                    "Cluster state has not been recovered yet, cannot write to the [" + indexState.concreteIndexName + "] index",, +                    "Index [" + indexState.concreteIndexName + "] is not on the current version.", +                            + "Security features relying on the index will not be available until the upgrade API is run on the index"));, +            assert indexState.concreteIndexName != null;, +            logger.info("security index does not exist. Creating [{}] with alias [{}]", indexState.concreteIndexName, this.aliasName);, +            final byte[] mappingSource = mappingSourceSupplier.get();, +            final Tuple<String, Settings> mappingAndSettings = parseMappingAndSettingsFromTemplateBytes(mappingSource);, +            CreateIndexRequest request = new CreateIndexRequest(indexState.concreteIndexName), +                    .alias(new Alias(this.aliasName)), +            logger.info("Index [{}] (alias [{}]) is not up to date. Updating mapping", indexState.concreteIndexName, this.aliasName);, +            final byte[] mappingSource = mappingSourceSupplier.get();, +            final Tuple<String, Settings> mappingAndSettings = parseMappingAndSettingsFromTemplateBytes(mappingSource);, +                    .source(mappingAndSettings.v1(), XContentType.JSON), +    private static byte[] readSecurityTemplateAsBytes() {, +        return TemplateUtils.loadTemplate("/" + SECURITY_TEMPLATE_NAME + ".json", Version.CURRENT.toString(),, +                SecurityIndexManager.TEMPLATE_VERSION_PATTERN).getBytes(StandardCharsets.UTF_8);, +    }, +, +    private static Tuple<String, Settings> parseMappingAndSettingsFromTemplateBytes(byte[] template) {, +        final PutIndexTemplateRequest request = new PutIndexTemplateRequest("name_is_not_important").source(template, XContentType.JSON);, +        final String mappingSource = request.mappings().get(MapperService.SINGLE_MAPPING_NAME);, +        try (XContentParser parser = XContentType.JSON.xContent().createParser(NamedXContentRegistry.EMPTY,, +                DeprecationHandler.THROW_UNSUPPORTED_OPERATION, mappingSource)) {, +            // remove the type wrapping to get the mapping, +            ensureExpectedToken(XContentParser.Token.START_OBJECT, parser.nextToken(), parser::getTokenLocation); // {, +            ensureFieldName(parser, parser.nextToken(), MapperService.SINGLE_MAPPING_NAME); // _doc, +            ensureExpectedToken(XContentParser.Token.START_OBJECT, parser.nextToken(), parser::getTokenLocation); // {, +, +            XContentBuilder builder = JsonXContent.contentBuilder();, +            builder.generator().copyCurrentStructure(parser);, +            return new Tuple<>(Strings.toString(builder), request.settings());, +        } catch (IOException e) {, +            throw ExceptionsHelper.convertToRuntime(e);, +        }, +    }, +, +++ b/x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/Security.java, +        securityIndex.set(SecurityIndexManager.buildSecurityIndexManager(client, clusterService));, +++ b/x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/support/SecurityIndexManager.java, +import java.util.function.Supplier;, + * Manages the lifecycle of a single index, mapping and and data upgrades/migrations., +    private static final Logger logger = LogManager.getLogger(SecurityIndexManager.class);, +    private final String aliasName;, +    private final String internalIndexName;, +    private final int internalIndexFormat;, +    private final Supplier<byte[]> mappingSourceSupplier;]