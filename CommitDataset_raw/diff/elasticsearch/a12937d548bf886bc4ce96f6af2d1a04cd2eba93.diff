[+++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/MethodWriter.java, +    /** Writes a dynamic binary instruction: returnType, lhs, and rhs can be different */, +    public void writeDynamicBinaryInstruction(Location location, Type returnType, Type lhs, Type rhs, Operation operation) {, +        org.objectweb.asm.Type descriptor = org.objectweb.asm.Type.getMethodType(returnType.type, lhs.type, rhs.type);, +    }, +    , +    /** Writes a static binary instruction */, +    public void writeBinaryInstruction(Location location, Type type, Operation operation) {, +        final Sort sort = type.sort;, +, +        if ((sort == Sort.FLOAT || sort == Sort.DOUBLE) &&, +                (operation == Operation.LSH || operation == Operation.USH ||, +                operation == Operation.RSH || operation == Operation.BWAND ||, +                operation == Operation.XOR || operation == Operation.BWOR)) {, +            throw location.createError(new IllegalStateException("Illegal tree structure."));, +        }, +, +++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/MethodWriter.java, +    /** Writes a dynamic binary instruction: returnType, lhs, and rhs can be different */, +    public void writeDynamicBinaryInstruction(Location location, Type returnType, Type lhs, Type rhs, Operation operation) {, +        org.objectweb.asm.Type descriptor = org.objectweb.asm.Type.getMethodType(returnType.type, lhs.type, rhs.type);, +    }, +    , +    /** Writes a static binary instruction */, +    public void writeBinaryInstruction(Location location, Type type, Operation operation) {, +        final Sort sort = type.sort;, +, +        if ((sort == Sort.FLOAT || sort == Sort.DOUBLE) &&, +                (operation == Operation.LSH || operation == Operation.USH ||, +                operation == Operation.RSH || operation == Operation.BWAND ||, +                operation == Operation.XOR || operation == Operation.BWOR)) {, +            throw location.createError(new IllegalStateException("Illegal tree structure."));, +        }, +, +++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/EBinary.java, +    Type promote;       // promoted type, +    Type shiftDistance; // for shifts, the RHS is promoted independently, +        promote = AnalyzerCaster.promoteNumeric(left.actual, right.actual, true);, +        actual = promote;, +, +        if (promote.sort == Sort.DEF) {, +            left.expected = left.actual;, +            right.expected = right.actual;, +            if (expected != null) {, +                actual = expected;, +            }, +        } else {, +        }, +        promote = AnalyzerCaster.promoteNumeric(left.actual, right.actual, true);, +        actual = promote;, +        if (promote.sort == Sort.DEF) {, +            left.expected = left.actual;, +            right.expected = right.actual;, +            if (expected != null) {, +                actual = expected;, +            }, +        } else {, +        }, +        promote = AnalyzerCaster.promoteNumeric(left.actual, right.actual, true);, +        actual = promote;, +, +        if (promote.sort == Sort.DEF) {, +            left.expected = left.actual;, +            right.expected = right.actual;, +            if (expected != null) {, +                actual = expected;, +            }, +        } else {, +        }, +        promote = AnalyzerCaster.promoteAdd(left.actual, right.actual);, +        actual = promote;, +, +        } else if (sort == Sort.DEF) {, +            left.expected = left.actual;, +            right.expected = right.actual;, +            if (expected != null) {, +                actual = expected;, +            }, +        promote = AnalyzerCaster.promoteNumeric(left.actual, right.actual, true);, +        actual = promote;, +, +        if (promote.sort == Sort.DEF) {, +            left.expected = left.actual;, +            right.expected = right.actual;, +            if (expected != null) {, +                actual = expected;, +            }, +        } else {, +        }, +        actual = promote = lhspromote;, +        shiftDistance = rhspromote;, +, +        if (lhspromote.sort == Sort.DEF || rhspromote.sort == Sort.DEF) {, +            left.expected = left.actual;, +            right.expected = right.actual;, +            if (expected != null) {, +                actual = expected;, +            }, +        } else {, +        }]