[+++ b/core/src/main/java/org/elasticsearch/index/engine/Engine.java, +import java.util.concurrent.atomic.AtomicLong;, +    protected volatile  long lastWriteNanos;, +        /**, +         * Called when a fatal exception occurred, +         */, +, +    /**, +     * Returns the timestamp of the last write in nanoseconds., +     * Note: this time might not be absolutely accurate since the {@link Operation#startTime()} is used which might be, +     * slightly inaccurate., +     * @see System#nanoTime(), +     * @see Operation#startTime(), +     */, +    public long getLastWriteNanos() {, +        return this.lastWriteNanos;, +    }, +++ b/core/src/main/java/org/elasticsearch/index/engine/Engine.java, +import java.util.concurrent.atomic.AtomicLong;, +    protected volatile  long lastWriteNanos;, +        /**, +         * Called when a fatal exception occurred, +         */, +, +    /**, +     * Returns the timestamp of the last write in nanoseconds., +     * Note: this time might not be absolutely accurate since the {@link Operation#startTime()} is used which might be, +     * slightly inaccurate., +     * @see System#nanoTime(), +     * @see Operation#startTime(), +     */, +    public long getLastWriteNanos() {, +        return this.lastWriteNanos;, +    }, +++ b/core/src/main/java/org/elasticsearch/index/engine/EngineConfig.java, +    private final TimeValue flushMergesAfter = TimeValue.timeValueMinutes(5);, +                        TranslogRecoveryPerformer translogRecoveryPerformer, QueryCache queryCache, QueryCachingPolicy queryCachingPolicy, TranslogConfig translogConfig, TimeValue flushMergesAfter) {, +, +    /**, +     * Returns a {@link TimeValue} at what time interval after the last write modification to the engine finished merges, +     * should be automatically flushed. This is used to free up transient disk usage of potentially large segments that, +     * are written after the engine became inactive from an indexing perspective., +     */, +    public TimeValue getFlushMergesAfter() { return flushMergesAfter; }, +, +++ b/core/src/main/java/org/elasticsearch/index/engine/Engine.java, +import java.util.concurrent.atomic.AtomicLong;, +    protected volatile  long lastWriteNanos;, +        /**, +         * Called when a fatal exception occurred, +         */, +, +    /**, +     * Returns the timestamp of the last write in nanoseconds., +     * Note: this time might not be absolutely accurate since the {@link Operation#startTime()} is used which might be, +     * slightly inaccurate., +     * @see System#nanoTime(), +     * @see Operation#startTime(), +     */, +    public long getLastWriteNanos() {, +        return this.lastWriteNanos;, +    }, +++ b/core/src/main/java/org/elasticsearch/index/engine/EngineConfig.java, +    private final TimeValue flushMergesAfter = TimeValue.timeValueMinutes(5);, +                        TranslogRecoveryPerformer translogRecoveryPerformer, QueryCache queryCache, QueryCachingPolicy queryCachingPolicy, TranslogConfig translogConfig, TimeValue flushMergesAfter) {, +, +    /**, +     * Returns a {@link TimeValue} at what time interval after the last write modification to the engine finished merges, +     * should be automatically flushed. This is used to free up transient disk usage of potentially large segments that, +     * are written after the engine became inactive from an indexing perspective., +     */, +    public TimeValue getFlushMergesAfter() { return flushMergesAfter; }, +, +++ b/core/src/main/java/org/elasticsearch/index/engine/InternalEngine.java, +            lastWriteNanos  = index.startTime();, +            lastWriteNanos = delete.startTime();, +    final boolean tryRenewSyncCommit() {, +        boolean renewed = false;, +        try (ReleasableLock lock = writeLock.acquire()) {, +            ensureOpen();, +            String syncId = lastCommittedSegmentInfos.getUserData().get(SYNC_COMMIT_ID);, +            if (syncId != null && translog.totalOperations() == 0 && indexWriter.hasUncommittedChanges()) {, +                logger.trace("start renewing sync commit [{}]", syncId);, +                commitIndexWriter(indexWriter, translog, syncId);, +                logger.debug("successfully sync committed. sync id [{}].", syncId);, +                lastCommittedSegmentInfos = store.readLastCommittedSegmentsInfo();, +                renewed = true;, +            }, +        } catch (IOException ex) {, +            maybeFailEngine("renew sync commit", ex);, +            throw new EngineException(shardId, "failed to renew sync commit", ex);, +        }, +        if (renewed) { // refresh outside of the write lock, +            refresh("renew sync commit");, +        }, +, +        return renewed;, +    }, +, +            if (indexWriter.hasPendingMerges() == false && System.nanoTime() - lastWriteNanos >= engineConfig.getFlushMergesAfter().nanos()) {]