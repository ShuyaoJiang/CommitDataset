[+++ b/x-pack/plugin/ccr/src/main/java/org/elasticsearch/xpack/ccr/action/ShardFollowNodeTask.java, +import org.elasticsearch.common.collect.Tuple;, +import java.util.stream.Collectors;, +    private final LinkedHashMap<Long, Tuple<AtomicInteger, ElasticsearchException>> fetchExceptions;, +        this.fetchExceptions = new LinkedHashMap<Long, Tuple<AtomicInteger, ElasticsearchException>>() {, +            protected boolean removeEldestEntry(final Map.Entry<Long, Tuple<AtomicInteger, ElasticsearchException>> eldest) {, +                        fetchExceptions.put(from, Tuple.tuple(retryCounter, new ElasticsearchException(e)));, +                new TreeMap<>(, +                        fetchExceptions, +                                .entrySet(), +                                .stream(), +                                .collect(, +                                        Collectors.toMap(Map.Entry::getKey, e -> Tuple.tuple(e.getValue().v1().get(), e.getValue().v2())))),, +++ b/x-pack/plugin/ccr/src/main/java/org/elasticsearch/xpack/ccr/action/ShardFollowNodeTask.java, +import org.elasticsearch.common.collect.Tuple;, +import java.util.stream.Collectors;, +    private final LinkedHashMap<Long, Tuple<AtomicInteger, ElasticsearchException>> fetchExceptions;, +        this.fetchExceptions = new LinkedHashMap<Long, Tuple<AtomicInteger, ElasticsearchException>>() {, +            protected boolean removeEldestEntry(final Map.Entry<Long, Tuple<AtomicInteger, ElasticsearchException>> eldest) {, +                        fetchExceptions.put(from, Tuple.tuple(retryCounter, new ElasticsearchException(e)));, +                new TreeMap<>(, +                        fetchExceptions, +                                .entrySet(), +                                .stream(), +                                .collect(, +                                        Collectors.toMap(Map.Entry::getKey, e -> Tuple.tuple(e.getValue().v1().get(), e.getValue().v2())))),, +++ b/x-pack/plugin/ccr/src/test/java/org/elasticsearch/xpack/ccr/action/ShardFollowNodeTaskStatusTests.java, +import org.elasticsearch.common.collect.Tuple;, +        for (final Map.Entry<Long, Tuple<Integer, ElasticsearchException>> entry : newInstance.fetchExceptions().entrySet()) {, +            final Tuple<Integer, ElasticsearchException> expectedTuple = expectedInstance.fetchExceptions().get(entry.getKey());, +            assertThat(entry.getValue().v1(), equalTo(expectedTuple.v1()));, +            final ElasticsearchException expected = expectedTuple.v2();, +            assertThat(entry.getValue().v2().getMessage(), containsString(expected.getMessage()));, +            assertNotNull(entry.getValue().v2().getCause());, +                    entry.getValue().v2().getCause(),, +            assertThat(entry.getValue().v2().getCause().getMessage(), containsString(expected.getCause().getMessage()));, +    private NavigableMap<Long, Tuple<Integer, ElasticsearchException>> randomReadExceptions() {, +        final NavigableMap<Long, Tuple<Integer, ElasticsearchException>> readExceptions = new TreeMap<>();, +            readExceptions.put(, +                    randomNonNegativeLong(),, +                    Tuple.tuple(, +                            randomIntBetween(0, Integer.MAX_VALUE),, +                            new ElasticsearchException(new IllegalStateException("index [" + i + "]"))));, +++ b/x-pack/plugin/ccr/src/main/java/org/elasticsearch/xpack/ccr/action/ShardFollowNodeTask.java, +import org.elasticsearch.common.collect.Tuple;, +import java.util.stream.Collectors;, +    private final LinkedHashMap<Long, Tuple<AtomicInteger, ElasticsearchException>> fetchExceptions;, +        this.fetchExceptions = new LinkedHashMap<Long, Tuple<AtomicInteger, ElasticsearchException>>() {, +            protected boolean removeEldestEntry(final Map.Entry<Long, Tuple<AtomicInteger, ElasticsearchException>> eldest) {, +                        fetchExceptions.put(from, Tuple.tuple(retryCounter, new ElasticsearchException(e)));, +                new TreeMap<>(, +                        fetchExceptions, +                                .entrySet(), +                                .stream(), +                                .collect(, +                                        Collectors.toMap(Map.Entry::getKey, e -> Tuple.tuple(e.getValue().v1().get(), e.getValue().v2())))),, +++ b/x-pack/plugin/ccr/src/test/java/org/elasticsearch/xpack/ccr/action/ShardFollowNodeTaskStatusTests.java, +import org.elasticsearch.common.collect.Tuple;, +        for (final Map.Entry<Long, Tuple<Integer, ElasticsearchException>> entry : newInstance.fetchExceptions().entrySet()) {, +            final Tuple<Integer, ElasticsearchException> expectedTuple = expectedInstance.fetchExceptions().get(entry.getKey());, +            assertThat(entry.getValue().v1(), equalTo(expectedTuple.v1()));, +            final ElasticsearchException expected = expectedTuple.v2();, +            assertThat(entry.getValue().v2().getMessage(), containsString(expected.getMessage()));, +            assertNotNull(entry.getValue().v2().getCause());, +                    entry.getValue().v2().getCause(),, +            assertThat(entry.getValue().v2().getCause().getMessage(), containsString(expected.getCause().getMessage()));, +    private NavigableMap<Long, Tuple<Integer, ElasticsearchException>> randomReadExceptions() {, +        final NavigableMap<Long, Tuple<Integer, ElasticsearchException>> readExceptions = new TreeMap<>();, +            readExceptions.put(, +                    randomNonNegativeLong(),, +                    Tuple.tuple(, +                            randomIntBetween(0, Integer.MAX_VALUE),, +                            new ElasticsearchException(new IllegalStateException("index [" + i + "]"))));, +++ b/x-pack/plugin/ccr/src/test/java/org/elasticsearch/xpack/ccr/action/ShardFollowNodeTaskTests.java, +import org.elasticsearch.common.collect.Tuple;, +                final Map.Entry<Long, Tuple<Integer, ElasticsearchException>> entry = status.fetchExceptions().entrySet().iterator().next();, +                assertThat(entry.getValue().v1(), equalTo(Math.toIntExact(retryCounter.get())));, +                assertThat(entry.getValue().v2(), instanceOf(ElasticsearchException.class));, +                assertNotNull(entry.getValue().v2().getCause());, +                assertThat(entry.getValue().v2().getCause(), instanceOf(ShardNotFoundException.class));, +                final ShardNotFoundException cause = (ShardNotFoundException) entry.getValue().v2().getCause();, +        final Map.Entry<Long, Tuple<Integer, ElasticsearchException>> entry = status.fetchExceptions().entrySet().iterator().next();, +        assertThat(entry.getValue().v2(), instanceOf(ElasticsearchException.class));, +        assertNotNull(entry.getValue().v2().getCause());, +        assertThat(entry.getValue().v2().getCause(), instanceOf(RuntimeException.class));, +        final RuntimeException cause = (RuntimeException) entry.getValue().v2().getCause();, +++ b/x-pack/plugin/ccr/src/main/java/org/elasticsearch/xpack/ccr/action/ShardFollowNodeTask.java, +import org.elasticsearch.common.collect.Tuple;, +import java.util.stream.Collectors;, +    private final LinkedHashMap<Long, Tuple<AtomicInteger, ElasticsearchException>> fetchExceptions;, +        this.fetchExceptions = new LinkedHashMap<Long, Tuple<AtomicInteger, ElasticsearchException>>() {, +            protected boolean removeEldestEntry(final Map.Entry<Long, Tuple<AtomicInteger, ElasticsearchException>> eldest) {, +                        fetchExceptions.put(from, Tuple.tuple(retryCounter, new ElasticsearchException(e)));, +                new TreeMap<>(, +                        fetchExceptions, +                                .entrySet(), +                                .stream(), +                                .collect(, +                                        Collectors.toMap(Map.Entry::getKey, e -> Tuple.tuple(e.getValue().v1().get(), e.getValue().v2())))),, +++ b/x-pack/plugin/ccr/src/test/java/org/elasticsearch/xpack/ccr/action/ShardFollowNodeTaskStatusTests.java]