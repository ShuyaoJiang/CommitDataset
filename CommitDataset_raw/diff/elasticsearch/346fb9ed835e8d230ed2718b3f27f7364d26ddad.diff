[+++ b/src/main/java/org/elasticsearch/indices/cluster/IndicesClusterStateService.java, +import org.elasticsearch.indices.recovery.RecoveryStatus;, +                // if the current and global routing are initializing, but are still not the same, its a different "shard" being allocated, +                // for example: a shard that recovers from one node and now needs to recover to another node,, +                //              or a replica allocated and then allocating a primary because the primary failed on another node, +                if (currentRoutingEntry.initializing() && shardRouting.initializing() && !currentRoutingEntry.equals(shardRouting)) {, +                    logger.debug("[{}][{}] removing shard (different instance of it allocated on this node, current [{}], global [{}])", shardRouting.index(), shardRouting.id(), currentRoutingEntry, shardRouting);, +                    // cancel recovery just in case we are in recovery (its fine if we are not in recovery, it will be a noop)., +                    recoveryTarget.cancelRecovery(indexShard);, +                        recoveryTarget.startRecovery(request, indexShard, new PeerRecoveryListener(request, shardRouting, indexService));, +                    recoveryTarget.startRecovery(request, indexShard, new PeerRecoveryListener(request, shardRouting, indexService));, +        public void onRetryRecovery(TimeValue retryAfter, RecoveryStatus recoveryStatus) {, +            recoveryTarget.retryRecovery(request, recoveryStatus, PeerRecoveryListener.this);, +++ b/src/main/java/org/elasticsearch/indices/cluster/IndicesClusterStateService.java, +import org.elasticsearch.indices.recovery.RecoveryStatus;, +                // if the current and global routing are initializing, but are still not the same, its a different "shard" being allocated, +                // for example: a shard that recovers from one node and now needs to recover to another node,, +                //              or a replica allocated and then allocating a primary because the primary failed on another node, +                if (currentRoutingEntry.initializing() && shardRouting.initializing() && !currentRoutingEntry.equals(shardRouting)) {, +                    logger.debug("[{}][{}] removing shard (different instance of it allocated on this node, current [{}], global [{}])", shardRouting.index(), shardRouting.id(), currentRoutingEntry, shardRouting);, +                    // cancel recovery just in case we are in recovery (its fine if we are not in recovery, it will be a noop)., +                    recoveryTarget.cancelRecovery(indexShard);, +                        recoveryTarget.startRecovery(request, indexShard, new PeerRecoveryListener(request, shardRouting, indexService));, +                    recoveryTarget.startRecovery(request, indexShard, new PeerRecoveryListener(request, shardRouting, indexService));, +        public void onRetryRecovery(TimeValue retryAfter, RecoveryStatus recoveryStatus) {, +            recoveryTarget.retryRecovery(request, recoveryStatus, PeerRecoveryListener.this);, +++ b/src/main/java/org/elasticsearch/indices/recovery/RecoveryCleanFilesRequest.java, +    private long recoveryId;, +    RecoveryCleanFilesRequest(long recoveryId, ShardId shardId, Set<String> snapshotFiles) {, +        this.recoveryId = recoveryId;, +    public long recoveryId() {, +        return this.recoveryId;, +    }, +, +        recoveryId = in.readLong();, +        out.writeLong(recoveryId);, +++ b/src/main/java/org/elasticsearch/indices/cluster/IndicesClusterStateService.java, +import org.elasticsearch.indices.recovery.RecoveryStatus;, +                // if the current and global routing are initializing, but are still not the same, its a different "shard" being allocated, +                // for example: a shard that recovers from one node and now needs to recover to another node,, +                //              or a replica allocated and then allocating a primary because the primary failed on another node, +                if (currentRoutingEntry.initializing() && shardRouting.initializing() && !currentRoutingEntry.equals(shardRouting)) {, +                    logger.debug("[{}][{}] removing shard (different instance of it allocated on this node, current [{}], global [{}])", shardRouting.index(), shardRouting.id(), currentRoutingEntry, shardRouting);, +                    // cancel recovery just in case we are in recovery (its fine if we are not in recovery, it will be a noop)., +                    recoveryTarget.cancelRecovery(indexShard);, +                        recoveryTarget.startRecovery(request, indexShard, new PeerRecoveryListener(request, shardRouting, indexService));, +                    recoveryTarget.startRecovery(request, indexShard, new PeerRecoveryListener(request, shardRouting, indexService));, +        public void onRetryRecovery(TimeValue retryAfter, RecoveryStatus recoveryStatus) {, +            recoveryTarget.retryRecovery(request, recoveryStatus, PeerRecoveryListener.this);, +++ b/src/main/java/org/elasticsearch/indices/recovery/RecoveryCleanFilesRequest.java, +    private long recoveryId;, +    RecoveryCleanFilesRequest(long recoveryId, ShardId shardId, Set<String> snapshotFiles) {, +        this.recoveryId = recoveryId;, +    public long recoveryId() {, +        return this.recoveryId;, +    }, +, +        recoveryId = in.readLong();, +        out.writeLong(recoveryId);, +++ b/src/main/java/org/elasticsearch/indices/recovery/RecoveryFileChunkRequest.java, +    private long recoveryId;, +    RecoveryFileChunkRequest(long recoveryId, ShardId shardId, String name, long position, long length, String checksum, BytesArray content) {, +        this.recoveryId = recoveryId;, +    public long recoveryId() {, +        return this.recoveryId;, +    }, +, +        recoveryId = in.readLong();, +        out.writeLong(recoveryId);, +++ b/src/main/java/org/elasticsearch/indices/cluster/IndicesClusterStateService.java, +import org.elasticsearch.indices.recovery.RecoveryStatus;, +                // if the current and global routing are initializing, but are still not the same, its a different "shard" being allocated, +                // for example: a shard that recovers from one node and now needs to recover to another node,, +                //              or a replica allocated and then allocating a primary because the primary failed on another node, +                if (currentRoutingEntry.initializing() && shardRouting.initializing() && !currentRoutingEntry.equals(shardRouting)) {, +                    logger.debug("[{}][{}] removing shard (different instance of it allocated on this node, current [{}], global [{}])", shardRouting.index(), shardRouting.id(), currentRoutingEntry, shardRouting);, +                    // cancel recovery just in case we are in recovery (its fine if we are not in recovery, it will be a noop)., +                    recoveryTarget.cancelRecovery(indexShard);, +                        recoveryTarget.startRecovery(request, indexShard, new PeerRecoveryListener(request, shardRouting, indexService));, +                    recoveryTarget.startRecovery(request, indexShard, new PeerRecoveryListener(request, shardRouting, indexService));, +        public void onRetryRecovery(TimeValue retryAfter, RecoveryStatus recoveryStatus) {, +            recoveryTarget.retryRecovery(request, recoveryStatus, PeerRecoveryListener.this);, +++ b/src/main/java/org/elasticsearch/indices/recovery/RecoveryCleanFilesRequest.java, +    private long recoveryId;, +    RecoveryCleanFilesRequest(long recoveryId, ShardId shardId, Set<String> snapshotFiles) {, +        this.recoveryId = recoveryId;, +    public long recoveryId() {, +        return this.recoveryId;, +    }, +, +        recoveryId = in.readLong();, +        out.writeLong(recoveryId);, +++ b/src/main/java/org/elasticsearch/indices/recovery/RecoveryFileChunkRequest.java, +    private long recoveryId;, +    RecoveryFileChunkRequest(long recoveryId, ShardId shardId, String name, long position, long length, String checksum, BytesArray content) {, +        this.recoveryId = recoveryId;, +    public long recoveryId() {, +        return this.recoveryId;, +    }, +]