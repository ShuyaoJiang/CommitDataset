[+++ b/plugin/src/main/java/org/elasticsearch/xpack/upgrade/Upgrade.java, +        ActionListener<DeleteIndexTemplateResponse> triggeredWatchIndexTemplateListener = deleteIndexTemplateListener("triggered_watches",, +                listener, () -> listener.onResponse(true));, +, +        ActionListener<DeleteIndexTemplateResponse> watchIndexTemplateListener = deleteIndexTemplateListener("watches", listener,, +                () -> client.admin().indices().prepareDeleteTemplate("triggered_watches").execute(triggeredWatchIndexTemplateListener));, +, +                        // don't start watcher after upgrade, +                        // stop watcher, +                                        // delete old templates before indexing, +                                        client.admin().indices().prepareDeleteTemplate("watches").execute(watchIndexTemplateListener);, +    private static ActionListener<DeleteIndexTemplateResponse> deleteIndexTemplateListener(String name, ActionListener<Boolean> listener,, +                                                                                           Runnable runnable) {, +        return ActionListener.wrap(r -> {, +                runnable.run();, +                listener.onFailure(new ElasticsearchException("Deleting [{}] template was not acknowledged", name));, +++ b/plugin/src/main/java/org/elasticsearch/xpack/upgrade/Upgrade.java, +        ActionListener<DeleteIndexTemplateResponse> triggeredWatchIndexTemplateListener = deleteIndexTemplateListener("triggered_watches",, +                listener, () -> listener.onResponse(true));, +, +        ActionListener<DeleteIndexTemplateResponse> watchIndexTemplateListener = deleteIndexTemplateListener("watches", listener,, +                () -> client.admin().indices().prepareDeleteTemplate("triggered_watches").execute(triggeredWatchIndexTemplateListener));, +, +                        // don't start watcher after upgrade, +                        // stop watcher, +                                        // delete old templates before indexing, +                                        client.admin().indices().prepareDeleteTemplate("watches").execute(watchIndexTemplateListener);, +    private static ActionListener<DeleteIndexTemplateResponse> deleteIndexTemplateListener(String name, ActionListener<Boolean> listener,, +                                                                                           Runnable runnable) {, +        return ActionListener.wrap(r -> {, +                runnable.run();, +                listener.onFailure(new ElasticsearchException("Deleting [{}] template was not acknowledged", name));, +++ b/plugin/src/main/java/org/elasticsearch/xpack/watcher/WatcherIndexingListener.java, +        boolean isWatchExecutionDistributed = WatcherLifeCycleService.isWatchExecutionDistributed(event.state());, +        if (isWatchExecutionDistributed) {, +        } else {, +            configuration = INACTIVE;, +        }, +++ b/plugin/src/main/java/org/elasticsearch/xpack/upgrade/Upgrade.java, +        ActionListener<DeleteIndexTemplateResponse> triggeredWatchIndexTemplateListener = deleteIndexTemplateListener("triggered_watches",, +                listener, () -> listener.onResponse(true));, +, +        ActionListener<DeleteIndexTemplateResponse> watchIndexTemplateListener = deleteIndexTemplateListener("watches", listener,, +                () -> client.admin().indices().prepareDeleteTemplate("triggered_watches").execute(triggeredWatchIndexTemplateListener));, +, +                        // don't start watcher after upgrade, +                        // stop watcher, +                                        // delete old templates before indexing, +                                        client.admin().indices().prepareDeleteTemplate("watches").execute(watchIndexTemplateListener);, +    private static ActionListener<DeleteIndexTemplateResponse> deleteIndexTemplateListener(String name, ActionListener<Boolean> listener,, +                                                                                           Runnable runnable) {, +        return ActionListener.wrap(r -> {, +                runnable.run();, +                listener.onFailure(new ElasticsearchException("Deleting [{}] template was not acknowledged", name));, +++ b/plugin/src/main/java/org/elasticsearch/xpack/watcher/WatcherIndexingListener.java, +        boolean isWatchExecutionDistributed = WatcherLifeCycleService.isWatchExecutionDistributed(event.state());, +        if (isWatchExecutionDistributed) {, +        } else {, +            configuration = INACTIVE;, +        }, +++ b/plugin/src/main/java/org/elasticsearch/xpack/watcher/WatcherLifeCycleService.java, +import org.elasticsearch.Version;, +    WatcherLifeCycleService(Settings settings, ThreadPool threadPool, ClusterService clusterService,, +            // if there are old nodes in the cluster hosting the watch index shards, we cannot run distributed, only on the master node, +            boolean isDistributedWatchExecutionEnabled = isWatchExecutionDistributed(event.state());, +            if (isDistributedWatchExecutionEnabled) {, +                    // no watcher index, time to pause, as there are for sure no shards on this node, +            } else {, +                if (event.localNodeMaster()) {, +                    if (watcherService.state() != WatcherState.STARTED && watcherService.state() != WatcherState.STARTING) {, +                        executor.execute(() -> start(event.state(), false));, +                } else {, +                    if (watcherService.state() == WatcherState.STARTED || watcherService.state() == WatcherState.STARTING) {, +                        executor.execute(() -> watcherService.pauseExecution("Pausing watcher, cluster contains old nodes not supporting" +, +                                " distributed watch execution"));, +                    }, +                }, +            }, +        }, +    }, +, +    /**, +     * Checks if the preconditions are given to run watcher with distributed watch execution., +     * The following requirements need to be fulfilled, +     *, +     * 1. The master node must run on a version greather than or equal 6.0, +     * 2. The nodes holding the watcher shards must run on a version greater than or equal 6.0, +     *, +     * @param state The cluster to check against, +     * @return true, if the above requirements are fulfilled, false otherwise, +     */, +    public static boolean isWatchExecutionDistributed(ClusterState state) {, +        // short circuit if all nodes are on 6.x, should be standard after upgrade, +        return state.nodes().getMinNodeVersion().onOrAfter(Version.V_6_0_0_beta1);, +++ b/plugin/src/main/java/org/elasticsearch/xpack/upgrade/Upgrade.java, +        ActionListener<DeleteIndexTemplateResponse> triggeredWatchIndexTemplateListener = deleteIndexTemplateListener("triggered_watches",, +                listener, () -> listener.onResponse(true));, +, +        ActionListener<DeleteIndexTemplateResponse> watchIndexTemplateListener = deleteIndexTemplateListener("watches", listener,, +                () -> client.admin().indices().prepareDeleteTemplate("triggered_watches").execute(triggeredWatchIndexTemplateListener));]