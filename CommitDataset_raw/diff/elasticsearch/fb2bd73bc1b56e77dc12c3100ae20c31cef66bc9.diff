[+++ b/elasticsearch/src/main/java/org/elasticsearch/xpack/prelert/job/process/autodetect/AutodetectCommunicator.java, +import java.util.concurrent.CountDownLatch;, +import java.util.concurrent.atomic.AtomicReference;, +    final AtomicReference<CountDownLatch> inUse = new AtomicReference<>();, +        }, false);, +        }, true);, +        }, false);, +            LOGGER.info("[{}] waiting for flush", jobId);, +        }, false);, +    private <T> T checkAndRun(Supplier<String> errorMessage, Callback<T> callback, boolean wait) throws IOException {, +        CountDownLatch latch = new CountDownLatch(1);, +        if (inUse.compareAndSet(null, latch)) {, +                latch.countDown();, +                inUse.set(null);, +            if (wait) {, +                latch = inUse.get();, +                if (latch != null) {, +                    try {, +                        latch.await();, +                    } catch (InterruptedException e) {, +                        Thread.currentThread().interrupt();, +                checkProcessIsAlive();, +                return callback.run();, +            } else {, +                throw new ElasticsearchStatusException(errorMessage.get(), RestStatus.TOO_MANY_REQUESTS);, +            }, +        }, +    }, +++ b/elasticsearch/src/main/java/org/elasticsearch/xpack/prelert/job/process/autodetect/AutodetectCommunicator.java, +import java.util.concurrent.CountDownLatch;, +import java.util.concurrent.atomic.AtomicReference;, +    final AtomicReference<CountDownLatch> inUse = new AtomicReference<>();, +        }, false);, +        }, true);, +        }, false);, +            LOGGER.info("[{}] waiting for flush", jobId);, +        }, false);, +    private <T> T checkAndRun(Supplier<String> errorMessage, Callback<T> callback, boolean wait) throws IOException {, +        CountDownLatch latch = new CountDownLatch(1);, +        if (inUse.compareAndSet(null, latch)) {, +                latch.countDown();, +                inUse.set(null);, +            if (wait) {, +                latch = inUse.get();, +                if (latch != null) {, +                    try {, +                        latch.await();, +                    } catch (InterruptedException e) {, +                        Thread.currentThread().interrupt();, +                checkProcessIsAlive();, +                return callback.run();, +            } else {, +                throw new ElasticsearchStatusException(errorMessage.get(), RestStatus.TOO_MANY_REQUESTS);, +            }, +        }, +    }, +++ b/elasticsearch/src/test/java/org/elasticsearch/xpack/prelert/integration/ScheduledJobIT.java, +                        Collections.singletonMap("metric", "status,data_counts"));, +                String responseAsString = responseEntityToString(getJobResponse);, +                assertThat(responseAsString, containsString("\"status\":\"RUNNING\""));, +                assertThat(responseAsString, containsString("\"input_record_count\":2"));, +++ b/elasticsearch/src/main/java/org/elasticsearch/xpack/prelert/job/process/autodetect/AutodetectCommunicator.java, +import java.util.concurrent.CountDownLatch;, +import java.util.concurrent.atomic.AtomicReference;, +    final AtomicReference<CountDownLatch> inUse = new AtomicReference<>();, +        }, false);, +        }, true);, +        }, false);, +            LOGGER.info("[{}] waiting for flush", jobId);, +        }, false);, +    private <T> T checkAndRun(Supplier<String> errorMessage, Callback<T> callback, boolean wait) throws IOException {, +        CountDownLatch latch = new CountDownLatch(1);, +        if (inUse.compareAndSet(null, latch)) {, +                latch.countDown();, +                inUse.set(null);, +            if (wait) {, +                latch = inUse.get();, +                if (latch != null) {, +                    try {, +                        latch.await();, +                    } catch (InterruptedException e) {, +                        Thread.currentThread().interrupt();, +                checkProcessIsAlive();, +                return callback.run();, +            } else {, +                throw new ElasticsearchStatusException(errorMessage.get(), RestStatus.TOO_MANY_REQUESTS);, +            }, +        }, +    }, +++ b/elasticsearch/src/test/java/org/elasticsearch/xpack/prelert/integration/ScheduledJobIT.java, +                        Collections.singletonMap("metric", "status,data_counts"));, +                String responseAsString = responseEntityToString(getJobResponse);, +                assertThat(responseAsString, containsString("\"status\":\"RUNNING\""));, +                assertThat(responseAsString, containsString("\"input_record_count\":2"));, +++ b/elasticsearch/src/test/java/org/elasticsearch/xpack/prelert/job/process/autodetect/AutodetectCommunicatorTests.java, +import java.util.concurrent.CountDownLatch;, +import static org.mockito.Mockito.times;, +import static org.mockito.Mockito.verify;, +        communicator.inUse.set(new CountDownLatch(1));, +        communicator.inUse.set(null);]