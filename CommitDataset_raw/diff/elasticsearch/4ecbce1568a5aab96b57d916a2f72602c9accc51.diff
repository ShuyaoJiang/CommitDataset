[+++ b/core/src/main/java/org/elasticsearch/action/bulk/TransportBulkAction.java, +import org.elasticsearch.cluster.routing.GroupShardsIterator;, +import org.elasticsearch.cluster.routing.ShardIterator;, +import org.elasticsearch.index.Index;, +        executeBulk(bulkRequest, startTime, listener, new AtomicArray<BulkItemResponse>(bulkRequest.requests.size()));, +    private final long buildTookInMillis(long startTime) {, +            if (request instanceof DocumentRequest) {, +                DocumentRequest req = (DocumentRequest) request;, +, +                if (addFailureIfIndexIsUnavailable(req, bulkRequest, responses, i, concreteIndices, metaData)) {, +, +                String concreteIndex = concreteIndices.resolveIfAbsent(req);, +                    concreteIndices.resolveIfAbsent(req);, +                    req.routing(clusterState.metaData().resolveIndexRouting(req.parent(), req.routing(), req.index()));, +                }, +                MappingMetaData mappingMd = clusterState.metaData().index(concreteIndex).mappingOrDefault(deleteRequest.type());, +                if (mappingMd != null && mappingMd.routing().required() && deleteRequest.routing() == null) {, +                    // if routing is required, and no routing on the delete request, we need to broadcast it...., +                    GroupShardsIterator groupShards = clusterService.operationRouting().broadcastDeleteShards(clusterState, concreteIndex);, +                    for (ShardIterator shardIt : groupShards) {, +                        List<BulkItemRequest> list = requestsByShard.get(shardIt.shardId());, +                        if (list == null) {, +                            list = new ArrayList<>();, +                            requestsByShard.put(shardIt.shardId(), list);, +                        }, +                        list.add(new BulkItemRequest(i, deleteRequest));, +                    }, +                } else {, +                }, +                MappingMetaData mappingMd = clusterState.metaData().index(concreteIndex).mappingOrDefault(updateRequest.type());, +                if (mappingMd != null && mappingMd.routing().required() && updateRequest.routing() == null) {, +                    BulkItemResponse.Failure failure = new BulkItemResponse.Failure(updateRequest.index(), updateRequest.type(),, +                            updateRequest.id(), new IllegalArgumentException("routing is required for this item"));, +                    responses.set(i, new BulkItemResponse(i, updateRequest.type(), failure));, +                    continue;, +                }, +++ b/core/src/main/java/org/elasticsearch/action/bulk/TransportBulkAction.java, +import org.elasticsearch.cluster.routing.GroupShardsIterator;, +import org.elasticsearch.cluster.routing.ShardIterator;, +import org.elasticsearch.index.Index;, +        executeBulk(bulkRequest, startTime, listener, new AtomicArray<BulkItemResponse>(bulkRequest.requests.size()));, +    private final long buildTookInMillis(long startTime) {, +            if (request instanceof DocumentRequest) {, +                DocumentRequest req = (DocumentRequest) request;, +, +                if (addFailureIfIndexIsUnavailable(req, bulkRequest, responses, i, concreteIndices, metaData)) {, +, +                String concreteIndex = concreteIndices.resolveIfAbsent(req);, +                    concreteIndices.resolveIfAbsent(req);, +                    req.routing(clusterState.metaData().resolveIndexRouting(req.parent(), req.routing(), req.index()));, +                }, +                MappingMetaData mappingMd = clusterState.metaData().index(concreteIndex).mappingOrDefault(deleteRequest.type());, +                if (mappingMd != null && mappingMd.routing().required() && deleteRequest.routing() == null) {, +                    // if routing is required, and no routing on the delete request, we need to broadcast it...., +                    GroupShardsIterator groupShards = clusterService.operationRouting().broadcastDeleteShards(clusterState, concreteIndex);, +                    for (ShardIterator shardIt : groupShards) {, +                        List<BulkItemRequest> list = requestsByShard.get(shardIt.shardId());, +                        if (list == null) {, +                            list = new ArrayList<>();, +                            requestsByShard.put(shardIt.shardId(), list);, +                        }, +                        list.add(new BulkItemRequest(i, deleteRequest));, +                    }, +                } else {, +                }, +                MappingMetaData mappingMd = clusterState.metaData().index(concreteIndex).mappingOrDefault(updateRequest.type());, +                if (mappingMd != null && mappingMd.routing().required() && updateRequest.routing() == null) {, +                    BulkItemResponse.Failure failure = new BulkItemResponse.Failure(updateRequest.index(), updateRequest.type(),, +                            updateRequest.id(), new IllegalArgumentException("routing is required for this item"));, +                    responses.set(i, new BulkItemResponse(i, updateRequest.type(), failure));, +                    continue;, +                }, +++ b/core/src/main/java/org/elasticsearch/action/delete/TransportDeleteAction.java, +            // check if routing is required, if so, do a broadcast delete, +        ShardId shardId = clusterService.operationRouting().shardId(clusterService.state(), concreteIndex, request.id(), request.routing());, +        request.setShardId(shardId);, +++ b/core/src/main/java/org/elasticsearch/action/bulk/TransportBulkAction.java, +import org.elasticsearch.cluster.routing.GroupShardsIterator;, +import org.elasticsearch.cluster.routing.ShardIterator;, +import org.elasticsearch.index.Index;, +        executeBulk(bulkRequest, startTime, listener, new AtomicArray<BulkItemResponse>(bulkRequest.requests.size()));, +    private final long buildTookInMillis(long startTime) {, +            if (request instanceof DocumentRequest) {, +                DocumentRequest req = (DocumentRequest) request;, +, +                if (addFailureIfIndexIsUnavailable(req, bulkRequest, responses, i, concreteIndices, metaData)) {, +, +                String concreteIndex = concreteIndices.resolveIfAbsent(req);, +                    concreteIndices.resolveIfAbsent(req);, +                    req.routing(clusterState.metaData().resolveIndexRouting(req.parent(), req.routing(), req.index()));, +                }, +                MappingMetaData mappingMd = clusterState.metaData().index(concreteIndex).mappingOrDefault(deleteRequest.type());, +                if (mappingMd != null && mappingMd.routing().required() && deleteRequest.routing() == null) {, +                    // if routing is required, and no routing on the delete request, we need to broadcast it...., +                    GroupShardsIterator groupShards = clusterService.operationRouting().broadcastDeleteShards(clusterState, concreteIndex);, +                    for (ShardIterator shardIt : groupShards) {, +                        List<BulkItemRequest> list = requestsByShard.get(shardIt.shardId());, +                        if (list == null) {, +                            list = new ArrayList<>();, +                            requestsByShard.put(shardIt.shardId(), list);]