[+++ b/server/src/main/java/org/elasticsearch/index/shard/IndexShard.java, +        final Releasable forceRefreshes = refreshListeners.forceRefreshes();, +                forceRefreshes.close();, +        } finally {, +            forceRefreshes.close();, +        asyncBlockOperations(onPermitAcquired, timeout.duration(), timeout.timeUnit());, +    }, +, +    private void asyncBlockOperations(ActionListener<Releasable> onPermitAcquired, long timeout, TimeUnit timeUnit) {, +        final Releasable forceRefreshes = refreshListeners.forceRefreshes();, +        final ActionListener<Releasable> wrappedListener = ActionListener.wrap(r -> {, +            forceRefreshes.close();, +            onPermitAcquired.onResponse(r);, +        }, e -> {, +            forceRefreshes.close();, +            onPermitAcquired.onFailure(e);, +        });, +        try {, +            indexShardOperationPermits.asyncBlockOperations(wrappedListener, timeout, timeUnit);, +        } catch (Exception e) {, +            forceRefreshes.close();, +            throw e;, +        }, +        asyncBlockOperations(new ActionListener<Releasable>() {, +        innerAcquireReplicaOperationPermit(opPrimaryTerm, globalCheckpoint, maxSeqNoOfUpdatesOrDeletes,, +            onPermitAcquired, true,, +            listener -> asyncBlockOperations(listener, timeout.duration(), timeout.timeUnit()), +        );, +++ b/server/src/main/java/org/elasticsearch/index/shard/IndexShard.java, +        final Releasable forceRefreshes = refreshListeners.forceRefreshes();, +                forceRefreshes.close();, +        } finally {, +            forceRefreshes.close();, +        asyncBlockOperations(onPermitAcquired, timeout.duration(), timeout.timeUnit());, +    }, +, +    private void asyncBlockOperations(ActionListener<Releasable> onPermitAcquired, long timeout, TimeUnit timeUnit) {, +        final Releasable forceRefreshes = refreshListeners.forceRefreshes();, +        final ActionListener<Releasable> wrappedListener = ActionListener.wrap(r -> {, +            forceRefreshes.close();, +            onPermitAcquired.onResponse(r);, +        }, e -> {, +            forceRefreshes.close();, +            onPermitAcquired.onFailure(e);, +        });, +        try {, +            indexShardOperationPermits.asyncBlockOperations(wrappedListener, timeout, timeUnit);, +        } catch (Exception e) {, +            forceRefreshes.close();, +            throw e;, +        }, +        asyncBlockOperations(new ActionListener<Releasable>() {, +        innerAcquireReplicaOperationPermit(opPrimaryTerm, globalCheckpoint, maxSeqNoOfUpdatesOrDeletes,, +            onPermitAcquired, true,, +            listener -> asyncBlockOperations(listener, timeout.duration(), timeout.timeUnit()), +        );, +++ b/server/src/main/java/org/elasticsearch/index/shard/IndexShardOperationPermits.java, +++ b/server/src/main/java/org/elasticsearch/index/shard/IndexShard.java, +        final Releasable forceRefreshes = refreshListeners.forceRefreshes();, +                forceRefreshes.close();, +        } finally {, +            forceRefreshes.close();, +        asyncBlockOperations(onPermitAcquired, timeout.duration(), timeout.timeUnit());, +    }, +, +    private void asyncBlockOperations(ActionListener<Releasable> onPermitAcquired, long timeout, TimeUnit timeUnit) {, +        final Releasable forceRefreshes = refreshListeners.forceRefreshes();, +        final ActionListener<Releasable> wrappedListener = ActionListener.wrap(r -> {, +            forceRefreshes.close();, +            onPermitAcquired.onResponse(r);, +        }, e -> {, +            forceRefreshes.close();, +            onPermitAcquired.onFailure(e);, +        });, +        try {, +            indexShardOperationPermits.asyncBlockOperations(wrappedListener, timeout, timeUnit);, +        } catch (Exception e) {, +            forceRefreshes.close();, +            throw e;, +        }, +        asyncBlockOperations(new ActionListener<Releasable>() {, +        innerAcquireReplicaOperationPermit(opPrimaryTerm, globalCheckpoint, maxSeqNoOfUpdatesOrDeletes,, +            onPermitAcquired, true,, +            listener -> asyncBlockOperations(listener, timeout.duration(), timeout.timeUnit()), +        );, +++ b/server/src/main/java/org/elasticsearch/index/shard/IndexShardOperationPermits.java, +++ b/server/src/main/java/org/elasticsearch/index/shard/RefreshListeners.java, +import org.elasticsearch.common.lease.Releasable;, +import org.elasticsearch.common.util.concurrent.RunOnce;, +, +    /**, +     * Force-refreshes new refresh listeners that are added while {@code >= 0}. Used to prevent becoming blocked on operations waiting for, +     * refresh during relocation., +     */, +    private int refreshForcers;, +, +     * Force-refreshes newly added listeners and forces a refresh if there are currently listeners registered. See {@link #refreshForcers}., +     */, +    public Releasable forceRefreshes() {, +        synchronized (this) {]