[+++ b/core/src/main/java/org/elasticsearch/client/transport/support/TransportProxyClient.java, +import java.util.Collections;, +++ b/core/src/main/java/org/elasticsearch/client/transport/support/TransportProxyClient.java, +import java.util.Collections;, +++ b/core/src/main/java/org/elasticsearch/indices/ttl/IndicesTTLService.java, +import org.apache.lucene.index.Term;, +import org.elasticsearch.index.mapper.UidFieldMapper;, +                final long version = Versions.loadVersion(context.reader(), new Term(UidFieldMapper.NAME, uid.toBytesRef()));, +++ b/core/src/main/java/org/elasticsearch/client/transport/support/TransportProxyClient.java, +import java.util.Collections;, +++ b/core/src/main/java/org/elasticsearch/indices/ttl/IndicesTTLService.java, +import org.apache.lucene.index.Term;, +import org.elasticsearch.index.mapper.UidFieldMapper;, +                final long version = Versions.loadVersion(context.reader(), new Term(UidFieldMapper.NAME, uid.toBytesRef()));, +++ b/core/src/main/java/org/elasticsearch/search/fetch/version/VersionFetchSubPhase.java, +import org.apache.lucene.index.Term;, +import org.apache.lucene.util.BytesRef;, +import org.elasticsearch.index.mapper.Uid;, +import org.elasticsearch.index.mapper.UidFieldMapper;, +        // it might make sense to cache the TermDocs on a shared fetch context and just skip here), +        // it is going to mean we work on the high level multi reader and not the lower level reader as is, +        // the case below..., +        final long version;, +            BytesRef uid = Uid.createUidAsBytes(hitContext.hit().type(), hitContext.hit().id());, +            version = Versions.loadVersion(, +                    hitContext.readerContext().reader(),, +                    new Term(UidFieldMapper.NAME, uid), +            );, +            throw new ElasticsearchException("Could not query index for _version", e);, +++ b/core/src/main/java/org/elasticsearch/client/transport/support/TransportProxyClient.java, +import java.util.Collections;, +++ b/core/src/main/java/org/elasticsearch/indices/ttl/IndicesTTLService.java, +import org.apache.lucene.index.Term;, +import org.elasticsearch.index.mapper.UidFieldMapper;, +                final long version = Versions.loadVersion(context.reader(), new Term(UidFieldMapper.NAME, uid.toBytesRef()));, +++ b/core/src/main/java/org/elasticsearch/search/fetch/version/VersionFetchSubPhase.java, +import org.apache.lucene.index.Term;, +import org.apache.lucene.util.BytesRef;, +import org.elasticsearch.index.mapper.Uid;, +import org.elasticsearch.index.mapper.UidFieldMapper;, +        // it might make sense to cache the TermDocs on a shared fetch context and just skip here), +        // it is going to mean we work on the high level multi reader and not the lower level reader as is, +        // the case below..., +        final long version;, +            BytesRef uid = Uid.createUidAsBytes(hitContext.hit().type(), hitContext.hit().id());, +            version = Versions.loadVersion(, +                    hitContext.readerContext().reader(),, +                    new Term(UidFieldMapper.NAME, uid), +            );, +            throw new ElasticsearchException("Could not query index for _version", e);, +++ b/core/src/test/java/org/elasticsearch/action/support/master/IndexingMasterFailoverIT.java, +import org.elasticsearch.test.disruption.NetworkDisconnectPartition;, +import org.elasticsearch.test.disruption.NetworkPartition;, +        NetworkPartition partition = new NetworkDisconnectPartition(Collections.singleton(master), otherNodes, random());, +++ b/core/src/main/java/org/elasticsearch/client/transport/support/TransportProxyClient.java, +import java.util.Collections;, +++ b/core/src/main/java/org/elasticsearch/indices/ttl/IndicesTTLService.java, +import org.apache.lucene.index.Term;, +import org.elasticsearch.index.mapper.UidFieldMapper;, +                final long version = Versions.loadVersion(context.reader(), new Term(UidFieldMapper.NAME, uid.toBytesRef()));, +++ b/core/src/main/java/org/elasticsearch/search/fetch/version/VersionFetchSubPhase.java, +import org.apache.lucene.index.Term;, +import org.apache.lucene.util.BytesRef;, +import org.elasticsearch.index.mapper.Uid;, +import org.elasticsearch.index.mapper.UidFieldMapper;, +        // it might make sense to cache the TermDocs on a shared fetch context and just skip here), +        // it is going to mean we work on the high level multi reader and not the lower level reader as is, +        // the case below..., +        final long version;, +            BytesRef uid = Uid.createUidAsBytes(hitContext.hit().type(), hitContext.hit().id());, +            version = Versions.loadVersion(, +                    hitContext.readerContext().reader(),, +                    new Term(UidFieldMapper.NAME, uid), +            );, +            throw new ElasticsearchException("Could not query index for _version", e);, +++ b/core/src/test/java/org/elasticsearch/action/support/master/IndexingMasterFailoverIT.java, +import org.elasticsearch.test.disruption.NetworkDisconnectPartition;, +import org.elasticsearch.test.disruption.NetworkPartition;, +        NetworkPartition partition = new NetworkDisconnectPartition(Collections.singleton(master), otherNodes, random());, +++ b/core/src/test/java/org/elasticsearch/cluster/MinimumMasterNodesIT.java, +import org.elasticsearch.test.disruption.NetworkDelaysPartition;, +        NetworkDelaysPartition partition = new NetworkDelaysPartition(Collections.singleton(master), otherNodes, 60000, random());, +        final AtomicReference<Throwable> failure = new AtomicReference<>();, +++ b/core/src/main/java/org/elasticsearch/client/transport/support/TransportProxyClient.java, +import java.util.Collections;, +++ b/core/src/main/java/org/elasticsearch/indices/ttl/IndicesTTLService.java, +import org.apache.lucene.index.Term;, +import org.elasticsearch.index.mapper.UidFieldMapper;, +                final long version = Versions.loadVersion(context.reader(), new Term(UidFieldMapper.NAME, uid.toBytesRef()));, +++ b/core/src/main/java/org/elasticsearch/search/fetch/version/VersionFetchSubPhase.java, +import org.apache.lucene.index.Term;, +import org.apache.lucene.util.BytesRef;, +import org.elasticsearch.index.mapper.Uid;, +import org.elasticsearch.index.mapper.UidFieldMapper;, +        // it might make sense to cache the TermDocs on a shared fetch context and just skip here), +        // it is going to mean we work on the high level multi reader and not the lower level reader as is, +        // the case below..., +        final long version;, +            BytesRef uid = Uid.createUidAsBytes(hitContext.hit().type(), hitContext.hit().id());, +            version = Versions.loadVersion(]