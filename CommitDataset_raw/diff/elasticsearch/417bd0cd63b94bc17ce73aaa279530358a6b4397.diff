[+++ b/core/src/main/java/org/elasticsearch/action/admin/indices/shards/TransportIndicesShardStoresAction.java, +import org.elasticsearch.cluster.metadata.IndexMetaData;, +            IndexMetaData indexMetaData = state.metaData().index(index);, +                final int shardId = routing.shardId().id();, +                ClusterShardHealth shardHealth = new ClusterShardHealth(shardId,, +                                                                        routing,, +                                                                        indexMetaData.activeAllocationIds(shardId).isEmpty());, +++ b/core/src/main/java/org/elasticsearch/action/admin/indices/shards/TransportIndicesShardStoresAction.java, +import org.elasticsearch.cluster.metadata.IndexMetaData;, +            IndexMetaData indexMetaData = state.metaData().index(index);, +                final int shardId = routing.shardId().id();, +                ClusterShardHealth shardHealth = new ClusterShardHealth(shardId,, +                                                                        routing,, +                                                                        indexMetaData.activeAllocationIds(shardId).isEmpty());, +++ b/core/src/main/java/org/elasticsearch/cluster/health/ClusterIndexHealth.java, +            shards.put(shardId, new ClusterShardHealth(shardId, shardRoutingTable, indexMetaData.activeAllocationIds(shardId).isEmpty()));, +++ b/core/src/main/java/org/elasticsearch/action/admin/indices/shards/TransportIndicesShardStoresAction.java, +import org.elasticsearch.cluster.metadata.IndexMetaData;, +            IndexMetaData indexMetaData = state.metaData().index(index);, +                final int shardId = routing.shardId().id();, +                ClusterShardHealth shardHealth = new ClusterShardHealth(shardId,, +                                                                        routing,, +                                                                        indexMetaData.activeAllocationIds(shardId).isEmpty());, +++ b/core/src/main/java/org/elasticsearch/cluster/health/ClusterIndexHealth.java, +            shards.put(shardId, new ClusterShardHealth(shardId, shardRoutingTable, indexMetaData.activeAllocationIds(shardId).isEmpty()));, +++ b/core/src/main/java/org/elasticsearch/cluster/health/ClusterShardHealth.java, +import org.elasticsearch.cluster.routing.UnassignedInfo;, +    public ClusterShardHealth(final int shardId, final IndexShardRoutingTable shardRoutingTable, final boolean noActiveAllocationIds) {, +        final ShardRouting primaryRouting = shardRoutingTable.primaryShard();, +        if (primaryRouting.active()) {, +            computeStatus = UnassignedInfo.unassignedPrimaryShardHealth(primaryRouting.unassignedInfo(), noActiveAllocationIds);, +        this.primaryActive = primaryRouting.active();, +, +++ b/core/src/main/java/org/elasticsearch/action/admin/indices/shards/TransportIndicesShardStoresAction.java, +import org.elasticsearch.cluster.metadata.IndexMetaData;, +            IndexMetaData indexMetaData = state.metaData().index(index);, +                final int shardId = routing.shardId().id();, +                ClusterShardHealth shardHealth = new ClusterShardHealth(shardId,, +                                                                        routing,, +                                                                        indexMetaData.activeAllocationIds(shardId).isEmpty());, +++ b/core/src/main/java/org/elasticsearch/cluster/health/ClusterIndexHealth.java, +            shards.put(shardId, new ClusterShardHealth(shardId, shardRoutingTable, indexMetaData.activeAllocationIds(shardId).isEmpty()));, +++ b/core/src/main/java/org/elasticsearch/cluster/health/ClusterShardHealth.java, +import org.elasticsearch.cluster.routing.UnassignedInfo;, +    public ClusterShardHealth(final int shardId, final IndexShardRoutingTable shardRoutingTable, final boolean noActiveAllocationIds) {, +        final ShardRouting primaryRouting = shardRoutingTable.primaryShard();, +        if (primaryRouting.active()) {, +            computeStatus = UnassignedInfo.unassignedPrimaryShardHealth(primaryRouting.unassignedInfo(), noActiveAllocationIds);, +        this.primaryActive = primaryRouting.active();, +, +++ b/core/src/main/java/org/elasticsearch/cluster/routing/UnassignedInfo.java, +import org.elasticsearch.cluster.health.ClusterHealthStatus;, +    /**, +     * Returns the appropriate {@link ClusterHealthStatus} for an unassigned primary shard, +     * based on its unassigned information and allocation id history., +     */, +    public static ClusterHealthStatus unassignedPrimaryShardHealth(final UnassignedInfo unassignedInfo,, +                                                                   final boolean noActiveAllocationIds) {, +        assert unassignedInfo != null;, +        final UnassignedInfo.Reason reason = unassignedInfo.getReason();, +        /**, +         * Normally, an inactive primary shard in an index should cause the cluster health to be RED.  However,, +         * there are exceptions where a health status of RED is inappropriate, namely in these scenarios:, +         *   1. Index Creation.  When an index is first created, the primary shards are in the initializing state, so, +         *      there is a small window where the cluster health is RED due to the primaries not being activated yet., +         *      However, this leads to a false sense that the cluster is in an unhealthy state, when in reality, its, +         *      simply a case of needing to wait for the primaries to initialize., +         *   2. When a cluster is in the recovery state, and the shard never had any allocation ids assigned to it,, +         *      which indicates the index was created and before allocation of the primary occurred for this shard,, +         *      a cluster restart happened., +         *, +         * Here, we check for these scenarios and set the cluster health to YELLOW if any are applicable., +         */, +        if (reason == UnassignedInfo.Reason.INDEX_CREATED, +                || (reason == UnassignedInfo.Reason.CLUSTER_RECOVERED && noActiveAllocationIds)) {, +            return ClusterHealthStatus.YELLOW;, +        } else {, +            return ClusterHealthStatus.RED;, +        }, +    }, +, +, +++ b/core/src/main/java/org/elasticsearch/action/admin/indices/shards/TransportIndicesShardStoresAction.java, +import org.elasticsearch.cluster.metadata.IndexMetaData;, +            IndexMetaData indexMetaData = state.metaData().index(index);, +                final int shardId = routing.shardId().id();, +                ClusterShardHealth shardHealth = new ClusterShardHealth(shardId,, +                                                                        routing,, +                                                                        indexMetaData.activeAllocationIds(shardId).isEmpty());, +++ b/core/src/main/java/org/elasticsearch/cluster/health/ClusterIndexHealth.java, +            shards.put(shardId, new ClusterShardHealth(shardId, shardRoutingTable, indexMetaData.activeAllocationIds(shardId).isEmpty()));, +++ b/core/src/main/java/org/elasticsearch/cluster/health/ClusterShardHealth.java, +import org.elasticsearch.cluster.routing.UnassignedInfo;, +    public ClusterShardHealth(final int shardId, final IndexShardRoutingTable shardRoutingTable, final boolean noActiveAllocationIds) {, +        final ShardRouting primaryRouting = shardRoutingTable.primaryShard();, +        if (primaryRouting.active()) {, +            computeStatus = UnassignedInfo.unassignedPrimaryShardHealth(primaryRouting.unassignedInfo(), noActiveAllocationIds);, +        this.primaryActive = primaryRouting.active();, +, +++ b/core/src/main/java/org/elasticsearch/cluster/routing/UnassignedInfo.java]