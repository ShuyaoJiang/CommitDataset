[+++ b/build.gradle, +++ b/build.gradle, +++ b/buildSrc/src/main/groovy/org/elasticsearch/gradle/test/StandaloneTestBasePlugin.groovy, +++ b/build.gradle, +++ b/buildSrc/src/main/groovy/org/elasticsearch/gradle/test/StandaloneTestBasePlugin.groovy, +++ b/core/src/main/java/org/elasticsearch/action/bulk/TransportShardBulkAction.java, +import org.elasticsearch.index.mapper.Mapping;, +import org.elasticsearch.index.mapper.SourceToParse;, +                    final WriteResult<DeleteResponse> writeResult = shardDeleteOperation(request, deleteRequest, indexShard);, +        processAfter(request.refresh(), indexShard, location);, +    private WriteResult shardIndexOperation(BulkShardRequest request, IndexRequest indexRequest, ClusterState clusterState,, +, +        return executeIndexRequestOnPrimary(indexRequest, indexShard);, +    }, +, +    private WriteResult<DeleteResponse> shardDeleteOperation(BulkShardRequest request, DeleteRequest deleteRequest, IndexShard indexShard) {, +        Engine.Delete delete = indexShard.prepareDelete(deleteRequest.type(), deleteRequest.id(), deleteRequest.version(), deleteRequest.versionType(), Engine.Operation.Origin.PRIMARY);, +        indexShard.delete(delete);, +        // update the request with the version so it will go to the replicas, +        deleteRequest.versionType(delete.versionType().versionTypeForReplicationAndRecovery());, +        deleteRequest.version(delete.version());, +, +        assert deleteRequest.versionType().validateVersionForWrites(deleteRequest.version());, +, +        DeleteResponse deleteResponse = new DeleteResponse(request.index(), deleteRequest.type(), deleteRequest.id(), delete.version(), delete.found());, +        return new WriteResult(deleteResponse, delete.getTranslogLocation());, +                    WriteResult result = shardDeleteOperation(bulkShardRequest, deleteRequest, indexShard);, +                    SourceToParse sourceToParse = SourceToParse.source(SourceToParse.Origin.REPLICA, indexRequest.source()).index(shardId.getIndex()).type(indexRequest.type()).id(indexRequest.id()), +                            .routing(indexRequest.routing()).parent(indexRequest.parent()).timestamp(indexRequest.timestamp()).ttl(indexRequest.ttl());, +, +                    final Engine.Index operation = indexShard.prepareIndex(sourceToParse, indexRequest.version(), indexRequest.versionType(), Engine.Operation.Origin.REPLICA);, +                    Mapping update = operation.parsedDoc().dynamicMappingsUpdate();, +                    if (update != null) {, +                        throw new RetryOnReplicaException(shardId, "Mappings are not available on the replica yet, triggered update: " + update);, +                    }, +                    indexShard.index(operation);, +                    Engine.Delete delete = indexShard.prepareDelete(deleteRequest.type(), deleteRequest.id(), deleteRequest.version(), deleteRequest.versionType(), Engine.Operation.Origin.REPLICA);, +        processAfter(request.refresh(), indexShard, location);, +++ b/build.gradle, +++ b/buildSrc/src/main/groovy/org/elasticsearch/gradle/test/StandaloneTestBasePlugin.groovy, +++ b/core/src/main/java/org/elasticsearch/action/bulk/TransportShardBulkAction.java, +import org.elasticsearch.index.mapper.Mapping;, +import org.elasticsearch.index.mapper.SourceToParse;, +                    final WriteResult<DeleteResponse> writeResult = shardDeleteOperation(request, deleteRequest, indexShard);, +        processAfter(request.refresh(), indexShard, location);, +    private WriteResult shardIndexOperation(BulkShardRequest request, IndexRequest indexRequest, ClusterState clusterState,, +, +        return executeIndexRequestOnPrimary(indexRequest, indexShard);, +    }, +, +    private WriteResult<DeleteResponse> shardDeleteOperation(BulkShardRequest request, DeleteRequest deleteRequest, IndexShard indexShard) {, +        Engine.Delete delete = indexShard.prepareDelete(deleteRequest.type(), deleteRequest.id(), deleteRequest.version(), deleteRequest.versionType(), Engine.Operation.Origin.PRIMARY);, +        indexShard.delete(delete);, +        // update the request with the version so it will go to the replicas, +        deleteRequest.versionType(delete.versionType().versionTypeForReplicationAndRecovery());, +        deleteRequest.version(delete.version());, +, +        assert deleteRequest.versionType().validateVersionForWrites(deleteRequest.version());, +, +        DeleteResponse deleteResponse = new DeleteResponse(request.index(), deleteRequest.type(), deleteRequest.id(), delete.version(), delete.found());, +        return new WriteResult(deleteResponse, delete.getTranslogLocation());, +                    WriteResult result = shardDeleteOperation(bulkShardRequest, deleteRequest, indexShard);, +                    SourceToParse sourceToParse = SourceToParse.source(SourceToParse.Origin.REPLICA, indexRequest.source()).index(shardId.getIndex()).type(indexRequest.type()).id(indexRequest.id()), +                            .routing(indexRequest.routing()).parent(indexRequest.parent()).timestamp(indexRequest.timestamp()).ttl(indexRequest.ttl());, +, +                    final Engine.Index operation = indexShard.prepareIndex(sourceToParse, indexRequest.version(), indexRequest.versionType(), Engine.Operation.Origin.REPLICA);, +                    Mapping update = operation.parsedDoc().dynamicMappingsUpdate();, +                    if (update != null) {, +                        throw new RetryOnReplicaException(shardId, "Mappings are not available on the replica yet, triggered update: " + update);, +                    }, +                    indexShard.index(operation);, +                    Engine.Delete delete = indexShard.prepareDelete(deleteRequest.type(), deleteRequest.id(), deleteRequest.version(), deleteRequest.versionType(), Engine.Operation.Origin.REPLICA);, +        processAfter(request.refresh(), indexShard, location);, +++ b/core/src/main/java/org/elasticsearch/action/delete/DeleteResponse.java, +import org.elasticsearch.common.xcontent.StatusToXContent;, +import org.elasticsearch.common.xcontent.ToXContent;, +import org.elasticsearch.common.xcontent.XContentBuilder;, +import org.elasticsearch.common.xcontent.XContentBuilderString;, +import org.elasticsearch.rest.RestStatus;, +import static org.elasticsearch.rest.RestStatus.NOT_FOUND;, +, +public class DeleteResponse extends ActionWriteResponse implements StatusToXContent {, +, +    @Override, +    public RestStatus status() {, +        RestStatus status = getShardInfo().status();, +        if (isFound() == false) {, +            status = NOT_FOUND;, +        }, +        return status;, +    }, +, +    @Override, +    public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {, +        ActionWriteResponse.ShardInfo shardInfo = getShardInfo();, +        builder.field(Fields.FOUND, found), +            .field(Fields._INDEX, index), +            .field(Fields._TYPE, type), +            .field(Fields._ID, id), +            .field(Fields._VERSION, version)]