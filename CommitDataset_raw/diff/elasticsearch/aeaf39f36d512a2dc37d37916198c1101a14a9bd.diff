[+++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/SArrayEach.java, +    public SArrayEach(Location location, int maxLoopCounter, String type, String name, AExpression expression, SBlock block) {, +        // Note that we do not need to analyze the expression as this must already be done, +        // in the parent to determine that the for each target type is an array., +, +++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/SArrayEach.java, +    public SArrayEach(Location location, int maxLoopCounter, String type, String name, AExpression expression, SBlock block) {, +        // Note that we do not need to analyze the expression as this must already be done, +        // in the parent to determine that the for each target type is an array., +, +++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/SDefEach.java, +import org.elasticsearch.painless.Location;, +import org.elasticsearch.painless.MethodWriter;, +import org.elasticsearch.painless.Variables;, +, +public class SDefEach extends AStatement {, +, +    final int maxLoopCounter;, +    final String type;, +    final String name;, +    AExpression expression;, +    AStatement block;, +, +    public SDefEach(Location location, int maxLoopCounter, String type, String name, AExpression expression, SBlock block) {, +        super(location);, +, +        this.maxLoopCounter = maxLoopCounter;, +        this.type = type;, +        this.name = name;, +        this.expression = expression;, +        this.block = block;, +    }, +, +    @Override, +    AStatement analyze(Variables variables) {, +        // Note that we do not need to analyze the expression as this must already be done, +        // in the parent to determine that the for each target type is def., +, +        throw location.createError(new UnsupportedOperationException("Cannot execute for each against def type."));, +, +        /*, +        try {, +            type = Definition.getType(this.type);, +        } catch (IllegalArgumentException exception) {, +            throw createError(new IllegalArgumentException("Not a type [" + this.type + "]."));, +        }, +, +        variables.incrementScope();, +, +        Type itr = Definition.getType("Iterator");, +, +        variable = variables.addVariable(location, type, name, true, false);, +, +        // We must store the iterator as a variable for securing a slot on the stack, and, +        // also add the location offset to make the name unique in case of nested for each loops., +        iterator = variables.addVariable(location, itr, "#itr" + location.getOffset(), true, false);, +, +        method = expression.actual.struct.methods.get(new MethodKey("iterator", 0));, +, +        if (method == null) {, +            throw location.createError(new IllegalArgumentException(, +                "Unable to create iterator for the type [" + expression.actual.name + "]."));, +        }, +, +        hasNext = itr.struct.methods.get(new MethodKey("hasNext", 0));, +, +        if (hasNext == null) {, +            throw location.createError(new IllegalArgumentException("Method [hasNext] does not exist for type [Iterator]."));, +        } else if (hasNext.rtn.sort != Sort.BOOL) {, +            throw location.createError(new IllegalArgumentException("Method [hasNext] does not return type [boolean]."));, +        }, +, +        next = itr.struct.methods.get(new MethodKey("next", 0));, +, +        if (next == null) {, +            throw location.createError(new IllegalArgumentException("Method [next] does not exist for type [Iterator]."));, +        } else if (next.rtn.sort != Sort.DEF) {, +            throw location.createError(new IllegalArgumentException("Method [next] does not return type [def]."));, +        }, +, +        cast = AnalyzerCaster.getLegalCast(location, Definition.DEF_TYPE, type, true, true);, +, +        if (block == null) {, +            throw location.createError(new IllegalArgumentException("Extraneous for each loop."));, +        }, +, +        block.beginLoop = true;, +        block.inLoop = true;, +        block = block.analyze(variables);, +        block.statementCount = Math.max(1, block.statementCount);, +, +        if (block.loopEscape && !block.anyContinue) {, +            throw createError(new IllegalArgumentException("Extraneous for loop."));, +        }, +, +        statementCount = 1;, +, +        if (maxLoopCounter > 0) {, +            loopCounterSlot = variables.getVariable(location, "#loop").slot;, +        }]