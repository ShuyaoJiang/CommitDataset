[+++ b/modules/ingest-common/src/main/java/org/elasticsearch/ingest/common/DateFormat.java, +            boolean isUtc = ZoneOffset.UTC.equals(zoneId);, +, +            DateFormatter dateFormatter = DateFormatter.forPattern(format), +                .withLocale(locale);, +            // if UTC zone is set here, the the time zone specified in the format will be ignored, leading to wrong dates, +            if (isUtc == false) {, +                dateFormatter = dateFormatter.withZone(zoneId);, +            }, +            final DateFormatter formatter = dateFormatter;, +                if (isUtc) {, +                    return DateFormatters.from(accessor).withZoneSameInstant(ZoneOffset.UTC);, +                } else {, +                }, +++ b/modules/ingest-common/src/main/java/org/elasticsearch/ingest/common/DateFormat.java, +            boolean isUtc = ZoneOffset.UTC.equals(zoneId);, +, +            DateFormatter dateFormatter = DateFormatter.forPattern(format), +                .withLocale(locale);, +            // if UTC zone is set here, the the time zone specified in the format will be ignored, leading to wrong dates, +            if (isUtc == false) {, +                dateFormatter = dateFormatter.withZone(zoneId);, +            }, +            final DateFormatter formatter = dateFormatter;, +                if (isUtc) {, +                    return DateFormatters.from(accessor).withZoneSameInstant(ZoneOffset.UTC);, +                } else {, +                }, +++ b/modules/ingest-common/src/main/java/org/elasticsearch/ingest/common/DateProcessor.java, +    private static final DateFormatter FORMATTER = DateFormatter.forPattern("yyyy-MM-dd'T'HH:mm:ss.SSSXXX");, +++ b/modules/ingest-common/src/main/java/org/elasticsearch/ingest/common/DateFormat.java, +            boolean isUtc = ZoneOffset.UTC.equals(zoneId);, +, +            DateFormatter dateFormatter = DateFormatter.forPattern(format), +                .withLocale(locale);, +            // if UTC zone is set here, the the time zone specified in the format will be ignored, leading to wrong dates, +            if (isUtc == false) {, +                dateFormatter = dateFormatter.withZone(zoneId);, +            }, +            final DateFormatter formatter = dateFormatter;, +                if (isUtc) {, +                    return DateFormatters.from(accessor).withZoneSameInstant(ZoneOffset.UTC);, +                } else {, +                }, +++ b/modules/ingest-common/src/main/java/org/elasticsearch/ingest/common/DateProcessor.java, +    private static final DateFormatter FORMATTER = DateFormatter.forPattern("yyyy-MM-dd'T'HH:mm:ss.SSSXXX");, +++ b/modules/ingest-common/src/test/java/org/elasticsearch/ingest/common/DateFormatTests.java, +import org.elasticsearch.common.time.DateFormatter;, +    public void testParseJavaWithTimeZone() {, +        Function<String, ZonedDateTime> javaFunction = DateFormat.Java.getFunction("yyyy-MM-dd'T'HH:mm:ss.SSSZZ",, +            ZoneOffset.UTC, Locale.ROOT);, +        ZonedDateTime datetime = javaFunction.apply("2018-02-05T13:44:56.657+0100");, +        String expectedDateTime = DateFormatter.forPattern("yyyy-MM-dd'T'HH:mm:ss.SSSXXX").withZone(ZoneOffset.UTC).format(datetime);, +        assertThat(expectedDateTime, is("2018-02-05T12:44:56.657Z"));, +    }, +, +        assertThat(DateFormat.Iso8601.getFunction(null, ZoneOffset.UTC, null).apply("2001-01-01T00:00:00-0800").toString(),, +                equalTo("2001-01-01T08:00Z"));, +        assertThat(DateFormat.Iso8601.getFunction(null, ZoneOffset.UTC, null).apply("2001-01-01T00:00:00-0800").toString(),, +                equalTo("2001-01-01T08:00Z"));, +++ b/modules/ingest-common/src/main/java/org/elasticsearch/ingest/common/DateFormat.java, +            boolean isUtc = ZoneOffset.UTC.equals(zoneId);, +, +            DateFormatter dateFormatter = DateFormatter.forPattern(format), +                .withLocale(locale);, +            // if UTC zone is set here, the the time zone specified in the format will be ignored, leading to wrong dates, +            if (isUtc == false) {, +                dateFormatter = dateFormatter.withZone(zoneId);, +            }, +            final DateFormatter formatter = dateFormatter;, +                if (isUtc) {, +                    return DateFormatters.from(accessor).withZoneSameInstant(ZoneOffset.UTC);, +                } else {, +                }, +++ b/modules/ingest-common/src/main/java/org/elasticsearch/ingest/common/DateProcessor.java, +    private static final DateFormatter FORMATTER = DateFormatter.forPattern("yyyy-MM-dd'T'HH:mm:ss.SSSXXX");, +++ b/modules/ingest-common/src/test/java/org/elasticsearch/ingest/common/DateFormatTests.java, +import org.elasticsearch.common.time.DateFormatter;, +    public void testParseJavaWithTimeZone() {, +        Function<String, ZonedDateTime> javaFunction = DateFormat.Java.getFunction("yyyy-MM-dd'T'HH:mm:ss.SSSZZ",, +            ZoneOffset.UTC, Locale.ROOT);, +        ZonedDateTime datetime = javaFunction.apply("2018-02-05T13:44:56.657+0100");, +        String expectedDateTime = DateFormatter.forPattern("yyyy-MM-dd'T'HH:mm:ss.SSSXXX").withZone(ZoneOffset.UTC).format(datetime);, +        assertThat(expectedDateTime, is("2018-02-05T12:44:56.657Z"));, +    }, +, +        assertThat(DateFormat.Iso8601.getFunction(null, ZoneOffset.UTC, null).apply("2001-01-01T00:00:00-0800").toString(),, +                equalTo("2001-01-01T08:00Z"));, +        assertThat(DateFormat.Iso8601.getFunction(null, ZoneOffset.UTC, null).apply("2001-01-01T00:00:00-0800").toString(),, +                equalTo("2001-01-01T08:00Z"));, +++ b/modules/ingest-common/src/test/java/org/elasticsearch/ingest/common/DateProcessorTests.java, +import java.util.Arrays;, +    public void testJavaPatternNoTimezone() {, +        DateProcessor dateProcessor = new DateProcessor(randomAlphaOfLength(10),, +            null, null,, +            "date_as_string", Arrays.asList("yyyy dd MM HH:mm:ss XXX"), "date_as_date");, +, +        Map<String, Object> document = new HashMap<>();, +        document.put("date_as_string", "2010 12 06 00:00:00 -02:00");, +        IngestDocument ingestDocument = RandomDocumentPicks.randomIngestDocument(random(), document);]