[+++ b/src/main/java/org/elasticsearch/cluster/action/index/NodeIndexDeletedAction.java, +import org.elasticsearch.common.unit.TimeValue;, +import org.elasticsearch.indices.IndicesService;, +    private final IndicesService indicesService;, +    public NodeIndexDeletedAction(Settings settings, ThreadPool threadPool, TransportService transportService, NodeEnvironment nodeEnv, IndicesService indicesService) {, +        this.indicesService = indicesService;, +            indicesService.processPendingDeletes(new Index(index), new TimeValue(30, TimeUnit.MINUTES));, +++ b/src/main/java/org/elasticsearch/cluster/action/index/NodeIndexDeletedAction.java, +import org.elasticsearch.common.unit.TimeValue;, +import org.elasticsearch.indices.IndicesService;, +    private final IndicesService indicesService;, +    public NodeIndexDeletedAction(Settings settings, ThreadPool threadPool, TransportService transportService, NodeEnvironment nodeEnv, IndicesService indicesService) {, +        this.indicesService = indicesService;, +            indicesService.processPendingDeletes(new Index(index), new TimeValue(30, TimeUnit.MINUTES));, +++ b/src/main/java/org/elasticsearch/index/IndexService.java, +                indicesServices.addPendingDelete(index(), lock.getShardId(), indexSettings);, +                logger.debug("{} failed to delete shard content - scheduled a retry", e, lock.getShardId());, +++ b/src/main/java/org/elasticsearch/cluster/action/index/NodeIndexDeletedAction.java, +import org.elasticsearch.common.unit.TimeValue;, +import org.elasticsearch.indices.IndicesService;, +    private final IndicesService indicesService;, +    public NodeIndexDeletedAction(Settings settings, ThreadPool threadPool, TransportService transportService, NodeEnvironment nodeEnv, IndicesService indicesService) {, +        this.indicesService = indicesService;, +            indicesService.processPendingDeletes(new Index(index), new TimeValue(30, TimeUnit.MINUTES));, +++ b/src/main/java/org/elasticsearch/index/IndexService.java, +                indicesServices.addPendingDelete(index(), lock.getShardId(), indexSettings);, +                logger.debug("{} failed to delete shard content - scheduled a retry", e, lock.getShardId());, +++ b/src/main/java/org/elasticsearch/indices/IndicesService.java, +import org.elasticsearch.common.unit.TimeValue;, +import java.util.*;, +import java.util.concurrent.*;, +    private final Map<Index, List<PendingDelete>> pendingDeletes = new HashMap<>();, +, +    /**, +     * Adds a pending delete for the given index., +     */, +    public void addPendingDelete(Index index, ShardId shardId, Settings settings) {, +        synchronized (pendingDeletes) {, +            List<PendingDelete> list = pendingDeletes.get(index);, +            if (list == null) {, +                list = new ArrayList<>();, +                pendingDeletes.put(index, list);, +            }, +            list.add(new PendingDelete(shardId, settings));, +        }, +    }, +, +    private static final class PendingDelete {, +        final ShardId shardId;, +        final Settings settings;, +, +        public PendingDelete(ShardId shardId, Settings settings) {, +            this.shardId = shardId;, +            this.settings = settings;, +        }, +, +        @Override, +        public String toString() {, +            return shardId.toString();, +        }, +    }, +, +    /**, +     * Processes all pending deletes for the given index. This method will acquire all locks for the given index and will, +     * process all pending deletes for this index. Pending deletes might occur if the OS doesn't allow deletion of files because, +     * they are used by a different process ie. on Windows where files might still be open by a virus scanner. On a shared, +     * filesystem a replica might not have been closed when the primary is deleted causing problems on delete calls so we, +     * schedule there deletes later., +     * @param index the index to process the pending deletes for, +     * @param timeout the timeout used for processing pending deletes, +     */, +    public void processPendingDeletes(Index index, TimeValue timeout) throws IOException {, +        final long startTime = System.currentTimeMillis();, +        final List<ShardLock> shardLocks = nodeEnv.lockAllForIndex(index, timeout.millis());, +        try {, +            Map<ShardId, ShardLock> locks = new HashMap<>();, +            for (ShardLock lock : shardLocks) {, +                locks.put(lock.getShardId(), lock);, +            }, +            final List<PendingDelete> remove;, +            synchronized (pendingDeletes) {, +                 remove = pendingDeletes.remove(index);, +            }, +            final long maxSleepTimeMs = 10 * 1000; // ensure we retry after 10 sec, +            long sleepTime = 10;, +            do {, +                if (remove == null || remove.isEmpty()) {, +                    break;, +                }, +                Iterator<PendingDelete> iterator = remove.iterator();, +                while (iterator.hasNext()) {, +                    PendingDelete delete = iterator.next();, +                    ShardLock shardLock = locks.get(delete.shardId);, +                    if (shardLock != null) {, +                        try {, +                            deleteShardStore("pending delete", shardLock, delete.settings);, +                        } catch (IOException ex) {, +                            logger.debug("{} retry pending delete", shardLock.getShardId(), ex);, +                        }, +                    } else {]