[+++ b/x-pack/plugin/sql/src/main/antlr/SqlBase.g4, +    : DECIMAL_VALUE         #decimalLiteral, +    | INTEGER_VALUE         #integerLiteral, +++ b/x-pack/plugin/sql/src/main/antlr/SqlBase.g4, +    : DECIMAL_VALUE         #decimalLiteral, +    | INTEGER_VALUE         #integerLiteral, +++ b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/parser/ExpressionBuilder.java, +                if (value instanceof Literal) { // Minus already processed together with literal number, +                    return value;, +                }, +        String ctxText = (hasMinusFromParent(ctx) ? "-" : "") + ctx.getText();, +            value = Double.parseDouble(ctxText);, +            throw new ParsingException(source(ctx), "Cannot parse number [{}]", ctxText);, +            throw new ParsingException(source(ctx), "Number [{}] is too large", ctxText);, +            throw new ParsingException(source(ctx), "[{}] cannot be parsed as a number (NaN)", ctxText);, +        String ctxText = (hasMinusFromParent(ctx) ? "-" : "") + ctx.getText();, +            value = Long.parseLong(ctxText);, +                BigInteger bi = new BigInteger(ctxText);, +                    throw new ParsingException(source(ctx), "Number [{}] is too large", ctxText);, +            throw new ParsingException(source(ctx), "Cannot parse number [{}]", ctxText);, +, +    private boolean hasMinusFromParent(SqlBaseParser.NumberContext ctx) {, +        ParserRuleContext parentCtx = ctx.getParent();, +        if (parentCtx != null && parentCtx instanceof SqlBaseParser.NumericLiteralContext) {, +            parentCtx = parentCtx.getParent();, +            if (parentCtx != null && parentCtx instanceof SqlBaseParser.ConstantDefaultContext) {, +                parentCtx = parentCtx.getParent();, +                if (parentCtx != null && parentCtx instanceof SqlBaseParser.ValueExpressionDefaultContext) {, +                    parentCtx = parentCtx.getParent();, +                    if (parentCtx != null && parentCtx instanceof SqlBaseParser.ArithmeticUnaryContext) {, +                        return ((ArithmeticUnaryContext) parentCtx).MINUS() != null;, +                    }, +                }, +            }, +        }, +        return false;, +    }, +++ b/x-pack/plugin/sql/src/main/antlr/SqlBase.g4, +    : DECIMAL_VALUE         #decimalLiteral, +    | INTEGER_VALUE         #integerLiteral, +++ b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/parser/ExpressionBuilder.java, +                if (value instanceof Literal) { // Minus already processed together with literal number, +                    return value;, +                }, +        String ctxText = (hasMinusFromParent(ctx) ? "-" : "") + ctx.getText();, +            value = Double.parseDouble(ctxText);, +            throw new ParsingException(source(ctx), "Cannot parse number [{}]", ctxText);, +            throw new ParsingException(source(ctx), "Number [{}] is too large", ctxText);, +            throw new ParsingException(source(ctx), "[{}] cannot be parsed as a number (NaN)", ctxText);, +        String ctxText = (hasMinusFromParent(ctx) ? "-" : "") + ctx.getText();, +            value = Long.parseLong(ctxText);, +                BigInteger bi = new BigInteger(ctxText);, +                    throw new ParsingException(source(ctx), "Number [{}] is too large", ctxText);, +            throw new ParsingException(source(ctx), "Cannot parse number [{}]", ctxText);, +, +    private boolean hasMinusFromParent(SqlBaseParser.NumberContext ctx) {, +        ParserRuleContext parentCtx = ctx.getParent();, +        if (parentCtx != null && parentCtx instanceof SqlBaseParser.NumericLiteralContext) {, +            parentCtx = parentCtx.getParent();, +            if (parentCtx != null && parentCtx instanceof SqlBaseParser.ConstantDefaultContext) {, +                parentCtx = parentCtx.getParent();, +                if (parentCtx != null && parentCtx instanceof SqlBaseParser.ValueExpressionDefaultContext) {, +                    parentCtx = parentCtx.getParent();, +                    if (parentCtx != null && parentCtx instanceof SqlBaseParser.ArithmeticUnaryContext) {, +                        return ((ArithmeticUnaryContext) parentCtx).MINUS() != null;, +                    }, +                }, +            }, +        }, +        return false;, +    }, +++ b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/parser/SqlBaseLexer.java, +    "\u0320\5\u00cfh\2\u031e\u0320\7a\2\2\u031f\u031c\3\2\2\2\u031f\u031d\3"+, +    "\2\2\2\u031f\u031e\3\2\2\2\u0320\u0321\3\2\2\2\u0321\u031f\3\2\2\2\u0321"+, +++ b/x-pack/plugin/sql/src/main/antlr/SqlBase.g4, +    : DECIMAL_VALUE         #decimalLiteral, +    | INTEGER_VALUE         #integerLiteral, +++ b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/parser/ExpressionBuilder.java, +                if (value instanceof Literal) { // Minus already processed together with literal number, +                    return value;, +                }, +        String ctxText = (hasMinusFromParent(ctx) ? "-" : "") + ctx.getText();, +            value = Double.parseDouble(ctxText);, +            throw new ParsingException(source(ctx), "Cannot parse number [{}]", ctxText);, +            throw new ParsingException(source(ctx), "Number [{}] is too large", ctxText);, +            throw new ParsingException(source(ctx), "[{}] cannot be parsed as a number (NaN)", ctxText);, +        String ctxText = (hasMinusFromParent(ctx) ? "-" : "") + ctx.getText();, +            value = Long.parseLong(ctxText);, +                BigInteger bi = new BigInteger(ctxText);, +                    throw new ParsingException(source(ctx), "Number [{}] is too large", ctxText);, +            throw new ParsingException(source(ctx), "Cannot parse number [{}]", ctxText);, +, +    private boolean hasMinusFromParent(SqlBaseParser.NumberContext ctx) {, +        ParserRuleContext parentCtx = ctx.getParent();, +        if (parentCtx != null && parentCtx instanceof SqlBaseParser.NumericLiteralContext) {, +            parentCtx = parentCtx.getParent();, +            if (parentCtx != null && parentCtx instanceof SqlBaseParser.ConstantDefaultContext) {, +                parentCtx = parentCtx.getParent();, +                if (parentCtx != null && parentCtx instanceof SqlBaseParser.ValueExpressionDefaultContext) {, +                    parentCtx = parentCtx.getParent();]