[+++ b/core/src/main/java/org/elasticsearch/common/settings/AbstractScopedSettings.java, +import java.util.function.Predicate;, +        final Predicate<String> canUpdate = (key) -> (onlyDynamic == false && get(key) != null) || hasDynamicSetting(key);, +        final Predicate<String> canRemove = (key) ->( // we can delete if, +            onlyDynamic && hasDynamicSetting(key)  // it's a dynamicSetting and we only do dynamic settings, +            || get(key) == null && key.startsWith(ARCHIVED_SETTINGS_PREFIX) // the setting is not registered AND it's been archived, +            || (onlyDynamic == false && get(key) != null)); // if it's not dynamic AND we have a key, +            if (entry.getValue() == null && (canRemove.test(entry.getKey()) || entry.getKey().endsWith("*"))) {, +                // this either accepts null values that suffice the canUpdate test OR wildcard expressions (key ends with *), +                // we don't validate if there is any dynamic setting with that prefix yet we could do in the future, +                // we don't set changed here it's set after we apply deletes below if something actually changed, +            } else if (entry.getValue() != null && canUpdate.test(entry.getKey())) {, +        changed |= applyDeletes(toRemove, target, canRemove);, +    private static boolean applyDeletes(Set<String> deletes, Settings.Builder builder, Predicate<String> canRemove) {, +                if (Regex.simpleMatch(entry, key) && canRemove.test(key)) {, +                    // we have to re-check with canRemove here since we might have a wildcard expression foo.* that matches, +                    // dynamic as well as static settings if that is the case we might remove static settings since we resolve the, +                    // wildcards late, +++ b/core/src/main/java/org/elasticsearch/common/settings/AbstractScopedSettings.java, +import java.util.function.Predicate;, +        final Predicate<String> canUpdate = (key) -> (onlyDynamic == false && get(key) != null) || hasDynamicSetting(key);, +        final Predicate<String> canRemove = (key) ->( // we can delete if, +            onlyDynamic && hasDynamicSetting(key)  // it's a dynamicSetting and we only do dynamic settings, +            || get(key) == null && key.startsWith(ARCHIVED_SETTINGS_PREFIX) // the setting is not registered AND it's been archived, +            || (onlyDynamic == false && get(key) != null)); // if it's not dynamic AND we have a key, +            if (entry.getValue() == null && (canRemove.test(entry.getKey()) || entry.getKey().endsWith("*"))) {, +                // this either accepts null values that suffice the canUpdate test OR wildcard expressions (key ends with *), +                // we don't validate if there is any dynamic setting with that prefix yet we could do in the future, +                // we don't set changed here it's set after we apply deletes below if something actually changed, +            } else if (entry.getValue() != null && canUpdate.test(entry.getKey())) {, +        changed |= applyDeletes(toRemove, target, canRemove);, +    private static boolean applyDeletes(Set<String> deletes, Settings.Builder builder, Predicate<String> canRemove) {, +                if (Regex.simpleMatch(entry, key) && canRemove.test(key)) {, +                    // we have to re-check with canRemove here since we might have a wildcard expression foo.* that matches, +                    // dynamic as well as static settings if that is the case we might remove static settings since we resolve the, +                    // wildcards late, +++ b/core/src/test/java/org/elasticsearch/common/settings/ScopedSettingsTests.java, +    public void testResetSetting() {, +        Setting<Integer> dynamicSetting = Setting.intSetting("some.dyn.setting", 1, Property.Dynamic, Property.NodeScope);, +        Setting<Integer> staticSetting = Setting.intSetting("some.static.setting", 1, Property.NodeScope);, +        Settings currentSettings = Settings.builder().put("some.dyn.setting", 5).put("some.static.setting", 6).put("archived.foo.bar", 9), +            .build();, +        ClusterSettings service = new ClusterSettings(currentSettings, +            , new HashSet<>(Arrays.asList(dynamicSetting, staticSetting)));, +, +        expectThrows(IllegalArgumentException.class, () ->, +        service.updateDynamicSettings(Settings.builder().put("some.dyn.setting", 8).putNull("some.static.setting").build(),, +            Settings.builder().put(currentSettings), Settings.builder(), "node"));, +, +        Settings.Builder target = Settings.builder().put(currentSettings);, +        Settings.Builder update = Settings.builder();, +        assertTrue(service.updateDynamicSettings(Settings.builder().put("some.dyn.setting", 8).build(),, +            target, update, "node"));, +        assertEquals(8, dynamicSetting.get(target.build()).intValue());, +        assertEquals(6, staticSetting.get(target.build()).intValue());, +        assertEquals(9, target.build().getAsInt("archived.foo.bar", null).intValue());, +, +        target = Settings.builder().put(currentSettings);, +        update = Settings.builder();, +        assertTrue(service.updateDynamicSettings(Settings.builder().putNull("some.dyn.setting").build(),, +            target, update, "node"));, +        assertEquals(1, dynamicSetting.get(target.build()).intValue());, +        assertEquals(6, staticSetting.get(target.build()).intValue());, +        assertEquals(9, target.build().getAsInt("archived.foo.bar", null).intValue());, +, +        target = Settings.builder().put(currentSettings);, +        update = Settings.builder();, +        assertTrue(service.updateDynamicSettings(Settings.builder().putNull("archived.foo.bar").build(),, +            target, update, "node"));, +        assertEquals(5, dynamicSetting.get(target.build()).intValue());, +        assertEquals(6, staticSetting.get(target.build()).intValue());, +        assertNull(target.build().getAsInt("archived.foo.bar", null));, +, +        target = Settings.builder().put(currentSettings);, +        update = Settings.builder();, +        assertTrue(service.updateDynamicSettings(Settings.builder().putNull("some.*").build(),, +            target, update, "node"));, +        assertEquals(1, dynamicSetting.get(target.build()).intValue());, +        assertEquals(6, staticSetting.get(target.build()).intValue());, +        assertEquals(9, target.build().getAsInt("archived.foo.bar", null).intValue());, +, +        target = Settings.builder().put(currentSettings);, +        update = Settings.builder();, +        assertTrue(service.updateDynamicSettings(Settings.builder().putNull("*").build(),, +            target, update, "node"));, +        assertEquals(1, dynamicSetting.get(target.build()).intValue());, +        assertEquals(6, staticSetting.get(target.build()).intValue());, +        assertNull(target.build().getAsInt("archived.foo.bar", null));, +    }, +]