[+++ b/core/src/main/java/org/elasticsearch/search/sort/GeoDistanceSortBuilder.java, +import org.elasticsearch.common.geo.GeoUtils;, +import org.elasticsearch.common.io.stream.NamedWriteable;, +import org.elasticsearch.common.io.stream.StreamInput;, +import org.elasticsearch.common.io.stream.StreamOutput;, +import org.elasticsearch.common.xcontent.ToXContent;, +import org.elasticsearch.common.xcontent.XContentParser;, +import org.elasticsearch.index.query.QueryParseContext;, +import org.elasticsearch.search.MultiValueMode;, +import java.util.Objects;, +public class GeoDistanceSortBuilder extends SortBuilder implements ToXContent, NamedWriteable<GeoDistanceSortBuilder>, SortElementParserTemp<GeoDistanceSortBuilder> {, +    public static final String NAME = "_geo_distance";, +    public static final boolean DEFAULT_COERCE = false;, +    public static final boolean DEFAULT_IGNORE_MALFORMED = false;, +    static final GeoDistanceSortBuilder PROTOTYPE = new GeoDistanceSortBuilder("", -1, -1);, +, +    private final String fieldName;, +    private GeoDistance geoDistance = GeoDistance.DEFAULT;, +    private DistanceUnit unit = DistanceUnit.DEFAULT;, +    private SortOrder order = SortOrder.ASC;, +    , +    // TODO there is an enum that covers that parameter which we should be using here, +    private String sortMode = null;, +    @SuppressWarnings("rawtypes"), +    , +    // TODO switch to GeoValidationMethod enum, +    private boolean coerce = DEFAULT_COERCE;, +    private boolean ignoreMalformed = DEFAULT_IGNORE_MALFORMED;, +     * @param points The points to create the range distance facets from., +    public GeoDistanceSortBuilder(String fieldName, GeoPoint... points) {, +        if (points.length == 0) {, +            throw new IllegalArgumentException("Geo distance sorting needs at least one point.");, +        }, +        this.points.addAll(Arrays.asList(points));, +    }, +, +    /**, +     * Constructs a new distance based sort on a geo point like field., +     *, +     * @param fieldName The geo point like field name., +     * @param lat Latitude of the point to create the range distance facets from., +     * @param lon Longitude of the point to create the range distance facets from., +     */, +    public GeoDistanceSortBuilder(String fieldName, double lat, double lon) {, +        this(fieldName, new GeoPoint(lat, lon));, +    }, +, +    /**, +     * Constructs a new distance based sort on a geo point like field., +     *, +     * @param fieldName The geo point like field name., +     * @param geohashes The points to create the range distance facets from., +     */, +    public GeoDistanceSortBuilder(String fieldName, String ... geohashes) {, +        if (geohashes.length == 0) {, +            throw new IllegalArgumentException("Geo distance sorting needs at least one point.");, +        }, +        for (String geohash : geohashes) {, +            this.points.add(GeoPoint.fromGeohash(geohash));, +        }, +        this.fieldName = fieldName;, +    }, +    , +    /**, +     * Copy constructor., +     * */, +    GeoDistanceSortBuilder(GeoDistanceSortBuilder original) {, +        this.fieldName = original.fieldName();, +        this.points.addAll(original.points);, +        this.geoDistance = original.geoDistance;, +        this.unit = original.unit;, +        this.order = original.order;, +        this.sortMode = original.sortMode;, +        this.nestedFilter = original.nestedFilter;, +        this.nestedPath = original.nestedPath;, +        this.coerce = original.coerce;, +        this.ignoreMalformed = original.ignoreMalformed;, +    }, +    , +    /**, +     * Returns the geo point like field the distance based sort operates on., +     * */, +    public String fieldName() {, +        return this.fieldName;, +     * Returns the points to create the range distance facets from., +    public GeoPoint[] points() {, +        return this.points.toArray(new GeoPoint[this.points.size()]);, +    }, +, +    /**, +     * The geohash of the geo point to create the range distance facets from., +     * , +     * Deprecated - please use points(GeoPoint... points) instead., +     */, +    @Deprecated, +        for (String geohash : geohashes) {, +            this.points.add(GeoPoint.fromGeohash(geohash));, +        }, +     * Returns the geo distance type used to compute the distance., +     */]