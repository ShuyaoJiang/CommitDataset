[+++ b/server/src/main/java/org/elasticsearch/cluster/coordination/Coordinator.java, +                    logger.debug("updateMaxTermSeen: maxTermSeen = {} > currentTerm = {}, enqueueing term bump", maxTermSeen, currentTerm);, +                        logger.debug("updateMaxTermSeen: maxTermSeen = {} > currentTerm = {}, bumping term", maxTermSeen, currentTerm);, +++ b/server/src/main/java/org/elasticsearch/cluster/coordination/Coordinator.java, +                    logger.debug("updateMaxTermSeen: maxTermSeen = {} > currentTerm = {}, enqueueing term bump", maxTermSeen, currentTerm);, +                        logger.debug("updateMaxTermSeen: maxTermSeen = {} > currentTerm = {}, bumping term", maxTermSeen, currentTerm);, +++ b/server/src/main/java/org/elasticsearch/transport/TransportService.java, +            getExecutorService().execute(new Runnable() {, +                @Override, +                public void run() {, +                        holderToNotify.handler().handleException(, +                            new NodeDisconnectedException(connection.getNode(), holderToNotify.action()));, +                    }, +                }, +, +                @Override, +                public String toString() {, +                    return "onConnectionClosed(" + connection.getNode() + ")";, +++ b/server/src/main/java/org/elasticsearch/cluster/coordination/Coordinator.java, +                    logger.debug("updateMaxTermSeen: maxTermSeen = {} > currentTerm = {}, enqueueing term bump", maxTermSeen, currentTerm);, +                        logger.debug("updateMaxTermSeen: maxTermSeen = {} > currentTerm = {}, bumping term", maxTermSeen, currentTerm);, +++ b/server/src/main/java/org/elasticsearch/transport/TransportService.java, +            getExecutorService().execute(new Runnable() {, +                @Override, +                public void run() {, +                        holderToNotify.handler().handleException(, +                            new NodeDisconnectedException(connection.getNode(), holderToNotify.action()));, +                    }, +                }, +, +                @Override, +                public String toString() {, +                    return "onConnectionClosed(" + connection.getNode() + ")";, +++ b/server/src/test/java/org/elasticsearch/cluster/coordination/CoordinatorTests.java, +import org.elasticsearch.common.Nullable;, +import static java.util.Collections.emptyList;, +        assertEquals(0, newNode.getLastAppliedClusterState().version());, +    public void testDiscoveryUsesNodesFromLastClusterState() {, +        final Cluster cluster = new Cluster(randomIntBetween(3, 5));, +        cluster.runRandomly();, +        cluster.stabilise();, +, +        final ClusterNode partitionedNode = cluster.getAnyNode();, +        if (randomBoolean()) {, +            logger.info("--> blackholing {}", partitionedNode);, +            partitionedNode.blackhole();, +        } else {, +            logger.info("--> disconnecting {}", partitionedNode);, +            partitionedNode.disconnect();, +        }, +        cluster.setEmptyUnicastHostsList();, +        cluster.stabilise();, +, +        partitionedNode.heal();, +        cluster.runRandomly(false);, +        cluster.stabilise();, +    }, +, +            // perhaps there is an election collision requiring another publication (which times out) and a term bump, +            + defaultMillis(PUBLISH_TIMEOUT_SETTING) + DEFAULT_ELECTION_DELAY, +, +        private final Function<DiscoveryNode, MockPersistedState> defaultPersistedStateSupplier = MockPersistedState::new;, +, +        @Nullable // null means construct a list from all the current nodes, +        private List<TransportAddress> unicastHostsList;, +            runRandomly(true);, +        }, +, +        void runRandomly(boolean allowReboots) {, +                    } else if (allowReboots && rarely()) {, +        void setEmptyUnicastHostsList() {, +            unicastHostsList = emptyList();, +        }, +, +                onNode(() -> {, +                });, +            return unicastHostsList != null ? unicastHostsList, +                : clusterNodes.stream().map(ClusterNode::getLocalNode).map(DiscoveryNode::getAddress).collect(Collectors.toList());, +++ b/server/src/main/java/org/elasticsearch/cluster/coordination/Coordinator.java, +                    logger.debug("updateMaxTermSeen: maxTermSeen = {} > currentTerm = {}, enqueueing term bump", maxTermSeen, currentTerm);, +                        logger.debug("updateMaxTermSeen: maxTermSeen = {} > currentTerm = {}, bumping term", maxTermSeen, currentTerm);, +++ b/server/src/main/java/org/elasticsearch/transport/TransportService.java, +            getExecutorService().execute(new Runnable() {, +                @Override, +                public void run() {, +                        holderToNotify.handler().handleException(, +                            new NodeDisconnectedException(connection.getNode(), holderToNotify.action()));, +                    }, +                }, +, +                @Override, +                public String toString() {, +                    return "onConnectionClosed(" + connection.getNode() + ")";, +++ b/server/src/test/java/org/elasticsearch/cluster/coordination/CoordinatorTests.java, +import org.elasticsearch.common.Nullable;, +import static java.util.Collections.emptyList;, +        assertEquals(0, newNode.getLastAppliedClusterState().version());, +    public void testDiscoveryUsesNodesFromLastClusterState() {, +        final Cluster cluster = new Cluster(randomIntBetween(3, 5));, +        cluster.runRandomly();]