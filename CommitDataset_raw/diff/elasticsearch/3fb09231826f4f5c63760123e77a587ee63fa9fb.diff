[+++ b/libs/x-content/src/main/java/org/elasticsearch/common/xcontent/XContentFactory.java, +    static final int GUESS_HEADER_LENGTH = 20;, +        if (length > 2, +                && first == SmileConstants.HEADER_BYTE_1, +                && content.charAt(1) == SmileConstants.HEADER_BYTE_2, +                && content.charAt(2) == SmileConstants.HEADER_BYTE_3) {, +        /*, +         * We need to guess the content type. To do this, we look for the first non-whitespace character and then try to guess the content, +         * type on the GUESS_HEADER_LENGTH bytes that follow. We do this in a way that does not modify the initial read position in the, +         * underlying input stream. This is why the input stream must support mark/reset and why we repeatedly mark the read position and, +         * reset., +         */, +        si.mark(Integer.MAX_VALUE);, +            // scan until we find the first non-whitespace character or the end of the stream, +            int current;, +            do {, +                current = si.read();, +                if (current == -1) {, +                    return null;, +                }, +            } while (Character.isWhitespace((char) current));, +            // now guess the content type off the next GUESS_HEADER_LENGTH bytes including the current byte, +            firstBytes[0] = (byte) current;, +            int read = 1;, +, +        if (length > 2, +                && first == SmileConstants.HEADER_BYTE_1, +                && bytes[offset + 1] == SmileConstants.HEADER_BYTE_2, +                && bytes[offset + 2] == SmileConstants.HEADER_BYTE_3) {, +++ b/libs/x-content/src/main/java/org/elasticsearch/common/xcontent/XContentFactory.java, +    static final int GUESS_HEADER_LENGTH = 20;, +        if (length > 2, +                && first == SmileConstants.HEADER_BYTE_1, +                && content.charAt(1) == SmileConstants.HEADER_BYTE_2, +                && content.charAt(2) == SmileConstants.HEADER_BYTE_3) {, +        /*, +         * We need to guess the content type. To do this, we look for the first non-whitespace character and then try to guess the content, +         * type on the GUESS_HEADER_LENGTH bytes that follow. We do this in a way that does not modify the initial read position in the, +         * underlying input stream. This is why the input stream must support mark/reset and why we repeatedly mark the read position and, +         * reset., +         */, +        si.mark(Integer.MAX_VALUE);, +            // scan until we find the first non-whitespace character or the end of the stream, +            int current;, +            do {, +                current = si.read();, +                if (current == -1) {, +                    return null;, +                }, +            } while (Character.isWhitespace((char) current));, +            // now guess the content type off the next GUESS_HEADER_LENGTH bytes including the current byte, +            firstBytes[0] = (byte) current;, +            int read = 1;, +, +        if (length > 2, +                && first == SmileConstants.HEADER_BYTE_1, +                && bytes[offset + 1] == SmileConstants.HEADER_BYTE_2, +                && bytes[offset + 2] == SmileConstants.HEADER_BYTE_3) {, +++ b/server/src/test/java/org/elasticsearch/common/xcontent/XContentFactoryTests.java, +import java.util.Arrays;, +        final BytesReference bytes;, +        if (type == XContentType.JSON && randomBoolean()) {, +            final int length = randomIntBetween(0, 8 * XContentFactory.GUESS_HEADER_LENGTH);, +            final String content = Strings.toString(builder);, +            final StringBuilder sb = new StringBuilder(length + content.length());, +            final char[] chars = new char[length];, +            Arrays.fill(chars, ' ');, +            sb.append(new String(chars)).append(content);, +            bytes = new BytesArray(sb.toString());, +        } else {, +            bytes = BytesReference.bytes(builder);, +        }, +, +        assertThat(XContentHelper.xContentType(bytes), equalTo(type));, +        assertThat(XContentFactory.xContentType(bytes.streamInput()), equalTo(type));]