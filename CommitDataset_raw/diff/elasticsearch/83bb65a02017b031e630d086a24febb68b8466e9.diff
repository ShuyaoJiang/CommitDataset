[+++ b/src/main/java/org/elasticsearch/common/lucene/LoggerInfoStream.java, +    public LoggerInfoStream(ESLogger parentLogger) {, +        logger = Loggers.getLogger(parentLogger, ".lucene.iw");, +        ifdLogger = Loggers.getLogger(parentLogger, ".lucene.iw.ifd");, +++ b/src/main/java/org/elasticsearch/common/lucene/LoggerInfoStream.java, +    public LoggerInfoStream(ESLogger parentLogger) {, +        logger = Loggers.getLogger(parentLogger, ".lucene.iw");, +        ifdLogger = Loggers.getLogger(parentLogger, ".lucene.iw.ifd");, +++ b/src/main/java/org/elasticsearch/index/engine/Engine.java, +public interface Engine extends CloseableComponent {, +    ShardId shardId();, +, +    /** Stops the engine but allow to re-start it */, +    void stop() throws EngineException;, +, +, +++ b/src/main/java/org/elasticsearch/common/lucene/LoggerInfoStream.java, +    public LoggerInfoStream(ESLogger parentLogger) {, +        logger = Loggers.getLogger(parentLogger, ".lucene.iw");, +        ifdLogger = Loggers.getLogger(parentLogger, ".lucene.iw.ifd");, +++ b/src/main/java/org/elasticsearch/index/engine/Engine.java, +public interface Engine extends CloseableComponent {, +    ShardId shardId();, +, +    /** Stops the engine but allow to re-start it */, +    void stop() throws EngineException;, +, +, +++ b/src/main/java/org/elasticsearch/index/engine/internal/InternalEngine.java, +import org.apache.lucene.search.*;, +import org.elasticsearch.index.engine.*;, +import java.util.*;, +public class InternalEngine implements Engine {, +, +    protected final ESLogger logger;, +    protected final ShardId shardId;, +    private volatile boolean compoundOnFlush;, +    private volatile long gcDeletesInMillis;, +    private final FailedEngineListener failedEngineListener;, +    private final IndexThrottle throttle;, +    public InternalEngine(ShardId shardId, ESLogger logger, CodecService codecService, ThreadPool threadPool,, +                          ShardIndexingService indexingService, @Nullable IndicesWarmer warmer,, +                          AnalysisService analysisService, SimilarityService similarityService,, +                          boolean enableGcDeletes, long gcDeletesInMillis, ByteSizeValue indexingBufferSize, String codecName,, +                          boolean compoundOnFlush, int indexConcurrency, boolean optimizeAutoGenerateId, boolean failEngineOnCorruption,, +                          FailedEngineListener failedEngineListener) throws EngineException {, +        this.shardId = shardId;, +        this.logger = logger;, +        this.gcDeletesInMillis = gcDeletesInMillis;, +        this.enableGcDeletes = enableGcDeletes;, +        this.indexingBufferSize = indexingBufferSize;, +        this.codecName = codecName;, +        this.compoundOnFlush = compoundOnFlush;, +        this.indexConcurrency = indexConcurrency;, +        this.optimizeAutoGenerateId = optimizeAutoGenerateId;, +        this.failEngineOnCorruption = failEngineOnCorruption;, +        this.failedEngineListener = failedEngineListener;, +        // will be decremented in close(), +, +        throttle = new IndexThrottle();, +        throw new UnsupportedOperationException("addFailedEngineListener is not supported by InternalEngineImpl. Use InternalEngine.");, +, +    @Override, +    public void stop() throws EngineException {, +        throw new UnsupportedOperationException("stop() is not supported by InternalEngineImpl. Use InternalEngine.");, +    }, +, +    public ShardId shardId() {, +        return shardId;, +    }, +, +    @Override, +        return InternalEngineHolder.DEFAULT_REFRESH_ITERVAL;, +    public void updateSettings(final long gcDeletesInMillis, final boolean compoundOnFlush, boolean failEngineOnCorruption, final int indexConcurrency, final String codecName) {, +        ensureOpen();, +        if (this.gcDeletesInMillis != gcDeletesInMillis) {, +            logger.trace("[impl] updating gcDeletesInMillis from [{}] to [{}]", this.gcDeletesInMillis, gcDeletesInMillis);, +            this.gcDeletesInMillis = gcDeletesInMillis;, +        }, +        if (this.compoundOnFlush != compoundOnFlush) {, +            this.compoundOnFlush = compoundOnFlush;, +            logger.trace("[impl] updating compoundOnFlush from [{}] to [{}]", this.compoundOnFlush, compoundOnFlush);, +            indexWriter.getConfig().setUseCompoundFile(compoundOnFlush);, +        }, +        if (this.failEngineOnCorruption != failEngineOnCorruption) {, +            logger.trace("[impl] updating failEngineOnCorruption from [{}] to [{}]", this.failEngineOnCorruption, failEngineOnCorruption);, +            this.failEngineOnCorruption = failEngineOnCorruption;, +        }, +        if (indexConcurrency != this.indexConcurrency || !codecName.equals(this.codecName)) {, +            boolean requiresFlushing = false;, +            try (InternalLock _ = readLock.acquire()) {, +                if (indexConcurrency != this.indexConcurrency) {, +                    logger.trace("[impl] updating indexConcurrency from [{}] to [{}]", this.indexConcurrency, indexConcurrency);, +                    this.indexConcurrency = indexConcurrency;, +                    // we have to flush in this case, since it only applies on a new index writer, +                    requiresFlushing = true;, +                }, +                if (!codecName.equals(this.codecName)) {, +                    logger.trace("[impl] updating codecName from [{}] to [{}]", this.codecName, codecName);, +                    this.codecName = codecName;]