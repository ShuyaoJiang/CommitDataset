[+++ b/core/src/test/java/org/elasticsearch/search/aggregations/AggregatorTestCase.java, +            if (aggs.isEmpty()) {, +                return null;, +            } else {, +                A internalAgg = (A) aggs.get(0).doReduce(aggs, new InternalAggregation.ReduceContext(root.context().bigArrays(), null));, +    }, +++ b/core/src/test/java/org/elasticsearch/search/aggregations/AggregatorTestCase.java, +            if (aggs.isEmpty()) {, +                return null;, +            } else {, +                A internalAgg = (A) aggs.get(0).doReduce(aggs, new InternalAggregation.ReduceContext(root.context().bigArrays(), null));, +    }, +++ b/core/src/test/java/org/elasticsearch/search/aggregations/bucket/histogram/DateHistogramAggregatorTests.java, +/*, + * Licensed to Elasticsearch under one or more contributor, + * license agreements. See the NOTICE file distributed with, + * this work for additional information regarding copyright, + * ownership. Elasticsearch licenses this file to you under, + * the Apache License, Version 2.0 (the "License"); you may, + * not use this file except in compliance with the License., + * You may obtain a copy of the License at, + *, + *    http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing,, + * software distributed under the License is distributed on an, + * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY, + * KIND, either express or implied.  See the License for the, + * specific language governing permissions and limitations, + * under the License., + */, +, +package org.elasticsearch.search.aggregations.bucket.histogram;, +, +import org.apache.lucene.document.Document;, +import org.apache.lucene.document.LongPoint;, +import org.apache.lucene.document.SortedNumericDocValuesField;, +import org.apache.lucene.index.DirectoryReader;, +import org.apache.lucene.index.IndexReader;, +import org.apache.lucene.index.RandomIndexWriter;, +import org.apache.lucene.search.IndexSearcher;, +import org.apache.lucene.search.MatchAllDocsQuery;, +import org.apache.lucene.search.MatchNoDocsQuery;, +import org.apache.lucene.search.Query;, +import org.apache.lucene.store.Directory;, +import org.elasticsearch.index.mapper.DateFieldMapper;, +import org.elasticsearch.search.aggregations.AggregatorTestCase;, +, +import java.io.IOException;, +import java.util.Arrays;, +import java.util.Collections;, +import java.util.List;, +import java.util.function.Consumer;, +, +public class DateHistogramAggregatorTests extends AggregatorTestCase {, +, +    private static final String DATE_FIELD = "date";, +    private static final String INSTANT_FIELD = "instant";, +, +    private static final List<String> dataset = Arrays.asList(, +            "2010-03-12T01:07:45",, +            "2010-04-27T03:43:34",, +            "2012-05-18T04:11:00",, +            "2013-05-29T05:11:31",, +            "2013-10-31T08:24:05",, +            "2015-02-13T13:09:32",, +            "2015-06-24T13:47:43",, +            "2015-11-13T16:14:34",, +            "2016-03-04T17:09:50",, +            "2017-12-12T22:55:46");, +, +    public void testMatchNoDocs() throws IOException {, +        testBothCases(new MatchNoDocsQuery(), dataset,, +                aggregation -> aggregation.dateHistogramInterval(DateHistogramInterval.YEAR).field(DATE_FIELD),, +                histogram -> assertEquals(0, histogram.getBuckets().size()), +        );, +    }, +, +    public void testMatchAllDocs() throws IOException {, +        Query query = new MatchAllDocsQuery();, +, +        testSearchCase(query, dataset,, +                aggregation -> aggregation.dateHistogramInterval(DateHistogramInterval.YEAR).field(DATE_FIELD),, +                histogram -> assertEquals(6, histogram.getBuckets().size()), +        );, +        testSearchAndReduceCase(query, dataset,, +                aggregation -> aggregation.dateHistogramInterval(DateHistogramInterval.YEAR).field(DATE_FIELD),, +                histogram -> assertEquals(8, histogram.getBuckets().size()), +        );, +        testBothCases(query, dataset,, +                aggregation -> aggregation.dateHistogramInterval(DateHistogramInterval.YEAR).field(DATE_FIELD).minDocCount(1L),, +                histogram -> assertEquals(6, histogram.getBuckets().size()), +        );, +    }, +, +    public void testNoDocs() throws IOException {, +        Query query = new MatchNoDocsQuery();, +        List<String> dates = Collections.emptyList();, +        Consumer<DateHistogramAggregationBuilder> aggregation = agg ->, +                agg.dateHistogramInterval(DateHistogramInterval.YEAR).field(DATE_FIELD);]