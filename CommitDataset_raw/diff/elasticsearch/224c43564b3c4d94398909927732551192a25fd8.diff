[+++ b/src/test/java/org/elasticsearch/bwcompat/OldIndexBackwardsCompatibilityTests.java, +import org.apache.lucene.index.IndexWriter;, +import java.io.IOException;, +import java.nio.file.FileVisitResult;, +import java.nio.file.FileVisitor;, +import java.nio.file.SimpleFileVisitor;, +import java.nio.file.attribute.BasicFileAttributes;, +    static Path singleDataPath;, +    static Path[] multiDataPath;, +        singleDataPath = null;, +        multiDataPath = null;, +        Path baseTempDir = newTempDirPath(LifecycleScope.SUITE);, +        // start single data path node, +            .put("path.data", baseTempDir.resolve("single-path").toAbsolutePath()), +        ListenableFuture<String> singleDataPathNode = internalCluster().startNodeAsync(nodeSettings.build());, +        // start multi data path node, +        nodeSettings = ImmutableSettings.builder(), +            .put("path.data", baseTempDir.resolve("multi-path1").toAbsolutePath() + "," + baseTempDir.resolve("multi-path2").toAbsolutePath()), +            .put("node.master", false); // workaround for dangling index loading issue when node is master, +        ListenableFuture<String> multiDataPathNode = internalCluster().startNodeAsync(nodeSettings.build());, +, +        // find single data path dir, +        Path[] nodePaths = internalCluster().getInstance(NodeEnvironment.class, singleDataPathNode.get()).nodeDataPaths();, +        singleDataPath = nodePaths[0].resolve(NodeEnvironment.INDICES_FOLDER);, +        assertFalse(Files.exists(singleDataPath));, +        Files.createDirectories(singleDataPath);, +        logger.info("--> Single data path: " + singleDataPath.toString());, +, +        // find multi data path dirs, +        nodePaths = internalCluster().getInstance(NodeEnvironment.class, multiDataPathNode.get()).nodeDataPaths();, +        assertEquals(2, nodePaths.length);, +        multiDataPath = new Path[] {nodePaths[0].resolve(NodeEnvironment.INDICES_FOLDER),, +                                   nodePaths[1].resolve(NodeEnvironment.INDICES_FOLDER)};, +        assertFalse(Files.exists(multiDataPath[0]));, +        assertFalse(Files.exists(multiDataPath[1]));, +        Files.createDirectories(multiDataPath[0]);, +        Files.createDirectories(multiDataPath[1]);, +        logger.info("--> Multi data paths: " + multiDataPath[0].toString() + ", " + multiDataPath[1].toString());, +        if (randomBoolean()) {, +            logger.info("--> injecting index [{}] into single data path", indexName);, +            copyIndex(src, indexName, singleDataPath);, +        } else {, +            logger.info("--> injecting index [{}] into multi data path", indexName);, +            copyIndex(src, indexName, multiDataPath);, +        }, +    // randomly distribute the files from src over dests paths, +    void copyIndex(final Path src, final String indexName, final Path... dests) throws IOException {, +        for (Path dest : dests) {, +            Path indexDir = dest.resolve(indexName);, +            assertFalse(Files.exists(indexDir));, +            Files.createDirectories(indexDir);, +        }, +        Files.walkFileTree(src, new SimpleFileVisitor<Path>() {, +            @Override, +            public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) throws IOException {, +                Path relativeDir = src.relativize(dir);, +                for (Path dest : dests) {, +                    Path destDir = dest.resolve(indexName).resolve(relativeDir);, +                    Files.createDirectories(destDir);, +                }, +                return FileVisitResult.CONTINUE;, +            }, +            @Override, +            public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {, +                if (file.getFileName().toString().equals(IndexWriter.WRITE_LOCK_NAME)) {, +                    // skip lock file, we don't need it, +                    logger.trace("Skipping lock file: " + file.toString());, +                    return FileVisitResult.CONTINUE;, +                }, +, +                Path relativeFile = src.relativize(file);, +                Path destFile = dests[randomInt(dests.length - 1)].resolve(indexName).resolve(relativeFile);, +                logger.trace("--> Moving " + relativeFile.toString() + " to " + destFile.toString());, +                Files.move(file, destFile);, +                assertFalse(Files.exists(file));, +                assertTrue(Files.exists(destFile));, +                return FileVisitResult.CONTINUE;, +            }, +        });, +    }, +]