[+++ b/core/src/main/java/org/elasticsearch/indices/cluster/IndicesClusterStateService.java, +                                logger.debug("{} removing shard (recovery source changed), current [{}], global [{}], shard [{}])",, +                                    shardId, recoveryState.getSourceNode(), sourceNode, newShardRouting);, +++ b/core/src/main/java/org/elasticsearch/indices/cluster/IndicesClusterStateService.java, +                                logger.debug("{} removing shard (recovery source changed), current [{}], global [{}], shard [{}])",, +                                    shardId, recoveryState.getSourceNode(), sourceNode, newShardRouting);, +++ b/core/src/main/java/org/elasticsearch/indices/recovery/RecoveriesCollection.java, +import org.elasticsearch.common.util.Callback;, +    private final Callback<Long> ensureClusterStateVersionCallback;, +    public RecoveriesCollection(ESLogger logger, ThreadPool threadPool, Callback<Long> ensureClusterStateVersionCallback) {, +        this.ensureClusterStateVersionCallback = ensureClusterStateVersionCallback;, +        RecoveryTarget status = new RecoveryTarget(indexShard, sourceNode, listener, ensureClusterStateVersionCallback);, +++ b/core/src/main/java/org/elasticsearch/indices/cluster/IndicesClusterStateService.java, +                                logger.debug("{} removing shard (recovery source changed), current [{}], global [{}], shard [{}])",, +                                    shardId, recoveryState.getSourceNode(), sourceNode, newShardRouting);, +++ b/core/src/main/java/org/elasticsearch/indices/recovery/RecoveriesCollection.java, +import org.elasticsearch.common.util.Callback;, +    private final Callback<Long> ensureClusterStateVersionCallback;, +    public RecoveriesCollection(ESLogger logger, ThreadPool threadPool, Callback<Long> ensureClusterStateVersionCallback) {, +        this.ensureClusterStateVersionCallback = ensureClusterStateVersionCallback;, +        RecoveryTarget status = new RecoveryTarget(indexShard, sourceNode, listener, ensureClusterStateVersionCallback);, +++ b/core/src/main/java/org/elasticsearch/indices/recovery/RecoverySource.java, +import org.elasticsearch.common.lease.Releasable;, +import java.util.function.Supplier;, +        ShardRouting targetShardRouting = node.getByShardId(request.shardId());, +        RecoverySourceHandler handler = ongoingRecoveries.addNewRecovery(request, shard);, +    private final class OngoingRecoveries {, +        private final Map<IndexShard, ShardRecoveryContext> ongoingRecoveries = new HashMap<>();, +        synchronized RecoverySourceHandler addNewRecovery(StartRecoveryRequest request, IndexShard shard) {, +            final ShardRecoveryContext shardContext = ongoingRecoveries.computeIfAbsent(shard, s -> new ShardRecoveryContext());, +            RecoverySourceHandler handler = shardContext.addNewRecovery(request, shard);, +            return handler;, +            final ShardRecoveryContext shardRecoveryContext = ongoingRecoveries.get(shard);, +            assert shardRecoveryContext != null : "Shard was not registered [" + shard + "]";, +            boolean remove = shardRecoveryContext.recoveryHandlers.remove(handler);, +            if (shardRecoveryContext.recoveryHandlers.isEmpty()) {, +                assert shardRecoveryContext.onNewRecoveryException == null;, +            final ShardRecoveryContext shardRecoveryContext = ongoingRecoveries.get(shard);, +            if (shardRecoveryContext != null) {, +                for (RecoverySourceHandler handlers : shardRecoveryContext.recoveryHandlers) {, +, +        private final class ShardRecoveryContext {, +            final Set<RecoverySourceHandler> recoveryHandlers = new HashSet<>();, +, +            @Nullable, +            private DelayRecoveryException onNewRecoveryException;, +, +            /**, +             * Adds recovery source handler if recoveries are not delayed from starting (see also {@link #delayNewRecoveries}., +             * Throws {@link DelayRecoveryException} if new recoveries are delayed from starting., +             */, +            synchronized RecoverySourceHandler addNewRecovery(StartRecoveryRequest request, IndexShard shard) {, +                if (onNewRecoveryException != null) {, +                    throw onNewRecoveryException;, +                }, +                RecoverySourceHandler handler = createRecoverySourceHandler(request, shard);, +                recoveryHandlers.add(handler);, +                return handler;, +            }, +, +            private RecoverySourceHandler createRecoverySourceHandler(StartRecoveryRequest request, IndexShard shard) {, +                RecoverySourceHandler handler;, +                final RemoteRecoveryTargetHandler recoveryTarget =, +                    new RemoteRecoveryTargetHandler(request.recoveryId(), request.shardId(), transportService, request.targetNode(),, +                        recoverySettings, throttleTime -> shard.recoveryStats().addThrottleTime(throttleTime));, +                Supplier<Long> currentClusterStateVersionSupplier = () -> clusterService.state().getVersion();, +                if (shard.indexSettings().isOnSharedFilesystem()) {, +                    handler = new SharedFSRecoverySourceHandler(shard, recoveryTarget, request, currentClusterStateVersionSupplier,, +                        this::delayNewRecoveries, logger);, +                } else {, +                    handler = new RecoverySourceHandler(shard, recoveryTarget, request, currentClusterStateVersionSupplier,, +                        this::delayNewRecoveries, recoverySettings.getChunkSize().bytesAsInt(), logger);, +                }, +                return handler;, +            }, +, +            /**, +             * Makes new recoveries throw a {@link DelayRecoveryException} with the provided message., +             *, +             * Throws {@link IllegalStateException} if new recoveries are already being delayed., +             */, +            synchronized Releasable delayNewRecoveries(String exceptionMessage) throws IllegalStateException {, +                if (onNewRecoveryException != null) {, +                    throw new IllegalStateException("already delaying recoveries");, +                }, +                onNewRecoveryException = new DelayRecoveryException(exceptionMessage);, +                return this::unblockNewRecoveries;, +            }, +, +, +            private synchronized void unblockNewRecoveries() {, +                onNewRecoveryException = null;, +            }, +        }, +++ b/core/src/main/java/org/elasticsearch/indices/cluster/IndicesClusterStateService.java, +                                logger.debug("{} removing shard (recovery source changed), current [{}], global [{}], shard [{}])",, +                                    shardId, recoveryState.getSourceNode(), sourceNode, newShardRouting);, +++ b/core/src/main/java/org/elasticsearch/indices/recovery/RecoveriesCollection.java, +import org.elasticsearch.common.util.Callback;, +    private final Callback<Long> ensureClusterStateVersionCallback;]