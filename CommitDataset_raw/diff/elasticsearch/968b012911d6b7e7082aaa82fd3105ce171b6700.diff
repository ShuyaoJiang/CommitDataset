[+++ b/src/main/java/org/elasticsearch/index/mapper/geo/MultiValueGeoPointFieldData.java, +import org.apache.lucene.util.BytesRef;, +            //LUCENE 4 UPGRADE: Make GeoHashUtils works with BytesRef instead of String, +            proc.onValue(docId, new BytesRef(GeoHashUtils.encode(lat[loc], lon[loc])));, +++ b/src/main/java/org/elasticsearch/index/mapper/geo/MultiValueGeoPointFieldData.java, +import org.apache.lucene.util.BytesRef;, +            //LUCENE 4 UPGRADE: Make GeoHashUtils works with BytesRef instead of String, +            proc.onValue(docId, new BytesRef(GeoHashUtils.encode(lat[loc], lon[loc])));, +++ b/src/main/java/org/elasticsearch/index/mapper/geo/SingleValueGeoPointFieldData.java, +import org.apache.lucene.util.BytesRef;, +        //LUCENE 4 UPGRADE: Make GeoHashUtils works with BytesRef instead of String, +        proc.onValue(docId, new BytesRef(GeoHashUtils.encode(lat[loc], lon[loc])));, +++ b/src/main/java/org/elasticsearch/index/mapper/geo/MultiValueGeoPointFieldData.java, +import org.apache.lucene.util.BytesRef;, +            //LUCENE 4 UPGRADE: Make GeoHashUtils works with BytesRef instead of String, +            proc.onValue(docId, new BytesRef(GeoHashUtils.encode(lat[loc], lon[loc])));, +++ b/src/main/java/org/elasticsearch/index/mapper/geo/SingleValueGeoPointFieldData.java, +import org.apache.lucene.util.BytesRef;, +        //LUCENE 4 UPGRADE: Make GeoHashUtils works with BytesRef instead of String, +        proc.onValue(docId, new BytesRef(GeoHashUtils.encode(lat[loc], lon[loc])));, +++ b/src/main/java/org/elasticsearch/index/search/geo/GeoDistanceDataComparator.java, +import org.apache.lucene.index.AtomicReaderContext;, +public class GeoDistanceDataComparator extends FieldComparator<Double> {, +            return SortField.Type.DOUBLE;, +    public GeoDistanceDataComparator setNextReader(AtomicReaderContext context) throws IOException {, +        fieldData = (GeoPointFieldData) fieldDataCache.cache(GeoPointFieldDataType.TYPE, context.reader(), indexFieldName);, +        return this;, +    public int compareDocToValue(int doc, Double distance2) throws IOException {, +        double distance1;, +        if (!fieldData.hasValue(doc)) {, +            // is this true? push this to the "end", +            distance1 = Double.MAX_VALUE;, +        } else {, +            distance1 = fixedSourceDistance.calculate(fieldData.latValue(doc), fieldData.lonValue(doc));, +        }, +        return (int) (distance1 - distance2);, +    }, +, +    @Override, +    public Double value(int slot) {, +        return values[slot];]