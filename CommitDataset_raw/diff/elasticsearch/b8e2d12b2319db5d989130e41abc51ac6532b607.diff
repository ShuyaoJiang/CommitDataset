[+++ b/core/src/main/java/org/elasticsearch/action/search/SearchPhaseController.java, +import java.util.function.Supplier;, +            fillTopDocs(shardTopDocs, results, new CollapseTopFieldDocs(firstTopDocs.field, 0, new FieldDoc[0],, +                sort.getSort(), new Object[0], Float.NaN));, +            fillTopDocs(shardTopDocs, results, new TopFieldDocs(0, new FieldDoc[0], sort.getSort(), Float.NaN));, +            fillTopDocs(shardTopDocs, results, Lucene.EMPTY_TOP_DOCS);, +    static <T extends TopDocs> void fillTopDocs(T[] shardTopDocs,, +                                                        List<? extends AtomicArray.Entry<? extends QuerySearchResultProvider>> results,, +                                                        T empytTopDocs) {, +        if (results.size() != shardTopDocs.length) {, +            // TopDocs#merge can't deal with null shard TopDocs, +            Arrays.fill(shardTopDocs, empytTopDocs);, +        }, +        for (AtomicArray.Entry<? extends QuerySearchResultProvider> resultProvider : results) {, +            final T topDocs = (T) resultProvider.value.queryResult().topDocs();, +            assert topDocs != null : "top docs must not be null in a valid result";, +            // the 'index' field is the position in the resultsArr atomic array, +            shardTopDocs[resultProvider.index] = topDocs;, +        }, +    }, +++ b/core/src/main/java/org/elasticsearch/action/search/SearchPhaseController.java, +import java.util.function.Supplier;, +            fillTopDocs(shardTopDocs, results, new CollapseTopFieldDocs(firstTopDocs.field, 0, new FieldDoc[0],, +                sort.getSort(), new Object[0], Float.NaN));, +            fillTopDocs(shardTopDocs, results, new TopFieldDocs(0, new FieldDoc[0], sort.getSort(), Float.NaN));, +            fillTopDocs(shardTopDocs, results, Lucene.EMPTY_TOP_DOCS);, +    static <T extends TopDocs> void fillTopDocs(T[] shardTopDocs,, +                                                        List<? extends AtomicArray.Entry<? extends QuerySearchResultProvider>> results,, +                                                        T empytTopDocs) {, +        if (results.size() != shardTopDocs.length) {, +            // TopDocs#merge can't deal with null shard TopDocs, +            Arrays.fill(shardTopDocs, empytTopDocs);, +        }, +        for (AtomicArray.Entry<? extends QuerySearchResultProvider> resultProvider : results) {, +            final T topDocs = (T) resultProvider.value.queryResult().topDocs();, +            assert topDocs != null : "top docs must not be null in a valid result";, +            // the 'index' field is the position in the resultsArr atomic array, +            shardTopDocs[resultProvider.index] = topDocs;, +        }, +    }, +++ b/core/src/test/java/org/elasticsearch/action/search/SearchPhaseControllerTests.java, +import org.elasticsearch.common.lucene.Lucene;, +, +    public void testFillTopDocs() {, +        final int maxIters =  randomIntBetween(5, 15);, +        for (int iters = 0; iters < maxIters; iters++) {, +            TopDocs[] topDocs = new TopDocs[randomIntBetween(2, 100)];, +            int numShards = topDocs.length;, +            AtomicArray<QuerySearchResultProvider> resultProviderAtomicArray = generateQueryResults(numShards, Collections.emptyList(),, +                2, randomBoolean());, +            if (randomBoolean()) {, +                int maxNull = randomIntBetween(1, topDocs.length - 1);, +                for (int i = 0; i < maxNull; i++) {, +                    resultProviderAtomicArray.set(randomIntBetween(0, resultProviderAtomicArray.length() - 1), null);, +                }, +            }, +            SearchPhaseController.fillTopDocs(topDocs, resultProviderAtomicArray.asList(), Lucene.EMPTY_TOP_DOCS);, +            for (int i = 0; i < topDocs.length; i++) {, +                assertNotNull(topDocs[i]);, +                if (topDocs[i] == Lucene.EMPTY_TOP_DOCS) {, +                    assertNull(resultProviderAtomicArray.get(i));, +                } else {, +                    assertNotNull(resultProviderAtomicArray.get(i));, +                    assertNotNull(resultProviderAtomicArray.get(i).queryResult());, +                    assertSame(resultProviderAtomicArray.get(i).queryResult().topDocs(), topDocs[i]);, +                }, +            }, +        }, +    }]