[+++ b/core/src/main/java/org/elasticsearch/client/transport/TransportProxyClient.java, +++ b/core/src/main/java/org/elasticsearch/client/transport/TransportProxyClient.java, +++ b/core/src/main/java/org/elasticsearch/cluster/routing/allocation/IndexMetaDataUpdater.java, +import org.elasticsearch.cluster.routing.IndexShardRoutingTable;, +            // Only trim the set of allocation ids when it grows, otherwise we might trim too eagerly when the number, +            // of replicas was decreased while shards were unassigned., +            IndexShardRoutingTable newShardRoutingTable = newRoutingTable.shardRoutingTable(shardId);, +            if (inSyncAllocationIds.size() > oldInSyncAllocationIds.size() && inSyncAllocationIds.size() > maxActiveShards) {, +                List<ShardRouting> assignedShards = newShardRoutingTable.assignedShards();, +            // only remove allocation id of failed active primary if there is at least one active shard remaining. Assume for example that, +            // the primary fails but there is no new primary to fail over to. If we were to remove the allocation id of the primary from the, +            // in-sync set, this could create an empty primary on the next allocation., +            if (newShardRoutingTable.activeShards().isEmpty() && updates.firstFailedPrimary != null) {, +++ b/core/src/main/java/org/elasticsearch/client/transport/TransportProxyClient.java, +++ b/core/src/main/java/org/elasticsearch/cluster/routing/allocation/IndexMetaDataUpdater.java, +import org.elasticsearch.cluster.routing.IndexShardRoutingTable;, +            // Only trim the set of allocation ids when it grows, otherwise we might trim too eagerly when the number, +            // of replicas was decreased while shards were unassigned., +            IndexShardRoutingTable newShardRoutingTable = newRoutingTable.shardRoutingTable(shardId);, +            if (inSyncAllocationIds.size() > oldInSyncAllocationIds.size() && inSyncAllocationIds.size() > maxActiveShards) {, +                List<ShardRouting> assignedShards = newShardRoutingTable.assignedShards();, +            // only remove allocation id of failed active primary if there is at least one active shard remaining. Assume for example that, +            // the primary fails but there is no new primary to fail over to. If we were to remove the allocation id of the primary from the, +            // in-sync set, this could create an empty primary on the next allocation., +            if (newShardRoutingTable.activeShards().isEmpty() && updates.firstFailedPrimary != null) {, +++ b/core/src/main/java/org/elasticsearch/script/Script.java, +            Map<String, String> options = (Map<String, String>)(Map)in.readMap();, +            Map<String, Object> options = (Map<String, Object>)(Map)this.options;, +++ b/core/src/main/java/org/elasticsearch/client/transport/TransportProxyClient.java, +++ b/core/src/main/java/org/elasticsearch/cluster/routing/allocation/IndexMetaDataUpdater.java, +import org.elasticsearch.cluster.routing.IndexShardRoutingTable;, +            // Only trim the set of allocation ids when it grows, otherwise we might trim too eagerly when the number, +            // of replicas was decreased while shards were unassigned., +            IndexShardRoutingTable newShardRoutingTable = newRoutingTable.shardRoutingTable(shardId);, +            if (inSyncAllocationIds.size() > oldInSyncAllocationIds.size() && inSyncAllocationIds.size() > maxActiveShards) {, +                List<ShardRouting> assignedShards = newShardRoutingTable.assignedShards();, +            // only remove allocation id of failed active primary if there is at least one active shard remaining. Assume for example that, +            // the primary fails but there is no new primary to fail over to. If we were to remove the allocation id of the primary from the, +            // in-sync set, this could create an empty primary on the next allocation., +            if (newShardRoutingTable.activeShards().isEmpty() && updates.firstFailedPrimary != null) {, +++ b/core/src/main/java/org/elasticsearch/script/Script.java, +            Map<String, String> options = (Map<String, String>)(Map)in.readMap();, +            Map<String, Object> options = (Map<String, Object>)(Map)this.options;, +++ b/core/src/test/java/org/elasticsearch/cluster/routing/allocation/InSyncAllocationIdTests.java, +    /**, +     * Only trim set of allocation ids when the set grows, +     */, +    public void testInSyncIdsNotTrimmedWhenNotGrowing() throws Exception {, +        ClusterState clusterState = createOnePrimaryOneReplicaClusterState(allocation);, +, +        Set<String> inSyncSet = clusterState.metaData().index("test").inSyncAllocationIds(0);, +        assertThat(inSyncSet.size(), equalTo(2));, +, +        IndexShardRoutingTable shardRoutingTable = clusterState.routingTable().index("test").shard(0);, +        ShardRouting primaryShard = shardRoutingTable.primaryShard();, +        ShardRouting replicaShard = shardRoutingTable.replicaShards().get(0);, +, +        logger.info("remove replica node");, +        clusterState = ClusterState.builder(clusterState).nodes(DiscoveryNodes.builder(clusterState.nodes()), +            .remove(replicaShard.currentNodeId())), +            .build();, +        clusterState = allocation.deassociateDeadNodes(clusterState, true, "reroute");, +, +        // in-sync allocation ids should not be updated, +        assertEquals(inSyncSet, clusterState.metaData().index("test").inSyncAllocationIds(0));, +, +        logger.info("remove primary node");, +        clusterState = ClusterState.builder(clusterState).nodes(DiscoveryNodes.builder(clusterState.nodes()), +            .remove(primaryShard.currentNodeId())), +            .build();, +        clusterState = allocation.deassociateDeadNodes(clusterState, true, "reroute");, +, +        // in-sync allocation ids should not be updated, +        assertEquals(inSyncSet, clusterState.metaData().index("test").inSyncAllocationIds(0));, +, +        logger.info("decrease number of replicas to 0");, +        clusterState = ClusterState.builder(clusterState), +            .routingTable(RoutingTable.builder(clusterState.routingTable()).updateNumberOfReplicas(0, "test").build()), +            .metaData(MetaData.builder(clusterState.metaData()).updateNumberOfReplicas(0, "test")).build();, +, +        logger.info("add back node 1");, +        clusterState = ClusterState.builder(clusterState).nodes(DiscoveryNodes.builder().add(, +            newNode("node1"))).build();, +        clusterState = allocation.reroute(clusterState, "reroute");, +, +        assertThat(clusterState.routingTable().index("test").shard(0).assignedShards().size(), equalTo(1));, +        // in-sync allocation ids should not be updated, +        assertEquals(inSyncSet, clusterState.metaData().index("test").inSyncAllocationIds(0));, +, +        logger.info("start primary shard");, +        clusterState = allocation.applyStartedShards(clusterState, clusterState.getRoutingNodes().shardsWithState(INITIALIZING));, +        // in-sync allocation ids should not be updated, +        assertEquals(inSyncSet, clusterState.metaData().index("test").inSyncAllocationIds(0));, +    }, +, +    /**, +     * Don't remove allocation id of failed active primary if there is no replica to promote as primary., +     */, +    public void testPrimaryAllocationIdNotRemovedFromInSyncSetWhenNoFailOver() throws Exception {, +        ClusterState clusterState = createOnePrimaryOneReplicaClusterState(allocation);]