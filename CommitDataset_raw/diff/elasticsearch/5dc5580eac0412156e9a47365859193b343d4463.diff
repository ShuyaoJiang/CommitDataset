[+++ b/core/src/main/java/org/elasticsearch/index/store/Store.java, +     * Only files that are part of the last commit are considered in this datastructure., +++ b/core/src/main/java/org/elasticsearch/index/store/Store.java, +     * Only files that are part of the last commit are considered in this datastructure., +++ b/core/src/main/java/org/elasticsearch/repositories/blobstore/BlobStoreRepository.java, +import java.util.Arrays;, +                    // this will throw an IOException if the store has no segments infos file. The, +                    // store can still have existing files but they will be deleted just before being, +                    // restored., +, +, +                final StoreFileMetaData restoredSegmentsFile = sourceMetaData.getSegmentsFile();, +                if (restoredSegmentsFile == null) {, +                    throw new IndexShardRestoreFailedException(shardId, "Snapshot has no segments file");, +                }, +, +                    // list of all existing store files, +                    final List<String> deleteIfExistFiles = Arrays.asList(store.directory().listAll());, +, +                        // if a file with a same physical name already exist in the store we need to delete it, +                        // before restoring it from the snapshot. We could be lenient and try to reuse the existing, +                        // store files (and compare their names/length/checksum again with the snapshot files) but to, +                        // avoid extra complexity we simply delete them and restore them again like StoreRecovery, +                        // does with dangling indices. Any existing store file that is not restored from the snapshot, +                        // will be clean up by RecoveryTarget.cleanFiles()., +                        final String physicalName = fileToRecover.physicalName();, +                        if (deleteIfExistFiles.contains(physicalName)) {, +                            logger.trace("[{}] [{}] deleting pre-existing file [{}]", shardId, snapshotId, physicalName);, +                            store.directory().deleteFile(physicalName);, +                        }, +, +, +++ b/core/src/main/java/org/elasticsearch/index/store/Store.java, +     * Only files that are part of the last commit are considered in this datastructure., +++ b/core/src/main/java/org/elasticsearch/repositories/blobstore/BlobStoreRepository.java, +import java.util.Arrays;, +                    // this will throw an IOException if the store has no segments infos file. The, +                    // store can still have existing files but they will be deleted just before being, +                    // restored., +, +, +                final StoreFileMetaData restoredSegmentsFile = sourceMetaData.getSegmentsFile();, +                if (restoredSegmentsFile == null) {, +                    throw new IndexShardRestoreFailedException(shardId, "Snapshot has no segments file");, +                }, +, +                    // list of all existing store files, +                    final List<String> deleteIfExistFiles = Arrays.asList(store.directory().listAll());, +, +                        // if a file with a same physical name already exist in the store we need to delete it, +                        // before restoring it from the snapshot. We could be lenient and try to reuse the existing, +                        // store files (and compare their names/length/checksum again with the snapshot files) but to, +                        // avoid extra complexity we simply delete them and restore them again like StoreRecovery, +                        // does with dangling indices. Any existing store file that is not restored from the snapshot, +                        // will be clean up by RecoveryTarget.cleanFiles()., +                        final String physicalName = fileToRecover.physicalName();, +                        if (deleteIfExistFiles.contains(physicalName)) {, +                            logger.trace("[{}] [{}] deleting pre-existing file [{}]", shardId, snapshotId, physicalName);, +                            store.directory().deleteFile(physicalName);, +                        }, +, +, +++ b/core/src/main/java/org/elasticsearch/snapshots/RestoreService.java, +            final MetaData metaData = repository.getSnapshotMetaData(snapshotInfo, repositoryData.resolveIndices(filteredIndices));, +++ b/core/src/main/java/org/elasticsearch/index/store/Store.java, +     * Only files that are part of the last commit are considered in this datastructure., +++ b/core/src/main/java/org/elasticsearch/repositories/blobstore/BlobStoreRepository.java, +import java.util.Arrays;, +                    // this will throw an IOException if the store has no segments infos file. The, +                    // store can still have existing files but they will be deleted just before being, +                    // restored., +, +, +                final StoreFileMetaData restoredSegmentsFile = sourceMetaData.getSegmentsFile();, +                if (restoredSegmentsFile == null) {, +                    throw new IndexShardRestoreFailedException(shardId, "Snapshot has no segments file");, +                }, +, +                    // list of all existing store files, +                    final List<String> deleteIfExistFiles = Arrays.asList(store.directory().listAll());, +, +                        // if a file with a same physical name already exist in the store we need to delete it, +                        // before restoring it from the snapshot. We could be lenient and try to reuse the existing, +                        // store files (and compare their names/length/checksum again with the snapshot files) but to, +                        // avoid extra complexity we simply delete them and restore them again like StoreRecovery, +                        // does with dangling indices. Any existing store file that is not restored from the snapshot, +                        // will be clean up by RecoveryTarget.cleanFiles()., +                        final String physicalName = fileToRecover.physicalName();, +                        if (deleteIfExistFiles.contains(physicalName)) {, +                            logger.trace("[{}] [{}] deleting pre-existing file [{}]", shardId, snapshotId, physicalName);, +                            store.directory().deleteFile(physicalName);, +                        }, +, +, +++ b/core/src/main/java/org/elasticsearch/snapshots/RestoreService.java, +            final MetaData metaData = repository.getSnapshotMetaData(snapshotInfo, repositoryData.resolveIndices(filteredIndices));, +++ b/core/src/test/java/org/elasticsearch/repositories/blobstore/BlobStoreRepositoryRestoreTests.java, +/*, + * Licensed to Elasticsearch under one or more contributor, + * license agreements. See the NOTICE file distributed with]