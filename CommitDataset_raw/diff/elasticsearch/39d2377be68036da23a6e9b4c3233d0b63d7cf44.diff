[+++ b/pom.xml, +                                <exclude>org/apache/lucene/queries/XTermsFilter.class</exclude>, +++ b/pom.xml, +                                <exclude>org/apache/lucene/queries/XTermsFilter.class</exclude>, +++ b/src/main/java/org/apache/lucene/queries/XTermsFilter.java, +package org.apache.lucene.queries;, +, +/*, + * Licensed to the Apache Software Foundation (ASF) under one or more, + * contributor license agreements.  See the NOTICE file distributed with, + * this work for additional information regarding copyright ownership., + * The ASF licenses this file to You under the Apache License, Version 2.0, + * (the "License"); you may not use this file except in compliance with, + * the License.  You may obtain a copy of the License at, + *, + *     http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS,, + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied., + * See the License for the specific language governing permissions and, + * limitations under the License., + */, +, +import org.apache.lucene.index.*;, +import org.apache.lucene.search.DocIdSet;, +import org.apache.lucene.search.DocIdSetIterator;, +import org.apache.lucene.search.Filter;, +import org.apache.lucene.util.*;, +, +import java.io.IOException;, +import java.util.ArrayList;, +import java.util.Arrays;, +import java.util.Collections;, +import java.util.Iterator;, +import java.util.List;, +, +/**, + * Constructs a filter for docs matching any of the terms added to this class., + * Unlike a RangeFilter this can be used for filtering on multiple terms that are not necessarily in, + * a sequence. An example might be a collection of primary keys from a database query result or perhaps, + * a choice of "category" labels picked by the end user. As a filter, this is much faster than the, + * equivalent query (a BooleanQuery with many "should" TermQueries), + */, +public final class XTermsFilter extends Filter {, +, +    static {, +        assert Version.LUCENE_47 == org.elasticsearch.Version.CURRENT.luceneVersion : "Remove this once we are on LUCENE_48 - see LUCENE-5502";, +    }, +, +    /*, +     * this class is often used for large number of terms in a single field., +     * to optimize for this case and to be filter-cache friendly we , +     * serialize all terms into a single byte array and store offsets, +     * in a parallel array to keep the # of object constant and speed up, +     * equals / hashcode., +     * , +     * This adds quite a bit of complexity but allows large term filters to, +     * be efficient for GC and cache-lookups, +     */, +    private final int[] offsets;, +    private final byte[] termsBytes;, +    private final TermsAndField[] termsAndFields;, +    private final int hashCode; // cached hashcode for fast cache lookups, +    private static final int PRIME = 31;, +, +    /**, +     * Creates a new {@link XTermsFilter} from the given list. The list, +     * can contain duplicate terms and multiple fields., +     */, +    public XTermsFilter(final List<Term> terms) {, +        this(new FieldAndTermEnum() {, +            // we need to sort for deduplication and to have a common cache key, +            final Iterator<Term> iter = sort(terms).iterator();, +            @Override, +            public BytesRef next() {, +                if (iter.hasNext()) {, +                    Term next = iter.next();, +                    field = next.field();, +                    return next.bytes();, +                }, +                return null;, +            }}, terms.size());, +    }, +, +    /**, +     * Creates a new {@link XTermsFilter} from the given {@link BytesRef} list for, +     * a single field., +     */, +    public XTermsFilter(final String field, final List<BytesRef> terms) {, +        this(new FieldAndTermEnum(field) {, +            // we need to sort for deduplication and to have a common cache key, +            final Iterator<BytesRef> iter = sort(terms).iterator();, +            @Override, +            public BytesRef next() {, +                if (iter.hasNext()) {, +                    return iter.next();, +                }, +                return null;, +            }]