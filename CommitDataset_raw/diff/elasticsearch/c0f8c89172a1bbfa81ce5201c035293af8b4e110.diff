[+++ b/server/src/main/java/org/elasticsearch/index/engine/EngineConfig.java, +import org.elasticsearch.index.seqno.RetentionLease;, +import java.util.Collection;, +import java.util.Objects;, +import java.util.function.Supplier;, +    private final Supplier<Collection<RetentionLease>> retentionLeasesSupplier;, +, +    /**, +     * A supplier of the outstanding retention leases. This is used during merged operations to determine which operations that have been, +     * soft deleted should be retained., +     *, +     * @return a supplier of outstanding retention leases, +     */, +    public Supplier<Collection<RetentionLease>> retentionLeasesSupplier() {, +        return retentionLeasesSupplier;, +    }, +, +                        Supplier<Collection<RetentionLease>> retentionLeasesSupplier,, +                        LongSupplier primaryTermSupplier,, +                        TombstoneDocSupplier tombstoneDocSupplier) {, +        this.retentionLeasesSupplier = Objects.requireNonNull(retentionLeasesSupplier);, +++ b/server/src/main/java/org/elasticsearch/index/engine/EngineConfig.java, +import org.elasticsearch.index.seqno.RetentionLease;, +import java.util.Collection;, +import java.util.Objects;, +import java.util.function.Supplier;, +    private final Supplier<Collection<RetentionLease>> retentionLeasesSupplier;, +, +    /**, +     * A supplier of the outstanding retention leases. This is used during merged operations to determine which operations that have been, +     * soft deleted should be retained., +     *, +     * @return a supplier of outstanding retention leases, +     */, +    public Supplier<Collection<RetentionLease>> retentionLeasesSupplier() {, +        return retentionLeasesSupplier;, +    }, +, +                        Supplier<Collection<RetentionLease>> retentionLeasesSupplier,, +                        LongSupplier primaryTermSupplier,, +                        TombstoneDocSupplier tombstoneDocSupplier) {, +        this.retentionLeasesSupplier = Objects.requireNonNull(retentionLeasesSupplier);, +++ b/server/src/main/java/org/elasticsearch/index/engine/InternalEngine.java, +        return new SoftDeletesPolicy(, +                translog::getLastSyncedGlobalCheckpoint,, +                lastMinRetainedSeqNo,, +                engineConfig.getIndexSettings().getSoftDeleteRetentionOperations(),, +                engineConfig.retentionLeasesSupplier());, +++ b/server/src/main/java/org/elasticsearch/index/engine/EngineConfig.java, +import org.elasticsearch.index.seqno.RetentionLease;, +import java.util.Collection;, +import java.util.Objects;, +import java.util.function.Supplier;, +    private final Supplier<Collection<RetentionLease>> retentionLeasesSupplier;, +, +    /**, +     * A supplier of the outstanding retention leases. This is used during merged operations to determine which operations that have been, +     * soft deleted should be retained., +     *, +     * @return a supplier of outstanding retention leases, +     */, +    public Supplier<Collection<RetentionLease>> retentionLeasesSupplier() {, +        return retentionLeasesSupplier;, +    }, +, +                        Supplier<Collection<RetentionLease>> retentionLeasesSupplier,, +                        LongSupplier primaryTermSupplier,, +                        TombstoneDocSupplier tombstoneDocSupplier) {, +        this.retentionLeasesSupplier = Objects.requireNonNull(retentionLeasesSupplier);, +++ b/server/src/main/java/org/elasticsearch/index/engine/InternalEngine.java, +        return new SoftDeletesPolicy(, +                translog::getLastSyncedGlobalCheckpoint,, +                lastMinRetainedSeqNo,, +                engineConfig.getIndexSettings().getSoftDeleteRetentionOperations(),, +                engineConfig.retentionLeasesSupplier());, +++ b/server/src/main/java/org/elasticsearch/index/engine/SoftDeletesPolicy.java, +import org.elasticsearch.index.seqno.RetentionLease;, +import java.util.Collection;, +import java.util.Objects;, +import java.util.function.Supplier;, +    // provides the retention leases used to calculate the minimum sequence number to retain, +    private final Supplier<Collection<RetentionLease>> retentionLeasesSupplier;, +    SoftDeletesPolicy(, +            final LongSupplier globalCheckpointSupplier,, +            final long minRetainedSeqNo,, +            final long retentionOperations,, +            final Supplier<Collection<RetentionLease>> retentionLeasesSupplier) {, +        this.retentionLeasesSupplier = Objects.requireNonNull(retentionLeasesSupplier);, +            /*, +             * This policy retains operations for two purposes: peer-recovery and querying changes history., +             *  - Peer-recovery is driven by the local checkpoint of the safe commit. In peer-recovery, the primary transfers a safe commit,, +             *    then sends operations after the local checkpoint of that commit. This requires keeping all ops after, +             *    localCheckpointOfSafeCommit., +             *  - Changes APIs are driven by a combination of the global checkpoint, retention operations, and retention leases. Here we, +             *    prefer using the global checkpoint instead of the maximum sequence number because only operations up to the global, +             *    checkpoint are exposed in the the changes APIs., +             */, +, +            // calculate the minimum sequence number to retain based on retention leases, +            final long minimumRetainingSequenceNumber = retentionLeasesSupplier]