[+++ b/qa/sql/src/main/java/org/elasticsearch/xpack/qa/sql/rest/RestSqlTestCase.java, +    public void testSelectInvalidSql() {, +    public void testSelectFromMissingIndex() {, +        assertEquals(e.getMessage(), 400, e.getResponse().getStatusLine().getStatusCode());, +++ b/qa/sql/src/main/java/org/elasticsearch/xpack/qa/sql/rest/RestSqlTestCase.java, +    public void testSelectInvalidSql() {, +    public void testSelectFromMissingIndex() {, +        assertEquals(e.getMessage(), 400, e.getResponse().getStatusLine().getStatusCode());, +++ b/sql/server/src/main/java/org/elasticsearch/xpack/sql/analysis/analyzer/Analyzer.java, +            if (index.isValid() == false) {, +            LogicalPlan catalogTable = new EsRelation(plan.location(), index.get());, +++ b/qa/sql/src/main/java/org/elasticsearch/xpack/qa/sql/rest/RestSqlTestCase.java, +    public void testSelectInvalidSql() {, +    public void testSelectFromMissingIndex() {, +        assertEquals(e.getMessage(), 400, e.getResponse().getStatusLine().getStatusCode());, +++ b/sql/server/src/main/java/org/elasticsearch/xpack/sql/analysis/analyzer/Analyzer.java, +            if (index.isValid() == false) {, +            LogicalPlan catalogTable = new EsRelation(plan.location(), index.get());, +++ b/sql/server/src/main/java/org/elasticsearch/xpack/sql/analysis/catalog/Catalog.java, +import java.util.function.Function;, + * Index representation that is compatible with SQL ({@link EsIndex})., +public final class Catalog {, +    public static final Catalog EMPTY = new Catalog(GetIndexResult::notFound);, +            , +    private final Function<String, GetIndexResult> resultFunction;, +, +    //TODO given that this always holds a single index, we cana probably get rid of the whole idea of Catalog, +    public Catalog(GetIndexResult result) {, +        assert result != null;, +        this.resultFunction = index -> result.matches(index) ? result : GetIndexResult.notFound(index);, +    }, +, +    private Catalog(Function<String, GetIndexResult> resultFunction) {, +        assert resultFunction != null;, +        this.resultFunction = resultFunction;, +    }, +    public GetIndexResult getIndex(String index) {, +        return resultFunction.apply(index);, +    }, +    public static final class GetIndexResult {, +        private boolean matches(String index) {, +            return isValid() && this.index.name().equals(index);, +        }, +, +++ b/qa/sql/src/main/java/org/elasticsearch/xpack/qa/sql/rest/RestSqlTestCase.java, +    public void testSelectInvalidSql() {, +    public void testSelectFromMissingIndex() {, +        assertEquals(e.getMessage(), 400, e.getResponse().getStatusLine().getStatusCode());, +++ b/sql/server/src/main/java/org/elasticsearch/xpack/sql/analysis/analyzer/Analyzer.java, +            if (index.isValid() == false) {, +            LogicalPlan catalogTable = new EsRelation(plan.location(), index.get());, +++ b/sql/server/src/main/java/org/elasticsearch/xpack/sql/analysis/catalog/Catalog.java, +import java.util.function.Function;, + * Index representation that is compatible with SQL ({@link EsIndex})., +public final class Catalog {, +    public static final Catalog EMPTY = new Catalog(GetIndexResult::notFound);, +            , +    private final Function<String, GetIndexResult> resultFunction;, +, +    //TODO given that this always holds a single index, we cana probably get rid of the whole idea of Catalog, +    public Catalog(GetIndexResult result) {, +        assert result != null;, +        this.resultFunction = index -> result.matches(index) ? result : GetIndexResult.notFound(index);, +    }, +, +    private Catalog(Function<String, GetIndexResult> resultFunction) {, +        assert resultFunction != null;, +        this.resultFunction = resultFunction;, +    }, +    public GetIndexResult getIndex(String index) {, +        return resultFunction.apply(index);, +    }, +    public static final class GetIndexResult {, +        private boolean matches(String index) {, +            return isValid() && this.index.name().equals(index);, +        }, +, +++ b/sql/server/src/main/java/org/elasticsearch/xpack/sql/analysis/catalog/EsIndex.java, +        assert name != null;, +        assert mapping != null;, +++ b/qa/sql/src/main/java/org/elasticsearch/xpack/qa/sql/rest/RestSqlTestCase.java, +    public void testSelectInvalidSql() {, +    public void testSelectFromMissingIndex() {, +        assertEquals(e.getMessage(), 400, e.getResponse().getStatusLine().getStatusCode());, +++ b/sql/server/src/main/java/org/elasticsearch/xpack/sql/analysis/analyzer/Analyzer.java, +            if (index.isValid() == false) {, +            LogicalPlan catalogTable = new EsRelation(plan.location(), index.get());, +++ b/sql/server/src/main/java/org/elasticsearch/xpack/sql/analysis/catalog/Catalog.java, +import java.util.function.Function;, + * Index representation that is compatible with SQL ({@link EsIndex})., +public final class Catalog {, +    public static final Catalog EMPTY = new Catalog(GetIndexResult::notFound);, +            , +    private final Function<String, GetIndexResult> resultFunction;, +, +    //TODO given that this always holds a single index, we cana probably get rid of the whole idea of Catalog, +    public Catalog(GetIndexResult result) {, +        assert result != null;, +        this.resultFunction = index -> result.matches(index) ? result : GetIndexResult.notFound(index);, +    }]