[+++ b/core/src/main/java/org/elasticsearch/bootstrap/Bootstrap.java, +    @SuppressForbidden(reason = "Exception#printStackTrace()"), +    private static void setupLogging(Settings settings) {, +        try {, +            Class.forName("org.apache.log4j.Logger");, +            LogConfigurator.configure(settings, true);, +        } catch (ClassNotFoundException e) {, +            // no log4j, +        } catch (NoClassDefFoundError e) {, +            // no log4j, +        } catch (Exception e) {, +            sysError("Failed to configure logging...", false);, +            e.printStackTrace();, +        }, +    }, +, +        setupLogging(settings);, +++ b/core/src/main/java/org/elasticsearch/bootstrap/Bootstrap.java, +    @SuppressForbidden(reason = "Exception#printStackTrace()"), +    private static void setupLogging(Settings settings) {, +        try {, +            Class.forName("org.apache.log4j.Logger");, +            LogConfigurator.configure(settings, true);, +        } catch (ClassNotFoundException e) {, +            // no log4j, +        } catch (NoClassDefFoundError e) {, +            // no log4j, +        } catch (Exception e) {, +            sysError("Failed to configure logging...", false);, +            e.printStackTrace();, +        }, +    }, +, +        setupLogging(settings);, +++ b/core/src/main/java/org/elasticsearch/index/mapper/DocumentParser.java, +import java.io.Closeable;, +import java.io.IOException;, +import java.util.ArrayList;, +import java.util.Collections;, +import java.util.HashSet;, +import java.util.List;, +import java.util.Set;, +, +import org.elasticsearch.common.settings.Settings;, +final class DocumentParser implements Closeable {, +        ParsedDocument doc = parsedDocument(source, context, createDynamicUpdate(mapping, docMapper, context.getDynamicMappers()));, +            parseObjectOrNested(context, mapping.root, true);, +    /** Creates a Mapping containing any dynamically added fields, or returns null if there were no dynamic mappings. */, +    static Mapping createDynamicUpdate(Mapping mapping, DocumentMapper docMapper, List<Mapper> dynamicMappers) {, +        if (dynamicMappers.isEmpty()) {, +            return null;, +        }, +        // We build a mapping by first sorting the mappers, so that all mappers containing a common prefix, +        // will be processed in a contiguous block. When the prefix is no longer seen, we pop the extra elements, +        // off the stack, merging them upwards into the existing mappers., +        Collections.sort(dynamicMappers, (Mapper o1, Mapper o2) -> o1.name().compareTo(o2.name()));, +        List<ObjectMapper> parentMappers = new ArrayList<>();, +        // create an empty root object which updates will be propagated into, +        RootObjectMapper.Builder rootBuilder = new RootObjectMapper.Builder(docMapper.type());, +        RootObjectMapper.BuilderContext context = new RootObjectMapper.BuilderContext(Settings.EMPTY, new ContentPath());, +        parentMappers.add(rootBuilder.build(context));, +        Mapper previousMapper = null;, +        for (Mapper newMapper : dynamicMappers) {, +            if (previousMapper != null && newMapper.name().equals(previousMapper.name())) {, +                // We can see the same mapper more than once, for example, if we had foo.bar and foo.baz, where, +                // foo did not yet exist. This will create 2 copies in dynamic mappings, which should be identical., +                // Here we just skip over the duplicates, but we merge them to ensure there are no conflicts., +                newMapper.merge(previousMapper, false);, +                continue;, +            }, +            previousMapper = newMapper;, +            String[] nameParts = newMapper.name().split("\\.");, +            // find common elements with the previously processed dynamic mapper, +            int keepBefore = 1;, +            while (keepBefore < parentMappers.size() &&, +                   parentMappers.get(keepBefore).simpleName().equals(nameParts[keepBefore - 1])) {, +                ++keepBefore;, +            }, +            popMappers(parentMappers, keepBefore);, +, +            // Add parent mappers that don't exist in dynamic mappers, +            while (keepBefore < nameParts.length) {, +                ObjectMapper parent = parentMappers.get(parentMappers.size() - 1);, +                Mapper newLast = parent.getMapper(nameParts[keepBefore - 1]);, +                if (newLast == null) {, +                    String objectName = nameParts[keepBefore - 1];, +                    if (keepBefore > 1) {, +                        // only prefix with parent mapper if the parent mapper isn't the root (which has a fake name), +                        objectName = parent.name() + '.' + objectName;, +                    }, +                    newLast = docMapper.objectMappers().get(objectName);, +                }, +                assert newLast instanceof ObjectMapper;, +                parentMappers.add((ObjectMapper)newLast);, +                ++keepBefore;, +            }, +, +            if (newMapper instanceof ObjectMapper) {, +                parentMappers.add((ObjectMapper)newMapper);, +            } else {]