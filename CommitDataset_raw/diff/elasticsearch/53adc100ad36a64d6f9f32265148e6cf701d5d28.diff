[+++ b/elasticsearch/src/main/java/org/elasticsearch/xpack/prelert/action/RevertModelSnapshotAction.java, +            logger.debug("Received request to revert to time '{}' description '{}' snapshot id '{}' for job '{}', deleting intervening " +, +                            "results: {}",, +                    request.getTime(), request.getDescription(), request.getSnapshotId(), request.getJobId(),, +                    request.getDeleteInterveningResults());, +            if (job.count() > 0 && allocation.getStatus().equals(JobStatus.CLOSED) == false) {, +                    logger.info("Deleting results after '" + deleteAfter + "'");, +                    OldDataRemover remover = new OldDataRemover(bulkDeleterFactory);, +++ b/elasticsearch/src/main/java/org/elasticsearch/xpack/prelert/action/RevertModelSnapshotAction.java, +            logger.debug("Received request to revert to time '{}' description '{}' snapshot id '{}' for job '{}', deleting intervening " +, +                            "results: {}",, +                    request.getTime(), request.getDescription(), request.getSnapshotId(), request.getJobId(),, +                    request.getDeleteInterveningResults());, +            if (job.count() > 0 && allocation.getStatus().equals(JobStatus.CLOSED) == false) {, +                    logger.info("Deleting results after '" + deleteAfter + "'");, +                    OldDataRemover remover = new OldDataRemover(bulkDeleterFactory);, +++ b/elasticsearch/src/main/java/org/elasticsearch/xpack/prelert/job/persistence/ElasticsearchBulkDeleter.java, +import org.apache.logging.log4j.Level;, +import org.elasticsearch.index.query.RangeQueryBuilder;, +import java.util.Date;, +    private long deletedResultCount;, +    public ElasticsearchBulkDeleter(Client client, String jobId, boolean quiet) {, +        this.client = Objects.requireNonNull(client);, +        this.jobId = Objects.requireNonNull(jobId);, +        bulkRequestBuilder = client.prepareBulk();, +        deletedResultCount = 0;, +        deletedModelSnapshotCount = 0;, +        deletedModelStateCount = 0;, +        this.quiet = quiet;, +    public void deleteResultsFromTime(long cutoffEpochMs) {, +        String index = JobResultsPersister.getJobIndexName(jobId);, +        RangeQueryBuilder timeRange = QueryBuilders.rangeQuery(ElasticsearchMappings.ES_TIMESTAMP);, +        timeRange.gte(cutoffEpochMs);, +        timeRange.lt(new Date().getTime());, +        SearchResponse searchResponse = client.prepareSearch(index), +                .setFetchSource(false), +                .setQuery(timeRange), +                .setScroll(SCROLL_CONTEXT_DURATION), +                .get();, +        String scrollId = searchResponse.getScrollId();, +        long totalHits = searchResponse.getHits().totalHits();, +        long totalDeletedCount = 0;, +        while (totalDeletedCount < totalHits) {, +                LOGGER.trace("Search hit for result: {}", hit.getId());, +                ++totalDeletedCount;, +                addDeleteRequest(hit, index);, +                ++deletedResultCount;, +            searchResponse = client.prepareSearchScroll(scrollId).setScroll(SCROLL_CONTEXT_DURATION).get();, +    private void addDeleteRequest(SearchHit hit, String index) {, +                .setIndex(index), +            bulkRequestBuilder.add(client.prepareDelete(indexName, ModelState.TYPE, stateId));, +        bulkRequestBuilder.add(client.prepareDelete(indexName, ModelSnapshot.TYPE.getPreferredName(), snapshotId));, +    @Override, +        String index = JobResultsPersister.getJobIndexName(jobId);, +, +        SearchResponse searchResponse = client.prepareSearch(index), +                .setFetchSource(false), +                LOGGER.trace("Search hit for result: {}", hit.getId());, +                addDeleteRequest(hit, index);, +                ++deletedResultCount;, +        Level logLevel = quiet ? Level.DEBUG : Level.INFO;, +        LOGGER.log(logLevel, "Requesting deletion of {} results, {} model snapshots and {} model state documents",, +                deletedResultCount, deletedModelSnapshotCount, deletedModelStateCount);, +++ b/elasticsearch/src/main/java/org/elasticsearch/xpack/prelert/action/RevertModelSnapshotAction.java, +            logger.debug("Received request to revert to time '{}' description '{}' snapshot id '{}' for job '{}', deleting intervening " +, +                            "results: {}",, +                    request.getTime(), request.getDescription(), request.getSnapshotId(), request.getJobId(),, +                    request.getDeleteInterveningResults());, +            if (job.count() > 0 && allocation.getStatus().equals(JobStatus.CLOSED) == false) {, +                    logger.info("Deleting results after '" + deleteAfter + "'");, +                    OldDataRemover remover = new OldDataRemover(bulkDeleterFactory);, +++ b/elasticsearch/src/main/java/org/elasticsearch/xpack/prelert/job/persistence/ElasticsearchBulkDeleter.java, +import org.apache.logging.log4j.Level;, +import org.elasticsearch.index.query.RangeQueryBuilder;, +import java.util.Date;, +    private long deletedResultCount;, +    public ElasticsearchBulkDeleter(Client client, String jobId, boolean quiet) {, +        this.client = Objects.requireNonNull(client);, +        this.jobId = Objects.requireNonNull(jobId);, +        bulkRequestBuilder = client.prepareBulk();, +        deletedResultCount = 0;, +        deletedModelSnapshotCount = 0;, +        deletedModelStateCount = 0;, +        this.quiet = quiet;, +    public void deleteResultsFromTime(long cutoffEpochMs) {, +        String index = JobResultsPersister.getJobIndexName(jobId);, +        RangeQueryBuilder timeRange = QueryBuilders.rangeQuery(ElasticsearchMappings.ES_TIMESTAMP);, +        timeRange.gte(cutoffEpochMs);, +        timeRange.lt(new Date().getTime());, +        SearchResponse searchResponse = client.prepareSearch(index), +                .setFetchSource(false), +                .setQuery(timeRange), +                .setScroll(SCROLL_CONTEXT_DURATION), +                .get();, +        String scrollId = searchResponse.getScrollId();, +        long totalHits = searchResponse.getHits().totalHits();, +        long totalDeletedCount = 0;, +        while (totalDeletedCount < totalHits) {, +                LOGGER.trace("Search hit for result: {}", hit.getId());, +                ++totalDeletedCount;]