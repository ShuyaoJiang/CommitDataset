[+++ b/client/rest-high-level/src/main/java/org/elasticsearch/client/security/PutRoleMappingResponse.java, +        ConstructingObjectParser<Boolean, Void> roleMappingParser = new ConstructingObjectParser<>(, +                "put_role_mapping_response.role_mapping", true, args -> (Boolean) args[0]);, +        roleMappingParser.declareBoolean(constructorArg(), new ParseField("created"));, +        PARSER.declareObject(constructorArg(), roleMappingParser::parse, new ParseField("role_mapping"));, +++ b/client/rest-high-level/src/main/java/org/elasticsearch/client/security/PutRoleMappingResponse.java, +        ConstructingObjectParser<Boolean, Void> roleMappingParser = new ConstructingObjectParser<>(, +                "put_role_mapping_response.role_mapping", true, args -> (Boolean) args[0]);, +        roleMappingParser.declareBoolean(constructorArg(), new ParseField("created"));, +        PARSER.declareObject(constructorArg(), roleMappingParser::parse, new ParseField("role_mapping"));, +++ b/libs/x-content/src/main/java/org/elasticsearch/common/xcontent/ObjectParser.java, +                /*, +                 * Well behaving parsers should consume the entire object but, +                 * asserting that they do that is not something we can do, +                 * efficiently here. Instead we can check that they end on an, +                 * END_OBJECT. They could end on the *wrong* end object and, +                 * this test won't catch them, but that is the price that we pay, +                 * for having a cheap test., +                 */, +                if (parser.currentToken() != XContentParser.Token.END_OBJECT) {, +                    throw new IllegalStateException("parser for [" + currentFieldName + "] did not end on END_OBJECT");, +                }, +                /*, +                 * Well behaving parsers should consume the entire array but, +                 * asserting that they do that is not something we can do, +                 * efficiently here. Instead we can check that they end on an, +                 * END_ARRAY. They could end on the *wrong* end array and, +                 * this test won't catch them, but that is the price that we pay, +                 * for having a cheap test., +                 */, +                if (parser.currentToken() != XContentParser.Token.END_ARRAY) {, +                    throw new IllegalStateException("parser for [" + currentFieldName + "] did not end on END_ARRAY");, +                }, +++ b/client/rest-high-level/src/main/java/org/elasticsearch/client/security/PutRoleMappingResponse.java, +        ConstructingObjectParser<Boolean, Void> roleMappingParser = new ConstructingObjectParser<>(, +                "put_role_mapping_response.role_mapping", true, args -> (Boolean) args[0]);, +        roleMappingParser.declareBoolean(constructorArg(), new ParseField("created"));, +        PARSER.declareObject(constructorArg(), roleMappingParser::parse, new ParseField("role_mapping"));, +++ b/libs/x-content/src/main/java/org/elasticsearch/common/xcontent/ObjectParser.java, +                /*, +                 * Well behaving parsers should consume the entire object but, +                 * asserting that they do that is not something we can do, +                 * efficiently here. Instead we can check that they end on an, +                 * END_OBJECT. They could end on the *wrong* end object and, +                 * this test won't catch them, but that is the price that we pay, +                 * for having a cheap test., +                 */, +                if (parser.currentToken() != XContentParser.Token.END_OBJECT) {, +                    throw new IllegalStateException("parser for [" + currentFieldName + "] did not end on END_OBJECT");, +                }, +                /*, +                 * Well behaving parsers should consume the entire array but, +                 * asserting that they do that is not something we can do, +                 * efficiently here. Instead we can check that they end on an, +                 * END_ARRAY. They could end on the *wrong* end array and, +                 * this test won't catch them, but that is the price that we pay, +                 * for having a cheap test., +                 */, +                if (parser.currentToken() != XContentParser.Token.END_ARRAY) {, +                    throw new IllegalStateException("parser for [" + currentFieldName + "] did not end on END_ARRAY");, +                }, +++ b/libs/x-content/src/test/java/org/elasticsearch/common/xcontent/ObjectParserTests.java, +import java.util.concurrent.atomic.AtomicReference;, +    public void testNoopDeclareObject() throws IOException {, +        ObjectParser<AtomicReference<String>, Void> parser = new ObjectParser<>("noopy", AtomicReference::new);, +        parser.declareString(AtomicReference::set, new ParseField("body"));, +        parser.declareObject((a,b) -> {}, (p, c) -> null, new ParseField("noop"));, +, +        assertEquals("i", parser.parse(createParser(JsonXContent.jsonXContent, "{\"body\": \"i\"}"), null).get());, +        Exception garbageException = expectThrows(IllegalStateException.class, () -> parser.parse(, +                createParser(JsonXContent.jsonXContent, "{\"noop\": {\"garbage\": \"shouldn't\"}}"),, +                null));, +        assertEquals("parser for [noop] did not end on END_OBJECT", garbageException.getMessage());, +        Exception sneakyException = expectThrows(IllegalStateException.class, () -> parser.parse(, +                createParser(JsonXContent.jsonXContent, "{\"noop\": {\"body\": \"shouldn't\"}}"),, +                null));, +        assertEquals("parser for [noop] did not end on END_OBJECT", sneakyException.getMessage());, +    }, +, +    public void testNoopDeclareField() throws IOException {, +        ObjectParser<AtomicReference<String>, Void> parser = new ObjectParser<>("noopy", AtomicReference::new);, +        parser.declareString(AtomicReference::set, new ParseField("body"));, +        parser.declareField((a,b) -> {}, (p, c) -> null, new ParseField("noop"), ValueType.STRING_ARRAY);, +, +        assertEquals("i", parser.parse(createParser(JsonXContent.jsonXContent, "{\"body\": \"i\"}"), null).get());, +        Exception e = expectThrows(IllegalStateException.class, () -> parser.parse(, +                createParser(JsonXContent.jsonXContent, "{\"noop\": [\"ignored\"]}"),, +                null));, +        assertEquals("parser for [noop] did not end on END_ARRAY", e.getMessage());, +    }, +, +    public void testNoopDeclareObjectArray() throws IOException {, +        ObjectParser<AtomicReference<String>, Void> parser = new ObjectParser<>("noopy", AtomicReference::new);, +        parser.declareString(AtomicReference::set, new ParseField("body"));, +        parser.declareObjectArray((a,b) -> {}, (p, c) -> null, new ParseField("noop"));, +, +        XContentParseException garbageError = expectThrows(XContentParseException.class, () -> parser.parse(, +                createParser(JsonXContent.jsonXContent, "{\"noop\": [{\"garbage\": \"shouldn't\"}}]"),, +                null));, +        assertEquals("expected value but got [FIELD_NAME]", garbageError.getCause().getMessage());]