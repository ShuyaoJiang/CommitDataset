[+++ b/x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authc/TokenService.java, +                                final TokensInvalidationResult incompleteResult = new TokensInvalidationResult(invalidated,, +                                        previouslyInvalidated, failedRequestResponses);, +                                final Runnable retryWithContextRunnable = client.threadPool().getThreadContext().preserveContext(, +                                        () -> indexInvalidation(retryTokenDocIds, listener, backoff, srcPrefix, incompleteResult));, +                                client.threadPool().schedule(retryWithContextRunnable, backoff.next(), GENERIC);, +                                logger.warn("failed to invalidate [{}] tokens out of [{}] after all retries", retryTokenDocIds.size(),, +                                        tokenIds.size());, +                            final TokensInvalidationResult result = new TokensInvalidationResult(invalidated, previouslyInvalidated,, +                            final Runnable retryWithContextRunnable = client.threadPool().getThreadContext(), +                                    .preserveContext(() -> indexInvalidation(tokenIds, listener, backoff, srcPrefix, previousResult));, +                            client.threadPool().schedule(retryWithContextRunnable, backoff.next(), GENERIC);, +        final Consumer<Exception> onFailure = ex -> listener.onFailure(traceLog("find token by refresh token", refreshToken, ex));, +        final Consumer<Exception> maybeRetryOnFailure = ex -> {, +            if (backoff.hasNext()) {, +                final TimeValue backofTimeValue = backoff.next();, +                logger.debug("retrying after [" + backofTimeValue + "] back off");, +                final Runnable retryWithContextRunnable = client.threadPool().getThreadContext(), +                        .preserveContext(() -> findTokenFromRefreshToken(refreshToken, listener, backoff));, +                client.threadPool().schedule(retryWithContextRunnable, backofTimeValue, GENERIC);, +            } else {, +                logger.warn("failed to find token from refresh token after all retries");, +                onFailure.accept(ex);, +            }, +        };, +            maybeRetryOnFailure.accept(invalidGrantException("could not refresh the requested token"));, +            final SearchRequest request = client.prepareSearch(SecurityIndexManager.SECURITY_INDEX_NAME), +                    .setQuery(QueryBuilders.boolQuery(), +                            .filter(QueryBuilders.termQuery("doc_type", TOKEN_DOC_TYPE)), +                            .filter(QueryBuilders.termQuery("refresh_token.token", refreshToken))), +                    .seqNoAndPrimaryTerm(true), +                    .request();, +                            logger.debug("find token from refresh token response timed out, retrying");, +                            maybeRetryOnFailure.accept(invalidGrantException("could not refresh the requested token"));, +                            logger.debug("find token from refresh token request failed because of unavailable shards, retrying");, +                            maybeRetryOnFailure.accept(invalidGrantException("could not refresh the requested token"));, +        final Consumer<Exception> onFailure = ex -> listener.onFailure(traceLog("refresh token", tokenDocId, ex));, +                    private final Consumer<Exception> maybeRetryOnFailure = ex -> {, +                        if (backoff.hasNext()) {, +                            final TimeValue backofTimeValue = backoff.next();, +                            logger.debug("retrying after [" + backofTimeValue + "] back off");, +                            final Runnable retryWithContextRunnable = client.threadPool().getThreadContext(), +                                    .preserveContext(() -> getTokenDocAsync(supersedingTokenDocId, this));, +                            client.threadPool().schedule(retryWithContextRunnable, backofTimeValue, GENERIC);, +                        } else {, +                            logger.warn("back off retries exhausted");, +                            onFailure.accept(ex);, +                        }, +                    };, +, +                        } else {, +                            maybeRetryOnFailure.accept(invalidGrantException("could not refresh the requested token"));, +                            maybeRetryOnFailure.accept(invalidGrantException("could not refresh the requested token"));, +                                final Runnable retryWithContextRunnable = client.threadPool().getThreadContext(), +                                        .preserveContext(() -> innerRefresh(tokenDocId, source, seqNo, primaryTerm, clientAuth, listener,, +                                                backoff, refreshRequested));, +                                client.threadPool().schedule(retryWithContextRunnable, backoff.next(), GENERIC);, +                                logger.debug("version conflict while updating document [{}], attempting to get it again", tokenDocId);, +                                            innerRefresh(tokenDocId, response.getSource(), response.getSeqNo(), response.getPrimaryTerm(),, +                                                    clientAuth, listener, backoff, refreshRequested);, +                                                logger.info("could not get token document [{}] for refresh, retrying", tokenDocId);, +                                                final Runnable retryWithContextRunnable = client.threadPool().getThreadContext(), +                                                        .preserveContext(() -> getTokenDocAsync(tokenDocId, this));, +                                                client.threadPool().schedule(retryWithContextRunnable, backoff.next(), GENERIC);, +                                                logger.warn("could not get token document [{}] for refresh after all retries", tokenDocId);, +                                    final Runnable retryWithContextRunnable = client.threadPool().getThreadContext().preserveContext(, +                                                    refreshRequested));, +                                    client.threadPool().schedule(retryWithContextRunnable, backoff.next(), GENERIC);]