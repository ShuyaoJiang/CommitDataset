[+++ b/docs/reference/query-dsl/filters.asciidoc, +include::filters/indices-filter.asciidoc[], +, +++ b/docs/reference/query-dsl/filters.asciidoc, +include::filters/indices-filter.asciidoc[], +, +++ b/docs/reference/query-dsl/filters/indices-filter.asciidoc, +`filter` is mandatory, as well as `indices` (or `index`)., +coming[0.90.8], +[TIP], +===================================================================, +The fields order is important: if the `indices` are provided before `filter`, +or `no_match_filter`, the related filters get parsed only against the indices, +that they are going to be executed on. This is useful to avoid parsing filters, +when it is not necessary and prevent potential mapping errors., +===================================================================, +++ b/docs/reference/query-dsl/filters.asciidoc, +include::filters/indices-filter.asciidoc[], +, +++ b/docs/reference/query-dsl/filters/indices-filter.asciidoc, +`filter` is mandatory, as well as `indices` (or `index`)., +coming[0.90.8], +[TIP], +===================================================================, +The fields order is important: if the `indices` are provided before `filter`, +or `no_match_filter`, the related filters get parsed only against the indices, +that they are going to be executed on. This is useful to avoid parsing filters, +when it is not necessary and prevent potential mapping errors., +===================================================================, +++ b/docs/reference/query-dsl/queries/indices-query.asciidoc, +`query` is mandatory, as well as `indices` (or `index`)., +coming[0.90.8], +[TIP], +===================================================================, +The fields order is important: if the `indices` are provided before `query`, +or `no_match_query`, the related queries get parsed only against the indices, +that they are going to be executed on. This is useful to avoid parsing queries, +when it is not necessary and prevent potential mapping errors., +===================================================================, +++ b/docs/reference/query-dsl/filters.asciidoc, +include::filters/indices-filter.asciidoc[], +, +++ b/docs/reference/query-dsl/filters/indices-filter.asciidoc, +`filter` is mandatory, as well as `indices` (or `index`)., +coming[0.90.8], +[TIP], +===================================================================, +The fields order is important: if the `indices` are provided before `filter`, +or `no_match_filter`, the related filters get parsed only against the indices, +that they are going to be executed on. This is useful to avoid parsing filters, +when it is not necessary and prevent potential mapping errors., +===================================================================, +++ b/docs/reference/query-dsl/queries/indices-query.asciidoc, +`query` is mandatory, as well as `indices` (or `index`)., +coming[0.90.8], +[TIP], +===================================================================, +The fields order is important: if the `indices` are provided before `query`, +or `no_match_query`, the related queries get parsed only against the indices, +that they are going to be executed on. This is useful to avoid parsing queries, +when it is not necessary and prevent potential mapping errors., +===================================================================, +++ b/src/main/java/org/elasticsearch/index/query/IndicesFilterParser.java, +        boolean currentIndexMatchesIndices = false;, +                    //TODO We are able to decide whether to parse the filter or not only if indices in the query appears first, +                    if (indicesFound && !currentIndexMatchesIndices) {, +                        parseContext.parser().skipChildren(); // skip the filter object without parsing it, +                    if (indicesFound && currentIndexMatchesIndices) {, +                        parseContext.parser().skipChildren(); // skip the filter object without parsing it, +                        throw  new QueryParsingException(parseContext.index(), "[indices] indices or index already specified");, +                    while (parser.nextToken() != XContentParser.Token.END_ARRAY) {, +                            throw new QueryParsingException(parseContext.index(), "[indices] no value specified for 'indices' entry");, +                    currentIndexMatchesIndices = matchesIndices(parseContext.index().name(), indices.toArray(new String[indices.size()]));, +                        throw  new QueryParsingException(parseContext.index(), "[indices] indices or index already specified");, +                    currentIndexMatchesIndices = matchesIndices(parseContext.index().name(), parser.text());, +            throw new QueryParsingException(parseContext.index(), "[indices] requires 'indices' or 'index' element");, +        if (currentIndexMatchesIndices) {, +            return filter;, +        return noMatchFilter;, +    protected boolean matchesIndices(String currentIndex, String... indices) {, +        String[] concreteIndices = clusterService.state().metaData().concreteIndices(indices, IgnoreIndices.MISSING, true);, +            if (Regex.simpleMatch(index, currentIndex)) {, +++ b/docs/reference/query-dsl/filters.asciidoc, +include::filters/indices-filter.asciidoc[], +, +++ b/docs/reference/query-dsl/filters/indices-filter.asciidoc, +`filter` is mandatory, as well as `indices` (or `index`)., +coming[0.90.8], +[TIP], +===================================================================, +The fields order is important: if the `indices` are provided before `filter`, +or `no_match_filter`, the related filters get parsed only against the indices, +that they are going to be executed on. This is useful to avoid parsing filters, +when it is not necessary and prevent potential mapping errors., +===================================================================, +++ b/docs/reference/query-dsl/queries/indices-query.asciidoc, +`query` is mandatory, as well as `indices` (or `index`)., +coming[0.90.8], +[TIP], +===================================================================]