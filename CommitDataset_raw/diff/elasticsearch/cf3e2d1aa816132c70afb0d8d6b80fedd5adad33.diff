[+++ b/client/rest/src/main/java/org/elasticsearch/client/HeapBufferedAsyncResponseConsumer.java, +    private final int bufferLimit;, +        this.bufferLimit = DEFAULT_BUFFER_LIMIT;, +        this.bufferLimit = bufferLimit;, +        if (len > bufferLimit) {, +                    "] for the configured buffer limit [" + bufferLimit + "]");, +++ b/client/rest/src/main/java/org/elasticsearch/client/HeapBufferedAsyncResponseConsumer.java, +    private final int bufferLimit;, +        this.bufferLimit = DEFAULT_BUFFER_LIMIT;, +        this.bufferLimit = bufferLimit;, +        if (len > bufferLimit) {, +                    "] for the configured buffer limit [" + bufferLimit + "]");, +++ b/core/src/main/java/org/elasticsearch/ElasticsearchException.java, +        // 28 was DeleteFailedEngineException, +        // 80 used to be for IndexFailedEngineException, removed in 6.0, +++ b/client/rest/src/main/java/org/elasticsearch/client/HeapBufferedAsyncResponseConsumer.java, +    private final int bufferLimit;, +        this.bufferLimit = DEFAULT_BUFFER_LIMIT;, +        this.bufferLimit = bufferLimit;, +        if (len > bufferLimit) {, +                    "] for the configured buffer limit [" + bufferLimit + "]");, +++ b/core/src/main/java/org/elasticsearch/ElasticsearchException.java, +        // 28 was DeleteFailedEngineException, +        // 80 used to be for IndexFailedEngineException, removed in 6.0, +++ b/core/src/main/java/org/elasticsearch/Version.java, +++ b/client/rest/src/main/java/org/elasticsearch/client/HeapBufferedAsyncResponseConsumer.java, +    private final int bufferLimit;, +        this.bufferLimit = DEFAULT_BUFFER_LIMIT;, +        this.bufferLimit = bufferLimit;, +        if (len > bufferLimit) {, +                    "] for the configured buffer limit [" + bufferLimit + "]");, +++ b/core/src/main/java/org/elasticsearch/ElasticsearchException.java, +        // 28 was DeleteFailedEngineException, +        // 80 used to be for IndexFailedEngineException, removed in 6.0, +++ b/core/src/main/java/org/elasticsearch/Version.java, +++ b/core/src/main/java/org/elasticsearch/action/bulk/TransportShardBulkAction.java, +import org.elasticsearch.index.mapper.MapperParsingException;, +import static org.elasticsearch.action.delete.TransportDeleteAction.executeDeleteRequestOnPrimary;, +import static org.elasticsearch.action.delete.TransportDeleteAction.executeDeleteRequestOnReplica;, +import static org.elasticsearch.action.index.TransportIndexAction.executeIndexRequestOnPrimary;, +import static org.elasticsearch.action.index.TransportIndexAction.executeIndexRequestOnReplica;, +public class TransportShardBulkAction extends TransportWriteAction<BulkShardRequest, BulkShardRequest, BulkShardResponse> {, +                indexNameExpressionResolver, BulkShardRequest::new, BulkShardRequest::new, ThreadPool.Names.BULK);, +    protected WritePrimaryResult shardOperationOnPrimary(BulkShardRequest request, IndexShard primary) throws Exception {, +        return new WritePrimaryResult(request, response, location, null, primary);, +    private Translog.Location executeBulkItemRequest(IndexMetaData metaData, IndexShard primary,, +                                                     Translog.Location location, int requestIndex) throws Exception {, +        final DocWriteRequest itemRequest = request.items()[requestIndex].request();, +        preVersions[requestIndex] = itemRequest.version();, +        preVersionTypes[requestIndex] = itemRequest.versionType();, +        DocWriteRequest.OpType opType = itemRequest.opType();, +            // execute item request, +            final Engine.Result operationResult;, +            final DocWriteResponse response;, +            final BulkItemRequest replicaRequest;, +            switch (itemRequest.opType()) {, +                case CREATE:, +                case INDEX:, +                    final IndexRequest indexRequest = (IndexRequest) itemRequest;, +                    Engine.IndexResult indexResult = executeIndexRequestOnPrimary(indexRequest, primary, mappingUpdatedAction);, +                    operationResult = indexResult;, +                    response = indexResult.hasFailure() ? null, +                            : new IndexResponse(primary.shardId(), indexRequest.type(), indexRequest.id(),, +                                indexResult.getVersion(), indexResult.isCreated());, +                    replicaRequest = request.items()[requestIndex];, +                    break;, +                case UPDATE:, +                    UpdateResultHolder updateResultHolder = executeUpdateRequest(((UpdateRequest) itemRequest),, +                            primary, metaData, request, requestIndex);, +                    operationResult = updateResultHolder.operationResult;, +                    response = updateResultHolder.response;, +                    replicaRequest = updateResultHolder.replicaRequest;, +                    break;, +                case DELETE:, +                    final DeleteRequest deleteRequest = (DeleteRequest) itemRequest;, +                    Engine.DeleteResult deleteResult = executeDeleteRequestOnPrimary(deleteRequest, primary);, +                    operationResult = deleteResult;, +                    response = deleteResult.hasFailure() ? null :, +                            new DeleteResponse(request.shardId(), deleteRequest.type(), deleteRequest.id(),, +                                deleteResult.getVersion(), deleteResult.isFound());, +                    replicaRequest = request.items()[requestIndex];, +                    break;, +                default: throw new IllegalStateException("unexpected opType [" + itemRequest.opType() + "] found");, +            request.items()[requestIndex] = replicaRequest;, +            if (operationResult == null) { // in case of noop update operation, +                assert response.getResult() == DocWriteResponse.Result.NOOP, +                        : "only noop update can have null operation";, +                replicaRequest.setIgnoreOnReplica();, +                replicaRequest.setPrimaryResponse(new BulkItemResponse(replicaRequest.id(), opType, response));, +            } else if (operationResult.hasFailure() == false) {, +                location = locationToSync(location, operationResult.getTranslogLocation());, +                BulkItemResponse primaryResponse = new BulkItemResponse(replicaRequest.id(), opType, response);, +                replicaRequest.setPrimaryResponse(primaryResponse);, +                // set the ShardInfo to 0 so we can safely send it to the replicas. We won't use it in the real response though., +                primaryResponse.getResponse().setShardInfo(new ShardInfo());, +            } else {, +                DocWriteRequest docWriteRequest = replicaRequest.request();, +                Exception failure = operationResult.getFailure();, +                if (isConflictException(failure)) {, +                    logger.trace((Supplier<?>) () -> new ParameterizedMessage("{} failed to execute bulk item ({}) {}",]