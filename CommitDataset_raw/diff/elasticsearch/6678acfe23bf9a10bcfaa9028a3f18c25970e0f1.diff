[+++ b/core/src/main/java/org/elasticsearch/action/index/IndexRequest.java, +import org.elasticsearch.Version;, +            Version version = Version.indexCreated(metaData.getIndices().get(concreteIndex).settings());, +                    mappingMd != null ? mappingMd.timestamp().dateTimeFormatter() : TimestampFieldMapper.Defaults.DATE_TIME_FORMATTER,, +                    version);, +                            Version version = Version.indexCreated(metaData.getIndices().get(concreteIndex).settings());, +                            timestamp = MappingMetaData.Timestamp.parseStringTimestamp(timestamp, mappingMd.timestamp().dateTimeFormatter(), version);, +                Version version = Version.indexCreated(metaData.getIndices().get(concreteIndex).settings());, +                timestamp = MappingMetaData.Timestamp.parseStringTimestamp(defaultTimestamp, mappingMd.timestamp().dateTimeFormatter(), version);, +++ b/core/src/main/java/org/elasticsearch/action/index/IndexRequest.java, +import org.elasticsearch.Version;, +            Version version = Version.indexCreated(metaData.getIndices().get(concreteIndex).settings());, +                    mappingMd != null ? mappingMd.timestamp().dateTimeFormatter() : TimestampFieldMapper.Defaults.DATE_TIME_FORMATTER,, +                    version);, +                            Version version = Version.indexCreated(metaData.getIndices().get(concreteIndex).settings());, +                            timestamp = MappingMetaData.Timestamp.parseStringTimestamp(timestamp, mappingMd.timestamp().dateTimeFormatter(), version);, +                Version version = Version.indexCreated(metaData.getIndices().get(concreteIndex).settings());, +                timestamp = MappingMetaData.Timestamp.parseStringTimestamp(defaultTimestamp, mappingMd.timestamp().dateTimeFormatter(), version);, +++ b/core/src/main/java/org/elasticsearch/cluster/metadata/MappingMetaData.java, +import org.elasticsearch.Version;, +        private static final FormatDateTimeFormatter EPOCH_MILLIS_PARSER = Joda.forPattern("epoch_millis");, +, +        public static String parseStringTimestamp(String timestampAsString, FormatDateTimeFormatter dateTimeFormatter,, +                                                  Version version) throws TimestampParsingException {, +            try {, +                // no need for unix timestamp parsing in 2.x, +                FormatDateTimeFormatter formatter = version.onOrAfter(Version.V_2_0_0) ? dateTimeFormatter : EPOCH_MILLIS_PARSER;, +                return Long.toString(formatter.parser().parseMillis(timestampAsString));, +            } catch (RuntimeException e) {, +                if (version.before(Version.V_2_0_0)) {, +                    } catch (RuntimeException e1) {, +                        throw new TimestampParsingException(timestampAsString, e1);, +                    }, +                }, +++ b/core/src/main/java/org/elasticsearch/action/index/IndexRequest.java, +import org.elasticsearch.Version;, +            Version version = Version.indexCreated(metaData.getIndices().get(concreteIndex).settings());, +                    mappingMd != null ? mappingMd.timestamp().dateTimeFormatter() : TimestampFieldMapper.Defaults.DATE_TIME_FORMATTER,, +                    version);, +                            Version version = Version.indexCreated(metaData.getIndices().get(concreteIndex).settings());, +                            timestamp = MappingMetaData.Timestamp.parseStringTimestamp(timestamp, mappingMd.timestamp().dateTimeFormatter(), version);, +                Version version = Version.indexCreated(metaData.getIndices().get(concreteIndex).settings());, +                timestamp = MappingMetaData.Timestamp.parseStringTimestamp(defaultTimestamp, mappingMd.timestamp().dateTimeFormatter(), version);, +++ b/core/src/main/java/org/elasticsearch/cluster/metadata/MappingMetaData.java, +import org.elasticsearch.Version;, +        private static final FormatDateTimeFormatter EPOCH_MILLIS_PARSER = Joda.forPattern("epoch_millis");, +, +        public static String parseStringTimestamp(String timestampAsString, FormatDateTimeFormatter dateTimeFormatter,, +                                                  Version version) throws TimestampParsingException {, +            try {, +                // no need for unix timestamp parsing in 2.x, +                FormatDateTimeFormatter formatter = version.onOrAfter(Version.V_2_0_0) ? dateTimeFormatter : EPOCH_MILLIS_PARSER;, +                return Long.toString(formatter.parser().parseMillis(timestampAsString));, +            } catch (RuntimeException e) {, +                if (version.before(Version.V_2_0_0)) {, +                    } catch (RuntimeException e1) {, +                        throw new TimestampParsingException(timestampAsString, e1);, +                    }, +                }, +++ b/core/src/main/java/org/elasticsearch/index/mapper/core/DateFieldMapper.java, +import org.elasticsearch.Version;, +import org.elasticsearch.index.mapper.MappedFieldType;, +import org.elasticsearch.index.mapper.Mapper;, +import org.elasticsearch.index.mapper.MapperParsingException;, +import org.elasticsearch.index.mapper.ParseContext;, +import java.util.*;, +        public static final FormatDateTimeFormatter DATE_TIME_FORMATTER = Joda.forPattern("dateOptionalTime||epoch_millis", Locale.ROOT);, +            // TODO MOVE ME OUTSIDE OF THIS SPACE?, +            if (Version.indexCreated(context.indexSettings()).before(Version.V_2_0_0)) {, +                boolean includesEpochFormatter = dateTimeFormatter.format().contains("epoch_");, +                if (!includesEpochFormatter) {, +                    String format = fieldType().timeUnit().equals(TimeUnit.SECONDS) ? "epoch_second" : "epoch_millis";, +                    fieldType().setDateTimeFormatter(Joda.forPattern(format + "||" + dateTimeFormatter.format()));, +                }, +            }, +++ b/core/src/main/java/org/elasticsearch/action/index/IndexRequest.java, +import org.elasticsearch.Version;, +            Version version = Version.indexCreated(metaData.getIndices().get(concreteIndex).settings());, +                    mappingMd != null ? mappingMd.timestamp().dateTimeFormatter() : TimestampFieldMapper.Defaults.DATE_TIME_FORMATTER,, +                    version);, +                            Version version = Version.indexCreated(metaData.getIndices().get(concreteIndex).settings());, +                            timestamp = MappingMetaData.Timestamp.parseStringTimestamp(timestamp, mappingMd.timestamp().dateTimeFormatter(), version);, +                Version version = Version.indexCreated(metaData.getIndices().get(concreteIndex).settings());, +                timestamp = MappingMetaData.Timestamp.parseStringTimestamp(defaultTimestamp, mappingMd.timestamp().dateTimeFormatter(), version);, +++ b/core/src/main/java/org/elasticsearch/cluster/metadata/MappingMetaData.java, +import org.elasticsearch.Version;, +        private static final FormatDateTimeFormatter EPOCH_MILLIS_PARSER = Joda.forPattern("epoch_millis");, +, +        public static String parseStringTimestamp(String timestampAsString, FormatDateTimeFormatter dateTimeFormatter,, +                                                  Version version) throws TimestampParsingException {, +            try {, +                // no need for unix timestamp parsing in 2.x, +                FormatDateTimeFormatter formatter = version.onOrAfter(Version.V_2_0_0) ? dateTimeFormatter : EPOCH_MILLIS_PARSER;, +                return Long.toString(formatter.parser().parseMillis(timestampAsString));, +            } catch (RuntimeException e) {, +                if (version.before(Version.V_2_0_0)) {, +                    } catch (RuntimeException e1) {, +                        throw new TimestampParsingException(timestampAsString, e1);, +                    }, +                }]