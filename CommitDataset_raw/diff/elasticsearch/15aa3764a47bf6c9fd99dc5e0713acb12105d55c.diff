[+++ b/docs/reference/modules/indices/recovery.asciidoc, +`indices.recovery.max_concurrent_file_chunks`::, +    Controls the number of file chunk requests that can be sent in parallel per recovery., +    As multiple recoveries are already running in parallel (controlled by, +    cluster.routing.allocation.node_concurrent_recoveries), increasing this expert-level, +    setting might only help in situations where peer recovery of a single shard is not, +    reaching the total inbound and outbound peer recovery traffic as configured by, +    indices.recovery.max_bytes_per_sec, but is CPU-bound instead, typically when using, +    transport-level security or compression. Defaults to `2`., +, +++ b/docs/reference/modules/indices/recovery.asciidoc, +`indices.recovery.max_concurrent_file_chunks`::, +    Controls the number of file chunk requests that can be sent in parallel per recovery., +    As multiple recoveries are already running in parallel (controlled by, +    cluster.routing.allocation.node_concurrent_recoveries), increasing this expert-level, +    setting might only help in situations where peer recovery of a single shard is not, +    reaching the total inbound and outbound peer recovery traffic as configured by, +    indices.recovery.max_bytes_per_sec, but is CPU-bound instead, typically when using, +    transport-level security or compression. Defaults to `2`., +, +++ b/server/src/main/java/org/elasticsearch/common/settings/ClusterSettings.java, +                    RecoverySettings.INDICES_RECOVERY_MAX_CONCURRENT_FILE_CHUNKS_SETTING,, +++ b/docs/reference/modules/indices/recovery.asciidoc, +`indices.recovery.max_concurrent_file_chunks`::, +    Controls the number of file chunk requests that can be sent in parallel per recovery., +    As multiple recoveries are already running in parallel (controlled by, +    cluster.routing.allocation.node_concurrent_recoveries), increasing this expert-level, +    setting might only help in situations where peer recovery of a single shard is not, +    reaching the total inbound and outbound peer recovery traffic as configured by, +    indices.recovery.max_bytes_per_sec, but is CPU-bound instead, typically when using, +    transport-level security or compression. Defaults to `2`., +, +++ b/server/src/main/java/org/elasticsearch/common/settings/ClusterSettings.java, +                    RecoverySettings.INDICES_RECOVERY_MAX_CONCURRENT_FILE_CHUNKS_SETTING,, +++ b/server/src/main/java/org/elasticsearch/indices/recovery/PeerRecoverySourceService.java, +                handler = new RecoverySourceHandler(shard, recoveryTarget, request,, +                    Math.toIntExact(recoverySettings.getChunkSize().getBytes()), recoverySettings.getMaxConcurrentFileChunks());, +++ b/docs/reference/modules/indices/recovery.asciidoc, +`indices.recovery.max_concurrent_file_chunks`::, +    Controls the number of file chunk requests that can be sent in parallel per recovery., +    As multiple recoveries are already running in parallel (controlled by, +    cluster.routing.allocation.node_concurrent_recoveries), increasing this expert-level, +    setting might only help in situations where peer recovery of a single shard is not, +    reaching the total inbound and outbound peer recovery traffic as configured by, +    indices.recovery.max_bytes_per_sec, but is CPU-bound instead, typically when using, +    transport-level security or compression. Defaults to `2`., +, +++ b/server/src/main/java/org/elasticsearch/common/settings/ClusterSettings.java, +                    RecoverySettings.INDICES_RECOVERY_MAX_CONCURRENT_FILE_CHUNKS_SETTING,, +++ b/server/src/main/java/org/elasticsearch/indices/recovery/PeerRecoverySourceService.java, +                handler = new RecoverySourceHandler(shard, recoveryTarget, request,, +                    Math.toIntExact(recoverySettings.getChunkSize().getBytes()), recoverySettings.getMaxConcurrentFileChunks());, +++ b/server/src/main/java/org/elasticsearch/indices/recovery/PeerRecoveryTargetService.java, +import org.elasticsearch.action.ActionListener;, +import org.elasticsearch.action.support.HandledTransportAction;, +            try (RecoveryRef recoveryRef = onGoingRecoveries.getRecoverySafe(request.recoveryId(), request.shardId())) {, +                final ActionListener<TransportResponse> listener =, +                    new HandledTransportAction.ChannelActionListener<>(channel, Actions.FILE_CHUNK, request);, +                recoveryTarget.writeFileChunk(request.metadata(), request.position(), request.content(), request.lastChunk(),, +                    request.totalTranslogOps(),, +                    ActionListener.wrap(nullVal -> listener.onResponse(TransportResponse.Empty.INSTANCE), listener::onFailure));, +++ b/docs/reference/modules/indices/recovery.asciidoc, +`indices.recovery.max_concurrent_file_chunks`::, +    Controls the number of file chunk requests that can be sent in parallel per recovery., +    As multiple recoveries are already running in parallel (controlled by, +    cluster.routing.allocation.node_concurrent_recoveries), increasing this expert-level, +    setting might only help in situations where peer recovery of a single shard is not, +    reaching the total inbound and outbound peer recovery traffic as configured by, +    indices.recovery.max_bytes_per_sec, but is CPU-bound instead, typically when using, +    transport-level security or compression. Defaults to `2`., +, +++ b/server/src/main/java/org/elasticsearch/common/settings/ClusterSettings.java, +                    RecoverySettings.INDICES_RECOVERY_MAX_CONCURRENT_FILE_CHUNKS_SETTING,, +++ b/server/src/main/java/org/elasticsearch/indices/recovery/PeerRecoverySourceService.java, +                handler = new RecoverySourceHandler(shard, recoveryTarget, request,, +                    Math.toIntExact(recoverySettings.getChunkSize().getBytes()), recoverySettings.getMaxConcurrentFileChunks());, +++ b/server/src/main/java/org/elasticsearch/indices/recovery/PeerRecoveryTargetService.java, +import org.elasticsearch.action.ActionListener;, +import org.elasticsearch.action.support.HandledTransportAction;, +            try (RecoveryRef recoveryRef = onGoingRecoveries.getRecoverySafe(request.recoveryId(), request.shardId())) {, +                final ActionListener<TransportResponse> listener =, +                    new HandledTransportAction.ChannelActionListener<>(channel, Actions.FILE_CHUNK, request);, +                recoveryTarget.writeFileChunk(request.metadata(), request.position(), request.content(), request.lastChunk(),, +                    request.totalTranslogOps(),, +                    ActionListener.wrap(nullVal -> listener.onResponse(TransportResponse.Empty.INSTANCE), listener::onFailure));, +++ b/server/src/main/java/org/elasticsearch/indices/recovery/RecoverySettings.java, +     * Controls the maximum number of file chunk requests that can be sent concurrently from the source node to the target node., +     */, +    public static final Setting<Integer> INDICES_RECOVERY_MAX_CONCURRENT_FILE_CHUNKS_SETTING =, +        Setting.intSetting("indices.recovery.max_concurrent_file_chunks", 2, 1, 5, Property.Dynamic, Property.NodeScope);, +, +    /**, +    private volatile int maxConcurrentFileChunks;, +        this.maxConcurrentFileChunks = INDICES_RECOVERY_MAX_CONCURRENT_FILE_CHUNKS_SETTING.get(settings);, +        clusterSettings.addSettingsUpdateConsumer(INDICES_RECOVERY_MAX_CONCURRENT_FILE_CHUNKS_SETTING, this::setMaxConcurrentFileChunks);, +, +    public int getMaxConcurrentFileChunks() {, +        return maxConcurrentFileChunks;, +    }, +]