[+++ b/core/src/main/java/org/apache/lucene/queryparser/classic/ExistsFieldQueryExtension.java, +import org.elasticsearch.index.query.ExistsQueryParser;, +        return new ConstantScoreQuery(ExistsQueryParser.newFilter(parseContext, queryText, null));, +++ b/core/src/main/java/org/apache/lucene/queryparser/classic/ExistsFieldQueryExtension.java, +import org.elasticsearch.index.query.ExistsQueryParser;, +        return new ConstantScoreQuery(ExistsQueryParser.newFilter(parseContext, queryText, null));, +++ b/core/src/main/java/org/elasticsearch/cluster/action/shard/ShardStateAction.java, +import org.elasticsearch.cluster.routing.allocation.FailedRerouteAllocation;, +                List<FailedRerouteAllocation.FailedShard> shardRoutingsToBeApplied = new ArrayList<>(shardRoutingEntries.size());, +                    shardRoutingsToBeApplied.add(new FailedRerouteAllocation.FailedShard(shardRouting, shardRoutingEntry.reason));, +++ b/core/src/main/java/org/apache/lucene/queryparser/classic/ExistsFieldQueryExtension.java, +import org.elasticsearch.index.query.ExistsQueryParser;, +        return new ConstantScoreQuery(ExistsQueryParser.newFilter(parseContext, queryText, null));, +++ b/core/src/main/java/org/elasticsearch/cluster/action/shard/ShardStateAction.java, +import org.elasticsearch.cluster.routing.allocation.FailedRerouteAllocation;, +                List<FailedRerouteAllocation.FailedShard> shardRoutingsToBeApplied = new ArrayList<>(shardRoutingEntries.size());, +                    shardRoutingsToBeApplied.add(new FailedRerouteAllocation.FailedShard(shardRouting, shardRoutingEntry.reason));, +++ b/core/src/main/java/org/elasticsearch/cluster/metadata/MetaDataIndexStateService.java, +                    rtBuilder.addAsFromCloseToOpen(updatedState.metaData().index(index));, +++ b/core/src/main/java/org/apache/lucene/queryparser/classic/ExistsFieldQueryExtension.java, +import org.elasticsearch.index.query.ExistsQueryParser;, +        return new ConstantScoreQuery(ExistsQueryParser.newFilter(parseContext, queryText, null));, +++ b/core/src/main/java/org/elasticsearch/cluster/action/shard/ShardStateAction.java, +import org.elasticsearch.cluster.routing.allocation.FailedRerouteAllocation;, +                List<FailedRerouteAllocation.FailedShard> shardRoutingsToBeApplied = new ArrayList<>(shardRoutingEntries.size());, +                    shardRoutingsToBeApplied.add(new FailedRerouteAllocation.FailedShard(shardRouting, shardRoutingEntry.reason));, +++ b/core/src/main/java/org/elasticsearch/cluster/metadata/MetaDataIndexStateService.java, +                    rtBuilder.addAsFromCloseToOpen(updatedState.metaData().index(index));, +++ b/core/src/main/java/org/elasticsearch/cluster/routing/ImmutableShardRouting.java, +import org.elasticsearch.Version;, +import org.elasticsearch.common.Nullable;, +    protected UnassignedInfo unassignedInfo;, +, +        this(copy.index(), copy.id(), copy.currentNodeId(), copy.relocatingNodeId(), copy.restoreSource(), copy.primary(), copy.state(), version, copy.unassignedInfo());, +        this(index, shardId, currentNodeId, relocatingNodeId, restoreSource, primary, state, version, null);, +    }, +, +    public ImmutableShardRouting(String index, int shardId, String currentNodeId,, +                                  String relocatingNodeId, RestoreSource restoreSource, boolean primary, ShardRoutingState state, long version,, +                                  UnassignedInfo unassignedInfo) {, +        this.unassignedInfo = unassignedInfo;, +        assert !(state == ShardRoutingState.UNASSIGNED && unassignedInfo == null) : "unassigned shard must be created with meta";, +    @Nullable, +    public UnassignedInfo unassignedInfo() {, +        return unassignedInfo;, +    }, +, +    @Override, +        if (in.getVersion().onOrAfter(Version.V_1_7_0)) {, +            if (in.readBoolean()) {, +                unassignedInfo = new UnassignedInfo(in);, +            }, +        }, +        if (out.getVersion().onOrAfter(Version.V_1_7_0)) {, +            if (unassignedInfo != null) {, +                out.writeBoolean(true);, +                unassignedInfo.writeTo(out);, +            } else {, +                out.writeBoolean(false);, +            }, +        }, +        if (this.unassignedInfo != null) {, +            sb.append(", ").append(unassignedInfo.toString());, +        }, +        if (unassignedInfo != null) {, +            unassignedInfo.toXContent(builder, params);, +        }, +++ b/core/src/main/java/org/apache/lucene/queryparser/classic/ExistsFieldQueryExtension.java, +import org.elasticsearch.index.query.ExistsQueryParser;, +        return new ConstantScoreQuery(ExistsQueryParser.newFilter(parseContext, queryText, null));, +++ b/core/src/main/java/org/elasticsearch/cluster/action/shard/ShardStateAction.java, +import org.elasticsearch.cluster.routing.allocation.FailedRerouteAllocation;, +                List<FailedRerouteAllocation.FailedShard> shardRoutingsToBeApplied = new ArrayList<>(shardRoutingEntries.size());, +                    shardRoutingsToBeApplied.add(new FailedRerouteAllocation.FailedShard(shardRouting, shardRoutingEntry.reason));, +++ b/core/src/main/java/org/elasticsearch/cluster/metadata/MetaDataIndexStateService.java, +                    rtBuilder.addAsFromCloseToOpen(updatedState.metaData().index(index));, +++ b/core/src/main/java/org/elasticsearch/cluster/routing/ImmutableShardRouting.java, +import org.elasticsearch.Version;, +import org.elasticsearch.common.Nullable;, +    protected UnassignedInfo unassignedInfo;, +, +        this(copy.index(), copy.id(), copy.currentNodeId(), copy.relocatingNodeId(), copy.restoreSource(), copy.primary(), copy.state(), version, copy.unassignedInfo());, +        this(index, shardId, currentNodeId, relocatingNodeId, restoreSource, primary, state, version, null);, +    }, +, +    public ImmutableShardRouting(String index, int shardId, String currentNodeId,, +                                  String relocatingNodeId, RestoreSource restoreSource, boolean primary, ShardRoutingState state, long version,, +                                  UnassignedInfo unassignedInfo) {, +        this.unassignedInfo = unassignedInfo;, +        assert !(state == ShardRoutingState.UNASSIGNED && unassignedInfo == null) : "unassigned shard must be created with meta";, +    @Nullable, +    public UnassignedInfo unassignedInfo() {, +        return unassignedInfo;, +    }, +, +    @Override, +        if (in.getVersion().onOrAfter(Version.V_1_7_0)) {, +            if (in.readBoolean()) {, +                unassignedInfo = new UnassignedInfo(in);, +            }]