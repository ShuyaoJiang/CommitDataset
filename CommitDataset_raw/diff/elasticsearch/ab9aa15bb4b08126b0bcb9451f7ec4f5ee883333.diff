[+++ b/modules/elasticsearch/src/main/java/org/elasticsearch/index/gateway/local/LocalIndexShardGateway.java, +import org.elasticsearch.common.unit.TimeValue;, +import org.elasticsearch.index.shard.IndexShardState;, +import org.elasticsearch.threadpool.ThreadPool;, +import java.util.concurrent.ScheduledFuture;, +    private final ScheduledFuture flushScheduler;, +, +    @Inject public LocalIndexShardGateway(ShardId shardId, @IndexSettings Settings indexSettings, ThreadPool threadPool, IndexShard indexShard) {, +, +        TimeValue sync = componentSettings.getAsTime("sync", TimeValue.timeValueSeconds(1));, +        if (sync.millis() > 0) {, +            this.indexShard.translog().syncOnEachOperation(false);, +            flushScheduler = threadPool.scheduleWithFixedDelay(new Sync(), sync);, +        } else if (sync.millis() == 0) {, +            flushScheduler = null;, +            this.indexShard.translog().syncOnEachOperation(true);, +        } else {, +            flushScheduler = null;, +        }, +        return "local";, +        if (flushScheduler != null) {, +            flushScheduler.cancel(false);, +        }, +    }, +, +    private class Sync implements Runnable {, +        @Override public void run() {, +            if (indexShard.state() == IndexShardState.STARTED) {, +                indexShard.translog().sync();, +            }, +        }, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/index/gateway/local/LocalIndexShardGateway.java, +import org.elasticsearch.common.unit.TimeValue;, +import org.elasticsearch.index.shard.IndexShardState;, +import org.elasticsearch.threadpool.ThreadPool;, +import java.util.concurrent.ScheduledFuture;, +    private final ScheduledFuture flushScheduler;, +, +    @Inject public LocalIndexShardGateway(ShardId shardId, @IndexSettings Settings indexSettings, ThreadPool threadPool, IndexShard indexShard) {, +, +        TimeValue sync = componentSettings.getAsTime("sync", TimeValue.timeValueSeconds(1));, +        if (sync.millis() > 0) {, +            this.indexShard.translog().syncOnEachOperation(false);, +            flushScheduler = threadPool.scheduleWithFixedDelay(new Sync(), sync);, +        } else if (sync.millis() == 0) {, +            flushScheduler = null;, +            this.indexShard.translog().syncOnEachOperation(true);, +        } else {, +            flushScheduler = null;, +        }, +        return "local";, +        if (flushScheduler != null) {, +            flushScheduler.cancel(false);, +        }, +    }, +, +    private class Sync implements Runnable {, +        @Override public void run() {, +            if (indexShard.state() == IndexShardState.STARTED) {, +                indexShard.translog().sync();, +            }, +        }, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/index/translog/Translog.java, +     * Sync's the translog., +    void sync();, +, +    void syncOnEachOperation(boolean syncOnEachOperation);, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/index/gateway/local/LocalIndexShardGateway.java, +import org.elasticsearch.common.unit.TimeValue;, +import org.elasticsearch.index.shard.IndexShardState;, +import org.elasticsearch.threadpool.ThreadPool;, +import java.util.concurrent.ScheduledFuture;, +    private final ScheduledFuture flushScheduler;, +, +    @Inject public LocalIndexShardGateway(ShardId shardId, @IndexSettings Settings indexSettings, ThreadPool threadPool, IndexShard indexShard) {, +, +        TimeValue sync = componentSettings.getAsTime("sync", TimeValue.timeValueSeconds(1));, +        if (sync.millis() > 0) {, +            this.indexShard.translog().syncOnEachOperation(false);, +            flushScheduler = threadPool.scheduleWithFixedDelay(new Sync(), sync);, +        } else if (sync.millis() == 0) {, +            flushScheduler = null;, +            this.indexShard.translog().syncOnEachOperation(true);, +        } else {, +            flushScheduler = null;, +        }, +        return "local";, +        if (flushScheduler != null) {, +            flushScheduler.cancel(false);, +        }, +    }, +, +    private class Sync implements Runnable {, +        @Override public void run() {, +            if (indexShard.state() == IndexShardState.STARTED) {, +                indexShard.translog().sync();, +            }, +        }, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/index/translog/Translog.java, +     * Sync's the translog.]