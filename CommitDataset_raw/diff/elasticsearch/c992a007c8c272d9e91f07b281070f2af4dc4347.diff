[+++ b/core/src/main/java/org/elasticsearch/index/engine/EngineConfig.java, +import org.elasticsearch.action.index.IndexRequest;, +    private final long maxUnsafeAutoIdTimestamp;, +                        TranslogConfig translogConfig, TimeValue flushMergesAfter, RefreshListeners refreshListeners,, +                        long maxUnsafeAutoIdTimestamp) {, +        assert maxUnsafeAutoIdTimestamp >= IndexRequest.UNSET_AUTO_GENERATED_TIMESTAMP :, +            "maxUnsafeAutoIdTimestamp must be >= -1 but was " + maxUnsafeAutoIdTimestamp;, +        this.maxUnsafeAutoIdTimestamp = maxUnsafeAutoIdTimestamp;, +     * Returns the max timestamp that is used to de-optimize documents with auto-generated IDs in the engine., +     * This is used to ensure we don't add duplicate documents when we assume an append only case based on auto-generated IDs, +    public long getMaxUnsafeAutoIdTimestamp() {, +        return indexSettings.getValue(INDEX_OPTIMIZE_AUTO_GENERATED_IDS) ? maxUnsafeAutoIdTimestamp : Long.MAX_VALUE;, +++ b/core/src/main/java/org/elasticsearch/index/engine/EngineConfig.java, +import org.elasticsearch.action.index.IndexRequest;, +    private final long maxUnsafeAutoIdTimestamp;, +                        TranslogConfig translogConfig, TimeValue flushMergesAfter, RefreshListeners refreshListeners,, +                        long maxUnsafeAutoIdTimestamp) {, +        assert maxUnsafeAutoIdTimestamp >= IndexRequest.UNSET_AUTO_GENERATED_TIMESTAMP :, +            "maxUnsafeAutoIdTimestamp must be >= -1 but was " + maxUnsafeAutoIdTimestamp;, +        this.maxUnsafeAutoIdTimestamp = maxUnsafeAutoIdTimestamp;, +     * Returns the max timestamp that is used to de-optimize documents with auto-generated IDs in the engine., +     * This is used to ensure we don't add duplicate documents when we assume an append only case based on auto-generated IDs, +    public long getMaxUnsafeAutoIdTimestamp() {, +        return indexSettings.getValue(INDEX_OPTIMIZE_AUTO_GENERATED_IDS) ? maxUnsafeAutoIdTimestamp : Long.MAX_VALUE;, +++ b/core/src/main/java/org/elasticsearch/index/engine/InternalEngine.java, +        if (engineConfig.getIndexSettings().getIndexVersionCreated().before(Version.V_5_0_0_alpha6)) {, +        } else {, +            maxUnsafeAutoIdTimestamp.set(engineConfig.getMaxUnsafeAutoIdTimestamp());, +        if (engineConfig.getMaxUnsafeAutoIdTimestamp() == Long.MAX_VALUE) {, +++ b/core/src/main/java/org/elasticsearch/index/engine/EngineConfig.java, +import org.elasticsearch.action.index.IndexRequest;, +    private final long maxUnsafeAutoIdTimestamp;, +                        TranslogConfig translogConfig, TimeValue flushMergesAfter, RefreshListeners refreshListeners,, +                        long maxUnsafeAutoIdTimestamp) {, +        assert maxUnsafeAutoIdTimestamp >= IndexRequest.UNSET_AUTO_GENERATED_TIMESTAMP :, +            "maxUnsafeAutoIdTimestamp must be >= -1 but was " + maxUnsafeAutoIdTimestamp;, +        this.maxUnsafeAutoIdTimestamp = maxUnsafeAutoIdTimestamp;, +     * Returns the max timestamp that is used to de-optimize documents with auto-generated IDs in the engine., +     * This is used to ensure we don't add duplicate documents when we assume an append only case based on auto-generated IDs, +    public long getMaxUnsafeAutoIdTimestamp() {, +        return indexSettings.getValue(INDEX_OPTIMIZE_AUTO_GENERATED_IDS) ? maxUnsafeAutoIdTimestamp : Long.MAX_VALUE;, +++ b/core/src/main/java/org/elasticsearch/index/engine/InternalEngine.java, +        if (engineConfig.getIndexSettings().getIndexVersionCreated().before(Version.V_5_0_0_alpha6)) {, +        } else {, +            maxUnsafeAutoIdTimestamp.set(engineConfig.getMaxUnsafeAutoIdTimestamp());, +        if (engineConfig.getMaxUnsafeAutoIdTimestamp() == Long.MAX_VALUE) {, +++ b/core/src/main/java/org/elasticsearch/index/engine/SegmentsStats.java, +     * Returns the max timestamp that is used to de-optimize documents with auto-generated IDs in the engine., +++ b/core/src/main/java/org/elasticsearch/index/engine/EngineConfig.java, +import org.elasticsearch.action.index.IndexRequest;, +    private final long maxUnsafeAutoIdTimestamp;, +                        TranslogConfig translogConfig, TimeValue flushMergesAfter, RefreshListeners refreshListeners,, +                        long maxUnsafeAutoIdTimestamp) {, +        assert maxUnsafeAutoIdTimestamp >= IndexRequest.UNSET_AUTO_GENERATED_TIMESTAMP :, +            "maxUnsafeAutoIdTimestamp must be >= -1 but was " + maxUnsafeAutoIdTimestamp;, +        this.maxUnsafeAutoIdTimestamp = maxUnsafeAutoIdTimestamp;, +     * Returns the max timestamp that is used to de-optimize documents with auto-generated IDs in the engine., +     * This is used to ensure we don't add duplicate documents when we assume an append only case based on auto-generated IDs, +    public long getMaxUnsafeAutoIdTimestamp() {, +        return indexSettings.getValue(INDEX_OPTIMIZE_AUTO_GENERATED_IDS) ? maxUnsafeAutoIdTimestamp : Long.MAX_VALUE;, +++ b/core/src/main/java/org/elasticsearch/index/engine/InternalEngine.java, +        if (engineConfig.getIndexSettings().getIndexVersionCreated().before(Version.V_5_0_0_alpha6)) {, +        } else {, +            maxUnsafeAutoIdTimestamp.set(engineConfig.getMaxUnsafeAutoIdTimestamp());, +        if (engineConfig.getMaxUnsafeAutoIdTimestamp() == Long.MAX_VALUE) {, +++ b/core/src/main/java/org/elasticsearch/index/engine/SegmentsStats.java, +     * Returns the max timestamp that is used to de-optimize documents with auto-generated IDs in the engine., +++ b/core/src/main/java/org/elasticsearch/index/shard/IndexShard.java, +import org.elasticsearch.action.index.IndexRequest;, +        internalPerformTranslogRecovery(false, indexExists, IndexRequest.UNSET_AUTO_GENERATED_TIMESTAMP);, +    private void internalPerformTranslogRecovery(boolean skipTranslogRecovery, boolean indexExists, long maxUnsafeAutoIdTimestamp) throws IOException {, +        final EngineConfig config = newEngineConfig(openMode, maxUnsafeAutoIdTimestamp);, +    public void skipTranslogRecovery(long maxUnsafeAutoIdTimestamp) throws IOException {, +        internalPerformTranslogRecovery(true, true, maxUnsafeAutoIdTimestamp);, +    private EngineConfig newEngineConfig(EngineConfig.OpenMode openMode, long maxUnsafeAutoIdTimestamp) {, +            IndexingMemoryController.SHARD_INACTIVE_TIME_SETTING.get(indexSettings.getSettings()), refreshListeners,, +            maxUnsafeAutoIdTimestamp);, +++ b/core/src/main/java/org/elasticsearch/index/engine/EngineConfig.java, +import org.elasticsearch.action.index.IndexRequest;, +    private final long maxUnsafeAutoIdTimestamp;, +                        TranslogConfig translogConfig, TimeValue flushMergesAfter, RefreshListeners refreshListeners,, +                        long maxUnsafeAutoIdTimestamp) {, +        assert maxUnsafeAutoIdTimestamp >= IndexRequest.UNSET_AUTO_GENERATED_TIMESTAMP :, +            "maxUnsafeAutoIdTimestamp must be >= -1 but was " + maxUnsafeAutoIdTimestamp;, +        this.maxUnsafeAutoIdTimestamp = maxUnsafeAutoIdTimestamp;, +     * Returns the max timestamp that is used to de-optimize documents with auto-generated IDs in the engine., +     * This is used to ensure we don't add duplicate documents when we assume an append only case based on auto-generated IDs, +    public long getMaxUnsafeAutoIdTimestamp() {, +        return indexSettings.getValue(INDEX_OPTIMIZE_AUTO_GENERATED_IDS) ? maxUnsafeAutoIdTimestamp : Long.MAX_VALUE;, +++ b/core/src/main/java/org/elasticsearch/index/engine/InternalEngine.java, +        if (engineConfig.getIndexSettings().getIndexVersionCreated().before(Version.V_5_0_0_alpha6)) {, +        } else {, +            maxUnsafeAutoIdTimestamp.set(engineConfig.getMaxUnsafeAutoIdTimestamp());, +        if (engineConfig.getMaxUnsafeAutoIdTimestamp() == Long.MAX_VALUE) {, +++ b/core/src/main/java/org/elasticsearch/index/engine/SegmentsStats.java, +     * Returns the max timestamp that is used to de-optimize documents with auto-generated IDs in the engine., +++ b/core/src/main/java/org/elasticsearch/index/shard/IndexShard.java, +import org.elasticsearch.action.index.IndexRequest;, +        internalPerformTranslogRecovery(false, indexExists, IndexRequest.UNSET_AUTO_GENERATED_TIMESTAMP);, +    private void internalPerformTranslogRecovery(boolean skipTranslogRecovery, boolean indexExists, long maxUnsafeAutoIdTimestamp) throws IOException {]