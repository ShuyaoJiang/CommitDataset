[+++ b/core/src/main/java/org/elasticsearch/action/admin/indices/shards/TransportIndicesShardStoresAction.java, +                ClusterShardHealth shardHealth = new ClusterShardHealth(shardId, routing, indexMetaData);, +++ b/core/src/main/java/org/elasticsearch/action/admin/indices/shards/TransportIndicesShardStoresAction.java, +                ClusterShardHealth shardHealth = new ClusterShardHealth(shardId, routing, indexMetaData);, +++ b/core/src/main/java/org/elasticsearch/cluster/health/ClusterIndexHealth.java, +            shards.put(shardId, new ClusterShardHealth(shardId, shardRoutingTable, indexMetaData));, +++ b/core/src/main/java/org/elasticsearch/action/admin/indices/shards/TransportIndicesShardStoresAction.java, +                ClusterShardHealth shardHealth = new ClusterShardHealth(shardId, routing, indexMetaData);, +++ b/core/src/main/java/org/elasticsearch/cluster/health/ClusterIndexHealth.java, +            shards.put(shardId, new ClusterShardHealth(shardId, shardRoutingTable, indexMetaData));, +++ b/core/src/main/java/org/elasticsearch/cluster/health/ClusterShardHealth.java, +import org.elasticsearch.cluster.metadata.IndexMetaData;, +import org.elasticsearch.cluster.routing.UnassignedInfo.AllocationStatus;, +import org.elasticsearch.cluster.routing.UnassignedInfo.Reason;, +    public ClusterShardHealth(final int shardId, final IndexShardRoutingTable shardRoutingTable, final IndexMetaData indexMetaData) {, +            computeStatus = getInactivePrimaryHealth(primaryRouting, indexMetaData);, +    /**, +     * Checks if an inactive primary shard should cause the cluster health to go RED., +     *, +     * Normally, an inactive primary shard in an index should cause the cluster health to be RED.  However,, +     * there are exceptions where a health status of RED is inappropriate, namely in these scenarios:, +     *   1. Index Creation.  When an index is first created, the primary shards are in the initializing state, so, +     *      there is a small window where the cluster health is RED due to the primaries not being activated yet., +     *      However, this leads to a false sense that the cluster is in an unhealthy state, when in reality, its, +     *      simply a case of needing to wait for the primaries to initialize., +     *   2. When a cluster is in the recovery state, and the shard never had any allocation ids assigned to it,, +     *      which indicates the index was created and before allocation of the primary occurred for this shard,, +     *      a cluster restart happened., +     *, +     * Here, we check for these scenarios and set the cluster health to YELLOW if any are applicable., +     *, +     * NB: this method should *not* be called on active shards nor on non-primary shards., +     */, +    public static ClusterHealthStatus getInactivePrimaryHealth(final ShardRouting shardRouting, final IndexMetaData indexMetaData) {, +        assert shardRouting.primary() : "cannot invoke on a replica shard: " + shardRouting;, +        assert shardRouting.active() == false : "cannot invoke on an active shard: " + shardRouting;, +        assert shardRouting.unassignedInfo() != null : "cannot invoke on a shard with no UnassignedInfo: " + shardRouting;, +        final UnassignedInfo unassignedInfo = shardRouting.unassignedInfo();, +        if (unassignedInfo.getLastAllocationStatus() != AllocationStatus.DECIDERS_NO, +                && shardRouting.allocatedPostIndexCreate(indexMetaData) == false, +                && (unassignedInfo.getReason() == Reason.INDEX_CREATED || unassignedInfo.getReason() == Reason.CLUSTER_RECOVERED)) {, +            return ClusterHealthStatus.YELLOW;, +        } else {, +            return ClusterHealthStatus.RED;, +        }, +    }, +, +++ b/core/src/main/java/org/elasticsearch/action/admin/indices/shards/TransportIndicesShardStoresAction.java, +                ClusterShardHealth shardHealth = new ClusterShardHealth(shardId, routing, indexMetaData);, +++ b/core/src/main/java/org/elasticsearch/cluster/health/ClusterIndexHealth.java, +            shards.put(shardId, new ClusterShardHealth(shardId, shardRoutingTable, indexMetaData));, +++ b/core/src/main/java/org/elasticsearch/cluster/health/ClusterShardHealth.java, +import org.elasticsearch.cluster.metadata.IndexMetaData;, +import org.elasticsearch.cluster.routing.UnassignedInfo.AllocationStatus;, +import org.elasticsearch.cluster.routing.UnassignedInfo.Reason;, +    public ClusterShardHealth(final int shardId, final IndexShardRoutingTable shardRoutingTable, final IndexMetaData indexMetaData) {, +            computeStatus = getInactivePrimaryHealth(primaryRouting, indexMetaData);, +    /**, +     * Checks if an inactive primary shard should cause the cluster health to go RED., +     *, +     * Normally, an inactive primary shard in an index should cause the cluster health to be RED.  However,, +     * there are exceptions where a health status of RED is inappropriate, namely in these scenarios:, +     *   1. Index Creation.  When an index is first created, the primary shards are in the initializing state, so, +     *      there is a small window where the cluster health is RED due to the primaries not being activated yet., +     *      However, this leads to a false sense that the cluster is in an unhealthy state, when in reality, its, +     *      simply a case of needing to wait for the primaries to initialize., +     *   2. When a cluster is in the recovery state, and the shard never had any allocation ids assigned to it,, +     *      which indicates the index was created and before allocation of the primary occurred for this shard,, +     *      a cluster restart happened., +     *, +     * Here, we check for these scenarios and set the cluster health to YELLOW if any are applicable., +     *, +     * NB: this method should *not* be called on active shards nor on non-primary shards., +     */, +    public static ClusterHealthStatus getInactivePrimaryHealth(final ShardRouting shardRouting, final IndexMetaData indexMetaData) {, +        assert shardRouting.primary() : "cannot invoke on a replica shard: " + shardRouting;, +        assert shardRouting.active() == false : "cannot invoke on an active shard: " + shardRouting;, +        assert shardRouting.unassignedInfo() != null : "cannot invoke on a shard with no UnassignedInfo: " + shardRouting;, +        final UnassignedInfo unassignedInfo = shardRouting.unassignedInfo();, +        if (unassignedInfo.getLastAllocationStatus() != AllocationStatus.DECIDERS_NO, +                && shardRouting.allocatedPostIndexCreate(indexMetaData) == false, +                && (unassignedInfo.getReason() == Reason.INDEX_CREATED || unassignedInfo.getReason() == Reason.CLUSTER_RECOVERED)) {, +            return ClusterHealthStatus.YELLOW;, +        } else {, +            return ClusterHealthStatus.RED;, +        }, +    }, +, +++ b/core/src/main/java/org/elasticsearch/cluster/routing/RoutingNodes.java, +import org.elasticsearch.cluster.routing.UnassignedInfo.AllocationStatus;, +         * @see UnassignedIterator#removeAndIgnore(AllocationStatus), +         * @return true iff the decision caused a change to the unassigned info, +        public boolean ignoreShard(ShardRouting shard, AllocationStatus allocationStatus) {, +            boolean changed = false;, +                UnassignedInfo currInfo = shard.unassignedInfo();, +                assert currInfo != null;, +                if (allocationStatus.equals(currInfo.getLastAllocationStatus()) == false) {, +                    UnassignedInfo newInfo = new UnassignedInfo(currInfo.getReason(), currInfo.getMessage(), currInfo.getFailure(),, +                                                                currInfo.getNumFailedAllocations(), currInfo.getUnassignedTimeInNanos(),, +                                                                currInfo.getUnassignedTimeInMillis(), currInfo.isDelayed(),]