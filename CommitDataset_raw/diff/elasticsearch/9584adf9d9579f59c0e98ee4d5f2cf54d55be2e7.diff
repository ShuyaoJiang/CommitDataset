[+++ b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/analysis/analyzer/Verifier.java, +                checkFilterOnAggs(p, localFailures);, +, +                            fail(condition, "Cannot use HAVING filter on non-aggregate" + plural + " %s; use WHERE instead",, +    private static void checkFilterOnAggs(LogicalPlan p, Set<Failure> localFailures) {, +        if (p instanceof Filter) {, +            Filter filter = (Filter) p;, +            if ((filter.child() instanceof Aggregate) == false) {, +                filter.condition().forEachDown(f -> {, +                    if (Functions.isAggregate(f) || Functions.isGrouping(f)) {, +                        String type = Functions.isAggregate(f) ? "aggregate" : "grouping";, +                        localFailures.add(fail(f,, +                                "Cannot use WHERE filtering on %s function [%s], use HAVING instead", type, Expressions.name(f)));, +                    }, +, +                }, Function.class);, +            }, +        }, +    }, +, +, +++ b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/analysis/analyzer/Verifier.java, +                checkFilterOnAggs(p, localFailures);, +, +                            fail(condition, "Cannot use HAVING filter on non-aggregate" + plural + " %s; use WHERE instead",, +    private static void checkFilterOnAggs(LogicalPlan p, Set<Failure> localFailures) {, +        if (p instanceof Filter) {, +            Filter filter = (Filter) p;, +            if ((filter.child() instanceof Aggregate) == false) {, +                filter.condition().forEachDown(f -> {, +                    if (Functions.isAggregate(f) || Functions.isGrouping(f)) {, +                        String type = Functions.isAggregate(f) ? "aggregate" : "grouping";, +                        localFailures.add(fail(f,, +                                "Cannot use WHERE filtering on %s function [%s], use HAVING instead", type, Expressions.name(f)));, +                    }, +, +                }, Function.class);, +            }, +        }, +    }, +, +, +++ b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/Functions.java, +import org.elasticsearch.xpack.sql.expression.function.grouping.GroupingFunction;, +    public static boolean isGrouping(Expression e) {, +        return e instanceof GroupingFunction;, +    }, +, +++ b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/analysis/analyzer/Verifier.java, +                checkFilterOnAggs(p, localFailures);, +, +                            fail(condition, "Cannot use HAVING filter on non-aggregate" + plural + " %s; use WHERE instead",, +    private static void checkFilterOnAggs(LogicalPlan p, Set<Failure> localFailures) {, +        if (p instanceof Filter) {, +            Filter filter = (Filter) p;, +            if ((filter.child() instanceof Aggregate) == false) {, +                filter.condition().forEachDown(f -> {, +                    if (Functions.isAggregate(f) || Functions.isGrouping(f)) {, +                        String type = Functions.isAggregate(f) ? "aggregate" : "grouping";, +                        localFailures.add(fail(f,, +                                "Cannot use WHERE filtering on %s function [%s], use HAVING instead", type, Expressions.name(f)));, +                    }, +, +                }, Function.class);, +            }, +        }, +    }, +, +, +++ b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/Functions.java, +import org.elasticsearch.xpack.sql.expression.function.grouping.GroupingFunction;, +    public static boolean isGrouping(Expression e) {, +        return e instanceof GroupingFunction;, +    }, +, +++ b/x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/analysis/analyzer/VerifierErrorMessagesTests.java, +        assertEquals("1:48: Cannot use HAVING filter on non-aggregate [int]; use WHERE instead",, +        assertEquals("1:42: Cannot use HAVING filter on non-aggregate [int]; use WHERE instead",, +        assertEquals("1:42: Cannot use HAVING filter on non-aggregate [int]; use WHERE instead",, +, +    public void testAggsInWhere() {, +        assertEquals("1:33: Cannot use WHERE filtering on aggregate function [MAX(int)], use HAVING instead",, +                error("SELECT MAX(int) FROM test WHERE MAX(int) > 10 GROUP BY bool"));, +    }, +, +    public void testHistogramInFilter() {, +        assertEquals("1:63: Cannot use WHERE filtering on grouping function [HISTOGRAM(date)], use HAVING instead",, +                error("SELECT HISTOGRAM(date, INTERVAL 1 MONTH) AS h FROM test WHERE ", +                        + "HISTOGRAM(date, INTERVAL 1 MONTH) > CAST('2000-01-01' AS DATE) GROUP BY h"));, +    }]