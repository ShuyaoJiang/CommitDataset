[+++ b/modules/elasticsearch/src/main/java/org/elasticsearch/indices/cluster/IndicesClusterStateService.java, +        // handle closed indices, since they are not allocated on a node once they are closed, +        // so applyDeletedIndices might not take them into account, +        for (final String index : indicesService.indices()) {, +            IndexMetaData indexMetaData = event.state().metaData().index(index);, +            if (indexMetaData != null && indexMetaData.state() == IndexMetaData.State.CLOSE) {, +                IndexService indexService = indicesService.indexService(index);, +                for (Integer shardId : indexService.shardIds()) {, +                    logger.warn("[{}][{}] removing shard (index is closed)", index, shardId);, +                    indexService.removeShard(shardId, "removing shard (index is closed)");, +                }, +            }, +        }, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/indices/cluster/IndicesClusterStateService.java, +        // handle closed indices, since they are not allocated on a node once they are closed, +        // so applyDeletedIndices might not take them into account, +        for (final String index : indicesService.indices()) {, +            IndexMetaData indexMetaData = event.state().metaData().index(index);, +            if (indexMetaData != null && indexMetaData.state() == IndexMetaData.State.CLOSE) {, +                IndexService indexService = indicesService.indexService(index);, +                for (Integer shardId : indexService.shardIds()) {, +                    logger.warn("[{}][{}] removing shard (index is closed)", index, shardId);, +                    indexService.removeShard(shardId, "removing shard (index is closed)");, +                }, +            }, +        }, +++ b/modules/test/integration/src/test/java/org/elasticsearch/test/integration/gateway/local/LocalGatewayIndexStateTests.java, +import static org.elasticsearch.index.query.xcontent.QueryBuilders.*;, +, +    @Test public void testTwoNodesSingleDoc() throws Exception {, +        logger.info("--> cleaning nodes");, +        buildNode("node1", settingsBuilder().put("gateway.type", "local").build());, +        buildNode("node2", settingsBuilder().put("gateway.type", "local").build());, +        cleanAndCloseNodes();, +, +        logger.info("--> starting 2 nodes");, +        startNode("node1", settingsBuilder().put("gateway.type", "local").put("index.number_of_shards", 5).put("index.number_of_replicas", 1).build());, +        startNode("node2", settingsBuilder().put("gateway.type", "local").put("index.number_of_shards", 5).put("index.number_of_replicas", 1).build());, +, +        logger.info("--> indexing a simple document");, +        client("node1").prepareIndex("test", "type1", "1").setSource("field1", "value1").setRefresh(true).execute().actionGet();, +, +        logger.info("--> waiting for green status");, +        ClusterHealthResponse health = client("node1").admin().cluster().prepareHealth().setWaitForGreenStatus().setWaitForNodes("2").execute().actionGet();, +        assertThat(health.timedOut(), equalTo(false));, +, +        logger.info("--> verify 1 doc in the index");, +        for (int i = 0; i < 10; i++) {, +            assertThat(client("node1").prepareCount().setQuery(matchAllQuery()).execute().actionGet().count(), equalTo(1l));, +        }, +, +        logger.info("--> closing test index...");, +        client("node1").admin().indices().prepareClose("test").execute().actionGet();, +, +, +        ClusterStateResponse stateResponse = client("node1").admin().cluster().prepareState().execute().actionGet();, +        assertThat(stateResponse.state().metaData().index("test").state(), equalTo(IndexMetaData.State.CLOSE));, +        assertThat(stateResponse.state().routingTable().index("test"), nullValue());, +, +        logger.info("--> opening the index...");, +        client("node1").admin().indices().prepareOpen("test").execute().actionGet();, +, +        logger.info("--> waiting for green status");, +        health = client("node1").admin().cluster().prepareHealth().setWaitForGreenStatus().setWaitForNodes("2").execute().actionGet();, +        assertThat(health.timedOut(), equalTo(false));, +, +        logger.info("--> verify 1 doc in the index");, +        assertThat(client("node1").prepareCount().setQuery(matchAllQuery()).execute().actionGet().count(), equalTo(1l));, +        for (int i = 0; i < 10; i++) {, +            assertThat(client("node1").prepareCount().setQuery(matchAllQuery()).execute().actionGet().count(), equalTo(1l));, +        }, +    }]