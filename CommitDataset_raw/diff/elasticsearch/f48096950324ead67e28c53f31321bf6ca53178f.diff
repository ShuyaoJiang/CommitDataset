[+++ b/docs/reference/modules/gateway.asciidoc, +`gateway.recover_after_time` is ignored and recovery starts., +Setting `gateway.expected_nodes` also defaults `gateway.recovery_after_time` to `5m` coming[1.3.0, before `expected_nodes`, +required `recovery_after_time` to be set]. The `gateway.expected_data_nodes` and `gateway.expected_master_nodes`, +++ b/docs/reference/modules/gateway.asciidoc, +`gateway.recover_after_time` is ignored and recovery starts., +Setting `gateway.expected_nodes` also defaults `gateway.recovery_after_time` to `5m` coming[1.3.0, before `expected_nodes`, +required `recovery_after_time` to be set]. The `gateway.expected_data_nodes` and `gateway.expected_master_nodes`, +++ b/docs/reference/modules/gateway/local.asciidoc, +    recover_after_nodes: 3, +    expected_nodes: 5, +++ b/docs/reference/modules/gateway.asciidoc, +`gateway.recover_after_time` is ignored and recovery starts., +Setting `gateway.expected_nodes` also defaults `gateway.recovery_after_time` to `5m` coming[1.3.0, before `expected_nodes`, +required `recovery_after_time` to be set]. The `gateway.expected_data_nodes` and `gateway.expected_master_nodes`, +++ b/docs/reference/modules/gateway/local.asciidoc, +    recover_after_nodes: 3, +    expected_nodes: 5, +++ b/src/main/java/org/elasticsearch/gateway/GatewayService.java, +    public static final TimeValue DEFAULT_RECOVER_AFTER_TIME_IF_EXPECTED_NODES_IS_SET = TimeValue.timeValueMinutes(5);, +, +        this.expectedMasterNodes = componentSettings.getAsInt("expected_master_nodes", -1);, +, +        TimeValue defaultRecoverAfterTime = null;, +        if (expectedNodes >= 0 || expectedDataNodes >= 0 || expectedMasterNodes >= 0) {, +            defaultRecoverAfterTime = DEFAULT_RECOVER_AFTER_TIME_IF_EXPECTED_NODES_IS_SET;, +        }, +, +        this.recoverAfterTime = componentSettings.getAsTime("recover_after_time", defaultRecoverAfterTime);, +        this.recoverAfterNodes = componentSettings.getAsInt("recover_after_nodes", -1);, +        this.recoverAfterDataNodes = componentSettings.getAsInt("recover_after_data_nodes", -1);, +                checkStateMeetsSettingsAndMaybeRecover(clusterState, false);, +            checkStateMeetsSettingsAndMaybeRecover(event.state(), true);, +        }, +    }, +, +    protected void checkStateMeetsSettingsAndMaybeRecover(ClusterState state, boolean asyncRecovery) {, +        DiscoveryNodes nodes = state.nodes();, +        if (state.blocks().hasGlobalBlock(Discovery.NO_MASTER_BLOCK)) {, +            boolean enforceRecoverAfterTime;, +            String reason;, +                // no expected is set, honor the setting if they are there, +                enforceRecoverAfterTime = true;, +                reason = "recovery_after_time was set to [" + recoverAfterTime + "]";, +                enforceRecoverAfterTime = false;, +                reason = "";, +                    enforceRecoverAfterTime = true;, +                    reason = "expecting [" + expectedNodes + "] nodes, but only have [" + nodes.masterAndDataNodes().size() + "]";, +                } else if (expectedDataNodes != -1 && (nodes.dataNodes().size() < expectedDataNodes)) { // does not meet the expected..., +                    enforceRecoverAfterTime = true;, +                    reason = "expecting [" + expectedDataNodes + "] data nodes, but only have [" + nodes.dataNodes().size() + "]";, +                } else if (expectedMasterNodes != -1 && (nodes.masterNodes().size() < expectedMasterNodes)) { // does not meet the expected..., +                    enforceRecoverAfterTime = true;, +                    reason = "expecting [" + expectedMasterNodes + "] master nodes, but only have [" + nodes.masterNodes().size() + "]";, +            performStateRecovery(asyncRecovery, enforceRecoverAfterTime, reason);, +    private void performStateRecovery(boolean asyncRecovery, boolean enforceRecoverAfterTime, String reason) {, +        if (enforceRecoverAfterTime && recoverAfterTime != null) {, +                logger.info("delaying initial state recovery for [{}]. {}", recoverAfterTime, reason);, +                            logger.info("recovery_after_time [{}] elapsed. performing state recovery...", recoverAfterTime);, +                if (asyncRecovery) {, +                    threadPool.generic().execute(new Runnable() {, +                        @Override, +                        public void run() {, +                            gateway.performStateRecovery(recoveryListener);, +                        }, +                    });, +                } else {, +    }, +, +    // used for testing, +    public TimeValue recoverAfterTime() {, +        return recoverAfterTime;, +    }, +, +++ b/docs/reference/modules/gateway.asciidoc, +`gateway.recover_after_time` is ignored and recovery starts., +Setting `gateway.expected_nodes` also defaults `gateway.recovery_after_time` to `5m` coming[1.3.0, before `expected_nodes`, +required `recovery_after_time` to be set]. The `gateway.expected_data_nodes` and `gateway.expected_master_nodes`, +++ b/docs/reference/modules/gateway/local.asciidoc, +    recover_after_nodes: 3, +    expected_nodes: 5, +++ b/src/main/java/org/elasticsearch/gateway/GatewayService.java, +    public static final TimeValue DEFAULT_RECOVER_AFTER_TIME_IF_EXPECTED_NODES_IS_SET = TimeValue.timeValueMinutes(5);, +, +        this.expectedMasterNodes = componentSettings.getAsInt("expected_master_nodes", -1);, +, +        TimeValue defaultRecoverAfterTime = null;, +        if (expectedNodes >= 0 || expectedDataNodes >= 0 || expectedMasterNodes >= 0) {, +            defaultRecoverAfterTime = DEFAULT_RECOVER_AFTER_TIME_IF_EXPECTED_NODES_IS_SET;, +        }, +, +        this.recoverAfterTime = componentSettings.getAsTime("recover_after_time", defaultRecoverAfterTime);, +        this.recoverAfterNodes = componentSettings.getAsInt("recover_after_nodes", -1);, +        this.recoverAfterDataNodes = componentSettings.getAsInt("recover_after_data_nodes", -1);, +                checkStateMeetsSettingsAndMaybeRecover(clusterState, false);, +            checkStateMeetsSettingsAndMaybeRecover(event.state(), true);, +        }, +    }, +, +    protected void checkStateMeetsSettingsAndMaybeRecover(ClusterState state, boolean asyncRecovery) {]