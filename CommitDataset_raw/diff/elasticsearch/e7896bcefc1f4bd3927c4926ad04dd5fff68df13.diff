[+++ b/server/src/main/java/org/elasticsearch/common/geo/parsers/GeoWKTParser.java, +import org.elasticsearch.common.Explicit;, +            Explicit<Boolean> ignoreZValue = (shapeMapper == null) ? GeoShapeFieldMapper.Defaults.IGNORE_Z_VALUE :, +                shapeMapper.ignoreZValue();, +            Explicit<Boolean> coerce = (shapeMapper == null) ? GeoShapeFieldMapper.Defaults.COERCE : shapeMapper.coerce();, +            ShapeBuilder builder = parseGeometry(tokenizer, shapeType, ignoreZValue.value(), coerce.value());, +    private static ShapeBuilder parseGeometry(StreamTokenizer stream, GeoShapeType shapeType, final boolean ignoreZValue,, +                                              final boolean coerce), +                return parsePoint(stream, ignoreZValue, coerce);, +                return parseMultiPoint(stream, ignoreZValue, coerce);, +                return parseLine(stream, ignoreZValue, coerce);, +                return parseMultiLine(stream, ignoreZValue, coerce);, +                return parsePolygon(stream, ignoreZValue, coerce);, +                return parseMultiPolygon(stream, ignoreZValue, coerce);, +                return parseGeometryCollection(stream, ignoreZValue, coerce);, +    private static PointBuilder parsePoint(StreamTokenizer stream, final boolean ignoreZValue, final boolean coerce), +    private static List<Coordinate> parseCoordinateList(StreamTokenizer stream, final boolean ignoreZValue, final boolean coerce), +            coordinates.coordinate(parseCoordinate(stream, ignoreZValue, coerce));, +                coordinates.coordinate(parseCoordinate(stream, ignoreZValue, coerce));, +    private static Coordinate parseCoordinate(StreamTokenizer stream, final boolean ignoreZValue, final boolean coerce), +    private static MultiPointBuilder parseMultiPoint(StreamTokenizer stream, final boolean ignoreZValue, final boolean coerce), +        return new MultiPointBuilder(parseCoordinateList(stream, ignoreZValue, coerce));, +    private static LineStringBuilder parseLine(StreamTokenizer stream, final boolean ignoreZValue, final boolean coerce), +        return new LineStringBuilder(parseCoordinateList(stream, ignoreZValue, coerce));, +    // A LinearRing is closed LineString with 4 or more positions. The first and last positions, +    // are equivalent (they represent equivalent points)., +    private static LineStringBuilder parseLinearRing(StreamTokenizer stream, final boolean ignoreZValue, final boolean coerce), +            throws IOException, ElasticsearchParseException {, +        String token = nextEmptyOrOpen(stream);, +        if (token.equals(EMPTY)) {, +            return null;, +        }, +        List<Coordinate> coordinates = parseCoordinateList(stream, ignoreZValue, coerce);, +        int coordinatesNeeded = coerce ? 3 : 4;, +        if (coordinates.size() >= coordinatesNeeded) {, +            if (!coordinates.get(0).equals(coordinates.get(coordinates.size() - 1))) {, +                if (coerce == true) {, +                    coordinates.add(coordinates.get(0));, +                } else {, +                    throw new ElasticsearchParseException("invalid LinearRing found (coordinates are not closed)");, +                }, +            }, +        }, +        if (coordinates.size() < 4) {, +            throw new ElasticsearchParseException("invalid number of points in LinearRing (found [{}] - must be >= 4)",, +                coordinates.size());, +        }, +        return new LineStringBuilder(coordinates);, +    }, +, +    private static MultiLineStringBuilder parseMultiLine(StreamTokenizer stream, final boolean ignoreZValue, final boolean coerce), +        builder.linestring(parseLine(stream, ignoreZValue, coerce));, +            builder.linestring(parseLine(stream, ignoreZValue, coerce));, +    private static PolygonBuilder parsePolygon(StreamTokenizer stream, final boolean ignoreZValue, final boolean coerce), +        PolygonBuilder builder = new PolygonBuilder(parseLinearRing(stream, ignoreZValue, coerce), ShapeBuilder.Orientation.RIGHT);, +            builder.hole(parseLinearRing(stream, ignoreZValue, coerce));, +    private static MultiPolygonBuilder parseMultiPolygon(StreamTokenizer stream, final boolean ignoreZValue, final boolean coerce), +        MultiPolygonBuilder builder = new MultiPolygonBuilder().polygon(parsePolygon(stream, ignoreZValue, coerce));, +            builder.polygon(parsePolygon(stream, ignoreZValue, coerce));, +    private static GeometryCollectionBuilder parseGeometryCollection(StreamTokenizer stream, final boolean ignoreZValue,, +                                                                     final boolean coerce), +            parseGeometry(stream, GeoShapeType.GEOMETRYCOLLECTION, ignoreZValue, coerce));, +            builder.shape(parseGeometry(stream, null, ignoreZValue, coerce));, +++ b/server/src/main/java/org/elasticsearch/common/geo/parsers/GeoWKTParser.java, +import org.elasticsearch.common.Explicit;, +            Explicit<Boolean> ignoreZValue = (shapeMapper == null) ? GeoShapeFieldMapper.Defaults.IGNORE_Z_VALUE :, +                shapeMapper.ignoreZValue();, +            Explicit<Boolean> coerce = (shapeMapper == null) ? GeoShapeFieldMapper.Defaults.COERCE : shapeMapper.coerce();, +            ShapeBuilder builder = parseGeometry(tokenizer, shapeType, ignoreZValue.value(), coerce.value());, +    private static ShapeBuilder parseGeometry(StreamTokenizer stream, GeoShapeType shapeType, final boolean ignoreZValue,, +                                              final boolean coerce), +                return parsePoint(stream, ignoreZValue, coerce);, +                return parseMultiPoint(stream, ignoreZValue, coerce);, +                return parseLine(stream, ignoreZValue, coerce);, +                return parseMultiLine(stream, ignoreZValue, coerce);, +                return parsePolygon(stream, ignoreZValue, coerce);, +                return parseMultiPolygon(stream, ignoreZValue, coerce);, +                return parseGeometryCollection(stream, ignoreZValue, coerce);, +    private static PointBuilder parsePoint(StreamTokenizer stream, final boolean ignoreZValue, final boolean coerce), +    private static List<Coordinate> parseCoordinateList(StreamTokenizer stream, final boolean ignoreZValue, final boolean coerce), +            coordinates.coordinate(parseCoordinate(stream, ignoreZValue, coerce));, +                coordinates.coordinate(parseCoordinate(stream, ignoreZValue, coerce));, +    private static Coordinate parseCoordinate(StreamTokenizer stream, final boolean ignoreZValue, final boolean coerce), +    private static MultiPointBuilder parseMultiPoint(StreamTokenizer stream, final boolean ignoreZValue, final boolean coerce), +        return new MultiPointBuilder(parseCoordinateList(stream, ignoreZValue, coerce));, +    private static LineStringBuilder parseLine(StreamTokenizer stream, final boolean ignoreZValue, final boolean coerce), +        return new LineStringBuilder(parseCoordinateList(stream, ignoreZValue, coerce));, +    // A LinearRing is closed LineString with 4 or more positions. The first and last positions, +    // are equivalent (they represent equivalent points)., +    private static LineStringBuilder parseLinearRing(StreamTokenizer stream, final boolean ignoreZValue, final boolean coerce), +            throws IOException, ElasticsearchParseException {, +        String token = nextEmptyOrOpen(stream);, +        if (token.equals(EMPTY)) {, +            return null;, +        }, +        List<Coordinate> coordinates = parseCoordinateList(stream, ignoreZValue, coerce);, +        int coordinatesNeeded = coerce ? 3 : 4;, +        if (coordinates.size() >= coordinatesNeeded) {, +            if (!coordinates.get(0).equals(coordinates.get(coordinates.size() - 1))) {, +                if (coerce == true) {]