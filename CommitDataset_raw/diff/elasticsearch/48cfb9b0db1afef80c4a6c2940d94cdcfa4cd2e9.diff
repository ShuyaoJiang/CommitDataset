[+++ b/client/rest/src/main/java/org/elasticsearch/client/RestClient.java, +        Iterable<Node> hosts = selectNodes(nodeTuple, blacklist, lastNodeIndex, nodeSelector);, +     * Select nodes to try and sorts them so that the first one will be tried initially, then the following ones, +     * if the previous attempt failed and so on. Package private for testing., +    static Iterable<Node> selectNodes(NodeTuple<List<Node>> nodeTuple, Map<HttpHost, DeadHostState> blacklist,, +                                      AtomicInteger lastNodeIndex, NodeSelector nodeSelector) throws IOException {, +                 * Rotate the list using a global counter as the distance so subsequent, +                 * requests will try the nodes in a different order., +         * Last resort: there are no good nodes to use, either because, +         * that the NodeSelectors are OK with. We do this by passing the dead, +         * nodes through the NodeSelector so it can have its say in which nodes, +         * are ok. If the selector is ok with any of the nodes then we will take, +         * the one in the list that has the lowest revival time and try it., +++ b/client/rest/src/main/java/org/elasticsearch/client/RestClient.java, +        Iterable<Node> hosts = selectNodes(nodeTuple, blacklist, lastNodeIndex, nodeSelector);, +     * Select nodes to try and sorts them so that the first one will be tried initially, then the following ones, +     * if the previous attempt failed and so on. Package private for testing., +    static Iterable<Node> selectNodes(NodeTuple<List<Node>> nodeTuple, Map<HttpHost, DeadHostState> blacklist,, +                                      AtomicInteger lastNodeIndex, NodeSelector nodeSelector) throws IOException {, +                 * Rotate the list using a global counter as the distance so subsequent, +                 * requests will try the nodes in a different order., +         * Last resort: there are no good nodes to use, either because, +         * that the NodeSelectors are OK with. We do this by passing the dead, +         * nodes through the NodeSelector so it can have its say in which nodes, +         * are ok. If the selector is ok with any of the nodes then we will take, +         * the one in the list that has the lowest revival time and try it., +++ b/client/rest/src/test/java/org/elasticsearch/client/RestClientTests.java, +import org.apache.http.client.AuthCache;, +import org.apache.http.impl.auth.BasicScheme;, +import org.apache.http.impl.client.BasicAuthCache;, +import java.util.concurrent.atomic.AtomicInteger;, +import static org.junit.Assert.assertSame;, +            assertEquals(singletonList(n1), RestClient.selectNodes(nodeTuple, blacklist, new AtomicInteger(), NodeSelector.ANY));, +            assertEquals(singletonList(n2), RestClient.selectNodes(nodeTuple, blacklist, new AtomicInteger(), not1));, +        assertEquals(expectedNodes, RestClient.selectNodes(nodeTuple, blacklist, lastNodeIndex, nodeSelector));, +                    RestClient.selectNodes(nodeTuple, blacklist, lastNodeIndex, nodeSelector));, +     * Assert that {@link RestClient#selectNodes} fails on the provided arguments., +    private static String assertSelectAllRejected( NodeTuple<List<Node>> nodeTuple,, +            RestClient.selectNodes(nodeTuple, blacklist, new AtomicInteger(0), nodeSelector);, +    public void testRoundRobin() throws IOException {, +        int numNodes = randomIntBetween(2, 10);, +        AuthCache authCache = new BasicAuthCache();, +        List<Node> nodes = new ArrayList<>(numNodes);, +        for (int i = 0; i < numNodes; i++) {, +            Node node = new Node(new HttpHost("localhost", 9200 + i));, +            nodes.add(node);, +            authCache.put(node.getHost(), new BasicScheme());, +        }, +        NodeTuple<List<Node>> nodeTuple = new NodeTuple<>(nodes, authCache);, +        //test the transition from negative to positive values, +        AtomicInteger lastNodeIndex = new AtomicInteger(-numNodes);, +        assertNodes(nodeTuple, lastNodeIndex, 50);, +        assertEquals(-numNodes + 50, lastNodeIndex.get());, +, +        //test the highest positive values up to MAX_VALUE, +        lastNodeIndex.set(Integer.MAX_VALUE - numNodes * 10);, +        assertNodes(nodeTuple, lastNodeIndex, numNodes * 10);, +        assertEquals(Integer.MAX_VALUE, lastNodeIndex.get());, +, +        //test the transition from MAX_VALUE to MIN_VALUE, +        //this is the only time where there is most likely going to be a jump from a node, +        //to another one that's not necessarily the next one., +        assertEquals(Integer.MIN_VALUE, lastNodeIndex.incrementAndGet());, +        assertNodes(nodeTuple, lastNodeIndex, 50);, +        assertEquals(Integer.MIN_VALUE + 50, lastNodeIndex.get());, +    }, +, +    private static void assertNodes(NodeTuple<List<Node>> nodeTuple, AtomicInteger lastNodeIndex, int runs) throws IOException {, +        int distance = lastNodeIndex.get() % nodeTuple.nodes.size();, +        /*, +         * Collections.rotate is not super intuitive: distance 1 means that the last element will become the first and so on,, +         * while distance -1 means that the second element will become the first and so on., +         */, +        int expectedOffset = distance > 0 ? nodeTuple.nodes.size() - distance : Math.abs(distance);, +        for (int i = 0; i < runs; i++) {, +            Iterable<Node> selectedNodes = RestClient.selectNodes(nodeTuple, Collections.<HttpHost, DeadHostState>emptyMap(),, +                    lastNodeIndex, NodeSelector.ANY);, +            List<Node> expectedNodes = nodeTuple.nodes;, +            int index = 0;, +            for (Node actualNode : selectedNodes) {, +                Node expectedNode = expectedNodes.get((index + expectedOffset) % expectedNodes.size());, +                assertSame(expectedNode, actualNode);, +                index++;, +            }, +            expectedOffset--;, +            if (expectedOffset < 0) {, +                expectedOffset += nodeTuple.nodes.size();, +            }, +        }, +    }]