[+++ b/server/src/main/java/org/elasticsearch/gateway/MetaDataStateFormat.java, +import org.elasticsearch.common.logging.Loggers;, +import org.elasticsearch.core.internal.io.IOUtils;, +    private static final int MIN_COMPATIBLE_STATE_FILE_VERSION = 1;, +                CodecUtil.checkHeader(indexInput, STATE_FILE_CODEC, MIN_COMPATIBLE_STATE_FILE_VERSION, STATE_FILE_VERSION);, +                            PathAndStateId pav = new PathAndStateId(stateFile, stateId);, +        //       we iterate only over the ones with the max version., +        long finalMaxStateId = maxStateId;, +                .filter(pathAndStateId -> pathAndStateId.id == finalMaxStateId), +        final List<Throwable> exceptions = new ArrayList<>();, +                T state = read(namedXContentRegistry, pathAndStateId.file);, +                logger.trace("state id [{}] read from [{}]", pathAndStateId.id, pathAndStateId.file.getFileName());, +        return null;, +     * Internal struct-like class that holds the parsed state id and the file, +        private PathAndStateId(Path file, long id) {, +            return "[id:" + id + ", file:" + file.toAbsolutePath() + "]";, +++ b/server/src/main/java/org/elasticsearch/gateway/MetaDataStateFormat.java, +import org.elasticsearch.common.logging.Loggers;, +import org.elasticsearch.core.internal.io.IOUtils;, +    private static final int MIN_COMPATIBLE_STATE_FILE_VERSION = 1;, +                CodecUtil.checkHeader(indexInput, STATE_FILE_CODEC, MIN_COMPATIBLE_STATE_FILE_VERSION, STATE_FILE_VERSION);, +                            PathAndStateId pav = new PathAndStateId(stateFile, stateId);, +        //       we iterate only over the ones with the max version., +        long finalMaxStateId = maxStateId;, +                .filter(pathAndStateId -> pathAndStateId.id == finalMaxStateId), +        final List<Throwable> exceptions = new ArrayList<>();, +                T state = read(namedXContentRegistry, pathAndStateId.file);, +                logger.trace("state id [{}] read from [{}]", pathAndStateId.id, pathAndStateId.file.getFileName());, +        return null;, +     * Internal struct-like class that holds the parsed state id and the file, +        private PathAndStateId(Path file, long id) {, +            return "[id:" + id + ", file:" + file.toAbsolutePath() + "]";, +++ b/server/src/test/java/org/elasticsearch/bwcompat/RecoveryWithUnsupportedIndicesIT.java, +    public void testUpgradeStartClusterOn_2_4_5() throws Exception {, +        String indexName = "unsupported-2.4.5";, +        assertThat(expectThrows(Exception.class, () -> internalCluster().startNode(nodeSettings)), +            .getCause().getCause().getMessage(), containsString("Format version is not supported"));, +++ b/server/src/main/java/org/elasticsearch/gateway/MetaDataStateFormat.java, +import org.elasticsearch.common.logging.Loggers;, +import org.elasticsearch.core.internal.io.IOUtils;, +    private static final int MIN_COMPATIBLE_STATE_FILE_VERSION = 1;, +                CodecUtil.checkHeader(indexInput, STATE_FILE_CODEC, MIN_COMPATIBLE_STATE_FILE_VERSION, STATE_FILE_VERSION);, +                            PathAndStateId pav = new PathAndStateId(stateFile, stateId);, +        //       we iterate only over the ones with the max version., +        long finalMaxStateId = maxStateId;, +                .filter(pathAndStateId -> pathAndStateId.id == finalMaxStateId), +        final List<Throwable> exceptions = new ArrayList<>();, +                T state = read(namedXContentRegistry, pathAndStateId.file);, +                logger.trace("state id [{}] read from [{}]", pathAndStateId.id, pathAndStateId.file.getFileName());, +        return null;, +     * Internal struct-like class that holds the parsed state id and the file, +        private PathAndStateId(Path file, long id) {, +            return "[id:" + id + ", file:" + file.toAbsolutePath() + "]";, +++ b/server/src/test/java/org/elasticsearch/bwcompat/RecoveryWithUnsupportedIndicesIT.java, +    public void testUpgradeStartClusterOn_2_4_5() throws Exception {, +        String indexName = "unsupported-2.4.5";, +        assertThat(expectThrows(Exception.class, () -> internalCluster().startNode(nodeSettings)), +            .getCause().getCause().getMessage(), containsString("Format version is not supported"));, +++ b/server/src/test/java/org/elasticsearch/gateway/MetaDataStateFormatTests.java, +        assertThat(read.clusterUUID(), equalTo("y9XcwLJGTROoOEfixlRwfQ"));, +            for (int j = 0; j < numStates; j++) {, +++ b/server/src/main/java/org/elasticsearch/gateway/MetaDataStateFormat.java, +import org.elasticsearch.common.logging.Loggers;, +import org.elasticsearch.core.internal.io.IOUtils;, +    private static final int MIN_COMPATIBLE_STATE_FILE_VERSION = 1;, +                CodecUtil.checkHeader(indexInput, STATE_FILE_CODEC, MIN_COMPATIBLE_STATE_FILE_VERSION, STATE_FILE_VERSION);, +                            PathAndStateId pav = new PathAndStateId(stateFile, stateId);, +        //       we iterate only over the ones with the max version., +        long finalMaxStateId = maxStateId;, +                .filter(pathAndStateId -> pathAndStateId.id == finalMaxStateId), +        final List<Throwable> exceptions = new ArrayList<>();, +                T state = read(namedXContentRegistry, pathAndStateId.file);, +                logger.trace("state id [{}] read from [{}]", pathAndStateId.id, pathAndStateId.file.getFileName());, +        return null;, +     * Internal struct-like class that holds the parsed state id and the file, +        private PathAndStateId(Path file, long id) {, +            return "[id:" + id + ", file:" + file.toAbsolutePath() + "]";, +++ b/server/src/test/java/org/elasticsearch/bwcompat/RecoveryWithUnsupportedIndicesIT.java, +    public void testUpgradeStartClusterOn_2_4_5() throws Exception {, +        String indexName = "unsupported-2.4.5";, +        assertThat(expectThrows(Exception.class, () -> internalCluster().startNode(nodeSettings)), +            .getCause().getCause().getMessage(), containsString("Format version is not supported"));, +++ b/server/src/test/java/org/elasticsearch/gateway/MetaDataStateFormatTests.java, +        assertThat(read.clusterUUID(), equalTo("y9XcwLJGTROoOEfixlRwfQ"));, +            for (int j = 0; j < numStates; j++) {, +++ /dev/null, +++ b/server/src/main/java/org/elasticsearch/gateway/MetaDataStateFormat.java, +import org.elasticsearch.common.logging.Loggers;, +import org.elasticsearch.core.internal.io.IOUtils;, +    private static final int MIN_COMPATIBLE_STATE_FILE_VERSION = 1;, +                CodecUtil.checkHeader(indexInput, STATE_FILE_CODEC, MIN_COMPATIBLE_STATE_FILE_VERSION, STATE_FILE_VERSION);, +                            PathAndStateId pav = new PathAndStateId(stateFile, stateId);, +        //       we iterate only over the ones with the max version., +        long finalMaxStateId = maxStateId;, +                .filter(pathAndStateId -> pathAndStateId.id == finalMaxStateId), +        final List<Throwable> exceptions = new ArrayList<>();, +                T state = read(namedXContentRegistry, pathAndStateId.file);, +                logger.trace("state id [{}] read from [{}]", pathAndStateId.id, pathAndStateId.file.getFileName());, +        return null;, +     * Internal struct-like class that holds the parsed state id and the file]