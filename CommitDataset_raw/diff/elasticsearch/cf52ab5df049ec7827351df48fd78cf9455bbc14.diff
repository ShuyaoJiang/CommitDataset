[+++ b/core/src/main/java/org/elasticsearch/action/admin/indices/delete/TransportDeleteIndexAction.java, +import org.elasticsearch.common.util.concurrent.CountDown;, +        String[] concreteIndices = indexNameExpressionResolver.concreteIndices(state, request);, +        // TODO: this API should be improved, currently, if one delete index failed, we send a failure, we should send a response array that includes all the indices that were deleted, +        final CountDown count = new CountDown(concreteIndices.length);, +        for (final String index : concreteIndices) {, +            deleteIndexService.deleteIndex(new MetaDataDeleteIndexService.Request(index).timeout(request.timeout()).masterTimeout(request.masterNodeTimeout()), new MetaDataDeleteIndexService.Listener() {, +, +                private volatile Throwable lastFailure;, +                private volatile boolean ack = true;, +                    if (!response.acknowledged()) {, +                        ack = false;, +                    }, +                    if (count.countDown()) {, +                        if (lastFailure != null) {, +                            listener.onFailure(lastFailure);, +                        } else {, +                            listener.onResponse(new DeleteIndexResponse(ack));, +                        }, +                    }, +                    logger.debug("[{}] failed to delete index", t, index);, +                    lastFailure = t;, +                    if (count.countDown()) {, +                }, +}, +++ b/core/src/main/java/org/elasticsearch/action/admin/indices/delete/TransportDeleteIndexAction.java, +import org.elasticsearch.common.util.concurrent.CountDown;, +        String[] concreteIndices = indexNameExpressionResolver.concreteIndices(state, request);, +        // TODO: this API should be improved, currently, if one delete index failed, we send a failure, we should send a response array that includes all the indices that were deleted, +        final CountDown count = new CountDown(concreteIndices.length);, +        for (final String index : concreteIndices) {, +            deleteIndexService.deleteIndex(new MetaDataDeleteIndexService.Request(index).timeout(request.timeout()).masterTimeout(request.masterNodeTimeout()), new MetaDataDeleteIndexService.Listener() {, +, +                private volatile Throwable lastFailure;, +                private volatile boolean ack = true;, +                    if (!response.acknowledged()) {, +                        ack = false;, +                    }, +                    if (count.countDown()) {, +                        if (lastFailure != null) {, +                            listener.onFailure(lastFailure);, +                        } else {, +                            listener.onResponse(new DeleteIndexResponse(ack));, +                        }, +                    }, +                    logger.debug("[{}] failed to delete index", t, index);, +                    lastFailure = t;, +                    if (count.countDown()) {, +                }, +}, +++ b/core/src/main/java/org/elasticsearch/action/admin/indices/validate/query/TransportValidateQueryAction.java, +                searchContext.parsedQuery(queryParserService.parseQuery(request.source()));, +++ b/core/src/main/java/org/elasticsearch/action/admin/indices/delete/TransportDeleteIndexAction.java, +import org.elasticsearch.common.util.concurrent.CountDown;, +        String[] concreteIndices = indexNameExpressionResolver.concreteIndices(state, request);, +        // TODO: this API should be improved, currently, if one delete index failed, we send a failure, we should send a response array that includes all the indices that were deleted, +        final CountDown count = new CountDown(concreteIndices.length);, +        for (final String index : concreteIndices) {, +            deleteIndexService.deleteIndex(new MetaDataDeleteIndexService.Request(index).timeout(request.timeout()).masterTimeout(request.masterNodeTimeout()), new MetaDataDeleteIndexService.Listener() {, +, +                private volatile Throwable lastFailure;, +                private volatile boolean ack = true;, +                    if (!response.acknowledged()) {, +                        ack = false;, +                    }, +                    if (count.countDown()) {, +                        if (lastFailure != null) {, +                            listener.onFailure(lastFailure);, +                        } else {, +                            listener.onResponse(new DeleteIndexResponse(ack));, +                        }, +                    }, +                    logger.debug("[{}] failed to delete index", t, index);, +                    lastFailure = t;, +                    if (count.countDown()) {, +                }, +}, +++ b/core/src/main/java/org/elasticsearch/action/admin/indices/validate/query/TransportValidateQueryAction.java, +                searchContext.parsedQuery(queryParserService.parseQuery(request.source()));, +++ b/core/src/main/java/org/elasticsearch/action/explain/TransportExplainAction.java, +            context.parsedQuery(indexService.queryParserService().parseQuery(request.source()));, +++ b/core/src/main/java/org/elasticsearch/action/admin/indices/delete/TransportDeleteIndexAction.java, +import org.elasticsearch.common.util.concurrent.CountDown;, +        String[] concreteIndices = indexNameExpressionResolver.concreteIndices(state, request);, +        // TODO: this API should be improved, currently, if one delete index failed, we send a failure, we should send a response array that includes all the indices that were deleted, +        final CountDown count = new CountDown(concreteIndices.length);, +        for (final String index : concreteIndices) {, +            deleteIndexService.deleteIndex(new MetaDataDeleteIndexService.Request(index).timeout(request.timeout()).masterTimeout(request.masterNodeTimeout()), new MetaDataDeleteIndexService.Listener() {, +, +                private volatile Throwable lastFailure;, +                private volatile boolean ack = true;, +                    if (!response.acknowledged()) {, +                        ack = false;, +                    }, +                    if (count.countDown()) {, +                        if (lastFailure != null) {, +                            listener.onFailure(lastFailure);, +                        } else {, +                            listener.onResponse(new DeleteIndexResponse(ack));, +                        }]