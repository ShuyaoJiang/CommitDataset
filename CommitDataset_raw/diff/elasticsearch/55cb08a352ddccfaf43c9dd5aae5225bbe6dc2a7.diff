[+++ b/CONTRIBUTING.md, +runtime. If the [`shadow`][shadow-plugin] plugin is applied to the project then, +this code is bundled into the jar produced by the project.</dd>, +<dt>`compileOnly`</dt><dd>Code that is on the classpath at comile time but that, +<dt>`shadow`</dt><dd>Only available in projects with the shadow plugin. Code, +that is on the classpath at both compile and runtime but it *not* bundled into, +the jar produced by the project. If you depend on a project with the `shadow`, +plugin then you need to depend on this configuration because it will bring, +along all of the dependencies you need at runtime.</dd>, +++ b/CONTRIBUTING.md, +runtime. If the [`shadow`][shadow-plugin] plugin is applied to the project then, +this code is bundled into the jar produced by the project.</dd>, +<dt>`compileOnly`</dt><dd>Code that is on the classpath at comile time but that, +<dt>`shadow`</dt><dd>Only available in projects with the shadow plugin. Code, +that is on the classpath at both compile and runtime but it *not* bundled into, +the jar produced by the project. If you depend on a project with the `shadow`, +plugin then you need to depend on this configuration because it will bring, +along all of the dependencies you need at runtime.</dd>, +++ b/build.gradle, +    if (project.plugins.hasPlugin(BuildPlugin)) {, +           * Do not add those projects to the javadoc classpath because, +           * we are going to resolve them with their source instead., +           */, +          project.javadoc.classpath = project.javadoc.classpath.filter { f ->, +            false == upstreamProject.configurations.archives.artifacts.files.files.contains(f), +          }, +          /*, +          .each({ c -> depJavadocClosure(hasShadow, c) }), +          .each({ c -> depJavadocClosure(hasShadow, c) }), +        project.configurations.shadow.dependencies, +            .each({ c -> depJavadocClosure(false, c) }), +   * in "IntelliJ mode" or "Eclipse mode" add "runtime" dependencies, +   * eveywhere where we see a "shadow" dependency which will cause them to, +   * reference shadowed projects directly rather than rely on the shadowing, +   * to include them. This is the correct thing for it to do because it, +   * doesn't run the jar shadowing at all. This isn't needed for the project, +	configurations.all { Configuration configuration ->, +	  dependencies.all { Dependency dep ->, +		if (dep instanceof ProjectDependency) {, +		  if (dep.getTargetConfiguration() == 'shadow') {, +			configuration.dependencies.add(project.dependencies.project(path: dep.dependencyProject.path, configuration: 'runtime')), +		  }, +		}, +++ b/CONTRIBUTING.md, +runtime. If the [`shadow`][shadow-plugin] plugin is applied to the project then, +this code is bundled into the jar produced by the project.</dd>, +<dt>`compileOnly`</dt><dd>Code that is on the classpath at comile time but that, +<dt>`shadow`</dt><dd>Only available in projects with the shadow plugin. Code, +that is on the classpath at both compile and runtime but it *not* bundled into, +the jar produced by the project. If you depend on a project with the `shadow`, +plugin then you need to depend on this configuration because it will bring, +along all of the dependencies you need at runtime.</dd>, +++ b/build.gradle, +    if (project.plugins.hasPlugin(BuildPlugin)) {, +           * Do not add those projects to the javadoc classpath because, +           * we are going to resolve them with their source instead., +           */, +          project.javadoc.classpath = project.javadoc.classpath.filter { f ->, +            false == upstreamProject.configurations.archives.artifacts.files.files.contains(f), +          }, +          /*, +          .each({ c -> depJavadocClosure(hasShadow, c) }), +          .each({ c -> depJavadocClosure(hasShadow, c) }), +        project.configurations.shadow.dependencies, +            .each({ c -> depJavadocClosure(false, c) }), +   * in "IntelliJ mode" or "Eclipse mode" add "runtime" dependencies, +   * eveywhere where we see a "shadow" dependency which will cause them to, +   * reference shadowed projects directly rather than rely on the shadowing, +   * to include them. This is the correct thing for it to do because it, +   * doesn't run the jar shadowing at all. This isn't needed for the project, +	configurations.all { Configuration configuration ->, +	  dependencies.all { Dependency dep ->, +		if (dep instanceof ProjectDependency) {, +		  if (dep.getTargetConfiguration() == 'shadow') {, +			configuration.dependencies.add(project.dependencies.project(path: dep.dependencyProject.path, configuration: 'runtime')), +		  }, +		}, +++ b/buildSrc/src/main/groovy/org/elasticsearch/gradle/BuildPlugin.groovy, +        configureJars(project) // jar config must be added before info broker, +        configureConfigurations(project), +            project.configurations.shadow.dependencies.all(disableTransitiveDeps), +                            artifactId = project.archivesBaseName, +                            /*, +                            * Configure the pom to include the "shadow" as compile dependencies, +                            * because that is how we're using them but remove all other dependencies, +                            * because they've been shaded into the jar., +                            pom.withXml { XmlProvider xml ->, +                                Node root = xml.asNode(), +                                root.remove(root.dependencies), +                                Node dependenciesNode = root.appendNode('dependencies'), +                                project.configurations.shadow.allDependencies.each {, +                                    if (false == it instanceof SelfResolvingDependency) {, +                                        Node dependencyNode = dependenciesNode.appendNode('dependency'), +                                        dependencyNode.appendNode('groupId', it.group), +                                        dependencyNode.appendNode('artifactId', it.name), +                                        dependencyNode.appendNode('version', it.version), +                                        dependencyNode.appendNode('scope', 'compile'), +                                    }, +                                }, +                                // Be tidy and remove the element if it is empty]