[+++ b/core/src/main/java/org/elasticsearch/client/transport/TransportClientNodesService.java, +                        transportService.connectToNodeLight(listedNode, pingTimeout, !ignoreClusterName);, +                        newFilteredNodes.add(listedNode);, +                                        transportService.connectToNodeLight(listedNode, pingTimeout, !ignoreClusterName);, +++ b/core/src/main/java/org/elasticsearch/client/transport/TransportClientNodesService.java, +                        transportService.connectToNodeLight(listedNode, pingTimeout, !ignoreClusterName);, +                        newFilteredNodes.add(listedNode);, +                                        transportService.connectToNodeLight(listedNode, pingTimeout, !ignoreClusterName);, +++ b/core/src/main/java/org/elasticsearch/discovery/zen/ping/unicast/UnicastZenPing.java, +                                transportService.connectToNodeLight(finalNodeToSend, timeout.getMillis());, +++ b/core/src/main/java/org/elasticsearch/client/transport/TransportClientNodesService.java, +                        transportService.connectToNodeLight(listedNode, pingTimeout, !ignoreClusterName);, +                        newFilteredNodes.add(listedNode);, +                                        transportService.connectToNodeLight(listedNode, pingTimeout, !ignoreClusterName);, +++ b/core/src/main/java/org/elasticsearch/discovery/zen/ping/unicast/UnicastZenPing.java, +                                transportService.connectToNodeLight(finalNodeToSend, timeout.getMillis());, +++ b/core/src/main/java/org/elasticsearch/transport/TransportService.java, +import org.elasticsearch.Version;, +import org.elasticsearch.cluster.ClusterName;, +import org.elasticsearch.common.io.stream.StreamInput;, +import org.elasticsearch.common.io.stream.StreamOutput;, +import java.util.Objects;, +    private static final String HANDSHAKE_ACTION_NAME = "internal:transport/handshake";, +    private final ClusterName clusterName;, +    public TransportService(Transport transport, ThreadPool threadPool, ClusterName clusterName) {, +        this(EMPTY_SETTINGS, transport, threadPool, clusterName);, +    public TransportService(Settings settings, Transport transport, ThreadPool threadPool, ClusterName clusterName) {, +        this.clusterName = clusterName;, +        registerRequestHandler(, +            HANDSHAKE_ACTION_NAME,, +            () -> HandshakeRequest.INSTANCE,, +            ThreadPool.Names.SAME,, +            (request, channel) -> channel.sendResponse(, +                    new HandshakeResponse(localNode, clusterName, localNode != null ? localNode.getVersion() : Version.CURRENT)));, +    /**, +     * Lightly connect to the specified node, and handshake cluster, +     * name and version, +     *, +     * @param node             the node to connect to, +     * @param handshakeTimeout handshake timeout, +     * @return the connected node with version set, +     * @throws ConnectTransportException if the connection or the, +     *                                   handshake failed, +     */, +    public DiscoveryNode connectToNodeLight(final DiscoveryNode node, final long handshakeTimeout) throws ConnectTransportException {, +        return connectToNodeLight(node, handshakeTimeout, true);, +    }, +, +    /**, +     * Lightly connect to the specified node, returning updated node, +     * information. The handshake will fail if the cluster name on the, +     * target node mismatches the local cluster name and, +     * {@code checkClusterName} is {@code true}., +     *, +     * @param node             the node to connect to, +     * @param handshakeTimeout handshake timeout, +     * @param checkClusterName whether or not to ignore cluster name, +     *                         mismatches, +     * @return the connected node, +     * @throws ConnectTransportException if the connection or the, +     *                                   handshake failed, +     */, +    public DiscoveryNode connectToNodeLight(final DiscoveryNode node, final long handshakeTimeout, final boolean checkClusterName) {, +            return localNode;, +        try {, +            return handshake(node, handshakeTimeout, checkClusterName);, +        } catch (ConnectTransportException e) {, +            transport.disconnectFromNode(node);, +            throw e;, +        }, +    }, +, +    private DiscoveryNode handshake(, +            final DiscoveryNode node,, +            final long handshakeTimeout,, +            final boolean checkClusterName) throws ConnectTransportException {, +        final HandshakeResponse response;, +        try {, +            response = this.submitRequest(, +                node,, +                HANDSHAKE_ACTION_NAME,, +                HandshakeRequest.INSTANCE,, +                TransportRequestOptions.builder().withTimeout(handshakeTimeout).build(),, +                new FutureTransportResponseHandler<HandshakeResponse>() {, +                    @Override, +                    public HandshakeResponse newInstance() {, +                        return new HandshakeResponse();, +                    }, +                }).txGet();, +        } catch (Exception e) {, +            throw new ConnectTransportException(node, "handshake failed", e);, +        }, +, +        if (checkClusterName && !Objects.equals(clusterName, response.clusterName)) {, +            throw new ConnectTransportException(node, "handshake failed, mismatched cluster name [" + response.clusterName + "]");, +        } else if (!isVersionCompatible(response.version)) {, +            throw new ConnectTransportException(node, "handshake failed, incompatible version [" + response.version + "]");, +        }, +, +        return response.discoveryNode;]