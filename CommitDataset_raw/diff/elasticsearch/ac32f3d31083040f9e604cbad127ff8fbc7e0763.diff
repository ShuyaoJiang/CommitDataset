[+++ b/core/src/main/java/org/elasticsearch/ElasticsearchException.java, +        Throwable ex = ExceptionsHelper.unwrapCause(this);, +        if (ex != this) {, +++ b/core/src/main/java/org/elasticsearch/ElasticsearchException.java, +        Throwable ex = ExceptionsHelper.unwrapCause(this);, +        if (ex != this) {, +++ b/core/src/main/java/org/elasticsearch/common/settings/Settings.java, +        this.settings = ImmutableMap.copyOf(settings);, +++ b/core/src/main/java/org/elasticsearch/ElasticsearchException.java, +        Throwable ex = ExceptionsHelper.unwrapCause(this);, +        if (ex != this) {, +++ b/core/src/main/java/org/elasticsearch/common/settings/Settings.java, +        this.settings = ImmutableMap.copyOf(settings);, +++ b/core/src/main/java/org/elasticsearch/index/mapper/MappedFieldType.java, +++ b/core/src/main/java/org/elasticsearch/ElasticsearchException.java, +        Throwable ex = ExceptionsHelper.unwrapCause(this);, +        if (ex != this) {, +++ b/core/src/main/java/org/elasticsearch/common/settings/Settings.java, +        this.settings = ImmutableMap.copyOf(settings);, +++ b/core/src/main/java/org/elasticsearch/index/mapper/MappedFieldType.java, +++ b/core/src/main/java/org/elasticsearch/index/mapper/MetadataFieldMapper.java, +    protected MetadataFieldMapper(String simpleName, MappedFieldType fieldType, Boolean docValues, @Nullable Settings fieldDataSettings, Settings indexSettings) {, +        super(simpleName, fieldType, docValues, fieldDataSettings, indexSettings, MultiFields.empty(), null);, +++ b/core/src/main/java/org/elasticsearch/ElasticsearchException.java, +        Throwable ex = ExceptionsHelper.unwrapCause(this);, +        if (ex != this) {, +++ b/core/src/main/java/org/elasticsearch/common/settings/Settings.java, +        this.settings = ImmutableMap.copyOf(settings);, +++ b/core/src/main/java/org/elasticsearch/index/mapper/MappedFieldType.java, +++ b/core/src/main/java/org/elasticsearch/index/mapper/MetadataFieldMapper.java, +    protected MetadataFieldMapper(String simpleName, MappedFieldType fieldType, Boolean docValues, @Nullable Settings fieldDataSettings, Settings indexSettings) {, +        super(simpleName, fieldType, docValues, fieldDataSettings, indexSettings, MultiFields.empty(), null);, +++ b/core/src/main/java/org/elasticsearch/index/mapper/core/AbstractFieldMapper.java, +        protected Boolean docValues;, +            this.docValues = docValues;, +    protected final boolean hasDefaultDocValues;, +    protected Settings customFieldDataSettings;, +    protected AbstractFieldMapper(String simpleName, MappedFieldType fieldType, Boolean docValues, @Nullable Settings fieldDataSettings, Settings indexSettings) {, +        this(simpleName, fieldType, docValues, fieldDataSettings, indexSettings, MultiFields.empty(), null);, +    }, +, +    protected AbstractFieldMapper(String simpleName, MappedFieldType fieldType, Boolean docValues, @Nullable Settings fieldDataSettings, Settings indexSettings, MultiFields multiFields, CopyTo copyTo) {, +        this.customFieldDataSettings = fieldDataSettings;, +        FieldDataType fieldDataType;, +        if (fieldDataSettings == null) {, +            fieldDataType = defaultFieldDataType();, +        } else {, +            // create a new field data type, with the default settings as well as the "new ones", +            fieldDataType = new FieldDataType(defaultFieldDataType().getType(),, +                Settings.builder().put(defaultFieldDataType().getSettings()).put(fieldDataSettings), +            );, +        }, +, +        // TODO: hasDocValues should just be set directly on the field type by callers of this ctor, but, +        // then we need to eliminate defaultDocValues() (only needed by geo, which needs to be fixed with passing, +        // doc values setting down to lat/lon) and get rid of specifying doc values in fielddata (which, +        // complicates whether we can just compare to the default value to know whether to write the setting), +        if (docValues == null && fieldDataType != null && FieldDataType.DOC_VALUES_FORMAT_VALUE.equals(fieldDataType.getFormat(indexSettings))) {, +            docValues = true;, +        }, +        hasDefaultDocValues = docValues == null;, +, +        this.fieldTypeRef = new MappedFieldTypeReference(fieldType); // must init first so defaultDocValues() can be called, +        fieldType = fieldType.clone();, +        if (fieldType.indexAnalyzer() == null && fieldType.tokenized() == false && fieldType.indexOptions() != IndexOptions.NONE) {, +            fieldType.setIndexAnalyzer(Lucene.KEYWORD_ANALYZER);, +            fieldType.setSearchAnalyzer(Lucene.KEYWORD_ANALYZER);, +        }, +        fieldType.setHasDocValues(docValues == null ? defaultDocValues() : docValues);, +        fieldType.setFieldDataType(fieldDataType);, +        fieldType.freeze();, +        this.fieldTypeRef.set(fieldType); // now reset ref once extra settings have been initialized, +, +    protected boolean defaultDocValues() {, +        if (indexCreatedBefore2x) {, +            return false;, +        } else {, +            return fieldType().tokenized() == false && fieldType().indexOptions() != IndexOptions.NONE;, +        }, +    }, +, +    public abstract MappedFieldType defaultFieldType();, +, +    public abstract FieldDataType defaultFieldDataType();, +, +            this.customFieldDataSettings = fieldMergeWith.customFieldDataSettings;, +        FieldType defaultFieldType = defaultFieldType();, +        TreeMap<String, Object> orderedFielddataSettings = new TreeMap<>();, +        if (hasCustomFieldDataSettings()) {, +            orderedFielddataSettings.putAll(customFieldDataSettings.getAsMap());, +            builder.field("fielddata", orderedFielddataSettings);, +        } else if (includeDefaults) {, +            orderedFielddataSettings.putAll(fieldType().fieldDataType().getSettings().getAsMap());, +            builder.field("fielddata", orderedFielddataSettings);, +        if (includeDefaults || hasDefaultDocValues == false) {, +        return customFieldDataSettings != null && customFieldDataSettings.equals(Settings.EMPTY) == false;, +++ b/core/src/main/java/org/elasticsearch/ElasticsearchException.java, +        Throwable ex = ExceptionsHelper.unwrapCause(this);, +        if (ex != this) {, +++ b/core/src/main/java/org/elasticsearch/common/settings/Settings.java]