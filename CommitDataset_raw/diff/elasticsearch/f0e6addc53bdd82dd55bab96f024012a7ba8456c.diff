[+++ b/src/main/java/org/elasticsearch/snapshots/SnapshotsService.java, +                    processIndexShardSnapshots(event);, +                    processIndexShardSnapshots(event);, +            if (event.state().nodes().masterNodeId() != null &&, +                    event.state().nodes().masterNodeId().equals(event.previousState().nodes().masterNodeId()) == false) {, +                syncShardStatsOnNewMaster(event);, +            }, +, +     * @param event cluster state changed event, +    private void processIndexShardSnapshots(ClusterChangedEvent event) {, +        SnapshotMetaData snapshotMetaData = event.state().metaData().custom(SnapshotMetaData.TYPE);, +                                if (snapshotStatus.stage() == IndexShardSnapshotStatus.Stage.STARTED) {, +                                } else if (snapshotStatus.stage() == IndexShardSnapshotStatus.Stage.DONE) {, +                                    logger.debug("[{}] trying to cancel snapshot on the shard [{}] that is already done, updating status on the master", entry.snapshotId(), shard.getKey());, +                                    updateIndexShardSnapshotStatus(new UpdateIndexShardSnapshotStatusRequest(entry.snapshotId(), shard.getKey(),, +                                            new ShardSnapshotStatus(event.state().nodes().localNodeId(), SnapshotMetaData.State.SUCCESS)));, +                                } else if (snapshotStatus.stage() == IndexShardSnapshotStatus.Stage.FAILURE) {, +                                    logger.debug("[{}] trying to cancel snapshot on the shard [{}] that has already failed, updating status on the master", entry.snapshotId(), shard.getKey());, +                                    updateIndexShardSnapshotStatus(new UpdateIndexShardSnapshotStatusRequest(entry.snapshotId(), shard.getKey(),, +                                            new ShardSnapshotStatus(event.state().nodes().localNodeId(), State.FAILED, snapshotStatus.failure())));, +                                }, +     * Checks if any shards were processed that the new master doesn't know about, +     * @param event, +     */, +    private void syncShardStatsOnNewMaster(ClusterChangedEvent event) {, +        SnapshotMetaData snapshotMetaData = event.state().getMetaData().custom(SnapshotMetaData.TYPE);, +        if (snapshotMetaData == null) {, +            return;, +        }, +        for (SnapshotMetaData.Entry snapshot : snapshotMetaData.entries()) {, +            if (snapshot.state() == State.STARTED || snapshot.state() == State.ABORTED) {, +                ImmutableMap<ShardId, IndexShardSnapshotStatus> localShards = currentSnapshotShards(snapshot.snapshotId());, +                if (localShards != null) {, +                    ImmutableMap<ShardId, ShardSnapshotStatus> masterShards = snapshot.shards();, +                    for(Map.Entry<ShardId, IndexShardSnapshotStatus> localShard : localShards.entrySet()) {, +                        ShardId shardId = localShard.getKey();, +                        IndexShardSnapshotStatus localShardStatus = localShard.getValue();, +                        ShardSnapshotStatus masterShard = masterShards.get(shardId);, +                        if (masterShard != null && masterShard.state().completed() == false) {, +                            // Master knows about the shard and thinks it has not completed, +                            if (localShardStatus.stage() == IndexShardSnapshotStatus.Stage.DONE) {, +                                // but we think the shard is done - we need to make new master know that the shard is done, +                                logger.debug("[{}] new master thinks the shard [{}] is not completed but the shard is done locally, updating status on the master", snapshot.snapshotId(), shardId);, +                                updateIndexShardSnapshotStatus(new UpdateIndexShardSnapshotStatusRequest(snapshot.snapshotId(), shardId,, +                                        new ShardSnapshotStatus(event.state().nodes().localNodeId(), SnapshotMetaData.State.SUCCESS)));, +                            } else if (localShard.getValue().stage() == IndexShardSnapshotStatus.Stage.FAILURE) {, +                                // but we think the shard failed - we need to make new master know that the shard failed, +                                logger.debug("[{}] new master thinks the shard [{}] is not completed but the shard failed locally, updating status on master", snapshot.snapshotId(), shardId);, +                                updateIndexShardSnapshotStatus(new UpdateIndexShardSnapshotStatusRequest(snapshot.snapshotId(), shardId,, +                                        new ShardSnapshotStatus(event.state().nodes().localNodeId(), State.FAILED, localShardStatus.failure())));, +, +                            }, +                        }, +                    }, +                }, +            }, +        }, +    }, +, +    /**, +++ b/src/main/java/org/elasticsearch/snapshots/SnapshotsService.java, +                    processIndexShardSnapshots(event);, +                    processIndexShardSnapshots(event);, +            if (event.state().nodes().masterNodeId() != null &&, +                    event.state().nodes().masterNodeId().equals(event.previousState().nodes().masterNodeId()) == false) {, +                syncShardStatsOnNewMaster(event);, +            }, +, +     * @param event cluster state changed event, +    private void processIndexShardSnapshots(ClusterChangedEvent event) {, +        SnapshotMetaData snapshotMetaData = event.state().metaData().custom(SnapshotMetaData.TYPE);, +                                if (snapshotStatus.stage() == IndexShardSnapshotStatus.Stage.STARTED) {, +                                } else if (snapshotStatus.stage() == IndexShardSnapshotStatus.Stage.DONE) {, +                                    logger.debug("[{}] trying to cancel snapshot on the shard [{}] that is already done, updating status on the master", entry.snapshotId(), shard.getKey());, +                                    updateIndexShardSnapshotStatus(new UpdateIndexShardSnapshotStatusRequest(entry.snapshotId(), shard.getKey(),, +                                            new ShardSnapshotStatus(event.state().nodes().localNodeId(), SnapshotMetaData.State.SUCCESS)));, +                                } else if (snapshotStatus.stage() == IndexShardSnapshotStatus.Stage.FAILURE) {, +                                    logger.debug("[{}] trying to cancel snapshot on the shard [{}] that has already failed, updating status on the master", entry.snapshotId(), shard.getKey());, +                                    updateIndexShardSnapshotStatus(new UpdateIndexShardSnapshotStatusRequest(entry.snapshotId(), shard.getKey(),, +                                            new ShardSnapshotStatus(event.state().nodes().localNodeId(), State.FAILED, snapshotStatus.failure())));, +                                }, +     * Checks if any shards were processed that the new master doesn't know about, +     * @param event, +     */, +    private void syncShardStatsOnNewMaster(ClusterChangedEvent event) {, +        SnapshotMetaData snapshotMetaData = event.state().getMetaData().custom(SnapshotMetaData.TYPE);, +        if (snapshotMetaData == null) {, +            return;, +        }, +        for (SnapshotMetaData.Entry snapshot : snapshotMetaData.entries()) {, +            if (snapshot.state() == State.STARTED || snapshot.state() == State.ABORTED) {, +                ImmutableMap<ShardId, IndexShardSnapshotStatus> localShards = currentSnapshotShards(snapshot.snapshotId());, +                if (localShards != null) {, +                    ImmutableMap<ShardId, ShardSnapshotStatus> masterShards = snapshot.shards();, +                    for(Map.Entry<ShardId, IndexShardSnapshotStatus> localShard : localShards.entrySet()) {, +                        ShardId shardId = localShard.getKey();, +                        IndexShardSnapshotStatus localShardStatus = localShard.getValue();, +                        ShardSnapshotStatus masterShard = masterShards.get(shardId);, +                        if (masterShard != null && masterShard.state().completed() == false) {, +                            // Master knows about the shard and thinks it has not completed]