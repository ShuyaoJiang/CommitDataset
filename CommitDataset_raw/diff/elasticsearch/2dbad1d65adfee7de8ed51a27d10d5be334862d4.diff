[+++ b/buildSrc/src/main/resources/forbidden/all-signatures.txt, +@defaultMessage Use org.elasticsearch.common.Randomness#get for reproducible sources of randomness, +java.util.Random#<init>(), +java.util.concurrent.ThreadLocalRandom, +++ b/buildSrc/src/main/resources/forbidden/all-signatures.txt, +@defaultMessage Use org.elasticsearch.common.Randomness#get for reproducible sources of randomness, +java.util.Random#<init>(), +java.util.concurrent.ThreadLocalRandom, +++ b/core/src/main/java/org/elasticsearch/action/admin/indices/validate/query/TransportValidateQueryAction.java, +import org.elasticsearch.common.Randomness;, +        Map<String, Set<String>> routingMap = indexNameExpressionResolver.resolveSearchRouting(clusterState, Integer.toString(Randomness.get().nextInt(1000)), request.indices());, +++ b/buildSrc/src/main/resources/forbidden/all-signatures.txt, +@defaultMessage Use org.elasticsearch.common.Randomness#get for reproducible sources of randomness, +java.util.Random#<init>(), +java.util.concurrent.ThreadLocalRandom, +++ b/core/src/main/java/org/elasticsearch/action/admin/indices/validate/query/TransportValidateQueryAction.java, +import org.elasticsearch.common.Randomness;, +        Map<String, Set<String>> routingMap = indexNameExpressionResolver.resolveSearchRouting(clusterState, Integer.toString(Randomness.get().nextInt(1000)), request.indices());, +++ b/core/src/main/java/org/elasticsearch/cluster/routing/IndexRoutingTable.java, +import org.elasticsearch.common.Randomness;, +        this.shuffler = new RotationShardShuffler(Randomness.get().nextInt());, +++ b/buildSrc/src/main/resources/forbidden/all-signatures.txt, +@defaultMessage Use org.elasticsearch.common.Randomness#get for reproducible sources of randomness, +java.util.Random#<init>(), +java.util.concurrent.ThreadLocalRandom, +++ b/core/src/main/java/org/elasticsearch/action/admin/indices/validate/query/TransportValidateQueryAction.java, +import org.elasticsearch.common.Randomness;, +        Map<String, Set<String>> routingMap = indexNameExpressionResolver.resolveSearchRouting(clusterState, Integer.toString(Randomness.get().nextInt(1000)), request.indices());, +++ b/core/src/main/java/org/elasticsearch/cluster/routing/IndexRoutingTable.java, +import org.elasticsearch.common.Randomness;, +        this.shuffler = new RotationShardShuffler(Randomness.get().nextInt());, +++ b/core/src/main/java/org/elasticsearch/cluster/routing/IndexShardRoutingTable.java, +import org.elasticsearch.common.Randomness;, +        this.shuffler = new RotationShardShuffler(Randomness.get().nextInt());, +++ b/buildSrc/src/main/resources/forbidden/all-signatures.txt, +@defaultMessage Use org.elasticsearch.common.Randomness#get for reproducible sources of randomness, +java.util.Random#<init>(), +java.util.concurrent.ThreadLocalRandom, +++ b/core/src/main/java/org/elasticsearch/action/admin/indices/validate/query/TransportValidateQueryAction.java, +import org.elasticsearch.common.Randomness;, +        Map<String, Set<String>> routingMap = indexNameExpressionResolver.resolveSearchRouting(clusterState, Integer.toString(Randomness.get().nextInt(1000)), request.indices());, +++ b/core/src/main/java/org/elasticsearch/cluster/routing/IndexRoutingTable.java, +import org.elasticsearch.common.Randomness;, +        this.shuffler = new RotationShardShuffler(Randomness.get().nextInt());, +++ b/core/src/main/java/org/elasticsearch/cluster/routing/IndexShardRoutingTable.java, +import org.elasticsearch.common.Randomness;, +        this.shuffler = new RotationShardShuffler(Randomness.get().nextInt());, +++ b/core/src/main/java/org/elasticsearch/common/Randomness.java, +    @SuppressForbidden(reason = "ThreadLocalRandom is okay when not running tests"), +++ b/buildSrc/src/main/resources/forbidden/all-signatures.txt, +@defaultMessage Use org.elasticsearch.common.Randomness#get for reproducible sources of randomness, +java.util.Random#<init>(), +java.util.concurrent.ThreadLocalRandom, +++ b/core/src/main/java/org/elasticsearch/action/admin/indices/validate/query/TransportValidateQueryAction.java, +import org.elasticsearch.common.Randomness;, +        Map<String, Set<String>> routingMap = indexNameExpressionResolver.resolveSearchRouting(clusterState, Integer.toString(Randomness.get().nextInt(1000)), request.indices());, +++ b/core/src/main/java/org/elasticsearch/cluster/routing/IndexRoutingTable.java, +import org.elasticsearch.common.Randomness;, +        this.shuffler = new RotationShardShuffler(Randomness.get().nextInt());, +++ b/core/src/main/java/org/elasticsearch/cluster/routing/IndexShardRoutingTable.java, +import org.elasticsearch.common.Randomness;, +        this.shuffler = new RotationShardShuffler(Randomness.get().nextInt());, +++ b/core/src/main/java/org/elasticsearch/common/Randomness.java, +    @SuppressForbidden(reason = "ThreadLocalRandom is okay when not running tests"), +++ /dev/null, +++ b/buildSrc/src/main/resources/forbidden/all-signatures.txt, +@defaultMessage Use org.elasticsearch.common.Randomness#get for reproducible sources of randomness, +java.util.Random#<init>(), +java.util.concurrent.ThreadLocalRandom, +++ b/core/src/main/java/org/elasticsearch/action/admin/indices/validate/query/TransportValidateQueryAction.java, +import org.elasticsearch.common.Randomness;, +        Map<String, Set<String>> routingMap = indexNameExpressionResolver.resolveSearchRouting(clusterState, Integer.toString(Randomness.get().nextInt(1000)), request.indices());, +++ b/core/src/main/java/org/elasticsearch/cluster/routing/IndexRoutingTable.java, +import org.elasticsearch.common.Randomness;, +        this.shuffler = new RotationShardShuffler(Randomness.get().nextInt());, +++ b/core/src/main/java/org/elasticsearch/cluster/routing/IndexShardRoutingTable.java, +import org.elasticsearch.common.Randomness;, +        this.shuffler = new RotationShardShuffler(Randomness.get().nextInt());, +++ b/core/src/main/java/org/elasticsearch/common/Randomness.java, +    @SuppressForbidden(reason = "ThreadLocalRandom is okay when not running tests"), +++ /dev/null, +++ b/core/src/main/java/org/elasticsearch/index/analysis/NGramTokenizerFactory.java, +import org.apache.lucene.analysis.ngram.Lucene43NGramTokenizer;, +import org.apache.lucene.util.Version;, +    private org.elasticsearch.Version esVersion;, +        this.esVersion = indexSettings.getIndexVersionCreated();, +    @SuppressWarnings("deprecation"), +        if (version.onOrAfter(Version.LUCENE_4_3) && esVersion.onOrAfter(org.elasticsearch.Version.V_0_90_2)) {, +            /*, +             * We added this in 0.90.2 but 0.90.1 used LUCENE_43 already so we can not rely on the lucene version., +             * Yet if somebody uses 0.90.2 or higher with a prev. lucene version we should also use the deprecated version., +             */, +            final Version version = this.version == Version.LUCENE_4_3 ? Version.LUCENE_4_4 : this.version; // always use 4.4 or higher, +        } else {, +            return new Lucene43NGramTokenizer(minGram, maxGram);, +        }, +++ b/buildSrc/src/main/resources/forbidden/all-signatures.txt, +@defaultMessage Use org.elasticsearch.common.Randomness#get for reproducible sources of randomness, +java.util.Random#<init>(), +java.util.concurrent.ThreadLocalRandom]