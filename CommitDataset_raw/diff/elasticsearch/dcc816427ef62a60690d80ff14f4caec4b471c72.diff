[+++ b/server/src/main/java/org/elasticsearch/index/seqno/ReplicationTracker.java, +import java.util.Objects;, +     * A callback invoked when the global checkpoint is updated. For primary mode this occurs if the computed global checkpoint advances on, +     * the basis of state changes tracked here. For non-primary mode this occurs if the local knowledge of the global checkpoint advances, +     * due to an update from the primary., +     */, +    private final LongConsumer onGlobalCheckpointUpdated;, +, +    /**, +            final long globalCheckpoint,, +            final LongConsumer onGlobalCheckpointUpdated) {, +        this.onGlobalCheckpointUpdated = Objects.requireNonNull(onGlobalCheckpointUpdated);, +                current -> {, +                    logger.trace("updated global checkpoint from [{}] to [{}] due to [{}]", current, globalCheckpoint, reason);, +                    onGlobalCheckpointUpdated.accept(globalCheckpoint);, +                });, +                        "updated local knowledge for [{}] on the primary of the global checkpoint from [{}] to [{}]",, +            ifUpdated.accept(cps.globalCheckpoint);, +            logger.trace("updated global checkpoint to [{}]", computedGlobalCheckpoint);, +            onGlobalCheckpointUpdated.accept(computedGlobalCheckpoint);, +++ b/server/src/main/java/org/elasticsearch/index/seqno/ReplicationTracker.java, +import java.util.Objects;, +     * A callback invoked when the global checkpoint is updated. For primary mode this occurs if the computed global checkpoint advances on, +     * the basis of state changes tracked here. For non-primary mode this occurs if the local knowledge of the global checkpoint advances, +     * due to an update from the primary., +     */, +    private final LongConsumer onGlobalCheckpointUpdated;, +, +    /**, +            final long globalCheckpoint,, +            final LongConsumer onGlobalCheckpointUpdated) {, +        this.onGlobalCheckpointUpdated = Objects.requireNonNull(onGlobalCheckpointUpdated);, +                current -> {, +                    logger.trace("updated global checkpoint from [{}] to [{}] due to [{}]", current, globalCheckpoint, reason);, +                    onGlobalCheckpointUpdated.accept(globalCheckpoint);, +                });, +                        "updated local knowledge for [{}] on the primary of the global checkpoint from [{}] to [{}]",, +            ifUpdated.accept(cps.globalCheckpoint);, +            logger.trace("updated global checkpoint to [{}]", computedGlobalCheckpoint);, +            onGlobalCheckpointUpdated.accept(computedGlobalCheckpoint);, +++ b/server/src/main/java/org/elasticsearch/index/shard/IndexShard.java, +        final String aId = shardRouting.allocationId().getId();, +        this.replicationTracker =, +                new ReplicationTracker(shardId, aId, indexSettings, SequenceNumbers.UNASSIGNED_SEQ_NO, globalCheckpoint -> {});, +++ b/server/src/main/java/org/elasticsearch/index/seqno/ReplicationTracker.java, +import java.util.Objects;, +     * A callback invoked when the global checkpoint is updated. For primary mode this occurs if the computed global checkpoint advances on, +     * the basis of state changes tracked here. For non-primary mode this occurs if the local knowledge of the global checkpoint advances, +     * due to an update from the primary., +     */, +    private final LongConsumer onGlobalCheckpointUpdated;, +, +    /**, +            final long globalCheckpoint,, +            final LongConsumer onGlobalCheckpointUpdated) {, +        this.onGlobalCheckpointUpdated = Objects.requireNonNull(onGlobalCheckpointUpdated);, +                current -> {, +                    logger.trace("updated global checkpoint from [{}] to [{}] due to [{}]", current, globalCheckpoint, reason);, +                    onGlobalCheckpointUpdated.accept(globalCheckpoint);, +                });, +                        "updated local knowledge for [{}] on the primary of the global checkpoint from [{}] to [{}]",, +            ifUpdated.accept(cps.globalCheckpoint);, +            logger.trace("updated global checkpoint to [{}]", computedGlobalCheckpoint);, +            onGlobalCheckpointUpdated.accept(computedGlobalCheckpoint);, +++ b/server/src/main/java/org/elasticsearch/index/shard/IndexShard.java, +        final String aId = shardRouting.allocationId().getId();, +        this.replicationTracker =, +                new ReplicationTracker(shardId, aId, indexSettings, SequenceNumbers.UNASSIGNED_SEQ_NO, globalCheckpoint -> {});, +++ b/server/src/test/java/org/elasticsearch/index/seqno/ReplicationTrackerTests.java, +import java.util.concurrent.atomic.AtomicLong;, +import java.util.function.LongConsumer;, +    private void updateLocalCheckpoint(final ReplicationTracker tracker, final String allocationId, final long localCheckpoint) {, +        tracker.updateLocalCheckpoint(allocationId, localCheckpoint);, +        assertThat(updatedGlobalCheckpoint.get(), equalTo(tracker.getGlobalCheckpoint()));, +    }, +    , +        allocations.keySet().forEach(aId -> updateLocalCheckpoint(tracker, aId.getId(), allocations.get(aId)));, +        allocations.keySet().forEach(aId -> updateLocalCheckpoint(tracker, aId.getId(), allocations.get(aId)));, +        updateLocalCheckpoint(tracker, extraId.getId(), minLocalCheckpointAfterUpdates + 1 + randomInt(4));, +            updateLocalCheckpoint(tracker, extraId.getId(), minLocalCheckpointAfterUpdates + 1 + randomInt(4));, +    public void testUpdateGlobalCheckpointOnReplica() {, +        final AllocationId active = AllocationId.newInitializing();, +        final ReplicationTracker tracker = newTracker(active);, +        final long globalCheckpoint = randomLongBetween(NO_OPS_PERFORMED, Long.MAX_VALUE - 1);, +        tracker.updateGlobalCheckpointOnReplica(globalCheckpoint, "test");, +        assertThat(updatedGlobalCheckpoint.get(), equalTo(globalCheckpoint));, +        final long nonUpdate = randomLongBetween(NO_OPS_PERFORMED, globalCheckpoint);, +        updatedGlobalCheckpoint.set(UNASSIGNED_SEQ_NO);, +        tracker.updateGlobalCheckpointOnReplica(nonUpdate, "test");, +        assertThat(updatedGlobalCheckpoint.get(), equalTo(UNASSIGNED_SEQ_NO));, +        final long update = randomLongBetween(globalCheckpoint, Long.MAX_VALUE);, +        tracker.updateGlobalCheckpointOnReplica(update, "test");, +        assertThat(updatedGlobalCheckpoint.get(), equalTo(update));, +    }, +, +    public void testMarkAllocationIdAsInSync() throws BrokenBarrierException, InterruptedException {, +        final long initialClusterStateVersion = randomNonNegativeLong();, +        Map<AllocationId, Long> activeWithCheckpoints = randomAllocationsWithLocalCheckpoints(1, 1);, +        Set<AllocationId> active = new HashSet<>(activeWithCheckpoints.keySet());, +        Map<AllocationId, Long> initializingWithCheckpoints = randomAllocationsWithLocalCheckpoints(1, 1);]