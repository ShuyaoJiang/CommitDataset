[+++ b/x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authc/ExpiredTokenRemover.java, +import org.elasticsearch.common.Strings;, +        logger.trace(() -> new ParameterizedMessage("Removing old tokens: [{}]", Strings.toString(expiredDbq)));, +++ b/x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authc/ExpiredTokenRemover.java, +import org.elasticsearch.common.Strings;, +        logger.trace(() -> new ParameterizedMessage("Removing old tokens: [{}]", Strings.toString(expiredDbq)));, +++ b/x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authc/TokenService.java, +import org.elasticsearch.ElasticsearchException;, +import org.elasticsearch.cluster.ClusterStateUpdateTask;, +import org.elasticsearch.cluster.metadata.MetaData;, +import org.elasticsearch.common.Priority;, +import org.elasticsearch.core.internal.io.IOUtils;, +import org.elasticsearch.xpack.core.XPackField;, +import java.util.function.Consumer;, +    private static final int MAX_RETRY_ATTEMPTS = 5;, +            listener.onFailure(traceLog("create token", null, new IllegalArgumentException("authentication must be provided")));, +            listener.onFailure(traceLog("create token", null,, +                new IllegalArgumentException("originating client authentication must be provided")));, +                final String documentId = getTokenDocumentId(userToken);, +                        client.prepareIndex(SecurityIndexManager.SECURITY_INDEX_NAME, TYPE, documentId), +                securityIndex.prepareIndexIfNeededThenExecute(ex -> listener.onFailure(traceLog("prepare security index", documentId, ex)),, +                    () -> executeAsyncWithOrigin(client, SECURITY_ORIGIN, IndexAction.INSTANCE, request,, +                    listener.onFailure(traceLog("decode token", token, expiredTokenException()));, +                                    securityIndex.checkIndexVersionThenExecute(, +                                        ex -> listener.onFailure(traceLog("prepare security index", tokenId, ex)),, +                                        () -> {, +                                            final GetRequest getRequest = client.prepareGet(SecurityIndexManager.SECURITY_INDEX_NAME, TYPE,, +                                            Consumer<Exception> onFailure = ex -> listener.onFailure(traceLog("decode token", tokenId, ex));, +                                                            onFailure.accept(new IllegalStateException(, +                                                                "token document is missing the access_token field"));, +                                                            onFailure.accept(new IllegalStateException(, +                                                                "token document is missing the user_token field"));, +                                                        onFailure.accept(, +            logger.trace("No token-string provided");, +                        listener.onFailure(traceLog("invalidate token", tokenString, malformedTokenException()));, +            logger.trace("No access token provided");, +            logger.trace("No refresh token provided");, +        if (attemptCount.get() > MAX_RETRY_ATTEMPTS) {, +            logger.warn("Failed to invalidate token [{}] after [{}] attempts", userToken.getId(), attemptCount.get());, +            securityIndex.prepareIndexIfNeededThenExecute(ex -> listener.onFailure(traceLog("prepare security index", tokenDocId, ex)),, +                () -> executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN, indexRequest,, +                                traceLog("(bwc) invalidate token", tokenDocId, cause);, +        if (attemptCount.get() > MAX_RETRY_ATTEMPTS) {, +            logger.warn("Failed to invalidate token [{}] after [{}] attempts", tokenDocId, attemptCount.get());, +            securityIndex.prepareIndexIfNeededThenExecute(ex -> listener.onFailure(traceLog("prepare security index", tokenDocId, ex)),, +                () -> executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN, request,, +                        logger.debug("Invalidated [{}] for doc [{}]", srcPrefix, tokenDocId);, +                        traceLog("invalidate token", tokenDocId, cause);, +                                            Map<String, Object> accessTokenSource = (Map<String, Object>) source.get("access_token");, +                                            Consumer<Exception> onFailure = ex -> listener.onFailure(traceLog("get token", tokenDocId, ex));, +                                                onFailure.accept(new IllegalArgumentException(, +                                                    "token document is missing access_token field"));, +                                                    onFailure.accept(new IllegalStateException(, +                                                    logger.trace("Token [{}] is already invalidated", tokenDocId);, +                                        traceLog("get token", tokenDocId, e1);, +        if (attemptCount.get() > MAX_RETRY_ATTEMPTS) {, +            logger.warn("Failed to find token for refresh token [{}] after [{}] attempts", refreshToken, attemptCount.get());, +                Consumer<Exception> onFailure = ex -> listener.onFailure(traceLog("find by refresh token", refreshToken, ex));, +                                onFailure.accept(invalidGrantException("could not refresh the requested token"));, +                                onFailure.accept(new IllegalStateException("multiple tokens share the same refresh token"));, +                                onFailure.accept(e);, +        if (attemptCount.getAndIncrement() > MAX_RETRY_ATTEMPTS) {, +            logger.warn("Failed to refresh token for doc [{}] after [{}] attempts", tokenDocId, attemptCount.get());, +            Consumer<Exception> onFailure = ex -> listener.onFailure(traceLog("refresh token", tokenDocId, ex));, +                            onFailure.accept(invalidSource.get());, +                                                onFailure.accept(e);, +                        onFailure.accept(invalidGrantException("could not refresh the requested token"));, +                Consumer<Exception> onFailure = ex -> listener.onFailure(traceLog("check token state", userToken.getId(), ex));, +                                    onFailure.accept(expiredTokenException());, +                                        onFailure.accept(new IllegalStateException("token document is missing access_token field"));, +                                            onFailure.accept(new IllegalStateException("token document is missing invalidated field"));, +                                            onFailure.accept(expiredTokenException());, +                                    onFailure.accept(new IllegalStateException("token document is missing and must be present"));, +    /**, +     * Logs an exception at TRACE level (if enabled), +     */, +    private <E extends Throwable> E traceLog(String action, String identifier, E exception) {, +        if (logger.isTraceEnabled()) {, +            if (exception instanceof ElasticsearchException) {, +                final ElasticsearchException esEx = (ElasticsearchException) exception;, +                final Object detail = esEx.getHeader("error_description");, +                if (detail != null) {, +                    logger.trace("Failure in [{}] for id [{}] - [{}] [{}]", action, identifier, detail, esEx.getDetailedMessage());, +                } else {, +                    logger.trace("Failure in [{}] for id [{}] - [{}]", action, identifier, esEx.getDetailedMessage());, +                }, +            } else {, +                logger.trace("Failure in [{}] for id [{}] - [{}]", action, identifier, exception.toString());, +            }, +        }, +        return exception;, +    }, +, +++ b/x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authc/ExpiredTokenRemover.java, +import org.elasticsearch.common.Strings;, +        logger.trace(() -> new ParameterizedMessage("Removing old tokens: [{}]", Strings.toString(expiredDbq)));, +++ b/x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authc/TokenService.java, +import org.elasticsearch.ElasticsearchException;, +import org.elasticsearch.cluster.ClusterStateUpdateTask;, +import org.elasticsearch.cluster.metadata.MetaData;]