[+++ b/core/src/main/java/org/elasticsearch/client/transport/TransportClientNodesService.java, +            List<DiscoveryNode> listNodesBuilder = new ArrayList<>();, +                    listNodesBuilder.add(otherNode);, +                    logger.debug("removing address [{}] from listed nodes", otherNode);, +            listedNodes = Collections.unmodifiableList(listNodesBuilder);, +            List<DiscoveryNode> nodesBuilder = new ArrayList<>();, +            for (DiscoveryNode otherNode : nodes) {, +                if (!otherNode.getAddress().equals(transportAddress)) {, +                    nodesBuilder.add(otherNode);, +                } else {, +                    logger.debug("disconnecting from node with address [{}]", otherNode);, +                    transportService.disconnectFromNode(otherNode);, +                }, +            }, +            nodes = Collections.unmodifiableList(nodesBuilder);, +++ b/core/src/main/java/org/elasticsearch/client/transport/TransportClientNodesService.java, +            List<DiscoveryNode> listNodesBuilder = new ArrayList<>();, +                    listNodesBuilder.add(otherNode);, +                    logger.debug("removing address [{}] from listed nodes", otherNode);, +            listedNodes = Collections.unmodifiableList(listNodesBuilder);, +            List<DiscoveryNode> nodesBuilder = new ArrayList<>();, +            for (DiscoveryNode otherNode : nodes) {, +                if (!otherNode.getAddress().equals(transportAddress)) {, +                    nodesBuilder.add(otherNode);, +                } else {, +                    logger.debug("disconnecting from node with address [{}]", otherNode);, +                    transportService.disconnectFromNode(otherNode);, +                }, +            }, +            nodes = Collections.unmodifiableList(nodesBuilder);, +++ b/core/src/main/java/org/elasticsearch/transport/TransportService.java, +            } else {, +                logger.debug("Exception while sending request, handler likely already notified due to timeout", e);, +++ b/core/src/main/java/org/elasticsearch/client/transport/TransportClientNodesService.java, +            List<DiscoveryNode> listNodesBuilder = new ArrayList<>();, +                    listNodesBuilder.add(otherNode);, +                    logger.debug("removing address [{}] from listed nodes", otherNode);, +            listedNodes = Collections.unmodifiableList(listNodesBuilder);, +            List<DiscoveryNode> nodesBuilder = new ArrayList<>();, +            for (DiscoveryNode otherNode : nodes) {, +                if (!otherNode.getAddress().equals(transportAddress)) {, +                    nodesBuilder.add(otherNode);, +                } else {, +                    logger.debug("disconnecting from node with address [{}]", otherNode);, +                    transportService.disconnectFromNode(otherNode);, +                }, +            }, +            nodes = Collections.unmodifiableList(nodesBuilder);, +++ b/core/src/main/java/org/elasticsearch/transport/TransportService.java, +            } else {, +                logger.debug("Exception while sending request, handler likely already notified due to timeout", e);, +++ b/core/src/test/java/org/elasticsearch/client/transport/FailAndRetryMockTransport.java, +import org.elasticsearch.action.admin.cluster.node.liveness.TransportLivenessAction;, +import org.elasticsearch.action.admin.cluster.state.ClusterStateAction;, +import org.elasticsearch.action.admin.cluster.state.ClusterStateResponse;, +import org.elasticsearch.cluster.ClusterState;, +import org.elasticsearch.cluster.node.DiscoveryNodes;, +    protected abstract ClusterState getMockClusterState(DiscoveryNode node);, +, +            if (TransportLivenessAction.NAME.equals(action)) {, +            } else if (ClusterStateAction.NAME.equals(action)) {, +                TransportResponseHandler transportResponseHandler = transportServiceAdapter.onResponseReceived(requestId);, +                ClusterState clusterState = getMockClusterState(node);, +                transportResponseHandler.handleResponse(new ClusterStateResponse(clusterName, clusterState));, +            } else {, +                throw new UnsupportedOperationException("Mock transport does not understand action " + action);, +            }, +++ b/core/src/main/java/org/elasticsearch/client/transport/TransportClientNodesService.java, +            List<DiscoveryNode> listNodesBuilder = new ArrayList<>();, +                    listNodesBuilder.add(otherNode);, +                    logger.debug("removing address [{}] from listed nodes", otherNode);, +            listedNodes = Collections.unmodifiableList(listNodesBuilder);, +            List<DiscoveryNode> nodesBuilder = new ArrayList<>();, +            for (DiscoveryNode otherNode : nodes) {, +                if (!otherNode.getAddress().equals(transportAddress)) {, +                    nodesBuilder.add(otherNode);, +                } else {, +                    logger.debug("disconnecting from node with address [{}]", otherNode);, +                    transportService.disconnectFromNode(otherNode);, +                }, +            }, +            nodes = Collections.unmodifiableList(nodesBuilder);, +++ b/core/src/main/java/org/elasticsearch/transport/TransportService.java, +            } else {, +                logger.debug("Exception while sending request, handler likely already notified due to timeout", e);, +++ b/core/src/test/java/org/elasticsearch/client/transport/FailAndRetryMockTransport.java, +import org.elasticsearch.action.admin.cluster.node.liveness.TransportLivenessAction;, +import org.elasticsearch.action.admin.cluster.state.ClusterStateAction;, +import org.elasticsearch.action.admin.cluster.state.ClusterStateResponse;, +import org.elasticsearch.cluster.ClusterState;, +import org.elasticsearch.cluster.node.DiscoveryNodes;, +    protected abstract ClusterState getMockClusterState(DiscoveryNode node);, +, +            if (TransportLivenessAction.NAME.equals(action)) {, +            } else if (ClusterStateAction.NAME.equals(action)) {, +                TransportResponseHandler transportResponseHandler = transportServiceAdapter.onResponseReceived(requestId);, +                ClusterState clusterState = getMockClusterState(node);, +                transportResponseHandler.handleResponse(new ClusterStateResponse(clusterName, clusterState));, +            } else {, +                throw new UnsupportedOperationException("Mock transport does not understand action " + action);]