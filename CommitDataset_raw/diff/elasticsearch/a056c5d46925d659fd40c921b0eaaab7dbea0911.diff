[+++ b/core/src/main/java/org/elasticsearch/search/aggregations/metrics/tophits/TopHitsAggregator.java, +import com.carrotsearch.hppc.LongObjectHashMap;, +    private final FetchPhase fetchPhase;, +    private final SubSearchContext subSearchContext;, +    private final LongObjectPagedHashMap<TopDocsCollector<?>> topDocsCollectors;, +    TopHitsAggregator(FetchPhase fetchPhase, SubSearchContext subSearchContext, String name, SearchContext context,, +    public LeafBucketCollector getLeafCollector(LeafReaderContext ctx, LeafBucketCollector sub) throws IOException {, +        // Create leaf collectors here instead of at the aggregator level. Otherwise in case this collector get invoked, +        // when post collecting then we have already replaced the leaf readers on the aggregator level have already been, +        // replaced with the next leaf readers and then post collection pushes docids of the previous segement, which, +        // then causes assertions to trip or incorrect top docs to be computed., +        final LongObjectHashMap<LeafCollector> leafCollectors = new LongObjectHashMap<>(1);, +                TopDocsCollector<?> topDocsCollector = topDocsCollectors.get(bucket);, +                if (topDocsCollector == null) {, +                        topDocsCollector = TopScoreDocCollector.create(topN);, +                        topDocsCollector = TopFieldCollector.create(sort.sort, topN, true, subSearchContext.trackScores(),, +                    topDocsCollectors.put(bucket, topDocsCollector);, +, +                final LeafCollector leafCollector;, +                final int key = leafCollectors.indexOf(bucket);, +                if (key < 0) {, +                    leafCollector = topDocsCollector.getLeafCollector(ctx);, +                    if (scorer != null) {, +                        leafCollector.setScorer(scorer);, +                    }, +                    leafCollectors.indexInsert(key, bucket, leafCollector);, +                } else {, +                    leafCollector = leafCollectors.indexGet(key);, +                }, +                leafCollector.collect(docId);, +        TopDocsCollector<?> topDocsCollector = topDocsCollectors.get(owningBucketOrdinal);, +            TopDocs topDocs = topDocsCollector.topDocs();, +++ b/core/src/main/java/org/elasticsearch/search/aggregations/metrics/tophits/TopHitsAggregator.java, +import com.carrotsearch.hppc.LongObjectHashMap;, +    private final FetchPhase fetchPhase;, +    private final SubSearchContext subSearchContext;, +    private final LongObjectPagedHashMap<TopDocsCollector<?>> topDocsCollectors;, +    TopHitsAggregator(FetchPhase fetchPhase, SubSearchContext subSearchContext, String name, SearchContext context,, +    public LeafBucketCollector getLeafCollector(LeafReaderContext ctx, LeafBucketCollector sub) throws IOException {, +        // Create leaf collectors here instead of at the aggregator level. Otherwise in case this collector get invoked, +        // when post collecting then we have already replaced the leaf readers on the aggregator level have already been, +        // replaced with the next leaf readers and then post collection pushes docids of the previous segement, which, +        // then causes assertions to trip or incorrect top docs to be computed., +        final LongObjectHashMap<LeafCollector> leafCollectors = new LongObjectHashMap<>(1);, +                TopDocsCollector<?> topDocsCollector = topDocsCollectors.get(bucket);, +                if (topDocsCollector == null) {, +                        topDocsCollector = TopScoreDocCollector.create(topN);, +                        topDocsCollector = TopFieldCollector.create(sort.sort, topN, true, subSearchContext.trackScores(),, +                    topDocsCollectors.put(bucket, topDocsCollector);, +, +                final LeafCollector leafCollector;, +                final int key = leafCollectors.indexOf(bucket);, +                if (key < 0) {, +                    leafCollector = topDocsCollector.getLeafCollector(ctx);, +                    if (scorer != null) {, +                        leafCollector.setScorer(scorer);, +                    }, +                    leafCollectors.indexInsert(key, bucket, leafCollector);, +                } else {, +                    leafCollector = leafCollectors.indexGet(key);, +                }, +                leafCollector.collect(docId);, +        TopDocsCollector<?> topDocsCollector = topDocsCollectors.get(owningBucketOrdinal);, +            TopDocs topDocs = topDocsCollector.topDocs();, +++ b/core/src/main/java/org/elasticsearch/search/aggregations/metrics/tophits/TopHitsAggregatorFactory.java, +    TopHitsAggregatorFactory(String name, int from, int size, boolean explain, boolean version, boolean trackScores,, +++ b/core/src/main/java/org/elasticsearch/search/aggregations/metrics/tophits/TopHitsAggregator.java, +import com.carrotsearch.hppc.LongObjectHashMap;, +    private final FetchPhase fetchPhase;, +    private final SubSearchContext subSearchContext;, +    private final LongObjectPagedHashMap<TopDocsCollector<?>> topDocsCollectors;, +    TopHitsAggregator(FetchPhase fetchPhase, SubSearchContext subSearchContext, String name, SearchContext context,, +    public LeafBucketCollector getLeafCollector(LeafReaderContext ctx, LeafBucketCollector sub) throws IOException {, +        // Create leaf collectors here instead of at the aggregator level. Otherwise in case this collector get invoked, +        // when post collecting then we have already replaced the leaf readers on the aggregator level have already been, +        // replaced with the next leaf readers and then post collection pushes docids of the previous segement, which, +        // then causes assertions to trip or incorrect top docs to be computed., +        final LongObjectHashMap<LeafCollector> leafCollectors = new LongObjectHashMap<>(1);, +                TopDocsCollector<?> topDocsCollector = topDocsCollectors.get(bucket);, +                if (topDocsCollector == null) {, +                        topDocsCollector = TopScoreDocCollector.create(topN);, +                        topDocsCollector = TopFieldCollector.create(sort.sort, topN, true, subSearchContext.trackScores(),, +                    topDocsCollectors.put(bucket, topDocsCollector);, +, +                final LeafCollector leafCollector;, +                final int key = leafCollectors.indexOf(bucket);, +                if (key < 0) {, +                    leafCollector = topDocsCollector.getLeafCollector(ctx);, +                    if (scorer != null) {, +                        leafCollector.setScorer(scorer);, +                    }, +                    leafCollectors.indexInsert(key, bucket, leafCollector);, +                } else {, +                    leafCollector = leafCollectors.indexGet(key);, +                }, +                leafCollector.collect(docId);, +        TopDocsCollector<?> topDocsCollector = topDocsCollectors.get(owningBucketOrdinal);, +            TopDocs topDocs = topDocsCollector.topDocs();, +++ b/core/src/main/java/org/elasticsearch/search/aggregations/metrics/tophits/TopHitsAggregatorFactory.java, +    TopHitsAggregatorFactory(String name, int from, int size, boolean explain, boolean version, boolean trackScores,]