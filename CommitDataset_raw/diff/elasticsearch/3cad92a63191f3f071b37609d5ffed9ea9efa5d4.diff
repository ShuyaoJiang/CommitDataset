[+++ b/core/src/main/java/org/elasticsearch/cluster/service/ClusterService.java, +    /** asserts that the current thread is <b>NOT</b> the cluster state update thread */, +    public static boolean assertNotClusterStateUpdateThread(String reason) {, +        assert Thread.currentThread().getName().contains(UPDATE_THREAD_NAME) == false :, +            "Expected current thread [" + Thread.currentThread() + "] to not be the cluster state update thread. Reason: [" + reason + "]";, +        return true;, +    }, +, +++ b/core/src/main/java/org/elasticsearch/cluster/service/ClusterService.java, +    /** asserts that the current thread is <b>NOT</b> the cluster state update thread */, +    public static boolean assertNotClusterStateUpdateThread(String reason) {, +        assert Thread.currentThread().getName().contains(UPDATE_THREAD_NAME) == false :, +            "Expected current thread [" + Thread.currentThread() + "] to not be the cluster state update thread. Reason: [" + reason + "]";, +        return true;, +    }, +, +++ b/core/src/main/java/org/elasticsearch/common/util/concurrent/BaseFuture.java, +import org.elasticsearch.cluster.service.ClusterService;, +            (Transports.assertNotTransportThread(BLOCKING_OP_REASON) &&, +                ThreadPool.assertNotScheduleThread(BLOCKING_OP_REASON) &&, +                ClusterService.assertNotClusterStateUpdateThread(BLOCKING_OP_REASON));, +        assert Transports.assertNotTransportThread(BLOCKING_OP_REASON) &&, +            ThreadPool.assertNotScheduleThread(BLOCKING_OP_REASON) &&, +            ClusterService.assertNotClusterStateUpdateThread(BLOCKING_OP_REASON);, +++ b/core/src/main/java/org/elasticsearch/cluster/service/ClusterService.java, +    /** asserts that the current thread is <b>NOT</b> the cluster state update thread */, +    public static boolean assertNotClusterStateUpdateThread(String reason) {, +        assert Thread.currentThread().getName().contains(UPDATE_THREAD_NAME) == false :, +            "Expected current thread [" + Thread.currentThread() + "] to not be the cluster state update thread. Reason: [" + reason + "]";, +        return true;, +    }, +, +++ b/core/src/main/java/org/elasticsearch/common/util/concurrent/BaseFuture.java, +import org.elasticsearch.cluster.service.ClusterService;, +            (Transports.assertNotTransportThread(BLOCKING_OP_REASON) &&, +                ThreadPool.assertNotScheduleThread(BLOCKING_OP_REASON) &&, +                ClusterService.assertNotClusterStateUpdateThread(BLOCKING_OP_REASON));, +        assert Transports.assertNotTransportThread(BLOCKING_OP_REASON) &&, +            ThreadPool.assertNotScheduleThread(BLOCKING_OP_REASON) &&, +            ClusterService.assertNotClusterStateUpdateThread(BLOCKING_OP_REASON);, +++ b/core/src/test/java/org/elasticsearch/cluster/service/ClusterServiceTests.java, +import org.elasticsearch.common.util.concurrent.BaseFuture;, +import java.util.concurrent.TimeUnit;, +import java.util.concurrent.atomic.AtomicReference;, +    public void testBlockingCallInClusterStateTaskListenerFails() throws InterruptedException {, +        assumeTrue("assertions must be enabled for this test to work", BaseFuture.class.desiredAssertionStatus());, +        final CountDownLatch latch = new CountDownLatch(1);, +        final AtomicReference<AssertionError> assertionRef = new AtomicReference<>();, +, +        clusterService.submitStateUpdateTask(, +            "testBlockingCallInClusterStateTaskListenerFails",, +            new Object(),, +            ClusterStateTaskConfig.build(Priority.NORMAL),, +            new ClusterStateTaskExecutor<Object>() {, +                @Override, +                public boolean runOnlyOnMaster() {, +                    return false;, +                }, +, +                @Override, +                public BatchResult<Object> execute(ClusterState currentState, List<Object> tasks) throws Exception {, +                    ClusterState newClusterState = ClusterState.builder(currentState).build();, +                    return BatchResult.builder().successes(tasks).build(newClusterState);, +                }, +, +                @Override, +                public void clusterStatePublished(ClusterChangedEvent clusterChangedEvent) {, +                    assertNotNull(assertionRef.get());, +                }, +            },, +            new ClusterStateTaskListener() {, +                @Override, +                public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {, +                    BaseFuture<Void> future = new BaseFuture<Void>() {};, +                    try {, +                        if (randomBoolean()) {, +                            future.get(1L, TimeUnit.SECONDS);, +                        } else {, +                            future.get();, +                        }, +                    } catch (Exception e) {, +                        throw new RuntimeException(e);, +                    } catch (AssertionError e) {, +                        assertionRef.set(e);, +                        latch.countDown();, +                    }, +                }, +, +                @Override, +                public void onFailure(String source, Exception e) {, +                }, +            }, +        );, +, +        latch.await();, +        assertNotNull(assertionRef.get());, +        assertThat(assertionRef.get().getMessage(), containsString("not be the cluster state update thread. Reason: [Blocking operation]"));, +    }, +]