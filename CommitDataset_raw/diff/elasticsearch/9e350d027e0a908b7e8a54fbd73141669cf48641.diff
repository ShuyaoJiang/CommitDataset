[+++ b/modules/ingest-common/src/main/java/org/elasticsearch/ingest/common/DateFormat.java, +import org.elasticsearch.common.joda.Joda;, +import org.elasticsearch.common.time.DateFormatter;, +import org.elasticsearch.common.time.DateFormatters;, +import org.elasticsearch.common.time.DateUtils;, +import java.time.Instant;, +import java.time.LocalDate;, +import java.time.ZoneOffset;, +import java.time.ZonedDateTime;, +import java.time.temporal.TemporalAccessor;, +    Java {, +            // in case you are wondering why we do not call 'DateFormatter.forPattern(format)' for all cases here, but only for the, +            // non java time case:, +            // When the joda date formatter parses a date then a year is always set, so that no fallback can be used, like, +            // done in the JodaDateFormatter.withYear() code below, +            // This means that we leave the existing parsing logic in place, but will fall back to the new java date parsing logic, if an, +            // "8" is prepended to the date format string, +            int year = LocalDate.now(ZoneOffset.UTC).getYear();, +            if (format.startsWith("8")) {, +                DateFormatter formatter = DateFormatter.forPattern(format), +                    .withLocale(locale), +                    .withZone(DateUtils.dateTimeZoneToZoneId(timezone));, +                return text -> {, +                    ZonedDateTime defaultZonedDateTime = Instant.EPOCH.atZone(ZoneOffset.UTC).withYear(year);, +                    TemporalAccessor accessor = formatter.parse(text);, +                    long millis = DateFormatters.toZonedDateTime(accessor, defaultZonedDateTime).toInstant().toEpochMilli();, +                    return new DateTime(millis, timezone);, +                };, +            } else {, +                DateFormatter formatter = Joda.forPattern(format), +                    .withYear(year), +                    .withZone(DateUtils.dateTimeZoneToZoneId(timezone)), +                    .withLocale(locale);, +                return text -> new DateTime(formatter.parseMillis(text), timezone);, +            }, +                return Java;, +++ b/modules/ingest-common/src/main/java/org/elasticsearch/ingest/common/DateFormat.java, +import org.elasticsearch.common.joda.Joda;, +import org.elasticsearch.common.time.DateFormatter;, +import org.elasticsearch.common.time.DateFormatters;, +import org.elasticsearch.common.time.DateUtils;, +import java.time.Instant;, +import java.time.LocalDate;, +import java.time.ZoneOffset;, +import java.time.ZonedDateTime;, +import java.time.temporal.TemporalAccessor;, +    Java {, +            // in case you are wondering why we do not call 'DateFormatter.forPattern(format)' for all cases here, but only for the, +            // non java time case:, +            // When the joda date formatter parses a date then a year is always set, so that no fallback can be used, like, +            // done in the JodaDateFormatter.withYear() code below, +            // This means that we leave the existing parsing logic in place, but will fall back to the new java date parsing logic, if an, +            // "8" is prepended to the date format string, +            int year = LocalDate.now(ZoneOffset.UTC).getYear();, +            if (format.startsWith("8")) {, +                DateFormatter formatter = DateFormatter.forPattern(format), +                    .withLocale(locale), +                    .withZone(DateUtils.dateTimeZoneToZoneId(timezone));, +                return text -> {, +                    ZonedDateTime defaultZonedDateTime = Instant.EPOCH.atZone(ZoneOffset.UTC).withYear(year);, +                    TemporalAccessor accessor = formatter.parse(text);, +                    long millis = DateFormatters.toZonedDateTime(accessor, defaultZonedDateTime).toInstant().toEpochMilli();, +                    return new DateTime(millis, timezone);, +                };, +            } else {, +                DateFormatter formatter = Joda.forPattern(format), +                    .withYear(year), +                    .withZone(DateUtils.dateTimeZoneToZoneId(timezone)), +                    .withLocale(locale);, +                return text -> new DateTime(formatter.parseMillis(text), timezone);, +            }, +                return Java;, +++ b/modules/ingest-common/src/test/java/org/elasticsearch/ingest/common/DateFormatTests.java, +        Function<String, DateTime> jodaFunction = DateFormat.Java.getFunction("MMM dd HH:mm:ss Z",, +        assertThat(DateFormat.fromString("unix_ms"), equalTo(DateFormat.Java));, +        assertThat(DateFormat.fromString("unix"), equalTo(DateFormat.Java));, +        assertThat(DateFormat.fromString("iso8601"), equalTo(DateFormat.Java));, +        assertThat(DateFormat.fromString("tai64n"), equalTo(DateFormat.Java));, +        assertThat(DateFormat.fromString("prefix-" + randomAlphaOfLengthBetween(1, 10)), equalTo(DateFormat.Java));, +++ b/modules/ingest-common/src/main/java/org/elasticsearch/ingest/common/DateFormat.java, +import org.elasticsearch.common.joda.Joda;, +import org.elasticsearch.common.time.DateFormatter;, +import org.elasticsearch.common.time.DateFormatters;, +import org.elasticsearch.common.time.DateUtils;, +import java.time.Instant;, +import java.time.LocalDate;, +import java.time.ZoneOffset;, +import java.time.ZonedDateTime;, +import java.time.temporal.TemporalAccessor;, +    Java {, +            // in case you are wondering why we do not call 'DateFormatter.forPattern(format)' for all cases here, but only for the, +            // non java time case:, +            // When the joda date formatter parses a date then a year is always set, so that no fallback can be used, like, +            // done in the JodaDateFormatter.withYear() code below, +            // This means that we leave the existing parsing logic in place, but will fall back to the new java date parsing logic, if an, +            // "8" is prepended to the date format string, +            int year = LocalDate.now(ZoneOffset.UTC).getYear();, +            if (format.startsWith("8")) {, +                DateFormatter formatter = DateFormatter.forPattern(format), +                    .withLocale(locale)]