[+++ b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ml/datafeed/DatafeedConfig.java, +import org.elasticsearch.common.util.CachedSupplier;, +import org.elasticsearch.common.xcontent.XContentParseException;, +import org.elasticsearch.xpack.core.ml.utils.XContentObjectTransformer;, +import java.util.function.BiFunction;, +    static final XContentObjectTransformer<QueryBuilder> QUERY_TRANSFORMER = XContentObjectTransformer.queryBuilderTransformer();, +    private static final BiFunction<Map<String, Object>, String, QueryBuilder> lazyQueryParser = (objectMap, id) -> {, +        try {, +            return QUERY_TRANSFORMER.fromMap(objectMap);, +        } catch (IOException | XContentParseException exception) {, +            // Certain thrown exceptions wrap up the real Illegal argument making it hard to determine cause for the user, +            if (exception.getCause() instanceof IllegalArgumentException) {, +                throw ExceptionsHelper.badRequestException(, +                    Messages.getMessage(Messages.DATAFEED_CONFIG_QUERY_BAD_FORMAT,, +                        id,, +                        exception.getCause().getMessage()),, +                    exception.getCause());, +            } else {, +                throw ExceptionsHelper.badRequestException(, +                    Messages.getMessage(Messages.DATAFEED_CONFIG_QUERY_BAD_FORMAT, exception, id),, +                    exception);, +            }, +        }, +    };, +, +    static final XContentObjectTransformer<AggregatorFactories.Builder> AGG_TRANSFORMER = XContentObjectTransformer.aggregatorTransformer();, +    private static final BiFunction<Map<String, Object>, String, AggregatorFactories.Builder> lazyAggParser = (objectMap, id) -> {, +        try {, +            return AGG_TRANSFORMER.fromMap(objectMap);, +        } catch (IOException | XContentParseException exception) {, +            // Certain thrown exceptions wrap up the real Illegal argument making it hard to determine cause for the user, +            if (exception.getCause() instanceof IllegalArgumentException) {, +                throw ExceptionsHelper.badRequestException(, +                    Messages.getMessage(Messages.DATAFEED_CONFIG_AGG_BAD_FORMAT,, +                        id,, +                        exception.getCause().getMessage()),, +                    exception.getCause());, +            } else {, +                throw ExceptionsHelper.badRequestException(, +                    Messages.getMessage(Messages.DATAFEED_CONFIG_AGG_BAD_FORMAT, exception.getMessage(), id),, +                    exception);, +            }, +        }, +    };, +    public static void validateAggregations(AggregatorFactories.Builder aggregations) {, +        if (aggregations == null) {, +            return;, +        }, +        Collection<AggregationBuilder> aggregatorFactories = aggregations.getAggregatorFactories();, +        if (aggregatorFactories.isEmpty()) {, +            throw ExceptionsHelper.badRequestException(Messages.DATAFEED_AGGREGATIONS_REQUIRES_DATE_HISTOGRAM);, +        }, +, +        AggregationBuilder histogramAggregation = ExtractorUtils.getHistogramAggregation(aggregatorFactories);, +        Builder.checkNoMoreHistogramAggregations(histogramAggregation.getSubAggregations());, +        Builder.checkHistogramAggregationHasChildMaxTimeAgg(histogramAggregation);, +        Builder.checkHistogramIntervalIsPositive(histogramAggregation);, +    }, +, +        if (ignoreUnknownFields) {, +            parser.declareObject(Builder::setQuery, (p, c) -> p.map(), QUERY);, +            parser.declareObject(Builder::setAggregations, (p, c) -> p.map(), AGGREGATIONS);, +            parser.declareObject(Builder::setAggregations, (p, c) -> p.map(), AGGS);, +        } else {, +            parser.declareObject(Builder::setParsedQuery, (p, c) -> AbstractQueryBuilder.parseInnerQueryBuilder(p), QUERY);, +            parser.declareObject(Builder::setParsedAggregations, (p, c) -> AggregatorFactories.parseAggregators(p), AGGREGATIONS);, +            parser.declareObject(Builder::setParsedAggregations, (p, c) -> AggregatorFactories.parseAggregators(p), AGGS);, +        }, +    private final Map<String, Object> query;, +    private final Map<String, Object> aggregations;, +    private final CachedSupplier<QueryBuilder> querySupplier;, +    private final CachedSupplier<AggregatorFactories.Builder> aggSupplier;, +                           Map<String, Object> query, Map<String, Object> aggregations, List<SearchSourceBuilder.ScriptField> scriptFields,, +        this.querySupplier = new CachedSupplier<>(() -> lazyQueryParser.apply(query, id));, +        this.aggSupplier = new CachedSupplier<>(() -> lazyAggParser.apply(aggregations, id));, +        if (in.getVersion().before(Version.CURRENT)) {, +            this.query = QUERY_TRANSFORMER.toMap(in.readNamedWriteable(QueryBuilder.class));, +            this.aggregations = AGG_TRANSFORMER.toMap(in.readOptionalWriteable(AggregatorFactories.Builder::new));, +        } else {, +            this.query = in.readMap();, +            if (in.readBoolean()) {, +                this.aggregations = in.readMap();, +            } else {, +                this.aggregations = null;, +            }, +        }, +        this.querySupplier = new CachedSupplier<>(() -> lazyQueryParser.apply(query, id));, +        this.aggSupplier = new CachedSupplier<>(() -> lazyAggParser.apply(aggregations, id));, +    public QueryBuilder getParsedQuery() {, +        return querySupplier.get();, +    }, +, +    public Map<String, Object> getQuery() {, +    public AggregatorFactories.Builder getParsedAggregations() {, +        return aggSupplier.get();, +    }, +, +    public Map<String, Object> getAggregations() {, +        return ExtractorUtils.getHistogramIntervalMillis(getParsedAggregations());, +        return aggregations != null && aggregations.size() > 0;]