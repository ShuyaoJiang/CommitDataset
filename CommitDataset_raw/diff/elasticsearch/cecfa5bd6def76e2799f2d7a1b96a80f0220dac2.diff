[+++ b/x-pack/plugin/ccr/src/main/java/org/elasticsearch/xpack/ccr/action/CcrRequests.java, +import org.elasticsearch.action.ActionListener;, +import org.elasticsearch.client.Client;, +import org.elasticsearch.cluster.metadata.MetaData;, +import org.elasticsearch.common.unit.TimeValue;, +import java.util.function.Supplier;, +    /**, +     * Gets an {@link IndexMetaData} of the given index. The mapping version and metadata version of the returned {@link IndexMetaData}, +     * must be at least the provided {@code mappingVersion} and {@code metadataVersion} respectively., +     */, +    public static void getIndexMetadata(Client client, Index index, long mappingVersion, long metadataVersion,, +                                        Supplier<TimeValue> timeoutSupplier, ActionListener<IndexMetaData> listener) {, +        final ClusterStateRequest request = CcrRequests.metaDataRequest(index.getName());, +        if (metadataVersion > 0) {, +            request.waitForMetaDataVersion(metadataVersion).waitForTimeout(timeoutSupplier.get());, +        }, +        client.admin().cluster().state(request, ActionListener.wrap(, +            response -> {, +                if (response.getState() == null) {, +                    assert metadataVersion > 0 : metadataVersion;, +                    throw new IllegalStateException("timeout to get cluster state with" +, +                        " metadata version [" + metadataVersion + "], mapping version [" + mappingVersion + "]");, +                }, +                final MetaData metaData = response.getState().metaData();, +                final IndexMetaData indexMetaData = metaData.getIndexSafe(index);, +                if (indexMetaData.getMappingVersion() >= mappingVersion) {, +                    listener.onResponse(indexMetaData);, +                    return;, +                }, +                if (timeoutSupplier.get().nanos() < 0) {, +                    throw new IllegalStateException("timeout to get cluster state with mapping version [" + mappingVersion + "]");, +                }, +                // ask for the next version., +                getIndexMetadata(client, index, mappingVersion, metaData.version() + 1, timeoutSupplier, listener);, +            },, +            listener::onFailure, +        ));, +    }, +, +++ b/x-pack/plugin/ccr/src/main/java/org/elasticsearch/xpack/ccr/action/CcrRequests.java, +import org.elasticsearch.action.ActionListener;, +import org.elasticsearch.client.Client;, +import org.elasticsearch.cluster.metadata.MetaData;, +import org.elasticsearch.common.unit.TimeValue;, +import java.util.function.Supplier;, +    /**, +     * Gets an {@link IndexMetaData} of the given index. The mapping version and metadata version of the returned {@link IndexMetaData}, +     * must be at least the provided {@code mappingVersion} and {@code metadataVersion} respectively., +     */, +    public static void getIndexMetadata(Client client, Index index, long mappingVersion, long metadataVersion,, +                                        Supplier<TimeValue> timeoutSupplier, ActionListener<IndexMetaData> listener) {, +        final ClusterStateRequest request = CcrRequests.metaDataRequest(index.getName());, +        if (metadataVersion > 0) {, +            request.waitForMetaDataVersion(metadataVersion).waitForTimeout(timeoutSupplier.get());, +        }, +        client.admin().cluster().state(request, ActionListener.wrap(, +            response -> {, +                if (response.getState() == null) {, +                    assert metadataVersion > 0 : metadataVersion;, +                    throw new IllegalStateException("timeout to get cluster state with" +, +                        " metadata version [" + metadataVersion + "], mapping version [" + mappingVersion + "]");, +                }, +                final MetaData metaData = response.getState().metaData();, +                final IndexMetaData indexMetaData = metaData.getIndexSafe(index);, +                if (indexMetaData.getMappingVersion() >= mappingVersion) {, +                    listener.onResponse(indexMetaData);, +                    return;, +                }, +                if (timeoutSupplier.get().nanos() < 0) {, +                    throw new IllegalStateException("timeout to get cluster state with mapping version [" + mappingVersion + "]");, +                }, +                // ask for the next version., +                getIndexMetadata(client, index, mappingVersion, metaData.version() + 1, timeoutSupplier, listener);, +            },, +            listener::onFailure, +        ));, +    }, +, +++ b/x-pack/plugin/ccr/src/main/java/org/elasticsearch/xpack/ccr/action/ShardFollowTasksExecutor.java, +import java.util.function.Supplier;, +                final Index leaderIndex = params.getLeaderShardId().getIndex();, +                final Supplier<TimeValue> timeout = () -> isStopped() ? TimeValue.MINUS_ONE : waitForMetadataTimeOut;, +                CcrRequests.getIndexMetadata(remoteClient(params), leaderIndex, minRequiredMappingVersion, 0L, timeout, ActionListener.wrap(, +++ b/x-pack/plugin/ccr/src/main/java/org/elasticsearch/xpack/ccr/action/CcrRequests.java, +import org.elasticsearch.action.ActionListener;, +import org.elasticsearch.client.Client;, +import org.elasticsearch.cluster.metadata.MetaData;, +import org.elasticsearch.common.unit.TimeValue;, +import java.util.function.Supplier;, +    /**, +     * Gets an {@link IndexMetaData} of the given index. The mapping version and metadata version of the returned {@link IndexMetaData}, +     * must be at least the provided {@code mappingVersion} and {@code metadataVersion} respectively., +     */, +    public static void getIndexMetadata(Client client, Index index, long mappingVersion, long metadataVersion,, +                                        Supplier<TimeValue> timeoutSupplier, ActionListener<IndexMetaData> listener) {, +        final ClusterStateRequest request = CcrRequests.metaDataRequest(index.getName());, +        if (metadataVersion > 0) {, +            request.waitForMetaDataVersion(metadataVersion).waitForTimeout(timeoutSupplier.get());, +        }, +        client.admin().cluster().state(request, ActionListener.wrap(]