[+++ b/modules/lang-painless/src/main/antlr/PainlessParser.g4, +    : TYPE REF ID, +++ b/modules/lang-painless/src/main/antlr/PainlessParser.g4, +    : TYPE REF ID, +++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/AStatement.java, +    abstract void analyze(Variables variables);, +++ b/modules/lang-painless/src/main/antlr/PainlessParser.g4, +    : TYPE REF ID, +++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/AStatement.java, +    abstract void analyze(Variables variables);, +++ /dev/null, +++ b/modules/lang-painless/src/main/antlr/PainlessParser.g4, +    : TYPE REF ID, +++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/AStatement.java, +    abstract void analyze(Variables variables);, +++ /dev/null, +++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/SBlock.java, +import java.util.Collections;, +        this.statements = Collections.unmodifiableList(statements);, +    void analyze(Variables variables) {, +        AStatement last = statements.get(statements.size() - 1);, +, +        for (AStatement statement : statements) {, +            // Note that we do not need to check after the last statement because, +            // there is no statement that can be unreachable after the last., +            statement.lastSource = lastSource && statement == last;, +            statement.lastLoop = (beginLoop || lastLoop) && statement == last;, +            statement.analyze(variables);, +++ b/modules/lang-painless/src/main/antlr/PainlessParser.g4, +    : TYPE REF ID, +++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/AStatement.java, +    abstract void analyze(Variables variables);, +++ /dev/null, +++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/SBlock.java, +import java.util.Collections;, +        this.statements = Collections.unmodifiableList(statements);, +    void analyze(Variables variables) {, +        AStatement last = statements.get(statements.size() - 1);, +, +        for (AStatement statement : statements) {, +            // Note that we do not need to check after the last statement because, +            // there is no statement that can be unreachable after the last., +            statement.lastSource = lastSource && statement == last;, +            statement.lastLoop = (beginLoop || lastLoop) && statement == last;, +            statement.analyze(variables);, +++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/SBreak.java, +    void analyze(Variables variables) {, +++ b/modules/lang-painless/src/main/antlr/PainlessParser.g4, +    : TYPE REF ID, +++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/AStatement.java, +    abstract void analyze(Variables variables);, +++ /dev/null, +++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/SBlock.java, +import java.util.Collections;, +        this.statements = Collections.unmodifiableList(statements);, +    void analyze(Variables variables) {, +        AStatement last = statements.get(statements.size() - 1);, +, +        for (AStatement statement : statements) {, +            // Note that we do not need to check after the last statement because, +            // there is no statement that can be unreachable after the last., +            statement.lastSource = lastSource && statement == last;, +            statement.lastLoop = (beginLoop || lastLoop) && statement == last;, +            statement.analyze(variables);, +++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/SBreak.java, +    void analyze(Variables variables) {, +++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/SCatch.java, +    final SBlock block;, +    void analyze(Variables variables) {, +            block.analyze(variables);, +++ b/modules/lang-painless/src/main/antlr/PainlessParser.g4, +    : TYPE REF ID, +++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/AStatement.java, +    abstract void analyze(Variables variables);, +++ /dev/null, +++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/SBlock.java, +import java.util.Collections;, +        this.statements = Collections.unmodifiableList(statements);, +    void analyze(Variables variables) {, +        AStatement last = statements.get(statements.size() - 1);, +, +        for (AStatement statement : statements) {, +            // Note that we do not need to check after the last statement because, +            // there is no statement that can be unreachable after the last., +            statement.lastSource = lastSource && statement == last;, +            statement.lastLoop = (beginLoop || lastLoop) && statement == last;, +            statement.analyze(variables);, +++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/SBreak.java, +    void analyze(Variables variables) {, +++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/SCatch.java, +    final SBlock block;, +    void analyze(Variables variables) {, +            block.analyze(variables);, +++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/SContinue.java, +    void analyze(Variables variables) {, +++ b/modules/lang-painless/src/main/antlr/PainlessParser.g4, +    : TYPE REF ID, +++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/AStatement.java, +    abstract void analyze(Variables variables);, +++ /dev/null]