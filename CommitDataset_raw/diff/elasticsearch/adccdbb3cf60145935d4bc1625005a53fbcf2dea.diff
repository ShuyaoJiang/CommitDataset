[+++ b/core/src/main/java/org/elasticsearch/action/search/FetchSearchPhase.java, +        ScoreDoc[] sortedShardDocs = searchPhaseController.sortDocs(isScrollSearch, phaseResults);, +++ b/core/src/main/java/org/elasticsearch/action/search/FetchSearchPhase.java, +        ScoreDoc[] sortedShardDocs = searchPhaseController.sortDocs(isScrollSearch, phaseResults);, +++ b/core/src/main/java/org/elasticsearch/action/search/SearchPhaseController.java, +     * @param results the search phase results to obtain the sort docs from, +    public ScoreDoc[] sortDocs(boolean ignoreFrom, Collection<? extends SearchPhaseResult> results) throws IOException {, +        final Collection<TopDocs> topDocs = new ArrayList<>();, +        int from = -1;, +        int size = -1;, +            /* We loop over all results once, group together the completion suggestions if there are any and collect relevant, +             * top docs results. Each top docs gets it's shard index set on all top docs to simplify top docs merging down the road, +             * this allowed to remove a single shared optimization code here since now we don't materialized a dense array of, +             * top docs anymore but instead only pass relevant results / top docs to the merge method*/, +            QuerySearchResult queryResult = sortedResult.queryResult();, +            if (queryResult.hasHits()) {, +                from = queryResult.from();, +                size = queryResult.size();, +                TopDocs td = queryResult.topDocs();, +                if (td != null && td.scoreDocs.length > 0) {, +                    setShardIndex(td, queryResult.getShardIndex());, +                    topDocs.add(td);, +                }, +                Suggest shardSuggest = queryResult.suggest();, +        }, +        if (size != -1) {, +            final ScoreDoc[] mergedScoreDocs = mergeTopDocs(topDocs, size, ignoreFrom ? 0 : from);, +            ScoreDoc[] scoreDocs = mergedScoreDocs;, +                scoreDocs = new ScoreDoc[mergedScoreDocs.length + numSuggestDocs];, +                System.arraycopy(mergedScoreDocs, 0, scoreDocs, 0, mergedScoreDocs.length);, +                int offset = mergedScoreDocs.length;, +        } else {, +            // no relevant docs - just return an empty array, +            return EMPTY_DOCS;, +        }, +    private ScoreDoc[] mergeTopDocs(Collection<TopDocs> results, int topN, int from) {, +        if (results.isEmpty()) {, +            return EMPTY_DOCS;, +        final boolean setShardIndex = false;, +        final TopDocs topDocs = results.stream().findFirst().get();, +        final TopDocs mergedTopDocs;, +        final int numShards = results.size();, +        if (numShards == 1 && from == 0) { // only one shard and no pagination we can just return the topDocs as we got them., +            return topDocs.scoreDocs;, +        } else if (topDocs instanceof CollapseTopFieldDocs) {, +            CollapseTopFieldDocs firstTopDocs = (CollapseTopFieldDocs) topDocs;, +            final Sort sort = new Sort(firstTopDocs.fields);, +            final CollapseTopFieldDocs[] shardTopDocs = results.toArray(new CollapseTopFieldDocs[numShards]);, +            mergedTopDocs = CollapseTopFieldDocs.merge(sort, from, topN, shardTopDocs, setShardIndex);, +        } else if (topDocs instanceof TopFieldDocs) {, +            TopFieldDocs firstTopDocs = (TopFieldDocs) topDocs;, +            final Sort sort = new Sort(firstTopDocs.fields);, +            final TopFieldDocs[] shardTopDocs = results.toArray(new TopFieldDocs[numShards]);, +            mergedTopDocs = TopDocs.merge(sort, from, topN, shardTopDocs, setShardIndex);, +        } else {, +            final TopDocs[] shardTopDocs = results.toArray(new TopDocs[numShards]);, +            mergedTopDocs = TopDocs.merge(from, topN, shardTopDocs, setShardIndex);, +        }, +        return mergedTopDocs.scoreDocs;, +    }, +, +    private static void setShardIndex(TopDocs topDocs, int shardIndex) {, +        for (ScoreDoc doc : topDocs.scoreDocs) {, +            if (doc.shardIndex != -1) {, +                // once there is a single shard index initialized all others will be initialized too, +                // there are many asserts down in lucene land that this is actually true. we can shortcut it here., +                return;, +            }, +            doc.shardIndex = shardIndex;, +, +++ b/core/src/main/java/org/elasticsearch/action/search/FetchSearchPhase.java, +        ScoreDoc[] sortedShardDocs = searchPhaseController.sortDocs(isScrollSearch, phaseResults);, +++ b/core/src/main/java/org/elasticsearch/action/search/SearchPhaseController.java, +     * @param results the search phase results to obtain the sort docs from, +    public ScoreDoc[] sortDocs(boolean ignoreFrom, Collection<? extends SearchPhaseResult> results) throws IOException {, +        final Collection<TopDocs> topDocs = new ArrayList<>();, +        int from = -1;, +        int size = -1;, +            /* We loop over all results once, group together the completion suggestions if there are any and collect relevant, +             * top docs results. Each top docs gets it's shard index set on all top docs to simplify top docs merging down the road, +             * this allowed to remove a single shared optimization code here since now we don't materialized a dense array of, +             * top docs anymore but instead only pass relevant results / top docs to the merge method*/, +            QuerySearchResult queryResult = sortedResult.queryResult();, +            if (queryResult.hasHits()) {, +                from = queryResult.from();, +                size = queryResult.size();, +                TopDocs td = queryResult.topDocs();, +                if (td != null && td.scoreDocs.length > 0) {, +                    setShardIndex(td, queryResult.getShardIndex());, +                    topDocs.add(td);, +                }, +                Suggest shardSuggest = queryResult.suggest();, +        }, +        if (size != -1) {, +            final ScoreDoc[] mergedScoreDocs = mergeTopDocs(topDocs, size, ignoreFrom ? 0 : from);, +            ScoreDoc[] scoreDocs = mergedScoreDocs;, +                scoreDocs = new ScoreDoc[mergedScoreDocs.length + numSuggestDocs];, +                System.arraycopy(mergedScoreDocs, 0, scoreDocs, 0, mergedScoreDocs.length);, +                int offset = mergedScoreDocs.length;, +        } else {]