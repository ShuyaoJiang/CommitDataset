[+++ b/server/src/main/java/org/elasticsearch/index/engine/InternalEngine.java, +        refreshIfNeeded(source, toSeqNo);, +    /**, +     * Refresh this engine **internally** iff the requesting seq_no is greater than the last refreshed checkpoint., +     */, +    protected final void refreshIfNeeded(String source, long requestingSeqNo) {, +        if (lastRefreshedCheckpoint() < requestingSeqNo) {, +            refresh(source, SearcherScope.INTERNAL);, +        }, +    }, +, +++ b/server/src/main/java/org/elasticsearch/index/engine/InternalEngine.java, +        refreshIfNeeded(source, toSeqNo);, +    /**, +     * Refresh this engine **internally** iff the requesting seq_no is greater than the last refreshed checkpoint., +     */, +    protected final void refreshIfNeeded(String source, long requestingSeqNo) {, +        if (lastRefreshedCheckpoint() < requestingSeqNo) {, +            refresh(source, SearcherScope.INTERNAL);, +        }, +    }, +, +++ b/test/framework/src/main/java/org/elasticsearch/index/engine/EngineTestCase.java, +import org.elasticsearch.common.CheckedFunction;, +import org.elasticsearch.common.Strings;, +import org.elasticsearch.common.compress.CompressedXContent;, +import org.elasticsearch.common.xcontent.XContentBuilder;, +import org.elasticsearch.common.xcontent.XContentFactory;, +import org.elasticsearch.index.mapper.DocumentMapper;, +import org.elasticsearch.index.mapper.SourceToParse;, +    public static CheckedFunction<String, ParsedDocument, IOException> nestedParsedDocFactory() throws Exception {, +        final MapperService mapperService = createMapperService("type");, +        final String nestedMapping = Strings.toString(XContentFactory.jsonBuilder().startObject().startObject("type"), +            .startObject("properties").startObject("nested_field").field("type", "nested").endObject().endObject(), +            .endObject().endObject());, +        final DocumentMapper nestedMapper = mapperService.documentMapperParser().parse("type", new CompressedXContent(nestedMapping));, +        return docId -> {, +            final XContentBuilder source = XContentFactory.jsonBuilder().startObject().field("field", "value");, +            final int nestedValues = between(0, 3);, +            if (nestedValues > 0) {, +                XContentBuilder nestedField = source.startObject("nested_field");, +                for (int i = 0; i < nestedValues; i++) {, +                    nestedField.field("field-" + i, "value-" + i);, +                }, +                source.endObject();, +            }, +            source.endObject();, +            return nestedMapper.parse(SourceToParse.source("test", "type", docId, BytesReference.bytes(source), XContentType.JSON));, +        };, +    }, +, +++ b/server/src/main/java/org/elasticsearch/index/engine/InternalEngine.java, +        refreshIfNeeded(source, toSeqNo);, +    /**, +     * Refresh this engine **internally** iff the requesting seq_no is greater than the last refreshed checkpoint., +     */, +    protected final void refreshIfNeeded(String source, long requestingSeqNo) {, +        if (lastRefreshedCheckpoint() < requestingSeqNo) {, +            refresh(source, SearcherScope.INTERNAL);, +        }, +    }, +, +++ b/test/framework/src/main/java/org/elasticsearch/index/engine/EngineTestCase.java, +import org.elasticsearch.common.CheckedFunction;, +import org.elasticsearch.common.Strings;, +import org.elasticsearch.common.compress.CompressedXContent;, +import org.elasticsearch.common.xcontent.XContentBuilder;, +import org.elasticsearch.common.xcontent.XContentFactory;, +import org.elasticsearch.index.mapper.DocumentMapper;, +import org.elasticsearch.index.mapper.SourceToParse;, +    public static CheckedFunction<String, ParsedDocument, IOException> nestedParsedDocFactory() throws Exception {, +        final MapperService mapperService = createMapperService("type");, +        final String nestedMapping = Strings.toString(XContentFactory.jsonBuilder().startObject().startObject("type"), +            .startObject("properties").startObject("nested_field").field("type", "nested").endObject().endObject(), +            .endObject().endObject());, +        final DocumentMapper nestedMapper = mapperService.documentMapperParser().parse("type", new CompressedXContent(nestedMapping));, +        return docId -> {, +            final XContentBuilder source = XContentFactory.jsonBuilder().startObject().field("field", "value");, +            final int nestedValues = between(0, 3);, +            if (nestedValues > 0) {, +                XContentBuilder nestedField = source.startObject("nested_field");, +                for (int i = 0; i < nestedValues; i++) {, +                    nestedField.field("field-" + i, "value-" + i);, +                }, +                source.endObject();, +            }, +            source.endObject();, +            return nestedMapper.parse(SourceToParse.source("test", "type", docId, BytesReference.bytes(source), XContentType.JSON));, +        };, +    }, +, +++ b/x-pack/plugin/ccr/src/main/java/org/elasticsearch/xpack/ccr/action/bulk/TransportBulkShardOperationsAction.java, +    static Translog.Operation rewriteOperationWithPrimaryTerm(Translog.Operation operation, long primaryTerm) {, +        final Translog.Operation operationWithPrimaryTerm;, +        switch (operation.opType()) {, +            case INDEX:, +                final Translog.Index index = (Translog.Index) operation;, +                operationWithPrimaryTerm = new Translog.Index(, +                    index.type(),, +                    index.id(),]