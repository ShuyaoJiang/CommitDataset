[+++ b/core/src/main/java/org/elasticsearch/index/analysis/AnalysisService.java, +import org.elasticsearch.index.mapper.core.StringFieldMapper;, +            /*, +             * Lucene defaults positionOffsetGap to 0 in all analyzers but, +             * Elasticsearch defaults them to 0 only before version 2.1, +             * and 100 afterwards so we override the positionOffsetGap if it, +             * doesn't match here., +             */, +            int overridePositionOffsetGap = StringFieldMapper.Defaults.positionOffsetGap(Version.indexCreated(indexSettings));, +                /*, +                 * Custom analyzers already default to the correct, version, +                 * dependent positionOffsetGap and the user is be able to, +                 * configure the positionOffsetGap directly on the analyzer so, +                 * we disable overriding the positionOffsetGap to preserve the, +                 * user's setting., +                 */, +                overridePositionOffsetGap = Integer.MIN_VALUE;, +                // if we got a named analyzer back, use it..., +                if (overridePositionOffsetGap >= 0 && analyzer.getPositionIncrementGap(analyzer.name()) != overridePositionOffsetGap) {, +                    // unless the positionOffsetGap needs to be overridden, +                    analyzer = new NamedAnalyzer(analyzer, overridePositionOffsetGap);, +                }, +                analyzer = new NamedAnalyzer(analyzerFactory.name(), analyzerFactory.scope(), analyzerF, overridePositionOffsetGap);, +++ b/core/src/main/java/org/elasticsearch/index/analysis/AnalysisService.java, +import org.elasticsearch.index.mapper.core.StringFieldMapper;, +            /*, +             * Lucene defaults positionOffsetGap to 0 in all analyzers but, +             * Elasticsearch defaults them to 0 only before version 2.1, +             * and 100 afterwards so we override the positionOffsetGap if it, +             * doesn't match here., +             */, +            int overridePositionOffsetGap = StringFieldMapper.Defaults.positionOffsetGap(Version.indexCreated(indexSettings));, +                /*, +                 * Custom analyzers already default to the correct, version, +                 * dependent positionOffsetGap and the user is be able to, +                 * configure the positionOffsetGap directly on the analyzer so, +                 * we disable overriding the positionOffsetGap to preserve the, +                 * user's setting., +                 */, +                overridePositionOffsetGap = Integer.MIN_VALUE;, +                // if we got a named analyzer back, use it..., +                if (overridePositionOffsetGap >= 0 && analyzer.getPositionIncrementGap(analyzer.name()) != overridePositionOffsetGap) {, +                    // unless the positionOffsetGap needs to be overridden, +                    analyzer = new NamedAnalyzer(analyzer, overridePositionOffsetGap);, +                }, +                analyzer = new NamedAnalyzer(analyzerFactory.name(), analyzerFactory.scope(), analyzerF, overridePositionOffsetGap);, +++ b/core/src/main/java/org/elasticsearch/index/analysis/CustomAnalyzerProvider.java, +import org.elasticsearch.Version;, +import org.elasticsearch.index.mapper.core.StringFieldMapper;, +        int positionOffsetGapDefault = StringFieldMapper.Defaults.positionOffsetGap(Version.indexCreated(indexSettings));, +        int positionOffsetGap = analyzerSettings.getAsInt("position_offset_gap", positionOffsetGapDefault);, +++ b/core/src/main/java/org/elasticsearch/index/analysis/AnalysisService.java, +import org.elasticsearch.index.mapper.core.StringFieldMapper;, +            /*, +             * Lucene defaults positionOffsetGap to 0 in all analyzers but, +             * Elasticsearch defaults them to 0 only before version 2.1, +             * and 100 afterwards so we override the positionOffsetGap if it, +             * doesn't match here., +             */, +            int overridePositionOffsetGap = StringFieldMapper.Defaults.positionOffsetGap(Version.indexCreated(indexSettings));, +                /*, +                 * Custom analyzers already default to the correct, version, +                 * dependent positionOffsetGap and the user is be able to, +                 * configure the positionOffsetGap directly on the analyzer so, +                 * we disable overriding the positionOffsetGap to preserve the, +                 * user's setting., +                 */, +                overridePositionOffsetGap = Integer.MIN_VALUE;, +                // if we got a named analyzer back, use it..., +                if (overridePositionOffsetGap >= 0 && analyzer.getPositionIncrementGap(analyzer.name()) != overridePositionOffsetGap) {, +                    // unless the positionOffsetGap needs to be overridden, +                    analyzer = new NamedAnalyzer(analyzer, overridePositionOffsetGap);, +                }, +                analyzer = new NamedAnalyzer(analyzerFactory.name(), analyzerFactory.scope(), analyzerF, overridePositionOffsetGap);, +++ b/core/src/main/java/org/elasticsearch/index/analysis/CustomAnalyzerProvider.java, +import org.elasticsearch.Version;, +import org.elasticsearch.index.mapper.core.StringFieldMapper;, +        int positionOffsetGapDefault = StringFieldMapper.Defaults.positionOffsetGap(Version.indexCreated(indexSettings));, +        int positionOffsetGap = analyzerSettings.getAsInt("position_offset_gap", positionOffsetGapDefault);, +++ b/core/src/main/java/org/elasticsearch/index/mapper/core/StringFieldMapper.java, +import org.elasticsearch.Version;, +    private static final int POSITION_OFFSET_GAP_USE_ANALYZER = -1;, +        /**, +         * Post 2.1 default for position_offset_gap. Set to 100 so that, +         * phrase queries of reasonably high slop will not match across field, +         * values., +         */, +        public static final int POSITION_OFFSET_GAP = 100;, +        public static final int POSITION_OFFSET_GAP_PRE_2_1 = 0;, +, +        /**, +         * The default position_offset_gap for a particular version of Elasticsearch., +         */, +        public static int positionOffsetGap(Version version) {, +            if (version.before(Version.V_2_1_0)) {, +                return POSITION_OFFSET_GAP_PRE_2_1;, +            }, +            return POSITION_OFFSET_GAP;, +        }, +        /**]