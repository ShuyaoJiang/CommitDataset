[+++ b/core/src/main/java/org/elasticsearch/cluster/metadata/MetaDataIndexStateService.java, +import com.carrotsearch.hppc.cursors.ObjectObjectCursor;, +import org.elasticsearch.cluster.RestoreInProgress;, +import org.elasticsearch.index.shard.ShardId;, +import java.util.HashSet;, +import java.util.Set;, +                Set<String> indicesToClose = new HashSet<>();, +                // Check if any of the indices to be closed are currently being restored from a snapshot and fail closing if such an index, +                // is found as closing an index that is being restored makes the index unusable (it cannot be recovered)., +                RestoreInProgress restore = currentState.custom(RestoreInProgress.TYPE);, +                if (restore != null) {, +                    Set<String> indicesToFail = null;, +                    for (RestoreInProgress.Entry entry : restore.entries()) {, +                        for (ObjectObjectCursor<ShardId, RestoreInProgress.ShardRestoreStatus> shard : entry.shards()) {, +                            if (!shard.value.state().completed()) {, +                                if (indicesToClose.contains(shard.key.getIndexName())) {, +                                    if (indicesToFail == null) {, +                                        indicesToFail = new HashSet<>();, +                                    }, +                                    indicesToFail.add(shard.key.getIndexName());, +                                }, +                            }, +                        }, +                    }, +                    if (indicesToFail != null) {, +                        throw new IllegalArgumentException("Cannot close indices that are being restored: " + indicesToFail);, +                    }, +                }, +, +++ b/core/src/main/java/org/elasticsearch/cluster/metadata/MetaDataIndexStateService.java, +import com.carrotsearch.hppc.cursors.ObjectObjectCursor;, +import org.elasticsearch.cluster.RestoreInProgress;, +import org.elasticsearch.index.shard.ShardId;, +import java.util.HashSet;, +import java.util.Set;, +                Set<String> indicesToClose = new HashSet<>();, +                // Check if any of the indices to be closed are currently being restored from a snapshot and fail closing if such an index, +                // is found as closing an index that is being restored makes the index unusable (it cannot be recovered)., +                RestoreInProgress restore = currentState.custom(RestoreInProgress.TYPE);, +                if (restore != null) {, +                    Set<String> indicesToFail = null;, +                    for (RestoreInProgress.Entry entry : restore.entries()) {, +                        for (ObjectObjectCursor<ShardId, RestoreInProgress.ShardRestoreStatus> shard : entry.shards()) {, +                            if (!shard.value.state().completed()) {, +                                if (indicesToClose.contains(shard.key.getIndexName())) {, +                                    if (indicesToFail == null) {, +                                        indicesToFail = new HashSet<>();, +                                    }, +                                    indicesToFail.add(shard.key.getIndexName());, +                                }, +                            }, +                        }, +                    }, +                    if (indicesToFail != null) {, +                        throw new IllegalArgumentException("Cannot close indices that are being restored: " + indicesToFail);, +                    }, +                }, +, +++ b/core/src/test/java/org/elasticsearch/snapshots/AbstractSnapshotIntegTestCase.java, +    public static void blockAllDataNodes(String repository) {, +        for(RepositoriesService repositoriesService : internalCluster().getDataNodeInstances(RepositoriesService.class)) {, +            ((MockRepository)repositoriesService.repository(repository)).blockOnDataFiles(true);, +        }, +    }, +, +    public static void unblockAllDataNodes(String repository) {, +        for(RepositoriesService repositoriesService : internalCluster().getDataNodeInstances(RepositoriesService.class)) {, +            ((MockRepository)repositoriesService.repository(repository)).unblock();, +        }, +    }, +, +    public void waitForBlockOnAnyDataNode(String repository, TimeValue timeout) throws InterruptedException {, +        if (false == awaitBusy(() -> {, +            for(RepositoriesService repositoriesService : internalCluster().getDataNodeInstances(RepositoriesService.class)) {, +                MockRepository mockRepository = (MockRepository) repositoriesService.repository(repository);, +                if (mockRepository.blocked()) {, +                    return true;, +                }, +            }, +            return false;, +        }, timeout.millis(), TimeUnit.MILLISECONDS)) {, +            fail("Timeout waiting for repository block on any data node!!!");, +        }, +    }, +, +++ b/core/src/main/java/org/elasticsearch/cluster/metadata/MetaDataIndexStateService.java, +import com.carrotsearch.hppc.cursors.ObjectObjectCursor;, +import org.elasticsearch.cluster.RestoreInProgress;, +import org.elasticsearch.index.shard.ShardId;, +import java.util.HashSet;, +import java.util.Set;, +                Set<String> indicesToClose = new HashSet<>();, +                // Check if any of the indices to be closed are currently being restored from a snapshot and fail closing if such an index, +                // is found as closing an index that is being restored makes the index unusable (it cannot be recovered)., +                RestoreInProgress restore = currentState.custom(RestoreInProgress.TYPE);, +                if (restore != null) {, +                    Set<String> indicesToFail = null;, +                    for (RestoreInProgress.Entry entry : restore.entries()) {, +                        for (ObjectObjectCursor<ShardId, RestoreInProgress.ShardRestoreStatus> shard : entry.shards()) {, +                            if (!shard.value.state().completed()) {]