[+++ b/server/src/main/java/org/elasticsearch/snapshots/SnapshotsService.java, +        long repoGenId = repositoryData.getGenId();, +            Optional<SnapshotsInProgress.Entry> matchedInProgress = currentSnapshots(repositoryName, Collections.emptyList()).stream(), +                               .filter(s -> s.snapshot().getSnapshotId().getName().equals(snapshotName)).findFirst();, +            if (matchedInProgress.isPresent()) {, +                matchedEntry = matchedInProgress.map(s -> s.snapshot().getSnapshotId());, +                // Derive repository generation if a snapshot is in progress because it will increment the generation when it finishes, +                repoGenId = matchedInProgress.get().getRepositoryStateId() + 1L;, +            }, +        deleteSnapshot(new Snapshot(repositoryName, matchedEntry.get()), listener, repoGenId, immediatePriority);, +++ b/server/src/main/java/org/elasticsearch/snapshots/SnapshotsService.java, +        long repoGenId = repositoryData.getGenId();, +            Optional<SnapshotsInProgress.Entry> matchedInProgress = currentSnapshots(repositoryName, Collections.emptyList()).stream(), +                               .filter(s -> s.snapshot().getSnapshotId().getName().equals(snapshotName)).findFirst();, +            if (matchedInProgress.isPresent()) {, +                matchedEntry = matchedInProgress.map(s -> s.snapshot().getSnapshotId());, +                // Derive repository generation if a snapshot is in progress because it will increment the generation when it finishes, +                repoGenId = matchedInProgress.get().getRepositoryStateId() + 1L;, +            }, +        deleteSnapshot(new Snapshot(repositoryName, matchedEntry.get()), listener, repoGenId, immediatePriority);, +++ b/server/src/test/java/org/elasticsearch/snapshots/SnapshotsServiceTests.java, +import org.elasticsearch.action.admin.cluster.snapshots.delete.DeleteSnapshotAction;, +import org.elasticsearch.action.admin.cluster.snapshots.delete.DeleteSnapshotRequest;, +import org.elasticsearch.action.admin.cluster.snapshots.delete.TransportDeleteSnapshotAction;, +    public void testConcurrentSnapshotCreateAndDelete() {, +        setupTestCluster(randomFrom(1, 3, 5), randomIntBetween(2, 10));, +, +        String repoName = "repo";, +        String snapshotName = "snapshot";, +        final String index = "test";, +, +        final int shards = randomIntBetween(1, 10);, +, +        TestClusterNode masterNode =, +            testClusterNodes.currentMaster(testClusterNodes.nodes.values().iterator().next().clusterService.state());, +        final AtomicBoolean createdSnapshot = new AtomicBoolean();, +        masterNode.client.admin().cluster().preparePutRepository(repoName), +            .setType(FsRepository.TYPE).setSettings(Settings.builder().put("location", randomAlphaOfLength(10))), +            .execute(, +                assertNoFailureListener(, +                    () -> masterNode.client.admin().indices().create(, +                        new CreateIndexRequest(index).waitForActiveShards(ActiveShardCount.ALL).settings(, +                            Settings.builder(), +                                .put(IndexMetaData.INDEX_NUMBER_OF_SHARDS_SETTING.getKey(), shards), +                                .put(IndexMetaData.INDEX_NUMBER_OF_REPLICAS_SETTING.getKey(), 0)),, +                        assertNoFailureListener(, +                            () -> masterNode.client.admin().cluster().prepareCreateSnapshot(repoName, snapshotName), +                                .execute(assertNoFailureListener(, +                                    () -> masterNode.client.admin().cluster().deleteSnapshot(, +                                        new DeleteSnapshotRequest(repoName, snapshotName),, +                                        assertNoFailureListener(() -> masterNode.client.admin().cluster(), +                                            .prepareCreateSnapshot(repoName, snapshotName).execute(, +                                                assertNoFailureListener(() -> createdSnapshot.set(true)), +                                            )))))))));, +, +        deterministicTaskQueue.runAllRunnableTasks();, +, +        assertTrue(createdSnapshot.get());, +        SnapshotsInProgress finalSnapshotsInProgress = masterNode.clusterService.state().custom(SnapshotsInProgress.TYPE);, +        assertFalse(finalSnapshotsInProgress.entries().stream().anyMatch(entry -> entry.state().completed() == false));, +        final Repository repository = masterNode.repositoriesService.repository(repoName);, +        Collection<SnapshotId> snapshotIds = repository.getRepositoryData().getSnapshotIds();, +        assertThat(snapshotIds, hasSize(1));, +, +        final SnapshotInfo snapshotInfo = repository.getSnapshotInfo(snapshotIds.iterator().next());, +        assertEquals(SnapshotState.SUCCESS, snapshotInfo.state());, +        assertThat(snapshotInfo.indices(), containsInAnyOrder(index));, +        assertEquals(shards, snapshotInfo.successfulShards());, +        assertEquals(0, snapshotInfo.failedShards());, +    }, +, +            actions.put(DeleteSnapshotAction.INSTANCE,, +                new TransportDeleteSnapshotAction(, +                    transportService, clusterService, threadPool,, +                    snapshotsService, actionFilters, indexNameExpressionResolver, +                ));]