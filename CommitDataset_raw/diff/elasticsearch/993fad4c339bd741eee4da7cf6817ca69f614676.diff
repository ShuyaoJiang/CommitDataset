[+++ b/src/main/java/org/elasticsearch/cluster/metadata/MetaDataMappingService.java, +import com.google.common.collect.Maps;, +        List<Object> allTasks = new ArrayList<Object>();, +        refreshOrUpdateQueue.drainTo(allTasks);, +        if (allTasks.isEmpty()) {, +        // break down to tasks per index, so we can optimize the on demand index service creation, +        // to only happen for the duration of a single index processing of its respective events, +        Map<String, List<Object>> tasksPerIndex = Maps.newHashMap();, +        for (Object task : allTasks) {, +            String index = null;, +            if (task instanceof UpdateTask) {, +                index = ((UpdateTask) task).index;, +            } else if (task instanceof RefreshTask) {, +                index = ((RefreshTask) task).index;, +            } else {, +                logger.warn("illegal state, got wrong mapping task type [{}]", task);, +            }, +            if (index != null) {, +                List<Object> indexTasks = tasksPerIndex.get(index);, +                if (indexTasks == null) {, +                    indexTasks = new ArrayList<Object>();, +                    tasksPerIndex.put(index, indexTasks);, +                }, +                indexTasks.add(task);, +            }, +        }, +, +        for (Map.Entry<String, List<Object>> entry : tasksPerIndex.entrySet()) {, +            String index = entry.getKey();, +            List<Object> tasks = entry.getValue();, +            boolean removeIndex = false;, +            // keep track of what we already refreshed, no need to refresh it again..., +            Set<String> processedRefreshes = Sets.newHashSet();, +            try {, +                            removeIndex = true;, +                            if (processedRefreshes.contains(type)) {, +                            processedRefreshes.add(type);, +                            removeIndex = true;, +                        processedRefreshes.add(type);, +                if (removeIndex) {, +        if (!dirty) {, +            return currentState;, +        }, +        return newClusterStateBuilder().state(currentState).metaData(mdBuilder).build();, +    }, +]