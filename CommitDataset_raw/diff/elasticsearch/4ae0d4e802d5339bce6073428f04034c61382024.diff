[+++ b/build.gradle, +    "org.elasticsearch:elasticsearch-cli:${version}": ':libs:cli',, +++ b/build.gradle, +    "org.elasticsearch:elasticsearch-cli:${version}": ':libs:cli',, +++ b/buildSrc/src/main/groovy/org/elasticsearch/gradle/plugin/PluginBuildPlugin.groovy, +            } else {, +                // no client plugin, so use the pom file from nebula, without jar, for the zip, +                project.ext.set("nebulaPublish.maven.jar", false), +                addZipPomGeneration(project), +    /** Adds a task to generate a pom file for the zip distribution. */, +    public static void addZipPomGeneration(Project project) {, +                zip(MavenPublication) {, +                    artifact project.bundlePlugin, +                }, +                /* HUGE HACK: the underlying maven publication library refuses to deploy any attached artifacts, +                 * when the packaging type is set to 'pom'. But Sonatype's OSS repositories require source files, +                 * for artifacts that are of type 'zip'. We already publish the source and javadoc for Elasticsearch, +                 * under the various other subprojects. So here we create another publication using the same, +                 * name that has the "real" pom, and rely on the fact that gradle will execute the publish tasks, +                 * in alphabetical order. This lets us publish the zip file and even though the pom says the, +                 * type is 'pom' instead of 'zip'. We cannot setup a dependency between the tasks because the, +                 * publishing tasks are created *extremely* late in the configuration phase, so that we cannot get, +                 * ahold of the actual task. Furthermore, this entire hack only exists so we can make publishing to, +                 * maven local work, since we publish to maven central externally. */, +                zipReal(MavenPublication) {, +                    artifactId = project.pluginProperties.extension.name, +                    pom.withXml { XmlProvider xml ->, +                        Node root = xml.asNode(), +                        root.appendNode('name', project.pluginProperties.extension.name), +                        root.appendNode('description', project.pluginProperties.extension.description), +                        root.appendNode('url', urlFromOrigin(project.scminfo.origin)), +                        Node scmNode = root.appendNode('scm'), +                        scmNode.appendNode('url', project.scminfo.origin), +                    }, +++ b/build.gradle, +    "org.elasticsearch:elasticsearch-cli:${version}": ':libs:cli',, +++ b/buildSrc/src/main/groovy/org/elasticsearch/gradle/plugin/PluginBuildPlugin.groovy, +            } else {, +                // no client plugin, so use the pom file from nebula, without jar, for the zip, +                project.ext.set("nebulaPublish.maven.jar", false), +                addZipPomGeneration(project), +    /** Adds a task to generate a pom file for the zip distribution. */, +    public static void addZipPomGeneration(Project project) {, +                zip(MavenPublication) {, +                    artifact project.bundlePlugin, +                }, +                /* HUGE HACK: the underlying maven publication library refuses to deploy any attached artifacts, +                 * when the packaging type is set to 'pom'. But Sonatype's OSS repositories require source files, +                 * for artifacts that are of type 'zip'. We already publish the source and javadoc for Elasticsearch, +                 * under the various other subprojects. So here we create another publication using the same, +                 * name that has the "real" pom, and rely on the fact that gradle will execute the publish tasks, +                 * in alphabetical order. This lets us publish the zip file and even though the pom says the, +                 * type is 'pom' instead of 'zip'. We cannot setup a dependency between the tasks because the, +                 * publishing tasks are created *extremely* late in the configuration phase, so that we cannot get, +                 * ahold of the actual task. Furthermore, this entire hack only exists so we can make publishing to, +                 * maven local work, since we publish to maven central externally. */, +                zipReal(MavenPublication) {, +                    artifactId = project.pluginProperties.extension.name, +                    pom.withXml { XmlProvider xml ->, +                        Node root = xml.asNode(), +                        root.appendNode('name', project.pluginProperties.extension.name), +                        root.appendNode('description', project.pluginProperties.extension.description), +                        root.appendNode('url', urlFromOrigin(project.scminfo.origin)), +                        Node scmNode = root.appendNode('scm'), +                        scmNode.appendNode('url', project.scminfo.origin), +                    }, +++ b/buildSrc/src/main/groovy/org/elasticsearch/gradle/test/ClusterConfiguration.groovy, +++ b/build.gradle, +    "org.elasticsearch:elasticsearch-cli:${version}": ':libs:cli',, +++ b/buildSrc/src/main/groovy/org/elasticsearch/gradle/plugin/PluginBuildPlugin.groovy, +            } else {, +                // no client plugin, so use the pom file from nebula, without jar, for the zip, +                project.ext.set("nebulaPublish.maven.jar", false), +                addZipPomGeneration(project), +    /** Adds a task to generate a pom file for the zip distribution. */, +    public static void addZipPomGeneration(Project project) {, +                zip(MavenPublication) {, +                    artifact project.bundlePlugin, +                }, +                /* HUGE HACK: the underlying maven publication library refuses to deploy any attached artifacts, +                 * when the packaging type is set to 'pom'. But Sonatype's OSS repositories require source files, +                 * for artifacts that are of type 'zip'. We already publish the source and javadoc for Elasticsearch, +                 * under the various other subprojects. So here we create another publication using the same, +                 * name that has the "real" pom, and rely on the fact that gradle will execute the publish tasks, +                 * in alphabetical order. This lets us publish the zip file and even though the pom says the, +                 * type is 'pom' instead of 'zip'. We cannot setup a dependency between the tasks because the, +                 * publishing tasks are created *extremely* late in the configuration phase, so that we cannot get, +                 * ahold of the actual task. Furthermore, this entire hack only exists so we can make publishing to, +                 * maven local work, since we publish to maven central externally. */, +                zipReal(MavenPublication) {, +                    artifactId = project.pluginProperties.extension.name, +                    pom.withXml { XmlProvider xml ->, +                        Node root = xml.asNode(), +                        root.appendNode('name', project.pluginProperties.extension.name), +                        root.appendNode('description', project.pluginProperties.extension.description), +                        root.appendNode('url', urlFromOrigin(project.scminfo.origin)), +                        Node scmNode = root.appendNode('scm'), +                        scmNode.appendNode('url', project.scminfo.origin), +                    }, +++ b/buildSrc/src/main/groovy/org/elasticsearch/gradle/test/ClusterConfiguration.groovy]