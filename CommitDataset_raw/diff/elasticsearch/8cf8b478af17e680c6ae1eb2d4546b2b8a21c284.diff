[+++ b/src/main/java/org/elasticsearch/common/lucene/Lucene.java, +    public static ScoreDoc[] EMPTY_SCORE_DOCS = new ScoreDoc[0];, +, +++ b/src/main/java/org/elasticsearch/common/lucene/Lucene.java, +    public static ScoreDoc[] EMPTY_SCORE_DOCS = new ScoreDoc[0];, +, +++ b/src/main/java/org/elasticsearch/search/internal/SearchContext.java, +import org.elasticsearch.search.scan.ScanContext;, +    // lazy initialized only if needed, +    private ScanContext scanContext;, +, +        if (scanContext != null) {, +            scanContext.clear();, +        }, +    public ScanContext scanContext() {, +        if (scanContext == null) {, +            scanContext = new ScanContext();, +        }, +        return scanContext;, +    }, +, +++ b/src/main/java/org/elasticsearch/common/lucene/Lucene.java, +    public static ScoreDoc[] EMPTY_SCORE_DOCS = new ScoreDoc[0];, +, +++ b/src/main/java/org/elasticsearch/search/internal/SearchContext.java, +import org.elasticsearch.search.scan.ScanContext;, +    // lazy initialized only if needed, +    private ScanContext scanContext;, +, +        if (scanContext != null) {, +            scanContext.clear();, +        }, +    public ScanContext scanContext() {, +        if (scanContext == null) {, +            scanContext = new ScanContext();, +        }, +        return scanContext;, +    }, +, +++ b/src/main/java/org/elasticsearch/search/query/QueryPhase.java, +import org.elasticsearch.common.lucene.Lucene;, +                TotalHitCountCollector collector = new TotalHitCountCollector();, +                searchContext.searcher().search(query, collector);, +                topDocs = new TopDocs(collector.getTotalHits(), Lucene.EMPTY_SCORE_DOCS, 0);, +                topDocs = searchContext.scanContext().execute(searchContext);, +++ b/src/main/java/org/elasticsearch/common/lucene/Lucene.java, +    public static ScoreDoc[] EMPTY_SCORE_DOCS = new ScoreDoc[0];, +, +++ b/src/main/java/org/elasticsearch/search/internal/SearchContext.java, +import org.elasticsearch.search.scan.ScanContext;, +    // lazy initialized only if needed, +    private ScanContext scanContext;, +, +        if (scanContext != null) {, +            scanContext.clear();, +        }, +    public ScanContext scanContext() {, +        if (scanContext == null) {, +            scanContext = new ScanContext();, +        }, +        return scanContext;, +    }, +, +++ b/src/main/java/org/elasticsearch/search/query/QueryPhase.java, +import org.elasticsearch.common.lucene.Lucene;, +                TotalHitCountCollector collector = new TotalHitCountCollector();, +                searchContext.searcher().search(query, collector);, +                topDocs = new TopDocs(collector.getTotalHits(), Lucene.EMPTY_SCORE_DOCS, 0);, +                topDocs = searchContext.scanContext().execute(searchContext);, +++ b/src/main/java/org/elasticsearch/search/scan/ScanContext.java, +package org.elasticsearch.search.scan;, +, +import com.google.common.collect.Maps;, +import org.apache.lucene.index.IndexReader;, +import org.apache.lucene.search.*;, +import org.elasticsearch.common.lucene.docset.AllDocSet;, +import org.elasticsearch.search.internal.SearchContext;, +, +import java.io.IOException;, +import java.util.ArrayList;, +import java.util.Map;, +, +/**, + * The scan context allows to optimize readers we already processed during scanning. We do that by keeping track, + * of the count per reader, and if we are done with it, we no longer process it by using a filter that returns, + * null docIdSet for this reader., + */, +public class ScanContext {, +, +    private final Map<IndexReader, ReaderState> readerStates = Maps.newHashMap();, +, +    public void clear() {, +        readerStates.clear();, +    }, +, +    public TopDocs execute(SearchContext context) throws IOException {, +        ScanCollector collector = new ScanCollector(readerStates, context.from(), context.size(), context.trackScores());, +        Query query = new FilteredQuery(context.query(), new ScanFilter(readerStates, collector));, +        try {, +            context.searcher().search(query, collector);]