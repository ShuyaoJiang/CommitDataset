[+++ b/core/src/main/java/org/elasticsearch/action/admin/indices/validate/query/TransportValidateQueryAction.java, +                explanation = searchContext.parsedQuery().query().toString();, +++ b/core/src/main/java/org/elasticsearch/action/admin/indices/validate/query/TransportValidateQueryAction.java, +                explanation = searchContext.parsedQuery().query().toString();, +++ b/core/src/main/java/org/elasticsearch/percolator/PercolateContext.java, +, +import org.apache.lucene.search.Collector;, +    private final Map<Class<?>, Collector> queryCollectors = new HashMap<>();, +, +    @Override, +    public Map<Class<?>, Collector> queryCollectors() {, +        return queryCollectors;, +    }, +++ b/core/src/main/java/org/elasticsearch/action/admin/indices/validate/query/TransportValidateQueryAction.java, +                explanation = searchContext.parsedQuery().query().toString();, +++ b/core/src/main/java/org/elasticsearch/percolator/PercolateContext.java, +, +import org.apache.lucene.search.Collector;, +    private final Map<Class<?>, Collector> queryCollectors = new HashMap<>();, +, +    @Override, +    public Map<Class<?>, Collector> queryCollectors() {, +        return queryCollectors;, +    }, +++ b/core/src/main/java/org/elasticsearch/search/aggregations/AggregationPhase.java, +                    context.queryCollectors().put(AggregationPhase.class, collector);, +        context.queryCollectors().remove(AggregationPhase.class);, +++ b/core/src/main/java/org/elasticsearch/action/admin/indices/validate/query/TransportValidateQueryAction.java, +                explanation = searchContext.parsedQuery().query().toString();, +++ b/core/src/main/java/org/elasticsearch/percolator/PercolateContext.java, +, +import org.apache.lucene.search.Collector;, +    private final Map<Class<?>, Collector> queryCollectors = new HashMap<>();, +, +    @Override, +    public Map<Class<?>, Collector> queryCollectors() {, +        return queryCollectors;, +    }, +++ b/core/src/main/java/org/elasticsearch/search/aggregations/AggregationPhase.java, +                    context.queryCollectors().put(AggregationPhase.class, collector);, +        context.queryCollectors().remove(AggregationPhase.class);, +++ b/core/src/main/java/org/elasticsearch/search/dfs/DfsPhase.java, +++ b/core/src/main/java/org/elasticsearch/action/admin/indices/validate/query/TransportValidateQueryAction.java, +                explanation = searchContext.parsedQuery().query().toString();, +++ b/core/src/main/java/org/elasticsearch/percolator/PercolateContext.java, +, +import org.apache.lucene.search.Collector;, +    private final Map<Class<?>, Collector> queryCollectors = new HashMap<>();, +, +    @Override, +    public Map<Class<?>, Collector> queryCollectors() {, +        return queryCollectors;, +    }, +++ b/core/src/main/java/org/elasticsearch/search/aggregations/AggregationPhase.java, +                    context.queryCollectors().put(AggregationPhase.class, collector);, +        context.queryCollectors().remove(AggregationPhase.class);, +++ b/core/src/main/java/org/elasticsearch/search/dfs/DfsPhase.java, +++ b/core/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java, +            // if scores are needed and we have dfs data then use it, +            if (dfSource != null && needsScores) {, +    public Explanation explain(Query query, int doc) throws IOException {, +            return in.explain(query, doc);, +    protected void search(List<LeafReaderContext> leaves, Weight weight, Collector collector) throws IOException {, +            super.search(leaves, weight, collector);, +++ b/core/src/main/java/org/elasticsearch/action/admin/indices/validate/query/TransportValidateQueryAction.java, +                explanation = searchContext.parsedQuery().query().toString();, +++ b/core/src/main/java/org/elasticsearch/percolator/PercolateContext.java, +, +import org.apache.lucene.search.Collector;, +    private final Map<Class<?>, Collector> queryCollectors = new HashMap<>();, +, +    @Override, +    public Map<Class<?>, Collector> queryCollectors() {, +        return queryCollectors;, +    }, +++ b/core/src/main/java/org/elasticsearch/search/aggregations/AggregationPhase.java, +                    context.queryCollectors().put(AggregationPhase.class, collector);, +        context.queryCollectors().remove(AggregationPhase.class);, +++ b/core/src/main/java/org/elasticsearch/search/dfs/DfsPhase.java, +++ b/core/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java, +            // if scores are needed and we have dfs data then use it, +            if (dfSource != null && needsScores) {, +    public Explanation explain(Query query, int doc) throws IOException {, +            return in.explain(query, doc);, +    protected void search(List<LeafReaderContext> leaves, Weight weight, Collector collector) throws IOException {, +            super.search(leaves, weight, collector);, +++ b/core/src/main/java/org/elasticsearch/search/internal/DefaultSearchContext.java, +, +import java.io.IOException;, +    private final Map<Class<?>, Collector> queryCollectors = new HashMap<>();, +        try {, +            this.query = searcher().rewrite(this.query);, +        } catch (IOException e) {, +            throw new QueryPhaseExecutionException(this, "Failed to rewrite main query", e);, +        }, +    public Query searchFilter(String[] types) {, +        return new ConstantScoreQuery(bq);, +     * The query to execute, in its rewritten form., +, +    @Override]