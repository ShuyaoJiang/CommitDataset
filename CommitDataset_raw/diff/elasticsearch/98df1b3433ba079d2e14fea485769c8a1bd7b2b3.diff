[+++ b/modules/elasticsearch/src/main/java/org/elasticsearch/gateway/GatewayService.java, +import org.elasticsearch.util.inject.Inject;, + * @author kimchy (shay.banon), +, +    private final TimeValue initialStateTimeout;, +, +    private final TimeValue delayIndexCreation;, +, +, +        // allow to control a delay of when indices will get created, +        // TODO we need to maintain, on the cluster state, a flag that states if it was read from the gateway or not, +        // so if we delay, and the first master failed to start, others will load it, +        this.delayIndexCreation = componentSettings.getAsTime("delay_index_creation", null);, +                    Boolean waited = readFromGateway(initialStateTimeout);, +                    if (waited != null && !waited) {, +    private Boolean readFromGateway(@Nullable TimeValue waitTimeout) {, +        if (delayIndexCreation != null) {, +            logger.debug("Delaying initial state index creation for [{}]", delayIndexCreation);, +            threadPool.schedule(new Runnable() {, +                @Override public void run() {, +                    updateClusterStateFromGateway(fMetaData, latch);, +                }, +            }, delayIndexCreation);, +        } else {, +            updateClusterStateFromGateway(fMetaData, latch);, +        }, +        // if we delay indices creation, then waiting for them does not make sense, +        if (delayIndexCreation != null) {, +            return null;, +        }, +        if (waitTimeout != null) {, +            try {, +                return latch.await(waitTimeout.millis(), TimeUnit.MILLISECONDS);, +            } catch (InterruptedException e) {, +                // ignore, +            }, +        }, +        return null;, +    }, +, +    private void updateClusterStateFromGateway(final MetaData fMetaData, final CountDownLatch latch) {]