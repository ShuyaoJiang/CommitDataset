[+++ b/core/src/main/java/org/apache/lucene/search/grouping/CollapseTopFieldDocs.java, +public final class CollapseTopFieldDocs extends TopFieldDocs {, +    private static final class ShardRef {, +        // True if we should use the incoming ScoreDoc.shardIndex for sort order, +        final boolean useScoreDocIndex;, +, +        ShardRef(int shardIndex, boolean useScoreDocIndex) {, +            this.useScoreDocIndex = useScoreDocIndex;, +, +        int getShardIndex(ScoreDoc scoreDoc) {, +            if (useScoreDocIndex) {, +                if (scoreDoc.shardIndex == -1) {, +                    throw new IllegalArgumentException("setShardIndex is false but TopDocs[", +                        + shardIndex + "].scoreDocs[" + hitIndex + "] is not set");, +                }, +                return scoreDoc.shardIndex;, +            } else {, +                // NOTE: we don't assert that shardIndex is -1 here, because caller could in fact have set it but asked us to ignore it now, +                return shardIndex;, +            }, +        }, +    }, +, +    /**, +     * if we need to tie-break since score / sort value are the same we first compare shard index (lower shard wins), +     * and then iff shard index is the same we use the hit index., +     */, +    static boolean tieBreakLessThan(ShardRef first, ScoreDoc firstDoc, ShardRef second, ScoreDoc secondDoc) {, +        final int firstShardIndex = first.getShardIndex(firstDoc);, +        final int secondShardIndex = second.getShardIndex(secondDoc);, +        // Tie break: earlier shard wins, +        if (firstShardIndex < secondShardIndex) {, +            return true;, +        } else if (firstShardIndex > secondShardIndex) {, +            return false;, +        } else {, +            // Tie break in same shard: resolve however the, +            // shard had resolved it:, +            assert first.hitIndex != second.hitIndex;, +            return first.hitIndex < second.hitIndex;, +        }, +    }, +        MergeSortQueue(Sort sort, CollapseTopFieldDocs[] shardHits) {, +            return tieBreakLessThan(first, firstFD, second, secondFD);, +                                             CollapseTopFieldDocs[] shardHits, boolean setShardIndex) {, +                queue.add(new ShardRef(shardIDX, setShardIndex == false));, +                if (setShardIndex) {, +                }, +++ b/core/src/main/java/org/apache/lucene/search/grouping/CollapseTopFieldDocs.java, +public final class CollapseTopFieldDocs extends TopFieldDocs {, +    private static final class ShardRef {, +        // True if we should use the incoming ScoreDoc.shardIndex for sort order, +        final boolean useScoreDocIndex;, +, +        ShardRef(int shardIndex, boolean useScoreDocIndex) {, +            this.useScoreDocIndex = useScoreDocIndex;, +, +        int getShardIndex(ScoreDoc scoreDoc) {, +            if (useScoreDocIndex) {, +                if (scoreDoc.shardIndex == -1) {, +                    throw new IllegalArgumentException("setShardIndex is false but TopDocs[", +                        + shardIndex + "].scoreDocs[" + hitIndex + "] is not set");, +                }, +                return scoreDoc.shardIndex;, +            } else {, +                // NOTE: we don't assert that shardIndex is -1 here, because caller could in fact have set it but asked us to ignore it now, +                return shardIndex;, +            }, +        }, +    }, +, +    /**, +     * if we need to tie-break since score / sort value are the same we first compare shard index (lower shard wins), +     * and then iff shard index is the same we use the hit index., +     */, +    static boolean tieBreakLessThan(ShardRef first, ScoreDoc firstDoc, ShardRef second, ScoreDoc secondDoc) {, +        final int firstShardIndex = first.getShardIndex(firstDoc);, +        final int secondShardIndex = second.getShardIndex(secondDoc);, +        // Tie break: earlier shard wins, +        if (firstShardIndex < secondShardIndex) {, +            return true;, +        } else if (firstShardIndex > secondShardIndex) {, +            return false;, +        } else {, +            // Tie break in same shard: resolve however the, +            // shard had resolved it:, +            assert first.hitIndex != second.hitIndex;, +            return first.hitIndex < second.hitIndex;, +        }, +    }, +        MergeSortQueue(Sort sort, CollapseTopFieldDocs[] shardHits) {, +            return tieBreakLessThan(first, firstFD, second, secondFD);, +                                             CollapseTopFieldDocs[] shardHits, boolean setShardIndex) {, +                queue.add(new ShardRef(shardIDX, setShardIndex == false));, +                if (setShardIndex) {, +                }, +++ b/core/src/main/java/org/elasticsearch/action/search/SearchPhaseController.java, +            mergedTopDocs = CollapseTopFieldDocs.merge(sort, from, topN, shardTopDocs, true);, +++ b/core/src/main/java/org/apache/lucene/search/grouping/CollapseTopFieldDocs.java, +public final class CollapseTopFieldDocs extends TopFieldDocs {]