[+++ b/modules/elasticsearch/src/main/java/org/elasticsearch/index/service/IndexService.java, +import org.elasticsearch.common.collect.ImmutableSet;, +    ImmutableSet<Integer> shardIds();, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/index/service/IndexService.java, +import org.elasticsearch.common.collect.ImmutableSet;, +    ImmutableSet<Integer> shardIds();, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/index/service/InternalIndexService.java, +import org.elasticsearch.ElasticSearchInterruptedException;, +import org.elasticsearch.common.collect.ImmutableSet;, +import org.elasticsearch.threadpool.ThreadPool;, +import java.util.concurrent.CountDownLatch;, +    private final ThreadPool threadPool;, +, +    @Inject public InternalIndexService(Injector injector, Index index, @IndexSettings Settings indexSettings, ThreadPool threadPool,, +        this.threadPool = threadPool;, +    @Override public ImmutableSet<Integer> shardIds() {, +        return ImmutableSet.copyOf(shards.keySet());, +    @Override public void close(final boolean delete) {, +            Set<Integer> shardIds = shardIds();, +            final CountDownLatch latch = new CountDownLatch(shardIds.size());, +            for (final int shardId : shardIds) {, +                threadPool.cached().execute(new Runnable() {, +                    @Override public void run() {, +                        } finally {, +                            latch.countDown();, +                });, +            }, +            try {, +                latch.await();, +            } catch (InterruptedException e) {, +                throw new ElasticSearchInterruptedException("interrupted closing index [ " + index().name() + "]", e);, +            }, +    private void deleteShard(int shardId, boolean delete, boolean deleteGateway) throws ElasticSearchException {, +        Injector shardInjector;, +        IndexShard indexShard;, +        synchronized (this) {, +            shardInjector = tmpShardInjectors.remove(shardId);, +            indexShard = tmpShardsMap.remove(shardId);, +        }, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/index/service/IndexService.java, +import org.elasticsearch.common.collect.ImmutableSet;, +    ImmutableSet<Integer> shardIds();, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/index/service/InternalIndexService.java, +import org.elasticsearch.ElasticSearchInterruptedException;, +import org.elasticsearch.common.collect.ImmutableSet;, +import org.elasticsearch.threadpool.ThreadPool;, +import java.util.concurrent.CountDownLatch;, +    private final ThreadPool threadPool;, +, +    @Inject public InternalIndexService(Injector injector, Index index, @IndexSettings Settings indexSettings, ThreadPool threadPool,, +        this.threadPool = threadPool;, +    @Override public ImmutableSet<Integer> shardIds() {, +        return ImmutableSet.copyOf(shards.keySet());, +    @Override public void close(final boolean delete) {, +            Set<Integer> shardIds = shardIds();, +            final CountDownLatch latch = new CountDownLatch(shardIds.size());, +            for (final int shardId : shardIds) {, +                threadPool.cached().execute(new Runnable() {, +                    @Override public void run() {, +                        } finally {, +                            latch.countDown();, +                });, +            }, +            try {, +                latch.await();, +            } catch (InterruptedException e) {, +                throw new ElasticSearchInterruptedException("interrupted closing index [ " + index().name() + "]", e);, +            }, +    private void deleteShard(int shardId, boolean delete, boolean deleteGateway) throws ElasticSearchException {, +        Injector shardInjector;, +        IndexShard indexShard;, +        synchronized (this) {, +            shardInjector = tmpShardInjectors.remove(shardId);, +            indexShard = tmpShardsMap.remove(shardId);, +        }, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/indices/InternalIndicesService.java, +import org.elasticsearch.common.collect.ImmutableSet;, +import org.elasticsearch.threadpool.ThreadPool;, +import java.util.concurrent.CountDownLatch;, +    private final ThreadPool threadPool;, +, +    @Inject public InternalIndicesService(Settings settings, ThreadPool threadPool, IndicesLifecycle indicesLifecycle, IndicesAnalysisService indicesAnalysisService, IndicesStore indicesStore, Injector injector) {, +        this.threadPool = threadPool;, +        ImmutableSet<String> indices = ImmutableSet.copyOf(this.indices.keySet());, +        final CountDownLatch latch = new CountDownLatch(indices.size());, +        for (final String index : indices) {, +            threadPool.cached().execute(new Runnable() {, +                @Override public void run() {, +                    try {, +                    } catch (Exception e) {, +                        logger.warn("failed to delete index on stop [" + index + "]", e);, +                    } finally {, +                        latch.countDown();, +                    }, +                }, +            });, +        }, +        try {, +            latch.await();, +        } catch (InterruptedException e) {]