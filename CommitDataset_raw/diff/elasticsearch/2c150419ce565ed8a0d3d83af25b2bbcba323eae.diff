[+++ b/src/main/java/org/elasticsearch/action/admin/indices/flush/TransportFlushAction.java, +        indexShard.flush(new Engine.Flush().refresh(request.refresh()).type(request.full() ? Engine.Flush.Type.NEW_WRITER : Engine.Flush.Type.COMMIT_TRANSLOG).force(request.force()));, +++ b/src/main/java/org/elasticsearch/action/admin/indices/flush/TransportFlushAction.java, +        indexShard.flush(new Engine.Flush().refresh(request.refresh()).type(request.full() ? Engine.Flush.Type.NEW_WRITER : Engine.Flush.Type.COMMIT_TRANSLOG).force(request.force()));, +++ b/src/main/java/org/elasticsearch/index/engine/Engine.java, +    /**, +     * Snapshots the index and returns a handle to it. Will always try and "commit" the, +     * lucene index to make sure we have a "fresh" copy of the files to snapshot., +     */, +    SnapshotIndexCommit snapshotIndex() throws EngineException;, +, +        public static enum Type {, +            /**, +             * A flush that causes a new writer to be created., +             */, +            NEW_WRITER,, +            /**, +             * A flush that just commits the writer, without cleaning the translog., +             */, +            COMMIT,, +            /**, +             * A flush that does a commit, as well as clears the translog., +             */, +            COMMIT_TRANSLOG, +        }, +, +        private Type type = Type.COMMIT_TRANSLOG;, +        /**, +         * Should the flush operation wait if there is an ongoing flush operation., +         */, +        private boolean waitIfOngoing = false;, +        public Type type() {, +            return this.type;, +        public Flush type(Type type) {, +            this.type = type;, +        public boolean waitIfOngoing() {, +            return this.waitIfOngoing;, +        }, +, +        public Flush waitIfOngoing(boolean waitIfOngoing) {, +            this.waitIfOngoing = waitIfOngoing;, +            return this;, +        }, +, +            return "type[" + type + "], refresh[" + refresh + "], force[" + force + "]";, +++ b/src/main/java/org/elasticsearch/action/admin/indices/flush/TransportFlushAction.java, +        indexShard.flush(new Engine.Flush().refresh(request.refresh()).type(request.full() ? Engine.Flush.Type.NEW_WRITER : Engine.Flush.Type.COMMIT_TRANSLOG).force(request.force()));, +++ b/src/main/java/org/elasticsearch/index/engine/Engine.java, +    /**, +     * Snapshots the index and returns a handle to it. Will always try and "commit" the, +     * lucene index to make sure we have a "fresh" copy of the files to snapshot., +     */, +    SnapshotIndexCommit snapshotIndex() throws EngineException;, +, +        public static enum Type {, +            /**, +             * A flush that causes a new writer to be created., +             */, +            NEW_WRITER,, +            /**, +             * A flush that just commits the writer, without cleaning the translog., +             */, +            COMMIT,, +            /**, +             * A flush that does a commit, as well as clears the translog., +             */, +            COMMIT_TRANSLOG, +        }, +, +        private Type type = Type.COMMIT_TRANSLOG;, +        /**, +         * Should the flush operation wait if there is an ongoing flush operation., +         */, +        private boolean waitIfOngoing = false;, +        public Type type() {, +            return this.type;, +        public Flush type(Type type) {, +            this.type = type;, +        public boolean waitIfOngoing() {, +            return this.waitIfOngoing;, +        }, +, +        public Flush waitIfOngoing(boolean waitIfOngoing) {, +            this.waitIfOngoing = waitIfOngoing;, +            return this;, +        }, +, +            return "type[" + type + "], refresh[" + refresh + "], force[" + force + "]";, +++ b/src/main/java/org/elasticsearch/index/engine/robin/RobinEngine.java, +import org.elasticsearch.ElasticSearchIllegalStateException;, +import java.util.concurrent.atomic.AtomicInteger;, +import java.util.concurrent.locks.Lock;, +import java.util.concurrent.locks.ReentrantLock;, +    private final boolean asyncLoadBloomFilter;, +, +    private final ReadWriteLock rwl = new ReentrantReadWriteLock();, +    private final AtomicBoolean optimizeMutex = new AtomicBoolean();, +    private final AtomicInteger flushing = new AtomicInteger();, +    private final Lock flushLock = new ReentrantLock();, +    private volatile int onGoingRecoveries = 0;]