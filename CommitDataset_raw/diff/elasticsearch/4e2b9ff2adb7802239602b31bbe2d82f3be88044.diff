[+++ b/src/main/java/org/elasticsearch/index/engine/robin/RobinEngine.java, +    private volatile boolean compoundOnFlush = true;, +, +        this.compoundOnFlush = indexSettings.getAsBoolean(INDEX_COMPOUND_ON_FLUSH, this.compoundOnFlush);, +            config.setUseCompoundFile(this.compoundOnFlush);, +    public static final String INDEX_COMPOUND_ON_FLUSH = "index.compound_on_flush";, +, +            final boolean compoundOnFlush = settings.getAsBoolean(INDEX_COMPOUND_ON_FLUSH, RobinEngine.this.compoundOnFlush);, +            if (compoundOnFlush != RobinEngine.this.compoundOnFlush) {, +                logger.info("updating {} from [{}] to [{}]", RobinEngine.INDEX_COMPOUND_ON_FLUSH, RobinEngine.this.compoundOnFlush, compoundOnFlush);, +                RobinEngine.this.compoundOnFlush = compoundOnFlush;, +                indexWriter.getConfig().setUseCompoundFile(compoundOnFlush);, +            }, +            , +++ b/src/main/java/org/elasticsearch/index/engine/robin/RobinEngine.java, +    private volatile boolean compoundOnFlush = true;, +, +        this.compoundOnFlush = indexSettings.getAsBoolean(INDEX_COMPOUND_ON_FLUSH, this.compoundOnFlush);, +            config.setUseCompoundFile(this.compoundOnFlush);, +    public static final String INDEX_COMPOUND_ON_FLUSH = "index.compound_on_flush";, +, +            final boolean compoundOnFlush = settings.getAsBoolean(INDEX_COMPOUND_ON_FLUSH, RobinEngine.this.compoundOnFlush);, +            if (compoundOnFlush != RobinEngine.this.compoundOnFlush) {, +                logger.info("updating {} from [{}] to [{}]", RobinEngine.INDEX_COMPOUND_ON_FLUSH, RobinEngine.this.compoundOnFlush, compoundOnFlush);, +                RobinEngine.this.compoundOnFlush = compoundOnFlush;, +                indexWriter.getConfig().setUseCompoundFile(compoundOnFlush);, +            }, +            , +++ /dev/null, +++ b/src/main/java/org/elasticsearch/index/engine/robin/RobinEngine.java, +    private volatile boolean compoundOnFlush = true;, +, +        this.compoundOnFlush = indexSettings.getAsBoolean(INDEX_COMPOUND_ON_FLUSH, this.compoundOnFlush);, +            config.setUseCompoundFile(this.compoundOnFlush);, +    public static final String INDEX_COMPOUND_ON_FLUSH = "index.compound_on_flush";, +, +            final boolean compoundOnFlush = settings.getAsBoolean(INDEX_COMPOUND_ON_FLUSH, RobinEngine.this.compoundOnFlush);, +            if (compoundOnFlush != RobinEngine.this.compoundOnFlush) {, +                logger.info("updating {} from [{}] to [{}]", RobinEngine.INDEX_COMPOUND_ON_FLUSH, RobinEngine.this.compoundOnFlush, compoundOnFlush);, +                RobinEngine.this.compoundOnFlush = compoundOnFlush;, +                indexWriter.getConfig().setUseCompoundFile(compoundOnFlush);, +            }, +            , +++ /dev/null, +++ b/src/test/java/org/elasticsearch/test/unit/index/engine/robin/RobinEngineTests.java, +/*, + * Licensed to ElasticSearch and Shay Banon under one, + * or more contributor license agreements.  See the NOTICE file, + * distributed with this work for additional information, + * regarding copyright ownership. ElasticSearch licenses this, + * file to you under the Apache License, Version 2.0 (the, + * "License"); you may not use this file except in compliance, + * with the License.  You may obtain a copy of the License at, + *, + *    http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing,, + * software distributed under the License is distributed on an, + * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY, + * KIND, either express or implied.  See the License for the, + * specific language governing permissions and limitations, + * under the License., + */, +, +package org.elasticsearch.test.unit.index.engine.robin;, +, +import org.apache.lucene.analysis.Analyzer;, +import org.apache.lucene.document.Document;, +import org.apache.lucene.document.Field;, +import org.apache.lucene.document.NumericDocValuesField;, +import org.apache.lucene.document.TextField;, +import org.apache.lucene.index.IndexDeletionPolicy;, +import org.apache.lucene.index.Term;, +import org.apache.lucene.search.TermQuery;, +import org.elasticsearch.common.bytes.BytesArray;, +import org.elasticsearch.common.bytes.BytesReference;, +import org.elasticsearch.common.lucene.Lucene;, +import org.elasticsearch.common.settings.ImmutableSettings;, +import org.elasticsearch.common.settings.Settings;, +import org.elasticsearch.index.Index;, +import org.elasticsearch.index.VersionType;, +import org.elasticsearch.index.analysis.AnalysisService;, +import org.elasticsearch.index.codec.CodecService;, +import org.elasticsearch.index.deletionpolicy.KeepOnlyLastDeletionPolicy;, +import org.elasticsearch.index.deletionpolicy.SnapshotDeletionPolicy;, +import org.elasticsearch.index.deletionpolicy.SnapshotIndexCommit;, +import org.elasticsearch.index.engine.*;, +import org.elasticsearch.index.engine.robin.RobinEngine;, +import org.elasticsearch.index.indexing.ShardIndexingService;, +import org.elasticsearch.index.indexing.slowlog.ShardSlowLogIndexingService;, +import org.elasticsearch.index.mapper.ParsedDocument;, +import org.elasticsearch.index.mapper.internal.SourceFieldMapper;, +import org.elasticsearch.index.mapper.internal.UidFieldMapper;, +import org.elasticsearch.index.merge.policy.LogByteSizeMergePolicyProvider;, +import org.elasticsearch.index.merge.policy.MergePolicyProvider;, +import org.elasticsearch.index.merge.scheduler.MergeSchedulerProvider;, +import org.elasticsearch.index.merge.scheduler.SerialMergeSchedulerProvider;, +import org.elasticsearch.index.settings.IndexSettingsService;, +import org.elasticsearch.index.shard.ShardId;, +import org.elasticsearch.index.similarity.SimilarityService;]