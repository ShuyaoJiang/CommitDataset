[+++ b/core/src/test/java/org/elasticsearch/cluster/ClusterServiceIT.java, +import java.util.concurrent.ConcurrentHashMap;, +import java.util.concurrent.ConcurrentMap;, +import java.util.concurrent.atomic.AtomicInteger;, +        List<PrioritizedTask> tasks = new ArrayList<>(taskCount);, +            clusterService.submitStateUpdateTask("test", new PrioritizedTask(priority, latch, tasks));, +        for (PrioritizedTask task : tasks) {, +    public void testClusterStateBatchedUpdates() throws InterruptedException {, +        Settings settings = settingsBuilder(), +                .put("discovery.type", "local"), +                .build();, +        internalCluster().startNode(settings);, +        ClusterService clusterService = internalCluster().getInstance(ClusterService.class);, +, +        AtomicInteger counter = new AtomicInteger();, +        class Task {, +            private AtomicBoolean state = new AtomicBoolean();, +, +            public void execute() {, +                if (!state.compareAndSet(false, true)) {, +                    throw new IllegalStateException();, +                } else {, +                    counter.incrementAndGet();, +                }, +            }, +        }, +, +        class TaskExecutor implements ClusterStateTaskExecutor<Task> {, +            private AtomicInteger counter = new AtomicInteger();, +, +            @Override, +            public Result execute(ClusterState currentState, List<Task> tasks) throws Exception {, +                tasks.forEach(task -> task.execute());, +                counter.addAndGet(tasks.size());, +                return new Result(currentState, tasks.size());, +            }, +, +            @Override, +            public boolean runOnlyOnMaster() {, +                return false;, +            }, +        }, +        int numberOfThreads = randomIntBetween(2, 256);, +        int tasksSubmittedPerThread = randomIntBetween(1, 1024);, +, +        ConcurrentMap<String, AtomicInteger> counters = new ConcurrentHashMap<>();, +        CountDownLatch latch = new CountDownLatch(numberOfThreads * tasksSubmittedPerThread);, +        ClusterStateTaskListener listener = new ClusterStateTaskListener() {, +            @Override, +            public void onFailure(String source, Throwable t) {, +                assert false;, +            }, +, +            @Override, +            public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {, +                counters.computeIfAbsent(source, key -> new AtomicInteger()).incrementAndGet();, +                latch.countDown();, +            }, +        };, +, +        int numberOfExecutors = Math.max(1, numberOfThreads / 4);, +        List<TaskExecutor> executors = new ArrayList<>();, +        for (int i = 0; i < numberOfExecutors; i++) {, +            executors.add(new TaskExecutor());, +        }, +, +        // randomly assign tasks to executors, +        List<TaskExecutor> assignments = new ArrayList<>();, +        for (int i = 0; i < numberOfThreads; i++) {, +            for (int j = 0; j < tasksSubmittedPerThread; j++) {, +                assignments.add(randomFrom(executors));, +            }, +        }, +, +        Map<TaskExecutor, Integer> counts = new HashMap<>();, +        for (TaskExecutor executor : assignments) {, +            counts.merge(executor, 1, (previous, one) -> previous + one);, +        }, +, +        CountDownLatch startingGun = new CountDownLatch(1 + numberOfThreads);, +        List<Thread> threads = new ArrayList<>();, +        for (int i = 0; i < numberOfThreads; i++) {, +            final int index = i;, +            Thread thread = new Thread(() -> {, +                startingGun.countDown();, +                for (int j = 0; j < tasksSubmittedPerThread; j++) {, +                    ClusterStateTaskExecutor<Task> executor = assignments.get(index * tasksSubmittedPerThread + j);, +                    clusterService.submitStateUpdateTask(, +                            Thread.currentThread().getName(),, +                            new Task(),, +                            ClusterStateTaskConfig.build(Priority.NORMAL),, +                            executor,, +                            listener);, +                }, +            });, +            threads.add(thread);, +            thread.start();, +        }, +, +        startingGun.countDown();]