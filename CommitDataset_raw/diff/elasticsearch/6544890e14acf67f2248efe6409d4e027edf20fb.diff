[+++ b/src/main/java/org/elasticsearch/common/util/concurrent/PrioritizedEsThreadPoolExecutor.java, +            if (command instanceof TieBreakingPrioritizedRunnable) {, +                ((TieBreakingPrioritizedRunnable) command).scheduleTimeout(timer, timeoutCallback, timeout);, +            } else {, +                // We really shouldn't be here. The only way we can get here if somebody created PrioritizedFutureTask, +                // and passed it to execute, which doesn't make much sense, +                throw new UnsupportedOperationException("Execute with timeout is not supported for future tasks");, +        super.execute(command);, +    private final class TieBreakingPrioritizedRunnable extends PrioritizedRunnable {, +        private Runnable runnable;, +        private final long insertionOrder;, +        private ScheduledFuture<?> timeoutFuture;, +            FutureUtils.cancel(timeoutFuture);, +            runAndClean(runnable);, +, +        public void scheduleTimeout(ScheduledExecutorService timer, final Runnable timeoutCallback, TimeValue timeValue) {, +            timeoutFuture = timer.schedule(new Runnable() {, +                @Override, +                public void run() {, +                    if (remove(TieBreakingPrioritizedRunnable.this)) {, +                        runAndClean(timeoutCallback);, +                    }, +                }, +            }, timeValue.nanos(), TimeUnit.NANOSECONDS);, +        /**, +         * Timeout callback might remain in the timer scheduling queue for some time and it might hold, +         * the pointers to other objects. As a result it's possible to run out of memory if a large number of, +         * tasks are executed, +         */, +        private void runAndClean(Runnable run) {, +            try {, +                run.run();, +            } finally {, +                runnable = null;, +                timeoutFuture = null;, +            }, +        }, +, +    }, +, +    private final class PrioritizedFutureTask<T> extends FutureTask<T> implements Comparable<PrioritizedFutureTask> {, +++ b/src/main/java/org/elasticsearch/common/util/concurrent/PrioritizedEsThreadPoolExecutor.java, +            if (command instanceof TieBreakingPrioritizedRunnable) {, +                ((TieBreakingPrioritizedRunnable) command).scheduleTimeout(timer, timeoutCallback, timeout);, +            } else {, +                // We really shouldn't be here. The only way we can get here if somebody created PrioritizedFutureTask, +                // and passed it to execute, which doesn't make much sense, +                throw new UnsupportedOperationException("Execute with timeout is not supported for future tasks");, +        super.execute(command);, +    private final class TieBreakingPrioritizedRunnable extends PrioritizedRunnable {, +        private Runnable runnable;, +        private final long insertionOrder;, +        private ScheduledFuture<?> timeoutFuture;, +            FutureUtils.cancel(timeoutFuture);, +            runAndClean(runnable);, +, +        public void scheduleTimeout(ScheduledExecutorService timer, final Runnable timeoutCallback, TimeValue timeValue) {, +            timeoutFuture = timer.schedule(new Runnable() {, +                @Override, +                public void run() {, +                    if (remove(TieBreakingPrioritizedRunnable.this)) {, +                        runAndClean(timeoutCallback);, +                    }, +                }, +            }, timeValue.nanos(), TimeUnit.NANOSECONDS);, +        /**, +         * Timeout callback might remain in the timer scheduling queue for some time and it might hold, +         * the pointers to other objects. As a result it's possible to run out of memory if a large number of, +         * tasks are executed, +         */, +        private void runAndClean(Runnable run) {, +            try {, +                run.run();, +            } finally {, +                runnable = null;, +                timeoutFuture = null;, +            }, +        }, +, +    }, +, +    private final class PrioritizedFutureTask<T> extends FutureTask<T> implements Comparable<PrioritizedFutureTask> {, +++ b/src/main/java/org/elasticsearch/threadpool/ThreadPool.java, +        this.scheduler.setRemoveOnCancelPolicy(true);, +++ b/src/main/java/org/elasticsearch/common/util/concurrent/PrioritizedEsThreadPoolExecutor.java, +            if (command instanceof TieBreakingPrioritizedRunnable) {, +                ((TieBreakingPrioritizedRunnable) command).scheduleTimeout(timer, timeoutCallback, timeout);, +            } else {, +                // We really shouldn't be here. The only way we can get here if somebody created PrioritizedFutureTask, +                // and passed it to execute, which doesn't make much sense, +                throw new UnsupportedOperationException("Execute with timeout is not supported for future tasks");, +        super.execute(command);, +    private final class TieBreakingPrioritizedRunnable extends PrioritizedRunnable {, +        private Runnable runnable;, +        private final long insertionOrder;, +        private ScheduledFuture<?> timeoutFuture;, +            FutureUtils.cancel(timeoutFuture);, +            runAndClean(runnable);, +, +        public void scheduleTimeout(ScheduledExecutorService timer, final Runnable timeoutCallback, TimeValue timeValue) {]