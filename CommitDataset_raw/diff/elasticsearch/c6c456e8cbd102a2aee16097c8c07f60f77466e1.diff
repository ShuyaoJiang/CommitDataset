[+++ b/server/src/main/java/org/elasticsearch/index/engine/Engine.java, +import org.apache.lucene.search.ReferenceManager;, +    public Searcher acquireSearcher(String source, SearcherScope scope) throws EngineException {, +        /* Acquire order here is store -> manager since we need, +         * to make sure that the store is not closed before, +         * the searcher is acquired. */, +        if (store.tryIncRef() == false) {, +            throw new AlreadyClosedException(shardId + " store is closed", failedEngine.get());, +        }, +        Releasable releasable = store::decRef;, +        try {, +            EngineSearcher engineSearcher = new EngineSearcher(source, getReferenceManager(scope), store, logger);, +            releasable = null; // success - hand over the reference to the engine searcher, +            return engineSearcher;, +        } catch (AlreadyClosedException ex) {, +            throw ex;, +        } catch (Exception ex) {, +            maybeFailEngine("acquire_searcher", ex);, +            ensureOpen(ex); // throw EngineCloseException here if we are already closed, +            logger.error(() -> new ParameterizedMessage("failed to acquire searcher, source {}", source), ex);, +            throw new EngineException(shardId, "failed to acquire searcher, source " + source, ex);, +        } finally {, +            Releasables.close(releasable);, +        }, +    }, +, +    protected abstract ReferenceManager<IndexSearcher> getReferenceManager(SearcherScope scope);, +++ b/server/src/main/java/org/elasticsearch/index/engine/Engine.java, +import org.apache.lucene.search.ReferenceManager;, +    public Searcher acquireSearcher(String source, SearcherScope scope) throws EngineException {, +        /* Acquire order here is store -> manager since we need, +         * to make sure that the store is not closed before, +         * the searcher is acquired. */, +        if (store.tryIncRef() == false) {, +            throw new AlreadyClosedException(shardId + " store is closed", failedEngine.get());, +        }, +        Releasable releasable = store::decRef;, +        try {, +            EngineSearcher engineSearcher = new EngineSearcher(source, getReferenceManager(scope), store, logger);, +            releasable = null; // success - hand over the reference to the engine searcher, +            return engineSearcher;, +        } catch (AlreadyClosedException ex) {, +            throw ex;, +        } catch (Exception ex) {, +            maybeFailEngine("acquire_searcher", ex);, +            ensureOpen(ex); // throw EngineCloseException here if we are already closed, +            logger.error(() -> new ParameterizedMessage("failed to acquire searcher, source {}", source), ex);, +            throw new EngineException(shardId, "failed to acquire searcher, source " + source, ex);, +        } finally {, +            Releasables.close(releasable);, +        }, +    }, +, +    protected abstract ReferenceManager<IndexSearcher> getReferenceManager(SearcherScope scope);, +++ b/server/src/main/java/org/elasticsearch/index/engine/InternalEngine.java, +                    ReferenceManager<IndexSearcher> referenceManager = getReferenceManager(scope);, +                    // it is intentional that we never refresh both internal / external together, +                    referenceManager.maybeRefreshBlocking();, +    protected final ReferenceManager<IndexSearcher> getReferenceManager(SearcherScope scope) {, +                return internalSearcherManager;, +                return externalSearcherManager;, +++ b/server/src/main/java/org/elasticsearch/index/engine/Engine.java, +import org.apache.lucene.search.ReferenceManager;, +    public Searcher acquireSearcher(String source, SearcherScope scope) throws EngineException {, +        /* Acquire order here is store -> manager since we need, +         * to make sure that the store is not closed before, +         * the searcher is acquired. */, +        if (store.tryIncRef() == false) {, +            throw new AlreadyClosedException(shardId + " store is closed", failedEngine.get());, +        }, +        Releasable releasable = store::decRef;, +        try {, +            EngineSearcher engineSearcher = new EngineSearcher(source, getReferenceManager(scope), store, logger);, +            releasable = null; // success - hand over the reference to the engine searcher, +            return engineSearcher;, +        } catch (AlreadyClosedException ex) {, +            throw ex;, +        } catch (Exception ex) {, +            maybeFailEngine("acquire_searcher", ex);, +            ensureOpen(ex); // throw EngineCloseException here if we are already closed, +            logger.error(() -> new ParameterizedMessage("failed to acquire searcher, source {}", source), ex);, +            throw new EngineException(shardId, "failed to acquire searcher, source " + source, ex);, +        } finally {, +            Releasables.close(releasable);, +        }, +    }, +, +    protected abstract ReferenceManager<IndexSearcher> getReferenceManager(SearcherScope scope);, +++ b/server/src/main/java/org/elasticsearch/index/engine/InternalEngine.java, +                    ReferenceManager<IndexSearcher> referenceManager = getReferenceManager(scope);, +                    // it is intentional that we never refresh both internal / external together, +                    referenceManager.maybeRefreshBlocking();, +    protected final ReferenceManager<IndexSearcher> getReferenceManager(SearcherScope scope) {, +                return internalSearcherManager;, +                return externalSearcherManager;, +++ b/server/src/main/java/org/elasticsearch/repositories/blobstore/BlobStoreRepository.java, +            if (Lucene.isCorruptionException(e)) {]