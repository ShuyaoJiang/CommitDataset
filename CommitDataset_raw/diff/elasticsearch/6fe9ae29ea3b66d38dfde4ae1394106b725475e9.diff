[+++ b/core/src/main/java/org/elasticsearch/action/admin/cluster/allocation/TransportClusterAllocationExplainAction.java, +                    storeStatus, shard.currentNodeId(), indexMetaData.inSyncAllocationIds(shard.getId()),, +++ b/core/src/main/java/org/elasticsearch/action/admin/cluster/allocation/TransportClusterAllocationExplainAction.java, +                    storeStatus, shard.currentNodeId(), indexMetaData.inSyncAllocationIds(shard.getId()),, +++ b/core/src/main/java/org/elasticsearch/action/support/replication/ReplicationOperation.java, +import org.elasticsearch.cluster.metadata.IndexMetaData;, +import org.elasticsearch.cluster.routing.AllocationId;, +import org.elasticsearch.common.util.set.Sets;, +import java.util.Objects;, +import java.util.Set;, +import java.util.stream.Collectors;, +    private final AtomicInteger pendingActions = new AtomicInteger();, +        pendingActions.incrementAndGet();, +        // we have to get a new state after successfully indexing into the primary in order to honour recovery semantics., +        // we have to make sure that every operation indexed into the primary after recovery start will also be replicated, +        // to the recovery target. If we use an old cluster state, we may miss a relocation that has started since then., +        ClusterState clusterState = clusterStateSupplier.get();, +        final List<ShardRouting> shards = getShards(primaryId, clusterState);, +        Set<String> inSyncAllocationIds = getInSyncAllocationIds(primaryId, clusterState);, +, +        markUnavailableShardsAsStale(replicaRequest, inSyncAllocationIds, shards);, +, +        performOnReplicas(replicaRequest, shards);, +    private void markUnavailableShardsAsStale(ReplicaRequest replicaRequest, Set<String> inSyncAllocationIds, List<ShardRouting> shards) {, +        if (inSyncAllocationIds.isEmpty() == false && shards.isEmpty() == false) {, +            Set<String> availableAllocationIds = shards.stream(), +                .map(ShardRouting::allocationId), +                .filter(Objects::nonNull), +                .map(AllocationId::getId), +                .collect(Collectors.toSet());, +, +            // if inSyncAllocationIds contains allocation ids of shards that don't exist in RoutingTable, mark copies as stale, +            for (String allocationId : Sets.difference(inSyncAllocationIds, availableAllocationIds)) {, +                // mark copy as stale, +                pendingActions.incrementAndGet();, +                replicasProxy.markShardCopyAsStale(replicaRequest.shardId(), allocationId, replicaRequest.primaryTerm(),, +                    ReplicationOperation.this::decPendingAndFinishIfNeeded,, +                    ReplicationOperation.this::onPrimaryDemoted,, +                    throwable -> decPendingAndFinishIfNeeded(), +                );, +            }, +        }, +    }, +, +    private void performOnReplicas(ReplicaRequest replicaRequest, List<ShardRouting> shards) {, +        // If the index gets deleted after primary operation, we skip replication, +        pendingActions.incrementAndGet();, +    protected Set<String> getInSyncAllocationIds(ShardId shardId, ClusterState clusterState) {, +        IndexMetaData indexMetaData = clusterState.metaData().index(shardId.getIndex());, +        if (indexMetaData != null) {, +            return indexMetaData.inSyncAllocationIds(shardId.id());, +        }, +        return Collections.emptySet();, +    }, +, +        assert pendingActions.get() > 0;, +        if (pendingActions.decrementAndGet() == 0) {, +, +        /**, +         * Marks shard copy as stale, removing its allocation id from the set of in-sync allocation ids., +         *, +         * @param shardId          shard id, +         * @param allocationId     allocation id to remove from the set of in-sync allocation ids, +         * @param primaryTerm      the primary term of the primary shard when requesting the failure, +         * @param onSuccess        a callback to call when the allocation id has been successfully removed from the in-sync set., +         * @param onPrimaryDemoted a callback to call when the request failed because the current primary was already demoted, +         *                         by the master., +         * @param onIgnoredFailure a callback to call when the request failed, but the failure can be safely ignored., +         */, +        void markShardCopyAsStale(ShardId shardId, String allocationId, long primaryTerm, Runnable onSuccess,, +                                  Consumer<Exception> onPrimaryDemoted, Consumer<Exception> onIgnoredFailure);, +++ b/core/src/main/java/org/elasticsearch/action/admin/cluster/allocation/TransportClusterAllocationExplainAction.java, +                    storeStatus, shard.currentNodeId(), indexMetaData.inSyncAllocationIds(shard.getId()),, +++ b/core/src/main/java/org/elasticsearch/action/support/replication/ReplicationOperation.java, +import org.elasticsearch.cluster.metadata.IndexMetaData;, +import org.elasticsearch.cluster.routing.AllocationId;, +import org.elasticsearch.common.util.set.Sets;, +import java.util.Objects;, +import java.util.Set;, +import java.util.stream.Collectors;, +    private final AtomicInteger pendingActions = new AtomicInteger();, +        pendingActions.incrementAndGet();, +        // we have to get a new state after successfully indexing into the primary in order to honour recovery semantics., +        // we have to make sure that every operation indexed into the primary after recovery start will also be replicated, +        // to the recovery target. If we use an old cluster state, we may miss a relocation that has started since then., +        ClusterState clusterState = clusterStateSupplier.get();, +        final List<ShardRouting> shards = getShards(primaryId, clusterState);, +        Set<String> inSyncAllocationIds = getInSyncAllocationIds(primaryId, clusterState);, +, +        markUnavailableShardsAsStale(replicaRequest, inSyncAllocationIds, shards);, +, +        performOnReplicas(replicaRequest, shards);, +    private void markUnavailableShardsAsStale(ReplicaRequest replicaRequest, Set<String> inSyncAllocationIds, List<ShardRouting> shards) {, +        if (inSyncAllocationIds.isEmpty() == false && shards.isEmpty() == false) {, +            Set<String> availableAllocationIds = shards.stream(), +                .map(ShardRouting::allocationId), +                .filter(Objects::nonNull), +                .map(AllocationId::getId), +                .collect(Collectors.toSet());, +]