[+++ b/core/src/main/java/org/elasticsearch/index/mapper/core/StringFieldMapper.java, +import org.elasticsearch.common.logging.DeprecationLogger;, +import org.elasticsearch.common.logging.ESLogger;, +import org.elasticsearch.common.logging.Loggers;, +import java.util.Arrays;, +import java.util.HashSet;, +import java.util.Set;, +    private static final Set<String> SUPPORTED_PARAMETERS_FOR_AUTO_UPGRADE = new HashSet<>(Arrays.asList(, +            "type",, +            // most common parameters, for which the upgrade is straightforward, +            "index", "store", "doc_values", "omit_norms", "norms", "fields", "copy_to"));, +, +        private final DeprecationLogger deprecationLogger;, +, +        public TypeParser() {, +            ESLogger logger = Loggers.getLogger(getClass());, +            this.deprecationLogger = new DeprecationLogger(logger);, +        }, +, +            if (parserContext.indexVersionCreated().onOrAfter(Version.V_5_0_0)) {, +                // Automatically upgrade simple mappings for ease of upgrade, otherwise fail, +                if (SUPPORTED_PARAMETERS_FOR_AUTO_UPGRADE.containsAll(node.keySet())) {, +                    deprecationLogger.deprecated("The [string] field is deprecated, please use [text] or [keyword] instead on [{}]",, +                            fieldName);, +                    final Object index = node.remove("index");, +                    final boolean keyword = index != null && "analyzed".equals(index) == false;, +                    // upgrade the index setting, +                    node.put("index", "no".equals(index) == false);, +                    if (keyword) {, +                        return new KeywordFieldMapper.TypeParser().parse(fieldName, node, parserContext);, +                    } else {, +                        return new TextFieldMapper.TypeParser().parse(fieldName, node, parserContext);, +                    }, +                }, +            }, +        if (Version.indexCreated(indexSettings).onOrAfter(Version.V_5_0_0)) {, +        }, +++ b/core/src/main/java/org/elasticsearch/index/mapper/core/StringFieldMapper.java, +import org.elasticsearch.common.logging.DeprecationLogger;, +import org.elasticsearch.common.logging.ESLogger;, +import org.elasticsearch.common.logging.Loggers;, +import java.util.Arrays;, +import java.util.HashSet;, +import java.util.Set;, +    private static final Set<String> SUPPORTED_PARAMETERS_FOR_AUTO_UPGRADE = new HashSet<>(Arrays.asList(, +            "type",, +            // most common parameters, for which the upgrade is straightforward, +            "index", "store", "doc_values", "omit_norms", "norms", "fields", "copy_to"));, +, +        private final DeprecationLogger deprecationLogger;, +, +        public TypeParser() {, +            ESLogger logger = Loggers.getLogger(getClass());, +            this.deprecationLogger = new DeprecationLogger(logger);, +        }, +, +            if (parserContext.indexVersionCreated().onOrAfter(Version.V_5_0_0)) {, +                // Automatically upgrade simple mappings for ease of upgrade, otherwise fail, +                if (SUPPORTED_PARAMETERS_FOR_AUTO_UPGRADE.containsAll(node.keySet())) {, +                    deprecationLogger.deprecated("The [string] field is deprecated, please use [text] or [keyword] instead on [{}]",, +                            fieldName);, +                    final Object index = node.remove("index");, +                    final boolean keyword = index != null && "analyzed".equals(index) == false;, +                    // upgrade the index setting, +                    node.put("index", "no".equals(index) == false);, +                    if (keyword) {, +                        return new KeywordFieldMapper.TypeParser().parse(fieldName, node, parserContext);, +                    } else {, +                        return new TextFieldMapper.TypeParser().parse(fieldName, node, parserContext);, +                    }, +                }, +            }, +        if (Version.indexCreated(indexSettings).onOrAfter(Version.V_5_0_0)) {, +        }, +++ b/core/src/main/java/org/elasticsearch/index/mapper/core/TypeParsers.java, +import org.elasticsearch.common.logging.DeprecationLogger;, +import org.elasticsearch.common.logging.Loggers;, +import java.util.Arrays;, +import java.util.HashSet;, +import java.util.Set;, +    private static final DeprecationLogger DEPRECATION_LOGGER = new DeprecationLogger(Loggers.getLogger(TypeParsers.class));, +    private static final Set<String> BOOLEAN_STRINGS = new HashSet<>(Arrays.asList("true", "false"));, +, +    private static boolean nodeBooleanValue(String name, Object node, Mapper.TypeParser.ParserContext parserContext) {, +        // Hook onto ParseFieldMatcher so that parsing becomes strict when setting index.query.parse.strict, +        if (parserContext.parseFieldMatcher().isStrict()) {, +            // TODO: remove this leniency in 6.0, +            if (BOOLEAN_STRINGS.contains(node.toString()) == false) {, +                DEPRECATION_LOGGER.deprecated("Expected a boolean for property [{}] but got [{}]", name, node);, +            }, +                builder.ignoreMalformed(nodeBooleanValue("ignore_malformed", propNode, parserContext));, +                builder.coerce(nodeBooleanValue("coerce", propNode, parserContext));, +                builder.omitNorms(nodeBooleanValue("omit_norms", propNode, parserContext));, +                builder.storeTermVectors(nodeBooleanValue("store_term_vectors", propNode, parserContext));, +                builder.storeTermVectorOffsets(nodeBooleanValue("store_term_vector_offsets", propNode, parserContext));, +                builder.storeTermVectorPositions(nodeBooleanValue("store_term_vector_positions", propNode, parserContext));, +                builder.storeTermVectorPayloads(nodeBooleanValue("store_term_vector_payloads", propNode, parserContext));, +                builder.docValues(nodeBooleanValue(DOC_VALUES, propNode, parserContext));, +                builder.omitNorms(nodeBooleanValue("omit_norms", propNode, parserContext));, +                builder.includeInAll(nodeBooleanValue("include_in_all", propNode, parserContext));]