[+++ b/x-pack/plugin/security/src/test/java/org/elasticsearch/test/SecurityIntegTestCase.java, +import org.junit.ClassRule;, +    /**, +     * A JUnit class level rule that runs after the AfterClass method in {@link ESIntegTestCase},, +     * which stops the cluster. After the cluster is stopped, there are a few netty threads that, +     * can linger, so we wait for them to finish otherwise these lingering threads can intermittently, +     * trigger the thread leak detector, +     */, +    @ClassRule, +    public static final ExternalResource STOP_NETTY_RESOURCE = new ExternalResource() {, +        @Override, +        protected void after() {, +            try {, +                GlobalEventExecutor.INSTANCE.awaitInactivity(5, TimeUnit.SECONDS);, +            } catch (InterruptedException e) {, +                Thread.currentThread().interrupt();, +            } catch (IllegalStateException e) {, +                if (e.getMessage().equals("thread was not started") == false) {, +                    throw e;, +                }, +                // ignore since the thread was never started, +            }, +, +            try {, +                ThreadDeathWatcher.awaitInactivity(5, TimeUnit.SECONDS);, +            } catch (InterruptedException e) {, +                Thread.currentThread().interrupt();, +            }, +        }, +    };, +, +++ b/x-pack/plugin/security/src/test/java/org/elasticsearch/test/SecurityIntegTestCase.java, +import org.junit.ClassRule;, +    /**, +     * A JUnit class level rule that runs after the AfterClass method in {@link ESIntegTestCase},, +     * which stops the cluster. After the cluster is stopped, there are a few netty threads that, +     * can linger, so we wait for them to finish otherwise these lingering threads can intermittently, +     * trigger the thread leak detector, +     */, +    @ClassRule, +    public static final ExternalResource STOP_NETTY_RESOURCE = new ExternalResource() {, +        @Override, +        protected void after() {, +            try {, +                GlobalEventExecutor.INSTANCE.awaitInactivity(5, TimeUnit.SECONDS);, +            } catch (InterruptedException e) {, +                Thread.currentThread().interrupt();, +            } catch (IllegalStateException e) {, +                if (e.getMessage().equals("thread was not started") == false) {, +                    throw e;, +                }, +                // ignore since the thread was never started, +            }, +, +            try {, +                ThreadDeathWatcher.awaitInactivity(5, TimeUnit.SECONDS);, +            } catch (InterruptedException e) {, +                Thread.currentThread().interrupt();, +            }, +        }, +    };, +, +++ b/x-pack/plugin/security/src/test/java/org/elasticsearch/test/SecuritySingleNodeTestCase.java, +import org.junit.ClassRule;, +    }, +    @Rule, +    //Rules are the only way to have something run before the before (final) method inherited from ESSingleNodeTestCase, +    public ExternalResource externalResource = new ExternalResource() {, +        @Override, +        protected void before() {, +            if (customSecuritySettingsSource == null) {, +                customSecuritySettingsSource =, +                        new CustomSecuritySettingsSource(transportSSLEnabled(), createTempDir(), ESIntegTestCase.Scope.SUITE);, +            }, +        }, +    };, +, +    /**, +     * A JUnit class level rule that runs after the AfterClass method in {@link ESIntegTestCase},, +     * which stops the cluster. After the cluster is stopped, there are a few netty threads that, +     * can linger, so we wait for them to finish otherwise these lingering threads can intermittently, +     * trigger the thread leak detector, +     */, +    @ClassRule, +    public static final ExternalResource STOP_NETTY_RESOURCE = new ExternalResource() {, +        @Override, +        protected void after() {]