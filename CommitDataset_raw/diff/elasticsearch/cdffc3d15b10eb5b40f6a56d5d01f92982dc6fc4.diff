[+++ b/client/src/main/java/org/elasticsearch/client/Connection.java, +++ b/client/src/main/java/org/elasticsearch/client/Connection.java, +++ /dev/null, +++ b/client/src/main/java/org/elasticsearch/client/Connection.java, +++ /dev/null, +++ b/client/src/main/java/org/elasticsearch/client/RestClient.java, +import java.util.ArrayList;, +import java.util.Collections;, +import java.util.Comparator;, +import java.util.List;, +import java.util.Objects;, +import java.util.concurrent.atomic.AtomicInteger;, +    private final AtomicInteger lastConnectionIndex = new AtomicInteger(0);, +    private volatile List<Connection> connections;, +    private volatile FailureListener failureListener = new FailureListener();, +    private RestClient(CloseableHttpClient client, long maxRetryTimeout, HttpHost... hosts) {, +        setNodes(hosts);, +    }, +, +    public synchronized void setNodes(HttpHost... hosts) {, +        List<Connection> connections = new ArrayList<>(hosts.length);, +        for (HttpHost host : hosts) {, +            Objects.requireNonNull(host, "host cannot be null");, +            connections.add(new Connection(host));, +        }, +        this.connections = Collections.unmodifiableList(connections);, +        Iterator<Connection> connectionIterator = nextConnection();, +                request.reset();, +                onFailure(connection);, +                onSuccess(connection);, +                    onFailure(connection);, +                    onSuccess(connection);, +    /**, +     * Returns an iterator of connections that should be used for a request call., +     * Ideally, the first connection is retrieved from the iterator and used successfully for the request., +     * Otherwise, after each failure the next connection should be retrieved from the iterator so that the request can be retried., +     * The maximum total of attempts is equal to the number of connections that are available in the iterator., +     * The iterator returned will never be empty, rather an {@link IllegalStateException} will be thrown in that case., +     * In case there are no alive connections available, or dead ones that should be retried, one dead connection, +     * gets resurrected and returned., +     */, +    private Iterator<Connection> nextConnection() {, +        if (this.connections.isEmpty()) {, +            throw new IllegalStateException("no connections available in the connection pool");, +        }, +, +        List<Connection> rotatedConnections = new ArrayList<>(connections);, +        //TODO is it possible to make this O(1)? (rotate is O(n)), +        Collections.rotate(rotatedConnections, rotatedConnections.size() - lastConnectionIndex.getAndIncrement());, +        Iterator<Connection> connectionIterator = rotatedConnections.iterator();, +        while (connectionIterator.hasNext()) {, +            Connection connection = connectionIterator.next();, +            if (connection.isAlive() == false && connection.shouldBeRetried() == false) {, +                connectionIterator.remove();, +            }, +        }, +        if (rotatedConnections.isEmpty()) {, +            List<Connection> sortedConnections = new ArrayList<>(connections);, +            Collections.sort(sortedConnections, new Comparator<Connection>() {, +                @Override, +                public int compare(Connection o1, Connection o2) {, +                    return Long.compare(o1.getDeadUntil(), o2.getDeadUntil());, +                }, +            });, +            Connection connection = sortedConnections.get(0);, +            connection.markResurrected();, +            logger.trace("marked connection resurrected for " + connection.getHost());, +            return Collections.singleton(connection).iterator();, +        }, +        return rotatedConnections.iterator();, +    }, +, +    /**, +     * Called after each successful request call., +     * Receives as an argument the connection that was used for the successful request., +     */, +    public void onSuccess(Connection connection) {, +        connection.markAlive();, +        logger.trace("marked connection alive for " + connection.getHost());, +    }, +, +    /**, +     * Called after each failed attempt., +     * Receives as an argument the connection that was used for the failed attempt., +     */, +    private void onFailure(Connection connection) throws IOException {, +        connection.markDead();, +        logger.debug("marked connection dead for " + connection.getHost());, +        failureListener.onFailure(connection);, +    }, +, +    public synchronized void setFailureListener(FailureListener failureListener) {, +        this.failureListener = failureListener;, +    }, +, +    @Override, +    public void close() throws IOException {, +        client.close();, +    }, +]