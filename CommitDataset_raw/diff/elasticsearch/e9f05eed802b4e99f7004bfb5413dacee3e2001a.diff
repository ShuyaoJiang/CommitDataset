[+++ b/src/main/java/org/elasticsearch/search/aggregations/metrics/MetricsAggregator.java, +        this(name, estimatedBucketsCount, BucketAggregationMode.MULTI_BUCKETS, context, parent);, +    }, +    , +    protected MetricsAggregator(String name, long estimatedBucketsCount, BucketAggregationMode bucketAggregationMode, AggregationContext context, Aggregator parent) {, +        super(name, bucketAggregationMode, AggregatorFactories.EMPTY, estimatedBucketsCount, context, parent);, +++ b/src/main/java/org/elasticsearch/search/aggregations/metrics/MetricsAggregator.java, +        this(name, estimatedBucketsCount, BucketAggregationMode.MULTI_BUCKETS, context, parent);, +    }, +    , +    protected MetricsAggregator(String name, long estimatedBucketsCount, BucketAggregationMode bucketAggregationMode, AggregationContext context, Aggregator parent) {, +        super(name, bucketAggregationMode, AggregatorFactories.EMPTY, estimatedBucketsCount, context, parent);, +++ b/src/main/java/org/elasticsearch/search/aggregations/metrics/scripted/ScriptedMetricAggregator.java, +import org.elasticsearch.search.SearchParseException;, +import org.elasticsearch.search.internal.SearchContext;, +import java.util.*;, +import java.util.Map.Entry;, +        super(name, 1, BucketAggregationMode.PER_BUCKET, context, parent);, +            this.params = new HashMap<>(params);, +            Map<String, Object> params = null;, +            if (this.params != null) {, +                params = deepCopyParams(this.params, context.searchContext());, +            }, +            Map<String, Object> reduceParams = null;, +            if (this.reduceParams != null) {, +                reduceParams = deepCopyParams(this.reduceParams, context.searchContext());, +            }, +        @SuppressWarnings({ "unchecked" }), +        private static <T> T deepCopyParams(T original, SearchContext context) {, +            T clone;, +            if (original instanceof Map) {, +                Map<?, ?> originalMap = (Map<?, ?>) original;, +                Map<Object, Object> clonedMap = new HashMap<>();, +                for (Entry<?, ?> e : originalMap.entrySet()) {, +                    clonedMap.put(deepCopyParams(e.getKey(), context), deepCopyParams(e.getValue(), context));, +                }, +                clone = (T) clonedMap;, +            } else if (original instanceof List) {, +                List<?> originalList = (List<?>) original;, +                List<Object> clonedList = new ArrayList<Object>();, +                for (Object o : originalList) {, +                    clonedList.add(deepCopyParams(o, context));, +                }, +                clone = (T) clonedList;, +            } else if (original instanceof String || original instanceof Integer || original instanceof Long || original instanceof Short, +                    || original instanceof Byte || original instanceof Float || original instanceof Double || original instanceof Character, +                    || original instanceof Boolean) {, +                clone = original;, +            } else {, +                throw new SearchParseException(context, "Can only clone primitives, String, ArrayList, and HashMap. Found: ", +                        + original.getClass().getCanonicalName());, +            }, +            return clone;, +        }, +, +++ b/src/main/java/org/elasticsearch/search/aggregations/metrics/MetricsAggregator.java, +        this(name, estimatedBucketsCount, BucketAggregationMode.MULTI_BUCKETS, context, parent);, +    }, +    , +    protected MetricsAggregator(String name, long estimatedBucketsCount, BucketAggregationMode bucketAggregationMode, AggregationContext context, Aggregator parent) {, +        super(name, bucketAggregationMode, AggregatorFactories.EMPTY, estimatedBucketsCount, context, parent);, +++ b/src/main/java/org/elasticsearch/search/aggregations/metrics/scripted/ScriptedMetricAggregator.java, +import org.elasticsearch.search.SearchParseException;, +import org.elasticsearch.search.internal.SearchContext;, +import java.util.*;, +import java.util.Map.Entry;, +        super(name, 1, BucketAggregationMode.PER_BUCKET, context, parent);, +            this.params = new HashMap<>(params);, +            Map<String, Object> params = null;, +            if (this.params != null) {, +                params = deepCopyParams(this.params, context.searchContext());, +            }, +            Map<String, Object> reduceParams = null;, +            if (this.reduceParams != null) {, +                reduceParams = deepCopyParams(this.reduceParams, context.searchContext());, +            }, +        @SuppressWarnings({ "unchecked" }), +        private static <T> T deepCopyParams(T original, SearchContext context) {, +            T clone;, +            if (original instanceof Map) {, +                Map<?, ?> originalMap = (Map<?, ?>) original;, +                Map<Object, Object> clonedMap = new HashMap<>();, +                for (Entry<?, ?> e : originalMap.entrySet()) {, +                    clonedMap.put(deepCopyParams(e.getKey(), context), deepCopyParams(e.getValue(), context));, +                }, +                clone = (T) clonedMap;, +            } else if (original instanceof List) {, +                List<?> originalList = (List<?>) original;, +                List<Object> clonedList = new ArrayList<Object>();, +                for (Object o : originalList) {, +                    clonedList.add(deepCopyParams(o, context));, +                }, +                clone = (T) clonedList;, +            } else if (original instanceof String || original instanceof Integer || original instanceof Long || original instanceof Short, +                    || original instanceof Byte || original instanceof Float || original instanceof Double || original instanceof Character, +                    || original instanceof Boolean) {, +                clone = original;, +            } else {, +                throw new SearchParseException(context, "Can only clone primitives, String, ArrayList, and HashMap. Found: ", +                        + original.getClass().getCanonicalName());]