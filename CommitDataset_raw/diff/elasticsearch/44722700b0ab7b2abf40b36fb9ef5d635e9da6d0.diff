[+++ b/core/src/main/java/org/elasticsearch/action/admin/indices/create/TransportCreateIndexAction.java, +        final String indexName = indexNameExpressionResolver.resolveDateMathExpression(request.index());, +        final CreateIndexClusterStateUpdateRequest updateRequest = new CreateIndexClusterStateUpdateRequest(request, cause, indexName, request.updateAllTypes()), +++ b/core/src/main/java/org/elasticsearch/action/admin/indices/create/TransportCreateIndexAction.java, +        final String indexName = indexNameExpressionResolver.resolveDateMathExpression(request.index());, +        final CreateIndexClusterStateUpdateRequest updateRequest = new CreateIndexClusterStateUpdateRequest(request, cause, indexName, request.updateAllTypes()), +++ b/core/src/main/java/org/elasticsearch/action/termvectors/TransportShardMultiTermsVectorAction.java, +                TermVectorsResponse termVectorsResponse = indexShard.getTermVectors(termVectorsRequest);, +++ b/core/src/main/java/org/elasticsearch/action/admin/indices/create/TransportCreateIndexAction.java, +        final String indexName = indexNameExpressionResolver.resolveDateMathExpression(request.index());, +        final CreateIndexClusterStateUpdateRequest updateRequest = new CreateIndexClusterStateUpdateRequest(request, cause, indexName, request.updateAllTypes()), +++ b/core/src/main/java/org/elasticsearch/action/termvectors/TransportShardMultiTermsVectorAction.java, +                TermVectorsResponse termVectorsResponse = indexShard.getTermVectors(termVectorsRequest);, +++ b/core/src/main/java/org/elasticsearch/action/termvectors/TransportTermVectorsAction.java, +        TermVectorsResponse response = indexShard.getTermVectors(request);, +++ b/core/src/main/java/org/elasticsearch/action/admin/indices/create/TransportCreateIndexAction.java, +        final String indexName = indexNameExpressionResolver.resolveDateMathExpression(request.index());, +        final CreateIndexClusterStateUpdateRequest updateRequest = new CreateIndexClusterStateUpdateRequest(request, cause, indexName, request.updateAllTypes()), +++ b/core/src/main/java/org/elasticsearch/action/termvectors/TransportShardMultiTermsVectorAction.java, +                TermVectorsResponse termVectorsResponse = indexShard.getTermVectors(termVectorsRequest);, +++ b/core/src/main/java/org/elasticsearch/action/termvectors/TransportTermVectorsAction.java, +        TermVectorsResponse response = indexShard.getTermVectors(request);, +++ b/core/src/main/java/org/elasticsearch/cluster/metadata/IndexNameExpressionResolver.java, +     * @return If the specified string is data math expression then this method returns the resolved expression., +     */, +    public String resolveDateMathExpression(String dateExpression) {, +        // The data math expression resolver doesn't rely on cluster state or indices options, because, +        // it just resolves the date math to an actual date., +        return dateMathExpressionResolver.resolveExpression(dateExpression, new Context(null, null));, +    }, +, +    /**, +++ b/core/src/main/java/org/elasticsearch/action/admin/indices/create/TransportCreateIndexAction.java, +        final String indexName = indexNameExpressionResolver.resolveDateMathExpression(request.index());, +        final CreateIndexClusterStateUpdateRequest updateRequest = new CreateIndexClusterStateUpdateRequest(request, cause, indexName, request.updateAllTypes()), +++ b/core/src/main/java/org/elasticsearch/action/termvectors/TransportShardMultiTermsVectorAction.java, +                TermVectorsResponse termVectorsResponse = indexShard.getTermVectors(termVectorsRequest);, +++ b/core/src/main/java/org/elasticsearch/action/termvectors/TransportTermVectorsAction.java, +        TermVectorsResponse response = indexShard.getTermVectors(request);, +++ b/core/src/main/java/org/elasticsearch/cluster/metadata/IndexNameExpressionResolver.java, +     * @return If the specified string is data math expression then this method returns the resolved expression., +     */, +    public String resolveDateMathExpression(String dateExpression) {, +        // The data math expression resolver doesn't rely on cluster state or indices options, because, +        // it just resolves the date math to an actual date., +        return dateMathExpressionResolver.resolveExpression(dateExpression, new Context(null, null));, +    }, +, +    /**, +++ b/core/src/main/java/org/elasticsearch/common/Strings.java, +++ b/core/src/main/java/org/elasticsearch/action/admin/indices/create/TransportCreateIndexAction.java, +        final String indexName = indexNameExpressionResolver.resolveDateMathExpression(request.index());, +        final CreateIndexClusterStateUpdateRequest updateRequest = new CreateIndexClusterStateUpdateRequest(request, cause, indexName, request.updateAllTypes()), +++ b/core/src/main/java/org/elasticsearch/action/termvectors/TransportShardMultiTermsVectorAction.java, +                TermVectorsResponse termVectorsResponse = indexShard.getTermVectors(termVectorsRequest);, +++ b/core/src/main/java/org/elasticsearch/action/termvectors/TransportTermVectorsAction.java, +        TermVectorsResponse response = indexShard.getTermVectors(request);, +++ b/core/src/main/java/org/elasticsearch/cluster/metadata/IndexNameExpressionResolver.java, +     * @return If the specified string is data math expression then this method returns the resolved expression., +     */, +    public String resolveDateMathExpression(String dateExpression) {, +        // The data math expression resolver doesn't rely on cluster state or indices options, because, +        // it just resolves the date math to an actual date., +        return dateMathExpressionResolver.resolveExpression(dateExpression, new Context(null, null));, +    }, +, +    /**, +++ b/core/src/main/java/org/elasticsearch/common/Strings.java, +++ b/core/src/main/java/org/elasticsearch/common/path/PathTrie.java, +import java.util.ArrayList;, +import java.util.List;, +                params.put(node.namedWildcard(), value);, +        String[] strings = splitPath(decoder.decode(path));, +, +    /*, +      Splits up the url path up by '/' and is aware of, +      index name expressions that appear between '<' and '>'., +     */, +    String[] splitPath(final String path) {, +        if (path == null || path.length() == 0) {, +            return Strings.EMPTY_ARRAY;, +        }, +        int count = 1;, +        boolean splitAllowed = true;, +        for (int i = 0; i < path.length(); i++) {, +            final char currentC = path.charAt(i);, +            if ('<' == currentC) {, +                splitAllowed = false;, +            } else if (currentC == '>') {, +                splitAllowed = true;, +            } else if (splitAllowed && currentC == separator) {, +                count++;, +            }, +        }, +, +        final List<String> result = new ArrayList<>(count);, +        final StringBuilder builder = new StringBuilder();, +, +        splitAllowed = true;, +        for (int i = 0; i < path.length(); i++) {]