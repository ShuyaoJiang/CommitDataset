[+++ b/src/main/java/org/elasticsearch/cluster/block/ClusterBlocks.java, +    public boolean hasGlobalBlock(ClusterBlockLevel level) {, +        return !global(level).isEmpty();, +    }, +, +++ b/src/main/java/org/elasticsearch/cluster/block/ClusterBlocks.java, +    public boolean hasGlobalBlock(ClusterBlockLevel level) {, +        return !global(level).isEmpty();, +    }, +, +++ b/src/main/java/org/elasticsearch/discovery/DiscoverySettings.java, +    public final static ClusterBlock NO_MASTER_BLOCK_ALL = new ClusterBlock(NO_MASTER_BLOCK_ID, "no master", true, true, RestStatus.SERVICE_UNAVAILABLE, ClusterBlockLevel.ALL);, +    public final static ClusterBlock NO_MASTER_BLOCK_WRITES = new ClusterBlock(NO_MASTER_BLOCK_ID, "no master", true, false, RestStatus.SERVICE_UNAVAILABLE, EnumSet.of(ClusterBlockLevel.WRITE, ClusterBlockLevel.METADATA));, +            return NO_MASTER_BLOCK_ALL;, +            return NO_MASTER_BLOCK_WRITES;, +++ b/src/main/java/org/elasticsearch/cluster/block/ClusterBlocks.java, +    public boolean hasGlobalBlock(ClusterBlockLevel level) {, +        return !global(level).isEmpty();, +    }, +, +++ b/src/main/java/org/elasticsearch/discovery/DiscoverySettings.java, +    public final static ClusterBlock NO_MASTER_BLOCK_ALL = new ClusterBlock(NO_MASTER_BLOCK_ID, "no master", true, true, RestStatus.SERVICE_UNAVAILABLE, ClusterBlockLevel.ALL);, +    public final static ClusterBlock NO_MASTER_BLOCK_WRITES = new ClusterBlock(NO_MASTER_BLOCK_ID, "no master", true, false, RestStatus.SERVICE_UNAVAILABLE, EnumSet.of(ClusterBlockLevel.WRITE, ClusterBlockLevel.METADATA));, +            return NO_MASTER_BLOCK_ALL;, +            return NO_MASTER_BLOCK_WRITES;, +++ b/src/test/java/org/elasticsearch/discovery/DiscoveryWithNetworkFailuresTests.java, +import org.elasticsearch.cluster.block.ClusterBlockLevel;, +import org.elasticsearch.common.Strings;, +@TestLogging("discovery.zen:TRACE"), +    /**, +     * Test that no split brain occurs under partial network partition. See https://github.com/elasticsearch/elasticsearch/issues/2488, +     *, +     * @throws Exception, +     */, +        final String masterNode = internalCluster().getMasterName();, +        logger.info("---> legit elected master node=" + masterNode);, +        Set<String> nonMasters = new HashSet<>(nodes);, +        nonMasters.remove(masterNode);, +        final String unluckyNode = randomFrom(nonMasters.toArray(Strings.EMPTY_ARRAY));, +, +        NetworkDisconnectPartition networkDisconnect = new NetworkDisconnectPartition(masterNode, unluckyNode, getRandom());, +        ensureStableCluster(2, masterNode);, +        boolean success = awaitBusy(new Predicate<Object>() {, +                ClusterState localClusterState = getNodeClusterState(unluckyNode);, +        assertThat(success, is(true));, +            ClusterState state = getNodeClusterState(node);, +            assertThat(state.nodes().masterNode().name(), equalTo(masterNode));, +    /**, +     * Verify that the proper block is applied when nodes loose their master, +     */, +        final String nonIsolatedNode = networkPartition.getMajoritySide().get(0);, +        final ClusterState[] lastState = new ClusterState[1];, +        boolean success = awaitBusy(new Predicate<Object>() {, +                lastState[0] = getNodeClusterState(isolatedNode);, +                DiscoveryNodes localDiscoveryNodes = lastState[0].nodes();, +                if (localDiscoveryNodes.masterNode() == null) {, +                    return false;, +                }, +                for (ClusterBlockLevel level : DiscoverySettings.NO_MASTER_BLOCK_WRITES.levels()) {, +                    if (lastState[0].getBlocks().hasGlobalBlock(level)) {, +                        return false;, +                    }, +                }, +                return true;, +        if (!success) {, +            fail("isolated node still has a master or the wrong blocks. Cluster state:\n" + lastState[0].prettyPrint());, +        }, +, +, +        logger.info("wait until elected master has been removed and a new 2 node cluster was from (via [{}])", isolatedNode);, +        for (String node : networkPartition.getMajoritySide()) {, +            ClusterState nodeState = getNodeClusterState(node);, +            success = true;, +            if (nodeState.nodes().getMasterNode() == null) {, +                success = false;, +            }, +            if (!nodeState.blocks().global().isEmpty()) {, +                success = false;, +            }, +            if (!success) {, +                fail("node [" + node + "] has no master or has blocks, despite of being on the right side of the partition. State dump:\n", +                        + nodeState.prettyPrint());, +            }, +        }, +, +        success = awaitBusy(new Predicate<Object>() {, +                lastState[0] = getNodeClusterState(isolatedNode);, +                DiscoveryNodes localDiscoveryNodes = lastState[0].nodes();, +                if (localDiscoveryNodes.masterNode() == null) {, +                    return false;, +                }, +                for (ClusterBlockLevel level : DiscoverySettings.NO_MASTER_BLOCK_ALL.levels()) {, +                    if (lastState[0].getBlocks().hasGlobalBlock(level)) {, +                        return false;, +                    }, +                }, +                return true;, +        if (!success) {, +            fail("isolated node still has a master or the wrong blocks (expected 'all' block). Cluster state:\n" + lastState[0].prettyPrint());, +    /**]