[+++ b/core/src/main/java/org/elasticsearch/index/snapshots/blobstore/BlobStoreIndexShardRepository.java, +++ b/core/src/main/java/org/elasticsearch/index/snapshots/blobstore/BlobStoreIndexShardRepository.java, +++ b/core/src/main/java/org/elasticsearch/index/snapshots/blobstore/BlobStoreIndexShardSnapshot.java, +++ b/core/src/main/java/org/elasticsearch/index/snapshots/blobstore/BlobStoreIndexShardRepository.java, +++ b/core/src/main/java/org/elasticsearch/index/snapshots/blobstore/BlobStoreIndexShardSnapshot.java, +++ /dev/null, +++ b/core/src/main/java/org/elasticsearch/index/snapshots/blobstore/BlobStoreIndexShardRepository.java, +++ b/core/src/main/java/org/elasticsearch/index/snapshots/blobstore/BlobStoreIndexShardSnapshot.java, +++ /dev/null, +++ b/core/src/main/java/org/elasticsearch/index/store/Store.java, +            assert metadata.writtenBy().onOrAfter(StoreFileMetaData.FIRST_LUCENE_CHECKSUM_VERSION);, +        assert metadata.writtenBy().onOrAfter(StoreFileMetaData.FIRST_LUCENE_CHECKSUM_VERSION);, +                StoreFileMetaData meta = new StoreFileMetaData(in);, +                Version maxVersion = segmentCommitInfos.getMinSegmentLuceneVersion(); // we don't know which version was used to write so we take the max version., +                        if (version.onOrAfter(StoreFileMetaData.FIRST_LUCENE_CHECKSUM_VERSION)) {, +                            throw new IllegalStateException("version must be onOrAfter: " + StoreFileMetaData.FIRST_LUCENE_CHECKSUM_VERSION + " but was: " +  version);, +                if (maxVersion == null) {, +                    maxVersion = StoreFileMetaData.FIRST_LUCENE_CHECKSUM_VERSION;, +                }, +                if (maxVersion.onOrAfter(StoreFileMetaData.FIRST_LUCENE_CHECKSUM_VERSION)) {, +                    throw new IllegalStateException("version must be onOrAfter: " + StoreFileMetaData.FIRST_LUCENE_CHECKSUM_VERSION + " but was: " +  maxVersion);, +        return IndexWriter.WRITE_LOCK_NAME.equals(name);, +++ b/core/src/main/java/org/elasticsearch/index/snapshots/blobstore/BlobStoreIndexShardRepository.java, +++ b/core/src/main/java/org/elasticsearch/index/snapshots/blobstore/BlobStoreIndexShardSnapshot.java, +++ /dev/null, +++ b/core/src/main/java/org/elasticsearch/index/store/Store.java, +            assert metadata.writtenBy().onOrAfter(StoreFileMetaData.FIRST_LUCENE_CHECKSUM_VERSION);, +        assert metadata.writtenBy().onOrAfter(StoreFileMetaData.FIRST_LUCENE_CHECKSUM_VERSION);, +                StoreFileMetaData meta = new StoreFileMetaData(in);, +                Version maxVersion = segmentCommitInfos.getMinSegmentLuceneVersion(); // we don't know which version was used to write so we take the max version., +                        if (version.onOrAfter(StoreFileMetaData.FIRST_LUCENE_CHECKSUM_VERSION)) {, +                            throw new IllegalStateException("version must be onOrAfter: " + StoreFileMetaData.FIRST_LUCENE_CHECKSUM_VERSION + " but was: " +  version);, +                if (maxVersion == null) {, +                    maxVersion = StoreFileMetaData.FIRST_LUCENE_CHECKSUM_VERSION;, +                }, +                if (maxVersion.onOrAfter(StoreFileMetaData.FIRST_LUCENE_CHECKSUM_VERSION)) {, +                    throw new IllegalStateException("version must be onOrAfter: " + StoreFileMetaData.FIRST_LUCENE_CHECKSUM_VERSION + " but was: " +  maxVersion);, +        return IndexWriter.WRITE_LOCK_NAME.equals(name);, +++ b/core/src/main/java/org/elasticsearch/index/store/StoreFileMetaData.java, +import org.elasticsearch.common.io.stream.Writeable;, +import java.util.Objects;, +public class StoreFileMetaData implements Writeable {, +    public static final Version FIRST_LUCENE_CHECKSUM_VERSION = Version.LUCENE_4_8_0;, +, +    private final String name;, +    private final long length;, +    private final String checksum;, +    private final Version writtenBy;, +    private final BytesRef hash;, +    public StoreFileMetaData(StreamInput in) throws IOException {, +        name = in.readString();, +        length = in.readVLong();, +        checksum = in.readString();, +        String versionString = in.readString();, +        assert versionString != null;, +        writtenBy = Lucene.parseVersionLenient(versionString, FIRST_LUCENE_CHECKSUM_VERSION);, +        hash = in.readBytesRef();, +        this(name, length, checksum, FIRST_LUCENE_CHECKSUM_VERSION);, +        assert writtenBy != null && writtenBy.onOrAfter(FIRST_LUCENE_CHECKSUM_VERSION) : "index version less that ", +            + FIRST_LUCENE_CHECKSUM_VERSION + " are not supported but got: " + writtenBy;, +        Objects.requireNonNull(writtenBy, "writtenBy must not be null");, +        Objects.requireNonNull(checksum, "checksum must not be null");, +     * by lucene., +    public StoreFileMetaData readFrom(StreamInput in) throws IOException {, +        return new StoreFileMetaData(in);, +        out.writeString(checksum);, +        out.writeString(writtenBy.toString());, +++ b/core/src/main/java/org/elasticsearch/index/snapshots/blobstore/BlobStoreIndexShardRepository.java, +++ b/core/src/main/java/org/elasticsearch/index/snapshots/blobstore/BlobStoreIndexShardSnapshot.java, +++ /dev/null, +++ b/core/src/main/java/org/elasticsearch/index/store/Store.java, +            assert metadata.writtenBy().onOrAfter(StoreFileMetaData.FIRST_LUCENE_CHECKSUM_VERSION);, +        assert metadata.writtenBy().onOrAfter(StoreFileMetaData.FIRST_LUCENE_CHECKSUM_VERSION);, +                StoreFileMetaData meta = new StoreFileMetaData(in);, +                Version maxVersion = segmentCommitInfos.getMinSegmentLuceneVersion(); // we don't know which version was used to write so we take the max version., +                        if (version.onOrAfter(StoreFileMetaData.FIRST_LUCENE_CHECKSUM_VERSION)) {, +                            throw new IllegalStateException("version must be onOrAfter: " + StoreFileMetaData.FIRST_LUCENE_CHECKSUM_VERSION + " but was: " +  version);, +                if (maxVersion == null) {, +                    maxVersion = StoreFileMetaData.FIRST_LUCENE_CHECKSUM_VERSION;, +                }, +                if (maxVersion.onOrAfter(StoreFileMetaData.FIRST_LUCENE_CHECKSUM_VERSION)) {, +                    throw new IllegalStateException("version must be onOrAfter: " + StoreFileMetaData.FIRST_LUCENE_CHECKSUM_VERSION + " but was: " +  maxVersion);, +        return IndexWriter.WRITE_LOCK_NAME.equals(name);, +++ b/core/src/main/java/org/elasticsearch/index/store/StoreFileMetaData.java, +import org.elasticsearch.common.io.stream.Writeable;, +import java.util.Objects;, +public class StoreFileMetaData implements Writeable {, +    public static final Version FIRST_LUCENE_CHECKSUM_VERSION = Version.LUCENE_4_8_0;, +, +    private final String name;, +    private final long length;, +    private final String checksum;, +    private final Version writtenBy;, +    private final BytesRef hash;, +    public StoreFileMetaData(StreamInput in) throws IOException {, +        name = in.readString();, +        length = in.readVLong();, +        checksum = in.readString();, +        String versionString = in.readString();, +        assert versionString != null;]