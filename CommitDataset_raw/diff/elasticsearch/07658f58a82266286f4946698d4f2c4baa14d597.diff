[+++ /dev/null, +++ /dev/null, +++ b/core/src/main/java/org/elasticsearch/common/lucene/search/function/FiltersFunctionScoreQuery.java, +import org.apache.lucene.search.FilterScorer;, +        if (needsScores == false && minScore == null) {, +        private FiltersFunctionFactorScorer functionScorer(LeafReaderContext context) throws IOException {, +            return new FiltersFunctionFactorScorer(this, subQueryScorer, scoreMode, filterFunctions, maxBoost, functions, docSets, combineFunction, needsScores);, +        }, +, +        @Override, +        public Scorer scorer(LeafReaderContext context) throws IOException {, +            Scorer scorer = functionScorer(context);, +            if (scorer != null && minScore != null) {, +                scorer = new MinScoreScorer(this, scorer, minScore);, +            }, +            return scorer;, +            Explanation expl = subQueryWeight.explain(context, doc);, +            if (!expl.isMatch()) {, +                return expl;, +                    Explanation functionExplanation = filterFunction.function.getLeafScoreFunction(context).explainScore(doc, expl);, +            if (filterExplanations.size() > 0) {, +                FiltersFunctionFactorScorer scorer = functionScorer(context);, +                int actualDoc = scorer.iterator().advance(doc);, +                double score = scorer.computeScore(doc, expl.getValue());, +                expl = combineFunction.explain(expl, factorExplanation, maxBoost);, +            }, +            if (minScore != null && minScore > expl.getValue()) {, +                expl = Explanation.noMatch("Score value is too low, expected at least " + minScore + " but got " + expl.getValue(), expl);, +            }, +            return expl;, +    static class FiltersFunctionFactorScorer extends FilterScorer {, +        private final CombineFunction scoreCombiner;, +        private final float maxBoost;, +                                            float maxBoost, LeafScoreFunction[] functions, Bits[] docSets, CombineFunction scoreCombiner, boolean needsScores) throws IOException {, +            super(scorer, w);, +            this.scoreCombiner = scoreCombiner;, +            this.maxBoost = maxBoost;, +        public float score() throws IOException {, +            int docId = docID();, +            float subQueryScore = needsScores ? super.score() : 0f;, +++ /dev/null, +++ b/core/src/main/java/org/elasticsearch/common/lucene/search/function/FiltersFunctionScoreQuery.java, +import org.apache.lucene.search.FilterScorer;, +        if (needsScores == false && minScore == null) {, +        private FiltersFunctionFactorScorer functionScorer(LeafReaderContext context) throws IOException {, +            return new FiltersFunctionFactorScorer(this, subQueryScorer, scoreMode, filterFunctions, maxBoost, functions, docSets, combineFunction, needsScores);, +        }, +, +        @Override, +        public Scorer scorer(LeafReaderContext context) throws IOException {, +            Scorer scorer = functionScorer(context);, +            if (scorer != null && minScore != null) {, +                scorer = new MinScoreScorer(this, scorer, minScore);, +            }, +            return scorer;, +            Explanation expl = subQueryWeight.explain(context, doc);, +            if (!expl.isMatch()) {, +                return expl;, +                    Explanation functionExplanation = filterFunction.function.getLeafScoreFunction(context).explainScore(doc, expl);, +            if (filterExplanations.size() > 0) {, +                FiltersFunctionFactorScorer scorer = functionScorer(context);, +                int actualDoc = scorer.iterator().advance(doc);, +                double score = scorer.computeScore(doc, expl.getValue());, +                expl = combineFunction.explain(expl, factorExplanation, maxBoost);, +            }, +            if (minScore != null && minScore > expl.getValue()) {, +                expl = Explanation.noMatch("Score value is too low, expected at least " + minScore + " but got " + expl.getValue(), expl);, +            }, +            return expl;, +    static class FiltersFunctionFactorScorer extends FilterScorer {, +        private final CombineFunction scoreCombiner;, +        private final float maxBoost;, +                                            float maxBoost, LeafScoreFunction[] functions, Bits[] docSets, CombineFunction scoreCombiner, boolean needsScores) throws IOException {, +            super(scorer, w);, +            this.scoreCombiner = scoreCombiner;, +            this.maxBoost = maxBoost;, +        public float score() throws IOException {, +            int docId = docID();, +            float subQueryScore = needsScores ? super.score() : 0f;, +++ b/core/src/main/java/org/elasticsearch/common/lucene/search/function/FunctionScoreQuery.java, +import org.apache.lucene.search.FilterScorer;, +        if (needsScores == false && minScore == null) {, +        private FunctionFactorScorer functionScorer(LeafReaderContext context) throws IOException {, +            return new FunctionFactorScorer(this, subQueryScorer, leafFunction, maxBoost, combineFunction, needsScores);, +        }, +, +        @Override, +        public Scorer scorer(LeafReaderContext context) throws IOException {, +            Scorer scorer = functionScorer(context);, +            if (scorer != null && minScore != null) {, +                scorer = new MinScoreScorer(this, scorer, minScore);, +            }, +            return scorer;, +            Explanation expl;, +                expl = combineFunction.explain(subQueryExpl, functionExplanation, maxBoost);, +                expl = subQueryExpl;, +            if (minScore != null && minScore > expl.getValue()) {, +                expl = Explanation.noMatch("Score value is too low, expected at least " + minScore + " but got " + expl.getValue(), expl);, +            }, +            return expl;]