[+++ b/core/src/main/java/org/elasticsearch/action/support/replication/ReplicationRequest.java, +++ b/core/src/main/java/org/elasticsearch/action/support/replication/ReplicationRequest.java, +++ b/core/src/main/java/org/elasticsearch/action/support/replication/TransportReplicationAction.java, +++ b/core/src/main/java/org/elasticsearch/action/support/replication/ReplicationRequest.java, +++ b/core/src/main/java/org/elasticsearch/action/support/replication/TransportReplicationAction.java, +++ b/core/src/main/java/org/elasticsearch/indices/cluster/IndicesClusterStateService.java, +    private final ConcurrentMap<ShardId, ShardRouting> failedShards = ConcurrentCollections.newConcurrentMap();, +        RoutingTable routingTable = event.state().routingTable();, +        for (Iterator<Map.Entry<ShardId, ShardRouting>> iterator = failedShards.entrySet().iterator(); iterator.hasNext(); ) {, +            Map.Entry<ShardId, ShardRouting> entry = iterator.next();, +            ShardId failedShardId = entry.getKey();, +            ShardRouting failedShardRouting = entry.getValue();, +            IndexRoutingTable indexRoutingTable = routingTable.index(failedShardId.getIndex());, +            if (indexRoutingTable == null) {, +                continue;, +            }, +            IndexShardRoutingTable shardRoutingTable = indexRoutingTable.shard(failedShardId.id());, +            if (shardRoutingTable == null) {, +                iterator.remove();, +                continue;, +            }, +            if (shardRoutingTable.assignedShards().stream().noneMatch(shr -> shr.isSameAllocation(failedShardRouting))) {, +                iterator.remove();, +            }, +            failedShards.put(shardRouting.shardId(), shardRouting);, +++ b/core/src/main/java/org/elasticsearch/action/support/replication/ReplicationRequest.java, +++ b/core/src/main/java/org/elasticsearch/action/support/replication/TransportReplicationAction.java, +++ b/core/src/main/java/org/elasticsearch/indices/cluster/IndicesClusterStateService.java, +    private final ConcurrentMap<ShardId, ShardRouting> failedShards = ConcurrentCollections.newConcurrentMap();, +        RoutingTable routingTable = event.state().routingTable();, +        for (Iterator<Map.Entry<ShardId, ShardRouting>> iterator = failedShards.entrySet().iterator(); iterator.hasNext(); ) {, +            Map.Entry<ShardId, ShardRouting> entry = iterator.next();, +            ShardId failedShardId = entry.getKey();, +            ShardRouting failedShardRouting = entry.getValue();, +            IndexRoutingTable indexRoutingTable = routingTable.index(failedShardId.getIndex());, +            if (indexRoutingTable == null) {, +                continue;, +            }, +            IndexShardRoutingTable shardRoutingTable = indexRoutingTable.shard(failedShardId.id());, +            if (shardRoutingTable == null) {, +                iterator.remove();, +                continue;, +            }, +            if (shardRoutingTable.assignedShards().stream().noneMatch(shr -> shr.isSameAllocation(failedShardRouting))) {, +                iterator.remove();, +            }, +            failedShards.put(shardRouting.shardId(), shardRouting);, +++ b/core/src/test/java/org/elasticsearch/action/support/replication/TransportReplicationActionTests.java]