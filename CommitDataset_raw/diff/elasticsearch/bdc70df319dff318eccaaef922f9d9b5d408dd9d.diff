[+++ b/core/src/main/java/org/elasticsearch/search/aggregations/bucket/filters/FiltersAggregatorBuilder.java, +import org.elasticsearch.search.aggregations.AggregatorFactory;, +import java.util.Collections;, +        // internally we want to have a fixed order of filters, regardless of the order of the filters in the request, +        this.filters = new ArrayList<>(filters);, +        Collections.sort(this.filters, (KeyedFilter kf1, KeyedFilter kf2) -> kf1.key().compareTo(kf2.key()));, +     * Get the filters. This will be an unmodifiable list, +     */, +    public List<KeyedFilter> filters() {, +        return Collections.unmodifiableList(this.filters);, +    }, +, +    /**, +++ b/core/src/main/java/org/elasticsearch/search/aggregations/bucket/filters/FiltersAggregatorBuilder.java, +import org.elasticsearch.search.aggregations.AggregatorFactory;, +import java.util.Collections;, +        // internally we want to have a fixed order of filters, regardless of the order of the filters in the request, +        this.filters = new ArrayList<>(filters);, +        Collections.sort(this.filters, (KeyedFilter kf1, KeyedFilter kf2) -> kf1.key().compareTo(kf2.key()));, +     * Get the filters. This will be an unmodifiable list, +     */, +    public List<KeyedFilter> filters() {, +        return Collections.unmodifiableList(this.filters);, +    }, +, +    /**, +++ b/core/src/main/java/org/elasticsearch/search/aggregations/metrics/tophits/TopHitsAggregatorBuilder.java, +import java.util.HashSet;, +import java.util.Set;, +    private Set<ScriptField> scriptFields;, +            scriptFields = new HashSet<>();, +            this.scriptFields = new HashSet<>();, +    public Set<ScriptField> scriptFields() {, +            Set<ScriptField> scriptFields = new HashSet<>(size);, +++ b/core/src/main/java/org/elasticsearch/search/aggregations/bucket/filters/FiltersAggregatorBuilder.java, +import org.elasticsearch.search.aggregations.AggregatorFactory;, +import java.util.Collections;, +        // internally we want to have a fixed order of filters, regardless of the order of the filters in the request, +        this.filters = new ArrayList<>(filters);, +        Collections.sort(this.filters, (KeyedFilter kf1, KeyedFilter kf2) -> kf1.key().compareTo(kf2.key()));, +     * Get the filters. This will be an unmodifiable list, +     */, +    public List<KeyedFilter> filters() {, +        return Collections.unmodifiableList(this.filters);, +    }, +, +    /**, +++ b/core/src/main/java/org/elasticsearch/search/aggregations/metrics/tophits/TopHitsAggregatorBuilder.java, +import java.util.HashSet;, +import java.util.Set;, +    private Set<ScriptField> scriptFields;, +            scriptFields = new HashSet<>();, +            this.scriptFields = new HashSet<>();, +    public Set<ScriptField> scriptFields() {, +            Set<ScriptField> scriptFields = new HashSet<>(size);, +++ b/core/src/main/java/org/elasticsearch/search/aggregations/metrics/tophits/TopHitsAggregatorFactory.java, +import java.util.Set;, +    private final Set<ScriptField> scriptFields;, +            Set<ScriptField> scriptFields, FetchSourceContext fetchSourceContext, AggregationContext context, AggregatorFactory<?> parent,, +++ b/core/src/main/java/org/elasticsearch/search/aggregations/bucket/filters/FiltersAggregatorBuilder.java, +import org.elasticsearch.search.aggregations.AggregatorFactory;, +import java.util.Collections;, +        // internally we want to have a fixed order of filters, regardless of the order of the filters in the request, +        this.filters = new ArrayList<>(filters);, +        Collections.sort(this.filters, (KeyedFilter kf1, KeyedFilter kf2) -> kf1.key().compareTo(kf2.key()));, +     * Get the filters. This will be an unmodifiable list, +     */, +    public List<KeyedFilter> filters() {, +        return Collections.unmodifiableList(this.filters);, +    }, +, +    /**, +++ b/core/src/main/java/org/elasticsearch/search/aggregations/metrics/tophits/TopHitsAggregatorBuilder.java, +import java.util.HashSet;, +import java.util.Set;, +    private Set<ScriptField> scriptFields;, +            scriptFields = new HashSet<>();, +            this.scriptFields = new HashSet<>();, +    public Set<ScriptField> scriptFields() {, +            Set<ScriptField> scriptFields = new HashSet<>(size);, +++ b/core/src/main/java/org/elasticsearch/search/aggregations/metrics/tophits/TopHitsAggregatorFactory.java, +import java.util.Set;, +    private final Set<ScriptField> scriptFields;, +            Set<ScriptField> scriptFields, FetchSourceContext fetchSourceContext, AggregationContext context, AggregatorFactory<?> parent,, +++ b/core/src/main/java/org/elasticsearch/search/aggregations/pipeline/PipelineAggregatorBuilder.java, +    protected final String name;, +    protected final String type;, +    protected final String[] bucketsPaths;, +++ b/core/src/main/java/org/elasticsearch/search/aggregations/bucket/filters/FiltersAggregatorBuilder.java, +import org.elasticsearch.search.aggregations.AggregatorFactory;, +import java.util.Collections;, +        // internally we want to have a fixed order of filters, regardless of the order of the filters in the request, +        this.filters = new ArrayList<>(filters);, +        Collections.sort(this.filters, (KeyedFilter kf1, KeyedFilter kf2) -> kf1.key().compareTo(kf2.key()));, +     * Get the filters. This will be an unmodifiable list, +     */, +    public List<KeyedFilter> filters() {, +        return Collections.unmodifiableList(this.filters);, +    }, +]