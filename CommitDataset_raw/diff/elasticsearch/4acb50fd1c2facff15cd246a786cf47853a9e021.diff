[+++ b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ml/datafeed/DatafeedConfig.java, +import org.apache.logging.log4j.LogManager;, +import org.apache.logging.log4j.Logger;, +import org.elasticsearch.index.query.MatchAllQueryBuilder;, +        } catch (Exception exception) {, +                exception = (Exception)exception.getCause();, +            throw ExceptionsHelper.badRequestException(Messages.getMessage(Messages.DATAFEED_CONFIG_QUERY_BAD_FORMAT, id), exception);, +        } catch (Exception exception) {, +                exception = (Exception)exception.getCause();, +            throw ExceptionsHelper.badRequestException(Messages.getMessage(Messages.DATAFEED_CONFIG_AGG_BAD_FORMAT, id), exception);, +    private static final Logger logger = LogManager.getLogger(DatafeedConfig.class);, +, +        parser.declareObject((builder, val) -> builder.setQuery(val, ignoreUnknownFields), (p, c) -> p.mapOrdered(), QUERY);, +        parser.declareObject((builder, val) -> builder.setAggregationsSafe(val, ignoreUnknownFields), (p, c) -> p.mapOrdered(),, +            AGGREGATIONS);, +        parser.declareObject((builder, val) -> builder.setAggregationsSafe(val, ignoreUnknownFields), (p, c) -> p.mapOrdered(),, +            AGGS);, +        private Map<String, Object> query = Collections.singletonMap(MatchAllQueryBuilder.NAME, Collections.emptyMap());, +        public Builder() { }, +            setQuery(query, true);, +        public void setQuery(Map<String, Object> query, boolean lenient) {, +            this.query = ExceptionsHelper.requireNonNull(query, QUERY.getPreferredName());, +            try {, +                QUERY_TRANSFORMER.fromMap(query);, +            } catch(Exception ex) {, +                String msg = Messages.getMessage(Messages.DATAFEED_CONFIG_QUERY_BAD_FORMAT, id);, +, +                if (ex.getCause() instanceof IllegalArgumentException) {, +                    ex = (Exception)ex.getCause();, +                }, +, +                if (lenient) {, +                    logger.warn(msg, ex);, +                } else {, +                    throw ExceptionsHelper.badRequestException(msg, ex);, +                }, +            }, +        }, +, +        // Kept for easier testing, +            } catch (Exception exception) {, +                    exception = (Exception)exception.getCause();, +                throw ExceptionsHelper.badRequestException(, +                    Messages.getMessage(Messages.DATAFEED_CONFIG_AGG_BAD_FORMAT, id), exception);, +        private void setAggregationsSafe(Map<String, Object> aggregations, boolean lenient) {, +            if (this.aggregations != null) {, +                throw ExceptionsHelper.badRequestException("Found two aggregation definitions: [aggs] and [aggregations]");, +            }, +            setAggregations(aggregations, lenient);, +        }, +, +            setAggregations(aggregations, true);, +        }, +, +        void setAggregations(Map<String, Object> aggregations, boolean lenient) {, +            try {, +                if (aggregations != null && aggregations.isEmpty()) {, +                    throw new Exception("[aggregations] are empty");, +                }, +                AGG_TRANSFORMER.fromMap(aggregations);, +            } catch (Exception ex) {, +                String msg = Messages.getMessage(Messages.DATAFEED_CONFIG_AGG_BAD_FORMAT, id);, +, +                if (ex.getCause() instanceof IllegalArgumentException) {, +                    ex = (Exception)ex.getCause();, +                }, +, +                if (lenient) {, +                    logger.warn(msg, ex);, +                } else {, +                    throw ExceptionsHelper.badRequestException(msg, ex);, +                }, +            }, +++ b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ml/datafeed/DatafeedConfig.java, +import org.apache.logging.log4j.LogManager;, +import org.apache.logging.log4j.Logger;, +import org.elasticsearch.index.query.MatchAllQueryBuilder;, +        } catch (Exception exception) {, +                exception = (Exception)exception.getCause();, +            throw ExceptionsHelper.badRequestException(Messages.getMessage(Messages.DATAFEED_CONFIG_QUERY_BAD_FORMAT, id), exception);, +        } catch (Exception exception) {, +                exception = (Exception)exception.getCause();, +            throw ExceptionsHelper.badRequestException(Messages.getMessage(Messages.DATAFEED_CONFIG_AGG_BAD_FORMAT, id), exception);, +    private static final Logger logger = LogManager.getLogger(DatafeedConfig.class);, +, +        parser.declareObject((builder, val) -> builder.setQuery(val, ignoreUnknownFields), (p, c) -> p.mapOrdered(), QUERY);, +        parser.declareObject((builder, val) -> builder.setAggregationsSafe(val, ignoreUnknownFields), (p, c) -> p.mapOrdered(),, +            AGGREGATIONS);, +        parser.declareObject((builder, val) -> builder.setAggregationsSafe(val, ignoreUnknownFields), (p, c) -> p.mapOrdered(),, +            AGGS);, +        private Map<String, Object> query = Collections.singletonMap(MatchAllQueryBuilder.NAME, Collections.emptyMap());, +        public Builder() { }, +            setQuery(query, true);, +        public void setQuery(Map<String, Object> query, boolean lenient) {, +            this.query = ExceptionsHelper.requireNonNull(query, QUERY.getPreferredName());, +            try {, +                QUERY_TRANSFORMER.fromMap(query);, +            } catch(Exception ex) {, +                String msg = Messages.getMessage(Messages.DATAFEED_CONFIG_QUERY_BAD_FORMAT, id);, +]