[+++ b/core/src/main/java/org/elasticsearch/cluster/routing/allocation/allocator/BalancedShardsAllocator.java, +import org.elasticsearch.cluster.metadata.IndexMetaData;, +                    AllocationDeciders deciders = allocation.deciders();, +                    final float[] weights = sorter.weights;, +                    for (String index : buildWeightOrderedIndices(sorter)) {, +                        IndexMetaData indexMetaData = metaData.index(index);, +, +                        // find nodes that have a shard of this index or where shards of this index are allowed to stay, +                        // move these nodes to the front of modelNodes so that we can only balance based on these nodes, +                        int relevantNodes = 0;, +                        for (int i = 0; i < modelNodes.length; i++) {, +                            ModelNode modelNode = modelNodes[i];, +                            if (modelNode.getIndex(index) != null, +                                || deciders.canAllocate(indexMetaData, routingNodes.node(modelNode.getNodeId()), allocation).type() != Type.NO) {, +                                // swap nodes at position i and relevantNodes, +                                modelNodes[i] = modelNodes[relevantNodes];, +                                modelNodes[relevantNodes] = modelNode;, +                                relevantNodes++;, +                            }, +                        }, +, +                        if (relevantNodes < 2) {, +                            continue;, +                        }, +, +                        sorter.reset(index, 0, relevantNodes);, +                        int highIdx = relevantNodes - 1;, +                                    sorter.sort(0, relevantNodes);, +                                    highIdx = relevantNodes - 1;, +        public void reset(String index, int from, int to) {, +            for (int i = from; i < to; i++) {, +            sort(from, to);, +        }, +, +        public void reset(String index) {, +            reset(index, 0, modelNodes.length);, +++ b/core/src/main/java/org/elasticsearch/cluster/routing/allocation/allocator/BalancedShardsAllocator.java, +import org.elasticsearch.cluster.metadata.IndexMetaData;, +                    AllocationDeciders deciders = allocation.deciders();, +                    final float[] weights = sorter.weights;, +                    for (String index : buildWeightOrderedIndices(sorter)) {, +                        IndexMetaData indexMetaData = metaData.index(index);, +, +                        // find nodes that have a shard of this index or where shards of this index are allowed to stay, +                        // move these nodes to the front of modelNodes so that we can only balance based on these nodes, +                        int relevantNodes = 0;, +                        for (int i = 0; i < modelNodes.length; i++) {, +                            ModelNode modelNode = modelNodes[i];, +                            if (modelNode.getIndex(index) != null, +                                || deciders.canAllocate(indexMetaData, routingNodes.node(modelNode.getNodeId()), allocation).type() != Type.NO) {, +                                // swap nodes at position i and relevantNodes, +                                modelNodes[i] = modelNodes[relevantNodes];, +                                modelNodes[relevantNodes] = modelNode;, +                                relevantNodes++;, +                            }, +                        }, +, +                        if (relevantNodes < 2) {, +                            continue;, +                        }, +, +                        sorter.reset(index, 0, relevantNodes);, +                        int highIdx = relevantNodes - 1;, +                                    sorter.sort(0, relevantNodes);, +                                    highIdx = relevantNodes - 1;, +        public void reset(String index, int from, int to) {, +            for (int i = from; i < to; i++) {, +            sort(from, to);, +        }, +, +        public void reset(String index) {, +            reset(index, 0, modelNodes.length);, +++ b/core/src/main/java/org/elasticsearch/cluster/routing/allocation/decider/AllocationDecider.java, +import org.elasticsearch.cluster.metadata.IndexMetaData;, +     * Returns a {@link Decision} whether the given shard routing can be allocated at all at this state of the, +     * {@link RoutingAllocation}. The default is {@link Decision#ALWAYS}., +     */, +    public Decision canAllocate(IndexMetaData indexMetaData, RoutingNode node, RoutingAllocation allocation) {, +        return Decision.ALWAYS;, +    }, +, +    /**, +++ b/core/src/main/java/org/elasticsearch/cluster/routing/allocation/allocator/BalancedShardsAllocator.java, +import org.elasticsearch.cluster.metadata.IndexMetaData;, +                    AllocationDeciders deciders = allocation.deciders();, +                    final float[] weights = sorter.weights;, +                    for (String index : buildWeightOrderedIndices(sorter)) {, +                        IndexMetaData indexMetaData = metaData.index(index);, +, +                        // find nodes that have a shard of this index or where shards of this index are allowed to stay, +                        // move these nodes to the front of modelNodes so that we can only balance based on these nodes, +                        int relevantNodes = 0;, +                        for (int i = 0; i < modelNodes.length; i++) {, +                            ModelNode modelNode = modelNodes[i];, +                            if (modelNode.getIndex(index) != null, +                                || deciders.canAllocate(indexMetaData, routingNodes.node(modelNode.getNodeId()), allocation).type() != Type.NO) {, +                                // swap nodes at position i and relevantNodes, +                                modelNodes[i] = modelNodes[relevantNodes];, +                                modelNodes[relevantNodes] = modelNode;, +                                relevantNodes++;]