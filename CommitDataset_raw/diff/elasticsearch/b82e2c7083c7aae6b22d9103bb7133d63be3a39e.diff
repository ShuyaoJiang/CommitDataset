[+++ b/src/test/java/org/elasticsearch/bwcompat/BasicBackwardsCompatibilityTest.java, +import org.elasticsearch.action.support.IndicesOptions;, +import org.elasticsearch.common.Strings;, +import org.elasticsearch.test.junit.annotations.TestLogging;, +    @TestLogging("action.search.type:TRACE,action.support.replication:TRACE,cluster.service:TRACE,indices.recovery:TRACE,index.shard.service:TRACE"), +        ArrayList<String> ids = new ArrayList<>();, +            String id = randomRealisticUnicodeOfLength(10) + String.valueOf(i);, +            ids.add(id);, +            docs[i] = client().prepareIndex("test", "type1", id).setSource("field1", English.intToEnglish(i));, +                String id = randomRealisticUnicodeOfLength(10) + String.valueOf(numDocs + i);, +                ids.add(id);, +                docs[i] = client().prepareIndex("test", "type1", id).setSource("field1", English.intToEnglish(numDocs + i));, +            if (compatibilityVersion().before(Version.V_1_3_0)) {, +                // issue another refresh through a new node to side step issue #6545, +                assertNoFailures(backwardsCluster().internalCluster().dataNodeClient().admin().indices().prepareRefresh().setIndicesOptions(IndicesOptions.lenientExpandOpen()).execute().get());, +            }, +            assertSearchHits(client().prepareSearch().setSize(ids.size()).get(), ids.toArray(new String[ids.size()]));, +    public void assertAllShardsOnNodes(String index, String pattern) {, +        ClusterState clusterState = client().admin().cluster().prepareState().execute().actionGet().getState();, +        for (IndexRoutingTable indexRoutingTable : clusterState.routingTable()) {, +            for (IndexShardRoutingTable indexShardRoutingTable : indexRoutingTable) {, +                for (ShardRouting shardRouting : indexShardRoutingTable) {, +                    if (shardRouting.currentNodeId() != null && index.equals(shardRouting.getIndex())) {, +                        String name = clusterState.nodes().get(shardRouting.currentNodeId()).name();, +                        assertThat("Allocated on new node: " + name, Regex.simpleMatch(pattern, name), is(true));, +                    }, +                }, +            }, +        }, +    }, +, +++ b/src/test/java/org/elasticsearch/bwcompat/BasicBackwardsCompatibilityTest.java, +import org.elasticsearch.action.support.IndicesOptions;, +import org.elasticsearch.common.Strings;, +import org.elasticsearch.test.junit.annotations.TestLogging;, +    @TestLogging("action.search.type:TRACE,action.support.replication:TRACE,cluster.service:TRACE,indices.recovery:TRACE,index.shard.service:TRACE"), +        ArrayList<String> ids = new ArrayList<>();, +            String id = randomRealisticUnicodeOfLength(10) + String.valueOf(i);, +            ids.add(id);, +            docs[i] = client().prepareIndex("test", "type1", id).setSource("field1", English.intToEnglish(i));, +                String id = randomRealisticUnicodeOfLength(10) + String.valueOf(numDocs + i);, +                ids.add(id);, +                docs[i] = client().prepareIndex("test", "type1", id).setSource("field1", English.intToEnglish(numDocs + i));, +            if (compatibilityVersion().before(Version.V_1_3_0)) {, +                // issue another refresh through a new node to side step issue #6545, +                assertNoFailures(backwardsCluster().internalCluster().dataNodeClient().admin().indices().prepareRefresh().setIndicesOptions(IndicesOptions.lenientExpandOpen()).execute().get());, +            }, +            assertSearchHits(client().prepareSearch().setSize(ids.size()).get(), ids.toArray(new String[ids.size()]));, +    public void assertAllShardsOnNodes(String index, String pattern) {, +        ClusterState clusterState = client().admin().cluster().prepareState().execute().actionGet().getState();, +        for (IndexRoutingTable indexRoutingTable : clusterState.routingTable()) {, +            for (IndexShardRoutingTable indexShardRoutingTable : indexRoutingTable) {, +                for (ShardRouting shardRouting : indexShardRoutingTable) {, +                    if (shardRouting.currentNodeId() != null && index.equals(shardRouting.getIndex())) {, +                        String name = clusterState.nodes().get(shardRouting.currentNodeId()).name();, +                        assertThat("Allocated on new node: " + name, Regex.simpleMatch(pattern, name), is(true));, +                    }, +                }, +            }, +        }, +    }, +, +++ b/src/test/java/org/elasticsearch/test/ElasticsearchIntegrationTest.java, +import java.util.concurrent.atomic.AtomicInteger;, +                String id = randomRealisticUnicodeOfLength(unicodeLen) + Integer.toString(dummmyDocIdGenerator.incrementAndGet());, +                bogusIds.add(new Tuple<>(index, id));, +    private AtomicInteger dummmyDocIdGenerator = new AtomicInteger();, +, +++ b/src/test/java/org/elasticsearch/bwcompat/BasicBackwardsCompatibilityTest.java, +import org.elasticsearch.action.support.IndicesOptions;, +import org.elasticsearch.common.Strings;, +import org.elasticsearch.test.junit.annotations.TestLogging;, +    @TestLogging("action.search.type:TRACE,action.support.replication:TRACE,cluster.service:TRACE,indices.recovery:TRACE,index.shard.service:TRACE"), +        ArrayList<String> ids = new ArrayList<>();, +            String id = randomRealisticUnicodeOfLength(10) + String.valueOf(i);, +            ids.add(id);, +            docs[i] = client().prepareIndex("test", "type1", id).setSource("field1", English.intToEnglish(i));, +                String id = randomRealisticUnicodeOfLength(10) + String.valueOf(numDocs + i);, +                ids.add(id);, +                docs[i] = client().prepareIndex("test", "type1", id).setSource("field1", English.intToEnglish(numDocs + i));, +            if (compatibilityVersion().before(Version.V_1_3_0)) {, +                // issue another refresh through a new node to side step issue #6545, +                assertNoFailures(backwardsCluster().internalCluster().dataNodeClient().admin().indices().prepareRefresh().setIndicesOptions(IndicesOptions.lenientExpandOpen()).execute().get());, +            }, +            assertSearchHits(client().prepareSearch().setSize(ids.size()).get(), ids.toArray(new String[ids.size()]));, +    public void assertAllShardsOnNodes(String index, String pattern) {, +        ClusterState clusterState = client().admin().cluster().prepareState().execute().actionGet().getState();, +        for (IndexRoutingTable indexRoutingTable : clusterState.routingTable()) {, +            for (IndexShardRoutingTable indexShardRoutingTable : indexRoutingTable) {, +                for (ShardRouting shardRouting : indexShardRoutingTable) {, +                    if (shardRouting.currentNodeId() != null && index.equals(shardRouting.getIndex())) {, +                        String name = clusterState.nodes().get(shardRouting.currentNodeId()).name();, +                        assertThat("Allocated on new node: " + name, Regex.simpleMatch(pattern, name), is(true));, +                    }, +                }, +            }, +        }, +    }, +, +++ b/src/test/java/org/elasticsearch/test/ElasticsearchIntegrationTest.java]