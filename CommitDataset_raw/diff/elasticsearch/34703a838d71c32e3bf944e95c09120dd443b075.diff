[+++ b/core/src/main/java/org/elasticsearch/index/translog/Translog.java, +                final Checkpoint checkpoint = readCheckpoint();, +        } catch (AlreadyClosedException | IOException ex) {, +            if (current.getTragicException() != null) {, +                try {, +                    close();, +                } catch (Exception inner) {, +                    ex.addSuppressed(inner);, +                }, +            }, +            throw ex;, +    /** Reads and returns the current checkpoint */, +    final Checkpoint readCheckpoint() throws IOException {, +        return Checkpoint.read(location.resolve(CHECKPOINT_FILE_NAME));, +    }, +, +++ b/core/src/main/java/org/elasticsearch/index/translog/Translog.java, +                final Checkpoint checkpoint = readCheckpoint();, +        } catch (AlreadyClosedException | IOException ex) {, +            if (current.getTragicException() != null) {, +                try {, +                    close();, +                } catch (Exception inner) {, +                    ex.addSuppressed(inner);, +                }, +            }, +            throw ex;, +    /** Reads and returns the current checkpoint */, +    final Checkpoint readCheckpoint() throws IOException {, +        return Checkpoint.read(location.resolve(CHECKPOINT_FILE_NAME));, +    }, +, +++ b/core/src/test/java/org/elasticsearch/index/translog/TranslogTests.java, +import org.apache.lucene.store.MockDirectoryWrapper;, +import java.util.function.Predicate;, +        private final Collection<LocationOperation> writtenOperations;, +        public TranslogThread(Translog translog, CountDownLatch downLatch, int opsPerThread, int threadId, Collection<LocationOperation> writtenOperations, Throwable[] threadExceptions) {, +                    Translog.Location loc = add(op);, +                    afterAdd();, +, +        protected Translog.Location add(Translog.Operation op) throws IOException {, +            return translog.add(op);, +        }, +, +        protected void afterAdd() throws IOException {}, +        final AtomicBoolean fail = new AtomicBoolean();, +        Translog translog = getFailableTranslog(fail, config);, +            fail.set(randomBoolean());, +        fail.set(false);, +, +    public void testFatalIOExceptionsWhileWritingConcurrently() throws IOException, InterruptedException {, +        Path tempDir = createTempDir();, +        final AtomicBoolean fail = new AtomicBoolean(false);, +, +        TranslogConfig config = getTranslogConfig(tempDir);, +        Translog translog = getFailableTranslog(fail, config);, +, +        final int threadCount = randomIntBetween(1, 5);, +        Thread[] threads = new Thread[threadCount];, +        final Throwable[] threadExceptions = new Throwable[threadCount];, +        final CountDownLatch downLatch = new CountDownLatch(1);, +        final CountDownLatch added = new CountDownLatch(randomIntBetween(10, 100));, +        List<LocationOperation> writtenOperations = Collections.synchronizedList(new ArrayList<>());, +        for (int i = 0; i < threadCount; i++) {, +            final int threadId = i;, +            threads[i] = new TranslogThread(translog, downLatch, 200, threadId, writtenOperations, threadExceptions) {, +                @Override, +                protected Translog.Location add(Translog.Operation op) throws IOException {, +                    Translog.Location add = super.add(op);, +                    added.countDown();, +                    return add;, +                }, +, +                @Override, +                protected void afterAdd() throws IOException {, +                    if (randomBoolean()) {, +                        translog.sync();, +                    }, +                }, +            };, +            threads[i].setDaemon(true);, +            threads[i].start();, +        }, +        downLatch.countDown();, +        added.await();, +        try (Translog.View view = translog.newView()) {, +            // this holds a reference to the current tlog channel such that it's not closed, +            // if we hit a tragic event. this is important to ensure that asserts inside the Translog#add doesn't trip, +            // otherwise our assertions here are off by one sometimes., +            fail.set(true);, +            for (int i = 0; i < threadCount; i++) {, +                threads[i].join();, +            }, +            Collections.sort(writtenOperations, (a, b) -> a.location.compareTo(b.location));, +            assertFalse(translog.isOpen());, +            final Checkpoint checkpoint = Checkpoint.read(config.getTranslogPath().resolve(Translog.CHECKPOINT_FILE_NAME));, +            Iterator<LocationOperation> iterator = writtenOperations.iterator();, +            while (iterator.hasNext()) {, +                LocationOperation next = iterator.next();, +                if (checkpoint.offset < (next.location.translogLocation + next.location.size)) {]