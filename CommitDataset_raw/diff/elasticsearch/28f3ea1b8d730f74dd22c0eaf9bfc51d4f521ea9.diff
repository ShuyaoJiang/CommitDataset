[+++ b/src/test/java/org/elasticsearch/index/search/child/AbstractChildTests.java, +import org.elasticsearch.common.xcontent.XContentHelper;, +import org.elasticsearch.common.xcontent.XContentParser;, +import org.elasticsearch.index.Index;, +import org.elasticsearch.index.query.QueryBuilder;, +import org.elasticsearch.index.query.QueryParseContext;, +        // Parent/child parsers require that the parent and child type to be presented in mapping, +        // Sometimes we want a nested object field in the parent type that triggers nonNestedDocsFilter to be used, +        mapperService.merge(parentType, new CompressedString(PutMappingRequest.buildFromSimplifiedDef(parentType, "nested_field", random().nextBoolean() ? "type=nested" : "type=object").string()), true);, +    static BitDocIdSetFilter wrapWithBitSetFilter(Filter filter) {, +    static Query parseQuery(QueryBuilder queryBuilder) throws IOException {, +        QueryParseContext context = new QueryParseContext(new Index("test"), SearchContext.current().queryParserService());, +        XContentParser parser = XContentHelper.createParser(queryBuilder.buildAsBytes());, +        context.reset(parser);, +        return context.parseInnerQuery();, +    }, +, +++ b/src/test/java/org/elasticsearch/index/search/child/AbstractChildTests.java, +import org.elasticsearch.common.xcontent.XContentHelper;, +import org.elasticsearch.common.xcontent.XContentParser;, +import org.elasticsearch.index.Index;, +import org.elasticsearch.index.query.QueryBuilder;, +import org.elasticsearch.index.query.QueryParseContext;, +        // Parent/child parsers require that the parent and child type to be presented in mapping, +        // Sometimes we want a nested object field in the parent type that triggers nonNestedDocsFilter to be used, +        mapperService.merge(parentType, new CompressedString(PutMappingRequest.buildFromSimplifiedDef(parentType, "nested_field", random().nextBoolean() ? "type=nested" : "type=object").string()), true);, +    static BitDocIdSetFilter wrapWithBitSetFilter(Filter filter) {, +    static Query parseQuery(QueryBuilder queryBuilder) throws IOException {, +        QueryParseContext context = new QueryParseContext(new Index("test"), SearchContext.current().queryParserService());, +        XContentParser parser = XContentHelper.createParser(queryBuilder.buildAsBytes());, +        context.reset(parser);, +        return context.parseInnerQuery();, +    }, +, +++ b/src/test/java/org/elasticsearch/index/search/child/ChildrenConstantScoreQueryTests.java, +import org.apache.lucene.index.*;, +import org.elasticsearch.index.query.QueryBuilder;, +import static org.elasticsearch.index.query.FilterBuilders.*;, +import static org.elasticsearch.index.query.QueryBuilders.*;, +        BitDocIdSetFilter parentFilter = wrapWithBitSetFilter(new TermFilter(new Term(TypeFieldMapper.NAME, "parent")));, +        Query query = new ChildrenConstantScoreQuery(parentChildIndexFieldData, childQuery, "parent", "child", parentFilter, 12, wrapWithBitSetFilter(NonNestedDocsFilter.INSTANCE));, +        BitDocIdSetFilter parentFilter = wrapWithBitSetFilter(new TermFilter(new Term(TypeFieldMapper.NAME, "parent")));, +                document.add(new StringField(UidFieldMapper.NAME, Uid.createUid("child", Integer.toString(childDocId++)), Field.Store.NO));, +            QueryBuilder queryBuilder;, +                queryBuilder = hasChildQuery("child", termQuery("field1", childValue)), +                        .setShortCircuitCutoff(shortCircuitParentDocSet);, +                queryBuilder = constantScoreQuery(, +                        hasChildFilter("child", termQuery("field1", childValue)), +                                .setShortCircuitCutoff(shortCircuitParentDocSet), +            // Using a FQ, will invoke / test the Scorer#advance(..) and also let the Weight#scorer not get live docs as acceptedDocs, +            queryBuilder = filteredQuery(queryBuilder, notFilter(termFilter("filter", "me")));, +            Query query = parseQuery(queryBuilder);, +, +++ b/src/test/java/org/elasticsearch/index/search/child/AbstractChildTests.java, +import org.elasticsearch.common.xcontent.XContentHelper;, +import org.elasticsearch.common.xcontent.XContentParser;, +import org.elasticsearch.index.Index;, +import org.elasticsearch.index.query.QueryBuilder;, +import org.elasticsearch.index.query.QueryParseContext;, +        // Parent/child parsers require that the parent and child type to be presented in mapping, +        // Sometimes we want a nested object field in the parent type that triggers nonNestedDocsFilter to be used, +        mapperService.merge(parentType, new CompressedString(PutMappingRequest.buildFromSimplifiedDef(parentType, "nested_field", random().nextBoolean() ? "type=nested" : "type=object").string()), true);, +    static BitDocIdSetFilter wrapWithBitSetFilter(Filter filter) {, +    static Query parseQuery(QueryBuilder queryBuilder) throws IOException {, +        QueryParseContext context = new QueryParseContext(new Index("test"), SearchContext.current().queryParserService());, +        XContentParser parser = XContentHelper.createParser(queryBuilder.buildAsBytes());, +        context.reset(parser);, +        return context.parseInnerQuery();, +    }, +, +++ b/src/test/java/org/elasticsearch/index/search/child/ChildrenConstantScoreQueryTests.java, +import org.apache.lucene.index.*;, +import org.elasticsearch.index.query.QueryBuilder;, +import static org.elasticsearch.index.query.FilterBuilders.*;, +import static org.elasticsearch.index.query.QueryBuilders.*;, +        BitDocIdSetFilter parentFilter = wrapWithBitSetFilter(new TermFilter(new Term(TypeFieldMapper.NAME, "parent")));, +        Query query = new ChildrenConstantScoreQuery(parentChildIndexFieldData, childQuery, "parent", "child", parentFilter, 12, wrapWithBitSetFilter(NonNestedDocsFilter.INSTANCE));, +        BitDocIdSetFilter parentFilter = wrapWithBitSetFilter(new TermFilter(new Term(TypeFieldMapper.NAME, "parent")));, +                document.add(new StringField(UidFieldMapper.NAME, Uid.createUid("child", Integer.toString(childDocId++)), Field.Store.NO));, +            QueryBuilder queryBuilder;, +                queryBuilder = hasChildQuery("child", termQuery("field1", childValue)), +                        .setShortCircuitCutoff(shortCircuitParentDocSet);, +                queryBuilder = constantScoreQuery(, +                        hasChildFilter("child", termQuery("field1", childValue)), +                                .setShortCircuitCutoff(shortCircuitParentDocSet), +            // Using a FQ, will invoke / test the Scorer#advance(..) and also let the Weight#scorer not get live docs as acceptedDocs, +            queryBuilder = filteredQuery(queryBuilder, notFilter(termFilter("filter", "me")));, +            Query query = parseQuery(queryBuilder);, +, +++ b/src/test/java/org/elasticsearch/index/search/child/ChildrenQueryTests.java, +import org.elasticsearch.index.query.QueryBuilder;, +import org.elasticsearch.index.query.functionscore.fieldvaluefactor.FieldValueFactorFunctionBuilder;, +import java.util.*;, +import static org.elasticsearch.index.query.FilterBuilders.*;, +import static org.elasticsearch.index.query.QueryBuilders.*;, +        BitDocIdSetFilter parentFilter = wrapWithBitSetFilter(new TermFilter(new Term(TypeFieldMapper.NAME, "parent")));, +                maxChildren, 12, wrapWithBitSetFilter(NonNestedDocsFilter.INSTANCE));, +            QueryBuilder queryBuilder = hasChildQuery("child", constantScoreQuery(termQuery("field1", childValue))), +                    .scoreType(scoreType.name().toLowerCase(Locale.ENGLISH)), +                    .minChildren(minChildren)]