[+++ b/core/src/main/java/org/elasticsearch/cluster/metadata/MetaDataCreateIndexService.java, +import org.elasticsearch.index.mapper.MapperService.MergeReason;, +                                mapperService.merge(mappings, MergeReason.MAPPING_UPDATE, request.updateAllTypes());, +                            } catch (Exception e) {, +                                throw e;, +++ b/core/src/main/java/org/elasticsearch/cluster/metadata/MetaDataCreateIndexService.java, +import org.elasticsearch.index.mapper.MapperService.MergeReason;, +                                mapperService.merge(mappings, MergeReason.MAPPING_UPDATE, request.updateAllTypes());, +                            } catch (Exception e) {, +                                throw e;, +++ b/core/src/main/java/org/elasticsearch/cluster/metadata/MetaDataIndexAliasesService.java, +                                    indicesToClose.add(index.getIndex());, +                                indexService.mapperService().merge(index, MapperService.MergeReason.MAPPING_RECOVERY, false);, +++ b/core/src/main/java/org/elasticsearch/cluster/metadata/MetaDataCreateIndexService.java, +import org.elasticsearch.index.mapper.MapperService.MergeReason;, +                                mapperService.merge(mappings, MergeReason.MAPPING_UPDATE, request.updateAllTypes());, +                            } catch (Exception e) {, +                                throw e;, +++ b/core/src/main/java/org/elasticsearch/cluster/metadata/MetaDataIndexAliasesService.java, +                                    indicesToClose.add(index.getIndex());, +                                indexService.mapperService().merge(index, MapperService.MergeReason.MAPPING_RECOVERY, false);, +++ b/core/src/main/java/org/elasticsearch/cluster/metadata/MetaDataIndexTemplateService.java, +import org.elasticsearch.index.mapper.MapperService.MergeReason;, +            dummyIndexService.mapperService().merge(mappingsForValidation, MergeReason.MAPPING_UPDATE, false);, +++ b/core/src/main/java/org/elasticsearch/cluster/metadata/MetaDataCreateIndexService.java, +import org.elasticsearch.index.mapper.MapperService.MergeReason;, +                                mapperService.merge(mappings, MergeReason.MAPPING_UPDATE, request.updateAllTypes());, +                            } catch (Exception e) {, +                                throw e;, +++ b/core/src/main/java/org/elasticsearch/cluster/metadata/MetaDataIndexAliasesService.java, +                                    indicesToClose.add(index.getIndex());, +                                indexService.mapperService().merge(index, MapperService.MergeReason.MAPPING_RECOVERY, false);, +++ b/core/src/main/java/org/elasticsearch/cluster/metadata/MetaDataIndexTemplateService.java, +import org.elasticsearch.index.mapper.MapperService.MergeReason;, +            dummyIndexService.mapperService().merge(mappingsForValidation, MergeReason.MAPPING_UPDATE, false);, +++ b/core/src/main/java/org/elasticsearch/cluster/metadata/MetaDataIndexUpgradeService.java, +                mapperService.merge(indexMetaData, MapperService.MergeReason.MAPPING_RECOVERY, false);, +++ b/core/src/main/java/org/elasticsearch/cluster/metadata/MetaDataCreateIndexService.java, +import org.elasticsearch.index.mapper.MapperService.MergeReason;, +                                mapperService.merge(mappings, MergeReason.MAPPING_UPDATE, request.updateAllTypes());, +                            } catch (Exception e) {, +                                throw e;, +++ b/core/src/main/java/org/elasticsearch/cluster/metadata/MetaDataIndexAliasesService.java, +                                    indicesToClose.add(index.getIndex());, +                                indexService.mapperService().merge(index, MapperService.MergeReason.MAPPING_RECOVERY, false);, +++ b/core/src/main/java/org/elasticsearch/cluster/metadata/MetaDataIndexTemplateService.java, +import org.elasticsearch.index.mapper.MapperService.MergeReason;, +            dummyIndexService.mapperService().merge(mappingsForValidation, MergeReason.MAPPING_UPDATE, false);, +++ b/core/src/main/java/org/elasticsearch/cluster/metadata/MetaDataIndexUpgradeService.java, +                mapperService.merge(indexMetaData, MapperService.MergeReason.MAPPING_RECOVERY, false);, +++ b/core/src/main/java/org/elasticsearch/cluster/metadata/MetaDataMappingService.java, +import org.elasticsearch.index.mapper.MapperService.MergeReason;, +                indexService.mapperService().merge(indexMetaData, MergeReason.MAPPING_RECOVERY, true);, +                                mapperService.merge(indexMetaData, MergeReason.MAPPING_RECOVERY, request.updateAllTypes());, +                DocumentMapper mergedMapper = mapperService.merge(mappingType, mappingUpdateSource, MergeReason.MAPPING_UPDATE, request.updateAllTypes());, +++ b/core/src/main/java/org/elasticsearch/cluster/metadata/MetaDataCreateIndexService.java, +import org.elasticsearch.index.mapper.MapperService.MergeReason;, +                                mapperService.merge(mappings, MergeReason.MAPPING_UPDATE, request.updateAllTypes());, +                            } catch (Exception e) {, +                                throw e;, +++ b/core/src/main/java/org/elasticsearch/cluster/metadata/MetaDataIndexAliasesService.java, +                                    indicesToClose.add(index.getIndex());, +                                indexService.mapperService().merge(index, MapperService.MergeReason.MAPPING_RECOVERY, false);, +++ b/core/src/main/java/org/elasticsearch/cluster/metadata/MetaDataIndexTemplateService.java, +import org.elasticsearch.index.mapper.MapperService.MergeReason;, +            dummyIndexService.mapperService().merge(mappingsForValidation, MergeReason.MAPPING_UPDATE, false);, +++ b/core/src/main/java/org/elasticsearch/cluster/metadata/MetaDataIndexUpgradeService.java, +                mapperService.merge(indexMetaData, MapperService.MergeReason.MAPPING_RECOVERY, false);, +++ b/core/src/main/java/org/elasticsearch/cluster/metadata/MetaDataMappingService.java, +import org.elasticsearch.index.mapper.MapperService.MergeReason;, +                indexService.mapperService().merge(indexMetaData, MergeReason.MAPPING_RECOVERY, true);, +                                mapperService.merge(indexMetaData, MergeReason.MAPPING_RECOVERY, request.updateAllTypes());, +                DocumentMapper mergedMapper = mapperService.merge(mappingType, mappingUpdateSource, MergeReason.MAPPING_UPDATE, request.updateAllTypes());, +++ b/core/src/main/java/org/elasticsearch/index/mapper/MapperService.java, +import org.elasticsearch.common.Nullable;, +import java.util.LinkedHashMap;, +    /**, +     * Update mapping by only merging the metadata that is different between received and stored entries, +     */, +        final Set<String> existingMappers = new HashSet<>(mappers.keySet());, +        final Map<String, DocumentMapper> updatedEntries;, +        try {, +            // only update entries if needed, +            updatedEntries = internalMerge(indexMetaData, MergeReason.MAPPING_RECOVERY, true, true);, +        } catch (Exception e) {, +            logger.warn((org.apache.logging.log4j.util.Supplier<?>) () -> new ParameterizedMessage("[{}] failed to apply mappings", index()), e);, +            throw e;, +        }, +, +, +        for (DocumentMapper documentMapper : updatedEntries.values()) {, +            String mappingType = documentMapper.type();, +            CompressedXContent incomingMappingSource = indexMetaData.mapping(mappingType).source();, +, +            String op = existingMappers.contains(mappingType) ? "updated" : "added";, +            if (logger.isDebugEnabled() && incomingMappingSource.compressed().length < 512) {, +                logger.debug("[{}] {} mapping [{}], source [{}]", index(), op, mappingType, incomingMappingSource.string());, +            } else if (logger.isTraceEnabled()) {, +                logger.trace("[{}] {} mapping [{}], source [{}]", index(), op, mappingType, incomingMappingSource.string());, +            } else {]