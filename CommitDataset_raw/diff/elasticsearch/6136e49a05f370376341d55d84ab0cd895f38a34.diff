[+++ b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/analysis/analyzer/Verifier.java, +     * 2. the ORDER BY/HAVING might contain a non-grouped attribute. This is typically, +     * 2a. HAVING also requires an Aggregate function, +                // variation of checkGroupMatch customized for HAVING, which requires just aggregations, +                condition.collectFirstChildren(c -> checkGroupByHavingHasOnlyAggs(c, condition, missing, functions));, +                    localFailures.add(, +                            fail(condition, "Cannot filter HAVING on non-aggregate" + plural + " %s; consider using WHERE instead",, +                            Expressions.names(missing.keySet())));, +    private static boolean checkGroupByHavingHasOnlyAggs(Expression e, Node<?> source,, +            Map<Expression, Node<?>> missing, Map<String, Function> functions) {, +, +        // resolve FunctionAttribute to backing functions, +        if (e instanceof FunctionAttribute) {, +            FunctionAttribute fa = (FunctionAttribute) e;, +            Function function = functions.get(fa.functionId());, +            // TODO: this should be handled by a different rule, +            if (function == null) {, +                return false;, +            }, +            e = function;, +        }, +, +        // scalar functions can be a binary tree, +        // first test the function against the grouping, +        // and if that fails, start unpacking hoping to find matches, +        if (e instanceof ScalarFunction) {, +            ScalarFunction sf = (ScalarFunction) e;, +, +            // unwrap function to find the base, +            for (Expression arg : sf.arguments()) {, +                arg.collectFirstChildren(c -> checkGroupByHavingHasOnlyAggs(c, source, missing, functions));, +            }, +            return true;, +, +        } else if (e instanceof Score) {, +            // Score can't be used for having, +            missing.put(e, source);, +            return true;, +        }, +, +        // skip literals / foldable, +        if (e.foldable()) {, +            return true;, +        }, +        // skip aggs (allowed to refer to non-group columns), +        if (Functions.isAggregate(e)) {, +            return true;, +        }, +, +        // left without leaves which have to match; that's a failure since everything should be based on an agg, +        if (e instanceof Attribute) {, +            missing.put(e, source);, +            return true;, +        }, +, +        return false;, +    }, +, +, +++ b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/analysis/analyzer/Verifier.java, +     * 2. the ORDER BY/HAVING might contain a non-grouped attribute. This is typically, +     * 2a. HAVING also requires an Aggregate function, +                // variation of checkGroupMatch customized for HAVING, which requires just aggregations, +                condition.collectFirstChildren(c -> checkGroupByHavingHasOnlyAggs(c, condition, missing, functions));, +                    localFailures.add(, +                            fail(condition, "Cannot filter HAVING on non-aggregate" + plural + " %s; consider using WHERE instead",, +                            Expressions.names(missing.keySet())));, +    private static boolean checkGroupByHavingHasOnlyAggs(Expression e, Node<?> source,, +            Map<Expression, Node<?>> missing, Map<String, Function> functions) {, +, +        // resolve FunctionAttribute to backing functions, +        if (e instanceof FunctionAttribute) {, +            FunctionAttribute fa = (FunctionAttribute) e;, +            Function function = functions.get(fa.functionId());, +            // TODO: this should be handled by a different rule, +            if (function == null) {, +                return false;, +            }, +            e = function;, +        }, +, +        // scalar functions can be a binary tree, +        // first test the function against the grouping, +        // and if that fails, start unpacking hoping to find matches, +        if (e instanceof ScalarFunction) {, +            ScalarFunction sf = (ScalarFunction) e;, +, +            // unwrap function to find the base, +            for (Expression arg : sf.arguments()) {, +                arg.collectFirstChildren(c -> checkGroupByHavingHasOnlyAggs(c, source, missing, functions));, +            }, +            return true;, +, +        } else if (e instanceof Score) {, +            // Score can't be used for having, +            missing.put(e, source);, +            return true;, +        }, +, +        // skip literals / foldable]