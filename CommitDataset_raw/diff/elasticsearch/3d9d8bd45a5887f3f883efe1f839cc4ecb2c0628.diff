[+++ b/core/src/main/java/org/elasticsearch/indices/memory/IndexingMemoryController.java, +import org.elasticsearch.index.shard.ShardId;, +, +    protected List<ShardId> availableShards() {, +        ArrayList<ShardId> list = new ArrayList<>();, +            for (IndexShard indexShard : indexService) {, +                if (shardAvailable(indexShard)) {, +                    list.add(indexShard.shardId());, +        return list;, +    }, +, +    /** returns true if shard exists and is availabe for updates */, +    protected boolean shardAvailable(ShardId shardId) {, +        return shardAvailable(getShard(shardId));, +    /** gets an {@link IndexShard} instance for the given shard. returns null if the shard doesn't exist */, +    protected IndexShard getShard(ShardId shardId) {, +        IndexService indexService = indicesService.indexService(shardId.index().name());, +        if (indexService != null) {, +            IndexShard indexShard = indexService.getShardOrNull(shardId.id());, +            return indexShard;, +        }, +        return null;, +    }, +, +    protected void updateShardBuffers(ShardId shardId, ByteSizeValue shardIndexingBufferSize, ByteSizeValue shardTranslogBufferSize) {, +        final IndexShard shard = getShard(shardId);, +                logger.warn("failed to set shard {} index buffer to [{}]", e, shardId, shardIndexingBufferSize);, +    /** returns {@link IndexShard#getActive} if the shard exists, else null */, +    protected Boolean getShardActive(ShardId shardId) {, +        final IndexShard indexShard = getShard(shardId);, +        if (indexShard == null) {, +            return null;, +        }, +        return indexShard.getActive();, +    }, +, +, +        // True if the shard was active last time we checked, +        private final Map<ShardId,Boolean> shardWasActive = new HashMap<>();, +, +            EnumSet<ShardStatusChangeType> changes = purgeDeletedAndClosedShards();, +, +            updateShardStatuses(changes);, +, +            if (changes.isEmpty() == false) {, +                // Something changed: recompute indexing buffers:, +                calcAndSetShardBuffers("[" + changes + "]");, +, +        /**, +         * goes through all existing shards and check whether there are changes in their active status, +         */, +        private void updateShardStatuses(EnumSet<ShardStatusChangeType> changes) {, +            for (ShardId shardId : availableShards()) {, +, +                // Is the shard active now?, +                Boolean isActive = getShardActive(shardId);, +, +                if (isActive == null) {, +                    // shard was closed.., +                    continue;, +                }, +, +                // Was the shard active last time we checked?, +                Boolean wasActive = shardWasActive.get(shardId);, +                if (wasActive == null) {, +                    // First time we are seeing this shard, +                    shardWasActive.put(shardId, isActive);, +                    changes.add(ShardStatusChangeType.ADDED);, +                } else if (isActive) {, +                    // Shard is active now, +                    if (wasActive == false) {, +                        // Shard became active itself, since we last checked (due to new indexing op arriving), +                        changes.add(ShardStatusChangeType.BECAME_ACTIVE);, +                        logger.debug("marking shard {} as active indexing wise", shardId);, +                        shardWasActive.put(shardId, true);, +                    } else if (checkIdle(shardId) == Boolean.TRUE) {, +                        // Make shard inactive now, +                        changes.add(ShardStatusChangeType.BECAME_INACTIVE);, +, +                        shardWasActive.put(shardId, false);, +                    }, +                }, +            }, +        }, +, +        /**, +         * purge any existing statuses that are no longer updated, +         *, +         * @return the changes applied, +         */, +        private EnumSet<ShardStatusChangeType> purgeDeletedAndClosedShards() {, +            EnumSet<ShardStatusChangeType> changes = EnumSet.noneOf(ShardStatusChangeType.class);, +, +            Iterator<ShardId> statusShardIdIterator = shardWasActive.keySet().iterator();, +            while (statusShardIdIterator.hasNext()) {, +                ShardId shardId = statusShardIdIterator.next();, +                if (shardAvailable(shardId) == false) {, +                    changes.add(ShardStatusChangeType.DELETED);, +                    statusShardIdIterator.remove();, +                }]