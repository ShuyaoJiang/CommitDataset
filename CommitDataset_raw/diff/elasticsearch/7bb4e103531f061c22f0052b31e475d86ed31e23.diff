[+++ b/core/src/main/java/org/elasticsearch/action/admin/indices/recovery/TransportRecoveryAction.java, +                shardResponses.put(indexName, new ArrayList<>());, +++ b/core/src/main/java/org/elasticsearch/action/admin/indices/recovery/TransportRecoveryAction.java, +                shardResponses.put(indexName, new ArrayList<>());, +++ b/core/src/main/java/org/elasticsearch/cluster/routing/allocation/RoutingAllocation.java, +    private boolean hasPendingAsyncFetch = false;, +, +, +, +    /**, +     * Returns <code>true</code> iff the current allocation run has not processed all of the in-flight or available, +     * shard or store fetches. Otherwise <code>true</code>, +     */, +    public boolean hasPendingAsyncFetch() {, +        return hasPendingAsyncFetch;, +    }, +, +    /**, +     * Sets a flag that signals that current allocation run has not processed all of the in-flight or available shard or store fetches., +     * This state is anti-viral and can be reset in on allocation run., +     */, +    public void setHasPendingAsyncFetch() {, +        this.hasPendingAsyncFetch = true;, +    }, +++ b/core/src/main/java/org/elasticsearch/action/admin/indices/recovery/TransportRecoveryAction.java, +                shardResponses.put(indexName, new ArrayList<>());, +++ b/core/src/main/java/org/elasticsearch/cluster/routing/allocation/RoutingAllocation.java, +    private boolean hasPendingAsyncFetch = false;, +, +, +, +    /**, +     * Returns <code>true</code> iff the current allocation run has not processed all of the in-flight or available, +     * shard or store fetches. Otherwise <code>true</code>, +     */, +    public boolean hasPendingAsyncFetch() {, +        return hasPendingAsyncFetch;, +    }, +, +    /**, +     * Sets a flag that signals that current allocation run has not processed all of the in-flight or available shard or store fetches., +     * This state is anti-viral and can be reset in on allocation run., +     */, +    public void setHasPendingAsyncFetch() {, +        this.hasPendingAsyncFetch = true;, +    }, +++ b/core/src/main/java/org/elasticsearch/cluster/routing/allocation/allocator/BalancedShardsAllocator.java, +        final Balancer balancer = new Balancer(logger, allocation, weightFunction, threshold);, +        return balancer.allocateUnassigned();, +         * Allocates all possible unassigned shards, +         * @return <code>true</code> if the current configuration has been, +         *         changed, otherwise <code>false</code>, +         */, +        final boolean allocateUnassigned() {, +            return balance(true);, +        }, +, +        /**, +            return balance(false);, +        }, +, +        private boolean balance(boolean onlyAssign) {, +                if (onlyAssign) {, +                } else {, +                    logger.trace("Start assigning unassigned shards");, +                }, +            if (onlyAssign == false && changed == false && allocation.deciders().canRebalance(allocation).type() == Type.YES) {, +++ b/core/src/main/java/org/elasticsearch/action/admin/indices/recovery/TransportRecoveryAction.java, +                shardResponses.put(indexName, new ArrayList<>());, +++ b/core/src/main/java/org/elasticsearch/cluster/routing/allocation/RoutingAllocation.java, +    private boolean hasPendingAsyncFetch = false;, +, +, +, +    /**, +     * Returns <code>true</code> iff the current allocation run has not processed all of the in-flight or available, +     * shard or store fetches. Otherwise <code>true</code>, +     */, +    public boolean hasPendingAsyncFetch() {, +        return hasPendingAsyncFetch;, +    }, +, +    /**, +     * Sets a flag that signals that current allocation run has not processed all of the in-flight or available shard or store fetches., +     * This state is anti-viral and can be reset in on allocation run., +     */, +    public void setHasPendingAsyncFetch() {, +        this.hasPendingAsyncFetch = true;, +    }, +++ b/core/src/main/java/org/elasticsearch/cluster/routing/allocation/allocator/BalancedShardsAllocator.java, +        final Balancer balancer = new Balancer(logger, allocation, weightFunction, threshold);, +        return balancer.allocateUnassigned();, +         * Allocates all possible unassigned shards, +         * @return <code>true</code> if the current configuration has been, +         *         changed, otherwise <code>false</code>, +         */, +        final boolean allocateUnassigned() {, +            return balance(true);, +        }, +]