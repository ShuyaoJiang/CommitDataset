[+++ b/x-pack/plugin/ccr/src/main/java/org/elasticsearch/xpack/ccr/Ccr.java, +        CcrRestoreSourceService restoreSourceService = new CcrRestoreSourceService(threadPool, ccrSettings);, +        this.restoreSourceService.set(restoreSourceService);, +++ b/x-pack/plugin/ccr/src/main/java/org/elasticsearch/xpack/ccr/Ccr.java, +        CcrRestoreSourceService restoreSourceService = new CcrRestoreSourceService(threadPool, ccrSettings);, +        this.restoreSourceService.set(restoreSourceService);, +++ b/x-pack/plugin/ccr/src/main/java/org/elasticsearch/xpack/ccr/CcrSettings.java, +     * The leader must open resources for a ccr recovery. If there is no activity for this interval of time,, +     * the leader will close the restore session., +     */, +    public static final Setting<TimeValue> INDICES_RECOVERY_ACTIVITY_TIMEOUT_SETTING =, +        Setting.timeSetting("ccr.indices.recovery.recovery_activity_timeout", TimeValue.timeValueSeconds(60),, +            Setting.Property.Dynamic, Setting.Property.NodeScope);, +, +    /**, +                INDICES_RECOVERY_ACTIVITY_TIMEOUT_SETTING,, +    private volatile TimeValue recoveryActivityTimeout;, +        this.recoveryActivityTimeout = INDICES_RECOVERY_ACTIVITY_TIMEOUT_SETTING.get(settings);, +        clusterSettings.addSettingsUpdateConsumer(INDICES_RECOVERY_ACTIVITY_TIMEOUT_SETTING, this::setRecoveryActivityTimeout);, +    private void setRecoveryActivityTimeout(TimeValue recoveryActivityTimeout) {, +        this.recoveryActivityTimeout = recoveryActivityTimeout;, +    }, +, +    public TimeValue getRecoveryActivityTimeout() {, +        return recoveryActivityTimeout;, +    }, +++ b/x-pack/plugin/ccr/src/main/java/org/elasticsearch/xpack/ccr/Ccr.java, +        CcrRestoreSourceService restoreSourceService = new CcrRestoreSourceService(threadPool, ccrSettings);, +        this.restoreSourceService.set(restoreSourceService);, +++ b/x-pack/plugin/ccr/src/main/java/org/elasticsearch/xpack/ccr/CcrSettings.java, +     * The leader must open resources for a ccr recovery. If there is no activity for this interval of time,, +     * the leader will close the restore session., +     */, +    public static final Setting<TimeValue> INDICES_RECOVERY_ACTIVITY_TIMEOUT_SETTING =, +        Setting.timeSetting("ccr.indices.recovery.recovery_activity_timeout", TimeValue.timeValueSeconds(60),, +            Setting.Property.Dynamic, Setting.Property.NodeScope);, +, +    /**, +                INDICES_RECOVERY_ACTIVITY_TIMEOUT_SETTING,, +    private volatile TimeValue recoveryActivityTimeout;, +        this.recoveryActivityTimeout = INDICES_RECOVERY_ACTIVITY_TIMEOUT_SETTING.get(settings);, +        clusterSettings.addSettingsUpdateConsumer(INDICES_RECOVERY_ACTIVITY_TIMEOUT_SETTING, this::setRecoveryActivityTimeout);, +    private void setRecoveryActivityTimeout(TimeValue recoveryActivityTimeout) {, +        this.recoveryActivityTimeout = recoveryActivityTimeout;, +    }, +, +    public TimeValue getRecoveryActivityTimeout() {, +        return recoveryActivityTimeout;, +    }, +++ b/x-pack/plugin/ccr/src/main/java/org/elasticsearch/xpack/ccr/repository/CcrRestoreSourceService.java, +import org.elasticsearch.common.unit.TimeValue;, +import org.elasticsearch.threadpool.Scheduler;, +import org.elasticsearch.threadpool.ThreadPool;, +import org.elasticsearch.xpack.ccr.CcrSettings;, +    private final ThreadPool threadPool;, +    private final CcrSettings ccrSettings;, +, +    public CcrRestoreSourceService(ThreadPool threadPool, CcrSettings ccrSettings) {, +        this.threadPool = threadPool;, +        this.ccrSettings = ccrSettings;, +    }, +                restore = new RestoreSession(sessionUUID, indexShard, indexShard.acquireSafeIndexCommit(), scheduleTimeout(sessionUUID));, +        internalCloseSession(sessionUUID, true);, +    }, +, +    public synchronized SessionReader getSessionReader(String sessionUUID) {, +        RestoreSession restore = onGoingRestores.get(sessionUUID);, +        if (restore == null) {, +            logger.debug("could not get session [{}] because session not found", sessionUUID);, +            throw new IllegalArgumentException("session [" + sessionUUID + "] not found");, +        }, +        restore.idle = false;, +        return new SessionReader(restore);, +    }, +, +    private void internalCloseSession(String sessionUUID, boolean throwIfSessionMissing) {, +                if (throwIfSessionMissing) {, +                } else {, +                    return;, +                }, +        closeSessionListeners.forEach(c -> c.accept(sessionUUID));, +, +    private Scheduler.Cancellable scheduleTimeout(String sessionUUID) {, +        TimeValue idleTimeout = ccrSettings.getRecoveryActivityTimeout();, +        return threadPool.scheduleWithFixedDelay(() -> maybeTimeout(sessionUUID), idleTimeout, ThreadPool.Names.GENERIC);, +, +    private void maybeTimeout(String sessionUUID) {, +        RestoreSession restoreSession = onGoingRestores.get(sessionUUID);, +        if (restoreSession != null) {, +            if (restoreSession.idle) {, +                internalCloseSession(sessionUUID, false);, +            } else {, +                restoreSession.idle = true;, +            }, +        }, +        private final Scheduler.Cancellable timeoutTask;, +        private volatile boolean idle = false;, +        private RestoreSession(String sessionUUID, IndexShard indexShard, Engine.IndexCommitRef commitRef,, +                               Scheduler.Cancellable timeoutTask) {, +            this.timeoutTask = timeoutTask;]