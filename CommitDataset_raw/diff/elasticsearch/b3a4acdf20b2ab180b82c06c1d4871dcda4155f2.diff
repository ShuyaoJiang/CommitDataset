[+++ b/server/src/main/java/org/elasticsearch/common/cache/Cache.java, +, +        /**, +         * remove an entry from the segment iff the future is done and the value is equal to the, +         * expected value, +         *, +         * @param key the key of the entry to remove from the cache, +         * @param value the value expected to be associated with the key, +         * @param onRemoval a callback for the removed entry, +         */, +        void remove(K key, V value, Consumer<CompletableFuture<Entry<K, V>>> onRemoval) {, +            CompletableFuture<Entry<K, V>> future;, +            boolean removed = false;, +            try (ReleasableLock ignored = writeLock.acquire()) {, +                future = map.get(key);, +                try {, +                    if (future != null) {, +                        if (future.isDone()) {, +                            Entry<K, V> entry = future.get();, +                            if (Objects.equals(value, entry.value)) {, +                                removed = map.remove(key, future);, +                            }, +                        }, +                    }, +                } catch (ExecutionException | InterruptedException e) {, +                    throw new IllegalStateException(e);, +                }, +            }, +, +            if (future != null && removed) {, +                segmentStats.eviction();, +                onRemoval.accept(future);, +            }, +        }, +, +    private final ReleasableLock lruLock = new ReleasableLock(new ReentrantLock());, +    private final Consumer<CompletableFuture<Entry<K, V>>> invalidationConsumer = f -> {, +    };, +, +    /**, +     * Invalidate the association for the specified key. A removal notification will be issued for invalidated, +     * entries with {@link org.elasticsearch.common.cache.RemovalNotification.RemovalReason} INVALIDATED., +     *, +     * @param key the key whose mapping is to be invalidated from the cache, +     */, +    public void invalidate(K key) {, +        CacheSegment<K, V> segment = getCacheSegment(key);, +        segment.remove(key, invalidationConsumer);, +    }, +, +    /**, +     * Invalidate the entry for the specified key and value. If the value provided is not equal to the value in, +     * the cache, no removal will occur. A removal notification will be issued for invalidated, +     * entries with {@link org.elasticsearch.common.cache.RemovalNotification.RemovalReason} INVALIDATED., +     *, +     * @param key the key whose mapping is to be invalidated from the cache, +     * @param value the expected value that should be associated with the key, +     */, +    public void invalidate(K key, V value) {, +        CacheSegment<K, V> segment = getCacheSegment(key);, +        segment.remove(key, value, invalidationConsumer);, +                segment.remove(entry.key, entry.value, f -> {});, +            segment.remove(entry.key, entry.value, f -> {});, +++ b/server/src/main/java/org/elasticsearch/common/cache/Cache.java, +, +        /**, +         * remove an entry from the segment iff the future is done and the value is equal to the, +         * expected value, +         *, +         * @param key the key of the entry to remove from the cache, +         * @param value the value expected to be associated with the key, +         * @param onRemoval a callback for the removed entry, +         */, +        void remove(K key, V value, Consumer<CompletableFuture<Entry<K, V>>> onRemoval) {, +            CompletableFuture<Entry<K, V>> future;, +            boolean removed = false;, +            try (ReleasableLock ignored = writeLock.acquire()) {, +                future = map.get(key);, +                try {, +                    if (future != null) {, +                        if (future.isDone()) {, +                            Entry<K, V> entry = future.get();, +                            if (Objects.equals(value, entry.value)) {, +                                removed = map.remove(key, future);, +                            }, +                        }, +                    }, +                } catch (ExecutionException | InterruptedException e) {, +                    throw new IllegalStateException(e);, +                }, +            }, +, +            if (future != null && removed) {, +                segmentStats.eviction();, +                onRemoval.accept(future);, +            }, +        }, +, +    private final ReleasableLock lruLock = new ReleasableLock(new ReentrantLock());, +    private final Consumer<CompletableFuture<Entry<K, V>>> invalidationConsumer = f -> {]