[+++ b/server/src/main/java/org/elasticsearch/search/aggregations/InternalAggregations.java, +import org.elasticsearch.Version;, +import org.elasticsearch.search.aggregations.pipeline.PipelineAggregator;, +import java.util.Collections;, +import java.util.Objects;, +    private List<SiblingPipelineAggregator> topLevelPipelineAggregators = Collections.emptyList();, +, +     * Constructs a new aggregation providing its {@link InternalAggregation}s and {@link SiblingPipelineAggregator}s, +    public InternalAggregations(List<InternalAggregation> aggregations, List<SiblingPipelineAggregator> topLevelPipelineAggregators) {, +        super(aggregations);, +        this.topLevelPipelineAggregators = Objects.requireNonNull(topLevelPipelineAggregators);, +     * Returns the top-level pipeline aggregators., +     * Note that top-level pipeline aggregators become normal aggregation once the final reduction has been performed, after which they, +     * become part of the list of {@link InternalAggregation}s., +     */, +    List<SiblingPipelineAggregator> getTopLevelPipelineAggregators() {, +        return topLevelPipelineAggregators;, +    }, +, +    /**, +     * Reduces the given list of aggregations as well as the top-level pipeline aggregators extracted from the first, +     * {@link InternalAggregations} object found in the list., +     * Note that top-level pipeline aggregators are reduced only as part of the final reduction phase, otherwise they are left untouched., +                                              ReduceContext context) {, +        if (aggregationsList.isEmpty()) {, +            return null;, +        }, +        InternalAggregations first = aggregationsList.get(0);, +        return reduce(aggregationsList, first.topLevelPipelineAggregators, context);, +    }, +, +    /**, +     * Reduces the given list of aggregations as well as the provided top-level pipeline aggregators., +     * Note that top-level pipeline aggregators are reduced only as part of the final reduction phase, otherwise they are left untouched., +     */, +    public static InternalAggregations reduce(List<InternalAggregations> aggregationsList,, +                                              List<SiblingPipelineAggregator> topLevelPipelineAggregators,, +            for (SiblingPipelineAggregator pipelineAggregator : topLevelPipelineAggregators) {, +        return new InternalAggregations(reducedAggregations, topLevelPipelineAggregators);, +    }, +        //TODO update version after backport, +        if (in.getVersion().onOrAfter(Version.V_8_0_0)) {, +            this.topLevelPipelineAggregators = in.readList(, +                stream -> (SiblingPipelineAggregator)in.readNamedWriteable(PipelineAggregator.class));, +        } else {, +            this.topLevelPipelineAggregators = Collections.emptyList();, +        }, +        //TODO update version after backport, +        if (out.getVersion().onOrAfter(Version.V_8_0_0)) {, +            out.writeNamedWriteableList(topLevelPipelineAggregators);, +        }, +++ b/server/src/main/java/org/elasticsearch/search/aggregations/InternalAggregations.java, +import org.elasticsearch.Version;, +import org.elasticsearch.search.aggregations.pipeline.PipelineAggregator;, +import java.util.Collections;, +import java.util.Objects;, +    private List<SiblingPipelineAggregator> topLevelPipelineAggregators = Collections.emptyList();, +, +     * Constructs a new aggregation providing its {@link InternalAggregation}s and {@link SiblingPipelineAggregator}s, +    public InternalAggregations(List<InternalAggregation> aggregations, List<SiblingPipelineAggregator> topLevelPipelineAggregators) {, +        super(aggregations);, +        this.topLevelPipelineAggregators = Objects.requireNonNull(topLevelPipelineAggregators);, +     * Returns the top-level pipeline aggregators., +     * Note that top-level pipeline aggregators become normal aggregation once the final reduction has been performed, after which they, +     * become part of the list of {@link InternalAggregation}s., +     */, +    List<SiblingPipelineAggregator> getTopLevelPipelineAggregators() {, +        return topLevelPipelineAggregators;, +    }, +, +    /**, +     * Reduces the given list of aggregations as well as the top-level pipeline aggregators extracted from the first, +     * {@link InternalAggregations} object found in the list., +     * Note that top-level pipeline aggregators are reduced only as part of the final reduction phase, otherwise they are left untouched., +                                              ReduceContext context) {, +        if (aggregationsList.isEmpty()) {, +            return null;, +        }, +        InternalAggregations first = aggregationsList.get(0);, +        return reduce(aggregationsList, first.topLevelPipelineAggregators, context);, +    }, +, +    /**, +     * Reduces the given list of aggregations as well as the provided top-level pipeline aggregators., +     * Note that top-level pipeline aggregators are reduced only as part of the final reduction phase, otherwise they are left untouched., +     */, +    public static InternalAggregations reduce(List<InternalAggregations> aggregationsList,, +                                              List<SiblingPipelineAggregator> topLevelPipelineAggregators,, +            for (SiblingPipelineAggregator pipelineAggregator : topLevelPipelineAggregators) {, +        return new InternalAggregations(reducedAggregations, topLevelPipelineAggregators);, +    }, +        //TODO update version after backport, +        if (in.getVersion().onOrAfter(Version.V_8_0_0)) {, +            this.topLevelPipelineAggregators = in.readList(, +                stream -> (SiblingPipelineAggregator)in.readNamedWriteable(PipelineAggregator.class));, +        } else {, +            this.topLevelPipelineAggregators = Collections.emptyList();, +        }, +        //TODO update version after backport, +        if (out.getVersion().onOrAfter(Version.V_8_0_0)) {]