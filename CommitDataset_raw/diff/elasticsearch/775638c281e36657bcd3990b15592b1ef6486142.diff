[+++ b/core/src/main/java/org/elasticsearch/index/engine/InternalEngine.java, +    @SuppressWarnings("finally"), +            if (indexWriter.getTragicException() instanceof Error) {, +                try {, +                    logger.error("tragic event in index writer", ex);, +                } finally {, +                    throw (Error) indexWriter.getTragicException();, +                }, +            } else {, +                failEngine("already closed by tragic event on the index writer", (Exception) indexWriter.getTragicException());, +            }, +++ b/core/src/main/java/org/elasticsearch/index/engine/InternalEngine.java, +    @SuppressWarnings("finally"), +            if (indexWriter.getTragicException() instanceof Error) {, +                try {, +                    logger.error("tragic event in index writer", ex);, +                } finally {, +                    throw (Error) indexWriter.getTragicException();, +                }, +            } else {, +                failEngine("already closed by tragic event on the index writer", (Exception) indexWriter.getTragicException());, +            }, +++ b/core/src/test/java/org/elasticsearch/index/engine/InternalEngineTests.java, +import org.apache.lucene.analysis.Analyzer;, +import org.apache.lucene.analysis.Tokenizer;, +import java.io.IOError;, +        return copy(config, openMode, config.getAnalyzer());, +    }, +, +    public EngineConfig copy(EngineConfig config, EngineConfig.OpenMode openMode, Analyzer analyzer) {, +            config.getStore(), config.getDeletionPolicy(), config.getMergePolicy(), analyzer, config.getSimilarity(),, +, +    public void testTragicEventErrorBubblesUp() throws IOException {, +        engine.close();, +        final AtomicBoolean failWithFatalError = new AtomicBoolean(true);, +        final VirtualMachineError error = randomFrom(, +            new InternalError(),, +            new OutOfMemoryError(),, +            new StackOverflowError(),, +            new UnknownError());, +        engine = new InternalEngine(copy(engine.config(), EngineConfig.OpenMode.OPEN_INDEX_AND_TRANSLOG, new Analyzer() {, +            @Override, +            protected TokenStreamComponents createComponents(String fieldName) {, +                return new TokenStreamComponents(new Tokenizer() {, +                    @Override, +                    public boolean incrementToken() throws IOException {, +                        if (failWithFatalError.get()) {, +                            throw error;, +                        } else {, +                            throw new AssertionError("should not get to this point");, +                        }, +                    }, +                });, +            }, +        }));, +        final Document document = testDocument();, +        document.add(new TextField("value", "test", Field.Store.YES));, +        final ParsedDocument doc = testParsedDocument("1", "1", "test", null, -1, -1, document, B_1, null);, +        final Engine.Index first = new Engine.Index(newUid("1"), doc);, +        expectThrows(error.getClass(), () -> engine.index(first));, +        failWithFatalError.set(false);, +        expectThrows(error.getClass(), () -> engine.index(first));, +        assertNull(engine.failedEngine.get());, +    }, +]