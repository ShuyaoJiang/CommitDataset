[+++ b/modules/elasticsearch/src/main/java/org/elasticsearch/cluster/routing/allocation/ShardsAllocation.java, +        boolean changed = applyStartedShards(routingNodes, startedShards);, +        boolean changed = applyFailedShards(routingNodes, failedShards);, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/cluster/routing/allocation/ShardsAllocation.java, +        boolean changed = applyStartedShards(routingNodes, startedShards);, +        boolean changed = applyFailedShards(routingNodes, failedShards);, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/gateway/blobstore/BlobReuseExistingNodeAllocation.java, +import org.elasticsearch.common.collect.Sets;, +import java.util.Set;, +    private final ConcurrentMap<ShardId, ConcurrentMap<DiscoveryNode, IndexStore.StoreFilesMetaData>> cachedStores = ConcurrentCollections.newConcurrentMap();, +, +            cachedStores.remove(shardRouting.shardId());, +            cachedStores.remove(shardRouting.shardId());, +            ConcurrentMap<DiscoveryNode, IndexStore.StoreFilesMetaData> shardStores = buildShardStores(nodes, shard);, +            for (Map.Entry<DiscoveryNode, IndexStore.StoreFilesMetaData> nodeStoreEntry : shardStores.entrySet()) {, +                DiscoveryNode discoNode = nodeStoreEntry.getKey();, +                IndexStore.StoreFilesMetaData storeFilesMetaData = nodeStoreEntry.getValue();, +                if (shard.primary()) {, +                } else {, +                        DiscoveryNode primaryNode = nodes.get(primaryShard.currentNodeId());, +                        if (primaryNode != null) {, +                            IndexStore.StoreFilesMetaData primaryNodeStore = shardStores.get(primaryNode);, +                            if (primaryNodeStore != null && primaryNodeStore.allocated()) {, +                                    if (primaryNodeStore.fileExists(storeFileMetaData.name()) && primaryNodeStore.file(storeFileMetaData.name()).length() == storeFileMetaData.length()) {, +                            }, +    private ConcurrentMap<DiscoveryNode, IndexStore.StoreFilesMetaData> buildShardStores(DiscoveryNodes nodes, MutableShardRouting shard) {, +        ConcurrentMap<DiscoveryNode, IndexStore.StoreFilesMetaData> shardStores = cachedStores.get(shard.shardId());, +        if (shardStores == null) {, +            shardStores = ConcurrentCollections.newConcurrentMap();, +            TransportNodesListShardStoreMetaData.NodesStoreFilesMetaData nodesStoreFilesMetaData = transportNodesListShardStoreMetaData.list(shard.shardId(), false, nodes.dataNodes().keySet(), listTimeout).actionGet();, +            if (logger.isDebugEnabled()) {, +                if (nodesStoreFilesMetaData.failures().length > 0) {, +                    StringBuilder sb = new StringBuilder(shard + ": failures when trying to list stores on nodes:");, +                    for (int i = 0; i < nodesStoreFilesMetaData.failures().length; i++) {, +                        Throwable cause = ExceptionsHelper.unwrapCause(nodesStoreFilesMetaData.failures()[i]);, +                        if (cause instanceof ConnectTransportException) {, +                            continue;, +                        }, +                        sb.append("\n    -> ").append(nodesStoreFilesMetaData.failures()[i].getDetailedMessage());, +                    }, +                    logger.debug(sb.toString());, +                }, +            }, +, +            for (TransportNodesListShardStoreMetaData.NodeStoreFilesMetaData nodeStoreFilesMetaData : nodesStoreFilesMetaData) {, +                shardStores.put(nodeStoreFilesMetaData.node(), nodeStoreFilesMetaData.storeFilesMetaData());, +            }, +            cachedStores.put(shard.shardId(), shardStores);, +        } else {, +            // clean nodes that have failed, +            for (DiscoveryNode node : shardStores.keySet()) {, +                if (!nodes.nodeExists(node.id())) {, +                    shardStores.remove(node);, +                }, +            }, +, +            // we have stored cached from before, see if the nodes changed, if they have, go fetch again, +            Set<String> fetchedNodes = Sets.newHashSet();, +            for (DiscoveryNode node : nodes.dataNodes().values()) {, +                if (!shardStores.containsKey(node)) {, +                    fetchedNodes.add(node.id());, +                }, +            }, +, +            if (!fetchedNodes.isEmpty()) {, +                TransportNodesListShardStoreMetaData.NodesStoreFilesMetaData nodesStoreFilesMetaData = transportNodesListShardStoreMetaData.list(shard.shardId(), false, fetchedNodes, listTimeout).actionGet();, +                if (logger.isDebugEnabled()) {, +                    if (nodesStoreFilesMetaData.failures().length > 0) {, +                        StringBuilder sb = new StringBuilder(shard + ": failures when trying to list stores on nodes:");, +                        for (int i = 0; i < nodesStoreFilesMetaData.failures().length; i++) {, +                            Throwable cause = ExceptionsHelper.unwrapCause(nodesStoreFilesMetaData.failures()[i]);, +                            if (cause instanceof ConnectTransportException) {, +                                continue;, +                            }, +                            sb.append("\n    -> ").append(nodesStoreFilesMetaData.failures()[i].getDetailedMessage());, +                        }, +                        logger.debug(sb.toString());, +                    }, +                }, +, +                for (TransportNodesListShardStoreMetaData.NodeStoreFilesMetaData nodeStoreFilesMetaData : nodesStoreFilesMetaData) {, +                    shardStores.put(nodeStoreFilesMetaData.node(), nodeStoreFilesMetaData.storeFilesMetaData());, +                }, +            }, +        }, +        return shardStores;, +    }, +]