[+++ b/server/src/main/java/org/elasticsearch/action/admin/cluster/settings/SettingsUpdater.java, +import org.apache.logging.log4j.Logger;, +import org.apache.logging.log4j.message.ParameterizedMessage;, +import org.apache.logging.log4j.util.Supplier;, +import org.elasticsearch.common.collect.Tuple;, +import java.util.Map;, +, +import static org.elasticsearch.common.settings.AbstractScopedSettings.ARCHIVED_SETTINGS_PREFIX;, +    synchronized ClusterState updateSettings(, +            final ClusterState currentState, final Settings transientToApply, final Settings persistentToApply, final Logger logger) {, +, +        /*, +         * Our cluster state could have unknown or invalid settings that are known and valid in a previous version of Elasticsearch. We can, +         * end up in this situation during a rolling upgrade where the previous version will infect the current version of Elasticsearch, +         * with settings that the current version either no longer knows about or now considers to have invalid values. When the current, +         * version of Elasticsearch becomes infected with a cluster state containing such settings, we need to skip validating such settings, +         * and instead archive them. Consequently, for the current transient and persistent settings in the cluster state we do the, +         * following:, +         *  - split existing settings instance into two with the known and valid settings in one, and the unknown or invalid in another, +         *    (note that existing archived settings are included in the known and valid settings), +         *  - validate the incoming settings update combined with the existing known and valid settings, +         *  - merge in the archived unknown or invalid settings, +         */, +        final Tuple<Settings, Settings> partitionedTransientSettings =, +                partitionKnownAndValidSettings(currentState.metaData().transientSettings(), "transient", logger);, +        final Settings knownAndValidTransientSettings = partitionedTransientSettings.v1();, +        final Settings unknownOrInvalidTransientSettings = partitionedTransientSettings.v2();, +        final Settings.Builder transientSettings = Settings.builder().put(knownAndValidTransientSettings);, +        final Tuple<Settings, Settings> partitionedPersistentSettings =, +                partitionKnownAndValidSettings(currentState.metaData().persistentSettings(), "persistent", logger);, +        final Settings knownAndValidPersistentSettings = partitionedPersistentSettings.v1();, +        final Settings unknownOrInvalidPersistentSettings = partitionedPersistentSettings.v2();, +        final Settings.Builder persistentSettings = Settings.builder().put(knownAndValidPersistentSettings);, +                    .transientSettings(Settings.builder().put(transientFinalSettings).put(unknownOrInvalidTransientSettings).build()), +                    .persistentSettings(Settings.builder().put(persistentFinalSettings).put(unknownOrInvalidPersistentSettings).build());, +    /**, +     * Partitions the settings into those that are known and valid versus those that are unknown or invalid. The resulting tuple contains, +     * the known and valid settings in the first component and the unknown or invalid settings in the second component. Note that archived, +     * settings contained in the settings to partition are included in the first component., +     *, +     * @param settings     the settings to partition, +     * @param settingsType a string to identify the settings (for logging), +     * @param logger       a logger to sending warnings to, +     * @return the partitioned settings, +     */, +    private Tuple<Settings, Settings> partitionKnownAndValidSettings(, +            final Settings settings, final String settingsType, final Logger logger) {, +        final Settings existingArchivedSettings = settings.filter(k -> k.startsWith(ARCHIVED_SETTINGS_PREFIX));, +        final Settings settingsExcludingExistingArchivedSettings =, +                settings.filter(k -> k.startsWith(ARCHIVED_SETTINGS_PREFIX) == false);, +        final Settings settingsWithUnknownOrInvalidArchived = clusterSettings.archiveUnknownOrInvalidSettings(, +                settingsExcludingExistingArchivedSettings,, +                e -> logUnknownSetting(settingsType, e, logger),, +                (e, ex) -> logInvalidSetting(settingsType, e, ex, logger));, +        return Tuple.tuple(, +                Settings.builder(), +                        .put(settingsWithUnknownOrInvalidArchived.filter(k -> k.startsWith(ARCHIVED_SETTINGS_PREFIX) == false)), +                        .put(existingArchivedSettings), +                        .build(),, +                settingsWithUnknownOrInvalidArchived.filter(k -> k.startsWith(ARCHIVED_SETTINGS_PREFIX)));, +    }, +, +    private void logUnknownSetting(final String settingType, final Map.Entry<String, String> e, final Logger logger) {, +        logger.warn("ignoring existing unknown {} setting: [{}] with value [{}]; archiving", settingType, e.getKey(), e.getValue());, +    }, +, +    private void logInvalidSetting(, +            final String settingType, final Map.Entry<String, String> e, final IllegalArgumentException ex, final Logger logger) {, +        logger.warn(, +                (Supplier<?>), +                        () -> new ParameterizedMessage("ignoring existing invalid {} setting: [{}] with value [{}]; archiving",, +                                settingType,, +                                e.getKey(),, +                                e.getValue()),, +                ex);, +    }, +++ b/server/src/main/java/org/elasticsearch/action/admin/cluster/settings/SettingsUpdater.java, +import org.apache.logging.log4j.Logger;, +import org.apache.logging.log4j.message.ParameterizedMessage;, +import org.apache.logging.log4j.util.Supplier;, +import org.elasticsearch.common.collect.Tuple;, +import java.util.Map;, +, +import static org.elasticsearch.common.settings.AbstractScopedSettings.ARCHIVED_SETTINGS_PREFIX;, +    synchronized ClusterState updateSettings(, +            final ClusterState currentState, final Settings transientToApply, final Settings persistentToApply, final Logger logger) {, +, +        /*, +         * Our cluster state could have unknown or invalid settings that are known and valid in a previous version of Elasticsearch. We can, +         * end up in this situation during a rolling upgrade where the previous version will infect the current version of Elasticsearch, +         * with settings that the current version either no longer knows about or now considers to have invalid values. When the current, +         * version of Elasticsearch becomes infected with a cluster state containing such settings, we need to skip validating such settings, +         * and instead archive them. Consequently, for the current transient and persistent settings in the cluster state we do the, +         * following:, +         *  - split existing settings instance into two with the known and valid settings in one, and the unknown or invalid in another, +         *    (note that existing archived settings are included in the known and valid settings), +         *  - validate the incoming settings update combined with the existing known and valid settings, +         *  - merge in the archived unknown or invalid settings, +         */, +        final Tuple<Settings, Settings> partitionedTransientSettings =]