[+++ b/src/main/java/org/elasticsearch/cluster/routing/allocation/allocator/BalancedShardsAllocator.java, +            if (!changed && allocation.deciders().canRebalance(allocation).type() == Type.YES) {, +++ b/src/main/java/org/elasticsearch/cluster/routing/allocation/allocator/BalancedShardsAllocator.java, +            if (!changed && allocation.deciders().canRebalance(allocation).type() == Type.YES) {, +++ b/src/main/java/org/elasticsearch/cluster/routing/allocation/decider/AllocationDecider.java, +, +    /**, +     * Returns a {@link Decision} whether the cluster can execute, +     * re-balanced operations at all., +     * {@link Decision#ALWAYS}., +     */, +    public Decision canRebalance(RoutingAllocation allocation) {, +        return Decision.ALWAYS;, +    }, +++ b/src/main/java/org/elasticsearch/cluster/routing/allocation/allocator/BalancedShardsAllocator.java, +            if (!changed && allocation.deciders().canRebalance(allocation).type() == Type.YES) {, +++ b/src/main/java/org/elasticsearch/cluster/routing/allocation/decider/AllocationDecider.java, +, +    /**, +     * Returns a {@link Decision} whether the cluster can execute, +     * re-balanced operations at all., +     * {@link Decision#ALWAYS}., +     */, +    public Decision canRebalance(RoutingAllocation allocation) {, +        return Decision.ALWAYS;, +    }, +++ b/src/main/java/org/elasticsearch/cluster/routing/allocation/decider/AllocationDeciders.java, +, +    @Override, +    public Decision canRebalance(RoutingAllocation allocation) {, +        Decision.Multi ret = new Decision.Multi();, +        for (AllocationDecider allocationDecider : allocations) {, +            Decision decision = allocationDecider.canRebalance(allocation);, +            // short track if a NO is returned., +            if (decision == Decision.NO) {, +                if (!allocation.debugDecision()) {, +                    return decision;, +                } else {, +                    ret.add(decision);, +                }, +            } else if (decision != Decision.ALWAYS) {, +                ret.add(decision);, +            }, +        }, +        return ret;, +    }, +++ b/src/main/java/org/elasticsearch/cluster/routing/allocation/allocator/BalancedShardsAllocator.java, +            if (!changed && allocation.deciders().canRebalance(allocation).type() == Type.YES) {, +++ b/src/main/java/org/elasticsearch/cluster/routing/allocation/decider/AllocationDecider.java, +, +    /**, +     * Returns a {@link Decision} whether the cluster can execute, +     * re-balanced operations at all., +     * {@link Decision#ALWAYS}., +     */, +    public Decision canRebalance(RoutingAllocation allocation) {, +        return Decision.ALWAYS;, +    }, +++ b/src/main/java/org/elasticsearch/cluster/routing/allocation/decider/AllocationDeciders.java, +, +    @Override, +    public Decision canRebalance(RoutingAllocation allocation) {, +        Decision.Multi ret = new Decision.Multi();, +        for (AllocationDecider allocationDecider : allocations) {, +            Decision decision = allocationDecider.canRebalance(allocation);, +            // short track if a NO is returned., +            if (decision == Decision.NO) {, +                if (!allocation.debugDecision()) {, +                    return decision;, +                } else {, +                    ret.add(decision);, +                }, +            } else if (decision != Decision.ALWAYS) {, +                ret.add(decision);, +            }, +        }, +        return ret;, +    }, +++ b/src/main/java/org/elasticsearch/cluster/routing/allocation/decider/ClusterRebalanceAllocationDecider.java, +        return canRebalance(allocation);, +    }, +, +    @Override, +    public Decision canRebalance(RoutingAllocation allocation) {]