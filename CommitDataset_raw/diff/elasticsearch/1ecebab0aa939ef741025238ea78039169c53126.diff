[+++ b/elasticsearch/x-pack/shield/src/main/java/org/elasticsearch/shield/authz/accesscontrol/ShieldIndexSearcherWrapper.java, +import org.elasticsearch.index.mapper.internal.FieldNamesFieldMapper;, +        allowedMetaFields.add(FieldNamesFieldMapper.NAME); // TODO: add _field_names to MapperService#META_FIELDS?, +++ b/elasticsearch/x-pack/shield/src/main/java/org/elasticsearch/shield/authz/accesscontrol/ShieldIndexSearcherWrapper.java, +import org.elasticsearch.index.mapper.internal.FieldNamesFieldMapper;, +        allowedMetaFields.add(FieldNamesFieldMapper.NAME); // TODO: add _field_names to MapperService#META_FIELDS?, +++ b/elasticsearch/x-pack/shield/src/test/java/org/elasticsearch/integration/FieldLevelSecurityTests.java, +import static org.elasticsearch.index.query.QueryBuilders.existsQuery;, +        assertThat(response.getHits().getAt(0).sortValues()[0], equalTo(1L));, +        assertThat(response.getHits().getAt(0).sortValues()[0], equalTo(Long.MAX_VALUE));, +        assertThat(response.getHits().getAt(0).sortValues()[0], equalTo(Long.MAX_VALUE));, +        assertThat(response.getHits().getAt(0).sortValues()[0], equalTo(2L));, +    public void testExistQuery() {, +        assertAcked(client().admin().indices().prepareCreate("test"), +                .addMapping("type1", "field1", "type=text", "field2", "type=text", "field3", "type=text"), +        );, +        client().prepareIndex("test", "type1", "1").setSource("field1", "value1", "field2", "value2", "field3", "value3"), +                .setRefreshPolicy(IMMEDIATE), +                .get();, +, +        // user1 has access to field1, so the query should match with the document:, +        SearchResponse response = client(), +                .filterWithHeader(Collections.singletonMap(BASIC_AUTH_HEADER, basicAuthHeaderValue("user1", USERS_PASSWD))), +                .prepareSearch("test"), +                .setQuery(existsQuery("field1")), +                .get();, +        assertHitCount(response, 1);, +        // user1 has no access to field2, so the query should not match with the document:, +        response = client(), +                .filterWithHeader(Collections.singletonMap(BASIC_AUTH_HEADER, basicAuthHeaderValue("user1", USERS_PASSWD))), +                .prepareSearch("test"), +                .setQuery(existsQuery("field2")), +                .get();, +        assertHitCount(response, 0);, +        // user2 has no access to field1, so the query should not match with the document:, +        response = client().filterWithHeader(Collections.singletonMap(BASIC_AUTH_HEADER, basicAuthHeaderValue("user2", USERS_PASSWD))), +                .prepareSearch("test"), +                .setQuery(existsQuery("field1")), +                .get();, +        assertHitCount(response, 0);, +        // user2 has access to field2, so the query should match with the document:, +        response = client().filterWithHeader(Collections.singletonMap(BASIC_AUTH_HEADER, basicAuthHeaderValue("user2", USERS_PASSWD))), +                .prepareSearch("test"), +                .setQuery(existsQuery("field2")), +                .get();, +        assertHitCount(response, 1);, +        // user3 has access to field1 and field2, so the query should match with the document:, +        response = client().filterWithHeader(Collections.singletonMap(BASIC_AUTH_HEADER, basicAuthHeaderValue("user3", USERS_PASSWD))), +                .prepareSearch("test"), +                .setQuery(existsQuery("field1")), +                .get();, +        assertHitCount(response, 1);, +        // user3 has access to field1 and field2, so the query should match with the document:, +        response = client().filterWithHeader(Collections.singletonMap(BASIC_AUTH_HEADER, basicAuthHeaderValue("user3", USERS_PASSWD))), +                .prepareSearch("test"), +                .setQuery(existsQuery("field2")), +                .get();, +        assertHitCount(response, 1);, +        // user4 has access to no fields, so the query should not match with the document:, +        response = client().filterWithHeader(Collections.singletonMap(BASIC_AUTH_HEADER, basicAuthHeaderValue("user4", USERS_PASSWD))), +                .prepareSearch("test"), +                .setQuery(existsQuery("field1")), +                .get();, +        assertHitCount(response, 0);, +        // user4 has access to no fields, so the query should not match with the document:, +        response = client().filterWithHeader(Collections.singletonMap(BASIC_AUTH_HEADER, basicAuthHeaderValue("user4", USERS_PASSWD))), +                .prepareSearch("test"), +                .setQuery(existsQuery("field2")), +                .get();, +        assertHitCount(response, 0);, +    }, +, +++ b/elasticsearch/x-pack/shield/src/main/java/org/elasticsearch/shield/authz/accesscontrol/ShieldIndexSearcherWrapper.java, +import org.elasticsearch.index.mapper.internal.FieldNamesFieldMapper;, +        allowedMetaFields.add(FieldNamesFieldMapper.NAME); // TODO: add _field_names to MapperService#META_FIELDS?, +++ b/elasticsearch/x-pack/shield/src/test/java/org/elasticsearch/integration/FieldLevelSecurityTests.java, +import static org.elasticsearch.index.query.QueryBuilders.existsQuery;, +        assertThat(response.getHits().getAt(0).sortValues()[0], equalTo(1L));, +        assertThat(response.getHits().getAt(0).sortValues()[0], equalTo(Long.MAX_VALUE));, +        assertThat(response.getHits().getAt(0).sortValues()[0], equalTo(Long.MAX_VALUE));, +        assertThat(response.getHits().getAt(0).sortValues()[0], equalTo(2L));, +    public void testExistQuery() {, +        assertAcked(client().admin().indices().prepareCreate("test"), +                .addMapping("type1", "field1", "type=text", "field2", "type=text", "field3", "type=text"), +        );, +        client().prepareIndex("test", "type1", "1").setSource("field1", "value1", "field2", "value2", "field3", "value3"), +                .setRefreshPolicy(IMMEDIATE), +                .get();, +, +        // user1 has access to field1, so the query should match with the document:, +        SearchResponse response = client(), +                .filterWithHeader(Collections.singletonMap(BASIC_AUTH_HEADER, basicAuthHeaderValue("user1", USERS_PASSWD))), +                .prepareSearch("test"), +                .setQuery(existsQuery("field1")), +                .get();, +        assertHitCount(response, 1);, +        // user1 has no access to field2, so the query should not match with the document:, +        response = client(), +                .filterWithHeader(Collections.singletonMap(BASIC_AUTH_HEADER, basicAuthHeaderValue("user1", USERS_PASSWD))), +                .prepareSearch("test")]