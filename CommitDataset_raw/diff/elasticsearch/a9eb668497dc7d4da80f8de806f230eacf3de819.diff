[+++ b/core/src/main/java/org/elasticsearch/cluster/routing/allocation/decider/NodeVersionAllocationDecider.java, +import org.elasticsearch.cluster.routing.RestoreSource;, +                if (shardRouting.restoreSource() != null) {, +                    // restoring from a snapshot - check that the node can handle the version, +                    return isVersionCompatible(shardRouting.restoreSource(), node, allocation);, +                } else {, +                }, +, +    private Decision isVersionCompatible(RestoreSource restoreSource, final RoutingNode target, RoutingAllocation allocation) {, +        if (target.node().version().onOrAfter(restoreSource.version())) {, +            /* we can allocate if we can restore from a snapshot that is older or on the same version */, +            return allocation.decision(Decision.YES, NAME, "target node version [%s] is same or newer than snapshot version [%s]",, +                target.node().version(), restoreSource.version());, +        } else {, +            return allocation.decision(Decision.NO, NAME, "target node version [%s] is older than snapshot version [%s]",, +                target.node().version(), restoreSource.version());, +        }, +    }, +++ b/core/src/main/java/org/elasticsearch/cluster/routing/allocation/decider/NodeVersionAllocationDecider.java, +import org.elasticsearch.cluster.routing.RestoreSource;, +                if (shardRouting.restoreSource() != null) {, +                    // restoring from a snapshot - check that the node can handle the version, +                    return isVersionCompatible(shardRouting.restoreSource(), node, allocation);, +                } else {, +                }, +, +    private Decision isVersionCompatible(RestoreSource restoreSource, final RoutingNode target, RoutingAllocation allocation) {, +        if (target.node().version().onOrAfter(restoreSource.version())) {, +            /* we can allocate if we can restore from a snapshot that is older or on the same version */, +            return allocation.decision(Decision.YES, NAME, "target node version [%s] is same or newer than snapshot version [%s]",, +                target.node().version(), restoreSource.version());, +        } else {, +            return allocation.decision(Decision.NO, NAME, "target node version [%s] is older than snapshot version [%s]",, +                target.node().version(), restoreSource.version());, +        }, +    }, +++ b/core/src/test/java/org/elasticsearch/cluster/routing/allocation/NodeVersionAllocationDeciderTests.java, +import org.elasticsearch.cluster.ClusterName;, +import org.elasticsearch.cluster.metadata.SnapshotId;, +import org.elasticsearch.cluster.routing.RestoreSource;, +import org.elasticsearch.cluster.routing.allocation.decider.ReplicaAfterPrimaryActiveAllocationDecider;, +, +    public void testRestoreDoesNotAllocateSnapshotOnOlderNodes() {, +        final DiscoveryNode newNode = new DiscoveryNode("newNode", DummyTransportAddress.INSTANCE, Version.CURRENT);, +        final DiscoveryNode oldNode1 = new DiscoveryNode("oldNode1", DummyTransportAddress.INSTANCE, VersionUtils.getPreviousVersion());, +        final DiscoveryNode oldNode2 = new DiscoveryNode("oldNode2", DummyTransportAddress.INSTANCE, VersionUtils.getPreviousVersion());, +, +        int numberOfShards = randomIntBetween(1, 3);, +        MetaData metaData = MetaData.builder(), +            .put(IndexMetaData.builder("test").settings(settings(Version.CURRENT)).numberOfShards(numberOfShards).numberOfReplicas, +                (randomIntBetween(0, 3))), +            .build();, +, +        ClusterState state = ClusterState.builder(ClusterName.DEFAULT), +            .metaData(metaData), +            .routingTable(RoutingTable.builder().addAsRestore(metaData.index("test"), new RestoreSource(new SnapshotId("rep1", "snp1"),, +                Version.CURRENT, "test")).build()), +            .nodes(DiscoveryNodes.builder().put(newNode).put(oldNode1).put(oldNode2)).build();, +        AllocationDeciders allocationDeciders = new AllocationDeciders(Settings.EMPTY, new AllocationDecider[]{, +            new ReplicaAfterPrimaryActiveAllocationDecider(Settings.EMPTY),, +            new NodeVersionAllocationDecider(Settings.EMPTY)});, +        AllocationService strategy = new MockAllocationService(Settings.EMPTY,, +            allocationDeciders,, +            new ShardsAllocators(Settings.EMPTY, NoopGatewayAllocator.INSTANCE), EmptyClusterInfoService.INSTANCE);, +        RoutingAllocation.Result result = strategy.reroute(state, new AllocationCommands(), true);, +, +        // Make sure that primary shards are only allocated on the new node, +        for (int i = 0; i < numberOfShards; i++) {, +            assertEquals("newNode", result.routingTable().index("test").getShards().get(i).primaryShard().currentNodeId());, +        }, +    }, +]