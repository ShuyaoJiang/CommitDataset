[+++ b/core/src/main/java/org/elasticsearch/index/mapper/DocumentParser.java, +++ b/core/src/main/java/org/elasticsearch/index/mapper/DocumentParser.java, +++ b/core/src/main/java/org/elasticsearch/index/mapper/object/RootObjectMapper.java, +    private DynamicTemplate findTemplate(ContentPath path, String name, String matchType) {, +++ b/core/src/main/java/org/elasticsearch/index/mapper/DocumentParser.java, +++ b/core/src/main/java/org/elasticsearch/index/mapper/object/RootObjectMapper.java, +    private DynamicTemplate findTemplate(ContentPath path, String name, String matchType) {, +++ b/core/src/test/java/org/elasticsearch/bootstrap/JarHellTests.java, +++ b/core/src/main/java/org/elasticsearch/index/mapper/DocumentParser.java, +++ b/core/src/main/java/org/elasticsearch/index/mapper/object/RootObjectMapper.java, +    private DynamicTemplate findTemplate(ContentPath path, String name, String matchType) {, +++ b/core/src/test/java/org/elasticsearch/bootstrap/JarHellTests.java, +++ b/core/src/test/java/org/elasticsearch/index/mapper/DynamicMappingTests.java, +import org.elasticsearch.index.mapper.core.KeywordFieldMapper;, +, +    public void testDynamicTemplateOrder() throws IOException {, +        // https://github.com/elastic/elasticsearch/issues/18625, +        // elasticsearch used to apply templates that do not have a match_mapping_type first, +        XContentBuilder mapping = XContentFactory.jsonBuilder().startObject().startObject("type"), +                .startArray("dynamic_templates"), +                    .startObject(), +                        .startObject("type-based"), +                            .field("match_mapping_type", "string"), +                            .startObject("mapping"), +                                .field("type", "keyword"), +                            .endObject(), +                        .endObject(), +                    .endObject(), +                    .startObject(), +                    .startObject("path-based"), +                        .field("path_match", "foo"), +                        .startObject("mapping"), +                            .field("type", "long"), +                        .endObject(), +                    .endObject(), +                .endObject(), +                .endArray(), +                .endObject().endObject();, +        IndexService index = createIndex("test", Settings.EMPTY, "type", mapping);, +        client().prepareIndex("test", "type", "1").setSource("foo", "abc").get();, +        assertThat(index.mapperService().fullName("foo"), instanceOf(KeywordFieldMapper.KeywordFieldType.class));, +    }, +++ b/core/src/main/java/org/elasticsearch/index/mapper/DocumentParser.java, +++ b/core/src/main/java/org/elasticsearch/index/mapper/object/RootObjectMapper.java, +    private DynamicTemplate findTemplate(ContentPath path, String name, String matchType) {, +++ b/core/src/test/java/org/elasticsearch/bootstrap/JarHellTests.java, +++ b/core/src/test/java/org/elasticsearch/index/mapper/DynamicMappingTests.java, +import org.elasticsearch.index.mapper.core.KeywordFieldMapper;, +, +    public void testDynamicTemplateOrder() throws IOException {, +        // https://github.com/elastic/elasticsearch/issues/18625, +        // elasticsearch used to apply templates that do not have a match_mapping_type first, +        XContentBuilder mapping = XContentFactory.jsonBuilder().startObject().startObject("type"), +                .startArray("dynamic_templates"), +                    .startObject(), +                        .startObject("type-based"), +                            .field("match_mapping_type", "string"), +                            .startObject("mapping"), +                                .field("type", "keyword"), +                            .endObject(), +                        .endObject(), +                    .endObject(), +                    .startObject(), +                    .startObject("path-based"), +                        .field("path_match", "foo"), +                        .startObject("mapping"), +                            .field("type", "long"), +                        .endObject(), +                    .endObject(), +                .endObject(), +                .endArray(), +                .endObject().endObject();, +        IndexService index = createIndex("test", Settings.EMPTY, "type", mapping);, +        client().prepareIndex("test", "type", "1").setSource("foo", "abc").get();, +        assertThat(index.mapperService().fullName("foo"), instanceOf(KeywordFieldMapper.KeywordFieldType.class));, +    }, +++ b/qa/evil-tests/src/test/java/org/elasticsearch/bootstrap/EvilJarHellTests.java, +/*, + * Licensed to Elasticsearch under one or more contributor, + * license agreements. See the NOTICE file distributed with, + * this work for additional information regarding copyright, + * ownership. Elasticsearch licenses this file to you under, + * the Apache License, Version 2.0 (the "License"); you may, + * not use this file except in compliance with the License., + * You may obtain a copy of the License at, + *, + *    http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing,, + * software distributed under the License is distributed on an, + * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY, + * KIND, either express or implied.  See the License for the, + * specific language governing permissions and limitations, + * under the License., + */, +, +package org.elasticsearch.bootstrap;, +, +import org.elasticsearch.common.SuppressForbidden;, +import org.elasticsearch.test.ESTestCase;]