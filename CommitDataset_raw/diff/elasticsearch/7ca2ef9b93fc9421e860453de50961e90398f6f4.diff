[+++ b/src/main/java/org/elasticsearch/search/aggregations/bucket/nested/NestedAggregator.java, +import com.carrotsearch.hppc.IntArrayList;, +import com.carrotsearch.hppc.IntObjectOpenHashMap;, +    private BitSet rootDocs;, +    private int currentRootDoc = -1;, +    private final IntObjectOpenHashMap<IntArrayList> childDocIdBuffers = new IntObjectOpenHashMap<>();, +, +            BitDocIdSetFilter rootDocsFilter = context.searchContext().bitsetFilterCache().getBitDocIdSetFilter(NonNestedDocsFilter.INSTANCE);, +            BitDocIdSet rootDocIdSet = rootDocsFilter.getDocIdSet(reader);, +            rootDocs = rootDocIdSet.bits();, +        IntArrayList iterator = getChildren(parentDoc);, +        final int[] buffer =  iterator.buffer;, +        final int size = iterator.size();, +        for (int i = 0; i < size; i++) {, +            collectBucketNoCounts(buffer[i], bucketOrd);, +        protected void doClose() {, +            childDocIdBuffers.clear();, +        }    , +        , +    @Override, +    // The aggs framework can collect buckets for the same parent doc id more than once and because the children docs, +    // can only be consumed once we need to buffer the child docs. We only need to buffer child docs in the scope, +    // of the current root doc., +, +    // Examples:, +    // 1) nested agg wrapped is by terms agg and multiple buckets per document are emitted, +    // 2) Multiple nested fields are defined. A nested agg joins back to another nested agg via the reverse_nested agg., +    //      For each child in the first nested agg the second nested agg gets invoked with the same buckets / docids, +    private IntArrayList getChildren(final int parentDocId) throws IOException {, +        int rootDocId = rootDocs.nextSetBit(parentDocId);, +        if (currentRootDoc == rootDocId) {, +            final IntArrayList childDocIdBuffer = childDocIdBuffers.get(parentDocId);, +            if (childDocIdBuffer != null) {, +                return childDocIdBuffer;, +            } else {, +                // here we translate the parent doc to a list of its nested docs,, +                // and then collect buckets for every one of them so they'll be collected, +                final IntArrayList newChildDocIdBuffer = new IntArrayList();, +                childDocIdBuffers.put(parentDocId, newChildDocIdBuffer);, +                int prevParentDoc = parentDocs.prevSetBit(parentDocId - 1);, +                int childDocId;, +                if (childDocs.docID() > prevParentDoc) {, +                    childDocId = childDocs.docID();, +                } else {, +                    childDocId = childDocs.advance(prevParentDoc + 1);, +                }, +                for (; childDocId < parentDocId; childDocId = childDocs.nextDoc()) {, +                    newChildDocIdBuffer.add(childDocId);, +                }, +                return newChildDocIdBuffer;, +            }, +        } else {, +            this.currentRootDoc = rootDocId;, +            childDocIdBuffers.clear();, +            return getChildren(parentDocId);, +        }, +    }, +, +++ b/src/main/java/org/elasticsearch/search/aggregations/bucket/nested/NestedAggregator.java, +import com.carrotsearch.hppc.IntArrayList;, +import com.carrotsearch.hppc.IntObjectOpenHashMap;, +    private BitSet rootDocs;, +    private int currentRootDoc = -1;, +    private final IntObjectOpenHashMap<IntArrayList> childDocIdBuffers = new IntObjectOpenHashMap<>();, +, +            BitDocIdSetFilter rootDocsFilter = context.searchContext().bitsetFilterCache().getBitDocIdSetFilter(NonNestedDocsFilter.INSTANCE);, +            BitDocIdSet rootDocIdSet = rootDocsFilter.getDocIdSet(reader);, +            rootDocs = rootDocIdSet.bits();, +        IntArrayList iterator = getChildren(parentDoc);, +        final int[] buffer =  iterator.buffer;, +        final int size = iterator.size();, +        for (int i = 0; i < size; i++) {, +            collectBucketNoCounts(buffer[i], bucketOrd);, +        protected void doClose() {, +            childDocIdBuffers.clear();, +        }    , +        , +    @Override, +    // The aggs framework can collect buckets for the same parent doc id more than once and because the children docs, +    // can only be consumed once we need to buffer the child docs. We only need to buffer child docs in the scope, +    // of the current root doc., +, +    // Examples:, +    // 1) nested agg wrapped is by terms agg and multiple buckets per document are emitted, +    // 2) Multiple nested fields are defined. A nested agg joins back to another nested agg via the reverse_nested agg., +    //      For each child in the first nested agg the second nested agg gets invoked with the same buckets / docids, +    private IntArrayList getChildren(final int parentDocId) throws IOException {, +        int rootDocId = rootDocs.nextSetBit(parentDocId);, +        if (currentRootDoc == rootDocId) {, +            final IntArrayList childDocIdBuffer = childDocIdBuffers.get(parentDocId);, +            if (childDocIdBuffer != null) {, +                return childDocIdBuffer;, +            } else {, +                // here we translate the parent doc to a list of its nested docs,, +                // and then collect buckets for every one of them so they'll be collected, +                final IntArrayList newChildDocIdBuffer = new IntArrayList();, +                childDocIdBuffers.put(parentDocId, newChildDocIdBuffer);, +                int prevParentDoc = parentDocs.prevSetBit(parentDocId - 1);, +                int childDocId;, +                if (childDocs.docID() > prevParentDoc) {]