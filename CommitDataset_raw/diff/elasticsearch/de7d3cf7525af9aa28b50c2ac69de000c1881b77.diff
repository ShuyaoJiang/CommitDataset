[+++ b/core/src/main/java/org/elasticsearch/discovery/DiscoveryService.java, +++ b/core/src/main/java/org/elasticsearch/discovery/DiscoveryService.java, +++ b/core/src/main/java/org/elasticsearch/gateway/GatewayService.java, +        // check we didn't miss any cluster state that came in until now / during the addition, +        clusterService.submitStateUpdateTask("gateway_initial_state_recovery", new ClusterStateUpdateTask() {, +, +            @Override, +            public ClusterState execute(ClusterState currentState) throws Exception {, +                checkStateMeetsSettingsAndMaybeRecover(currentState);, +                return currentState;, +, +            @Override, +            public boolean runOnlyOnMaster() {, +                // It's OK to run on non masters as checkStateMeetsSettingsAndMaybeRecover checks for this, +                // we return false to avoid unneeded failure logs, +                return false;, +, +            @Override, +            public void onFailure(String source, Throwable t) {, +                logger.warn("unexpected failure while checking if state can be recovered. another attempt will be made with the next cluster state change", t);, +            }, +        });, +        checkStateMeetsSettingsAndMaybeRecover(event.state());, +    protected void checkStateMeetsSettingsAndMaybeRecover(ClusterState state) {, +        if (state.nodes().localNodeMaster() == false) {, +            // not our job to recover, +            return;, +        }, +        if (state.blocks().hasGlobalBlock(STATE_NOT_RECOVERED_BLOCK) == false) {, +            // already recovered, +            return;, +        }, +, +            performStateRecovery(enforceRecoverAfterTime, reason);, +    private void performStateRecovery(boolean enforceRecoverAfterTime, String reason) {, +        final Gateway.GatewayStateRecoveredListener recoveryListener = new GatewayRecoveryListener();, +                threadPool.schedule(recoverAfterTime, ThreadPool.Names.GENERIC, () -> {, +                threadPool.generic().execute(() -> gateway.performStateRecovery(recoveryListener));, +, +++ b/core/src/main/java/org/elasticsearch/discovery/DiscoveryService.java, +++ b/core/src/main/java/org/elasticsearch/gateway/GatewayService.java, +        // check we didn't miss any cluster state that came in until now / during the addition, +        clusterService.submitStateUpdateTask("gateway_initial_state_recovery", new ClusterStateUpdateTask() {, +, +            @Override, +            public ClusterState execute(ClusterState currentState) throws Exception {, +                checkStateMeetsSettingsAndMaybeRecover(currentState);, +                return currentState;, +, +            @Override, +            public boolean runOnlyOnMaster() {, +                // It's OK to run on non masters as checkStateMeetsSettingsAndMaybeRecover checks for this, +                // we return false to avoid unneeded failure logs, +                return false;, +, +            @Override, +            public void onFailure(String source, Throwable t) {, +                logger.warn("unexpected failure while checking if state can be recovered. another attempt will be made with the next cluster state change", t);, +            }, +        });, +        checkStateMeetsSettingsAndMaybeRecover(event.state());, +    protected void checkStateMeetsSettingsAndMaybeRecover(ClusterState state) {, +        if (state.nodes().localNodeMaster() == false) {, +            // not our job to recover, +            return;, +        }, +        if (state.blocks().hasGlobalBlock(STATE_NOT_RECOVERED_BLOCK) == false) {, +            // already recovered, +            return;, +        }, +, +            performStateRecovery(enforceRecoverAfterTime, reason);, +    private void performStateRecovery(boolean enforceRecoverAfterTime, String reason) {, +        final Gateway.GatewayStateRecoveredListener recoveryListener = new GatewayRecoveryListener();, +                threadPool.schedule(recoverAfterTime, ThreadPool.Names.GENERIC, () -> {, +                threadPool.generic().execute(() -> gateway.performStateRecovery(recoveryListener));, +, +++ b/docs/reference/query-dsl/geo-bounding-box-query.asciidoc, +    "boost" : {, +++ b/core/src/main/java/org/elasticsearch/discovery/DiscoveryService.java, +++ b/core/src/main/java/org/elasticsearch/gateway/GatewayService.java, +        // check we didn't miss any cluster state that came in until now / during the addition, +        clusterService.submitStateUpdateTask("gateway_initial_state_recovery", new ClusterStateUpdateTask() {, +, +            @Override, +            public ClusterState execute(ClusterState currentState) throws Exception {, +                checkStateMeetsSettingsAndMaybeRecover(currentState);, +                return currentState;, +, +            @Override, +            public boolean runOnlyOnMaster() {, +                // It's OK to run on non masters as checkStateMeetsSettingsAndMaybeRecover checks for this, +                // we return false to avoid unneeded failure logs, +                return false;, +, +            @Override, +            public void onFailure(String source, Throwable t) {, +                logger.warn("unexpected failure while checking if state can be recovered. another attempt will be made with the next cluster state change", t);, +            }, +        });]