[+++ b/plugins/ingest/src/main/java/org/elasticsearch/ingest/IngestDocument.java, +    private final Map<String, Object> sourceAndMetadata;, +        this.sourceAndMetadata = new HashMap<>();, +        this.sourceAndMetadata.putAll(source);, +        this.sourceAndMetadata.put(MetaData.INDEX.getFieldName(), index);, +        this.sourceAndMetadata.put(MetaData.TYPE.getFieldName(), type);, +        this.sourceAndMetadata.put(MetaData.ID.getFieldName(), id);, +            this.sourceAndMetadata.put(MetaData.ROUTING.getFieldName(), routing);, +            this.sourceAndMetadata.put(MetaData.PARENT.getFieldName(), parent);, +            this.sourceAndMetadata.put(MetaData.TIMESTAMP.getFieldName(), timestamp);, +            this.sourceAndMetadata.put(MetaData.TTL.getFieldName(), ttl);, +, +     * Copy constructor that creates a new {@link IngestDocument} which has exactly the same properties as the one provided as argument, +        this(new HashMap<>(other.sourceAndMetadata), new HashMap<>(other.ingestMetadata));, +     * init time, which makes equality comparisons impossible in tests., +    public IngestDocument(Map<String, Object> sourceAndMetadata, Map<String, String> ingestMetadata) {, +        this.sourceAndMetadata = sourceAndMetadata;, +        this.ingestMetadata = ingestMetadata;, +     * @throws IllegalArgumentException if the path is null, empty, invalid, if the field doesn't exist, +     * or if the field that is found at the provided path is not of the expected type., +        FieldPath fieldPath = new FieldPath(path);, +        Object context = fieldPath.initialContext;, +        for (String pathElement : fieldPath.pathElements) {, +        return cast(path, context, clazz);, +     * @throws IllegalArgumentException if the path is null, empty or invalid., +        FieldPath fieldPath = new FieldPath(path);, +        Object context = fieldPath.initialContext;, +        for (int i = 0; i < fieldPath.pathElements.length - 1; i++) {, +            String pathElement = fieldPath.pathElements[i];, +        String leafKey = fieldPath.pathElements[fieldPath.pathElements.length - 1];, +     * Removes the field identified by the provided path., +     * @throws IllegalArgumentException if the path is null, empty, invalid or if the field doesn't exist., +        FieldPath fieldPath = new FieldPath(path);, +        Object context = fieldPath.initialContext;, +        for (int i = 0; i < fieldPath.pathElements.length - 1; i++) {, +            context = resolve(fieldPath.pathElements[i], path, context);, +        String leafKey = fieldPath.pathElements[fieldPath.pathElements.length - 1];, +     * @throws IllegalArgumentException if the path is null, empty, invalid or if the field doesn't exist., +     * @throws IllegalArgumentException if the path is null, empty, invalid or if the field doesn't exist., +        FieldPath fieldPath = new FieldPath(path);, +        Object context = fieldPath.initialContext;, +        for (int i = 0; i < fieldPath.pathElements.length - 1; i++) {, +            String pathElement = fieldPath.pathElements[i];, +        String leafKey = fieldPath.pathElements[fieldPath.pathElements.length - 1];, +    private static <T> T cast(String path, Object object, Class<T> clazz) {, +        if (object == null) {, +            return null;, +        if (clazz.isInstance(object)) {, +            return clazz.cast(object);, +        throw new IllegalArgumentException("field [" + path + "] of type [" + object.getClass().getName() + "] cannot be cast to [" + clazz.getName() + "]");, +     * one time operation that extracts the metadata fields from the ingest document and returns them., +     * Metadata fields that used to be accessible as ordinary top level fields will be removed as part of this call., +    public Map<MetaData, String> extractMetadata() {, +        Map<MetaData, String> metadataMap = new HashMap<>();, +        for (MetaData metaData : MetaData.values()) {, +            metadataMap.put(metaData, cast(metaData.getFieldName(), sourceAndMetadata.remove(metaData.getFieldName()), String.class));, +        }, +        return metadataMap;, +    }, +, +    /**, +     * Returns the available ingest metadata fields, by default only timestamp, but it is possible to set additional ones., +     * Use only for reading values, modify them instead using {@link #setFieldValue(String, Object)} and {@link #removeField(String)}, +     */, +    public Map<String, String> getIngestMetadata() {, +        return this.ingestMetadata;, +    }, +, +    /**, +     * Returns the document including its metadata fields, unless {@link #extractMetadata()} has been called, in which case the, +     * metadata fields will not be present anymore. Should be used only for reading., +     * Modify the document instead using {@link #setFieldValue(String, Object)} and {@link #removeField(String)}, +     */, +    public Map<String, Object> getSourceAndMetadata() {, +        return this.sourceAndMetadata;, +        return Objects.equals(sourceAndMetadata, other.sourceAndMetadata) &&, +        return Objects.hash(sourceAndMetadata, ingestMetadata);, +                " sourceAndMetadata=" + sourceAndMetadata +, +, +    private class FieldPath {, +        private final String[] pathElements;, +        private final Object initialContext;, +, +        private FieldPath(String path) {, +            if (Strings.isEmpty(path)) {, +                throw new IllegalArgumentException("path cannot be null nor empty");, +            }, +            String newPath;, +            if (path.startsWith("_ingest.")) {, +                initialContext = ingestMetadata;, +                newPath = path.substring(8, path.length());, +            } else {, +                initialContext = sourceAndMetadata;, +                newPath = path;, +            }, +            if (newPath.startsWith("_source.")) {, +                newPath = newPath.substring(8, path.length());, +            }, +, +            this.pathElements = Strings.splitStringToArray(newPath, '.');]