[+++ b/core-signatures.txt, +++ b/core-signatures.txt, +++ b/pom.xml, +        <lucene.version>4.9.0</lucene.version>, +++ b/core-signatures.txt, +++ b/pom.xml, +        <lucene.version>4.9.0</lucene.version>, +++ /dev/null, +++ b/core-signatures.txt, +++ b/pom.xml, +        <lucene.version>4.9.0</lucene.version>, +++ /dev/null, +++ b/src/main/java/org/apache/lucene/index/XOrdinalMap.java, +package org.apache.lucene.index;, +, +/*, + * Licensed to the Apache Software Foundation (ASF) under one or more, + * contributor license agreements.  See the NOTICE file distributed with, + * this work for additional information regarding copyright ownership., + * The ASF licenses this file to You under the Apache License, Version 2.0, + * (the "License"); you may not use this file except in compliance with, + * the License.  You may obtain a copy of the License at, + *, + *     http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS,, + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied., + * See the License for the specific language governing permissions and, + * limitations under the License., + */, +, +import java.io.IOException;, +import java.util.Arrays;, +, +import org.apache.lucene.index.MultiTermsEnum.TermsEnumIndex;, +import org.apache.lucene.index.MultiTermsEnum.TermsEnumWithSlice;, +import org.apache.lucene.util.Accountable;, +import org.apache.lucene.util.InPlaceMergeSorter;, +import org.apache.lucene.util.LongValues;, +import org.apache.lucene.util.RamUsageEstimator;, +import org.apache.lucene.util.packed.AppendingPackedLongBuffer;, +import org.apache.lucene.util.packed.MonotonicAppendingLongBuffer;, +import org.apache.lucene.util.packed.PackedInts;, +, +/** maps per-segment ordinals to/from global ordinal space */, +// TODO: we could also have a utility method to merge Terms[] and use size() as a weight when we need it, +// TODO: use more efficient packed ints structures?, +// TODO: pull this out? its pretty generic (maps between N ord()-enabled TermsEnums) , +public class XOrdinalMap implements Accountable {, +, +static {, +  assert org.elasticsearch.Version.CURRENT.luceneVersion == org.apache.lucene.util.Version.LUCENE_4_9: "Remove this code once we upgrade to Lucene 4.10 (LUCENE-5780, LUCENE-5782)";, +}, +  , +  private static class SegmentMap implements Accountable {, +    private static final long BASE_RAM_BYTES_USED = RamUsageEstimator.shallowSizeOfInstance(SegmentMap.class);, +    , +    /** Build a map from an index into a sorted view of `weights` to an index into `weights`. */, +    private static int[] map(final long[] weights) {, +      final int[] newToOld = new int[weights.length];, +      for (int i = 0; i < weights.length; ++i) {, +        newToOld[i] = i;, +      }, +      new InPlaceMergeSorter() {, +        @Override, +        protected void swap(int i, int j) {, +          final int tmp = newToOld[i];, +          newToOld[i] = newToOld[j];, +          newToOld[j] = tmp;, +        }, +        @Override, +        protected int compare(int i, int j) {, +          // j first since we actually want higher weights first, +          return Long.compare(weights[newToOld[j]], weights[newToOld[i]]);, +        }, +      }.sort(0, weights.length);, +      return newToOld;, +    }, +    , +    /** Inverse the map. */, +    private static int[] inverse(int[] map) {, +      final int[] inverse = new int[map.length];, +      for (int i = 0; i < map.length; ++i) {, +        inverse[map[i]] = i;, +      }, +      return inverse;, +    }, +    , +    private final int[] newToOld, oldToNew;, +    , +    SegmentMap(long[] weights) {, +      newToOld = map(weights);, +      oldToNew = inverse(newToOld);, +      assert Arrays.equals(newToOld, inverse(oldToNew));, +    }, +    , +    int newToOld(int segment) {, +      return newToOld[segment];, +    }]