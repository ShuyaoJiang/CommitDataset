[+++ b/core/src/main/java/org/elasticsearch/client/transport/TransportClient.java, +++ b/core/src/main/java/org/elasticsearch/client/transport/TransportClient.java, +++ b/core/src/main/java/org/elasticsearch/common/blobstore/fs/FsBlobContainer.java, +import java.nio.file.FileVisitResult;, +import java.nio.file.SimpleFileVisitor;, +        if (Files.isDirectory(blobPath)) {, +            // delete directory recursively as long as it is empty (only contains empty directories),, +            // which is the reason we aren't deleting any files, only the directories on the post-visit, +            Files.walkFileTree(blobPath, new SimpleFileVisitor<Path>() {, +                @Override, +                public FileVisitResult postVisitDirectory(Path dir, IOException exc) throws IOException {, +                    Files.delete(dir);, +                    return FileVisitResult.CONTINUE;, +                }, +            });, +        } else {, +    }, +++ b/core/src/main/java/org/elasticsearch/client/transport/TransportClient.java, +++ b/core/src/main/java/org/elasticsearch/common/blobstore/fs/FsBlobContainer.java, +import java.nio.file.FileVisitResult;, +import java.nio.file.SimpleFileVisitor;, +        if (Files.isDirectory(blobPath)) {, +            // delete directory recursively as long as it is empty (only contains empty directories),, +            // which is the reason we aren't deleting any files, only the directories on the post-visit, +            Files.walkFileTree(blobPath, new SimpleFileVisitor<Path>() {, +                @Override, +                public FileVisitResult postVisitDirectory(Path dir, IOException exc) throws IOException {, +                    Files.delete(dir);, +                    return FileVisitResult.CONTINUE;, +                }, +            });, +        } else {, +    }, +++ b/core/src/main/java/org/elasticsearch/index/mapper/FieldMapper.java, +    private final Version indexCreatedVersion;, +        this.indexCreatedVersion = Version.indexCreated(indexSettings);, +                        && indexCreatedVersion.before(Version.V_5_0_0_alpha1)) {, +++ b/core/src/main/java/org/elasticsearch/client/transport/TransportClient.java, +++ b/core/src/main/java/org/elasticsearch/common/blobstore/fs/FsBlobContainer.java, +import java.nio.file.FileVisitResult;, +import java.nio.file.SimpleFileVisitor;, +        if (Files.isDirectory(blobPath)) {, +            // delete directory recursively as long as it is empty (only contains empty directories),, +            // which is the reason we aren't deleting any files, only the directories on the post-visit, +            Files.walkFileTree(blobPath, new SimpleFileVisitor<Path>() {, +                @Override, +                public FileVisitResult postVisitDirectory(Path dir, IOException exc) throws IOException {, +                    Files.delete(dir);, +                    return FileVisitResult.CONTINUE;, +                }, +            });, +        } else {, +    }, +++ b/core/src/main/java/org/elasticsearch/index/mapper/FieldMapper.java, +    private final Version indexCreatedVersion;, +        this.indexCreatedVersion = Version.indexCreated(indexSettings);, +                        && indexCreatedVersion.before(Version.V_5_0_0_alpha1)) {, +++ b/core/src/main/java/org/elasticsearch/index/query/CommonTermsQueryBuilder.java, +            throw new IllegalArgumentException("text cannot be null");, +, +        String fieldName = null;, +        XContentParser.Token token;, +            } else if (parseContext.isDeprecatedSetting(currentFieldName)) {, +                // skip, +            } else if (token == XContentParser.Token.START_OBJECT) {, +                if (fieldName != null) {, +                    throw new ParsingException(parser.getTokenLocation(), "[common] query doesn't support multiple fields, found [", +                            + fieldName + "] and [" + currentFieldName + "]");, +                }, +                fieldName = currentFieldName;, +                while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {, +                    if (token == XContentParser.Token.FIELD_NAME) {, +                        currentFieldName = parser.currentName();, +                fieldName = parser.currentName();, +++ b/core/src/main/java/org/elasticsearch/client/transport/TransportClient.java, +++ b/core/src/main/java/org/elasticsearch/common/blobstore/fs/FsBlobContainer.java, +import java.nio.file.FileVisitResult;, +import java.nio.file.SimpleFileVisitor;, +        if (Files.isDirectory(blobPath)) {, +            // delete directory recursively as long as it is empty (only contains empty directories),, +            // which is the reason we aren't deleting any files, only the directories on the post-visit, +            Files.walkFileTree(blobPath, new SimpleFileVisitor<Path>() {, +                @Override, +                public FileVisitResult postVisitDirectory(Path dir, IOException exc) throws IOException {, +                    Files.delete(dir);, +                    return FileVisitResult.CONTINUE;, +                }, +            });, +        } else {, +    }, +++ b/core/src/main/java/org/elasticsearch/index/mapper/FieldMapper.java, +    private final Version indexCreatedVersion;, +        this.indexCreatedVersion = Version.indexCreated(indexSettings);, +                        && indexCreatedVersion.before(Version.V_5_0_0_alpha1)) {, +++ b/core/src/main/java/org/elasticsearch/index/query/CommonTermsQueryBuilder.java, +            throw new IllegalArgumentException("text cannot be null");, +, +        String fieldName = null;, +        XContentParser.Token token;, +            } else if (parseContext.isDeprecatedSetting(currentFieldName)) {]