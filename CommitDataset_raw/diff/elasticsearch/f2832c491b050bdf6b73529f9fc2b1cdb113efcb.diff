[+++ /dev/null, +++ /dev/null, +++ b/core/src/main/java/org/elasticsearch/index/mapper/DocumentMapper.java, +            mapperService.checkMappersCompatibility(type, mapping, updateAllTypes);, +++ /dev/null, +++ b/core/src/main/java/org/elasticsearch/index/mapper/DocumentMapper.java, +            mapperService.checkMappersCompatibility(type, mapping, updateAllTypes);, +++ b/core/src/main/java/org/elasticsearch/index/mapper/FieldMapper.java, +++ /dev/null, +++ b/core/src/main/java/org/elasticsearch/index/mapper/DocumentMapper.java, +            mapperService.checkMappersCompatibility(type, mapping, updateAllTypes);, +++ b/core/src/main/java/org/elasticsearch/index/mapper/FieldMapper.java, +++ b/core/src/main/java/org/elasticsearch/index/mapper/FieldTypeLookup.java, +import java.util.Collections;, +    /** Full field name to types containing a mapping for this full name. */, +    private final CopyOnWriteHashMap<String, Set<String>> fullNameToTypes;, +, +    /** Index field name to types containing a mapping for this index name. */, +    private final CopyOnWriteHashMap<String, Set<String>> indexNameToTypes;, +, +        fullNameToTypes = new CopyOnWriteHashMap<>();, +        indexNameToTypes = new CopyOnWriteHashMap<>();, +    private FieldTypeLookup(, +            CopyOnWriteHashMap<String, MappedFieldTypeReference> fullName,, +            CopyOnWriteHashMap<String, Set<String>> fullNameToTypes,, +            CopyOnWriteHashMap<String, MappedFieldTypeReference> indexName,, +            CopyOnWriteHashMap<String, Set<String>> indexNameToTypes) {, +        this.fullNameToFieldType = fullName;, +        this.fullNameToTypes = fullNameToTypes;, +        this.indexNameToFieldType = indexName;, +        this.indexNameToTypes = indexNameToTypes;, +    }, +, +    private static CopyOnWriteHashMap<String, Set<String>> addType(CopyOnWriteHashMap<String, Set<String>> map, String key, String type) {, +        Set<String> types = map.get(key);, +        if (types == null) {, +            return map.copyAndPut(key, Collections.singleton(type));, +        } else if (types.contains(type)) {, +            // noting to do, +            return map;, +        } else {, +            Set<String> newTypes = new HashSet<>(types.size() + 1);, +            newTypes.addAll(types);, +            newTypes.add(type);, +            assert newTypes.size() == types.size() + 1;, +            newTypes = Collections.unmodifiableSet(newTypes);, +            return map.copyAndPut(key, newTypes);, +        }, +        CopyOnWriteHashMap<String, Set<String>> fullNameToTypes = this.fullNameToTypes;, +        CopyOnWriteHashMap<String, Set<String>> indexNameToTypes = this.indexNameToTypes;, +, +            fullNameToTypes = addType(fullNameToTypes, fieldType.names().fullName(), type);, +            indexNameToTypes = addType(indexNameToTypes, fieldType.names().indexName(), type);, +        return new FieldTypeLookup(fullName, fullNameToTypes, indexName, indexNameToTypes);, +    }, +, +    private static boolean beStrict(String type, Set<String> types, boolean updateAllTypes) {, +        assert types.size() >= 1;, +        if (updateAllTypes) {, +            return false;, +        } else if (types.size() == 1 && types.contains(type)) {, +            // we are implicitly updating all types, +            return false;, +        } else {, +            return true;, +        }, +    public void checkCompatibility(String type, Collection<FieldMapper> fieldMappers, boolean updateAllTypes) {, +        for (FieldMapper fieldMapper : fieldMappers) {, +                    final Set<String> types = fullNameToTypes.get(fieldMapper.fieldType().names().fullName());, +                    boolean strict = beStrict(type, types, updateAllTypes);, +                    final Set<String> types = indexNameToTypes.get(fieldMapper.fieldType().names().indexName());, +                    boolean strict = beStrict(type, types, updateAllTypes);, +    /** Get the set of types that have a mapping for the given field. */, +    public Set<String> getTypes(String field) {, +        Set<String> types = fullNameToTypes.get(field);, +        if (types == null) {, +            types = Collections.emptySet();, +        }, +        return types;, +    }, +, +    /** Get the set of types that have a mapping for the given field. */, +    public Set<String> getTypesByIndexName(String field) {, +        Set<String> types = indexNameToTypes.get(field);, +        if (types == null) {, +            types = Collections.emptySet();, +        }, +        return types;, +    }, +, +++ /dev/null, +++ b/core/src/main/java/org/elasticsearch/index/mapper/DocumentMapper.java, +            mapperService.checkMappersCompatibility(type, mapping, updateAllTypes);, +++ b/core/src/main/java/org/elasticsearch/index/mapper/FieldMapper.java, +++ b/core/src/main/java/org/elasticsearch/index/mapper/FieldTypeLookup.java, +import java.util.Collections;, +    /** Full field name to types containing a mapping for this full name. */, +    private final CopyOnWriteHashMap<String, Set<String>> fullNameToTypes;, +, +    /** Index field name to types containing a mapping for this index name. */]