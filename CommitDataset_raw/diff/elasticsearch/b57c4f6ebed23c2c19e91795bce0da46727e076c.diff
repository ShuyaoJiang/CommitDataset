[+++ b/elasticsearch/src/main/java/org/elasticsearch/xpack/watcher/Watcher.java, +                watchLockService, clock, threadPool, watchParser, watcherClientProxy);, +        final WatcherService watcherService = new WatcherService(settings, triggerService, executionService, watchLockService,, +                watcherIndexTemplateRegistry, watchParser, watcherClientProxy);, +                watcherLifeCycleService, executionService, triggerEngineListener, watcherService, watchParser,, +                configuredTriggerEngine, triggeredWatchStore, watcherSearchTemplateService, watcherClientProxy);, +                "[{}, {}, {}*]", (Object) value, Watch.INDEX, TriggeredWatchStore.INDEX_NAME, HistoryStore.INDEX_PREFIX);, +++ b/elasticsearch/src/main/java/org/elasticsearch/xpack/watcher/Watcher.java, +                watchLockService, clock, threadPool, watchParser, watcherClientProxy);, +        final WatcherService watcherService = new WatcherService(settings, triggerService, executionService, watchLockService,, +                watcherIndexTemplateRegistry, watchParser, watcherClientProxy);, +                watcherLifeCycleService, executionService, triggerEngineListener, watcherService, watchParser,, +                configuredTriggerEngine, triggeredWatchStore, watcherSearchTemplateService, watcherClientProxy);, +                "[{}, {}, {}*]", (Object) value, Watch.INDEX, TriggeredWatchStore.INDEX_NAME, HistoryStore.INDEX_PREFIX);, +++ b/elasticsearch/src/main/java/org/elasticsearch/xpack/watcher/WatcherLifeCycleService.java, +import org.elasticsearch.xpack.watcher.watch.Watch;, +                        .filter(index -> Watch.INDEX.equals(index.getName())), +                final boolean isWatchIndexOpenInPreviousClusterState = event.previousState().metaData().hasIndex(Watch.INDEX) &&, +                        event.previousState().metaData().index(Watch.INDEX).getState() == IndexMetaData.State.OPEN;, +                final boolean isWatchIndexClosedInCurrentClusterState = event.state().metaData().hasIndex(Watch.INDEX) &&, +                        event.state().metaData().index(Watch.INDEX).getState() == IndexMetaData.State.CLOSE;, +                final boolean hasWatcherIndexBeenClosed = isWatchIndexOpenInPreviousClusterState && isWatchIndexClosedInCurrentClusterState;, +++ b/elasticsearch/src/main/java/org/elasticsearch/xpack/watcher/Watcher.java, +                watchLockService, clock, threadPool, watchParser, watcherClientProxy);, +        final WatcherService watcherService = new WatcherService(settings, triggerService, executionService, watchLockService,, +                watcherIndexTemplateRegistry, watchParser, watcherClientProxy);, +                watcherLifeCycleService, executionService, triggerEngineListener, watcherService, watchParser,, +                configuredTriggerEngine, triggeredWatchStore, watcherSearchTemplateService, watcherClientProxy);, +                "[{}, {}, {}*]", (Object) value, Watch.INDEX, TriggeredWatchStore.INDEX_NAME, HistoryStore.INDEX_PREFIX);, +++ b/elasticsearch/src/main/java/org/elasticsearch/xpack/watcher/WatcherLifeCycleService.java, +import org.elasticsearch.xpack.watcher.watch.Watch;, +                        .filter(index -> Watch.INDEX.equals(index.getName())), +                final boolean isWatchIndexOpenInPreviousClusterState = event.previousState().metaData().hasIndex(Watch.INDEX) &&, +                        event.previousState().metaData().index(Watch.INDEX).getState() == IndexMetaData.State.OPEN;, +                final boolean isWatchIndexClosedInCurrentClusterState = event.state().metaData().hasIndex(Watch.INDEX) &&, +                        event.state().metaData().index(Watch.INDEX).getState() == IndexMetaData.State.CLOSE;, +                final boolean hasWatcherIndexBeenClosed = isWatchIndexOpenInPreviousClusterState && isWatchIndexClosedInCurrentClusterState;, +++ b/elasticsearch/src/main/java/org/elasticsearch/xpack/watcher/WatcherService.java, +import org.apache.logging.log4j.message.ParameterizedMessage;, +import org.apache.logging.log4j.util.Supplier;, +import org.elasticsearch.ElasticsearchException;, +import org.elasticsearch.action.admin.indices.refresh.RefreshRequest;, +import org.elasticsearch.action.admin.indices.refresh.RefreshResponse;, +import org.elasticsearch.action.search.SearchRequest;, +import org.elasticsearch.action.search.SearchResponse;, +import org.elasticsearch.cluster.metadata.IndexMetaData;, +import org.elasticsearch.common.unit.TimeValue;, +import org.elasticsearch.search.SearchHit;, +import org.elasticsearch.search.builder.SearchSourceBuilder;, +import org.elasticsearch.search.sort.SortBuilders;, +import org.elasticsearch.xpack.watcher.support.init.proxy.WatcherClientProxy;, +import org.elasticsearch.xpack.watcher.watch.WatchStoreUtils;, +import java.util.ArrayList;, +import java.util.Collection;, +import java.util.Collections;, +import java.util.List;, +import static org.elasticsearch.xpack.watcher.watch.Watch.DOC_TYPE;, +import static org.elasticsearch.xpack.watcher.watch.Watch.INDEX;, +    private final TimeValue scrollTimeout;, +    private final int scrollSize;, +    private final Watch.Parser parser;, +    private final WatcherClientProxy client;, +    public WatcherService(Settings settings, TriggerService triggerService,, +                          ExecutionService executionService, WatchLockService watchLockService,, +                          WatcherIndexTemplateRegistry watcherIndexTemplateRegistry, Watch.Parser parser, WatcherClientProxy client) {, +        this.scrollTimeout = settings.getAsTime("xpack.watcher.watch.scroll.timeout", TimeValue.timeValueSeconds(30));, +        this.scrollSize = settings.getAsInt("xpack.watcher.watch.scroll.size", 100);, +        this.parser = parser;, +        this.client = client;, +                triggerService.start(loadWatches(clusterState));, +        return executionService.validate(state);, +     * This reads all watches from the .watches index/alias and puts them into memory for a short period of time,, +     * before they are fed into the trigger service., +     *, +     * This is only invoked when a node becomes master, so either on start up or when a master node switches - while watcher is started up, +    private Collection<Watch> loadWatches(ClusterState clusterState) {, +        IndexMetaData indexMetaData = WatchStoreUtils.getConcreteIndex(INDEX, clusterState.metaData());, +, +        // no index exists, all good, we can start, +        if (indexMetaData == null) {, +            return Collections.emptyList();, +        RefreshResponse refreshResponse = client.refresh(new RefreshRequest(INDEX));, +        if (refreshResponse.getSuccessfulShards() < indexMetaData.getNumberOfShards()) {, +            throw illegalState("not all required shards have been refreshed");, +        }, +, +        List<Watch> watches = new ArrayList<>();, +        SearchRequest searchRequest = new SearchRequest(INDEX), +                .types(DOC_TYPE), +                .scroll(scrollTimeout), +                .source(new SearchSourceBuilder(), +                        .size(scrollSize), +                        .sort(SortBuilders.fieldSort("_doc")), +                        .version(true));, +        SearchResponse response = client.search(searchRequest, null);, +        try {, +            if (response.getTotalShards() != response.getSuccessfulShards()) {, +                throw new ElasticsearchException("Partial response while loading watches");, +            }, +]