[+++ b/server/src/main/java/org/elasticsearch/cluster/coordination/CoordinationState.java, +        assert join.targetMatches(localNode) : "handling join " + join + " for the wrong node " + localNode;, +++ b/server/src/main/java/org/elasticsearch/cluster/coordination/CoordinationState.java, +        assert join.targetMatches(localNode) : "handling join " + join + " for the wrong node " + localNode;, +++ b/server/src/main/java/org/elasticsearch/cluster/coordination/Coordinator.java, +            && lastJoin.get().targetMatches(leader), +++ b/server/src/main/java/org/elasticsearch/cluster/coordination/CoordinationState.java, +        assert join.targetMatches(localNode) : "handling join " + join + " for the wrong node " + localNode;, +++ b/server/src/main/java/org/elasticsearch/cluster/coordination/Coordinator.java, +            && lastJoin.get().targetMatches(leader), +++ b/server/src/main/java/org/elasticsearch/cluster/coordination/Join.java, +    public boolean targetMatches(DiscoveryNode matchingNode) {, +        return targetNode.getId().equals(matchingNode.getId());, +    }, +, +++ b/server/src/main/java/org/elasticsearch/cluster/coordination/CoordinationState.java, +        assert join.targetMatches(localNode) : "handling join " + join + " for the wrong node " + localNode;, +++ b/server/src/main/java/org/elasticsearch/cluster/coordination/Coordinator.java, +            && lastJoin.get().targetMatches(leader), +++ b/server/src/main/java/org/elasticsearch/cluster/coordination/Join.java, +    public boolean targetMatches(DiscoveryNode matchingNode) {, +        return targetNode.getId().equals(matchingNode.getId());, +    }, +, +++ b/server/src/test/java/org/elasticsearch/cluster/coordination/CoordinatorTests.java, +import org.elasticsearch.cluster.ClusterModule;, +import org.elasticsearch.common.io.stream.BytesStreamOutput;, +import org.elasticsearch.common.io.stream.NamedWriteableAwareStreamInput;, +import org.elasticsearch.common.io.stream.NamedWriteableRegistry;, +import org.elasticsearch.common.io.stream.StreamInput;, +        nonLeader.onNode(() -> {, +            final List<Runnable> cleanupActions = new ArrayList<>();, +            cleanupActions.add(disconnectedNodes::clear);, +            cleanupActions.add(blackholedNodes::clear);, +            cleanupActions.add(() -> disruptStorage = false);, +, +                        clusterNode.onNode(() -> {, +                        clusterNode.onNode(, +                        // reboot random node, +                        logger.debug("----> [runRandomly {}] rebooting [{}]", thisStep, clusterNode.getId());, +                        clusterNode.close();, +                        clusterNodes.forEach(, +                            cn -> deterministicTaskQueue.scheduleNow(cn.onNode(, +                                new Runnable() {, +                                    @Override, +                                    public void run() {, +                                        cn.transportService.disconnectFromNode(clusterNode.getLocalNode());, +                                    }, +, +                                    @Override, +                                    public String toString() {, +                                        return "disconnect from " + clusterNode.getLocalNode() + " after shutdown";, +                                    }, +                                })));, +                        clusterNodes.replaceAll(cn -> cn == clusterNode ? cn.restartedNode() : cn);, +                    } else if (rarely()) {, +                        final ClusterNode clusterNode = getAnyNode();, +                        clusterNode.onNode(() -> {, +                        clusterNode.onNode(, +            logger.debug("running {} cleanup actions", cleanupActions.size());, +            cleanupActions.forEach(Runnable::run);, +            logger.debug("finished running cleanup actions");, +        private final ConnectionStatus preferredUnknownNodeConnectionStatus =, +            randomFrom(ConnectionStatus.DISCONNECTED, ConnectionStatus.BLACK_HOLE);, +, +            } else if (nodeExists(sender) && nodeExists(destination)) {, +            } else {, +                connectionStatus = usually() ? preferredUnknownNodeConnectionStatus :, +                    randomFrom(ConnectionStatus.DISCONNECTED, ConnectionStatus.BLACK_HOLE);, +        boolean nodeExists(DiscoveryNode node) {, +            return clusterNodes.stream().anyMatch(cn -> cn.getLocalNode().equals(node));, +        }, +, +            private final DiscoveryNode localNode;, +                this(nodeIndex, createDiscoveryNode(nodeIndex, masterEligible),, +                    localNode -> new MockPersistedState(0L,, +                        clusterState(0L, 0L, localNode, VotingConfiguration.EMPTY_CONFIG, VotingConfiguration.EMPTY_CONFIG, 0L)));, +            ClusterNode(int nodeIndex, DiscoveryNode localNode, Function<DiscoveryNode, PersistedState> persistedStateSupplier) {, +                this.nodeIndex = nodeIndex;, +                this.localNode = localNode;, +                persistedState = persistedStateSupplier.apply(localNode);, +                onNodeLog(localNode, this::setUp).run();, +                mockTransport = new DisruptableMockTransport(localNode, logger) {, +                    protected void execute(Runnable runnable) {, +                        deterministicTaskQueue.scheduleNow(onNode(runnable));, +                    protected ConnectionStatus getConnectionStatus(DiscoveryNode destination) {, +                        return Cluster.this.getConnectionStatus(getLocalNode(), destination);, +                    protected Optional<DisruptableMockTransport> getDisruptableMockTransport(TransportAddress address) {, +                        return clusterNodes.stream().map(cn -> cn.mockTransport), +                            .filter(transport -> transport.getLocalNode().getAddress().equals(address)).findAny();, +                    runnable -> deterministicTaskQueue.scheduleNow(onNode(runnable)));, +                    settings, deterministicTaskQueue.getThreadPool(this::onNode), NOOP_TRANSPORT_INTERCEPTOR,, +                logger.trace("starting up [{}]", localNode);, +            void close() {, +                logger.trace("taking down [{}]", localNode);, +                //transportService.stop(); // does blocking stuff :/, +                masterService.stop();, +                coordinator.stop();, +                //transportService.close(); // does blocking stuff :/, +                masterService.close();]