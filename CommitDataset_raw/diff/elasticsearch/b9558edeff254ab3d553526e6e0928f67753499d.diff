[+++ b/src/main/java/org/elasticsearch/action/search/type/TransportSearchTypeAction.java, +                    if (logger.isDebugEnabled()) {, +                        logger.debug("All shards failied for phase: [{}]", firstPhaseName(), t);, +                    }, +++ b/src/main/java/org/elasticsearch/action/search/type/TransportSearchTypeAction.java, +                    if (logger.isDebugEnabled()) {, +                        logger.debug("All shards failied for phase: [{}]", firstPhaseName(), t);, +                    }, +++ b/src/main/java/org/elasticsearch/cluster/routing/allocation/allocator/BalancedShardsAllocator.java, +                        advance_range: , +                                if (lowIdx > 0 && highIdx-1 > 0 // is there a chance for a higher delta? , +                                    && (weights[highIdx-1] - weights[0] > threshold) // check if we need to break at all, +                                    ) {, +                                    /* This is a special case if allocations from the "heaviest" to the "lighter" nodes is not possible , +                                     * due to some allocation decider restrictions like zone awareness. if one zone has for instance , +                                     * less nodes than another zone. so one zone is horribly overloaded from a balanced perspective but we, +                                     * can't move to the "lighter" shards since otherwise the zone would go over capacity., +                                     * , +                                     * This break jumps straight to the condition below were we start moving from the high index towards , +                                     * the low index to shrink the window we are considering for balance from the other direction. , +                                     * (check shrinking the window from MAX to MIN), +                                     * See #3580, +                                     */, +                                    break advance_range;, +                                }, +                            /* Shrinking the window from MIN to MAX, +                             * we can't move from any shard from the min node lets move on to the next node, +                            /* Shrinking the window from MAX to MIN, +                             * now we go max to min since obviously we can't move anything to the max node , +             * allocate on the minimal eligible node., +                if (decision.type() == Type.YES) { // TODO maybe we can respect throttling here too?, +++ b/src/main/java/org/elasticsearch/action/search/type/TransportSearchTypeAction.java, +                    if (logger.isDebugEnabled()) {, +                        logger.debug("All shards failied for phase: [{}]", firstPhaseName(), t);, +                    }, +++ b/src/main/java/org/elasticsearch/cluster/routing/allocation/allocator/BalancedShardsAllocator.java, +                        advance_range: , +                                if (lowIdx > 0 && highIdx-1 > 0 // is there a chance for a higher delta? , +                                    && (weights[highIdx-1] - weights[0] > threshold) // check if we need to break at all, +                                    ) {, +                                    /* This is a special case if allocations from the "heaviest" to the "lighter" nodes is not possible , +                                     * due to some allocation decider restrictions like zone awareness. if one zone has for instance , +                                     * less nodes than another zone. so one zone is horribly overloaded from a balanced perspective but we, +                                     * can't move to the "lighter" shards since otherwise the zone would go over capacity., +                                     * , +                                     * This break jumps straight to the condition below were we start moving from the high index towards , +                                     * the low index to shrink the window we are considering for balance from the other direction. , +                                     * (check shrinking the window from MAX to MIN), +                                     * See #3580, +                                     */, +                                    break advance_range;, +                                }, +                            /* Shrinking the window from MIN to MAX, +                             * we can't move from any shard from the min node lets move on to the next node, +                            /* Shrinking the window from MAX to MIN, +                             * now we go max to min since obviously we can't move anything to the max node , +             * allocate on the minimal eligible node., +                if (decision.type() == Type.YES) { // TODO maybe we can respect throttling here too?, +++ b/src/test/java/org/elasticsearch/test/integration/cluster/allocation/AwarenessAllocationTests.java, +        health = client().admin().cluster().prepareHealth().setWaitForEvents(Priority.LANGUID).setWaitForGreenStatus().setWaitForNodes("3").setWaitForActiveShards(10).setWaitForRelocatingShards(0).execute().actionGet();, +, +        clusterState = client().admin().cluster().prepareState().execute().actionGet().getState();, +        assertThat(counts.get("B-1"), equalTo(2));, +        , +++ b/src/main/java/org/elasticsearch/action/search/type/TransportSearchTypeAction.java, +                    if (logger.isDebugEnabled()) {, +                        logger.debug("All shards failied for phase: [{}]", firstPhaseName(), t);, +                    }, +++ b/src/main/java/org/elasticsearch/cluster/routing/allocation/allocator/BalancedShardsAllocator.java, +                        advance_range: , +                                if (lowIdx > 0 && highIdx-1 > 0 // is there a chance for a higher delta? , +                                    && (weights[highIdx-1] - weights[0] > threshold) // check if we need to break at all, +                                    ) {, +                                    /* This is a special case if allocations from the "heaviest" to the "lighter" nodes is not possible , +                                     * due to some allocation decider restrictions like zone awareness. if one zone has for instance , +                                     * less nodes than another zone. so one zone is horribly overloaded from a balanced perspective but we, +                                     * can't move to the "lighter" shards since otherwise the zone would go over capacity., +                                     * , +                                     * This break jumps straight to the condition below were we start moving from the high index towards , +                                     * the low index to shrink the window we are considering for balance from the other direction. , +                                     * (check shrinking the window from MAX to MIN), +                                     * See #3580, +                                     */, +                                    break advance_range;, +                                }, +                            /* Shrinking the window from MIN to MAX, +                             * we can't move from any shard from the min node lets move on to the next node, +                            /* Shrinking the window from MAX to MIN, +                             * now we go max to min since obviously we can't move anything to the max node , +             * allocate on the minimal eligible node., +                if (decision.type() == Type.YES) { // TODO maybe we can respect throttling here too?, +++ b/src/test/java/org/elasticsearch/test/integration/cluster/allocation/AwarenessAllocationTests.java, +        health = client().admin().cluster().prepareHealth().setWaitForEvents(Priority.LANGUID).setWaitForGreenStatus().setWaitForNodes("3").setWaitForActiveShards(10).setWaitForRelocatingShards(0).execute().actionGet();, +, +        clusterState = client().admin().cluster().prepareState().execute().actionGet().getState();, +        assertThat(counts.get("B-1"), equalTo(2));, +        , +++ b/src/test/java/org/elasticsearch/test/unit/cluster/routing/allocation/AwarenessAllocationTests.java, +        for (int i = 0; i < 2; i++) {, +            logger.info("--> complete initializing round: [{}]", i);]