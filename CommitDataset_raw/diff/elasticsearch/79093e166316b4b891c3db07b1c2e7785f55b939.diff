[+++ b/core/src/main/java/org/elasticsearch/cluster/metadata/MetaDataCreateIndexService.java, +, +            .put(IndexMetaData.SETTING_VERSION_CREATED, sourceMetaData.getCreationVersion()), +            .put(IndexMetaData.SETTING_VERSION_UPGRADED, sourceMetaData.getUpgradedVersion()), +        if (sourceMetaData.getMinimumCompatibleVersion() != null) {, +            indexSettingsBuilder.put(IndexMetaData.SETTING_VERSION_MINIMUM_COMPATIBLE, sourceMetaData.getMinimumCompatibleVersion());, +        }, +++ b/core/src/main/java/org/elasticsearch/cluster/metadata/MetaDataCreateIndexService.java, +, +            .put(IndexMetaData.SETTING_VERSION_CREATED, sourceMetaData.getCreationVersion()), +            .put(IndexMetaData.SETTING_VERSION_UPGRADED, sourceMetaData.getUpgradedVersion()), +        if (sourceMetaData.getMinimumCompatibleVersion() != null) {, +            indexSettingsBuilder.put(IndexMetaData.SETTING_VERSION_MINIMUM_COMPATIBLE, sourceMetaData.getMinimumCompatibleVersion());, +        }, +++ b/core/src/test/java/org/elasticsearch/action/admin/indices/create/CreateIndexIT.java, +, +++ b/core/src/main/java/org/elasticsearch/cluster/metadata/MetaDataCreateIndexService.java, +, +            .put(IndexMetaData.SETTING_VERSION_CREATED, sourceMetaData.getCreationVersion()), +            .put(IndexMetaData.SETTING_VERSION_UPGRADED, sourceMetaData.getUpgradedVersion()), +        if (sourceMetaData.getMinimumCompatibleVersion() != null) {, +            indexSettingsBuilder.put(IndexMetaData.SETTING_VERSION_MINIMUM_COMPATIBLE, sourceMetaData.getMinimumCompatibleVersion());, +        }, +++ b/core/src/test/java/org/elasticsearch/action/admin/indices/create/CreateIndexIT.java, +, +++ b/core/src/test/java/org/elasticsearch/action/admin/indices/create/ShrinkIndexIT.java, +/*, + * Licensed to Elasticsearch under one or more contributor, + * license agreements. See the NOTICE file distributed with, + * this work for additional information regarding copyright, + * ownership. Elasticsearch licenses this file to you under, + * the Apache License, Version 2.0 (the "License"); you may, + * not use this file except in compliance with the License., + * You may obtain a copy of the License at, + *, + *    http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing,, + * software distributed under the License is distributed on an, + * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY, + * KIND, either express or implied.  See the License for the, + * specific language governing permissions and limitations, + * under the License., + */, +, +package org.elasticsearch.action.admin.indices.create;, +, +import org.elasticsearch.Version;, +import org.elasticsearch.action.admin.cluster.reroute.ClusterRerouteResponse;, +import org.elasticsearch.action.admin.cluster.state.ClusterStateResponse;, +import org.elasticsearch.action.admin.indices.settings.get.GetSettingsResponse;, +import org.elasticsearch.action.support.ActiveShardCount;, +import org.elasticsearch.cluster.ClusterInfoService;, +import org.elasticsearch.cluster.InternalClusterInfoService;, +import org.elasticsearch.cluster.node.DiscoveryNode;, +import org.elasticsearch.cluster.routing.RoutingTable;, +import org.elasticsearch.cluster.routing.UnassignedInfo;, +import org.elasticsearch.common.Priority;, +import org.elasticsearch.common.collect.ImmutableOpenMap;, +import org.elasticsearch.common.settings.Settings;, +import org.elasticsearch.index.query.TermsQueryBuilder;, +import org.elasticsearch.plugins.Plugin;, +import org.elasticsearch.test.ESIntegTestCase;, +import org.elasticsearch.test.InternalSettingsPlugin;, +import org.elasticsearch.test.VersionUtils;, +, +import java.util.Arrays;, +import java.util.Collection;, +, +import static org.elasticsearch.test.hamcrest.ElasticsearchAssertions.assertAcked;, +import static org.elasticsearch.test.hamcrest.ElasticsearchAssertions.assertHitCount;, +, +public class ShrinkIndexIT extends ESIntegTestCase {, +, +    @Override, +    protected Collection<Class<? extends Plugin>> nodePlugins() {, +        return Arrays.asList(InternalSettingsPlugin.class);, +    }, +, +    public void testCreateShrinkIndexToN() {, +        int[][] possibleShardSplits = new int[][] {{8,4,2}, {9, 3, 1}, {4, 2, 1}, {15,5,1}};, +        int[] shardSplits = randomFrom(possibleShardSplits);, +        assertEquals(shardSplits[0], (shardSplits[0] / shardSplits[1]) * shardSplits[1]);, +        assertEquals(shardSplits[1], (shardSplits[1] / shardSplits[2]) * shardSplits[2]);, +        internalCluster().ensureAtLeastNumDataNodes(2);, +        prepareCreate("source").setSettings(Settings.builder().put(indexSettings()).put("number_of_shards", shardSplits[0])).get();, +        for (int i = 0; i < 20; i++) {, +            client().prepareIndex("source", "t1", Integer.toString(i)).setSource("{\"foo\" : \"bar\", \"i\" : " + i + "}").get();, +        }, +        ImmutableOpenMap<String, DiscoveryNode> dataNodes = client().admin().cluster().prepareState().get().getState().nodes(), +            .getDataNodes();, +        assertTrue("at least 2 nodes but was: " + dataNodes.size(), dataNodes.size() >= 2);, +        DiscoveryNode[] discoveryNodes = dataNodes.values().toArray(DiscoveryNode.class);, +        String mergeNode = discoveryNodes[0].getName();, +        // ensure all shards are allocated otherwise the ensure green below might not succeed since we require the merge node, +        // if we change the setting too quickly we will end up with one replica unassigned which can't be assigned anymore due, +        // to the require._name below., +        ensureGreen();, +        // relocate all shards to one node such that we can merge it., +        client().admin().indices().prepareUpdateSettings("source")]