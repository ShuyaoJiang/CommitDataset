[+++ b/src/main/java/org/elasticsearch/cluster/routing/IndexShardRoutingTable.java, +    final boolean allShardsStarted;, +        boolean allShardsStarted = true;, +            if (shard.state() != ShardRoutingState.STARTED) {, +                allShardsStarted = false;, +        }, +        this.allShardsStarted = allShardsStarted;, +    /**, +     * Returns <code>true</code> iff all shards in the routing table are started otherwise <code>false</code>, +     */, +    public boolean allShardsStarted() {, +        return allShardsStarted;, +    }, +, +++ b/src/main/java/org/elasticsearch/cluster/routing/IndexShardRoutingTable.java, +    final boolean allShardsStarted;, +        boolean allShardsStarted = true;, +            if (shard.state() != ShardRoutingState.STARTED) {, +                allShardsStarted = false;, +        }, +        this.allShardsStarted = allShardsStarted;, +    /**, +     * Returns <code>true</code> iff all shards in the routing table are started otherwise <code>false</code>, +     */, +    public boolean allShardsStarted() {, +        return allShardsStarted;, +    }, +, +++ b/src/main/java/org/elasticsearch/cluster/routing/MutableShardRouting.java, +, +, +++ b/src/main/java/org/elasticsearch/cluster/routing/IndexShardRoutingTable.java, +    final boolean allShardsStarted;, +        boolean allShardsStarted = true;, +            if (shard.state() != ShardRoutingState.STARTED) {, +                allShardsStarted = false;, +        }, +        this.allShardsStarted = allShardsStarted;, +    /**, +     * Returns <code>true</code> iff all shards in the routing table are started otherwise <code>false</code>, +     */, +    public boolean allShardsStarted() {, +        return allShardsStarted;, +    }, +, +++ b/src/main/java/org/elasticsearch/cluster/routing/MutableShardRouting.java, +, +, +++ b/src/main/java/org/elasticsearch/gateway/local/state/shards/LocalGatewayShardsState.java, +import org.elasticsearch.cluster.ClusterState;, +        if (listGatewayStartedShards != null) { // for testing, +        }, +        final ClusterState state = event.state();, +        if (state.blocks().disableStatePersistence() == false, +            && state.nodes().localNode().dataNode(), +            && event.routingTableChanged()) {, +            RoutingNode routingNode = state.readOnlyRoutingNodes().node(state.nodes().localNodeId());, +            final Map<ShardId, ShardStateInfo> newState;, +               newState = persistRoutingNodeState(routingNode);, +            } else {, +               newState = Maps.newHashMap();, +            // preserve all shards that:, +            //   * are not already in the new map AND, +            //   * belong to an active index AND, +            //   * used to be on this node but are not yet completely stated on any other node, +            // since these shards are NOT active on this node the won't need to be written above - we just preserve these, +            // in this map until they are fully started anywhere else or are re-assigned and we need to update the state, +            final RoutingTable indexRoutingTables = state.routingTable();, +            for (Map.Entry<ShardId, ShardStateInfo> entry : this.currentState.entrySet()) {, +                if (newState.containsKey(shardId) == false) { // this shard used to be here, +                    String indexName = shardId.index().getName();, +                    if (state.metaData().hasIndex(indexName)) { // it's index is not deleted, +                        IndexRoutingTable index = indexRoutingTables.index(indexName);, +                        if (index != null && index.shard(shardId.id()).allShardsStarted() == false) {, +                           // not all shards are active on another node so we put it back until they are active, +                           newState.put(shardId, entry.getValue());, +    }, +, +    Map<ShardId, ShardStateInfo> persistRoutingNodeState(RoutingNode routingNode) {, +        final Map<ShardId, ShardStateInfo> newState = Maps.newHashMap();, +        for (MutableShardRouting shardRouting : routingNode) {, +            if (shardRouting.active()) {, +                ShardId shardId = shardRouting.shardId();, +                ShardStateInfo shardStateInfo = new ShardStateInfo(shardRouting.version(), shardRouting.primary());, +                final ShardStateInfo previous = currentState.get(shardId);, +                if(maybeWriteShardState(shardId, shardStateInfo, previous) ) {, +                    newState.put(shardId, shardStateInfo);, +                } else if (previous != null) {, +                    currentState.put(shardId, previous);, +                }, +            }, +        }, +        return newState;, +    }, +, +    Map<ShardId, ShardStateInfo> getCurrentState() {, +        return currentState;, +    }, +, +    boolean maybeWriteShardState(ShardId shardId, ShardStateInfo shardStateInfo, ShardStateInfo previousState) {]