[+++ b/server/src/main/java/org/elasticsearch/index/engine/Engine.java, +            LOCAL_TRANSLOG_RECOVERY,, +            LOCAL_RESET;, +, +            boolean isFromTranslog() {, +                return this == LOCAL_TRANSLOG_RECOVERY || this == LOCAL_RESET;, +            }, +++ b/server/src/main/java/org/elasticsearch/index/engine/Engine.java, +            LOCAL_TRANSLOG_RECOVERY,, +            LOCAL_RESET;, +, +            boolean isFromTranslog() {, +                return this == LOCAL_TRANSLOG_RECOVERY || this == LOCAL_RESET;, +            }, +++ b/server/src/main/java/org/elasticsearch/index/engine/InternalEngine.java, +                case LOCAL_RESET:, +                if (index.origin().isFromTranslog() == false) {, +            if (delete.origin().isFromTranslog() == false) {, +            if (noOp.origin().isFromTranslog() == false) {, +++ b/server/src/main/java/org/elasticsearch/index/engine/Engine.java, +            LOCAL_TRANSLOG_RECOVERY,, +            LOCAL_RESET;, +, +            boolean isFromTranslog() {, +                return this == LOCAL_TRANSLOG_RECOVERY || this == LOCAL_RESET;, +            }, +++ b/server/src/main/java/org/elasticsearch/index/engine/InternalEngine.java, +                case LOCAL_RESET:, +                if (index.origin().isFromTranslog() == false) {, +            if (delete.origin().isFromTranslog() == false) {, +            if (noOp.origin().isFromTranslog() == false) {, +++ b/server/src/main/java/org/elasticsearch/index/engine/ReadOnlyEngine.java, +++ b/server/src/main/java/org/elasticsearch/index/engine/Engine.java, +            LOCAL_TRANSLOG_RECOVERY,, +            LOCAL_RESET;, +, +            boolean isFromTranslog() {, +                return this == LOCAL_TRANSLOG_RECOVERY || this == LOCAL_RESET;, +            }, +++ b/server/src/main/java/org/elasticsearch/index/engine/InternalEngine.java, +                case LOCAL_RESET:, +                if (index.origin().isFromTranslog() == false) {, +            if (delete.origin().isFromTranslog() == false) {, +            if (noOp.origin().isFromTranslog() == false) {, +++ b/server/src/main/java/org/elasticsearch/index/engine/ReadOnlyEngine.java, +++ b/server/src/main/java/org/elasticsearch/index/seqno/LocalCheckpointTracker.java, +        // TODO: remove this method as after we restore the local history on promotion., +++ b/server/src/main/java/org/elasticsearch/index/engine/Engine.java, +            LOCAL_TRANSLOG_RECOVERY,, +            LOCAL_RESET;, +, +            boolean isFromTranslog() {, +                return this == LOCAL_TRANSLOG_RECOVERY || this == LOCAL_RESET;, +            }, +++ b/server/src/main/java/org/elasticsearch/index/engine/InternalEngine.java, +                case LOCAL_RESET:, +                if (index.origin().isFromTranslog() == false) {, +            if (delete.origin().isFromTranslog() == false) {, +            if (noOp.origin().isFromTranslog() == false) {, +++ b/server/src/main/java/org/elasticsearch/index/engine/ReadOnlyEngine.java, +++ b/server/src/main/java/org/elasticsearch/index/seqno/LocalCheckpointTracker.java, +        // TODO: remove this method as after we restore the local history on promotion., +++ b/server/src/main/java/org/elasticsearch/index/shard/IndexShard.java, +    /**, +     * Replays translog operations from the provided translog {@code snapshot} to the current engine using the given {@code origin}., +     * The callback {@code onOperationRecovered} is notified after each translog operation is replayed successfully., +     */, +    int runTranslogRecovery(Engine engine, Translog.Snapshot snapshot, Engine.Operation.Origin origin,, +                            Runnable onOperationRecovered) throws IOException {, +                Engine.Result result = applyTranslogOperation(operation, origin);, +                onOperationRecovered.run();, +        final RecoveryState.Translog translogRecoveryStats = recoveryState.getTranslog();, +        final Engine.TranslogRecoveryRunner translogRecoveryRunner = (engine, snapshot) -> {, +            translogRecoveryStats.totalOperations(snapshot.totalOperations());, +            translogRecoveryStats.totalOperationsOnStart(snapshot.totalOperations());, +            return runTranslogRecovery(engine, snapshot, Engine.Operation.Origin.LOCAL_TRANSLOG_RECOVERY,, +                translogRecoveryStats::incrementRecoveredOperations);, +        };, +        getEngine().recoverFromTranslog(translogRecoveryRunner, Long.MAX_VALUE);, +        trimUnsafeCommits();, +    private void trimUnsafeCommits() throws IOException {, +        assert currentEngineReference.get() == null : "engine is running";, +        final String translogUUID = store.readLastCommittedSegmentsInfo().getUserData().get(Translog.TRANSLOG_UUID_KEY);, +        final long globalCheckpoint = Translog.readGlobalCheckpoint(translogConfig.getTranslogPath(), translogUUID);, +        final long minRetainedTranslogGen = Translog.readMinTranslogGeneration(translogConfig.getTranslogPath(), translogUUID);, +        assertMaxUnsafeAutoIdInCommit();, +        store.trimUnsafeCommits(globalCheckpoint, minRetainedTranslogGen, indexSettings.getIndexVersionCreated());, +    }, +, +                assert origin == Engine.Operation.Origin.REPLICA || origin == Engine.Operation.Origin.LOCAL_RESET;, +            verifyNotClosed();, +                                final long maxSeqNo = seqNoStats().getMaxSeqNo();, +                                logger.info("detected new primary with primary term [{}], global checkpoint [{}], max_seq_no [{}]",, +                                             opPrimaryTerm, currentGlobalCheckpoint, maxSeqNo);, +                                if (currentGlobalCheckpoint < maxSeqNo) {, +                                    resetEngineToGlobalCheckpoint();, +                                }, +, +    /**, +     * Rollback the current engine to the safe commit, then replay local translog up to the global checkpoint.]