[+++ b/server/src/main/java/org/elasticsearch/cluster/metadata/IndexGraveyard.java, +import org.elasticsearch.common.time.DateFormatter;, +        static final DateFormatter FORMATTER = DateFormatters.forPattern("strict_date_optional_time").withZone(ZoneOffset.UTC);, +++ b/server/src/main/java/org/elasticsearch/cluster/metadata/IndexGraveyard.java, +import org.elasticsearch.common.time.DateFormatter;, +        static final DateFormatter FORMATTER = DateFormatters.forPattern("strict_date_optional_time").withZone(ZoneOffset.UTC);, +++ b/server/src/main/java/org/elasticsearch/cluster/routing/UnassignedInfo.java, +import org.elasticsearch.common.time.DateFormatter;, +    public static final DateFormatter DATE_TIME_FORMATTER = DateFormatters.forPattern("dateOptionalTime").withZone(ZoneOffset.UTC);, +++ b/server/src/main/java/org/elasticsearch/cluster/metadata/IndexGraveyard.java, +import org.elasticsearch.common.time.DateFormatter;, +        static final DateFormatter FORMATTER = DateFormatters.forPattern("strict_date_optional_time").withZone(ZoneOffset.UTC);, +++ b/server/src/main/java/org/elasticsearch/cluster/routing/UnassignedInfo.java, +import org.elasticsearch.common.time.DateFormatter;, +    public static final DateFormatter DATE_TIME_FORMATTER = DateFormatters.forPattern("dateOptionalTime").withZone(ZoneOffset.UTC);, +++ b/server/src/main/java/org/elasticsearch/common/Table.java, +import org.elasticsearch.common.time.DateFormatter;, +    private static final DateFormatter FORMATTER = DateFormatters.forPattern("HH:mm:ss").withZone(ZoneOffset.UTC);, +++ b/server/src/main/java/org/elasticsearch/cluster/metadata/IndexGraveyard.java, +import org.elasticsearch.common.time.DateFormatter;, +        static final DateFormatter FORMATTER = DateFormatters.forPattern("strict_date_optional_time").withZone(ZoneOffset.UTC);, +++ b/server/src/main/java/org/elasticsearch/cluster/routing/UnassignedInfo.java, +import org.elasticsearch.common.time.DateFormatter;, +    public static final DateFormatter DATE_TIME_FORMATTER = DateFormatters.forPattern("dateOptionalTime").withZone(ZoneOffset.UTC);, +++ b/server/src/main/java/org/elasticsearch/common/Table.java, +import org.elasticsearch.common.time.DateFormatter;, +    private static final DateFormatter FORMATTER = DateFormatters.forPattern("HH:mm:ss").withZone(ZoneOffset.UTC);, +++ /dev/null, +++ b/server/src/main/java/org/elasticsearch/cluster/metadata/IndexGraveyard.java, +import org.elasticsearch.common.time.DateFormatter;, +        static final DateFormatter FORMATTER = DateFormatters.forPattern("strict_date_optional_time").withZone(ZoneOffset.UTC);, +++ b/server/src/main/java/org/elasticsearch/cluster/routing/UnassignedInfo.java, +import org.elasticsearch.common.time.DateFormatter;, +    public static final DateFormatter DATE_TIME_FORMATTER = DateFormatters.forPattern("dateOptionalTime").withZone(ZoneOffset.UTC);, +++ b/server/src/main/java/org/elasticsearch/common/Table.java, +import org.elasticsearch.common.time.DateFormatter;, +    private static final DateFormatter FORMATTER = DateFormatters.forPattern("HH:mm:ss").withZone(ZoneOffset.UTC);, +++ /dev/null, +++ b/server/src/main/java/org/elasticsearch/common/time/DateFormatter.java, +/*, + * Licensed to Elasticsearch under one or more contributor, + * license agreements. See the NOTICE file distributed with, + * this work for additional information regarding copyright, + * ownership. Elasticsearch licenses this file to you under, + * the Apache License, Version 2.0 (the "License"); you may, + * not use this file except in compliance with the License., + * You may obtain a copy of the License at, + *, + *    http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing,, + * software distributed under the License is distributed on an, + * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY, + * KIND, either express or implied.  See the License for the, + * specific language governing permissions and limitations, + * under the License., + */, +, +package org.elasticsearch.common.time;, +, +import java.time.ZoneId;, +import java.time.format.DateTimeParseException;, +import java.time.temporal.TemporalAccessor;, +import java.time.temporal.TemporalField;, +import java.util.Arrays;, +import java.util.Map;, +import java.util.stream.Collectors;, +, +public interface DateFormatter {, +, +    /**, +     * Try to parse input to a java time TemporalAccessor, +     * @param input                   An arbitrary string resembling the string representation of a date or time, +     * @throws DateTimeParseException If parsing fails, this exception will be thrown., +     *                                Note that it can contained suppressed exceptions when several formatters failed parse this value, +     * @return                        The java time object containing the parsed input, +     */, +    TemporalAccessor parse(String input);, +, +    /**, +     * Create a copy of this formatter that is configured to parse dates in the specified time zone, +     *, +     * @param zoneId The time zone to act on, +     * @return       A copy of the date formatter this has been called on, +     */, +    DateFormatter withZone(ZoneId zoneId);, +, +    /**, +     * Print the supplied java time accessor in a string based representation according to this formatter, +     *, +     * @param accessor The temporal accessor used to format, +     * @return         The string result for the formatting, +     */, +    String format(TemporalAccessor accessor);, +, +    /**, +     * A name based format for this formatter. Can be one of the registered formatters like <code>epoch_millis</code> or, +     * a configured format like <code>HH:mm:ss</code>, +     *, +     * @return The name of this formatter]