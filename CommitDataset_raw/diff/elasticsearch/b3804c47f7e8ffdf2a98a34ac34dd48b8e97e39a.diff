[+++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/WriterConstants.java, +import java.util.Iterator;, +    public final static Type ITERATOR_TYPE = Type.getType(Iterator.class);, +    public final static Method ITERATOR_HASNEXT = getAsmMethod(boolean.class, "hasNext");, +    public final static Method ITERATOR_NEXT = getAsmMethod(Object.class, "next");, +, +++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/WriterConstants.java, +import java.util.Iterator;, +    public final static Type ITERATOR_TYPE = Type.getType(Iterator.class);, +    public final static Method ITERATOR_HASNEXT = getAsmMethod(boolean.class, "hasNext");, +    public final static Method ITERATOR_NEXT = getAsmMethod(Object.class, "next");, +, +++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/SEach.java, +import static org.elasticsearch.painless.WriterConstants.ITERATOR_HASNEXT;, +import static org.elasticsearch.painless.WriterConstants.ITERATOR_NEXT;, +import static org.elasticsearch.painless.WriterConstants.ITERATOR_TYPE;, +, +        if (expression.actual.sort == Sort.ARRAY) {, +            analyzeArray(variables, type);, +        } else if (expression.actual.sort == Sort.DEF || Iterable.class.isAssignableFrom(expression.actual.clazz)) {, +            analyzeIterable(variables, type);, +        } else {, +            throw location.createError(new IllegalArgumentException("Illegal for each type [" + expression.actual.name + "]."));, +        }, +    void analyzeArray(Variables variables, Type type) {, +        // We must store the array and index as variables for securing slots on the stack, and, +        // also add the location offset to make the names unique in case of nested for each loops., +        array = variables.addVariable(location, expression.actual, "#array" + location.getOffset(), true, false);, +        index = variables.addVariable(location, Definition.INT_TYPE, "#index" + location.getOffset(), true, false);, +        indexed = Definition.getType(expression.actual.struct, expression.actual.dimensions - 1);, +        cast = AnalyzerCaster.getLegalCast(location, indexed, type, true, true);, +    void analyzeIterable(Variables variables, Type type) {, +        iterator = variables.addVariable(location, Definition.getType("Iterator"), "#itr" + location.getOffset(), true, false);, +        writer.writeStatementOffset(location);, +, +        writer.invokeInterface(ITERATOR_TYPE, ITERATOR_HASNEXT);, +        writer.invokeInterface(ITERATOR_TYPE, ITERATOR_NEXT);]