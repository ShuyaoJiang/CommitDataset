[+++ b/modules/elasticsearch/src/main/java/org/elasticsearch/gateway/blobstore/BlobReuseExistingNodeAllocation.java, +import org.elasticsearch.common.collect.Maps;, +    private final TransportNodesListShardStoreMetaData listShardStoreMetaData;, +    private final ConcurrentMap<ShardId, Map<DiscoveryNode, TransportNodesListShardStoreMetaData.StoreFilesMetaData>> cachedStores = ConcurrentCollections.newConcurrentMap();, +        this.listShardStoreMetaData = transportNodesListShardStoreMetaData;, +            Map<DiscoveryNode, TransportNodesListShardStoreMetaData.StoreFilesMetaData> shardStores = buildShardStores(nodes, shard);, +    private Map<DiscoveryNode, TransportNodesListShardStoreMetaData.StoreFilesMetaData> buildShardStores(DiscoveryNodes nodes, MutableShardRouting shard) {, +        Map<DiscoveryNode, TransportNodesListShardStoreMetaData.StoreFilesMetaData> shardStores = cachedStores.get(shard.shardId());, +        Set<String> nodesIds;, +            shardStores = Maps.newHashMap();, +            nodesIds = nodes.dataNodes().keySet();, +            nodesIds = Sets.newHashSet();, +                    nodesIds.add(node.id());, +                }, +        if (!nodesIds.isEmpty()) {, +            TransportNodesListShardStoreMetaData.NodesStoreFilesMetaData nodesStoreFilesMetaData = listShardStoreMetaData.list(shard.shardId(), false, nodesIds, listTimeout).actionGet();, +            if (logger.isTraceEnabled()) {, +                    logger.trace(sb.toString());, +, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/gateway/blobstore/BlobReuseExistingNodeAllocation.java, +import org.elasticsearch.common.collect.Maps;, +    private final TransportNodesListShardStoreMetaData listShardStoreMetaData;, +    private final ConcurrentMap<ShardId, Map<DiscoveryNode, TransportNodesListShardStoreMetaData.StoreFilesMetaData>> cachedStores = ConcurrentCollections.newConcurrentMap();, +        this.listShardStoreMetaData = transportNodesListShardStoreMetaData;, +            Map<DiscoveryNode, TransportNodesListShardStoreMetaData.StoreFilesMetaData> shardStores = buildShardStores(nodes, shard);, +    private Map<DiscoveryNode, TransportNodesListShardStoreMetaData.StoreFilesMetaData> buildShardStores(DiscoveryNodes nodes, MutableShardRouting shard) {, +        Map<DiscoveryNode, TransportNodesListShardStoreMetaData.StoreFilesMetaData> shardStores = cachedStores.get(shard.shardId());, +        Set<String> nodesIds;, +            shardStores = Maps.newHashMap();, +            nodesIds = nodes.dataNodes().keySet();, +            nodesIds = Sets.newHashSet();, +                    nodesIds.add(node.id());, +                }, +        if (!nodesIds.isEmpty()) {, +            TransportNodesListShardStoreMetaData.NodesStoreFilesMetaData nodesStoreFilesMetaData = listShardStoreMetaData.list(shard.shardId(), false, nodesIds, listTimeout).actionGet();, +            if (logger.isTraceEnabled()) {, +                    logger.trace(sb.toString());, +, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/gateway/local/LocalGatewayNodeAllocation.java, +import org.elasticsearch.common.collect.Maps;, +import org.elasticsearch.common.trove.iterator.TObjectLongIterator;, +import org.elasticsearch.common.trove.map.hash.TObjectLongHashMap;, +    private final ConcurrentMap<ShardId, Map<DiscoveryNode, TransportNodesListShardStoreMetaData.StoreFilesMetaData>> cachedStores = ConcurrentCollections.newConcurrentMap();, +, +    private final ConcurrentMap<ShardId, TObjectLongHashMap<DiscoveryNode>> cachedShardsState = ConcurrentCollections.newConcurrentMap();, +            cachedShardsState.remove(shardRouting.shardId());, +        cachedShardsState.remove(failedShard.shardId());, +            TObjectLongHashMap<DiscoveryNode> nodesState = buildShardStates(nodes, shard);, +            for (TObjectLongIterator<DiscoveryNode> it = nodesState.iterator(); it.hasNext();) {, +                it.advance();, +                DiscoveryNode node = it.key();, +                long version = it.value();, +                if (allocation.shouldIgnoreShardForNode(shard.shardId(), node.id())) {, +                if (version != -1) {, +                        nodeWithHighestVersion = node;, +                            nodeWithHighestVersion = node;, +            Map<DiscoveryNode, TransportNodesListShardStoreMetaData.StoreFilesMetaData> shardStores = buildShardStores(nodes, shard);, +    private TObjectLongHashMap<DiscoveryNode> buildShardStates(DiscoveryNodes nodes, MutableShardRouting shard) {, +        TObjectLongHashMap<DiscoveryNode> shardStates = cachedShardsState.get(shard.shardId());, +        Set<String> nodeIds;, +        if (shardStates == null) {, +            shardStates = new TObjectLongHashMap<DiscoveryNode>();, +            cachedShardsState.put(shard.shardId(), shardStates);, +            nodeIds = nodes.dataNodes().keySet();, +        } else {, +            // clean nodes that have failed, +            for (DiscoveryNode node : shardStates.keySet()) {, +                if (!nodes.nodeExists(node.id())) {, +                    shardStates.remove(node);, +                }, +            }, +            nodeIds = Sets.newHashSet();, +            // we have stored cached from before, see if the nodes changed, if they have, go fetch again, +            for (DiscoveryNode node : nodes.dataNodes().values()) {, +                if (!shardStates.containsKey(node)) {, +                    nodeIds.add(node.id());, +                }, +            }, +        }, +        if (nodeIds.isEmpty()) {, +            return shardStates;, +        }, +, +        TransportNodesListGatewayStartedShards.NodesLocalGatewayStartedShards response = listGatewayStartedShards.list(shard.shardId(), nodes.dataNodes().keySet(), listTimeout).actionGet();, +            if (response.failures().length > 0) {, +                StringBuilder sb = new StringBuilder(shard + ": failures when trying to list shards on nodes:");, +                for (int i = 0; i < response.failures().length; i++) {, +                    Throwable cause = ExceptionsHelper.unwrapCause(response.failures()[i]);, +                    sb.append("\n    -> ").append(response.failures()[i].getDetailedMessage());, +        for (TransportNodesListGatewayStartedShards.NodeLocalGatewayStartedShards nodeShardState : response) {, +            // -1 version means it does not exists, which is what the API returns, and what we expect to, +            shardStates.put(nodeShardState.node(), nodeShardState.version());, +        return shardStates;, +, +    private Map<DiscoveryNode, TransportNodesListShardStoreMetaData.StoreFilesMetaData> buildShardStores(DiscoveryNodes nodes, MutableShardRouting shard) {, +        Map<DiscoveryNode, TransportNodesListShardStoreMetaData.StoreFilesMetaData> shardStores = cachedStores.get(shard.shardId());, +        Set<String> nodesIds;, +        if (shardStores == null) {, +            shardStores = Maps.newHashMap();, +            nodesIds = nodes.dataNodes().keySet();]