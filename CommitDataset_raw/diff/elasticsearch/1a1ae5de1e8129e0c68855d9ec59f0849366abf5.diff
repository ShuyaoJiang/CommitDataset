[+++ b/docs/reference/rest-api/info.asciidoc, +      "index_lifecycle" : {, +         "description" : "Index lifecycle management for the Elastic Stack",, +         "available" : true,, +         "enabled" : true, +      },, +++ b/docs/reference/rest-api/info.asciidoc, +      "index_lifecycle" : {, +         "description" : "Index lifecycle management for the Elastic Stack",, +         "available" : true,, +         "enabled" : true, +      },, +++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/lookup/PainlessLookupBuilder.java, +import org.objectweb.asm.Type;, +import static org.elasticsearch.painless.lookup.PainlessLookupUtility.DEF_TYPE_NAME;, +    private final Map<Class<?>, PainlessClassBuilder> classesToPainlessClasses;, +        classesToPainlessClasses = new HashMap<>();, +        canonicalClassNamesToClasses.put(DEF_TYPE_NAME, def.class);, +        classesToPainlessClasses.put(def.class,, +                new PainlessClassBuilder(DEF_TYPE_NAME, Object.class, Type.getType(Object.class)));, +        PainlessLookupUtility.validateType(type, classesToPainlessClasses.keySet());, +            throw new IllegalArgumentException("cannot add reserved class [" + DEF_TYPE_NAME + "]");, +        String canonicalClassName = clazz.getCanonicalName();, +        PainlessClassBuilder existingPainlessClassBuilder = classesToPainlessClasses.get(clazz);, +            PainlessClassBuilder painlessClassBuilder = new PainlessClassBuilder(canonicalClassName, clazz, Type.getType(clazz));, +            classesToPainlessClasses.put(clazz, painlessClassBuilder);, +            Class<?> importedPainlessType = canonicalClassNamesToClasses.get(importedCanonicalClassName);, +            if (importedPainlessType == null) {, +                        throw new IllegalArgumentException(, +                                "inconsistent only_fqn parameters found for painless type [" + canonicalClassName + "]");, +            } else if (importedPainlessType.equals(clazz) == false) {, +                throw new IllegalArgumentException("painless type [" + importedCanonicalClassName + "] illegally represents multiple " +, +                        "java types [" + clazz.getCanonicalName() + "] and [" + importedPainlessType.getCanonicalName() + "]");, +                throw new IllegalArgumentException("inconsistent only_fqn parameters found for painless type [" + canonicalClassName + "]");, +    private void addConstructor(String ownerStructName, WhitelistConstructor whitelistConstructor) {, +        PainlessClassBuilder ownerStruct = classesToPainlessClasses.get(canonicalClassNamesToClasses.get(ownerStructName));, +        if (ownerStruct == null) {, +            throw new IllegalArgumentException("owner struct [" + ownerStructName + "] not defined for constructor with " +, +                "parameters " + whitelistConstructor.painlessParameterTypeNames);, +        List<Class<?>> painlessParametersTypes = new ArrayList<>(whitelistConstructor.painlessParameterTypeNames.size());, +        Class<?>[] javaClassParameters = new Class<?>[whitelistConstructor.painlessParameterTypeNames.size()];, +        for (int parameterCount = 0; parameterCount < whitelistConstructor.painlessParameterTypeNames.size(); ++parameterCount) {, +            String painlessParameterTypeName = whitelistConstructor.painlessParameterTypeNames.get(parameterCount);, +, +                Class<?> painlessParameterClass = canonicalTypeNameToType(painlessParameterTypeName);, +, +                painlessParametersTypes.add(painlessParameterClass);, +                javaClassParameters[parameterCount] = PainlessLookupUtility.typeToJavaType(painlessParameterClass);, +                throw new IllegalArgumentException("struct not defined for constructor parameter [" + painlessParameterTypeName + "] " +, +                    "with owner struct [" + ownerStructName + "] and constructor parameters " +, +                    whitelistConstructor.painlessParameterTypeNames, iae);, +        java.lang.reflect.Constructor<?> javaConstructor;, +            javaConstructor = ownerStruct.clazz.getConstructor(javaClassParameters);, +        } catch (NoSuchMethodException exception) {, +            throw new IllegalArgumentException("constructor not defined for owner struct [" + ownerStructName + "] " +, +                " with constructor parameters " + whitelistConstructor.painlessParameterTypeNames, exception);, +        String painlessMethodKey = buildPainlessMethodKey("<init>", whitelistConstructor.painlessParameterTypeNames.size());, +        PainlessMethod painlessConstructor = ownerStruct.constructors.get(painlessMethodKey);, +            MethodHandle javaHandle;, +                javaHandle = MethodHandles.publicLookup().in(ownerStruct.clazz).unreflectConstructor(javaConstructor);, +            } catch (IllegalAccessException exception) {, +                throw new IllegalArgumentException("constructor not defined for owner struct [" + ownerStructName + "] " +, +                    " with constructor parameters " + whitelistConstructor.painlessParameterTypeNames);, +                new PainlessMethodCacheKey(ownerStruct.clazz, "<init>", painlessParametersTypes),, +                key -> new PainlessMethod("<init>", ownerStruct.clazz, null, void.class, painlessParametersTypes,, +                    asmConstructor, javaConstructor.getModifiers(), javaHandle));, +            ownerStruct.constructors.put(painlessMethodKey, painlessConstructor);, +        } else if (painlessConstructor.arguments.equals(painlessParametersTypes) == false){, +            throw new IllegalArgumentException(, +                "illegal duplicate constructors [" + painlessMethodKey + "] found within the struct [" + ownerStruct.name + "] " +, +                    "with parameters " + painlessParametersTypes + " and " + painlessConstructor.arguments);, +    private void addMethod(ClassLoader whitelistClassLoader, String ownerStructName, WhitelistMethod whitelistMethod) {, +        PainlessClassBuilder ownerStruct = classesToPainlessClasses.get(canonicalClassNamesToClasses.get(ownerStructName));, +        if (ownerStruct == null) {, +            throw new IllegalArgumentException("owner struct [" + ownerStructName + "] not defined for method with " +, +                "name [" + whitelistMethod.javaMethodName + "] and parameters " + whitelistMethod.painlessParameterTypeNames);, +        if (METHOD_NAME_PATTERN.matcher(whitelistMethod.javaMethodName).matches() == false) {, +            throw new IllegalArgumentException("invalid method name" +, +                " [" + whitelistMethod.javaMethodName + "] for owner struct [" + ownerStructName + "].");, +        }, +        Class<?> javaAugmentedClass;, +, +        if (whitelistMethod.javaAugmentedClassName != null) {, +                javaAugmentedClass = Class.forName(whitelistMethod.javaAugmentedClassName, true, whitelistClassLoader);, +                throw new IllegalArgumentException("augmented class [" + whitelistMethod.javaAugmentedClassName + "] " +, +                    "not found for method with name [" + whitelistMethod.javaMethodName + "] " +, +                    "and parameters " + whitelistMethod.painlessParameterTypeNames, cnfe);, +            javaAugmentedClass = null;, +        }, +, +        int augmentedOffset = javaAugmentedClass == null ? 0 : 1;, +, +        List<Class<?>> painlessParametersTypes = new ArrayList<>(whitelistMethod.painlessParameterTypeNames.size());, +        Class<?>[] javaClassParameters = new Class<?>[whitelistMethod.painlessParameterTypeNames.size() + augmentedOffset];, +, +        if (javaAugmentedClass != null) {, +            javaClassParameters[0] = ownerStruct.clazz;, +        }, +, +        for (int parameterCount = 0; parameterCount < whitelistMethod.painlessParameterTypeNames.size(); ++parameterCount) {]