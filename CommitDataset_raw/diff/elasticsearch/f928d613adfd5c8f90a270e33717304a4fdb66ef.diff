[+++ b/core/src/main/java/org/elasticsearch/index/engine/Engine.java, +    /** Returns how many bytes we are currently moving from heap to disk */, +    public abstract long getWritingBytes();, +, +++ b/core/src/main/java/org/elasticsearch/index/engine/Engine.java, +    /** Returns how many bytes we are currently moving from heap to disk */, +    public abstract long getWritingBytes();, +, +++ b/core/src/main/java/org/elasticsearch/index/engine/InternalEngine.java, +    /**, +     * How many bytes we are currently moving to disk, via either IndexWriter.flush or refresh.  IndexingMemoryController polls this, +     * across all shards to decide if throttling is necessary because moving bytes to disk is falling behind vs incoming documents, +     * being indexed/deleted., +     */, +    private final AtomicLong writingBytes = new AtomicLong();, +    /** Returns how many bytes we are currently moving from indexing buffer to segments on disk */, +    @Override, +    public long getWritingBytes() {, +        return writingBytes.get();, +    }, +, +        long bytes = 0;, +            bytes = indexWriter.ramBytesUsed();, +                    writingBytes.addAndGet(bytes);, +                    final long versionMapBytes = versionMap.ramBytesUsedForRefresh();, +                    bytes += versionMapBytes;, +                    writingBytes.addAndGet(bytes);, +        }  finally {, +            writingBytes.addAndGet(-bytes);, +++ b/core/src/main/java/org/elasticsearch/index/engine/Engine.java, +    /** Returns how many bytes we are currently moving from heap to disk */, +    public abstract long getWritingBytes();, +, +++ b/core/src/main/java/org/elasticsearch/index/engine/InternalEngine.java, +    /**, +     * How many bytes we are currently moving to disk, via either IndexWriter.flush or refresh.  IndexingMemoryController polls this, +     * across all shards to decide if throttling is necessary because moving bytes to disk is falling behind vs incoming documents, +     * being indexed/deleted., +     */, +    private final AtomicLong writingBytes = new AtomicLong();, +    /** Returns how many bytes we are currently moving from indexing buffer to segments on disk */, +    @Override, +    public long getWritingBytes() {, +        return writingBytes.get();, +    }, +, +        long bytes = 0;, +            bytes = indexWriter.ramBytesUsed();, +                    writingBytes.addAndGet(bytes);, +                    final long versionMapBytes = versionMap.ramBytesUsedForRefresh();, +                    bytes += versionMapBytes;, +                    writingBytes.addAndGet(bytes);, +        }  finally {, +            writingBytes.addAndGet(-bytes);, +++ b/core/src/main/java/org/elasticsearch/index/shard/IndexShard.java, +        Engine engine = getEngineOrNull();, +        if (engine == null) {, +            return 0;, +        }, +        return engine.getWritingBytes();, +++ b/core/src/main/java/org/elasticsearch/index/engine/Engine.java, +    /** Returns how many bytes we are currently moving from heap to disk */, +    public abstract long getWritingBytes();, +, +++ b/core/src/main/java/org/elasticsearch/index/engine/InternalEngine.java, +    /**, +     * How many bytes we are currently moving to disk, via either IndexWriter.flush or refresh.  IndexingMemoryController polls this, +     * across all shards to decide if throttling is necessary because moving bytes to disk is falling behind vs incoming documents, +     * being indexed/deleted., +     */, +    private final AtomicLong writingBytes = new AtomicLong();, +    /** Returns how many bytes we are currently moving from indexing buffer to segments on disk */, +    @Override, +    public long getWritingBytes() {, +        return writingBytes.get();, +    }, +, +        long bytes = 0;, +            bytes = indexWriter.ramBytesUsed();, +                    writingBytes.addAndGet(bytes);, +                    final long versionMapBytes = versionMap.ramBytesUsedForRefresh();, +                    bytes += versionMapBytes;, +                    writingBytes.addAndGet(bytes);, +        }  finally {, +            writingBytes.addAndGet(-bytes);, +++ b/core/src/main/java/org/elasticsearch/index/shard/IndexShard.java, +        Engine engine = getEngineOrNull();, +        if (engine == null) {, +            return 0;, +        }, +        return engine.getWritingBytes();, +++ b/core/src/main/java/org/elasticsearch/indices/IndexingMemoryController.java, +            if (CAN_WRITE_INDEX_BUFFER_STATES.contains(shard.state())) {]