[+++ b/core/src/main/java/org/elasticsearch/index/query/CommonTermsQueryBuilder.java, +import org.apache.lucene.analysis.Analyzer;, +import org.apache.lucene.analysis.TokenStream;, +import org.apache.lucene.analysis.tokenattributes.CharTermAttribute;, +import org.apache.lucene.queries.ExtendedCommonTermsQuery;, +import org.apache.lucene.search.BooleanClause.Occur;, +import org.apache.lucene.search.Query;, +import org.apache.lucene.util.BytesRefBuilder;, +import org.elasticsearch.common.Strings;, +import org.elasticsearch.common.io.stream.StreamInput;, +import org.elasticsearch.common.io.stream.StreamOutput;, +import org.elasticsearch.index.mapper.MappedFieldType;, +import java.util.Objects;, + * stopwords. This query basically builds 2 queries off the, + * {@link org.apache.lucene.queries.CommonTermsQuery#add(Term) added} terms , + * where low-frequency terms are added to a required boolean clause, +    public static final float DEFAULT_CUTOFF_FREQ = 0.01f;, +    public static final Operator DEFAULT_HIGH_FREQ_OCCUR = Operator.OR;, +, +    public static final Operator DEFAULT_LOW_FREQ_OCCUR = Operator.OR;, +, +    public static final boolean DEFAULT_DISABLE_COORD = true;, +, +    private final String fieldName;, +    private Operator highFreqOperator = DEFAULT_HIGH_FREQ_OCCUR;, +    private Operator lowFreqOperator = DEFAULT_LOW_FREQ_OCCUR;, +    private float boost = 1.0f;, +    private boolean disableCoord = DEFAULT_DISABLE_COORD;, +    private float cutoffFrequency = DEFAULT_CUTOFF_FREQ;, +    static final CommonTermsQueryBuilder PROTOTYPE = new CommonTermsQueryBuilder(null, null);, +    public CommonTermsQueryBuilder(String fieldName, Object text) {, +        this.fieldName = fieldName;, +    public String fieldName() {, +        return this.fieldName;, +    }, +, +    public Object text() {, +        return this.text;, +        this.highFreqOperator = (operator == null) ? DEFAULT_HIGH_FREQ_OCCUR : operator;, +    public Operator highFreqOperator() {, +        return highFreqOperator;, +    }, +, +        this.lowFreqOperator = (operator == null) ? DEFAULT_LOW_FREQ_OCCUR : operator;, +    public Operator lowFreqOperator() {, +        return lowFreqOperator;, +    }, +, +    public String analyzer() {, +        return this.analyzer;, +    }, +, +    public float boost() {, +        return boost;, +    }, +, +     * <tt>{@value #DEFAULT_CUTOFF_FREQ}</tt>, +    public float cutoffFrequency() {, +        return this.cutoffFrequency;, +    }, +, +    public String highFreqMinimumShouldMatch() {, +        return this.highFreqMinimumShouldMatch;, +    }, +, +    public String lowFreqMinimumShouldMatch() {, +        return this.lowFreqMinimumShouldMatch;, +    }, +, +    public boolean disableCoord() {, +        return this.disableCoord;, +    }, +, +    public String queryName() {, +        return this.queryName;, +    }, +, +        builder.startObject(fieldName);, +, +    @Override, +    public Query toQuery(QueryParseContext parseContext) throws QueryParsingException, IOException {, +        String field;, +        MappedFieldType fieldType = parseContext.fieldMapper(fieldName);, +        if (fieldType != null) {, +            field = fieldType.names().indexName();, +        } else {, +            field = fieldName;, +        }, +, +        Analyzer analyzerObj;, +        if (analyzer == null) {, +            if (fieldType != null) {, +                analyzerObj = parseContext.getSearchAnalyzer(fieldType);, +            } else {, +                analyzerObj = parseContext.mapperService().searchAnalyzer();, +            }, +        } else {, +            analyzerObj = parseContext.mapperService().analysisService().analyzer(analyzer);, +            if (analyzerObj == null) {, +                throw new IllegalArgumentException("no analyzer found for [" + analyzer + "]");]