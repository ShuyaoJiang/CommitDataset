[+++ b/server/src/main/java/org/elasticsearch/index/fielddata/plain/SortedNumericDVIndexFieldData.java, +, +                @Override, +                public int nextDoc() throws IOException {, +                    return dv.nextDoc();, +                }, +++ b/server/src/main/java/org/elasticsearch/index/fielddata/plain/SortedNumericDVIndexFieldData.java, +, +                @Override, +                public int nextDoc() throws IOException {, +                    return dv.nextDoc();, +                }, +++ b/server/src/test/java/org/elasticsearch/index/mapper/DateFieldTypeTests.java, +import org.apache.lucene.document.NumericDocValuesField;, +import org.apache.lucene.index.SortedNumericDocValues;, +import org.apache.lucene.search.DocIdSetIterator;, +import org.elasticsearch.index.fielddata.AtomicNumericFieldData;, +import org.elasticsearch.index.fielddata.IndexNumericFieldData;, +import org.elasticsearch.index.fielddata.plain.SortedNumericDVIndexFieldData;, +, +    public void testDateNanoDocValues() throws IOException {, +        // Create an index with some docValues, +        Directory dir = newDirectory();, +        IndexWriter w = new IndexWriter(dir, new IndexWriterConfig(null));, +        Document doc = new Document();, +        NumericDocValuesField docValuesField = new NumericDocValuesField("my_date", 1444608000000L);, +        doc.add(docValuesField);, +        w.addDocument(doc);, +        docValuesField.setLongValue(1459641600000L);, +        w.addDocument(doc);, +        // Create the doc values reader, +        Settings settings = Settings.builder().put(IndexMetaData.SETTING_VERSION_CREATED, Version.CURRENT), +            .put(IndexMetaData.SETTING_NUMBER_OF_SHARDS, 1).put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, 1).build();, +        IndexSettings indexSettings =  new IndexSettings(IndexMetaData.builder("foo").settings(settings).build(), settings);, +        SortedNumericDVIndexFieldData fieldData = new SortedNumericDVIndexFieldData(indexSettings.getIndex(), "my_date",, +            IndexNumericFieldData.NumericType.DATE_NANOSECONDS);, +        // Read index and check the doc values, +        DirectoryReader reader = DirectoryReader.open(w);, +        assertTrue(reader.leaves().size() > 0);, +        AtomicNumericFieldData a = fieldData.load(reader.leaves().get(0).reader().getContext());, +        SortedNumericDocValues docValues = a.getLongValues();, +        assertEquals(0, docValues.nextDoc());, +        assertEquals(1, docValues.nextDoc());, +        assertEquals(DocIdSetIterator.NO_MORE_DOCS, docValues.nextDoc());, +        reader.close();, +        w.close();, +        dir.close();, +    }, +++ b/server/src/main/java/org/elasticsearch/index/fielddata/plain/SortedNumericDVIndexFieldData.java, +, +                @Override, +                public int nextDoc() throws IOException {, +                    return dv.nextDoc();, +                }, +++ b/server/src/test/java/org/elasticsearch/index/mapper/DateFieldTypeTests.java, +import org.apache.lucene.document.NumericDocValuesField;, +import org.apache.lucene.index.SortedNumericDocValues;, +import org.apache.lucene.search.DocIdSetIterator;, +import org.elasticsearch.index.fielddata.AtomicNumericFieldData;, +import org.elasticsearch.index.fielddata.IndexNumericFieldData;, +import org.elasticsearch.index.fielddata.plain.SortedNumericDVIndexFieldData;, +, +    public void testDateNanoDocValues() throws IOException {, +        // Create an index with some docValues, +        Directory dir = newDirectory();, +        IndexWriter w = new IndexWriter(dir, new IndexWriterConfig(null));, +        Document doc = new Document();, +        NumericDocValuesField docValuesField = new NumericDocValuesField("my_date", 1444608000000L);, +        doc.add(docValuesField);, +        w.addDocument(doc);, +        docValuesField.setLongValue(1459641600000L);, +        w.addDocument(doc);, +        // Create the doc values reader, +        Settings settings = Settings.builder().put(IndexMetaData.SETTING_VERSION_CREATED, Version.CURRENT), +            .put(IndexMetaData.SETTING_NUMBER_OF_SHARDS, 1).put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, 1).build();, +        IndexSettings indexSettings =  new IndexSettings(IndexMetaData.builder("foo").settings(settings).build(), settings);, +        SortedNumericDVIndexFieldData fieldData = new SortedNumericDVIndexFieldData(indexSettings.getIndex(), "my_date",, +            IndexNumericFieldData.NumericType.DATE_NANOSECONDS);, +        // Read index and check the doc values, +        DirectoryReader reader = DirectoryReader.open(w);, +        assertTrue(reader.leaves().size() > 0);, +        AtomicNumericFieldData a = fieldData.load(reader.leaves().get(0).reader().getContext());, +        SortedNumericDocValues docValues = a.getLongValues();, +        assertEquals(0, docValues.nextDoc());, +        assertEquals(1, docValues.nextDoc());, +        assertEquals(DocIdSetIterator.NO_MORE_DOCS, docValues.nextDoc());, +        reader.close();, +        w.close();, +        dir.close();, +    }, +++ b/server/src/test/java/org/elasticsearch/search/aggregations/bucket/DateHistogramIT.java, +, +    /**, +     * See https://github.com/elastic/elasticsearch/issues/39107. Make sure we handle properly different, +     * timeZones., +     */, +    public void testDateNanosHistogram() throws Exception {, +        assertAcked(prepareCreate("nanos").addMapping("_doc", "date", "type=date_nanos").get());, +        indexRandom(true,, +            client().prepareIndex("nanos", "_doc", "1").setSource("date", "2000-01-01"));]