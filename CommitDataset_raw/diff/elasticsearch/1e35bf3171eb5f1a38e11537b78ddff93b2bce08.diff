[+++ b/core/src/main/java/org/elasticsearch/cluster/routing/RoutingService.java, +    protected void performReroute(String reason) {, +++ b/core/src/main/java/org/elasticsearch/cluster/routing/RoutingService.java, +    protected void performReroute(String reason) {, +++ b/core/src/main/java/org/elasticsearch/discovery/zen/NodeJoinController.java, +/*, + * Licensed to Elasticsearch under one or more contributor, + * license agreements. See the NOTICE file distributed with, + * this work for additional information regarding copyright, + * ownership. Elasticsearch licenses this file to you under, + * the Apache License, Version 2.0 (the "License"); you may, + * not use this file except in compliance with the License., + * You may obtain a copy of the License at, + *, + *    http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing,, + * software distributed under the License is distributed on an, + * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY, + * KIND, either express or implied.  See the License for the, + * specific language governing permissions and limitations, + * under the License., + */, +package org.elasticsearch.discovery.zen;, +, +import org.elasticsearch.ElasticsearchTimeoutException;, +import org.elasticsearch.cluster.ClusterService;, +import org.elasticsearch.cluster.ClusterState;, +import org.elasticsearch.cluster.ProcessedClusterStateUpdateTask;, +import org.elasticsearch.cluster.block.ClusterBlocks;, +import org.elasticsearch.cluster.node.DiscoveryNode;, +import org.elasticsearch.cluster.node.DiscoveryNodes;, +import org.elasticsearch.cluster.routing.RoutingService;, +import org.elasticsearch.cluster.routing.allocation.RoutingAllocation;, +import org.elasticsearch.common.Priority;, +import org.elasticsearch.common.component.AbstractComponent;, +import org.elasticsearch.common.settings.Settings;, +import org.elasticsearch.common.unit.TimeValue;, +import org.elasticsearch.discovery.DiscoverySettings;, +import org.elasticsearch.discovery.zen.membership.MembershipAction;, +, +import java.util.*;, +import java.util.concurrent.CountDownLatch;, +import java.util.concurrent.TimeUnit;, +import java.util.concurrent.atomic.AtomicBoolean;, +import java.util.concurrent.atomic.AtomicReference;, +, +/**, + * This class processes incoming join request (passed zia {@link ZenDiscovery}). Incoming nodes, + * are directly added to the cluster state or are accumulated during master election., + */, +public class NodeJoinController extends AbstractComponent {, +, +    final ClusterService clusterService;, +    final RoutingService routingService;, +    final DiscoverySettings discoverySettings;, +    final AtomicBoolean accumulateJoins = new AtomicBoolean(false);, +, +    // this is site while trying to become a master, +    final AtomicReference<ElectionContext> electionContext = new AtomicReference<>();, +, +, +    protected final Map<DiscoveryNode, List<MembershipAction.JoinCallback>> pendingJoinRequests = new HashMap<>();, +, +    public NodeJoinController(ClusterService clusterService, RoutingService routingService, DiscoverySettings discoverySettings, Settings settings) {, +        super(settings);, +        this.clusterService = clusterService;, +        this.routingService = routingService;, +        this.discoverySettings = discoverySettings;, +    }, +, +    /**, +     * waits for enough incoming joins from master eligible nodes to complete the master election, +     * <p/>, +     * You must start accumulating joins before calling this method. See {@link #startAccumulatingJoins()}, +     * <p/>, +     * The method will return once the local node has been elected as master or some failure/timeout has happened., +     * The exact outcome is communicated via the callback parameter, which is guaranteed to be called., +     *, +     * @param requiredMasterJoins the number of joins from master eligible needed to complete the election, +     * @param timeValue           how long to wait before failing. a timeout is communicated via the callback's onFailure method., +     * @param callback            the result of the election (success or failure) will be communicated by calling methods on this, +     *                            object, +     **/, +    public void waitToBeElectedAsMaster(int requiredMasterJoins, TimeValue timeValue, final Callback callback) {, +        assert accumulateJoins.get() : "waitToBeElectedAsMaster is called we are not accumulating joins";, +, +        final CountDownLatch done = new CountDownLatch(1);, +        final ElectionContext newContext = new ElectionContext(callback, requiredMasterJoins) {, +            @Override, +            void onClose() {, +                if (electionContext.compareAndSet(this, null)) {, +                    stopAccumulatingJoins();, +                } else {, +                    assert false : "failed to remove current election context";, +                }, +                done.countDown();, +            }, +        };, +]