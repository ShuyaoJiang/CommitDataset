[+++ b/docs/reference/modules/scripting/painless-syntax.asciidoc, +[[painless-arrays]], +==== Arrays, +, +Arrays can be subscripted starting from `0` for traditional array access or with, +negative numbers to starting from the back of the array. So the following, +returns `2`., +, +[source,painless], +---------------------------------------------------------, +int[] x = new int[5];, +x[0]++;, +x[-5]++;, +return x[0];, +---------------------------------------------------------, +, +, +[float], +Lists can also be accessed similar to arrays. They support `.length` and, +subscripts, including negative subscripts to read from the back of the list:, +list[-1] = 5, +++ b/docs/reference/modules/scripting/painless-syntax.asciidoc, +[[painless-arrays]], +==== Arrays, +, +Arrays can be subscripted starting from `0` for traditional array access or with, +negative numbers to starting from the back of the array. So the following, +returns `2`., +, +[source,painless], +---------------------------------------------------------, +int[] x = new int[5];, +x[0]++;, +x[-5]++;, +return x[0];, +---------------------------------------------------------, +, +, +[float], +Lists can also be accessed similar to arrays. They support `.length` and, +subscripts, including negative subscripts to read from the back of the list:, +list[-1] = 5, +++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/Def.java, +    /** pointer to {@link Def#mapIndexNormalize}. */, +    private static final MethodHandle MAP_INDEX_NORMALIZE;, +    /** pointer to {@link Def#listIndexNormalize}. */, +    private static final MethodHandle LIST_INDEX_NORMALIZE;, +            MAP_INDEX_NORMALIZE = lookup.findStatic(Def.class, "mapIndexNormalize",, +                    MethodType.methodType(Object.class, Map.class, Object.class));, +            LIST_INDEX_NORMALIZE = lookup.findStatic(Def.class, "listIndexNormalize",, +                    MethodType.methodType(int.class, List.class, int.class));, +     * Returns a method handle to normalize the index into an array. This is what makes lists and arrays stored in {@code def} support, +     * negative offsets., +     * @param receiverClass Class of the array to store the value in, +     * @return a MethodHandle that accepts the receiver as first argument, the index as second argument, and returns the normalized index, +     *   to use with array loads and array stores, +     */, +    static MethodHandle lookupIndexNormalize(Class<?> receiverClass) {, +        if (receiverClass.isArray()) {, +            return ArrayIndexNormalizeHelper.arrayIndexNormalizer(receiverClass);, +        } else if (Map.class.isAssignableFrom(receiverClass)) {, +            // noop so that mymap[key] doesn't do funny things with negative keys, +            return MAP_INDEX_NORMALIZE;, +        } else if (List.class.isAssignableFrom(receiverClass)) {, +            return LIST_INDEX_NORMALIZE;, +        }, +        throw new IllegalArgumentException("Attempting to address a non-array-like type " +, +                                           "[" + receiverClass.getCanonicalName() + "] as an array.");, +    }, +, +    /**, +, +    /**, +     * "Normalizes" the index into a {@code Map} by making no change to the index., +     */, +    public static Object mapIndexNormalize(final Map<?, ?> value, Object index) {, +        return index;, +    }, +, +    /**, +     * "Normalizes" the idnex into a {@code List} by flipping negative indexes around so they are "from the end" of the list., +     */, +    public static int listIndexNormalize(final List<?> value, int index) {, +        return index >= 0 ? index : value.size() + index;, +    }, +, +    /**, +     * Methods to normalize array indices to support negative indices into arrays stored in {@code def}s., +     */, +    @SuppressWarnings("unused") // normalizeIndex() methods are are actually used, javac just does not know :), +    private static final class ArrayIndexNormalizeHelper {, +        private static final Lookup PRIV_LOOKUP = MethodHandles.lookup();, +, +        private static final Map<Class<?>,MethodHandle> ARRAY_TYPE_MH_MAPPING = Collections.unmodifiableMap(, +            Stream.of(boolean[].class, byte[].class, short[].class, int[].class, long[].class,, +                char[].class, float[].class, double[].class, Object[].class), +                .collect(Collectors.toMap(Function.identity(), type -> {, +                    try {, +                        return PRIV_LOOKUP.findStatic(PRIV_LOOKUP.lookupClass(), "normalizeIndex",, +                                MethodType.methodType(int.class, type, int.class));]