[+++ b/core/src/main/java/org/elasticsearch/index/IndexService.java, +     * This method gets an instance for each of the given classes passed and calls #close() on the returned instance., +     * NOTE: this method swallows all exceptions thrown from the close method of the injector and logs them as debug log, +     */, +    private void closeInjectorResource(ShardId shardId, Injector shardInjector, Class<? extends Closeable>... toClose) {, +        for (Class<? extends Closeable> closeable : toClose) {, +            if (closeInjectorOptionalResource(shardId, shardInjector, closeable) == false) {, +                logger.warn("[{}] no instance available for [{}], ignoring... ", shardId, closeable.getSimpleName());, +            }, +        }, +    }, +, +    /**, +++ b/core/src/main/java/org/elasticsearch/index/IndexService.java, +     * This method gets an instance for each of the given classes passed and calls #close() on the returned instance., +     * NOTE: this method swallows all exceptions thrown from the close method of the injector and logs them as debug log, +     */, +    private void closeInjectorResource(ShardId shardId, Injector shardInjector, Class<? extends Closeable>... toClose) {, +        for (Class<? extends Closeable> closeable : toClose) {, +            if (closeInjectorOptionalResource(shardId, shardInjector, closeable) == false) {, +                logger.warn("[{}] no instance available for [{}], ignoring... ", shardId, closeable.getSimpleName());, +            }, +        }, +    }, +, +    /**, +++ b/core/src/main/java/org/elasticsearch/index/settings/IndexSettingsService.java, +++ b/core/src/main/java/org/elasticsearch/index/IndexService.java, +     * This method gets an instance for each of the given classes passed and calls #close() on the returned instance., +     * NOTE: this method swallows all exceptions thrown from the close method of the injector and logs them as debug log, +     */, +    private void closeInjectorResource(ShardId shardId, Injector shardInjector, Class<? extends Closeable>... toClose) {, +        for (Class<? extends Closeable> closeable : toClose) {, +            if (closeInjectorOptionalResource(shardId, shardInjector, closeable) == false) {, +                logger.warn("[{}] no instance available for [{}], ignoring... ", shardId, closeable.getSimpleName());, +            }, +        }, +    }, +, +    /**, +++ b/core/src/main/java/org/elasticsearch/index/settings/IndexSettingsService.java, +++ b/core/src/main/java/org/elasticsearch/index/shard/IndexShard.java, +import org.elasticsearch.cluster.ClusterService;, +import org.elasticsearch.cluster.routing.RestoreSource;, +public class IndexShard extends AbstractIndexShardComponent {, +    private final IndexSettingsService indexSettingsService;, +    private final DiscoveryNode localNode;, +, +, +    private ApplyRefreshSettings applyRefreshSettings = new ApplyRefreshSettings();, +, +    public IndexShard(ShardId shardId, IndexSettingsService indexSettingsService, IndicesLifecycle indicesLifecycle, Store store,, +                      ClusterService clusterService, ShardPath path, BigArrays bigArrays, IndexSearcherWrappingService wrappingService) {, +        super(shardId, indexSettingsService.getSettings());, +        this.indexSettingsService = indexSettingsService;, +        assert clusterService.localNode() != null : "Local node is null lifecycle state is: " + clusterService.lifecycleState();, +        this.localNode = clusterService.localNode();, +        indexSettingsService.addListener(applyRefreshSettings);, +     * Marks the shard as recovering based on a remote or local node, fails with exception is recovering is not allowed to be set., +    public IndexShardState recovering(String reason, RecoveryState.Type type, DiscoveryNode sourceNode) throws IndexShardStartedException,, +            IndexShardRelocatedException, IndexShardRecoveringException, IndexShardClosedException {, +        return recovering(reason, new RecoveryState(shardId, shardRouting.primary(), type, sourceNode, localNode));, +    }, +, +    /**, +     * Marks the shard as recovering based on a restore, fails with exception is recovering is not allowed to be set., +     */, +    public IndexShardState recovering(String reason, RecoveryState.Type type, RestoreSource restoreSource) throws IndexShardStartedException {, +        return recovering(reason, new RecoveryState(shardId, shardRouting.primary(), type, restoreSource, localNode));, +    }, +, +    private IndexShardState recovering(String reason, RecoveryState recoveryState) throws IndexShardStartedException,, +                indexSettingsService.removeListener(applyRefreshSettings);, +    public boolean recoverFromStore(ShardRouting shard) {, +    public boolean restoreFromRepository(ShardRouting shard, IndexShardRepository repository) {, +        return storeRecovery.recoverFromRepository(this, repository);, +    private class ApplyRefreshSettings implements IndexSettingsService.Listener {, +                int flushThresholdOperations = settings.getAsInt(INDEX_TRANSLOG_FLUSH_THRESHOLD_OPS, IndexShard.this.flushThresholdOperations);, +                if (flushThresholdOperations != IndexShard.this.flushThresholdOperations) {, +                    logger.info("updating flush_threshold_ops from [{}] to [{}]", IndexShard.this.flushThresholdOperations, flushThresholdOperations);, +                    IndexShard.this.flushThresholdOperations = flushThresholdOperations;, +                ByteSizeValue flushThresholdSize = settings.getAsBytesSize(INDEX_TRANSLOG_FLUSH_THRESHOLD_SIZE, IndexShard.this.flushThresholdSize);, +                if (!flushThresholdSize.equals(IndexShard.this.flushThresholdSize)) {, +                    logger.info("updating flush_threshold_size from [{}] to [{}]", IndexShard.this.flushThresholdSize, flushThresholdSize);, +                    IndexShard.this.flushThresholdSize = flushThresholdSize;, +                boolean disableFlush = settings.getAsBoolean(INDEX_TRANSLOG_DISABLE_FLUSH, IndexShard.this.disableFlush);, +                if (disableFlush != IndexShard.this.disableFlush) {, +                    logger.info("updating disable_flush from [{}] to [{}]", IndexShard.this.disableFlush, disableFlush);, +                    IndexShard.this.disableFlush = disableFlush;, +                final boolean flushOnClose = settings.getAsBoolean(INDEX_FLUSH_ON_CLOSE, IndexShard.this.flushOnClose);, +                if (flushOnClose != IndexShard.this.flushOnClose) {, +                    logger.info("updating {} from [{}] to [{}]", INDEX_FLUSH_ON_CLOSE, IndexShard.this.flushOnClose, flushOnClose);, +                    IndexShard.this.flushOnClose = flushOnClose;, +                TimeValue refreshInterval = settings.getAsTime(INDEX_REFRESH_INTERVAL, IndexShard.this.refreshInterval);, +                if (!refreshInterval.equals(IndexShard.this.refreshInterval)) {, +                    logger.info("updating refresh_interval from [{}] to [{}]", IndexShard.this.refreshInterval, refreshInterval);, +                    IndexShard.this.refreshInterval = refreshInterval;, +    }, +                threadPool, indexingService, indexSettingsService.indexSettings(), warmer, store, deletionPolicy, mergePolicyConfig.getMergePolicy(), mergeSchedulerConfig,, +++ b/core/src/main/java/org/elasticsearch/index/IndexService.java]