[+++ b/distribution/packages/build.gradle, +      }, +      // we need to specify every intermediate directory in these paths so the package managers know they are explicitly, +      // intended to manage them; otherwise they may be left behind on uninstallation. duplicate calls of the same, +      // directory are fine, +        for (int i = segments.length - 2; i > 2; --i) {, +++ b/distribution/packages/build.gradle, +      }, +      // we need to specify every intermediate directory in these paths so the package managers know they are explicitly, +      // intended to manage them; otherwise they may be left behind on uninstallation. duplicate calls of the same, +      // directory are fine, +        for (int i = segments.length - 2; i > 2; --i) {, +++ b/docs/reference/rest-api/info.asciidoc, +++ b/distribution/packages/build.gradle, +      }, +      // we need to specify every intermediate directory in these paths so the package managers know they are explicitly, +      // intended to manage them; otherwise they may be left behind on uninstallation. duplicate calls of the same, +      // directory are fine, +        for (int i = segments.length - 2; i > 2; --i) {, +++ b/docs/reference/rest-api/info.asciidoc, +++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/lookup/PainlessLookupBuilder.java, +import java.lang.reflect.Constructor;, +import java.lang.reflect.Field;, +import java.lang.reflect.Method;, +import static org.elasticsearch.painless.lookup.PainlessLookupUtility.CONSTRUCTOR_NAME;, +import static org.elasticsearch.painless.lookup.PainlessLookupUtility.DEF_CLASS_NAME;, +import static org.elasticsearch.painless.lookup.PainlessLookupUtility.buildPainlessFieldKey;, +import static org.elasticsearch.painless.lookup.PainlessLookupUtility.typeToCanonicalTypeName;, +import static org.elasticsearch.painless.lookup.PainlessLookupUtility.typeToJavaType;, +import static org.elasticsearch.painless.lookup.PainlessLookupUtility.typesToCanonicalTypeNames;, +    private final Map<Class<?>, PainlessClassBuilder> classesToPainlessClassBuilders;, +        classesToPainlessClassBuilders = new HashMap<>();, +        canonicalClassNamesToClasses.put(DEF_CLASS_NAME, def.class);, +        classesToPainlessClassBuilders.put(def.class,, +                new PainlessClassBuilder(DEF_CLASS_NAME, Object.class, org.objectweb.asm.Type.getType(Object.class)));, +        PainlessLookupUtility.validateType(type, classesToPainlessClassBuilders.keySet());, +            throw new IllegalArgumentException("cannot add reserved class [" + DEF_CLASS_NAME + "]");, +        String canonicalClassName = typeToCanonicalTypeName(clazz);, +        PainlessClassBuilder existingPainlessClassBuilder = classesToPainlessClassBuilders.get(clazz);, +            PainlessClassBuilder painlessClassBuilder =, +                    new PainlessClassBuilder(canonicalClassName, clazz, org.objectweb.asm.Type.getType(clazz));, +            classesToPainlessClassBuilders.put(clazz, painlessClassBuilder);, +            Class<?> importedPainlessClass = canonicalClassNamesToClasses.get(importedCanonicalClassName);, +            if (importedPainlessClass == null) {, +                        throw new IllegalArgumentException("inconsistent only_fqn parameters found for class [" + canonicalClassName + "]");, +            } else if (importedPainlessClass.equals(clazz) == false) {, +                throw new IllegalArgumentException("imported class [" + importedCanonicalClassName + "] cannot represent multiple " +, +                        "classes [" + canonicalClassName + "] and [" + typeToCanonicalTypeName(importedPainlessClass) + "]");, +                throw new IllegalArgumentException("inconsistent only_fqn parameters found for class [" + canonicalClassName + "]");, +    public void addPainlessConstructor(String targetCanonicalClassName, List<String> typeNameParameters) {, +        Objects.requireNonNull(targetCanonicalClassName);, +        Objects.requireNonNull(typeNameParameters);, +        Class<?> targetClass = canonicalClassNamesToClasses.get(targetCanonicalClassName);, +, +        if (targetClass == null) {, +            throw new IllegalArgumentException("target class [" + targetCanonicalClassName + "] not found" +, +                    "for constructor [[" + targetCanonicalClassName + "], " + typeNameParameters  + "]");, +        List<Class<?>> typeParameters = new ArrayList<>(typeNameParameters.size());, +        for (String typeNameParameter : typeNameParameters) {, +                Class<?> typeParameter = canonicalTypeNameToType(typeNameParameter);, +                typeParameters.add(typeParameter);, +                throw new IllegalArgumentException("type parameter [" + typeNameParameter + "] not found " +, +                        "for constructor [[" + targetCanonicalClassName + "], " + typeNameParameters  + "]", iae);, +        addPainlessConstructor(targetClass, typeParameters);, +    }, +, +    public void addPainlessConstructor(Class<?> targetClass, List<Class<?>> typeParameters) {, +        Objects.requireNonNull(targetClass);, +        Objects.requireNonNull(typeParameters);, +, +        if (targetClass == def.class) {, +            throw new IllegalArgumentException("cannot add constructor to reserved class [" + DEF_CLASS_NAME + "]");, +        }, +, +        String targetCanonicalClassName = targetClass.getCanonicalName();, +        PainlessClassBuilder painlessClassBuilder = classesToPainlessClassBuilders.get(targetClass);, +, +        if (painlessClassBuilder == null) {, +            throw new IllegalArgumentException("target class [" + targetCanonicalClassName + "] not found" +, +                    "for constructor [[" + targetCanonicalClassName + "], " + typesToCanonicalTypeNames(typeParameters)  + "]");, +        }, +, +        int typeParametersSize = typeParameters.size();, +        List<Class<?>> javaTypeParameters = new ArrayList<>(typeParametersSize);, +, +        for (Class<?> typeParameter : typeParameters) {, +            try {, +                validateType(typeParameter);, +            } catch (IllegalArgumentException iae) {, +                throw new IllegalArgumentException("type parameter [" + typeToCanonicalTypeName(typeParameter) + "] not found " +, +                        "for constructor [[" + targetCanonicalClassName + "], " + typesToCanonicalTypeNames(typeParameters) + "]", iae);, +            }, +, +            javaTypeParameters.add(typeToJavaType(typeParameter));, +        }, +, +        Constructor<?> javaConstructor;, +            javaConstructor = targetClass.getConstructor(javaTypeParameters.toArray(new Class<?>[typeParametersSize]));, +        } catch (NoSuchMethodException nsme) {, +            throw new IllegalArgumentException("constructor reflection object " +]