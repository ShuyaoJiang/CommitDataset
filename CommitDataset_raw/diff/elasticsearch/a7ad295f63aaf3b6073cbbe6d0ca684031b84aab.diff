[+++ b/modules/elasticsearch/src/main/java/org/elasticsearch/discovery/zen/ZenDiscovery.java, +        nodesFD.updateNodes(latestDiscoNodes);, +                    if (e instanceof ElasticSearchException) {, +                        logger.info("Failed to send join request to master [{}], reason [{}]", masterNode, ((ElasticSearchException) e).getDetailedMessage());, +                    } else {, +                        logger.info("Failed to send join request to master [{}], reason [{}]", masterNode, e.getMessage());, +                    }, +                    if (logger.isTraceEnabled()) {, +                        logger.trace("Detailed failed reason", e);, +                    }, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/discovery/zen/ZenDiscovery.java, +        nodesFD.updateNodes(latestDiscoNodes);, +                    if (e instanceof ElasticSearchException) {, +                        logger.info("Failed to send join request to master [{}], reason [{}]", masterNode, ((ElasticSearchException) e).getDetailedMessage());, +                    } else {, +                        logger.info("Failed to send join request to master [{}], reason [{}]", masterNode, e.getMessage());, +                    }, +                    if (logger.isTraceEnabled()) {, +                        logger.trace("Detailed failed reason", e);, +                    }, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/discovery/zen/fd/MasterFaultDetection.java, +import org.elasticsearch.ElasticSearchIllegalStateException;, +                transportService.sendRequest(masterNode, MasterPingRequestHandler.ACTION, new MasterPingRequest(nodesProvider.nodes().localNode().id(), sentToNode.id()), pingRetryTimeout,, +                                        // resend the request, not reschedule, rely on send timeout, +                                        transportService.sendRequest(sentToNode, MasterPingRequestHandler.ACTION, new MasterPingRequest(nodesProvider.nodes().localNode().id(), sentToNode.id()), pingRetryTimeout, this);, +            // check if we are really the same master as the one we seemed to be think we are, +            // this can happen if the master got "kill -9" and then another node started using the same port, +            if (!request.masterNodeId.equals(nodes.localNodeId())) {, +                throw new ElasticSearchIllegalStateException("Got ping as master with id [" + request.masterNodeId + "], but not master and no id");, +            }, +            // send a response, and note if we are connected to the master or not, +            channel.sendResponse(new MasterPingResponseResponse(nodes.nodeExists(request.nodeId)));, +        private String nodeId;, +, +        private String masterNodeId;, +        private MasterPingRequest(String nodeId, String masterNodeId) {, +            this.nodeId = nodeId;, +            this.masterNodeId = masterNodeId;, +            nodeId = in.readUTF();, +            masterNodeId = in.readUTF();, +            out.writeUTF(nodeId);, +            out.writeUTF(masterNodeId);, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/discovery/zen/ZenDiscovery.java, +        nodesFD.updateNodes(latestDiscoNodes);, +                    if (e instanceof ElasticSearchException) {, +                        logger.info("Failed to send join request to master [{}], reason [{}]", masterNode, ((ElasticSearchException) e).getDetailedMessage());, +                    } else {, +                        logger.info("Failed to send join request to master [{}], reason [{}]", masterNode, e.getMessage());, +                    }, +                    if (logger.isTraceEnabled()) {, +                        logger.trace("Detailed failed reason", e);, +                    }, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/discovery/zen/fd/MasterFaultDetection.java, +import org.elasticsearch.ElasticSearchIllegalStateException;, +                transportService.sendRequest(masterNode, MasterPingRequestHandler.ACTION, new MasterPingRequest(nodesProvider.nodes().localNode().id(), sentToNode.id()), pingRetryTimeout,, +                                        // resend the request, not reschedule, rely on send timeout, +                                        transportService.sendRequest(sentToNode, MasterPingRequestHandler.ACTION, new MasterPingRequest(nodesProvider.nodes().localNode().id(), sentToNode.id()), pingRetryTimeout, this);, +            // check if we are really the same master as the one we seemed to be think we are, +            // this can happen if the master got "kill -9" and then another node started using the same port, +            if (!request.masterNodeId.equals(nodes.localNodeId())) {, +                throw new ElasticSearchIllegalStateException("Got ping as master with id [" + request.masterNodeId + "], but not master and no id");, +            }, +            // send a response, and note if we are connected to the master or not, +            channel.sendResponse(new MasterPingResponseResponse(nodes.nodeExists(request.nodeId)));, +        private String nodeId;, +, +        private String masterNodeId;, +        private MasterPingRequest(String nodeId, String masterNodeId) {, +            this.nodeId = nodeId;, +            this.masterNodeId = masterNodeId;, +            nodeId = in.readUTF();, +            masterNodeId = in.readUTF();, +            out.writeUTF(nodeId);, +            out.writeUTF(masterNodeId);, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/discovery/zen/fd/NodesFaultDetection.java, +import org.elasticsearch.ElasticSearchIllegalStateException;, +            transportService.sendRequest(node, PingRequestHandler.ACTION, new PingRequest(node.id()), pingRetryTimeout,, +                                        // resend the request, not reschedule, rely on send timeout, +                                        transportService.sendRequest(node, PingRequestHandler.ACTION, new PingRequest(node.id()), pingRetryTimeout, this);, +    class PingRequestHandler extends BaseTransportRequestHandler<PingRequest> {, +            // if we are not the node we are supposed to be pinged, send an exception, +            // this can happen when a kill -9 is sent, and another node is started using the same port, +            if (!latestNodes.localNodeId().equals(request.nodeId)) {, +                throw new ElasticSearchIllegalStateException("Got pinged as node [" + request.nodeId + "], but I am node [" + latestNodes.localNodeId() + "]");, +            }, +    static class PingRequest implements Streamable {, +        // the (assumed) node id we are pinging, +        private String nodeId;, +, +        PingRequest() {, +        }, +, +        PingRequest(String nodeId) {, +            this.nodeId = nodeId;, +            nodeId = in.readUTF();, +            out.writeUTF(nodeId);]