[+++ b/src/main/java/org/elasticsearch/index/mapper/core/AbstractFieldMapper.java, +            return new MultiFields(Defaults.PATH_TYPE, ImmutableOpenMap.<String, FieldMapper>of());, +                    return new MultiFields(pathType, ImmutableOpenMap.<String, FieldMapper>of());, +                        Mapper mapper = value.build(context);, +                        assert mapper instanceof FieldMapper;, +                        mapperBuilders.put(key, mapper);, +                    ImmutableOpenMap.Builder<String, FieldMapper> mappers = mapperBuilders.cast();, +        private volatile ImmutableOpenMap<String, FieldMapper> mappers;, +        public MultiFields(ContentPath.Type pathType, ImmutableOpenMap<String, FieldMapper> mappers) {, +            for (ObjectCursor<FieldMapper> cursor : mappers.values()) {, +                FieldMapper mapper = cursor.value;, +            for (ObjectCursor<FieldMapper> cursor : mappers.values()) {, +            ImmutableOpenMap.Builder<String, FieldMapper> newMappersBuilder = null;, +            for (ObjectCursor<FieldMapper> cursor : mergeWithMultiField.multiFields.mappers.values()) {, +                FieldMapper mergeWithMapper = cursor.value;, +                            newFieldMappers.add(mergeWithMapper);, +            for (ObjectCursor<FieldMapper> cursor : mappers.values()) {, +            for (ObjectCursor<FieldMapper> cursor : mappers.values()) {, +++ b/src/main/java/org/elasticsearch/index/mapper/core/AbstractFieldMapper.java, +            return new MultiFields(Defaults.PATH_TYPE, ImmutableOpenMap.<String, FieldMapper>of());, +                    return new MultiFields(pathType, ImmutableOpenMap.<String, FieldMapper>of());, +                        Mapper mapper = value.build(context);, +                        assert mapper instanceof FieldMapper;, +                        mapperBuilders.put(key, mapper);, +                    ImmutableOpenMap.Builder<String, FieldMapper> mappers = mapperBuilders.cast();, +        private volatile ImmutableOpenMap<String, FieldMapper> mappers;, +        public MultiFields(ContentPath.Type pathType, ImmutableOpenMap<String, FieldMapper> mappers) {, +            for (ObjectCursor<FieldMapper> cursor : mappers.values()) {, +                FieldMapper mapper = cursor.value;, +            for (ObjectCursor<FieldMapper> cursor : mappers.values()) {, +            ImmutableOpenMap.Builder<String, FieldMapper> newMappersBuilder = null;, +            for (ObjectCursor<FieldMapper> cursor : mergeWithMultiField.multiFields.mappers.values()) {, +                FieldMapper mergeWithMapper = cursor.value;, +                            newFieldMappers.add(mergeWithMapper);, +            for (ObjectCursor<FieldMapper> cursor : mappers.values()) {, +            for (ObjectCursor<FieldMapper> cursor : mappers.values()) {, +++ b/src/main/java/org/elasticsearch/index/mapper/core/TypeParsers.java, +import org.elasticsearch.index.mapper.object.ObjectMapper;, +                if (type.equals(ObjectMapper.CONTENT_TYPE) || type.equals(ObjectMapper.NESTED_CONTENT_TYPE)) {, +                    throw new MapperParsingException("Type [" + type + "] cannot be used in multi field");, +                }, +++ b/src/main/java/org/elasticsearch/index/mapper/core/AbstractFieldMapper.java, +            return new MultiFields(Defaults.PATH_TYPE, ImmutableOpenMap.<String, FieldMapper>of());, +                    return new MultiFields(pathType, ImmutableOpenMap.<String, FieldMapper>of());, +                        Mapper mapper = value.build(context);, +                        assert mapper instanceof FieldMapper;, +                        mapperBuilders.put(key, mapper);, +                    ImmutableOpenMap.Builder<String, FieldMapper> mappers = mapperBuilders.cast();, +        private volatile ImmutableOpenMap<String, FieldMapper> mappers;, +        public MultiFields(ContentPath.Type pathType, ImmutableOpenMap<String, FieldMapper> mappers) {, +            for (ObjectCursor<FieldMapper> cursor : mappers.values()) {, +                FieldMapper mapper = cursor.value;, +            for (ObjectCursor<FieldMapper> cursor : mappers.values()) {, +            ImmutableOpenMap.Builder<String, FieldMapper> newMappersBuilder = null;, +            for (ObjectCursor<FieldMapper> cursor : mergeWithMultiField.multiFields.mappers.values()) {, +                FieldMapper mergeWithMapper = cursor.value;, +                            newFieldMappers.add(mergeWithMapper);, +            for (ObjectCursor<FieldMapper> cursor : mappers.values()) {, +            for (ObjectCursor<FieldMapper> cursor : mappers.values()) {, +++ b/src/main/java/org/elasticsearch/index/mapper/core/TypeParsers.java, +import org.elasticsearch.index.mapper.object.ObjectMapper;, +                if (type.equals(ObjectMapper.CONTENT_TYPE) || type.equals(ObjectMapper.NESTED_CONTENT_TYPE)) {, +                    throw new MapperParsingException("Type [" + type + "] cannot be used in multi field");, +                }, +++ b/src/test/java/org/elasticsearch/index/mapper/multifield/MultiFieldTests.java, +import org.elasticsearch.index.mapper.MapperParsingException;, +, +    public void testObjectFieldNotAllowed() throws Exception {, +        String mapping = jsonBuilder().startObject().startObject("type").startObject("properties").startObject("my_field"), +            .field("type", "string").startObject("fields").startObject("multi").field("type", "object").endObject().endObject(), +            .endObject().endObject().endObject().endObject().string();, +        final DocumentMapperParser parser = createIndex("test").mapperService().documentMapperParser();, +        try {, +            parser.parse(mapping);, +            fail("expected mapping parse failure");, +        } catch (MapperParsingException e) {, +            assertTrue(e.getMessage().contains("cannot be used in multi field"));, +        }, +    }, +, +    public void testNestedFieldNotAllowed() throws Exception {, +        String mapping = jsonBuilder().startObject().startObject("type").startObject("properties").startObject("my_field"), +            .field("type", "string").startObject("fields").startObject("multi").field("type", "nested").endObject().endObject(), +            .endObject().endObject().endObject().endObject().string();, +        final DocumentMapperParser parser = createIndex("test").mapperService().documentMapperParser();, +        try {, +            parser.parse(mapping);, +            fail("expected mapping parse failure");, +        } catch (MapperParsingException e) {, +            assertTrue(e.getMessage().contains("cannot be used in multi field"));, +        }, +    }]