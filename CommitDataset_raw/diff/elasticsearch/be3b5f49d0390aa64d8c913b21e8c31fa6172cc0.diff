[+++ b/migrate-issues.py, +import argparse, +import calendar, +import json, +import re, +import requests, +import shutil, +import subprocess, +import tempfile, +import time, +, +def throttle(response):, +    if 'X-RateLimit-Remaining' in response.headers:, +        rate_limit_remaining = int(response.headers['X-RateLimit-Remaining']), +        if rate_limit_remaining < 16:, +            rate_limit_reset = int(response.headers['X-RateLimit-Reset']), +            delay = rate_limit_reset - calendar.timegm(time.gmtime()), +            print('rate limit remaining: {}, rate limit reset: {}, throttling for {} seconds'.format(rate_limit_remaining, rate_limit_reset, delay)), +            if delay >= 0:, +                time.sleep(delay), +, +    return response, +, +def authorization_token(token):, +    return {'Authorization':'token {}'.format(token)}, +, +def next_url(response):, +    """Return the next URL following the Link header, otherwise None.""", +    nu = None, +    if 'Link' in response.headers:, +        links = response.headers['Link'].split(','), +        for link in links:, +            if 'rel="next"' in link:, +                nu = link.split(';')[0][1:-1], +                break, +, +    return nu, +, +def get(url, token):, +    """Return the response for the specified URL.""", +    headers = authorization_token(token), +    return throttle(requests.get(url, headers=headers)), +, +def get_all(url, token):, +    """Returns all pages starting at the specified URL.""", +    items = [], +    while url is not None:, +        response = get(url, token), +        json = response.json(), +        if json:, +            items.extend(response.json()), +            url = next_url(response), +        else:, +            url = None, +, +    return items, +, +def issue_comments(source_owner, source_repo, issue, token):, +    """Return all issue comments.""", +    url = 'https://api.github.com/repos/{}/{}/issues/{}/comments'.format(source_owner, source_repo, issue), +    return get_all(url, token), +, +assignees_cache = {}, +, +def repo_assignees(assignee, owner, repo, token):, +    """Returns True if the assignee is valid for the specified owner/repo, otherwise False.""", +    if assignee in assignees_cache:, +        return assignees_cache[assignee], +    url = 'https://api.github.com/repos/{}/{}/assignees/{}'.format(owner, repo, assignee), +    response = get(url, token), +    assignees_cache[assignee] = response.status_code == 204, +    return assignees_cache[assignee], +, +def rewrite_issue_links(text, source_owner, source_repo):, +    return re.sub(r"(\s+)(#\d+)", "\\1{}/{}\\2".format(source_owner, source_repo), text), +, +def rewrite_commits(text, source_owner, source_repo, temp):, +    commits = [], +    for match in re.finditer(r"(?<!@)[a-f0-9]{7,40}", text):, +        if subprocess.call(['git', '-C', temp, 'cat-file', 'commit', match.group(0)], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL) == 0:, +            commits.append(match.group(0)), +, +    for commit in commits:, +        text = re.sub(r"(?<!@)({})".format(commit), "{}/{}@{}".format(source_owner, source_repo, commit), text), +, +    return text, +, +def copy_issue(issue, label_names, source_owner, source_repo, destination_owner, destination_repo, token, temp):, +    """Posts an issue to the specified owner/repo with the specified labels.""", +    url = 'https://api.github.com/repos/{}/{}/issues'.format(destination_owner, destination_repo), +    headers = authorization_token(token), +    issue_number = issue['number'], +    title = issue['title'], +    issue_body = rewrite_commits(rewrite_issue_links(issue['body'], source_owner, source_repo), source_owner, source_repo, temp), +    body = '*Original comment by @{}:*'.format(issue['user']['login']) + '\n\n' + issue_body + '\n\n' + 'Supercedes {}/{}#{}'.format(source_owner, source_repo, issue_number), +    labels = [label for label in label_names], +    assignees = [assignee['login'] for assignee in issue['assignees'] if repo_assignees(assignee['login'], destination_owner, destination_repo, token)], +    payload = { 'title':title, 'body':body, 'labels':labels, 'assignees':assignees }, +    return throttle(requests.post(url, headers=headers, data=json.dumps(payload))), +]