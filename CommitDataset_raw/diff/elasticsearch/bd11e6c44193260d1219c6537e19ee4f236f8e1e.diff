[+++ b/server/src/main/java/org/elasticsearch/search/aggregations/bucket/composite/CompositeAggregator.java, +import org.apache.lucene.search.Query;, +import org.apache.lucene.search.Scorer;, +import org.apache.lucene.search.Weight;, +        final boolean needsScores = needsScores();, +        Weight weight = null;, +        if (needsScores) {, +            Query query = context.query();, +            weight = context.searcher().createNormalizedWeight(query, true);, +        }, +            DocIdSetIterator scorerIt = null;, +            if (needsScores) {, +                Scorer scorer = weight.scorer(context.ctx);, +                // We don't need to check if the scorer is null, +                // since we are sure that there are documents to replay (docIdSetIterator it not empty)., +                scorerIt = scorer.iterator();, +                context.subCollector.setScorer(scorer);, +            }, +                if (needsScores) {, +                    assert scorerIt.docID() < docID;, +                    scorerIt.advance(docID);, +                    // aggregations should only be replayed on matching documents, +                    assert scorerIt.docID() == docID;, +                }, +++ b/server/src/main/java/org/elasticsearch/search/aggregations/bucket/composite/CompositeAggregator.java, +import org.apache.lucene.search.Query;, +import org.apache.lucene.search.Scorer;, +import org.apache.lucene.search.Weight;, +        final boolean needsScores = needsScores();, +        Weight weight = null;, +        if (needsScores) {, +            Query query = context.query();, +            weight = context.searcher().createNormalizedWeight(query, true);, +        }, +            DocIdSetIterator scorerIt = null;, +            if (needsScores) {, +                Scorer scorer = weight.scorer(context.ctx);, +                // We don't need to check if the scorer is null, +                // since we are sure that there are documents to replay (docIdSetIterator it not empty)., +                scorerIt = scorer.iterator();, +                context.subCollector.setScorer(scorer);, +            }, +                if (needsScores) {, +                    assert scorerIt.docID() < docID;, +                    scorerIt.advance(docID);, +                    // aggregations should only be replayed on matching documents, +                    assert scorerIt.docID() == docID;, +                }, +++ b/server/src/test/java/org/elasticsearch/search/aggregations/bucket/composite/CompositeAggregatorTests.java, +import org.elasticsearch.search.aggregations.metrics.tophits.TopHits;, +import org.elasticsearch.search.aggregations.metrics.tophits.TopHitsAggregationBuilder;, +    public void testWithKeywordAndTopHits() throws Exception {, +        final List<Map<String, List<Object>>> dataset = new ArrayList<>();, +        dataset.addAll(, +            Arrays.asList(, +                createDocument("keyword", "a"),, +                createDocument("keyword", "c"),, +                createDocument("keyword", "a"),, +                createDocument("keyword", "d"),, +                createDocument("keyword", "c"), +            ), +        );, +        final Sort sort = new Sort(new SortedSetSortField("keyword", false));, +        testSearchCase(new MatchAllDocsQuery(), sort, dataset,, +            () -> {, +                TermsValuesSourceBuilder terms = new TermsValuesSourceBuilder("keyword"), +                    .field("keyword");, +                return new CompositeAggregationBuilder("name", Collections.singletonList(terms)), +                    .subAggregation(new TopHitsAggregationBuilder("top_hits").storedField("_none_"));, +            }, (result) -> {, +                assertEquals(3, result.getBuckets().size());, +                assertEquals("{keyword=a}", result.getBuckets().get(0).getKeyAsString());, +                assertEquals(2L, result.getBuckets().get(0).getDocCount());, +                TopHits topHits = result.getBuckets().get(0).getAggregations().get("top_hits");, +                assertNotNull(topHits);, +                assertEquals(topHits.getHits().getHits().length, 2);, +                assertEquals(topHits.getHits().getTotalHits(), 2L);, +                assertEquals("{keyword=c}", result.getBuckets().get(1).getKeyAsString());, +                assertEquals(2L, result.getBuckets().get(1).getDocCount());, +                topHits = result.getBuckets().get(1).getAggregations().get("top_hits");, +                assertNotNull(topHits);, +                assertEquals(topHits.getHits().getHits().length, 2);, +                assertEquals(topHits.getHits().getTotalHits(), 2L);, +                assertEquals("{keyword=d}", result.getBuckets().get(2).getKeyAsString());, +                assertEquals(1L, result.getBuckets().get(2).getDocCount());, +                topHits = result.getBuckets().get(2).getAggregations().get("top_hits");, +                assertNotNull(topHits);, +                assertEquals(topHits.getHits().getHits().length, 1);, +                assertEquals(topHits.getHits().getTotalHits(), 1L);;, +            }, +        );, +, +        testSearchCase(new MatchAllDocsQuery(), sort, dataset,, +            () -> {, +                TermsValuesSourceBuilder terms = new TermsValuesSourceBuilder("keyword"), +                    .field("keyword");, +                return new CompositeAggregationBuilder("name", Collections.singletonList(terms)), +                    .aggregateAfter(Collections.singletonMap("keyword", "a")), +                    .subAggregation(new TopHitsAggregationBuilder("top_hits").storedField("_none_"));, +            }, (result) -> {]