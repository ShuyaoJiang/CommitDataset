[+++ b/core/src/main/java/org/elasticsearch/action/support/replication/TransportReplicationAction.java, +import java.util.function.Consumer;, +            final IndexShardRoutingTable shardRoutingTable = state.getRoutingTable().shardRoutingTableOrNull(shardId);, +            List<ShardRouting> shards = shards(shardRoutingTable);, +            boolean executeOnReplica = (indexMetaData == null) || shouldExecuteReplication(indexMetaData.getSettings());, +            DiscoveryNodes nodes = state.getNodes();, +            AtomicInteger numberOfPendingShardInstances = new AtomicInteger();, +            this.totalShards = countTotalAndPending(shards, executeOnReplica, nodes, numberOfPendingShardInstances);, +            this.pending = numberOfPendingShardInstances;, +            this.shards = shards;, +            this.executeOnReplica = executeOnReplica;, +            this.nodes = nodes;, +            if (logger.isTraceEnabled()) {, +                logger.trace("replication phase started. pending [{}], action [{}], request [{}], cluster state version used [{}]", pending.get(),, +                        transportReplicaAction, replicaRequest, state.version());, +            }, +        }, +, +        private int countTotalAndPending(List<ShardRouting> shards, boolean executeOnReplica, DiscoveryNodes nodes, AtomicInteger pending) {, +            assert pending.get() == 0;, +            int numberOfIgnoredShardInstances = performOnShards(shards, executeOnReplica, nodes, shard -> pending.incrementAndGet(), shard -> pending.incrementAndGet());, +            // one for the local primary copy, +            return 1 + numberOfIgnoredShardInstances + pending.get();, +        }, +, +        private int performOnShards(List<ShardRouting> shards, boolean executeOnReplica, DiscoveryNodes nodes, Consumer<ShardRouting> onLocalShard, Consumer<ShardRouting> onRelocatingShard) {, +                    // If the replicas use shadow replicas, there is no reason to, +                    // perform the action on the replica, so skip it and, +                    // immediately return, +, +                    // this delays mapping updates on replicas because they have, +                    // to wait until they get the new mapping through the cluster, +                    // state, which is why we recommend pre-defined mappings for, +                    // indices using shadow replicas, +                // we index on a replica that is initializing as well since we might not have got the event, +                // yet that it was started. We will get an exception IllegalShardState exception if its not started, +                // and that's fine, we will ignore it, +, +                // we never execute replication operation locally as primary operation has already completed locally, +                // hence, we ignore any local shard for replication, +                    onLocalShard.accept(shard);, +                // send operation to relocating shard, +                // local shard can be a relocation target of a primary that is in relocated state, +                    onRelocatingShard.accept(shard);, +            return numberOfIgnoredShardInstances;, +, +        private List<ShardRouting> shards(IndexShardRoutingTable shardRoutingTable) {, +            return (shardRoutingTable != null) ? shardRoutingTable.shards() : Collections.emptyList();, +            performOnShards(shards, executeOnReplica, nodes, shard -> performOnReplica(shard), shard -> performOnReplica(shard.buildTargetRelocatingShard()));]