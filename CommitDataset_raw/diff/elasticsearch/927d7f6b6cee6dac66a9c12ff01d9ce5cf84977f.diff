[+++ b/core/src/main/java/org/elasticsearch/index/shard/IndexShard.java, +                                 * replaying the translog and marking any operations there are completed. Rolling the translog generation is, +                                 * not strictly needed here (as we will never have collisions between sequence numbers in a translog, +                                 * generation in a new primary as it takes the last known sequence number as a starting point), but it, +                                 * simplifies reasoning about the relationship between primary terms and translog generations., +                                getEngine().rollTranslogGeneration();, +++ b/core/src/main/java/org/elasticsearch/index/shard/IndexShard.java, +                                 * replaying the translog and marking any operations there are completed. Rolling the translog generation is, +                                 * not strictly needed here (as we will never have collisions between sequence numbers in a translog, +                                 * generation in a new primary as it takes the last known sequence number as a starting point), but it, +                                 * simplifies reasoning about the relationship between primary terms and translog generations., +                                getEngine().rollTranslogGeneration();, +++ b/core/src/test/java/org/elasticsearch/index/shard/IndexShardTests.java, +    public void testPrimaryPromotionRollsGeneration() throws Exception {, +        final IndexShard indexShard = newStartedShard(false);, +, +        final long currentTranslogGeneration = indexShard.getTranslog().getGeneration().translogFileGeneration;, +, +        // promote the replica, +        final ShardRouting replicaRouting = indexShard.routingEntry();, +        final ShardRouting primaryRouting =, +                newShardRouting(, +                        replicaRouting.shardId(),, +                        replicaRouting.currentNodeId(),, +                        null,, +                        true,, +                        ShardRoutingState.STARTED,, +                        replicaRouting.allocationId());, +        indexShard.updateShardState(primaryRouting, indexShard.getPrimaryTerm() + 1, (shard, listener) -> {},, +                0L, Collections.singleton(primaryRouting.allocationId().getId()),, +                new IndexShardRoutingTable.Builder(primaryRouting.shardId()).addShard(primaryRouting).build(), Collections.emptySet());, +, +        /*, +         * This operation completing means that the delay operation executed as part of increasing the primary term has completed and the, +         * gaps are filled., +         */, +        final CountDownLatch latch = new CountDownLatch(1);, +        indexShard.acquirePrimaryOperationPermit(, +                new ActionListener<Releasable>() {, +                    @Override, +                    public void onResponse(Releasable releasable) {, +                        releasable.close();, +                        latch.countDown();, +                    }, +, +                    @Override, +                    public void onFailure(Exception e) {, +                        throw new RuntimeException(e);, +                    }, +                },, +                ThreadPool.Names.GENERIC);, +, +        latch.await();, +        assertThat(indexShard.getTranslog().getGeneration().translogFileGeneration, equalTo(currentTranslogGeneration + 1));, +, +        closeShards(indexShard);, +    }, +]