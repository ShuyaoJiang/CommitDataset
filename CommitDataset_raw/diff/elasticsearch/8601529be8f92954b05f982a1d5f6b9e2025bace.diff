[+++ b/src/main/java/org/elasticsearch/cluster/service/InternalClusterService.java, +                        // we got a cluster state with older version, when we are *not* the master, let it in since it might be valid, +                        // we check on version where applicable, like at ZenDiscovery#handleNewClusterStateFromMaster, +                        logger.debug("got smaller cluster state when not master [" + newClusterState.version() + "<" + previousClusterState.version() + "] from source [" + source + "]");, +++ b/src/main/java/org/elasticsearch/cluster/service/InternalClusterService.java, +                        // we got a cluster state with older version, when we are *not* the master, let it in since it might be valid, +                        // we check on version where applicable, like at ZenDiscovery#handleNewClusterStateFromMaster, +                        logger.debug("got smaller cluster state when not master [" + newClusterState.version() + "<" + previousClusterState.version() + "] from source [" + source + "]");, +++ b/src/main/java/org/elasticsearch/discovery/local/LocalDiscovery.java, +import com.google.common.base.Objects;, +                            if (nodeSpecificClusterState.version() < currentState.version() && Objects.equal(nodeSpecificClusterState.nodes().masterNodeId(), currentState.nodes().masterNodeId())) {, +                                return currentState;, +                            }, +, +++ b/src/main/java/org/elasticsearch/cluster/service/InternalClusterService.java, +                        // we got a cluster state with older version, when we are *not* the master, let it in since it might be valid, +                        // we check on version where applicable, like at ZenDiscovery#handleNewClusterStateFromMaster, +                        logger.debug("got smaller cluster state when not master [" + newClusterState.version() + "<" + previousClusterState.version() + "] from source [" + source + "]");, +++ b/src/main/java/org/elasticsearch/discovery/local/LocalDiscovery.java, +import com.google.common.base.Objects;, +                            if (nodeSpecificClusterState.version() < currentState.version() && Objects.equal(nodeSpecificClusterState.nodes().masterNodeId(), currentState.nodes().masterNodeId())) {, +                                return currentState;, +                            }, +, +++ b/src/main/java/org/elasticsearch/discovery/zen/ZenDiscovery.java, +import com.google.common.base.Objects;, +import org.elasticsearch.common.util.concurrent.ConcurrentCollections;, +import java.util.concurrent.BlockingQueue;, +    static class ProcessClusterState {, +        final ClusterState clusterState;, +        final PublishClusterStateAction.NewClusterStateListener.NewStateProcessed newStateProcessed;, +        volatile boolean processed;, +, +        ProcessClusterState(ClusterState clusterState, PublishClusterStateAction.NewClusterStateListener.NewStateProcessed newStateProcessed) {, +            this.clusterState = clusterState;, +            this.newStateProcessed = newStateProcessed;, +        }, +    }, +, +    private final BlockingQueue<ProcessClusterState> processNewClusterStates = ConcurrentCollections.newBlockingQueue();, +, +    void handleNewClusterStateFromMaster(ClusterState newClusterState, final PublishClusterStateAction.NewClusterStateListener.NewStateProcessed newStateProcessed) {, +            final ClusterState newState = newClusterState;, +            if (newClusterState.nodes().localNode() == null) {, +                logger.warn("received a cluster state from [{}] and not part of the cluster, should not happen", newClusterState.nodes().masterNode());, +                final ProcessClusterState processClusterState = new ProcessClusterState(newClusterState, newStateProcessed);, +                processNewClusterStates.add(processClusterState);, +, +                clusterService.submitStateUpdateTask("zen-disco-receive(from master [" + newClusterState.nodes().masterNode() + "])", Priority.URGENT, new ProcessedClusterStateUpdateTask() {, +                        // we already processed it in a previous event, +                        if (processClusterState.processed) {, +                            return currentState;, +                        }, +, +                        // TODO: once improvement that we can do is change the message structure to include version and masterNodeId, +                        // at the start, this will allow us to keep the "compressed bytes" around, and only parse the first page, +                        // to figure out if we need to use it or not, and only once we picked the latest one, parse the whole state, +, +, +                        // try and get the state with the highest version out of all the ones with the same master node id, +                        ProcessClusterState stateToProcess = processNewClusterStates.poll();, +                        if (stateToProcess == null) {, +                            return currentState;, +                        }, +                        stateToProcess.processed = true;, +                        while (true) {, +                            ProcessClusterState potentialState = processNewClusterStates.peek();, +                            // nothing else in the queue, bail, +                            if (potentialState == null) {, +                                break;, +                            }, +                            // if its not from the same master, then bail, +                            if (!Objects.equal(stateToProcess.clusterState.nodes().masterNodeId(), potentialState.clusterState.nodes().masterNodeId())) {, +                                break;, +                            }, +, +                            // we are going to use it for sure, poll (remove) it, +                            potentialState = processNewClusterStates.poll();, +                            potentialState.processed = true;, +, +                            if (potentialState.clusterState.version() > stateToProcess.clusterState.version()) {, +                                // we found a new one, +                                stateToProcess = potentialState;, +                            }, +                        }, +, +                        ClusterState updatedState = stateToProcess.clusterState;, +, +                        // if the new state has a smaller version, and it has the same master node, then no need to process it, +                        if (updatedState.version() < currentState.version() && Objects.equal(updatedState.nodes().masterNodeId(), currentState.nodes().masterNodeId())) {, +                            return currentState;, +                        }, +                        latestDiscoNodes = updatedState.nodes();, +                        ClusterState.Builder builder = ClusterState.builder(updatedState);, +                        if (updatedState.routingTable().version() == currentState.routingTable().version()) {, +                        if (updatedState.metaData().version() == currentState.metaData().version()) {, +                            MetaData.Builder metaDataBuilder = MetaData.builder(updatedState.metaData()).removeAllIndices();, +                            for (IndexMetaData indexMetaData : updatedState.metaData()) {]