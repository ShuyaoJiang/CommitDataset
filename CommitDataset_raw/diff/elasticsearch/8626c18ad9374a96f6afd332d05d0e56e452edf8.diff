[+++ b/src/main/java/org/elasticsearch/common/settings/ImmutableSettings.java, +import com.google.common.base.Predicate;, +import com.google.common.collect.Iterables;, +import java.util.regex.Matcher;, +import java.util.regex.Pattern;, +    private final static Pattern ARRAY_PATTERN = Pattern.compile("(.*)\\.\\d+$");, +            removeNonArraysFieldsIfNewSettingsContainsFieldAsArray(settings.getAsMap());, +            removeNonArraysFieldsIfNewSettingsContainsFieldAsArray(settings);, +         * Removes non array values from the existing map, if settings contains an array value instead, +         *, +         * Example:, +         *   Existing map contains: {key:value}, +         *   New map contains: {key:[value1,value2]} (which has been flattened to {}key.0:value1,key.1:value2}), +         *, +         *   This ensure that that the 'key' field gets removed from the map in order to override all the, +         *   data instead of merging, +         */, +        private void removeNonArraysFieldsIfNewSettingsContainsFieldAsArray(Map<String, String> settings) {, +            List<String> prefixesToRemove = new ArrayList<>();, +            for (final Map.Entry<String, String> entry : settings.entrySet()) {, +                final Matcher matcher = ARRAY_PATTERN.matcher(entry.getKey());, +                if (matcher.matches()) {, +                    prefixesToRemove.add(matcher.group(1));, +                } else if (Iterables.any(map.keySet(), startsWith(entry.getKey() + "."))) {, +                    prefixesToRemove.add(entry.getKey());, +                }, +            }, +            for (String prefix : prefixesToRemove) {, +                Iterator<Map.Entry<String, String>> iterator = map.entrySet().iterator();, +                while (iterator.hasNext()) {, +                    Map.Entry<String, String> entry = iterator.next();, +                    if (entry.getKey().startsWith(prefix + ".") || entry.getKey().equals(prefix)) {, +                        iterator.remove();, +                    }, +                }, +            }, +        }, +, +        /**, +, +    private static StartsWithPredicate startsWith(String prefix) {, +        return new StartsWithPredicate(prefix);, +    }, +, +    private static final class StartsWithPredicate implements Predicate<String> {, +, +        private String prefix;, +, +        public StartsWithPredicate(String prefix) {, +            this.prefix = prefix;, +        }, +, +        @Override, +        public boolean apply(String input) {, +            return input.startsWith(prefix);, +        }, +    }, +++ b/src/main/java/org/elasticsearch/common/settings/ImmutableSettings.java, +import com.google.common.base.Predicate;, +import com.google.common.collect.Iterables;, +import java.util.regex.Matcher;, +import java.util.regex.Pattern;, +    private final static Pattern ARRAY_PATTERN = Pattern.compile("(.*)\\.\\d+$");, +            removeNonArraysFieldsIfNewSettingsContainsFieldAsArray(settings.getAsMap());, +            removeNonArraysFieldsIfNewSettingsContainsFieldAsArray(settings);, +         * Removes non array values from the existing map, if settings contains an array value instead, +         *, +         * Example:, +         *   Existing map contains: {key:value}, +         *   New map contains: {key:[value1,value2]} (which has been flattened to {}key.0:value1,key.1:value2}), +         *, +         *   This ensure that that the 'key' field gets removed from the map in order to override all the, +         *   data instead of merging, +         */, +        private void removeNonArraysFieldsIfNewSettingsContainsFieldAsArray(Map<String, String> settings) {, +            List<String> prefixesToRemove = new ArrayList<>();, +            for (final Map.Entry<String, String> entry : settings.entrySet()) {, +                final Matcher matcher = ARRAY_PATTERN.matcher(entry.getKey());, +                if (matcher.matches()) {, +                    prefixesToRemove.add(matcher.group(1));, +                } else if (Iterables.any(map.keySet(), startsWith(entry.getKey() + "."))) {, +                    prefixesToRemove.add(entry.getKey());, +                }, +            }, +            for (String prefix : prefixesToRemove) {, +                Iterator<Map.Entry<String, String>> iterator = map.entrySet().iterator();, +                while (iterator.hasNext()) {, +                    Map.Entry<String, String> entry = iterator.next();, +                    if (entry.getKey().startsWith(prefix + ".") || entry.getKey().equals(prefix)) {, +                        iterator.remove();, +                    }, +                }, +            }, +        }, +, +        /**, +, +    private static StartsWithPredicate startsWith(String prefix) {, +        return new StartsWithPredicate(prefix);, +    }]