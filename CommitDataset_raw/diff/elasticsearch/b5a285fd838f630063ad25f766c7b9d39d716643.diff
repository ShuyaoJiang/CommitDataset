[+++ b/plugin/src/test/java/org/elasticsearch/xpack/monitoring/exporter/local/LocalExporterTests.java, +import org.apache.lucene.util.SetOnce;, +import org.elasticsearch.action.admin.cluster.state.ClusterStateResponse;, +import org.elasticsearch.action.admin.indices.exists.indices.IndicesExistsResponse;, +import org.elasticsearch.action.admin.indices.get.GetIndexResponse;, +import org.elasticsearch.action.admin.indices.mapping.get.GetMappingsResponse;, +import org.elasticsearch.action.admin.indices.template.get.GetIndexTemplatesResponse;, +import org.elasticsearch.action.index.IndexRequestBuilder;, +import org.elasticsearch.action.ingest.GetPipelineResponse;, +import org.elasticsearch.cluster.metadata.AliasMetaData;, +import org.elasticsearch.cluster.metadata.IndexTemplateMetaData;, +import org.elasticsearch.common.Strings;, +import org.elasticsearch.common.bytes.BytesReference;, +import org.elasticsearch.common.network.NetworkModule;, +import org.elasticsearch.common.xcontent.XContentType;, +import org.elasticsearch.rest.RestStatus;, +import org.elasticsearch.test.RandomObjects;, +import org.elasticsearch.test.TestCluster;, +import org.elasticsearch.xpack.monitoring.action.MonitoringBulkDoc;, +import org.elasticsearch.xpack.monitoring.action.MonitoringBulkRequestBuilder;, +import org.elasticsearch.xpack.monitoring.action.MonitoringIndex;, +import org.joda.time.format.DateTimeFormatter;, +import org.joda.time.format.ISODateTimeFormat;, +import org.junit.AfterClass;, +import java.io.IOException;, +import java.util.HashSet;, +import java.util.Locale;, +import java.util.Set;, +import java.util.stream.Collectors;, +import static org.elasticsearch.xpack.monitoring.MonitoredSystem.BEATS;, +import static org.elasticsearch.xpack.monitoring.MonitoredSystem.KIBANA;, +import static org.elasticsearch.xpack.monitoring.MonitoredSystem.LOGSTASH;, +import static org.elasticsearch.xpack.monitoring.exporter.MonitoringTemplateUtils.DATA_INDEX;, +import static org.hamcrest.Matchers.greaterThan;, +    private static SetOnce<String> indexTimeFormat = new SetOnce<>();, +, +    @Override, +    protected TestCluster buildTestCluster(Scope scope, long seed) throws IOException {, +        String customTimeFormat = null;, +        if (randomBoolean()) {, +            customTimeFormat = randomFrom("YY", "YYYY", "YYYY.MM", "YYYY-MM", "MM.YYYY", "MM");, +        }, +        indexTimeFormat.set(customTimeFormat);, +        return super.buildTestCluster(scope, seed);, +    }, +, +                .put("xpack.monitoring.exporters._local.type", LocalExporter.TYPE), +                .put("xpack.monitoring.exporters._local.enabled", false), +                .put(NetworkModule.HTTP_ENABLED.getKey(), false), +    @AfterClass, +    public static void cleanUp() {, +        indexTimeFormat = null;, +    }, +, +    public void stopMonitoring() throws Exception {, +        Settings.Builder exporterSettings = Settings.builder(), +                .putNull("xpack.monitoring.exporters._local.enabled"), +                .putNull("xpack.monitoring.exporters._local.index.name.time_format"), +                .putNull(MonitoringSettings.INTERVAL.getKey());, +, +        assertAcked(client().admin().cluster().prepareUpdateSettings(), +                .setTransientSettings(exporterSettings));, +, +    public void testExport() throws Exception {, +        if (randomBoolean()) {, +            // indexing some random documents, +            IndexRequestBuilder[] indexRequestBuilders = new IndexRequestBuilder[5];, +            for (int i = 0; i < indexRequestBuilders.length; i++) {, +                indexRequestBuilders[i] = client().prepareIndex("test", "type", Integer.toString(i)), +                        .setSource("title", "This is a random document");, +            indexRandom(true, indexRequestBuilders);, +            // create some marvel indices to check if aliases are correctly created, +            final int oldies = randomIntBetween(1, 20);, +            for (int i = 0; i < oldies; i++) {, +                assertAcked(client().admin().indices().prepareCreate(".marvel-es-1-2014.12." + i), +                        .setSettings("number_of_shards", 1, "number_of_replicas", 0).get());, +, +        if (randomBoolean()) {, +            // create the monitoring data index to check if its mappings are correctly updated, +            createIndex(DATA_INDEX);, +        }, +, +        Settings.Builder exporterSettings = Settings.builder(), +                .put("xpack.monitoring.exporters._local.enabled", true);, +, +        String timeFormat = indexTimeFormat.get();, +        if (timeFormat != null) {, +            exporterSettings.put("xpack.monitoring.exporters._local.index.name.time_format",, +                    timeFormat);, +        }, +, +        // local exporter is now enabled, +        assertAcked(client().admin().cluster().prepareUpdateSettings(), +                .setTransientSettings(exporterSettings));, +, +        if (randomBoolean()) {, +            // export some documents now, before starting the monitoring service, +            final int nbDocs = randomIntBetween(1, 20);, +            List<MonitoringBulkDoc> monitoringDocs = new ArrayList<>(nbDocs);, +            for (int i = 0; i < nbDocs; i++) {]