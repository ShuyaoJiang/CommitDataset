[+++ b/modules/elasticsearch/src/main/java/org/elasticsearch/common/compress/lzf/LZFDecoder.java, +    /**, +     * Method for decompressing a block of input data encoded in LZF, +     * block structure (compatible with lzf command line utility),, +     * and can consist of any number of blocks., +     * Note that input MUST consists of a sequence of one or more complete, +     * chunks; partial chunks can not be handled., +     */, +    public static byte[] decode(final byte[] inputBuffer) throws IOException {, +        byte[] result = new byte[calculateUncompressedSize(inputBuffer, 0, inputBuffer.length)];, +        decode(inputBuffer, 0, inputBuffer.length, result);, +     * Method for decompressing a block of input data encoded in LZF, +     * and can consist of any number of blocks., +     * Note that input MUST consists of a sequence of one or more complete, +     * chunks; partial chunks can not be handled., +     *, +     * @since 0.8.2, +    public static byte[] decode(final byte[] inputBuffer, int inputPtr, int inputLen) throws IOException {, +        byte[] result = new byte[calculateUncompressedSize(inputBuffer, inputPtr, inputLen)];, +        decode(inputBuffer, inputPtr, inputLen, result);, +        return result;, +    }, +    /**, +     * Method for decompressing a block of input data encoded in LZF, +     * block structure (compatible with lzf command line utility),, +     * and can consist of any number of blocks., +     * Note that input MUST consists of a sequence of one or more complete, +     * chunks; partial chunks can not be handled., +     */, +    public static int decode(final byte[] inputBuffer, final byte[] targetBuffer) throws IOException {, +        return decode(inputBuffer, 0, inputBuffer.length, targetBuffer);, +    }, +, +    /**, +     * Method for decompressing a block of input data encoded in LZF, +     * block structure (compatible with lzf command line utility),, +     * and can consist of any number of blocks., +     * Note that input MUST consists of a sequence of one or more complete, +     * chunks; partial chunks can not be handled., +     */, +    public static int decode(final byte[] sourceBuffer, int inPtr, int inLength,, +                             final byte[] targetBuffer) throws IOException {, +        byte[] result = targetBuffer;, +        int outPtr = 0;, +        int blockNr = 0;, +, +        final int end = inPtr + inLength - 1; // -1 to offset possible end marker, +, +        while (inPtr < end) {, +            // let's do basic sanity checks; no point in skimping with these checks, +            if (sourceBuffer[inPtr] != LZFChunk.BYTE_Z || sourceBuffer[inPtr + 1] != LZFChunk.BYTE_V) {, +                throw new IOException("Corrupt input data, block #" + blockNr + " (at offset " + inPtr + "): did not start with 'ZV' signature bytes");, +            }, +            inPtr += 2;, +            ++blockNr;, +    /**, +     * Helper method that will calculate total uncompressed size, for sequence of, +     * one or more LZF blocks stored in given byte array., +     * Will do basic sanity checking, so that this method can be called to, +     * verify against some types of corruption., +     */, +    public static int calculateUncompressedSize(byte[] data, int ptr, int length) throws IOException {, +        final int end = ptr + length;, +        while (ptr < end) {, +                // 11-Aug-2011, tatu: Looks silly, but is faster than simple loop or System.arraycopy, +                switch (ctrl) {, +                    case 31:, +                        out[outPos++] = in[inPos++];, +                    case 30:, +                        out[outPos++] = in[inPos++];, +                    case 29:, +                        out[outPos++] = in[inPos++];, +                    case 28:, +                        out[outPos++] = in[inPos++];, +                    case 27:, +                        out[outPos++] = in[inPos++];, +                    case 26:, +                        out[outPos++] = in[inPos++];, +                    case 25:, +                        out[outPos++] = in[inPos++];, +                    case 24:, +                        out[outPos++] = in[inPos++];, +                    case 23:, +                        out[outPos++] = in[inPos++];, +                    case 22:, +                        out[outPos++] = in[inPos++];, +                    case 21:, +                        out[outPos++] = in[inPos++];, +                    case 20:, +                        out[outPos++] = in[inPos++];, +                    case 19:, +                        out[outPos++] = in[inPos++];, +                    case 18:, +                        out[outPos++] = in[inPos++];, +                    case 17:, +                        out[outPos++] = in[inPos++];, +                    case 16:, +                        out[outPos++] = in[inPos++];, +                    case 15:, +                        out[outPos++] = in[inPos++];]