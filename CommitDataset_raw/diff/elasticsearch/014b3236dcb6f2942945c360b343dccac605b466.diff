[+++ b/server/src/main/java/org/elasticsearch/index/engine/InternalEngine.java, +                        location = translog.add(new Translog.NoOp(indexResult.getSeqNo(), index.primaryTerm(), indexResult.getFailure().toString()));, +                            delete.primaryTerm(), deleteResult.getFailure().toString()));, +++ b/server/src/main/java/org/elasticsearch/index/engine/InternalEngine.java, +                        location = translog.add(new Translog.NoOp(indexResult.getSeqNo(), index.primaryTerm(), indexResult.getFailure().toString()));, +                            delete.primaryTerm(), deleteResult.getFailure().toString()));, +++ b/server/src/test/java/org/elasticsearch/index/replication/IndexLevelReplicationTests.java, +import org.elasticsearch.index.translog.SnapshotMatchers;, +import java.nio.charset.StandardCharsets;, +        final IOException indexException = new IOException("simulated indexing failure");, +        final IOException deleteException = new IOException("simulated deleting failure");, +        final EngineFactory engineFactory = config -> InternalEngineTests.createInternalEngine((dir, iwc) ->, +            new IndexWriter(dir, iwc) {, +                final AtomicBoolean throwAfterIndexedOneDoc = new AtomicBoolean(); // need one document to trigger delete in IW., +                @Override, +                public long addDocument(Iterable<? extends IndexableField> doc) throws IOException {, +                    if (throwAfterIndexedOneDoc.getAndSet(true)) {, +                        throw indexException;, +                    } else {, +                        return super.addDocument(doc);, +                    }, +                }, +                @Override, +                public long deleteDocuments(Term... terms) throws IOException {, +                    throw deleteException;, +                }, +            }, null, null, config);, +            protected EngineFactory getEngineFactory(ShardRouting routing) { return engineFactory; }}) {, +            // start with the primary only so two first failures are replicated to replicas via recovery from the translog of the primary., +            long primaryTerm = shards.getPrimary().getPendingPrimaryTerm();, +            List<Translog.Operation> expectedTranslogOps = new ArrayList<>();, +            BulkItemResponse indexResp = shards.index(new IndexRequest(index.getName(), "type", "1").source("{}", XContentType.JSON));, +            assertThat(indexResp.isFailed(), equalTo(false));, +            expectedTranslogOps.add(new Translog.Index("type", "1", 0, primaryTerm, 1, "{}".getBytes(StandardCharsets.UTF_8), null, -1));, +            try (Translog.Snapshot snapshot = getTranslog(shards.getPrimary()).newSnapshot()) {, +                assertThat(snapshot, SnapshotMatchers.containsOperationsInAnyOrder(expectedTranslogOps));, +            }, +            indexResp = shards.index(new IndexRequest(index.getName(), "type", "any").source("{}", XContentType.JSON));, +            assertThat(indexResp.getFailure().getCause(), equalTo(indexException));, +            expectedTranslogOps.add(new Translog.NoOp(1, primaryTerm, indexException.toString()));, +, +            BulkItemResponse deleteResp = shards.delete(new DeleteRequest(index.getName(), "type", "1"));, +            assertThat(deleteResp.getFailure().getCause(), equalTo(deleteException));, +            expectedTranslogOps.add(new Translog.NoOp(2, primaryTerm, deleteException.toString()));, +            shards.assertAllEqual(1);, +, +            for (IndexShard shard : shards) {, +                try (Translog.Snapshot snapshot = getTranslog(shard).newSnapshot()) {, +                    assertThat(snapshot, SnapshotMatchers.containsOperationsInAnyOrder(expectedTranslogOps));, +                }, +            }, +            // unlike previous failures, these two failures replicated directly from the replication channel., +            indexResp = shards.index(new IndexRequest(index.getName(), "type", "any").source("{}", XContentType.JSON));, +            assertThat(indexResp.getFailure().getCause(), equalTo(indexException));, +            expectedTranslogOps.add(new Translog.NoOp(3, primaryTerm, indexException.toString()));, +, +            deleteResp = shards.delete(new DeleteRequest(index.getName(), "type", "1"));, +            assertThat(deleteResp.getFailure().getCause(), equalTo(deleteException));, +            expectedTranslogOps.add(new Translog.NoOp(4, primaryTerm, deleteException.toString()));, +, +            for (IndexShard shard : shards) {, +                try (Translog.Snapshot snapshot = getTranslog(shard).newSnapshot()) {, +                    assertThat(snapshot, SnapshotMatchers.containsOperationsInAnyOrder(expectedTranslogOps));, +                }, +            }, +            shards.assertAllEqual(1);, +++ b/server/src/main/java/org/elasticsearch/index/engine/InternalEngine.java, +                        location = translog.add(new Translog.NoOp(indexResult.getSeqNo(), index.primaryTerm(), indexResult.getFailure().toString()));, +                            delete.primaryTerm(), deleteResult.getFailure().toString()));, +++ b/server/src/test/java/org/elasticsearch/index/replication/IndexLevelReplicationTests.java, +import org.elasticsearch.index.translog.SnapshotMatchers;, +import java.nio.charset.StandardCharsets;, +        final IOException indexException = new IOException("simulated indexing failure");, +        final IOException deleteException = new IOException("simulated deleting failure");, +        final EngineFactory engineFactory = config -> InternalEngineTests.createInternalEngine((dir, iwc) ->, +            new IndexWriter(dir, iwc) {, +                final AtomicBoolean throwAfterIndexedOneDoc = new AtomicBoolean(); // need one document to trigger delete in IW., +                @Override, +                public long addDocument(Iterable<? extends IndexableField> doc) throws IOException {, +                    if (throwAfterIndexedOneDoc.getAndSet(true)) {, +                        throw indexException;, +                    } else {, +                        return super.addDocument(doc);, +                    }, +                }, +                @Override, +                public long deleteDocuments(Term... terms) throws IOException {, +                    throw deleteException;, +                }, +            }, null, null, config);, +            protected EngineFactory getEngineFactory(ShardRouting routing) { return engineFactory; }}) {, +            // start with the primary only so two first failures are replicated to replicas via recovery from the translog of the primary., +            long primaryTerm = shards.getPrimary().getPendingPrimaryTerm();, +            List<Translog.Operation> expectedTranslogOps = new ArrayList<>();, +            BulkItemResponse indexResp = shards.index(new IndexRequest(index.getName(), "type", "1").source("{}", XContentType.JSON));, +            assertThat(indexResp.isFailed(), equalTo(false));, +            expectedTranslogOps.add(new Translog.Index("type", "1", 0, primaryTerm, 1, "{}".getBytes(StandardCharsets.UTF_8), null, -1));, +            try (Translog.Snapshot snapshot = getTranslog(shards.getPrimary()).newSnapshot()) {, +                assertThat(snapshot, SnapshotMatchers.containsOperationsInAnyOrder(expectedTranslogOps));, +            }]