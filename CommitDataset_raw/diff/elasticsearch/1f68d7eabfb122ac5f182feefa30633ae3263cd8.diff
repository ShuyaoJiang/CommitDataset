[+++ b/modules/elasticsearch/src/main/java/org/elasticsearch/action/index/TransportIndexAction.java, +import java.util.concurrent.CountDownLatch;, +import java.util.concurrent.TimeUnit;, +    private final boolean waitForMappingChange;, +, +        this.waitForMappingChange = settings.getAsBoolean("action.wait_on_mapping_change", true);, +        final CountDownLatch latch = new CountDownLatch(1);, +                    latch.countDown();, +                    latch.countDown();, +            latch.countDown();, +, +        if (waitForMappingChange) {, +            try {, +                latch.await(5, TimeUnit.SECONDS);, +            } catch (InterruptedException e) {, +                // ignore, +            }, +        }, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/action/index/TransportIndexAction.java, +import java.util.concurrent.CountDownLatch;, +import java.util.concurrent.TimeUnit;, +    private final boolean waitForMappingChange;, +, +        this.waitForMappingChange = settings.getAsBoolean("action.wait_on_mapping_change", true);, +        final CountDownLatch latch = new CountDownLatch(1);, +                    latch.countDown();, +                    latch.countDown();, +            latch.countDown();, +, +        if (waitForMappingChange) {, +            try {, +                latch.await(5, TimeUnit.SECONDS);, +            } catch (InterruptedException e) {, +                // ignore, +            }, +        }, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/cluster/action/index/MappingUpdatedAction.java, +import java.util.concurrent.CountDownLatch;, +import java.util.concurrent.atomic.AtomicReference;, +        final CountDownLatch latch = new CountDownLatch(1);, +        final AtomicReference<Throwable> failure = new AtomicReference<Throwable>();, +            metaDataMappingService.updateMapping(request.index(), request.type(), request.mappingSource(), new MetaDataMappingService.Listener() {, +                @Override public void onResponse(MetaDataMappingService.Response response) {, +                    latch.countDown();, +                }, +, +                @Override public void onFailure(Throwable t) {, +                    failure.set(t);, +                    latch.countDown();, +                }, +            });, +            failure.set(e);, +        }, +        if (failure.get() != null) {, +            if (failure.get() instanceof ElasticSearchException) {, +                throw (ElasticSearchException) failure.get();, +            } else {, +                throw new ElasticSearchException("failed to update mapping", failure.get());, +            }, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/action/index/TransportIndexAction.java, +import java.util.concurrent.CountDownLatch;, +import java.util.concurrent.TimeUnit;, +    private final boolean waitForMappingChange;, +, +        this.waitForMappingChange = settings.getAsBoolean("action.wait_on_mapping_change", true);, +        final CountDownLatch latch = new CountDownLatch(1);, +                    latch.countDown();, +                    latch.countDown();, +            latch.countDown();, +, +        if (waitForMappingChange) {, +            try {, +                latch.await(5, TimeUnit.SECONDS);, +            } catch (InterruptedException e) {, +                // ignore, +            }, +        }, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/cluster/action/index/MappingUpdatedAction.java, +import java.util.concurrent.CountDownLatch;, +import java.util.concurrent.atomic.AtomicReference;, +        final CountDownLatch latch = new CountDownLatch(1);, +        final AtomicReference<Throwable> failure = new AtomicReference<Throwable>();, +            metaDataMappingService.updateMapping(request.index(), request.type(), request.mappingSource(), new MetaDataMappingService.Listener() {, +                @Override public void onResponse(MetaDataMappingService.Response response) {, +                    latch.countDown();, +                }, +, +                @Override public void onFailure(Throwable t) {, +                    failure.set(t);, +                    latch.countDown();, +                }, +            });, +            failure.set(e);, +        }, +        if (failure.get() != null) {, +            if (failure.get() instanceof ElasticSearchException) {, +                throw (ElasticSearchException) failure.get();, +            } else {, +                throw new ElasticSearchException("failed to update mapping", failure.get());, +            }]