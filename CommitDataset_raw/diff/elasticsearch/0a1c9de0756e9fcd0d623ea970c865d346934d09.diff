[+++ b/core/src/main/java/org/elasticsearch/action/admin/cluster/health/TransportClusterHealthAction.java, +                    numberOfPendingTasks, numberOfInFlightFetch, UnassignedInfo.getNumberOfDelayedUnassigned(System.currentTimeMillis(), settings, clusterState),, +                numberOfInFlightFetch, UnassignedInfo.getNumberOfDelayedUnassigned(System.currentTimeMillis(), settings, clusterState), pendingTaskTimeInQueue);, +++ b/core/src/main/java/org/elasticsearch/action/admin/cluster/health/TransportClusterHealthAction.java, +                    numberOfPendingTasks, numberOfInFlightFetch, UnassignedInfo.getNumberOfDelayedUnassigned(System.currentTimeMillis(), settings, clusterState),, +                numberOfInFlightFetch, UnassignedInfo.getNumberOfDelayedUnassigned(System.currentTimeMillis(), settings, clusterState), pendingTaskTimeInQueue);, +++ b/core/src/main/java/org/elasticsearch/cluster/routing/RoutingService.java, +    private volatile long unassignedShardsAllocatedTimestamp = 0;, +     * Update the last time the allocator tried to assign unassigned shards, +     *, +     * This is used so that both the GatewayAllocator and RoutingService use a, +     * consistent timestamp for comparing which shards have been delayed to, +     * avoid a race condition where GatewayAllocator thinks the shard should, +     * be delayed and the RoutingService thinks it has already passed the delay, +     * and that the GatewayAllocator has/will handle it., +     */, +    public void setUnassignedShardsAllocatedTimestamp(long timeInMillis) {, +        this.unassignedShardsAllocatedTimestamp = timeInMillis;, +    }, +, +    /**, +                // We use System.currentTimeMillis here because we want the, +                // next delay from the "now" perspective, rather than the, +                // delay from the last time the GatewayAllocator tried to, +                // assign/delay the shard, +                TimeValue nextDelay = TimeValue.timeValueMillis(UnassignedInfo.findNextDelayedAllocationIn(System.currentTimeMillis(), settings, event.state()));, +                int unassignedDelayedShards = UnassignedInfo.getNumberOfDelayedUnassigned(unassignedShardsAllocatedTimestamp, settings, event.state());, +                if (unassignedDelayedShards > 0) {, +                    logger.info("delaying allocation for [{}] unassigned shards, next check in [{}]",, +                            unassignedDelayedShards, nextDelay);, +                            registeredNextDelaySetting = Long.MAX_VALUE;, +                }, +++ b/core/src/main/java/org/elasticsearch/action/admin/cluster/health/TransportClusterHealthAction.java, +                    numberOfPendingTasks, numberOfInFlightFetch, UnassignedInfo.getNumberOfDelayedUnassigned(System.currentTimeMillis(), settings, clusterState),, +                numberOfInFlightFetch, UnassignedInfo.getNumberOfDelayedUnassigned(System.currentTimeMillis(), settings, clusterState), pendingTaskTimeInQueue);, +++ b/core/src/main/java/org/elasticsearch/cluster/routing/RoutingService.java, +    private volatile long unassignedShardsAllocatedTimestamp = 0;, +     * Update the last time the allocator tried to assign unassigned shards, +     *, +     * This is used so that both the GatewayAllocator and RoutingService use a, +     * consistent timestamp for comparing which shards have been delayed to, +     * avoid a race condition where GatewayAllocator thinks the shard should, +     * be delayed and the RoutingService thinks it has already passed the delay, +     * and that the GatewayAllocator has/will handle it., +     */, +    public void setUnassignedShardsAllocatedTimestamp(long timeInMillis) {, +        this.unassignedShardsAllocatedTimestamp = timeInMillis;, +    }, +, +    /**, +                // We use System.currentTimeMillis here because we want the, +                // next delay from the "now" perspective, rather than the, +                // delay from the last time the GatewayAllocator tried to, +                // assign/delay the shard, +                TimeValue nextDelay = TimeValue.timeValueMillis(UnassignedInfo.findNextDelayedAllocationIn(System.currentTimeMillis(), settings, event.state()));, +                int unassignedDelayedShards = UnassignedInfo.getNumberOfDelayedUnassigned(unassignedShardsAllocatedTimestamp, settings, event.state());, +                if (unassignedDelayedShards > 0) {, +                    logger.info("delaying allocation for [{}] unassigned shards, next check in [{}]",, +                            unassignedDelayedShards, nextDelay);, +                            registeredNextDelaySetting = Long.MAX_VALUE;, +                }, +++ b/core/src/main/java/org/elasticsearch/cluster/routing/UnassignedInfo.java, +    public long getDelayAllocationExpirationIn(long unassignedShardsAllocatedTimestamp, Settings settings, Settings indexSettings) {, +        long delta = unassignedShardsAllocatedTimestamp - timestamp;, +    public static int getNumberOfDelayedUnassigned(long unassignedShardsAllocatedTimestamp, Settings settings, ClusterState state) {, +                long delay = shard.unassignedInfo().getDelayAllocationExpirationIn(unassignedShardsAllocatedTimestamp, settings, indexMetaData.getSettings());, +    public static long findNextDelayedAllocationIn(long unassignedShardsAllocatedTimestamp, Settings settings, ClusterState state) {, +                long nextShardDelay = shard.unassignedInfo().getDelayAllocationExpirationIn(unassignedShardsAllocatedTimestamp, settings, indexMetaData.getSettings());, +++ b/core/src/main/java/org/elasticsearch/action/admin/cluster/health/TransportClusterHealthAction.java, +                    numberOfPendingTasks, numberOfInFlightFetch, UnassignedInfo.getNumberOfDelayedUnassigned(System.currentTimeMillis(), settings, clusterState),, +                numberOfInFlightFetch, UnassignedInfo.getNumberOfDelayedUnassigned(System.currentTimeMillis(), settings, clusterState), pendingTaskTimeInQueue);, +++ b/core/src/main/java/org/elasticsearch/cluster/routing/RoutingService.java, +    private volatile long unassignedShardsAllocatedTimestamp = 0;, +     * Update the last time the allocator tried to assign unassigned shards, +     *, +     * This is used so that both the GatewayAllocator and RoutingService use a, +     * consistent timestamp for comparing which shards have been delayed to, +     * avoid a race condition where GatewayAllocator thinks the shard should, +     * be delayed and the RoutingService thinks it has already passed the delay, +     * and that the GatewayAllocator has/will handle it., +     */, +    public void setUnassignedShardsAllocatedTimestamp(long timeInMillis) {, +        this.unassignedShardsAllocatedTimestamp = timeInMillis;, +    }, +, +    /**, +                // We use System.currentTimeMillis here because we want the, +                // next delay from the "now" perspective, rather than the, +                // delay from the last time the GatewayAllocator tried to, +                // assign/delay the shard, +                TimeValue nextDelay = TimeValue.timeValueMillis(UnassignedInfo.findNextDelayedAllocationIn(System.currentTimeMillis(), settings, event.state()));, +                int unassignedDelayedShards = UnassignedInfo.getNumberOfDelayedUnassigned(unassignedShardsAllocatedTimestamp, settings, event.state());, +                if (unassignedDelayedShards > 0) {, +                    logger.info("delaying allocation for [{}] unassigned shards, next check in [{}]",, +                            unassignedDelayedShards, nextDelay);, +                            registeredNextDelaySetting = Long.MAX_VALUE;, +                }, +++ b/core/src/main/java/org/elasticsearch/cluster/routing/UnassignedInfo.java, +    public long getDelayAllocationExpirationIn(long unassignedShardsAllocatedTimestamp, Settings settings, Settings indexSettings) {, +        long delta = unassignedShardsAllocatedTimestamp - timestamp;]