[+++ b/core/src/test/java/org/elasticsearch/discovery/DiscoveryWithServiceDisruptionsIT.java, +        SingleNodeDisruption masterNodeDisruption = new IntermittentLongGCDisruption(random(), oldMasterNode, 100, 200, 30000, 60000);, +++ b/core/src/test/java/org/elasticsearch/discovery/DiscoveryWithServiceDisruptionsIT.java, +        SingleNodeDisruption masterNodeDisruption = new IntermittentLongGCDisruption(random(), oldMasterNode, 100, 200, 30000, 60000);, +++ b/test/framework/src/main/java/org/elasticsearch/test/disruption/IntermittentLongGCDisruption.java, +        logger.info("node [{}] goes into GC for for [{}]", disruptedNode, duration);, +            while (stopNodeThreads(nodeThreads)) ;, +            logger.info("node [{}] resumes from GC", disruptedNode);, +            while (disrupting) {, +                    if (disrupting) {, +++ b/core/src/test/java/org/elasticsearch/discovery/DiscoveryWithServiceDisruptionsIT.java, +        SingleNodeDisruption masterNodeDisruption = new IntermittentLongGCDisruption(random(), oldMasterNode, 100, 200, 30000, 60000);, +++ b/test/framework/src/main/java/org/elasticsearch/test/disruption/IntermittentLongGCDisruption.java, +        logger.info("node [{}] goes into GC for for [{}]", disruptedNode, duration);, +            while (stopNodeThreads(nodeThreads)) ;, +            logger.info("node [{}] resumes from GC", disruptedNode);, +            while (disrupting) {, +                    if (disrupting) {, +++ b/test/framework/src/main/java/org/elasticsearch/test/disruption/LongGCDisruption.java, +import org.elasticsearch.common.Nullable;, +import java.lang.management.ManagementFactory;, +import java.lang.management.ThreadInfo;, +import java.lang.management.ThreadMXBean;, +        Pattern.compile("java\\.lang\\.SecurityManager"),, +        // SecureRandom instance from SecureRandomHolder class is shared by all nodes, +        Pattern.compile("java\\.security\\.SecureRandom"), +    private static final ThreadMXBean threadBean = ManagementFactory.getThreadMXBean();, +, +    private Thread blockDetectionThread;, +                assert isDisruptedNodeThread(currentThreadName) == false :, +                        while (stopNodeThreads(suspendedThreads)) {, +                        , disruptedNode, getStoppingTimeoutInMillis(), stackTrace(stoppingThread.getStackTrace()));, +                // block detection checks if other threads are blocked waiting on an object that is held by one, +                // of the threads that was suspended, +                if (isBlockDetectionSupported()) {, +                    blockDetectionThread = new Thread(new AbstractRunnable() {, +                        @Override, +                        public void onFailure(Exception e) {, +                            if (e instanceof InterruptedException == false) {, +                                throw new AssertionError("unexpected exception in blockDetectionThread", e);, +                            }, +                        }, +, +                        @Override, +                        protected void doRun() throws Exception {, +                            while (Thread.currentThread().isInterrupted() == false) {, +                                ThreadInfo[] threadInfos = threadBean.dumpAllThreads(true, true);, +                                for (ThreadInfo threadInfo : threadInfos) {, +                                    if (isDisruptedNodeThread(threadInfo.getThreadName()) == false &&, +                                        threadInfo.getLockOwnerName() != null &&, +                                        isDisruptedNodeThread(threadInfo.getLockOwnerName())) {, +, +                                        // find ThreadInfo object of the blocking thread (if available), +                                        ThreadInfo blockingThreadInfo = null;, +                                        for (ThreadInfo otherThreadInfo : threadInfos) {, +                                            if (otherThreadInfo.getThreadId() == threadInfo.getLockOwnerId()) {, +                                                blockingThreadInfo = otherThreadInfo;, +                                                break;, +                                            }, +                                        }, +                                        onBlockDetected(threadInfo, blockingThreadInfo);, +                                    }, +                                }, +                                Thread.sleep(getBlockDetectionIntervalInMillis());, +                            }, +                        }, +                    });, +                    blockDetectionThread.setName(currentThreadName + "[LongGCDisruption][blockDetection]");, +                    blockDetectionThread.start();, +                }, +                    stopBlockDetection();, +    public boolean isDisruptedNodeThread(String threadName) {, +        return threadName.contains("[" + disruptedNode + "]");, +    }, +, +    private String stackTrace(StackTraceElement[] stackTraceElements) {, +        return Arrays.stream(stackTraceElements).map(Object::toString).collect(Collectors.joining("\n"));, +        stopBlockDetection();, +    private void stopBlockDetection() {, +        if (blockDetectionThread != null) {, +            try {, +                blockDetectionThread.interrupt(); // best effort, +                blockDetectionThread.join(getStoppingTimeoutInMillis());, +            } catch (InterruptedException e) {, +                throw new RuntimeException(e);, +            }, +            blockDetectionThread = null;, +        }, +    }, +, +    protected boolean stopNodeThreads(Set<Thread> nodeThreads) {, +            String threadName = thread.getName();, +            if (isDisruptedNodeThread(threadName)) {, +                    logger.trace("stopping thread [{}]", threadName);, +                        logger.trace("resuming thread [{}] as it is in a critical section", threadName);, +    public boolean isBlockDetectionSupported() {, +        return threadBean.isObjectMonitorUsageSupported() && threadBean.isSynchronizerUsageSupported();, +    }, +, +    // for testing]