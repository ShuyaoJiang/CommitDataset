[+++ b/src/main/java/org/elasticsearch/index/fielddata/IndexFieldDataService.java, +                .put("float", new FloatArrayIndexFieldData.Builder()), +                .put("int", new IntArrayIndexFieldData.Builder()), +                .put(Tuple.tuple("float", "array"), new FloatArrayIndexFieldData.Builder()), +                .put(Tuple.tuple("int", "array"), new IntArrayIndexFieldData.Builder()), +++ b/src/main/java/org/elasticsearch/index/fielddata/IndexFieldDataService.java, +                .put("float", new FloatArrayIndexFieldData.Builder()), +                .put("int", new IntArrayIndexFieldData.Builder()), +                .put(Tuple.tuple("float", "array"), new FloatArrayIndexFieldData.Builder()), +                .put(Tuple.tuple("int", "array"), new IntArrayIndexFieldData.Builder()), +++ b/src/main/java/org/elasticsearch/index/fielddata/StringValues.java, +import org.elasticsearch.index.fielddata.util.FloatArrayRef;, +import org.elasticsearch.index.fielddata.util.IntArrayRef;, +    public static class IntBased implements StringValues {, +, +        private final IntValues values;, +, +        private final StringArrayRef arrayScratch = new StringArrayRef(new String[1], 1);, +        private final ValuesIter valuesIter = new ValuesIter();, +        private final Proc proc = new Proc();, +, +        public IntBased(IntValues values) {, +            this.values = values;, +        }, +, +        @Override, +        public boolean isMultiValued() {, +            return values.isMultiValued();, +        }, +, +        @Override, +        public boolean hasValue(int docId) {, +            return values.hasValue(docId);, +        }, +, +        @Override, +        public String getValue(int docId) {, +            if (!values.hasValue(docId)) {, +                return null;, +            }, +            return Integer.toString(values.getValue(docId));, +        }, +, +        @Override, +        public StringArrayRef getValues(int docId) {, +            IntArrayRef arrayRef = values.getValues(docId);, +            int size = arrayRef.size();, +            if (size == 0) return StringArrayRef.EMPTY;, +, +            arrayScratch.reset(size);, +            for (int i = arrayRef.start; i < arrayRef.end; i++) {, +                arrayScratch.values[arrayScratch.end++] = Integer.toString(arrayRef.values[i]);, +            }, +            return arrayScratch;, +        }, +, +        @Override, +        public Iter getIter(int docId) {, +            return valuesIter.reset(values.getIter(docId));, +        }, +, +        @Override, +        public void forEachValueInDoc(int docId, ValueInDocProc proc) {, +            values.forEachValueInDoc(docId, this.proc.reset(proc));, +        }, +, +        static class ValuesIter implements Iter {, +, +            private IntValues.Iter iter;, +, +            private ValuesIter reset(IntValues.Iter iter) {, +                this.iter = iter;, +                return this;, +            }, +, +            @Override, +            public boolean hasNext() {, +                return iter.hasNext();, +            }, +, +            @Override, +            public String next() {, +                return Integer.toString(iter.next());, +            }, +        }, +, +        static class Proc implements IntValues.ValueInDocProc {, +, +            private ValueInDocProc proc;, +, +            private Proc reset(ValueInDocProc proc) {, +                this.proc = proc;, +                return this;, +            }, +, +            @Override, +            public void onValue(int docId, int value) {, +                proc.onValue(docId, Integer.toString(value));, +            }, +]