[+++ b/core/src/main/java/org/elasticsearch/common/lucene/uid/PerThreadIDVersionAndSeqNoLookup.java, + *  finds., + *  This class uses live docs, so it should be cached based on the, + *  {@link org.apache.lucene.index.IndexReader#getReaderCacheHelper() reader cache helper}, + *  rather than the {@link LeafReader#getCoreCacheHelper() core cache helper}., + */, +    /** The {@link LeafReaderContext} that needs to be looked up. */, +    private final LeafReaderContext context;, +    /** Live docs of the context, cached to avoid the cost of ensureOpen() on every, +     *  segment for every index operation. */, +    private final Bits liveDocs;, +, +    PerThreadIDVersionAndSeqNoLookup(LeafReaderContext context, String uidField) throws IOException {, +        this.context = context;, +        final LeafReader reader = context.reader();, +        this.liveDocs = reader.getLiveDocs();, +    public DocIdAndVersion lookupVersion(BytesRef id), +        int docID = getDocID(id);, +    private int getDocID(BytesRef id) throws IOException {, +    DocIdAndSeqNo lookupSeqNo(BytesRef id) throws IOException {, +        int docID = getDocID(id);, +++ b/core/src/main/java/org/elasticsearch/common/lucene/uid/PerThreadIDVersionAndSeqNoLookup.java, + *  finds., + *  This class uses live docs, so it should be cached based on the, + *  {@link org.apache.lucene.index.IndexReader#getReaderCacheHelper() reader cache helper}, + *  rather than the {@link LeafReader#getCoreCacheHelper() core cache helper}., + */, +    /** The {@link LeafReaderContext} that needs to be looked up. */, +    private final LeafReaderContext context;, +    /** Live docs of the context, cached to avoid the cost of ensureOpen() on every, +     *  segment for every index operation. */, +    private final Bits liveDocs;, +, +    PerThreadIDVersionAndSeqNoLookup(LeafReaderContext context, String uidField) throws IOException {, +        this.context = context;, +        final LeafReader reader = context.reader();, +        this.liveDocs = reader.getLiveDocs();, +    public DocIdAndVersion lookupVersion(BytesRef id), +        int docID = getDocID(id);, +    private int getDocID(BytesRef id) throws IOException {, +    DocIdAndSeqNo lookupSeqNo(BytesRef id) throws IOException {, +        int docID = getDocID(id);, +++ b/core/src/main/java/org/elasticsearch/common/lucene/uid/VersionsAndSeqNoResolver.java, +import org.apache.lucene.index.NumericDocValues;, +import org.elasticsearch.index.mapper.SeqNoFieldMapper;, +    static final ConcurrentMap<IndexReader.CacheKey, CloseableThreadLocal<PerThreadIDVersionAndSeqNoLookup[]>> lookupStates =, +        CloseableThreadLocal<PerThreadIDVersionAndSeqNoLookup[]> ctl = lookupStates.remove(key);, +    private static PerThreadIDVersionAndSeqNoLookup[] getLookupState(IndexReader reader, String uidField) throws IOException {, +        // We cache on the top level, +        // This means cache entries have a shorter lifetime, maybe as low as 1s with the, +        // default refresh interval and a steady indexing rate, but on the other hand it, +        // proved to be cheaper than having to perform a CHM and a TL get for every segment., +        // See https://github.com/elastic/elasticsearch/pull/19856., +        IndexReader.CacheHelper cacheHelper = reader.getReaderCacheHelper();, +        CloseableThreadLocal<PerThreadIDVersionAndSeqNoLookup[]> ctl = lookupStates.get(cacheHelper.getKey());, +            CloseableThreadLocal<PerThreadIDVersionAndSeqNoLookup[]> other = lookupStates.putIfAbsent(cacheHelper.getKey(), ctl);, +                // Our CTL won, we must remove it when the reader is closed:, +        PerThreadIDVersionAndSeqNoLookup[] lookupState = ctl.get();, +            lookupState = new PerThreadIDVersionAndSeqNoLookup[reader.leaves().size()];, +            for (LeafReaderContext leaf : reader.leaves()) {, +                lookupState[leaf.ord] = new PerThreadIDVersionAndSeqNoLookup(leaf, uidField);, +            }, +        }, +, +        if (lookupState.length != reader.leaves().size()) {, +            throw new AssertionError("Mismatched numbers of leaves: " + lookupState.length + " != " + reader.leaves().size());, +        }, +, +        if (lookupState.length > 0 && Objects.equals(lookupState[0].uidField, uidField) == false) {, +                    + uidField + "] != [" + lookupState[0].uidField + "]");, +        PerThreadIDVersionAndSeqNoLookup[] lookups = getLookupState(reader, term.field());, +            PerThreadIDVersionAndSeqNoLookup lookup = lookups[leaves.get(i).ord];, +            DocIdAndVersion result = lookup.lookupVersion(term.bytes());, +        PerThreadIDVersionAndSeqNoLookup[] lookups = getLookupState(reader, term.field());, +            PerThreadIDVersionAndSeqNoLookup lookup = lookups[leaves.get(i).ord];, +            DocIdAndSeqNo result = lookup.lookupSeqNo(term.bytes());, +        NumericDocValues primaryTerms = docIdAndSeqNo.context.reader().getNumericDocValues(SeqNoFieldMapper.PRIMARY_TERM_NAME);, +        long result;, +        if (primaryTerms != null && primaryTerms.advanceExact(docIdAndSeqNo.docId)) {, +            result = primaryTerms.longValue();, +        } else {, +            result = 0;, +        }, +++ b/core/src/main/java/org/elasticsearch/common/lucene/uid/PerThreadIDVersionAndSeqNoLookup.java, + *  finds., + *  This class uses live docs, so it should be cached based on the, + *  {@link org.apache.lucene.index.IndexReader#getReaderCacheHelper() reader cache helper}, + *  rather than the {@link LeafReader#getCoreCacheHelper() core cache helper}., + */, +    /** The {@link LeafReaderContext} that needs to be looked up. */, +    private final LeafReaderContext context;, +    /** Live docs of the context, cached to avoid the cost of ensureOpen() on every, +     *  segment for every index operation. */, +    private final Bits liveDocs;, +, +    PerThreadIDVersionAndSeqNoLookup(LeafReaderContext context, String uidField) throws IOException {, +        this.context = context;, +        final LeafReader reader = context.reader();, +        this.liveDocs = reader.getLiveDocs();, +    public DocIdAndVersion lookupVersion(BytesRef id)]