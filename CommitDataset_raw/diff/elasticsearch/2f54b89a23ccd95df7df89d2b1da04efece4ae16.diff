[+++ b/core/src/main/java/org/elasticsearch/action/bulk/BulkRequest.java, +++ b/core/src/main/java/org/elasticsearch/action/bulk/BulkRequest.java, +++ b/core/src/main/java/org/elasticsearch/action/support/single/instance/InstanceShardOperationRequest.java, +    private String concreteIndex;, +, +    public String concreteIndex() {, +        return concreteIndex;, +    }, +, +    void concreteIndex(String concreteIndex) {, +        this.concreteIndex = concreteIndex;, +    }, +, +        concreteIndex = in.readOptionalString();, +        out.writeOptionalString(concreteIndex);, +++ b/core/src/main/java/org/elasticsearch/action/bulk/BulkRequest.java, +++ b/core/src/main/java/org/elasticsearch/action/support/single/instance/InstanceShardOperationRequest.java, +    private String concreteIndex;, +, +    public String concreteIndex() {, +        return concreteIndex;, +    }, +, +    void concreteIndex(String concreteIndex) {, +        this.concreteIndex = concreteIndex;, +    }, +, +        concreteIndex = in.readOptionalString();, +        out.writeOptionalString(concreteIndex);, +++ b/core/src/main/java/org/elasticsearch/action/support/single/instance/TransportInstanceSingleOperationAction.java, +    final String shardActionName;, +        this.shardActionName = actionName + "[s]";, +        transportService.registerRequestHandler(shardActionName, request, executor, new ShardTransportHandler());, +    protected abstract void shardOperation(Request request, ActionListener<Response> listener);, +    protected ClusterBlockException checkRequestBlock(ClusterState state, Request request) {, +    protected abstract boolean resolveRequest(ClusterState state, Request request, ActionListener<Response> listener);, +    protected abstract ShardIterator shards(ClusterState clusterState, Request request);, +        private final Request request;, +            this.request = request;, +            this.observer = new ClusterStateObserver(clusterService, request.timeout(), logger);, +                request.concreteIndex(indexNameExpressionResolver.concreteSingleIndex(observer.observedState(), request));, +                if (!resolveRequest(observer.observedState(), request, listener)) {, +                blockException = checkRequestBlock(observer.observedState(), request);, +                shardIt = shards(observer.observedState(), request);, +            request.shardId = shardIt.shardId().id();, +            transportService.sendRequest(node, shardActionName, request, transportOptions(), new BaseTransportResponseHandler<Response>() {, +                                listenFailure = new UnavailableShardsException(new ShardId(request.concreteIndex(), -1), "Timeout waiting for [" + timeout + "], request: " + request.toString());, +                                listenFailure = new UnavailableShardsException(shardIt.shardId(), "[" + shardIt.size() + "] shardIt, [" + shardIt.sizeActive() + "] active : Timeout waiting for [" + timeout + "], request: " + request.toString());, +            }, request.timeout());, +    private class ShardTransportHandler implements TransportRequestHandler<Request> {, +        @Override, +        public void messageReceived(final Request request, final TransportChannel channel) throws Exception {, +            shardOperation(request, new ActionListener<Response>() {, +                @Override, +                public void onResponse(Response response) {, +                    try {, +                        channel.sendResponse(response);, +                    } catch (Throwable e) {, +                        onFailure(e);, +                    }, +                @Override, +                public void onFailure(Throwable e) {, +                    try {, +                        channel.sendResponse(e);, +                    } catch (Exception e1) {, +                        logger.warn("failed to send response for get", e1);, +            });, +++ b/core/src/main/java/org/elasticsearch/action/bulk/BulkRequest.java, +++ b/core/src/main/java/org/elasticsearch/action/support/single/instance/InstanceShardOperationRequest.java, +    private String concreteIndex;, +, +    public String concreteIndex() {, +        return concreteIndex;, +    }, +, +    void concreteIndex(String concreteIndex) {, +        this.concreteIndex = concreteIndex;, +    }, +, +        concreteIndex = in.readOptionalString();, +        out.writeOptionalString(concreteIndex);, +++ b/core/src/main/java/org/elasticsearch/action/support/single/instance/TransportInstanceSingleOperationAction.java, +    final String shardActionName;, +        this.shardActionName = actionName + "[s]";, +        transportService.registerRequestHandler(shardActionName, request, executor, new ShardTransportHandler());, +    protected abstract void shardOperation(Request request, ActionListener<Response> listener);, +    protected ClusterBlockException checkRequestBlock(ClusterState state, Request request) {, +    protected abstract boolean resolveRequest(ClusterState state, Request request, ActionListener<Response> listener);, +    protected abstract ShardIterator shards(ClusterState clusterState, Request request);, +        private final Request request;, +            this.request = request;, +            this.observer = new ClusterStateObserver(clusterService, request.timeout(), logger);, +                request.concreteIndex(indexNameExpressionResolver.concreteSingleIndex(observer.observedState(), request));, +                if (!resolveRequest(observer.observedState(), request, listener)) {, +                blockException = checkRequestBlock(observer.observedState(), request);, +                shardIt = shards(observer.observedState(), request);, +            request.shardId = shardIt.shardId().id();, +            transportService.sendRequest(node, shardActionName, request, transportOptions(), new BaseTransportResponseHandler<Response>() {, +                                listenFailure = new UnavailableShardsException(new ShardId(request.concreteIndex(), -1), "Timeout waiting for [" + timeout + "], request: " + request.toString());, +                                listenFailure = new UnavailableShardsException(shardIt.shardId(), "[" + shardIt.size() + "] shardIt, [" + shardIt.sizeActive() + "] active : Timeout waiting for [" + timeout + "], request: " + request.toString());]