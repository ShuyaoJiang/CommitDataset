[+++ b/server/src/main/java/org/elasticsearch/cluster/action/shard/ShardStateAction.java, +    public void shardStarted(final ShardRouting shardRouting,, +                             final long primaryTerm,, +                             final String message,, +                             final Listener listener) {, +        shardStarted(shardRouting, primaryTerm, message, listener, clusterService.state());, +, +    public void shardStarted(final ShardRouting shardRouting,, +                             final long primaryTerm,, +                             final String message,, +                             final Listener listener,, +                             final ClusterState currentState) {, +        StartedShardEntry entry = new StartedShardEntry(shardRouting.shardId(), shardRouting.allocationId().getId(), primaryTerm, message);, +        sendShardAction(SHARD_STARTED_ACTION_NAME, currentState, entry, listener);, +                final ShardRouting matched = currentState.getRoutingTable().getByAllocationId(task.shardId, task.allocationId);, +                    if (matched.primary() && task.primaryTerm > 0) {, +                        final IndexMetaData indexMetaData = currentState.metaData().index(task.shardId.getIndex());, +                        assert indexMetaData != null;, +                        final long currentPrimaryTerm = indexMetaData.primaryTerm(task.shardId.id());, +                        if (currentPrimaryTerm != task.primaryTerm) {, +                            assert currentPrimaryTerm > task.primaryTerm : "received a primary term with a higher term than in the " +, +                                "current cluster state (received [" + task.primaryTerm + "] but current is [" + currentPrimaryTerm + "])";, +                            logger.debug("{} ignoring shard started task [{}] (primary term {} does not match current term {})",, +                                task.shardId, task, task.primaryTerm, currentPrimaryTerm);, +                            builder.success(task);, +                            continue;, +                        }, +                    }, +        final long primaryTerm;, +                primaryTerm = in.readVLong();, +            } else if (in.getVersion().onOrAfter(Version.V_7_0_0)) {  // TODO update version to 6.7.0 after backport, +                primaryTerm = in.readVLong();, +            } else {, +                primaryTerm = UNASSIGNED_PRIMARY_TERM;, +        public StartedShardEntry(final ShardId shardId, final String allocationId, final long primaryTerm, final String message) {, +            this.primaryTerm = primaryTerm;, +            } else if (out.getVersion().onOrAfter(Version.V_7_0_0)) {  // TODO update version to 6.7.0 after backport, +                out.writeVLong(primaryTerm);, +            return String.format(Locale.ROOT,  "StartedShardEntry{shardId [%s], allocationId [%s], primary term [%d], message [%s]}",, +                shardId, allocationId, primaryTerm, message);, +++ b/server/src/main/java/org/elasticsearch/cluster/action/shard/ShardStateAction.java, +    public void shardStarted(final ShardRouting shardRouting,, +                             final long primaryTerm,, +                             final String message,, +                             final Listener listener) {, +        shardStarted(shardRouting, primaryTerm, message, listener, clusterService.state());, +, +    public void shardStarted(final ShardRouting shardRouting,, +                             final long primaryTerm,, +                             final String message,, +                             final Listener listener,, +                             final ClusterState currentState) {, +        StartedShardEntry entry = new StartedShardEntry(shardRouting.shardId(), shardRouting.allocationId().getId(), primaryTerm, message);, +        sendShardAction(SHARD_STARTED_ACTION_NAME, currentState, entry, listener);, +                final ShardRouting matched = currentState.getRoutingTable().getByAllocationId(task.shardId, task.allocationId);, +                    if (matched.primary() && task.primaryTerm > 0) {, +                        final IndexMetaData indexMetaData = currentState.metaData().index(task.shardId.getIndex());, +                        assert indexMetaData != null;, +                        final long currentPrimaryTerm = indexMetaData.primaryTerm(task.shardId.id());, +                        if (currentPrimaryTerm != task.primaryTerm) {, +                            assert currentPrimaryTerm > task.primaryTerm : "received a primary term with a higher term than in the " +, +                                "current cluster state (received [" + task.primaryTerm + "] but current is [" + currentPrimaryTerm + "])";, +                            logger.debug("{} ignoring shard started task [{}] (primary term {} does not match current term {})",, +                                task.shardId, task, task.primaryTerm, currentPrimaryTerm);, +                            builder.success(task);, +                            continue;, +                        }, +                    }, +        final long primaryTerm;, +                primaryTerm = in.readVLong();, +            } else if (in.getVersion().onOrAfter(Version.V_7_0_0)) {  // TODO update version to 6.7.0 after backport, +                primaryTerm = in.readVLong();, +            } else {, +                primaryTerm = UNASSIGNED_PRIMARY_TERM;, +        public StartedShardEntry(final ShardId shardId, final String allocationId, final long primaryTerm, final String message) {, +            this.primaryTerm = primaryTerm;, +            } else if (out.getVersion().onOrAfter(Version.V_7_0_0)) {  // TODO update version to 6.7.0 after backport, +                out.writeVLong(primaryTerm);, +            return String.format(Locale.ROOT,  "StartedShardEntry{shardId [%s], allocationId [%s], primary term [%d], message [%s]}",, +                shardId, allocationId, primaryTerm, message);, +++ b/server/src/main/java/org/elasticsearch/indices/cluster/IndicesClusterStateService.java, +            final long primaryTerm = state.metaData().index(shardRouting.index()).primaryTerm(shardRouting.id());, +            logger.debug("{} creating shard with primary term [{}]", shardRouting.shardId(), primaryTerm);, +                    new RecoveryListener(shardRouting, primaryTerm),, +        final long primaryTerm;, +            primaryTerm = indexMetaData.primaryTerm(shard.shardId().id());, +                shardStateAction.shardStarted(shardRouting, primaryTerm, "master " + nodes.getMasterNode() +, +        /**, +         * ShardRouting with which the shard was created, +         */, +        /**, +         * Primary term with which the shard was created, +         */, +        private final long primaryTerm;, +, +        private RecoveryListener(final ShardRouting shardRouting, final long primaryTerm) {, +            this.primaryTerm = primaryTerm;, +        public void onRecoveryDone(final RecoveryState state) {, +            shardStateAction.shardStarted(shardRouting, primaryTerm, "after " + state.getRecoverySource(), SHARD_STATE_ACTION_LISTENER);, +++ b/server/src/main/java/org/elasticsearch/cluster/action/shard/ShardStateAction.java]