[+++ /dev/null, +++ /dev/null, +++ b/src/main/java/org/elasticsearch/search/internal/DefaultSearchContext.java, +        scanContext = null;, +++ /dev/null, +++ b/src/main/java/org/elasticsearch/search/internal/DefaultSearchContext.java, +        scanContext = null;, +++ b/src/main/java/org/elasticsearch/search/scan/ScanContext.java, +import org.apache.lucene.search.CollectionTerminatedException;, +import org.apache.lucene.search.ConstantScoreScorer;, +import org.apache.lucene.search.ConstantScoreWeight;, +import org.apache.lucene.search.DocIdSetIterator;, +import org.apache.lucene.search.IndexSearcher;, +import org.apache.lucene.search.Weight;, +import org.elasticsearch.common.lucene.search.Queries;, +import java.util.List;, + * of the last collected doc ID and only collecting doc IDs that are greater., +    private volatile int docUpTo;, +        return execute(context.searcher(), context.query(), context.size(), context.trackScores());, +, +    TopDocs execute(IndexSearcher searcher, Query query, int size, boolean trackScores) throws IOException {, +        ScanCollector collector = new ScanCollector(size, trackScores);, +        Query q = Queries.filtered(query, new MinDocQuery(docUpTo));, +        searcher.search(q, collector);, +    private class ScanCollector extends SimpleCollector {, +        private final List<ScoreDoc> docs;, +        private final int size;, +        ScanCollector(int size, boolean trackScores) {, +            this.size = size;, +            int topLevelDoc = docBase + doc;, +            docs.add(new ScoreDoc(topLevelDoc, trackScores ? scorer.score() : 0f));, +            // record that we collected up to this document, +            assert topLevelDoc >= docUpTo;, +            docUpTo = topLevelDoc + 1;, +            if (docs.size() >= size) {, +                throw new CollectionTerminatedException();, +            if (docs.size() >= size || context.docBase + context.reader().maxDoc() <= docUpTo) {, +                // no need to collect a new segment, we either already collected enough, +                // or the segment is not competitive, +                throw new CollectionTerminatedException();, +            docBase = context.docBase;, +    /**, +     * A filtering query that matches all doc IDs that are not deleted and, +     * greater than or equal to the configured doc ID., +     */, +    // pkg-private for testing, +    static class MinDocQuery extends Query {, +        private final int minDoc;, +        MinDocQuery(int minDoc) {, +            this.minDoc = minDoc;, +        public int hashCode() {, +            return 31 * super.hashCode() + minDoc;, +        }, +, +        @Override, +        public boolean equals(Object obj) {, +            if (super.equals(obj) == false) {, +                return false;, +            }, +            MinDocQuery that = (MinDocQuery) obj;, +            return minDoc == that.minDoc;, +        }, +, +        @Override, +        public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {, +            return new ConstantScoreWeight(this) {, +                @Override, +                public Scorer scorer(LeafReaderContext context, final Bits acceptDocs) throws IOException {, +                    final int maxDoc = context.reader().maxDoc();, +                    if (context.docBase + maxDoc <= minDoc) {, +                    final int segmentMinDoc = Math.max(0, minDoc - context.docBase);, +                    final DocIdSetIterator disi = new DocIdSetIterator() {, +, +                        int doc = -1;, +, +                        @Override, +                        public int docID() {, +                            return doc;, +                        }, +, +                        @Override, +                        public int nextDoc() throws IOException {, +                            return advance(doc + 1);, +                        }, +, +                        @Override, +                        public int advance(int target) throws IOException {, +                            assert target > doc;, +                            if (doc == -1) {, +                                // skip directly to minDoc, +                                doc = Math.max(target, segmentMinDoc);, +                            } else {, +                                doc = target;, +                            }, +                            while (doc < maxDoc) {, +                                if (acceptDocs == null || acceptDocs.get(doc)) {, +                                    break;, +                                }, +                                doc += 1;, +                            }]