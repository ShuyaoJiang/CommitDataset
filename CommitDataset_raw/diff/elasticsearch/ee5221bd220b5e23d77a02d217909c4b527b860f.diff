[+++ b/src/main/java/org/elasticsearch/index/mapper/internal/TimestampFieldMapper.java, +        if (includeDefaults || (fieldType.indexed() != Defaults.FIELD_TYPE.indexed()) || (fieldType.tokenized() != Defaults.FIELD_TYPE.tokenized())) {, +        super.merge(mergeWith, mergeContext);, +        } else {, +            if (!timestampFieldMapperMergeWith.defaultTimestamp().equals(defaultTimestamp)) {, +                mergeContext.addConflict("Cannot update default in _timestamp value. Value is " + defaultTimestamp.toString() + " now encountering " + timestampFieldMapperMergeWith.defaultTimestamp());, +            }, +            if (this.path != null) {, +                if (path.equals(timestampFieldMapperMergeWith.path()) == false) {, +                    mergeContext.addConflict("Cannot update path in _timestamp value. Value is " + path + " path in merged mapping is " + (timestampFieldMapperMergeWith.path() == null ? "missing" : timestampFieldMapperMergeWith.path()));, +                }, +            } else if (timestampFieldMapperMergeWith.path() != null) {, +                mergeContext.addConflict("Cannot update path in _timestamp value. Value is " + path + " path in merged mapping is missing");, +            }, +++ b/src/main/java/org/elasticsearch/index/mapper/internal/TimestampFieldMapper.java, +        if (includeDefaults || (fieldType.indexed() != Defaults.FIELD_TYPE.indexed()) || (fieldType.tokenized() != Defaults.FIELD_TYPE.tokenized())) {, +        super.merge(mergeWith, mergeContext);, +        } else {, +            if (!timestampFieldMapperMergeWith.defaultTimestamp().equals(defaultTimestamp)) {, +                mergeContext.addConflict("Cannot update default in _timestamp value. Value is " + defaultTimestamp.toString() + " now encountering " + timestampFieldMapperMergeWith.defaultTimestamp());, +            }, +            if (this.path != null) {, +                if (path.equals(timestampFieldMapperMergeWith.path()) == false) {, +                    mergeContext.addConflict("Cannot update path in _timestamp value. Value is " + path + " path in merged mapping is " + (timestampFieldMapperMergeWith.path() == null ? "missing" : timestampFieldMapperMergeWith.path()));, +                }, +            } else if (timestampFieldMapperMergeWith.path() != null) {, +                mergeContext.addConflict("Cannot update path in _timestamp value. Value is " + path + " path in merged mapping is missing");, +            }, +++ b/src/test/java/org/elasticsearch/index/mapper/timestamp/TimestampMappingTests.java, +import org.elasticsearch.index.mapper.DocumentMapperParser;, +import org.elasticsearch.index.mapper.FieldMapper;, +import java.util.ArrayList;, +import java.util.List;, +        assertThat(docMapper.timestampFieldMapper().path(), equalTo(TimestampFieldMapper.Defaults.PATH));, +, +    @Test, +    public void testMergingFielddataLoadingWorks() throws Exception {, +        String mapping = XContentFactory.jsonBuilder().startObject().startObject("type"), +                .startObject("_timestamp").field("enabled", randomBoolean()).startObject("fielddata").field("loading", "lazy").field("format", "doc_values").endObject().field("store", "yes").endObject(), +                .endObject().endObject().string();, +        DocumentMapperParser parser = createIndex("test").mapperService().documentMapperParser();, +, +        DocumentMapper docMapper = parser.parse(mapping);, +        assertThat(docMapper.timestampFieldMapper().fieldDataType().getLoading(), equalTo(FieldMapper.Loading.LAZY));, +        assertThat(docMapper.timestampFieldMapper().fieldDataType().getFormat(docMapper.timestampFieldMapper().fieldDataType().getSettings()), equalTo("doc_values"));, +        mapping = XContentFactory.jsonBuilder().startObject().startObject("type"), +                .startObject("_timestamp").field("enabled", randomBoolean()).startObject("fielddata").field("loading", "eager").field("format", "array").endObject().field("store", "yes").endObject(), +                .endObject().endObject().string();, +, +        DocumentMapper.MergeResult mergeResult = docMapper.merge(parser.parse(mapping), DocumentMapper.MergeFlags.mergeFlags().simulate(false));, +        assertThat(mergeResult.conflicts().length, equalTo(0));, +        assertThat(docMapper.timestampFieldMapper().fieldDataType().getLoading(), equalTo(FieldMapper.Loading.EAGER));, +        assertThat(docMapper.timestampFieldMapper().fieldDataType().getFormat(docMapper.timestampFieldMapper().fieldDataType().getSettings()), equalTo("array"));, +    }, +, +    @Test, +    public void testParsingNotDefaultTwiceDoesNotChangeMapping() throws Exception {, +        String mapping = XContentFactory.jsonBuilder().startObject().startObject("type"), +                .startObject("_timestamp").field("enabled", true), +                .field("index", randomBoolean() ? "no" : "analyzed") // default is "not_analyzed" which will be omitted when building the source again, +                .field("store", true), +                .field("path", "foo"), +                .field("default", "1970-01-01"), +                .startObject("fielddata").field("format", "doc_values").endObject(), +                .endObject(), +                .startObject("properties"), +                .endObject(), +                .endObject().endObject().string();, +        DocumentMapperParser parser = createIndex("test").mapperService().documentMapperParser();, +, +        DocumentMapper docMapper = parser.parse(mapping);, +        docMapper.refreshSource();, +        docMapper = parser.parse(docMapper.mappingSource().string());, +        assertThat(docMapper.mappingSource().string(), equalTo(mapping));, +    }, +, +    @Test, +    public void testParsingTwiceDoesNotChangeTokenizeValue() throws Exception {, +        String[] index_options = {"no", "analyzed", "not_analyzed"};, +        String mapping = XContentFactory.jsonBuilder().startObject().startObject("type"), +                .startObject("_timestamp").field("enabled", true), +                .field("index", index_options[randomInt(2)]), +                .field("store", true), +                .field("path", "foo"), +                .field("default", "1970-01-01"), +                .startObject("fielddata").field("format", "doc_values").endObject(), +                .endObject(), +                .startObject("properties"), +                .endObject(), +                .endObject().endObject().string();, +        DocumentMapperParser parser = createIndex("test").mapperService().documentMapperParser();, +, +        DocumentMapper docMapper = parser.parse(mapping);, +        boolean tokenized = docMapper.timestampFieldMapper().fieldType().tokenized();, +        docMapper.refreshSource();, +        docMapper = parser.parse(docMapper.mappingSource().string());, +        assertThat(tokenized, equalTo(docMapper.timestampFieldMapper().fieldType().tokenized()));, +    }, +, +    @Test]