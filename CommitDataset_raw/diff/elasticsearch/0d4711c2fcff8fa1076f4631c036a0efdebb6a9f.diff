[+++ b/buildSrc/src/main/resources/checkstyle_suppressions.xml, +++ b/buildSrc/src/main/resources/checkstyle_suppressions.xml, +++ b/core/src/main/java/org/elasticsearch/index/mapper/core/StringFieldMapper.java, +        public Mapper.Builder parse(String fieldName, Map<String, Object> node, ParserContext parserContext) throws MapperParsingException {, +            StringFieldMapper.Builder builder = stringField(fieldName);, +                    throw new IllegalArgumentException("Can't parse [index] value [" + index + "] for field [" + fieldName + "], expected [true], [false], [no], [not_analyzed] or [analyzed]");, +            parseTextField(builder, fieldName, node, parserContext);, +                        throw new MapperParsingException("Analyzer [" + propNode.toString() + "] not found for field [" + fieldName + "]");, +                } else if (parseMultiField(builder, fieldName, parserContext, propName, propNode)) {, +++ b/buildSrc/src/main/resources/checkstyle_suppressions.xml, +++ b/core/src/main/java/org/elasticsearch/index/mapper/core/StringFieldMapper.java, +        public Mapper.Builder parse(String fieldName, Map<String, Object> node, ParserContext parserContext) throws MapperParsingException {, +            StringFieldMapper.Builder builder = stringField(fieldName);, +                    throw new IllegalArgumentException("Can't parse [index] value [" + index + "] for field [" + fieldName + "], expected [true], [false], [no], [not_analyzed] or [analyzed]");, +            parseTextField(builder, fieldName, node, parserContext);, +                        throw new MapperParsingException("Analyzer [" + propNode.toString() + "] not found for field [" + fieldName + "]");, +                } else if (parseMultiField(builder, fieldName, parserContext, propName, propNode)) {, +++ b/core/src/main/java/org/elasticsearch/index/mapper/core/TypeParsers.java, +                throw new IllegalArgumentException("Can't parse [index] value [" + index + "] for field [" + fieldName + "], expected [true] or [false]");, +                throw new IllegalArgumentException("Can't parse [index] value [" + index + "] for field [" + fieldName + "], expected [true], [false], [no], [not_analyzed] or [analyzed]");, +            throw new MapperParsingException("Unknown Similarity type [" + value + "] for field [" + name + "]");, +++ b/buildSrc/src/main/resources/checkstyle_suppressions.xml, +++ b/core/src/main/java/org/elasticsearch/index/mapper/core/StringFieldMapper.java, +        public Mapper.Builder parse(String fieldName, Map<String, Object> node, ParserContext parserContext) throws MapperParsingException {, +            StringFieldMapper.Builder builder = stringField(fieldName);, +                    throw new IllegalArgumentException("Can't parse [index] value [" + index + "] for field [" + fieldName + "], expected [true], [false], [no], [not_analyzed] or [analyzed]");, +            parseTextField(builder, fieldName, node, parserContext);, +                        throw new MapperParsingException("Analyzer [" + propNode.toString() + "] not found for field [" + fieldName + "]");, +                } else if (parseMultiField(builder, fieldName, parserContext, propName, propNode)) {, +++ b/core/src/main/java/org/elasticsearch/index/mapper/core/TypeParsers.java, +                throw new IllegalArgumentException("Can't parse [index] value [" + index + "] for field [" + fieldName + "], expected [true] or [false]");, +                throw new IllegalArgumentException("Can't parse [index] value [" + index + "] for field [" + fieldName + "], expected [true], [false], [no], [not_analyzed] or [analyzed]");, +            throw new MapperParsingException("Unknown Similarity type [" + value + "] for field [" + name + "]");, +++ b/core/src/main/java/org/elasticsearch/ingest/core/ConfigurationUtils.java, +    public static String readOptionalStringProperty(String processorType, String processorTag, Map<String, Object> configuration,, +                                                    String propertyName) {, +    public static String readStringProperty(String processorType, String processorTag, Map<String, Object> configuration,, +                                            String propertyName) {, +    public static String readStringProperty(String processorType, String processorTag, Map<String, Object> configuration,, +                                            String propertyName, String defaultValue) {, +        throw newConfigurationException(processorType, processorTag, propertyName, "property isn't a string, but of type [" +, +            value.getClass().getName() + "]");, +    }, +, +    /**, +     * Returns and removes the specified property from the specified configuration map., +     *, +     * If the property value isn't of type int a {@link ElasticsearchParseException} is thrown., +     * If the property is missing an {@link ElasticsearchParseException} is thrown, +     */, +    public static int readIntProperty(String processorType, String processorTag, Map<String, Object> configuration, String propertyName,, +                                      int defaultValue) {, +        Object value = configuration.remove(propertyName);, +        if (value == null) {, +            return defaultValue;, +        }, +        try {, +            return Integer.parseInt(value.toString());, +        } catch (Throwable t) {, +            throw newConfigurationException(processorType, processorTag, propertyName,, +                "property cannot be converted to an int [" + value.toString() + "]");, +        }, +    public static <T> List<T> readOptionalList(String processorType, String processorTag, Map<String, Object> configuration,, +                                               String propertyName) {, +            throw newConfigurationException(processorType, processorTag, propertyName,, +                "property isn't a list, but of type [" + value.getClass().getName() + "]");, +    public static <T> Map<String, T> readMap(String processorType, String processorTag, Map<String, Object> configuration,, +                                             String propertyName) {, +    public static <T> Map<String, T> readOptionalMap(String processorType, String processorTag, Map<String, Object> configuration,, +                                                     String propertyName) {, +            throw newConfigurationException(processorType, processorTag, propertyName,, +                "property isn't a map, but of type [" + value.getClass().getName() + "]");, +    public static ElasticsearchParseException newConfigurationException(String processorType, String processorTag, String propertyName,, +                                                                        String reason) {, +    public static List<Processor> readProcessorConfigs(List<Map<String, Map<String, Object>>> processorConfigs,, +                                                       ProcessorsRegistry processorRegistry) throws Exception {, +            List<Map<String, Map<String, Object>>> onFailureProcessorConfigs =, +                ConfigurationUtils.readOptionalList(null, null, config, Pipeline.ON_FAILURE_KEY);, +, +                throw new ElasticsearchParseException("processor [{}] doesn't support one or more provided configuration parameters {}",, +                    type, Arrays.toString(config.keySet().toArray()));, +++ b/buildSrc/src/main/resources/checkstyle_suppressions.xml, +++ b/core/src/main/java/org/elasticsearch/index/mapper/core/StringFieldMapper.java, +        public Mapper.Builder parse(String fieldName, Map<String, Object> node, ParserContext parserContext) throws MapperParsingException {, +            StringFieldMapper.Builder builder = stringField(fieldName);, +                    throw new IllegalArgumentException("Can't parse [index] value [" + index + "] for field [" + fieldName + "], expected [true], [false], [no], [not_analyzed] or [analyzed]");, +            parseTextField(builder, fieldName, node, parserContext);, +                        throw new MapperParsingException("Analyzer [" + propNode.toString() + "] not found for field [" + fieldName + "]");, +                } else if (parseMultiField(builder, fieldName, parserContext, propName, propNode)) {, +++ b/core/src/main/java/org/elasticsearch/index/mapper/core/TypeParsers.java, +                throw new IllegalArgumentException("Can't parse [index] value [" + index + "] for field [" + fieldName + "], expected [true] or [false]");, +                throw new IllegalArgumentException("Can't parse [index] value [" + index + "] for field [" + fieldName + "], expected [true], [false], [no], [not_analyzed] or [analyzed]");, +            throw new MapperParsingException("Unknown Similarity type [" + value + "] for field [" + name + "]");, +++ b/core/src/main/java/org/elasticsearch/ingest/core/ConfigurationUtils.java, +    public static String readOptionalStringProperty(String processorType, String processorTag, Map<String, Object> configuration,, +                                                    String propertyName) {, +    public static String readStringProperty(String processorType, String processorTag, Map<String, Object> configuration,, +                                            String propertyName) {, +    public static String readStringProperty(String processorType, String processorTag, Map<String, Object> configuration,, +                                            String propertyName, String defaultValue) {]