[+++ b/buildSrc/src/main/groovy/org/elasticsearch/gradle/BuildPlugin.groovy, +        // we are not shipping these jars, we act like dumb consumers of these things, +        if (project.path.startsWith(':test:fixtures')) {, +            return, +        }, +            if (configuration.name.endsWith('Fixture')) {, +                // just a self contained test-fixture configuration, likely transitive and hellacious, +                return, +            }, +++ b/buildSrc/src/main/groovy/org/elasticsearch/gradle/BuildPlugin.groovy, +        // we are not shipping these jars, we act like dumb consumers of these things, +        if (project.path.startsWith(':test:fixtures')) {, +            return, +        }, +            if (configuration.name.endsWith('Fixture')) {, +                // just a self contained test-fixture configuration, likely transitive and hellacious, +                return, +            }, +++ b/core/src/main/java/org/apache/lucene/queryparser/classic/MapperQueryParser.java, +                        query = super.getFieldQuery(currentFieldType.names().indexName(), queryText, quoted);, +                    query = getPossiblyAnalyzedPrefixQuery(currentFieldType.names().indexName(), termStr);, +                indexedNameField = currentFieldType.names().indexName();, +++ b/buildSrc/src/main/groovy/org/elasticsearch/gradle/BuildPlugin.groovy, +        // we are not shipping these jars, we act like dumb consumers of these things, +        if (project.path.startsWith(':test:fixtures')) {, +            return, +        }, +            if (configuration.name.endsWith('Fixture')) {, +                // just a self contained test-fixture configuration, likely transitive and hellacious, +                return, +            }, +++ b/core/src/main/java/org/apache/lucene/queryparser/classic/MapperQueryParser.java, +                        query = super.getFieldQuery(currentFieldType.names().indexName(), queryText, quoted);, +                    query = getPossiblyAnalyzedPrefixQuery(currentFieldType.names().indexName(), termStr);, +                indexedNameField = currentFieldType.names().indexName();, +++ b/core/src/main/java/org/elasticsearch/action/admin/indices/analyze/TransportAnalyzeAction.java, +                MappedFieldType fieldType = indexService.mapperService().smartNameFieldType(request.field());, +                    field = fieldType.names().indexName();, +++ b/buildSrc/src/main/groovy/org/elasticsearch/gradle/BuildPlugin.groovy, +        // we are not shipping these jars, we act like dumb consumers of these things, +        if (project.path.startsWith(':test:fixtures')) {, +            return, +        }, +            if (configuration.name.endsWith('Fixture')) {, +                // just a self contained test-fixture configuration, likely transitive and hellacious, +                return, +            }, +++ b/core/src/main/java/org/apache/lucene/queryparser/classic/MapperQueryParser.java, +                        query = super.getFieldQuery(currentFieldType.names().indexName(), queryText, quoted);, +                    query = getPossiblyAnalyzedPrefixQuery(currentFieldType.names().indexName(), termStr);, +                indexedNameField = currentFieldType.names().indexName();, +++ b/core/src/main/java/org/elasticsearch/action/admin/indices/analyze/TransportAnalyzeAction.java, +                MappedFieldType fieldType = indexService.mapperService().smartNameFieldType(request.field());, +                    field = fieldType.names().indexName();, +++ b/core/src/main/java/org/elasticsearch/action/admin/indices/mapping/get/TransportGetFieldMappingsIndexAction.java, +                    addFieldMapper(fieldMapper.fieldType().names().fullName(), fieldMapper, fieldMappings, request.includeDefaults());, +                    if (Regex.simpleMatch(field, fieldMapper.fieldType().names().fullName())) {, +                        addFieldMapper(fieldMapper.fieldType().names().fullName(), fieldMapper, fieldMappings, request.includeDefaults());, +                    if (Regex.simpleMatch(field, fieldMapper.fieldType().names().indexName())) {, +                        addFieldMapper(fieldMapper.fieldType().names().indexName(), fieldMapper, fieldMappings, request.includeDefaults());, +            fieldMappings.put(field, new FieldMappingMetaData(fieldMapper.fieldType().names().fullName(), builder.bytes()));, +++ b/buildSrc/src/main/groovy/org/elasticsearch/gradle/BuildPlugin.groovy, +        // we are not shipping these jars, we act like dumb consumers of these things, +        if (project.path.startsWith(':test:fixtures')) {, +            return, +        }, +            if (configuration.name.endsWith('Fixture')) {, +                // just a self contained test-fixture configuration, likely transitive and hellacious, +                return, +            }, +++ b/core/src/main/java/org/apache/lucene/queryparser/classic/MapperQueryParser.java, +                        query = super.getFieldQuery(currentFieldType.names().indexName(), queryText, quoted);, +                    query = getPossiblyAnalyzedPrefixQuery(currentFieldType.names().indexName(), termStr);, +                indexedNameField = currentFieldType.names().indexName();, +++ b/core/src/main/java/org/elasticsearch/action/admin/indices/analyze/TransportAnalyzeAction.java, +                MappedFieldType fieldType = indexService.mapperService().smartNameFieldType(request.field());, +                    field = fieldType.names().indexName();, +++ b/core/src/main/java/org/elasticsearch/action/admin/indices/mapping/get/TransportGetFieldMappingsIndexAction.java, +                    addFieldMapper(fieldMapper.fieldType().names().fullName(), fieldMapper, fieldMappings, request.includeDefaults());, +                    if (Regex.simpleMatch(field, fieldMapper.fieldType().names().fullName())) {, +                        addFieldMapper(fieldMapper.fieldType().names().fullName(), fieldMapper, fieldMappings, request.includeDefaults());, +                    if (Regex.simpleMatch(field, fieldMapper.fieldType().names().indexName())) {, +                        addFieldMapper(fieldMapper.fieldType().names().indexName(), fieldMapper, fieldMappings, request.includeDefaults());, +            fieldMappings.put(field, new FieldMappingMetaData(fieldMapper.fieldType().names().fullName(), builder.bytes()));, +++ b/core/src/main/java/org/elasticsearch/action/support/replication/TransportReplicationAction.java, +        if (indexShard.getTranslogDurability() == Translog.Durabilty.REQUEST && location != null) {, +++ b/buildSrc/src/main/groovy/org/elasticsearch/gradle/BuildPlugin.groovy, +        // we are not shipping these jars, we act like dumb consumers of these things, +        if (project.path.startsWith(':test:fixtures')) {, +            return, +        }, +            if (configuration.name.endsWith('Fixture')) {, +                // just a self contained test-fixture configuration, likely transitive and hellacious, +                return, +            }, +++ b/core/src/main/java/org/apache/lucene/queryparser/classic/MapperQueryParser.java, +                        query = super.getFieldQuery(currentFieldType.names().indexName(), queryText, quoted);, +                    query = getPossiblyAnalyzedPrefixQuery(currentFieldType.names().indexName(), termStr);, +                indexedNameField = currentFieldType.names().indexName();, +++ b/core/src/main/java/org/elasticsearch/action/admin/indices/analyze/TransportAnalyzeAction.java]