[+++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/lookup/PainlessLookupBuilder.java, +import java.lang.reflect.Constructor;, +import java.lang.reflect.Field;, +import java.lang.reflect.Method;, +import static org.elasticsearch.painless.lookup.PainlessLookupUtility.CONSTRUCTOR_NAME;, +import static org.elasticsearch.painless.lookup.PainlessLookupUtility.DEF_CLASS_NAME;, +import static org.elasticsearch.painless.lookup.PainlessLookupUtility.buildPainlessFieldKey;, +import static org.elasticsearch.painless.lookup.PainlessLookupUtility.typeToCanonicalTypeName;, +import static org.elasticsearch.painless.lookup.PainlessLookupUtility.typeToJavaType;, +import static org.elasticsearch.painless.lookup.PainlessLookupUtility.typesToCanonicalTypeNames;, +    private final Map<Class<?>, PainlessClassBuilder> classesToPainlessClassBuilders;, +        classesToPainlessClassBuilders = new HashMap<>();, +        canonicalClassNamesToClasses.put(DEF_CLASS_NAME, def.class);, +        classesToPainlessClassBuilders.put(def.class,, +                new PainlessClassBuilder(DEF_CLASS_NAME, Object.class, org.objectweb.asm.Type.getType(Object.class)));, +        PainlessLookupUtility.validateType(type, classesToPainlessClassBuilders.keySet());, +            throw new IllegalArgumentException("cannot add reserved class [" + DEF_CLASS_NAME + "]");, +        String canonicalClassName = typeToCanonicalTypeName(clazz);, +        PainlessClassBuilder existingPainlessClassBuilder = classesToPainlessClassBuilders.get(clazz);, +            PainlessClassBuilder painlessClassBuilder =, +                    new PainlessClassBuilder(canonicalClassName, clazz, org.objectweb.asm.Type.getType(clazz));, +            classesToPainlessClassBuilders.put(clazz, painlessClassBuilder);, +            Class<?> importedPainlessClass = canonicalClassNamesToClasses.get(importedCanonicalClassName);, +            if (importedPainlessClass == null) {, +                        throw new IllegalArgumentException("inconsistent only_fqn parameters found for class [" + canonicalClassName + "]");, +            } else if (importedPainlessClass.equals(clazz) == false) {, +                throw new IllegalArgumentException("imported class [" + importedCanonicalClassName + "] cannot represent multiple " +, +                        "classes [" + canonicalClassName + "] and [" + typeToCanonicalTypeName(importedPainlessClass) + "]");, +                throw new IllegalArgumentException("inconsistent only_fqn parameters found for class [" + canonicalClassName + "]");, +    public void addPainlessConstructor(String targetCanonicalClassName, List<String> typeNameParameters) {, +        Objects.requireNonNull(targetCanonicalClassName);, +        Objects.requireNonNull(typeNameParameters);, +        Class<?> targetClass = canonicalClassNamesToClasses.get(targetCanonicalClassName);, +, +        if (targetClass == null) {, +            throw new IllegalArgumentException("target class [" + targetCanonicalClassName + "] not found" +, +                    "for constructor [[" + targetCanonicalClassName + "], " + typeNameParameters  + "]");, +        List<Class<?>> typeParameters = new ArrayList<>(typeNameParameters.size());, +        for (String typeNameParameter : typeNameParameters) {, +                Class<?> typeParameter = canonicalTypeNameToType(typeNameParameter);, +                typeParameters.add(typeParameter);, +                throw new IllegalArgumentException("type parameter [" + typeNameParameter + "] not found " +, +                        "for constructor [[" + targetCanonicalClassName + "], " + typeNameParameters  + "]", iae);, +        addPainlessConstructor(targetClass, typeParameters);, +    }, +, +    public void addPainlessConstructor(Class<?> targetClass, List<Class<?>> typeParameters) {, +        Objects.requireNonNull(targetClass);, +        Objects.requireNonNull(typeParameters);, +, +        if (targetClass == def.class) {, +            throw new IllegalArgumentException("cannot add constructor to reserved class [" + DEF_CLASS_NAME + "]");, +        }, +, +        String targetCanonicalClassName = targetClass.getCanonicalName();, +        PainlessClassBuilder painlessClassBuilder = classesToPainlessClassBuilders.get(targetClass);, +, +        if (painlessClassBuilder == null) {, +            throw new IllegalArgumentException("target class [" + targetCanonicalClassName + "] not found" +, +                    "for constructor [[" + targetCanonicalClassName + "], " + typesToCanonicalTypeNames(typeParameters)  + "]");, +        }, +, +        int typeParametersSize = typeParameters.size();, +        List<Class<?>> javaTypeParameters = new ArrayList<>(typeParametersSize);, +, +        for (Class<?> typeParameter : typeParameters) {, +            try {, +                validateType(typeParameter);, +            } catch (IllegalArgumentException iae) {, +                throw new IllegalArgumentException("type parameter [" + typeToCanonicalTypeName(typeParameter) + "] not found " +, +                        "for constructor [[" + targetCanonicalClassName + "], " + typesToCanonicalTypeNames(typeParameters) + "]", iae);, +            }, +, +            javaTypeParameters.add(typeToJavaType(typeParameter));, +        }, +, +        Constructor<?> javaConstructor;, +            javaConstructor = targetClass.getConstructor(javaTypeParameters.toArray(new Class<?>[typeParametersSize]));, +        } catch (NoSuchMethodException nsme) {, +            throw new IllegalArgumentException("constructor reflection object " +, +                    "[[" + targetCanonicalClassName + "], " + typesToCanonicalTypeNames(typeParameters) + "] not found", nsme);, +        String painlessMethodKey = buildPainlessMethodKey(CONSTRUCTOR_NAME, typeParametersSize);, +        PainlessMethod painlessConstructor = painlessClassBuilder.constructors.get(painlessMethodKey);, +            MethodHandle methodHandle;, +                methodHandle = MethodHandles.publicLookup().in(targetClass).unreflectConstructor(javaConstructor);, +            } catch (IllegalAccessException iae) {, +                throw new IllegalArgumentException("constructor method handle " +, +                        "[[" + targetCanonicalClassName + "], " + typesToCanonicalTypeNames(typeParameters) + "] not found", iae);, +                    new PainlessMethodCacheKey(targetClass, CONSTRUCTOR_NAME, typeParameters),, +                    key -> new PainlessMethod(CONSTRUCTOR_NAME, targetClass, null, void.class, typeParameters,, +                                              asmConstructor, javaConstructor.getModifiers(), methodHandle), +            );, +, +            painlessClassBuilder.constructors.put(painlessMethodKey, painlessConstructor);, +        } else if (painlessConstructor.arguments.equals(typeParameters) == false){, +            throw new IllegalArgumentException("cannot have constructors " +, +                    "[[" + targetCanonicalClassName + "], " + typesToCanonicalTypeNames(typeParameters) + "] and " +, +                    "[[" + targetCanonicalClassName + "], " + typesToCanonicalTypeNames(painlessConstructor.arguments) + "] " +, +                    "with the same arity and different type parameters");, +    public void addPainlessMethod(ClassLoader classLoader, String targetCanonicalClassName, String augmentedCanonicalClassName,]