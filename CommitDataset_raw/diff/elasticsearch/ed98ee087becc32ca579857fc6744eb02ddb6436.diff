[+++ b/x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/MachineLearning.java, +        MlLifeCycleService mlLifeCycleService = new MlLifeCycleService(environment, clusterService, datafeedManager,, +                autodetectProcessManager, memoryTracker);, +++ b/x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/MachineLearning.java, +        MlLifeCycleService mlLifeCycleService = new MlLifeCycleService(environment, clusterService, datafeedManager,, +                autodetectProcessManager, memoryTracker);, +++ b/x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/MlLifeCycleService.java, +import org.elasticsearch.xpack.ml.process.MlMemoryTracker;, +    private final MlMemoryTracker memoryTracker;, +                              AutodetectProcessManager autodetectProcessManager, MlMemoryTracker memoryTracker) {, +        this.memoryTracker = memoryTracker;, +        if (memoryTracker != null) {, +            memoryTracker.stop();, +        }, +++ b/x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/MachineLearning.java, +        MlLifeCycleService mlLifeCycleService = new MlLifeCycleService(environment, clusterService, datafeedManager,, +                autodetectProcessManager, memoryTracker);, +++ b/x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/MlLifeCycleService.java, +import org.elasticsearch.xpack.ml.process.MlMemoryTracker;, +    private final MlMemoryTracker memoryTracker;, +                              AutodetectProcessManager autodetectProcessManager, MlMemoryTracker memoryTracker) {, +        this.memoryTracker = memoryTracker;, +        if (memoryTracker != null) {, +            memoryTracker.stop();, +        }, +++ b/x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/process/MlMemoryTracker.java, +import java.util.concurrent.Phaser;, +    private final Phaser stopPhaser;, +        this.stopPhaser = new Phaser(1);, +    /**, +     * Wait for all outstanding searches to complete., +     * After returning, no new searches can be started., +     */, +    public void stop() {, +        logger.trace("ML memory tracker stop called");, +        // We never terminate the phaser, +        assert stopPhaser.isTerminated() == false;, +        // If there are no registered parties or no unarrived parties then there is a flaw, +        // in the register/arrive/unregister logic in another method that uses the phaser, +        assert stopPhaser.getRegisteredParties() > 0;, +        assert stopPhaser.getUnarrivedParties() > 0;, +        stopPhaser.arriveAndAwaitAdvance();, +        assert stopPhaser.getPhase() > 0;, +        logger.debug("ML memory tracker stopped");, +    }, +, +                    e -> logger.warn("Failed to refresh job memory requirements", e), +                logger.warn("Couldn't schedule ML memory update - node might be shutting down", e);, +        // The phaser prevents searches being started after the memory tracker's stop() method has returned, +        if (stopPhaser.register() != 0) {, +            // Phases above 0 mean we've been stopped, so don't do any operations that involve external interaction, +            stopPhaser.arriveAndDeregister();, +            listener.onFailure(new EsRejectedExecutionException("Couldn't run ML memory update - node is shutting down"));, +            return;, +        }, +        ActionListener<Long> phaserListener = ActionListener.wrap(, +            r -> {, +                stopPhaser.arriveAndDeregister();, +                listener.onResponse(r);, +            },, +            e -> {, +                stopPhaser.arriveAndDeregister();, +                listener.onFailure(e);, +            }, +        );, +, +                        setJobMemoryToLimit(jobId, phaserListener);, +                        phaserListener.onResponse(memoryRequirementBytes);, +                    setJobMemoryToLimit(jobId, phaserListener);, +            setJobMemoryToLimit(jobId, phaserListener);, +++ b/x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/MachineLearning.java, +        MlLifeCycleService mlLifeCycleService = new MlLifeCycleService(environment, clusterService, datafeedManager,, +                autodetectProcessManager, memoryTracker);, +++ b/x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/MlLifeCycleService.java, +import org.elasticsearch.xpack.ml.process.MlMemoryTracker;, +    private final MlMemoryTracker memoryTracker;, +                              AutodetectProcessManager autodetectProcessManager, MlMemoryTracker memoryTracker) {, +        this.memoryTracker = memoryTracker;, +        if (memoryTracker != null) {, +            memoryTracker.stop();, +        }, +++ b/x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/process/MlMemoryTracker.java, +import java.util.concurrent.Phaser;, +    private final Phaser stopPhaser;, +        this.stopPhaser = new Phaser(1);, +    /**, +     * Wait for all outstanding searches to complete., +     * After returning, no new searches can be started., +     */, +    public void stop() {, +        logger.trace("ML memory tracker stop called");, +        // We never terminate the phaser, +        assert stopPhaser.isTerminated() == false;, +        // If there are no registered parties or no unarrived parties then there is a flaw, +        // in the register/arrive/unregister logic in another method that uses the phaser, +        assert stopPhaser.getRegisteredParties() > 0;, +        assert stopPhaser.getUnarrivedParties() > 0;, +        stopPhaser.arriveAndAwaitAdvance();, +        assert stopPhaser.getPhase() > 0;, +        logger.debug("ML memory tracker stopped");]