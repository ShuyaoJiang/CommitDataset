[+++ b/src/main/java/org/elasticsearch/search/suggest/phrase/StupidBackoffScorer.java, +        // First see if there are bigrams.  If there aren't then skip looking up the trigram.  This saves lookups, +        // when the bigrams and trigrams are rare and we need both anyway., +        long bigramCount = frequency(spare);, +        if (bigramCount < 1) {, +        SuggestUtils.join(separator, spare, w_2.term, w_1.term, w.term);, +        long trigramCount = frequency(spare);, +        if (trigramCount < 1) {, +            return discount * (bigramCount / (w_1.frequency + 0.00000000001d));, +++ b/src/main/java/org/elasticsearch/search/suggest/phrase/StupidBackoffScorer.java, +        // First see if there are bigrams.  If there aren't then skip looking up the trigram.  This saves lookups, +        // when the bigrams and trigrams are rare and we need both anyway., +        long bigramCount = frequency(spare);, +        if (bigramCount < 1) {, +        SuggestUtils.join(separator, spare, w_2.term, w_1.term, w.term);, +        long trigramCount = frequency(spare);, +        if (trigramCount < 1) {, +            return discount * (bigramCount / (w_1.frequency + 0.00000000001d));, +++ b/src/main/java/org/elasticsearch/search/suggest/phrase/WordScorer.java, +import com.carrotsearch.hppc.ObjectObjectMap;, +import com.carrotsearch.hppc.ObjectObjectOpenHashMap;, +import org.apache.lucene.index.*;, +import org.apache.lucene.index.FilterAtomicReader.FilterTermsEnum;, +import org.apache.lucene.util.Bits;, +    protected final double realWordLikelyhood;, +        this.termsEnum = new FrequencyCachingTermsEnumWrapper(terms.iterator(null));, +, +   /**, +    * Terms enum wrapper that caches term frequencies in an effort to outright skip seeks.  Only works with seekExact(BytesRef), not next or, +    * not seekCeil.  Because of this it really only makes sense in this context., +    */, +   private static class FrequencyCachingTermsEnumWrapper extends FilterTermsEnum {, +       private ObjectObjectMap<BytesRef, CacheEntry> cache = new ObjectObjectOpenHashMap<BytesRef, CacheEntry>();, +       /**, +        * The last term that the called attempted to seek to., +        */, +       private CacheEntry last;, +, +       public FrequencyCachingTermsEnumWrapper(TermsEnum in) {, +           super(in);, +       }, +, +       @Override, +       public boolean seekExact(BytesRef text) throws IOException {, +           last = cache.get(text);, +           if (last != null) {, +               // This'll fail to work properly if the user seeks but doesn't check the frequency, causing us to cache it., +               // That is OK because WordScorer only seeks to check the frequency., +               return last.ttf != 0 || last.df != 0;, +           }, +           last = new CacheEntry();, +           cache.put(BytesRef.deepCopyOf(text), last);, +           if (in.seekExact(text)) {, +               // Found so mark the term uncached., +               last.df = -1;, +               last.ttf = -1;, +               return true;, +           }, +           // Not found.  The cache will default to 0 for the freqs, meaning not found., +           return false;, +       }, +, +       @Override, +       public long totalTermFreq() throws IOException {, +           if (last.ttf == -1) {, +               last.ttf = in.totalTermFreq();, +           }, +           return last.ttf;, +       }, +, +       @Override, +       public int docFreq() throws IOException {, +           if (last.df == -1) {, +               last.df = in.docFreq();, +           }, +           return last.df;, +       }, +, +       @Override, +       public void seekExact(long ord) throws IOException {, +           throw new UnsupportedOperationException();, +       }, +, +       @Override, +       public DocsEnum docs(Bits liveDocs, DocsEnum reuse, int flags) throws IOException {, +           throw new UnsupportedOperationException();, +       }, +, +       @Override, +       public DocsAndPositionsEnum docsAndPositions(Bits liveDocs, DocsAndPositionsEnum reuse, int flags) throws IOException {, +           throw new UnsupportedOperationException();, +       }, +, +       public SeekStatus seekCeil(BytesRef text) throws IOException {, +           throw new UnsupportedOperationException();, +       }, +, +       @Override, +       public BytesRef next() {, +           throw new UnsupportedOperationException();]