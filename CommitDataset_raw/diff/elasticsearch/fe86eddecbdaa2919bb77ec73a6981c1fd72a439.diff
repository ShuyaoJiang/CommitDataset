[+++ b/src/main/java/org/elasticsearch/cluster/metadata/MetaDataCreateIndexService.java, +import org.elasticsearch.cluster.metadata.IndexMetaData.*;, +import java.io.UnsupportedEncodingException;, +    public final static int MAX_INDEX_NAME_BYTES = 100;, +, +        int byteCount = 0;, +        try {, +            byteCount = index.getBytes("UTF-8").length;, +        } catch (UnsupportedEncodingException e) {, +            // UTF-8 should always be supported, but rethrow this if it is not for some reason, +            throw new ElasticsearchException("Unable to determine length of index name", e);, +        }, +        if (byteCount > MAX_INDEX_NAME_BYTES) {, +            throw new InvalidIndexNameException(new Index(index), index,, +                    "index name is too long, (" + byteCount +, +                    " > " + MAX_INDEX_NAME_BYTES + ")");, +        }, +++ b/src/main/java/org/elasticsearch/cluster/metadata/MetaDataCreateIndexService.java, +import org.elasticsearch.cluster.metadata.IndexMetaData.*;, +import java.io.UnsupportedEncodingException;, +    public final static int MAX_INDEX_NAME_BYTES = 100;, +, +        int byteCount = 0;, +        try {, +            byteCount = index.getBytes("UTF-8").length;, +        } catch (UnsupportedEncodingException e) {, +            // UTF-8 should always be supported, but rethrow this if it is not for some reason, +            throw new ElasticsearchException("Unable to determine length of index name", e);, +        }, +        if (byteCount > MAX_INDEX_NAME_BYTES) {, +            throw new InvalidIndexNameException(new Index(index), index,, +                    "index name is too long, (" + byteCount +, +                    " > " + MAX_INDEX_NAME_BYTES + ")");, +        }, +++ b/src/test/java/org/elasticsearch/indexing/IndexActionTests.java, +import org.elasticsearch.cluster.metadata.MetaDataCreateIndexService;, +import org.elasticsearch.indices.InvalidIndexNameException;, +import java.util.Locale;, +, +    @Test, +    public void testCreateIndexWithLongName() {, +        int min = MetaDataCreateIndexService.MAX_INDEX_NAME_BYTES + 1;, +        int max = MetaDataCreateIndexService.MAX_INDEX_NAME_BYTES * 2;, +        try {, +            createIndex(randomAsciiOfLengthBetween(min, max).toLowerCase(Locale.ROOT));, +            fail("exception should have been thrown on too-long index name");, +        } catch (InvalidIndexNameException e) {, +            assertThat("exception contains message about index name too long: " + e.getMessage(),, +                    e.getMessage().contains("index name is too long,"), equalTo(true));, +        }, +, +        try {, +            client().prepareIndex(randomAsciiOfLengthBetween(min, max).toLowerCase(Locale.ROOT), "mytype").setSource("foo", "bar").get();, +            fail("exception should have been thrown on too-long index name");, +        } catch (InvalidIndexNameException e) {, +            assertThat("exception contains message about index name too long: " + e.getMessage(),, +                    e.getMessage().contains("index name is too long,"), equalTo(true));, +        }, +, +        try {, +            // Catch chars that are more than a single byte, +            client().prepareIndex(randomAsciiOfLength(MetaDataCreateIndexService.MAX_INDEX_NAME_BYTES -1).toLowerCase(Locale.ROOT) +, +                            "Ïž".toLowerCase(Locale.ROOT),, +                    "mytype").setSource("foo", "bar").get();, +            fail("exception should have been thrown on too-long index name");, +        } catch (InvalidIndexNameException e) {, +            assertThat("exception contains message about index name too long: " + e.getMessage(),, +                    e.getMessage().contains("index name is too long,"), equalTo(true));, +        }, +, +        // we can create an index of max length, +        createIndex(randomAsciiOfLength(MetaDataCreateIndexService.MAX_INDEX_NAME_BYTES).toLowerCase(Locale.ROOT));, +    }]