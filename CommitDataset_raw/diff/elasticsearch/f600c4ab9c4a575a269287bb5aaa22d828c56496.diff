[+++ b/buildSrc/src/main/resources/checkstyle_suppressions.xml, +++ b/buildSrc/src/main/resources/checkstyle_suppressions.xml, +++ b/core/src/main/java/org/elasticsearch/action/fieldstats/FieldStats.java, +import org.elasticsearch.common.io.stream.Writeable;, +import org.elasticsearch.common.network.InetAddresses;, +public abstract class FieldStats<T> implements Writeable, ToXContent {, +    private boolean isSearchable;, +    private boolean isAggregatable;, +    FieldStats(byte type, long maxDoc, boolean isSearchable, boolean isAggregatable) {, +        this(type, maxDoc, 0, 0, 0, isSearchable, isAggregatable, null, null);, +    FieldStats(byte type,, +               long maxDoc, long docCount, long sumDocFreq, long sumTotalTermFreq,, +               boolean isSearchable, boolean isAggregatable, T minValue, T maxValue) {, +        this.type = type;, +        this.isSearchable = isSearchable;, +        this.isAggregatable = isAggregatable;, +        this.minValue = minValue;, +        this.maxValue = maxValue;, +        return this.type;, +     * @return the number of documents that have at least one term for this field,, +     * or -1 if this measurement isn't available., +     * @return the sum of the term frequencies of all terms in this field across all documents,, +     * or -1 if this measurement, +     * @return <code>true</code> if any of the instances of the field name is searchable., +     */, +    public boolean isSearchable() {, +        return isSearchable;, +    }, +, +    /**, +     * @return <code>true</code> if any of the instances of the field name is aggregatable., +     */, +    public boolean isAggregatable() {, +        return isAggregatable;, +    }, +, +    /**, +     * Accumulates the provided stats into this stats instance., +    public final void accumulate(FieldStats other) {, +        this.maxDoc += other.maxDoc;, +        if (other.docCount == -1) {, +            this.docCount += other.docCount;, +        if (other.sumDocFreq == -1) {, +            this.sumDocFreq += other.sumDocFreq;, +        if (other.sumTotalTermFreq == -1) {, +            this.sumTotalTermFreq += other.sumTotalTermFreq;, +        }, +, +        isSearchable |= other.isSearchable;, +        isAggregatable |= other.isAggregatable;, +, +        assert type == other.getType();, +        updateMinMax((T) other.minValue, (T) other.maxValue);, +    }, +, +    private void updateMinMax(T min, T max) {, +        if (minValue == null) {, +            minValue = min;, +        } else if (min != null && compare(minValue, min) > 0) {, +            minValue = min;, +        }, +        if (maxValue == null) {, +            maxValue = max;, +        } else if (max != null && compare(maxValue, max) < 0) {, +            maxValue = max;, +    protected abstract int compare(T o1, T o2);, +, +    @Override, +    public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {, +        builder.startObject();, +        builder.field(Fields.MAX_DOC, maxDoc);, +        builder.field(Fields.DOC_COUNT, docCount);, +        builder.field(Fields.DENSITY, getDensity());, +        builder.field(Fields.SUM_DOC_FREQ, sumDocFreq);, +        builder.field(Fields.SUM_TOTAL_TERM_FREQ, sumTotalTermFreq);, +        builder.field(Fields.SEARCHABLE, isSearchable);, +        builder.field(Fields.AGGREGATABLE, isAggregatable);, +        toInnerXContent(builder);, +        builder.endObject();, +        return builder;, +    }, +, +    protected void toInnerXContent(XContentBuilder builder) throws IOException {, +        builder.field(Fields.MIN_VALUE, getMinValue());, +        builder.field(Fields.MIN_VALUE_AS_STRING, getMinValueAsString());, +        builder.field(Fields.MAX_VALUE, getMaxValue());, +        builder.field(Fields.MAX_VALUE_AS_STRING, getMaxValueAsString());, +    }, +, +    @Override, +    public final void writeTo(StreamOutput out) throws IOException {, +        out.writeByte(type);, +        out.writeLong(maxDoc);, +        out.writeLong(docCount);, +        out.writeLong(sumDocFreq);, +        out.writeLong(sumTotalTermFreq);, +        out.writeBoolean(isSearchable);, +        out.writeBoolean(isAggregatable);, +        boolean hasMinMax = minValue != null;, +        out.writeBoolean(hasMinMax);]