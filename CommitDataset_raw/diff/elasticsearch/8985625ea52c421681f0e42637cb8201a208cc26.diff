[+++ b/plugin/src/main/java/org/elasticsearch/xpack/security/authz/AuthorizationService.java, +import org.elasticsearch.common.collect.Tuple;, +            authorizeBulkItems(authentication, (BulkShardRequest) request, permission, metaData, localIndices, authorizedIndices);, +    private void authorizeBulkItems(Authentication authentication, BulkShardRequest request, Role permission,, +                                    MetaData metaData, Set<String> indices, AuthorizedIndices authorizedIndices) {, +        // Maps original-index -> expanded-index-name (expands date-math, but not aliases), +        final Map<String, String> resolvedIndexNames = new HashMap<>();, +        // Maps (resolved-index , action) -> is-granted, +        final Map<Tuple<String, String>, Boolean> indexActionAuthority = new HashMap<>();, +            String resolvedIndex = resolvedIndexNames.computeIfAbsent(item.index(), key -> {, +                final ResolvedIndices resolvedIndices = indicesAndAliasesResolver.resolveIndicesAndAliases(item.request(), metaData,, +                        authorizedIndices);, +                if (resolvedIndices.getRemote().size() != 0) {, +                    throw illegalArgument("Bulk item should not write to remote indices, but request writes to ", +                            + String.join(",", resolvedIndices.getRemote()));, +                }, +                if (resolvedIndices.getLocal().size() != 1) {, +                    throw illegalArgument("Bulk item should write to exactly 1 index, but request writes to ", +                            + String.join(",", resolvedIndices.getLocal()));, +                }, +                final String resolved = resolvedIndices.getLocal().get(0);, +                if (indices.contains(resolved) == false) {, +                    throw illegalArgument("Found bulk item that writes to index " + resolved + " but the request writes to " + indices);, +                }, +                return resolved;, +            });, +            final Tuple<String, String> indexAndAction = new Tuple<>(resolvedIndex, itemAction);, +            final boolean granted = indexActionAuthority.computeIfAbsent(indexAndAction, key -> {, +                final IndicesAccessControl itemAccessControl = permission.authorize(itemAction, Collections.singleton(resolvedIndex),, +                        metaData, fieldPermissionsCache);, +                item.abort(resolvedIndex, denial(authentication, itemAction, request));, +    private IllegalArgumentException illegalArgument(String message) {, +        assert false : message;, +        return new IllegalArgumentException(message);, +    }, +, +++ b/plugin/src/main/java/org/elasticsearch/xpack/security/authz/AuthorizationService.java, +import org.elasticsearch.common.collect.Tuple;, +            authorizeBulkItems(authentication, (BulkShardRequest) request, permission, metaData, localIndices, authorizedIndices);, +    private void authorizeBulkItems(Authentication authentication, BulkShardRequest request, Role permission,, +                                    MetaData metaData, Set<String> indices, AuthorizedIndices authorizedIndices) {, +        // Maps original-index -> expanded-index-name (expands date-math, but not aliases), +        final Map<String, String> resolvedIndexNames = new HashMap<>();, +        // Maps (resolved-index , action) -> is-granted, +        final Map<Tuple<String, String>, Boolean> indexActionAuthority = new HashMap<>();, +            String resolvedIndex = resolvedIndexNames.computeIfAbsent(item.index(), key -> {, +                final ResolvedIndices resolvedIndices = indicesAndAliasesResolver.resolveIndicesAndAliases(item.request(), metaData,, +                        authorizedIndices);, +                if (resolvedIndices.getRemote().size() != 0) {, +                    throw illegalArgument("Bulk item should not write to remote indices, but request writes to ", +                            + String.join(",", resolvedIndices.getRemote()));, +                }, +                if (resolvedIndices.getLocal().size() != 1) {, +                    throw illegalArgument("Bulk item should write to exactly 1 index, but request writes to ", +                            + String.join(",", resolvedIndices.getLocal()));, +                }, +                final String resolved = resolvedIndices.getLocal().get(0);, +                if (indices.contains(resolved) == false) {, +                    throw illegalArgument("Found bulk item that writes to index " + resolved + " but the request writes to " + indices);, +                }, +                return resolved;, +            });, +            final Tuple<String, String> indexAndAction = new Tuple<>(resolvedIndex, itemAction);, +            final boolean granted = indexActionAuthority.computeIfAbsent(indexAndAction, key -> {, +                final IndicesAccessControl itemAccessControl = permission.authorize(itemAction, Collections.singleton(resolvedIndex),, +                        metaData, fieldPermissionsCache);, +                item.abort(resolvedIndex, denial(authentication, itemAction, request));, +    private IllegalArgumentException illegalArgument(String message) {, +        assert false : message;, +        return new IllegalArgumentException(message);, +    }, +, +++ b/plugin/src/main/java/org/elasticsearch/xpack/security/authz/IndicesAndAliasesResolver.java, +    ResolvedIndices resolveIndicesAndAliases(IndicesRequest indicesRequest, MetaData metaData,, +++ b/plugin/src/main/java/org/elasticsearch/xpack/security/authz/AuthorizationService.java, +import org.elasticsearch.common.collect.Tuple;, +            authorizeBulkItems(authentication, (BulkShardRequest) request, permission, metaData, localIndices, authorizedIndices);, +    private void authorizeBulkItems(Authentication authentication, BulkShardRequest request, Role permission,, +                                    MetaData metaData, Set<String> indices, AuthorizedIndices authorizedIndices) {, +        // Maps original-index -> expanded-index-name (expands date-math, but not aliases), +        final Map<String, String> resolvedIndexNames = new HashMap<>();, +        // Maps (resolved-index , action) -> is-granted, +        final Map<Tuple<String, String>, Boolean> indexActionAuthority = new HashMap<>();, +            String resolvedIndex = resolvedIndexNames.computeIfAbsent(item.index(), key -> {, +                final ResolvedIndices resolvedIndices = indicesAndAliasesResolver.resolveIndicesAndAliases(item.request(), metaData,, +                        authorizedIndices);, +                if (resolvedIndices.getRemote().size() != 0) {, +                    throw illegalArgument("Bulk item should not write to remote indices, but request writes to ", +                            + String.join(",", resolvedIndices.getRemote()));, +                }, +                if (resolvedIndices.getLocal().size() != 1) {, +                    throw illegalArgument("Bulk item should write to exactly 1 index, but request writes to ", +                            + String.join(",", resolvedIndices.getLocal()));, +                }, +                final String resolved = resolvedIndices.getLocal().get(0);, +                if (indices.contains(resolved) == false) {, +                    throw illegalArgument("Found bulk item that writes to index " + resolved + " but the request writes to " + indices);, +                }, +                return resolved;, +            });]