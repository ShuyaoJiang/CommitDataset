[+++ b/plugin/src/main/java/org/elasticsearch/xpack/ml/job/persistence/JobProvider.java, +import org.elasticsearch.ElasticsearchException;, +import org.elasticsearch.action.search.MultiSearchRequestBuilder;, +import org.elasticsearch.action.search.SearchRequestBuilder;, +import org.elasticsearch.action.search.ShardSearchFailure;, +import org.elasticsearch.xpack.ml.job.process.autodetect.params.AutodetectParams;, +import org.elasticsearch.xpack.ml.utils.ExceptionsHelper;, +    public void getAutodetectParams(Job job, Consumer<AutodetectParams> consumer, Consumer<Exception> errorHandler) {, +        AutodetectParams.Builder paramsBuilder = new AutodetectParams.Builder(job.getId());, +, +        String jobId = job.getId();, +        String resultsIndex = AnomalyDetectorsIndex.jobResultsAliasedName(jobId);, +        String stateIndex = AnomalyDetectorsIndex.jobStateIndexName();, +        MultiSearchRequestBuilder msearch = client.prepareMultiSearch(), +                .add(createDocIdSearch(resultsIndex, DataCounts.TYPE.getPreferredName(), DataCounts.documentId(jobId))), +                .add(createDocIdSearch(resultsIndex, Result.TYPE.getPreferredName(), ModelSizeStats.documentId(jobId))), +                .add(createDocIdSearch(resultsIndex, ModelSnapshot.TYPE.getPreferredName(),, +                        ModelSnapshot.documentId(jobId, job.getModelSnapshotId()))), +                .add(createDocIdSearch(stateIndex, Quantiles.TYPE.getPreferredName(), Quantiles.documentId(jobId)));, +, +        for (String filterId : job.getAnalysisConfig().extractReferencedFilters()) {, +            msearch.add(createDocIdSearch(ML_META_INDEX, MlFilter.TYPE.getPreferredName(), filterId));, +        }, +, +        msearch.execute(ActionListener.wrap(, +                response -> {, +                    for (MultiSearchResponse.Item itemResponse : response.getResponses()) {, +                        if (itemResponse.isFailure()) {, +                            if (itemResponse.getFailure() instanceof IndexNotFoundException == false) {, +                                throw itemResponse.getFailure();, +                            } else {, +                                // Ignore IndexNotFoundException; AutodetectParamsBuilder has defaults for new jobs, +                            }, +                        } else {, +                            SearchResponse searchResponse = itemResponse.getResponse();, +                            ShardSearchFailure[] shardFailures = searchResponse.getShardFailures();, +                            int unavailableShards = searchResponse.getTotalShards() - searchResponse.getSuccessfulShards();, +                            if (shardFailures != null && shardFailures.length > 0) {, +                                LOGGER.error("[{}] Search request returned shard failures: {}", jobId,, +                                        Arrays.toString(shardFailures));, +                                errorHandler.accept(new ElasticsearchException(, +                                        ExceptionsHelper.shardFailuresToErrorMsg(jobId, shardFailures)));, +                            } else if (unavailableShards > 0) {, +                                errorHandler.accept(new ElasticsearchException("[" + jobId, +                                        + "] Search request encountered [" + unavailableShards + "] unavailable shards"));, +                            } else {, +                                SearchHit[] hits = searchResponse.getHits().getHits();, +                                if (hits.length == 1) {, +                                    parseAutodetectParamSearchHit(paramsBuilder, hits[0], errorHandler);, +                                } else if (hits.length > 1) {, +                                    errorHandler.accept(new IllegalStateException("Got [", +                                            + hits.length + "] even though search size was 1"));, +                                }, +                            }, +                        }, +                    }, +                    consumer.accept(paramsBuilder.build());, +                },, +                errorHandler, +        ));, +    }, +, +    private SearchRequestBuilder createDocIdSearch(String index, String type, String id) {, +        return client.prepareSearch(index).setSize(1), +                .setQuery(QueryBuilders.idsQuery(type).addIds(id)), +                .setRouting(id);, +    }, +, +    private void parseAutodetectParamSearchHit(AutodetectParams.Builder paramsBuilder,, +                                               SearchHit hit, Consumer<Exception> errorHandler) {, +        String type = hit.getType();, +        if (DataCounts.TYPE.getPreferredName().equals(type)) {, +            paramsBuilder.setDataCounts(parseSearchHit(hit, DataCounts.PARSER, errorHandler));, +        } else if (Result.TYPE.getPreferredName().equals(type)) {, +            ModelSizeStats.Builder modelSizeStats = parseSearchHit(hit, ModelSizeStats.PARSER, errorHandler);, +            paramsBuilder.setModelSizeStats(modelSizeStats == null ? null : modelSizeStats.build());, +        } else if (ModelSnapshot.TYPE.getPreferredName().equals(type)) {, +            ModelSnapshot.Builder modelSnapshot = parseSearchHit(hit, ModelSnapshot.PARSER, errorHandler);, +            paramsBuilder.setModelSnapshot(modelSnapshot == null ? null : modelSnapshot.build());, +        } else if (Quantiles.TYPE.getPreferredName().equals(type)) {, +            paramsBuilder.setQuantiles(parseSearchHit(hit, Quantiles.PARSER, errorHandler));, +        } else if (MlFilter.TYPE.getPreferredName().equals(type)) {, +            paramsBuilder.addFilter(parseSearchHit(hit, MlFilter.PARSER, errorHandler));, +        } else {, +            errorHandler.accept(new IllegalStateException("Unexpected type [" + type + "]"));, +        }, +    }, +, +    private <T, U> T parseSearchHit(SearchHit hit, BiFunction<XContentParser, U, T> objectParser,, +                                    Consumer<Exception> errorHandler) {, +        BytesReference source = hit.getSourceRef();, +        try (XContentParser parser = XContentFactory.xContent(source).createParser(NamedXContentRegistry.EMPTY, source)) {, +            return objectParser.apply(parser, null);, +        } catch (IOException e) {, +            errorHandler.accept(new ElasticsearchParseException("failed to parse " + hit.getType(), e));, +            return null;, +        }, +    }, +, +                    return new ModelSizeStats.Builder(jobId).build();]