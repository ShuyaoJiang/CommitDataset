[+++ b/modules/elasticsearch/src/main/java/org/elasticsearch/index/gateway/blobstore/BlobStoreIndexShardGateway.java, +            long fileLength = 0;, +                fileLength = store.directory().fileLength(fileName);, +            if (fileInfo == null || fileInfo.length() != fileLength || !commitPointFileExistsInBlobs(fileInfo, blobs)) {, +                indexTotalFilesSize += fileLength;, +                    CommitPoint.FileInfo snapshotFileInfo = new CommitPoint.FileInfo(fileNameFromGeneration(++generation), fileName, fileLength);, +            String fileName = fileInfo.physicalName();, +            long fileLength = -1;, +            try {, +                fileLength = store.directory().fileLength(fileName);, +            } catch (Exception e) {, +                // no file, +            }, +            if (!fileName.contains("segment") && fileLength == fileInfo.length()) {, +                totalSize += fileLength;, +                reusedTotalSize += fileLength;, +                    if (fileLength == -1) {, +                        logger.trace("recovering [{}], exists in local store but has different length: gateway [{}], local [{}]", fileInfo.physicalName(), fileInfo.length(), fileLength);, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/index/gateway/blobstore/BlobStoreIndexShardGateway.java, +            long fileLength = 0;, +                fileLength = store.directory().fileLength(fileName);, +            if (fileInfo == null || fileInfo.length() != fileLength || !commitPointFileExistsInBlobs(fileInfo, blobs)) {, +                indexTotalFilesSize += fileLength;, +                    CommitPoint.FileInfo snapshotFileInfo = new CommitPoint.FileInfo(fileNameFromGeneration(++generation), fileName, fileLength);, +            String fileName = fileInfo.physicalName();, +            long fileLength = -1;, +            try {, +                fileLength = store.directory().fileLength(fileName);, +            } catch (Exception e) {, +                // no file, +            }, +            if (!fileName.contains("segment") && fileLength == fileInfo.length()) {, +                totalSize += fileLength;, +                reusedTotalSize += fileLength;, +                    if (fileLength == -1) {, +                        logger.trace("recovering [{}], exists in local store but has different length: gateway [{}], local [{}]", fileInfo.physicalName(), fileInfo.length(), fileLength);, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/index/shard/recovery/RecoverySource.java, +                        long length = shard.store().directory().fileLength(name);, +                            if (!name.contains("segment") && length == request.existingFiles().get(name).length()) {, +                                response.phase1ExistingFileSizes.add(length);, +                                existingTotalSize += length;, +                                    logger.trace("[{}][{}] recovery [phase1] to {}: not recovering [{}], exists in local store and has size [{}]", request.shardId().index().name(), request.shardId().id(), request.targetNode(), name, length);, +                                logger.trace("[{}][{}] recovery [phase1] to {}: recovering [{}], exists in local store, but has different length: remote [{}], local [{}]", request.shardId().index().name(), request.shardId().id(), request.targetNode(), name, request.existingFiles().get(name).length(), length);, +                            response.phase1FileSizes.add(length);, +                            totalSize += length;, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/index/gateway/blobstore/BlobStoreIndexShardGateway.java, +            long fileLength = 0;, +                fileLength = store.directory().fileLength(fileName);, +            if (fileInfo == null || fileInfo.length() != fileLength || !commitPointFileExistsInBlobs(fileInfo, blobs)) {, +                indexTotalFilesSize += fileLength;, +                    CommitPoint.FileInfo snapshotFileInfo = new CommitPoint.FileInfo(fileNameFromGeneration(++generation), fileName, fileLength);, +            String fileName = fileInfo.physicalName();, +            long fileLength = -1;, +            try {, +                fileLength = store.directory().fileLength(fileName);, +            } catch (Exception e) {, +                // no file, +            }, +            if (!fileName.contains("segment") && fileLength == fileInfo.length()) {, +                totalSize += fileLength;, +                reusedTotalSize += fileLength;, +                    if (fileLength == -1) {, +                        logger.trace("recovering [{}], exists in local store but has different length: gateway [{}], local [{}]", fileInfo.physicalName(), fileInfo.length(), fileLength);, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/index/shard/recovery/RecoverySource.java, +                        long length = shard.store().directory().fileLength(name);, +                            if (!name.contains("segment") && length == request.existingFiles().get(name).length()) {, +                                response.phase1ExistingFileSizes.add(length);, +                                existingTotalSize += length;, +                                    logger.trace("[{}][{}] recovery [phase1] to {}: not recovering [{}], exists in local store and has size [{}]", request.shardId().index().name(), request.shardId().id(), request.targetNode(), name, length);, +                                logger.trace("[{}][{}] recovery [phase1] to {}: recovering [{}], exists in local store, but has different length: remote [{}], local [{}]", request.shardId().index().name(), request.shardId().id(), request.targetNode(), name, request.existingFiles().get(name).length(), length);, +                            response.phase1FileSizes.add(length);, +                            totalSize += length;, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/index/store/Store.java, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/index/gateway/blobstore/BlobStoreIndexShardGateway.java, +            long fileLength = 0;, +                fileLength = store.directory().fileLength(fileName);, +            if (fileInfo == null || fileInfo.length() != fileLength || !commitPointFileExistsInBlobs(fileInfo, blobs)) {, +                indexTotalFilesSize += fileLength;, +                    CommitPoint.FileInfo snapshotFileInfo = new CommitPoint.FileInfo(fileNameFromGeneration(++generation), fileName, fileLength);, +            String fileName = fileInfo.physicalName();, +            long fileLength = -1;, +            try {, +                fileLength = store.directory().fileLength(fileName);, +            } catch (Exception e) {, +                // no file, +            }, +            if (!fileName.contains("segment") && fileLength == fileInfo.length()) {, +                totalSize += fileLength;, +                reusedTotalSize += fileLength;, +                    if (fileLength == -1) {, +                        logger.trace("recovering [{}], exists in local store but has different length: gateway [{}], local [{}]", fileInfo.physicalName(), fileInfo.length(), fileLength);, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/index/shard/recovery/RecoverySource.java, +                        long length = shard.store().directory().fileLength(name);, +                            if (!name.contains("segment") && length == request.existingFiles().get(name).length()) {, +                                response.phase1ExistingFileSizes.add(length);, +                                existingTotalSize += length;, +                                    logger.trace("[{}][{}] recovery [phase1] to {}: not recovering [{}], exists in local store and has size [{}]", request.shardId().index().name(), request.shardId().id(), request.targetNode(), name, length);, +                                logger.trace("[{}][{}] recovery [phase1] to {}: recovering [{}], exists in local store, but has different length: remote [{}], local [{}]", request.shardId().index().name(), request.shardId().id(), request.targetNode(), name, request.existingFiles().get(name).length(), length);, +                            response.phase1FileSizes.add(length);, +                            totalSize += length;]