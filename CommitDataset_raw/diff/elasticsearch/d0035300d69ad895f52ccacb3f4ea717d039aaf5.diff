[+++ b/server/src/main/java/org/elasticsearch/index/shard/IndexShard.java, +                logger.trace("index [{}][{}] seq# [{}] allocation-id {}",, +                    index.type(), index.id(), index.seqNo(), routingEntry().allocationId());, +++ b/server/src/main/java/org/elasticsearch/index/shard/IndexShard.java, +                logger.trace("index [{}][{}] seq# [{}] allocation-id {}",, +                    index.type(), index.id(), index.seqNo(), routingEntry().allocationId());, +++ b/test/framework/src/main/java/org/elasticsearch/index/engine/EngineTestCase.java, +            docs.sort(Comparator.comparingLong(DocIdSeqNoAndTerm::getSeqNo), +                .thenComparingLong(DocIdSeqNoAndTerm::getPrimaryTerm), +                .thenComparing((DocIdSeqNoAndTerm::getId)));, +++ b/server/src/main/java/org/elasticsearch/index/shard/IndexShard.java, +                logger.trace("index [{}][{}] seq# [{}] allocation-id {}",, +                    index.type(), index.id(), index.seqNo(), routingEntry().allocationId());, +++ b/test/framework/src/main/java/org/elasticsearch/index/engine/EngineTestCase.java, +            docs.sort(Comparator.comparingLong(DocIdSeqNoAndTerm::getSeqNo), +                .thenComparingLong(DocIdSeqNoAndTerm::getPrimaryTerm), +                .thenComparing((DocIdSeqNoAndTerm::getId)));, +++ b/x-pack/plugin/ccr/src/test/java/org/elasticsearch/xpack/CcrIntegTestCase.java, +import org.elasticsearch.common.util.set.Sets;, +            Map<Integer, List<DocIdSeqNoAndTerm>> docsOnLeader = getDocIdAndSeqNos(clusterGroup.leaderCluster, leaderIndex);, +            Map<Integer, Set<DocIdSeqNoAndTerm>> mismatchedDocs = new HashMap<>();, +            for (Map.Entry<Integer, List<DocIdSeqNoAndTerm>> fe : docsOnFollower.entrySet()) {, +                Set<DocIdSeqNoAndTerm> d1 = Sets.difference(, +                    Sets.newHashSet(fe.getValue()), Sets.newHashSet(docsOnLeader.getOrDefault(fe.getKey(), Collections.emptyList())));, +                Set<DocIdSeqNoAndTerm> d2 = Sets.difference(, +                    Sets.newHashSet(docsOnLeader.getOrDefault(fe.getKey(), Collections.emptyList())), Sets.newHashSet(fe.getValue()));, +                if (d1.isEmpty() == false || d2.isEmpty() == false) {, +                    mismatchedDocs.put(fe.getKey(), Sets.union(d1, d2));, +                }, +            }, +            assertThat("mismatched documents [" + mismatchedDocs + "]", docsOnFollower, equalTo(docsOnLeader));, +            if (shardRouting == null || shardRouting.assignedToNode() == false) {, +                final List<DocIdSeqNoAndTerm> docsOnShard = IndexShardTestCase.getDocIdAndSeqNos(indexShard);, +                logger.info("--> shard {} docs {} seq_no_stats {}", shardRouting, docsOnShard, indexShard.seqNoStats());, +                docs.put(shardRouting.shardId().id(), docsOnShard.stream(), +++ b/server/src/main/java/org/elasticsearch/index/shard/IndexShard.java, +                logger.trace("index [{}][{}] seq# [{}] allocation-id {}",, +                    index.type(), index.id(), index.seqNo(), routingEntry().allocationId());, +++ b/test/framework/src/main/java/org/elasticsearch/index/engine/EngineTestCase.java, +            docs.sort(Comparator.comparingLong(DocIdSeqNoAndTerm::getSeqNo), +                .thenComparingLong(DocIdSeqNoAndTerm::getPrimaryTerm), +                .thenComparing((DocIdSeqNoAndTerm::getId)));, +++ b/x-pack/plugin/ccr/src/test/java/org/elasticsearch/xpack/CcrIntegTestCase.java, +import org.elasticsearch.common.util.set.Sets;, +            Map<Integer, List<DocIdSeqNoAndTerm>> docsOnLeader = getDocIdAndSeqNos(clusterGroup.leaderCluster, leaderIndex);, +            Map<Integer, Set<DocIdSeqNoAndTerm>> mismatchedDocs = new HashMap<>();, +            for (Map.Entry<Integer, List<DocIdSeqNoAndTerm>> fe : docsOnFollower.entrySet()) {, +                Set<DocIdSeqNoAndTerm> d1 = Sets.difference(, +                    Sets.newHashSet(fe.getValue()), Sets.newHashSet(docsOnLeader.getOrDefault(fe.getKey(), Collections.emptyList())));, +                Set<DocIdSeqNoAndTerm> d2 = Sets.difference(, +                    Sets.newHashSet(docsOnLeader.getOrDefault(fe.getKey(), Collections.emptyList())), Sets.newHashSet(fe.getValue()));, +                if (d1.isEmpty() == false || d2.isEmpty() == false) {, +                    mismatchedDocs.put(fe.getKey(), Sets.union(d1, d2));, +                }, +            }, +            assertThat("mismatched documents [" + mismatchedDocs + "]", docsOnFollower, equalTo(docsOnLeader));, +            if (shardRouting == null || shardRouting.assignedToNode() == false) {, +                final List<DocIdSeqNoAndTerm> docsOnShard = IndexShardTestCase.getDocIdAndSeqNos(indexShard);, +                logger.info("--> shard {} docs {} seq_no_stats {}", shardRouting, docsOnShard, indexShard.seqNoStats());, +                docs.put(shardRouting.shardId().id(), docsOnShard.stream(), +++ b/x-pack/plugin/ccr/src/test/java/org/elasticsearch/xpack/ccr/FollowerFailOverIT.java, +@TestLogging("org.elasticsearch.xpack.ccr:TRACE,org.elasticsearch.xpack.ccr.action.ShardChangesAction:DEBUG,", +    + "org.elasticsearch.index.shard:TRACE"), +        final String leaderIndex = "leader_test_failover";, +        final String followerIndex = "follower_test_failover";, +        assertAcked(leaderClient().admin().indices().prepareCreate(leaderIndex).setSource(leaderIndexSettings, XContentType.JSON));, +                        IndexResponse indexResponse = leaderClient().prepareIndex(leaderIndex, "doc", id), +                        logger.info("--> index {} id={} seq_no={}", leaderIndex, indexResponse.getId(), indexResponse.getSeqNo());, +                        DeleteResponse deleteResponse = leaderClient().prepareDelete(leaderIndex, "doc", id).get();, +                        logger.info("--> delete {} id={} seq_no={}", leaderIndex, deleteResponse.getId(), deleteResponse.getSeqNo());, +        PutFollowAction.Request follow = putFollow(leaderIndex, followerIndex);, +        disableDelayedAllocation(followerIndex);, +        ensureFollowerGreen(followerIndex);, +        awaitGlobalCheckpointAtLeast(followerClient(), new ShardId(resolveFollowerIndex(followerIndex), 0), between(30, 80));, +        for (ShardRouting shardRouting : clusterState.routingTable().allShards(followerIndex)) {, +        ensureFollowerGreen(followerIndex);, +        awaitGlobalCheckpointAtLeast(followerClient(), new ShardId(resolveFollowerIndex(followerIndex), 0), between(100, 150));, +        assertIndexFullyReplicatedToFollower(leaderIndex, followerIndex);, +        pauseFollow(followerIndex);]