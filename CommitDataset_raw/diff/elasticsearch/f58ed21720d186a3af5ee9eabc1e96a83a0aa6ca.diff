[+++ /dev/null, +++ /dev/null, +++ b/server/src/main/java/org/elasticsearch/action/bulk/BulkPrimaryExecutionContext.java, +/*, + * Licensed to Elasticsearch under one or more contributor, + * license agreements. See the NOTICE file distributed with, + * this work for additional information regarding copyright, + * ownership. Elasticsearch licenses this file to you under, + * the Apache License, Version 2.0 (the "License"); you may, + * not use this file except in compliance with the License., + * You may obtain a copy of the License at, + *, + *    http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing,, + * software distributed under the License is distributed on an, + * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY, + * KIND, either express or implied.  See the License for the, + * specific language governing permissions and limitations, + * under the License., + */, +, +package org.elasticsearch.action.bulk;, +, +import org.elasticsearch.action.DocWriteRequest;, +import org.elasticsearch.action.DocWriteResponse;, +import org.elasticsearch.action.delete.DeleteResponse;, +import org.elasticsearch.action.index.IndexResponse;, +import org.elasticsearch.action.support.replication.ReplicationResponse;, +import org.elasticsearch.action.support.replication.TransportWriteAction;, +import org.elasticsearch.index.engine.Engine;, +import org.elasticsearch.index.shard.IndexShard;, +import org.elasticsearch.index.translog.Translog;, +, +import java.util.Arrays;, +, +/**, + * This is a utility class that holds the per request state needed to perform bulk operations on the primary., + * More specifically, it maintains an index to the current executing bulk item, which allows execution, + * to stop and wait for external events such as mapping updates., + */, +class BulkPrimaryExecutionContext {, +, +    enum ItemProcessingState {, +        /** Item execution is ready to start, no operations have been performed yet */, +        INITIAL,, +        /**, +         * The incoming request has been translated to a request that can be executed on the shard., +         * This is used to convert update requests to a fully specified index or delete requests., +         */, +        TRANSLATED,, +        /**, +         * the request can not execute with the current mapping and should wait for a new mapping, +         * to arrive from the master. A mapping request for the needed changes has already been, +         * submitted, +         */, +        WAIT_FOR_MAPPING_UPDATE,, +        /**, +         * The request should be executed again, but there is no need to wait for an external event., +         * This is needed to support retry on conflicts during updates., +         */, +        IMMEDIATE_RETRY,, +        /** The request has been executed on the primary shard (successfully or not) */, +        EXECUTED,, +        /**, +         * No further handling of current request is needed. The result has been converted to a user response, +         * and execution can continue to the next item (if available)., +         */, +        COMPLETED, +    }, +, +    private final BulkShardRequest request;, +    private final IndexShard primary;, +    private Translog.Location locationToSync = null;, +    private int currentIndex = -1;, +, +    private ItemProcessingState currentItemState;, +    private DocWriteRequest requestToExecute;, +    private BulkItemResponse executionResult;, +    private int retryCounter;, +, +, +    BulkPrimaryExecutionContext(BulkShardRequest request, IndexShard primary) {, +        this.request = request;, +        this.primary = primary;, +        advance();, +    }, +, +, +    private int findNextNonAborted(int startIndex) {, +        final int length = request.items().length;, +        while (startIndex < length && isAborted(request.items()[startIndex].getPrimaryResponse())) {, +            startIndex++;, +        }, +        return startIndex;, +    }, +, +    private static boolean isAborted(BulkItemResponse response) {, +        return response != null && response.isFailed() && response.getFailure().isAborted();, +    }]