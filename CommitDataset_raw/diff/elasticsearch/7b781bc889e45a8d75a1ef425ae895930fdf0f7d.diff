[+++ b/server/src/main/java/org/elasticsearch/transport/TcpTransport.java, +    private static final TransportMessageListener NOOP_LISTENER = new TransportMessageListener() {};, +    private volatile TransportMessageListener messageListener = NOOP_LISTENER;, +    @Override, +    public synchronized void setMessageListener(TransportMessageListener listener) {, +        if (messageListener == NOOP_LISTENER) {, +            messageListener = listener;, +        } else {, +            throw new IllegalStateException("Cannot set message listener twice");, +++ b/server/src/main/java/org/elasticsearch/transport/TcpTransport.java, +    private static final TransportMessageListener NOOP_LISTENER = new TransportMessageListener() {};, +    private volatile TransportMessageListener messageListener = NOOP_LISTENER;, +    @Override, +    public synchronized void setMessageListener(TransportMessageListener listener) {, +        if (messageListener == NOOP_LISTENER) {, +            messageListener = listener;, +        } else {, +            throw new IllegalStateException("Cannot set message listener twice");, +++ b/server/src/main/java/org/elasticsearch/transport/Transport.java, +    void setMessageListener(TransportMessageListener listener);, +++ b/server/src/main/java/org/elasticsearch/transport/TcpTransport.java, +    private static final TransportMessageListener NOOP_LISTENER = new TransportMessageListener() {};, +    private volatile TransportMessageListener messageListener = NOOP_LISTENER;, +    @Override, +    public synchronized void setMessageListener(TransportMessageListener listener) {, +        if (messageListener == NOOP_LISTENER) {, +            messageListener = listener;, +        } else {, +            throw new IllegalStateException("Cannot set message listener twice");, +++ b/server/src/main/java/org/elasticsearch/transport/Transport.java, +    void setMessageListener(TransportMessageListener listener);, +++ b/server/src/main/java/org/elasticsearch/transport/TransportService.java, +import java.util.concurrent.CopyOnWriteArrayList;, +    private final DelegatingTransportMessageListener messageListener = new DelegatingTransportMessageListener();, +        transport.setMessageListener(this);, +    public void addMessageListener(TransportMessageListener listener) {, +        messageListener.listeners.add(listener);, +    }, +, +    public boolean removeMessageListener(TransportMessageListener listener) {, +        return messageListener.listeners.remove(listener);, +    }, +, +        if (tracerLog.isTraceEnabled() && shouldTraceAction(action)) {, +            tracerLog.trace("[{}][{}] received request", requestId, action);, +        messageListener.onRequestReceived(requestId, action);, +    /** called by the {@link Transport} implementation once a request has been sent */, +    @Override, +    public void onRequestSent(DiscoveryNode node, long requestId, String action, TransportRequest request,, +                              TransportRequestOptions options) {, +        if (tracerLog.isTraceEnabled() && shouldTraceAction(action)) {, +            tracerLog.trace("[{}][{}] sent to [{}] (timeout: [{}])", requestId, action, node, options.timeout());, +        messageListener.onRequestSent(node, requestId, action, request, options);, +    }, +        } else if (tracerLog.isTraceEnabled() && shouldTraceAction(holder.action())) {, +            tracerLog.trace("[{}][{}] received response from [{}]", requestId, holder.action(), holder.connection().getNode());, +        messageListener.onResponseReceived(requestId, holder);, +    }, +, +    /** called by the {@link Transport} implementation once a response was sent to calling node */, +    @Override, +    public void onResponseSent(long requestId, String action, TransportResponse response) {, +        if (tracerLog.isTraceEnabled() && shouldTraceAction(action)) {, +            tracerLog.trace("[{}][{}] sent response", requestId, action);, +        }, +        messageListener.onResponseSent(requestId, action, response);, +    }, +, +    /** called by the {@link Transport} implementation after an exception was sent as a response to an incoming request */, +    @Override, +    public void onResponseSent(long requestId, String action, Exception e) {, +        if (tracerLog.isTraceEnabled() && shouldTraceAction(action)) {, +            tracerLog.trace(() -> new ParameterizedMessage("[{}][{}] sent error response", requestId, action), e);, +        }, +        messageListener.onResponseSent(requestId, action, e);, +    }, +, +    public RequestHandlerRegistry<? extends TransportRequest> getRequestHandler(String action) {, +        return transport.getRequestHandler(action);, +        if (tracerLog.isTraceEnabled() == false) {, +            tracerLog.trace("[{}] received response but can't resolve it to a request", requestId);, +            tracerLog.trace("[{}][{}] received response from [{}]", requestId, action, sourceNode);, +, +    private static final class DelegatingTransportMessageListener implements TransportMessageListener {, +, +        private final List<TransportMessageListener> listeners = new CopyOnWriteArrayList<>();, +, +        @Override, +        public void onRequestReceived(long requestId, String action) {, +            for (TransportMessageListener listener : listeners) {, +                listener.onRequestReceived(requestId, action);, +            }, +        }, +, +        @Override, +        public void onResponseSent(long requestId, String action, TransportResponse response) {, +            for (TransportMessageListener listener : listeners) {, +                listener.onResponseSent(requestId, action, response);, +            }, +        }]