[+++ b/server/src/main/java/org/elasticsearch/cluster/action/shard/ShardStateAction.java, +import org.elasticsearch.cluster.ClusterStateTaskExecutor;, +import org.elasticsearch.common.util.concurrent.ConcurrentCollections;, +import java.util.Objects;, +import java.util.concurrent.ConcurrentMap;, +    // a list of shards that failed during replication, +    // we keep track of these shards in order to avoid sending duplicate failed shard requests for a single failing shard., +    private final ConcurrentMap<FailedShardEntry, CompositeListener> remoteFailedShardsCache = ConcurrentCollections.newConcurrentMap();, +, +        final FailedShardEntry shardEntry = new FailedShardEntry(shardId, allocationId, primaryTerm, message, failure, markAsStale);, +        final CompositeListener compositeListener = new CompositeListener(listener);, +        final CompositeListener existingListener = remoteFailedShardsCache.putIfAbsent(shardEntry, compositeListener);, +        if (existingListener == null) {, +            sendShardAction(SHARD_FAILED_ACTION_NAME, clusterService.state(), shardEntry, new Listener() {, +                @Override, +                public void onSuccess() {, +                    try {, +                        compositeListener.onSuccess();, +                    } finally {, +                        remoteFailedShardsCache.remove(shardEntry);, +                    }, +                }, +                @Override, +                public void onFailure(Exception e) {, +                    try {, +                        compositeListener.onFailure(e);, +                    } finally {, +                        remoteFailedShardsCache.remove(shardEntry);, +                    }, +                }, +            });, +        } else {, +            existingListener.addListener(listener);, +        }, +    }, +, +    int remoteShardFailedCacheSize() {, +        return remoteFailedShardsCache.size();, +, +        @Override, +        public boolean equals(Object o) {, +            if (this == o) return true;, +            if (o == null || getClass() != o.getClass()) return false;, +            FailedShardEntry that = (FailedShardEntry) o;, +            // Exclude message and exception from equals and hashCode, +            return Objects.equals(this.shardId, that.shardId) &&, +                Objects.equals(this.allocationId, that.allocationId) &&, +                primaryTerm == that.primaryTerm &&, +                markAsStale == that.markAsStale;, +        }, +, +        @Override, +        public int hashCode() {, +            return Objects.hash(shardId, allocationId, primaryTerm, markAsStale);, +        }, +    /**, +     * A composite listener that allows registering multiple listeners dynamically., +     */, +    static final class CompositeListener implements Listener {, +        private boolean isNotified = false;, +        private Exception failure = null;, +        private final List<Listener> listeners = new ArrayList<>();, +, +        CompositeListener(Listener listener) {, +            listeners.add(listener);, +        }, +, +        void addListener(Listener listener) {, +            final boolean ready;, +            synchronized (this) {, +                ready = this.isNotified;, +                if (ready == false) {, +                    listeners.add(listener);, +                }, +            }, +            if (ready) {, +                if (failure != null) {, +                    listener.onFailure(failure);, +                } else {, +                    listener.onSuccess();, +                }, +            }, +        }, +, +        private void onCompleted(Exception failure) {, +            synchronized (this) {, +                this.failure = failure;, +                this.isNotified = true;, +            }, +            RuntimeException firstException = null;, +            for (Listener listener : listeners) {, +                try {, +                    if (failure != null) {, +                        listener.onFailure(failure);, +                    } else {, +                        listener.onSuccess();, +                    }, +                } catch (RuntimeException innerEx) {, +                    if (firstException == null) {, +                        firstException = innerEx;]