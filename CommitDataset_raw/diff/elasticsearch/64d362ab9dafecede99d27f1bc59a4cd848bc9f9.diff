[+++ b/core/src/main/java/org/elasticsearch/search/sort/GeoDistanceSortBuilder.java, +    public static final String ALTERNATIVE_NAME = "_geoDistance";, +++ b/core/src/main/java/org/elasticsearch/search/sort/GeoDistanceSortBuilder.java, +    public static final String ALTERNATIVE_NAME = "_geoDistance";, +++ b/core/src/main/java/org/elasticsearch/search/sort/ScoreSortBuilder.java, +    public static final String NAME = "_score";, +    @Override, +++ b/core/src/main/java/org/elasticsearch/search/sort/GeoDistanceSortBuilder.java, +    public static final String ALTERNATIVE_NAME = "_geoDistance";, +++ b/core/src/main/java/org/elasticsearch/search/sort/ScoreSortBuilder.java, +    public static final String NAME = "_score";, +    @Override, +++ b/core/src/main/java/org/elasticsearch/search/sort/ScriptSortBuilder.java, +    public static final String NAME = "_script";, +++ b/core/src/main/java/org/elasticsearch/search/sort/GeoDistanceSortBuilder.java, +    public static final String ALTERNATIVE_NAME = "_geoDistance";, +++ b/core/src/main/java/org/elasticsearch/search/sort/ScoreSortBuilder.java, +    public static final String NAME = "_score";, +    @Override, +++ b/core/src/main/java/org/elasticsearch/search/sort/ScriptSortBuilder.java, +    public static final String NAME = "_script";, +++ b/core/src/main/java/org/elasticsearch/search/sort/SortBuilder.java, +import org.apache.lucene.search.Sort;, +import org.apache.lucene.search.SortField;, +import org.elasticsearch.common.xcontent.XContentParser;, +import org.elasticsearch.index.query.QueryParseContext;, +import org.elasticsearch.search.internal.SearchContext;, +import java.util.ArrayList;, +import java.util.HashMap;, +import java.util.List;, +import java.util.Map;, +import java.util.Optional;, +, +import static java.util.Collections.unmodifiableMap;, +public abstract class SortBuilder<T extends SortBuilder<?>> implements SortBuilderParser<T>, ToXContent {, +    private static final Map<String, SortBuilder<?>> PARSERS;, +, +    static {, +        Map<String, SortBuilder<?>> parsers = new HashMap<>();, +        parsers.put(ScriptSortBuilder.NAME, ScriptSortBuilder.PROTOTYPE);, +        parsers.put(GeoDistanceSortBuilder.NAME, new GeoDistanceSortBuilder("_na_", -1, -1));, +        parsers.put(GeoDistanceSortBuilder.ALTERNATIVE_NAME, new GeoDistanceSortBuilder("_na_", -1, -1));, +        parsers.put(ScoreSortBuilder.NAME, ScoreSortBuilder.PROTOTYPE);, +        PARSERS = unmodifiableMap(parsers);, +    }, +, +, +    public static List<SortBuilder<?>> fromXContent(QueryParseContext context) throws IOException {, +        List<SortBuilder<?>> sortFields = new ArrayList<>(2);, +        XContentParser parser = context.parser();, +        XContentParser.Token token = parser.currentToken();, +        if (token == XContentParser.Token.START_ARRAY) {, +            while ((token = parser.nextToken()) != XContentParser.Token.END_ARRAY) {, +                if (token == XContentParser.Token.START_OBJECT) {, +                    parseCompoundSortField(parser, context, sortFields);, +                } else if (token == XContentParser.Token.VALUE_STRING) {, +                    String fieldName = parser.text();, +                    if (fieldName.equals(ScoreSortBuilder.NAME)) {, +                        sortFields.add(new ScoreSortBuilder());, +                    } else {, +                        sortFields.add(new FieldSortBuilder(fieldName));, +                    }, +                } else {, +                    throw new IllegalArgumentException("malformed sort format, ", +                            + "within the sort array, an object, or an actual string are allowed");, +                }, +            }, +        } else if (token == XContentParser.Token.VALUE_STRING) {, +            String fieldName = parser.text();, +            if (fieldName.equals(ScoreSortBuilder.NAME)) {, +                sortFields.add(new ScoreSortBuilder());, +            } else {, +                sortFields.add(new FieldSortBuilder(fieldName));, +            }, +        } else if (token == XContentParser.Token.START_OBJECT) {, +            parseCompoundSortField(parser, context, sortFields);, +        } else {, +            throw new IllegalArgumentException("malformed sort format, either start with array, object, or an actual string");, +        }, +        return sortFields;, +    }, +, +    private static void parseCompoundSortField(XContentParser parser, QueryParseContext context, List<SortBuilder<?>> sortFields), +            throws IOException {, +        XContentParser.Token token;, +        while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {, +            if (token == XContentParser.Token.FIELD_NAME) {, +                String fieldName = parser.currentName();, +                token = parser.nextToken();, +                if (token == XContentParser.Token.VALUE_STRING) {, +                    SortOrder order = SortOrder.fromString(parser.text());, +                    if (fieldName.equals(ScoreSortBuilder.NAME)) {, +                        sortFields.add(new ScoreSortBuilder().order(order));, +                    } else {, +                        sortFields.add(new FieldSortBuilder(fieldName).order(order));, +                    }, +                } else {, +                    if (PARSERS.containsKey(fieldName)) {, +                        sortFields.add(PARSERS.get(fieldName).fromXContent(context, fieldName));, +                    } else {]