[+++ b/.gitignore, +, +++ b/.gitignore, +, +++ b/core/src/main/java/org/apache/lucene/queries/BlendedTermQuery.java, +import org.apache.lucene.util.ToStringUtils;, +    private final float[] boosts;, +    public BlendedTermQuery(Term[] terms, float[] boosts) {, +        if (boosts != null && boosts.length != terms.length) {, +            throw new IllegalArgumentException("boosts must have the same size as terms");, +        }, +        this.boosts = boosts;, +        StringBuilder builder = new StringBuilder("blended(terms:[");, +        for (int i = 0; i < terms.length; ++i) {, +            builder.append(terms[i]);, +            float boost = 1f;, +            if (boosts != null) {, +                boost = boosts[i];, +            }, +            builder.append(ToStringUtils.boost(boost));, +            builder.append(", ");, +        }, +        if (terms.length > 0) {, +            builder.setLength(builder.length() - 2);, +        }, +        builder.append("])");, +        builder.append(ToStringUtils.boost(getBoost()));, +        return builder.toString();, +        return new BlendedTermQuery(terms, boosts) {, +        return new BlendedTermQuery(terms, boosts) {, +        return new BlendedTermQuery(terms, boosts) {, +++ b/.gitignore, +, +++ b/core/src/main/java/org/apache/lucene/queries/BlendedTermQuery.java, +import org.apache.lucene.util.ToStringUtils;, +    private final float[] boosts;, +    public BlendedTermQuery(Term[] terms, float[] boosts) {, +        if (boosts != null && boosts.length != terms.length) {, +            throw new IllegalArgumentException("boosts must have the same size as terms");, +        }, +        this.boosts = boosts;, +        StringBuilder builder = new StringBuilder("blended(terms:[");, +        for (int i = 0; i < terms.length; ++i) {, +            builder.append(terms[i]);, +            float boost = 1f;, +            if (boosts != null) {, +                boost = boosts[i];, +            }, +            builder.append(ToStringUtils.boost(boost));, +            builder.append(", ");, +        }, +        if (terms.length > 0) {, +            builder.setLength(builder.length() - 2);, +        }, +        builder.append("])");, +        builder.append(ToStringUtils.boost(getBoost()));, +        return builder.toString();, +        return new BlendedTermQuery(terms, boosts) {, +        return new BlendedTermQuery(terms, boosts) {, +        return new BlendedTermQuery(terms, boosts) {, +++ b/core/src/main/java/org/elasticsearch/action/admin/cluster/health/TransportClusterHealthAction.java, +                    numberOfPendingTasks, numberOfInFlightFetch, UnassignedInfo.getNumberOfDelayedUnassigned(settings, clusterState),, +                numberOfInFlightFetch, UnassignedInfo.getNumberOfDelayedUnassigned(settings, clusterState), pendingTaskTimeInQueue);, +++ b/.gitignore, +, +++ b/core/src/main/java/org/apache/lucene/queries/BlendedTermQuery.java, +import org.apache.lucene.util.ToStringUtils;, +    private final float[] boosts;, +    public BlendedTermQuery(Term[] terms, float[] boosts) {, +        if (boosts != null && boosts.length != terms.length) {, +            throw new IllegalArgumentException("boosts must have the same size as terms");, +        }, +        this.boosts = boosts;, +        StringBuilder builder = new StringBuilder("blended(terms:[");, +        for (int i = 0; i < terms.length; ++i) {, +            builder.append(terms[i]);, +            float boost = 1f;, +            if (boosts != null) {, +                boost = boosts[i];, +            }, +            builder.append(ToStringUtils.boost(boost));, +            builder.append(", ");, +        }, +        if (terms.length > 0) {, +            builder.setLength(builder.length() - 2);, +        }, +        builder.append("])");, +        builder.append(ToStringUtils.boost(getBoost()));, +        return builder.toString();, +        return new BlendedTermQuery(terms, boosts) {, +        return new BlendedTermQuery(terms, boosts) {, +        return new BlendedTermQuery(terms, boosts) {, +++ b/core/src/main/java/org/elasticsearch/action/admin/cluster/health/TransportClusterHealthAction.java, +                    numberOfPendingTasks, numberOfInFlightFetch, UnassignedInfo.getNumberOfDelayedUnassigned(settings, clusterState),, +                numberOfInFlightFetch, UnassignedInfo.getNumberOfDelayedUnassigned(settings, clusterState), pendingTaskTimeInQueue);, +++ b/core/src/main/java/org/elasticsearch/bootstrap/JVMCheck.java, +            sb.append("Java version: ").append(Constants.JAVA_VERSION);, +            Loggers.getLogger(JVMCheck.class).warn("bypassing jvm version check for version [{}], this can result in data corruption!", Constants.JAVA_VERSION);, +                sb.append("Your version: " + Constants.JVM_VERSION);, +++ b/.gitignore]