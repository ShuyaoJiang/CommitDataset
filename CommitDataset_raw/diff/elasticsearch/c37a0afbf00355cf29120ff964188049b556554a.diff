[+++ b/modules/elasticsearch/src/main/java/org/elasticsearch/cluster/metadata/MetaDataDeleteIndexService.java, +import org.elasticsearch.cluster.ClusterStateUpdateTask;, +import org.elasticsearch.cluster.action.index.NodeIndexDeletedAction;, +import org.elasticsearch.cluster.routing.IndexShardRoutingTable;, +import org.elasticsearch.cluster.routing.ShardRouting;, +import org.elasticsearch.common.collect.Sets;, +import org.elasticsearch.common.timer.Timeout;, +import org.elasticsearch.common.timer.TimerTask;, +import org.elasticsearch.timer.TimerService;, +, +import java.util.Set;, +import java.util.concurrent.atomic.AtomicBoolean;, +import java.util.concurrent.atomic.AtomicInteger;, +    private final TimerService timerService;, +, +    private final NodeIndexDeletedAction nodeIndexDeletedAction;, +, +    @Inject public MetaDataDeleteIndexService(Settings settings, TimerService timerService, ClusterService clusterService, ShardsAllocation shardsAllocation,, +                                              NodeIndexDeletedAction nodeIndexDeletedAction) {, +        this.timerService = timerService;, +        this.nodeIndexDeletedAction = nodeIndexDeletedAction;, +    public void deleteIndex(final Request request, final Listener userListener) {, +        clusterService.submitStateUpdateTask("delete-index [" + request.index + "]", new ClusterStateUpdateTask() {, +                final DeleteIndexListener listener = new DeleteIndexListener(request, userListener);, +                    // initialize the counter only for nodes the shards are allocated to, +                    Set<String> allocatedNodes = Sets.newHashSet();, +                    for (IndexShardRoutingTable indexShardRoutingTable : currentState.routingTable().index(request.index)) {, +                        for (ShardRouting shardRouting : indexShardRoutingTable) {, +                            if (shardRouting.currentNodeId() != null) {, +                                allocatedNodes.add(shardRouting.currentNodeId());, +                            }, +                            if (shardRouting.relocatingNodeId() != null) {, +                                allocatedNodes.add(shardRouting.relocatingNodeId());, +                            }, +                        }, +                    }, +                    final AtomicInteger counter = new AtomicInteger(allocatedNodes.size());, +, +                    final NodeIndexDeletedAction.Listener nodeIndexDeleteListener = new NodeIndexDeletedAction.Listener() {, +                        @Override public void onNodeIndexDeleted(String index, String nodeId) {, +                            if (index.equals(request.index)) {, +                                if (counter.decrementAndGet() == 0) {, +                                    listener.onResponse(new Response(true));, +                                    nodeIndexDeletedAction.remove(this);, +                                }, +                            }, +                        }, +                    };, +                    nodeIndexDeletedAction.add(nodeIndexDeleteListener);, +, +                    Timeout timeoutTask = timerService.newTimeout(new TimerTask() {, +                        @Override public void run(Timeout timeout) throws Exception {, +                            listener.onResponse(new Response(false));, +                            nodeIndexDeletedAction.remove(nodeIndexDeleteListener);, +                        }, +                    }, request.timeout, TimerService.ExecutionType.THREADED);, +                    listener.timeout = timeoutTask;, +, +, +    class DeleteIndexListener implements Listener {, +, +        private AtomicBoolean notified = new AtomicBoolean();, +, +        private final Request request;, +, +        private final Listener listener;, +, +        volatile Timeout timeout;, +, +        private DeleteIndexListener(Request request, Listener listener) {, +            this.request = request;, +            this.listener = listener;, +        }, +, +        @Override public void onResponse(final Response response) {, +            if (notified.compareAndSet(false, true)) {, +                if (timeout != null) {, +                    timeout.cancel();, +                }, +                listener.onResponse(response);, +            }, +        }, +, +        @Override public void onFailure(Throwable t) {, +            if (notified.compareAndSet(false, true)) {, +                if (timeout != null) {, +                    timeout.cancel();, +                }, +                listener.onFailure(t);, +            }, +        }, +    }, +, +, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/cluster/metadata/MetaDataDeleteIndexService.java, +import org.elasticsearch.cluster.ClusterStateUpdateTask;, +import org.elasticsearch.cluster.action.index.NodeIndexDeletedAction;, +import org.elasticsearch.cluster.routing.IndexShardRoutingTable;, +import org.elasticsearch.cluster.routing.ShardRouting;, +import org.elasticsearch.common.collect.Sets;]