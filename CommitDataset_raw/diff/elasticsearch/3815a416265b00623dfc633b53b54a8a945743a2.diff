[+++ b/core/src/main/java/org/elasticsearch/discovery/DiscoverySettings.java, +    public static final String COMMIT_TIMEOUT = "discovery.zen.commit_timeout";, +    public static final TimeValue DEFAULT_COMMIT_TIMEOUT = TimeValue.timeValueSeconds(1);, +    private volatile TimeValue commitTimeout = DEFAULT_COMMIT_TIMEOUT;, +        this.commitTimeout = settings.getAsTime(PUBLISH_TIMEOUT, publishTimeout);, +    public TimeValue getCommitTimeout() {, +        return commitTimeout;, +    }, +, +++ b/core/src/main/java/org/elasticsearch/discovery/DiscoverySettings.java, +    public static final String COMMIT_TIMEOUT = "discovery.zen.commit_timeout";, +    public static final TimeValue DEFAULT_COMMIT_TIMEOUT = TimeValue.timeValueSeconds(1);, +    private volatile TimeValue commitTimeout = DEFAULT_COMMIT_TIMEOUT;, +        this.commitTimeout = settings.getAsTime(PUBLISH_TIMEOUT, publishTimeout);, +    public TimeValue getCommitTimeout() {, +        return commitTimeout;, +    }, +, +++ b/core/src/main/java/org/elasticsearch/discovery/zen/ZenDiscovery.java, +import org.elasticsearch.cluster.routing.RoutingNode;, +        this.publishClusterState = new PublishClusterStateAction(settings, transportService, this, new NewClusterStateListener(), discoverySettings, clusterName);, +        try {, +            publishClusterState.publish(clusterChangedEvent, electMaster.minimumMasterNodes(), ackListener);, +        } catch (PublishClusterStateAction.FailedToCommitException t) {, +            logger.warn("failed to publish [{}] (not enough nodes acknowledged, min master nodes [{}])", clusterChangedEvent.state().version(), electMaster.minimumMasterNodes());, +            clusterService.submitStateUpdateTask("zen-disco-failed-to-publish", Priority.IMMEDIATE, new ClusterStateUpdateTask() {, +                @Override, +                public ClusterState execute(ClusterState currentState) {, +                    return rejoin(currentState, "failed to publish to min_master_nodes");, +                }, +, +                @Override, +                public void onFailure(String source, Throwable t) {, +                    logger.error("unexpected failure during [{}]", t, source);, +                }, +, +            });, +            throw t;, +        }, +, +        rejectNewClusterStateIfNeeded(logger, currentState.nodes(), newClusterState);, +        if (currentState.nodes().masterNodeId() != null && newClusterState.version() < currentState.version()) {, +    /**, +     * In the case we follow an elected master the new cluster state needs to have the same elected master, +     * This method checks for this and throws an exception if needed, +     */, +, +    public static void rejectNewClusterStateIfNeeded(ESLogger logger, DiscoveryNodes currentNodes, ClusterState newClusterState) {, +        if (currentNodes.masterNodeId() == null) {, +            return;, +        }, +        if (!currentNodes.masterNodeId().equals(newClusterState.nodes().masterNodeId())) {, +            logger.warn("received a cluster state from a different master then the current one, rejecting (received {}, current {})", newClusterState.nodes().masterNode(), currentNodes.masterNode());, +            throw new IllegalStateException("cluster state from a different master then the current one, rejecting (received " + newClusterState.nodes().masterNode() + ", current " + currentNodes.masterNode() + ")");, +        }, +    }, +, +++ b/core/src/main/java/org/elasticsearch/discovery/DiscoverySettings.java, +    public static final String COMMIT_TIMEOUT = "discovery.zen.commit_timeout";, +    public static final TimeValue DEFAULT_COMMIT_TIMEOUT = TimeValue.timeValueSeconds(1);, +    private volatile TimeValue commitTimeout = DEFAULT_COMMIT_TIMEOUT;, +        this.commitTimeout = settings.getAsTime(PUBLISH_TIMEOUT, publishTimeout);, +    public TimeValue getCommitTimeout() {, +        return commitTimeout;, +    }, +, +++ b/core/src/main/java/org/elasticsearch/discovery/zen/ZenDiscovery.java, +import org.elasticsearch.cluster.routing.RoutingNode;, +        this.publishClusterState = new PublishClusterStateAction(settings, transportService, this, new NewClusterStateListener(), discoverySettings, clusterName);, +        try {, +            publishClusterState.publish(clusterChangedEvent, electMaster.minimumMasterNodes(), ackListener);, +        } catch (PublishClusterStateAction.FailedToCommitException t) {, +            logger.warn("failed to publish [{}] (not enough nodes acknowledged, min master nodes [{}])", clusterChangedEvent.state().version(), electMaster.minimumMasterNodes());, +            clusterService.submitStateUpdateTask("zen-disco-failed-to-publish", Priority.IMMEDIATE, new ClusterStateUpdateTask() {, +                @Override, +                public ClusterState execute(ClusterState currentState) {, +                    return rejoin(currentState, "failed to publish to min_master_nodes");, +                }, +, +                @Override, +                public void onFailure(String source, Throwable t) {, +                    logger.error("unexpected failure during [{}]", t, source);, +                }, +, +            });, +            throw t;, +        }, +, +        rejectNewClusterStateIfNeeded(logger, currentState.nodes(), newClusterState);, +        if (currentState.nodes().masterNodeId() != null && newClusterState.version() < currentState.version()) {, +    /**, +     * In the case we follow an elected master the new cluster state needs to have the same elected master, +     * This method checks for this and throws an exception if needed, +     */, +, +    public static void rejectNewClusterStateIfNeeded(ESLogger logger, DiscoveryNodes currentNodes, ClusterState newClusterState) {, +        if (currentNodes.masterNodeId() == null) {, +            return;, +        }, +        if (!currentNodes.masterNodeId().equals(newClusterState.nodes().masterNodeId())) {]