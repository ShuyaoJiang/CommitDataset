[+++ b/core/src/main/java/org/elasticsearch/search/query/QueryPhase.java, +, +import org.apache.lucene.index.LeafReaderContext;, +import org.apache.lucene.index.Term;, +        boolean rescore = execute(searchContext, searchContext.searcher());, +, +        if (rescore) { // only if we do a regular search, +            rescorePhase.execute(searchContext);, +        }, +        suggestPhase.execute(searchContext);, +        aggregationPhase.execute(searchContext);, +    }, +, +    /**, +     * In a package-private method so that it can be tested without having to, +     * wire everything (mapperService, etc.), +     * @return whether the rescoring phase should be executed, +     */, +    static boolean execute(SearchContext searchContext, final IndexSearcher searcher) throws QueryPhaseExecutionException {, +        QuerySearchResult queryResult = searchContext.queryResult();, +        queryResult.searchTimedOut(false);, +            queryResult.from(searchContext.from());, +            queryResult.size(searchContext.size());, +            Callable<TopDocs> topDocsCallable;, +            assert query == searcher.rewrite(query); // already rewritten, +            if (collector.getClass() == TotalHitCountCollector.class) {, +                // Optimize counts in simple cases to return in constant time, +                // instead of using a collector, +                while (true) {, +                    // remove wrappers that don't matter for counts, +                    // this is necessary so that we don't only optimize match_all, +                    // queries but also match_all queries that are nested in, +                    // a constant_score query, +                    if (query instanceof ConstantScoreQuery) {, +                        query = ((ConstantScoreQuery) query).getQuery();, +                    } else {, +                        break;, +                    }, +                }, +, +                if (query.getClass() == MatchAllDocsQuery.class) {, +                    collector = null;, +                    topDocsCallable = new Callable<TopDocs>() {, +                        @Override, +                        public TopDocs call() throws Exception {, +                            int count = searcher.getIndexReader().numDocs();, +                            return new TopDocs(count, Lucene.EMPTY_SCORE_DOCS, 0);, +                        }, +                    };, +                } else if (query.getClass() == TermQuery.class && searcher.getIndexReader().hasDeletions() == false) {, +                    final Term term = ((TermQuery) query).getTerm();, +                    collector = null;, +                    topDocsCallable = new Callable<TopDocs>() {, +                        @Override, +                        public TopDocs call() throws Exception {, +                            int count = 0;, +                            for (LeafReaderContext context : searcher.getIndexReader().leaves()) {, +                                count += context.reader().docFreq(term);, +                            }, +                            return new TopDocs(count, Lucene.EMPTY_SCORE_DOCS, 0);, +                        }, +                    };, +                }, +            }, +, +            if (timeoutSet && collector != null) { // collector might be null if no collection is actually needed, +                if (collector != null) {, +                    searcher.search(query, collector);, +                }, +                queryResult.searchTimedOut(true);, +                queryResult.terminatedEarly(true);, +            if (terminateAfterSet && queryResult.terminatedEarly() == null) {, +                queryResult.terminatedEarly(false);, +            queryResult.topDocs(topDocsCallable.call());, +, +            return rescore;, +++ b/core/src/main/java/org/elasticsearch/search/query/QueryPhase.java, +, +import org.apache.lucene.index.LeafReaderContext;, +import org.apache.lucene.index.Term;, +        boolean rescore = execute(searchContext, searchContext.searcher());, +, +        if (rescore) { // only if we do a regular search, +            rescorePhase.execute(searchContext);, +        }, +        suggestPhase.execute(searchContext);, +        aggregationPhase.execute(searchContext);, +    }, +, +    /**, +     * In a package-private method so that it can be tested without having to, +     * wire everything (mapperService, etc.), +     * @return whether the rescoring phase should be executed, +     */, +    static boolean execute(SearchContext searchContext, final IndexSearcher searcher) throws QueryPhaseExecutionException {, +        QuerySearchResult queryResult = searchContext.queryResult();, +        queryResult.searchTimedOut(false);, +            queryResult.from(searchContext.from());, +            queryResult.size(searchContext.size());, +            Callable<TopDocs> topDocsCallable;]