[+++ b/src/main/java/org/elasticsearch/index/mapper/MapperService.java, +            Filter filter = docMapper != null ? docMapper.typeFilter() : new TermFilter(new Term(types[0]));, +            if (hasNested) {, +                return new AndFilter(ImmutableList.of(filter, NonNestedDocsFilter.INSTANCE));, +            } else {, +                return filter;, +        // We only use terms filter is there is a type filter, this means we don't need to check for hasNested here, +            if (hasNested) {, +                bool.add(NonNestedDocsFilter.INSTANCE, BooleanClause.Occur.MUST);, +            }, +++ b/src/main/java/org/elasticsearch/index/mapper/MapperService.java, +            Filter filter = docMapper != null ? docMapper.typeFilter() : new TermFilter(new Term(types[0]));, +            if (hasNested) {, +                return new AndFilter(ImmutableList.of(filter, NonNestedDocsFilter.INSTANCE));, +            } else {, +                return filter;, +        // We only use terms filter is there is a type filter, this means we don't need to check for hasNested here, +            if (hasNested) {, +                bool.add(NonNestedDocsFilter.INSTANCE, BooleanClause.Occur.MUST);, +            }, +++ b/src/test/java/org/elasticsearch/indices/template/SimpleIndexTemplateTests.java, +        assertAcked(prepareCreate("test_index").addMapping("type1").addMapping("type2").addMapping("typeX").addMapping("typeY").addMapping("typeZ"));, +        ensureGreen();, +, +        assertAcked(prepareCreate("test_index").addMapping("type1").addMapping("type2"));, +        assertAcked(prepareCreate("test_index").addMapping("type1").addMapping("type2"));, +++ b/src/main/java/org/elasticsearch/index/mapper/MapperService.java, +            Filter filter = docMapper != null ? docMapper.typeFilter() : new TermFilter(new Term(types[0]));, +            if (hasNested) {, +                return new AndFilter(ImmutableList.of(filter, NonNestedDocsFilter.INSTANCE));, +            } else {, +                return filter;, +        // We only use terms filter is there is a type filter, this means we don't need to check for hasNested here, +            if (hasNested) {, +                bool.add(NonNestedDocsFilter.INSTANCE, BooleanClause.Occur.MUST);, +            }, +++ b/src/test/java/org/elasticsearch/indices/template/SimpleIndexTemplateTests.java, +        assertAcked(prepareCreate("test_index").addMapping("type1").addMapping("type2").addMapping("typeX").addMapping("typeY").addMapping("typeZ"));, +        ensureGreen();, +, +        assertAcked(prepareCreate("test_index").addMapping("type1").addMapping("type2"));, +        assertAcked(prepareCreate("test_index").addMapping("type1").addMapping("type2"));, +++ b/src/test/java/org/elasticsearch/nested/SimpleNestedTests.java, +        assertAcked(prepareCreate("test").addMapping("type1", "nested1", "type=nested").addMapping("type2", "nested1", "type=nested"));, +, +        searchResponse = client().prepareSearch("test").setTypes("type1", "type2").setQuery(nestedQuery("nested1", termQuery("nested1.n_field1", "n_value1_1"))).execute().actionGet();, +        assertNoFailures(searchResponse);, +        assertThat(searchResponse.getHits().totalHits(), equalTo(1l));, +++ b/src/main/java/org/elasticsearch/index/mapper/MapperService.java, +            Filter filter = docMapper != null ? docMapper.typeFilter() : new TermFilter(new Term(types[0]));, +            if (hasNested) {, +                return new AndFilter(ImmutableList.of(filter, NonNestedDocsFilter.INSTANCE));, +            } else {, +                return filter;, +        // We only use terms filter is there is a type filter, this means we don't need to check for hasNested here, +            if (hasNested) {, +                bool.add(NonNestedDocsFilter.INSTANCE, BooleanClause.Occur.MUST);, +            }, +++ b/src/test/java/org/elasticsearch/indices/template/SimpleIndexTemplateTests.java, +        assertAcked(prepareCreate("test_index").addMapping("type1").addMapping("type2").addMapping("typeX").addMapping("typeY").addMapping("typeZ"));, +        ensureGreen();, +, +        assertAcked(prepareCreate("test_index").addMapping("type1").addMapping("type2"));, +        assertAcked(prepareCreate("test_index").addMapping("type1").addMapping("type2"));, +++ b/src/test/java/org/elasticsearch/nested/SimpleNestedTests.java, +        assertAcked(prepareCreate("test").addMapping("type1", "nested1", "type=nested").addMapping("type2", "nested1", "type=nested"));, +, +        searchResponse = client().prepareSearch("test").setTypes("type1", "type2").setQuery(nestedQuery("nested1", termQuery("nested1.n_field1", "n_value1_1"))).execute().actionGet();, +        assertNoFailures(searchResponse);, +        assertThat(searchResponse.getHits().totalHits(), equalTo(1l));, +++ b/src/test/java/org/elasticsearch/search/aggregations/bucket/NestedTests.java, +        logger.info("AGG COLLECTION MODE: " + aggCollectionMode);, +++ b/src/main/java/org/elasticsearch/index/mapper/MapperService.java, +            Filter filter = docMapper != null ? docMapper.typeFilter() : new TermFilter(new Term(types[0]));, +            if (hasNested) {, +                return new AndFilter(ImmutableList.of(filter, NonNestedDocsFilter.INSTANCE));, +            } else {, +                return filter;, +        // We only use terms filter is there is a type filter, this means we don't need to check for hasNested here, +            if (hasNested) {, +                bool.add(NonNestedDocsFilter.INSTANCE, BooleanClause.Occur.MUST);, +            }, +++ b/src/test/java/org/elasticsearch/indices/template/SimpleIndexTemplateTests.java, +        assertAcked(prepareCreate("test_index").addMapping("type1").addMapping("type2").addMapping("typeX").addMapping("typeY").addMapping("typeZ"));, +        ensureGreen();, +, +        assertAcked(prepareCreate("test_index").addMapping("type1").addMapping("type2"));, +        assertAcked(prepareCreate("test_index").addMapping("type1").addMapping("type2"));, +++ b/src/test/java/org/elasticsearch/nested/SimpleNestedTests.java, +        assertAcked(prepareCreate("test").addMapping("type1", "nested1", "type=nested").addMapping("type2", "nested1", "type=nested"));, +, +        searchResponse = client().prepareSearch("test").setTypes("type1", "type2").setQuery(nestedQuery("nested1", termQuery("nested1.n_field1", "n_value1_1"))).execute().actionGet();, +        assertNoFailures(searchResponse);, +        assertThat(searchResponse.getHits().totalHits(), equalTo(1l));, +++ b/src/test/java/org/elasticsearch/search/aggregations/bucket/NestedTests.java, +        logger.info("AGG COLLECTION MODE: " + aggCollectionMode);, +++ b/src/test/java/org/elasticsearch/search/suggest/ContextSuggestSearchTests.java, +import org.elasticsearch.common.xcontent.XContentBuilder;, +        mapping.startObject("_type").field("index", "not_analyzed").endObject(); // Forcefully configure the _type field, since it can be randomized and if used as context it needs to be enabled, +++ b/src/main/java/org/elasticsearch/index/mapper/MapperService.java]