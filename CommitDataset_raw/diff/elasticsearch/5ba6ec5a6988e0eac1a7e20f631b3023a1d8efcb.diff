[+++ b/modules/elasticsearch/src/main/java/org/elasticsearch/index/engine/robin/RobinEngine.java, +                    // doc does not exists and no prior deletes, +                    delete.version(updatedVersion).notFound(true);, +                    Translog.Location translogLocation = translog.add(new Translog.Delete(delete));, +                    versionMap.put(delete.uid().text(), new VersionValue(updatedVersion, true, threadPool.estimatedTimeInMillis(), translogLocation));, +                    // a "delete on delete", in this case, we still increment the version, log it, and return that version, +                    delete.version(updatedVersion).notFound(true);, +                    Translog.Location translogLocation = translog.add(new Translog.Delete(delete));, +                    versionMap.put(delete.uid().text(), new VersionValue(updatedVersion, true, threadPool.estimatedTimeInMillis(), translogLocation));, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/index/engine/robin/RobinEngine.java, +                    // doc does not exists and no prior deletes, +                    delete.version(updatedVersion).notFound(true);, +                    Translog.Location translogLocation = translog.add(new Translog.Delete(delete));, +                    versionMap.put(delete.uid().text(), new VersionValue(updatedVersion, true, threadPool.estimatedTimeInMillis(), translogLocation));, +                    // a "delete on delete", in this case, we still increment the version, log it, and return that version, +                    delete.version(updatedVersion).notFound(true);, +                    Translog.Location translogLocation = translog.add(new Translog.Delete(delete));, +                    versionMap.put(delete.uid().text(), new VersionValue(updatedVersion, true, threadPool.estimatedTimeInMillis(), translogLocation));, +++ b/modules/test/integration/src/test/java/org/elasticsearch/test/integration/versioning/SimpleVersioningTests.java, +import org.elasticsearch.action.delete.DeleteResponse;, +, +        DeleteResponse deleteResponse = client2.prepareDelete("test", "type", "1").setVersion(17).setVersionType(VersionType.EXTERNAL).execute().actionGet();, +        assertThat(deleteResponse.notFound(), equalTo(false));, +        assertThat(deleteResponse.version(), equalTo(17l));, +, +        try {, +            client2.prepareDelete("test", "type", "1").setVersion(2).setVersionType(VersionType.EXTERNAL).execute().actionGet();, +        } catch (ElasticSearchException e) {, +            assertThat(e.unwrapCause(), instanceOf(VersionConflictEngineException.class));, +        }, +, +        deleteResponse = client2.prepareDelete("test", "type", "1").setVersion(18).setVersionType(VersionType.EXTERNAL).execute().actionGet();, +        assertThat(deleteResponse.notFound(), equalTo(true));, +        assertThat(deleteResponse.version(), equalTo(18l));, +, +        DeleteResponse deleteResponse = client2.prepareDelete("test", "type", "1").setVersion(2).execute().actionGet();, +        assertThat(deleteResponse.notFound(), equalTo(false));, +        assertThat(deleteResponse.version(), equalTo(3l));, +, +        try {, +            client2.prepareDelete("test", "type", "1").setVersion(2).execute().actionGet();, +        } catch (ElasticSearchException e) {, +            assertThat(e.unwrapCause(), instanceOf(VersionConflictEngineException.class));, +        }, +, +        deleteResponse = client2.prepareDelete("test", "type", "1").setVersion(3).execute().actionGet();, +        assertThat(deleteResponse.notFound(), equalTo(true));, +        assertThat(deleteResponse.version(), equalTo(4l));]