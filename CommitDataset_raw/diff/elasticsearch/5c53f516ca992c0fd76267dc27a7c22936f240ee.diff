[+++ b/core/src/main/java/org/elasticsearch/bootstrap/JarHell.java, +        final Map<String,Path> clazzes = new HashMap<>(32768);, +        Set<Path> seenJars = new HashSet<>();, +            final Path path = PathUtils.get(url.toURI());, +                try (JarFile file = new JarFile(path.toString())) {, +                            checkClass(clazzes, entry, path);, +                            checkClass(clazzes, entry, path);, +    static void checkClass(Map<String,Path> clazzes, String clazz, Path jarpath) {, +        Path previous = clazzes.put(clazz, jarpath);, +            if (previous.equals(jarpath)) {, +                        "exists multiple times in jar: " + jarpath + " !!!!!!!!!");, +                        "jar1: " + previous + System.lineSeparator() +, +                        "jar2: " + jarpath);, +++ b/core/src/main/java/org/elasticsearch/bootstrap/JarHell.java, +        final Map<String,Path> clazzes = new HashMap<>(32768);, +        Set<Path> seenJars = new HashSet<>();, +            final Path path = PathUtils.get(url.toURI());, +                try (JarFile file = new JarFile(path.toString())) {, +                            checkClass(clazzes, entry, path);, +                            checkClass(clazzes, entry, path);, +    static void checkClass(Map<String,Path> clazzes, String clazz, Path jarpath) {, +        Path previous = clazzes.put(clazz, jarpath);, +            if (previous.equals(jarpath)) {, +                        "exists multiple times in jar: " + jarpath + " !!!!!!!!!");, +                        "jar1: " + previous + System.lineSeparator() +, +                        "jar2: " + jarpath);, +++ b/core/src/main/java/org/elasticsearch/index/mapper/FieldMapper.java, +import com.carrotsearch.hppc.cursors.ObjectCursor;, +import com.carrotsearch.hppc.cursors.ObjectObjectCursor;, +import com.google.common.base.Function;, +import com.google.common.collect.ImmutableList;, +import com.google.common.collect.Iterators;, +import org.apache.lucene.document.Field;, +import org.apache.lucene.document.FieldType;, +import org.apache.lucene.index.IndexOptions;, +import org.elasticsearch.Version;, +import org.elasticsearch.common.Nullable;, +import org.elasticsearch.common.collect.ImmutableOpenMap;, +import org.elasticsearch.common.lucene.Lucene;, +import org.elasticsearch.common.settings.Settings;, +import org.elasticsearch.common.xcontent.XContentBuilder;, +import org.elasticsearch.index.analysis.NamedAnalyzer;, +import org.elasticsearch.index.fielddata.FieldDataType;, +import org.elasticsearch.index.mapper.core.TypeParsers;, +import org.elasticsearch.index.mapper.internal.AllFieldMapper;, +import org.elasticsearch.index.similarity.SimilarityLookupService;, +import org.elasticsearch.index.similarity.SimilarityProvider;, +import java.util.ArrayList;, +import java.util.Arrays;, +import java.util.Collections;, +import java.util.Comparator;, +import java.util.Iterator;, +import java.util.List;, +import java.util.Locale;, +    public abstract static class Builder<T extends Builder, Y extends FieldMapper> extends Mapper.Builder<T, Y> {, +, +        protected final MappedFieldType fieldType;, +        protected final MappedFieldType defaultFieldType;, +        private final IndexOptions defaultOptions;, +        protected boolean omitNormsSet = false;, +        protected String indexName;, +        protected Boolean includeInAll;, +        protected boolean indexOptionsSet = false;, +        protected boolean docValuesSet = false;, +        @Nullable, +        protected Settings fieldDataSettings;, +        protected final MultiFields.Builder multiFieldsBuilder;, +        protected CopyTo copyTo;, +, +        protected Builder(String name, MappedFieldType fieldType) {, +            super(name);, +            this.fieldType = fieldType.clone();, +            this.defaultFieldType = fieldType.clone();, +            this.defaultOptions = fieldType.indexOptions(); // we have to store it the fieldType is mutable, +            multiFieldsBuilder = new MultiFields.Builder();, +        public MappedFieldType fieldType() {, +            return fieldType;, +        }, +, +        public T index(boolean index) {, +            if (index) {, +                if (fieldType.indexOptions() == IndexOptions.NONE) {, +                    /*, +                     * the logic here is to reset to the default options only if we are not indexed ie. options are null, +                     * if the fieldType has a non-null option we are all good it might have been set through a different, +                     * call., +                     */, +                    final IndexOptions options = getDefaultIndexOption();, +                    assert options != IndexOptions.NONE : "default IndexOptions is NONE can't enable indexing";, +                    fieldType.setIndexOptions(options);, +                }, +            } else {, +                fieldType.setIndexOptions(IndexOptions.NONE);, +            }, +            return builder;, +        }, +, +        protected IndexOptions getDefaultIndexOption() {, +            return defaultOptions;, +        }]