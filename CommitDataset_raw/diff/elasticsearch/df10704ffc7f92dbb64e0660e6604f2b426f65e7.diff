[+++ b/server/src/main/java/org/elasticsearch/search/aggregations/bucket/histogram/DateHistogramAggregationBuilder.java, +import org.elasticsearch.common.joda.DateMathParser;, +import org.elasticsearch.common.joda.Joda;, +import java.util.Locale;, +    private static DateMathParser EPOCH_MILLIS_PARSER = new DateMathParser(Joda.forPattern("epoch_millis", Locale.ROOT));, +                    AtomicNumericFieldData leafFD = fieldData.load(ctx);, +                    if (ft.isFieldWithinQuery(reader, low, high, true, false, DateTimeZone.UTC, EPOCH_MILLIS_PARSER,, +                            context) == Relation.WITHIN) {, +++ b/server/src/main/java/org/elasticsearch/search/aggregations/bucket/histogram/DateHistogramAggregationBuilder.java, +import org.elasticsearch.common.joda.DateMathParser;, +import org.elasticsearch.common.joda.Joda;, +import java.util.Locale;, +    private static DateMathParser EPOCH_MILLIS_PARSER = new DateMathParser(Joda.forPattern("epoch_millis", Locale.ROOT));, +                    AtomicNumericFieldData leafFD = fieldData.load(ctx);, +                    if (ft.isFieldWithinQuery(reader, low, high, true, false, DateTimeZone.UTC, EPOCH_MILLIS_PARSER,, +                            context) == Relation.WITHIN) {, +++ b/server/src/test/java/org/elasticsearch/search/aggregations/bucket/DateHistogramIT.java, +import org.elasticsearch.search.aggregations.BucketOrder;, +     * https://github.com/elastic/elasticsearch/issues/31392 demonstrates an edge case where a date field mapping with, +     * "format" = "epoch_millis" can lead for the date histogram aggregation to throw an error if a non-UTC time zone, +     * with daylight savings time is used. This test was added to check this is working now, +     * @throws ExecutionException, +     * @throws InterruptedException, +     */, +    public void testRewriteTimeZone_EpochMillisFormat() throws InterruptedException, ExecutionException {, +        String index = "test31392";, +        assertAcked(client().admin().indices().prepareCreate(index).addMapping("type", "d", "type=date,format=epoch_millis").get());, +        indexRandom(true, client().prepareIndex(index, "type").setSource("d", "1477954800000"));, +        ensureSearchable(index);, +        SearchResponse response = client().prepareSearch(index).addAggregation(dateHistogram("histo").field("d"), +                .dateHistogramInterval(DateHistogramInterval.MONTH).timeZone(DateTimeZone.forID("Europe/Berlin"))).execute().actionGet();, +        assertSearchResponse(response);, +        Histogram histo = response.getAggregations().get("histo");, +        assertThat(histo.getBuckets().size(), equalTo(1));, +        assertThat(histo.getBuckets().get(0).getKeyAsString(), equalTo("1477954800000"));, +        assertThat(histo.getBuckets().get(0).getDocCount(), equalTo(1L));, +, +        response = client().prepareSearch(index).addAggregation(dateHistogram("histo").field("d"), +                .dateHistogramInterval(DateHistogramInterval.MONTH).timeZone(DateTimeZone.forID("Europe/Berlin")).format("yyyy-MM-dd")), +                .execute().actionGet();, +        assertSearchResponse(response);, +        histo = response.getAggregations().get("histo");, +        assertThat(histo.getBuckets().size(), equalTo(1));, +        assertThat(histo.getBuckets().get(0).getKeyAsString(), equalTo("2016-11-01"));, +        assertThat(histo.getBuckets().get(0).getDocCount(), equalTo(1L));, +, +        internalCluster().wipeIndices(index);, +    }, +, +    /**]