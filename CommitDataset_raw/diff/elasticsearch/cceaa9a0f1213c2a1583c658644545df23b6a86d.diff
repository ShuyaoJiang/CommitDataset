[+++ b/server/src/main/java/org/elasticsearch/cluster/AckedClusterStateTaskListener.java, +     * Called to determine which nodes the acknowledgement is expected from., +     *, +     * As this method will be called multiple times to determine the set of acking nodes,, +     * it is crucial for it to return consistent results: Given the same listener instance, +     * and the same node parameter, the method implementation should return the same result., +++ b/server/src/main/java/org/elasticsearch/cluster/AckedClusterStateTaskListener.java, +     * Called to determine which nodes the acknowledgement is expected from., +     *, +     * As this method will be called multiple times to determine the set of acking nodes,, +     * it is crucial for it to return consistent results: Given the same listener instance, +     * and the same node parameter, the method implementation should return the same result., +++ b/server/src/main/java/org/elasticsearch/cluster/AckedClusterStateUpdateTask.java, +        listener.onResponse(newResponse(e == null));, +++ b/server/src/main/java/org/elasticsearch/cluster/AckedClusterStateTaskListener.java, +     * Called to determine which nodes the acknowledgement is expected from., +     *, +     * As this method will be called multiple times to determine the set of acking nodes,, +     * it is crucial for it to return consistent results: Given the same listener instance, +     * and the same node parameter, the method implementation should return the same result., +++ b/server/src/main/java/org/elasticsearch/cluster/AckedClusterStateUpdateTask.java, +        listener.onResponse(newResponse(e == null));, +++ b/server/src/main/java/org/elasticsearch/cluster/metadata/MetaDataMappingService.java, +                        listener.onResponse(new ClusterStateUpdateResponse(e == null));, +++ b/server/src/main/java/org/elasticsearch/cluster/AckedClusterStateTaskListener.java, +     * Called to determine which nodes the acknowledgement is expected from., +     *, +     * As this method will be called multiple times to determine the set of acking nodes,, +     * it is crucial for it to return consistent results: Given the same listener instance, +     * and the same node parameter, the method implementation should return the same result., +++ b/server/src/main/java/org/elasticsearch/cluster/AckedClusterStateUpdateTask.java, +        listener.onResponse(newResponse(e == null));, +++ b/server/src/main/java/org/elasticsearch/cluster/metadata/MetaDataMappingService.java, +                        listener.onResponse(new ClusterStateUpdateResponse(e == null));, +++ b/server/src/main/java/org/elasticsearch/cluster/service/MasterService.java, +        private final DiscoveryNode masterNode;, +            this.masterNode = nodes.getMasterNode();, +                //we always wait for at least the master node, +                if (node.equals(masterNode) || ackedTaskListener.mustAck(node)) {, +            if (node.equals(masterNode) == false && ackedTaskListener.mustAck(node) == false) {, +++ b/server/src/main/java/org/elasticsearch/cluster/AckedClusterStateTaskListener.java, +     * Called to determine which nodes the acknowledgement is expected from., +     *, +     * As this method will be called multiple times to determine the set of acking nodes,, +     * it is crucial for it to return consistent results: Given the same listener instance, +     * and the same node parameter, the method implementation should return the same result., +++ b/server/src/main/java/org/elasticsearch/cluster/AckedClusterStateUpdateTask.java, +        listener.onResponse(newResponse(e == null));, +++ b/server/src/main/java/org/elasticsearch/cluster/metadata/MetaDataMappingService.java, +                        listener.onResponse(new ClusterStateUpdateResponse(e == null));, +++ b/server/src/main/java/org/elasticsearch/cluster/service/MasterService.java, +        private final DiscoveryNode masterNode;, +            this.masterNode = nodes.getMasterNode();, +                //we always wait for at least the master node, +                if (node.equals(masterNode) || ackedTaskListener.mustAck(node)) {, +            if (node.equals(masterNode) == false && ackedTaskListener.mustAck(node) == false) {, +++ b/server/src/test/java/org/elasticsearch/cluster/ack/AckClusterUpdateSettingsIT.java, +import org.elasticsearch.action.admin.indices.create.CreateIndexResponse;, +import org.elasticsearch.discovery.zen.PublishClusterStateAction;, +import org.elasticsearch.plugins.Plugin;, +import org.elasticsearch.test.transport.MockTransportService;, +import org.elasticsearch.transport.TransportService;, +, +import java.util.Arrays;, +import java.util.Collection;, +import java.util.stream.Stream;, +    protected Collection<Class<? extends Plugin>> nodePlugins() {, +        return Arrays.asList(MockTransportService.TestPlugin.class);, +    }, +, +    @Override, +, +    public void testAckingFailsIfNotPublishedToAllNodes() {, +        String masterNode = internalCluster().getMasterName();, +        String nonMasterNode = Stream.of(internalCluster().getNodeNames()), +            .filter(node -> node.equals(masterNode) == false).findFirst().get();, +, +        MockTransportService masterTransportService =, +            (MockTransportService) internalCluster().getInstance(TransportService.class, masterNode);, +        MockTransportService nonMasterTransportService =, +            (MockTransportService) internalCluster().getInstance(TransportService.class, nonMasterNode);, +, +        logger.info("blocking cluster state publishing from master [{}] to non master [{}]", masterNode, nonMasterNode);, +        if (randomBoolean() && internalCluster().numMasterNodes() != 2) {, +            masterTransportService.addFailToSendNoConnectRule(nonMasterTransportService, PublishClusterStateAction.SEND_ACTION_NAME);, +        } else {, +            masterTransportService.addFailToSendNoConnectRule(nonMasterTransportService, PublishClusterStateAction.COMMIT_ACTION_NAME);, +        }, +, +        CreateIndexResponse response = client().admin().indices().prepareCreate("test").get();, +        assertFalse(response.isAcknowledged());, +, +        logger.info("waiting for cluster to reform");, +        masterTransportService.clearRule(nonMasterTransportService);, +, +        ensureStableCluster(internalCluster().size());, +, +        assertAcked(client().admin().indices().prepareDelete("test"));, +    }]