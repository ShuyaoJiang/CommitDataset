[+++ b/src/main/java/org/elasticsearch/cluster/action/index/NodeIndexDeletedAction.java, +    public void nodeIndexDeleted(final ClusterState clusterState, final String index, final Settings indexSettings, final String nodeId) throws ElasticsearchException {, +                    lockIndexAndAck(index, nodes, nodeId, clusterState, indexSettings);, +                    lockIndexAndAck(index, nodes, nodeId, clusterState, indexSettings);, +    private void lockIndexAndAck(String index, DiscoveryNodes nodes, String nodeId, ClusterState clusterState, Settings indexSettings) throws IOException {, +            indicesService.processPendingDeletes(new Index(index), indexSettings, new TimeValue(30, TimeUnit.MINUTES));, +++ b/src/main/java/org/elasticsearch/cluster/action/index/NodeIndexDeletedAction.java, +    public void nodeIndexDeleted(final ClusterState clusterState, final String index, final Settings indexSettings, final String nodeId) throws ElasticsearchException {, +                    lockIndexAndAck(index, nodes, nodeId, clusterState, indexSettings);, +                    lockIndexAndAck(index, nodes, nodeId, clusterState, indexSettings);, +    private void lockIndexAndAck(String index, DiscoveryNodes nodes, String nodeId, ClusterState clusterState, Settings indexSettings) throws IOException {, +            indicesService.processPendingDeletes(new Index(index), indexSettings, new TimeValue(30, TimeUnit.MINUTES));, +++ b/src/main/java/org/elasticsearch/env/NodeEnvironment.java, +        final List<ShardLock> locks = lockAllForIndex(index, indexSettings, lockTimeoutMS);, +    public List<ShardLock> lockAllForIndex(Index index, @IndexSettings Settings settings, long lockTimeoutMS) throws IOException {, +        final Integer numShards = settings.getAsInt(IndexMetaData.SETTING_NUMBER_OF_SHARDS, null);, +        if (numShards == null || numShards <= 0) {, +            throw new IllegalArgumentException("settings must contain a non-null > 0 number of shards");, +        }, +        logger.trace("locking all shards for index {} - [{}]", index, numShards);, +        List<ShardLock> allLocks = new ArrayList<>(numShards);, +            for (int i = 0; i < numShards; i++) {, +                allLocks.add(shardLock(new ShardId(index, i), timeoutLeft));, +++ b/src/main/java/org/elasticsearch/cluster/action/index/NodeIndexDeletedAction.java, +    public void nodeIndexDeleted(final ClusterState clusterState, final String index, final Settings indexSettings, final String nodeId) throws ElasticsearchException {, +                    lockIndexAndAck(index, nodes, nodeId, clusterState, indexSettings);, +                    lockIndexAndAck(index, nodes, nodeId, clusterState, indexSettings);, +    private void lockIndexAndAck(String index, DiscoveryNodes nodes, String nodeId, ClusterState clusterState, Settings indexSettings) throws IOException {, +            indicesService.processPendingDeletes(new Index(index), indexSettings, new TimeValue(30, TimeUnit.MINUTES));, +++ b/src/main/java/org/elasticsearch/env/NodeEnvironment.java, +        final List<ShardLock> locks = lockAllForIndex(index, indexSettings, lockTimeoutMS);, +    public List<ShardLock> lockAllForIndex(Index index, @IndexSettings Settings settings, long lockTimeoutMS) throws IOException {, +        final Integer numShards = settings.getAsInt(IndexMetaData.SETTING_NUMBER_OF_SHARDS, null);, +        if (numShards == null || numShards <= 0) {, +            throw new IllegalArgumentException("settings must contain a non-null > 0 number of shards");, +        }, +        logger.trace("locking all shards for index {} - [{}]", index, numShards);, +        List<ShardLock> allLocks = new ArrayList<>(numShards);, +            for (int i = 0; i < numShards; i++) {, +                allLocks.add(shardLock(new ShardId(index, i), timeoutLeft));, +++ b/src/main/java/org/elasticsearch/indices/IndicesService.java, +    public void processPendingDeletes(Index index, @IndexSettings Settings indexSettings, TimeValue timeout) throws IOException {, +        final List<ShardLock> shardLocks = nodeEnv.lockAllForIndex(index, indexSettings, timeout.millis());, +++ b/src/main/java/org/elasticsearch/cluster/action/index/NodeIndexDeletedAction.java, +    public void nodeIndexDeleted(final ClusterState clusterState, final String index, final Settings indexSettings, final String nodeId) throws ElasticsearchException {, +                    lockIndexAndAck(index, nodes, nodeId, clusterState, indexSettings);, +                    lockIndexAndAck(index, nodes, nodeId, clusterState, indexSettings);, +    private void lockIndexAndAck(String index, DiscoveryNodes nodes, String nodeId, ClusterState clusterState, Settings indexSettings) throws IOException {, +            indicesService.processPendingDeletes(new Index(index), indexSettings, new TimeValue(30, TimeUnit.MINUTES));, +++ b/src/main/java/org/elasticsearch/env/NodeEnvironment.java, +        final List<ShardLock> locks = lockAllForIndex(index, indexSettings, lockTimeoutMS);, +    public List<ShardLock> lockAllForIndex(Index index, @IndexSettings Settings settings, long lockTimeoutMS) throws IOException {, +        final Integer numShards = settings.getAsInt(IndexMetaData.SETTING_NUMBER_OF_SHARDS, null);, +        if (numShards == null || numShards <= 0) {, +            throw new IllegalArgumentException("settings must contain a non-null > 0 number of shards");, +        }, +        logger.trace("locking all shards for index {} - [{}]", index, numShards);, +        List<ShardLock> allLocks = new ArrayList<>(numShards);, +            for (int i = 0; i < numShards; i++) {, +                allLocks.add(shardLock(new ShardId(index, i), timeoutLeft));, +++ b/src/main/java/org/elasticsearch/indices/IndicesService.java, +    public void processPendingDeletes(Index index, @IndexSettings Settings indexSettings, TimeValue timeout) throws IOException {, +        final List<ShardLock> shardLocks = nodeEnv.lockAllForIndex(index, indexSettings, timeout.millis());, +++ b/src/main/java/org/elasticsearch/indices/cluster/IndicesClusterStateService.java, +            final Settings indexSettings;, +            final IndexService idxService = indicesService.indexService(index);, +            if (idxService != null) {, +                indexSettings = idxService.getIndexSettings();, +                final IndexMetaData metaData = previousState.metaData().index(index);, +                indexSettings = metaData.settings();, +                nodeIndexDeletedAction.nodeIndexDeleted(event.state(), index, indexSettings, localNodeId);, +++ b/src/main/java/org/elasticsearch/cluster/action/index/NodeIndexDeletedAction.java, +    public void nodeIndexDeleted(final ClusterState clusterState, final String index, final Settings indexSettings, final String nodeId) throws ElasticsearchException {, +                    lockIndexAndAck(index, nodes, nodeId, clusterState, indexSettings);, +                    lockIndexAndAck(index, nodes, nodeId, clusterState, indexSettings);, +    private void lockIndexAndAck(String index, DiscoveryNodes nodes, String nodeId, ClusterState clusterState, Settings indexSettings) throws IOException {, +            indicesService.processPendingDeletes(new Index(index), indexSettings, new TimeValue(30, TimeUnit.MINUTES));, +++ b/src/main/java/org/elasticsearch/env/NodeEnvironment.java, +        final List<ShardLock> locks = lockAllForIndex(index, indexSettings, lockTimeoutMS);, +    public List<ShardLock> lockAllForIndex(Index index, @IndexSettings Settings settings, long lockTimeoutMS) throws IOException {, +        final Integer numShards = settings.getAsInt(IndexMetaData.SETTING_NUMBER_OF_SHARDS, null);, +        if (numShards == null || numShards <= 0) {, +            throw new IllegalArgumentException("settings must contain a non-null > 0 number of shards");, +        }, +        logger.trace("locking all shards for index {} - [{}]", index, numShards);, +        List<ShardLock> allLocks = new ArrayList<>(numShards);, +            for (int i = 0; i < numShards; i++) {, +                allLocks.add(shardLock(new ShardId(index, i), timeoutLeft));, +++ b/src/main/java/org/elasticsearch/indices/IndicesService.java, +    public void processPendingDeletes(Index index, @IndexSettings Settings indexSettings, TimeValue timeout) throws IOException {, +        final List<ShardLock> shardLocks = nodeEnv.lockAllForIndex(index, indexSettings, timeout.millis());, +++ b/src/main/java/org/elasticsearch/indices/cluster/IndicesClusterStateService.java, +            final Settings indexSettings;, +            final IndexService idxService = indicesService.indexService(index);, +            if (idxService != null) {, +                indexSettings = idxService.getIndexSettings();, +                final IndexMetaData metaData = previousState.metaData().index(index);, +                indexSettings = metaData.settings();, +                nodeIndexDeletedAction.nodeIndexDeleted(event.state(), index, indexSettings, localNodeId);, +++ b/src/test/java/org/elasticsearch/env/NodeEnvironmentTests.java]