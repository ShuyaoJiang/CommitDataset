[+++ b/src/main/java/org/elasticsearch/action/admin/indices/recovery/TransportRecoveryAction.java, +        RecoveryState state = indexShard.recoveryState();, +        if (state == null) {, +            state = recoveryTarget.recoveryState(indexShard);, +        if (state == null) {, +        ShardRecoveryRequest() {, +        }, +++ b/src/main/java/org/elasticsearch/action/admin/indices/recovery/TransportRecoveryAction.java, +        RecoveryState state = indexShard.recoveryState();, +        if (state == null) {, +            state = recoveryTarget.recoveryState(indexShard);, +        if (state == null) {, +        ShardRecoveryRequest() {, +        }, +++ b/src/main/java/org/elasticsearch/index/gateway/IndexShardGatewayService.java, +        this.recoveryState.setType(RecoveryState.Type.GATEWAY);, +++ b/src/main/java/org/elasticsearch/action/admin/indices/recovery/TransportRecoveryAction.java, +        RecoveryState state = indexShard.recoveryState();, +        if (state == null) {, +            state = recoveryTarget.recoveryState(indexShard);, +        if (state == null) {, +        ShardRecoveryRequest() {, +        }, +++ b/src/main/java/org/elasticsearch/index/gateway/IndexShardGatewayService.java, +        this.recoveryState.setType(RecoveryState.Type.GATEWAY);, +++ b/src/main/java/org/elasticsearch/index/shard/service/InternalIndexShard.java, +import org.elasticsearch.indices.recovery.RecoveryState;, +    @Nullable, +    private RecoveryState recoveryState;, +     * The peer recovery state if this shard recovered from a peer shard, null o.w., +    public RecoveryState recoveryState() {, +        return this.recoveryState;, +    public void performRecoveryFinalization(boolean withFlush, RecoveryState recoveryState) throws ElasticsearchException {, +        this.recoveryState = recoveryState;, +++ b/src/main/java/org/elasticsearch/action/admin/indices/recovery/TransportRecoveryAction.java, +        RecoveryState state = indexShard.recoveryState();, +        if (state == null) {, +            state = recoveryTarget.recoveryState(indexShard);, +        if (state == null) {, +        ShardRecoveryRequest() {, +        }, +++ b/src/main/java/org/elasticsearch/index/gateway/IndexShardGatewayService.java, +        this.recoveryState.setType(RecoveryState.Type.GATEWAY);, +++ b/src/main/java/org/elasticsearch/index/shard/service/InternalIndexShard.java, +import org.elasticsearch.indices.recovery.RecoveryState;, +    @Nullable, +    private RecoveryState recoveryState;, +     * The peer recovery state if this shard recovered from a peer shard, null o.w., +    public RecoveryState recoveryState() {, +        return this.recoveryState;, +    public void performRecoveryFinalization(boolean withFlush, RecoveryState recoveryState) throws ElasticsearchException {, +        this.recoveryState = recoveryState;, +++ b/src/main/java/org/elasticsearch/indices/cluster/IndicesClusterStateService.java, +import org.elasticsearch.indices.recovery.RecoveryFailedException;, +import org.elasticsearch.indices.recovery.RecoveryState;, +import org.elasticsearch.indices.recovery.RecoveryTarget;, +                    // closing the shard will also cancel any ongoing recovery., +                    RecoveryState recoveryState = recoveryTarget.recoveryState(indexShard);, +                    if (recoveryState != null && recoveryState.getStage() != RecoveryState.Stage.DONE) {, +                        if (!recoveryState.getSourceNode().equals(sourceNode)) {, +                            // closing the shard will also cancel any ongoing recovery., +                recoveryTarget.startRecovery(indexShard, type, sourceNode, new PeerRecoveryListener(shardRouting, indexService, indexMetaData));, +        private PeerRecoveryListener(ShardRouting shardRouting, IndexService indexService, IndexMetaData indexMetaData) {, +        public void onRecoveryDone(RecoveryState state) {, +            shardStateAction.shardStarted(shardRouting, indexMetaData.getUUID(), "after recovery (replica) from node [" + state.getSourceNode() + "]");, +        public void onRecoveryFailure(RecoveryState state, RecoveryFailedException e, boolean sendShardFailure) {, +                    logger.debug("[{}][{}] removing shard on failed recovery [{}]", shardRouting.index(), shardRouting.shardId().id(), failure.getMessage());, +                    logger.warn("[{}][{}] failed to delete shard after recovery failure", e1, indexService.index().name(), shardRouting.shardId().id());, +                logger.warn("[{}][{}] sending failed shard after recovery failure", failure, indexService.index().name(), shardRouting.shardId().id());, +++ b/src/main/java/org/elasticsearch/action/admin/indices/recovery/TransportRecoveryAction.java, +        RecoveryState state = indexShard.recoveryState();, +        if (state == null) {, +            state = recoveryTarget.recoveryState(indexShard);, +        if (state == null) {, +        ShardRecoveryRequest() {, +        }, +++ b/src/main/java/org/elasticsearch/index/gateway/IndexShardGatewayService.java, +        this.recoveryState.setType(RecoveryState.Type.GATEWAY);, +++ b/src/main/java/org/elasticsearch/index/shard/service/InternalIndexShard.java, +import org.elasticsearch.indices.recovery.RecoveryState;, +    @Nullable, +    private RecoveryState recoveryState;, +     * The peer recovery state if this shard recovered from a peer shard, null o.w., +    public RecoveryState recoveryState() {, +        return this.recoveryState;, +    public void performRecoveryFinalization(boolean withFlush, RecoveryState recoveryState) throws ElasticsearchException {, +        this.recoveryState = recoveryState;, +++ b/src/main/java/org/elasticsearch/indices/cluster/IndicesClusterStateService.java, +import org.elasticsearch.indices.recovery.RecoveryFailedException;, +import org.elasticsearch.indices.recovery.RecoveryState;, +import org.elasticsearch.indices.recovery.RecoveryTarget;, +                    // closing the shard will also cancel any ongoing recovery., +                    RecoveryState recoveryState = recoveryTarget.recoveryState(indexShard);, +                    if (recoveryState != null && recoveryState.getStage() != RecoveryState.Stage.DONE) {, +                        if (!recoveryState.getSourceNode().equals(sourceNode)) {, +                            // closing the shard will also cancel any ongoing recovery., +                recoveryTarget.startRecovery(indexShard, type, sourceNode, new PeerRecoveryListener(shardRouting, indexService, indexMetaData));, +        private PeerRecoveryListener(ShardRouting shardRouting, IndexService indexService, IndexMetaData indexMetaData) {, +        public void onRecoveryDone(RecoveryState state) {, +            shardStateAction.shardStarted(shardRouting, indexMetaData.getUUID(), "after recovery (replica) from node [" + state.getSourceNode() + "]");]