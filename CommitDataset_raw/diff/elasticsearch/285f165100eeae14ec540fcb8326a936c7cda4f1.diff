[+++ b/src/main/java/org/elasticsearch/cluster/settings/Validator.java, +import org.elasticsearch.common.Booleans;, +    public static final Validator BOOLEAN = new Validator() {, +        @Override, +        public String validate(String setting, String value) {, +, +            if (value != null && (Booleans.isExplicitFalse(value) || Booleans.isExplicitTrue(value))) {, +                return null;, +            }, +            return "cannot parse value [" + value + "] as a boolean";, +        }, +    };, +++ b/src/main/java/org/elasticsearch/cluster/settings/Validator.java, +import org.elasticsearch.common.Booleans;, +    public static final Validator BOOLEAN = new Validator() {, +        @Override, +        public String validate(String setting, String value) {, +, +            if (value != null && (Booleans.isExplicitFalse(value) || Booleans.isExplicitTrue(value))) {, +                return null;, +            }, +            return "cannot parse value [" + value + "] as a boolean";, +        }, +    };, +++ b/src/main/java/org/elasticsearch/index/settings/IndexDynamicSettingsModule.java, +        indexDynamicSettings.addDynamicSetting(RobinEngine.INDEX_COMPOUND_ON_FLUSH, Validator.BOOLEAN);, +++ b/src/main/java/org/elasticsearch/cluster/settings/Validator.java, +import org.elasticsearch.common.Booleans;, +    public static final Validator BOOLEAN = new Validator() {, +        @Override, +        public String validate(String setting, String value) {, +, +            if (value != null && (Booleans.isExplicitFalse(value) || Booleans.isExplicitTrue(value))) {, +                return null;, +            }, +            return "cannot parse value [" + value + "] as a boolean";, +        }, +    };, +++ b/src/main/java/org/elasticsearch/index/settings/IndexDynamicSettingsModule.java, +        indexDynamicSettings.addDynamicSetting(RobinEngine.INDEX_COMPOUND_ON_FLUSH, Validator.BOOLEAN);, +++ b/src/test/java/org/elasticsearch/index/engine/robin/RobinEngineIntegrationTest.java, +/*, + * Licensed to ElasticSearch and Shay Banon under one, + * or more contributor license agreements.  See the NOTICE file, + * distributed with this work for additional information, + * regarding copyright ownership. ElasticSearch licenses this, + * file to you under the Apache License, Version 2.0 (the, + * "License"); you may not use this file except in compliance, + * with the License.  You may obtain a copy of the License at, + *, + *    http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing,, + * software distributed under the License is distributed on an, + * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY, + * KIND, either express or implied.  See the License for the, + * specific language governing permissions and limitations, + * under the License., + */, +, +package org.elasticsearch.index.engine.robin;, +, +import org.elasticsearch.action.admin.indices.segments.IndexSegments;, +import org.elasticsearch.action.admin.indices.segments.IndexShardSegments;, +import org.elasticsearch.action.admin.indices.segments.IndicesSegmentResponse;, +import org.elasticsearch.action.admin.indices.segments.ShardSegments;, +import org.elasticsearch.common.settings.ImmutableSettings;, +import org.elasticsearch.index.engine.Segment;, +import org.elasticsearch.test.AbstractIntegrationTest;, +import org.hamcrest.Matchers;, +import org.junit.Test;, +, +import java.util.Collection;, +, +public class RobinEngineIntegrationTest extends AbstractIntegrationTest {, +, +    @Test, +    public void testSetIndexCompoundOnFlush() {, +        client().admin().indices().prepareCreate("test").setSettings(ImmutableSettings.builder().put("number_of_replicas", 0));, +        client().prepareIndex("test", "foo").setSource("field", "foo").get();, +        refresh();, +        assertTotalCompoundSegments(2, 2, "test");, +        client().admin().indices().prepareUpdateSettings("test"), +                .setSettings(ImmutableSettings.builder().put(RobinEngine.INDEX_COMPOUND_ON_FLUSH, false)).get();, +        client().prepareIndex("test", "foo").setSource("field", "foo").get();, +        refresh();, +        assertTotalCompoundSegments(2, 4, "test");, +        , +        client().admin().indices().prepareUpdateSettings("test"), +        .setSettings(ImmutableSettings.builder().put(RobinEngine.INDEX_COMPOUND_ON_FLUSH, true)).get();, +        client().prepareIndex("test", "foo").setSource("field", "foo").get();, +        refresh();, +        assertTotalCompoundSegments(4, 6, "test");, +, +    }, +, +    private void assertTotalCompoundSegments(int i, int t, String index) {, +        IndicesSegmentResponse indicesSegmentResponse = client().admin().indices().prepareSegments(index).get();, +        IndexSegments indexSegments = indicesSegmentResponse.getIndices().get(index);, +        Collection<IndexShardSegments> values = indexSegments.getShards().values();]