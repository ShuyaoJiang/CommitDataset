[+++ b/src/test/java/org/elasticsearch/search/aggregations/reducers/moving/avg/MovAvgTests.java, +import org.elasticsearch.search.aggregations.metrics.ValuesSourceMetricsAggregationBuilder;, +import static org.elasticsearch.search.aggregations.AggregationBuilders.*;, +import static org.elasticsearch.search.aggregations.reducers.ReducerBuilders.movingAvg;, +import static org.hamcrest.Matchers.*;, +    static long[] docValues;, +    static Double[] simpleDocCounts;, +    static Double[] linearDocCounts;, +    static Double[] singleDocCounts;, +    static Double[] doubleDocCounts;, +    static Double[] simpleDocValues;, +    static Double[] linearDocValues;, +    static Double[] singleDocValues;, +    static Double[] doubleDocValues;, +        gapPolicy = randomBoolean() ? BucketHelpers.GapPolicy.IGNORE : BucketHelpers.GapPolicy.INSERT_ZEROS;, +                , +        docValues = new long[numValueBuckets];, +            docValues[i] = randomIntBetween(1,20);    //this will be used as a constant for all values within a bucket, +                        .field(SINGLE_VALUED_VALUE_FIELD_NAME, docValues[i]).endObject()));, +        simpleDocCounts = new Double[numValueBuckets];, +            if (docCounts[i] == 0 && gapPolicy.equals(BucketHelpers.GapPolicy.IGNORE)) {, +                continue;, +            simpleDocCounts[i] = movAvg;, +        }, +, +        window.clear();, +        simpleDocValues = new Double[numValueBuckets];, +        for (int i = 0; i < numValueBuckets; i++) {, +            if (docCounts[i] == 0) {, +                // If there was a gap in doc counts and we are ignoring, just skip this bucket, +                if (gapPolicy.equals(BucketHelpers.GapPolicy.IGNORE)) {, +                    continue;, +                } else if (gapPolicy.equals(BucketHelpers.GapPolicy.INSERT_ZEROS)) {, +                    // otherwise insert a zero instead of the true value, +                    window.offer(0.0);, +                } else {, +                    window.offer((double) docValues[i]);, +                }, +            } else {, +                //if there are docs in this bucket, insert the regular value, +                window.offer((double) docValues[i]);, +            }, +, +            double movAvg = 0;, +            for (double value : window) {, +                movAvg += value;, +            }, +            movAvg /= window.size();, +, +            simpleDocValues[i] = movAvg;, +        linearDocCounts = new Double[numValueBuckets];, +            if (docCounts[i] == 0 && gapPolicy.equals(BucketHelpers.GapPolicy.IGNORE)) {, +                continue;, +            window.offer((double)docCounts[i]);, +            linearDocCounts[i] = avg / totalWeight;, +        linearDocValues = new Double[numValueBuckets];, +            if (docCounts[i] == 0) {, +                // If there was a gap in doc counts and we are ignoring, just skip this bucket, +                if (gapPolicy.equals(BucketHelpers.GapPolicy.IGNORE)) {, +                    continue;, +                } else if (gapPolicy.equals(BucketHelpers.GapPolicy.INSERT_ZEROS)) {, +                    // otherwise insert a zero instead of the true value, +                    window.offer(0.0);, +                } else {, +                    window.offer((double) docValues[i]);, +                }, +            } else {, +                //if there are docs in this bucket, insert the regular value, +                window.offer((double) docValues[i]);, +            }, +            linearDocValues[i] = avg / totalWeight;, +        singleDocCounts = new Double[numValueBuckets];, +            if (docCounts[i] == 0 && gapPolicy.equals(BucketHelpers.GapPolicy.IGNORE)) {, +                continue;, +            singleDocCounts[i] = avg ;, +        }, +, +        singleDocValues = new Double[numValueBuckets];, +        window.clear();, +, +        for (int i = 0; i < numValueBuckets; i++) {, +            if (docCounts[i] == 0) {, +                // If there was a gap in doc counts and we are ignoring, just skip this bucket, +                if (gapPolicy.equals(BucketHelpers.GapPolicy.IGNORE)) {, +                    continue;, +                } else if (gapPolicy.equals(BucketHelpers.GapPolicy.INSERT_ZEROS)) {, +                    // otherwise insert a zero instead of the true value, +                    window.offer(0.0);, +                } else {, +                    window.offer((double) docValues[i]);, +                }, +            } else {, +                //if there are docs in this bucket, insert the regular value, +                window.offer((double) docValues[i]);, +            }, +, +            double avg = 0;, +            double alpha = 0.5;, +            boolean first = true;, +]