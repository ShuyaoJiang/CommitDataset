[+++ b/core/src/main/java/org/elasticsearch/index/fielddata/ScriptDocValues.java, + * Script level doc values, the assumption is that any implementation will, + * implement a <code>getValue</code> and a <code>getValues</code> that return, + * the relevant type that then can be used in scripts., + * , + * Implementations should not internally re-use objects for the values that they, + * return as a single {@link ScriptDocValues} instance can be reused to return, + * values form multiple documents., +                dates[i] = new MutableDateTime(in.nextValue(), DateTimeZone.UTC);, +                    values[i] = new GeoPoint(point.lat(), point.lon());, +++ b/core/src/main/java/org/elasticsearch/index/fielddata/ScriptDocValues.java, + * Script level doc values, the assumption is that any implementation will, + * implement a <code>getValue</code> and a <code>getValues</code> that return, + * the relevant type that then can be used in scripts., + * , + * Implementations should not internally re-use objects for the values that they, + * return as a single {@link ScriptDocValues} instance can be reused to return, + * values form multiple documents., +                dates[i] = new MutableDateTime(in.nextValue(), DateTimeZone.UTC);, +                    values[i] = new GeoPoint(point.lat(), point.lon());, +++ b/core/src/main/java/org/elasticsearch/search/fetch/subphase/DocValueFieldsFetchSubPhase.java, +import org.apache.lucene.index.LeafReaderContext;, +import org.apache.lucene.index.ReaderUtil;, +import org.elasticsearch.search.SearchHit;, +import java.util.Arrays;, +    public void hitsExecute(SearchContext context, SearchHit[] hits) throws IOException {, +, +, +, +        hits = hits.clone(); // don't modify the incoming hits, +        Arrays.sort(hits, (a, b) -> Integer.compare(a.docId(), b.docId()));, +, +                LeafReaderContext subReaderContext = null;, +                AtomicFieldData data = null;, +                ScriptDocValues<?> values = null;, +                for (SearchHit hit : hits) {, +                    // if the reader index has changed we need to get a new doc values reader instance, +                    if (subReaderContext == null || hit.docId() >= subReaderContext.docBase + subReaderContext.reader().maxDoc()) {, +                        int readerIndex = ReaderUtil.subIndex(hit.docId(), context.searcher().getIndexReader().leaves());, +                        subReaderContext = context.searcher().getIndexReader().leaves().get(readerIndex);, +                        data = context.fieldData().getForField(fieldType).load(subReaderContext);, +                        values = data.getScriptValues();, +                    }, +                    int subDocId = hit.docId() - subReaderContext.docBase;, +                    values.setNextDocId(subDocId);, +                    if (hit.fieldsOrNull() == null) {, +                        hit.fields(new HashMap<>(2));, +                    }, +                    DocumentField hitField = hit.getFields().get(field);, +                    if (hitField == null) {, +                        hitField = new DocumentField(field, new ArrayList<>(2));, +                        hit.getFields().put(field, hitField);, +                    }, +}]