[+++ b/core/src/main/java/org/elasticsearch/index/mapper/object/DynamicTemplate.java, +        String type;, +        if (mapping.containsKey("type")) {, +            type = mapping.get("type").toString();, +            type = type.replace("{dynamic_type}", dynamicType);, +            type = type.replace("{dynamicType}", dynamicType);, +        } else {, +            type = dynamicType;, +        }, +        if (type.equals(mapping.get("type")) == false // either the type was not set, or we updated it through replacements, +                && "text".equals(type)) { // and the result is "text", +            // now that string has been splitted into text and keyword, we use text for, +            // dynamic mappings. However before it used to be possible to index as a keyword, +            // by setting index=not_analyzed, so for now we will use a keyword field rather, +            // than a text field if index=not_analyzed and the field type was not specified, +            // explicitly, +            // TODO: remove this in 6.0, +            // TODO: how to do it in the future?, +            final Object index = mapping.get("index");, +            if ("not_analyzed".equals(index) || "no".equals(index)) {, +                type = "keyword";, +            }, +        }, +        return type;, +++ b/core/src/main/java/org/elasticsearch/index/mapper/object/DynamicTemplate.java, +        String type;, +        if (mapping.containsKey("type")) {, +            type = mapping.get("type").toString();, +            type = type.replace("{dynamic_type}", dynamicType);, +            type = type.replace("{dynamicType}", dynamicType);, +        } else {, +            type = dynamicType;, +        }, +        if (type.equals(mapping.get("type")) == false // either the type was not set, or we updated it through replacements, +                && "text".equals(type)) { // and the result is "text", +            // now that string has been splitted into text and keyword, we use text for, +            // dynamic mappings. However before it used to be possible to index as a keyword, +            // by setting index=not_analyzed, so for now we will use a keyword field rather, +            // than a text field if index=not_analyzed and the field type was not specified, +            // explicitly, +            // TODO: remove this in 6.0, +            // TODO: how to do it in the future?, +            final Object index = mapping.get("index");, +            if ("not_analyzed".equals(index) || "no".equals(index)) {, +                type = "keyword";, +            }, +        }, +        return type;, +++ b/core/src/main/java/org/elasticsearch/indices/recovery/RecoveryTargetService.java, +            recoverySettings, ClusterService clusterService) {, +                    // which causes local mapping changes since the mapping (clusterstate) might not have arrived on this node., +                    // we want to wait until these mappings are processed but also need to do some maintenance and roll back the, +                    // number of processed (completed) operations in this batch to ensure accounting is correct., +                    final RecoveryState.Translog translog = recoveryTarget.state().getTranslog();, +                    translog.decrementRecoveredOperations(exception.completedOperations()); // do the maintainance and rollback competed ops, +++ b/core/src/main/java/org/elasticsearch/index/mapper/object/DynamicTemplate.java, +        String type;, +        if (mapping.containsKey("type")) {, +            type = mapping.get("type").toString();, +            type = type.replace("{dynamic_type}", dynamicType);, +            type = type.replace("{dynamicType}", dynamicType);, +        } else {, +            type = dynamicType;, +        }, +        if (type.equals(mapping.get("type")) == false // either the type was not set, or we updated it through replacements, +                && "text".equals(type)) { // and the result is "text", +            // now that string has been splitted into text and keyword, we use text for, +            // dynamic mappings. However before it used to be possible to index as a keyword, +            // by setting index=not_analyzed, so for now we will use a keyword field rather, +            // than a text field if index=not_analyzed and the field type was not specified, +            // explicitly, +            // TODO: remove this in 6.0, +            // TODO: how to do it in the future?, +            final Object index = mapping.get("index");, +            if ("not_analyzed".equals(index) || "no".equals(index)) {, +                type = "keyword";, +            }, +        }, +        return type;, +++ b/core/src/main/java/org/elasticsearch/indices/recovery/RecoveryTargetService.java, +            recoverySettings, ClusterService clusterService) {, +                    // which causes local mapping changes since the mapping (clusterstate) might not have arrived on this node., +                    // we want to wait until these mappings are processed but also need to do some maintenance and roll back the, +                    // number of processed (completed) operations in this batch to ensure accounting is correct., +                    final RecoveryState.Translog translog = recoveryTarget.state().getTranslog();, +                    translog.decrementRecoveredOperations(exception.completedOperations()); // do the maintainance and rollback competed ops, +++ b/core/src/test/java/org/elasticsearch/index/mapper/core/StringMappingUpgradeTests.java, +import org.elasticsearch.common.bytes.BytesReference;, +import org.elasticsearch.index.mapper.Mapper;, +import org.elasticsearch.index.mapper.ParsedDocument;, +, +    public void testUpgradeTemplateWithDynamicType() throws IOException {, +        IndexService indexService = createIndex("test");, +        DocumentMapperParser parser = indexService.mapperService().documentMapperParser();, +        String mapping = XContentFactory.jsonBuilder().startObject().startObject("type"), +                .startArray("dynamic_templates"), +                    .startObject(), +                        .startObject("my_template"), +                            .field("match_mapping_type", "string"), +                            .startObject("mapping")]