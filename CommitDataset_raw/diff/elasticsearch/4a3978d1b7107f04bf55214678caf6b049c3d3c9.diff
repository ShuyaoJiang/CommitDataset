[+++ b/src/main/java/org/elasticsearch/action/bulk/TransportShardBulkAction.java, +import org.elasticsearch.cluster.node.DiscoveryNode;, +            IndexMetaData metaData = clusterService.state().metaData().index(index);, +            if (metaData == null) {, +                return;, +            }, +, +            // we generate the order id before we get the mapping to send and refresh the source, so, +            // if 2 happen concurrently, we know that the later order will include the previous one, +            long orderId = mappingUpdatedAction.generateNextMappingUpdateOrder();, +            DiscoveryNode node = clusterService.localNode();, +            final MappingUpdatedAction.MappingUpdatedRequest request = new MappingUpdatedAction.MappingUpdatedRequest(index, metaData.uuid(), type, documentMapper.mappingSource(), orderId, node != null ? node.id() : null);, +++ b/src/main/java/org/elasticsearch/action/bulk/TransportShardBulkAction.java, +import org.elasticsearch.cluster.node.DiscoveryNode;, +            IndexMetaData metaData = clusterService.state().metaData().index(index);, +            if (metaData == null) {, +                return;, +            }, +, +            // we generate the order id before we get the mapping to send and refresh the source, so, +            // if 2 happen concurrently, we know that the later order will include the previous one, +            long orderId = mappingUpdatedAction.generateNextMappingUpdateOrder();, +            DiscoveryNode node = clusterService.localNode();, +            final MappingUpdatedAction.MappingUpdatedRequest request = new MappingUpdatedAction.MappingUpdatedRequest(index, metaData.uuid(), type, documentMapper.mappingSource(), orderId, node != null ? node.id() : null);, +++ b/src/main/java/org/elasticsearch/action/index/TransportIndexAction.java, +import org.elasticsearch.cluster.node.DiscoveryNode;, +            // we generate the order id before we get the mapping to send and refresh the source, so, +            // if 2 happen concurrently, we know that the later order will include the previous one, +            long orderId = mappingUpdatedAction.generateNextMappingUpdateOrder();, +            DiscoveryNode node = clusterService.localNode();, +                    new MappingUpdatedAction.MappingUpdatedRequest(request.index(), indexMetaData.uuid(), request.type(), documentMapper.mappingSource(), orderId, node != null ? node.id() : null);, +++ b/src/main/java/org/elasticsearch/action/bulk/TransportShardBulkAction.java, +import org.elasticsearch.cluster.node.DiscoveryNode;, +            IndexMetaData metaData = clusterService.state().metaData().index(index);, +            if (metaData == null) {, +                return;, +            }, +, +            // we generate the order id before we get the mapping to send and refresh the source, so, +            // if 2 happen concurrently, we know that the later order will include the previous one, +            long orderId = mappingUpdatedAction.generateNextMappingUpdateOrder();, +            DiscoveryNode node = clusterService.localNode();, +            final MappingUpdatedAction.MappingUpdatedRequest request = new MappingUpdatedAction.MappingUpdatedRequest(index, metaData.uuid(), type, documentMapper.mappingSource(), orderId, node != null ? node.id() : null);, +++ b/src/main/java/org/elasticsearch/action/index/TransportIndexAction.java, +import org.elasticsearch.cluster.node.DiscoveryNode;, +            // we generate the order id before we get the mapping to send and refresh the source, so, +            // if 2 happen concurrently, we know that the later order will include the previous one, +            long orderId = mappingUpdatedAction.generateNextMappingUpdateOrder();, +            DiscoveryNode node = clusterService.localNode();, +                    new MappingUpdatedAction.MappingUpdatedRequest(request.index(), indexMetaData.uuid(), request.type(), documentMapper.mappingSource(), orderId, node != null ? node.id() : null);, +++ b/src/main/java/org/elasticsearch/cluster/action/index/MappingUpdatedAction.java, +import java.util.concurrent.atomic.AtomicLong;, +    private final AtomicLong mappingUpdateOrderGen = new AtomicLong();, +    public long generateNextMappingUpdateOrder() {, +        return mappingUpdateOrderGen.incrementAndGet();, +    }, +, +        metaDataMappingService.updateMapping(request.index(), request.indexUUID(), request.type(), request.mappingSource(), request.order, request.nodeId, new ClusterStateUpdateListener() {, +        private long order = -1; // -1 means not set..., +        private String nodeId = null; // null means not set, +        public MappingUpdatedRequest(String index, String indexUUID, String type, CompressedString mappingSource, long order, String nodeId) {, +            this.order = order;, +            this.nodeId = nodeId;, +        /**, +         * Returns -1 if not set..., +         */, +        public long order() {, +            return this.order;, +        }, +, +        /**, +         * Returns null for not set., +         */, +        public String nodeId() {, +            return this.nodeId;, +        }, +, +            if (in.getVersion().after(Version.V_0_90_7)) {, +                order = in.readLong();, +                nodeId = in.readOptionalString();, +            }, +            if (out.getVersion().after(Version.V_0_90_7)) {, +                out.writeLong(order);, +                out.writeOptionalString(nodeId);, +            }, +++ b/src/main/java/org/elasticsearch/action/bulk/TransportShardBulkAction.java, +import org.elasticsearch.cluster.node.DiscoveryNode;, +            IndexMetaData metaData = clusterService.state().metaData().index(index);, +            if (metaData == null) {, +                return;, +            }, +, +            // we generate the order id before we get the mapping to send and refresh the source, so, +            // if 2 happen concurrently, we know that the later order will include the previous one, +            long orderId = mappingUpdatedAction.generateNextMappingUpdateOrder();, +            DiscoveryNode node = clusterService.localNode();, +            final MappingUpdatedAction.MappingUpdatedRequest request = new MappingUpdatedAction.MappingUpdatedRequest(index, metaData.uuid(), type, documentMapper.mappingSource(), orderId, node != null ? node.id() : null);, +++ b/src/main/java/org/elasticsearch/action/index/TransportIndexAction.java, +import org.elasticsearch.cluster.node.DiscoveryNode;, +            // we generate the order id before we get the mapping to send and refresh the source, so]