[+++ b/core/src/main/java/org/elasticsearch/action/search/InitialSearchPhase.java, +    private final AtomicInteger shardExecutionIndex = new AtomicInteger(0);, +    private final int maxConcurrentShardRequests;, +        maxConcurrentShardRequests = Math.min(request.getMaxConcurrentShardRequests(), shardsIts.size());, +                maybeExecuteNext(); // move to the next execution if needed, +        boolean success = shardExecutionIndex.compareAndSet(0, maxConcurrentShardRequests);, +        assert success;, +        for (int i = 0; i < maxConcurrentShardRequests; i++) {, +            SearchShardIterator shardRoutings = shardsIts.get(i);, +            performPhaseOnShard(i, shardRoutings, shardRoutings.nextOrNull());, +    private void maybeExecuteNext() {, +        final int index = shardExecutionIndex.getAndIncrement();, +        if (index < shardsIts.size()) {, +            SearchShardIterator shardRoutings = shardsIts.get(index);, +            performPhaseOnShard(index, shardRoutings, shardRoutings.nextOrNull());, +        }, +    }, +, +, +        maybeExecuteNext();, +++ b/core/src/main/java/org/elasticsearch/action/search/InitialSearchPhase.java, +    private final AtomicInteger shardExecutionIndex = new AtomicInteger(0);, +    private final int maxConcurrentShardRequests;, +        maxConcurrentShardRequests = Math.min(request.getMaxConcurrentShardRequests(), shardsIts.size());, +                maybeExecuteNext(); // move to the next execution if needed, +        boolean success = shardExecutionIndex.compareAndSet(0, maxConcurrentShardRequests);, +        assert success;, +        for (int i = 0; i < maxConcurrentShardRequests; i++) {, +            SearchShardIterator shardRoutings = shardsIts.get(i);, +            performPhaseOnShard(i, shardRoutings, shardRoutings.nextOrNull());, +    private void maybeExecuteNext() {, +        final int index = shardExecutionIndex.getAndIncrement();, +        if (index < shardsIts.size()) {, +            SearchShardIterator shardRoutings = shardsIts.get(index);, +            performPhaseOnShard(index, shardRoutings, shardRoutings.nextOrNull());, +        }, +    }, +, +, +        maybeExecuteNext();, +++ b/core/src/main/java/org/elasticsearch/action/search/SearchRequest.java, +import org.elasticsearch.Version;, +    private int maxConcurrentShardRequests = 0;, +, +     * Returns the number of shard requests that should be executed concurrently. This value should be used as a protection mechanism to, +     * reduce the number of shard reqeusts fired per high level search request. Searches that hit the entire cluster can be throttled, +     * with this number to reduce the cluster load. The default grows with the number of nodes in the cluster but is at most <tt>256</tt>., +     */, +    public int getMaxConcurrentShardRequests() {, +        return maxConcurrentShardRequests == 0 ? 256 : maxConcurrentShardRequests;, +    }, +, +    /**, +     * Sets the number of shard requests that should be executed concurrently. This value should be used as a protection mechanism to, +     * reduce the number of shard requests fired per high level search request. Searches that hit the entire cluster can be throttled, +     * with this number to reduce the cluster load. The default grows with the number of nodes in the cluster but is at most <tt>256</tt>., +     */, +    public void setMaxConcurrentShardRequests(int maxConcurrentShardRequests) {, +        if (maxConcurrentShardRequests < 1) {, +            throw new IllegalArgumentException("maxConcurrentShardRequests must be >= 1");, +        }, +        this.maxConcurrentShardRequests = maxConcurrentShardRequests;, +    }, +, +    /**, +     * Returns <code>true</code> iff the maxConcurrentShardRequest is set., +     */, +    boolean isMaxConcurrentShardRequestsSet() {, +        return maxConcurrentShardRequests != 0;, +    }, +, +    /**, +        if (in.getVersion().onOrAfter(Version.V_6_0_0_beta1)) {, +            maxConcurrentShardRequests = in.readVInt();, +        }, +        if (out.getVersion().onOrAfter(Version.V_6_0_0_beta1)) {, +            out.writeVInt(maxConcurrentShardRequests);, +        }, +                Objects.equals(batchedReduceSize, that.batchedReduceSize) &&, +                Objects.equals(maxConcurrentShardRequests, that.maxConcurrentShardRequests) &&, +                scroll, Arrays.hashCode(types), indicesOptions, maxConcurrentShardRequests);, +                ", maxConcurrentShardRequests=" + maxConcurrentShardRequests +, +                ", batchedReduceSize=" + batchedReduceSize +, +++ b/core/src/main/java/org/elasticsearch/action/search/InitialSearchPhase.java, +    private final AtomicInteger shardExecutionIndex = new AtomicInteger(0);, +    private final int maxConcurrentShardRequests;, +        maxConcurrentShardRequests = Math.min(request.getMaxConcurrentShardRequests(), shardsIts.size());, +                maybeExecuteNext(); // move to the next execution if needed, +        boolean success = shardExecutionIndex.compareAndSet(0, maxConcurrentShardRequests);, +        assert success;, +        for (int i = 0; i < maxConcurrentShardRequests; i++) {, +            SearchShardIterator shardRoutings = shardsIts.get(i);, +            performPhaseOnShard(i, shardRoutings, shardRoutings.nextOrNull());, +    private void maybeExecuteNext() {, +        final int index = shardExecutionIndex.getAndIncrement();, +        if (index < shardsIts.size()) {, +            SearchShardIterator shardRoutings = shardsIts.get(index);, +            performPhaseOnShard(index, shardRoutings, shardRoutings.nextOrNull());, +        }, +    }]