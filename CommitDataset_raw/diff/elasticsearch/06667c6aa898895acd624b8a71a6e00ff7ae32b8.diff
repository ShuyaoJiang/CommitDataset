[+++ b/src/main/java/org/elasticsearch/common/geo/GeoPoint.java, +import com.vividsolutions.jts.geom.Coordinate;, +, +public final class GeoPoint extends Coordinate {, +    public GeoPoint(GeoPoint other) {, +        super(other);, +    }, +, +        this.y = lat;, +        this.x = lon;, +        this.y = lat;, +        this.x = lon;, +        this.y = lat;, +        this.x = lon;, +            this.y = Double.parseDouble(value.substring(0, comma).trim());, +            this.x = Double.parseDouble(value.substring(comma + 1).trim());, +        return this.y;, +        return this.y;, +        return this.x;, +        return this.x;, +        return GeoHashUtils.encode(y, x);, +        return GeoHashUtils.encode(y, x);, +        if (o == null) return false;, +        if (o instanceof Coordinate) {, +            Coordinate c = (Coordinate)o;, +            return Double.compare(c.x, this.x) == 0, +                    && Double.compare(c.y, this.y) == 0, +                    && Double.compare(c.z, this.z) == 0;, +        }, +        if (getClass() != o.getClass()) return false;, +        temp = y != +0.0d ? Double.doubleToLongBits(y) : 0L;, +        temp = x != +0.0d ? Double.doubleToLongBits(x) : 0L;, +        return "[" + y + ", " + x + "]";, +++ b/src/main/java/org/elasticsearch/common/geo/GeoPoint.java, +import com.vividsolutions.jts.geom.Coordinate;, +, +public final class GeoPoint extends Coordinate {, +    public GeoPoint(GeoPoint other) {, +        super(other);, +    }, +, +        this.y = lat;, +        this.x = lon;, +        this.y = lat;, +        this.x = lon;, +        this.y = lat;, +        this.x = lon;, +            this.y = Double.parseDouble(value.substring(0, comma).trim());, +            this.x = Double.parseDouble(value.substring(comma + 1).trim());, +        return this.y;, +        return this.y;, +        return this.x;, +        return this.x;, +        return GeoHashUtils.encode(y, x);, +        return GeoHashUtils.encode(y, x);, +        if (o == null) return false;, +        if (o instanceof Coordinate) {, +            Coordinate c = (Coordinate)o;, +            return Double.compare(c.x, this.x) == 0, +                    && Double.compare(c.y, this.y) == 0, +                    && Double.compare(c.z, this.z) == 0;, +        }, +        if (getClass() != o.getClass()) return false;, +        temp = y != +0.0d ? Double.doubleToLongBits(y) : 0L;, +        temp = x != +0.0d ? Double.doubleToLongBits(x) : 0L;, +        return "[" + y + ", " + x + "]";, +++ b/src/main/java/org/elasticsearch/common/geo/GeoUtils.java, +import org.apache.commons.lang3.tuple.Pair;, +    public static final double DATELINE = 180.0D;, +, +    public static boolean correctPolyAmbiguity(GeoPoint[] points, boolean handedness) {, +        return correctPolyAmbiguity(points, handedness, computePolyOrientation(points), 0, points.length, false);, +    }, +, +    public static boolean correctPolyAmbiguity(GeoPoint[] points, boolean handedness, boolean orientation, int component, int length,, +                                               boolean shellCorrected) {, +        // OGC requires shell as ccw (Right-Handedness) and holes as cw (Left-Handedness), +        // since GeoJSON doesn't specify (and doesn't need to) GEO core will assume OGC standards, +        // thus if orientation is computed as cw, the logic will translate points across dateline, +        // and convert to a right handed system, +, +        // compute the bounding box and calculate range, +        Pair<Pair, Pair> range = GeoUtils.computeBBox(points, length);, +        final double rng = (Double)range.getLeft().getRight() - (Double)range.getLeft().getLeft();, +        // translate the points if the following is true, +        //   1.  shell orientation is cw and range is greater than a hemisphere (180 degrees) but not spanning 2 hemispheres, +        //       (translation would result in a collapsed poly), +        //   2.  the shell of the candidate hole has been translated (to preserve the coordinate system), +        boolean incorrectOrientation = component == 0 && handedness != orientation;, +        boolean translated = ((incorrectOrientation && (rng > DATELINE && rng != 360.0)) || (shellCorrected && component != 0));, +        if (translated) {, +            for (GeoPoint c : points) {, +                if (c.x < 0.0) {, +                    c.x += 360.0;, +                }, +            }, +        }, +        return translated;, +    }, +]