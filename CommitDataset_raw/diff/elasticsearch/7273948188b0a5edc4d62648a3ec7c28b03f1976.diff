[+++ b/core/src/main/java/org/elasticsearch/index/mapper/DocumentParser.java, +            context = nestedContext(context, mapper);, +        update = innerParseObject(context, mapper, parser, currentFieldName, token, update);, +        // restore the enable path flag, +        if (nested.isNested()) {, +            nested(context, nested);, +        }, +        return update;, +    }, +, +    private static ObjectMapper innerParseObject(ParseContext context, ObjectMapper mapper, XContentParser parser, String currentFieldName, XContentParser.Token token, ObjectMapper update) throws IOException {, +        return update;, +    }, +, +    private static void nested(ParseContext context, ObjectMapper.Nested nested) {, +            addFields(nestedDoc, parentDoc);, +                addFields(nestedDoc, rootDoc);, +            }, +        }, +    }, +, +    private static void addFields(ParseContext.Document nestedDoc, ParseContext.Document rootDoc) {, +            if (!field.name().equals(UidFieldMapper.NAME) && !field.name().equals(TypeFieldMapper.NAME)) {, +, +    private static ParseContext nestedContext(ParseContext context, ObjectMapper mapper) {, +        context = context.createNestedContext(mapper.fullPath());, +        ParseContext.Document nestedDoc = context.doc();, +        ParseContext.Document parentDoc = nestedDoc.getParent();, +        // pre add the uid field if possible (id was already provided), +        IndexableField uidField = parentDoc.getField(UidFieldMapper.NAME);, +        if (uidField != null) {, +            // we don't need to add it as a full uid field in nested docs, since we don't need versioning, +            // we also rely on this for UidField#loadVersion, +, +            // this is a deeply nested field, +            nestedDoc.add(new Field(UidFieldMapper.NAME, uidField.stringValue(), UidFieldMapper.Defaults.NESTED_FIELD_TYPE));, +        // the type of the nested doc starts with __, so we can identify that its a nested one in filters, +        // note, we don't prefix it with the type of the doc since it allows us to execute a nested query, +        // across types (for example, with similar nested objects), +        nestedDoc.add(new Field(TypeFieldMapper.NAME, mapper.nestedTypePathAsString(), TypeFieldMapper.Defaults.FIELD_TYPE));, +        return context;]