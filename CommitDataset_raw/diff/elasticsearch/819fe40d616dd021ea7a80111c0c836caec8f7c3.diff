[+++ b/core/src/main/java/org/elasticsearch/common/bytes/BytesArray.java, +public final class BytesArray implements BytesReference {, +++ b/core/src/main/java/org/elasticsearch/common/bytes/BytesArray.java, +public final class BytesArray implements BytesReference {, +++ b/core/src/main/java/org/elasticsearch/common/bytes/BytesReference.java, +            BytesRef ref = length() == 0 ? null : toBytesRef();, +++ b/core/src/main/java/org/elasticsearch/common/bytes/BytesArray.java, +public final class BytesArray implements BytesReference {, +++ b/core/src/main/java/org/elasticsearch/common/bytes/BytesReference.java, +            BytesRef ref = length() == 0 ? null : toBytesRef();, +++ b/core/src/main/java/org/elasticsearch/common/bytes/PagedBytesReference.java, +            return (pos < length) ? Byte.toUnsignedInt(bytearray.get(offset + pos++)) : -1;, +++ b/core/src/main/java/org/elasticsearch/common/bytes/BytesArray.java, +public final class BytesArray implements BytesReference {, +++ b/core/src/main/java/org/elasticsearch/common/bytes/BytesReference.java, +            BytesRef ref = length() == 0 ? null : toBytesRef();, +++ b/core/src/main/java/org/elasticsearch/common/bytes/PagedBytesReference.java, +            return (pos < length) ? Byte.toUnsignedInt(bytearray.get(offset + pos++)) : -1;, +++ b/core/src/main/java/org/elasticsearch/common/netty/ChannelBufferBytesReference.java, +        return new ChannelBufferBytesReference(buffer.slice(buffer.readerIndex() + from, length));, +++ b/core/src/main/java/org/elasticsearch/common/bytes/BytesArray.java, +public final class BytesArray implements BytesReference {, +++ b/core/src/main/java/org/elasticsearch/common/bytes/BytesReference.java, +            BytesRef ref = length() == 0 ? null : toBytesRef();, +++ b/core/src/main/java/org/elasticsearch/common/bytes/PagedBytesReference.java, +            return (pos < length) ? Byte.toUnsignedInt(bytearray.get(offset + pos++)) : -1;, +++ b/core/src/main/java/org/elasticsearch/common/netty/ChannelBufferBytesReference.java, +        return new ChannelBufferBytesReference(buffer.slice(buffer.readerIndex() + from, length));, +++ b/core/src/main/java/org/elasticsearch/transport/netty/ChannelBufferStreamInput.java, +            throw new IndexOutOfBoundsException();, +++ b/core/src/main/java/org/elasticsearch/common/bytes/BytesArray.java, +public final class BytesArray implements BytesReference {, +++ b/core/src/main/java/org/elasticsearch/common/bytes/BytesReference.java, +            BytesRef ref = length() == 0 ? null : toBytesRef();, +++ b/core/src/main/java/org/elasticsearch/common/bytes/PagedBytesReference.java, +            return (pos < length) ? Byte.toUnsignedInt(bytearray.get(offset + pos++)) : -1;, +++ b/core/src/main/java/org/elasticsearch/common/netty/ChannelBufferBytesReference.java, +        return new ChannelBufferBytesReference(buffer.slice(buffer.readerIndex() + from, length));, +++ b/core/src/main/java/org/elasticsearch/transport/netty/ChannelBufferStreamInput.java, +            throw new IndexOutOfBoundsException();, +++ b/core/src/test/java/org/elasticsearch/common/bytes/AbstractBytesReferenceTestCase.java, +/*, + * Licensed to Elasticsearch under one or more contributor, + * license agreements. See the NOTICE file distributed with, + * this work for additional information regarding copyright, + * ownership. Elasticsearch licenses this file to you under, + * the Apache License, Version 2.0 (the "License"); you may, + * not use this file except in compliance with the License., + * You may obtain a copy of the License at, + *, + *    http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing,, + * software distributed under the License is distributed on an, + * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY, + * KIND, either express or implied.  See the License for the, + * specific language governing permissions and limitations, + * under the License., + */, +, +package org.elasticsearch.common.bytes;, +, +import org.apache.lucene.util.BytesRef;, +import org.apache.lucene.util.BytesRefBuilder;, +import org.apache.lucene.util.BytesRefIterator;, +import org.elasticsearch.common.io.stream.BytesStreamOutput;, +import org.elasticsearch.common.io.stream.ReleasableBytesStreamOutput;, +import org.elasticsearch.common.io.stream.StreamInput;, +import org.elasticsearch.common.util.BigArrays;, +import org.elasticsearch.common.util.ByteArray;, +import org.elasticsearch.indices.breaker.NoneCircuitBreakerService;, +import org.elasticsearch.test.ESTestCase;, +import org.hamcrest.Matchers;, +, +import java.io.EOFException;, +import java.io.IOException;, +import java.util.Arrays;, +, +public abstract class AbstractBytesReferenceTestCase extends ESTestCase {, +, +    protected static final int PAGE_SIZE = BigArrays.BYTE_PAGE_SIZE;, +    protected final BigArrays bigarrays = new BigArrays(null, new NoneCircuitBreakerService(), false);, +, +    public void testGet() throws IOException {, +        int length = randomIntBetween(1, PAGE_SIZE * 3);, +        BytesReference pbr = newBytesReference(length);, +        int sliceOffset = randomIntBetween(0, length / 2);, +        int sliceLength = Math.max(1, length - sliceOffset - 1);, +        BytesReference slice = pbr.slice(sliceOffset, sliceLength);, +        assertEquals(pbr.get(sliceOffset), slice.get(0));, +        assertEquals(pbr.get(sliceOffset + sliceLength - 1), slice.get(sliceLength - 1));, +    }, +, +    public void testLength() throws IOException {, +        int[] sizes = {0, randomInt(PAGE_SIZE), PAGE_SIZE, randomInt(PAGE_SIZE * 3)};, +, +        for (int i = 0; i < sizes.length; i++) {, +            BytesReference pbr = newBytesReference(sizes[i]);, +            assertEquals(sizes[i], pbr.length());, +        }]