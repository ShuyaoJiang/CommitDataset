[+++ b/modules/elasticsearch/src/main/java/org/elasticsearch/index/query/type/child/ChildCollector.java, +            IdReaderTypeCache idReaderTypeCache = typeCacheMap.get(indexReader.getCoreCacheKey());, +            if (idReaderTypeCache == null) { // might be if we don't have that doc with that type in this reader, +                continue;, +            }, +            int parentDocId = idReaderTypeCache.docById(parentId);, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/index/query/type/child/ChildCollector.java, +            IdReaderTypeCache idReaderTypeCache = typeCacheMap.get(indexReader.getCoreCacheKey());, +            if (idReaderTypeCache == null) { // might be if we don't have that doc with that type in this reader, +                continue;, +            }, +            int parentDocId = idReaderTypeCache.docById(parentId);, +++ b/modules/test/integration/src/test/java/org/elasticsearch/test/stress/search1/ParentChildStressTest.java, +/*, + * Licensed to Elastic Search and Shay Banon under one, + * or more contributor license agreements.  See the NOTICE file, + * distributed with this work for additional information, + * regarding copyright ownership. Elastic Search licenses this, + * file to you under the Apache License, Version 2.0 (the, + * "License"); you may not use this file except in compliance, + * with the License.  You may obtain a copy of the License at, + *, + *    http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing,, + * software distributed under the License is distributed on an, + * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY, + * KIND, either express or implied.  See the License for the, + * specific language governing permissions and limitations, + * under the License., + */, +, +package org.elasticsearch.test.stress.search1;, +, +import org.elasticsearch.action.admin.indices.create.CreateIndexRequest;, +import org.elasticsearch.action.search.SearchRequest;, +import org.elasticsearch.action.search.SearchResponse;, +import org.elasticsearch.action.search.ShardSearchFailure;, +import org.elasticsearch.client.Client;, +import org.elasticsearch.client.Requests;, +import org.elasticsearch.client.action.index.IndexRequestBuilder;, +import org.elasticsearch.common.settings.Settings;, +import org.elasticsearch.common.xcontent.XContentBuilder;, +import org.elasticsearch.common.xcontent.XContentFactory;, +import org.elasticsearch.node.Node;, +import org.elasticsearch.node.NodeBuilder;, +import org.elasticsearch.search.SearchHit;, +import org.elasticsearch.transport.RemoteTransportException;, +, +import java.io.IOException;, +import java.util.*;, +, +, +public class ParentChildStressTest {, +, +    private Node elasticNode;, +    private Client client;, +, +    private static final String PARENT_TYPE_NAME = "content";, +    private static final String CHILD_TYPE_NAME = "contentFiles";, +    private static final String INDEX_NAME = "acme";, +, +    /**, +     * Constructor.  Initialize elastic and create the index/mapping, +     */, +    public ParentChildStressTest() {, +        NodeBuilder nodeBuilder = NodeBuilder.nodeBuilder();, +        Settings settings = nodeBuilder.settings(), +                .build();, +        this.elasticNode = nodeBuilder.settings(settings).client(true).node();, +        this.client = this.elasticNode.client();, +, +        String mapping =, +                "{\"contentFiles\": {" +, +                        "\"_parent\": {" +, +                        "\"type\" : \"content\"" +, +                        "}}}";, +, +        try {, +            client.admin().indices().create(new CreateIndexRequest(INDEX_NAME).mapping(CHILD_TYPE_NAME, mapping)).actionGet();, +        } catch (RemoteTransportException e) {, +            // usually means the index is already created., +        }, +    }, +, +    public void shutdown() {, +        client.close();, +        elasticNode.close();, +    }, +, +    /**, +     * Deletes the item from both the parent and child type locations., +     */, +    public void deleteById(String id) {, +        client.prepareDelete(INDEX_NAME, PARENT_TYPE_NAME, id).execute().actionGet();, +        client.prepareDelete(INDEX_NAME, CHILD_TYPE_NAME, id).execute().actionGet();, +    }, +, +    /**, +     * Index a parent doc]