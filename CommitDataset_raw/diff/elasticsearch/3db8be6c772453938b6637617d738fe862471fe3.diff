[+++ /dev/null, +++ /dev/null, +++ b/src/test/java/org/elasticsearch/test/unit/index/fielddata/DuellFieldDataTests.java, +/*, + * Licensed to ElasticSearch and Shay Banon under one, + * or more contributor license agreements.  See the NOTICE file, + * distributed with this work for additional information, + * regarding copyright ownership. ElasticSearch licenses this, + * file to you under the Apache License, Version 2.0 (the, + * "License"); you may not use this file except in compliance, + * with the License.  You may obtain a copy of the License at, + *, + *    http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing,, + * software distributed under the License is distributed on an, + * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY, + * KIND, either express or implied.  See the License for the, + * specific language governing permissions and limitations, + * under the License., + */, +package org.elasticsearch.test.unit.index.fielddata;, +, +import org.apache.lucene.document.*;, +import org.apache.lucene.index.AtomicReaderContext;, +import org.apache.lucene.index.CompositeReaderContext;, +import org.apache.lucene.index.DirectoryReader;, +import org.apache.lucene.util.BytesRef;, +import org.apache.lucene.util.English;, +import org.elasticsearch.common.settings.ImmutableSettings;, +import org.elasticsearch.index.fielddata.*;, +import org.elasticsearch.index.fielddata.BytesValues.Iter;, +import org.elasticsearch.index.mapper.FieldMapper;, +import org.junit.Test;, +, +import java.util.*;, +import java.util.Map.Entry;, +, +import static org.hamcrest.Matchers.equalTo;, +import static org.hamcrest.Matchers.nullValue;, +, +public class DuellFieldDataTests extends AbstractFieldDataTests {, +, +    @Override, +    protected FieldDataType getFieldDataType() {, +        return null;, +    }, +, +    public static int atLeast(Random random, int i) {, +        int min = i;, +        int max = min + (min / 2);, +        return min + random.nextInt(max - min);, +    }, +, +    @Test, +    public void testDuellAllTypesSingleValue() throws Exception {, +        Random random = getRandom();, +        int atLeast = atLeast(random, 1000);, +        for (int i = 0; i < atLeast; i++) {, +            int v = (random.nextBoolean() ? -1 * random.nextInt(Byte.MAX_VALUE) : random.nextInt(Byte.MAX_VALUE));, +            Document d = new Document();, +            d.add(new StringField("_id", "" + i, Field.Store.NO));, +            if (random.nextInt(15) != 0) {, +                d.add(new LongField("long", v, Field.Store.NO));, +                d.add(new IntField("integer", v, Field.Store.NO));, +                d.add(new DoubleField("double", v, Field.Store.NO));, +                d.add(new FloatField("float", v, Field.Store.NO));, +                d.add(new StringField("bytes", "" + v, Field.Store.NO));, +            }, +            writer.addDocument(d);, +            if (random.nextInt(10) == 0) {, +                refreshReader();, +            }, +        }, +        AtomicReaderContext context = refreshReader();, +        Map<FieldDataType, Type> typeMap = new HashMap<FieldDataType, DuellFieldDataTests.Type>();, +        typeMap.put(new FieldDataType("string", ImmutableSettings.builder().put("format", "fst")), Type.Bytes);, +        typeMap.put(new FieldDataType("string", ImmutableSettings.builder().put("format", "paged_bytes")), Type.Bytes);, +        typeMap.put(new FieldDataType("string", ImmutableSettings.builder().put("format", "concrete_bytes")), Type.Bytes);, +        typeMap.put(new FieldDataType("byte"), Type.Integer);, +        typeMap.put(new FieldDataType("short"), Type.Integer);, +        typeMap.put(new FieldDataType("int"), Type.Integer);, +        typeMap.put(new FieldDataType("long"), Type.Long);, +        typeMap.put(new FieldDataType("double"), Type.Double);, +        typeMap.put(new FieldDataType("float"), Type.Float);, +        ArrayList<Entry<FieldDataType, Type>> list = new ArrayList<Entry<FieldDataType, Type>>(typeMap.entrySet());, +        Preprocessor pre = new ToDoublePreprocessor();, +        while (!list.isEmpty()) {, +            Entry<FieldDataType, Type> left;, +            Entry<FieldDataType, Type> right;, +            if (list.size() > 1) {, +                left = list.remove(random.nextInt(list.size()));, +                right = list.remove(random.nextInt(list.size()));, +            } else {, +                right = left = list.remove(0);, +            }, +            ifdService.clear();, +            IndexFieldData leftFieldData = ifdService.getForField(new FieldMapper.Names(left.getValue().name().toLowerCase(Locale.ROOT)),, +                    left.getKey());, +            ifdService.clear();]