[+++ b/x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/job/process/autodetect/AutodetectCommunicator.java, +import org.elasticsearch.common.util.concurrent.FutureUtils;, +                throw FutureUtils.rethrowExecutionException(e);, +++ b/x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/job/process/autodetect/AutodetectCommunicator.java, +import org.elasticsearch.common.util.concurrent.FutureUtils;, +                throw FutureUtils.rethrowExecutionException(e);, +++ b/x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/job/process/autodetect/output/AutoDetectResultProcessor.java, +import org.elasticsearch.common.unit.TimeValue;, +import org.elasticsearch.common.util.concurrent.EsRejectedExecutionException;, +import org.elasticsearch.common.util.concurrent.FutureUtils;, +import org.elasticsearch.xpack.ml.MachineLearning;, +import java.util.concurrent.Future;, +    /**, +     * This is how far behind real-time we'll update the job with the latest established model memory., +     * If more updates are received during the delay period then they'll take precedence., +     * As a result there will be at most one update of established model memory per delay period., +     */, +    private static final TimeValue ESTABLISHED_MODEL_MEMORY_UPDATE_DELAY = TimeValue.timeValueSeconds(5);, +, +    private volatile Date latestDateForEstablishedModelMemoryCalc;, +    private Future<?> scheduledEstablishedModelMemoryUpdate; // only accessed in synchronized methods, +            runEstablishedModelMemoryUpdate(true);, +            latestDateForEstablishedModelMemoryCalc = bucket.getTimestamp();, +            // a reasonable number of buckets have elapsed since the last model size stats update, +            if (haveNewLatestModelSizeStats && latestEstablishedModelMemory == 0 && latestDateForEstablishedModelMemoryCalc.getTime(), +                > latestModelSizeStats.getTimestamp().getTime() + minEstablishedTimespanMs) {, +                scheduleEstablishedModelMemoryUpdate(ESTABLISHED_MODEL_MEMORY_UPDATE_DELAY);, +        latestDateForEstablishedModelMemoryCalc = modelSizeStats.getTimestamp();, +            scheduleEstablishedModelMemoryUpdate(ESTABLISHED_MODEL_MEMORY_UPDATE_DELAY);, +    /**, +     * The purpose of this method is to avoid saturating the cluster state update thread, +     * when a lookback job is churning through buckets very fast and the memory usage of, +     * the job is changing regularly.  The idea is to only update the established model, +     * memory associated with the job a few seconds after the new value has been received., +     * If more updates are received during the delay period then they simply replace the, +     * value that originally caused the update to be scheduled.  This rate limits cluster, +     * state updates due to established model memory changing to one per job per delay period., +     * (In reality updates will only occur this rapidly during lookback.  During real-time, +     * operation the limit of one model size stats document per bucket will mean there is a, +     * maximum of one cluster state update per job per bucket, and usually the bucket span, +     * is 5 minutes or more.), +     * @param delay The delay before updating established model memory., +     */, +    synchronized void scheduleEstablishedModelMemoryUpdate(TimeValue delay) {, +, +        if (scheduledEstablishedModelMemoryUpdate == null) {, +            try {, +                scheduledEstablishedModelMemoryUpdate = client.threadPool().schedule(delay, MachineLearning.UTILITY_THREAD_POOL_NAME,, +                    () -> runEstablishedModelMemoryUpdate(false));, +                LOGGER.trace("[{}] Scheduled established model memory update to run in [{}]", jobId, delay);, +            } catch (EsRejectedExecutionException e) {, +                if (e.isExecutorShutdown()) {, +                    LOGGER.debug("failed to schedule established model memory update; shutting down", e);, +                } else {, +                    throw e;, +                }, +            }, +        }, +    }, +, +    /**, +     * This method is called from two places:, +     * - From the {@link Future} used for delayed updates, +     * - When shutting down this result processor, +     * When shutting down the result processor it's only necessary to do anything, +     * if an update has been scheduled, but we want to do the update immediately., +     * Despite cancelling the scheduled update in this case, it's possible that, +     * it's already started running, in which case this method will get called, +     * twice in quick succession.  But the second call will do nothing, as, +     * <code>scheduledEstablishedModelMemoryUpdate</code> will have been reset, +     * to <code>null</code> by the first call., +     */, +    private synchronized void runEstablishedModelMemoryUpdate(boolean cancelExisting) {, +, +        if (scheduledEstablishedModelMemoryUpdate != null) {, +            if (cancelExisting) {, +                LOGGER.debug("[{}] Bringing forward previously scheduled established model memory update", jobId);, +                FutureUtils.cancel(scheduledEstablishedModelMemoryUpdate);, +            }, +            scheduledEstablishedModelMemoryUpdate = null;, +            updateEstablishedModelMemoryOnJob();, +        }, +    }, +, +    private void updateEstablishedModelMemoryOnJob() {, +, +        // Copy these before committing writes, so the calculation is done based on committed documents, +        Date latestBucketTimestamp = latestDateForEstablishedModelMemoryCalc;, +        ModelSizeStats modelSizeStatsForCalc = latestModelSizeStats;, +, +        // We need to make all results written up to and including these stats available for the established memory calculation, +        persister.commitResultWrites(jobId);, +, +        jobProvider.getEstablishedMemoryUsage(jobId, latestBucketTimestamp, modelSizeStatsForCalc, establishedModelMemory -> {, +            if (latestEstablishedModelMemory != establishedModelMemory) {, +                JobUpdate update = new JobUpdate.Builder(jobId).setEstablishedModelMemory(establishedModelMemory).build();, +                executeAsyncWithOrigin(client, ML_ORIGIN, UpdateJobAction.INSTANCE, updateRequest,, +                    new ActionListener<PutJobAction.Response>() {, +                        LOGGER.error("[" + jobId + "] Failed to update job with new established model memory [" +, +                            establishedModelMemory + "]", e);]