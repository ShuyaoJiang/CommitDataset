[+++ b/server/src/main/java/org/elasticsearch/persistent/NodePersistentTasksExecutor.java, +import org.elasticsearch.tasks.Task;, +                                                                  @Nullable Task.Status status,, +                    executor.nodeOperation(task, params, status);, +++ b/server/src/main/java/org/elasticsearch/persistent/NodePersistentTasksExecutor.java, +import org.elasticsearch.tasks.Task;, +                                                                  @Nullable Task.Status status,, +                    executor.nodeOperation(task, params, status);, +++ b/server/src/main/java/org/elasticsearch/persistent/PersistentTasksExecutor.java, +import org.elasticsearch.tasks.Task;, +     * NOTE: The nodeOperation has to throw an exception, trigger task.markAsCompleted() or task.completeAndNotifyIfNeeded() methods to, +    protected abstract void nodeOperation(AllocatedPersistentTask task, @Nullable Params params, @Nullable Task.Status status);, +++ b/server/src/main/java/org/elasticsearch/persistent/NodePersistentTasksExecutor.java, +import org.elasticsearch.tasks.Task;, +                                                                  @Nullable Task.Status status,, +                    executor.nodeOperation(task, params, status);, +++ b/server/src/main/java/org/elasticsearch/persistent/PersistentTasksExecutor.java, +import org.elasticsearch.tasks.Task;, +     * NOTE: The nodeOperation has to throw an exception, trigger task.markAsCompleted() or task.completeAndNotifyIfNeeded() methods to, +    protected abstract void nodeOperation(AllocatedPersistentTask task, @Nullable Params params, @Nullable Task.Status status);, +++ b/server/src/main/java/org/elasticsearch/persistent/PersistentTasksNodeService.java, +                nodePersistentTasksExecutor.executeTask(taskInProgress.getParams(), taskInProgress.getStatus(), task, executor);, +++ b/server/src/main/java/org/elasticsearch/persistent/NodePersistentTasksExecutor.java, +import org.elasticsearch.tasks.Task;, +                                                                  @Nullable Task.Status status,, +                    executor.nodeOperation(task, params, status);, +++ b/server/src/main/java/org/elasticsearch/persistent/PersistentTasksExecutor.java, +import org.elasticsearch.tasks.Task;, +     * NOTE: The nodeOperation has to throw an exception, trigger task.markAsCompleted() or task.completeAndNotifyIfNeeded() methods to, +    protected abstract void nodeOperation(AllocatedPersistentTask task, @Nullable Params params, @Nullable Task.Status status);, +++ b/server/src/main/java/org/elasticsearch/persistent/PersistentTasksNodeService.java, +                nodePersistentTasksExecutor.executeTask(taskInProgress.getParams(), taskInProgress.getStatus(), task, executor);, +++ b/server/src/test/java/org/elasticsearch/persistent/PersistentTasksNodeServiceTests.java, +import static org.hamcrest.Matchers.sameInstance;, +import static org.mockito.Mockito.verify;, +    public void testParamsStatusAndNodeTaskAreDelegated() throws Exception {, +        PersistentTasksService persistentTasksService = mock(PersistentTasksService.class);, +        @SuppressWarnings("unchecked") PersistentTasksExecutor<TestParams> action = mock(PersistentTasksExecutor.class);, +        when(action.getExecutor()).thenReturn(ThreadPool.Names.SAME);, +        when(action.getTaskName()).thenReturn(TestPersistentTasksExecutor.NAME);, +        TaskId parentId = new TaskId("cluster", 1);, +        AllocatedPersistentTask nodeTask = new TestPersistentTasksPlugin.TestTask(0, "persistent", "test", "", parentId);, +        when(action.createTask(anyLong(), anyString(), anyString(), eq(parentId), any())).thenReturn(nodeTask);, +        PersistentTasksExecutorRegistry registry = new PersistentTasksExecutorRegistry(Settings.EMPTY, Collections.singletonList(action));, +, +        MockExecutor executor = new MockExecutor();, +        PersistentTasksNodeService coordinator = new PersistentTasksNodeService(Settings.EMPTY, persistentTasksService,, +                registry, new TaskManager(Settings.EMPTY), executor);, +, +        ClusterState state = createInitialClusterState(1, Settings.EMPTY);, +, +        Task.Status status = new TestPersistentTasksPlugin.Status("_test_phase");, +        PersistentTasksCustomMetaData.Builder tasks = PersistentTasksCustomMetaData.builder();, +        String taskId = UUIDs.base64UUID();, +        TestParams taskParams = new TestParams("other_0");, +        tasks.addTask(taskId, TestPersistentTasksExecutor.NAME, taskParams,, +                new Assignment("this_node", "test assignment on other node"));, +        tasks.updateTaskStatus(taskId, status);, +        MetaData.Builder metaData = MetaData.builder(state.metaData());, +        metaData.putCustom(PersistentTasksCustomMetaData.TYPE, tasks.build());, +        ClusterState newClusterState = ClusterState.builder(state).metaData(metaData).build();, +, +        coordinator.clusterChanged(new ClusterChangedEvent("test", newClusterState, state));, +, +        assertThat(executor.size(), equalTo(1));, +        assertThat(executor.get(0).params, sameInstance(taskParams));, +        assertThat(executor.get(0).status, sameInstance(status));, +        assertThat(executor.get(0).task, sameInstance(nodeTask));, +    }, +, +        private final Task.Status status;, +        Execution(PersistentTaskParams params, AllocatedPersistentTask task, Task.Status status, PersistentTasksExecutor<?> holder) {, +            this.status = status;, +        public <Params extends PersistentTaskParams> void executeTask(Params params,, +                                                                      Task.Status status,, +                                                                      AllocatedPersistentTask task,, +            executions.add(new Execution(params, task, status, executor));, +++ b/server/src/main/java/org/elasticsearch/persistent/NodePersistentTasksExecutor.java, +import org.elasticsearch.tasks.Task;, +                                                                  @Nullable Task.Status status,, +                    executor.nodeOperation(task, params, status);, +++ b/server/src/main/java/org/elasticsearch/persistent/PersistentTasksExecutor.java, +import org.elasticsearch.tasks.Task;, +     * NOTE: The nodeOperation has to throw an exception, trigger task.markAsCompleted() or task.completeAndNotifyIfNeeded() methods to, +    protected abstract void nodeOperation(AllocatedPersistentTask task, @Nullable Params params, @Nullable Task.Status status);, +++ b/server/src/main/java/org/elasticsearch/persistent/PersistentTasksNodeService.java, +                nodePersistentTasksExecutor.executeTask(taskInProgress.getParams(), taskInProgress.getStatus(), task, executor);, +++ b/server/src/test/java/org/elasticsearch/persistent/PersistentTasksNodeServiceTests.java, +import static org.hamcrest.Matchers.sameInstance;, +import static org.mockito.Mockito.verify;, +    public void testParamsStatusAndNodeTaskAreDelegated() throws Exception {, +        PersistentTasksService persistentTasksService = mock(PersistentTasksService.class);, +        @SuppressWarnings("unchecked") PersistentTasksExecutor<TestParams> action = mock(PersistentTasksExecutor.class);, +        when(action.getExecutor()).thenReturn(ThreadPool.Names.SAME);, +        when(action.getTaskName()).thenReturn(TestPersistentTasksExecutor.NAME);, +        TaskId parentId = new TaskId("cluster", 1);, +        AllocatedPersistentTask nodeTask = new TestPersistentTasksPlugin.TestTask(0, "persistent", "test", "", parentId);, +        when(action.createTask(anyLong(), anyString(), anyString(), eq(parentId), any())).thenReturn(nodeTask);, +        PersistentTasksExecutorRegistry registry = new PersistentTasksExecutorRegistry(Settings.EMPTY, Collections.singletonList(action));, +]