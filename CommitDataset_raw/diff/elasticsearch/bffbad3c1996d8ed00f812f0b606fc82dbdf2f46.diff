[+++ b/core/src/main/java/org/elasticsearch/action/ActionRequest.java, +++ b/core/src/main/java/org/elasticsearch/action/ActionRequest.java, +++ b/core/src/main/java/org/elasticsearch/cluster/ClusterModule.java, +import org.elasticsearch.index.translog.TranslogConfig;, +, +++ b/core/src/main/java/org/elasticsearch/action/ActionRequest.java, +++ b/core/src/main/java/org/elasticsearch/cluster/ClusterModule.java, +import org.elasticsearch.index.translog.TranslogConfig;, +, +++ b/core/src/main/java/org/elasticsearch/cluster/routing/IndexShardRoutingTable.java, +, +++ b/core/src/main/java/org/elasticsearch/action/ActionRequest.java, +++ b/core/src/main/java/org/elasticsearch/cluster/ClusterModule.java, +import org.elasticsearch.index.translog.TranslogConfig;, +, +++ b/core/src/main/java/org/elasticsearch/cluster/routing/IndexShardRoutingTable.java, +, +++ b/core/src/main/java/org/elasticsearch/cluster/routing/RoutingNodes.java, +                        } else if (!shard.active()) { // shards that are initializing without being relocated, +++ b/core/src/main/java/org/elasticsearch/action/ActionRequest.java, +++ b/core/src/main/java/org/elasticsearch/cluster/ClusterModule.java, +import org.elasticsearch.index.translog.TranslogConfig;, +, +++ b/core/src/main/java/org/elasticsearch/cluster/routing/IndexShardRoutingTable.java, +, +++ b/core/src/main/java/org/elasticsearch/cluster/routing/RoutingNodes.java, +                        } else if (!shard.active()) { // shards that are initializing without being relocated, +++ b/core/src/main/java/org/elasticsearch/cluster/routing/allocation/AllocationService.java, +        RoutingNodes routingNodes = allocation.routingNodes();, +, +        // go over and remove dangling replicas that are initializing for primary shards, +        List<ShardRouting> shardsToFail = new ArrayList<>();, +                for (ShardRouting routing : routingNodes.assignedShards(shardEntry)) {, +                    if (!routing.primary() && routing.initializing()) {, +                        shardsToFail.add(routing);, +                    }, +                }, +, +            }, +        }, +        for (ShardRouting shardToFail : shardsToFail) {, +            changed |= applyFailedShard(allocation, shardToFail, false,, +                    new UnassignedInfo(UnassignedInfo.Reason.ALLOCATION_FAILED, "primary failed while replica initializing",, +                            null, allocation.getCurrentNanoTime(), System.currentTimeMillis()));, +        }, +, +        // now, go over and elect a new primary if possible, not, from this code block on, if one is elected,, +        // routingNodes.hasUnassignedPrimaries() will potentially be false, +, +        for (ShardRouting shardEntry : routingNodes.unassigned()) {, +            if (shardEntry.primary()) {, +, +, +++ b/core/src/main/java/org/elasticsearch/action/ActionRequest.java, +++ b/core/src/main/java/org/elasticsearch/cluster/ClusterModule.java, +import org.elasticsearch.index.translog.TranslogConfig;, +, +++ b/core/src/main/java/org/elasticsearch/cluster/routing/IndexShardRoutingTable.java, +, +++ b/core/src/main/java/org/elasticsearch/cluster/routing/RoutingNodes.java, +                        } else if (!shard.active()) { // shards that are initializing without being relocated, +++ b/core/src/main/java/org/elasticsearch/cluster/routing/allocation/AllocationService.java, +        RoutingNodes routingNodes = allocation.routingNodes();, +, +        // go over and remove dangling replicas that are initializing for primary shards, +        List<ShardRouting> shardsToFail = new ArrayList<>();, +                for (ShardRouting routing : routingNodes.assignedShards(shardEntry)) {, +                    if (!routing.primary() && routing.initializing()) {, +                        shardsToFail.add(routing);, +                    }, +                }, +, +            }, +        }, +        for (ShardRouting shardToFail : shardsToFail) {, +            changed |= applyFailedShard(allocation, shardToFail, false,, +                    new UnassignedInfo(UnassignedInfo.Reason.ALLOCATION_FAILED, "primary failed while replica initializing",, +                            null, allocation.getCurrentNanoTime(), System.currentTimeMillis()));, +        }, +, +        // now, go over and elect a new primary if possible, not, from this code block on, if one is elected,, +        // routingNodes.hasUnassignedPrimaries() will potentially be false, +, +        for (ShardRouting shardEntry : routingNodes.unassigned()) {, +            if (shardEntry.primary()) {, +, +, +++ b/core/src/main/java/org/elasticsearch/cluster/routing/allocation/allocator/BalancedShardsAllocator.java, +        private final float[] theta;, +            theta = new float[]{shardBalance / sum, indexBalance / sum};, +        public float weight(Operation operation, Balancer balancer, ModelNode node, String index) {, +            final float weightShard = (node.numShards() - balancer.avgShardsPerNode());, +            final float weightIndex = (node.numShards(index) - balancer.avgShardsPerNode(index));, +            assert theta != null;, +            return theta[0] * weightShard + theta[1] * weightIndex;, +    /**, +     * An enum that donates the actual operation the {@link WeightFunction} is, +     * applied to., +     */, +    public static enum Operation {]