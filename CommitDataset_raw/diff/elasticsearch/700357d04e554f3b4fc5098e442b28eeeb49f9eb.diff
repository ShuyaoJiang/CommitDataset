[+++ /dev/null, +++ /dev/null, +++ b/libs/nio/src/main/java/org/elasticsearch/nio/ChannelContext.java, +        if (isOpen()) {, +++ /dev/null, +++ b/libs/nio/src/main/java/org/elasticsearch/nio/ChannelContext.java, +        if (isOpen()) {, +++ b/libs/nio/src/main/java/org/elasticsearch/nio/EventHandler.java, +     * This method is called after events (READ, WRITE, CONNECT) have been handled for a channel., +++ /dev/null, +++ b/libs/nio/src/main/java/org/elasticsearch/nio/ChannelContext.java, +        if (isOpen()) {, +++ b/libs/nio/src/main/java/org/elasticsearch/nio/EventHandler.java, +     * This method is called after events (READ, WRITE, CONNECT) have been handled for a channel., +++ b/libs/nio/src/main/java/org/elasticsearch/nio/NioSelector.java, +    public NioSelector(EventHandler eventHandler, Selector selector) {, +        cleanupPendingWrites();, +     * Queues a write operation directly in a channel's buffer. If this channel does not have pending writes, +     * already, the channel will be flushed. Channel buffers are only safe to be accessed by the selector, +     * thread. As a result, this method should only be called by the selector thread. If this channel does, +     * not have pending writes already, the channel will be flushed., +    public void writeToChannel(WriteOperation writeOperation) {, +        // If the channel does not currently have anything that is ready to flush, we should flush after, +        // the write operation is queued., +        boolean shouldFlushAfterQueuing = context.readyForFlush() == false;, +            shouldFlushAfterQueuing = false;, +, +        if (shouldFlushAfterQueuing) {, +            handleWrite(context);, +            eventHandler.postHandling(context);, +        }, +    private void cleanupPendingWrites() {, +        WriteOperation op;, +        while ((op = queuedWrites.poll()) != null) {, +            executeFailedListener(op.getListener(), new ClosedSelectorException());, +        }, +    }, +, +                writeToChannel(writeOperation);, +++ /dev/null, +++ b/libs/nio/src/main/java/org/elasticsearch/nio/ChannelContext.java, +        if (isOpen()) {, +++ b/libs/nio/src/main/java/org/elasticsearch/nio/EventHandler.java, +     * This method is called after events (READ, WRITE, CONNECT) have been handled for a channel., +++ b/libs/nio/src/main/java/org/elasticsearch/nio/NioSelector.java, +    public NioSelector(EventHandler eventHandler, Selector selector) {, +        cleanupPendingWrites();, +     * Queues a write operation directly in a channel's buffer. If this channel does not have pending writes, +     * already, the channel will be flushed. Channel buffers are only safe to be accessed by the selector, +     * thread. As a result, this method should only be called by the selector thread. If this channel does, +     * not have pending writes already, the channel will be flushed., +    public void writeToChannel(WriteOperation writeOperation) {, +        // If the channel does not currently have anything that is ready to flush, we should flush after, +        // the write operation is queued., +        boolean shouldFlushAfterQueuing = context.readyForFlush() == false;, +            shouldFlushAfterQueuing = false;, +, +        if (shouldFlushAfterQueuing) {, +            handleWrite(context);, +            eventHandler.postHandling(context);, +        }, +    private void cleanupPendingWrites() {, +        WriteOperation op;, +        while ((op = queuedWrites.poll()) != null) {, +            executeFailedListener(op.getListener(), new ClosedSelectorException());, +        }, +    }, +, +                writeToChannel(writeOperation);, +++ b/libs/nio/src/main/java/org/elasticsearch/nio/SocketChannelContext.java, +        selector.writeToChannel(writeOperation);, +        if (isOpen()) {, +++ /dev/null, +++ b/libs/nio/src/main/java/org/elasticsearch/nio/ChannelContext.java, +        if (isOpen()) {, +++ b/libs/nio/src/main/java/org/elasticsearch/nio/EventHandler.java, +     * This method is called after events (READ, WRITE, CONNECT) have been handled for a channel., +++ b/libs/nio/src/main/java/org/elasticsearch/nio/NioSelector.java, +    public NioSelector(EventHandler eventHandler, Selector selector) {, +        cleanupPendingWrites();, +     * Queues a write operation directly in a channel's buffer. If this channel does not have pending writes, +     * already, the channel will be flushed. Channel buffers are only safe to be accessed by the selector, +     * thread. As a result, this method should only be called by the selector thread. If this channel does, +     * not have pending writes already, the channel will be flushed., +    public void writeToChannel(WriteOperation writeOperation) {, +        // If the channel does not currently have anything that is ready to flush, we should flush after, +        // the write operation is queued., +        boolean shouldFlushAfterQueuing = context.readyForFlush() == false;, +            shouldFlushAfterQueuing = false;, +, +        if (shouldFlushAfterQueuing) {, +            handleWrite(context);, +            eventHandler.postHandling(context);, +        }, +    private void cleanupPendingWrites() {, +        WriteOperation op;, +        while ((op = queuedWrites.poll()) != null) {, +            executeFailedListener(op.getListener(), new ClosedSelectorException());, +        }, +    }]