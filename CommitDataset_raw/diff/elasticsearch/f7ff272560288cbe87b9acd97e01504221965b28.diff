[+++ b/src/test/java/org/elasticsearch/gateway/local/QuorumLocalGatewayTests.java, +import com.google.common.base.Predicate;, +import org.elasticsearch.AbstractNodesTests;, +import java.util.concurrent.TimeUnit;, +, +import static org.elasticsearch.test.hamcrest.ElasticsearchAssertions.assertHitCount;, +import static org.elasticsearch.test.hamcrest.ElasticsearchAssertions.assertNoFailures;, +        node1.client().prepareIndex("test", "type1", "1").setSource(jsonBuilder().startObject().field("field", "value1").endObject()).get();, +        //We don't check for failures in the flush response: if we do we might get the following:, +        // FlushNotAllowedEngineException[[test][1] recovery is in progress, flush [COMMIT_TRANSLOG] is not allowed], +        node1.client().admin().indices().prepareFlush().get();, +        node1.client().prepareIndex("test", "type1", "2").setSource(jsonBuilder().startObject().field("field", "value2").endObject()).get();, +        assertNoFailures(node1.client().admin().indices().prepareRefresh().execute().get());, +            assertHitCount(node1.client().prepareCount().setQuery(matchAllQuery()).get(), 2l);, +        assertThat(awaitBusy(new Predicate<Object>() {, +            @Override, +            public boolean apply(Object input) {, +                ClusterStateResponse clusterStateResponse = client("node1").admin().cluster().prepareState().setMasterNodeTimeout("500ms").get();, +                return !clusterStateResponse.getState().routingTable().index("test").allPrimaryShardsActive();, +            }, +        }, 30, TimeUnit.SECONDS), equalTo(true));, +        client("node1").admin().indices().prepareUpdateSettings("test").setSettings(settingsBuilder().put("recovery.initial_shards", 1)).get();, +            assertHitCount(node1.client().prepareCount().setQuery(matchAllQuery()).get(), 2l);, +        node1.client().prepareIndex("test", "type1", "1").setSource(jsonBuilder().startObject().field("field", "value1").endObject()).get();, +        //We don't check for failures in the flush response: if we do we might get the following:, +        // FlushNotAllowedEngineException[[test][1] recovery is in progress, flush [COMMIT_TRANSLOG] is not allowed], +        node1.client().admin().indices().prepareFlush().get();, +        node1.client().prepareIndex("test", "type1", "2").setSource(jsonBuilder().startObject().field("field", "value2").endObject()).get();, +        assertNoFailures(node1.client().admin().indices().prepareRefresh().get());, +            assertHitCount(node1.client().prepareCount().setQuery(matchAllQuery()).get(), 2l);, +        assertThat(awaitBusy(new Predicate<Object>() {, +            @Override, +            public boolean apply(Object input) {, +                ClusterHealthResponse clusterHealth = client("node2").admin().cluster().health(clusterHealthRequest().waitForYellowStatus().waitForNodes("2").waitForActiveShards(4)).actionGet();, +                return clusterHealth.isTimedOut() && clusterHealth.getStatus() == ClusterHealthStatus.YELLOW;, +            }, +        }, 30, TimeUnit.SECONDS), equalTo(false));, +        node2.client().prepareIndex("test", "type1", "3").setSource(jsonBuilder().startObject().field("field", "value3").endObject()).get();, +        assertNoFailures(node2.client().admin().indices().prepareRefresh().get());, +            assertHitCount(node2.client().prepareCount().setQuery(matchAllQuery()).get(), 3l);, +        node3 = startNode("node3", settingsBuilder().put("gateway.type", "local").build());, +            assertHitCount(node1.client().prepareCount().setQuery(matchAllQuery()).get(), 3l);]