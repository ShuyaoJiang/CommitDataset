[+++ b/server/src/main/java/org/elasticsearch/action/bulk/MappingUpdatePerformer.java, +++ b/server/src/main/java/org/elasticsearch/action/bulk/MappingUpdatePerformer.java, +++ b/server/src/main/java/org/elasticsearch/action/bulk/TransportShardBulkAction.java, +import org.elasticsearch.common.CheckedSupplier;, +import java.io.IOException;, +import java.util.function.Function;, +        switch (indexResult.getResultType()) {, +            case SUCCESS:, +            case FAILURE:, +                return new BulkItemResultHolder(null, indexResult, bulkItemRequest);, +            default:, +                throw new AssertionError("unknown result type for " + indexRequest + ": " + indexResult.getResultType());, +        switch (deleteResult.getResultType()) {, +            case SUCCESS:, +            case FAILURE:, +                return new BulkItemResultHolder(null, deleteResult, bulkItemRequest);, +            case MAPPING_UPDATE_REQUIRED:, +                throw new AssertionError("delete operation leaked a mapping update " + deleteRequest);, +            default:, +                throw new AssertionError("unknown result type for " + deleteRequest + ": " + deleteResult.getResultType());, +        if (operationResult != null && operationResult.getResultType() == Engine.Result.Type.SUCCESS) {, +        } else if (operationResult.getResultType() == Engine.Result.Type.SUCCESS) {, +        } else if (operationResult.getResultType() == Engine.Result.Type.FAILURE) {, +        } else {, +            throw new AssertionError("unknown result type for " + request + ": " + operationResult.getResultType());, +                                                      final IndexShard primary, final int bulkReqId) {, +        } else if (result.getResultType() == Engine.Result.Type.FAILURE) {, +        } else if (result.getResultType() == Engine.Result.Type.SUCCESS) {, +        } else {, +            throw new AssertionError("unknown result type for " + updateRequest + ": " + result.getResultType());, +        final Engine.Result result;, +                result = replica.applyIndexOperationOnReplica(primaryResponse.getSeqNo(), primaryResponse.getVersion(),, +                    indexRequest.isRetry(), sourceToParse);, +                break;, +                result =  replica.applyDeleteOperationOnReplica(primaryResponse.getSeqNo(), primaryResponse.getVersion(),, +                    deleteRequest.type(), deleteRequest.id(), deleteRequest.versionType().versionTypeForReplicationAndRecovery());, +                break;, +        if (result.getResultType() == Engine.Result.Type.MAPPING_UPDATE_REQUIRED) {, +            throw new TransportReplicationAction.RetryOnReplicaException(replica.shardId(),, +                "Mappings are not available on the replica yet, triggered update: " + result.getRequiredMappingUpdate());, +        }, +        return result;, +        return executeOnPrimaryWhileHandlingMappingUpdates(primary.shardId(), request.type(),, +            () ->, +                primary.applyIndexOperationOnPrimary(request.version(), request.versionType(), sourceToParse,, +                    request.getAutoGeneratedTimestamp(), request.isRetry()),, +            e -> new Engine.IndexResult(e, request.version()),, +            mappingUpdater);, +        return executeOnPrimaryWhileHandlingMappingUpdates(primary.shardId(), request.type(),, +            () -> primary.applyDeleteOperationOnPrimary(request.version(), request.type(), request.id(), request.versionType()),, +            e -> new Engine.DeleteResult(e, request.version()),, +            mappingUpdater);, +, +    private static <T extends Engine.Result> T executeOnPrimaryWhileHandlingMappingUpdates(ShardId shardId, String type,, +                                                                                           CheckedSupplier<T, IOException> toExecute,, +                                                                                           Function<Exception, T> onError,, +                                                                                           MappingUpdatePerformer mappingUpdater), +        throws IOException {, +        T result = toExecute.get();, +        if (result.getResultType() == Engine.Result.Type.MAPPING_UPDATE_REQUIRED) {, +            // try to update the mappings and try again., +            try {, +                mappingUpdater.updateMappings(result.getRequiredMappingUpdate(), shardId, type);, +            } catch (Exception e) {, +                // failure to update the mapping should translate to a failure of specific requests. Other requests, +                // still need to be executed and replicated., +                return onError.apply(e);, +            }, +, +            result = toExecute.get();, +, +            if (result.getResultType() == Engine.Result.Type.MAPPING_UPDATE_REQUIRED) {, +                // double mapping update. We assume that the successful mapping update wasn't yet processed on the node, +                // and retry the entire request again., +                throw new ReplicationOperation.RetryOnPrimaryException(shardId,, +                    "Dynamic mappings are not available on the node that holds the primary yet");, +            }, +        }, +        assert result.getFailure() instanceof ReplicationOperation.RetryOnPrimaryException == false :, +            "IndexShard shouldn't use RetryOnPrimaryException. got " + result.getFailure();, +        return result;, +, +            assert update != null;, +            assert shardId != null;, +++ b/server/src/main/java/org/elasticsearch/action/bulk/MappingUpdatePerformer.java, +++ b/server/src/main/java/org/elasticsearch/action/bulk/TransportShardBulkAction.java, +import org.elasticsearch.common.CheckedSupplier;, +import java.io.IOException;, +import java.util.function.Function;, +        switch (indexResult.getResultType()) {, +            case SUCCESS:, +            case FAILURE:, +                return new BulkItemResultHolder(null, indexResult, bulkItemRequest);, +            default:, +                throw new AssertionError("unknown result type for " + indexRequest + ": " + indexResult.getResultType());, +        switch (deleteResult.getResultType()) {, +            case SUCCESS:, +            case FAILURE:, +                return new BulkItemResultHolder(null, deleteResult, bulkItemRequest);, +            case MAPPING_UPDATE_REQUIRED:]