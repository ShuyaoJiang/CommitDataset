[+++ b/x-pack/plugin/rollup/src/main/java/org/elasticsearch/xpack/rollup/job/RollupIndexer.java, +        long lowerBound = 0L;, +        if (position != null) {, +            Number value = (Number) position.get(rollupFieldName);, +            lowerBound = value.longValue();, +        }, +++ b/x-pack/plugin/rollup/src/main/java/org/elasticsearch/xpack/rollup/job/RollupIndexer.java, +        long lowerBound = 0L;, +        if (position != null) {, +            Number value = (Number) position.get(rollupFieldName);, +            lowerBound = value.longValue();, +        }, +++ b/x-pack/qa/full-cluster-restart/src/test/java/org/elasticsearch/xpack/restart/FullClusterRestartIT.java, +import org.elasticsearch.client.Request;, +import org.hamcrest.Matcher;, +import java.util.Locale;, +    /**, +     * Tests that a RollUp job created on a old cluster is correctly restarted after the upgrade., +     */, +    public void testRollupAfterRestart() throws Exception {, +        assumeTrue("Rollup can be tested with 6.3.0 and onwards", oldClusterVersion.onOrAfter(Version.V_6_3_0));, +        if (runningAgainstOldCluster) {, +            final int numDocs = 59;, +            final int year = randomIntBetween(1970, 2018);, +, +            // index documents for the rollup job, +            final StringBuilder bulk = new StringBuilder();, +            for (int i = 0; i < numDocs; i++) {, +                bulk.append("{\"index\":{\"_index\":\"rollup-docs\",\"_type\":\"doc\"}}\n");, +                String date = String.format(Locale.ROOT, "%04d-01-01T00:%02d:00Z", year, i);, +                bulk.append("{\"timestamp\":\"").append(date).append("\",\"value\":").append(i).append("}\n");, +            }, +            bulk.append("\r\n");, +, +            final Request bulkRequest = new Request("POST", "/_bulk");, +            bulkRequest.setJsonEntity(bulk.toString());, +            client().performRequest(bulkRequest);, +, +            // create the rollup job, +            final Request createRollupJobRequest = new Request("PUT", "/_xpack/rollup/job/rollup-job-test");, +            createRollupJobRequest.setJsonEntity("{", +                    + "\"index_pattern\":\"rollup-*\",", +                    + "\"rollup_index\":\"results-rollup\",", +                    + "\"cron\":\"*/30 * * * * ?\",", +                    + "\"page_size\":100,", +                    + "\"groups\":{", +                    + "    \"date_histogram\":{", +                    + "        \"field\":\"timestamp\",", +                    + "        \"interval\":\"5m\"", +                    + "      }", +                    + "},", +                    + "\"metrics\":[", +                    + "    {\"field\":\"value\",\"metrics\":[\"min\",\"max\",\"sum\"]}", +                    + "]", +                    + "}");, +, +            Map<String, Object> createRollupJobResponse = toMap(client().performRequest(createRollupJobRequest));, +            assertThat(createRollupJobResponse.get("acknowledged"), equalTo(Boolean.TRUE));, +, +            // start the rollup job, +            final Request startRollupJobRequest = new Request("POST", "_xpack/rollup/job/rollup-job-test/_start");, +            Map<String, Object> startRollupJobResponse = toMap(client().performRequest(startRollupJobRequest));, +            assertThat(startRollupJobResponse.get("started"), equalTo(Boolean.TRUE));, +, +            assertRollUpJob("rollup-job-test");, +, +        } else {, +, +            final Request clusterHealthRequest = new Request("GET", "/_cluster/health");, +            clusterHealthRequest.addParameter("wait_for_status", "yellow");, +            clusterHealthRequest.addParameter("wait_for_no_relocating_shards", "true");, +            if (oldClusterVersion.onOrAfter(Version.V_6_2_0)) {, +                clusterHealthRequest.addParameter("wait_for_no_initializing_shards", "true");, +            }, +            Map<String, Object> clusterHealthResponse = toMap(client().performRequest(clusterHealthRequest));, +            assertThat(clusterHealthResponse.get("timed_out"), equalTo(Boolean.FALSE));, +, +            assertRollUpJob("rollup-job-test");, +        }, +    }, +, +, +    @SuppressWarnings("unchecked"), +    private void assertRollUpJob(final String rollupJob) throws Exception {, +        final Matcher<?> expectedStates = anyOf(equalTo("indexing"), equalTo("started"));, +        waitForRollUpJob(rollupJob, expectedStates);, +, +        // check that the rollup job is started using the RollUp API, +        final Request getRollupJobRequest = new Request("GET", "_xpack/rollup/job/" + rollupJob);, +        Map<String, Object> getRollupJobResponse = toMap(client().performRequest(getRollupJobRequest));, +        assertThat(ObjectPath.eval("jobs.0.status.job_state", getRollupJobResponse), expectedStates);, +, +        // check that the rollup job is started using the Tasks API, +        final Request taskRequest = new Request("GET", "_tasks");, +        taskRequest.addParameter("detailed", "true");, +        taskRequest.addParameter("actions", "xpack/rollup/*");, +        Map<String, Object> taskResponse = toMap(client().performRequest(taskRequest));, +        Map<String, Object> taskResponseNodes = (Map<String, Object>) taskResponse.get("nodes");, +        Map<String, Object> taskResponseNode = (Map<String, Object>) taskResponseNodes.values().iterator().next();, +        Map<String, Object> taskResponseTasks = (Map<String, Object>) taskResponseNode.get("tasks");]