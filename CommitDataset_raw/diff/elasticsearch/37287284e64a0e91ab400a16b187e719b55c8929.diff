[+++ b/docs/reference/mapping/date-format.asciidoc, +When doing `range` type searches with rounding, the value parsed, +depends on whether the end of the range is inclusive or exclusive, and, +whether the beginning or end of the range.  Rounding up moves to the, +last millisecond of the rounding scope, and rounding down to the, +first millisecond of the rounding scope. The semantics work as follows:, +* `gt` - round up, and use > that value (`2014-11-18||/M` becomes `2014-11-30T23:59:59.999`, ie excluding the entire month), +* `gte` - round D down, and use >= that value (`2014-11-18||/M` becomes `2014-11-01`, ie including the entire month), +* `lt` - round D down, and use < that value (`2014-11-18||/M` becomes `2014-11-01`, ie excluding the entire month), +* `lte` - round D up, and use <= that value(`2014-11-18||/M` becomes `2014-11-30T23:59:59.999`, ie including the entire month), +++ b/docs/reference/mapping/date-format.asciidoc, +When doing `range` type searches with rounding, the value parsed, +depends on whether the end of the range is inclusive or exclusive, and, +whether the beginning or end of the range.  Rounding up moves to the, +last millisecond of the rounding scope, and rounding down to the, +first millisecond of the rounding scope. The semantics work as follows:, +* `gt` - round up, and use > that value (`2014-11-18||/M` becomes `2014-11-30T23:59:59.999`, ie excluding the entire month), +* `gte` - round D down, and use >= that value (`2014-11-18||/M` becomes `2014-11-01`, ie including the entire month), +* `lt` - round D down, and use < that value (`2014-11-18||/M` becomes `2014-11-01`, ie excluding the entire month), +* `lte` - round D up, and use <= that value(`2014-11-18||/M` becomes `2014-11-30T23:59:59.999`, ie including the entire month), +++ b/src/main/java/org/elasticsearch/common/joda/DateMathParser.java, +import org.apache.commons.lang3.StringUtils;, + * A parser for date/time formatted text with optional date math., + * , + * The format of the datetime is configurable, and unix timestamps can also be used. Datemath, + * is appended to a datetime with the following syntax:, + * <code>||[+-/](\d+)?[yMwdhHms]</code>., +        if (dateTimeFormatter == null) throw new NullPointerException();, +        if (timeUnit == null) throw new NullPointerException();, +    public long parse(String text, long now, boolean roundUp, DateTimeZone timeZone) {, +                return parseDateTime(text, timeZone);, +            }, +            time = parseDateTime(text.substring(0, index), timeZone);, +        }, +        return parseMath(mathString, time, roundUp);, +                    // we want to go up to the next whole value, even if we are already on a rounded value, +                    propertyToRound.add(1);, +                    propertyToRound.roundFloor();, +    private long parseDateTime(String value, DateTimeZone timeZone) {, +        , +        // first check for timestamp, +        if (value.length() > 4 && StringUtils.isNumeric(value)) {, +            try {, +                long time = Long.parseLong(value);, +                return timeUnit.toMillis(time);, +            } catch (NumberFormatException e) {, +                throw new ElasticsearchParseException("failed to parse date field [" + value + "] as timestamp", e);, +            }, +        } catch (IllegalArgumentException e) {, +            throw new ElasticsearchParseException("failed to parse date field [" + value + "] with format [" + dateTimeFormatter.format() + "]", e);, +++ b/docs/reference/mapping/date-format.asciidoc, +When doing `range` type searches with rounding, the value parsed, +depends on whether the end of the range is inclusive or exclusive, and, +whether the beginning or end of the range.  Rounding up moves to the, +last millisecond of the rounding scope, and rounding down to the, +first millisecond of the rounding scope. The semantics work as follows:, +* `gt` - round up, and use > that value (`2014-11-18||/M` becomes `2014-11-30T23:59:59.999`, ie excluding the entire month), +* `gte` - round D down, and use >= that value (`2014-11-18||/M` becomes `2014-11-01`, ie including the entire month), +* `lt` - round D down, and use < that value (`2014-11-18||/M` becomes `2014-11-01`, ie excluding the entire month), +* `lte` - round D up, and use <= that value(`2014-11-18||/M` becomes `2014-11-30T23:59:59.999`, ie including the entire month), +++ b/src/main/java/org/elasticsearch/common/joda/DateMathParser.java, +import org.apache.commons.lang3.StringUtils;, + * A parser for date/time formatted text with optional date math., + * , + * The format of the datetime is configurable, and unix timestamps can also be used. Datemath, + * is appended to a datetime with the following syntax:, + * <code>||[+-/](\d+)?[yMwdhHms]</code>., +        if (dateTimeFormatter == null) throw new NullPointerException();, +        if (timeUnit == null) throw new NullPointerException();, +    public long parse(String text, long now, boolean roundUp, DateTimeZone timeZone) {, +                return parseDateTime(text, timeZone);, +            }, +            time = parseDateTime(text.substring(0, index), timeZone);, +        }, +        return parseMath(mathString, time, roundUp);, +                    // we want to go up to the next whole value, even if we are already on a rounded value, +                    propertyToRound.add(1);, +                    propertyToRound.roundFloor();, +    private long parseDateTime(String value, DateTimeZone timeZone) {, +        , +        // first check for timestamp, +        if (value.length() > 4 && StringUtils.isNumeric(value)) {, +            try {, +                long time = Long.parseLong(value);, +                return timeUnit.toMillis(time);, +            } catch (NumberFormatException e) {, +                throw new ElasticsearchParseException("failed to parse date field [" + value + "] as timestamp", e);, +            }, +        } catch (IllegalArgumentException e) {, +            throw new ElasticsearchParseException("failed to parse date field [" + value + "] with format [" + dateTimeFormatter.format() + "]", e);, +++ b/src/main/java/org/elasticsearch/index/mapper/core/DateFieldMapper.java, +                    fieldType.numericPrecisionStep(), boost, fieldType, docValues, nullValue, timeUnit, ignoreMalformed(context), coerce(context),, +                              String nullValue, TimeUnit timeUnit, Explicit<Boolean> ignoreMalformed,Explicit<Boolean> coerce,, +        return dateParser.parse(value, now, inclusive, zone);, +++ b/docs/reference/mapping/date-format.asciidoc, +When doing `range` type searches with rounding, the value parsed, +depends on whether the end of the range is inclusive or exclusive, and, +whether the beginning or end of the range.  Rounding up moves to the, +last millisecond of the rounding scope, and rounding down to the, +first millisecond of the rounding scope. The semantics work as follows:]