[+++ b/src/main/java/org/elasticsearch/cluster/routing/allocation/AllocationService.java, +import org.elasticsearch.cluster.routing.allocation.decider.Decision;, +            Decision decision = allocation.deciders().canRemain(shardRouting, routingNode, allocation);, +            if (decision.type() == Decision.Type.NO) {, +++ b/src/main/java/org/elasticsearch/cluster/routing/allocation/AllocationService.java, +import org.elasticsearch.cluster.routing.allocation.decider.Decision;, +            Decision decision = allocation.deciders().canRemain(shardRouting, routingNode, allocation);, +            if (decision.type() == Decision.Type.NO) {, +++ b/src/main/java/org/elasticsearch/cluster/routing/allocation/allocator/EvenShardsCountAllocator.java, +                    Decision rebalanceDecision = allocation.deciders().canRebalance(startedShard, allocation);, +                    if (rebalanceDecision.type() == Decision.Type.NO) {, +                    Decision allocateDecision = allocation.deciders().canAllocate(startedShard, lowRoutingNode, allocation);, +                    if (allocateDecision.type() == Decision.Type.YES) {, +++ b/src/main/java/org/elasticsearch/cluster/routing/allocation/AllocationService.java, +import org.elasticsearch.cluster.routing.allocation.decider.Decision;, +            Decision decision = allocation.deciders().canRemain(shardRouting, routingNode, allocation);, +            if (decision.type() == Decision.Type.NO) {, +++ b/src/main/java/org/elasticsearch/cluster/routing/allocation/allocator/EvenShardsCountAllocator.java, +                    Decision rebalanceDecision = allocation.deciders().canRebalance(startedShard, allocation);, +                    if (rebalanceDecision.type() == Decision.Type.NO) {, +                    Decision allocateDecision = allocation.deciders().canAllocate(startedShard, lowRoutingNode, allocation);, +                    if (allocateDecision.type() == Decision.Type.YES) {, +++ b/src/main/java/org/elasticsearch/cluster/routing/allocation/decider/AllocationDecider.java, +    /**, +     * Are we allowed to rebalance this shard?, +     */, +    public Decision canRebalance(ShardRouting shardRouting, RoutingAllocation allocation) {, +        return Decision.ALWAYS;, +    /**, +     * Can the provided shard routing be allocated on the node., +     */, +    public Decision canRemain(ShardRouting shardRouting, RoutingNode node, RoutingAllocation allocation) {, +        return Decision.ALWAYS;, +++ b/src/main/java/org/elasticsearch/cluster/routing/allocation/AllocationService.java, +import org.elasticsearch.cluster.routing.allocation.decider.Decision;, +            Decision decision = allocation.deciders().canRemain(shardRouting, routingNode, allocation);, +            if (decision.type() == Decision.Type.NO) {, +++ b/src/main/java/org/elasticsearch/cluster/routing/allocation/allocator/EvenShardsCountAllocator.java, +                    Decision rebalanceDecision = allocation.deciders().canRebalance(startedShard, allocation);, +                    if (rebalanceDecision.type() == Decision.Type.NO) {, +                    Decision allocateDecision = allocation.deciders().canAllocate(startedShard, lowRoutingNode, allocation);, +                    if (allocateDecision.type() == Decision.Type.YES) {, +++ b/src/main/java/org/elasticsearch/cluster/routing/allocation/decider/AllocationDecider.java, +    /**, +     * Are we allowed to rebalance this shard?, +     */, +    public Decision canRebalance(ShardRouting shardRouting, RoutingAllocation allocation) {, +        return Decision.ALWAYS;, +    /**, +     * Can the provided shard routing be allocated on the node., +     */, +    public Decision canRemain(ShardRouting shardRouting, RoutingNode node, RoutingAllocation allocation) {, +        return Decision.ALWAYS;, +++ b/src/main/java/org/elasticsearch/cluster/routing/allocation/decider/AllocationDeciders.java, +    public Decision canRebalance(ShardRouting shardRouting, RoutingAllocation allocation) {, +        Decision.Multi ret = new Decision.Multi();, +        for (AllocationDecider allocationDecider : allocations) {, +            Decision decision = allocationDecider.canRebalance(shardRouting, allocation);, +            if (decision != Decision.ALWAYS) {, +                ret.add(decision);, +        return ret;, +    public Decision canRemain(ShardRouting shardRouting, RoutingNode node, RoutingAllocation allocation) {, +            return Decision.NO;, +        Decision.Multi ret = new Decision.Multi();, +        for (AllocationDecider allocationDecider : allocations) {, +            Decision decision = allocationDecider.canRemain(shardRouting, node, allocation);, +            if (decision != Decision.ALWAYS) {, +                ret.add(decision);, +        return ret;, +++ b/src/main/java/org/elasticsearch/cluster/routing/allocation/AllocationService.java, +import org.elasticsearch.cluster.routing.allocation.decider.Decision;, +            Decision decision = allocation.deciders().canRemain(shardRouting, routingNode, allocation);, +            if (decision.type() == Decision.Type.NO) {, +++ b/src/main/java/org/elasticsearch/cluster/routing/allocation/allocator/EvenShardsCountAllocator.java, +                    Decision rebalanceDecision = allocation.deciders().canRebalance(startedShard, allocation);, +                    if (rebalanceDecision.type() == Decision.Type.NO) {, +                    Decision allocateDecision = allocation.deciders().canAllocate(startedShard, lowRoutingNode, allocation);, +                    if (allocateDecision.type() == Decision.Type.YES) {, +++ b/src/main/java/org/elasticsearch/cluster/routing/allocation/decider/AllocationDecider.java, +    /**, +     * Are we allowed to rebalance this shard?, +     */, +    public Decision canRebalance(ShardRouting shardRouting, RoutingAllocation allocation) {, +        return Decision.ALWAYS;, +    /**, +     * Can the provided shard routing be allocated on the node., +     */, +    public Decision canRemain(ShardRouting shardRouting, RoutingNode node, RoutingAllocation allocation) {, +        return Decision.ALWAYS;, +++ b/src/main/java/org/elasticsearch/cluster/routing/allocation/decider/AllocationDeciders.java, +    public Decision canRebalance(ShardRouting shardRouting, RoutingAllocation allocation) {, +        Decision.Multi ret = new Decision.Multi();, +        for (AllocationDecider allocationDecider : allocations) {, +            Decision decision = allocationDecider.canRebalance(shardRouting, allocation);, +            if (decision != Decision.ALWAYS) {, +                ret.add(decision);, +        return ret;, +    public Decision canRemain(ShardRouting shardRouting, RoutingNode node, RoutingAllocation allocation) {, +            return Decision.NO;, +        Decision.Multi ret = new Decision.Multi();]