[+++ b/server/src/main/java/org/elasticsearch/index/engine/Engine.java, +     * Do not replay translog operations, but make the engine be ready., +     */, +    public abstract void skipTranslogRecovery();, +, +    /**, +++ b/server/src/main/java/org/elasticsearch/index/engine/Engine.java, +     * Do not replay translog operations, but make the engine be ready., +     */, +    public abstract void skipTranslogRecovery();, +, +    /**, +++ b/server/src/main/java/org/elasticsearch/index/engine/InternalEngine.java, +    @Override, +    public void skipTranslogRecovery() {, +        if (openMode != EngineConfig.OpenMode.OPEN_INDEX_AND_TRANSLOG) {, +            throw new IllegalStateException("Can't skip translog recovery with open mode: " + openMode);, +        }, +        assert pendingTranslogRecovery.get() : "translogRecovery is not pending but should be";, +        pendingTranslogRecovery.set(false); // we are good - now we can commit, +    }, +, +++ b/server/src/main/java/org/elasticsearch/index/engine/Engine.java, +     * Do not replay translog operations, but make the engine be ready., +     */, +    public abstract void skipTranslogRecovery();, +, +    /**, +++ b/server/src/main/java/org/elasticsearch/index/engine/InternalEngine.java, +    @Override, +    public void skipTranslogRecovery() {, +        if (openMode != EngineConfig.OpenMode.OPEN_INDEX_AND_TRANSLOG) {, +            throw new IllegalStateException("Can't skip translog recovery with open mode: " + openMode);, +        }, +        assert pendingTranslogRecovery.get() : "translogRecovery is not pending but should be";, +        pendingTranslogRecovery.set(false); // we are good - now we can commit, +    }, +, +++ b/server/src/main/java/org/elasticsearch/index/shard/IndexShard.java, +    public void openIndexAndRecoveryFromTranslog() throws IOException {, +        getEngine().recoverFromTranslog();, +    }, +, +    /**, +     * Opens the engine on top of the existing lucene engine and translog., +     * The translog is kept but its operations won't be replayed., +     */, +    public void openIndexAndSkipTranslogRecovery() throws IOException {, +        assert recoveryState.getRecoverySource().getType() == RecoverySource.Type.PEER;, +        innerOpenEngineAndTranslog(EngineConfig.OpenMode.OPEN_INDEX_AND_TRANSLOG, false);, +        getEngine().skipTranslogRecovery();, +        createNewEngine(config);, +++ b/server/src/main/java/org/elasticsearch/index/engine/Engine.java, +     * Do not replay translog operations, but make the engine be ready., +     */, +    public abstract void skipTranslogRecovery();, +, +    /**, +++ b/server/src/main/java/org/elasticsearch/index/engine/InternalEngine.java, +    @Override, +    public void skipTranslogRecovery() {, +        if (openMode != EngineConfig.OpenMode.OPEN_INDEX_AND_TRANSLOG) {, +            throw new IllegalStateException("Can't skip translog recovery with open mode: " + openMode);, +        }, +        assert pendingTranslogRecovery.get() : "translogRecovery is not pending but should be";, +        pendingTranslogRecovery.set(false); // we are good - now we can commit, +    }, +, +++ b/server/src/main/java/org/elasticsearch/index/shard/IndexShard.java, +    public void openIndexAndRecoveryFromTranslog() throws IOException {, +        getEngine().recoverFromTranslog();, +    }, +, +    /**, +     * Opens the engine on top of the existing lucene engine and translog., +     * The translog is kept but its operations won't be replayed., +     */, +    public void openIndexAndSkipTranslogRecovery() throws IOException {, +        assert recoveryState.getRecoverySource().getType() == RecoverySource.Type.PEER;, +        innerOpenEngineAndTranslog(EngineConfig.OpenMode.OPEN_INDEX_AND_TRANSLOG, false);, +        getEngine().skipTranslogRecovery();, +        createNewEngine(config);, +++ b/server/src/main/java/org/elasticsearch/index/shard/StoreRecovery.java, +                    indexShard.openIndexAndRecoveryFromTranslog();, +++ b/server/src/main/java/org/elasticsearch/index/engine/Engine.java, +     * Do not replay translog operations, but make the engine be ready., +     */, +    public abstract void skipTranslogRecovery();, +, +    /**, +++ b/server/src/main/java/org/elasticsearch/index/engine/InternalEngine.java, +    @Override, +    public void skipTranslogRecovery() {, +        if (openMode != EngineConfig.OpenMode.OPEN_INDEX_AND_TRANSLOG) {, +            throw new IllegalStateException("Can't skip translog recovery with open mode: " + openMode);, +        }, +        assert pendingTranslogRecovery.get() : "translogRecovery is not pending but should be";, +        pendingTranslogRecovery.set(false); // we are good - now we can commit, +    }, +]