[+++ b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/dataframe/DataFrameMessages.java, +    public static final String DATA_FRAME_UNABLE_TO_GATHER_FIELD_MAPPINGS = "Failed to gather field mappings for index [{0}]";, +++ b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/dataframe/DataFrameMessages.java, +    public static final String DATA_FRAME_UNABLE_TO_GATHER_FIELD_MAPPINGS = "Failed to gather field mappings for index [{0}]";, +++ b/x-pack/plugin/data-frame/qa/single-node-tests/src/test/java/org/elasticsearch/xpack/dataframe/integration/DataFramePivotRestIT.java, +import static org.hamcrest.Matchers.containsString;, +    public void testPivotWithMaxOnDateField() throws Exception {, +        String transformId = "simpleDateHistogramPivotWithMaxTime";, +        String dataFrameIndex = "pivot_reviews_via_date_histogram_with_max_time";, +        setupDataAccessRole(DATA_ACCESS_ROLE, REVIEWS_INDEX_NAME, dataFrameIndex);, +, +        final Request createDataframeTransformRequest = createRequestWithAuth("PUT", DATAFRAME_ENDPOINT + transformId,, +            BASIC_AUTH_VALUE_DATA_FRAME_ADMIN_WITH_SOME_DATA_ACCESS);, +, +        String config = "{", +            + " \"source\": \"" + REVIEWS_INDEX_NAME + "\",", +            + " \"dest\": \"" + dataFrameIndex + "\",";, +, +        config +="    \"pivot\": { \n" +, +            "        \"group_by\": {\n" +, +            "            \"by_day\": {\"date_histogram\": {\n" +, +            "                \"interval\": \"1d\",\"field\":\"timestamp\",\"format\":\"yyyy-MM-DD\"\n" +, +            "            }}\n" +, +            "        },\n" +, +            "    \n" +, +            "    \"aggs\" :{\n" +, +            "        \"avg_rating\": {\n" +, +            "            \"avg\": {\"field\": \"stars\"}\n" +, +            "        },\n" +, +            "        \"timestamp\": {\n" +, +            "            \"max\": {\"field\": \"timestamp\"}\n" +, +            "        }\n" +, +            "    }}", +            + "}";, +, +        createDataframeTransformRequest.setJsonEntity(config);, +        Map<String, Object> createDataframeTransformResponse = entityAsMap(client().performRequest(createDataframeTransformRequest));, +        assertThat(createDataframeTransformResponse.get("acknowledged"), equalTo(Boolean.TRUE));, +        assertTrue(indexExists(dataFrameIndex));, +, +        startAndWaitForTransform(transformId, dataFrameIndex, BASIC_AUTH_VALUE_DATA_FRAME_ADMIN_WITH_SOME_DATA_ACCESS);, +, +        // we expect 21 documents as there shall be 21 days worth of docs, +        Map<String, Object> indexStats = getAsMap(dataFrameIndex + "/_stats");, +        assertEquals(21, XContentMapValues.extractValue("_all.total.docs.count", indexStats));, +        assertOnePivotValue(dataFrameIndex + "/_search?q=by_day:2017-01-15", 3.82);, +        Map<String, Object> searchResult = getAsMap(dataFrameIndex + "/_search?q=by_day:2017-01-15");, +        String actual = (String) ((List<?>) XContentMapValues.extractValue("hits.hits._source.timestamp", searchResult)).get(0);, +        // Do `containsString` as actual ending timestamp is indeterminate due to how data is generated, +        assertThat(actual, containsString("2017-01-15T20:"));, +    }, +, +++ b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/dataframe/DataFrameMessages.java, +    public static final String DATA_FRAME_UNABLE_TO_GATHER_FIELD_MAPPINGS = "Failed to gather field mappings for index [{0}]";, +++ b/x-pack/plugin/data-frame/qa/single-node-tests/src/test/java/org/elasticsearch/xpack/dataframe/integration/DataFramePivotRestIT.java, +import static org.hamcrest.Matchers.containsString;, +    public void testPivotWithMaxOnDateField() throws Exception {, +        String transformId = "simpleDateHistogramPivotWithMaxTime";, +        String dataFrameIndex = "pivot_reviews_via_date_histogram_with_max_time";, +        setupDataAccessRole(DATA_ACCESS_ROLE, REVIEWS_INDEX_NAME, dataFrameIndex);, +, +        final Request createDataframeTransformRequest = createRequestWithAuth("PUT", DATAFRAME_ENDPOINT + transformId,, +            BASIC_AUTH_VALUE_DATA_FRAME_ADMIN_WITH_SOME_DATA_ACCESS);, +, +        String config = "{", +            + " \"source\": \"" + REVIEWS_INDEX_NAME + "\",", +            + " \"dest\": \"" + dataFrameIndex + "\",";, +, +        config +="    \"pivot\": { \n" +, +            "        \"group_by\": {\n" +, +            "            \"by_day\": {\"date_histogram\": {\n" +, +            "                \"interval\": \"1d\",\"field\":\"timestamp\",\"format\":\"yyyy-MM-DD\"\n" +, +            "            }}\n" +, +            "        },\n" +, +            "    \n" +, +            "    \"aggs\" :{\n" +, +            "        \"avg_rating\": {\n" +, +            "            \"avg\": {\"field\": \"stars\"}\n" +, +            "        },\n" +, +            "        \"timestamp\": {\n" +, +            "            \"max\": {\"field\": \"timestamp\"}\n" +, +            "        }\n" +, +            "    }}", +            + "}";, +, +        createDataframeTransformRequest.setJsonEntity(config);, +        Map<String, Object> createDataframeTransformResponse = entityAsMap(client().performRequest(createDataframeTransformRequest));, +        assertThat(createDataframeTransformResponse.get("acknowledged"), equalTo(Boolean.TRUE));, +        assertTrue(indexExists(dataFrameIndex));, +, +        startAndWaitForTransform(transformId, dataFrameIndex, BASIC_AUTH_VALUE_DATA_FRAME_ADMIN_WITH_SOME_DATA_ACCESS);, +, +        // we expect 21 documents as there shall be 21 days worth of docs, +        Map<String, Object> indexStats = getAsMap(dataFrameIndex + "/_stats");, +        assertEquals(21, XContentMapValues.extractValue("_all.total.docs.count", indexStats));, +        assertOnePivotValue(dataFrameIndex + "/_search?q=by_day:2017-01-15", 3.82);, +        Map<String, Object> searchResult = getAsMap(dataFrameIndex + "/_search?q=by_day:2017-01-15");, +        String actual = (String) ((List<?>) XContentMapValues.extractValue("hits.hits._source.timestamp", searchResult)).get(0);, +        // Do `containsString` as actual ending timestamp is indeterminate due to how data is generated, +        assertThat(actual, containsString("2017-01-15T20:"));]