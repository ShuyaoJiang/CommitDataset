[+++ b/docs/reference/mapping/fields/source-field.asciidoc, +++ b/docs/reference/mapping/fields/source-field.asciidoc, +++ b/docs/reference/migration/migrate_2_0.asciidoc, +==== Boolean fields, +==== Murmur3 Fields, +==== Source field configuration, +The `_source` field no longer supports `includes` and `excludes` paramters. When, +`_source` is enabled, the entire original source will be stored., +, +++ b/docs/reference/mapping/fields/source-field.asciidoc, +++ b/docs/reference/migration/migrate_2_0.asciidoc, +==== Boolean fields, +==== Murmur3 Fields, +==== Source field configuration, +The `_source` field no longer supports `includes` and `excludes` paramters. When, +`_source` is enabled, the entire original source will be stored., +, +++ b/src/main/java/org/elasticsearch/index/mapper/internal/SourceFieldMapper.java, +import org.elasticsearch.Version;, +                } else if (fieldName.equals("includes") && parserContext.indexVersionCreated().before(Version.V_2_0_0)) {, +                } else if (fieldName.equals("excludes") && parserContext.indexVersionCreated().before(Version.V_2_0_0)) {, +++ b/docs/reference/mapping/fields/source-field.asciidoc, +++ b/docs/reference/migration/migrate_2_0.asciidoc, +==== Boolean fields, +==== Murmur3 Fields, +==== Source field configuration, +The `_source` field no longer supports `includes` and `excludes` paramters. When, +`_source` is enabled, the entire original source will be stored., +, +++ b/src/main/java/org/elasticsearch/index/mapper/internal/SourceFieldMapper.java, +import org.elasticsearch.Version;, +                } else if (fieldName.equals("includes") && parserContext.indexVersionCreated().before(Version.V_2_0_0)) {, +                } else if (fieldName.equals("excludes") && parserContext.indexVersionCreated().before(Version.V_2_0_0)) {, +++ b/src/test/java/org/elasticsearch/get/GetActionTests.java, +import org.elasticsearch.Version;, +import org.elasticsearch.cluster.metadata.IndexMetaData;, +                .setSettings("index.refresh_interval", -1, IndexMetaData.SETTING_VERSION_CREATED, Version.V_1_4_2.id));, +                .setSettings("index.refresh_interval", -1, IndexMetaData.SETTING_VERSION_CREATED, Version.V_1_4_2.id));, +                .setSettings("index.refresh_interval", -1, IndexMetaData.SETTING_VERSION_CREATED, Version.V_1_4_2.id));, +++ b/docs/reference/mapping/fields/source-field.asciidoc, +++ b/docs/reference/migration/migrate_2_0.asciidoc, +==== Boolean fields, +==== Murmur3 Fields, +==== Source field configuration, +The `_source` field no longer supports `includes` and `excludes` paramters. When, +`_source` is enabled, the entire original source will be stored., +, +++ b/src/main/java/org/elasticsearch/index/mapper/internal/SourceFieldMapper.java, +import org.elasticsearch.Version;, +                } else if (fieldName.equals("includes") && parserContext.indexVersionCreated().before(Version.V_2_0_0)) {, +                } else if (fieldName.equals("excludes") && parserContext.indexVersionCreated().before(Version.V_2_0_0)) {, +++ b/src/test/java/org/elasticsearch/get/GetActionTests.java, +import org.elasticsearch.Version;, +import org.elasticsearch.cluster.metadata.IndexMetaData;, +                .setSettings("index.refresh_interval", -1, IndexMetaData.SETTING_VERSION_CREATED, Version.V_1_4_2.id));, +                .setSettings("index.refresh_interval", -1, IndexMetaData.SETTING_VERSION_CREATED, Version.V_1_4_2.id));, +                .setSettings("index.refresh_interval", -1, IndexMetaData.SETTING_VERSION_CREATED, Version.V_1_4_2.id));, +++ b/src/test/java/org/elasticsearch/index/mapper/source/DefaultSourceMappingTests.java, +import org.elasticsearch.Version;, +import org.elasticsearch.cluster.metadata.IndexMetaData;, +import org.elasticsearch.common.settings.Settings;, +    public void testIncludesBackcompat() throws Exception {, +        try {, +            createIndex("testbad").mapperService().documentMapperParser().parse(mapping);, +            fail("includes should not be allowed");, +        } catch (MapperParsingException e) {, +            assertTrue(e.getMessage().contains("unsupported parameters"));, +        }, +, +        Settings settings = ImmutableSettings.builder().put(IndexMetaData.SETTING_VERSION_CREATED, Version.V_1_4_2.id).build();, +        DocumentMapper documentMapper = createIndex("test", settings).mapperService().documentMapperParser().parse(mapping);, +    public void testExcludesBackcompat() throws Exception {, +        String mapping = XContentFactory.jsonBuilder().startObject().startObject("type"), +            .startObject("_source").field("excludes", new String[]{"path1*"}).endObject(), +            .endObject().endObject().string();, +, +        try {, +            createIndex("testbad").mapperService().documentMapperParser().parse(mapping);, +            fail("excludes should not be allowed");, +        } catch (MapperParsingException e) {, +            assertTrue(e.getMessage().contains("unsupported parameters"));, +        }, +, +        Settings settings = ImmutableSettings.builder().put(IndexMetaData.SETTING_VERSION_CREATED, Version.V_1_4_2.id).build();, +        DocumentMapper documentMapper = createIndex("test", settings).mapperService().documentMapperParser().parse(mapping);, +, +        ParsedDocument doc = documentMapper.parse("type", "1", XContentFactory.jsonBuilder().startObject(), +            .startObject("path1").field("field1", "value1").endObject(), +            .startObject("path2").field("field2", "value2").endObject(), +            .endObject().bytes());, +, +        IndexableField sourceField = doc.rootDoc().getField("_source");, +        Map<String, Object> sourceAsMap = XContentFactory.xContent(XContentType.JSON).createParser(new BytesArray(sourceField.binaryValue())).mapAndClose();, +        assertThat(sourceAsMap.containsKey("path1"), equalTo(false));, +        assertThat(sourceAsMap.containsKey("path2"), equalTo(true));, +    }, +, +++ b/docs/reference/mapping/fields/source-field.asciidoc, +++ b/docs/reference/migration/migrate_2_0.asciidoc, +==== Boolean fields]