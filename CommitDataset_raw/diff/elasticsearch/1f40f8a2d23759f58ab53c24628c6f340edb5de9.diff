[+++ b/core/src/main/java/org/elasticsearch/action/search/FetchSearchPhase.java, +            -> moveToNextPhase(searchPhaseController, scrollId, reducedQueryPhase, queryAndFetchOptimization ?, +            final IntArrayList[] docIdsToLoad = searchPhaseController.fillDocIdsToLoad(numShards, reducedQueryPhase.scoreDocs);, +            if (reducedQueryPhase.scoreDocs.length == 0) { // no docs to fetch -- sidestep everything and return, +                    searchPhaseController.getLastEmittedDocPerShard(reducedQueryPhase, numShards), +        if (context.getRequest().scroll() == null && queryResult.hasSearchContext()) {, +    private void moveToNextPhase(SearchPhaseController searchPhaseController,, +            reducedQueryPhase, fetchResultsArr.asList(), fetchResultsArr::get);, +++ b/core/src/main/java/org/elasticsearch/action/search/FetchSearchPhase.java, +            -> moveToNextPhase(searchPhaseController, scrollId, reducedQueryPhase, queryAndFetchOptimization ?, +            final IntArrayList[] docIdsToLoad = searchPhaseController.fillDocIdsToLoad(numShards, reducedQueryPhase.scoreDocs);, +            if (reducedQueryPhase.scoreDocs.length == 0) { // no docs to fetch -- sidestep everything and return, +                    searchPhaseController.getLastEmittedDocPerShard(reducedQueryPhase, numShards), +        if (context.getRequest().scroll() == null && queryResult.hasSearchContext()) {, +    private void moveToNextPhase(SearchPhaseController searchPhaseController,, +            reducedQueryPhase, fetchResultsArr.asList(), fetchResultsArr::get);, +++ b/core/src/main/java/org/elasticsearch/action/search/SearchPhaseController.java, +import org.elasticsearch.search.DocValueFormat;, +     * @param bufferedTopDocs the pre-consumed buffered top docs, +     * @param topDocsStats the top docs stats to fill, +     * @param from the offset into the search results top docs, +     * @param size the number of hits to return from the merged top docs, +    public SortedTopDocs sortDocs(boolean ignoreFrom, Collection<? extends SearchPhaseResult> results,, +                               final Collection<TopDocs> bufferedTopDocs, final TopDocsStats topDocsStats, int from, int size) {, +            return SortedTopDocs.EMPTY;, +        final Collection<TopDocs> topDocs = bufferedTopDocs == null ? new ArrayList<>() : bufferedTopDocs;, +        for (SearchPhaseResult sortedResult : results) { // TODO we can move this loop into the reduce call to only loop over this once, +            if (queryResult.hasConsumedTopDocs() == false) { // already consumed?, +                final TopDocs td = queryResult.consumeTopDocs();, +                assert td != null;, +                topDocsStats.add(td);, +                if (td.scoreDocs.length > 0) { // make sure we set the shard index before we add it - the consumer didn't do that yet, +            }, +            if (queryResult.hasSuggestHits()) {, +        final boolean hasHits = (groupedCompletionSuggestions.isEmpty() && topDocs.isEmpty()) == false;, +        if (hasHits) {, +            final TopDocs mergedTopDocs = mergeTopDocs(topDocs, size, ignoreFrom ? 0 : from);, +            final ScoreDoc[] mergedScoreDocs = mergedTopDocs == null ? EMPTY_DOCS : mergedTopDocs.scoreDocs;, +            final boolean isSortedByField;, +            final SortField[] sortFields;, +            if (mergedTopDocs != null && mergedTopDocs instanceof TopFieldDocs) {, +                TopFieldDocs fieldDocs = (TopFieldDocs) mergedTopDocs;, +                isSortedByField = (fieldDocs instanceof CollapseTopFieldDocs &&, +                    fieldDocs.fields.length == 1 && fieldDocs.fields[0].getType() == SortField.Type.SCORE) == false;, +                sortFields = fieldDocs.fields;, +                isSortedByField = false;, +                sortFields = null;, +            }, +            return new SortedTopDocs(scoreDocs, isSortedByField, sortFields);, +        } else {, +            // no relevant docs, +            return SortedTopDocs.EMPTY;, +    TopDocs mergeTopDocs(Collection<TopDocs> results, int topN, int from) {, +            return null;, +        assert results.isEmpty() == false;, +            return topDocs;, +        return mergedTopDocs;, +    public ScoreDoc[] getLastEmittedDocPerShard(ReducedQueryPhase reducedQueryPhase, int numShards) {, +        final ScoreDoc[] lastEmittedDocPerShard = new ScoreDoc[numShards];, +        if (reducedQueryPhase.isEmptyResult == false) {, +            final ScoreDoc[] sortedScoreDocs = reducedQueryPhase.scoreDocs;, +            long size = Math.min(reducedQueryPhase.fetchHits, reducedQueryPhase.size);, +    public InternalSearchResponse merge(boolean ignoreFrom, ReducedQueryPhase reducedQueryPhase,, +        if (reducedQueryPhase.isEmptyResult) {, +        ScoreDoc[] sortedDocs = reducedQueryPhase.scoreDocs;, +        SearchHits hits = getHits(reducedQueryPhase, ignoreFrom, fetchResults, resultsLookup);, +    private SearchHits getHits(ReducedQueryPhase reducedQueryPhase, boolean ignoreFrom,, +        final boolean sorted = reducedQueryPhase.isSortedByField;, +        ScoreDoc[] sortedDocs = reducedQueryPhase.scoreDocs;, +        if (sorted) {, +            for (int i = 0; i < reducedQueryPhase.sortField.length; i++) {, +                if (reducedQueryPhase.sortField[i].getType() == SortField.Type.SCORE) {, +        int from = ignoreFrom ? 0 : reducedQueryPhase.from;, +        int numSearchHits = (int) Math.min(reducedQueryPhase.fetchHits - from, reducedQueryPhase.size);, +                        searchHit.sortValues(fieldDoc.fields, reducedQueryPhase.sortValueFormats);, +    public ReducedQueryPhase reducedQueryPhase(Collection<? extends SearchPhaseResult> queryResults, boolean isScrollRequest) {, +        return reducedQueryPhase(queryResults, null, new ArrayList<>(), new TopDocsStats(), 0, isScrollRequest);, +     * @param bufferedAggs a list of pre-collected / buffered aggregations. if this list is non-null all aggregations have been consumed, +     *                    from all non-null query results., +     * @param bufferedTopDocs a list of pre-collected / buffered top docs. if this list is non-null all top docs have been consumed, +                                                List<InternalAggregations> bufferedAggs, List<TopDocs> bufferedTopDocs,, +                                                TopDocsStats topDocsStats, int numReducePhases, boolean isScrollRequest) {, +            return new ReducedQueryPhase(topDocsStats.totalHits, topDocsStats.fetchHits, topDocsStats.maxScore,, +                timedOut, terminatedEarly, null, null, null, EMPTY_DOCS, null, null, numReducePhases, false, 0, 0, true);, +        if (bufferedAggs != null) {, +            aggregationsList = bufferedAggs;, +        int from = 0;, +        int size = 0;, +            from = result.from();, +            size = result.size();, +        final SortedTopDocs scoreDocs = this.sortDocs(isScrollRequest, queryResults, bufferedTopDocs, topDocsStats, from, size);, +        return new ReducedQueryPhase(topDocsStats.totalHits, topDocsStats.fetchHits, topDocsStats.maxScore,, +            timedOut, terminatedEarly, suggest, aggregations, shardResults, scoreDocs.scoreDocs, scoreDocs.sortFields,, +            firstResult != null ? firstResult.sortValueFormats() : null,, +            numReducePhases, scoreDocs.isSortedByField, size, from, firstResult == null);, +        // the searches merged top docs, +        final ScoreDoc[] scoreDocs;, +        // the top docs sort fields used to sort the score docs, <code>null</code> if the results are not sorted, +        final SortField[] sortField;, +        // <code>true</code> iff the result score docs is sorted by a field (not score), this implies that <code>sortField</code> is set.]