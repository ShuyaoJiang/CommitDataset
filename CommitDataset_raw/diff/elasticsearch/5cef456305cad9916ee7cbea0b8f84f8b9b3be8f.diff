[+++ b/modules/elasticsearch/src/main/java/org/elasticsearch/cluster/ClusterState.java, +     * are mutable, use them just for read operations</b>, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/cluster/ClusterState.java, +     * are mutable, use them just for read operations</b>, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/indices/cluster/IndicesClusterStateService.java, + * @author kimchy (shay.banon), +        applyNewIndices(event);, +        applyMappings(event);, +        applyNewShards(event);, +        applyDeletedIndices(event);, +        applyDeletedShards(event);, +    }, +, +    private void applyDeletedIndices(final ClusterChangedEvent event) {, +        for (final String index : indicesService.indices()) {, +            if (!event.state().metaData().hasIndex(index)) {, +                if (logger.isDebugEnabled()) {, +                    logger.debug("Index [{}]: Deleting", index);, +                }, +                indicesService.deleteIndex(index);, +                threadPool.execute(new Runnable() {, +                    @Override public void run() {, +                        nodeIndexDeletedAction.nodeIndexDeleted(index, event.state().nodes().localNodeId());, +                    }, +                });, +            }, +        }, +    }, +, +    private void applyDeletedShards(final ClusterChangedEvent event) {, +        RoutingNode routingNodes = event.state().readOnlyRoutingNodes().nodesToShards().get(event.state().nodes().localNodeId());, +        if (routingNodes == null) {, +            return;, +        }, +        for (final String index : indicesService.indices()) {, +            if (event.state().metaData().hasIndex(index)) {, +                // now, go over and delete shards that needs to get deleted, +                Set<Integer> newShardIds = newHashSet();, +                for (final ShardRouting shardRouting : routingNodes) {, +                    if (shardRouting.index().equals(index)) {, +                        newShardIds.add(shardRouting.id());, +                    }, +                }, +                final IndexService indexService = indicesService.indexService(index);, +                if (indexService == null) {, +                    continue;, +                }, +                for (Integer existingShardId : indexService.shardIds()) {, +                    if (!newShardIds.contains(existingShardId)) {, +                        if (logger.isDebugEnabled()) {, +                            logger.debug("Index [{}]: Deleting shard [{}]", index, existingShardId);, +                        }, +                        indexService.deleteShard(existingShardId);, +                    }, +                }, +            }, +        }, +    }, +, +    private void applyNewIndices(final ClusterChangedEvent event) {, +        for (final IndexMetaData indexMetaData : event.state().metaData()) {, +    }, +    private void applyMappings(ClusterChangedEvent event) {, +        for (IndexMetaData indexMetaData : event.state().metaData()) {, +    private void applyNewShards(final ClusterChangedEvent event) throws ElasticSearchException {, +        RoutingTable routingTable = event.state().routingTable();, +        RoutingNode routingNodes = event.state().readOnlyRoutingNodes().nodesToShards().get(event.state().nodes().localNodeId());, +        if (routingNodes == null) {, +            return;, +        }, +        Nodes nodes = event.state().nodes();, +, +]