[+++ b/buildSrc/src/main/resources/checkstyle_suppressions.xml, +  <suppress files="core[/\\]src[/\\]main[/\\]java[/\\]org[/\\]elasticsearch[/\\]indices[/\\]recovery[/\\]StartRecoveryRequest.java" checks="LineLength" />, +++ b/buildSrc/src/main/resources/checkstyle_suppressions.xml, +  <suppress files="core[/\\]src[/\\]main[/\\]java[/\\]org[/\\]elasticsearch[/\\]indices[/\\]recovery[/\\]StartRecoveryRequest.java" checks="LineLength" />, +++ b/core/src/main/java/org/elasticsearch/ElasticsearchException.java, +        StringBuilder message = new StringBuilder("Elasticsearch exception [");, +        message.append(TYPE).append('=').append(type).append(", ");, +        message.append(REASON).append('=').append(reason);, +        if (stack != null) {, +            message.append(", ").append(STACK_TRACE).append('=').append(stack);, +        }, +        message.append(']');, +, +        ElasticsearchException e = new ElasticsearchException(message.toString(), cause);, +, +     * This method is usually used when the {@link Exception} is rendered as a full XContent object., +++ b/buildSrc/src/main/resources/checkstyle_suppressions.xml, +  <suppress files="core[/\\]src[/\\]main[/\\]java[/\\]org[/\\]elasticsearch[/\\]indices[/\\]recovery[/\\]StartRecoveryRequest.java" checks="LineLength" />, +++ b/core/src/main/java/org/elasticsearch/ElasticsearchException.java, +        StringBuilder message = new StringBuilder("Elasticsearch exception [");, +        message.append(TYPE).append('=').append(type).append(", ");, +        message.append(REASON).append('=').append(reason);, +        if (stack != null) {, +            message.append(", ").append(STACK_TRACE).append('=').append(stack);, +        }, +        message.append(']');, +, +        ElasticsearchException e = new ElasticsearchException(message.toString(), cause);, +, +     * This method is usually used when the {@link Exception} is rendered as a full XContent object., +++ b/core/src/main/java/org/elasticsearch/action/admin/cluster/node/tasks/cancel/TransportCancelTasksAction.java, +        boolean canceled = taskManager.cancel(cancellableTask, request.getReason(), banLock::onTaskFinished);, +            if (cancellableTask.shouldCancelChildrenOnCancellation()) {, +                String nodeId = clusterService.localNode().getId();, +        } else {, +++ b/buildSrc/src/main/resources/checkstyle_suppressions.xml, +  <suppress files="core[/\\]src[/\\]main[/\\]java[/\\]org[/\\]elasticsearch[/\\]indices[/\\]recovery[/\\]StartRecoveryRequest.java" checks="LineLength" />, +++ b/core/src/main/java/org/elasticsearch/ElasticsearchException.java, +        StringBuilder message = new StringBuilder("Elasticsearch exception [");, +        message.append(TYPE).append('=').append(type).append(", ");, +        message.append(REASON).append('=').append(reason);, +        if (stack != null) {, +            message.append(", ").append(STACK_TRACE).append('=').append(stack);, +        }, +        message.append(']');, +, +        ElasticsearchException e = new ElasticsearchException(message.toString(), cause);, +, +     * This method is usually used when the {@link Exception} is rendered as a full XContent object., +++ b/core/src/main/java/org/elasticsearch/action/admin/cluster/node/tasks/cancel/TransportCancelTasksAction.java, +        boolean canceled = taskManager.cancel(cancellableTask, request.getReason(), banLock::onTaskFinished);, +            if (cancellableTask.shouldCancelChildrenOnCancellation()) {, +                String nodeId = clusterService.localNode().getId();, +        } else {, +++ b/core/src/main/java/org/elasticsearch/action/search/AbstractSearchAsyncAction.java, +import org.elasticsearch.cluster.node.DiscoveryNode;, +, +    protected final int expectedSuccessfulOps;, +    protected final AtomicInteger successfulOps = new AtomicInteger();, +    protected final AtomicArray<FirstResult> firstResults;, +    protected volatile ScoreDoc[] sortedShardDocs;, +                                        Executor executor, SearchRequest request, ActionListener<SearchResponse> listener,, +                                        GroupShardsIterator shardsIts, long startTime, long clusterStateVersion, SearchTask task) {, +        firstResults = new AtomicArray<>(shardsIts.size());, +                performFirstPhase(shardIndex, shardIt, shard);, +                onFirstPhaseResult(shardIndex, null, null, shardIt, new NoShardAvailableActionException(shardIt.shardId()));, +    void performFirstPhase(final int shardIndex, final ShardIterator shardIt, final ShardRouting shard) {, +            onFirstPhaseResult(shardIndex, null, null, shardIt, new NoShardAvailableActionException(shardIt.shardId()));, +                        onFirstPhaseResult(shardIndex, shard.currentNodeId(), result, shardIt);, +                        onFirstPhaseResult(shardIndex, shard, connection.getNode().getId(), shardIt, t);, +                onFirstPhaseResult(shardIndex, shard, shard.currentNodeId(), shardIt, ex);, +    private void onFirstPhaseResult(int shardIndex, String nodeId, FirstResult result, ShardIterator shardIt) {, +            try {, +                innerMoveToSecondPhase();, +            } catch (Exception e) {, +                if (logger.isDebugEnabled()) {, +                    logger.debug(, +                        (Supplier<?>) () -> new ParameterizedMessage(, +                            "{}: Failed to execute [{}] while moving to second phase",, +                            shardIt.shardId(),, +                            request),, +                        e);, +                }, +                raiseEarlyFailure(new ReduceSearchPhaseException(firstPhaseName(), "", e, buildShardFailures()));, +            }, +    private void onFirstPhaseResult(final int shardIndex, @Nullable ShardRouting shard, @Nullable String nodeId,, +                    logger.debug((Supplier<?>) () -> new ParameterizedMessage("All shards failed for phase: [{}]", firstPhaseName()), e);, +                raiseEarlyFailure(new SearchPhaseExecutionException(firstPhaseName(), "all shards failed", e, shardSearchFailures));, +                try {, +                    innerMoveToSecondPhase();, +                } catch (Exception inner) {, +                    inner.addSuppressed(e);, +                    raiseEarlyFailure(new ReduceSearchPhaseException(firstPhaseName(), "", inner, shardSearchFailures));, +                }, +                    performFirstPhase(shardIndex, shardIt, nextShard);, +                    onFirstPhaseResult(shardIndex, shard, shard.currentNodeId(), shardIt, inner);, +        for (AtomicArray.Entry<FirstResult> entry : firstResults.asList()) {, +    /**, +     * Releases shard targets that are not used in the docsIdsToLoad., +     */]