[+++ b/core/src/main/java/org/apache/lucene/queries/MinDocQuery.java, +import org.apache.lucene.index.IndexReader;, +    // Matching documents depend on the sequence of segments that the index reader, +    // wraps. Yet matches must be cacheable per-segment, so we need to incorporate, +    // the reader id in the identity of the query so that a cache entry may only, +    // be reused if this query is run against the same index reader., +    private final Object readerId;, +        this(minDoc, null);, +    }, +, +    MinDocQuery(int minDoc, Object readerId) {, +        this.readerId = readerId;, +        return Objects.hash(classHash(), minDoc, readerId);, +        return minDoc == that.minDoc && Objects.equals(readerId, that.readerId);, +    }, +, +    @Override, +    public Query rewrite(IndexReader reader) throws IOException {, +        if (Objects.equals(reader.getContext().id(), readerId) == false) {, +            return new MinDocQuery(minDoc, reader.getContext().id());, +        }, +        return this;, +        if (readerId == null) {, +            throw new IllegalStateException("Rewrite first");, +        } else if (Objects.equals(searcher.getIndexReader().getContext().id(), readerId) == false) {, +            throw new IllegalStateException("Executing against a different reader than the query has been rewritten against");, +        }, +++ b/core/src/main/java/org/apache/lucene/queries/MinDocQuery.java, +import org.apache.lucene.index.IndexReader;, +    // Matching documents depend on the sequence of segments that the index reader, +    // wraps. Yet matches must be cacheable per-segment, so we need to incorporate, +    // the reader id in the identity of the query so that a cache entry may only, +    // be reused if this query is run against the same index reader., +    private final Object readerId;, +        this(minDoc, null);, +    }, +, +    MinDocQuery(int minDoc, Object readerId) {, +        this.readerId = readerId;, +        return Objects.hash(classHash(), minDoc, readerId);, +        return minDoc == that.minDoc && Objects.equals(readerId, that.readerId);, +    }, +, +    @Override, +    public Query rewrite(IndexReader reader) throws IOException {, +        if (Objects.equals(reader.getContext().id(), readerId) == false) {, +            return new MinDocQuery(minDoc, reader.getContext().id());, +        }, +        return this;, +        if (readerId == null) {, +            throw new IllegalStateException("Rewrite first");, +        } else if (Objects.equals(searcher.getIndexReader().getContext().id(), readerId) == false) {, +            throw new IllegalStateException("Executing against a different reader than the query has been rewritten against");, +        }, +++ b/core/src/test/java/org/apache/lucene/queries/MinDocQueryTests.java, +import org.apache.lucene.index.MultiReader;, +import org.apache.lucene.search.Query;, +, +        MinDocQuery query4 = new MinDocQuery(42, new Object());, +        MinDocQuery query5 = new MinDocQuery(42, new Object());, +        QueryUtils.checkUnequal(query4, query5);, +    }, +, +    public void testRewrite() throws Exception {, +        IndexReader reader = new MultiReader();, +        MinDocQuery query = new MinDocQuery(42);, +        Query rewritten = query.rewrite(reader);, +        QueryUtils.checkUnequal(query, rewritten);, +        Query rewritten2 = rewritten.rewrite(reader);, +        assertSame(rewritten, rewritten2);]