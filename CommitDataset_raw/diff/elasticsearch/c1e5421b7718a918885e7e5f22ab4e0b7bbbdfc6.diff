[+++ b/core/src/main/java/org/elasticsearch/common/joda/DateMathParser.java, +                return parseDateTime(text, timeZone, roundUp);, +            time = parseDateTime(text.substring(0, index), timeZone, false);, +    private long parseDateTime(String value, DateTimeZone timeZone, boolean roundUpIfNoTime) {, +            MutableDateTime date;, +            // We use 01/01/1970 as a base date so that things keep working with date, +            // fields that are filled with times without dates, +            if (roundUpIfNoTime) {, +                date = new MutableDateTime(1970, 1, 1, 23, 59, 59, 999, DateTimeZone.UTC);, +            } else {, +                date = new MutableDateTime(1970, 1, 1, 0, 0, 0, 0, DateTimeZone.UTC);, +            }, +            final int end = parser.parseInto(date, value, 0);, +            if (end < 0) {, +                int position = ~end;, +                throw new IllegalArgumentException("Parse failure at index [" + position + "] of [" + value + "]");, +            } else if (end != value.length()) {, +                throw new IllegalArgumentException("Unrecognized chars at the end of [" + value + "]: [" + value.substring(end) + "]");, +            }, +            return date.getMillis();, +++ b/core/src/main/java/org/elasticsearch/common/joda/DateMathParser.java, +                return parseDateTime(text, timeZone, roundUp);, +            time = parseDateTime(text.substring(0, index), timeZone, false);, +    private long parseDateTime(String value, DateTimeZone timeZone, boolean roundUpIfNoTime) {, +            MutableDateTime date;, +            // We use 01/01/1970 as a base date so that things keep working with date, +            // fields that are filled with times without dates, +            if (roundUpIfNoTime) {, +                date = new MutableDateTime(1970, 1, 1, 23, 59, 59, 999, DateTimeZone.UTC);, +            } else {, +                date = new MutableDateTime(1970, 1, 1, 0, 0, 0, 0, DateTimeZone.UTC);, +            }, +            final int end = parser.parseInto(date, value, 0);, +            if (end < 0) {, +                int position = ~end;, +                throw new IllegalArgumentException("Parse failure at index [" + position + "] of [" + value + "]");, +            } else if (end != value.length()) {, +                throw new IllegalArgumentException("Unrecognized chars at the end of [" + value + "]: [" + value.substring(end) + "]");, +            }, +            return date.getMillis();, +++ b/core/src/test/java/org/elasticsearch/common/joda/DateMathParserTests.java, +        assertDateMathEquals("2014-11-12T22:55:00.000Z", "2014-11-12T22:55:00.000Z", 0, true, null);, +        assertDateMathEquals("2014-11-12T22:55:00.000Z", "2014-11-12T22:55:00.000Z", 0, false, null);, +, +        assertDateMathEquals("2014-11-12T22:55:00.000", "2014-11-12T21:55:00.000Z", 0, true, DateTimeZone.forID("+01:00"));, +        assertDateMathEquals("2014-11-12T22:55:00.000", "2014-11-12T21:55:00.000Z", 0, false, DateTimeZone.forID("+01:00"));, +, +        assertDateMathEquals("2014-11-12T22:55:00.000+01:00", "2014-11-12T21:55:00.000Z", 0, true, null);, +        assertDateMathEquals("2014-11-12T22:55:00.000+01:00", "2014-11-12T21:55:00.000Z", 0, false, null);, +    public void testRoundingPreservesEpochAsBaseDate() {, +        // If a user only specifies times, then the date needs to always be 1970-01-01 regardless of rounding, +        FormatDateTimeFormatter formatter = Joda.forPattern("HH:mm:ss");, +        DateMathParser parser = new DateMathParser(formatter);, +        assertEquals(, +                this.formatter.parser().parseMillis("1970-01-01T04:52:20.000Z"),, +                parser.parse("04:52:20", () -> 0, false, null));, +        assertEquals(, +                this.formatter.parser().parseMillis("1970-01-01T04:52:20.999Z"),, +                parser.parse("04:52:20", () -> 0, true, null));, +    }, +, +    // Implicit rounding happening when parts of the date are not specified, +    public void testImplicitRounding() {, +        assertDateMathEquals("2014-11-18", "2014-11-18", 0, false, null);, +        assertDateMathEquals("2014-11-18", "2014-11-18T23:59:59.999Z", 0, true, null);, +, +        assertDateMathEquals("2014-11-18T09:20", "2014-11-18T09:20", 0, false, null);, +        assertDateMathEquals("2014-11-18T09:20", "2014-11-18T09:20:59.999Z", 0, true, null);, +, +        assertDateMathEquals("2014-11-18", "2014-11-17T23:00:00.000Z", 0, false, DateTimeZone.forID("CET"));, +        assertDateMathEquals("2014-11-18", "2014-11-18T22:59:59.999Z", 0, true, DateTimeZone.forID("CET"));, +, +        assertDateMathEquals("2014-11-18T09:20", "2014-11-18T08:20:00.000Z", 0, false, DateTimeZone.forID("CET"));, +        assertDateMathEquals("2014-11-18T09:20", "2014-11-18T08:20:59.999Z", 0, true, DateTimeZone.forID("CET"));, +, +        // implicit rounding with explicit timezone in the date format, +        FormatDateTimeFormatter formatter = Joda.forPattern("YYYY-MM-ddZ");, +        DateMathParser parser = new DateMathParser(formatter);, +        long time = parser.parse("2011-10-09+01:00", () -> 0, false, null);, +        assertEquals(this.parser.parse("2011-10-09T00:00:00.000+01:00", () -> 0), time);, +        time = parser.parse("2011-10-09+01:00", () -> 0, true, null);, +        assertEquals(this.parser.parse("2011-10-09T23:59:59.999+01:00", () -> 0), time);, +    }, +, +    // Explicit rounding using the || separator, +    public void testExplicitRounding() {, +++ b/core/src/main/java/org/elasticsearch/common/joda/DateMathParser.java, +                return parseDateTime(text, timeZone, roundUp);, +            time = parseDateTime(text.substring(0, index), timeZone, false);, +    private long parseDateTime(String value, DateTimeZone timeZone, boolean roundUpIfNoTime) {, +            MutableDateTime date;, +            // We use 01/01/1970 as a base date so that things keep working with date, +            // fields that are filled with times without dates, +            if (roundUpIfNoTime) {, +                date = new MutableDateTime(1970, 1, 1, 23, 59, 59, 999, DateTimeZone.UTC);, +            } else {, +                date = new MutableDateTime(1970, 1, 1, 0, 0, 0, 0, DateTimeZone.UTC);, +            }, +            final int end = parser.parseInto(date, value, 0);, +            if (end < 0) {]