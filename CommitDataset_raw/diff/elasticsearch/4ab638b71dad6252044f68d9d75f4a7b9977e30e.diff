[+++ b/modules/percolator/src/main/java/org/elasticsearch/percolator/PercolatorFieldMapper.java, +            Tuple<BooleanQuery, Boolean> t = createCandidateQuery(indexReader, indexVersion);, +            Query candidateQuery = t.v1();, +            boolean canUseMinimumShouldMatchField = t.v2();, +            if (canUseMinimumShouldMatchField && indexReader.maxDoc() == 1) {, +            return new PercolateQuery(name, queryStore, documents, candidateQuery, searcher, verifiedMatchesQuery);, +        Tuple<BooleanQuery, Boolean> createCandidateQuery(IndexReader indexReader, Version indexVersion) throws IOException {, +            Tuple<List<BytesRef>, Map<String, List<byte[]>>> t = extractTermsAndRanges(indexReader);, +            List<BytesRef> extractedTerms = t.v1();, +            Map<String, List<byte[]>> encodedPointValuesByField = t.v2();, +            // `1 + ` is needed to take into account the EXTRACTION_FAILED should clause, +            boolean canUseMinimumShouldMatchField = 1 + extractedTerms.size() + encodedPointValuesByField.size() <=, +                BooleanQuery.getMaxClauseCount();, +, +            List<Query> subQueries = new ArrayList<>();, +            for (Map.Entry<String, List<byte[]>> entry : encodedPointValuesByField.entrySet()) {, +                String rangeFieldName = entry.getKey();, +                List<byte[]> encodedPointValues = entry.getValue();, +                byte[] min = encodedPointValues.get(0);, +                byte[] max = encodedPointValues.get(1);, +                Query query = BinaryRange.newIntersectsQuery(rangeField.name(), encodeRange(rangeFieldName, min, max));, +                subQueries.add(query);, +            }, +, +            BooleanQuery.Builder candidateQuery = new BooleanQuery.Builder();, +            if (canUseMinimumShouldMatchField && indexVersion.onOrAfter(Version.V_6_1_0)) {, +                LongValuesSource valuesSource = LongValuesSource.fromIntField(minimumShouldMatchField.name());, +                for (BytesRef extractedTerm : extractedTerms) {, +                    subQueries.add(new TermQuery(new Term(queryTermsField.name(), extractedTerm)));, +                }, +                candidateQuery.add(new CoveringQuery(subQueries, valuesSource), BooleanClause.Occur.SHOULD);, +            } else {, +                candidateQuery.add(new TermInSetQuery(queryTermsField.name(), extractedTerms), BooleanClause.Occur.SHOULD);, +                for (Query subQuery : subQueries) {, +                    candidateQuery.add(subQuery, BooleanClause.Occur.SHOULD);, +                }, +            }, +            // include extractionResultField:failed, because docs with this term have no extractedTermsField, +            // and otherwise we would fail to return these docs. Docs that failed query term extraction, +            // always need to be verified by MemoryIndex:, +            candidateQuery.add(new TermQuery(new Term(extractionResultField.name(), EXTRACTION_FAILED)), BooleanClause.Occur.SHOULD);, +            return new Tuple<>(candidateQuery.build(), canUseMinimumShouldMatchField);, +        }, +, +        // This was extracted the method above, because otherwise it is difficult to test what terms are included in, +        // the query in case a CoveringQuery is used (it does not have a getter to retrieve the clauses), +        Tuple<List<BytesRef>, Map<String, List<byte[]>>> extractTermsAndRanges(IndexReader indexReader) throws IOException {, +            return new Tuple<>(extractedTerms, encodedPointValuesByField);, +++ b/modules/percolator/src/main/java/org/elasticsearch/percolator/PercolatorFieldMapper.java, +            Tuple<BooleanQuery, Boolean> t = createCandidateQuery(indexReader, indexVersion);, +            Query candidateQuery = t.v1();, +            boolean canUseMinimumShouldMatchField = t.v2();, +            if (canUseMinimumShouldMatchField && indexReader.maxDoc() == 1) {, +            return new PercolateQuery(name, queryStore, documents, candidateQuery, searcher, verifiedMatchesQuery);, +        Tuple<BooleanQuery, Boolean> createCandidateQuery(IndexReader indexReader, Version indexVersion) throws IOException {, +            Tuple<List<BytesRef>, Map<String, List<byte[]>>> t = extractTermsAndRanges(indexReader);, +            List<BytesRef> extractedTerms = t.v1();, +            Map<String, List<byte[]>> encodedPointValuesByField = t.v2();, +            // `1 + ` is needed to take into account the EXTRACTION_FAILED should clause, +            boolean canUseMinimumShouldMatchField = 1 + extractedTerms.size() + encodedPointValuesByField.size() <=, +                BooleanQuery.getMaxClauseCount();, +, +            List<Query> subQueries = new ArrayList<>();, +            for (Map.Entry<String, List<byte[]>> entry : encodedPointValuesByField.entrySet()) {, +                String rangeFieldName = entry.getKey();, +                List<byte[]> encodedPointValues = entry.getValue();, +                byte[] min = encodedPointValues.get(0);, +                byte[] max = encodedPointValues.get(1);, +                Query query = BinaryRange.newIntersectsQuery(rangeField.name(), encodeRange(rangeFieldName, min, max));, +                subQueries.add(query);, +            }, +, +            BooleanQuery.Builder candidateQuery = new BooleanQuery.Builder();, +            if (canUseMinimumShouldMatchField && indexVersion.onOrAfter(Version.V_6_1_0)) {, +                LongValuesSource valuesSource = LongValuesSource.fromIntField(minimumShouldMatchField.name());, +                for (BytesRef extractedTerm : extractedTerms) {, +                    subQueries.add(new TermQuery(new Term(queryTermsField.name(), extractedTerm)));, +                }, +                candidateQuery.add(new CoveringQuery(subQueries, valuesSource), BooleanClause.Occur.SHOULD);, +            } else {, +                candidateQuery.add(new TermInSetQuery(queryTermsField.name(), extractedTerms), BooleanClause.Occur.SHOULD);, +                for (Query subQuery : subQueries) {, +                    candidateQuery.add(subQuery, BooleanClause.Occur.SHOULD);, +                }, +            }, +            // include extractionResultField:failed, because docs with this term have no extractedTermsField, +            // and otherwise we would fail to return these docs. Docs that failed query term extraction, +            // always need to be verified by MemoryIndex:, +            candidateQuery.add(new TermQuery(new Term(extractionResultField.name(), EXTRACTION_FAILED)), BooleanClause.Occur.SHOULD);, +            return new Tuple<>(candidateQuery.build(), canUseMinimumShouldMatchField);, +        }, +, +        // This was extracted the method above, because otherwise it is difficult to test what terms are included in, +        // the query in case a CoveringQuery is used (it does not have a getter to retrieve the clauses), +        Tuple<List<BytesRef>, Map<String, List<byte[]>>> extractTermsAndRanges(IndexReader indexReader) throws IOException {, +            return new Tuple<>(extractedTerms, encodedPointValuesByField);, +++ b/modules/percolator/src/test/java/org/elasticsearch/percolator/CandidateQueryTests.java, +import org.apache.lucene.search.CoveringQuery;, +                PercolateQuery query = (PercolateQuery), +                BooleanQuery candidateQuery = (BooleanQuery) query.getCandidateMatchesQuery();]