[+++ b/core/src/main/java/org/elasticsearch/action/bulk/TransportBulkAction.java, +++ b/core/src/main/java/org/elasticsearch/action/bulk/TransportBulkAction.java, +++ b/core/src/main/java/org/elasticsearch/action/support/replication/TransportReplicationAction.java, +                            new TransportChannelResponseHandler<>(logger, channel, extraMessage,, +                                () -> TransportResponse.Empty.INSTANCE);, +++ b/core/src/main/java/org/elasticsearch/action/bulk/TransportBulkAction.java, +++ b/core/src/main/java/org/elasticsearch/action/support/replication/TransportReplicationAction.java, +                            new TransportChannelResponseHandler<>(logger, channel, extraMessage,, +                                () -> TransportResponse.Empty.INSTANCE);, +++ b/core/src/main/java/org/elasticsearch/cluster/ClusterStateObserver.java, +import java.util.function.Supplier;, +        listener = new ContextPreservingListener(listener, contextHolder.newRestorableContext(false));, +            final ObservingContext context = new ObservingContext(listener, statePredicate);, +        private final Supplier<ThreadContext.StoredContext> contextSupplier;, +        private ContextPreservingListener(Listener delegate, Supplier<ThreadContext.StoredContext> contextSupplier) {, +            this.contextSupplier = contextSupplier;, +            try (ThreadContext.StoredContext context  = contextSupplier.get()) {, +        }, +            try (ThreadContext.StoredContext context  = contextSupplier.get()) {, +        }, +            try (ThreadContext.StoredContext context  = contextSupplier.get()) {, +}, +++ b/core/src/main/java/org/elasticsearch/action/bulk/TransportBulkAction.java, +++ b/core/src/main/java/org/elasticsearch/action/support/replication/TransportReplicationAction.java, +                            new TransportChannelResponseHandler<>(logger, channel, extraMessage,, +                                () -> TransportResponse.Empty.INSTANCE);, +++ b/core/src/main/java/org/elasticsearch/cluster/ClusterStateObserver.java, +import java.util.function.Supplier;, +        listener = new ContextPreservingListener(listener, contextHolder.newRestorableContext(false));, +            final ObservingContext context = new ObservingContext(listener, statePredicate);, +        private final Supplier<ThreadContext.StoredContext> contextSupplier;, +        private ContextPreservingListener(Listener delegate, Supplier<ThreadContext.StoredContext> contextSupplier) {, +            this.contextSupplier = contextSupplier;, +            try (ThreadContext.StoredContext context  = contextSupplier.get()) {, +        }, +            try (ThreadContext.StoredContext context  = contextSupplier.get()) {, +        }, +            try (ThreadContext.StoredContext context  = contextSupplier.get()) {, +}, +++ b/core/src/main/java/org/elasticsearch/common/util/concurrent/ThreadContext.java, +import org.elasticsearch.index.store.Store;, +import java.util.function.Supplier;, +import java.util.stream.Collectors;, +import java.util.stream.Stream;, +, +     * @param preserveResponseHeaders if set to <code>true</code> the response headers of the restore thread will be preserved., +    public StoredContext newStoredContext(boolean preserveResponseHeaders) {, +        return ()  -> {, +            if (preserveResponseHeaders && threadLocal.get() != context) {, +                threadLocal.set(context.putResponseHeaders(threadLocal.get().responseHeaders));, +            } else {, +                threadLocal.set(context);, +            }, +        };, +    }, +, +    /**, +     * Returns a supplier that gathers a {@link #newStoredContext(boolean)} and restores it once the, +     * returned supplier is invoked. The context returned from the supplier is a stored version of the, +     * suppliers callers context that should be restored once the originally gathered context is not needed anymore., +     * For instance this method should be used like this:, +     *, +     * <pre>, +     *     Supplier&lt;ThreadContext.StoredContext&gt; restorable = context.newRestorableContext(true);, +     *     new Thread() {, +     *         public void run() {, +     *             try (ThreadContext.StoredContext ctx = restorable.get()) {, +     *                 // execute with the parents context and restore the threads context afterwards, +     *             }, +     *         }, +     *, +     *     }.start();, +     * </pre>, +     *, +     * @param preserveResponseHeaders if set to <code>true</code> the response headers of the restore thread will be preserved., +     * @return a restorable context supplier, +     */, +    public Supplier<StoredContext> newRestorableContext(boolean preserveResponseHeaders) {, +        return wrapRestorable(newStoredContext(preserveResponseHeaders));, +    }, +, +    /**, +     * Same as {@link #newRestorableContext(boolean)} but wraps an existing context to restore., +     * @param storedContext the context to restore, +     */, +    public Supplier<StoredContext> wrapRestorable(StoredContext storedContext) {, +        return () -> {, +            StoredContext context = newStoredContext(false);, +            storedContext.restore();, +            return context;, +        };, +        private ThreadContextStruct putResponseHeaders(Map<String, List<String>> headers) {, +            assert headers != null;, +            if (headers.isEmpty()) {, +                return this;, +            }, +            final Map<String, List<String>> newResponseHeaders = new HashMap<>(this.responseHeaders);, +            for (Map.Entry<String, List<String>> entry : headers.entrySet()) {, +                String key = entry.getKey();, +                final List<String> existingValues = newResponseHeaders.get(key);]