[+++ b/buildSrc/src/main/groovy/org/elasticsearch/gradle/precommit/PrecommitTasks.groovy, +                configureForbiddenPatterns(project.tasks)], +++ b/buildSrc/src/main/groovy/org/elasticsearch/gradle/precommit/PrecommitTasks.groovy, +                configureForbiddenPatterns(project.tasks)], +++ b/core/src/main/java/org/elasticsearch/ElasticsearchException.java, +    /**, +     * Construct a <code>ElasticsearchException</code> with the specified cause exception., +     */, +, +++ b/buildSrc/src/main/groovy/org/elasticsearch/gradle/precommit/PrecommitTasks.groovy, +                configureForbiddenPatterns(project.tasks)], +++ b/core/src/main/java/org/elasticsearch/ElasticsearchException.java, +    /**, +     * Construct a <code>ElasticsearchException</code> with the specified cause exception., +     */, +, +++ b/core/src/main/java/org/elasticsearch/action/admin/cluster/health/TransportClusterHealthAction.java, +                    numberOfPendingTasks, numberOfInFlightFetch, UnassignedInfo.getNumberOfDelayedUnassigned(clusterState),, +                numberOfInFlightFetch, UnassignedInfo.getNumberOfDelayedUnassigned(clusterState), pendingTaskTimeInQueue);, +++ b/buildSrc/src/main/groovy/org/elasticsearch/gradle/precommit/PrecommitTasks.groovy, +                configureForbiddenPatterns(project.tasks)], +++ b/core/src/main/java/org/elasticsearch/ElasticsearchException.java, +    /**, +     * Construct a <code>ElasticsearchException</code> with the specified cause exception., +     */, +, +++ b/core/src/main/java/org/elasticsearch/action/admin/cluster/health/TransportClusterHealthAction.java, +                    numberOfPendingTasks, numberOfInFlightFetch, UnassignedInfo.getNumberOfDelayedUnassigned(clusterState),, +                numberOfInFlightFetch, UnassignedInfo.getNumberOfDelayedUnassigned(clusterState), pendingTaskTimeInQueue);, +++ b/core/src/main/java/org/elasticsearch/bootstrap/JNANatives.java, +            logger.warn("unable to install syscall filter: ", t);, +++ b/buildSrc/src/main/groovy/org/elasticsearch/gradle/precommit/PrecommitTasks.groovy, +                configureForbiddenPatterns(project.tasks)], +++ b/core/src/main/java/org/elasticsearch/ElasticsearchException.java, +    /**, +     * Construct a <code>ElasticsearchException</code> with the specified cause exception., +     */, +, +++ b/core/src/main/java/org/elasticsearch/action/admin/cluster/health/TransportClusterHealthAction.java, +                    numberOfPendingTasks, numberOfInFlightFetch, UnassignedInfo.getNumberOfDelayedUnassigned(clusterState),, +                numberOfInFlightFetch, UnassignedInfo.getNumberOfDelayedUnassigned(clusterState), pendingTaskTimeInQueue);, +++ b/core/src/main/java/org/elasticsearch/bootstrap/JNANatives.java, +            logger.warn("unable to install syscall filter: ", t);, +++ b/core/src/main/java/org/elasticsearch/cluster/metadata/MetaDataIndexUpgradeService.java, +            throw new IllegalStateException("unable to upgrade the mappings for the index [" + indexMetaData.getIndex() + "]", ex);, +++ b/buildSrc/src/main/groovy/org/elasticsearch/gradle/precommit/PrecommitTasks.groovy, +                configureForbiddenPatterns(project.tasks)], +++ b/core/src/main/java/org/elasticsearch/ElasticsearchException.java, +    /**, +     * Construct a <code>ElasticsearchException</code> with the specified cause exception., +     */, +, +++ b/core/src/main/java/org/elasticsearch/action/admin/cluster/health/TransportClusterHealthAction.java, +                    numberOfPendingTasks, numberOfInFlightFetch, UnassignedInfo.getNumberOfDelayedUnassigned(clusterState),, +                numberOfInFlightFetch, UnassignedInfo.getNumberOfDelayedUnassigned(clusterState), pendingTaskTimeInQueue);, +++ b/core/src/main/java/org/elasticsearch/bootstrap/JNANatives.java, +            logger.warn("unable to install syscall filter: ", t);, +++ b/core/src/main/java/org/elasticsearch/cluster/metadata/MetaDataIndexUpgradeService.java, +            throw new IllegalStateException("unable to upgrade the mappings for the index [" + indexMetaData.getIndex() + "]", ex);, +++ b/core/src/main/java/org/elasticsearch/cluster/routing/RoutingService.java, +    private volatile long minDelaySettingAtLastScheduling = Long.MAX_VALUE;, +            // Figure out if an existing scheduled reroute is good enough or whether we need to cancel and reschedule., +            // If the minimum of the currently relevant delay settings is larger than something we scheduled in the past,, +            // we are guaranteed that the planned schedule will happen before any of the current shard delays are expired., +            long minDelaySetting = UnassignedInfo.findSmallestDelayedAllocationSetting(settings, event.state());, +            if (minDelaySetting <= 0) {, +                logger.trace("no need to schedule reroute - no delayed unassigned shards, minDelaySetting [{}], scheduled [{}]", minDelaySetting, minDelaySettingAtLastScheduling);, +                minDelaySettingAtLastScheduling = Long.MAX_VALUE;, +            } else if (minDelaySetting < minDelaySettingAtLastScheduling) {, +                FutureUtils.cancel(registeredNextDelayFuture);, +                minDelaySettingAtLastScheduling = minDelaySetting;, +                TimeValue nextDelay = TimeValue.timeValueNanos(UnassignedInfo.findNextDelayedAllocationIn(event.state()));, +                assert nextDelay.nanos() > 0 : "next delay must be non 0 as minDelaySetting is [" + minDelaySetting + "]";, +                        UnassignedInfo.getNumberOfDelayedUnassigned(event.state()), nextDelay);, +                        minDelaySettingAtLastScheduling = Long.MAX_VALUE;, +                        minDelaySettingAtLastScheduling = Long.MAX_VALUE;, +                logger.trace("no need to schedule reroute - current schedule reroute is enough. minDelaySetting [{}], scheduled [{}]", minDelaySetting, minDelaySettingAtLastScheduling);, +    long getMinDelaySettingAtLastScheduling() {, +        return this.minDelaySettingAtLastScheduling;, +++ b/buildSrc/src/main/groovy/org/elasticsearch/gradle/precommit/PrecommitTasks.groovy, +                configureForbiddenPatterns(project.tasks)], +++ b/core/src/main/java/org/elasticsearch/ElasticsearchException.java, +    /**, +     * Construct a <code>ElasticsearchException</code> with the specified cause exception., +     */, +, +++ b/core/src/main/java/org/elasticsearch/action/admin/cluster/health/TransportClusterHealthAction.java, +                    numberOfPendingTasks, numberOfInFlightFetch, UnassignedInfo.getNumberOfDelayedUnassigned(clusterState),, +                numberOfInFlightFetch, UnassignedInfo.getNumberOfDelayedUnassigned(clusterState), pendingTaskTimeInQueue);, +++ b/core/src/main/java/org/elasticsearch/bootstrap/JNANatives.java, +            logger.warn("unable to install syscall filter: ", t);, +++ b/core/src/main/java/org/elasticsearch/cluster/metadata/MetaDataIndexUpgradeService.java, +            throw new IllegalStateException("unable to upgrade the mappings for the index [" + indexMetaData.getIndex() + "]", ex);, +++ b/core/src/main/java/org/elasticsearch/cluster/routing/RoutingService.java, +    private volatile long minDelaySettingAtLastScheduling = Long.MAX_VALUE;, +            // Figure out if an existing scheduled reroute is good enough or whether we need to cancel and reschedule., +            // If the minimum of the currently relevant delay settings is larger than something we scheduled in the past,, +            // we are guaranteed that the planned schedule will happen before any of the current shard delays are expired., +            long minDelaySetting = UnassignedInfo.findSmallestDelayedAllocationSetting(settings, event.state());, +            if (minDelaySetting <= 0) {]