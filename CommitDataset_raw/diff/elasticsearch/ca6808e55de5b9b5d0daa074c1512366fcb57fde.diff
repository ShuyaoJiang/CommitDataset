[+++ b/docs/reference/sql/security.asciidoc, +include-tagged::{sql-tests}/security/roles.yml[cli_drivers], +++ b/docs/reference/sql/security.asciidoc, +include-tagged::{sql-tests}/security/roles.yml[cli_drivers], +++ b/x-pack/plugin/sql/sql-proto/src/main/java/org/elasticsearch/xpack/sql/type/DataType.java, +    OBJECT(      JDBCType.STRUCT,    null,            -1,                0,                 0, false, false, false),, +    NESTED(      JDBCType.STRUCT,    null,            -1,                0,                 0, false, false, false),, +        try {, +        } catch (IllegalArgumentException ex) {, +            return DataType.UNSUPPORTED;, +        }, +++ b/docs/reference/sql/security.asciidoc, +include-tagged::{sql-tests}/security/roles.yml[cli_drivers], +++ b/x-pack/plugin/sql/sql-proto/src/main/java/org/elasticsearch/xpack/sql/type/DataType.java, +    OBJECT(      JDBCType.STRUCT,    null,            -1,                0,                 0, false, false, false),, +    NESTED(      JDBCType.STRUCT,    null,            -1,                0,                 0, false, false, false),, +        try {, +        } catch (IllegalArgumentException ex) {, +            return DataType.UNSUPPORTED;, +        }, +++ b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/analysis/index/IndexResolver.java, +import org.elasticsearch.action.fieldcaps.FieldCapabilities;, +import org.elasticsearch.action.fieldcaps.FieldCapabilitiesRequest;, +import org.elasticsearch.xpack.sql.SqlIllegalArgumentException;, +import org.elasticsearch.xpack.sql.type.DataType;, +import org.elasticsearch.xpack.sql.type.DateEsField;, +import org.elasticsearch.xpack.sql.type.KeywordEsField;, +import org.elasticsearch.xpack.sql.type.TextEsField;, +import org.elasticsearch.xpack.sql.type.UnsupportedEsField;, +import java.util.Arrays;, +import java.util.LinkedHashMap;, +import java.util.Map.Entry;, +import java.util.NavigableSet;, +import java.util.TreeMap;, +import static java.util.Collections.emptyMap;, +    public void resolveAsMergedMapping(String indexWildcard, String javaRegex, ActionListener<IndexResolution> listener) {, +        FieldCapabilitiesRequest fieldRequest = createFieldCapsRequest(indexWildcard);, +        client.fieldCaps(fieldRequest,, +                ActionListener.wrap(response -> listener.onResponse(mergedMapping(indexWildcard, response.get())), listener::onFailure));, +    static IndexResolution mergedMapping(String indexPattern, Map<String, Map<String, FieldCapabilities>> fieldCaps) {, +        if (fieldCaps == null || fieldCaps.isEmpty()) {, +            return IndexResolution.notFound(indexPattern);, +        StringBuilder errorMessage = new StringBuilder();, +, +        NavigableSet<Entry<String, Map<String, FieldCapabilities>>> sortedFields = new TreeSet<>(, +                // for some reason .reversed doesn't work (prolly due to inference), +                Collections.reverseOrder(Comparator.comparing(Entry::getKey)));, +        sortedFields.addAll(fieldCaps.entrySet());, +, +        Map<String, EsField> hierarchicalMapping = new TreeMap<>();, +        Map<String, EsField> flattedMapping = new LinkedHashMap<>();, +        , +        // sort keys descending in order to easily detect multi-fields (a.b.c multi-field of a.b), +        // without sorting, they can still be detected however without the emptyMap optimization, +        // (fields without multi-fields have no children), +        for (Entry<String, Map<String, FieldCapabilities>> entry : sortedFields) {, +            String name = entry.getKey();, +            // skip internal fields, +            if (!name.startsWith("_")) {, +                Map<String, FieldCapabilities> types = entry.getValue();, +                // field is mapped differently across indices, +                if (types.size() > 1) {, +                    // build error message, +                    for (Entry<String, FieldCapabilities> type : types.entrySet()) {, +                        if (errorMessage.length() > 0) {, +                            errorMessage.append(", ");, +                        errorMessage.append("[");, +                        errorMessage.append(type.getKey());, +                        errorMessage.append("] in ");, +                        errorMessage.append(Arrays.toString(type.getValue().indices()));, +, +                    errorMessage.insert(0,, +                            "[" + indexPattern + "] points to indices with incompatible mappings; " +, +                            "field [" + name + "] is mapped in [" + types.size() + "] different ways: ");, +                }, +                if (errorMessage.length() > 0) {, +                    return IndexResolution.invalid(errorMessage.toString());, +                }, +                , +                FieldCapabilities fieldCap = types.values().iterator().next();, +                // validate search/agg-able, +                if (fieldCap.isAggregatable() && fieldCap.nonAggregatableIndices() != null) {, +                    errorMessage.append("[" + indexPattern + "] points to indices with incompatible mappings: ");, +                    errorMessage.append("field [" + name + "] is aggregateable except in ");, +                    errorMessage.append(Arrays.toString(fieldCap.nonAggregatableIndices()));, +                }, +                if (fieldCap.isSearchable() && fieldCap.nonSearchableIndices() != null) {, +                    if (errorMessage.length() > 0) {, +                        errorMessage.append(",");, +                    }, +                    errorMessage.append("[" + indexPattern + "] points to indices with incompatible mappings: ");, +                    errorMessage.append("field [" + name + "] is searchable except in ");, +                    errorMessage.append(Arrays.toString(fieldCap.nonSearchableIndices()));, +                }, +                if (errorMessage.length() > 0) {, +                    return IndexResolution.invalid(errorMessage.toString());, +                }, +                , +                // validation passes - create the field, +                // and name wasn't added before]