[+++ b/buildSrc/build.gradle, +    // The test task is configured to runtimeJava version, but build-tools doesn't support all of them, so test, +++ b/buildSrc/build.gradle, +    // The test task is configured to runtimeJava version, but build-tools doesn't support all of them, so test, +++ b/buildSrc/src/main/resources/forbidden/es-test-signatures.txt, +, +java.lang.Math#random() @ Use one of the various randomization methods from LuceneTestCase or ESTestCase for reproducibility, +++ b/buildSrc/build.gradle, +    // The test task is configured to runtimeJava version, but build-tools doesn't support all of them, so test, +++ b/buildSrc/src/main/resources/forbidden/es-test-signatures.txt, +, +java.lang.Math#random() @ Use one of the various randomization methods from LuceneTestCase or ESTestCase for reproducibility, +++ b/docs/reference/search/profile.asciidoc, +Note that the Profile API, <<profile-limitations, amongst other things>>, doesn't measure, +network latency, time spent in the search fetch phase, time spent while the requests spends, +in queues or while merging shard responses on the coordinating node., +[[profile-limitations]], +- Profiling currently does not measure the search fetch phase nor the network overhead, +- Profiling also does not account for time spent in the queue, merging shard responses on the coordinating node or, +additional work like e.g. building global ordinals (an internal data structure used to speed up search), +++ b/buildSrc/build.gradle, +    // The test task is configured to runtimeJava version, but build-tools doesn't support all of them, so test, +++ b/buildSrc/src/main/resources/forbidden/es-test-signatures.txt, +, +java.lang.Math#random() @ Use one of the various randomization methods from LuceneTestCase or ESTestCase for reproducibility, +++ b/docs/reference/search/profile.asciidoc, +Note that the Profile API, <<profile-limitations, amongst other things>>, doesn't measure, +network latency, time spent in the search fetch phase, time spent while the requests spends, +in queues or while merging shard responses on the coordinating node., +[[profile-limitations]], +- Profiling currently does not measure the search fetch phase nor the network overhead, +- Profiling also does not account for time spent in the queue, merging shard responses on the coordinating node or, +additional work like e.g. building global ordinals (an internal data structure used to speed up search), +++ b/modules/ingest-common/src/test/resources/rest-api-spec/test/ingest/200_default_pipeline.yml, +          aliases:, +            test_alias: {}, +        index: test_alias, +  - match: { _source.bytes_target_field: 1024 }, +, +  - do:, +      index:, +        index: test, +        type: test, +        id: 3, +        pipeline: "_none", +        body: {bytes_source_field: "1kb"}, +        , +  - do:, +      get:, +        index: test, +        type: test, +        id: 3, +  - match: { _source.bytes_source_field: "1kb" }, +        id: 4, +++ b/buildSrc/build.gradle, +    // The test task is configured to runtimeJava version, but build-tools doesn't support all of them, so test, +++ b/buildSrc/src/main/resources/forbidden/es-test-signatures.txt, +, +java.lang.Math#random() @ Use one of the various randomization methods from LuceneTestCase or ESTestCase for reproducibility, +++ b/docs/reference/search/profile.asciidoc, +Note that the Profile API, <<profile-limitations, amongst other things>>, doesn't measure, +network latency, time spent in the search fetch phase, time spent while the requests spends, +in queues or while merging shard responses on the coordinating node., +[[profile-limitations]], +- Profiling currently does not measure the search fetch phase nor the network overhead, +- Profiling also does not account for time spent in the queue, merging shard responses on the coordinating node or, +additional work like e.g. building global ordinals (an internal data structure used to speed up search), +++ b/modules/ingest-common/src/test/resources/rest-api-spec/test/ingest/200_default_pipeline.yml, +          aliases:, +            test_alias: {}, +        index: test_alias, +  - match: { _source.bytes_target_field: 1024 }, +, +  - do:, +      index:, +        index: test, +        type: test, +        id: 3, +        pipeline: "_none", +        body: {bytes_source_field: "1kb"}, +        , +  - do:, +      get:, +        index: test, +        type: test, +        id: 3, +  - match: { _source.bytes_source_field: "1kb" }, +        id: 4, +++ b/server/src/main/java/org/elasticsearch/action/bulk/TransportBulkAction.java, +import org.elasticsearch.cluster.metadata.AliasOrIndex;, +        final MetaData metaData = clusterService.state().getMetaData();, +        ImmutableOpenMap<String, IndexMetaData> indicesMetaData = metaData.indices();, +                        //check the alias, +                        AliasOrIndex indexOrAlias = metaData.getAliasAndIndexLookup().get(indexRequest.index());, +                        if (indexOrAlias != null && indexOrAlias.isAlias()) {, +                            AliasOrIndex.Alias alias = (AliasOrIndex.Alias) indexOrAlias;, +                            indexMetaData = alias.getWriteIndex();, +                        }, +                    }, +                    if (indexMetaData == null) {]