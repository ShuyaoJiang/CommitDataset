[+++ b/buildSrc/src/main/resources/checkstyle_suppressions.xml, +++ b/buildSrc/src/main/resources/checkstyle_suppressions.xml, +++ b/server/src/main/java/org/elasticsearch/bootstrap/JNANatives.java, +                logger.warn("Increase RLIMIT_MEMLOCK, soft limit: {}, hard limit: {}", rlimitToString(softLimit),, +                    rlimitToString(hardLimit));, +++ b/buildSrc/src/main/resources/checkstyle_suppressions.xml, +++ b/server/src/main/java/org/elasticsearch/bootstrap/JNANatives.java, +                logger.warn("Increase RLIMIT_MEMLOCK, soft limit: {}, hard limit: {}", rlimitToString(softLimit),, +                    rlimitToString(hardLimit));, +++ b/server/src/main/java/org/elasticsearch/client/support/AbstractClient.java, +        public void updateSettings(final ClusterUpdateSettingsRequest request,, +                                   final ActionListener<ClusterUpdateSettingsResponse> listener) {, +++ b/buildSrc/src/main/resources/checkstyle_suppressions.xml, +++ b/server/src/main/java/org/elasticsearch/bootstrap/JNANatives.java, +                logger.warn("Increase RLIMIT_MEMLOCK, soft limit: {}, hard limit: {}", rlimitToString(softLimit),, +                    rlimitToString(hardLimit));, +++ b/server/src/main/java/org/elasticsearch/client/support/AbstractClient.java, +        public void updateSettings(final ClusterUpdateSettingsRequest request,, +                                   final ActionListener<ClusterUpdateSettingsResponse> listener) {, +++ b/server/src/main/java/org/elasticsearch/client/transport/TransportClient.java, + * or more nodes directly by adding their respective addresses using, + * {@link #addTransportAddress(org.elasticsearch.common.transport.TransportAddress)}., +            ClientTemplate transportClient = new ClientTemplate(injector, pluginLifecycleComponents, nodesService, proxy,, +                namedWriteableRegistry);, +++ b/buildSrc/src/main/resources/checkstyle_suppressions.xml, +++ b/server/src/main/java/org/elasticsearch/bootstrap/JNANatives.java, +                logger.warn("Increase RLIMIT_MEMLOCK, soft limit: {}, hard limit: {}", rlimitToString(softLimit),, +                    rlimitToString(hardLimit));, +++ b/server/src/main/java/org/elasticsearch/client/support/AbstractClient.java, +        public void updateSettings(final ClusterUpdateSettingsRequest request,, +                                   final ActionListener<ClusterUpdateSettingsResponse> listener) {, +++ b/server/src/main/java/org/elasticsearch/client/transport/TransportClient.java, + * or more nodes directly by adding their respective addresses using, + * {@link #addTransportAddress(org.elasticsearch.common.transport.TransportAddress)}., +            ClientTemplate transportClient = new ClientTemplate(injector, pluginLifecycleComponents, nodesService, proxy,, +                namedWriteableRegistry);, +++ b/server/src/main/java/org/elasticsearch/discovery/Discovery.java, +     * The method is guaranteed to throw a {@link FailedToCommitClusterStateException} if the change is not, +     * committed and should be rejected., +++ b/buildSrc/src/main/resources/checkstyle_suppressions.xml, +++ b/server/src/main/java/org/elasticsearch/bootstrap/JNANatives.java, +                logger.warn("Increase RLIMIT_MEMLOCK, soft limit: {}, hard limit: {}", rlimitToString(softLimit),, +                    rlimitToString(hardLimit));, +++ b/server/src/main/java/org/elasticsearch/client/support/AbstractClient.java, +        public void updateSettings(final ClusterUpdateSettingsRequest request,, +                                   final ActionListener<ClusterUpdateSettingsResponse> listener) {, +++ b/server/src/main/java/org/elasticsearch/client/transport/TransportClient.java, + * or more nodes directly by adding their respective addresses using, + * {@link #addTransportAddress(org.elasticsearch.common.transport.TransportAddress)}., +            ClientTemplate transportClient = new ClientTemplate(injector, pluginLifecycleComponents, nodesService, proxy,, +                namedWriteableRegistry);, +++ b/server/src/main/java/org/elasticsearch/discovery/Discovery.java, +     * The method is guaranteed to throw a {@link FailedToCommitClusterStateException} if the change is not, +     * committed and should be rejected., +++ b/server/src/main/java/org/elasticsearch/discovery/DiscoverySettings.java, +    public static final ClusterBlock NO_MASTER_BLOCK_ALL = new ClusterBlock(NO_MASTER_BLOCK_ID, "no master", true, true, false,, +        RestStatus.SERVICE_UNAVAILABLE, ClusterBlockLevel.ALL);, +    public static final ClusterBlock NO_MASTER_BLOCK_WRITES = new ClusterBlock(NO_MASTER_BLOCK_ID, "no master", true, false, false,, +        RestStatus.SERVICE_UNAVAILABLE, EnumSet.of(ClusterBlockLevel.WRITE, ClusterBlockLevel.METADATA_WRITE));, +++ b/buildSrc/src/main/resources/checkstyle_suppressions.xml, +++ b/server/src/main/java/org/elasticsearch/bootstrap/JNANatives.java, +                logger.warn("Increase RLIMIT_MEMLOCK, soft limit: {}, hard limit: {}", rlimitToString(softLimit),, +                    rlimitToString(hardLimit));, +++ b/server/src/main/java/org/elasticsearch/client/support/AbstractClient.java, +        public void updateSettings(final ClusterUpdateSettingsRequest request,, +                                   final ActionListener<ClusterUpdateSettingsResponse> listener) {, +++ b/server/src/main/java/org/elasticsearch/client/transport/TransportClient.java, + * or more nodes directly by adding their respective addresses using, + * {@link #addTransportAddress(org.elasticsearch.common.transport.TransportAddress)}., +            ClientTemplate transportClient = new ClientTemplate(injector, pluginLifecycleComponents, nodesService, proxy,, +                namedWriteableRegistry);, +++ b/server/src/main/java/org/elasticsearch/discovery/Discovery.java, +     * The method is guaranteed to throw a {@link FailedToCommitClusterStateException} if the change is not, +     * committed and should be rejected., +++ b/server/src/main/java/org/elasticsearch/discovery/DiscoverySettings.java, +    public static final ClusterBlock NO_MASTER_BLOCK_ALL = new ClusterBlock(NO_MASTER_BLOCK_ID, "no master", true, true, false,, +        RestStatus.SERVICE_UNAVAILABLE, ClusterBlockLevel.ALL);, +    public static final ClusterBlock NO_MASTER_BLOCK_WRITES = new ClusterBlock(NO_MASTER_BLOCK_ID, "no master", true, false, false,, +        RestStatus.SERVICE_UNAVAILABLE, EnumSet.of(ClusterBlockLevel.WRITE, ClusterBlockLevel.METADATA_WRITE));, +++ b/server/src/main/java/org/elasticsearch/discovery/zen/ZenDiscovery.java, +                        logger.debug(() -> new ParameterizedMessage("failed to send leave request from master [{}] to possible master [{}]",, +                            nodes.getMasterNode(), possibleMaster), e);, +                        logger.info("failed to send join request to master [{}], reason [{}], tried [{}] times", masterNode,, +                            ExceptionsHelper.detailedMessage(e), joinAttempt);, +                        logger.trace("master {} failed with [{}]. retrying... (attempts done: [{}])", masterNode,, +                            ExceptionsHelper.detailedMessage(e), joinAttempt);, +                        logger.info("failed to send join request to master [{}], reason [{}]", masterNode,, +                            ExceptionsHelper.detailedMessage(e));, +    public static class NodeRemovalClusterStateTaskExecutor, +        implements ClusterStateTaskExecutor<NodeRemovalClusterStateTaskExecutor.Task>, ClusterStateTaskListener {, +                rejoin("not enough master nodes on change of minimum_master_nodes from [" + prevMinimumMasterNode + "] to [" +, +                    minimumMasterNodes + "]");, +        assert !newClusterState.blocks().hasGlobalBlock(discoverySettings.getNoMasterBlock()) :, +            "received a cluster state with a master block";, +            handleAnotherMaster(currentState, newClusterState.nodes().getMasterNode(), newClusterState.version(),, +                "via a new cluster state");, +                (newClusterState.nodes().getMasterNodeId().equals(currentState.nodes().getMasterNodeId()) &&, +                    currentState.version() == newClusterState.version())) {, +            logger.debug("received a cluster state that is not newer than the current one, ignoring (received {}, current {})",, +                newClusterState.version(), currentState.version());]