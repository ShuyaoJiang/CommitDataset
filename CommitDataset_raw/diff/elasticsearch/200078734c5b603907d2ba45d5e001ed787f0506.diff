[+++ b/server/src/main/java/org/elasticsearch/ingest/IngestService.java, +    private final Map<String, Processor.Factory> processorFactories;, +    // Ideally this should be in IngestMetadata class, but we don't have the processor factories around there., +    // We know of all the processor factories when a node with all its plugin have been initialized. Also some, +    // processor factories rely on other node services. Custom metadata is statically registered when classes, +    // are loaded, so in the cluster state we just save the pipeline config and here we keep the actual pipelines around., +    private volatile Map<String, Pipeline> pipelines = new HashMap<>();, +    private final ThreadPool threadPool;, +    private final StatsHolder totalStats = new StatsHolder();, +    private volatile Map<String, StatsHolder> statsHolderPerPipeline = Collections.emptyMap();, +        this.processorFactories = processorFactories(, +        this.threadPool = threadPool;, +    public void delete(DeletePipelineRequest request, ActionListener<AcknowledgedResponse> listener) {, +        put(clusterService, ingestInfos, request, listener);, +        return pipelines.get(id);, +        return processorFactories;, +        return pipelines;, +        innerUpdatePipelines(event.previousState(), state);, +            updatePipelineStats(ingestMetadata);, +    static ClusterState innerPut(PutPipelineRequest request, ClusterState currentState) {, +        IngestMetadata currentIngestMetadata = currentState.metaData().custom(IngestMetadata.TYPE);, +        Map<String, PipelineConfiguration> pipelines;, +        if (currentIngestMetadata != null) {, +            pipelines = new HashMap<>(currentIngestMetadata.getPipelines());, +        } else {, +            pipelines = new HashMap<>();, +        }, +, +        pipelines.put(request.getId(), new PipelineConfiguration(request.getId(), request.getSource(), request.getXContentType()));, +        ClusterState.Builder newState = ClusterState.builder(currentState);, +        newState.metaData(MetaData.builder(currentState.getMetaData()), +            .putCustom(IngestMetadata.TYPE, new IngestMetadata(pipelines)), +            .build());, +        return newState.build();, +    }, +, +    public void executeBulkRequest(Iterable<DocWriteRequest<?>> actionRequests,, +        BiConsumer<IndexRequest, Exception> itemFailureHandler, Consumer<Exception> completionHandler) {, +                    String pipelineId = indexRequest.getPipeline();, +                    if (NOOP_PIPELINE_NAME.equals(pipelineId) == false) {, +                            Pipeline pipeline = pipelines.get(pipelineId);, +                            if (pipeline == null) {, +                                throw new IllegalArgumentException("pipeline with id [" + pipelineId + "] does not exist");, +                            }, +                            innerExecute(indexRequest, pipeline);, +    public IngestStats stats() {, +    private void innerUpdatePipelines(ClusterState previousState, ClusterState state) {, +        if (state.blocks().hasGlobalBlock(GatewayService.STATE_NOT_RECOVERED_BLOCK)) {, +            return;, +, +        IngestMetadata ingestMetadata = state.getMetaData().custom(IngestMetadata.TYPE);, +        IngestMetadata previousIngestMetadata = previousState.getMetaData().custom(IngestMetadata.TYPE);, +        if (Objects.equals(ingestMetadata, previousIngestMetadata)) {, +            return;, +        }, +, +        Map<String, Pipeline> pipelines = new HashMap<>();, +        List<ElasticsearchParseException> exceptions = new ArrayList<>();, +        for (PipelineConfiguration pipeline : ingestMetadata.getPipelines().values()) {, +            try {, +                pipelines.put(pipeline.getId(), Pipeline.create(pipeline.getId(), pipeline.getConfigAsMap(), processorFactories));, +            } catch (ElasticsearchParseException e) {, +                pipelines.put(pipeline.getId(), substitutePipeline(pipeline.getId(), e));, +                exceptions.add(e);, +            } catch (Exception e) {, +                ElasticsearchParseException parseException = new ElasticsearchParseException(, +                    "Error updating pipeline with id [" + pipeline.getId() + "]", e);, +                pipelines.put(pipeline.getId(), substitutePipeline(pipeline.getId(), parseException));, +                exceptions.add(parseException);, +            }, +        }, +        this.pipelines = Collections.unmodifiableMap(pipelines);, +        ExceptionsHelper.rethrowAndSuppress(exceptions);, +++ b/server/src/main/java/org/elasticsearch/ingest/IngestService.java, +    private final Map<String, Processor.Factory> processorFactories;, +    // Ideally this should be in IngestMetadata class, but we don't have the processor factories around there., +    // We know of all the processor factories when a node with all its plugin have been initialized. Also some, +    // processor factories rely on other node services. Custom metadata is statically registered when classes, +    // are loaded, so in the cluster state we just save the pipeline config and here we keep the actual pipelines around., +    private volatile Map<String, Pipeline> pipelines = new HashMap<>();, +    private final ThreadPool threadPool;, +    private final StatsHolder totalStats = new StatsHolder();, +    private volatile Map<String, StatsHolder> statsHolderPerPipeline = Collections.emptyMap();, +        this.processorFactories = processorFactories(, +        this.threadPool = threadPool;, +    public void delete(DeletePipelineRequest request, ActionListener<AcknowledgedResponse> listener) {, +        put(clusterService, ingestInfos, request, listener);, +        return pipelines.get(id);, +        return processorFactories;, +        return pipelines;, +        innerUpdatePipelines(event.previousState(), state);, +            updatePipelineStats(ingestMetadata);, +    static ClusterState innerPut(PutPipelineRequest request, ClusterState currentState) {, +        IngestMetadata currentIngestMetadata = currentState.metaData().custom(IngestMetadata.TYPE);, +        Map<String, PipelineConfiguration> pipelines;, +        if (currentIngestMetadata != null) {, +            pipelines = new HashMap<>(currentIngestMetadata.getPipelines());, +        } else {, +            pipelines = new HashMap<>();, +        }]