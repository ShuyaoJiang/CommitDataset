[+++ b/docs/reference/modules/tribe.asciidoc, +  clusters. By default it will pick one of them, see later for on_conflict options., +coming[1.2.0], +, +The tribe node can also configure blocks on indices explicitly:, +, +[source,yaml], +--------------------------------, +tribe:, +    blocks:, +        indices.write: hk*,ldn*, +--------------------------------, +, +coming[1.2.0], +, +When there is a conflict and multiple clusters hold the same index, by default, +the tribe node will pick one of them. This can be configured using the `tribe.on_conflict`, +setting. It defaults to `any`, but can be set to `drop` (drop indices that have, +a conflict), or `prefer_[tribeName]` to prefer the index from a specific tribe., +, +++ b/docs/reference/modules/tribe.asciidoc, +  clusters. By default it will pick one of them, see later for on_conflict options., +coming[1.2.0], +, +The tribe node can also configure blocks on indices explicitly:, +, +[source,yaml], +--------------------------------, +tribe:, +    blocks:, +        indices.write: hk*,ldn*, +--------------------------------, +, +coming[1.2.0], +, +When there is a conflict and multiple clusters hold the same index, by default, +the tribe node will pick one of them. This can be configured using the `tribe.on_conflict`, +setting. It defaults to `any`, but can be set to `drop` (drop indices that have, +a conflict), or `prefer_[tribeName]` to prefer the index from a specific tribe., +, +++ b/src/main/java/org/elasticsearch/tribe/TribeService.java, +import com.google.common.collect.Sets;, +import org.elasticsearch.cluster.block.ClusterBlocks;, +import org.elasticsearch.cluster.routing.IndexRoutingTable;, +import org.elasticsearch.common.regex.Regex;, +import org.elasticsearch.common.util.concurrent.ConcurrentCollections;, +import java.util.Set;, +    private final String[] blockIndicesWrite;, +    private final String[] blockIndicesRead;, +    private final String[] blockIndicesMetadata;, +, +    private static final String ON_CONFLICT_ANY = "any", ON_CONFLICT_DROP = "drop", ON_CONFLICT_PREFER = "prefer_";, +    private final String onConflict;, +    private final Set<String> droppedIndices = ConcurrentCollections.newConcurrentSet();, +        nodesSettings.remove("on_conflict"); // remove prefix settings that don't indicate a client, +        String[] blockIndicesWrite = Strings.EMPTY_ARRAY;, +        String[] blockIndicesRead = Strings.EMPTY_ARRAY;, +        String[] blockIndicesMetadata = Strings.EMPTY_ARRAY;, +            blockIndicesWrite = settings.getAsArray("tribe.blocks.write.indices", Strings.EMPTY_ARRAY);, +            blockIndicesMetadata = settings.getAsArray("tribe.blocks.metadata.indices", Strings.EMPTY_ARRAY);, +            blockIndicesRead = settings.getAsArray("tribe.blocks.read.indices", Strings.EMPTY_ARRAY);, +        this.blockIndicesMetadata = blockIndicesMetadata;, +        this.blockIndicesRead = blockIndicesRead;, +        this.blockIndicesWrite = blockIndicesWrite;, +, +        this.onConflict = settings.get("tribe.on_conflict", ON_CONFLICT_ANY);, +                    ClusterBlocks.Builder blocks = ClusterBlocks.builder().blocks(currentState.blocks());, +                                removeIndex(blocks, metaData, routingTable, index);, +                        // if there is no routing table yet, do nothing with it..., +                        IndexRoutingTable table = tribeState.routingTable().index(tribeIndex.index());, +                        if (table == null) {, +                            continue;, +                        }, +                        if (!currentState.metaData().hasIndex(tribeIndex.index()) && !droppedIndices.contains(tribeIndex.index())) {, +                            addNewIndex(tribeState, blocks, metaData, routingTable, tribeIndex);, +                        } else {, +                            String existingFromTribe = currentState.metaData().index(tribeIndex.index()).getSettings().get(TRIBE_NAME);, +                            if (!tribeName.equals(existingFromTribe)) {, +                                // we have a potential conflict on index names, decide what to do..., +                                if (ON_CONFLICT_ANY.equals(onConflict)) {, +                                    // we chose any tribe, carry on, +                                } else if (ON_CONFLICT_DROP.equals(onConflict)) {, +                                    // drop the indices, there is a conflict, +                                    logger.info("[{}] dropping index [{}] due to conflict with [{}]", tribeName, tribeIndex.index(), existingFromTribe);, +                                    removeIndex(blocks, metaData, routingTable, tribeIndex);, +                                    droppedIndices.add(tribeIndex.index());, +                                } else if (onConflict.startsWith(ON_CONFLICT_PREFER)) {, +                                    // on conflict, prefer a tribe..., +                                    String preferredTribeName = onConflict.substring(ON_CONFLICT_PREFER.length());, +                                    if (tribeName.equals(preferredTribeName)) {, +                                        // the new one is hte preferred one, replace..., +                                        logger.info("[{}] adding index [{}], preferred over [{}]", tribeName, tribeIndex.index(), existingFromTribe);, +                                        removeIndex(blocks, metaData, routingTable, tribeIndex);, +                                        addNewIndex(tribeState, blocks, metaData, routingTable, tribeIndex);, +                                    } // else: either the existing one is the preferred one, or we haven't seen one, carry on, +                                }, +                            }, +                    return ClusterState.builder(currentState).blocks(blocks).nodes(nodes).metaData(metaData).routingTable(routingTable).build();, +                }, +]