[+++ b/src/main/java/org/elasticsearch/cluster/service/InternalClusterService.java, +import org.elasticsearch.Version;, +import org.elasticsearch.cluster.node.DiscoveryNodeService;, +import java.util.*;, +    public static final String UPDATE_THREAD_NAME = "clusterService#updateTask";, +    private final DiscoveryNodeService discoveryNodeService;, +    private final Version version;, +                                  NodeSettingsService nodeSettingsService, ThreadPool threadPool, ClusterName clusterName, DiscoveryNodeService discoveryNodeService, Version version) {, +        this.discoveryNodeService = discoveryNodeService;, +        this.version = version;, +, +        // will be replaced on doStart., +        this.updateTasksExecutor = EsExecutors.newSinglePrioritizing(daemonThreadFactory(settings, UPDATE_THREAD_NAME));, +        Map<String, String> nodeAttributes = discoveryNodeService.buildAttributes();, +        // note, we rely on the fact that its a new id each time we start, see FD and "kill -9" handling, +        final String nodeId = DiscoveryService.generateNodeId(settings);, +        DiscoveryNode localNode = new DiscoveryNode(settings.get("name"), nodeId, transportService.boundAddress().publishAddress(), nodeAttributes, version);, +        DiscoveryNodes.Builder nodeBuilder = DiscoveryNodes.builder().put(localNode).localNodeId(localNode.id());, +        this.clusterState = ClusterState.builder(clusterState).nodes(nodeBuilder).blocks(initialBlocks).build();, +        return clusterState.getNodes().localNode();, +                        ackListener.onNodeAck(newClusterState.nodes().localNode(), null);, +++ b/src/main/java/org/elasticsearch/cluster/service/InternalClusterService.java, +import org.elasticsearch.Version;, +import org.elasticsearch.cluster.node.DiscoveryNodeService;, +import java.util.*;, +    public static final String UPDATE_THREAD_NAME = "clusterService#updateTask";, +    private final DiscoveryNodeService discoveryNodeService;, +    private final Version version;, +                                  NodeSettingsService nodeSettingsService, ThreadPool threadPool, ClusterName clusterName, DiscoveryNodeService discoveryNodeService, Version version) {, +        this.discoveryNodeService = discoveryNodeService;, +        this.version = version;, +, +        // will be replaced on doStart., +        this.updateTasksExecutor = EsExecutors.newSinglePrioritizing(daemonThreadFactory(settings, UPDATE_THREAD_NAME));, +        Map<String, String> nodeAttributes = discoveryNodeService.buildAttributes();, +        // note, we rely on the fact that its a new id each time we start, see FD and "kill -9" handling, +        final String nodeId = DiscoveryService.generateNodeId(settings);, +        DiscoveryNode localNode = new DiscoveryNode(settings.get("name"), nodeId, transportService.boundAddress().publishAddress(), nodeAttributes, version);, +        DiscoveryNodes.Builder nodeBuilder = DiscoveryNodes.builder().put(localNode).localNodeId(localNode.id());, +        this.clusterState = ClusterState.builder(clusterState).nodes(nodeBuilder).blocks(initialBlocks).build();, +        return clusterState.getNodes().localNode();, +                        ackListener.onNodeAck(newClusterState.nodes().localNode(), null);, +++ b/src/main/java/org/elasticsearch/discovery/zen/ZenDiscovery.java, +import org.elasticsearch.cluster.service.InternalClusterService;, +import java.util.concurrent.atomic.AtomicReference;, +    private final JoinThreadControl joinThreadControl;, +                        DiscoveryNodeService discoveryNodeService, ZenPingService pingService, ElectMasterService electMasterService,, +        this.joinThreadControl = new JoinThreadControl(threadPool);, +, +, +        nodesFD.setLocalNode(clusterService.localNode());, +        // start the join thread from a cluster state update. See {@link JoinThreadControl} for details., +        clusterService.submitStateUpdateTask("initial_join", new ClusterStateNonMasterUpdateTask() {, +            @Override, +            public ClusterState execute(ClusterState currentState) throws Exception {, +                joinThreadControl.startNewThreadIfNotRunning();, +                return currentState;, +            }, +, +            @Override, +            public void onFailure(String source, @org.elasticsearch.common.Nullable Throwable t) {, +                logger.warn("failed to start initial join process", t);, +            }, +        });, +, +        DiscoveryNodes nodes = nodes();, +            if (nodes.masterNode() == null) {, +                // if we don't know who the master is, nothing to do here, +            } else if (!nodes.localNodeMaster()) {, +                    membership.sendLeaveRequestBlocking(nodes.masterNode(), nodes.localNode(), TimeValue.timeValueSeconds(1));, +                    logger.debug("failed to send leave request to master [{}]", e, nodes.masterNode());, +                // we're master -> let other potential master we left and start a master election now rather then wait for masterFD, +                DiscoveryNode[] possibleMasters = electMaster.nextPossibleMasters(nodes.nodes().values(), 5);, +                    if (nodes.localNode().equals(possibleMaster)) {, +                        membership.sendLeaveRequest(nodes.localNode(), possibleMaster);, +                        logger.debug("failed to send leave request from master [{}] to possible master [{}]", e, nodes.masterNode(), possibleMaster);, +        joinThreadControl.stop();, +        return clusterService.localNode();, +        return clusterName.value() + "/" + clusterService.localNode().id();, +        return clusterService.state().nodes();, +        if (!clusterState.getNodes().localNodeMaster()) {, +        nodesFD.updateNodes(clusterState);, +        return joinThreadControl.joinThreadActive();, +    /**, +     * the main function of a join thread. This function is guaranteed to join the cluster, +     * or spawn a new join thread upon failure to do so., +     */, +        DiscoveryNode masterNode = null;, +        final Thread currentThread = Thread.currentThread();, +        while (masterNode == null && joinThreadControl.joinThreadActive(currentThread)) {, +            masterNode = findMaster();, +        }, +, +        if (!joinThreadControl.joinThreadActive(currentThread)) {, +            logger.trace("thread is no longer in currentJoinThread. Stopping.");, +, +        if (clusterService.localNode().equals(masterNode)) {, +, +                    if (currentState.nodes().masterNode() != null) {, +                        // TODO can we tie break here? we don't have a remote master cluster state version to decide on]