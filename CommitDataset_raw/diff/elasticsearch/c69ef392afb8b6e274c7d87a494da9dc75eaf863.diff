[+++ b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/watcher/watch/WatchStatus.java, +    public ZonedDateTime lastMetCondition() {, +        return lastMetCondition;, +    }, +, +            writeDate(Field.LAST_CHECKED.getPreferredName(), builder, lastChecked);, +            writeDate(Field.LAST_MET_CONDITION.getPreferredName(), builder, lastMetCondition);, +++ b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/watcher/watch/WatchStatus.java, +    public ZonedDateTime lastMetCondition() {, +        return lastMetCondition;, +    }, +, +            writeDate(Field.LAST_CHECKED.getPreferredName(), builder, lastChecked);, +            writeDate(Field.LAST_MET_CONDITION.getPreferredName(), builder, lastMetCondition);, +++ b/x-pack/plugin/watcher/src/test/java/org/elasticsearch/xpack/watcher/test/WatcherTestUtils.java, +import org.elasticsearch.xpack.core.watcher.support.WatcherDateTimeUtils;, +import org.hamcrest.Matcher;, +import static org.hamcrest.Matchers.is;, +, +    public static Matcher<String> isSameDate(ZonedDateTime zonedDateTime) {, +        /*, +        When comparing timestamps returned from _search/.watcher-history* the same format of date has to be used, +        during serialisation to json on index time., +        The toString of ZonedDateTime is omitting the millisecond part when is 0. This was not the case in joda., +         */, +        return is(WatcherDateTimeUtils.formatDate(zonedDateTime));, +    }, +++ b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/watcher/watch/WatchStatus.java, +    public ZonedDateTime lastMetCondition() {, +        return lastMetCondition;, +    }, +, +            writeDate(Field.LAST_CHECKED.getPreferredName(), builder, lastChecked);, +            writeDate(Field.LAST_MET_CONDITION.getPreferredName(), builder, lastMetCondition);, +++ b/x-pack/plugin/watcher/src/test/java/org/elasticsearch/xpack/watcher/test/WatcherTestUtils.java, +import org.elasticsearch.xpack.core.watcher.support.WatcherDateTimeUtils;, +import org.hamcrest.Matcher;, +import static org.hamcrest.Matchers.is;, +, +    public static Matcher<String> isSameDate(ZonedDateTime zonedDateTime) {, +        /*, +        When comparing timestamps returned from _search/.watcher-history* the same format of date has to be used, +        during serialisation to json on index time., +        The toString of ZonedDateTime is omitting the millisecond part when is 0. This was not the case in joda., +         */, +        return is(WatcherDateTimeUtils.formatDate(zonedDateTime));, +    }, +++ b/x-pack/plugin/watcher/src/test/java/org/elasticsearch/xpack/watcher/test/integration/HistoryIntegrationTests.java, +import org.elasticsearch.xpack.watcher.test.WatcherTestUtils;, +        assertThat(timestamp, WatcherTestUtils.isSameDate(status.state().getTimestamp()));, +        assertThat(lastChecked, WatcherTestUtils.isSameDate(status.lastChecked()));, +        String lastMetCondition = source.getValue("status.last_met_condition");, +        assertThat(lastMetCondition, WatcherTestUtils.isSameDate(status.lastMetCondition()));, +++ b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/watcher/watch/WatchStatus.java, +    public ZonedDateTime lastMetCondition() {, +        return lastMetCondition;, +    }, +, +            writeDate(Field.LAST_CHECKED.getPreferredName(), builder, lastChecked);, +            writeDate(Field.LAST_MET_CONDITION.getPreferredName(), builder, lastMetCondition);, +++ b/x-pack/plugin/watcher/src/test/java/org/elasticsearch/xpack/watcher/test/WatcherTestUtils.java, +import org.elasticsearch.xpack.core.watcher.support.WatcherDateTimeUtils;, +import org.hamcrest.Matcher;, +import static org.hamcrest.Matchers.is;, +, +    public static Matcher<String> isSameDate(ZonedDateTime zonedDateTime) {, +        /*, +        When comparing timestamps returned from _search/.watcher-history* the same format of date has to be used, +        during serialisation to json on index time., +        The toString of ZonedDateTime is omitting the millisecond part when is 0. This was not the case in joda., +         */, +        return is(WatcherDateTimeUtils.formatDate(zonedDateTime));, +    }, +++ b/x-pack/plugin/watcher/src/test/java/org/elasticsearch/xpack/watcher/test/integration/HistoryIntegrationTests.java, +import org.elasticsearch.xpack.watcher.test.WatcherTestUtils;, +        assertThat(timestamp, WatcherTestUtils.isSameDate(status.state().getTimestamp()));, +        assertThat(lastChecked, WatcherTestUtils.isSameDate(status.lastChecked()));, +        String lastMetCondition = source.getValue("status.last_met_condition");, +        assertThat(lastMetCondition, WatcherTestUtils.isSameDate(status.lastMetCondition()));, +++ b/x-pack/plugin/watcher/src/test/java/org/elasticsearch/xpack/watcher/watch/WatchStatusIntegrationTests.java, +import org.elasticsearch.xpack.watcher.test.WatcherTestUtils;, +import org.hamcrest.FeatureMatcher;, +import org.hamcrest.Matcher;, +, +import java.time.ZonedDateTime;, +import java.time.temporal.ChronoField;, +import static org.hamcrest.Matchers.equalTo;, +import static org.hamcrest.Matchers.nullValue;, +        String lastChecked = source.getValue("status.last_checked");, +        assertThat(lastChecked, WatcherTestUtils.isSameDate(getWatchResponse.getStatus().lastChecked()));, +        assertThat(getWatchResponse.getStatus().lastChecked(), isMillisResolution());, +        // not started yet, so both nulls, +        String lastMetCondition = source.getValue("status.last_met_condition");, +        assertThat(lastMetCondition, is(nullValue()));, +        assertThat(getWatchResponse.getStatus().lastMetCondition(), is(nullValue()));, +    }, +, +    private Matcher<ZonedDateTime> isMillisResolution() {, +        return new FeatureMatcher<ZonedDateTime,Boolean>(equalTo(true), "has millisecond precision", "precission") {, +            @Override]