[+++ b/src/main/java/org/elasticsearch/common/util/BigArrays.java, +import org.elasticsearch.common.lease.Releasable;, +import org.elasticsearch.common.lease.Releasables;, +import org.elasticsearch.common.recycler.Recycler;, +    private static abstract class AbstractArrayWrapper extends AbstractArray {, +        private final Releasable releasable;, +        private final long size;, +        AbstractArrayWrapper(long size, Releasable releasable, boolean clearOnResize) {, +            this.releasable = releasable;, +            this.size = size;, +        }, +, +        public final long size() {, +            return size;, +        public final boolean release() {, +            Releasables.release(releasable);, +            return true;, +        }, +, +    }, +, +    private static class ByteArrayWrapper extends AbstractArrayWrapper implements ByteArray {, +, +        private final byte[] array;, +, +        ByteArrayWrapper(byte[] array, long size, Recycler.V<byte[]> releasable, boolean clearOnResize) {, +            super(size, releasable, clearOnResize);, +            this.array = array;, +    private static class IntArrayWrapper extends AbstractArrayWrapper implements IntArray {, +        IntArrayWrapper(int[] array, long size, Recycler.V<int[]> releasable, boolean clearOnResize) {, +            super(size, releasable, clearOnResize);, +    private static class LongArrayWrapper extends AbstractArrayWrapper implements LongArray {, +        LongArrayWrapper(long[] array, long size, Recycler.V<long[]> releasable, boolean clearOnResize) {, +            super(size, releasable, clearOnResize);, +    private static class DoubleArrayWrapper extends AbstractArrayWrapper implements DoubleArray {, +        DoubleArrayWrapper(double[] array, long size, Recycler.V<double[]> releasable, boolean clearOnResize) {, +            super(size, releasable, clearOnResize);, +    private static class FloatArrayWrapper extends AbstractArrayWrapper implements FloatArray {, +        FloatArrayWrapper(float[] array, long size, Recycler.V<float[]> releasable, boolean clearOnResize) {, +            super(size, releasable, clearOnResize);, +    private static class ObjectArrayWrapper<T> extends AbstractArrayWrapper implements ObjectArray<T> {, +        ObjectArrayWrapper(Object[] array, long size, Recycler.V<Object[]> releasable) {, +            super(size, releasable, true);, +    final PageCacheRecycler recycler;, +        if (size > BYTE_PAGE_SIZE) {, +        } else if (size >= BYTE_PAGE_SIZE / 2 && recycler != null) {, +            final Recycler.V<byte[]> page = recycler.bytePage(clearOnResize);, +            return new ByteArrayWrapper(page.v(), size, page, clearOnResize);, +        } else {, +            return new ByteArrayWrapper(new byte[(int) size], size, null, clearOnResize);, +        if (size > INT_PAGE_SIZE) {, +        } else if (size >= INT_PAGE_SIZE / 2 && recycler != null) {, +            final Recycler.V<int[]> page = recycler.intPage(clearOnResize);, +            return new IntArrayWrapper(page.v(), size, page, clearOnResize);, +        } else {, +            return new IntArrayWrapper(new int[(int) size], size, null, clearOnResize);, +        if (size > LONG_PAGE_SIZE) {, +        } else if (size >= LONG_PAGE_SIZE / 2 && recycler != null) {, +            final Recycler.V<long[]> page = recycler.longPage(clearOnResize);, +            return new LongArrayWrapper(page.v(), size, page, clearOnResize);, +        } else {, +            return new LongArrayWrapper(new long[(int) size], size, null, clearOnResize);, +        if (size > DOUBLE_PAGE_SIZE) {, +        } else if (size >= DOUBLE_PAGE_SIZE / 2 && recycler != null) {, +            final Recycler.V<double[]> page = recycler.doublePage(clearOnResize);, +            return new DoubleArrayWrapper(page.v(), size, page, clearOnResize);, +        } else {, +            return new DoubleArrayWrapper(new double[(int) size], size, null, clearOnResize);, +        if (size > FLOAT_PAGE_SIZE) {, +        } else if (size >= FLOAT_PAGE_SIZE / 2 && recycler != null) {, +            final Recycler.V<float[]> page = recycler.floatPage(clearOnResize);, +            return new FloatArrayWrapper(page.v(), size, page, clearOnResize);, +        } else {, +            return new FloatArrayWrapper(new float[(int) size], size, null, clearOnResize);, +        if (size > OBJECT_PAGE_SIZE) {, +        } else if (size >= OBJECT_PAGE_SIZE / 2 && recycler != null) {, +            final Recycler.V<Object[]> page = recycler.objectPage();, +            return new ObjectArrayWrapper<T>(page.v(), size, page);, +        } else {, +            return new ObjectArrayWrapper<T>(new Object[(int) size], size, null);]