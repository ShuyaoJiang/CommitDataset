[+++ b/src/main/java/org/elasticsearch/search/controller/SearchPhaseController.java, +        // Need to use the length of the resultsArr array, since the slots will be based on the position in the resultsArr array, +        TopDocs[] shardTopDocs = new TopDocs[resultsArr.length()];, +            // the 'index' field is the position in the resultsArr atomic array, +        // TopDocs#merge can't deal with empty shard TopDocs, +        for (int i = 0; i < shardTopDocs.length; i++) {, +            if (shardTopDocs[i] == null) {, +                shardTopDocs[i] = new TopDocs(0, EMPTY_DOCS, 0.0f);, +            }, +        }, +++ b/src/main/java/org/elasticsearch/search/controller/SearchPhaseController.java, +        // Need to use the length of the resultsArr array, since the slots will be based on the position in the resultsArr array, +        TopDocs[] shardTopDocs = new TopDocs[resultsArr.length()];, +            // the 'index' field is the position in the resultsArr atomic array, +        // TopDocs#merge can't deal with empty shard TopDocs, +        for (int i = 0; i < shardTopDocs.length; i++) {, +            if (shardTopDocs[i] == null) {, +                shardTopDocs[i] = new TopDocs(0, EMPTY_DOCS, 0.0f);, +            }, +        }, +++ b/src/test/java/org/elasticsearch/nested/SimpleNestedTests.java, +                            .startObject("properties"), +                                .startObject("field1"), +                                    .field("type", "long"), +                                .endObject(), +                                .startObject("field2"), +                                    .field("type", "boolean"), +                                .endObject(), +                            .endObject(), +++ b/src/main/java/org/elasticsearch/search/controller/SearchPhaseController.java, +        // Need to use the length of the resultsArr array, since the slots will be based on the position in the resultsArr array, +        TopDocs[] shardTopDocs = new TopDocs[resultsArr.length()];, +            // the 'index' field is the position in the resultsArr atomic array, +        // TopDocs#merge can't deal with empty shard TopDocs, +        for (int i = 0; i < shardTopDocs.length; i++) {, +            if (shardTopDocs[i] == null) {, +                shardTopDocs[i] = new TopDocs(0, EMPTY_DOCS, 0.0f);, +            }, +        }, +++ b/src/test/java/org/elasticsearch/nested/SimpleNestedTests.java, +                            .startObject("properties"), +                                .startObject("field1"), +                                    .field("type", "long"), +                                .endObject(), +                                .startObject("field2"), +                                    .field("type", "boolean"), +                                .endObject(), +                            .endObject(), +++ b/src/test/java/org/elasticsearch/search/scroll/SearchScrollWithFailingNodesTests.java, +/*, + * Licensed to Elasticsearch under one or more contributor, + * license agreements. See the NOTICE file distributed with, + * this work for additional information regarding copyright, + * ownership. Elasticsearch licenses this file to you under, + * the Apache License, Version 2.0 (the "License"); you may, + * not use this file except in compliance with the License., + * You may obtain a copy of the License at, + *, + *    http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing,, + * software distributed under the License is distributed on an, + * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY, + * KIND, either express or implied.  See the License for the, + * specific language governing permissions and limitations, + * under the License., + */, +, +package org.elasticsearch.search.scroll;, +, +import org.elasticsearch.action.index.IndexRequestBuilder;, +import org.elasticsearch.action.search.SearchResponse;, +import org.elasticsearch.common.unit.TimeValue;, +import org.elasticsearch.test.ElasticsearchIntegrationTest;, +import org.elasticsearch.test.junit.annotations.TestLogging;, +import org.junit.Test;, +, +import java.util.ArrayList;, +import java.util.List;, +, +import static org.elasticsearch.common.xcontent.XContentFactory.jsonBuilder;, +import static org.elasticsearch.index.query.QueryBuilders.matchAllQuery;, +import static org.elasticsearch.test.hamcrest.ElasticsearchAssertions.assertAcked;, +import static org.elasticsearch.test.hamcrest.ElasticsearchAssertions.assertAllSuccessful;, +import static org.hamcrest.Matchers.*;, +, +/**, + */, +@ElasticsearchIntegrationTest.ClusterScope(scope = ElasticsearchIntegrationTest.Scope.TEST, numDataNodes = 2), +public class SearchScrollWithFailingNodesTests extends ElasticsearchIntegrationTest {, +, +    @Override, +    protected int numberOfShards() {, +        // We need at least 2 primary shards, otherwise a stopping a node isn't going to result into shard failures., +        return between(2, 6);, +    }, +, +    @Override, +    protected int numberOfReplicas() {, +        return 0;]