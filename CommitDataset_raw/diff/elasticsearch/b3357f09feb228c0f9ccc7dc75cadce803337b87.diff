[+++ b/core/src/main/java/org/elasticsearch/cluster/ClusterModule.java, +++ b/core/src/main/java/org/elasticsearch/cluster/ClusterModule.java, +++ b/core/src/main/java/org/elasticsearch/cluster/metadata/MetaDataIndexUpgradeService.java, +                                    "index.version_map_size",, +                                    "index.buffer_size"));, +++ b/core/src/main/java/org/elasticsearch/cluster/ClusterModule.java, +++ b/core/src/main/java/org/elasticsearch/cluster/metadata/MetaDataIndexUpgradeService.java, +                                    "index.version_map_size",, +                                    "index.buffer_size"));, +++ b/core/src/main/java/org/elasticsearch/index/engine/Engine.java, +    /** How much heap is used that would be freed by a refresh */, +    abstract public long indexBufferRAMBytesUsed();, +     * Synchronously refreshes the engine for new search operations to reflect the latest, +++ b/core/src/main/java/org/elasticsearch/cluster/ClusterModule.java, +++ b/core/src/main/java/org/elasticsearch/cluster/metadata/MetaDataIndexUpgradeService.java, +                                    "index.version_map_size",, +                                    "index.buffer_size"));, +++ b/core/src/main/java/org/elasticsearch/index/engine/Engine.java, +    /** How much heap is used that would be freed by a refresh */, +    abstract public long indexBufferRAMBytesUsed();, +     * Synchronously refreshes the engine for new search operations to reflect the latest, +++ b/core/src/main/java/org/elasticsearch/index/engine/EngineConfig.java, +    private final ByteSizeValue indexingBufferSize;, +     * Index setting to control the index buffer size., +     * This setting is <b>not</b> realtime updateable., +    public static final String INDEX_BUFFER_SIZE_SETTING = "index.buffer_size";, +        this.compoundOnFlush = indexSettings.getAsBoolean(INDEX_COMPOUND_ON_FLUSH, compoundOnFlush);, +        codecName = indexSettings.get(INDEX_CODEC_SETTING, DEFAULT_CODEC_NAME);, +        // We tell IndexWriter to use large heap, but IndexingMemoryController checks periodically and refreshes the most heap-consuming, +        // shards when total indexing heap usage is too high:, +        indexingBufferSize = indexSettings.getAsBytesSize(INDEX_BUFFER_SIZE_SETTING, new ByteSizeValue(256, ByteSizeUnit.MB));, +        gcDeletesInMillis = indexSettings.getAsTime(INDEX_GC_DELETES_SETTING, DEFAULT_GC_DELETES).millis();, +++ b/core/src/main/java/org/elasticsearch/cluster/ClusterModule.java, +++ b/core/src/main/java/org/elasticsearch/cluster/metadata/MetaDataIndexUpgradeService.java, +                                    "index.version_map_size",, +                                    "index.buffer_size"));, +++ b/core/src/main/java/org/elasticsearch/index/engine/Engine.java, +    /** How much heap is used that would be freed by a refresh */, +    abstract public long indexBufferRAMBytesUsed();, +     * Synchronously refreshes the engine for new search operations to reflect the latest, +++ b/core/src/main/java/org/elasticsearch/index/engine/EngineConfig.java, +    private final ByteSizeValue indexingBufferSize;, +     * Index setting to control the index buffer size., +     * This setting is <b>not</b> realtime updateable., +    public static final String INDEX_BUFFER_SIZE_SETTING = "index.buffer_size";, +        this.compoundOnFlush = indexSettings.getAsBoolean(INDEX_COMPOUND_ON_FLUSH, compoundOnFlush);, +        codecName = indexSettings.get(INDEX_CODEC_SETTING, DEFAULT_CODEC_NAME);, +        // We tell IndexWriter to use large heap, but IndexingMemoryController checks periodically and refreshes the most heap-consuming, +        // shards when total indexing heap usage is too high:, +        indexingBufferSize = indexSettings.getAsBytesSize(INDEX_BUFFER_SIZE_SETTING, new ByteSizeValue(256, ByteSizeUnit.MB));, +        gcDeletesInMillis = indexSettings.getAsTime(INDEX_GC_DELETES_SETTING, DEFAULT_GC_DELETES).millis();, +++ b/core/src/main/java/org/elasticsearch/index/engine/InternalEngine.java, +    private volatile boolean refreshing;, +, +            refreshing = true;, +        } finally {, +            refreshing = false;, +    public long indexBufferRAMBytesUsed() {, +        if (refreshing) {, +            return 0;, +        } else {, +            return indexWriter.ramBytesUsed() + versionMap.ramBytesUsedForRefresh();, +        }, +++ b/core/src/main/java/org/elasticsearch/cluster/ClusterModule.java, +++ b/core/src/main/java/org/elasticsearch/cluster/metadata/MetaDataIndexUpgradeService.java, +                                    "index.version_map_size",, +                                    "index.buffer_size"));, +++ b/core/src/main/java/org/elasticsearch/index/engine/Engine.java, +    /** How much heap is used that would be freed by a refresh */, +    abstract public long indexBufferRAMBytesUsed();, +     * Synchronously refreshes the engine for new search operations to reflect the latest, +++ b/core/src/main/java/org/elasticsearch/index/engine/EngineConfig.java, +    private final ByteSizeValue indexingBufferSize;, +     * Index setting to control the index buffer size., +     * This setting is <b>not</b> realtime updateable., +    public static final String INDEX_BUFFER_SIZE_SETTING = "index.buffer_size";, +        this.compoundOnFlush = indexSettings.getAsBoolean(INDEX_COMPOUND_ON_FLUSH, compoundOnFlush);, +        codecName = indexSettings.get(INDEX_CODEC_SETTING, DEFAULT_CODEC_NAME);, +        // We tell IndexWriter to use large heap, but IndexingMemoryController checks periodically and refreshes the most heap-consuming, +        // shards when total indexing heap usage is too high:, +        indexingBufferSize = indexSettings.getAsBytesSize(INDEX_BUFFER_SIZE_SETTING, new ByteSizeValue(256, ByteSizeUnit.MB));, +        gcDeletesInMillis = indexSettings.getAsTime(INDEX_GC_DELETES_SETTING, DEFAULT_GC_DELETES).millis();, +++ b/core/src/main/java/org/elasticsearch/index/engine/InternalEngine.java, +    private volatile boolean refreshing;, +, +            refreshing = true;, +        } finally {, +            refreshing = false;, +    public long indexBufferRAMBytesUsed() {, +        if (refreshing) {, +            return 0;, +        } else {, +            return indexWriter.ramBytesUsed() + versionMap.ramBytesUsedForRefresh();, +        }, +++ b/core/src/main/java/org/elasticsearch/index/engine/ShadowEngine.java, +    public long indexBufferRAMBytesUsed() {, +        // No IndexWriter nor version map, +++ b/core/src/main/java/org/elasticsearch/cluster/ClusterModule.java, +++ b/core/src/main/java/org/elasticsearch/cluster/metadata/MetaDataIndexUpgradeService.java, +                                    "index.version_map_size",]