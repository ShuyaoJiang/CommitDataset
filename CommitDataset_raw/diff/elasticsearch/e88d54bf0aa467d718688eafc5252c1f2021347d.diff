[+++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/Compiler.java, +import java.util.concurrent.atomic.AtomicInteger;, +        private final AtomicInteger lambdaCounter = new AtomicInteger(0);, +        , +            return defineClass(name, bytes, 0, bytes.length, CODESOURCE);, +        }, +        , +        /**, +         * A counter used to generate a unique name for each lambda, +         * function/reference class in this classloader., +         */, +        int newLambdaIdentifier() {, +            return lambdaCounter.getAndIncrement();, +++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/Compiler.java, +import java.util.concurrent.atomic.AtomicInteger;, +        private final AtomicInteger lambdaCounter = new AtomicInteger(0);, +        , +            return defineClass(name, bytes, 0, bytes.length, CODESOURCE);, +        }, +        , +        /**, +         * A counter used to generate a unique name for each lambda, +         * function/reference class in this classloader., +         */, +        int newLambdaIdentifier() {, +            return lambdaCounter.getAndIncrement();, +++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/LambdaBootstrap.java, + * 3. a static ctor delegation method, if the lambda function is a ctor., + * code them. For method references to a constructor, a static, + * wrapper method is created, that creates a class instance and, + * calls the constructor. This method is used by the, + * invokedynamic call to initialize the instance., +     * This method name is used to generate a static wrapper method to handle delegation of ctors., +    private static final String DELEGATED_CTOR_WRAPPER_NAME = "delegate$ctor";, +     * @param delegateClassName The name of the class to delegate method call to, +        Loader loader = (Loader)lookup.lookupClass().getClassLoader();, +        String lambdaClassName = Type.getInternalName(lookup.lookupClass()) + "$$Lambda" + loader.newLambdaIdentifier();, +        Type lambdaClassType = Type.getObjectType(lambdaClassName);, +        Type delegateClassType = Type.getObjectType(delegateClassName.replace('.', '/'));, +        ClassWriter cw = beginLambdaClass(lambdaClassName, factoryMethodType.returnType());, +        // Handles the special case where a method reference refers to a ctor (we need a static wrapper method):, +        if (delegateInvokeType == H_NEWINVOKESPECIAL) {, +            generateStaticCtorDelegator(cw, delegateClassType, delegateMethodName, delegateMethodType);, +            // replace the delegate with our static wrapper:, +            delegateMethodName = DELEGATED_CTOR_WRAPPER_NAME;, +            delegateClassType = lambdaClassType;, +            delegateInvokeType = H_INVOKESTATIC;, +        generateInterfaceMethod(cw, factoryMethodType, lambdaClassType, interfaceMethodName,, +            interfaceMethodType, delegateClassType, delegateInvokeType,, +        , +        Class<?> lambdaClass = createLambdaClass(loader, cw, lambdaClassType);, +            return createCaptureCallSite(lookup, factoryMethodType, lambdaClass);, +    private static ClassWriter beginLambdaClass(String lambdaClassName, Class<?> lambdaInterface) {, +        String baseClass = Type.getInternalName(Object.class);, +        int modifiers = ACC_PUBLIC | ACC_SUPER | ACC_FINAL | ACC_SYNTHETIC;, +            modifiers, lambdaClassName, null, baseClass, new String[] { Type.getInternalName(lambdaInterface) });, +            int modifiers = ACC_PRIVATE | ACC_FINAL;, +    private static void generateLambdaConstructor(, +     * Generates a factory method to delegate to constructors using, +     * {@code INVOKEDYNAMIC} using the {@link #delegateBootstrap} type converter., +    private static void generateStaticCtorDelegator(ClassWriter cw, Type delegateClassType, String delegateMethodName,, +            MethodType delegateMethodType) {, +        Method wrapperMethod = new Method(DELEGATED_CTOR_WRAPPER_NAME, delegateMethodType.toMethodDescriptorString());, +        Method constructorMethod = , +            new Method(delegateMethodName, delegateMethodType.changeReturnType(void.class).toMethodDescriptorString());, +        int modifiers = ACC_PRIVATE | ACC_STATIC;, +        GeneratorAdapter factory = new GeneratorAdapter(modifiers, wrapperMethod,, +            cw.visitMethod(modifiers, DELEGATED_CTOR_WRAPPER_NAME, delegateMethodType.toMethodDescriptorString(), null, null));, +        factory.newInstance(delegateClassType);, +        factory.invokeConstructor(delegateClassType, constructorMethod);, +            Type delegateClassType,, +        Method lamMeth = new Method(lambdaClassType.getInternalName(), lamDesc);, +                delegateClassType = Type.getType(clazz);, +                delegateClassType = Type.getType(clazz);, +            new Handle(delegateInvokeType, delegateClassType.getInternalName(),, +            Type lambdaClassType) {, +        // DEBUG:, +        // new ClassReader(classBytes).accept(new TraceClassVisitor(new PrintWriter(System.out)), ClassReader.SKIP_DEBUG);, +            loader.defineLambda(lambdaClassType.getClassName(), classBytes));, +                factoryMethodType.returnType(), lambdaClass.getConstructor().newInstance()));, +        } catch (ReflectiveOperationException exception) {, +            throw new IllegalStateException("unable to instantiate lambda class", exception);, +                lookup.findConstructor(lambdaClass, factoryMethodType.changeReturnType(void.class)), +                .asType(factoryMethodType));, +        } catch (ReflectiveOperationException exception) {, +            throw new IllegalStateException("unable to create lambda class", exception);, +++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/Compiler.java, +import java.util.concurrent.atomic.AtomicInteger;, +        private final AtomicInteger lambdaCounter = new AtomicInteger(0);, +        , +            return defineClass(name, bytes, 0, bytes.length, CODESOURCE);, +        }, +        , +        /**, +         * A counter used to generate a unique name for each lambda, +         * function/reference class in this classloader., +         */, +        int newLambdaIdentifier() {, +            return lambdaCounter.getAndIncrement();, +++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/LambdaBootstrap.java]