[+++ b/dev-tools/checkstyle_suppressions.xml, +++ b/dev-tools/checkstyle_suppressions.xml, +++ b/sql/server/src/main/java/org/elasticsearch/xpack/sql/analysis/analyzer/Analyzer.java, +                log.trace("Trying to resolve conflicts " + conflicting + " between left " + left.nodeString(), +                        + " and right " + right.nodeString());, +                                throw new AnalysisException(exp, "Group ordinal " + ordinal + " refers to an aggregate function ", +                                        + reference.nodeName() + " which is not compatible/allowed with GROUP BY");, +                            throw new AnalysisException(exp, "Invalid ordinal " + ordinal, +                                    + " specified in Aggregate (valid range is [1, " + max + "])");, +                            uf = new UnresolvedFunction(uf.location(), uf.name(), uf.distinct(),, +                                singletonList(Literal.of(uf.arguments().get(0).location(), Integer.valueOf(1))));, +                        String message = matches.isEmpty() ?, +                                uf.unresolvedMessage() : UnresolvedFunction.errorMessage(normalizedName, matches);, +                        Aggregate newAgg = new Aggregate(agg.location(), agg.child(), agg.groupings(),, +                                combine(agg.aggregates(), missing));, +++ b/dev-tools/checkstyle_suppressions.xml, +++ b/sql/server/src/main/java/org/elasticsearch/xpack/sql/analysis/analyzer/Analyzer.java, +                log.trace("Trying to resolve conflicts " + conflicting + " between left " + left.nodeString(), +                        + " and right " + right.nodeString());, +                                throw new AnalysisException(exp, "Group ordinal " + ordinal + " refers to an aggregate function ", +                                        + reference.nodeName() + " which is not compatible/allowed with GROUP BY");, +                            throw new AnalysisException(exp, "Invalid ordinal " + ordinal, +                                    + " specified in Aggregate (valid range is [1, " + max + "])");, +                            uf = new UnresolvedFunction(uf.location(), uf.name(), uf.distinct(),, +                                singletonList(Literal.of(uf.arguments().get(0).location(), Integer.valueOf(1))));, +                        String message = matches.isEmpty() ?, +                                uf.unresolvedMessage() : UnresolvedFunction.errorMessage(normalizedName, matches);, +                        Aggregate newAgg = new Aggregate(agg.location(), agg.child(), agg.groupings(),, +                                combine(agg.aggregates(), missing));, +++ b/sql/server/src/main/java/org/elasticsearch/xpack/sql/analysis/analyzer/Verifier.java, +     * 2. the order/having might contain a non-grouped attribute. This is typically, +     * caught by the Analyzer however if wrapped in a function (ABS()) it gets resolved, +     * (because the expression gets resolved little by little without being pushed down,, +     * without the Analyzer modifying anything., +    private static boolean checkGroupBy(LogicalPlan p, Set<Failure> localFailures,, +            Map<String, Function> resolvedFunctions, Set<LogicalPlan> groupingFailures) {, +    private static boolean checkGroupByOrder(LogicalPlan p, Set<Failure> localFailures,, +            Set<LogicalPlan> groupingFailures, Map<String, Function> functions) {, +    private static boolean checkGroupByHaving(LogicalPlan p, Set<Failure> localFailures,, +            Set<LogicalPlan> groupingFailures, Map<String, Function> functions) {, +    private static boolean checkGroupByAgg(LogicalPlan p, Set<Failure> localFailures,, +            Set<LogicalPlan> groupingFailures, Map<String, Function> functions) {, +    private static boolean checkGroupMatch(Expression e, Node<?> source, List<Expression> groupings,, +            Map<Expression, Node<?>> missing, Map<String, Function> functions) {]