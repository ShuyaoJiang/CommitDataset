[+++ b/.idea/dictionaries/kimchy.xml, +      <w>multipart</w>, +++ b/.idea/dictionaries/kimchy.xml, +      <w>multipart</w>, +++ b/modules/benchmark/micro/src/main/java/org/elasticsearch/benchmark/index/engine/SimpleEngineBenchmark.java, +import org.elasticsearch.index.translog.fs.FsTranslog;, +import java.io.File;, +        Engine engine = new RobinEngine(shardId, settings, store, deletionPolicy, new FsTranslog(shardId, EMPTY_SETTINGS, new File("work/fs-translog"), false), new LogByteSizeMergePolicyProvider(store),, +++ b/.idea/dictionaries/kimchy.xml, +      <w>multipart</w>, +++ b/modules/benchmark/micro/src/main/java/org/elasticsearch/benchmark/index/engine/SimpleEngineBenchmark.java, +import org.elasticsearch.index.translog.fs.FsTranslog;, +import java.io.File;, +        Engine engine = new RobinEngine(shardId, settings, store, deletionPolicy, new FsTranslog(shardId, EMPTY_SETTINGS, new File("work/fs-translog"), false), new LogByteSizeMergePolicyProvider(store),, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/action/admin/indices/status/GatewaySnapshotStatus.java, +    public GatewaySnapshotStatus(Stage stage, long startTime, long time, long indexSize) {, +++ b/.idea/dictionaries/kimchy.xml, +      <w>multipart</w>, +++ b/modules/benchmark/micro/src/main/java/org/elasticsearch/benchmark/index/engine/SimpleEngineBenchmark.java, +import org.elasticsearch.index.translog.fs.FsTranslog;, +import java.io.File;, +        Engine engine = new RobinEngine(shardId, settings, store, deletionPolicy, new FsTranslog(shardId, EMPTY_SETTINGS, new File("work/fs-translog"), false), new LogByteSizeMergePolicyProvider(store),, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/action/admin/indices/status/GatewaySnapshotStatus.java, +    public GatewaySnapshotStatus(Stage stage, long startTime, long time, long indexSize) {, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/action/admin/indices/status/ShardStatus.java, +                    in.readVLong(), in.readVLong(), in.readVLong());, +++ b/.idea/dictionaries/kimchy.xml, +      <w>multipart</w>, +++ b/modules/benchmark/micro/src/main/java/org/elasticsearch/benchmark/index/engine/SimpleEngineBenchmark.java, +import org.elasticsearch.index.translog.fs.FsTranslog;, +import java.io.File;, +        Engine engine = new RobinEngine(shardId, settings, store, deletionPolicy, new FsTranslog(shardId, EMPTY_SETTINGS, new File("work/fs-translog"), false), new LogByteSizeMergePolicyProvider(store),, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/action/admin/indices/status/GatewaySnapshotStatus.java, +    public GatewaySnapshotStatus(Stage stage, long startTime, long time, long indexSize) {, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/action/admin/indices/status/ShardStatus.java, +                    in.readVLong(), in.readVLong(), in.readVLong());, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/action/admin/indices/status/TransportIndicesStatusAction.java, +                    snapshotStatus.index().totalSize());, +++ b/.idea/dictionaries/kimchy.xml, +      <w>multipart</w>, +++ b/modules/benchmark/micro/src/main/java/org/elasticsearch/benchmark/index/engine/SimpleEngineBenchmark.java, +import org.elasticsearch.index.translog.fs.FsTranslog;, +import java.io.File;, +        Engine engine = new RobinEngine(shardId, settings, store, deletionPolicy, new FsTranslog(shardId, EMPTY_SETTINGS, new File("work/fs-translog"), false), new LogByteSizeMergePolicyProvider(store),, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/action/admin/indices/status/GatewaySnapshotStatus.java, +    public GatewaySnapshotStatus(Stage stage, long startTime, long time, long indexSize) {, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/action/admin/indices/status/ShardStatus.java, +                    in.readVLong(), in.readVLong(), in.readVLong());, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/action/admin/indices/status/TransportIndicesStatusAction.java, +                    snapshotStatus.index().totalSize());, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/cluster/routing/allocation/PreferUnallocatedShardUnassignedStrategy.java, +import org.elasticsearch.index.gateway.CommitPoint;, +                        CommitPoint commitPoint = indexGateway.findCommitPoint(shard.id());, +                            for (CommitPoint.FileInfo fileInfo : commitPoint.indexFiles()) {, +                                sb.append("        [").append(fileInfo.name()).append("]/[" + fileInfo.physicalName() + "], size [").append(new ByteSizeValue(fileInfo.length())).append("]\n");, +                                sb.append("        [").append(md.name()).append("], size [").append(new ByteSizeValue(md.length())).append("]\n");, +                            CommitPoint.FileInfo fileInfo = commitPoint.findPhysicalIndexFile(storeFileMetaData.name());, +                            if (fileInfo != null) {, +                                if (fileInfo.length() == storeFileMetaData.length()) {, +                                    logger.trace("{}: [{}] reusing file since it exists on remote node and on gateway with size [{}]", shard, storeFileMetaData.name(), new ByteSizeValue(storeFileMetaData.length()));, +                                    sizeMatched += storeFileMetaData.length();, +                                    logger.trace("{}: [{}] ignore file since it exists on remote node and on gateway but has different size, remote node [{}], gateway [{}]", shard, storeFileMetaData.name(), storeFileMetaData.length(), fileInfo.length());, +                                if (primaryStoreFilesMetaData.fileExists(storeFileMetaData.name()) && primaryStoreFilesMetaData.file(storeFileMetaData.name()).length() == storeFileMetaData.length()) {, +                                    sizeMatched += storeFileMetaData.length();, +++ b/.idea/dictionaries/kimchy.xml, +      <w>multipart</w>, +++ b/modules/benchmark/micro/src/main/java/org/elasticsearch/benchmark/index/engine/SimpleEngineBenchmark.java, +import org.elasticsearch.index.translog.fs.FsTranslog;, +import java.io.File;, +        Engine engine = new RobinEngine(shardId, settings, store, deletionPolicy, new FsTranslog(shardId, EMPTY_SETTINGS, new File("work/fs-translog"), false), new LogByteSizeMergePolicyProvider(store),, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/action/admin/indices/status/GatewaySnapshotStatus.java, +    public GatewaySnapshotStatus(Stage stage, long startTime, long time, long indexSize) {, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/action/admin/indices/status/ShardStatus.java, +                    in.readVLong(), in.readVLong(), in.readVLong());, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/action/admin/indices/status/TransportIndicesStatusAction.java, +                    snapshotStatus.index().totalSize());, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/cluster/routing/allocation/PreferUnallocatedShardUnassignedStrategy.java, +import org.elasticsearch.index.gateway.CommitPoint;, +                        CommitPoint commitPoint = indexGateway.findCommitPoint(shard.id());, +                            for (CommitPoint.FileInfo fileInfo : commitPoint.indexFiles()) {, +                                sb.append("        [").append(fileInfo.name()).append("]/[" + fileInfo.physicalName() + "], size [").append(new ByteSizeValue(fileInfo.length())).append("]\n");, +                                sb.append("        [").append(md.name()).append("], size [").append(new ByteSizeValue(md.length())).append("]\n");, +                            CommitPoint.FileInfo fileInfo = commitPoint.findPhysicalIndexFile(storeFileMetaData.name());, +                            if (fileInfo != null) {, +                                if (fileInfo.length() == storeFileMetaData.length()) {, +                                    logger.trace("{}: [{}] reusing file since it exists on remote node and on gateway with size [{}]", shard, storeFileMetaData.name(), new ByteSizeValue(storeFileMetaData.length()));, +                                    sizeMatched += storeFileMetaData.length();, +                                    logger.trace("{}: [{}] ignore file since it exists on remote node and on gateway but has different size, remote node [{}], gateway [{}]", shard, storeFileMetaData.name(), storeFileMetaData.length(), fileInfo.length());, +                                if (primaryStoreFilesMetaData.fileExists(storeFileMetaData.name()) && primaryStoreFilesMetaData.file(storeFileMetaData.name()).length() == storeFileMetaData.length()) {, +                                    sizeMatched += storeFileMetaData.length();, +++ /dev/null, +++ b/.idea/dictionaries/kimchy.xml, +      <w>multipart</w>, +++ b/modules/benchmark/micro/src/main/java/org/elasticsearch/benchmark/index/engine/SimpleEngineBenchmark.java, +import org.elasticsearch.index.translog.fs.FsTranslog;, +import java.io.File;, +        Engine engine = new RobinEngine(shardId, settings, store, deletionPolicy, new FsTranslog(shardId, EMPTY_SETTINGS, new File("work/fs-translog"), false), new LogByteSizeMergePolicyProvider(store),, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/action/admin/indices/status/GatewaySnapshotStatus.java, +    public GatewaySnapshotStatus(Stage stage, long startTime, long time, long indexSize) {, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/action/admin/indices/status/ShardStatus.java]