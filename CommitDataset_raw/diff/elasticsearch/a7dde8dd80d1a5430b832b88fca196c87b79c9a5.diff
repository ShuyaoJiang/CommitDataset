[+++ b/src/test/java/org/elasticsearch/index/store/CorruptedTranslogTests.java, +        indexRandom(false, false, false, Arrays.asList(builders));  // this one, +++ b/src/test/java/org/elasticsearch/index/store/CorruptedTranslogTests.java, +        indexRandom(false, false, false, Arrays.asList(builders));  // this one, +++ b/src/test/java/org/elasticsearch/test/ElasticsearchIntegrationTest.java, +        indexRandom(forceRefresh, dummyDocuments, true, builders);, +    }, +, +    /**, +     * Indexes the given {@link IndexRequestBuilder} instances randomly. It shuffles the given builders and either, +     * indexes they in a blocking or async fashion. This is very useful to catch problems that relate to internal document, +     * ids or index segment creations. Some features might have bug when a given document is the first or the last in a, +     * segment or if only one document is in a segment etc. This method prevents issues like this by randomizing the index, +     * layout., +     *, +     * @param forceRefresh   if <tt>true</tt> all involved indices are refreshed once the documents are indexed., +     * @param dummyDocuments if <tt>true</tt> some empty dummy documents may be randomly inserted into the document list and deleted once, +     *                       all documents are indexed. This is useful to produce deleted documents on the server side., +     * @param maybeFlush if <tt>true</tt> this method may randomly execute full flushes after index operations., +     * @param builders       the documents to index., +     */, +    public void indexRandom(boolean forceRefresh, boolean dummyDocuments, boolean maybeFlush, List<IndexRequestBuilder> builders) throws InterruptedException, ExecutionException {, +, +                    postIndexAsyncActions(indices, inFlightAsyncOperations, maybeFlush);, +                    postIndexAsyncActions(indices, inFlightAsyncOperations, maybeFlush);, +    private void postIndexAsyncActions(String[] indices, List<CountDownLatch> inFlightAsyncOperations, boolean maybeFlush) throws InterruptedException {, +            } else if (maybeFlush && rarely()) {, +                client().admin().indices().prepareOptimize(indices).setIndicesOptions(IndicesOptions.lenientExpandOpen()).setMaxNumSegments(between(1, 10)).setFlush(maybeFlush && randomBoolean()).execute(]