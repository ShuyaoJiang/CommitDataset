[+++ b/src/main/java/org/elasticsearch/index/engine/internal/InternalEngine.java, +        lastCommittedSegmentInfos = store.readLastCommittedSegmentsInfo();, +                    if (Lucene.isCorruptionException(e)) {, +                        throw new FlushFailedEngineException(shardId, e);, +            }, +            maybeFailEngine(ex, "flush");, +        // we have to flush outside of the readlock otherwise we might have a problem upgrading, +        // the to a write lock when we fail the engine in this operation, +        try (InternalLock _ = readLock.acquire()) {, +    private boolean maybeFailEngine(Throwable t, String source) {, +                return true;, +            return true;, +        return false;, +        private final ThreadLocal<AtomicInteger> lockIsHeld;, +            ThreadLocal<AtomicInteger> tl = null;, +            AtomicInteger count = lockIsHeld.get();, +            if (count.decrementAndGet() == 0) {, +                lockIsHeld.remove();, +            }, +            AtomicInteger count = lockIsHeld.get();, +            if (count == null) {, +                count = new AtomicInteger(0);, +                lockIsHeld.set(count);, +            }, +            count.incrementAndGet();, +            AtomicInteger count = lockIsHeld.get();, +            return count != null && count.get() > 0;, +++ b/src/main/java/org/elasticsearch/index/engine/internal/InternalEngine.java, +        lastCommittedSegmentInfos = store.readLastCommittedSegmentsInfo();, +                    if (Lucene.isCorruptionException(e)) {, +                        throw new FlushFailedEngineException(shardId, e);, +            }, +            maybeFailEngine(ex, "flush");, +        // we have to flush outside of the readlock otherwise we might have a problem upgrading, +        // the to a write lock when we fail the engine in this operation, +        try (InternalLock _ = readLock.acquire()) {, +    private boolean maybeFailEngine(Throwable t, String source) {, +                return true;, +            return true;, +        return false;, +        private final ThreadLocal<AtomicInteger> lockIsHeld;, +            ThreadLocal<AtomicInteger> tl = null;, +            AtomicInteger count = lockIsHeld.get();, +            if (count.decrementAndGet() == 0) {, +                lockIsHeld.remove();, +            }, +            AtomicInteger count = lockIsHeld.get();, +            if (count == null) {, +                count = new AtomicInteger(0);, +                lockIsHeld.set(count);, +            }, +            count.incrementAndGet();, +            AtomicInteger count = lockIsHeld.get();, +            return count != null && count.get() > 0;, +++ b/src/main/java/org/elasticsearch/index/snapshots/IndexShardSnapshotAndRestoreService.java, +import org.elasticsearch.common.lucene.Lucene;, +            if (Lucene.isCorruptionException(t)) {, +                restoreService.failRestore(restoreSource.snapshotId(), shardId());, +            }, +++ b/src/main/java/org/elasticsearch/index/engine/internal/InternalEngine.java, +        lastCommittedSegmentInfos = store.readLastCommittedSegmentsInfo();, +                    if (Lucene.isCorruptionException(e)) {, +                        throw new FlushFailedEngineException(shardId, e);, +            }, +            maybeFailEngine(ex, "flush");, +        // we have to flush outside of the readlock otherwise we might have a problem upgrading, +        // the to a write lock when we fail the engine in this operation, +        try (InternalLock _ = readLock.acquire()) {, +    private boolean maybeFailEngine(Throwable t, String source) {, +                return true;, +            return true;, +        return false;, +        private final ThreadLocal<AtomicInteger> lockIsHeld;, +            ThreadLocal<AtomicInteger> tl = null;, +            AtomicInteger count = lockIsHeld.get();, +            if (count.decrementAndGet() == 0) {, +                lockIsHeld.remove();, +            }, +            AtomicInteger count = lockIsHeld.get();, +            if (count == null) {, +                count = new AtomicInteger(0);, +                lockIsHeld.set(count);, +            }, +            count.incrementAndGet();, +            AtomicInteger count = lockIsHeld.get();, +            return count != null && count.get() > 0;, +++ b/src/main/java/org/elasticsearch/index/snapshots/IndexShardSnapshotAndRestoreService.java, +import org.elasticsearch.common.lucene.Lucene;, +            if (Lucene.isCorruptionException(t)) {, +                restoreService.failRestore(restoreSource.snapshotId(), shardId());, +            }, +++ b/src/main/java/org/elasticsearch/index/snapshots/blobstore/BlobStoreIndexShardRepository.java, +import org.apache.lucene.index.CorruptIndexException;, +                } catch (CorruptIndexException e) {, +                    logger.warn("{} Can't read metadata from store", e, shardId);, +                    throw new IndexShardRestoreFailedException(shardId, "Can't restore corrupted shard", e);, +                    if (md != null && fileInfo.isSame(md)) {, +                            if (t instanceof CorruptIndexException) {, +                                try {, +                                    store.markStoreCorrupted((CorruptIndexException)t);]