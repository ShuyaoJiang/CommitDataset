[+++ b/core/src/main/java/org/elasticsearch/index/engine/InternalEngine.java, +            } else if (translog.isOpen() == false && translog.getTragicException() != null) {, +                failEngine("already closed by tragic event", translog.getTragicException());, +        } else if (t != null &&, +            ((indexWriter.isOpen() == false && indexWriter.getTragicException() == t), +                || (translog.isOpen() == false && translog.getTragicException() == t))) {, +++ b/core/src/main/java/org/elasticsearch/index/engine/InternalEngine.java, +            } else if (translog.isOpen() == false && translog.getTragicException() != null) {, +                failEngine("already closed by tragic event", translog.getTragicException());, +        } else if (t != null &&, +            ((indexWriter.isOpen() == false && indexWriter.getTragicException() == t), +                || (translog.isOpen() == false && translog.getTragicException() == t))) {, +++ b/core/src/main/java/org/elasticsearch/index/translog/Translog.java, +    /** Returns {@code true} if this {@code Translog} is still open. */, +    public boolean isOpen() {, +    public Location add(Operation operation) throws IOException {, +        } catch (AlreadyClosedException | IOException ex) {, +            if (current.getTragicException() != null) {, +                try {, +                    close();, +                } catch (Exception inner) {, +                    ex.addSuppressed(inner);, +                }, +            }, +        ensureOpen();, +        } catch (AlreadyClosedException | IOException ex) {, +            if (current.getTragicException() != null) {, +                try {, +                    close();, +                } catch (Exception inner) {, +                    ex.addSuppressed(inner);, +                }, +            }, +            throw ex;, +            oldCurrent.ensureOpen();, +            throw new AlreadyClosedException("translog is already closed", current.getTragicException());, +    /** If this {@code Translog} was closed as a side-effect of a tragic exception,, +     *  e.g. disk full while flushing a new segment, this returns the root cause exception., +     *  Otherwise (no tragic exception has occurred) it returns null. */, +    public Throwable getTragicException() {, +        return current.getTragicException();, +    }, +, +++ b/core/src/main/java/org/elasticsearch/index/engine/InternalEngine.java, +            } else if (translog.isOpen() == false && translog.getTragicException() != null) {, +                failEngine("already closed by tragic event", translog.getTragicException());, +        } else if (t != null &&, +            ((indexWriter.isOpen() == false && indexWriter.getTragicException() == t), +                || (translog.isOpen() == false && translog.getTragicException() == t))) {, +++ b/core/src/main/java/org/elasticsearch/index/translog/Translog.java, +    /** Returns {@code true} if this {@code Translog} is still open. */, +    public boolean isOpen() {, +    public Location add(Operation operation) throws IOException {, +        } catch (AlreadyClosedException | IOException ex) {, +            if (current.getTragicException() != null) {, +                try {, +                    close();, +                } catch (Exception inner) {, +                    ex.addSuppressed(inner);, +                }, +            }, +        ensureOpen();, +        } catch (AlreadyClosedException | IOException ex) {, +            if (current.getTragicException() != null) {, +                try {, +                    close();, +                } catch (Exception inner) {, +                    ex.addSuppressed(inner);, +                }, +            }, +            throw ex;, +            oldCurrent.ensureOpen();, +            throw new AlreadyClosedException("translog is already closed", current.getTragicException());, +    /** If this {@code Translog} was closed as a side-effect of a tragic exception,, +     *  e.g. disk full while flushing a new segment, this returns the root cause exception., +     *  Otherwise (no tragic exception has occurred) it returns null. */, +    public Throwable getTragicException() {, +        return current.getTragicException();, +    }, +, +++ b/core/src/main/java/org/elasticsearch/index/translog/TranslogWriter.java, +    private volatile Throwable tragedy;, +    /** If this {@code TranslogWriter} was closed as a side-effect of a tragic exception,, +     *  e.g. disk full while flushing a new segment, this returns the root cause exception., +     *  Otherwise (no tragic exception has occurred) it returns null. */, +    public Throwable getTragicException() {, +        return tragedy;, +    }, +                if (tragedy == null) {, +                    tragedy = throwable;, +                    tragedy.addSuppressed(throwable);, +            throw new AlreadyClosedException("translog [" + getGeneration() + "] is already closed", tragedy);, +++ b/core/src/main/java/org/elasticsearch/index/engine/InternalEngine.java, +            } else if (translog.isOpen() == false && translog.getTragicException() != null) {, +                failEngine("already closed by tragic event", translog.getTragicException());, +        } else if (t != null &&, +            ((indexWriter.isOpen() == false && indexWriter.getTragicException() == t), +                || (translog.isOpen() == false && translog.getTragicException() == t))) {, +++ b/core/src/main/java/org/elasticsearch/index/translog/Translog.java, +    /** Returns {@code true} if this {@code Translog} is still open. */]