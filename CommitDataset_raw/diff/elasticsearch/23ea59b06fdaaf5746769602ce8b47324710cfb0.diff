[+++ b/core/src/main/java/org/elasticsearch/index/engine/InternalEngine.java, +        Translog.TranslogGeneration generation = null;, +            generation = loadTranslogIdFromCommit(writer);, +        final Translog translog = new Translog(translogConfig, generation);, +++ b/core/src/main/java/org/elasticsearch/index/engine/InternalEngine.java, +        Translog.TranslogGeneration generation = null;, +            generation = loadTranslogIdFromCommit(writer);, +        final Translog translog = new Translog(translogConfig, generation);, +++ b/core/src/main/java/org/elasticsearch/index/translog/Translog.java, +     * @param config the configuration of this translog, +     * @param translogGeneration the translog generation to open. If this is <code>null</code> a new translog is created. If non-null, +     * the translog tries to open the given translog generation. The generation is treated as the last generation referenced, +     * form already committed data. This means all operations that have not yet been committed should be in the translog, +     * file referenced by this generation. The translog creation will fail if this generation can't be opened., +     *, +     *, +    public Translog(TranslogConfig config, TranslogGeneration translogGeneration) throws IOException {, +++ b/core/src/main/java/org/elasticsearch/index/engine/InternalEngine.java, +        Translog.TranslogGeneration generation = null;, +            generation = loadTranslogIdFromCommit(writer);, +        final Translog translog = new Translog(translogConfig, generation);, +++ b/core/src/main/java/org/elasticsearch/index/translog/Translog.java, +     * @param config the configuration of this translog, +     * @param translogGeneration the translog generation to open. If this is <code>null</code> a new translog is created. If non-null, +     * the translog tries to open the given translog generation. The generation is treated as the last generation referenced, +     * form already committed data. This means all operations that have not yet been committed should be in the translog, +     * file referenced by this generation. The translog creation will fail if this generation can't be opened., +     *, +     *, +    public Translog(TranslogConfig config, TranslogGeneration translogGeneration) throws IOException {, +++ b/core/src/main/java/org/elasticsearch/index/translog/TranslogConfig.java, +++ b/core/src/main/java/org/elasticsearch/index/engine/InternalEngine.java, +        Translog.TranslogGeneration generation = null;, +            generation = loadTranslogIdFromCommit(writer);, +        final Translog translog = new Translog(translogConfig, generation);, +++ b/core/src/main/java/org/elasticsearch/index/translog/Translog.java, +     * @param config the configuration of this translog, +     * @param translogGeneration the translog generation to open. If this is <code>null</code> a new translog is created. If non-null, +     * the translog tries to open the given translog generation. The generation is treated as the last generation referenced, +     * form already committed data. This means all operations that have not yet been committed should be in the translog, +     * file referenced by this generation. The translog creation will fail if this generation can't be opened., +     *, +     *, +    public Translog(TranslogConfig config, TranslogGeneration translogGeneration) throws IOException {, +++ b/core/src/main/java/org/elasticsearch/index/translog/TranslogConfig.java, +++ b/core/src/test/java/org/elasticsearch/index/engine/InternalEngineTests.java, +        return new Translog(translogConfig, null);, +        Translog translog = new Translog(new TranslogConfig(shardId, createTempDir(), INDEX_SETTINGS, BigArrays.NON_RECYCLING_INSTANCE), +            , null);, +++ b/core/src/main/java/org/elasticsearch/index/engine/InternalEngine.java, +        Translog.TranslogGeneration generation = null;, +            generation = loadTranslogIdFromCommit(writer);, +        final Translog translog = new Translog(translogConfig, generation);, +++ b/core/src/main/java/org/elasticsearch/index/translog/Translog.java, +     * @param config the configuration of this translog, +     * @param translogGeneration the translog generation to open. If this is <code>null</code> a new translog is created. If non-null, +     * the translog tries to open the given translog generation. The generation is treated as the last generation referenced, +     * form already committed data. This means all operations that have not yet been committed should be in the translog, +     * file referenced by this generation. The translog creation will fail if this generation can't be opened., +     *, +     *, +    public Translog(TranslogConfig config, TranslogGeneration translogGeneration) throws IOException {, +++ b/core/src/main/java/org/elasticsearch/index/translog/TranslogConfig.java, +++ b/core/src/test/java/org/elasticsearch/index/engine/InternalEngineTests.java, +        return new Translog(translogConfig, null);, +        Translog translog = new Translog(new TranslogConfig(shardId, createTempDir(), INDEX_SETTINGS, BigArrays.NON_RECYCLING_INSTANCE), +            , null);, +++ b/core/src/test/java/org/elasticsearch/index/translog/TranslogTests.java, +        return new Translog(getTranslogConfig(path), null);, +        translog = new Translog(config, translogGeneration);, +        try (Translog translog = new Translog(config, translogGeneration)) {, +            try (Translog translog = new Translog(config, translogGeneration)) {, +        try (Translog translog = new Translog(config, translogGeneration)) {, +            try (Translog translog = new Translog(config, translogGeneration)) {, +        try (Translog translog = new Translog(config, translogGeneration)) {, +        try (Translog translog = new Translog(config, translogGeneration)) {, +        Translog.TranslogGeneration generation = new Translog.TranslogGeneration(randomRealisticUnicodeOfCodepointLengthBetween(1,, +            translogGeneration.translogUUID.length()), translogGeneration.translogFileGeneration);, +            new Translog(config, generation);, +        this.translog = new Translog(config, translogGeneration);, +        try (Translog tlog = new Translog(config, translogGeneration)) {, +        Translog translog = getFailableTranslog(fail, config, false, true, null);, +            try (Translog tlog = new Translog(config, translog.getGeneration())) {, +        return getFailableTranslog(fail, config, randomBoolean(), false, null);, +    private Translog getFailableTranslog(final FailSwitch fail, final TranslogConfig config, final boolean paritalWrites, final boolean throwUnknownException, Translog.TranslogGeneration generation) throws IOException {, +        return new Translog(config, generation) {, +        Translog translog = new Translog(config, null);, +            new Translog(config, generation) {, +        try (Translog tlog = new Translog(config, translogGeneration)) {, +        try (Translog tlog = new Translog(config, translogGeneration)) {, +            Translog tlog = new Translog(config, translogGeneration);, +        try (Translog tlog = new Translog(config, translogGeneration)) {, +            Translog tlog = new Translog(config, translogGeneration);, +            Translog.TranslogGeneration generation = null;, +                final Translog failableTLog = getFailableTranslog(fail, config, randomBoolean(), false, generation);, +                    generation = failableTLog.getGeneration();, +                    IOUtils.close(getFailableTranslog(fail, config, randomBoolean(), false, generation));, +            try (Translog translog = new Translog(config, generation)) {]