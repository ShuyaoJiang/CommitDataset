[+++ b/core/src/main/java/org/elasticsearch/cli/Terminal.java, +            String answer = readText(prompt + answerPrompt);, +            if (answer == null || answer.isEmpty()) {, +            answer = answer.toLowerCase(Locale.ROOT);, +++ b/core/src/main/java/org/elasticsearch/cli/Terminal.java, +            String answer = readText(prompt + answerPrompt);, +            if (answer == null || answer.isEmpty()) {, +            answer = answer.toLowerCase(Locale.ROOT);, +++ b/core/src/test/java/org/elasticsearch/cli/TerminalTests.java, +        terminal.addTextInput(null);, +        assertFalse(terminal.promptYesNo("Answer?", false));, +++ b/core/src/main/java/org/elasticsearch/cli/Terminal.java, +            String answer = readText(prompt + answerPrompt);, +            if (answer == null || answer.isEmpty()) {, +            answer = answer.toLowerCase(Locale.ROOT);, +++ b/core/src/test/java/org/elasticsearch/cli/TerminalTests.java, +        terminal.addTextInput(null);, +        assertFalse(terminal.promptYesNo("Answer?", false));, +++ b/test/framework/src/main/java/org/elasticsearch/cli/MockTerminal.java, +import java.util.ArrayList;, +import java.util.List;, +, +    // A deque would be a perfect data structure for the FIFO queue of input values needed here. However,, +    // to support the valid return value of readText being null (defined by Console), we need to be able, +    // to store nulls. However, java the java Deque api does not allow nulls because it uses null as, +    // a special return value from certain methods like peek(). So instead of deque, we use an array list here,, +    // and keep track of the last position which was read. It means that we will hold onto all input, +    // setup for the mock terminal during its lifetime, but this is normally a very small amount of data, +    // so in reality it will not matter., +    private final List<String> textInput = new ArrayList<>();, +    private int textIndex = 0;, +    private final List<String> secretInput = new ArrayList<>();, +    private int secretIndex = 0;, +        if (textIndex >= textInput.size()) {, +        return textInput.get(textIndex++);, +        if (secretIndex >= secretInput.size()) {, +        return secretInput.get(secretIndex++).toCharArray();, +        textInput.add(input);, +        secretInput.add(input);]