[+++ b/src/main/java/org/elasticsearch/common/lucene/docset/AndDocIdSet.java, +import com.google.common.collect.Iterables;, +, +import org.elasticsearch.common.lucene.search.XDocIdSetIterator;, +import java.util.Collections;, +        List<DocIdSetIterator> iterators = new ArrayList<>(sets.length);, +            if (DocIdSets.isEmpty(set)) {, +                return DocIdSetIterator.empty();, +            }, +            DocIdSetIterator it = set.iterator();, +            if (it == null) {, +                return DocIdSetIterator.empty();, +            }, +            if (bit != null && DocIdSets.isBroken(it)) {, +                iterators.add(it);, +    static class IteratorBasedIterator extends XDocIdSetIterator {, +        public static DocIdSetIterator newDocIdSetIterator(Collection<DocIdSetIterator> iterators) throws IOException {, +            if (iterators.isEmpty()) {, +            if (iterators.size() == 1) {, +               return iterators.iterator().next();, +        private IteratorBasedIterator(Collection<DocIdSetIterator> iterators) throws IOException {, +            final DocIdSetIterator[] sortedIterators = iterators.toArray(new DocIdSetIterator[iterators.size()]);, +        public boolean isBroken() {, +            for (DocIdSetIterator it : Iterables.concat(Collections.singleton(lead), Arrays.asList(otherIterators))) {, +                if (DocIdSets.isBroken(it)) {, +                    return true;, +                }, +            }, +            return false;, +        }, +, +        @Override, +++ b/src/main/java/org/elasticsearch/common/lucene/docset/AndDocIdSet.java, +import com.google.common.collect.Iterables;, +, +import org.elasticsearch.common.lucene.search.XDocIdSetIterator;, +import java.util.Collections;, +        List<DocIdSetIterator> iterators = new ArrayList<>(sets.length);, +            if (DocIdSets.isEmpty(set)) {, +                return DocIdSetIterator.empty();, +            }, +            DocIdSetIterator it = set.iterator();, +            if (it == null) {, +                return DocIdSetIterator.empty();, +            }, +            if (bit != null && DocIdSets.isBroken(it)) {, +                iterators.add(it);, +    static class IteratorBasedIterator extends XDocIdSetIterator {, +        public static DocIdSetIterator newDocIdSetIterator(Collection<DocIdSetIterator> iterators) throws IOException {, +            if (iterators.isEmpty()) {, +            if (iterators.size() == 1) {, +               return iterators.iterator().next();, +        private IteratorBasedIterator(Collection<DocIdSetIterator> iterators) throws IOException {, +            final DocIdSetIterator[] sortedIterators = iterators.toArray(new DocIdSetIterator[iterators.size()]);, +        public boolean isBroken() {, +            for (DocIdSetIterator it : Iterables.concat(Collections.singleton(lead), Arrays.asList(otherIterators))) {, +                if (DocIdSets.isBroken(it)) {, +                    return true;, +                }, +            }, +            return false;, +        }, +, +        @Override, +++ b/src/main/java/org/elasticsearch/common/lucene/docset/DocIdSets.java, +import org.apache.lucene.search.DocValuesDocIdSet;, +import org.apache.lucene.search.FilteredDocIdSetIterator;, +import org.elasticsearch.common.lucene.search.XDocIdSetIterator;, +     * Check if the given iterator can nextDoc() or advance() in sub-linear time, +     * of the number of documents. For instance, an iterator that would need to, +     * iterate one document at a time to check for its value would be considered, +     * broken., +    public static boolean isBroken(DocIdSetIterator iterator) {, +        while (iterator instanceof FilteredDocIdSetIterator) {, +            // this iterator is filtered (likely by some bits), +            // unwrap in order to check if the underlying iterator is fast, +            iterator = ((FilteredDocIdSetIterator) iterator).getDelegate();, +        if (iterator instanceof XDocIdSetIterator) {, +            return ((XDocIdSetIterator) iterator).isBroken();, +        }, +        if (iterator instanceof MatchDocIdSetIterator) {, +            return true;, +        }, +        // DocValuesDocIdSet produces anonymous slow iterators, +        if (iterator != null && DocValuesDocIdSet.class.equals(iterator.getClass().getEnclosingClass())) {, +            return true;, +        }, +        return false;, +++ b/src/main/java/org/elasticsearch/common/lucene/docset/AndDocIdSet.java, +import com.google.common.collect.Iterables;, +, +import org.elasticsearch.common.lucene.search.XDocIdSetIterator;, +import java.util.Collections;, +        List<DocIdSetIterator> iterators = new ArrayList<>(sets.length);, +            if (DocIdSets.isEmpty(set)) {, +                return DocIdSetIterator.empty();, +            }, +            DocIdSetIterator it = set.iterator();, +            if (it == null) {, +                return DocIdSetIterator.empty();]