[+++ b/server/src/main/java/org/elasticsearch/gateway/MetaDataStateFormat.java, +import org.elasticsearch.common.logging.Loggers;, +    private static final Logger logger = Loggers.getLogger(MetaDataStateFormat.class);, +            logger.trace("written state to {}", finalStatePath);, +                    logger.trace("copied state to {}", finalPath);, +                    logger.trace("cleaned up {}", tmpPath);, +            logger.trace("cleaned up {}", tmpStatePath);, +        final DirectoryStream.Filter<Path> filter = entry -> {, +            logger.trace("cleanupOldFiles: cleaning up {}", dataLocation);, +                    logger.trace("cleanupOldFiles: cleaned up {}", stateFile);, +++ b/server/src/main/java/org/elasticsearch/gateway/MetaDataStateFormat.java, +import org.elasticsearch.common.logging.Loggers;, +    private static final Logger logger = Loggers.getLogger(MetaDataStateFormat.class);, +            logger.trace("written state to {}", finalStatePath);, +                    logger.trace("copied state to {}", finalPath);, +                    logger.trace("cleaned up {}", tmpPath);, +            logger.trace("cleaned up {}", tmpStatePath);, +        final DirectoryStream.Filter<Path> filter = entry -> {, +            logger.trace("cleanupOldFiles: cleaning up {}", dataLocation);, +                    logger.trace("cleanupOldFiles: cleaned up {}", stateFile);, +++ b/server/src/main/java/org/elasticsearch/gateway/MetaStateService.java, +            logger.trace("[{}] state written", index);, +            logger.trace("[_global] state written");, +++ b/server/src/main/java/org/elasticsearch/gateway/MetaDataStateFormat.java, +import org.elasticsearch.common.logging.Loggers;, +    private static final Logger logger = Loggers.getLogger(MetaDataStateFormat.class);, +            logger.trace("written state to {}", finalStatePath);, +                    logger.trace("copied state to {}", finalPath);, +                    logger.trace("cleaned up {}", tmpPath);, +            logger.trace("cleaned up {}", tmpStatePath);, +        final DirectoryStream.Filter<Path> filter = entry -> {, +            logger.trace("cleanupOldFiles: cleaning up {}", dataLocation);, +                    logger.trace("cleanupOldFiles: cleaned up {}", stateFile);, +++ b/server/src/main/java/org/elasticsearch/gateway/MetaStateService.java, +            logger.trace("[{}] state written", index);, +            logger.trace("[_global] state written");, +++ b/server/src/test/java/org/elasticsearch/transport/RemoteClusterClientTests.java, +import java.util.concurrent.Semaphore;, +                Semaphore semaphore = new Semaphore(1);, +                service.addConnectionListener(new TransportConnectionListener() {, +                    @Override, +                    public void onNodeDisconnected(DiscoveryNode node) {, +                        if (remoteNode.equals(node)) {, +                            semaphore.release();, +                        }, +                    }, +                });, +                // this test is not perfect since we might reconnect concurrently but it will fail most of the time if we don't have, +                // the right calls in place in the RemoteAwareClient, +                for (int i = 0; i < 10; i++) {, +                    semaphore.acquire();, +                    try {, +                        semaphore.acquire();, +                        assertTrue(remoteClusterService.isRemoteNodeConnected("test", remoteNode));, +                    } finally {, +                        semaphore.release();, +        }, +    }, +++ b/server/src/main/java/org/elasticsearch/gateway/MetaDataStateFormat.java, +import org.elasticsearch.common.logging.Loggers;, +    private static final Logger logger = Loggers.getLogger(MetaDataStateFormat.class);, +            logger.trace("written state to {}", finalStatePath);, +                    logger.trace("copied state to {}", finalPath);, +                    logger.trace("cleaned up {}", tmpPath);, +            logger.trace("cleaned up {}", tmpStatePath);, +        final DirectoryStream.Filter<Path> filter = entry -> {, +            logger.trace("cleanupOldFiles: cleaning up {}", dataLocation);, +                    logger.trace("cleanupOldFiles: cleaned up {}", stateFile);, +++ b/server/src/main/java/org/elasticsearch/gateway/MetaStateService.java, +            logger.trace("[{}] state written", index);, +            logger.trace("[_global] state written");, +++ b/server/src/test/java/org/elasticsearch/transport/RemoteClusterClientTests.java, +import java.util.concurrent.Semaphore;, +                Semaphore semaphore = new Semaphore(1);, +                service.addConnectionListener(new TransportConnectionListener() {, +                    @Override, +                    public void onNodeDisconnected(DiscoveryNode node) {, +                        if (remoteNode.equals(node)) {, +                            semaphore.release();, +                        }, +                    }, +                });, +                // this test is not perfect since we might reconnect concurrently but it will fail most of the time if we don't have, +                // the right calls in place in the RemoteAwareClient, +                for (int i = 0; i < 10; i++) {, +                    semaphore.acquire();, +                    try {, +                        semaphore.acquire();, +                        assertTrue(remoteClusterService.isRemoteNodeConnected("test", remoteNode));, +                    } finally {, +                        semaphore.release();, +        }, +    }, +++ /dev/null, +++ b/server/src/main/java/org/elasticsearch/gateway/MetaDataStateFormat.java, +import org.elasticsearch.common.logging.Loggers;, +    private static final Logger logger = Loggers.getLogger(MetaDataStateFormat.class);, +            logger.trace("written state to {}", finalStatePath);, +                    logger.trace("copied state to {}", finalPath);, +                    logger.trace("cleaned up {}", tmpPath);]