[+++ b/core/src/main/java/org/elasticsearch/cluster/action/shard/ShardStateAction.java, +import org.elasticsearch.cluster.ClusterService;, +import org.elasticsearch.cluster.ClusterState;, +import org.elasticsearch.cluster.ClusterStateUpdateTask;, +import java.util.concurrent.CountDownLatch;, +    private final BlockingQueue<ShardRoutingEntry> failedShardQueue = ConcurrentCollections.newBlockingQueue();, +        failedShardQueue.add(shardRoutingEntry);, +        clusterService.submitStateUpdateTask("shard-failed (" + shardRoutingEntry.shardRouting + "), message [" + shardRoutingEntry.message + "]",, +                new ClusterStateUpdateTask(Priority.HIGH) {, +, +            @Override, +            public ClusterState execute(ClusterState currentState) {, +                if (shardRoutingEntry.processed) {, +                    return currentState;, +                List<ShardRoutingEntry> shardRoutingEntries = new ArrayList<>();, +                failedShardQueue.drainTo(shardRoutingEntries);, +, +                // nothing to process (a previous event has processed it already), +                if (shardRoutingEntries.isEmpty()) {, +                    return currentState;, +                }, +, +                List<FailedRerouteAllocation.FailedShard> shardRoutingsToBeApplied = new ArrayList<>(shardRoutingEntries.size());, +, +                // mark all entries as processed, +                for (ShardRoutingEntry entry : shardRoutingEntries) {, +                    entry.processed = true;, +                    shardRoutingsToBeApplied.add(new FailedRerouteAllocation.FailedShard(entry.shardRouting, entry.message, entry.failure));, +                }, +, +                RoutingAllocation.Result routingResult = allocationService.applyFailedShards(currentState, shardRoutingsToBeApplied);, +                if (!routingResult.changed()) {, +                    return currentState;, +                }, +                return ClusterState.builder(currentState).routingResult(routingResult).build();, +            }, +, +            public void onFailure(String source, Throwable t) {, +                logger.error("unexpected failure during [{}]", t, source);, +        });, +++ b/core/src/main/java/org/elasticsearch/cluster/action/shard/ShardStateAction.java, +import org.elasticsearch.cluster.ClusterService;, +import org.elasticsearch.cluster.ClusterState;, +import org.elasticsearch.cluster.ClusterStateUpdateTask;, +import java.util.concurrent.CountDownLatch;, +    private final BlockingQueue<ShardRoutingEntry> failedShardQueue = ConcurrentCollections.newBlockingQueue();, +        failedShardQueue.add(shardRoutingEntry);, +        clusterService.submitStateUpdateTask("shard-failed (" + shardRoutingEntry.shardRouting + "), message [" + shardRoutingEntry.message + "]",, +                new ClusterStateUpdateTask(Priority.HIGH) {, +, +            @Override, +            public ClusterState execute(ClusterState currentState) {, +                if (shardRoutingEntry.processed) {, +                    return currentState;, +                List<ShardRoutingEntry> shardRoutingEntries = new ArrayList<>();, +                failedShardQueue.drainTo(shardRoutingEntries);, +, +                // nothing to process (a previous event has processed it already), +                if (shardRoutingEntries.isEmpty()) {, +                    return currentState;, +                }, +, +                List<FailedRerouteAllocation.FailedShard> shardRoutingsToBeApplied = new ArrayList<>(shardRoutingEntries.size());, +, +                // mark all entries as processed, +                for (ShardRoutingEntry entry : shardRoutingEntries) {, +                    entry.processed = true;, +                    shardRoutingsToBeApplied.add(new FailedRerouteAllocation.FailedShard(entry.shardRouting, entry.message, entry.failure));, +                }, +, +                RoutingAllocation.Result routingResult = allocationService.applyFailedShards(currentState, shardRoutingsToBeApplied);, +                if (!routingResult.changed()) {, +                    return currentState;, +                }, +                return ClusterState.builder(currentState).routingResult(routingResult).build();, +            }, +, +            public void onFailure(String source, Throwable t) {, +                logger.error("unexpected failure during [{}]", t, source);, +        });, +++ b/core/src/main/java/org/elasticsearch/cluster/routing/allocation/AllocationService.java, +        return applyFailedShards(clusterState, Collections.singletonList(new FailedRerouteAllocation.FailedShard(failedShard, null, null)));, +++ b/core/src/main/java/org/elasticsearch/cluster/action/shard/ShardStateAction.java, +import org.elasticsearch.cluster.ClusterService;, +import org.elasticsearch.cluster.ClusterState;, +import org.elasticsearch.cluster.ClusterStateUpdateTask;, +import java.util.concurrent.CountDownLatch;, +    private final BlockingQueue<ShardRoutingEntry> failedShardQueue = ConcurrentCollections.newBlockingQueue();, +        failedShardQueue.add(shardRoutingEntry);, +        clusterService.submitStateUpdateTask("shard-failed (" + shardRoutingEntry.shardRouting + "), message [" + shardRoutingEntry.message + "]",, +                new ClusterStateUpdateTask(Priority.HIGH) {, +, +            @Override, +            public ClusterState execute(ClusterState currentState) {, +                if (shardRoutingEntry.processed) {, +                    return currentState;, +                List<ShardRoutingEntry> shardRoutingEntries = new ArrayList<>();, +                failedShardQueue.drainTo(shardRoutingEntries);, +, +                // nothing to process (a previous event has processed it already)]