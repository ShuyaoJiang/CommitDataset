[+++ b/core/src/main/java/org/elasticsearch/percolator/MultiDocumentPercolatorIndex.java, +            Analyzer analyzer = context.mapperService().documentMapper(parsedDocument.type()).mappers().indexAnalyzer();, +            memoryIndices[i] = indexDoc(d, analyzer, memoryIndex).createSearcher().getIndexReader();, +    MemoryIndex indexDoc(ParseContext.Document d, Analyzer analyzer, MemoryIndex memoryIndex) {, +++ b/core/src/main/java/org/elasticsearch/percolator/MultiDocumentPercolatorIndex.java, +            Analyzer analyzer = context.mapperService().documentMapper(parsedDocument.type()).mappers().indexAnalyzer();, +            memoryIndices[i] = indexDoc(d, analyzer, memoryIndex).createSearcher().getIndexReader();, +    MemoryIndex indexDoc(ParseContext.Document d, Analyzer analyzer, MemoryIndex memoryIndex) {, +++ b/core/src/main/java/org/elasticsearch/percolator/PercolateDocumentParser.java, +    private final MappingUpdatedAction mappingUpdatedAction;, +    public PercolateDocumentParser(HighlightPhase highlightPhase, SortParseElement sortParseElement, AggregationPhase aggregationPhase, MappingUpdatedAction mappingUpdatedAction) {, +        this.mappingUpdatedAction = mappingUpdatedAction;, +                        if (doc.dynamicMappingsUpdate() != null) {, +                            mappingUpdatedAction.updateMappingOnMasterSynchronously(request.shardId().getIndex(), request.documentType(), doc.dynamicMappingsUpdate());, +                        }, +++ b/core/src/main/java/org/elasticsearch/percolator/MultiDocumentPercolatorIndex.java, +            Analyzer analyzer = context.mapperService().documentMapper(parsedDocument.type()).mappers().indexAnalyzer();, +            memoryIndices[i] = indexDoc(d, analyzer, memoryIndex).createSearcher().getIndexReader();, +    MemoryIndex indexDoc(ParseContext.Document d, Analyzer analyzer, MemoryIndex memoryIndex) {, +++ b/core/src/main/java/org/elasticsearch/percolator/PercolateDocumentParser.java, +    private final MappingUpdatedAction mappingUpdatedAction;, +    public PercolateDocumentParser(HighlightPhase highlightPhase, SortParseElement sortParseElement, AggregationPhase aggregationPhase, MappingUpdatedAction mappingUpdatedAction) {, +        this.mappingUpdatedAction = mappingUpdatedAction;, +                        if (doc.dynamicMappingsUpdate() != null) {, +                            mappingUpdatedAction.updateMappingOnMasterSynchronously(request.shardId().getIndex(), request.documentType(), doc.dynamicMappingsUpdate());, +                        }, +++ b/core/src/main/java/org/elasticsearch/percolator/PercolatorService.java, +            boolean isNested = indexShard.mapperService().documentMapper(request.documentType()).hasNestedObjects();, +++ b/core/src/main/java/org/elasticsearch/percolator/MultiDocumentPercolatorIndex.java, +            Analyzer analyzer = context.mapperService().documentMapper(parsedDocument.type()).mappers().indexAnalyzer();, +            memoryIndices[i] = indexDoc(d, analyzer, memoryIndex).createSearcher().getIndexReader();, +    MemoryIndex indexDoc(ParseContext.Document d, Analyzer analyzer, MemoryIndex memoryIndex) {, +++ b/core/src/main/java/org/elasticsearch/percolator/PercolateDocumentParser.java, +    private final MappingUpdatedAction mappingUpdatedAction;, +    public PercolateDocumentParser(HighlightPhase highlightPhase, SortParseElement sortParseElement, AggregationPhase aggregationPhase, MappingUpdatedAction mappingUpdatedAction) {, +        this.mappingUpdatedAction = mappingUpdatedAction;, +                        if (doc.dynamicMappingsUpdate() != null) {, +                            mappingUpdatedAction.updateMappingOnMasterSynchronously(request.shardId().getIndex(), request.documentType(), doc.dynamicMappingsUpdate());, +                        }, +++ b/core/src/main/java/org/elasticsearch/percolator/PercolatorService.java, +            boolean isNested = indexShard.mapperService().documentMapper(request.documentType()).hasNestedObjects();, +++ b/core/src/main/java/org/elasticsearch/percolator/SingleDocumentPercolatorIndex.java, +                Analyzer analyzer = context.mapperService().documentMapper(parsedDocument.type()).mappers().indexAnalyzer();, +++ b/core/src/main/java/org/elasticsearch/percolator/MultiDocumentPercolatorIndex.java, +            Analyzer analyzer = context.mapperService().documentMapper(parsedDocument.type()).mappers().indexAnalyzer();, +            memoryIndices[i] = indexDoc(d, analyzer, memoryIndex).createSearcher().getIndexReader();, +    MemoryIndex indexDoc(ParseContext.Document d, Analyzer analyzer, MemoryIndex memoryIndex) {, +++ b/core/src/main/java/org/elasticsearch/percolator/PercolateDocumentParser.java, +    private final MappingUpdatedAction mappingUpdatedAction;, +    public PercolateDocumentParser(HighlightPhase highlightPhase, SortParseElement sortParseElement, AggregationPhase aggregationPhase, MappingUpdatedAction mappingUpdatedAction) {, +        this.mappingUpdatedAction = mappingUpdatedAction;, +                        if (doc.dynamicMappingsUpdate() != null) {, +                            mappingUpdatedAction.updateMappingOnMasterSynchronously(request.shardId().getIndex(), request.documentType(), doc.dynamicMappingsUpdate());, +                        }, +++ b/core/src/main/java/org/elasticsearch/percolator/PercolatorService.java, +            boolean isNested = indexShard.mapperService().documentMapper(request.documentType()).hasNestedObjects();, +++ b/core/src/main/java/org/elasticsearch/percolator/SingleDocumentPercolatorIndex.java, +                Analyzer analyzer = context.mapperService().documentMapper(parsedDocument.type()).mappers().indexAnalyzer();, +++ b/core/src/main/java/org/elasticsearch/search/sort/ScriptSortBuilder.java, +            builder.field("nested_filter", nestedFilter, builderParams);, +++ b/core/src/main/java/org/elasticsearch/percolator/MultiDocumentPercolatorIndex.java, +            Analyzer analyzer = context.mapperService().documentMapper(parsedDocument.type()).mappers().indexAnalyzer();, +            memoryIndices[i] = indexDoc(d, analyzer, memoryIndex).createSearcher().getIndexReader();, +    MemoryIndex indexDoc(ParseContext.Document d, Analyzer analyzer, MemoryIndex memoryIndex) {, +++ b/core/src/main/java/org/elasticsearch/percolator/PercolateDocumentParser.java, +    private final MappingUpdatedAction mappingUpdatedAction;, +    public PercolateDocumentParser(HighlightPhase highlightPhase, SortParseElement sortParseElement, AggregationPhase aggregationPhase, MappingUpdatedAction mappingUpdatedAction) {, +        this.mappingUpdatedAction = mappingUpdatedAction;, +                        if (doc.dynamicMappingsUpdate() != null) {, +                            mappingUpdatedAction.updateMappingOnMasterSynchronously(request.shardId().getIndex(), request.documentType(), doc.dynamicMappingsUpdate());, +                        }, +++ b/core/src/main/java/org/elasticsearch/percolator/PercolatorService.java, +            boolean isNested = indexShard.mapperService().documentMapper(request.documentType()).hasNestedObjects();, +++ b/core/src/main/java/org/elasticsearch/percolator/SingleDocumentPercolatorIndex.java, +                Analyzer analyzer = context.mapperService().documentMapper(parsedDocument.type()).mappers().indexAnalyzer();, +++ b/core/src/main/java/org/elasticsearch/search/sort/ScriptSortBuilder.java, +            builder.field("nested_filter", nestedFilter, builderParams);, +++ b/core/src/main/java/org/elasticsearch/search/sort/SortBuilders.java, +++ b/core/src/main/java/org/elasticsearch/percolator/MultiDocumentPercolatorIndex.java, +            Analyzer analyzer = context.mapperService().documentMapper(parsedDocument.type()).mappers().indexAnalyzer();, +            memoryIndices[i] = indexDoc(d, analyzer, memoryIndex).createSearcher().getIndexReader();, +    MemoryIndex indexDoc(ParseContext.Document d, Analyzer analyzer, MemoryIndex memoryIndex) {, +++ b/core/src/main/java/org/elasticsearch/percolator/PercolateDocumentParser.java, +    private final MappingUpdatedAction mappingUpdatedAction;, +    public PercolateDocumentParser(HighlightPhase highlightPhase, SortParseElement sortParseElement, AggregationPhase aggregationPhase, MappingUpdatedAction mappingUpdatedAction) {, +        this.mappingUpdatedAction = mappingUpdatedAction;, +                        if (doc.dynamicMappingsUpdate() != null) {, +                            mappingUpdatedAction.updateMappingOnMasterSynchronously(request.shardId().getIndex(), request.documentType(), doc.dynamicMappingsUpdate());, +                        }, +++ b/core/src/main/java/org/elasticsearch/percolator/PercolatorService.java, +            boolean isNested = indexShard.mapperService().documentMapper(request.documentType()).hasNestedObjects();, +++ b/core/src/main/java/org/elasticsearch/percolator/SingleDocumentPercolatorIndex.java, +                Analyzer analyzer = context.mapperService().documentMapper(parsedDocument.type()).mappers().indexAnalyzer();, +++ b/core/src/main/java/org/elasticsearch/search/sort/ScriptSortBuilder.java, +            builder.field("nested_filter", nestedFilter, builderParams);, +++ b/core/src/main/java/org/elasticsearch/search/sort/SortBuilders.java, +++ b/core/src/test/java/org/elasticsearch/percolator/PercolateDocumentParserTests.java, +import org.elasticsearch.cluster.action.index.MappingUpdatedAction;, +        MappingUpdatedAction mappingUpdatedAction = Mockito.mock(MappingUpdatedAction.class);, +        parser = new PercolateDocumentParser(]