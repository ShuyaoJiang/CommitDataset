[+++ b/core/src/main/java/org/elasticsearch/index/mapper/core/AbstractFieldMapper.java, +            this.fieldType().setIndexAnalyzer(Lucene.KEYWORD_ANALYZER);, +            this.fieldType().setSearchAnalyzer(Lucene.KEYWORD_ANALYZER);, +        this.fieldType().setHasDocValues(docValues == null ? defaultDocValues() : docValues);, +        this.fieldType().setFieldDataType(fieldDataType);, +        this.fieldType().freeze();, +            return fieldType().tokenized() == false && fieldType().indexOptions() != IndexOptions.NONE;, +        return fieldType().names().shortName();, +                    field.setBoost(fieldType().boost());, +            throw new MapperParsingException("failed to parse [" + fieldType().names().fullName() + "]", e);, +            mergeResult.addConflict("mapper [" + fieldType().names().fullName() + "] of different type, current_type [" + contentType() + "], merged_type [" + mergedType + "]");, +        boolean indexed =  fieldType().indexOptions() != IndexOptions.NONE;, +            mergeResult.addConflict("mapper [" + fieldType().names().fullName() + "] has different index values");, +            mergeResult.addConflict("mapper [" + fieldType().names().fullName() + "] has different store values");, +            mergeResult.addConflict("mapper [" + fieldType().names().fullName() + "] has different " + TypeParsers.DOC_VALUES + " values");, +        if (this.fieldType().omitNorms() && !fieldMergeWith.fieldType().omitNorms()) {, +            mergeResult.addConflict("mapper [" + fieldType().names().fullName() + "] cannot enable norms (`norms.enabled`)");, +            mergeResult.addConflict("mapper [" + fieldType().names().fullName() + "] has different tokenize values");, +            mergeResult.addConflict("mapper [" + fieldType().names().fullName() + "] has different store_term_vector values");, +            mergeResult.addConflict("mapper [" + fieldType().names().fullName() + "] has different store_term_vector_offsets values");, +            mergeResult.addConflict("mapper [" + fieldType().names().fullName() + "] has different store_term_vector_positions values");, +            mergeResult.addConflict("mapper [" + fieldType().names().fullName() + "] has different store_term_vector_payloads values");, +        if (this.fieldType().indexAnalyzer() == null || "default".equals(this.fieldType().indexAnalyzer().name())) {, +            if (fieldMergeWith.fieldType().indexAnalyzer() != null && "default".equals(fieldMergeWith.fieldType().indexAnalyzer().name()) == false) {, +                mergeResult.addConflict("mapper [" + fieldType().names().fullName() + "] has different analyzer");, +        } else if (fieldMergeWith.fieldType().indexAnalyzer() == null || "default".equals(fieldMergeWith.fieldType().indexAnalyzer().name())) {, +            mergeResult.addConflict("mapper [" + fieldType().names().fullName() + "] has different analyzer");, +        } else if (this.fieldType().indexAnalyzer().name().equals(fieldMergeWith.fieldType().indexAnalyzer().name()) == false) {, +            mergeResult.addConflict("mapper [" + fieldType().names().fullName() + "] has different analyzer");, +            mergeResult.addConflict("mapper [" + fieldType().names().fullName() + "] has different index_name");, +        if (this.fieldType().similarity() == null) {, +            if (fieldMergeWith.fieldType().similarity() != null) {, +                mergeResult.addConflict("mapper [" + fieldType().names().fullName() + "] has different similarity");, +            mergeResult.addConflict("mapper [" + fieldType().names().fullName() + "] has different similarity");, +            mergeResult.addConflict("mapper [" + fieldType().names().fullName() + "] has different similarity");, +            this.fieldType = this.fieldType().clone();, +            this.fieldType().setOmitNorms(fieldMergeWith.fieldType().omitNorms());, +            this.fieldType().setBoost(fieldMergeWith.fieldType().boost());, +            this.fieldType().setNormsLoading(fieldMergeWith.fieldType().normsLoading());, +            if (fieldMergeWith.fieldType().searchAnalyzer() != null) {, +                this.fieldType().setSearchAnalyzer(fieldMergeWith.fieldType().searchAnalyzer());, +                    this.fieldType().setFieldDataType(new FieldDataType(defaultFieldDataType().getType(),, +            this.fieldType().freeze();, +        builder.startObject(fieldType().names().shortName());, +        if (indexCreatedBefore2x && (includeDefaults || !fieldType().names().shortName().equals(fieldType().names().originalIndexName()))) {, +            builder.field("index_name", fieldType().names().originalIndexName());, +        if (includeDefaults || fieldType().boost() != 1.0f) {, +            builder.field("boost", fieldType().boost());, +        boolean indexed =  fieldType().indexOptions() != IndexOptions.NONE;, +                fieldType().tokenized() != defaultFieldType.tokenized()) {, +            builder.field("index", indexTokenizeOptionToString(indexed, fieldType().tokenized()));, +        if (includeDefaults || fieldType().stored() != defaultFieldType.stored()) {, +            builder.field("store", fieldType().stored());, +        if (includeDefaults || fieldType().storeTermVectors() != defaultFieldType.storeTermVectors()) {, +            builder.field("term_vector", termVectorOptionsToString(fieldType()));, +        if (includeDefaults || fieldType().omitNorms() != defaultFieldType.omitNorms() || fieldType().normsLoading() != null) {, +            if (includeDefaults || fieldType().omitNorms() != defaultFieldType.omitNorms()) {, +                builder.field("enabled", !fieldType().omitNorms());, +            if (fieldType().normsLoading() != null) {, +                builder.field(MappedFieldType.Loading.KEY, fieldType().normsLoading());, +        if (indexed && (includeDefaults || fieldType().indexOptions() != defaultFieldType.indexOptions())) {, +            builder.field("index_options", indexOptionToString(fieldType().indexOptions()));, +            orderedFielddataSettings.putAll(fieldType().fieldDataType().getSettings().getAsMap());, +        if (fieldType().indexAnalyzer() == null) {, +        } else if (includeDefaults || fieldType().indexAnalyzer().name().startsWith("_") == false && fieldType().indexAnalyzer().name().equals("default") == false) {, +            builder.field("analyzer", fieldType().indexAnalyzer().name());, +            if (fieldType().searchAnalyzer().name().equals(fieldType().indexAnalyzer().name()) == false) {, +                builder.field("search_analyzer", fieldType().searchAnalyzer().name());, +++ b/core/src/main/java/org/elasticsearch/index/mapper/core/AbstractFieldMapper.java, +            this.fieldType().setIndexAnalyzer(Lucene.KEYWORD_ANALYZER);, +            this.fieldType().setSearchAnalyzer(Lucene.KEYWORD_ANALYZER);, +        this.fieldType().setHasDocValues(docValues == null ? defaultDocValues() : docValues);, +        this.fieldType().setFieldDataType(fieldDataType);, +        this.fieldType().freeze();, +            return fieldType().tokenized() == false && fieldType().indexOptions() != IndexOptions.NONE;, +        return fieldType().names().shortName();, +                    field.setBoost(fieldType().boost());, +            throw new MapperParsingException("failed to parse [" + fieldType().names().fullName() + "]", e);, +            mergeResult.addConflict("mapper [" + fieldType().names().fullName() + "] of different type, current_type [" + contentType() + "], merged_type [" + mergedType + "]");, +        boolean indexed =  fieldType().indexOptions() != IndexOptions.NONE;, +            mergeResult.addConflict("mapper [" + fieldType().names().fullName() + "] has different index values");, +            mergeResult.addConflict("mapper [" + fieldType().names().fullName() + "] has different store values");, +            mergeResult.addConflict("mapper [" + fieldType().names().fullName() + "] has different " + TypeParsers.DOC_VALUES + " values");, +        if (this.fieldType().omitNorms() && !fieldMergeWith.fieldType().omitNorms()) {, +            mergeResult.addConflict("mapper [" + fieldType().names().fullName() + "] cannot enable norms (`norms.enabled`)");, +            mergeResult.addConflict("mapper [" + fieldType().names().fullName() + "] has different tokenize values");, +            mergeResult.addConflict("mapper [" + fieldType().names().fullName() + "] has different store_term_vector values");, +            mergeResult.addConflict("mapper [" + fieldType().names().fullName() + "] has different store_term_vector_offsets values");, +            mergeResult.addConflict("mapper [" + fieldType().names().fullName() + "] has different store_term_vector_positions values");, +            mergeResult.addConflict("mapper [" + fieldType().names().fullName() + "] has different store_term_vector_payloads values");, +        if (this.fieldType().indexAnalyzer() == null || "default".equals(this.fieldType().indexAnalyzer().name())) {, +            if (fieldMergeWith.fieldType().indexAnalyzer() != null && "default".equals(fieldMergeWith.fieldType().indexAnalyzer().name()) == false) {, +                mergeResult.addConflict("mapper [" + fieldType().names().fullName() + "] has different analyzer");, +        } else if (fieldMergeWith.fieldType().indexAnalyzer() == null || "default".equals(fieldMergeWith.fieldType().indexAnalyzer().name())) {, +            mergeResult.addConflict("mapper [" + fieldType().names().fullName() + "] has different analyzer");, +        } else if (this.fieldType().indexAnalyzer().name().equals(fieldMergeWith.fieldType().indexAnalyzer().name()) == false) {, +            mergeResult.addConflict("mapper [" + fieldType().names().fullName() + "] has different analyzer");, +            mergeResult.addConflict("mapper [" + fieldType().names().fullName() + "] has different index_name");, +        if (this.fieldType().similarity() == null) {, +            if (fieldMergeWith.fieldType().similarity() != null) {]