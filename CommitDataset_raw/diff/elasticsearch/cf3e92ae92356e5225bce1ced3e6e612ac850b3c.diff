[+++ b/core/src/main/java/org/elasticsearch/Version.java, +    public static final Version V_1_7_3 = new Version(V_1_7_3_ID, false, org.apache.lucene.util.Version.LUCENE_4_10_4);, +    public static final int V_1_7_4_ID = 1070499;, +    public static final Version V_1_7_4 = new Version(V_1_7_4_ID, true, org.apache.lucene.util.Version.LUCENE_4_10_4);, +            case V_1_7_4_ID:, +                return V_1_7_4;, +++ b/core/src/main/java/org/elasticsearch/Version.java, +    public static final Version V_1_7_3 = new Version(V_1_7_3_ID, false, org.apache.lucene.util.Version.LUCENE_4_10_4);, +    public static final int V_1_7_4_ID = 1070499;, +    public static final Version V_1_7_4 = new Version(V_1_7_4_ID, true, org.apache.lucene.util.Version.LUCENE_4_10_4);, +            case V_1_7_4_ID:, +                return V_1_7_4;, +++ b/core/src/main/java/org/elasticsearch/bootstrap/JNANatives.java, +    // Set to true, in case policy can be applied to all threads of the process (even existing ones), +    // otherwise they are only inherited for new threads (ES app threads), +    static boolean LOCAL_SECCOMP_ALL = false;, +            int ret = Seccomp.init(tmpFile);, +            if (ret == 1) {, +                LOCAL_SECCOMP_ALL = true;, +            }, +++ b/core/src/main/java/org/elasticsearch/Version.java, +    public static final Version V_1_7_3 = new Version(V_1_7_3_ID, false, org.apache.lucene.util.Version.LUCENE_4_10_4);, +    public static final int V_1_7_4_ID = 1070499;, +    public static final Version V_1_7_4 = new Version(V_1_7_4_ID, true, org.apache.lucene.util.Version.LUCENE_4_10_4);, +            case V_1_7_4_ID:, +                return V_1_7_4;, +++ b/core/src/main/java/org/elasticsearch/bootstrap/JNANatives.java, +    // Set to true, in case policy can be applied to all threads of the process (even existing ones), +    // otherwise they are only inherited for new threads (ES app threads), +    static boolean LOCAL_SECCOMP_ALL = false;, +            int ret = Seccomp.init(tmpFile);, +            if (ret == 1) {, +                LOCAL_SECCOMP_ALL = true;, +            }, +++ b/core/src/main/java/org/elasticsearch/bootstrap/Seccomp.java, +    static final long SECCOMP_MODE_FILTER      =   2;   // since Linux Linux 3.5, +    static final int NR_SYSCALL_TUXCALL  = 184;  // should return ENOSYS, +    private static int linuxImpl() {, +        // pure paranoia:, +, +        // check that unimplemented syscalls actually return ENOSYS, +        // you never know (e.g. https://code.google.com/p/chromium/issues/detail?id=439795), +        if (linux_libc.syscall(NR_SYSCALL_TUXCALL) >= 0 || Native.getLastError() != ENOSYS) {, +            throw new UnsupportedOperationException("seccomp unavailable: your kernel is buggy and you should upgrade");, +        }, +, +        // try to check system calls really are who they claim, +        // you never know (e.g. https://chromium.googlesource.com/chromium/src.git/+/master/sandbox/linux/seccomp-bpf/sandbox_bpf.cc#57), +        final int bogusArg = 0xf7a46a5c;, +, +        // test seccomp(BOGUS), +        long ret = linux_libc.syscall(SECCOMP_SYSCALL_NR, bogusArg);, +        if (ret != -1) {, +            throw new UnsupportedOperationException("seccomp unavailable: seccomp(BOGUS_OPERATION) returned " + ret);, +        } else {, +                case ENOSYS: break; // ok, +                case EINVAL: break; // ok, +                default: throw new UnsupportedOperationException("seccomp(BOGUS_OPERATION): " + JNACLibrary.strerror(errno));, +            }, +        }, +, +        // test seccomp(VALID, BOGUS), +        ret = linux_libc.syscall(SECCOMP_SYSCALL_NR, SECCOMP_SET_MODE_FILTER, bogusArg);, +        if (ret != -1) {, +            throw new UnsupportedOperationException("seccomp unavailable: seccomp(SECCOMP_SET_MODE_FILTER, BOGUS_FLAG) returned " + ret);, +        } else {, +            int errno = Native.getLastError();, +            switch (errno) {, +                case ENOSYS: break; // ok, +                case EINVAL: break; // ok, +                default: throw new UnsupportedOperationException("seccomp(SECCOMP_SET_MODE_FILTER, BOGUS_FLAG): " + JNACLibrary.strerror(errno));, +            }, +        }, +, +        // test prctl(BOGUS), +        ret = linux_libc.prctl(bogusArg, 0, 0, 0, 0);, +        if (ret != -1) {, +            throw new UnsupportedOperationException("seccomp unavailable: prctl(BOGUS_OPTION) returned " + ret);, +        } else {, +            int errno = Native.getLastError();, +            switch (errno) {, +                case ENOSYS: break; // ok, +                case EINVAL: break; // ok, +                default: throw new UnsupportedOperationException("prctl(BOGUS_OPTION): " + JNACLibrary.strerror(errno));, +            }, +        }, +, +        // now just normal defensive checks, +, +        // check for GET_NO_NEW_PRIVS, +        switch (linux_libc.prctl(PR_GET_NO_NEW_PRIVS, 0, 0, 0, 0)) {, +            case 0: break; // not yet set, +            case 1: break; // already set by caller, +            default:, +                int errno = Native.getLastError();, +                if (errno == ENOSYS) {, +                    throw new UnsupportedOperationException("seccomp unavailable: requires kernel 3.5+ with CONFIG_SECCOMP and CONFIG_SECCOMP_FILTER compiled in");, +                } else {, +                    throw new UnsupportedOperationException("prctl(PR_GET_NO_NEW_PRIVS): " + JNACLibrary.strerror(errno));, +        switch (linux_libc.prctl(PR_GET_SECCOMP, 0, 0, 0, 0)) {]