[+++ b/pom.xml, +        <lucene.version>4.1.0</lucene.version>, +++ b/pom.xml, +        <lucene.version>4.1.0</lucene.version>, +++ b/src/main/java/org/apache/lucene/index/TrackingConcurrentMergeScheduler.java, +++ b/pom.xml, +        <lucene.version>4.1.0</lucene.version>, +++ b/src/main/java/org/apache/lucene/index/TrackingConcurrentMergeScheduler.java, +++ /dev/null, +++ b/pom.xml, +        <lucene.version>4.1.0</lucene.version>, +++ b/src/main/java/org/apache/lucene/index/TrackingConcurrentMergeScheduler.java, +++ /dev/null, +++ b/src/main/java/org/apache/lucene/index/TrackingSerialMergeScheduler.java, +++ b/pom.xml, +        <lucene.version>4.1.0</lucene.version>, +++ b/src/main/java/org/apache/lucene/index/TrackingConcurrentMergeScheduler.java, +++ /dev/null, +++ b/src/main/java/org/apache/lucene/index/TrackingSerialMergeScheduler.java, +++ /dev/null, +++ b/pom.xml, +        <lucene.version>4.1.0</lucene.version>, +++ b/src/main/java/org/apache/lucene/index/TrackingConcurrentMergeScheduler.java, +++ /dev/null, +++ b/src/main/java/org/apache/lucene/index/TrackingSerialMergeScheduler.java, +++ /dev/null, +++ b/src/main/java/org/apache/lucene/queryparser/classic/MapperQueryParser.java, +            source.reset();, +                        source.reset();, +                source.reset();, +++ b/pom.xml, +        <lucene.version>4.1.0</lucene.version>, +++ b/src/main/java/org/apache/lucene/index/TrackingConcurrentMergeScheduler.java, +++ /dev/null, +++ b/src/main/java/org/apache/lucene/index/TrackingSerialMergeScheduler.java, +++ /dev/null, +++ b/src/main/java/org/apache/lucene/queryparser/classic/MapperQueryParser.java, +            source.reset();, +                        source.reset();, +                source.reset();, +++ b/src/main/java/org/apache/lucene/store/RateLimitedFSDirectory.java, +package org.apache.lucene.store;, +, +import java.io.IOException;, +import java.util.Collection;, +, +import org.apache.lucene.store.IOContext.Context;, +, +public final class RateLimitedFSDirectory extends Directory {, +    private final FSDirectory delegate;, +, +    private final StoreRateLimiting.Provider rateLimitingProvider;, +, +    private final StoreRateLimiting.Listener rateListener;, +, +    public RateLimitedFSDirectory(FSDirectory wrapped, StoreRateLimiting.Provider rateLimitingProvider,, +            StoreRateLimiting.Listener rateListener) {, +        this.delegate = wrapped;, +        this.rateLimitingProvider = rateLimitingProvider;, +        this.rateListener = rateListener;, +    }, +, +    public FSDirectory wrappedDirectory() {, +        return this.delegate;, +    }, +, +    @Override, +    public String[] listAll() throws IOException {, +        ensureOpen();, +        return delegate.listAll();, +    }, +, +    @Override, +    public boolean fileExists(String name) throws IOException {, +        ensureOpen();, +        return delegate.fileExists(name);, +    }, +, +    @Override, +    public void deleteFile(String name) throws IOException {, +        ensureOpen();, +        delegate.deleteFile(name);, +    }, +, +    @Override, +    public long fileLength(String name) throws IOException {, +        ensureOpen();, +        return delegate.fileLength(name);, +    }, +, +    @Override, +    public IndexOutput createOutput(String name, IOContext context) throws IOException {, +        ensureOpen();, +        final IndexOutput output = delegate.createOutput(name, context);, +, +        StoreRateLimiting rateLimiting = rateLimitingProvider.rateLimiting();, +        StoreRateLimiting.Type type = rateLimiting.getType();, +        RateLimiter limiter = rateLimiting.getRateLimiter();, +        if (type == StoreRateLimiting.Type.NONE || limiter == null) {, +            return output;]