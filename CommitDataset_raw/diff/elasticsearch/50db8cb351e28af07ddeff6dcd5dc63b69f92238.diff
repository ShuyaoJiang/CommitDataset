[+++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/Compiler.java, +import static org.elasticsearch.painless.node.SSource.MainMethodReserved;, +    Constructor<?> compile(Loader loader, MainMethodReserved reserved, String name, String source, CompilerSettings settings) {, +        SSource root = Walker.buildPainlessTree(scriptClassInfo, reserved, name, source, settings, definition,, +        SSource root = Walker.buildPainlessTree(scriptClassInfo, new MainMethodReserved(), name, source, settings, definition,, +++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/Compiler.java, +import static org.elasticsearch.painless.node.SSource.MainMethodReserved;, +    Constructor<?> compile(Loader loader, MainMethodReserved reserved, String name, String source, CompilerSettings settings) {, +        SSource root = Walker.buildPainlessTree(scriptClassInfo, reserved, name, source, settings, definition,, +        SSource root = Walker.buildPainlessTree(scriptClassInfo, new MainMethodReserved(), name, source, settings, definition,, +++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/PainlessScriptEngine.java, +import org.apache.logging.log4j.core.tools.Generate;, +import static org.elasticsearch.painless.node.SSource.MainMethodReserved;, +            MainMethodReserved reserved = new MainMethodReserved();, +            compile(contextsToCompilers.get(context), loader, reserved, scriptName, scriptSource, params);, +                return generateFactory(loader, context, reserved, generateStatefulFactory(loader, context, reserved));, +                return generateFactory(loader, context, reserved, WriterConstants.CLASS_TYPE);, +    private <T> Type generateStatefulFactory(Loader loader, ScriptContext<T> context, MainMethodReserved reserved) {, +        writeNeedsMethods(context.statefulFactoryClazz, writer, reserved);, +    private <T> T generateFactory(Loader loader, ScriptContext<T> context, MainMethodReserved reserved, Type classType) {, +        writeNeedsMethods(context.factoryClazz, writer, reserved);, +    private void writeNeedsMethods(Class<?> clazz, ClassWriter writer, MainMethodReserved reserved) {, +        for (Method method : clazz.getMethods()) {, +            if (method.getName().startsWith("needs") &&, +                method.getReturnType().equals(boolean.class) && method.getParameterTypes().length == 0) {, +                String name = method.getName();, +                name = name.substring(5);, +                name = Character.toLowerCase(name.charAt(0)) + name.substring(1);, +, +                org.objectweb.asm.commons.Method needs = new org.objectweb.asm.commons.Method(method.getName(),, +                    MethodType.methodType(boolean.class).toMethodDescriptorString());, +, +                GeneratorAdapter adapter = new GeneratorAdapter(Opcodes.ASM5, needs,, +                    writer.visitMethod(Opcodes.ACC_PUBLIC, needs.getName(), needs.getDescriptor(), null, null));, +                adapter.visitCode();, +                adapter.push(reserved.getUsedVariables().contains(name));, +                adapter.returnValue();, +                adapter.endMethod();, +            }, +        }, +    }, +, +                    Constructor<?> constructor = compiler.compile(loader, new MainMethodReserved(), name, source, compilerSettings);, +    void compile(Compiler compiler, Loader loader, MainMethodReserved reserved,, +                 String scriptName, String source, Map<String, String> params) {, +                    compiler.compile(loader, reserved, name, source, compilerSettings);, +++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/Compiler.java, +import static org.elasticsearch.painless.node.SSource.MainMethodReserved;, +    Constructor<?> compile(Loader loader, MainMethodReserved reserved, String name, String source, CompilerSettings settings) {, +        SSource root = Walker.buildPainlessTree(scriptClassInfo, reserved, name, source, settings, definition,, +        SSource root = Walker.buildPainlessTree(scriptClassInfo, new MainMethodReserved(), name, source, settings, definition,, +++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/PainlessScriptEngine.java, +import org.apache.logging.log4j.core.tools.Generate;, +import static org.elasticsearch.painless.node.SSource.MainMethodReserved;, +            MainMethodReserved reserved = new MainMethodReserved();, +            compile(contextsToCompilers.get(context), loader, reserved, scriptName, scriptSource, params);, +                return generateFactory(loader, context, reserved, generateStatefulFactory(loader, context, reserved));, +                return generateFactory(loader, context, reserved, WriterConstants.CLASS_TYPE);, +    private <T> Type generateStatefulFactory(Loader loader, ScriptContext<T> context, MainMethodReserved reserved) {, +        writeNeedsMethods(context.statefulFactoryClazz, writer, reserved);, +    private <T> T generateFactory(Loader loader, ScriptContext<T> context, MainMethodReserved reserved, Type classType) {, +        writeNeedsMethods(context.factoryClazz, writer, reserved);, +    private void writeNeedsMethods(Class<?> clazz, ClassWriter writer, MainMethodReserved reserved) {, +        for (Method method : clazz.getMethods()) {, +            if (method.getName().startsWith("needs") &&, +                method.getReturnType().equals(boolean.class) && method.getParameterTypes().length == 0) {, +                String name = method.getName();, +                name = name.substring(5);, +                name = Character.toLowerCase(name.charAt(0)) + name.substring(1);, +, +                org.objectweb.asm.commons.Method needs = new org.objectweb.asm.commons.Method(method.getName(),, +                    MethodType.methodType(boolean.class).toMethodDescriptorString());, +, +                GeneratorAdapter adapter = new GeneratorAdapter(Opcodes.ASM5, needs,, +                    writer.visitMethod(Opcodes.ACC_PUBLIC, needs.getName(), needs.getDescriptor(), null, null));, +                adapter.visitCode();, +                adapter.push(reserved.getUsedVariables().contains(name));, +                adapter.returnValue();, +                adapter.endMethod();, +            }, +        }, +    }, +, +                    Constructor<?> constructor = compiler.compile(loader, new MainMethodReserved(), name, source, compilerSettings);, +    void compile(Compiler compiler, Loader loader, MainMethodReserved reserved,, +                 String scriptName, String source, Map<String, String> params) {, +                    compiler.compile(loader, reserved, name, source, compilerSettings);, +++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/antlr/Walker.java, +    public static SSource buildPainlessTree(ScriptClassInfo mainMethod, MainMethodReserved reserved, String sourceName,, +        return new Walker(mainMethod, reserved, sourceName, sourceText, settings, definition, debugStream).source;, +    private Walker(ScriptClassInfo scriptClassInfo, MainMethodReserved reserved, String sourceName, String sourceText,, +        this.reserved.push(reserved);, +++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/Compiler.java, +import static org.elasticsearch.painless.node.SSource.MainMethodReserved;, +    Constructor<?> compile(Loader loader, MainMethodReserved reserved, String name, String source, CompilerSettings settings) {, +        SSource root = Walker.buildPainlessTree(scriptClassInfo, reserved, name, source, settings, definition,, +        SSource root = Walker.buildPainlessTree(scriptClassInfo, new MainMethodReserved(), name, source, settings, definition,, +++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/PainlessScriptEngine.java, +import org.apache.logging.log4j.core.tools.Generate;, +import static org.elasticsearch.painless.node.SSource.MainMethodReserved;]