[+++ b/core/src/main/java/org/elasticsearch/action/support/replication/TransportReplicationAction.java, +     * {@link IndexShard#acquireReplicaOperationPermit(long, long, ActionListener, String)}., +            replica.acquireReplicaOperationPermit(request.primaryTerm, globalCheckpoint, this, executor);, +++ b/core/src/main/java/org/elasticsearch/action/support/replication/TransportReplicationAction.java, +     * {@link IndexShard#acquireReplicaOperationPermit(long, long, ActionListener, String)}., +            replica.acquireReplicaOperationPermit(request.primaryTerm, globalCheckpoint, this, executor);, +++ b/core/src/main/java/org/elasticsearch/index/shard/IndexShard.java, +     * @param globalCheckpoint     the global checkpoint associated with the request, +    public void acquireReplicaOperationPermit(final long operationPrimaryTerm, final long globalCheckpoint,, +                                              final ActionListener<Releasable> onPermitAcquired, final String executorOnDelay) {, +        final boolean globalCheckpointUpdated;, +                    IndexShardState shardState = state();, +                    // only roll translog and update primary term if shard has made it past recovery, +                    // Having a new primary term here means that the old primary failed and that there is a new primary, which again, +                    // means that the master will fail this shard as all initializing shards are failed when a primary is selected, +                    // We abort early here to prevent an ongoing recovery from the failed primary to mess with the global / local checkpoint, +                    if (shardState != IndexShardState.POST_RECOVERY &&, +                        shardState != IndexShardState.STARTED &&, +                        shardState != IndexShardState.RELOCATED) {, +                        throw new IndexShardNotStartedException(shardId, shardState);, +                    }, +                            updateGlobalCheckpointOnReplica(globalCheckpoint);, +                        globalCheckpointUpdated = true;, +                } else {, +                    globalCheckpointUpdated = false;, +        } else {, +            globalCheckpointUpdated = false;, +                            if (globalCheckpointUpdated == false) {, +                                try {, +                                    updateGlobalCheckpointOnReplica(globalCheckpoint);, +                                } catch (Exception e) {, +                                    releasable.close();, +                                    onPermitAcquired.onFailure(e);, +                                    return;, +                                }, +                            }, +++ b/core/src/main/java/org/elasticsearch/action/support/replication/TransportReplicationAction.java, +     * {@link IndexShard#acquireReplicaOperationPermit(long, long, ActionListener, String)}., +            replica.acquireReplicaOperationPermit(request.primaryTerm, globalCheckpoint, this, executor);, +++ b/core/src/main/java/org/elasticsearch/index/shard/IndexShard.java, +     * @param globalCheckpoint     the global checkpoint associated with the request, +    public void acquireReplicaOperationPermit(final long operationPrimaryTerm, final long globalCheckpoint,, +                                              final ActionListener<Releasable> onPermitAcquired, final String executorOnDelay) {, +        final boolean globalCheckpointUpdated;, +                    IndexShardState shardState = state();, +                    // only roll translog and update primary term if shard has made it past recovery, +                    // Having a new primary term here means that the old primary failed and that there is a new primary, which again, +                    // means that the master will fail this shard as all initializing shards are failed when a primary is selected, +                    // We abort early here to prevent an ongoing recovery from the failed primary to mess with the global / local checkpoint, +                    if (shardState != IndexShardState.POST_RECOVERY &&, +                        shardState != IndexShardState.STARTED &&, +                        shardState != IndexShardState.RELOCATED) {, +                        throw new IndexShardNotStartedException(shardId, shardState);, +                    }, +                            updateGlobalCheckpointOnReplica(globalCheckpoint);, +                        globalCheckpointUpdated = true;, +                } else {, +                    globalCheckpointUpdated = false;, +        } else {, +            globalCheckpointUpdated = false;, +                            if (globalCheckpointUpdated == false) {, +                                try {, +                                    updateGlobalCheckpointOnReplica(globalCheckpoint);, +                                } catch (Exception e) {, +                                    releasable.close();, +                                    onPermitAcquired.onFailure(e);, +                                    return;, +                                }, +                            }, +++ b/core/src/test/java/org/elasticsearch/action/support/replication/TransportReplicationActionTests.java, +            ActionListener<Releasable> callback = (ActionListener<Releasable>) invocation.getArguments()[2];, +        }).when(indexShard).acquireReplicaOperationPermit(anyLong(), anyLong(), any(ActionListener.class), anyString());, +++ b/core/src/main/java/org/elasticsearch/action/support/replication/TransportReplicationAction.java, +     * {@link IndexShard#acquireReplicaOperationPermit(long, long, ActionListener, String)}., +            replica.acquireReplicaOperationPermit(request.primaryTerm, globalCheckpoint, this, executor);, +++ b/core/src/main/java/org/elasticsearch/index/shard/IndexShard.java, +     * @param globalCheckpoint     the global checkpoint associated with the request, +    public void acquireReplicaOperationPermit(final long operationPrimaryTerm, final long globalCheckpoint,, +                                              final ActionListener<Releasable> onPermitAcquired, final String executorOnDelay) {, +        final boolean globalCheckpointUpdated;, +                    IndexShardState shardState = state();, +                    // only roll translog and update primary term if shard has made it past recovery, +                    // Having a new primary term here means that the old primary failed and that there is a new primary, which again, +                    // means that the master will fail this shard as all initializing shards are failed when a primary is selected, +                    // We abort early here to prevent an ongoing recovery from the failed primary to mess with the global / local checkpoint, +                    if (shardState != IndexShardState.POST_RECOVERY &&, +                        shardState != IndexShardState.STARTED &&, +                        shardState != IndexShardState.RELOCATED) {, +                        throw new IndexShardNotStartedException(shardId, shardState);, +                    }, +                            updateGlobalCheckpointOnReplica(globalCheckpoint);, +                        globalCheckpointUpdated = true;, +                } else {, +                    globalCheckpointUpdated = false;, +        } else {, +            globalCheckpointUpdated = false;, +                            if (globalCheckpointUpdated == false) {, +                                try {, +                                    updateGlobalCheckpointOnReplica(globalCheckpoint);, +                                } catch (Exception e) {]