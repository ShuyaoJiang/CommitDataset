[+++ b/src/main/java/org/elasticsearch/discovery/zen/ZenDiscovery.java, +import org.elasticsearch.discovery.zen.ping.PingContextProvider;, +import java.util.concurrent.atomic.AtomicLong;, +public class ZenDiscovery extends AbstractLifecycleComponent<Discovery> implements Discovery, PingContextProvider {, +    /** counts the time this node has joined the cluster or have elected it self as master */, +    private final AtomicLong clusterJoinsCounter = new AtomicLong();, +, +        this.pingService.setPingContextProvider(this);, +    /** start of {@link org.elasticsearch.discovery.zen.ping.PingContextProvider } implementation */, +    public boolean nodeHasJoinedClusterOnce() {, +        return clusterJoinsCounter.get() > 0;, +    }, +, +    /** end of {@link org.elasticsearch.discovery.zen.ping.PingContextProvider } implementation */, +, +, +    @Override, +                        long count = clusterJoinsCounter.incrementAndGet();, +                        logger.trace("cluster joins counter set to [{}] (elected as master)", count);, +                long count = clusterJoinsCounter.incrementAndGet();, +                logger.trace("cluster joins counter set to [{}] (joined master)", count);, +                    sb.append("\n\t--> ").append(pingResponse);, +            DiscoveryNode node = pingResponse.node();, +                    sb.append("\n\t--> ").append(pingResponse);, +        // nodes discovered during pinging, +        Set<DiscoveryNode> activeNodes = Sets.newHashSet();, +        // nodes discovered who has previously been part of the cluster and do not ping for the very first time, +        Set<DiscoveryNode> joinedOnceActiveNodes = Sets.newHashSet();, +            activeNodes.add(localNode);, +            long joinsCounter = clusterJoinsCounter.get();, +            if (joinsCounter > 0) {, +                logger.trace("adding local node to the list of active nodes who has previously joined the cluster (joins counter is [{}})", joinsCounter);, +                joinedOnceActiveNodes.add(localNode);, +            }, +            activeNodes.add(pingResponse.node());, +            if (pingResponse.hasJoinedOnce()) {, +                joinedOnceActiveNodes.add(pingResponse.node());, +            }, +            if (electMaster.hasEnoughMasterNodes(activeNodes)) {, +                // we give preference to nodes who have previously already joined the cluster. Those will, +                // have a cluster state in memory, including an up to date routing table (which is not persistent to disk, +                // by the gateway), +                DiscoveryNode master = electMaster.electMaster(joinedOnceActiveNodes);, +                if (master != null) {, +                    return master;, +                }, +                return electMaster.electMaster(activeNodes);, +                // if we don't have enough master nodes, we bail, because there are not enough master to elect from, +                logger.trace("not enough master nodes [{}]", activeNodes);, +++ b/src/main/java/org/elasticsearch/discovery/zen/ZenDiscovery.java, +import org.elasticsearch.discovery.zen.ping.PingContextProvider;, +import java.util.concurrent.atomic.AtomicLong;, +public class ZenDiscovery extends AbstractLifecycleComponent<Discovery> implements Discovery, PingContextProvider {, +    /** counts the time this node has joined the cluster or have elected it self as master */, +    private final AtomicLong clusterJoinsCounter = new AtomicLong();, +, +        this.pingService.setPingContextProvider(this);, +    /** start of {@link org.elasticsearch.discovery.zen.ping.PingContextProvider } implementation */, +    public boolean nodeHasJoinedClusterOnce() {, +        return clusterJoinsCounter.get() > 0;, +    }, +, +    /** end of {@link org.elasticsearch.discovery.zen.ping.PingContextProvider } implementation */, +, +, +    @Override, +                        long count = clusterJoinsCounter.incrementAndGet();, +                        logger.trace("cluster joins counter set to [{}] (elected as master)", count);, +                long count = clusterJoinsCounter.incrementAndGet();, +                logger.trace("cluster joins counter set to [{}] (joined master)", count);, +                    sb.append("\n\t--> ").append(pingResponse);, +            DiscoveryNode node = pingResponse.node();, +                    sb.append("\n\t--> ").append(pingResponse);, +        // nodes discovered during pinging, +        Set<DiscoveryNode> activeNodes = Sets.newHashSet();, +        // nodes discovered who has previously been part of the cluster and do not ping for the very first time, +        Set<DiscoveryNode> joinedOnceActiveNodes = Sets.newHashSet();, +            activeNodes.add(localNode);, +            long joinsCounter = clusterJoinsCounter.get();, +            if (joinsCounter > 0) {, +                logger.trace("adding local node to the list of active nodes who has previously joined the cluster (joins counter is [{}})", joinsCounter);, +                joinedOnceActiveNodes.add(localNode);, +            }, +            activeNodes.add(pingResponse.node());, +            if (pingResponse.hasJoinedOnce()) {, +                joinedOnceActiveNodes.add(pingResponse.node());, +            }, +            if (electMaster.hasEnoughMasterNodes(activeNodes)) {, +                // we give preference to nodes who have previously already joined the cluster. Those will, +                // have a cluster state in memory, including an up to date routing table (which is not persistent to disk, +                // by the gateway), +                DiscoveryNode master = electMaster.electMaster(joinedOnceActiveNodes);, +                if (master != null) {, +                    return master;, +                }, +                return electMaster.electMaster(activeNodes);, +                // if we don't have enough master nodes, we bail, because there are not enough master to elect from, +                logger.trace("not enough master nodes [{}]", activeNodes);, +++ b/src/main/java/org/elasticsearch/discovery/zen/ping/PingContextProvider.java, +/*]