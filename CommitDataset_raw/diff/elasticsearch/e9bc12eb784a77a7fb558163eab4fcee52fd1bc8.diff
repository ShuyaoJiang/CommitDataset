[+++ b/x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authc/TokenService.java, +                final Authentication clientAuth = Authentication.readFromContext(client.threadPool().getThreadContext());, +                innerRefresh(tokenDocId, clientAuth, listener, tuple.v2());, +    private void innerRefresh(String tokenDocId, Authentication clientAuth, ActionListener<Tuple<UserToken, String>> listener,, +                        final Optional<ElasticsearchSecurityException> invalidSource = checkTokenDocForRefresh(source, clientAuth);, +                                        updateResponse -> createUserToken(authentication, clientAuth, listener, metadata, true),, +                                                innerRefresh(tokenDocId, clientAuth,, +                        innerRefresh(tokenDocId, clientAuth, listener, attemptCount);, +    private Optional<ElasticsearchSecurityException> checkTokenDocForRefresh(Map<String, Object> source, Authentication clientAuth) {, +                return checkClient(refreshTokenSrc, clientAuth);, +    private Optional<ElasticsearchSecurityException> checkClient(Map<String, Object> refreshTokenSource, Authentication clientAuth) {, +        } else if (clientAuth.getUser().principal().equals(clientInfo.get("user")) == false) {, +        } else if (clientAuth.getAuthenticatedBy().getName().equals(clientInfo.get("realm")) == false) {, +++ b/x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authc/TokenService.java, +                final Authentication clientAuth = Authentication.readFromContext(client.threadPool().getThreadContext());, +                innerRefresh(tokenDocId, clientAuth, listener, tuple.v2());, +    private void innerRefresh(String tokenDocId, Authentication clientAuth, ActionListener<Tuple<UserToken, String>> listener,, +                        final Optional<ElasticsearchSecurityException> invalidSource = checkTokenDocForRefresh(source, clientAuth);, +                                        updateResponse -> createUserToken(authentication, clientAuth, listener, metadata, true),, +                                                innerRefresh(tokenDocId, clientAuth,, +                        innerRefresh(tokenDocId, clientAuth, listener, attemptCount);, +    private Optional<ElasticsearchSecurityException> checkTokenDocForRefresh(Map<String, Object> source, Authentication clientAuth) {, +                return checkClient(refreshTokenSrc, clientAuth);, +    private Optional<ElasticsearchSecurityException> checkClient(Map<String, Object> refreshTokenSource, Authentication clientAuth) {, +        } else if (clientAuth.getUser().principal().equals(clientInfo.get("user")) == false) {, +        } else if (clientAuth.getAuthenticatedBy().getName().equals(clientInfo.get("realm")) == false) {, +++ b/x-pack/qa/rolling-upgrade/build.gradle, +        if (version.onOrAfter('7.0.0')) {, +          setting 'xpack.security.authc.realms.file.file1.order', '0', +          setting 'xpack.security.authc.realms.native.native1.order', '1', +        } else {, +          setting 'xpack.security.authc.realms.file1.type', 'file', +          setting 'xpack.security.authc.realms.file1.order', '0', +          setting 'xpack.security.authc.realms.native1.type', 'native', +          setting 'xpack.security.authc.realms.native1.order', '1', +        }, +++ b/x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authc/TokenService.java, +                final Authentication clientAuth = Authentication.readFromContext(client.threadPool().getThreadContext());, +                innerRefresh(tokenDocId, clientAuth, listener, tuple.v2());, +    private void innerRefresh(String tokenDocId, Authentication clientAuth, ActionListener<Tuple<UserToken, String>> listener,, +                        final Optional<ElasticsearchSecurityException> invalidSource = checkTokenDocForRefresh(source, clientAuth);, +                                        updateResponse -> createUserToken(authentication, clientAuth, listener, metadata, true),, +                                                innerRefresh(tokenDocId, clientAuth,, +                        innerRefresh(tokenDocId, clientAuth, listener, attemptCount);, +    private Optional<ElasticsearchSecurityException> checkTokenDocForRefresh(Map<String, Object> source, Authentication clientAuth) {, +                return checkClient(refreshTokenSrc, clientAuth);, +    private Optional<ElasticsearchSecurityException> checkClient(Map<String, Object> refreshTokenSource, Authentication clientAuth) {, +        } else if (clientAuth.getUser().principal().equals(clientInfo.get("user")) == false) {, +        } else if (clientAuth.getAuthenticatedBy().getName().equals(clientInfo.get("realm")) == false) {, +++ b/x-pack/qa/rolling-upgrade/build.gradle, +        if (version.onOrAfter('7.0.0')) {, +          setting 'xpack.security.authc.realms.file.file1.order', '0', +          setting 'xpack.security.authc.realms.native.native1.order', '1', +        } else {, +          setting 'xpack.security.authc.realms.file1.type', 'file', +          setting 'xpack.security.authc.realms.file1.order', '0', +          setting 'xpack.security.authc.realms.native1.type', 'native', +          setting 'xpack.security.authc.realms.native1.order', '1', +        }, +++ b/x-pack/qa/rolling-upgrade/src/test/java/org/elasticsearch/upgrades/TokenBackwardsCompatibilityIT.java, +        // Create a couple of tokens and store them in the token_backwards_compatibility_it index to be used for tests in the mixed/upgraded, +        // clusters, +        Response indexResponse1 = client().performRequest(indexRequest1);, +        assertOK(indexResponse1);, +        Response indexResponse2 = client().performRequest(indexRequest2);, +        assertOK(indexResponse2);, +    public void testTokenWorksInMixedCluster() throws Exception {, +        // Verify that an old token continues to work during all stages of the rolling upgrade, +        assumeTrue("this test should only run against the mixed cluster", CLUSTER_TYPE == ClusterType.MIXED);, +    public void testInvalidatingTokenInMixedCluster() throws Exception {, +        // Verify that we can invalidate a token in a mixed cluster, +        assertOK(getResponse);, +        String token = (String) source.get("token");, +        // The token might be already invalidated by running testInvalidatingTokenInMixedCluster in a previous stage, +        // we don't try to assert it works before invalidating. This case is handled by testTokenWorksInMixedCluster, +    }, +, +    public void testMixedClusterWithUpgradedMaster() throws Exception {, +        assumeTrue("this test should only run against the mixed cluster", CLUSTER_TYPE == ClusterType.MIXED);, +        assumeTrue("the master must be on the latest version before we can write", isMasterOnLatestVersion());, +            // Invalidate the new access token and ensure that it no longer works, +            Request invalidateTokenRequest = new Request("DELETE", "/_security/oauth2/token");, +            invalidateTokenRequest.setJsonEntity(, +                "{\n" +, +                    "    \"token\": \"" + updatedAccessToken + "\"\n" +, +                    "}");, +            Response invalidateTokenResponse = client.performRequest(invalidateTokenRequest);, +            assertOK(invalidateTokenResponse);, +            assertTokenDoesNotWork(updatedAccessToken);, +        assumeTrue("this test should only run against the upgraded cluster", CLUSTER_TYPE == ClusterType.UPGRADED);, +        // Use an old token to authenticate, then invalidate it and verify that it can no longer be used, +        Request getRequest = new Request("GET", "token_backwards_compatibility_it/_doc/old_cluster_token1");, +        logger.info("Master node is on version: " + objectPath.evaluate("nodes." + masterNodeId + ".version"));]