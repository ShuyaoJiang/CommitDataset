[+++ b/src/main/java/org/elasticsearch/rest/BaseRestHandler.java, +        handleRequest(request, channel, new HeadersAndContextCopyClient(client, request, usefulHeaders));, +++ b/src/main/java/org/elasticsearch/rest/BaseRestHandler.java, +        handleRequest(request, channel, new HeadersAndContextCopyClient(client, request, usefulHeaders));, +++ b/src/test/java/org/elasticsearch/rest/HeadersAndContextCopyClientTests.java, +/*, + * Licensed to Elasticsearch under one or more contributor, + * license agreements. See the NOTICE file distributed with, + * this work for additional information regarding copyright, + * ownership. Elasticsearch licenses this file to you under, + * the Apache License, Version 2.0 (the "License"); you may, + * not use this file except in compliance with the License., + * You may obtain a copy of the License at, + *, + *    http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing,, + * software distributed under the License is distributed on an, + * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY, + * KIND, either express or implied.  See the License for the, + * specific language governing permissions and limitations, + * under the License., + */, +, +package org.elasticsearch.rest;, +, +import com.google.common.collect.Maps;, +import org.elasticsearch.ElasticsearchException;, +import org.elasticsearch.action.*;, +import org.elasticsearch.action.admin.cluster.health.ClusterHealthRequest;, +import org.elasticsearch.action.admin.cluster.state.ClusterStateRequest;, +import org.elasticsearch.action.admin.cluster.stats.ClusterStatsRequest;, +import org.elasticsearch.action.admin.indices.close.CloseIndexRequest;, +import org.elasticsearch.action.admin.indices.create.CreateIndexRequest;, +import org.elasticsearch.action.admin.indices.flush.FlushRequest;, +import org.elasticsearch.action.get.GetRequest;, +import org.elasticsearch.action.index.IndexRequest;, +import org.elasticsearch.action.search.SearchRequest;, +import org.elasticsearch.client.*;, +import org.elasticsearch.client.support.AbstractClient;, +import org.elasticsearch.client.support.AbstractClusterAdminClient;, +import org.elasticsearch.client.support.AbstractIndicesAdminClient;, +import org.elasticsearch.common.collect.ImmutableOpenMap;, +import org.elasticsearch.common.settings.Settings;, +import org.elasticsearch.test.ElasticsearchTestCase;, +import org.elasticsearch.threadpool.ThreadPool;, +import org.junit.Test;, +, +import java.util.*;, +import java.util.concurrent.ExecutorService;, +import java.util.concurrent.Executors;, +import java.util.concurrent.TimeUnit;, +, +import static org.hamcrest.CoreMatchers.equalTo;, +import static org.hamcrest.CoreMatchers.notNullValue;, +import static org.hamcrest.Matchers.*;, +, +public class HeadersAndContextCopyClientTests extends ElasticsearchTestCase {, +, +    @Test, +    public void testAddUsefulHeaders() throws InterruptedException {, +        //take the existing headers into account to make sure this test runs with tests.iters>1 as the list is static, +        final Set<String> headers = new HashSet<>();, +        headers.addAll(BaseRestHandler.usefulHeaders());, +        int iterations = randomIntBetween(1, 5);, +, +        ExecutorService executorService = Executors.newFixedThreadPool(iterations);, +        for (int i = 0; i < iterations; i++) {, +            int headersCount = randomInt(10);, +            final Set<String> newHeaders = new HashSet<>();, +            for (int j = 0; j < headersCount; j++) {, +                String usefulHeader = randomRealisticUnicodeOfLengthBetween(1, 30);, +                newHeaders.add(usefulHeader);, +                headers.add(usefulHeader);, +            }, +, +            executorService.submit(new Runnable() {, +                @Override, +                public void run() {, +                    BaseRestHandler.addUsefulHeaders(newHeaders.toArray(new String[newHeaders.size()]));, +                }, +            });, +        }, +, +        executorService.shutdown();, +        assertThat(executorService.awaitTermination(1, TimeUnit.SECONDS), equalTo(true));, +        String[] usefulHeaders = BaseRestHandler.usefulHeaders().toArray(new String[BaseRestHandler.usefulHeaders().size()]);, +        assertThat(usefulHeaders.length, equalTo(headers.size()));, +, +        Arrays.sort(usefulHeaders);, +        String[] headersArray = new String[headers.size()];, +        headersArray = headers.toArray(headersArray);, +        Arrays.sort(headersArray);, +        assertThat(usefulHeaders, equalTo(headersArray));, +    }, +, +    @Test, +    public void testCopyHeadersRequest() {, +        Map<String, String> transportHeaders = randomHeaders(randomIntBetween(0, 10));, +        Map<String, String> restHeaders = randomHeaders(randomIntBetween(0, 10));]