[+++ b/buildSrc/src/main/groovy/org/elasticsearch/gradle/precommit/DependencyLicensesTask.groovy, +        if (dependencies.isEmpty()) {, +            if (licensesDir.exists()) {, +            return // no dependencies to check, +        } else if (licensesDir.exists() == false) {, +            throw new GradleException("Licences dir ${licensesDir} does not exist, but there are dependencies"), +        }, +, +++ b/buildSrc/src/main/groovy/org/elasticsearch/gradle/precommit/DependencyLicensesTask.groovy, +        if (dependencies.isEmpty()) {, +            if (licensesDir.exists()) {, +            return // no dependencies to check, +        } else if (licensesDir.exists() == false) {, +            throw new GradleException("Licences dir ${licensesDir} does not exist, but there are dependencies"), +        }, +, +++ b/buildSrc/src/main/resources/forbidden/all-signatures.txt, +@defaultMessage Avoid unchecked warnings by using Collections#empty(List|Map|Set) methods, +java.util.Collections#EMPTY_LIST, +java.util.Collections#EMPTY_MAP, +java.util.Collections#EMPTY_SET, +++ b/buildSrc/src/main/groovy/org/elasticsearch/gradle/precommit/DependencyLicensesTask.groovy, +        if (dependencies.isEmpty()) {, +            if (licensesDir.exists()) {, +            return // no dependencies to check, +        } else if (licensesDir.exists() == false) {, +            throw new GradleException("Licences dir ${licensesDir} does not exist, but there are dependencies"), +        }, +, +++ b/buildSrc/src/main/resources/forbidden/all-signatures.txt, +@defaultMessage Avoid unchecked warnings by using Collections#empty(List|Map|Set) methods, +java.util.Collections#EMPTY_LIST, +java.util.Collections#EMPTY_MAP, +java.util.Collections#EMPTY_SET, +++ b/buildSrc/src/main/resources/forbidden/third-party-signatures.txt, +++ b/buildSrc/src/main/groovy/org/elasticsearch/gradle/precommit/DependencyLicensesTask.groovy, +        if (dependencies.isEmpty()) {, +            if (licensesDir.exists()) {, +            return // no dependencies to check, +        } else if (licensesDir.exists() == false) {, +            throw new GradleException("Licences dir ${licensesDir} does not exist, but there are dependencies"), +        }, +, +++ b/buildSrc/src/main/resources/forbidden/all-signatures.txt, +@defaultMessage Avoid unchecked warnings by using Collections#empty(List|Map|Set) methods, +java.util.Collections#EMPTY_LIST, +java.util.Collections#EMPTY_MAP, +java.util.Collections#EMPTY_SET, +++ b/buildSrc/src/main/resources/forbidden/third-party-signatures.txt, +++ b/core/build.gradle, +++ b/buildSrc/src/main/groovy/org/elasticsearch/gradle/precommit/DependencyLicensesTask.groovy, +        if (dependencies.isEmpty()) {, +            if (licensesDir.exists()) {, +            return // no dependencies to check, +        } else if (licensesDir.exists() == false) {, +            throw new GradleException("Licences dir ${licensesDir} does not exist, but there are dependencies"), +        }, +, +++ b/buildSrc/src/main/resources/forbidden/all-signatures.txt, +@defaultMessage Avoid unchecked warnings by using Collections#empty(List|Map|Set) methods, +java.util.Collections#EMPTY_LIST, +java.util.Collections#EMPTY_MAP, +java.util.Collections#EMPTY_SET, +++ b/buildSrc/src/main/resources/forbidden/third-party-signatures.txt, +++ b/core/build.gradle, +++ b/core/src/main/java/org/elasticsearch/cluster/action/index/NodeMappingRefreshAction.java, +            logger.warn("can't send mapping refresh for [{}], no master known.", request.index());, +            metaDataMappingService.refreshMapping(request.index(), request.indexUUID());, +        public NodeMappingRefreshRequest(String index, String indexUUID, String nodeId) {, +++ b/buildSrc/src/main/groovy/org/elasticsearch/gradle/precommit/DependencyLicensesTask.groovy, +        if (dependencies.isEmpty()) {, +            if (licensesDir.exists()) {, +            return // no dependencies to check, +        } else if (licensesDir.exists() == false) {, +            throw new GradleException("Licences dir ${licensesDir} does not exist, but there are dependencies"), +        }, +, +++ b/buildSrc/src/main/resources/forbidden/all-signatures.txt, +@defaultMessage Avoid unchecked warnings by using Collections#empty(List|Map|Set) methods, +java.util.Collections#EMPTY_LIST, +java.util.Collections#EMPTY_MAP, +java.util.Collections#EMPTY_SET, +++ b/buildSrc/src/main/resources/forbidden/third-party-signatures.txt, +++ b/core/build.gradle, +++ b/core/src/main/java/org/elasticsearch/cluster/action/index/NodeMappingRefreshAction.java, +            logger.warn("can't send mapping refresh for [{}], no master known.", request.index());, +            metaDataMappingService.refreshMapping(request.index(), request.indexUUID());, +        public NodeMappingRefreshRequest(String index, String indexUUID, String nodeId) {, +++ b/core/src/main/java/org/elasticsearch/cluster/metadata/MetaData.java, +import org.elasticsearch.common.logging.support.LoggerMessageFormat;, +                    AliasOrIndex aliasOrIndex = aliasAndIndexLookup.get(aliasMetaData.getAlias());, +                    } else if (aliasOrIndex instanceof AliasOrIndex.Alias) {, +                        AliasOrIndex.Alias alias = (AliasOrIndex.Alias) aliasOrIndex;, +                        alias.addIndex(indexMetaData);, +                    } else if (aliasOrIndex instanceof AliasOrIndex.Index) {, +                        AliasOrIndex.Index index = (AliasOrIndex.Index) aliasOrIndex;, +                        throw new IllegalStateException("index and alias names need to be unique, but alias [" + aliasMetaData.getAlias() + "] and index [" + index.getIndex().getIndex() + "] have the same name");, +                        throw new IllegalStateException("unexpected alias [" + aliasMetaData.getAlias() + "][" + aliasOrIndex + "]");, +++ b/buildSrc/src/main/groovy/org/elasticsearch/gradle/precommit/DependencyLicensesTask.groovy, +        if (dependencies.isEmpty()) {]