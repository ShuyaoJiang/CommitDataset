[+++ b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ml/job/persistence/JobStorageDeletionTask.java, +import org.elasticsearch.action.admin.indices.delete.DeleteIndexRequest;, +import org.elasticsearch.action.search.SearchAction;, +import org.elasticsearch.action.search.SearchRequest;, +import org.elasticsearch.action.search.SearchResponse;, +import org.elasticsearch.index.query.QueryBuilders;, +import org.elasticsearch.search.builder.SearchSourceBuilder;, +        final ActionListener<AcknowledgedResponse> completionHandler = ActionListener.wrap(, +            response -> finishedHandler.accept(response.isAcknowledged()),, +            failureHandler);, +        // Step 7. If we did not drop the index and after DBQ state done, we delete the aliases, +                    if (bulkByScrollResponse == null) { // no action was taken by DBQ, assume Index was deleted, +                        completionHandler.onResponse(new AcknowledgedResponse(true));, +                    } else {, +                        deleteAliases(jobId, client, completionHandler);, +                    }, +        // Step 6. If we did not delete the index, we run a delete by query, +        ActionListener<Boolean> deleteByQueryExecutor = ActionListener.wrap(, +                    if (response) {, +                    } else { // We did not execute DBQ, no need to delete aliases or check the response, +                        dbqHandler.onResponse(null);, +                    }, +        // Step 5. If we have any hits, that means we are NOT the only job on this index, and should not delete it, +        // if we do not have any hits, we can drop the index and then skip the DBQ and alias deletion, +        ActionListener<SearchResponse> customIndexSearchHandler = ActionListener.wrap(, +            searchResponse -> {, +                if (searchResponse == null || searchResponse.getHits().totalHits > 0) {, +                    deleteByQueryExecutor.onResponse(true); // We need to run DBQ and alias deletion, +                } else {, +                    logger.info("Running DELETE Index on [" + indexName + "] for job [" + jobId + "]");, +                    DeleteIndexRequest request = new DeleteIndexRequest(indexName);, +                    request.indicesOptions(IndicesOptions.lenientExpandOpen());, +                    // If we have deleted the index, then we don't need to delete the aliases or run the DBQ, +                    executeAsyncWithOrigin(, +                        client.threadPool().getThreadContext(),, +                        ML_ORIGIN,, +                        request,, +                        ActionListener.<AcknowledgedResponse>wrap(, +                            response -> deleteByQueryExecutor.onResponse(false), // skip DBQ && Alias, +                            failureHandler),, +                        client.admin().indices()::delete);, +                }, +            },, +            failure -> {, +                if (failure.getClass() == IndexNotFoundException.class) { // assume the index is already deleted, +                    deleteByQueryExecutor.onResponse(false); // skip DBQ && Alias, +                } else {, +                    failureHandler.accept(failure);, +                }, +            }, +        );, +, +        // Step 4. Determine if we are on a shared index by looking at `.ml-anomalies-shared` or the custom index's aliases, +        ActionListener<Boolean> deleteCategorizerStateHandler = ActionListener.wrap(, +            response -> {, +                if (indexName.equals(AnomalyDetectorsIndexFields.RESULTS_INDEX_PREFIX +, +                    AnomalyDetectorsIndexFields.RESULTS_INDEX_DEFAULT)) {, +                    customIndexSearchHandler.onResponse(null); //don't bother searching the index any further, we are on the default shared, +                } else {, +                    SearchSourceBuilder source = new SearchSourceBuilder(), +                        .size(1), +                        .query(QueryBuilders.boolQuery().filter(, +                            QueryBuilders.boolQuery().mustNot(QueryBuilders.termQuery(Job.ID.getPreferredName(), jobId))));, +, +                    SearchRequest searchRequest = new SearchRequest(indexName);, +                    searchRequest.source(source);, +                    executeAsyncWithOrigin(client, ML_ORIGIN, SearchAction.INSTANCE, searchRequest, customIndexSearchHandler);, +                }, +            },, +            failureHandler, +        );, +, +    private void deleteAliases(String jobId, Client client, ActionListener<AcknowledgedResponse> finishedHandler) {, +                                finishedHandler.onResponse(new AcknowledgedResponse(true));, +                                ActionListener.<AcknowledgedResponse>wrap(, +                                    finishedHandler::onResponse,, +++ b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ml/job/persistence/JobStorageDeletionTask.java, +import org.elasticsearch.action.admin.indices.delete.DeleteIndexRequest;, +import org.elasticsearch.action.search.SearchAction;, +import org.elasticsearch.action.search.SearchRequest;, +import org.elasticsearch.action.search.SearchResponse;, +import org.elasticsearch.index.query.QueryBuilders;, +import org.elasticsearch.search.builder.SearchSourceBuilder;, +        final ActionListener<AcknowledgedResponse> completionHandler = ActionListener.wrap(, +            response -> finishedHandler.accept(response.isAcknowledged()),, +            failureHandler);, +        // Step 7. If we did not drop the index and after DBQ state done, we delete the aliases, +                    if (bulkByScrollResponse == null) { // no action was taken by DBQ, assume Index was deleted, +                        completionHandler.onResponse(new AcknowledgedResponse(true));, +                    } else {, +                        deleteAliases(jobId, client, completionHandler);, +                    }, +        // Step 6. If we did not delete the index, we run a delete by query, +        ActionListener<Boolean> deleteByQueryExecutor = ActionListener.wrap(, +                    if (response) {, +                    } else { // We did not execute DBQ, no need to delete aliases or check the response, +                        dbqHandler.onResponse(null);, +                    }, +        // Step 5. If we have any hits, that means we are NOT the only job on this index, and should not delete it, +        // if we do not have any hits, we can drop the index and then skip the DBQ and alias deletion]