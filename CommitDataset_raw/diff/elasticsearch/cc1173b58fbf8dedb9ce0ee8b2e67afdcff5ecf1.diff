[+++ b/src/main/java/org/elasticsearch/index/settings/IndexDynamicSettingsModule.java, +++ b/src/main/java/org/elasticsearch/index/settings/IndexDynamicSettingsModule.java, +++ b/src/main/java/org/elasticsearch/index/translog/Translog.java, +import org.elasticsearch.common.unit.ByteSizeValue;, +    static ByteSizeValue INACTIVE_SHARD_TRANSLOG_BUFFER = ByteSizeValue.parseBytesSizeValue("1kb");, +, +    void updateBuffer(ByteSizeValue bufferSize);, +, +++ b/src/main/java/org/elasticsearch/index/settings/IndexDynamicSettingsModule.java, +++ b/src/main/java/org/elasticsearch/index/translog/Translog.java, +import org.elasticsearch.common.unit.ByteSizeValue;, +    static ByteSizeValue INACTIVE_SHARD_TRANSLOG_BUFFER = ByteSizeValue.parseBytesSizeValue("1kb");, +, +    void updateBuffer(ByteSizeValue bufferSize);, +, +++ b/src/main/java/org/elasticsearch/index/translog/fs/BufferingFsTranslogFile.java, +, +    @Override, +    public void updateBufferSize(int bufferSize) {, +        rwl.writeLock().lock();, +        try {, +            if (this.buffer.length == bufferSize) {, +                return;, +            }, +            flushBuffer();, +            this.buffer = new byte[bufferSize];, +        } catch (IOException e) {, +            throw new TranslogException(shardId, "failed to flush", e);, +        } finally {, +            rwl.writeLock().unlock();, +        }, +    }, +++ b/src/main/java/org/elasticsearch/index/settings/IndexDynamicSettingsModule.java, +++ b/src/main/java/org/elasticsearch/index/translog/Translog.java, +import org.elasticsearch.common.unit.ByteSizeValue;, +    static ByteSizeValue INACTIVE_SHARD_TRANSLOG_BUFFER = ByteSizeValue.parseBytesSizeValue("1kb");, +, +    void updateBuffer(ByteSizeValue bufferSize);, +, +++ b/src/main/java/org/elasticsearch/index/translog/fs/BufferingFsTranslogFile.java, +, +    @Override, +    public void updateBufferSize(int bufferSize) {, +        rwl.writeLock().lock();, +        try {, +            if (this.buffer.length == bufferSize) {, +                return;, +            }, +            flushBuffer();, +            this.buffer = new byte[bufferSize];, +        } catch (IOException e) {, +            throw new TranslogException(shardId, "failed to flush", e);, +        } finally {, +            rwl.writeLock().unlock();, +        }, +    }, +++ b/src/main/java/org/elasticsearch/index/translog/fs/FsTranslog.java, +    private volatile int bufferSize;, +    private volatile int transientBufferSize;, +        this.bufferSize = (int) componentSettings.getAsBytesSize("buffer_size", ByteSizeValue.parseBytesSizeValue("64k")).bytes(); // Not really interesting, updated by IndexingMemoryController..., +    @Override, +    public void updateBuffer(ByteSizeValue bufferSize) {, +        this.bufferSize = bufferSize.bytesAsInt();, +        rwl.writeLock().lock();, +        try {, +            FsTranslogFile current1 = this.current;, +            if (current1 != null) {, +                current1.updateBufferSize(this.bufferSize);, +            }, +            current1 = this.trans;, +            if (current1 != null) {, +                current1.updateBufferSize(this.bufferSize);, +            }, +        } finally {, +            rwl.writeLock().unlock();, +        }, +    }, +, +++ b/src/main/java/org/elasticsearch/index/settings/IndexDynamicSettingsModule.java, +++ b/src/main/java/org/elasticsearch/index/translog/Translog.java, +import org.elasticsearch.common.unit.ByteSizeValue;, +    static ByteSizeValue INACTIVE_SHARD_TRANSLOG_BUFFER = ByteSizeValue.parseBytesSizeValue("1kb");, +, +    void updateBuffer(ByteSizeValue bufferSize);, +, +++ b/src/main/java/org/elasticsearch/index/translog/fs/BufferingFsTranslogFile.java, +, +    @Override, +    public void updateBufferSize(int bufferSize) {, +        rwl.writeLock().lock();, +        try {, +            if (this.buffer.length == bufferSize) {, +                return;, +            }, +            flushBuffer();, +            this.buffer = new byte[bufferSize];, +        } catch (IOException e) {, +            throw new TranslogException(shardId, "failed to flush", e);, +        } finally {, +            rwl.writeLock().unlock();]