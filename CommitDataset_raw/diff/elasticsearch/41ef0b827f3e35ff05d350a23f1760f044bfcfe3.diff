[+++ b/plugin/src/main/java/org/elasticsearch/xpack/ml/MachineLearningTemplateRegistry.java, +++ b/plugin/src/main/java/org/elasticsearch/xpack/ml/MachineLearningTemplateRegistry.java, +++ b/plugin/src/main/java/org/elasticsearch/xpack/ml/job/persistence/AnomalyDetectorsIndex.java, +     * The name of the alias pointing to the indices where the job's results are stored, +     * @return The read alias, +        // ".write" rather than simply "write" to avoid the danger of clashing, +        // with the read alias of a job whose name begins with "write-", +        return RESULTS_INDEX_PREFIX + ".write-" + jobId;, +++ b/plugin/src/main/java/org/elasticsearch/xpack/ml/MachineLearningTemplateRegistry.java, +++ b/plugin/src/main/java/org/elasticsearch/xpack/ml/job/persistence/AnomalyDetectorsIndex.java, +     * The name of the alias pointing to the indices where the job's results are stored, +     * @return The read alias, +        // ".write" rather than simply "write" to avoid the danger of clashing, +        // with the read alias of a job whose name begins with "write-", +        return RESULTS_INDEX_PREFIX + ".write-" + jobId;, +++ b/plugin/src/main/java/org/elasticsearch/xpack/ml/job/persistence/JobProvider.java, +        String readAliasName = AnomalyDetectorsIndex.jobResultsAliasedName(job.getId());, +        String writeAliasName = AnomalyDetectorsIndex.resultsWriteAlias(job.getId());, +                            .addAlias(indexName, readAliasName, QueryBuilders.termQuery(Job.ID.getPreferredName(), job.getId())), +                            .addAlias(indexName, writeAliasName), +                            .execute(ActionListener.wrap(r -> finalListener.onResponse(true), finalListener::onFailure));, +++ b/plugin/src/main/java/org/elasticsearch/xpack/ml/MachineLearningTemplateRegistry.java, +++ b/plugin/src/main/java/org/elasticsearch/xpack/ml/job/persistence/AnomalyDetectorsIndex.java, +     * The name of the alias pointing to the indices where the job's results are stored, +     * @return The read alias, +        // ".write" rather than simply "write" to avoid the danger of clashing, +        // with the read alias of a job whose name begins with "write-", +        return RESULTS_INDEX_PREFIX + ".write-" + jobId;, +++ b/plugin/src/main/java/org/elasticsearch/xpack/ml/job/persistence/JobProvider.java, +        String readAliasName = AnomalyDetectorsIndex.jobResultsAliasedName(job.getId());, +        String writeAliasName = AnomalyDetectorsIndex.resultsWriteAlias(job.getId());, +                            .addAlias(indexName, readAliasName, QueryBuilders.termQuery(Job.ID.getPreferredName(), job.getId())), +                            .addAlias(indexName, writeAliasName), +                            .execute(ActionListener.wrap(r -> finalListener.onResponse(true), finalListener::onFailure));, +++ b/plugin/src/main/java/org/elasticsearch/xpack/ml/job/persistence/JobStorageDeletionTask.java, +        // Step 5. DBQ state done, delete the aliases, +                    deleteAliases(jobId, client, deleteAliasHandler);, +    private void deleteAliases(String jobId, Client client, ActionListener<Boolean> finishedHandler) {, +        final String readAliasName = AnomalyDetectorsIndex.jobResultsAliasedName(jobId);, +        final String writeAliasName = AnomalyDetectorsIndex.resultsWriteAlias(jobId);, +        final String indexPattern = AnomalyDetectorsIndex.jobResultsIndexPrefix() + "*";, +, +        IndicesAliasesRequest request = new IndicesAliasesRequest().addAliasAction(, +                IndicesAliasesRequest.AliasActions.remove().aliases(readAliasName, writeAliasName).indices(indexPattern));, +                    if (e instanceof AliasesNotFoundException) {, +                        logger.warn("[{}] Aliases {} not found. Continuing to delete job.", jobId,, +                                ((AliasesNotFoundException) e).getResourceId());, +                        finishedHandler.onResponse(true);, +                    } else if (e instanceof IndexNotFoundException) {, +                        logger.warn("[{}] Index [{}] referenced by alias not found. Continuing to delete job.", jobId,, +                                ((IndexNotFoundException) e).getIndex().getName());, +                        logger.error("[" + jobId + "] Failed to delete aliases [" + readAliasName + ", " + writeAliasName + "].", e);, +++ b/plugin/src/main/java/org/elasticsearch/xpack/ml/MachineLearningTemplateRegistry.java, +++ b/plugin/src/main/java/org/elasticsearch/xpack/ml/job/persistence/AnomalyDetectorsIndex.java, +     * The name of the alias pointing to the indices where the job's results are stored, +     * @return The read alias, +        // ".write" rather than simply "write" to avoid the danger of clashing, +        // with the read alias of a job whose name begins with "write-", +        return RESULTS_INDEX_PREFIX + ".write-" + jobId;, +++ b/plugin/src/main/java/org/elasticsearch/xpack/ml/job/persistence/JobProvider.java, +        String readAliasName = AnomalyDetectorsIndex.jobResultsAliasedName(job.getId());, +        String writeAliasName = AnomalyDetectorsIndex.resultsWriteAlias(job.getId());, +                            .addAlias(indexName, readAliasName, QueryBuilders.termQuery(Job.ID.getPreferredName(), job.getId())), +                            .addAlias(indexName, writeAliasName), +                            .execute(ActionListener.wrap(r -> finalListener.onResponse(true), finalListener::onFailure));, +++ b/plugin/src/main/java/org/elasticsearch/xpack/ml/job/persistence/JobStorageDeletionTask.java, +        // Step 5. DBQ state done, delete the aliases, +                    deleteAliases(jobId, client, deleteAliasHandler);, +    private void deleteAliases(String jobId, Client client, ActionListener<Boolean> finishedHandler) {, +        final String readAliasName = AnomalyDetectorsIndex.jobResultsAliasedName(jobId);, +        final String writeAliasName = AnomalyDetectorsIndex.resultsWriteAlias(jobId);, +        final String indexPattern = AnomalyDetectorsIndex.jobResultsIndexPrefix() + "*";, +, +        IndicesAliasesRequest request = new IndicesAliasesRequest().addAliasAction(, +                IndicesAliasesRequest.AliasActions.remove().aliases(readAliasName, writeAliasName).indices(indexPattern));, +                    if (e instanceof AliasesNotFoundException) {, +                        logger.warn("[{}] Aliases {} not found. Continuing to delete job.", jobId,, +                                ((AliasesNotFoundException) e).getResourceId());, +                        finishedHandler.onResponse(true);, +                    } else if (e instanceof IndexNotFoundException) {, +                        logger.warn("[{}] Index [{}] referenced by alias not found. Continuing to delete job.", jobId,, +                                ((IndexNotFoundException) e).getIndex().getName());, +                        logger.error("[" + jobId + "] Failed to delete aliases [" + readAliasName + ", " + writeAliasName + "].", e);, +++ b/plugin/src/test/java/org/elasticsearch/xpack/ml/integration/AutodetectResultProcessorIT.java, +import org.elasticsearch.xpack.ml.action.DeleteJobAction;, +import org.elasticsearch.xpack.ml.action.PutJobAction;, +import org.elasticsearch.xpack.ml.job.config.AnalysisConfig;, +import org.elasticsearch.xpack.ml.job.config.DataDescription;, +import org.elasticsearch.xpack.ml.job.config.Detector;, +import org.elasticsearch.xpack.ml.job.config.Job;, +import org.junit.After;, +    public void createComponents() throws Exception {, +        putIndexTemplates();, +        putJob();, +    }, +, +    @After, +    public void deleteJob() throws Exception {, +        DeleteJobAction.Request request = new DeleteJobAction.Request(JOB_ID);, +        DeleteJobAction.Response response = client().execute(DeleteJobAction.INSTANCE, request).actionGet();]