[+++ b/modules/lang-painless/src/main/antlr/PainlessParser.g4, +    | ID REF ID, +++ b/modules/lang-painless/src/main/antlr/PainlessParser.g4, +    | ID REF ID, +++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/Def.java, +     * @param lookup caller's lookup, +     * @param callSiteType callsite's type, +     static MethodHandle lookupMethod(Lookup lookup, MethodType callSiteType, , +             Class<?> receiverClass, String name, Object args[], long recipe) throws LambdaConversionException {, +         // simple case: no lambdas, +         if (recipe == 0) {, +             return lookupMethodInternal(receiverClass, name, args.length - 1).handle;, +         }, +         , +         // otherwise: first we have to compute the "real" arity. This is because we have extra arguments:, +         // e.g. f(a, g(x), b, h(y), i()) looks like f(a, g, x, b, h, y, i). , +         int arity = args.length - 1;, +         for (int i = 0; i < args.length; i++) {, +             if ((recipe & (1L << (i - 1))) != 0) {, +                 String signature = (String) args[i];, +                 int numCaptures = Integer.parseInt(signature.substring(signature.indexOf(',')+1));, +                 arity -= numCaptures;, +             }, +         }, +         , +         // lookup the method with the proper arity, then we know everything (e.g. interface types of parameters)., +         // based on these we can finally link any remaining lambdas that were deferred., +         Method method = lookupMethodInternal(receiverClass, name, arity);, +         int replaced = 0;, +         for (int i = 1; i < args.length; i++) {, +                 // decode signature of form 'type.call,2' , +                 String signature = (String) args[i];, +                 int separator = signature.indexOf('.');, +                 int separator2 = signature.indexOf(',');, +                 String type = signature.substring(1, separator);, +                 String call = signature.substring(separator+1, separator2);, +                 int numCaptures = Integer.parseInt(signature.substring(separator2+1));, +                 Class<?> captures[] = new Class<?>[numCaptures];, +                 for (int capture = 0; capture < captures.length; capture++) {, +                     captures[capture] = callSiteType.parameterType(i + 1 + capture);, +                 MethodHandle filter;, +                 Definition.Type interfaceType = method.arguments.get(i - 1 - replaced);, +                 if (signature.charAt(0) == 'S') {, +                     // the implementation is strongly typed, now that we know the interface type,, +                     // we have everything., +                     filter = lookupReferenceInternal(lookup,, +                                                      interfaceType,, +                                                      type,, +                                                      call,, +                                                      captures);, +                 } else if (signature.charAt(0) == 'D') {, +                     // the interface type is now known, but we need to get the implementation., +                     // this is dynamically based on the receiver type (and cached separately, underneath, +                     // this cache). It won't blow up since we never nest here (just references), +                     MethodType nestedType = MethodType.methodType(interfaceType.clazz, captures);, +                     CallSite nested = DefBootstrap.bootstrap(lookup, , +                                                              call,, +                                                              nestedType, , +                                                              DefBootstrap.REFERENCE,, +                                                              interfaceType.name);, +                     filter = nested.dynamicInvoker();, +                 } else {, +                     throw new AssertionError();, +                 // the filter now ignores the signature (placeholder) on the stack, +                 filter = MethodHandles.dropArguments(filter, 0, String.class);, +                 handle = MethodHandles.collectArguments(handle, i, filter);, +                 i += numCaptures;, +                 replaced += numCaptures;, +             }, +     /**, +      * Returns an implementation of interfaceClass that calls receiverClass.name, +      * <p>, +      * This is just like LambdaMetaFactory, only with a dynamic type. The interface type is known,, +      * so we simply need to lookup the matching implementation method based on receiver type., +      */, +     static MethodHandle lookupReference(Lookup lookup, String interfaceClass, , +                                         Class<?> receiverClass, String name) throws LambdaConversionException {, +         Definition.Type interfaceType = Definition.getType(interfaceClass);, +         Method interfaceMethod = interfaceType.struct.getFunctionalMethod();, +         if (interfaceMethod == null) {, +             throw new IllegalArgumentException("Class [" + interfaceClass + "] is not a functional interface");, +         }, +         int arity = interfaceMethod.arguments.size();, +         Method implMethod = lookupMethodInternal(receiverClass, name, arity);, +         return lookupReferenceInternal(lookup, interfaceType, implMethod.owner.name, implMethod.name, receiverClass);, +     }, +     , +     private static MethodHandle lookupReferenceInternal(Lookup lookup, Definition.Type clazz, String type,, +                                                         String call, Class<?>... captures) throws LambdaConversionException {, +         FunctionRef ref = new FunctionRef(clazz, type, call, captures);, +         return callSite.dynamicInvoker().asType(MethodType.methodType(clazz.clazz, captures));, +++ b/modules/lang-painless/src/main/antlr/PainlessParser.g4, +    | ID REF ID, +++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/Def.java, +     * @param lookup caller's lookup, +     * @param callSiteType callsite's type, +     static MethodHandle lookupMethod(Lookup lookup, MethodType callSiteType, , +             Class<?> receiverClass, String name, Object args[], long recipe) throws LambdaConversionException {, +         // simple case: no lambdas, +         if (recipe == 0) {]