[+++ b/src/main/java/org/elasticsearch/action/admin/cluster/health/TransportClusterHealthAction.java, +import org.elasticsearch.ElasticsearchIllegalStateException;, +import org.elasticsearch.cluster.*;, +import org.elasticsearch.common.unit.TimeValue;, +        // this should be executing quickly no need to fork off, +        return ThreadPool.Names.SAME;, +            final long endTime = System.currentTimeMillis() + request.timeout().millis();, +                    final long timeoutInMillis = Math.max(0, endTime - System.currentTimeMillis());, +                    final TimeValue newTimeout = TimeValue.timeValueMillis(timeoutInMillis);, +                    request.timeout(newTimeout);, +                    executeHealth(request, listener);, +                    listener.onFailure(t);, +        } else {, +            executeHealth(request, listener);, +    }, +    private void executeHealth(final ClusterHealthRequest request, final ActionListener<ClusterHealthResponse> listener) {, +, +        assert waitFor >= 0;, +        final ClusterStateObserver observer = new ClusterStateObserver(clusterService, logger);, +        final ClusterState state = observer.observedState();, +        if (waitFor == 0 || request.timeout().millis() == 0) {, +            // we check for a timeout here since this method might be called from the wait_for_events, +            // response handler which might have timed out already., +            ClusterHealthResponse response = clusterHealth(request, state);, +            response.timedOut = request.timeout().millis() == 0;, +            listener.onResponse(response);, +        final int concreteWaitFor = waitFor;, +        final ClusterStateObserver.ChangePredicate validationPredicate = new ClusterStateObserver.ValidationPredicate() {, +            @Override, +            protected boolean validate(ClusterState newState) {, +                return newState.status() == ClusterState.ClusterStateStatus.APPLIED && validateRequest(request, newState, concreteWaitFor);, +            }, +        };, +, +        final ClusterStateObserver.Listener stateListener = new ClusterStateObserver.Listener() {, +            @Override, +            public void onNewClusterState(ClusterState clusterState) {, +                listener.onResponse(getResponse(request, clusterState, concreteWaitFor, false));, +            }, +, +            @Override, +            public void onClusterServiceClose() {, +                listener.onFailure(new ElasticsearchIllegalStateException("ClusterService was close during health call"));, +            }, +, +            @Override, +            public void onTimeout(TimeValue timeout) {, +                final ClusterState clusterState = clusterService.state();, +                final ClusterHealthResponse response = getResponse(request, clusterState, concreteWaitFor, true);, +                listener.onResponse(response);, +            }, +        };, +        if (state.status() == ClusterState.ClusterStateStatus.APPLIED && validateRequest(request, state, concreteWaitFor)) {, +            stateListener.onNewClusterState(state);, +        } else {, +            observer.waitForNextChange(stateListener, validationPredicate, request.timeout());, +        }, +    }, +, +    private boolean validateRequest(final ClusterHealthRequest request, ClusterState clusterState, final int waitFor) {, +        return prepareResponse(request, response, clusterState, waitFor);, +    }, +, +    private ClusterHealthResponse getResponse(final ClusterHealthRequest request, ClusterState clusterState, final int waitFor, boolean timedOut) {, +        ClusterHealthResponse response = clusterHealth(request, clusterState);, +        boolean valid = prepareResponse(request, response, clusterState, waitFor);, +        assert valid || timedOut;, +        response.timedOut = timedOut;, +        return response;, +    }, +, +    private boolean prepareResponse(final ClusterHealthRequest request, final ClusterHealthResponse response, ClusterState clusterState, final int waitFor) {, +        int waitForCounter = 0;, +        return waitForCounter == waitFor;, +++ b/src/main/java/org/elasticsearch/action/admin/cluster/health/TransportClusterHealthAction.java, +import org.elasticsearch.ElasticsearchIllegalStateException;, +import org.elasticsearch.cluster.*;, +import org.elasticsearch.common.unit.TimeValue;, +        // this should be executing quickly no need to fork off, +        return ThreadPool.Names.SAME;, +            final long endTime = System.currentTimeMillis() + request.timeout().millis();, +                    final long timeoutInMillis = Math.max(0, endTime - System.currentTimeMillis());, +                    final TimeValue newTimeout = TimeValue.timeValueMillis(timeoutInMillis);, +                    request.timeout(newTimeout);, +                    executeHealth(request, listener);, +                    listener.onFailure(t);, +        } else {, +            executeHealth(request, listener);, +    }, +    private void executeHealth(final ClusterHealthRequest request, final ActionListener<ClusterHealthResponse> listener) {, +, +        assert waitFor >= 0;, +        final ClusterStateObserver observer = new ClusterStateObserver(clusterService, logger);, +        final ClusterState state = observer.observedState();, +        if (waitFor == 0 || request.timeout().millis() == 0) {, +            // we check for a timeout here since this method might be called from the wait_for_events, +            // response handler which might have timed out already., +            ClusterHealthResponse response = clusterHealth(request, state);, +            response.timedOut = request.timeout().millis() == 0;, +            listener.onResponse(response);]