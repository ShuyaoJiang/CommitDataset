[+++ b/docs/reference/modules/scripting/painless.asciidoc, +++ b/docs/reference/modules/scripting/painless.asciidoc, +++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/AnalyzerUtility.java, +        this.definition = metadata.definition;, +++ b/docs/reference/modules/scripting/painless.asciidoc, +++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/AnalyzerUtility.java, +        this.definition = metadata.definition;, +++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/Compiler.java, +    static Executable compile(final Loader loader, final String name, final String source, final CompilerSettings settings) {, +        final Definition definition = Definition.INSTANCE;, +++ b/docs/reference/modules/scripting/painless.asciidoc, +++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/AnalyzerUtility.java, +        this.definition = metadata.definition;, +++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/Compiler.java, +    static Executable compile(final Loader loader, final String name, final String source, final CompilerSettings settings) {, +        final Definition definition = Definition.INSTANCE;, +++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/Def.java, +import org.elasticsearch.painless.Definition.RuntimeClass;, +import java.lang.invoke.MethodHandles;, +import java.lang.invoke.MethodType;, +import java.lang.invoke.MethodHandles.Lookup;, +/**, + * Support for dynamic type (def)., + * <p>, + * Dynamic types can invoke methods, load/store fields, and be passed as parameters to operators without , + * compile-time type information. , + * <p>, + * Dynamic methods, loads, and stores involve locating the appropriate field or method depending, + * on the receiver's class. For these, we emit an {@code invokedynamic} instruction that, for each new , + * type encountered will query a corresponding {@code lookupXXX} method to retrieve the appropriate method., + * In most cases, the {@code lookupXXX} methods here will only be called once for a given call site, because , + * caching ({@link DynamicCallSite}) generally works: usually all objects at any call site will be consistently , + * the same type (or just a few types).  In extreme cases, if there is type explosion, they may be called every , + * single time, but simplicity is still more valuable than performance in this code., + * <p>, + * Dynamic array loads and stores and operator functions (e.g. {@code +}) are called directly, + * with {@code invokestatic}. Because these features cannot be overloaded in painless, they are hardcoded , + * decision trees based on the only types that are possible. This keeps overhead low, and seems to be as fast, + * on average as the more adaptive methodhandle caching. , + */, +    /** , +     * Looks up handle for a dynamic method call., +     * <p>, +     * A dynamic method call for variable {@code x} of type {@code def} looks like:, +     * {@code x.method(args...)}, +     * <p>, +     * This method traverses {@code recieverClass}'s class hierarchy (including interfaces) , +     * until it finds a matching whitelisted method. If one is not found, it throws an exception. , +     * Otherwise it returns a handle to the matching method., +     * <p>, +     * @param receiverClass Class of the object to invoke the method on., +     * @param name Name of the method., +     * @param definition Whitelist to check., +     * @return pointer to matching method to invoke. never returns null., +     * @throws IllegalArgumentException if no matching whitelisted method was found., +     */, +    static MethodHandle lookupMethod(Class<?> receiverClass, String name, Definition definition) {, +        // check whitelist for matching method, +        for (Class<?> clazz = receiverClass; clazz != null; clazz = clazz.getSuperclass()) {, +            RuntimeClass struct = definition.runtimeMap.get(clazz);, +, +            if (struct != null) {, +                Method method = struct.methods.get(name);, +                if (method != null) {, +                    return method.handle;, +                }, +            }, +, +            for (Class<?> iface : clazz.getInterfaces()) {, +                struct = definition.runtimeMap.get(iface);, +, +                if (struct != null) {, +                    Method method = struct.methods.get(name);, +                    if (method != null) {, +                        return method.handle;, +                    }, +                }, +            }, +        }, +, +        // no matching methods in whitelist found, +                                           "for class [" + receiverClass.getCanonicalName() + "].");, +    /** pointer to Array.getLength(Object) */, +    private static final MethodHandle ARRAY_LENGTH;, +    /** pointer to Map.get(Object) */, +    private static final MethodHandle MAP_GET;, +    /** pointer to Map.put(Object,Object) */, +    private static final MethodHandle MAP_PUT;, +    /** pointer to List.get(int) */, +    private static final MethodHandle LIST_GET;, +    /** pointer to List.set(int,Object) */, +    private static final MethodHandle LIST_SET;, +    static {, +        Lookup lookup = MethodHandles.publicLookup();, +            // TODO: maybe specialize handles for different array types. this may be slower, but simple :), +            ARRAY_LENGTH = lookup.findStatic(Array.class, "getLength",, +                                             MethodType.methodType(int.class, Object.class));, +            MAP_GET      = lookup.findVirtual(Map.class, "get",, +                                             MethodType.methodType(Object.class, Object.class));, +            MAP_PUT      = lookup.findVirtual(Map.class, "put",]