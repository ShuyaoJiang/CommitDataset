[+++ b/server/src/main/java/org/elasticsearch/common/joda/Joda.java, +++ b/server/src/main/java/org/elasticsearch/common/joda/Joda.java, +++ b/server/src/main/java/org/elasticsearch/common/joda/JodaDateFormatter.java, +        final DateTime dt = parser.parseDateTime(input);, +++ b/server/src/main/java/org/elasticsearch/common/joda/Joda.java, +++ b/server/src/main/java/org/elasticsearch/common/joda/JodaDateFormatter.java, +        final DateTime dt = parser.parseDateTime(input);, +++ b/server/src/main/java/org/elasticsearch/common/time/DateFormatter.java, +import org.elasticsearch.common.Strings;, +import org.elasticsearch.common.joda.Joda;, +import java.time.ZoneOffset;, +import java.util.ArrayList;, +import java.util.List;, +        return format(ZonedDateTime.ofInstant(Instant.ofEpochMilli(millis), ZoneOffset.UTC));, +    static DateFormatter forPattern(String input) {, +        return forPattern(input, Locale.ROOT);, +    static DateFormatter forPattern(String input, Locale locale) {, +        if (Strings.hasLength(input) == false) {, +            throw new IllegalArgumentException("No date pattern provided");, +        }, +        List<DateFormatter> formatters = new ArrayList<>();, +        for (String pattern : Strings.delimitedListToStringArray(input, "||")) {, +            formatters.add(Joda.forPattern(pattern, locale));, +        if (formatters.size() == 1) {, +            return formatters.get(0);, +        return new DateFormatters.MergedDateFormatter(input, formatters);, +++ b/server/src/main/java/org/elasticsearch/common/joda/Joda.java, +++ b/server/src/main/java/org/elasticsearch/common/joda/JodaDateFormatter.java, +        final DateTime dt = parser.parseDateTime(input);, +++ b/server/src/main/java/org/elasticsearch/common/time/DateFormatter.java, +import org.elasticsearch.common.Strings;, +import org.elasticsearch.common.joda.Joda;, +import java.time.ZoneOffset;, +import java.util.ArrayList;, +import java.util.List;, +        return format(ZonedDateTime.ofInstant(Instant.ofEpochMilli(millis), ZoneOffset.UTC));, +    static DateFormatter forPattern(String input) {, +        return forPattern(input, Locale.ROOT);, +    static DateFormatter forPattern(String input, Locale locale) {, +        if (Strings.hasLength(input) == false) {, +            throw new IllegalArgumentException("No date pattern provided");, +        }, +        List<DateFormatter> formatters = new ArrayList<>();, +        for (String pattern : Strings.delimitedListToStringArray(input, "||")) {, +            formatters.add(Joda.forPattern(pattern, locale));, +        if (formatters.size() == 1) {, +            return formatters.get(0);, +        return new DateFormatters.MergedDateFormatter(input, formatters);, +++ b/server/src/main/java/org/elasticsearch/common/time/DateFormatters.java, +import org.elasticsearch.ElasticsearchParseException;, +import java.time.ZoneId;, +import java.time.format.DateTimeParseException;, +import java.util.ArrayList;, +import java.util.Collections;, +import java.util.List;, +import java.util.stream.Collectors;, +                    List<DateFormatter> formatters = new ArrayList<>(formats.length);, +                        formatters.add(forPattern(formats[i], locale));, +                    return new MergedDateFormatter(input, formatters);, +    static class MergedDateFormatter implements DateFormatter {, +, +        private final String pattern;, +        private final List<DateFormatter> formatters;, +        private final List<DateMathParser> dateMathParsers;, +, +        MergedDateFormatter(String pattern, List<DateFormatter> formatters) {, +            assert formatters.size() > 0;, +            this.pattern = pattern;, +            this.formatters = Collections.unmodifiableList(formatters);, +            this.dateMathParsers = formatters.stream().map(DateFormatter::toDateMathParser).collect(Collectors.toList());, +        }, +, +        @Override, +        public TemporalAccessor parse(String input) {, +            IllegalArgumentException failure = null;, +            for (DateFormatter formatter : formatters) {, +                try {, +                    return formatter.parse(input);, +                    // TODO: remove DateTimeParseException when JavaDateFormatter throws IAE, +                } catch (IllegalArgumentException | DateTimeParseException e) {, +                    if (failure == null) {, +                        // wrap so the entire multi format is in the message, +                        failure = new IllegalArgumentException("failed to parse date field [" + input + "] with format [" + pattern + "]",, +                            e);, +                    } else {, +                        failure.addSuppressed(e);, +                    }, +                }, +            }, +            throw failure;, +        }, +, +        @Override, +        public DateFormatter withZone(ZoneId zoneId) {, +            return new MergedDateFormatter(pattern, formatters.stream().map(f -> f.withZone(zoneId)).collect(Collectors.toList()));, +        }, +, +        @Override, +        public DateFormatter withLocale(Locale locale) {, +            return new MergedDateFormatter(pattern, formatters.stream().map(f -> f.withLocale(locale)).collect(Collectors.toList()));]