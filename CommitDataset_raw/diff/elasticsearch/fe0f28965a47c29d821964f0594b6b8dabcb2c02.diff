[+++ b/buildSrc/src/main/resources/checkstyle_suppressions.xml, +++ b/buildSrc/src/main/resources/checkstyle_suppressions.xml, +++ b/core/src/main/java/org/elasticsearch/search/SearchModule.java, +        registerAggregation(, +                new AggregationSpec(TermsAggregationBuilder::new, new TermsParser(), TermsAggregationBuilder.AGGREGATION_NAME_FIELD), +                    .addResultReader(StringTerms.NAME, StringTerms::new), +                    .addResultReader(UnmappedTerms.NAME, UnmappedTerms::new), +                    .addResultReader(LongTerms.NAME, LongTerms::new), +                    .addResultReader(DoubleTerms.NAME, DoubleTerms::new));, +++ b/buildSrc/src/main/resources/checkstyle_suppressions.xml, +++ b/core/src/main/java/org/elasticsearch/search/SearchModule.java, +        registerAggregation(, +                new AggregationSpec(TermsAggregationBuilder::new, new TermsParser(), TermsAggregationBuilder.AGGREGATION_NAME_FIELD), +                    .addResultReader(StringTerms.NAME, StringTerms::new), +                    .addResultReader(UnmappedTerms.NAME, UnmappedTerms::new), +                    .addResultReader(LongTerms.NAME, LongTerms::new), +                    .addResultReader(DoubleTerms.NAME, DoubleTerms::new));, +++ b/core/src/main/java/org/elasticsearch/search/aggregations/InternalAggregation.java, +     * Reduces the given aggregations to a single one and returns it. In <b>most</b> cases, the assumption will be the all given, +     * aggregations are of the same type (the same type as this aggregation). For best efficiency, when implementing,, +     * try reusing an existing instance (typically the first in the given list) to save on redundant object, +++ b/buildSrc/src/main/resources/checkstyle_suppressions.xml, +++ b/core/src/main/java/org/elasticsearch/search/SearchModule.java, +        registerAggregation(, +                new AggregationSpec(TermsAggregationBuilder::new, new TermsParser(), TermsAggregationBuilder.AGGREGATION_NAME_FIELD), +                    .addResultReader(StringTerms.NAME, StringTerms::new), +                    .addResultReader(UnmappedTerms.NAME, UnmappedTerms::new), +                    .addResultReader(LongTerms.NAME, LongTerms::new), +                    .addResultReader(DoubleTerms.NAME, DoubleTerms::new));, +++ b/core/src/main/java/org/elasticsearch/search/aggregations/InternalAggregation.java, +     * Reduces the given aggregations to a single one and returns it. In <b>most</b> cases, the assumption will be the all given, +     * aggregations are of the same type (the same type as this aggregation). For best efficiency, when implementing,, +     * try reusing an existing instance (typically the first in the given list) to save on redundant object, +++ b/core/src/main/java/org/elasticsearch/search/aggregations/bucket/terms/AbstractStringTermsAggregator.java, +import static java.util.Collections.emptyList;, +, +        return new StringTerms(name, order, bucketCountThresholds.getRequiredSize(), bucketCountThresholds.getMinDocCount(),, +                pipelineAggregators(), metaData(), format, bucketCountThresholds.getShardSize(), showTermDocCountError, 0, emptyList(), 0);, +++ b/buildSrc/src/main/resources/checkstyle_suppressions.xml, +++ b/core/src/main/java/org/elasticsearch/search/SearchModule.java, +        registerAggregation(, +                new AggregationSpec(TermsAggregationBuilder::new, new TermsParser(), TermsAggregationBuilder.AGGREGATION_NAME_FIELD), +                    .addResultReader(StringTerms.NAME, StringTerms::new), +                    .addResultReader(UnmappedTerms.NAME, UnmappedTerms::new), +                    .addResultReader(LongTerms.NAME, LongTerms::new), +                    .addResultReader(DoubleTerms.NAME, DoubleTerms::new));, +++ b/core/src/main/java/org/elasticsearch/search/aggregations/InternalAggregation.java, +     * Reduces the given aggregations to a single one and returns it. In <b>most</b> cases, the assumption will be the all given, +     * aggregations are of the same type (the same type as this aggregation). For best efficiency, when implementing,, +     * try reusing an existing instance (typically the first in the given list) to save on redundant object, +++ b/core/src/main/java/org/elasticsearch/search/aggregations/bucket/terms/AbstractStringTermsAggregator.java, +import static java.util.Collections.emptyList;, +, +        return new StringTerms(name, order, bucketCountThresholds.getRequiredSize(), bucketCountThresholds.getMinDocCount(),, +                pipelineAggregators(), metaData(), format, bucketCountThresholds.getShardSize(), showTermDocCountError, 0, emptyList(), 0);, +++ b/core/src/main/java/org/elasticsearch/search/aggregations/bucket/terms/DoubleTerms.java, + * Result of the {@link TermsAggregator} when the field is some kind of decimal number like a float, double, or distance., +public class DoubleTerms extends InternalMappedTerms<DoubleTerms, DoubleTerms.Bucket> {, +    public static final String NAME = "dterms";, +    static class Bucket extends InternalTerms.Bucket<Bucket> {, +        private final double term;, +        /**, +         * Read from a stream., +         */, +        public Bucket(StreamInput in, DocValueFormat format, boolean showDocCountError) throws IOException {, +            super(in, format, showDocCountError);, +            term = in.readDouble();, +        }, +, +        @Override, +        protected void writeTermTo(StreamOutput out) throws IOException {, +            out.writeDouble(term);, +        }, +, +            return format.format(term);, +    public DoubleTerms(String name, Terms.Order order, int requiredSize, long minDocCount, List<PipelineAggregator> pipelineAggregators,, +            Map<String, Object> metaData, DocValueFormat format, int shardSize, boolean showTermDocCountError, long otherDocCount,, +            List<Bucket> buckets, long docCountError) {, +        super(name, order, requiredSize, minDocCount, pipelineAggregators, metaData, format, shardSize, showTermDocCountError,, +                otherDocCount, buckets, docCountError);, +    }, +    /**, +     * Read from a stream., +     */, +    public DoubleTerms(StreamInput in) throws IOException {, +        super(in, Bucket::new);, +    public String getWriteableName() {, +        return NAME;, +        return new DoubleTerms(name, order, requiredSize, minDocCount, this.pipelineAggregators(), metaData, format, shardSize,, +                showTermDocCountError, otherDocCount, buckets, docCountError);, +    protected DoubleTerms create(String name, List<Bucket> buckets, long docCountError, long otherDocCount) {, +        return new DoubleTerms(name, order, requiredSize, minDocCount, pipelineAggregators(), getMetaData(), format,, +                shardSize, showTermDocCountError, otherDocCount, buckets, docCountError);, +        for (Bucket bucket : buckets) {, +    @Override, +    protected Bucket[] createBucketsArray(int size) {, +        return new Bucket[size];, +    }, +++ b/buildSrc/src/main/resources/checkstyle_suppressions.xml, +++ b/core/src/main/java/org/elasticsearch/search/SearchModule.java]