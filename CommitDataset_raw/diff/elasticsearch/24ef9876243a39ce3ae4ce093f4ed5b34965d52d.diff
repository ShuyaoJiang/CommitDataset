[+++ b/src/main/java/org/elasticsearch/index/cache/id/IdCache.java, +import org.apache.lucene.index.AtomicReaderContext;, +import java.util.List;, +, +    void refresh(List<AtomicReaderContext> readers) throws Exception;, +++ b/src/main/java/org/elasticsearch/index/cache/id/IdCache.java, +import org.apache.lucene.index.AtomicReaderContext;, +import java.util.List;, +, +    void refresh(List<AtomicReaderContext> readers) throws Exception;, +++ b/src/main/java/org/elasticsearch/index/cache/id/simple/SimpleIdCache.java, +import org.apache.lucene.util.BytesRef;, +import org.elasticsearch.ElasticSearchIllegalArgumentException;, +import org.elasticsearch.common.bytes.BytesReference;, +import java.util.*;, +    public void refresh(List<AtomicReaderContext> atomicReaderContexts) throws Exception {, +        if (refreshNeeded(atomicReaderContexts)) {, +                if (!refreshNeeded(atomicReaderContexts)) {, +                Map<Object, Map<BytesReference, TypeBuilder>> builders = new HashMap<Object, Map<BytesReference, TypeBuilder>>();, +                for (AtomicReaderContext context : atomicReaderContexts) {, +                    AtomicReader reader = context.reader();, +                    Map<BytesReference, TypeBuilder> readerBuilder = new HashMap<BytesReference, TypeBuilder>();, +                    Terms terms = reader.terms(UidFieldMapper.NAME);, +                    if (terms == null) { // Should not happen, +                        throw new ElasticSearchIllegalArgumentException("Id cache needs _uid field");, +                    }, +, +                    TermsEnum termsEnum = terms.iterator(null);, +                    DocsEnum docsEnum = null;, +                    for (BytesRef term = termsEnum.next(); term != null; term = termsEnum.term()) {, +                        HashedBytesArray[] typeAndId = splitUidIntoTypeAndId(term);, +                        TypeBuilder typeBuilder = readerBuilder.get(typeAndId[0]);, +                            readerBuilder.put(typeAndId[0], typeBuilder);, +                        HashedBytesArray idAsBytes = checkIfCanReuse(builders, typeAndId[1]);, +                        docsEnum = termsEnum.docs(reader.getLiveDocs(), docsEnum, 0);, +                        for (int docId = docsEnum.nextDoc(); docId != DocsEnum.NO_MORE_DOCS; docId = docsEnum.nextDoc()) {, +                            typeBuilder.idToDoc.put(idAsBytes, docId);, +                            typeBuilder.docToId[docId] = idAsBytes;, +                for (AtomicReaderContext context : atomicReaderContexts) {, +                    AtomicReader reader = context.reader();, +                    Map<BytesReference, TypeBuilder> readerBuilder = builders.get(reader.getCoreCacheKey());, +                    Terms terms = reader.terms(ParentFieldMapper.NAME);, +                    if (terms == null) { // Should not happen, +                        throw new ElasticSearchIllegalArgumentException("Id cache needs _parent field");, +                    TermsEnum termsEnum = terms.iterator(null);, +                    DocsEnum docsEnum = null;, +                    for (BytesRef term = termsEnum.next(); term != null; term = termsEnum.term()) {, +                        HashedBytesArray[] typeAndId = splitUidIntoTypeAndId(term);, +, +                        TypeBuilder typeBuilder = readerBuilder.get(typeAndId[0]);, +                        if (typeBuilder == null) {, +                            typeBuilder = new TypeBuilder(reader);, +                            readerBuilder.put(typeAndId[0], typeBuilder);, +                        }, +, +                        HashedBytesArray idAsBytes = checkIfCanReuse(builders, typeAndId[1]);, +                        docsEnum = termsEnum.docs(reader.getLiveDocs(), docsEnum, 0);, +                        for (int docId = docsEnum.nextDoc(); docId != DocsEnum.NO_MORE_DOCS; docId = docsEnum.nextDoc()) {, +                            typeBuilder.parentIdsOrdinals[docId] = typeBuilder.t;, +, +                for (Map.Entry<Object, Map<BytesReference, TypeBuilder>> entry : builders.entrySet()) {, +                    MapBuilder<BytesReference, SimpleIdReaderTypeCache> types = MapBuilder.newMapBuilder();, +                    for (Map.Entry<BytesReference, TypeBuilder> typeBuilderEntry : entry.getValue().entrySet()) {, +    private HashedBytesArray checkIfCanReuse(Map<Object, Map<BytesReference, TypeBuilder>> builders, HashedBytesArray idAsBytes) {, +        for (Map<BytesReference, TypeBuilder> map : builders.values()) {, +    private boolean refreshNeeded(List<AtomicReaderContext> atomicReaderContexts) {, +        for (AtomicReaderContext atomicReaderContext : atomicReaderContexts) {, +            if (!idReaders.containsKey(atomicReaderContext.reader().getCoreCacheKey())) {, +    // LUCENE 4 UPGRADE: This logic should go to Uid class. Uid class should BR based instead of string, +    private static HashedBytesArray[] splitUidIntoTypeAndId(BytesRef term) {, +        int loc = -1;, +        for (int i = term.offset; i < term.length; i++) {, +            if (term.bytes[i] == 0x23) { // 0x23 is equal to '#', +                loc = i;, +                break;, +            }, +        }, +, +        if (loc == -1) {, +            return null;, +        }, +, +        byte[] type = new byte[loc - term.offset];, +        System.arraycopy(term.bytes, term.offset, type, 0, type.length);, +, +        byte[] id = new byte[term.length - type.length -1];, +        System.arraycopy(term.bytes, loc + 1, id, 0, id.length);, +        return new HashedBytesArray[]{new HashedBytesArray(type), new HashedBytesArray(id)};, +    }, +, +++ b/src/main/java/org/elasticsearch/index/cache/id/IdCache.java, +import org.apache.lucene.index.AtomicReaderContext;, +import java.util.List;, +, +    void refresh(List<AtomicReaderContext> readers) throws Exception;, +++ b/src/main/java/org/elasticsearch/index/cache/id/simple/SimpleIdCache.java, +import org.apache.lucene.util.BytesRef;, +import org.elasticsearch.ElasticSearchIllegalArgumentException;, +import org.elasticsearch.common.bytes.BytesReference;, +import java.util.*;]