[+++ b/core/src/main/java/org/elasticsearch/action/support/replication/TransportReplicationAction.java, +     * Synchronously execute the specified replica operation. This is done under a permit from, +     * {@link IndexShard#acquireReplicaOperationPermit(long, ActionListener, String)}., +            replica.acquireReplicaOperationPermit(request.primaryTerm, this, executor);, +        indexShard.acquirePrimaryOperationPermit(onAcquired, executor);, +++ b/core/src/main/java/org/elasticsearch/action/support/replication/TransportReplicationAction.java, +     * Synchronously execute the specified replica operation. This is done under a permit from, +     * {@link IndexShard#acquireReplicaOperationPermit(long, ActionListener, String)}., +            replica.acquireReplicaOperationPermit(request.primaryTerm, this, executor);, +        indexShard.acquirePrimaryOperationPermit(onAcquired, executor);, +++ b/core/src/main/java/org/elasticsearch/index/IndexService.java, +++ b/core/src/main/java/org/elasticsearch/action/support/replication/TransportReplicationAction.java, +     * Synchronously execute the specified replica operation. This is done under a permit from, +     * {@link IndexShard#acquireReplicaOperationPermit(long, ActionListener, String)}., +            replica.acquireReplicaOperationPermit(request.primaryTerm, this, executor);, +        indexShard.acquirePrimaryOperationPermit(onAcquired, executor);, +++ b/core/src/main/java/org/elasticsearch/index/IndexService.java, +++ b/core/src/main/java/org/elasticsearch/index/shard/IndexShard.java, +import java.util.Locale;, +    private final IndexShardOperationPermits indexShardOperationPermits;, +        indexShardOperationPermits = new IndexShardOperationPermits(shardId, logger, threadPool);, +        assert shardRouting.primary() : "primary term can only be explicitly updated on a primary shard";, +                assert shardRouting.initializing() == false :, +                        "a started primary shard should never update its term; ", +                                + "shard " + shardRouting + ", ", +                                + "current term [" + primaryTerm + "], ", +                                + "new term [" + newTerm + "]";, +                assert newTerm > primaryTerm :, +                        "primary terms can only go up; current term [" + primaryTerm + "], new term [" + newTerm + "]";, +            indexShardOperationPermits.blockOperations(30, TimeUnit.MINUTES, () -> {, +                // no shard operation permits are being held here, move state from started to relocated, +                assert indexShardOperationPermits.getActiveOperationsCount() == 0 :, +                    indexShardOperationPermits.close();, +     * Acquire a primary operation permit whenever the shard is ready for indexing. If a permit is directly available, the provided, +     * ActionListener will be called on the calling thread. During relocation hand-off, permit acquisition can be delayed. The provided, +    public void acquirePrimaryOperationPermit(ActionListener<Releasable> onPermitAcquired, String executorOnDelay) {, +        indexShardOperationPermits.acquire(onPermitAcquired, executorOnDelay, false);, +    private final Object primaryTermMutex = new Object();, +, +     * Acquire a replica operation permit whenever the shard is ready for indexing (see, +     * {@link #acquirePrimaryOperationPermit(ActionListener, String)}). If the given primary term is lower than then one in, +     * {@link #shardRouting}, the {@link ActionListener#onFailure(Exception)} method of the provided listener is invoked with an, +     * {@link IllegalStateException}. If permit acquisition is delayed, the listener will be invoked on the executor with the specified, +     * name., +     *, +     * @param operationPrimaryTerm the operation primary term, +     * @param onPermitAcquired     the listener for permit acquisition, +     * @param executorOnDelay      the name of the executor to invoke the listener on if permit acquisition is delayed, +    public void acquireReplicaOperationPermit(, +            final long operationPrimaryTerm, final ActionListener<Releasable> onPermitAcquired, final String executorOnDelay) {, +        if (operationPrimaryTerm > primaryTerm) {, +            synchronized (primaryTermMutex) {, +                if (operationPrimaryTerm > primaryTerm) {, +                    try {, +                        indexShardOperationPermits.blockOperations(30, TimeUnit.MINUTES, () -> {, +                            assert operationPrimaryTerm > primaryTerm;, +                            primaryTerm = operationPrimaryTerm;, +                        });, +                    } catch (final InterruptedException | TimeoutException e) {, +                        onPermitAcquired.onFailure(e);, +                        return;, +                    }, +                }, +            }, +        assert operationPrimaryTerm <= primaryTerm, +                : "operation primary term [" + operationPrimaryTerm + "] should be at most [" + primaryTerm + "]";, +        indexShardOperationPermits.acquire(, +                new ActionListener<Releasable>() {, +                    @Override, +                    public void onResponse(final Releasable releasable) {, +                        if (operationPrimaryTerm < primaryTerm) {, +                            releasable.close();, +                            onOperationPrimaryTermIsTooOld(shardId, operationPrimaryTerm, primaryTerm, onPermitAcquired);, +                        } else {, +                            onPermitAcquired.onResponse(releasable);, +                        }, +                    }, +, +                    @Override, +                    public void onFailure(final Exception e) {, +                        onPermitAcquired.onFailure(e);, +                    }, +                },, +                executorOnDelay,, +                true);, +    }, +, +    private static void onOperationPrimaryTermIsTooOld(, +            final ShardId shardId,, +            final long operationPrimaryTerm,, +            final long primaryTerm,, +            final ActionListener<Releasable> onPermitAcquired) {, +        final String message = String.format(, +                Locale.ROOT,, +                "%s operation primary term [%d] is too old (current [%d])",, +                shardId,, +                operationPrimaryTerm,, +                primaryTerm);, +        onPermitAcquired.onFailure(new IllegalStateException(message));, +        return indexShardOperationPermits.getActiveOperationsCount(); // refCount is incremented on successful acquire and decremented on close]