[+++ /dev/null, +++ /dev/null, +++ b/core/src/main/java/org/elasticsearch/index/translog/Translog.java, +            closeOnTragicEvent(e);, +        } catch (Throwable ex) {, +        } catch (Throwable ex) {, +++ /dev/null, +++ b/core/src/main/java/org/elasticsearch/index/translog/Translog.java, +            closeOnTragicEvent(e);, +        } catch (Throwable ex) {, +        } catch (Throwable ex) {, +++ /dev/null, +++ /dev/null, +++ b/core/src/main/java/org/elasticsearch/index/translog/Translog.java, +            closeOnTragicEvent(e);, +        } catch (Throwable ex) {, +        } catch (Throwable ex) {, +++ /dev/null, +++ b/core/src/test/java/org/elasticsearch/index/translog/TranslogTests.java, +    public void testTragicEventCanBeAnyException() throws IOException {, +        Path tempDir = createTempDir();, +        final AtomicBoolean fail = new AtomicBoolean();, +        TranslogConfig config = getTranslogConfig(tempDir);, +        assumeFalse("this won't work if we sync on any op",config.isSyncOnEachOperation());, +        Translog translog = getFailableTranslog(fail, config, false, true);, +        LineFileDocs lineFileDocs = new LineFileDocs(random()); // writes pretty big docs so we cross buffer boarders regularly, +        translog.add(new Translog.Index("test", "1", lineFileDocs.nextDoc().toString().getBytes(Charset.forName("UTF-8"))));, +        fail.set(true);, +        try {, +            Translog.Location location = translog.add(new Translog.Index("test", "2", lineFileDocs.nextDoc().toString().getBytes(Charset.forName("UTF-8"))));, +            if (config.getType() == TranslogWriter.Type.BUFFERED) { // the buffered case will fail on the add if we exceed the buffer or will fail on the flush once we sync, +                if (randomBoolean()) {, +                    translog.ensureSynced(location);, +                } else {, +                    translog.sync();, +                }, +            }, +            //TODO once we have a mock FS that can simulate we can also fail on plain sync, +            fail("WTF");, +        } catch (UnknownException ex) {, +            // w00t, +        } catch (TranslogException ex) {, +            assertTrue(ex.getCause() instanceof UnknownException);, +        }, +        assertFalse(translog.isOpen());, +        assertTrue(translog.getTragicException() instanceof  UnknownException);, +    }, +, +                assertTrue(ex.toString(), ex instanceof IOException || ex instanceof AlreadyClosedException);, +        return getFailableTranslog(fail, config, randomBoolean(), false);, +    }, +, +    private Translog getFailableTranslog(final AtomicBoolean fail, final TranslogConfig config, final boolean paritalWrites, final boolean throwUnknownException) throws IOException {, +                        return new ThrowingFileChannel(fail, paritalWrites, throwUnknownException, channel);, +        private final boolean throwUnknownException;, +        public ThrowingFileChannel(AtomicBoolean fail, boolean partialWrite, boolean throwUnknownException, FileChannel delegate) {, +            this.throwUnknownException = throwUnknownException;, +                    if (src.hasRemaining()) {, +                        src.limit(randomIntBetween(pos, limit));, +                        src.position(pos);, +                if (throwUnknownException) {, +                    throw new UnknownException();, +                } else {, +            }, +, +    private static final class UnknownException extends RuntimeException {, +, +    }, +++ /dev/null, +++ b/core/src/main/java/org/elasticsearch/index/translog/Translog.java, +            closeOnTragicEvent(e);, +        } catch (Throwable ex) {, +        } catch (Throwable ex) {, +++ /dev/null, +++ b/core/src/test/java/org/elasticsearch/index/translog/TranslogTests.java, +    public void testTragicEventCanBeAnyException() throws IOException {, +        Path tempDir = createTempDir();, +        final AtomicBoolean fail = new AtomicBoolean();, +        TranslogConfig config = getTranslogConfig(tempDir);, +        assumeFalse("this won't work if we sync on any op",config.isSyncOnEachOperation());, +        Translog translog = getFailableTranslog(fail, config, false, true);, +        LineFileDocs lineFileDocs = new LineFileDocs(random()); // writes pretty big docs so we cross buffer boarders regularly, +        translog.add(new Translog.Index("test", "1", lineFileDocs.nextDoc().toString().getBytes(Charset.forName("UTF-8"))));, +        fail.set(true);, +        try {, +            Translog.Location location = translog.add(new Translog.Index("test", "2", lineFileDocs.nextDoc().toString().getBytes(Charset.forName("UTF-8"))));, +            if (config.getType() == TranslogWriter.Type.BUFFERED) { // the buffered case will fail on the add if we exceed the buffer or will fail on the flush once we sync, +                if (randomBoolean()) {, +                    translog.ensureSynced(location);, +                } else {, +                    translog.sync();, +                }, +            }, +            //TODO once we have a mock FS that can simulate we can also fail on plain sync, +            fail("WTF");, +        } catch (UnknownException ex) {, +            // w00t, +        } catch (TranslogException ex) {, +            assertTrue(ex.getCause() instanceof UnknownException);, +        }]