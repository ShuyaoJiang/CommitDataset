[+++ b/core/src/main/java/org/elasticsearch/cluster/metadata/MetaDataIndexUpgradeService.java, +                                    "index.shard.inactive_time",, +++ b/core/src/main/java/org/elasticsearch/cluster/metadata/MetaDataIndexUpgradeService.java, +                                    "index.shard.inactive_time",, +++ b/core/src/main/java/org/elasticsearch/common/unit/TimeValue.java, +        assert settingName.startsWith("index.") == false || MetaDataIndexUpgradeService.INDEX_TIME_SETTINGS.contains(settingName) : settingName;, +++ b/core/src/main/java/org/elasticsearch/cluster/metadata/MetaDataIndexUpgradeService.java, +                                    "index.shard.inactive_time",, +++ b/core/src/main/java/org/elasticsearch/common/unit/TimeValue.java, +        assert settingName.startsWith("index.") == false || MetaDataIndexUpgradeService.INDEX_TIME_SETTINGS.contains(settingName) : settingName;, +++ b/core/src/main/java/org/elasticsearch/index/shard/IndexShard.java, +    /** If we see no indexing operations after this much time for a given shard, we consider that shard inactive (default: 5 minutes). */, +    public static final String INDEX_SHARD_INACTIVE_TIME_SETTING = "index.shard.inactive_time";, +    private static final String INDICES_INACTIVE_TIME_SETTING = "indices.memory.shard_inactive_time";, +    private final TimeValue inactiveTime;, +        this.inactiveTime = this.indexSettings.getAsTime(INDEX_SHARD_INACTIVE_TIME_SETTING, this.indexSettings.getAsTime(INDICES_INACTIVE_TIME_SETTING, TimeValue.timeValueMinutes(5)));, +    public boolean checkIdle() {, +        if (engineOrNull != null && System.nanoTime() - engineOrNull.getLastWriteNanos() >= inactiveTime.nanos()) {, +     *  IndexShard#INDEX_SHARD_INACTIVE_TIME_SETTING} (default 5 minutes), else {@code false}. */, +    public TimeValue getInactiveTime() {, +        return inactiveTime;, +    }, +, +                mapperService.indexAnalyzer(), similarityService.similarity(mapperService), codecService, shardEventListener, translogRecoveryPerformer, indexCache.query(), cachingPolicy, translogConfig, inactiveTime);, +++ b/core/src/main/java/org/elasticsearch/cluster/metadata/MetaDataIndexUpgradeService.java, +                                    "index.shard.inactive_time",, +++ b/core/src/main/java/org/elasticsearch/common/unit/TimeValue.java, +        assert settingName.startsWith("index.") == false || MetaDataIndexUpgradeService.INDEX_TIME_SETTINGS.contains(settingName) : settingName;, +++ b/core/src/main/java/org/elasticsearch/index/shard/IndexShard.java, +    /** If we see no indexing operations after this much time for a given shard, we consider that shard inactive (default: 5 minutes). */, +    public static final String INDEX_SHARD_INACTIVE_TIME_SETTING = "index.shard.inactive_time";, +    private static final String INDICES_INACTIVE_TIME_SETTING = "indices.memory.shard_inactive_time";, +    private final TimeValue inactiveTime;, +        this.inactiveTime = this.indexSettings.getAsTime(INDEX_SHARD_INACTIVE_TIME_SETTING, this.indexSettings.getAsTime(INDICES_INACTIVE_TIME_SETTING, TimeValue.timeValueMinutes(5)));, +    public boolean checkIdle() {, +        if (engineOrNull != null && System.nanoTime() - engineOrNull.getLastWriteNanos() >= inactiveTime.nanos()) {, +     *  IndexShard#INDEX_SHARD_INACTIVE_TIME_SETTING} (default 5 minutes), else {@code false}. */, +    public TimeValue getInactiveTime() {, +        return inactiveTime;, +    }, +, +                mapperService.indexAnalyzer(), similarityService.similarity(mapperService), codecService, shardEventListener, translogRecoveryPerformer, indexCache.query(), cachingPolicy, translogConfig, inactiveTime);, +++ b/core/src/main/java/org/elasticsearch/indices/memory/IndexingMemoryController.java, +        logger.debug("using indexing buffer size [{}], with {} [{}], {} [{}], {} [{}]",, +                    } else if (checkIdle(shardId) == Boolean.TRUE) {, +, +    protected Boolean checkIdle(ShardId shardId) {, +        final String ignoreReason;, +                if (shard.checkIdle()) {, +                    logger.debug("marking shard {} as inactive (inactive_time[{}]) indexing wise",, +                            shardId,, +                            shard.getInactiveTime());, +                }, +                return Boolean.TRUE;, +        // At least on shard used to be inactive ie. a new write operation just showed up., +        // We try to fix the shards indexing buffer immediately. We could do this async instead, but cost should, +        // be low, and it's rare this happens., +++ b/core/src/main/java/org/elasticsearch/cluster/metadata/MetaDataIndexUpgradeService.java, +                                    "index.shard.inactive_time",, +++ b/core/src/main/java/org/elasticsearch/common/unit/TimeValue.java, +        assert settingName.startsWith("index.") == false || MetaDataIndexUpgradeService.INDEX_TIME_SETTINGS.contains(settingName) : settingName;, +++ b/core/src/main/java/org/elasticsearch/index/shard/IndexShard.java, +    /** If we see no indexing operations after this much time for a given shard, we consider that shard inactive (default: 5 minutes). */, +    public static final String INDEX_SHARD_INACTIVE_TIME_SETTING = "index.shard.inactive_time";, +    private static final String INDICES_INACTIVE_TIME_SETTING = "indices.memory.shard_inactive_time";, +    private final TimeValue inactiveTime;, +        this.inactiveTime = this.indexSettings.getAsTime(INDEX_SHARD_INACTIVE_TIME_SETTING, this.indexSettings.getAsTime(INDICES_INACTIVE_TIME_SETTING, TimeValue.timeValueMinutes(5)));, +    public boolean checkIdle() {, +        if (engineOrNull != null && System.nanoTime() - engineOrNull.getLastWriteNanos() >= inactiveTime.nanos()) {, +     *  IndexShard#INDEX_SHARD_INACTIVE_TIME_SETTING} (default 5 minutes), else {@code false}. */, +    public TimeValue getInactiveTime() {, +        return inactiveTime;, +    }, +, +                mapperService.indexAnalyzer(), similarityService.similarity(mapperService), codecService, shardEventListener, translogRecoveryPerformer, indexCache.query(), cachingPolicy, translogConfig, inactiveTime);, +++ b/core/src/main/java/org/elasticsearch/indices/memory/IndexingMemoryController.java, +        logger.debug("using indexing buffer size [{}], with {} [{}], {} [{}], {} [{}]",, +                    } else if (checkIdle(shardId) == Boolean.TRUE) {, +, +    protected Boolean checkIdle(ShardId shardId) {, +        final String ignoreReason;, +                if (shard.checkIdle()) {, +                    logger.debug("marking shard {} as inactive (inactive_time[{}]) indexing wise",, +                            shardId,, +                            shard.getInactiveTime());, +                }, +                return Boolean.TRUE;, +        // At least on shard used to be inactive ie. a new write operation just showed up., +        // We try to fix the shards indexing buffer immediately. We could do this async instead, but cost should, +        // be low, and it's rare this happens., +++ b/core/src/test/java/org/elasticsearch/index/shard/IndexShardTests.java, +                .setSettings(SETTING_NUMBER_OF_SHARDS, 1, SETTING_NUMBER_OF_REPLICAS, 0, IndexShard.INDEX_SHARD_INACTIVE_TIME_SETTING, "0s"));, +        Boolean result = indicesService.indexService("test").getShardOrNull(0).checkIdle();, +        assertBusy(() -> {, +++ b/core/src/main/java/org/elasticsearch/cluster/metadata/MetaDataIndexUpgradeService.java, +                                    "index.shard.inactive_time",, +++ b/core/src/main/java/org/elasticsearch/common/unit/TimeValue.java, +        assert settingName.startsWith("index.") == false || MetaDataIndexUpgradeService.INDEX_TIME_SETTINGS.contains(settingName) : settingName;, +++ b/core/src/main/java/org/elasticsearch/index/shard/IndexShard.java, +    /** If we see no indexing operations after this much time for a given shard, we consider that shard inactive (default: 5 minutes). */]