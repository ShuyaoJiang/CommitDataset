[+++ b/core/src/main/java/org/elasticsearch/ElasticsearchException.java, +        return innerFromXContent(parser, false);, +    private static ElasticsearchException innerFromXContent(XContentParser parser, boolean parseRootCauses) throws IOException {, +        List<ElasticsearchException> rootCauses = new ArrayList<>();, +                if (parseRootCauses && ROOT_CAUSE.equals(currentFieldName)) {, +                    while ((token = parser.nextToken()) != XContentParser.Token.END_ARRAY) {, +                        rootCauses.add(fromXContent(parser));, +                    }, +                } else {, +        }, +, +        // Adds root causes as suppressed exception. This way they are not lost, +        // after parsing and can be retrieved using getSuppressed() method., +        for (ElasticsearchException rootCause : rootCauses) {, +            e.addSuppressed(rootCause);, +        }, +        // Root causes are parsed in the innerFromXContent() and are added as suppressed exceptions., +        return innerFromXContent(parser, true);, +++ b/core/src/main/java/org/elasticsearch/ElasticsearchException.java, +        return innerFromXContent(parser, false);, +    private static ElasticsearchException innerFromXContent(XContentParser parser, boolean parseRootCauses) throws IOException {, +        List<ElasticsearchException> rootCauses = new ArrayList<>();, +                if (parseRootCauses && ROOT_CAUSE.equals(currentFieldName)) {, +                    while ((token = parser.nextToken()) != XContentParser.Token.END_ARRAY) {, +                        rootCauses.add(fromXContent(parser));, +                    }, +                } else {, +        }, +, +        // Adds root causes as suppressed exception. This way they are not lost, +        // after parsing and can be retrieved using getSuppressed() method., +        for (ElasticsearchException rootCause : rootCauses) {, +            e.addSuppressed(rootCause);, +        }, +        // Root causes are parsed in the innerFromXContent() and are added as suppressed exceptions., +        return innerFromXContent(parser, true);, +++ b/core/src/test/java/org/elasticsearch/ElasticsearchExceptionTests.java, +import org.elasticsearch.action.NoShardAvailableActionException;, +import org.elasticsearch.client.transport.NoNodeAvailableException;, +import org.elasticsearch.cluster.node.DiscoveryNode;, +import org.elasticsearch.node.NodeClosedException;, +import org.elasticsearch.repositories.RepositoryException;, +import org.elasticsearch.script.ScriptException;, +import org.elasticsearch.search.SearchContextMissingException;, +import java.nio.file.FileAlreadyExistsException;, +import static java.util.Collections.singletonList;, +            builder.startObject(), +                    .field("metadata_int", 1), +                    .array("metadata_array_of_ints", new int[]{8, 13, 21}), +                    .field("reason", "Custom reason"), +                    .array("metadata_array_of_boolean", new boolean[]{false, false}), +                    .startArray("metadata_array_of_objects"), +                        .startObject(), +                            .field("object_array_one", "value_one"), +                        .endObject(), +                        .startObject(), +                            .field("object_array_two", "value_two"), +                        .endObject(), +                    .endArray(), +                    .field("type", "custom_exception"), +                    .field("metadata_long", 1L), +                    .array("metadata_array_of_longs", new long[]{2L, 3L, 5L}), +                    .field("metadata_other", "some metadata"), +                    .startObject("header"), +                        .field("header_string", "some header"), +                        .array("header_array_of_strings", new String[]{"foo", "bar", "baz"}), +                    .endObject(), +                    .startObject("metadata_object"), +                        .field("object_field", "value"), +                    .endObject(), +            .endObject();, +    public void testFailureToAndFromXContentWithNoDetails() throws IOException {, +        final Exception failure = (Exception) randomExceptions().v1();, +            ElasticsearchException.generateFailureXContent(builder, params, failure, false);, +        try (XContentParser parser = createParser(xContent, failureBytes)) {, +            failureBytes = shuffleXContent(parser, randomBoolean()).bytes();, +        }, +, +, +    public void testFailureToAndFromXContentWithDetails() throws IOException {, +        final XContent xContent = randomFrom(XContentType.values()).xContent();, +, +        Exception failure;, +        Throwable failureCause;, +        ElasticsearchException expected;, +        ElasticsearchException expectedCause;, +        ElasticsearchException suppressed;, +, +        switch (randomIntBetween(0, 6)) {, +            case 0: // Simple elasticsearch exception without cause, +                failure = new NoNodeAvailableException("A");, +, +                expected = new ElasticsearchException("Elasticsearch exception [type=no_node_available_exception, reason=A]");, +                expected.addSuppressed(new ElasticsearchException("Elasticsearch exception [type=no_node_available_exception, reason=A]"));, +                break;, +, +            case 1: // Simple elasticsearch exception with headers (other metadata of type number are not parsed), +                failure = new CircuitBreakingException("B", 5_000, 2_000);, +                ((ElasticsearchException) failure).addHeader("header_name", "0", "1");, +                expected = new ElasticsearchException("Elasticsearch exception [type=circuit_breaking_exception, reason=B]");]