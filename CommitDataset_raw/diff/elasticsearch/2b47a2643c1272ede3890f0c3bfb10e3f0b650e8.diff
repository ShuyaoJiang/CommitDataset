[+++ b/core/src/main/java/org/elasticsearch/cluster/routing/RoutingNodes.java, +                if (shard.initializing() && shard.relocatingNodeId() == null) {, +        /**, +         * Removes relocation source of an initializing non-primary shard. This allows the replica shard to continue recovery from, +         * the primary even though its non-primary relocation source has failed., +         */, +        public ShardRouting removeRelocationSource() {, +            assert shard.isRelocationTarget();, +            ensureMutable();, +            ShardRouting relocationMarkerRemoved = shard.removeRelocationSource();, +            updateAssigned(shard, relocationMarkerRemoved);, +            inactiveShardCount++; // relocation targets are not counted as inactive shards whereas initializing shards are, +            Recoveries.getOrAdd(recoveriesPerNode, shard.relocatingNodeId()).addOutgoing(-1);, +            return relocationMarkerRemoved;, +        }, +, +++ b/core/src/main/java/org/elasticsearch/cluster/routing/RoutingNodes.java, +                if (shard.initializing() && shard.relocatingNodeId() == null) {, +        /**, +         * Removes relocation source of an initializing non-primary shard. This allows the replica shard to continue recovery from, +         * the primary even though its non-primary relocation source has failed., +         */, +        public ShardRouting removeRelocationSource() {, +            assert shard.isRelocationTarget();, +            ensureMutable();, +            ShardRouting relocationMarkerRemoved = shard.removeRelocationSource();, +            updateAssigned(shard, relocationMarkerRemoved);, +            inactiveShardCount++; // relocation targets are not counted as inactive shards whereas initializing shards are, +            Recoveries.getOrAdd(recoveriesPerNode, shard.relocatingNodeId()).addOutgoing(-1);, +            return relocationMarkerRemoved;, +        }, +, +++ b/core/src/main/java/org/elasticsearch/cluster/routing/ShardRouting.java, +     * Removes relocation source of a non-primary shard. The shard state must be <code>INITIALIZING</code>., +     * This allows the non-primary shard to continue recovery from the primary even though its non-primary, +     * relocation source has failed., +     */, +    public ShardRouting removeRelocationSource() {, +        assert primary == false : this;, +        assert state == ShardRoutingState.INITIALIZING : this;, +        assert assignedToNode() : this;, +        assert relocatingNodeId != null : this;, +        return new ShardRouting(shardId, currentNodeId, null, restoreSource, primary, state, unassignedInfo,, +            AllocationId.finishRelocation(allocationId), expectedShardSize);, +    }, +, +    /**, +++ b/core/src/main/java/org/elasticsearch/cluster/routing/RoutingNodes.java, +                if (shard.initializing() && shard.relocatingNodeId() == null) {, +        /**, +         * Removes relocation source of an initializing non-primary shard. This allows the replica shard to continue recovery from, +         * the primary even though its non-primary relocation source has failed., +         */, +        public ShardRouting removeRelocationSource() {, +            assert shard.isRelocationTarget();, +            ensureMutable();, +            ShardRouting relocationMarkerRemoved = shard.removeRelocationSource();, +            updateAssigned(shard, relocationMarkerRemoved);, +            inactiveShardCount++; // relocation targets are not counted as inactive shards whereas initializing shards are, +            Recoveries.getOrAdd(recoveriesPerNode, shard.relocatingNodeId()).addOutgoing(-1);, +            return relocationMarkerRemoved;, +        }, +, +++ b/core/src/main/java/org/elasticsearch/cluster/routing/ShardRouting.java, +     * Removes relocation source of a non-primary shard. The shard state must be <code>INITIALIZING</code>., +     * This allows the non-primary shard to continue recovery from the primary even though its non-primary, +     * relocation source has failed., +     */, +    public ShardRouting removeRelocationSource() {, +        assert primary == false : this;, +        assert state == ShardRoutingState.INITIALIZING : this;, +        assert assignedToNode() : this;, +        assert relocatingNodeId != null : this;, +        return new ShardRouting(shardId, currentNodeId, null, restoreSource, primary, state, unassignedInfo,, +            AllocationId.finishRelocation(allocationId), expectedShardSize);, +    }, +, +    /**, +++ b/core/src/main/java/org/elasticsearch/cluster/routing/allocation/AllocationService.java, +            // The fail shard is the main copy of the current shard routing., +            boolean addAsUnassigned = true;, +                // now, find the shard that is initializing on the target node, +                            if (failedShard.primary()) {, +                                // cancel and remove target shard, +                            } else {, +                                logger.trace("{}, relocation source failed, mark as initializing without relocation source", shardRouting);, +                                // promote to initializing shard without relocation source and ensure that removed relocation source, +                                // is not added back as unassigned shard, +                                initializingNode.removeRelocationSource();, +                                addAsUnassigned = false;, +                            }, +                            break;, +            if (addAsUnassigned) {, +        }, +++ b/core/src/main/java/org/elasticsearch/cluster/routing/RoutingNodes.java, +                if (shard.initializing() && shard.relocatingNodeId() == null) {, +        /**, +         * Removes relocation source of an initializing non-primary shard. This allows the replica shard to continue recovery from, +         * the primary even though its non-primary relocation source has failed., +         */]