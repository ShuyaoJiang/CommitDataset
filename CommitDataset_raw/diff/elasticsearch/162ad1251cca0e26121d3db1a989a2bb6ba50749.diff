[+++ b/core/src/main/java/org/elasticsearch/action/support/replication/TransportWriteAction.java, +import java.util.concurrent.atomic.AtomicBoolean;, +import java.util.concurrent.atomic.AtomicInteger;, +import java.util.concurrent.atomic.AtomicReference;, +            new AsyncAfterWriteAction(indexShard, request, location, this, logger).run();, +            respondIfPossible(null);, +        protected void respondIfPossible(Exception ex) {, +                if (ex == null) {, +                } else {, +                    listener.onFailure(ex);, +                }, +        public synchronized void onFailure(Exception exception) {, +            finishedAsyncActions = true;, +            respondIfPossible(exception);, +        }, +, +        public synchronized void onSuccess(boolean forcedRefresh) {, +            respondIfPossible(null);, +            new AsyncAfterWriteAction(indexShard, request, location, this, logger).run();, +            respondIfPossible(null);, +        protected void respondIfPossible(Exception ex) {, +                if (ex == null) {, +                } else {, +                    listener.onFailure(ex);, +                }, +        public void onFailure(Exception ex) {, +            respondIfPossible(ex);, +        }, +, +        @Override, +        public synchronized void onSuccess(boolean forcedRefresh) {, +            finishedAsyncActions = true;, +            respondIfPossible(null);, +    /**, +     * callback used by {@link AsyncAfterWriteAction} to notify that all post, +     * process actions have been executed, +     */, +        /**, +         * Called on successful processing of all post write actions, +         * @param forcedRefresh <code>true</code> iff this write has caused a refresh, +         */, +        void onSuccess(boolean forcedRefresh);, +, +        /**, +         * Called on failure if a post action failed., +         */, +        void onFailure(Exception ex);, +    /**, +     * This class encapsulates post write actions like async waits for, +     * translog syncs or waiting for a refresh to happen making the write operation, +     * visible., +     */, +    static final class AsyncAfterWriteAction {, +        private final Location location;, +        private final boolean waitUntilRefresh;, +        private final boolean sync;, +        private final AtomicInteger pendingOps = new AtomicInteger(1);, +        private final AtomicBoolean refreshed = new AtomicBoolean(false);, +        private final AtomicReference<Exception> syncFailure = new AtomicReference<>(null);, +        private final RespondingWriteResult respond;, +        private final IndexShard indexShard;, +        private final WriteRequest<?> request;, +        private final ESLogger logger;, +, +        AsyncAfterWriteAction(final IndexShard indexShard,, +            this.indexShard = indexShard;, +            this.request = request;, +            boolean waitUntilRefresh = false;, +                    refreshed.set(true);, +                        waitUntilRefresh = true;, +                        pendingOps.incrementAndGet();, +                default:, +                    throw new IllegalArgumentException("unknown refresh policy: " + request.getRefreshPolicy());, +            this.waitUntilRefresh = waitUntilRefresh;, +            this.respond = respond;, +            this.location = location;, +            if ((sync = indexShard.getTranslogDurability() == Translog.Durability.REQUEST && location != null)) {, +                pendingOps.incrementAndGet();, +            this.logger = logger;, +            assert pendingOps.get() >= 0 && pendingOps.get() <= 3 : "pendingOpts was: " + pendingOps.get();, +        }, +, +        /** calls the response listener if all pending operations have returned otherwise it just decrements the pending opts counter.*/, +        private void maybeFinish() {, +            final int numPending = pendingOps.decrementAndGet();, +            if (numPending == 0) {, +                if (syncFailure.get() != null) {, +                    respond.onFailure(syncFailure.get());, +                } else {, +                    respond.onSuccess(refreshed.get());, +                }, +            }, +            assert numPending >= 0 && numPending <= 2: "numPending must either 2, 1 or 0 but was " + numPending ;, +        }, +, +        void run() {, +            // we either respond immediately ie. if we we don't fsync per request or wait for refresh, +            // OR we got an pass async operations on and wait for them to return to respond., +            maybeFinish(); // decrement the pendingOpts by one, if there is nothing else to do we just respond with success., +            if (waitUntilRefresh) {]