[+++ b/core/src/main/java/org/elasticsearch/cluster/routing/RoutingNodes.java, +, +import java.util.*;, +            nodesToShards.put(cursor.value.id(), new ArrayList<ShardRouting>());, +                        List<ShardRouting> entries = nodesToShards.get(shard.currentNodeId());, +                        if (entries == null) {, +                            entries = new ArrayList<>();, +                            nodesToShards.put(shard.currentNodeId(), entries);, +                        }, +                            entries = nodesToShards.get(shard.relocatingNodeId());, +                            if (entries == null) {, +                                entries = new ArrayList<>();, +                                nodesToShards.put(shard.relocatingNodeId(), entries);, +                            }, +        List<ShardRouting> shards = assignedShards.get(shard.shardId());, +        if (shards == null) {, +            shards = new ArrayList<>();, +            assignedShards.put(shard.shardId(), shards);, +        }, +++ b/core/src/main/java/org/elasticsearch/cluster/routing/RoutingNodes.java, +, +import java.util.*;, +            nodesToShards.put(cursor.value.id(), new ArrayList<ShardRouting>());, +                        List<ShardRouting> entries = nodesToShards.get(shard.currentNodeId());, +                        if (entries == null) {, +                            entries = new ArrayList<>();, +                            nodesToShards.put(shard.currentNodeId(), entries);, +                        }, +                            entries = nodesToShards.get(shard.relocatingNodeId());, +                            if (entries == null) {, +                                entries = new ArrayList<>();, +                                nodesToShards.put(shard.relocatingNodeId(), entries);, +                            }, +        List<ShardRouting> shards = assignedShards.get(shard.shardId());, +        if (shards == null) {, +            shards = new ArrayList<>();, +            assignedShards.put(shard.shardId(), shards);, +        }, +++ b/core/src/main/java/org/elasticsearch/index/translog/Translog.java, +                final Checkpoint checkpoint = readCheckpoint();, +            closeOnTragicEvent(ex);, +            closeOnTragicEvent(ex);, +        } catch (AlreadyClosedException | IOException ex) {, +            closeOnTragicEvent(ex);, +            throw ex;, +    private void closeOnTragicEvent(Throwable ex) {, +        if (current.getTragicException() != null) {, +            try {, +                close();, +            } catch (Exception inner) {, +                ex.addSuppressed(inner);, +            }, +        }, +    }, +, +    /** Reads and returns the current checkpoint */, +    final Checkpoint readCheckpoint() throws IOException {, +        return Checkpoint.read(location.resolve(CHECKPOINT_FILE_NAME));, +    }, +, +++ b/core/src/main/java/org/elasticsearch/cluster/routing/RoutingNodes.java, +, +import java.util.*;, +            nodesToShards.put(cursor.value.id(), new ArrayList<ShardRouting>());, +                        List<ShardRouting> entries = nodesToShards.get(shard.currentNodeId());, +                        if (entries == null) {, +                            entries = new ArrayList<>();, +                            nodesToShards.put(shard.currentNodeId(), entries);, +                        }, +                            entries = nodesToShards.get(shard.relocatingNodeId());, +                            if (entries == null) {, +                                entries = new ArrayList<>();, +                                nodesToShards.put(shard.relocatingNodeId(), entries);, +                            }, +        List<ShardRouting> shards = assignedShards.get(shard.shardId());, +        if (shards == null) {, +            shards = new ArrayList<>();, +            assignedShards.put(shard.shardId(), shards);, +        }, +++ b/core/src/main/java/org/elasticsearch/index/translog/Translog.java, +                final Checkpoint checkpoint = readCheckpoint();, +            closeOnTragicEvent(ex);, +            closeOnTragicEvent(ex);, +        } catch (AlreadyClosedException | IOException ex) {, +            closeOnTragicEvent(ex);, +            throw ex;, +    private void closeOnTragicEvent(Throwable ex) {, +        if (current.getTragicException() != null) {, +            try {, +                close();, +            } catch (Exception inner) {, +                ex.addSuppressed(inner);, +            }, +        }, +    }, +, +    /** Reads and returns the current checkpoint */, +    final Checkpoint readCheckpoint() throws IOException {, +        return Checkpoint.read(location.resolve(CHECKPOINT_FILE_NAME));, +    }]