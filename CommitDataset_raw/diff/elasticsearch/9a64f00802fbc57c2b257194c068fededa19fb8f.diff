[+++ b/src/main/java/org/elasticsearch/license/plugin/core/LicensesService.java, +                break;, +            case INVALID:, +            case EXPIRED:, +                listener.onResponse(new LicensesUpdateResponse(true, status));, +                break;, +        }, +++ b/src/main/java/org/elasticsearch/license/plugin/core/LicensesService.java, +                break;, +            case INVALID:, +            case EXPIRED:, +                listener.onResponse(new LicensesUpdateResponse(true, status));, +                break;, +        }, +++ b/src/test/java/org/elasticsearch/license/plugin/AbstractLicensesIntegrationTests.java, +import org.elasticsearch.common.unit.TimeValue;, +import org.elasticsearch.license.core.ESLicense;, +import org.elasticsearch.license.licensor.ESLicenseSigner;, +import java.util.UUID;, +import static org.elasticsearch.license.AbstractLicensingTestBase.getTestPriKeyPath;, +import static org.elasticsearch.license.AbstractLicensingTestBase.getTestPubKeyPath;, +, +    public static ESLicense generateSignedLicense(String feature, TimeValue expiryDate) throws Exception {, +        final ESLicense licenseSpec = ESLicense.builder(), +                .uid(UUID.randomUUID().toString()), +                .feature(feature), +                .expiryDate(System.currentTimeMillis() + expiryDate.getMillis()), +                .issueDate(System.currentTimeMillis()), +                .type("subscription"), +                .subscriptionType("gold"), +                .issuedTo("customer"), +                .issuer("elasticsearch"), +                .maxNodes(randomIntBetween(5, 100)), +                .build();, +, +        ESLicenseSigner signer = new ESLicenseSigner(getTestPriKeyPath(), getTestPubKeyPath());, +        return signer.sign(licenseSpec);, +    }, +++ b/src/main/java/org/elasticsearch/license/plugin/core/LicensesService.java, +                break;, +            case INVALID:, +            case EXPIRED:, +                listener.onResponse(new LicensesUpdateResponse(true, status));, +                break;, +        }, +++ b/src/test/java/org/elasticsearch/license/plugin/AbstractLicensesIntegrationTests.java, +import org.elasticsearch.common.unit.TimeValue;, +import org.elasticsearch.license.core.ESLicense;, +import org.elasticsearch.license.licensor.ESLicenseSigner;, +import java.util.UUID;, +import static org.elasticsearch.license.AbstractLicensingTestBase.getTestPriKeyPath;, +import static org.elasticsearch.license.AbstractLicensingTestBase.getTestPubKeyPath;, +, +    public static ESLicense generateSignedLicense(String feature, TimeValue expiryDate) throws Exception {, +        final ESLicense licenseSpec = ESLicense.builder(), +                .uid(UUID.randomUUID().toString()), +                .feature(feature), +                .expiryDate(System.currentTimeMillis() + expiryDate.getMillis()), +                .issueDate(System.currentTimeMillis()), +                .type("subscription"), +                .subscriptionType("gold"), +                .issuedTo("customer"), +                .issuer("elasticsearch"), +                .maxNodes(randomIntBetween(5, 100)), +                .build();, +, +        ESLicenseSigner signer = new ESLicenseSigner(getTestPriKeyPath(), getTestPubKeyPath());, +        return signer.sign(licenseSpec);, +    }, +++ b/src/test/java/org/elasticsearch/license/plugin/LicenseTransportTests.java, +import org.elasticsearch.common.collect.Lists;, +import org.elasticsearch.common.unit.TimeValue;, +import org.elasticsearch.license.plugin.core.LicensesStatus;, +import org.junit.After;, +import java.util.Arrays;, +import java.util.Collections;, +import java.util.List;, +    @After, +    public void beforeTest() throws Exception {, +        wipeAllLicenses();, +    public void testPutLicense() throws Exception {, +        ESLicense signedLicense = generateSignedLicense(TestUtils.SHIELD, TimeValue.timeValueMinutes(2));, +        List<ESLicense> actualLicenses = Collections.singletonList(signedLicense);, +        // put license, +        PutLicenseRequestBuilder putLicenseRequestBuilder = new PutLicenseRequestBuilder(client().admin().cluster()), +                .setLicense(actualLicenses);, +        PutLicenseResponse putLicenseResponse = putLicenseRequestBuilder.execute().get();, +        assertThat(putLicenseResponse.status(), equalTo(LicensesStatus.VALID));, +        // get license, +        GetLicenseResponse getLicenseResponse = new GetLicenseRequestBuilder(client().admin().cluster()).get();, +        // check license, +        TestUtils.isSame(actualLicenses, getLicenseResponse.licenses());, +        ESLicense signedLicense = generateSignedLicense(TestUtils.SHIELD, TimeValue.timeValueMinutes(2));, +        // modify content of signed license, +        ESLicense tamperedLicense = ESLicense.builder(), +                .fromLicenseSpec(signedLicense, signedLicense.signature()), +                .expiryDate(signedLicense.expiryDate() + 10 * 24 * 60 * 60 * 1000l), +        // try to put license (should be invalid), +        final PutLicenseResponse putLicenseResponse = builder.execute().get();, +        assertThat(putLicenseResponse.status(), equalTo(LicensesStatus.INVALID));]