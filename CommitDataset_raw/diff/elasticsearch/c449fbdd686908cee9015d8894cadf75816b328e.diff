[+++ b/src/main/java/org/apache/lucene/queryparser/classic/MapperQueryParser.java, +            fields = parseContext.simpleMatchToIndexNames(field);, +++ b/src/main/java/org/apache/lucene/queryparser/classic/MapperQueryParser.java, +            fields = parseContext.simpleMatchToIndexNames(field);, +++ b/src/main/java/org/elasticsearch/index/mapper/MapperService.java, +import com.google.common.collect.*;, +    /**, +     * Returns all the fields that match the given pattern, with an optional narrowing, +     * based on a list of types., +     */, +    public Set<String> simpleMatchToIndexNames(String pattern, @Nullable String[] types) {, +        if (types == null || types.length == 0) {, +            return simpleMatchToIndexNames(pattern);, +        }, +        if (types.length == 1 && types[0].equals("_all")) {, +            return simpleMatchToIndexNames(pattern);, +        }, +        if (!Regex.isSimpleMatchPattern(pattern)) {, +            return ImmutableSet.of(pattern);, +        }, +        Set<String> fields = Sets.newHashSet();, +        for (String type : types) {, +            DocumentMapper possibleDocMapper = mappers.get(type);, +            if (possibleDocMapper != null) {, +                for (String indexName : possibleDocMapper.mappers().simpleMatchToIndexNames(pattern)) {, +                    fields.add(indexName);, +                }, +            }, +        }, +        return fields;, +    }, +, +    /**, +     * Returns all the fields that match the given pattern. If the pattern is prefixed with a type, +     * then the fields will be returned with a type prefix., +     */, +        if (!Regex.isSimpleMatchPattern(pattern)) {, +            return ImmutableSet.of(pattern);, +        }, +++ b/src/main/java/org/apache/lucene/queryparser/classic/MapperQueryParser.java, +            fields = parseContext.simpleMatchToIndexNames(field);, +++ b/src/main/java/org/elasticsearch/index/mapper/MapperService.java, +import com.google.common.collect.*;, +    /**, +     * Returns all the fields that match the given pattern, with an optional narrowing, +     * based on a list of types., +     */, +    public Set<String> simpleMatchToIndexNames(String pattern, @Nullable String[] types) {, +        if (types == null || types.length == 0) {, +            return simpleMatchToIndexNames(pattern);, +        }, +        if (types.length == 1 && types[0].equals("_all")) {, +            return simpleMatchToIndexNames(pattern);, +        }, +        if (!Regex.isSimpleMatchPattern(pattern)) {, +            return ImmutableSet.of(pattern);, +        }, +        Set<String> fields = Sets.newHashSet();, +        for (String type : types) {, +            DocumentMapper possibleDocMapper = mappers.get(type);, +            if (possibleDocMapper != null) {, +                for (String indexName : possibleDocMapper.mappers().simpleMatchToIndexNames(pattern)) {, +                    fields.add(indexName);, +                }, +            }, +        }, +        return fields;, +    }, +, +    /**, +     * Returns all the fields that match the given pattern. If the pattern is prefixed with a type, +     * then the fields will be returned with a type prefix., +     */, +        if (!Regex.isSimpleMatchPattern(pattern)) {, +            return ImmutableSet.of(pattern);, +        }, +++ b/src/main/java/org/elasticsearch/index/query/ExistsFilterParser.java, +import org.apache.lucene.search.BooleanClause;, +import org.elasticsearch.common.lucene.search.XBooleanFilter;, +import org.elasticsearch.index.cache.filter.support.CacheKeyFilter;, +import java.util.Set;, +        String fieldPattern = null;, +                    fieldPattern = parser.text();, +        if (fieldPattern == null) {, +        MapperService.SmartNameObjectMapper smartNameObjectMapper = parseContext.smartObjectMapper(fieldPattern);, +        if (smartNameObjectMapper != null && smartNameObjectMapper.hasMapper()) {, +            // automatic make the object mapper pattern, +            fieldPattern = fieldPattern + ".*";, +        }, +, +        Set<String> fields = parseContext.simpleMatchToIndexNames(fieldPattern);, +        if (fields.isEmpty()) {, +            return null;, +        }, +        MapperService.SmartNameFieldMappers nonNullFieldMappers = null;, +, +        XBooleanFilter boolFilter = new XBooleanFilter();, +        for (String field : fields) {, +            MapperService.SmartNameFieldMappers smartNameFieldMappers = parseContext.smartFieldMappers(field);, +            if (smartNameFieldMappers != null) {]