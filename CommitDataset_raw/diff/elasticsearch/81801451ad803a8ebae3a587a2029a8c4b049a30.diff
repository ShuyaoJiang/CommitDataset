[+++ b/buildSrc/src/main/resources/checkstyle_suppressions.xml, +++ b/buildSrc/src/main/resources/checkstyle_suppressions.xml, +++ b/core/src/main/java/org/elasticsearch/index/IndexModule.java, +import org.elasticsearch.index.shard.SearchOperationListener;, +import java.util.ArrayList;, +import java.util.List;, +import java.util.concurrent.atomic.AtomicBoolean;, + *     <li>{@link SimilarityProvider} - New {@link SimilarityProvider} implementations can be registered through, + *     {@link #addSimilarity(String, BiFunction)}while existing Providers can be referenced through Settings under the, + *     {@link IndexModule#SIMILARITY_SETTINGS_PREFIX} prefix along with the "type" value.  For example, to reference the, + *     {@link BM25SimilarityProvider}, the configuration <tt>"index.similarity.my_similarity.type : "BM25"</tt> can be used.</li>, + *      <li>{@link IndexEventListener} - Custom {@link IndexEventListener} instances can be registered via, + *      {@link #addIndexEventListener(IndexEventListener)}</li>, + *      <li>Settings update listener - Custom settings update listener can be registered via, + *      {@link #addSettingsUpdateConsumer(Setting, Consumer)}</li>, +    private final List<SearchOperationListener> searchOperationListeners = new ArrayList<>();, +    private final List<IndexingOperationListener> indexOperationListeners = new ArrayList<>();, +    private final AtomicBoolean frozen = new AtomicBoolean(false);, +        this.searchOperationListeners.add(new SearchSlowLog(indexSettings));, +        this.indexOperationListeners.add(new IndexingSlowLog(indexSettings));, +        ensureNotFrozen();, +        ensureNotFrozen();, +     * Adds an {@link SearchOperationListener} for this index. All listeners added here, +     * are maintained for the entire index lifecycle on this node. Once an index is closed or deleted these, +     * listeners go out of scope., +     * <p>, +     * Note: an index might be created on a node multiple times. For instance if the last shard from an index is, +     * relocated to another node the internal representation will be destroyed which includes the registered listeners., +     * Once the node holds at least one shard of an index all modules are reloaded and listeners are registered again., +     * Listeners can't be unregistered they will stay alive for the entire time the index is allocated on a node., +     * </p>, +     */, +    public void addSearchOperationListener(SearchOperationListener listener) {, +        ensureNotFrozen();, +        if (listener == null) {, +            throw new IllegalArgumentException("listener must not be null");, +        }, +        if (searchOperationListeners.contains(listener)) {, +            throw new IllegalArgumentException("listener already added");, +        }, +, +        this.searchOperationListeners.add(listener);, +    }, +, +    /**, +     * Adds an {@link IndexingOperationListener} for this index. All listeners added here, +     * are maintained for the entire index lifecycle on this node. Once an index is closed or deleted these, +     * listeners go out of scope., +     * <p>, +     * Note: an index might be created on a node multiple times. For instance if the last shard from an index is, +     * relocated to another node the internal representation will be destroyed which includes the registered listeners., +     * Once the node holds at least one shard of an index all modules are reloaded and listeners are registered again., +     * Listeners can't be unregistered they will stay alive for the entire time the index is allocated on a node., +     * </p>, +     */, +    public void addIndexOperationListener(IndexingOperationListener listener) {, +        ensureNotFrozen();, +        if (listener == null) {, +            throw new IllegalArgumentException("listener must not be null");, +        }, +        if (indexOperationListeners.contains(listener)) {, +            throw new IllegalArgumentException("listener already added");, +        }, +, +        this.indexOperationListeners.add(listener);, +    }, +, +    /**, +        ensureNotFrozen();, +        ensureNotFrozen();, +        ensureNotFrozen();, +     * Sets a {@link org.elasticsearch.index.IndexModule.IndexSearcherWrapperFactory} that is called once the IndexService, +     * is fully constructed., +        ensureNotFrozen();, +    IndexEventListener freeze() { // pkg private for testing, +        if (this.frozen.compareAndSet(false, true)) {, +            return new CompositeIndexEventListener(indexSettings, indexEventListeners);, +        } else {, +            throw new IllegalStateException("already frozen");, +    public IndexService newIndexService(NodeEnvironment environment, IndexService.ShardStoreDeleter shardStoreDeleter,, +                                        NodeServicesProvider servicesProvider, IndicesQueryCache indicesQueryCache,, +                                        MapperRegistry mapperRegistry, IndicesFieldDataCache indicesFieldDataCache) throws IOException {, +        final IndexEventListener eventListener = freeze();, +        IndexSearcherWrapperFactory searcherWrapperFactory = indexSearcherWrapper.get() == null, +            ? (shard) -> null : indexSearcherWrapper.get();, +        eventListener.beforeIndexCreated(indexSettings.getIndex(), indexSettings.getSettings());, +        indexSettings.getScopedSettings().addSettingsUpdateConsumer(IndexStore.INDEX_STORE_THROTTLE_MAX_BYTES_PER_SEC_SETTING,, +            store::setMaxRate);, +        final String queryCacheType = forceQueryCacheType.get() != null, +            ? forceQueryCacheType.get() : indexSettings.getValue(INDEX_QUERY_CACHE_TYPE_SETTING);, +        return new IndexService(indexSettings, environment, new SimilarityService(indexSettings, similarities), shardStoreDeleter,, +            analysisRegistry, engineFactory.get(), servicesProvider, queryCache, store, eventListener, searcherWrapperFactory,, +            mapperRegistry, indicesFieldDataCache, searchOperationListeners, indexOperationListeners);, +        ensureNotFrozen();, +    private void ensureNotFrozen() {, +        if (this.frozen.get()) {, +            throw new IllegalStateException("Can't modify IndexModule once the index service has been created");, +        }, +    }, +]