[+++ b/src/main/java/org/elasticsearch/watcher/condition/ConditionModule.java, +import org.elasticsearch.watcher.condition.compare.CompareCondition;, +import org.elasticsearch.watcher.condition.compare.CompareConditionFactory;, +        bind(CompareConditionFactory.class).asEagerSingleton();, +        factoriesBinder.addBinding(CompareCondition.TYPE).to(CompareConditionFactory.class);, +, +++ b/src/main/java/org/elasticsearch/watcher/condition/ConditionModule.java, +import org.elasticsearch.watcher.condition.compare.CompareCondition;, +import org.elasticsearch.watcher.condition.compare.CompareConditionFactory;, +        bind(CompareConditionFactory.class).asEagerSingleton();, +        factoriesBinder.addBinding(CompareCondition.TYPE).to(CompareConditionFactory.class);, +, +++ b/src/main/java/org/elasticsearch/watcher/condition/compare/CompareCondition.java, +/*, + * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one, + * or more contributor license agreements. Licensed under the Elastic License;, + * you may not use this file except in compliance with the Elastic License., + */, +package org.elasticsearch.watcher.condition.compare;, +, +import org.elasticsearch.common.ParseField;, +import org.elasticsearch.common.joda.time.DateTime;, +import org.elasticsearch.common.xcontent.XContentBuilder;, +import org.elasticsearch.common.xcontent.XContentParser;, +import org.elasticsearch.watcher.condition.Condition;, +import org.elasticsearch.watcher.support.WatcherDateUtils;, +import org.elasticsearch.watcher.support.xcontent.WatcherXContentUtils;, +, +import java.io.IOException;, +import java.util.Locale;, +import java.util.Objects;, +, +import static org.elasticsearch.common.joda.time.DateTimeZone.UTC;, +, +/**, + *, + */, +public class CompareCondition implements Condition {, +, +    public static final String TYPE = "compare";, +, +    private String path;, +    private Op op;, +    private Object value;, +, +    public CompareCondition(String path, Op op, Object value) {, +        this.path = path;, +        this.op = op;, +        this.value = value;, +    }, +, +    @Override, +    public final String type() {, +        return TYPE;, +    }, +, +    public String getPath() {, +        return path;, +    }, +, +    public Op getOp() {, +        return op;, +    }, +, +    public Object getValue() {, +        return value;, +    }, +, +    @Override, +    public boolean equals(Object o) {, +        if (this == o) return true;, +        if (o == null || getClass() != o.getClass()) return false;, +, +        CompareCondition condition = (CompareCondition) o;, +, +        if (!path.equals(condition.path)) return false;, +        if (op != condition.op) return false;, +        return !(value != null ? !value.equals(condition.value) : condition.value != null);, +    }, +, +    @Override, +    public int hashCode() {, +        int result = path.hashCode();, +        result = 31 * result + op.hashCode();, +        result = 31 * result + (value != null ? value.hashCode() : 0);, +        return result;, +    }, +, +    @Override, +    public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {, +        return builder.startObject(), +                .startObject(path), +                    .field(op.id(), value), +                .endObject(), +            .endObject();, +    }, +, +    public static CompareCondition parse(String watchId, XContentParser parser) throws IOException {, +        if (parser.currentToken() != XContentParser.Token.START_OBJECT) {, +            throw new CompareConditionException("could not parse [{}] condition for watch [{}]. expected an object but found [{}] instead", TYPE, watchId, parser.currentToken());]