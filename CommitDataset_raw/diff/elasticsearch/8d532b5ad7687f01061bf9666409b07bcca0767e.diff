[+++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/server/src/main/java/org/elasticsearch/transport/InboundHandler.java, +/*, + * Licensed to Elasticsearch under one or more contributor, + * license agreements. See the NOTICE file distributed with, + * this work for additional information regarding copyright, + * ownership. Elasticsearch licenses this file to you under, + * the Apache License, Version 2.0 (the "License"); you may, + * not use this file except in compliance with the License., + * You may obtain a copy of the License at, + *, + *    http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing,, + * software distributed under the License is distributed on an, + * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY, + * KIND, either express or implied.  See the License for the, + * specific language governing permissions and limitations, + * under the License., + */, +, +package org.elasticsearch.transport;, +, +import org.apache.logging.log4j.LogManager;, +import org.apache.logging.log4j.Logger;, +import org.apache.logging.log4j.message.ParameterizedMessage;, +import org.elasticsearch.Version;, +import org.elasticsearch.common.breaker.CircuitBreaker;, +import org.elasticsearch.common.bytes.BytesReference;, +import org.elasticsearch.common.collect.MapBuilder;, +import org.elasticsearch.common.io.stream.StreamInput;, +import org.elasticsearch.common.metrics.MeanMetric;, +import org.elasticsearch.common.transport.TransportAddress;, +import org.elasticsearch.common.util.concurrent.AbstractRunnable;, +import org.elasticsearch.common.util.concurrent.ThreadContext;, +import org.elasticsearch.indices.breaker.CircuitBreakerService;, +import org.elasticsearch.threadpool.ThreadPool;, +, +import java.io.IOException;, +import java.net.InetSocketAddress;, +import java.util.Collections;, +import java.util.Map;, +import java.util.Set;, +, +public class InboundHandler {, +, +    private static final Logger logger = LogManager.getLogger(InboundHandler.class);, +, +    private final MeanMetric readBytesMetric = new MeanMetric();, +    private final ThreadPool threadPool;, +    private final OutboundHandler outboundHandler;, +    private final CircuitBreakerService circuitBreakerService;, +    private final InboundMessage.Reader reader;, +    private final TransportLogger transportLogger;, +    private final TransportHandshaker handshaker;, +    private final TransportKeepAlive keepAlive;, +, +    private final Transport.ResponseHandlers responseHandlers = new Transport.ResponseHandlers();, +    private volatile Map<String, RequestHandlerRegistry<? extends TransportRequest>> requestHandlers = Collections.emptyMap();, +    private volatile TransportMessageListener messageListener = TransportMessageListener.NOOP_LISTENER;, +, +    InboundHandler(ThreadPool threadPool, OutboundHandler outboundHandler, InboundMessage.Reader reader,, +                   CircuitBreakerService circuitBreakerService, TransportLogger transportLogger, TransportHandshaker handshaker,, +                   TransportKeepAlive keepAlive) {, +        this.threadPool = threadPool;, +        this.outboundHandler = outboundHandler;, +        this.circuitBreakerService = circuitBreakerService;, +        this.reader = reader;, +        this.transportLogger = transportLogger;, +        this.handshaker = handshaker;, +        this.keepAlive = keepAlive;, +    }, +, +    synchronized <Request extends TransportRequest> void registerRequestHandler(RequestHandlerRegistry<Request> reg) {, +        if (requestHandlers.containsKey(reg.getAction())) {, +            throw new IllegalArgumentException("transport handlers for action " + reg.getAction() + " is already registered");, +        }, +        requestHandlers = MapBuilder.newMapBuilder(requestHandlers).put(reg.getAction(), reg).immutableMap();, +    }, +, +    final RequestHandlerRegistry<? extends TransportRequest> getRequestHandler(String action) {, +        return requestHandlers.get(action);, +    }, +, +    final Transport.ResponseHandlers getResponseHandlers() {, +        return responseHandlers;, +    }, +, +    MeanMetric getReadBytes() {, +        return readBytesMetric;, +    }, +, +    void setMessageListener(TransportMessageListener listener) {, +        if (messageListener == TransportMessageListener.NOOP_LISTENER) {, +            messageListener = listener;, +        } else {]