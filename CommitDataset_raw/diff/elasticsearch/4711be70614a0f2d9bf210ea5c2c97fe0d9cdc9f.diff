[+++ b/modules/elasticsearch/src/main/java/org/elasticsearch/common/io/stream/LZFStreamOutput.java, +            // just reset here the LZF stream (not the underlying stream, since we might want to read from it), +            _position = 0;, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/common/io/stream/LZFStreamOutput.java, +            // just reset here the LZF stream (not the underlying stream, since we might want to read from it), +            _position = 0;, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/gateway/blobstore/BlobStoreGateway.java, +import org.elasticsearch.common.blobstore.BlobContainer;, +import org.elasticsearch.common.blobstore.BlobMetaData;, +import org.elasticsearch.common.blobstore.BlobPath;, +import org.elasticsearch.common.blobstore.BlobStore;, +import org.elasticsearch.common.blobstore.ImmutableBlobContainer;, +import org.elasticsearch.common.io.stream.CachedStreamOutput;, +import org.elasticsearch.common.io.stream.StreamOutput;, +import org.elasticsearch.common.xcontent.ToXContent;, +import org.elasticsearch.common.xcontent.XContentBuilder;, +import org.elasticsearch.common.xcontent.XContentFactory;, +import org.elasticsearch.common.xcontent.XContentParser;, +import org.elasticsearch.common.xcontent.XContentType;, +        CachedStreamOutput.Entry cachedEntry = CachedStreamOutput.popEntry();, +            StreamOutput out;, +            if (compress) {, +                out = cachedEntry.cachedLZFBytes();, +            } else {, +                out = cachedEntry.cachedBytes();, +            }, +            XContentBuilder builder = XContentFactory.contentBuilder(XContentType.JSON, out);, +            builder.close();, +            metaDataBlobContainer.writeBlob(newMetaData, new ByteArrayInputStream(cachedEntry.bytes().unsafeByteArray(), 0, cachedEntry.bytes().size()), cachedEntry.bytes().size());, +        } finally {, +            CachedStreamOutput.pushEntry(cachedEntry);, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/common/io/stream/LZFStreamOutput.java, +            // just reset here the LZF stream (not the underlying stream, since we might want to read from it), +            _position = 0;, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/gateway/blobstore/BlobStoreGateway.java, +import org.elasticsearch.common.blobstore.BlobContainer;, +import org.elasticsearch.common.blobstore.BlobMetaData;, +import org.elasticsearch.common.blobstore.BlobPath;, +import org.elasticsearch.common.blobstore.BlobStore;, +import org.elasticsearch.common.blobstore.ImmutableBlobContainer;, +import org.elasticsearch.common.io.stream.CachedStreamOutput;, +import org.elasticsearch.common.io.stream.StreamOutput;, +import org.elasticsearch.common.xcontent.ToXContent;, +import org.elasticsearch.common.xcontent.XContentBuilder;, +import org.elasticsearch.common.xcontent.XContentFactory;, +import org.elasticsearch.common.xcontent.XContentParser;, +import org.elasticsearch.common.xcontent.XContentType;, +        CachedStreamOutput.Entry cachedEntry = CachedStreamOutput.popEntry();, +            StreamOutput out;, +            if (compress) {, +                out = cachedEntry.cachedLZFBytes();, +            } else {, +                out = cachedEntry.cachedBytes();, +            }, +            XContentBuilder builder = XContentFactory.contentBuilder(XContentType.JSON, out);, +            builder.close();, +            metaDataBlobContainer.writeBlob(newMetaData, new ByteArrayInputStream(cachedEntry.bytes().unsafeByteArray(), 0, cachedEntry.bytes().size()), cachedEntry.bytes().size());, +        } finally {, +            CachedStreamOutput.pushEntry(cachedEntry);, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/gateway/local/LocalGateway.java, +import org.elasticsearch.cluster.routing.IndexRoutingTable;, +import org.elasticsearch.cluster.routing.IndexShardRoutingTable;, +import org.elasticsearch.cluster.routing.MutableShardRouting;, +import org.elasticsearch.cluster.routing.RoutingNode;, +import org.elasticsearch.cluster.routing.ShardRoutingState;, +import org.elasticsearch.common.xcontent.ToXContent;, +import org.elasticsearch.common.xcontent.XContentBuilder;, +import org.elasticsearch.common.xcontent.XContentFactory;, +import org.elasticsearch.common.xcontent.XContentParser;, +import org.elasticsearch.common.xcontent.XContentType;, +import java.io.File;, +import java.io.FileInputStream;, +import java.io.FileOutputStream;, +import java.io.FilenameFilter;, +import java.io.IOException;, +import java.io.OutputStream;, +                        File stateFile = new File(location, "metadata-" + event.state().version());, +                        OutputStream fos = new FileOutputStream(stateFile);, +                        if (compress) {, +                            fos = new LZFOutputStream(fos);, +                        }, +                        XContentBuilder xContentBuilder = XContentFactory.contentBuilder(XContentType.JSON, fos);, +                        xContentBuilder.close();, +                        File stateFile = new File(location, "shards-" + event.state().version());, +                        OutputStream fos = new FileOutputStream(stateFile);, +                        if (compress) {, +                            fos = new LZFOutputStream(fos);, +                        }, +, +                        XContentBuilder xContentBuilder = XContentFactory.contentBuilder(XContentType.JSON, fos);, +                        xContentBuilder.close();]