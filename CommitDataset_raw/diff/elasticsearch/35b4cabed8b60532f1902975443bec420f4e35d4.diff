[+++ b/modules/elasticsearch/src/main/java/org/elasticsearch/cluster/action/shard/ShardStateAction.java, +import org.elasticsearch.common.util.concurrent.jsr166y.LinkedTransferQueue;, +import org.elasticsearch.transport.BaseTransportRequestHandler;, +import org.elasticsearch.transport.TransportChannel;, +import org.elasticsearch.transport.TransportException;, +import org.elasticsearch.transport.TransportService;, +import org.elasticsearch.transport.VoidTransportResponseHandler;, +import java.util.ArrayList;, +import java.util.List;, +import java.util.concurrent.BlockingQueue;, +    private final BlockingQueue<ShardRouting> startedShardsQueue = new LinkedTransferQueue<ShardRouting>();, +, +        // buffer shard started requests, and the state update tasks will simply drain it, +        // this is to optimize the number of "started" events we generate, and batch them, +        // possibly, we can do time based batching as well, but usually, we would want to, +        // process started events as fast as possible, to make shards available, +        startedShardsQueue.add(shardRouting);, +, +, +                List<ShardRouting> shards = new ArrayList<ShardRouting>();, +                startedShardsQueue.drainTo(shards);, +, +                // nothing to process (a previous event has process it already), +                if (shards.isEmpty()) {, +                    return currentState;, +                }, +, +, +                for (int i = 0; i < shards.size(); i++) {, +                    ShardRouting shardRouting = shards.get(i);, +                        shards.remove(i);, +                    } else {, +                                    shards.remove(i);, +                                }, +                            }, +                        }, +                    }, +                }, +, +                if (shards.isEmpty()) {, +, +                    logger.debug("applying started shards {}, reason [{}]", shards, reason);, +                RoutingAllocation.Result routingResult = shardsAllocation.applyStartedShards(currentState, shards);]