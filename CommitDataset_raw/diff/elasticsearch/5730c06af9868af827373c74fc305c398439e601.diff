[+++ b/src/main/java/org/elasticsearch/common/util/MultiDataPathUpgrader.java, +/*, + * Licensed to Elasticsearch under one or more contributor, + * license agreements. See the NOTICE file distributed with, + * this work for additional information regarding copyright, + * ownership. Elasticsearch licenses this file to you under, + * the Apache License, Version 2.0 (the "License"); you may, + * not use this file except in compliance with the License., + * You may obtain a copy of the License at, + *, + *    http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing,, + * software distributed under the License is distributed on an, + * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY, + * KIND, either express or implied.  See the License for the, + * specific language governing permissions and limitations, + * under the License., + */, +package org.elasticsearch.common.util;, +, +import com.google.common.base.Charsets;, +import com.google.common.collect.Sets;, +import com.google.common.primitives.Ints;, +import org.apache.lucene.index.CheckIndex;, +import org.apache.lucene.index.IndexWriter;, +import org.apache.lucene.store.Directory;, +import org.apache.lucene.store.Lock;, +import org.apache.lucene.store.SimpleFSDirectory;, +import org.apache.lucene.util.IOUtils;, +import org.elasticsearch.ElasticsearchIllegalStateException;, +import org.elasticsearch.cluster.metadata.IndexMetaData;, +import org.elasticsearch.common.io.FileSystemUtils;, +import org.elasticsearch.common.io.stream.BytesStreamOutput;, +import org.elasticsearch.common.logging.ESLogger;, +import org.elasticsearch.common.logging.Loggers;, +import org.elasticsearch.common.unit.ByteSizeValue;, +import org.elasticsearch.env.NodeEnvironment;, +import org.elasticsearch.env.ShardLock;, +import org.elasticsearch.gateway.MetaDataStateFormat;, +import org.elasticsearch.index.Index;, +import org.elasticsearch.index.shard.*;, +, +import java.io.IOException;, +import java.io.PrintStream;, +import java.nio.file.*;, +import java.nio.file.attribute.BasicFileAttributes;, +import java.util.*;, +, +/**, + */, +public class MultiDataPathUpgrader {, +, +    private final NodeEnvironment nodeEnvironment;, +    private final ESLogger logger = Loggers.getLogger(getClass());, +, +, +    /**, +     * Creates a new upgrader instance, +     * @param nodeEnvironment the node env to operate on., +     *, +     */, +    public MultiDataPathUpgrader(NodeEnvironment nodeEnvironment) {, +        this.nodeEnvironment = nodeEnvironment;, +    }, +, +, +    /**, +     * Upgrades the given shard Id from multiple shard paths into the given target path., +     *, +     * @see #pickShardPath(org.elasticsearch.index.shard.ShardId), +     */, +    public void upgrade(ShardId shard, ShardPath targetPath) throws IOException {, +        final Path[] paths = nodeEnvironment.availableShardPaths(shard); // custom data path doesn't need upgrading, +        if (isTargetPathConfigured(paths, targetPath) == false) {, +            throw new IllegalArgumentException("shard path must be one of the shards data paths");, +        }, +        assert needsUpgrading(shard) : "Should not upgrade a path that needs no upgrading";, +        logger.info("{} upgrading multi data dir to {}", shard, targetPath.getDataPath());, +        final ShardStateMetaData loaded = ShardStateMetaData.FORMAT.loadLatestState(logger, paths);, +        if (loaded == null) {, +            throw new IllegalStateException(shard + " no shard state found in any of: " + Arrays.toString(paths) + " please check and remove them if possible");, +        }, +        logger.info("{} loaded shard state {}", shard, loaded);, +, +        ShardStateMetaData.FORMAT.write(loaded, loaded.version, targetPath.getShardStatePath());, +        Files.createDirectories(targetPath.resolveIndex());, +        try (SimpleFSDirectory directory = new SimpleFSDirectory(targetPath.resolveIndex())) {, +            try (final Lock lock = directory.makeLock(IndexWriter.WRITE_LOCK_NAME)) {, +                if (lock.obtain(5000)) {, +                    upgradeFiles(shard, targetPath, targetPath.resolveIndex(), ShardPath.INDEX_FOLDER_NAME, paths);, +                } else {, +                    throw new IllegalStateException("Can't obtain lock on " + targetPath.resolveIndex());, +                }, +            }, +        }, +, +, +        upgradeFiles(shard, targetPath, targetPath.resolveTranslog(), ShardPath.TRANSLOG_FOLDER_NAME, paths);, +]