[+++ b/core/src/main/java/org/elasticsearch/search/SearchModule.java, +import org.elasticsearch.search.aggregations.bucket.histogram.DateHistogramAggregatorBuilder;, +import org.elasticsearch.search.aggregations.bucket.histogram.HistogramAggregatorBuilder;, +        registerAggregation(HistogramAggregatorBuilder::new, new HistogramParser(), HistogramAggregatorBuilder.AGGREGATION_NAME_FIELD);, +        registerAggregation(DateHistogramAggregatorBuilder::new, new DateHistogramParser(),, +                DateHistogramAggregatorBuilder.AGGREGATION_NAME_FIELD);, +++ b/core/src/main/java/org/elasticsearch/search/SearchModule.java, +import org.elasticsearch.search.aggregations.bucket.histogram.DateHistogramAggregatorBuilder;, +import org.elasticsearch.search.aggregations.bucket.histogram.HistogramAggregatorBuilder;, +        registerAggregation(HistogramAggregatorBuilder::new, new HistogramParser(), HistogramAggregatorBuilder.AGGREGATION_NAME_FIELD);, +        registerAggregation(DateHistogramAggregatorBuilder::new, new DateHistogramParser(),, +                DateHistogramAggregatorBuilder.AGGREGATION_NAME_FIELD);, +++ b/core/src/main/java/org/elasticsearch/search/aggregations/bucket/histogram/AbstractHistogramBuilder.java, +, +    protected AbstractHistogramBuilder(String name, InternalHistogram.Factory<?> histogramFactory) {, +    /**, +     * Read from a stream., +     */, +    protected AbstractHistogramBuilder(StreamInput in, InternalHistogram.Factory<?> histogramFactory) throws IOException {, +        super(in, histogramFactory.type(), ValuesSourceType.NUMERIC, histogramFactory.valueType());, +        interval = in.readVLong();, +        offset = in.readLong();, +        if (in.readBoolean()) {, +            order = InternalOrder.Streams.readOrder(in);, +        }, +        keyed = in.readBoolean();, +        minDocCount = in.readVLong();, +        if (in.readBoolean()) {, +            extendedBounds = ExtendedBounds.readFrom(in);, +        }, +    }, +, +    @Override, +    protected void innerWriteTo(StreamOutput out) throws IOException {, +        out.writeVLong(interval);, +        out.writeLong(offset);, +        boolean hasOrder = order != null;, +        out.writeBoolean(hasOrder);, +        if (hasOrder) {, +            InternalOrder.Streams.writeOrder(order, out);, +        }, +        out.writeBoolean(keyed);, +        out.writeVLong(minDocCount);, +        boolean hasExtendedBounds = extendedBounds != null;, +        out.writeBoolean(hasExtendedBounds);, +        if (hasExtendedBounds) {, +            extendedBounds.writeTo(out);, +        }, +    }, +, +    @Override, +    protected boolean usesNewStyleSerialization() {, +        return true;, +    }, +, +++ b/core/src/main/java/org/elasticsearch/search/SearchModule.java, +import org.elasticsearch.search.aggregations.bucket.histogram.DateHistogramAggregatorBuilder;, +import org.elasticsearch.search.aggregations.bucket.histogram.HistogramAggregatorBuilder;, +        registerAggregation(HistogramAggregatorBuilder::new, new HistogramParser(), HistogramAggregatorBuilder.AGGREGATION_NAME_FIELD);, +        registerAggregation(DateHistogramAggregatorBuilder::new, new DateHistogramParser(),, +                DateHistogramAggregatorBuilder.AGGREGATION_NAME_FIELD);, +++ b/core/src/main/java/org/elasticsearch/search/aggregations/bucket/histogram/AbstractHistogramBuilder.java, +, +    protected AbstractHistogramBuilder(String name, InternalHistogram.Factory<?> histogramFactory) {, +    /**, +     * Read from a stream., +     */, +    protected AbstractHistogramBuilder(StreamInput in, InternalHistogram.Factory<?> histogramFactory) throws IOException {, +        super(in, histogramFactory.type(), ValuesSourceType.NUMERIC, histogramFactory.valueType());, +        interval = in.readVLong();, +        offset = in.readLong();, +        if (in.readBoolean()) {, +            order = InternalOrder.Streams.readOrder(in);, +        }, +        keyed = in.readBoolean();, +        minDocCount = in.readVLong();, +        if (in.readBoolean()) {, +            extendedBounds = ExtendedBounds.readFrom(in);, +        }, +    }, +, +    @Override, +    protected void innerWriteTo(StreamOutput out) throws IOException {, +        out.writeVLong(interval);, +        out.writeLong(offset);, +        boolean hasOrder = order != null;, +        out.writeBoolean(hasOrder);, +        if (hasOrder) {, +            InternalOrder.Streams.writeOrder(order, out);, +        }, +        out.writeBoolean(keyed);, +        out.writeVLong(minDocCount);, +        boolean hasExtendedBounds = extendedBounds != null;, +        out.writeBoolean(hasExtendedBounds);, +        if (hasExtendedBounds) {, +            extendedBounds.writeTo(out);, +        }, +    }, +, +    @Override]