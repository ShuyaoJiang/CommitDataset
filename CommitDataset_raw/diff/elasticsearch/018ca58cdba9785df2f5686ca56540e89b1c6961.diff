[+++ b/src/main/java/org/elasticsearch/common/xcontent/support/XContentMapValues.java, +        if (includes.length == 0 && excludes.length == 0) {, +            into.putAll(map);, +            return;, +        }, +            boolean exactIncludeMatch = false;, +                    // check for prefix as well to see if we need to zero in, something like: obj1.arr1.*, +                    if (include.startsWith(path)) {, +                        if (include.length() == path.length()) {, +                            atLeastOnOneIncludeMatched = true;, +                            exactIncludeMatch = true;, +                            break;, +                        } else if (include.length() > path.length() && include.charAt(path.length()) == '.') {, +                            // include might may match deeper paths. Dive deeper., +                            atLeastOnOneIncludeMatched = true;, +                            break;, +                        }, +                    }, +                    if (Regex.simpleMatch(include, path)) {, +                // if we had an exact match, we want give deeper excludes their chance, +                filter((Map<String, Object>) entry.getValue(), innerInto, exactIncludeMatch ? Strings.EMPTY_ARRAY : includes, excludes, sb);, +                // if we had an exact match, we want give deeper excludes their chance, +                filter(list, innerInto, exactIncludeMatch ? Strings.EMPTY_ARRAY : includes, excludes, sb);, +        if (includes.length == 0 && excludes.length == 0) {, +            to.addAll(from);, +            return;, +        }, +, +++ b/src/main/java/org/elasticsearch/common/xcontent/support/XContentMapValues.java, +        if (includes.length == 0 && excludes.length == 0) {, +            into.putAll(map);, +            return;, +        }, +            boolean exactIncludeMatch = false;, +                    // check for prefix as well to see if we need to zero in, something like: obj1.arr1.*, +                    if (include.startsWith(path)) {, +                        if (include.length() == path.length()) {, +                            atLeastOnOneIncludeMatched = true;, +                            exactIncludeMatch = true;, +                            break;, +                        } else if (include.length() > path.length() && include.charAt(path.length()) == '.') {, +                            // include might may match deeper paths. Dive deeper., +                            atLeastOnOneIncludeMatched = true;, +                            break;, +                        }, +                    }, +                    if (Regex.simpleMatch(include, path)) {, +                // if we had an exact match, we want give deeper excludes their chance, +                filter((Map<String, Object>) entry.getValue(), innerInto, exactIncludeMatch ? Strings.EMPTY_ARRAY : includes, excludes, sb);, +                // if we had an exact match, we want give deeper excludes their chance, +                filter(list, innerInto, exactIncludeMatch ? Strings.EMPTY_ARRAY : includes, excludes, sb);, +        if (includes.length == 0 && excludes.length == 0) {, +            to.addAll(from);, +            return;, +        }, +, +++ b/src/test/java/org/elasticsearch/test/unit/common/xcontent/support/XContentMapValuesTests.java, +import java.util.Arrays;, +import java.util.HashMap;, +import static org.hamcrest.core.IsEqual.equalTo;, +        assertThat(filter.size(), equalTo(1));, +, +    @Test, +    public void prefixedNamesFilteringTest() {, +        Map<String, Object> map = new HashMap<String, Object>();, +        map.put("obj", "value");, +        map.put("obj_name", "value_name");, +        Map<String, Object> filterdMap = XContentMapValues.filter(map, new String[]{"obj_name"}, Strings.EMPTY_ARRAY);, +        assertThat(filterdMap.size(), equalTo(1));, +        assertThat((String) filterdMap.get("obj_name"), equalTo("value_name"));, +    }, +, +, +    @Test, +    @SuppressWarnings("unchecked"), +    public void nestedFilteringTest() {, +        Map<String, Object> map = new HashMap<String, Object>();, +        map.put("field", "value");, +        map.put("array",, +                Arrays.asList(, +                        1,, +                        new HashMap<String, Object>() {{, +                            put("nested", 2);, +                            put("nested_2", 3);, +                        }}));, +        Map<String, Object> falteredMap = XContentMapValues.filter(map, new String[]{"array.nested"}, Strings.EMPTY_ARRAY);, +        assertThat(falteredMap.size(), equalTo(1));, +, +        // Selecting members of objects within arrays (ex. [ 1, { nested: "value"} ])  always returns all values in the array (1 in the ex), +        // this is expected behavior as this types of objects are not supported in ES, +        assertThat((Integer) ((List) falteredMap.get("array")).get(0), equalTo(1));, +        assertThat(((Map<String, Object>) ((List) falteredMap.get("array")).get(1)).size(), equalTo(1));, +        assertThat((Integer) ((Map<String, Object>) ((List) falteredMap.get("array")).get(1)).get("nested"), equalTo(2));, +, +        falteredMap = XContentMapValues.filter(map, new String[]{"array.*"}, Strings.EMPTY_ARRAY);, +        assertThat(falteredMap.size(), equalTo(1));, +        assertThat((Integer) ((List) falteredMap.get("array")).get(0), equalTo(1));, +        assertThat(((Map<String, Object>) ((List) falteredMap.get("array")).get(1)).size(), equalTo(2));, +, +        map.clear();]