[+++ b/libs/nio/src/main/java/org/elasticsearch/nio/EventHandler.java, +     * This method is called when a task or listener attached to a channel operation throws an exception., +    protected void taskException(Exception exception) {, +++ b/libs/nio/src/main/java/org/elasticsearch/nio/EventHandler.java, +     * This method is called when a task or listener attached to a channel operation throws an exception., +    protected void taskException(Exception exception) {, +++ b/libs/nio/src/main/java/org/elasticsearch/nio/NioSelector.java, +import java.util.concurrent.TimeUnit;, +    private final TaskScheduler taskScheduler = new TaskScheduler();, +    public TaskScheduler getTaskScheduler() {, +        return taskScheduler;, +    }, +, +            long nanosUntilNextTask = taskScheduler.nanosUntilNextTask(System.nanoTime());, +            int ready;, +            if (nanosUntilNextTask == 0) {, +                ready = selector.selectNow();, +            } else {, +                long millisUntilNextTask = TimeUnit.NANOSECONDS.toMillis(nanosUntilNextTask);, +                // Only select until the next task needs to be run. Do not select with a value of 0 because, +                // that blocks without a timeout., +                ready = selector.select(Math.min(300, Math.max(millisUntilNextTask, 1)));, +            }, +, +            handleScheduledTasks(System.nanoTime());, +    private void handleScheduledTasks(long nanoTime) {, +        Runnable task;, +        while ((task = taskScheduler.pollTask(nanoTime)) != null) {, +            try {, +                task.run();, +            } catch (Exception e) {, +                eventHandler.taskException(e);, +            }, +        }, +    }, +, +        if (isOnCurrentThread() == false) {, +    }, +            eventHandler.taskException(e);, +            eventHandler.taskException(e);, +++ b/libs/nio/src/main/java/org/elasticsearch/nio/EventHandler.java, +     * This method is called when a task or listener attached to a channel operation throws an exception., +    protected void taskException(Exception exception) {, +++ b/libs/nio/src/main/java/org/elasticsearch/nio/NioSelector.java, +import java.util.concurrent.TimeUnit;, +    private final TaskScheduler taskScheduler = new TaskScheduler();, +    public TaskScheduler getTaskScheduler() {, +        return taskScheduler;, +    }, +, +            long nanosUntilNextTask = taskScheduler.nanosUntilNextTask(System.nanoTime());, +            int ready;, +            if (nanosUntilNextTask == 0) {, +                ready = selector.selectNow();, +            } else {, +                long millisUntilNextTask = TimeUnit.NANOSECONDS.toMillis(nanosUntilNextTask);, +                // Only select until the next task needs to be run. Do not select with a value of 0 because, +                // that blocks without a timeout., +                ready = selector.select(Math.min(300, Math.max(millisUntilNextTask, 1)));, +            }, +, +            handleScheduledTasks(System.nanoTime());, +    private void handleScheduledTasks(long nanoTime) {, +        Runnable task;, +        while ((task = taskScheduler.pollTask(nanoTime)) != null) {, +            try {, +                task.run();, +            } catch (Exception e) {, +                eventHandler.taskException(e);, +            }, +        }, +    }, +, +        if (isOnCurrentThread() == false) {, +    }, +            eventHandler.taskException(e);, +            eventHandler.taskException(e);, +++ b/libs/nio/src/main/java/org/elasticsearch/nio/SocketChannelContext.java, +    protected void setCloseNow() {, +        closeNow = true;, +    }, +++ b/libs/nio/src/main/java/org/elasticsearch/nio/EventHandler.java, +     * This method is called when a task or listener attached to a channel operation throws an exception., +    protected void taskException(Exception exception) {, +++ b/libs/nio/src/main/java/org/elasticsearch/nio/NioSelector.java, +import java.util.concurrent.TimeUnit;, +    private final TaskScheduler taskScheduler = new TaskScheduler();, +    public TaskScheduler getTaskScheduler() {, +        return taskScheduler;, +    }, +, +            long nanosUntilNextTask = taskScheduler.nanosUntilNextTask(System.nanoTime());, +            int ready;, +            if (nanosUntilNextTask == 0) {, +                ready = selector.selectNow();, +            } else {, +                long millisUntilNextTask = TimeUnit.NANOSECONDS.toMillis(nanosUntilNextTask);, +                // Only select until the next task needs to be run. Do not select with a value of 0 because, +                // that blocks without a timeout., +                ready = selector.select(Math.min(300, Math.max(millisUntilNextTask, 1)));]