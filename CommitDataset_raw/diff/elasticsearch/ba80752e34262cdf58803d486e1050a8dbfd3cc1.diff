[+++ b/TESTING.asciidoc, +, +== Building with extra plugins, +Additional plugins may be built alongside elasticsearch, where their, +dependency on elasticsearch will be substituted with the local elasticsearch, +build. To add your plugin, check it out into the extra-plugins directory., +The build will automatically pick it up. You can verify the plugin is, +included as part of the build by checking the projects of the build., +, +---------------------------------------------------------------------------, +gradle projects, +---------------------------------------------------------------------------, +, +++ b/TESTING.asciidoc, +, +== Building with extra plugins, +Additional plugins may be built alongside elasticsearch, where their, +dependency on elasticsearch will be substituted with the local elasticsearch, +build. To add your plugin, check it out into the extra-plugins directory., +The build will automatically pick it up. You can verify the plugin is, +included as part of the build by checking the projects of the build., +, +---------------------------------------------------------------------------, +gradle projects, +---------------------------------------------------------------------------, +, +++ b/build.gradle, +      javadoc = true, +  project.afterEvaluate {, +    // ignore missing javadocs, +    tasks.withType(Javadoc) { Javadoc javadoc ->, +      // the -quiet here is because of a bug in gradle, in that adding a string option, +      // by itself is not added to the options. By adding quiet, both this option and, +      // the "value" -quiet is added, separated by a space. This is ok since the javadoc, +      // command already adds -quiet, so we are just duplicating it, +      // see https://discuss.gradle.org/t/add-custom-javadoc-option-that-does-not-take-an-argument/5959, +      javadoc.options.addStringOption('Xdoclint:all,-missing', '-quiet'), +    }, +  ext.projectSubstitutions = [, +    "org.elasticsearch:rest-api-spec:${version}": ':rest-api-spec',, +    "org.elasticsearch:elasticsearch:${version}": ':core',, +    "org.elasticsearch:test-framework:${version}": ':test-framework',, +    "org.elasticsearch.distribution.zip:elasticsearch:${version}": ':distribution:zip',, +    "org.elasticsearch.distribution.tar:elasticsearch:${version}": ':distribution:tar', +  ], +  configurations.all {, +    resolutionStrategy.dependencySubstitution { DependencySubstitutions subs ->, +      projectSubstitutions.each { k,v ->, +        subs.substitute(subs.module(k)).with(subs.project(v)), +      }, +    }, +  }, +}, +, +// Ensure similar tasks in dependent projects run first. The projectsEvaluated here is, +// important because, while dependencies.all will pickup future dependencies,, +// it is not necessarily true that the task exists in both projects at the time, +// the dependency is added., +gradle.projectsEvaluated {, +  allprojects {, +    if (project.path == ':test-framework') {, +      // :test-framework:test cannot run before and after :core:test, +      return, +    }, +    configurations.all {, +      dependencies.all { Dependency dep ->, +        Project upstreamProject = null, +        if (dep instanceof ProjectDependency) {, +          upstreamProject = dep.dependencyProject, +        } else {, +          // gradle doesn't apply substitutions until resolve time, so they won't, +          // show up as a ProjectDependency above, +          String substitution = projectSubstitutions.get("${dep.group}:${dep.name}:${dep.version}"), +          if (substitution != null) {, +            upstreamProject = findProject(substitution), +          }, +        }, +        if (upstreamProject != null) {, +          if (project.path == upstreamProject.path) {, +            // TODO: distribution integ tests depend on themselves (!), fix that, +            return, +          }, +          for (String taskName : ['test', 'integTest']) {, +            Task task = project.tasks.findByName(taskName), +            Task upstreamTask = upstreamProject.tasks.findByName(taskName), +            if (task != null && upstreamTask != null) {, +              task.mustRunAfter(upstreamTask), +            }, +          }, +    languageLevel = org.elasticsearch.gradle.BuildPlugin.minimumJava.toString(), +// Make sure gradle idea was run before running anything in intellij (including import)., +File ideaMarker = new File(projectDir, '.local-idea-is-configured'), +tasks.idea.doLast {, +  ideaMarker.setText('', 'UTF-8'), +if (System.getProperty('idea.active') != null && ideaMarker.exists() == false) {, +  throw new GradleException('You must run gradle idea from the root of elasticsearch before importing into IntelliJ'), +, +  impliesSubProjects = true, +++ b/TESTING.asciidoc, +]