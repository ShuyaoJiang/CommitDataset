[+++ b/modules/elasticsearch/src/main/java/org/elasticsearch/env/NodeEnvironment.java, +    public File indicesLocation() {, +        return new File(nodeDataLocation(), "indices");, +    }, +, +        return new File(indicesLocation(), index.name());, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/env/NodeEnvironment.java, +    public File indicesLocation() {, +        return new File(nodeDataLocation(), "indices");, +    }, +, +        return new File(indicesLocation(), index.name());, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/indices/store/IndicesStore.java, +import org.elasticsearch.common.io.FileSystemUtils;, +import org.elasticsearch.env.NodeEnvironment;, +import java.io.File;, +, +    private final NodeEnvironment nodeEnv;, +, +    @Inject public IndicesStore(Settings settings, NodeEnvironment nodeEnv, IndicesService indicesService, ClusterService clusterService) {, +        this.nodeEnv = nodeEnv;, +, +        // do the reverse, and delete dangling indices that might remain on that node, +        // this can happen when deleting a closed index, or when a node joins and it has deleted indices, +        if (nodeEnv.hasNodeFile()) {, +            File[] files = nodeEnv.indicesLocation().listFiles();, +            if (files != null) {, +                for (File file : files) {, +                    // if we have the index on the metadata, don't delete it, +                    if (event.state().metaData().hasIndex(file.getName())) {, +                        continue;, +                    }, +                    logger.debug("[{}] deleting index that is no longer in the cluster meta_date", file.getName());, +                    FileSystemUtils.deleteRecursively(file);, +                }, +            }, +        }]