[+++ b/src/main/java/org/elasticsearch/index/shard/IndexShard.java, +     *, +            throw new ElasticsearchIllegalStateException("Can't delete shard state on an active shard");, +                // delete the shard state so this folder will not be reused, +                MetaDataStateFormat.deleteMetaState(nodeEnv.shardPaths(shardId));, +            } catch (IOException e) {, +                logger.warn("failed to delete shard state", e);, +            } finally {, +++ b/src/main/java/org/elasticsearch/index/shard/IndexShard.java, +     *, +            throw new ElasticsearchIllegalStateException("Can't delete shard state on an active shard");, +                // delete the shard state so this folder will not be reused, +                MetaDataStateFormat.deleteMetaState(nodeEnv.shardPaths(shardId));, +            } catch (IOException e) {, +                logger.warn("failed to delete shard state", e);, +            } finally {, +++ b/src/main/java/org/elasticsearch/index/store/Store.java, +     * @throws IndexFormatTooOldException  if the lucene index is too old to be opened., +     * @throws IndexFormatTooNewException  if the lucene index is too new to be opened., +     * @throws IndexFormatTooOldException  if the lucene index is too old to be opened., +     * @throws IndexFormatTooNewException  if the lucene index is too new to be opened., +     * @throws IndexFormatTooOldException  if the lucene index is too old to be opened., +     * @throws IndexFormatTooNewException  if the lucene index is too new to be opened., +++ b/src/main/java/org/elasticsearch/index/shard/IndexShard.java, +     *, +            throw new ElasticsearchIllegalStateException("Can't delete shard state on an active shard");, +                // delete the shard state so this folder will not be reused, +                MetaDataStateFormat.deleteMetaState(nodeEnv.shardPaths(shardId));, +            } catch (IOException e) {, +                logger.warn("failed to delete shard state", e);, +            } finally {, +++ b/src/main/java/org/elasticsearch/index/store/Store.java, +     * @throws IndexFormatTooOldException  if the lucene index is too old to be opened., +     * @throws IndexFormatTooNewException  if the lucene index is too new to be opened., +     * @throws IndexFormatTooOldException  if the lucene index is too old to be opened., +     * @throws IndexFormatTooNewException  if the lucene index is too new to be opened., +     * @throws IndexFormatTooOldException  if the lucene index is too old to be opened., +     * @throws IndexFormatTooNewException  if the lucene index is too new to be opened., +++ b/src/main/java/org/elasticsearch/indices/recovery/RecoveryTarget.java, +        Map<String, StoreFileMetaData> existingFiles;, +        } catch (IOException e) {, +            logger.warn("error while listing local files, recover as if there are none", e);, +            existingFiles = Store.MetadataSnapshot.EMPTY.asMap();, +            // this will be logged as warning later on..., +            logger.trace("unexpected error while listing local files, failing recovery", e);, +++ b/src/main/java/org/elasticsearch/index/shard/IndexShard.java, +     *, +            throw new ElasticsearchIllegalStateException("Can't delete shard state on an active shard");, +                // delete the shard state so this folder will not be reused, +                MetaDataStateFormat.deleteMetaState(nodeEnv.shardPaths(shardId));, +            } catch (IOException e) {, +                logger.warn("failed to delete shard state", e);, +            } finally {, +++ b/src/main/java/org/elasticsearch/index/store/Store.java, +     * @throws IndexFormatTooOldException  if the lucene index is too old to be opened., +     * @throws IndexFormatTooNewException  if the lucene index is too new to be opened., +     * @throws IndexFormatTooOldException  if the lucene index is too old to be opened., +     * @throws IndexFormatTooNewException  if the lucene index is too new to be opened., +     * @throws IndexFormatTooOldException  if the lucene index is too old to be opened., +     * @throws IndexFormatTooNewException  if the lucene index is too new to be opened., +++ b/src/main/java/org/elasticsearch/indices/recovery/RecoveryTarget.java, +        Map<String, StoreFileMetaData> existingFiles;, +        } catch (IOException e) {, +            logger.warn("error while listing local files, recover as if there are none", e);, +            existingFiles = Store.MetadataSnapshot.EMPTY.asMap();, +            // this will be logged as warning later on..., +            logger.trace("unexpected error while listing local files, failing recovery", e);, +++ b/src/test/java/org/elasticsearch/index/store/CorruptedFileTest.java, +import org.elasticsearch.test.junit.annotations.TestLogging;, +    @TestLogging("indices.recovery:TRACE"), +        // have enough space for 3 copies, +        internalCluster().ensureAtLeastNumDataNodes(3);, +        if (cluster().numDataNodes() == 3) {, +            logger.info("--> cluster has [3] data nodes, corrupted primary will be overwritten");, +, +                        .put(IndexMetaData.SETTING_NUMBER_OF_SHARDS, "1"), +        ShardRouting corruptedShardRouting = corruptRandomPrimaryFile();, +        logger.info("--> {} corrupted", corruptedShardRouting);, +        internalCluster().ensureAtLeastNumDataNodes(2);, +        ShardRouting shardRouting = corruptRandomPrimaryFile();, +        internalCluster().ensureAtLeastNumDataNodes(2);, +        internalCluster().ensureAtLeastNumDataNodes(2);, +        ShardRouting shardRouting = corruptRandomPrimaryFile(false);, +    private ShardRouting corruptRandomPrimaryFile() throws IOException {, +        return corruptRandomPrimaryFile(true);, +    private ShardRouting corruptRandomPrimaryFile(final boolean includePerCommitFiles) throws IOException {]