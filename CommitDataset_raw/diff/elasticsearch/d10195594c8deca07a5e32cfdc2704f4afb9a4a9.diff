[+++ b/docs/reference/sql/functions/type-conversion.asciidoc, +IMPORTANT: Both ANSI SQL and {es-sql} types are supported with the former taking, +precedence. This only affects `FLOAT` which due naming conflict, is interpreted as ANSI SQL , +and thus maps to `double` in {es} as oppose to `float`., +To obtain an {es} `float`, perform casting to its SQL equivalent, `real` type., +, +++ b/docs/reference/sql/functions/type-conversion.asciidoc, +IMPORTANT: Both ANSI SQL and {es-sql} types are supported with the former taking, +precedence. This only affects `FLOAT` which due naming conflict, is interpreted as ANSI SQL , +and thus maps to `double` in {es} as oppose to `float`., +To obtain an {es} `float`, perform casting to its SQL equivalent, `real` type., +, +++ b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/parser/ExpressionBuilder.java, +        String type = visitIdentifier(ctx.identifier());, +        DataType dataType = DataType.fromSqlOrEsType(type);, +        if (dataType == null) {, +            throw new ParsingException(source(ctx), "Does not recognize type [{}]", type);        }, +        return dataType;, +++ b/docs/reference/sql/functions/type-conversion.asciidoc, +IMPORTANT: Both ANSI SQL and {es-sql} types are supported with the former taking, +precedence. This only affects `FLOAT` which due naming conflict, is interpreted as ANSI SQL , +and thus maps to `double` in {es} as oppose to `float`., +To obtain an {es} `float`, perform casting to its SQL equivalent, `real` type., +, +++ b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/parser/ExpressionBuilder.java, +        String type = visitIdentifier(ctx.identifier());, +        DataType dataType = DataType.fromSqlOrEsType(type);, +        if (dataType == null) {, +            throw new ParsingException(source(ctx), "Does not recognize type [{}]", type);        }, +        return dataType;, +++ b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/type/DataType.java, +import java.util.Map.Entry;, +    private static final Map<String, DataType> ODBC_TO_ES = new HashMap<>(36);, +        ODBC_TO_ES.put("SQL_BIT", BOOLEAN);, +        ODBC_TO_ES.put("SQL_TINYINT", BYTE);, +        ODBC_TO_ES.put("SQL_SMALLINT", SHORT);, +        ODBC_TO_ES.put("SQL_INTEGER", INTEGER);, +        ODBC_TO_ES.put("SQL_BIGINT", LONG);, +        ODBC_TO_ES.put("SQL_REAL", FLOAT);, +        ODBC_TO_ES.put("SQL_FLOAT", DOUBLE);, +        ODBC_TO_ES.put("SQL_DOUBLE", DOUBLE);, +        ODBC_TO_ES.put("SQL_DECIMAL", DOUBLE);, +        ODBC_TO_ES.put("SQL_NUMERIC", DOUBLE);, +        ODBC_TO_ES.put("SQL_GUID", KEYWORD);, +        ODBC_TO_ES.put("SQL_CHAR", KEYWORD);, +        ODBC_TO_ES.put("SQL_WCHAR", KEYWORD);, +        ODBC_TO_ES.put("SQL_VARCHAR", TEXT);, +        ODBC_TO_ES.put("SQL_WVARCHAR", TEXT);, +        ODBC_TO_ES.put("SQL_LONGVARCHAR", TEXT);, +        ODBC_TO_ES.put("SQL_WLONGVARCHAR", TEXT);, +        ODBC_TO_ES.put("SQL_BINARY", BINARY);, +        ODBC_TO_ES.put("SQL_VARBINARY", BINARY);, +        ODBC_TO_ES.put("SQL_LONGVARBINARY", BINARY);, +        ODBC_TO_ES.put("SQL_DATE", DATE);, +        ODBC_TO_ES.put("SQL_TIME", DATETIME);, +        ODBC_TO_ES.put("SQL_TIMESTAMP", DATETIME);, +        ODBC_TO_ES.put("SQL_INTERVAL_HOUR_TO_MINUTE", INTERVAL_HOUR_TO_MINUTE);, +        ODBC_TO_ES.put("SQL_INTERVAL_HOUR_TO_SECOND", INTERVAL_HOUR_TO_SECOND);, +        ODBC_TO_ES.put("SQL_INTERVAL_MINUTE_TO_SECOND", INTERVAL_MINUTE_TO_SECOND);, +        ODBC_TO_ES.put("SQL_INTERVAL_MONTH", INTERVAL_MONTH);, +        ODBC_TO_ES.put("SQL_INTERVAL_YEAR", INTERVAL_YEAR);, +        ODBC_TO_ES.put("SQL_INTERVAL_YEAR_TO_MONTH", INTERVAL_YEAR_TO_MONTH);, +        ODBC_TO_ES.put("SQL_INTERVAL_DAY", INTERVAL_DAY);, +        ODBC_TO_ES.put("SQL_INTERVAL_HOUR", INTERVAL_HOUR);, +        ODBC_TO_ES.put("SQL_INTERVAL_MINUTE", INTERVAL_MINUTE);, +        ODBC_TO_ES.put("SQL_INTERVAL_SECOND", INTERVAL_SECOND);, +        ODBC_TO_ES.put("SQL_INTERVAL_DAY_TO_HOUR", INTERVAL_DAY_TO_HOUR);, +        ODBC_TO_ES.put("SQL_INTERVAL_DAY_TO_MINUTE", INTERVAL_DAY_TO_MINUTE);, +        ODBC_TO_ES.put("SQL_INTERVAL_DAY_TO_SECOND", INTERVAL_DAY_TO_SECOND);, +    private static final Map<String, DataType> SQL_TO_ES = new HashMap<>(45);, +    static {, +        // first add ES types, +        for (DataType type : DataType.values()) {, +            if (type.isPrimitive()) {, +                SQL_TO_ES.put(type.name(), type);, +            }, +        }, +, +        // reuse the ODBC definition (without SQL_), +        // note that this will override existing types in particular FLOAT, +        for (Entry<String, DataType> entry : ODBC_TO_ES.entrySet()) {, +            SQL_TO_ES.put(entry.getKey().substring(4), entry.getValue());, +        }, +, +, +        // special ones, +        SQL_TO_ES.put("BOOL", DataType.BOOLEAN);, +        SQL_TO_ES.put("INT", DataType.INTEGER);, +        SQL_TO_ES.put("STRING", DataType.KEYWORD);, +    }, +, +        return ODBC_TO_ES.get(odbcType);, +    }, +    , +    public static DataType fromSqlOrEsType(String typeName) {, +        return SQL_TO_ES.get(typeName.toUpperCase(Locale.ROOT));, +++ b/docs/reference/sql/functions/type-conversion.asciidoc, +IMPORTANT: Both ANSI SQL and {es-sql} types are supported with the former taking, +precedence. This only affects `FLOAT` which due naming conflict, is interpreted as ANSI SQL , +and thus maps to `double` in {es} as oppose to `float`.]