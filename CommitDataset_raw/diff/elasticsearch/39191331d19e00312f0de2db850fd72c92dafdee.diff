[+++ b/server/src/main/java/org/elasticsearch/index/shard/GlobalCheckpointListeners.java, +import org.elasticsearch.common.collect.Tuple;, +import java.util.HashMap;, +import java.util.stream.Collectors;, +    private final Map<GlobalCheckpointListener, Tuple<Long, ScheduledFuture<?>>> listeners = new LinkedHashMap<>();, +     * Add a global checkpoint listener. If the global checkpoint is equal to or above the global checkpoint the listener is waiting for,, +     * then the listener will be asynchronously notified on the executor used to construct this collection of global checkpoint listeners., +     * If the shard is closed then the listener will be asynchronously notified on the executor used to construct this collection of global, +     * checkpoint listeners. The listener will only be notified of at most one event, either the global checkpoint is updated above the, +     * global checkpoint the listener is waiting for, or the shard is closed. A listener must re-register after one of these events to, +     * receive subsequent events. Callers may add a timeout to be notified after if the timeout elapses. In this case, the listener will be, +     * notified with a {@link TimeoutException}. Passing null fo the timeout means no timeout will be associated to the listener., +     * @param waitingForGlobalCheckpoint the current global checkpoint known to the listener, +    synchronized void add(final long waitingForGlobalCheckpoint, final GlobalCheckpointListener listener, final TimeValue timeout) {, +        if (lastKnownGlobalCheckpoint >= waitingForGlobalCheckpoint) {, +                listeners.put(listener, Tuple.tuple(waitingForGlobalCheckpoint, null));, +                        Tuple.tuple(, +                                waitingForGlobalCheckpoint,, +                                                 * We know that this listener has a timeout associated with it (otherwise we would not be, +                                                 * here) so the future component of the return value from remove being null is an indication, +                                                 * that we are not in the map. This can happen if a notification collected us into listeners, +                                                 * to be notified and removed us from the map, and then our scheduled execution occurred, +                                                 * before we could be cancelled by the notification. In this case, our listener here would, +                                                 * not be in the map and we should not fire the timeout logic., +                                                removed = listeners.remove(listener).v2() != null;, +                                        TimeUnit.NANOSECONDS)));, +        return listeners.size();, +        return listeners.get(listener).v2();, +, +        final Map<GlobalCheckpointListener, Tuple<Long, ScheduledFuture<?>>> listenersToNotify;, +        if (globalCheckpoint != UNASSIGNED_SEQ_NO) {, +            listenersToNotify =, +                    listeners, +                            .entrySet(), +                            .stream(), +                            .filter(entry -> entry.getValue().v1() <= globalCheckpoint), +                            .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));, +            listenersToNotify.keySet().forEach(listeners::remove);, +        } else {, +            listenersToNotify = new HashMap<>(listeners);, +            listeners.clear();, +        }, +        if (listenersToNotify.isEmpty() == false) {, +            executor.execute(() ->, +                    listenersToNotify, +                            .forEach((listener, t) -> {, +                                 * We do not want to interrupt any timeouts that fired, these will detect that the listener has been, +                                 * notified and not trigger the timeout., +                                FutureUtils.cancel(t.v2());, +                                notifyListener(listener, globalCheckpoint, e);, +                            }));, +++ b/server/src/main/java/org/elasticsearch/index/shard/GlobalCheckpointListeners.java, +import org.elasticsearch.common.collect.Tuple;, +import java.util.HashMap;, +import java.util.stream.Collectors;, +    private final Map<GlobalCheckpointListener, Tuple<Long, ScheduledFuture<?>>> listeners = new LinkedHashMap<>();, +     * Add a global checkpoint listener. If the global checkpoint is equal to or above the global checkpoint the listener is waiting for,, +     * then the listener will be asynchronously notified on the executor used to construct this collection of global checkpoint listeners., +     * If the shard is closed then the listener will be asynchronously notified on the executor used to construct this collection of global, +     * checkpoint listeners. The listener will only be notified of at most one event, either the global checkpoint is updated above the, +     * global checkpoint the listener is waiting for, or the shard is closed. A listener must re-register after one of these events to, +     * receive subsequent events. Callers may add a timeout to be notified after if the timeout elapses. In this case, the listener will be, +     * notified with a {@link TimeoutException}. Passing null fo the timeout means no timeout will be associated to the listener., +     * @param waitingForGlobalCheckpoint the current global checkpoint known to the listener, +    synchronized void add(final long waitingForGlobalCheckpoint, final GlobalCheckpointListener listener, final TimeValue timeout) {, +        if (lastKnownGlobalCheckpoint >= waitingForGlobalCheckpoint) {, +                listeners.put(listener, Tuple.tuple(waitingForGlobalCheckpoint, null));, +                        Tuple.tuple(, +                                waitingForGlobalCheckpoint,, +                                                 * We know that this listener has a timeout associated with it (otherwise we would not be, +                                                 * here) so the future component of the return value from remove being null is an indication, +                                                 * that we are not in the map. This can happen if a notification collected us into listeners, +                                                 * to be notified and removed us from the map, and then our scheduled execution occurred, +                                                 * before we could be cancelled by the notification. In this case, our listener here would, +                                                 * not be in the map and we should not fire the timeout logic., +                                                removed = listeners.remove(listener).v2() != null;, +                                        TimeUnit.NANOSECONDS)));, +        return listeners.size();, +        return listeners.get(listener).v2();, +, +        final Map<GlobalCheckpointListener, Tuple<Long, ScheduledFuture<?>>> listenersToNotify;, +        if (globalCheckpoint != UNASSIGNED_SEQ_NO) {, +            listenersToNotify =, +                    listeners, +                            .entrySet(), +                            .stream(), +                            .filter(entry -> entry.getValue().v1() <= globalCheckpoint), +                            .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));, +            listenersToNotify.keySet().forEach(listeners::remove);, +        } else {, +            listenersToNotify = new HashMap<>(listeners);, +            listeners.clear();, +        }, +        if (listenersToNotify.isEmpty() == false) {, +            executor.execute(() ->, +                    listenersToNotify, +                            .forEach((listener, t) -> {, +                                 * We do not want to interrupt any timeouts that fired, these will detect that the listener has been, +                                 * notified and not trigger the timeout., +                                FutureUtils.cancel(t.v2());]