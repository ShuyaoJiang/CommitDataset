[+++ b/elasticsearch/x-pack/marvel/src/test/java/org/elasticsearch/marvel/agent/resolver/node/NodeStatsTests.java, +import java.util.Arrays;, +, +            for (String filter : nodeStatsFilters(watcherEnabled)) {, +, +, +    /**, +     * Optionally exclude {@link NodeStatsResolver#FILTERS} that require Watcher to be enabled., +     *, +     * @param includeWatcher {@code true} to keep watcher filters., +     * @return Never {@code null} or empty., +     * @see #watcherEnabled, +     */, +    private static String[] nodeStatsFilters(boolean includeWatcher) {, +        if (includeWatcher) {, +            return NodeStatsResolver.FILTERS;, +        }, +, +        return Arrays.stream(NodeStatsResolver.FILTERS).filter(s -> s.contains("watcher") == false).toArray(String[]::new);, +    }, +, +    @Override, +    protected boolean enableWatcher() {, +        // currently this is the only Monitoring test that expects Watcher to be enabled., +        // Once this becomes the default, then this should be removed., +        return randomBoolean();, +    }, +++ b/elasticsearch/x-pack/marvel/src/test/java/org/elasticsearch/marvel/agent/resolver/node/NodeStatsTests.java, +import java.util.Arrays;, +, +            for (String filter : nodeStatsFilters(watcherEnabled)) {, +, +, +    /**, +     * Optionally exclude {@link NodeStatsResolver#FILTERS} that require Watcher to be enabled., +     *, +     * @param includeWatcher {@code true} to keep watcher filters., +     * @return Never {@code null} or empty., +     * @see #watcherEnabled, +     */, +    private static String[] nodeStatsFilters(boolean includeWatcher) {, +        if (includeWatcher) {, +            return NodeStatsResolver.FILTERS;, +        }, +, +        return Arrays.stream(NodeStatsResolver.FILTERS).filter(s -> s.contains("watcher") == false).toArray(String[]::new);, +    }, +, +    @Override, +    protected boolean enableWatcher() {, +        // currently this is the only Monitoring test that expects Watcher to be enabled., +        // Once this becomes the default, then this should be removed., +        return randomBoolean();, +    }, +++ b/elasticsearch/x-pack/marvel/src/test/java/org/elasticsearch/marvel/test/MarvelIntegTestCase.java, +    /**, +     * Enables individual tests to control the behavior., +     * <p>, +     * Control this by overriding {@link #enableShield()}, which defaults to enabling it randomly., +     */, +    // SCARY: This needs to be static or lots of tests randomly fail, but it's not used statically!, +    /**, +     * Enables individual tests to control the behavior., +     * <p>, +     * Control this by overriding {@link #enableWatcher()}, which defaults to disabling it (this will change!)., +     */, +    protected Boolean watcherEnabled;, +        if (watcherEnabled == null) {, +            watcherEnabled = enableWatcher();, +        }, +, +        logger.debug("--> shield {}", shieldEnabled ? "enabled" : "disabled");, +        logger.debug("--> watcher {}", watcherEnabled ? "enabled" : "disabled");, +, +                .put(XPackPlugin.featureEnabledSetting(Watcher.NAME), watcherEnabled), +     * Override and return {@code false} to force running without Security., +    /**, +     * Override and return {@code false} to force running without Watcher., +     */, +    protected boolean enableWatcher() {, +        // Once randomDefault() becomes the default again, then this should only be actively disabled when, +        // trying to figure out exactly how many indices are at play, +        return false;, +    }, +, +        assertContains(field, values, null);, +    }, +, +    /**, +     * Checks if a field exist in a map of values. If the field contains a dot like 'foo.bar', +     * it checks that 'foo' exists in the map of values and that it points to a sub-map. Then, +     * it recurses to check if 'bar' exists in the sub-map., +     */, +    protected void assertContains(String field, Map<String, Object> values, String parent) {, +            assertTrue("expecting field [" + rebuildName(parent, segment) + "] to be present in monitoring document", fieldExists);, +                assertContains(next, (Map<String, Object>) value, rebuildName(parent, segment));, +            assertTrue("expecting field [" + rebuildName(parent, field) + "] to be present in monitoring document",, +                       values.containsKey(field));, +    private String rebuildName(String parent, String field) {, +        if (Strings.isEmpty(parent)) {]