[+++ b/buildSrc/src/main/groovy/org/elasticsearch/gradle/test/ClusterFormationTasks.groovy, +                ant.exec(executable: 'cmd', spawn: true, dir: home) {, +++ b/buildSrc/src/main/groovy/org/elasticsearch/gradle/test/ClusterFormationTasks.groovy, +                ant.exec(executable: 'cmd', spawn: true, dir: home) {, +++ b/core/src/main/java/org/elasticsearch/action/support/broadcast/node/TransportBroadcastByNodeAction.java, +                // send a request to the shard only if it is assigned to a node that is in the local node's cluster state, +                // a scenario in which a shard can be assigned but to a node that is not in the local node's cluster state, +                // is when the shard is assigned to the master node, the local node has detected the master as failed, +                // and a new master has not yet been elected; in this situation the local node will have removed the, +                // master node from the local cluster state, but the shards assigned to the master will still be in the, +                // routing table as such, +                if (shard.assignedToNode() && nodes.get(shard.currentNodeId()) != null) {, +++ b/buildSrc/src/main/groovy/org/elasticsearch/gradle/test/ClusterFormationTasks.groovy, +                ant.exec(executable: 'cmd', spawn: true, dir: home) {, +++ b/core/src/main/java/org/elasticsearch/action/support/broadcast/node/TransportBroadcastByNodeAction.java, +                // send a request to the shard only if it is assigned to a node that is in the local node's cluster state, +                // a scenario in which a shard can be assigned but to a node that is not in the local node's cluster state, +                // is when the shard is assigned to the master node, the local node has detected the master as failed, +                // and a new master has not yet been elected; in this situation the local node will have removed the, +                // master node from the local cluster state, but the shards assigned to the master will still be in the, +                // routing table as such, +                if (shard.assignedToNode() && nodes.get(shard.currentNodeId()) != null) {, +++ b/core/src/test/java/org/elasticsearch/action/support/broadcast/node/TransportBroadcastByNodeActionTests.java, +    // simulate the master being removed from the cluster but before a new master is elected, +    // as such, the shards assigned to the master will still show up in the cluster state as assigned to a node but, +    // that node will not be in the local cluster state on any node that has detected the master as failing, +    // in this case, such a shard should be treated as unassigned, +    public void testRequestsAreNotSentToFailedMaster() {, +        Request request = new Request(new String[]{TEST_INDEX});, +        PlainActionFuture<Response> listener = new PlainActionFuture<>();, +, +        DiscoveryNode masterNode = clusterService.state().nodes().masterNode();, +        DiscoveryNodes.Builder builder = DiscoveryNodes.builder(clusterService.state().getNodes());, +        builder.remove(masterNode.id());, +, +        clusterService.setState(ClusterState.builder(clusterService.state()).nodes(builder));, +, +        action.new AsyncAction(request, listener).start();, +, +        Map<String, List<CapturingTransport.CapturedRequest>> capturedRequests = transport.capturedRequestsByTargetNode();, +, +        // the master should not be in the list of nodes that requests were sent to, +        ShardsIterator shardIt = clusterService.state().routingTable().allShards(new String[]{TEST_INDEX});, +        Set<String> set = new HashSet<>();, +        for (ShardRouting shard : shardIt.asUnordered()) {, +            if (shard.currentNodeId() != masterNode.id()) {, +                set.add(shard.currentNodeId());, +            }, +        }, +, +        // check a request was sent to the right number of nodes, +        assertEquals(set.size(), capturedRequests.size());, +, +        // check requests were sent to the right nodes, +        assertEquals(set, capturedRequests.keySet());, +        for (Map.Entry<String, List<CapturingTransport.CapturedRequest>> entry : capturedRequests.entrySet()) {, +            // check one request was sent to each non-master node, +            assertEquals(1, entry.getValue().size());, +        }, +    }, +, +        // simulate removing the master, +        final boolean simulateFailedMasterNode = rarely();, +        DiscoveryNode failedMasterNode = null;, +        if (simulateFailedMasterNode) {, +            failedMasterNode = clusterService.state().nodes().masterNode();, +            DiscoveryNodes.Builder builder = DiscoveryNodes.builder(clusterService.state().getNodes());, +            builder.remove(failedMasterNode.id());, +            builder.masterNodeId(null);, +, +            clusterService.setState(ClusterState.builder(clusterService.state()).nodes(builder));, +        }, +, +        if (simulateFailedMasterNode) {, +            totalShards += map.get(failedMasterNode.id()).size();, +        }]