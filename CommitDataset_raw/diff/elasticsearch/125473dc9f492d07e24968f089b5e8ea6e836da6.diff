[+++ b/core/src/main/java/org/elasticsearch/index/mapper/DocumentParser.java, +                parseCopyFields(context, fieldMapper.copyTo().copyToFields());, +        Mapper objectMapper = getMapper(mapper, currentFieldName);, +            ObjectMapper.Dynamic dynamic = dynamicOrDefault(mapper, context.root().dynamic());, +        Mapper mapper = getMapper(parentMapper, lastFieldName);, +            ObjectMapper.Dynamic dynamic = dynamicOrDefault(parentMapper, context.root().dynamic());, +        Mapper mapper = getMapper(parentMapper, currentFieldName);, +        Mapper mapper = getMapper(parentMapper, lastFieldName);, +        ObjectMapper.Dynamic dynamic = dynamicOrDefault(parentMapper, context.root().dynamic());, +        final Mapper.Builder builder;, +        } else {, +    private static void parseCopyFields(ParseContext context, List<String> copyToFields) throws IOException {, +                        ObjectMapper.Dynamic dynamic = dynamicOrDefault(parent, context.root().dynamic());, +    private static ObjectMapper.Dynamic dynamicOrDefault(ObjectMapper parentMapper, ObjectMapper.Dynamic dynamicDefault) {, +        ObjectMapper.Dynamic dynamic = parentMapper.dynamic();, +        if (dynamic == null) {, +            return dynamicDefault == null ? ObjectMapper.Dynamic.TRUE : dynamicDefault;, +        }, +        return dynamic;, +    }, +, +    // looks up a child mapper, but takes into account field names that expand to objects, +    static Mapper getMapper(ObjectMapper objectMapper, String fieldName) {, +        String[] subfields = fieldName.split("\\.");, +        for (int i = 0; i < subfields.length - 1; ++i) {, +            Mapper mapper = objectMapper.getMapper(subfields[i]);, +            if (mapper == null || (mapper instanceof ObjectMapper) == false) {, +                return null;, +            }, +            objectMapper = (ObjectMapper)mapper;, +        }, +        return objectMapper.getMapper(subfields[subfields.length - 1]);, +++ b/core/src/main/java/org/elasticsearch/index/mapper/DocumentParser.java, +                parseCopyFields(context, fieldMapper.copyTo().copyToFields());, +        Mapper objectMapper = getMapper(mapper, currentFieldName);, +            ObjectMapper.Dynamic dynamic = dynamicOrDefault(mapper, context.root().dynamic());, +        Mapper mapper = getMapper(parentMapper, lastFieldName);, +            ObjectMapper.Dynamic dynamic = dynamicOrDefault(parentMapper, context.root().dynamic());, +        Mapper mapper = getMapper(parentMapper, currentFieldName);, +        Mapper mapper = getMapper(parentMapper, lastFieldName);, +        ObjectMapper.Dynamic dynamic = dynamicOrDefault(parentMapper, context.root().dynamic());, +        final Mapper.Builder builder;, +        } else {, +    private static void parseCopyFields(ParseContext context, List<String> copyToFields) throws IOException {, +                        ObjectMapper.Dynamic dynamic = dynamicOrDefault(parent, context.root().dynamic());, +    private static ObjectMapper.Dynamic dynamicOrDefault(ObjectMapper parentMapper, ObjectMapper.Dynamic dynamicDefault) {, +        ObjectMapper.Dynamic dynamic = parentMapper.dynamic();, +        if (dynamic == null) {, +            return dynamicDefault == null ? ObjectMapper.Dynamic.TRUE : dynamicDefault;, +        }, +        return dynamic;, +    }, +, +    // looks up a child mapper, but takes into account field names that expand to objects, +    static Mapper getMapper(ObjectMapper objectMapper, String fieldName) {, +        String[] subfields = fieldName.split("\\.");, +        for (int i = 0; i < subfields.length - 1; ++i) {, +            Mapper mapper = objectMapper.getMapper(subfields[i]);, +            if (mapper == null || (mapper instanceof ObjectMapper) == false) {, +                return null;, +            }, +            objectMapper = (ObjectMapper)mapper;, +        }, +        return objectMapper.getMapper(subfields[subfields.length - 1]);, +++ b/core/src/main/java/org/elasticsearch/node/Node.java, +        if (lifecycle.moveToStarted()) {, +            return this;, +        }, +++ b/core/src/main/java/org/elasticsearch/index/mapper/DocumentParser.java, +                parseCopyFields(context, fieldMapper.copyTo().copyToFields());, +        Mapper objectMapper = getMapper(mapper, currentFieldName);, +            ObjectMapper.Dynamic dynamic = dynamicOrDefault(mapper, context.root().dynamic());, +        Mapper mapper = getMapper(parentMapper, lastFieldName);, +            ObjectMapper.Dynamic dynamic = dynamicOrDefault(parentMapper, context.root().dynamic());, +        Mapper mapper = getMapper(parentMapper, currentFieldName);, +        Mapper mapper = getMapper(parentMapper, lastFieldName);, +        ObjectMapper.Dynamic dynamic = dynamicOrDefault(parentMapper, context.root().dynamic());, +        final Mapper.Builder builder;, +        } else {, +    private static void parseCopyFields(ParseContext context, List<String> copyToFields) throws IOException {, +                        ObjectMapper.Dynamic dynamic = dynamicOrDefault(parent, context.root().dynamic());, +    private static ObjectMapper.Dynamic dynamicOrDefault(ObjectMapper parentMapper, ObjectMapper.Dynamic dynamicDefault) {, +        ObjectMapper.Dynamic dynamic = parentMapper.dynamic();, +        if (dynamic == null) {, +            return dynamicDefault == null ? ObjectMapper.Dynamic.TRUE : dynamicDefault;, +        }, +        return dynamic;, +    }, +, +    // looks up a child mapper, but takes into account field names that expand to objects, +    static Mapper getMapper(ObjectMapper objectMapper, String fieldName) {, +        String[] subfields = fieldName.split("\\.");, +        for (int i = 0; i < subfields.length - 1; ++i) {, +            Mapper mapper = objectMapper.getMapper(subfields[i]);, +            if (mapper == null || (mapper instanceof ObjectMapper) == false) {, +                return null;, +            }, +            objectMapper = (ObjectMapper)mapper;, +        }, +        return objectMapper.getMapper(subfields[subfields.length - 1]);]