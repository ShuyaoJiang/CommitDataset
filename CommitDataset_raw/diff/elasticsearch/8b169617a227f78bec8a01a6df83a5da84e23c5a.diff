[+++ b/src/test/java/org/elasticsearch/plugin/PluginManagerTests.java, +import org.apache.lucene.util.LuceneTestCase;, +import java.nio.file.Files;, +    @LuceneTestCase.AwaitsFix(bugUrl = "@uboness works on this"), +++ b/src/test/java/org/elasticsearch/plugin/PluginManagerTests.java, +import org.apache.lucene.util.LuceneTestCase;, +import java.nio.file.Files;, +    @LuceneTestCase.AwaitsFix(bugUrl = "@uboness works on this"), +++ b/src/test/java/org/elasticsearch/update/UpdateTests.java, +import org.elasticsearch.ElasticsearchTimeoutException;, +import org.elasticsearch.action.ActionListener;, +import org.elasticsearch.action.delete.DeleteResponse;, +import org.elasticsearch.action.delete.DeleteRequest;, +import org.elasticsearch.common.unit.TimeValue;, +import java.util.*;, +import java.util.concurrent.Semaphore;, +import java.util.concurrent.TimeUnit;, +, +    @Test, +    @Slow, +    public void stressUpdateDeleteConcurrency() throws Exception {, +        final boolean useBulkApi = randomBoolean();, +        createIndex();, +        ensureGreen();, +        final int numberOfThreads = scaledRandomIntBetween(5,20);, +        final int numberOfIdsPerThread = scaledRandomIntBetween(3,10);, +        final int numberOfUpdatesPerId = scaledRandomIntBetween(100,1000);, +        final int retryOnConflict = randomIntBetween(0,1);, +        final CountDownLatch latch = new CountDownLatch(numberOfThreads);, +        final CountDownLatch startLatch = new CountDownLatch(1);, +        final List<Throwable> failures = new CopyOnWriteArrayList<>();, +, +        final class UpdateThread extends Thread {, +            final Map<Integer,Integer> failedMap = new HashMap<>();, +            final int numberOfIds;, +            final int updatesPerId;, +            final int maxUpdateRequests = numberOfIdsPerThread*numberOfUpdatesPerId;, +            final int maxDeleteRequests = numberOfIdsPerThread*numberOfUpdatesPerId;, +            private final Semaphore updateRequestsOutstanding = new Semaphore(maxUpdateRequests);, +            private final Semaphore deleteRequestsOutstanding = new Semaphore(maxDeleteRequests);, +, +            public UpdateThread(int numberOfIds, int updatesPerId) {, +                this.numberOfIds = numberOfIds;, +                this.updatesPerId = updatesPerId;, +            }, +, +            final class UpdateListener implements ActionListener<UpdateResponse> {, +                int id;, +, +                public UpdateListener(int id) {, +                    this.id = id;, +                }, +, +                @Override, +                public void onResponse(UpdateResponse updateResponse) {, +                    updateRequestsOutstanding.release(1);, +                }, +, +                @Override, +                public void onFailure(Throwable e) {, +                    synchronized (failedMap) {, +                        incrementMapValue(id, failedMap);, +                    }, +                    updateRequestsOutstanding.release(1);, +                }, +, +            }, +, +            final class DeleteListener implements ActionListener<DeleteResponse> {, +                int id;, +, +                public DeleteListener(int id) {, +                    this.id = id;, +                }, +, +                @Override, +                public void onResponse(DeleteResponse deleteResponse) {, +                    deleteRequestsOutstanding.release(1);, +                }, +, +                @Override, +                public void onFailure(Throwable e) {, +                    synchronized (failedMap) {, +                        incrementMapValue(id, failedMap);, +                    }, +                    deleteRequestsOutstanding.release(1);, +                }, +            }, +, +            @Override, +            public void run(){, +                try {, +                    startLatch.await();, +                    for (int j = 0; j < numberOfIds; j++) {, +                        for (int k = 0; k < numberOfUpdatesPerId; ++k) {, +                            updateRequestsOutstanding.acquire();, +                            UpdateRequest ur = client().prepareUpdate("test", "type1", Integer.toString(j)), +                                .setScript("ctx._source.field += 1", ScriptService.ScriptType.INLINE), +                                .setRetryOnConflict(retryOnConflict), +                                .setUpsert(jsonBuilder().startObject().field("field", 1).endObject())]