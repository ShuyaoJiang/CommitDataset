[+++ b/server/src/main/java/org/elasticsearch/index/IndexService.java, +    private volatile AsyncRetentionLeaseSyncTask retentionLeaseSyncTask;, +        this.retentionLeaseSyncTask = new AsyncRetentionLeaseSyncTask(this);, +                        retentionLeaseSyncTask);, +    private void syncRetentionLeases() {, +        sync(IndexShard::syncRetentionLeases, "retention lease");, +                                                            "{} failed to execute {} sync", shard.shardId(), source), e);, +                                    source + " sync");, +    final class AsyncRetentionLeaseSyncTask extends BaseAsyncTask {, +        AsyncRetentionLeaseSyncTask(final IndexService indexService) {, +            indexService.syncRetentionLeases();, +            return "retention_lease_sync";, +++ b/server/src/main/java/org/elasticsearch/index/IndexService.java, +    private volatile AsyncRetentionLeaseSyncTask retentionLeaseSyncTask;, +        this.retentionLeaseSyncTask = new AsyncRetentionLeaseSyncTask(this);, +                        retentionLeaseSyncTask);, +    private void syncRetentionLeases() {, +        sync(IndexShard::syncRetentionLeases, "retention lease");, +                                                            "{} failed to execute {} sync", shard.shardId(), source), e);, +                                    source + " sync");, +    final class AsyncRetentionLeaseSyncTask extends BaseAsyncTask {, +        AsyncRetentionLeaseSyncTask(final IndexService indexService) {, +            indexService.syncRetentionLeases();, +            return "retention_lease_sync";, +++ b/server/src/main/java/org/elasticsearch/index/IndexSettings.java, +    private void setRetentionLeaseMillis(final TimeValue retentionLease) {, +        this.retentionLeaseMillis = retentionLease.millis();, +    }, +, +        scopedSettings.addSettingsUpdateConsumer(INDEX_SOFT_DELETES_RETENTION_LEASE_SETTING, this::setRetentionLeaseMillis);, +++ b/server/src/main/java/org/elasticsearch/index/IndexService.java, +    private volatile AsyncRetentionLeaseSyncTask retentionLeaseSyncTask;, +        this.retentionLeaseSyncTask = new AsyncRetentionLeaseSyncTask(this);, +                        retentionLeaseSyncTask);, +    private void syncRetentionLeases() {, +        sync(IndexShard::syncRetentionLeases, "retention lease");, +                                                            "{} failed to execute {} sync", shard.shardId(), source), e);, +                                    source + " sync");, +    final class AsyncRetentionLeaseSyncTask extends BaseAsyncTask {, +        AsyncRetentionLeaseSyncTask(final IndexService indexService) {, +            indexService.syncRetentionLeases();, +            return "retention_lease_sync";, +++ b/server/src/main/java/org/elasticsearch/index/IndexSettings.java, +    private void setRetentionLeaseMillis(final TimeValue retentionLease) {, +        this.retentionLeaseMillis = retentionLease.millis();, +    }, +, +        scopedSettings.addSettingsUpdateConsumer(INDEX_SOFT_DELETES_RETENTION_LEASE_SETTING, this::setRetentionLeaseMillis);, +++ b/server/src/main/java/org/elasticsearch/index/seqno/ReplicationTracker.java, +import org.elasticsearch.common.collect.Tuple;, +     * A callback when a new retention lease is created. In practice, this callback invokes the retention lease sync action, to sync, +     * retention leases to replicas., +    private final BiConsumer<RetentionLeases, ActionListener<ReplicationResponse>> onAddRetentionLease;, +     * Get all retention leases tracked on this shard., +        return getRetentionLeases(false).v2();, +    }, +, +    /**, +     * If the expire leases parameter is false, gets all retention leases tracked on this shard and otherwise first calculates, +     * expiration of existing retention leases, and then gets all non-expired retention leases tracked on this shard. Note that only the, +     * primary shard calculates which leases are expired, and if any have expired, syncs the retention leases to any replicas. If the, +     * expire leases parameter is true, this replication tracker must be in primary mode., +     *, +     * @return a tuple indicating whether or not any retention leases were expired, and the non-expired retention leases, +     */, +    public synchronized Tuple<Boolean, RetentionLeases> getRetentionLeases(final boolean expireLeases) {, +        if (expireLeases == false) {, +            return Tuple.tuple(false, retentionLeases);, +        }, +        assert primaryMode;, +            return Tuple.tuple(false, retentionLeases);, +        return Tuple.tuple(true, retentionLeases);, +        onAddRetentionLease.accept(currentRetentionLeases, listener);, +     * @param onAddRetentionLease a callback when a new retention lease is created or an existing retention lease expires, +            final BiConsumer<RetentionLeases, ActionListener<ReplicationResponse>> onAddRetentionLease) {, +        this.onAddRetentionLease = Objects.requireNonNull(onAddRetentionLease);, +++ b/server/src/main/java/org/elasticsearch/index/IndexService.java, +    private volatile AsyncRetentionLeaseSyncTask retentionLeaseSyncTask;, +        this.retentionLeaseSyncTask = new AsyncRetentionLeaseSyncTask(this);, +                        retentionLeaseSyncTask);, +    private void syncRetentionLeases() {, +        sync(IndexShard::syncRetentionLeases, "retention lease");, +                                                            "{} failed to execute {} sync", shard.shardId(), source), e);, +                                    source + " sync");, +    final class AsyncRetentionLeaseSyncTask extends BaseAsyncTask {, +        AsyncRetentionLeaseSyncTask(final IndexService indexService) {, +            indexService.syncRetentionLeases();, +            return "retention_lease_sync";, +++ b/server/src/main/java/org/elasticsearch/index/IndexSettings.java, +    private void setRetentionLeaseMillis(final TimeValue retentionLease) {, +        this.retentionLeaseMillis = retentionLease.millis();, +    }, +, +        scopedSettings.addSettingsUpdateConsumer(INDEX_SOFT_DELETES_RETENTION_LEASE_SETTING, this::setRetentionLeaseMillis);, +++ b/server/src/main/java/org/elasticsearch/index/seqno/ReplicationTracker.java, +import org.elasticsearch.common.collect.Tuple;, +     * A callback when a new retention lease is created. In practice, this callback invokes the retention lease sync action, to sync, +     * retention leases to replicas., +    private final BiConsumer<RetentionLeases, ActionListener<ReplicationResponse>> onAddRetentionLease;, +     * Get all retention leases tracked on this shard.]