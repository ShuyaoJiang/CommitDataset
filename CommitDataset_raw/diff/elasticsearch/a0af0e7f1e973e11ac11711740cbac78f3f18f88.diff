[+++ b/server/src/main/java/org/elasticsearch/persistent/AllocatedPersistentTask.java, +     * Waits for a given persistent task to comply with a given predicate, then call back the listener accordingly., +     *, +     * @param predicate the persistent task predicate to evaluate, +     * @param timeout a timeout for waiting, +     * @param listener the callback listener, +    public void waitForPersistentTask(final Predicate<PersistentTasksCustomMetaData.PersistentTask<?>> predicate,, +                                      final @Nullable TimeValue timeout,, +                                      final PersistentTasksService.WaitForPersistentTaskListener<?> listener) {, +        persistentTasksService.waitForPersistentTaskCondition(persistentTaskId, predicate, timeout, listener);, +                    persistentTasksService.sendCompletionRequest(getPersistentTaskId(), getAllocationId(), failure, new, +++ b/server/src/main/java/org/elasticsearch/persistent/AllocatedPersistentTask.java, +     * Waits for a given persistent task to comply with a given predicate, then call back the listener accordingly., +     *, +     * @param predicate the persistent task predicate to evaluate, +     * @param timeout a timeout for waiting, +     * @param listener the callback listener, +    public void waitForPersistentTask(final Predicate<PersistentTasksCustomMetaData.PersistentTask<?>> predicate,, +                                      final @Nullable TimeValue timeout,, +                                      final PersistentTasksService.WaitForPersistentTaskListener<?> listener) {, +        persistentTasksService.waitForPersistentTaskCondition(persistentTaskId, predicate, timeout, listener);, +                    persistentTasksService.sendCompletionRequest(getPersistentTaskId(), getAllocationId(), failure, new, +++ b/server/src/main/java/org/elasticsearch/persistent/PersistentTasksNodeService.java, +            String reason = "task has been removed, cancelling locally";, +            persistentTasksService.sendCancelRequest(task.getId(), reason, new ActionListener<CancelTasksResponse>() {, +++ b/server/src/main/java/org/elasticsearch/persistent/AllocatedPersistentTask.java, +     * Waits for a given persistent task to comply with a given predicate, then call back the listener accordingly., +     *, +     * @param predicate the persistent task predicate to evaluate, +     * @param timeout a timeout for waiting, +     * @param listener the callback listener, +    public void waitForPersistentTask(final Predicate<PersistentTasksCustomMetaData.PersistentTask<?>> predicate,, +                                      final @Nullable TimeValue timeout,, +                                      final PersistentTasksService.WaitForPersistentTaskListener<?> listener) {, +        persistentTasksService.waitForPersistentTaskCondition(persistentTaskId, predicate, timeout, listener);, +                    persistentTasksService.sendCompletionRequest(getPersistentTaskId(), getAllocationId(), failure, new, +++ b/server/src/main/java/org/elasticsearch/persistent/PersistentTasksNodeService.java, +            String reason = "task has been removed, cancelling locally";, +            persistentTasksService.sendCancelRequest(task.getId(), reason, new ActionListener<CancelTasksResponse>() {, +++ b/server/src/main/java/org/elasticsearch/persistent/PersistentTasksService.java, +import org.elasticsearch.persistent.PersistentTasksCustomMetaData.PersistentTask;, + * This service is used by persistent tasks and allocated persistent tasks to communicate changes, + * to the master node so that the master can update the cluster state and can track of the states, + * of the persistent tasks., +    private static final String ACTION_ORIGIN_TRANSIENT_NAME = "action.origin";, +    private static final String PERSISTENT_TASK_ORIGIN = "persistent_tasks";, +, +     * Notifies the master node to create new persistent task and to assign it to a node., +    public <Params extends PersistentTaskParams> void sendStartRequest(final String taskId,, +                                                                       final String taskName,, +                                                                       final @Nullable Params taskParams,, +                                                                       final ActionListener<PersistentTask<Params>> listener) {, +        final ActionListener<PersistentTask<?>> wrappedListener =, +            ActionListener.wrap(t -> listener.onResponse((PersistentTask<Params>) t), listener::onFailure);, +        StartPersistentTaskAction.Request request = new StartPersistentTaskAction.Request(taskId, taskName, taskParams);, +        execute(request, StartPersistentTaskAction.INSTANCE, wrappedListener);, +     * Notifies the master node about the completion of a persistent task., +     * <p>, +     * When {@code failure} is {@code null}, the persistent task is considered as successfully completed., +    public void sendCompletionRequest(final String taskId,, +                                      final long taskAllocationId,, +                                      final @Nullable Exception taskFailure,, +                                      final ActionListener<PersistentTask<?>> listener) {, +        CompletionPersistentTaskAction.Request request = new CompletionPersistentTaskAction.Request(taskId, taskAllocationId, taskFailure);, +        execute(request, CompletionPersistentTaskAction.INSTANCE, listener);, +     * Cancels a locally running task using the Task Manager API, +    void sendCancelRequest(final long taskId, final String reason, final ActionListener<CancelTasksResponse> listener) {, +        CancelTasksRequest request = new CancelTasksRequest();, +        request.setTaskId(new TaskId(clusterService.localNode().getId(), taskId));, +        request.setReason(reason);, +            final ThreadContext threadContext = client.threadPool().getThreadContext();, +            final Supplier<ThreadContext.StoredContext> supplier = threadContext.newRestorableContext(false);, +, +            try (ThreadContext.StoredContext ignore = stashWithOrigin(threadContext, PERSISTENT_TASK_ORIGIN)) {, +                client.admin().cluster().cancelTasks(request, new ContextPreservingActionListener<>(supplier, listener));, +            }, +     * Notifies the master node that the state of a persistent task has changed., +    void updateStatus(final String taskId,, +                      final long taskAllocationID,, +                      final Task.Status status,, +                      final ActionListener<PersistentTask<?>> listener) {, +        UpdatePersistentTaskStatusAction.Request request = new UpdatePersistentTaskStatusAction.Request(taskId, taskAllocationID, status);, +        execute(request, UpdatePersistentTaskStatusAction.INSTANCE, listener);, +    }, +, +    /**, +     * Notifies the master node to remove a persistent task from the cluster state, +     */, +    public void sendRemoveRequest(final String taskId, final ActionListener<PersistentTask<?>> listener) {, +        RemovePersistentTaskAction.Request request = new RemovePersistentTaskAction.Request(taskId);, +        execute(request, RemovePersistentTaskAction.INSTANCE, listener);, +    }, +, +    /**, +     * Executes an asynchronous persistent task action using the client., +     * <p>, +     * The origin is set in the context and the listener is wrapped to ensure the proper context is restored, +     */, +    private <Req extends ActionRequest, Resp extends PersistentTaskResponse, Builder extends ActionRequestBuilder<Req, Resp, Builder>>, +        void execute(final Req request, final Action<Req, Resp, Builder> action, final ActionListener<PersistentTask<?>> listener) {]