[+++ b/server/src/main/java/org/elasticsearch/indices/IndicesQueryCache.java, +import java.util.Collections;, +    private final Map<Object, StatsAndCount> stats2 = Collections.synchronizedMap(new IdentityHashMap<>());, +, +        // This cache stores two things: filters, and doc id sets. At this time, +        // we only know that there are no more doc id sets, but we still track, +        // recently used queries, which we want to reclaim., +        final ShardId shardId;, +        Stats(ShardId shardId) {, +            this.shardId = shardId;, +        }, +, +, +        @Override, +        public String toString() {, +            return "{shardId=" + shardId + ", ramBytedUsed=" + ramBytesUsed + ", hitCount=" + hitCount + ", missCount=" + missCount +, +                    ", cacheCount=" + cacheCount + ", cacheSize=" + cacheSize + "}";, +        }, +, +        @Override, +        public String toString() {, +            return "{stats=" + stats + " ,count=" + count + "}";, +        }, +                stats = new Stats(shardId);, +            stats2.clear();, +++ b/server/src/main/java/org/elasticsearch/indices/IndicesQueryCache.java, +import java.util.Collections;, +    private final Map<Object, StatsAndCount> stats2 = Collections.synchronizedMap(new IdentityHashMap<>());, +, +        // This cache stores two things: filters, and doc id sets. At this time, +        // we only know that there are no more doc id sets, but we still track, +        // recently used queries, which we want to reclaim., +        final ShardId shardId;, +        Stats(ShardId shardId) {, +            this.shardId = shardId;, +        }, +, +, +        @Override, +        public String toString() {, +            return "{shardId=" + shardId + ", ramBytedUsed=" + ramBytesUsed + ", hitCount=" + hitCount + ", missCount=" + missCount +, +                    ", cacheCount=" + cacheCount + ", cacheSize=" + cacheSize + "}";, +        }, +, +        @Override, +        public String toString() {, +            return "{stats=" + stats + " ,count=" + count + "}";, +        }, +                stats = new Stats(shardId);, +            stats2.clear();, +++ b/server/src/main/java/org/elasticsearch/indices/IndicesService.java, +    final IndicesRequestCache indicesRequestCache; // pkg-private for testing, +                } finally {, +                    indicesRefCount.decRef();, +++ b/server/src/main/java/org/elasticsearch/indices/IndicesQueryCache.java, +import java.util.Collections;, +    private final Map<Object, StatsAndCount> stats2 = Collections.synchronizedMap(new IdentityHashMap<>());, +, +        // This cache stores two things: filters, and doc id sets. At this time, +        // we only know that there are no more doc id sets, but we still track, +        // recently used queries, which we want to reclaim., +        final ShardId shardId;, +        Stats(ShardId shardId) {, +            this.shardId = shardId;, +        }, +, +, +        @Override, +        public String toString() {, +            return "{shardId=" + shardId + ", ramBytedUsed=" + ramBytesUsed + ", hitCount=" + hitCount + ", missCount=" + missCount +, +                    ", cacheCount=" + cacheCount + ", cacheSize=" + cacheSize + "}";, +        }, +, +        @Override, +        public String toString() {, +            return "{stats=" + stats + " ,count=" + count + "}";, +        }, +                stats = new Stats(shardId);, +            stats2.clear();, +++ b/server/src/main/java/org/elasticsearch/indices/IndicesService.java, +    final IndicesRequestCache indicesRequestCache; // pkg-private for testing, +                } finally {, +                    indicesRefCount.decRef();, +++ b/server/src/test/java/org/elasticsearch/indices/IndicesServiceCloseTests.java, +import org.apache.lucene.document.LongPoint;, +import org.apache.lucene.search.Query;, +import org.elasticsearch.common.bytes.BytesArray;, +import org.elasticsearch.common.bytes.BytesReference;, +import org.elasticsearch.common.cache.RemovalNotification;, +import org.elasticsearch.index.IndexModule;, +import org.elasticsearch.index.engine.Engine.Searcher;, +import org.elasticsearch.indices.IndicesRequestCache.Key;, +import org.elasticsearch.test.InternalSettingsPlugin;, +import org.elasticsearch.test.hamcrest.ElasticsearchAssertions;, +import java.util.Collections;, +            .put(IndicesQueryCache.INDICES_QUERIES_CACHE_ALL_SEGMENTS_SETTING.getKey(), true), +        Node node = new MockNode(settings,, +                Arrays.asList(MockNioTransportPlugin.class, MockHttpTransport.TestPlugin.class, InternalSettingsPlugin.class), true);, +    public void testCloseWithIncedRefStore() throws Exception {, +    public void testCloseWhileOngoingRequest() throws Exception {]