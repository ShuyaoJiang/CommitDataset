[+++ b/src/test/java/org/elasticsearch/cluster/SimpleDataNodesTests.java, +import org.elasticsearch.test.AbstractIntegrationTest;, +import org.elasticsearch.test.AbstractIntegrationTest.ClusterScope;, +import org.elasticsearch.test.AbstractIntegrationTest.Scope;, +@ClusterScope(scope=Scope.TEST, numNodes=0), +public class SimpleDataNodesTests extends AbstractIntegrationTest {, +        cluster().startNode(settingsBuilder().put("node.data", false).build());, +        client().admin().indices().create(createIndexRequest("test")).actionGet();, +            client().index(Requests.indexRequest("test").type("type1").id("1").source(source("1", "test")).timeout(timeValueSeconds(1))).actionGet();, +            fail("no allocation should happen");, +        cluster().startNode(settingsBuilder().put("node.data", false).build());, +        assertThat(client().admin().cluster().prepareHealth().setWaitForEvents(Priority.LANGUID).setWaitForNodes("2").setLocal(true).execute().actionGet().isTimedOut(), equalTo(false));, +            client().index(Requests.indexRequest("test").type("type1").id("1").source(source("1", "test")).timeout(timeValueSeconds(1))).actionGet();, +            fail("no allocation should happen");, +        cluster().startNode(settingsBuilder().put("node.data", true).build());, +        assertThat(client().admin().cluster().prepareHealth().setWaitForEvents(Priority.LANGUID).setWaitForNodes("3").setLocal(true).execute().actionGet().isTimedOut(), equalTo(false));, +        IndexResponse indexResponse = client().index(Requests.indexRequest("test").type("type1").id("1").source(source("1", "test"))).actionGet();, +++ b/src/test/java/org/elasticsearch/cluster/SimpleDataNodesTests.java, +import org.elasticsearch.test.AbstractIntegrationTest;, +import org.elasticsearch.test.AbstractIntegrationTest.ClusterScope;, +import org.elasticsearch.test.AbstractIntegrationTest.Scope;, +@ClusterScope(scope=Scope.TEST, numNodes=0), +public class SimpleDataNodesTests extends AbstractIntegrationTest {, +        cluster().startNode(settingsBuilder().put("node.data", false).build());, +        client().admin().indices().create(createIndexRequest("test")).actionGet();, +            client().index(Requests.indexRequest("test").type("type1").id("1").source(source("1", "test")).timeout(timeValueSeconds(1))).actionGet();, +            fail("no allocation should happen");, +        cluster().startNode(settingsBuilder().put("node.data", false).build());, +        assertThat(client().admin().cluster().prepareHealth().setWaitForEvents(Priority.LANGUID).setWaitForNodes("2").setLocal(true).execute().actionGet().isTimedOut(), equalTo(false));, +            client().index(Requests.indexRequest("test").type("type1").id("1").source(source("1", "test")).timeout(timeValueSeconds(1))).actionGet();, +            fail("no allocation should happen");, +        cluster().startNode(settingsBuilder().put("node.data", true).build());, +        assertThat(client().admin().cluster().prepareHealth().setWaitForEvents(Priority.LANGUID).setWaitForNodes("3").setLocal(true).execute().actionGet().isTimedOut(), equalTo(false));, +        IndexResponse indexResponse = client().index(Requests.indexRequest("test").type("type1").id("1").source(source("1", "test"))).actionGet();, +++ b/src/test/java/org/elasticsearch/indexlifecycle/IndexLifecycleActionTests.java, +import com.carrotsearch.randomizedtesting.annotations.Nightly;, +import com.google.common.base.Predicate;, +import org.elasticsearch.test.AbstractIntegrationTest;, +import org.elasticsearch.test.AbstractIntegrationTest.ClusterScope;, +import org.elasticsearch.test.AbstractIntegrationTest.Scope;, +@ClusterScope(scope=Scope.TEST, numNodes=0), +public class IndexLifecycleActionTests extends AbstractIntegrationTest {, +    @Slow, +    @Test, +    public void testIndexLifecycleActions() throws Exception {, +        if (randomBoolean()) { // both run with @Nightly, +            testIndexLifecycleActionsWith11Shards0Backup();, +        } else {, +            testIndexLifecycleActionsWith11Shards1Backup();, +        }, +    @Nightly, +        final String server_1 = cluster().startNode(settings);, +        final String node1 = getLocalNodeId(server_1);, +        CreateIndexResponse createIndexResponse = client().admin().indices().create(createIndexRequest("test")).actionGet();, +        ClusterHealthResponse clusterHealth = client().admin().cluster().prepareHealth().setWaitForEvents(Priority.LANGUID).setWaitForYellowStatus().execute().actionGet();, +        String server_2 = cluster().startNode(settings);, +        clusterHealth = client().admin().cluster().health(clusterHealthRequest().waitForGreenStatus().waitForNodes("2")).actionGet();, +        final String node2 = getLocalNodeId(server_2);, +        client().admin().cluster().prepareReroute().execute().actionGet();, +        clusterHealth = client().admin().cluster().health(clusterHealthRequest().waitForGreenStatus().waitForNodes("2").waitForRelocatingShards(0)).actionGet();, +        String server_3 = cluster().startNode(settings);, +        clusterHealth = client().admin().cluster().health(clusterHealthRequest().waitForGreenStatus().waitForNodes("3")).actionGet();, +        final String node3 = getLocalNodeId(server_3);, +        client().admin().cluster().prepareReroute().execute().actionGet();, +        clusterHealth = client().admin().cluster().health(clusterHealthRequest().waitForGreenStatus().waitForNodes("3").waitForRelocatingShards(0)).actionGet();, +        cluster().stopRandomNode(new Predicate<Settings>() {, +            public boolean apply(Settings settings) {, +                return server_1.equals(settings.get("name"));, +                        , +            }, +        });, +        clusterHealth = client().admin().cluster().health(clusterHealthRequest().waitForGreenStatus().waitForNodes("2")).actionGet();, +        clusterHealth = client().admin().cluster().health(clusterHealthRequest().waitForGreenStatus().waitForRelocatingShards(0).waitForNodes("2")).actionGet();, +        DeleteIndexResponse deleteIndexResponse = client().admin().indices().prepareDelete("test").execute().actionGet();, +        Discovery discovery = cluster().getInstance(Discovery.class, name);, +    , +    @Nightly, +        final String server_1 = cluster().startNode(settings);, +        final String node1 = getLocalNodeId(server_1);, +        CreateIndexResponse createIndexResponse = client().admin().indices().create(createIndexRequest("test")).actionGet();, +        ClusterHealthResponse clusterHealth = client().admin().cluster().health(clusterHealthRequest().waitForGreenStatus()).actionGet();, +        final String server_2 = cluster().startNode(settings);, +        clusterHealth = client().admin().cluster().health(clusterHealthRequest().waitForGreenStatus().waitForNodes("2")).actionGet();, +        final String node2 = getLocalNodeId(server_2);, +        client().admin().cluster().prepareReroute().execute().actionGet();, +        clusterHealth = client().admin().cluster().health(clusterHealthRequest().waitForGreenStatus().waitForRelocatingShards(0).waitForNodes("2")).actionGet();, +        final String server_3 = cluster().startNode();, +        clusterHealth = client().admin().cluster().health(clusterHealthRequest().waitForGreenStatus().waitForNodes("3")).actionGet();, +        final String node3 = getLocalNodeId(server_3);, +        client().admin().cluster().prepareReroute().execute().actionGet();, +        clusterHealth = client().admin().cluster().health(clusterHealthRequest().waitForGreenStatus().waitForNodes("3").waitForRelocatingShards(0)).actionGet();, +        cluster().stopRandomNode(new Predicate<Settings>() {, +            public boolean apply(Settings settings) {, +                return server_1.equals(settings.get("name"));, +                        , +            }, +        });, +        clusterHealth = client().admin().cluster().health(clusterHealthRequest().waitForGreenStatus().waitForNodes("2")).actionGet();, +        clusterHealth = client().admin().cluster().health(clusterHealthRequest().waitForGreenStatus().waitForNodes("2").waitForRelocatingShards(0)).actionGet();, +        DeleteIndexResponse deleteIndexResponse = client().admin().indices().delete(deleteIndexRequest("test")).actionGet();]