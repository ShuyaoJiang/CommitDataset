[+++ b/src/main/java/org/elasticsearch/threadpool/ThreadPool.java, +    public Info info(String name) {, +        ExecutorHolder holder = executors.get(name);, +        if (holder == null) {, +            return null;, +        }, +        return holder.info;, +    }, +, +++ b/src/main/java/org/elasticsearch/threadpool/ThreadPool.java, +    public Info info(String name) {, +        ExecutorHolder holder = executors.get(name);, +        if (holder == null) {, +            return null;, +        }, +        return holder.info;, +    }, +, +++ b/src/test/java/org/elasticsearch/indices/mapping/UpdateMappingTests.java, +import org.elasticsearch.action.bulk.BulkRequestBuilder;, +import org.elasticsearch.action.bulk.BulkResponse;, +import org.elasticsearch.action.index.IndexRequest;, +import org.elasticsearch.action.index.IndexRequestBuilder;, +import org.elasticsearch.threadpool.ThreadPool;, +    public void dynamicUpdates_Index() throws Exception {, +        ThreadPool.Info info = cluster().getInstance(ThreadPool.class).info(ThreadPool.Names.INDEX);, +        int recCount = info.getMax() + (int) info.getQueueSize().getSingles();, +    @Test, +    public void dynamicUpdates_Bulk() throws Exception {, +        client().admin().indices().prepareCreate("test"), +                .setSettings(, +                        ImmutableSettings.settingsBuilder(), +                                .put("index.number_of_shards", 1), +                                .put("index.number_of_replicas", 0), +                ).execute().actionGet();, +        client().admin().cluster().prepareHealth().setWaitForEvents(Priority.LANGUID).setWaitForGreenStatus().execute().actionGet();, +, +        ThreadPool.Info info = cluster().getInstance(ThreadPool.class).info(ThreadPool.Names.BULK);, +        int bulkCount = info.getMax() + (int) info.getQueueSize().getSingles();, +        int bulkSize = between(4, 10);, +        int recCount = bulkCount * bulkSize;, +        int idCounter = 0;, +        final CountDownLatch latch = new CountDownLatch(bulkCount);, +        for (int i = 0; i < bulkCount; i++) {, +            BulkRequestBuilder bulk = client().prepareBulk();, +            for (int rec = 0; rec < bulkSize; rec++) {, +                int id = idCounter++;, +                bulk.add(new IndexRequestBuilder(client()), +                        .setOpType(IndexRequest.OpType.INDEX), +                        .setIndex("test"), +                        .setType("type"), +                        .setId("rec" + id), +                        .setSource("field" + id, "some_value"));, +            }, +            bulk.execute(new ActionListener<BulkResponse>() {, +                @Override, +                public void onResponse(BulkResponse bulkItemResponses) {, +                    if (bulkItemResponses.hasFailures()) {, +                        System.out.println("failed to index in test: " + bulkItemResponses.buildFailureMessage());, +                    }, +                    latch.countDown();, +                }, +, +                @Override, +                public void onFailure(Throwable e) {, +                    logger.error("failed to index in test", e);, +                    latch.countDown();, +                }, +            });, +        }, +        latch.await();, +, +        logger.info("wait till the mappings have been processed...");, +        awaitBusy(new Predicate<Object>() {, +            @Override, +            public boolean apply(Object input) {, +                PendingClusterTasksResponse pendingTasks = client().admin().cluster().preparePendingClusterTasks().get();, +                return pendingTasks.pendingTasks().isEmpty();, +            }, +        });, +, +        logger.info("checking all the documents are there");, +        RefreshResponse refreshResponse = client().admin().indices().prepareRefresh().execute().actionGet();, +        assertThat(refreshResponse.getFailedShards(), equalTo(0));, +        CountResponse response = client().prepareCount("test").execute().actionGet();, +        assertThat(response.getCount(), equalTo((long) recCount));, +, +        logger.info("checking all the fields are in the mappings");, +        String source = client().admin().cluster().prepareState().get().getState().getMetaData().getIndices().get("test").getMappings().get("type").source().string();, +        for (int rec = 0; rec < recCount; rec++) {, +            assertThat(source, containsString("\"field" + rec + "\""));, +        }, +    }, +]