[+++ b/src/main/java/org/elasticsearch/watcher/input/http/ExecutableHttpInput.java, +, +            return new HttpInput.Result(Payload.EMPTY, request, response.status());, +        }, +, +        XContentType contentType = response.xContentType();, +        XContentParser parser = contentType != null ?, +                contentType.xContent().createParser(response.body()) :, +                XContentHelper.createParser(response.body());, +, +        final Payload payload;, +        if (input.getExtractKeys() != null) {, +            Map<String, Object> map = parser.mapOrderedAndClose();, +            payload = new Payload.Simple(map);, +, +++ b/src/main/java/org/elasticsearch/watcher/input/http/ExecutableHttpInput.java, +, +            return new HttpInput.Result(Payload.EMPTY, request, response.status());, +        }, +, +        XContentType contentType = response.xContentType();, +        XContentParser parser = contentType != null ?, +                contentType.xContent().createParser(response.body()) :, +                XContentHelper.createParser(response.body());, +, +        final Payload payload;, +        if (input.getExtractKeys() != null) {, +            Map<String, Object> map = parser.mapOrderedAndClose();, +            payload = new Payload.Simple(map);, +, +++ b/src/main/java/org/elasticsearch/watcher/support/http/HttpClient.java, +import org.elasticsearch.common.collect.ImmutableMap;, +import java.util.List;, +        ImmutableMap.Builder<String, String[]> responseHeaders = ImmutableMap.builder();, +        for (Map.Entry<String, List<String>> header : urlConnection.getHeaderFields().entrySet()) {, +            // HttpURLConnection#getHeaderFields returns the first status line as a header, +            // with a `null` key (facepalm)... so we have to skip that one., +            if (header.getKey() != null) {, +                responseHeaders.put(header.getKey(), header.getValue().toArray(new String[header.getValue().size()]));, +            }, +        }, +            return new HttpResponse(statusCode, body, responseHeaders.build());, +        return new HttpResponse(statusCode, responseHeaders.build());, +++ b/src/main/java/org/elasticsearch/watcher/input/http/ExecutableHttpInput.java, +, +            return new HttpInput.Result(Payload.EMPTY, request, response.status());, +        }, +, +        XContentType contentType = response.xContentType();, +        XContentParser parser = contentType != null ?, +                contentType.xContent().createParser(response.body()) :, +                XContentHelper.createParser(response.body());, +, +        final Payload payload;, +        if (input.getExtractKeys() != null) {, +            Map<String, Object> map = parser.mapOrderedAndClose();, +            payload = new Payload.Simple(map);, +, +++ b/src/main/java/org/elasticsearch/watcher/support/http/HttpClient.java, +import org.elasticsearch.common.collect.ImmutableMap;, +import java.util.List;, +        ImmutableMap.Builder<String, String[]> responseHeaders = ImmutableMap.builder();, +        for (Map.Entry<String, List<String>> header : urlConnection.getHeaderFields().entrySet()) {, +            // HttpURLConnection#getHeaderFields returns the first status line as a header, +            // with a `null` key (facepalm)... so we have to skip that one., +            if (header.getKey() != null) {, +                responseHeaders.put(header.getKey(), header.getValue().toArray(new String[header.getValue().size()]));, +            }, +        }, +            return new HttpResponse(statusCode, body, responseHeaders.build());, +        return new HttpResponse(statusCode, responseHeaders.build());, +++ b/src/main/java/org/elasticsearch/watcher/support/http/HttpResponse.java, +import org.elasticsearch.common.collect.ImmutableMap;, +import org.elasticsearch.common.netty.handler.codec.http.HttpHeaders;, +import org.elasticsearch.common.xcontent.XContentType;, +import javax.annotation.Nullable;, +import java.util.ArrayList;, +import java.util.List;, +import java.util.Map;, +    private final ImmutableMap<String, String[]> headers;, +        this(status, ImmutableMap.<String, String[]>of());, +    public HttpResponse(int status, ImmutableMap<String, String[]> headers) {, +        this(status, (BytesReference) null, headers);, +    public HttpResponse(int status, @Nullable String body) {, +        this(status, body != null ? new BytesArray(body) : null, ImmutableMap.<String, String[]>of());, +    public HttpResponse(int status, @Nullable String body, ImmutableMap<String, String[]> headers) {, +        this(status, body != null ? new BytesArray(body) : null, headers);, +    }, +, +    public HttpResponse(int status, @Nullable byte[] body) {, +        this(status, body != null ? new BytesArray(body) : null, ImmutableMap.<String, String[]>of());, +    }, +, +    public HttpResponse(int status, @Nullable byte[] body, ImmutableMap<String, String[]> headers) {, +        this(status, body != null ? new BytesArray(body) : null, headers);, +    }, +, +    public HttpResponse(int status, @Nullable BytesReference body, ImmutableMap<String, String[]> headers) {, +        this.headers = headers;, +    public ImmutableMap<String, String[]> headers() {]