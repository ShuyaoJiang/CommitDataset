[+++ b/server/src/main/java/org/elasticsearch/snapshots/SnapshotShardsService.java, +import java.util.Iterator;, +import static java.util.Collections.unmodifiableList;, +    private final Map<Snapshot, Map<ShardId, IndexShardSnapshotStatus>> shardSnapshots = new HashMap<>();, +                synchronized (shardSnapshots) {, +                    processIndexShardSnapshots(currentSnapshots);, +                }, +        synchronized (shardSnapshots) {, +            for (Map.Entry<Snapshot, Map<ShardId, IndexShardSnapshotStatus>> snapshotShards : shardSnapshots.entrySet()) {, +    }, +        synchronized (shardSnapshots) {, +            final Map<ShardId, IndexShardSnapshotStatus> current = shardSnapshots.get(snapshot);, +            return current == null ? null : new HashMap<>(current);, +        }, +     * @param snapshotsInProgress Current snapshots in progress in cluster state, +    private void processIndexShardSnapshots(SnapshotsInProgress snapshotsInProgress) {, +        cancelRemoved(snapshotsInProgress);, +        if (snapshotsInProgress != null) {, +            startNewSnapshots(snapshotsInProgress);, +        }, +    }, +, +    private void cancelRemoved(@Nullable SnapshotsInProgress snapshotsInProgress) {, +        Iterator<Map.Entry<Snapshot, Map<ShardId, IndexShardSnapshotStatus>>> it = shardSnapshots.entrySet().iterator();, +        while (it.hasNext()) {, +            final Map.Entry<Snapshot, Map<ShardId, IndexShardSnapshotStatus>> entry = it.next();, +            if (snapshotsInProgress == null || snapshotsInProgress.snapshot(snapshot) == null) {, +                it.remove();, +    }, +    private void startNewSnapshots(SnapshotsInProgress snapshotsInProgress) {, +        final String localNodeId = clusterService.localNode().getId();, +            final State entryState = entry.state();, +            if (entryState == State.STARTED) {, +                Map<ShardId, IndexShardSnapshotStatus> startedShards = null;, +                final Snapshot snapshot = entry.snapshot();, +                Map<ShardId, IndexShardSnapshotStatus> snapshotShards = shardSnapshots.getOrDefault(snapshot, emptyMap());, +                    final ShardId shardId = shard.key;, +                    final ShardSnapshotStatus shardSnapshotStatus = shard.value;, +                    if (localNodeId.equals(shardSnapshotStatus.nodeId()) && shardSnapshotStatus.state() == State.INIT, +                        && snapshotShards.containsKey(shardId) == false) {, +                        logger.trace("[{}] - Adding shard to the queue", shardId);, +                        if (startedShards == null) {, +                             startedShards = new HashMap<>();, +                        }, +                        startedShards.put(shardId, IndexShardSnapshotStatus.newInitializing());, +                if (startedShards != null && startedShards.isEmpty() == false) {, +                    shardSnapshots.computeIfAbsent(snapshot, s -> new HashMap<>()).putAll(startedShards);, +                    startNewShards(entry, startedShards);, +            } else if (entryState == State.ABORTED) {, +                final Snapshot snapshot = entry.snapshot();, +                Map<ShardId, IndexShardSnapshotStatus> snapshotShards = shardSnapshots.getOrDefault(snapshot, emptyMap());, +                                "letting it finish", snapshot, shard.key);, +                                "updating status on the master", snapshot, shard.key);, +                            notifySuccessfulSnapshotShard(snapshot, shard.key);, +                                "updating status on the master", snapshot, shard.key);, +                            notifyFailedSnapshotShard(snapshot, shard.key, lastSnapshotStatus.getFailure());, +                                notifyFailedSnapshotShard(snapshot, curr.key, curr.value.reason());, +                            }, +    private void startNewShards(SnapshotsInProgress.Entry entry, Map<ShardId, IndexShardSnapshotStatus> startedShards) {, +        final Snapshot snapshot = entry.snapshot();, +        final Map<String, IndexId> indicesMap = entry.indices().stream().collect(Collectors.toMap(IndexId::getName, Function.identity()));, +        final Executor executor = threadPool.executor(ThreadPool.Names.SNAPSHOT);, +        for (final Map.Entry<ShardId, IndexShardSnapshotStatus> shardEntry : startedShards.entrySet()) {, +            assert indexId != null;, +                private final SetOnce<Exception> failure = new SetOnce<>();, +                    final IndexShard indexShard =, +                        indicesService.indexServiceSafe(shardId.getIndex()).getShardOrNull(shardId.id());, +                    logger.warn(() -> new ParameterizedMessage("[{}][{}] failed to snapshot shard", shardId, snapshot), e);, +                        notifyFailedSnapshotShard(snapshot, shardId, ExceptionsHelper.detailedMessage(exception));, +                        notifySuccessfulSnapshotShard(snapshot, shardId);, +                                notifySuccessfulSnapshotShard(snapshot.snapshot(), shardId);, +                                notifyFailedSnapshotShard(snapshot.snapshot(), shardId, indexShardSnapshotStatus.getFailure());, +    private void notifySuccessfulSnapshotShard(final Snapshot snapshot, final ShardId shardId) {, +        sendSnapshotShardUpdate(snapshot, shardId, new ShardSnapshotStatus(clusterService.localNode().getId(), State.SUCCESS));, +    private void notifyFailedSnapshotShard(final Snapshot snapshot, final ShardId shardId, final String failure) {, +        sendSnapshotShardUpdate(snapshot, shardId, new ShardSnapshotStatus(clusterService.localNode().getId(), State.FAILED, failure));, +    private class SnapshotStateExecutor implements ClusterStateTaskExecutor<UpdateIndexShardSnapshotStatusRequest> {, +                        execute(ClusterState currentState, List<UpdateIndexShardSnapshotStatusRequest> tasks) {, +                    return ClusterTasksResult.<UpdateIndexShardSnapshotStatusRequest>builder().successes(tasks), +                        .build(ClusterState.builder(currentState).putCustom(SnapshotsInProgress.TYPE,, +                            new SnapshotsInProgress(unmodifiableList(entries))).build());, +                                       ActionListener<UpdateIndexShardSnapshotStatusResponse> listener) {, +++ b/server/src/main/java/org/elasticsearch/snapshots/SnapshotShardsService.java, +import java.util.Iterator;, +import static java.util.Collections.unmodifiableList;, +    private final Map<Snapshot, Map<ShardId, IndexShardSnapshotStatus>> shardSnapshots = new HashMap<>();, +                synchronized (shardSnapshots) {, +                    processIndexShardSnapshots(currentSnapshots);, +                }, +        synchronized (shardSnapshots) {, +            for (Map.Entry<Snapshot, Map<ShardId, IndexShardSnapshotStatus>> snapshotShards : shardSnapshots.entrySet()) {, +    }, +        synchronized (shardSnapshots) {, +            final Map<ShardId, IndexShardSnapshotStatus> current = shardSnapshots.get(snapshot);, +            return current == null ? null : new HashMap<>(current);, +        }, +     * @param snapshotsInProgress Current snapshots in progress in cluster state, +    private void processIndexShardSnapshots(SnapshotsInProgress snapshotsInProgress) {, +        cancelRemoved(snapshotsInProgress);, +        if (snapshotsInProgress != null) {]