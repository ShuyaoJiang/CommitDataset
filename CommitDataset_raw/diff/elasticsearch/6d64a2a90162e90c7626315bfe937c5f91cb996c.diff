[+++ b/buildSrc/src/main/resources/forbidden/es-all-signatures.txt, +, +@defaultMessage use executors from org.elasticsearch.common.util.concurrent.EsExecutors instead which will properly bubble up Errors, +java.util.concurrent.AbstractExecutorService#<init>(), +java.util.concurrent.ThreadPoolExecutor#<init>(int, int, long, java.util.concurrent.TimeUnit, java.util.concurrent.BlockingQueue), +java.util.concurrent.ThreadPoolExecutor#<init>(int, int, long, java.util.concurrent.TimeUnit, java.util.concurrent.BlockingQueue, java.util.concurrent.ThreadFactory), +java.util.concurrent.ThreadPoolExecutor#<init>(int, int, long, java.util.concurrent.TimeUnit, java.util.concurrent.BlockingQueue, java.util.concurrent.RejectedExecutionHandler), +java.util.concurrent.ThreadPoolExecutor#<init>(int, int, long, java.util.concurrent.TimeUnit, java.util.concurrent.BlockingQueue, java.util.concurrent.ThreadFactory, java.util.concurrent.RejectedExecutionHandler), +, +@defaultMessage extend org.elasticsearch.threadpool.Scheduler.SafeScheduledThreadPoolExecutor instead which will properly bubble up Errors, +java.util.concurrent.ScheduledThreadPoolExecutor#<init>(int), +java.util.concurrent.ScheduledThreadPoolExecutor#<init>(int, java.util.concurrent.ThreadFactory), +java.util.concurrent.ScheduledThreadPoolExecutor#<init>(int, java.util.concurrent.RejectedExecutionHandler), +java.util.concurrent.ScheduledThreadPoolExecutor#<init>(int, java.util.concurrent.ThreadFactory, java.util.concurrent.RejectedExecutionHandler), +++ b/buildSrc/src/main/resources/forbidden/es-all-signatures.txt, +, +@defaultMessage use executors from org.elasticsearch.common.util.concurrent.EsExecutors instead which will properly bubble up Errors, +java.util.concurrent.AbstractExecutorService#<init>(), +java.util.concurrent.ThreadPoolExecutor#<init>(int, int, long, java.util.concurrent.TimeUnit, java.util.concurrent.BlockingQueue), +java.util.concurrent.ThreadPoolExecutor#<init>(int, int, long, java.util.concurrent.TimeUnit, java.util.concurrent.BlockingQueue, java.util.concurrent.ThreadFactory), +java.util.concurrent.ThreadPoolExecutor#<init>(int, int, long, java.util.concurrent.TimeUnit, java.util.concurrent.BlockingQueue, java.util.concurrent.RejectedExecutionHandler), +java.util.concurrent.ThreadPoolExecutor#<init>(int, int, long, java.util.concurrent.TimeUnit, java.util.concurrent.BlockingQueue, java.util.concurrent.ThreadFactory, java.util.concurrent.RejectedExecutionHandler), +, +@defaultMessage extend org.elasticsearch.threadpool.Scheduler.SafeScheduledThreadPoolExecutor instead which will properly bubble up Errors, +java.util.concurrent.ScheduledThreadPoolExecutor#<init>(int), +java.util.concurrent.ScheduledThreadPoolExecutor#<init>(int, java.util.concurrent.ThreadFactory), +java.util.concurrent.ScheduledThreadPoolExecutor#<init>(int, java.util.concurrent.RejectedExecutionHandler), +java.util.concurrent.ScheduledThreadPoolExecutor#<init>(int, java.util.concurrent.ThreadFactory, java.util.concurrent.RejectedExecutionHandler), +++ b/qa/evil-tests/src/test/java/org/elasticsearch/threadpool/EvilThreadPoolTests.java, +import org.elasticsearch.common.settings.Settings;, +import org.elasticsearch.common.unit.TimeValue;, +import org.elasticsearch.common.util.concurrent.AbstractRunnable;, +import org.elasticsearch.common.util.concurrent.EsExecutors;, +import org.elasticsearch.common.util.concurrent.EsThreadPoolExecutor;, +import org.elasticsearch.common.util.concurrent.PrioritizedEsThreadPoolExecutor;, +import java.util.concurrent.ExecutorService;, +import java.util.concurrent.ScheduledThreadPoolExecutor;, +import java.util.concurrent.TimeUnit;, +    public void tearDownThreadPool() {, +    public void testExecutionErrorOnDefaultThreadPoolTypes() throws InterruptedException {, +        for (String executor : ThreadPool.THREAD_POOL_TYPES.keySet()) {, +            checkExecutionError(getExecuteRunner(threadPool.executor(executor)));, +            checkExecutionError(getSubmitRunner(threadPool.executor(executor)));, +            checkExecutionError(getScheduleRunner(executor));, +        }, +    }, +, +    public void testExecutionErrorOnDirectExecutorService() throws InterruptedException {, +        final ExecutorService directExecutorService = EsExecutors.newDirectExecutorService();, +        checkExecutionError(getExecuteRunner(directExecutorService));, +        checkExecutionError(getSubmitRunner(directExecutorService));, +    }, +, +    public void testExecutionErrorOnFixedESThreadPoolExecutor() throws InterruptedException {, +        final EsThreadPoolExecutor fixedExecutor = EsExecutors.newFixed("test", 1, 1,, +            EsExecutors.daemonThreadFactory("test"), threadPool.getThreadContext());, +        try {, +            checkExecutionError(getExecuteRunner(fixedExecutor));, +            checkExecutionError(getSubmitRunner(fixedExecutor));, +        } finally {, +            ThreadPool.terminate(fixedExecutor, 10, TimeUnit.SECONDS);, +        }, +    }, +, +    public void testExecutionErrorOnScalingESThreadPoolExecutor() throws InterruptedException {, +        final EsThreadPoolExecutor scalingExecutor = EsExecutors.newScaling("test", 1, 1,, +            10, TimeUnit.SECONDS, EsExecutors.daemonThreadFactory("test"), threadPool.getThreadContext());, +        try {, +            checkExecutionError(getExecuteRunner(scalingExecutor));, +            checkExecutionError(getSubmitRunner(scalingExecutor));, +        } finally {, +            ThreadPool.terminate(scalingExecutor, 10, TimeUnit.SECONDS);, +        }, +    }, +, +    public void testExecutionErrorOnAutoQueueFixedESThreadPoolExecutor() throws InterruptedException {, +        final EsThreadPoolExecutor autoQueueFixedExecutor = EsExecutors.newAutoQueueFixed("test", 1, 1,, +            1, 1, 1, TimeValue.timeValueSeconds(10), EsExecutors.daemonThreadFactory("test"), threadPool.getThreadContext());, +        try {, +            checkExecutionError(getExecuteRunner(autoQueueFixedExecutor));, +            checkExecutionError(getSubmitRunner(autoQueueFixedExecutor));, +        } finally {, +            ThreadPool.terminate(autoQueueFixedExecutor, 10, TimeUnit.SECONDS);, +        }, +    }, +, +    public void testExecutionErrorOnSinglePrioritizingThreadPoolExecutor() throws InterruptedException {, +        final PrioritizedEsThreadPoolExecutor prioritizedExecutor = EsExecutors.newSinglePrioritizing("test",, +            EsExecutors.daemonThreadFactory("test"), threadPool.getThreadContext(), threadPool.scheduler());, +        try {, +            checkExecutionError(getExecuteRunner(prioritizedExecutor));, +            checkExecutionError(getSubmitRunner(prioritizedExecutor));, +            checkExecutionError(r -> prioritizedExecutor.execute(r, TimeValue.ZERO, r));, +        } finally {, +            ThreadPool.terminate(prioritizedExecutor, 10, TimeUnit.SECONDS);, +        }, +    }, +, +    public void testExecutionErrorOnScheduler() throws InterruptedException {, +        final ScheduledThreadPoolExecutor scheduler = Scheduler.initScheduler(Settings.EMPTY);]