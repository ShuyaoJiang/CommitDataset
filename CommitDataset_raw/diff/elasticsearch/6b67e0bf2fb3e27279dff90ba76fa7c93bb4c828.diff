[+++ b/core/src/main/java/org/elasticsearch/action/admin/cluster/shards/ClusterSearchShardsResponse.java, +import java.util.Arrays;, +                String[] aliases = aliasFilter.getAliases();, +                if (aliases.length > 0) {, +                    Arrays.sort(aliases); // we want consistent ordering here and these values might be generated from a set / map, +                    builder.array("aliases", aliases);, +                    if (aliasFilter.getQueryBuilder() != null) { // might be null if we include non-filtering aliases, +                }, +++ b/core/src/main/java/org/elasticsearch/action/admin/cluster/shards/ClusterSearchShardsResponse.java, +import java.util.Arrays;, +                String[] aliases = aliasFilter.getAliases();, +                if (aliases.length > 0) {, +                    Arrays.sort(aliases); // we want consistent ordering here and these values might be generated from a set / map, +                    builder.array("aliases", aliases);, +                    if (aliasFilter.getQueryBuilder() != null) { // might be null if we include non-filtering aliases, +                }, +++ b/core/src/main/java/org/elasticsearch/action/admin/cluster/shards/TransportClusterSearchShardsAction.java, +            final AliasFilter aliasFilter = indicesService.buildAliasFilter(clusterState, index, request.indices());, +            final String[] aliases = indexNameExpressionResolver.indexAliases(clusterState, index, aliasMetadata -> true, true,, +                request.indices());, +            indicesAndFilters.put(index, new AliasFilter(aliasFilter.getQueryBuilder(), aliases));, +++ b/core/src/main/java/org/elasticsearch/action/admin/cluster/shards/ClusterSearchShardsResponse.java, +import java.util.Arrays;, +                String[] aliases = aliasFilter.getAliases();, +                if (aliases.length > 0) {, +                    Arrays.sort(aliases); // we want consistent ordering here and these values might be generated from a set / map, +                    builder.array("aliases", aliases);, +                    if (aliasFilter.getQueryBuilder() != null) { // might be null if we include non-filtering aliases, +                }, +++ b/core/src/main/java/org/elasticsearch/action/admin/cluster/shards/TransportClusterSearchShardsAction.java, +            final AliasFilter aliasFilter = indicesService.buildAliasFilter(clusterState, index, request.indices());, +            final String[] aliases = indexNameExpressionResolver.indexAliases(clusterState, index, aliasMetadata -> true, true,, +                request.indices());, +            indicesAndFilters.put(index, new AliasFilter(aliasFilter.getQueryBuilder(), aliases));, +++ b/core/src/main/java/org/elasticsearch/cluster/metadata/IndexNameExpressionResolver.java, +import java.util.function.Predicate;, +        return indexAliases(state, index, AliasMetaData::filteringRequired, false, expressions);, +    }, +, +    /**, +     * Iterates through the list of indices and selects the effective list of required aliases for the, +     * given index., +     * <p>Only aliases where the given predicate tests successfully are returned. If the indices list contains a non-required reference to, +     * the index itself - null is returned. Returns <tt>null</tt> if no filtering is required., +     */, +    public String[] indexAliases(ClusterState state, String index, Predicate<AliasMetaData> requiredAlias, boolean skipIdentity,, +                                 String... expressions) {, +        List<String> resolvedExpressions = expressions != null ? Arrays.asList(expressions) : Collections.emptyList();, +        final IndexMetaData indexMetaData = state.metaData().getIndices().get(index);, +        // optimize for the most common single index/alias scenario, +        if (resolvedExpressions.size() == 1) {, +            String alias = resolvedExpressions.get(0);, +, +            if (aliasMetaData == null || requiredAlias.test(aliasMetaData) == false) {, +        List<String> aliases = null;, +                if (skipIdentity) {, +                    continue;, +                } else {, +                if (requiredAlias.test(aliasMetaData)) {, +                    // If required - add it to the list of aliases, +                    if (aliases == null) {, +                        aliases = new ArrayList<>();, +                    aliases.add(alias);, +                    // If not, we have a non required alias for this index - no futher checking needed, +        if (aliases == null) {, +        return aliases.toArray(new String[aliases.size()]);, +++ b/core/src/main/java/org/elasticsearch/action/admin/cluster/shards/ClusterSearchShardsResponse.java, +import java.util.Arrays;, +                String[] aliases = aliasFilter.getAliases();, +                if (aliases.length > 0) {, +                    Arrays.sort(aliases); // we want consistent ordering here and these values might be generated from a set / map, +                    builder.array("aliases", aliases);, +                    if (aliasFilter.getQueryBuilder() != null) { // might be null if we include non-filtering aliases, +                }, +++ b/core/src/main/java/org/elasticsearch/action/admin/cluster/shards/TransportClusterSearchShardsAction.java, +            final AliasFilter aliasFilter = indicesService.buildAliasFilter(clusterState, index, request.indices());, +            final String[] aliases = indexNameExpressionResolver.indexAliases(clusterState, index, aliasMetadata -> true, true,, +                request.indices());, +            indicesAndFilters.put(index, new AliasFilter(aliasFilter.getQueryBuilder(), aliases));, +++ b/core/src/main/java/org/elasticsearch/cluster/metadata/IndexNameExpressionResolver.java, +import java.util.function.Predicate;, +        return indexAliases(state, index, AliasMetaData::filteringRequired, false, expressions);, +    }, +, +    /**, +     * Iterates through the list of indices and selects the effective list of required aliases for the, +     * given index., +     * <p>Only aliases where the given predicate tests successfully are returned. If the indices list contains a non-required reference to, +     * the index itself - null is returned. Returns <tt>null</tt> if no filtering is required., +     */, +    public String[] indexAliases(ClusterState state, String index, Predicate<AliasMetaData> requiredAlias, boolean skipIdentity,, +                                 String... expressions) {, +        List<String> resolvedExpressions = expressions != null ? Arrays.asList(expressions) : Collections.emptyList();, +        final IndexMetaData indexMetaData = state.metaData().getIndices().get(index);, +        // optimize for the most common single index/alias scenario, +        if (resolvedExpressions.size() == 1) {, +            String alias = resolvedExpressions.get(0);, +, +            if (aliasMetaData == null || requiredAlias.test(aliasMetaData) == false) {, +        List<String> aliases = null;]