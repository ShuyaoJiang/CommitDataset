[+++ b/core/src/main/java/org/elasticsearch/cluster/routing/RoutingNodes.java, +                            addInitialRecovery(targetShardRouting, indexShard.primary);, +                        } else if (shard.initializing()) {, +                            addInitialRecovery(shard, indexShard.primary);, +        updateRecoveryCounts(routing, true, findAssignedPrimaryIfPeerRecovery(routing));, +        updateRecoveryCounts(routing, false, findAssignedPrimaryIfPeerRecovery(routing));, +    private void addInitialRecovery(ShardRouting routing, ShardRouting initialPrimaryShard) {, +        updateRecoveryCounts(routing, true, initialPrimaryShard);, +    private void updateRecoveryCounts(final ShardRouting routing, final boolean increment, @Nullable final ShardRouting primary) {, +        // TODO: check primary == null || primary.active() after all tests properly add ReplicaAfterPrimaryActiveAllocationDecider, +        assert primary == null || primary.assignedToNode() :, +            "shard is initializing but its primary is not assigned to a node";, +, +, +        if (routing.isPeerRecovery()) {, +            // add/remove corresponding outgoing recovery on node with primary shard, +            if (primary == null) {, +                throw new IllegalStateException("shard is peer recovering but primary is unassigned");, +            }, +            Recoveries.getOrAdd(recoveriesPerNode, primary.currentNodeId()).addOutgoing(howMany);, +, +            if (increment == false && routing.primary() && routing.relocatingNodeId() != null) {, +                // primary is done relocating, move non-primary recoveries from old primary to new primary, +                    if (assigned.primary() == false && assigned.isPeerRecovery()) {, +                recoveriesPerNode.get(routing.relocatingNodeId()).addOutgoing(-numRecoveringReplicas);, +    @Nullable, +    private ShardRouting findAssignedPrimaryIfPeerRecovery(ShardRouting routing) {, +        if (routing.isPeerRecovery()) {, +            List<ShardRouting> shardRoutings = assignedShards.get(routing.shardId());, +        }, +                    if (routing.primary() && routing.isPeerRecovery() == false) {, +                        for (ShardRouting assigned : routingNodes.assignedShards.get(routing.shardId())) {, +                            if (assigned.isPeerRecovery()) {, +            assert incoming == value.incoming : incoming + " != " + value.incoming + " node: " + routingNode;, +++ b/core/src/main/java/org/elasticsearch/cluster/routing/RoutingNodes.java, +                            addInitialRecovery(targetShardRouting, indexShard.primary);, +                        } else if (shard.initializing()) {, +                            addInitialRecovery(shard, indexShard.primary);, +        updateRecoveryCounts(routing, true, findAssignedPrimaryIfPeerRecovery(routing));, +        updateRecoveryCounts(routing, false, findAssignedPrimaryIfPeerRecovery(routing));, +    private void addInitialRecovery(ShardRouting routing, ShardRouting initialPrimaryShard) {, +        updateRecoveryCounts(routing, true, initialPrimaryShard);, +    private void updateRecoveryCounts(final ShardRouting routing, final boolean increment, @Nullable final ShardRouting primary) {, +        // TODO: check primary == null || primary.active() after all tests properly add ReplicaAfterPrimaryActiveAllocationDecider, +        assert primary == null || primary.assignedToNode() :, +            "shard is initializing but its primary is not assigned to a node";, +, +, +        if (routing.isPeerRecovery()) {, +            // add/remove corresponding outgoing recovery on node with primary shard, +            if (primary == null) {, +                throw new IllegalStateException("shard is peer recovering but primary is unassigned");, +            }, +            Recoveries.getOrAdd(recoveriesPerNode, primary.currentNodeId()).addOutgoing(howMany);, +, +            if (increment == false && routing.primary() && routing.relocatingNodeId() != null) {, +                // primary is done relocating, move non-primary recoveries from old primary to new primary, +                    if (assigned.primary() == false && assigned.isPeerRecovery()) {, +                recoveriesPerNode.get(routing.relocatingNodeId()).addOutgoing(-numRecoveringReplicas);, +    @Nullable, +    private ShardRouting findAssignedPrimaryIfPeerRecovery(ShardRouting routing) {, +        if (routing.isPeerRecovery()) {, +            List<ShardRouting> shardRoutings = assignedShards.get(routing.shardId());, +        }, +                    if (routing.primary() && routing.isPeerRecovery() == false) {, +                        for (ShardRouting assigned : routingNodes.assignedShards.get(routing.shardId())) {, +                            if (assigned.isPeerRecovery()) {, +            assert incoming == value.incoming : incoming + " != " + value.incoming + " node: " + routingNode;, +++ b/core/src/main/java/org/elasticsearch/cluster/routing/allocation/decider/ThrottlingAllocationDecider.java, +import static org.elasticsearch.cluster.routing.allocation.decider.Decision.THROTTLE;, +import static org.elasticsearch.cluster.routing.allocation.decider.Decision.YES;, +, +        if (shardRouting.primary() && shardRouting.unassigned()) {, +            assert initializingShard(shardRouting, node.nodeId()).isPeerRecovery() == false;, +            // primary is unassigned, means we are going to do recovery from store, snapshot or local shards, +            // count *just the primaries* currently doing recovery on the node and check against primariesInitialRecoveries, +, +                // TODO: Should index creation not be throttled for primary shards?, +                return allocation.decision(THROTTLE, NAME, "too many primaries are currently recovering [%d], limit: [%d]",, +                return allocation.decision(YES, NAME, "below primary recovery limit of [%d]", primariesInitialRecoveries);, +        } else {, +            // Peer recovery, +            assert initializingShard(shardRouting, node.nodeId()).isPeerRecovery();, +            // Allocating a shard to this node will increase the incoming recoveries, +            if (currentInRecoveries >= concurrentIncomingRecoveries) {, +                return allocation.decision(THROTTLE, NAME, "too many incoming shards are currently recovering [%d], limit: [%d]",, +                // search for corresponding recovery source (= primary shard) and check number of outgoing recoveries on that node, +                ShardRouting primaryShard = allocation.routingNodes().activePrimary(shardRouting.shardId());, +                if (primaryShard == null) {, +                    return allocation.decision(Decision.NO, NAME, "primary shard for this replica is not yet active");, +                }, +                int primaryNodeOutRecoveries = allocation.routingNodes().getOutgoingRecoveries(primaryShard.currentNodeId());, +                if (primaryNodeOutRecoveries >= concurrentOutgoingRecoveries) {, +                    return allocation.decision(THROTTLE, NAME, "too many outgoing shards are currently recovering [%d], limit: [%d]",, +                        primaryNodeOutRecoveries, concurrentOutgoingRecoveries);, +                } else {, +                    return allocation.decision(YES, NAME, "below shard recovery limit of outgoing: [%d < %d] incoming: [%d < %d]",, +                        primaryNodeOutRecoveries,, +    }, +]