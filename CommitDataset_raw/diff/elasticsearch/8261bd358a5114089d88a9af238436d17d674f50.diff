[+++ b/core/src/main/java/org/elasticsearch/action/admin/cluster/snapshots/delete/TransportDeleteSnapshotAction.java, +        }, false);, +++ b/core/src/main/java/org/elasticsearch/action/admin/cluster/snapshots/delete/TransportDeleteSnapshotAction.java, +        }, false);, +++ b/core/src/main/java/org/elasticsearch/cluster/ClusterState.java, +        registerPrototype(SnapshotDeletionsInProgress.TYPE, SnapshotDeletionsInProgress.PROTO);, +        boolean omitSnapshotDeletions = false;, +        if (out.getVersion().before(SnapshotDeletionsInProgress.VERSION_INTRODUCED), +                && customs.containsKey(SnapshotDeletionsInProgress.TYPE)) {, +            // before the stated version, there were no SnapshotDeletionsInProgress, so, +            // don't transfer over the wire protocol, +            omitSnapshotDeletions = true;, +        }, +        out.writeVInt(omitSnapshotDeletions ? customs.size() - 1 : customs.size());, +            if (omitSnapshotDeletions && cursor.key.equals(SnapshotDeletionsInProgress.TYPE)) {, +                continue;, +            }, +            Diff<ImmutableOpenMap<String, Custom>> customsDiff = customs;, +            if (out.getVersion().before(SnapshotDeletionsInProgress.VERSION_INTRODUCED)) {, +                customsDiff = removeSnapshotDeletionsCustomDiff(customsDiff);, +            }, +            customsDiff.writeTo(out);, +        }, +, +        private Diff<ImmutableOpenMap<String, Custom>> removeSnapshotDeletionsCustomDiff(Diff<ImmutableOpenMap<String, Custom>> customs) {, +            if (customs instanceof DiffableUtils.ImmutableOpenMapDiff) {, +                @SuppressWarnings("unchecked"), +                DiffableUtils.ImmutableOpenMapDiff customsDiff = ((DiffableUtils.ImmutableOpenMapDiff) customs), +                                                                     .withKeyRemoved(SnapshotDeletionsInProgress.TYPE);, +                return customsDiff;, +            }, +            return customs;, +++ b/core/src/main/java/org/elasticsearch/action/admin/cluster/snapshots/delete/TransportDeleteSnapshotAction.java, +        }, false);, +++ b/core/src/main/java/org/elasticsearch/cluster/ClusterState.java, +        registerPrototype(SnapshotDeletionsInProgress.TYPE, SnapshotDeletionsInProgress.PROTO);, +        boolean omitSnapshotDeletions = false;, +        if (out.getVersion().before(SnapshotDeletionsInProgress.VERSION_INTRODUCED), +                && customs.containsKey(SnapshotDeletionsInProgress.TYPE)) {, +            // before the stated version, there were no SnapshotDeletionsInProgress, so, +            // don't transfer over the wire protocol, +            omitSnapshotDeletions = true;, +        }, +        out.writeVInt(omitSnapshotDeletions ? customs.size() - 1 : customs.size());, +            if (omitSnapshotDeletions && cursor.key.equals(SnapshotDeletionsInProgress.TYPE)) {, +                continue;, +            }, +            Diff<ImmutableOpenMap<String, Custom>> customsDiff = customs;, +            if (out.getVersion().before(SnapshotDeletionsInProgress.VERSION_INTRODUCED)) {, +                customsDiff = removeSnapshotDeletionsCustomDiff(customsDiff);, +            }, +            customsDiff.writeTo(out);, +        }, +, +        private Diff<ImmutableOpenMap<String, Custom>> removeSnapshotDeletionsCustomDiff(Diff<ImmutableOpenMap<String, Custom>> customs) {, +            if (customs instanceof DiffableUtils.ImmutableOpenMapDiff) {, +                @SuppressWarnings("unchecked"), +                DiffableUtils.ImmutableOpenMapDiff customsDiff = ((DiffableUtils.ImmutableOpenMapDiff) customs), +                                                                     .withKeyRemoved(SnapshotDeletionsInProgress.TYPE);, +                return customsDiff;, +            }, +            return customs;, +++ b/core/src/main/java/org/elasticsearch/cluster/DiffableUtils.java, +    public static class ImmutableOpenMapDiff<K, T> extends MapDiff<K, T, ImmutableOpenMap<K, T>> {, +        private ImmutableOpenMapDiff(KeySerializer<K> keySerializer, ValueSerializer<K, T> valueSerializer,, +                                     List<K> deletes, Map<K, Diff<T>> diffs, Map<K, T> upserts) {, +            super(keySerializer, valueSerializer, deletes, diffs, upserts);, +        }, +, +        /**, +         * Returns a new diff map with the given key removed, does not modify the invoking instance., +         * If the key does not exist in the diff map, the same instance is returned., +         */, +        public ImmutableOpenMapDiff<K, T> withKeyRemoved(K key) {, +            if (this.diffs.containsKey(key) == false && this.upserts.containsKey(key) == false) {, +                return this;, +            }, +            Map<K, Diff<T>> newDiffs = new HashMap<>(this.diffs);, +            newDiffs.remove(key);, +            Map<K, T> newUpserts = new HashMap<>(this.upserts);, +            newUpserts.remove(key);, +            return new ImmutableOpenMapDiff<>(this.keySerializer, this.valueSerializer, this.deletes, newDiffs, newUpserts);, +        }, +, +        protected MapDiff(KeySerializer<K> keySerializer, ValueSerializer<K, T> valueSerializer,, +                          List<K> deletes, Map<K, Diff<T>> diffs, Map<K, T> upserts) {, +            this.keySerializer = keySerializer;, +            this.valueSerializer = valueSerializer;, +            this.deletes = deletes;, +            this.diffs = diffs;, +            this.upserts = upserts;, +        }, +, +++ b/core/src/main/java/org/elasticsearch/action/admin/cluster/snapshots/delete/TransportDeleteSnapshotAction.java, +        }, false);, +++ b/core/src/main/java/org/elasticsearch/cluster/ClusterState.java, +        registerPrototype(SnapshotDeletionsInProgress.TYPE, SnapshotDeletionsInProgress.PROTO);, +        boolean omitSnapshotDeletions = false;, +        if (out.getVersion().before(SnapshotDeletionsInProgress.VERSION_INTRODUCED), +                && customs.containsKey(SnapshotDeletionsInProgress.TYPE)) {]