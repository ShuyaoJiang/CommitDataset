[+++ /dev/null, +++ /dev/null, +++ b/src/main/java/org/elasticsearch/common/lucene/uid/Versions.java, +/*, + * Licensed to ElasticSearch and Shay Banon under one, + * or more contributor license agreements.  See the NOTICE file, + * distributed with this work for additional information, + * regarding copyright ownership. ElasticSearch licenses this, + * file to you under the Apache License, Version 2.0 (the, + * "License"); you may not use this file except in compliance, + * with the License.  You may obtain a copy of the License at, + *, + *    http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing,, + * software distributed under the License is distributed on an, + * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY, + * KIND, either express or implied.  See the License for the, + * specific language governing permissions and limitations, + * under the License., + */, +, +package org.elasticsearch.common.lucene.uid;, +, +import org.apache.lucene.util.Bits;, +, +import org.apache.lucene.index.*;, +import org.apache.lucene.util.BytesRef;, +import org.elasticsearch.common.Numbers;, +import org.elasticsearch.index.mapper.internal.UidFieldMapper;, +, +import java.io.IOException;, +import java.util.List;, +, +/** Utility class to resolve the Lucene doc ID and version for a given uid. */, +public class Versions {, +, +    public static final long NOT_FOUND = -1L;, +    public static final long NOT_SET = -2L;, +, +    private Versions() {}, +, +    /** Wraps an {@link AtomicReaderContext}, a doc ID <b>relative to the context doc base</b> and a version. */, +    public static class DocIdAndVersion {, +        public final int docId;, +        public final long version;, +        public final AtomicReaderContext reader;, +, +        public DocIdAndVersion(int docId, long version, AtomicReaderContext reader) {, +            this.docId = docId;, +            this.version = version;, +            this.reader = reader;, +        }, +    }, +, +    /**, +     * Load the internal doc ID and version for the uid from the reader, returning<ul>, +     * <li>null if the uid wasn't found,, +     * <li>a doc ID and a version otherwise, the version being potentially set to {@link #NOT_SET} if the uid has no associated version, +     * </ul>, +     */, +    public static DocIdAndVersion loadDocIdAndVersion(IndexReader reader, Term term) throws IOException {, +        // iterate backwards to optimize for the frequently updated documents, +        // which are likely to be in the last segments, +        final List<AtomicReaderContext> leaves = reader.leaves();, +        for (int i = leaves.size() - 1; i >= 0; --i) {, +            final DocIdAndVersion docIdAndVersion = loadDocIdAndVersion(leaves.get(i), term);, +            if (docIdAndVersion != null) {, +                assert docIdAndVersion.version != NOT_FOUND;, +                return docIdAndVersion;, +            }, +        }, +        return null;, +    }, +, +    /**, +     * Load the version for the uid from the reader, returning<ul>, +     * <li>{@link #NOT_FOUND} if no matching doc exists,, +     * <li>{@link #NOT_SET} if no version is available,, +     * <li>the version associated with the provided uid otherwise, +     * </ul>, +     */, +    public static long loadVersion(IndexReader reader, Term term) throws IOException {, +        final DocIdAndVersion docIdAndVersion = loadDocIdAndVersion(reader, term);, +        return docIdAndVersion == null ? NOT_FOUND : docIdAndVersion.version;, +    }, +, +    /** Same as {@link #loadDocIdAndVersion(IndexReader, Term)} but operates directly on a reader context. */, +    public static DocIdAndVersion loadDocIdAndVersion(AtomicReaderContext readerContext, Term term) throws IOException {, +        assert term.field().equals(UidFieldMapper.NAME);, +        final AtomicReader reader = readerContext.reader();, +        final Bits liveDocs = reader.getLiveDocs();, +        final Terms terms = reader.terms(UidFieldMapper.NAME);, +        assert terms != null : "All segments must have a _uid field, but " + reader + " doesn't";, +        final TermsEnum termsEnum = terms.iterator(null);, +        final boolean useCache = false; // avoid high cache churn, +        if (!termsEnum.seekExact(term.bytes(), useCache)) {, +            return null;, +        }, +]