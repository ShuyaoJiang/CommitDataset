[+++ b/src/main/java/org/elasticsearch/action/percolate/TransportMultiPercolateAction.java, +                                PercolateRequest originalRequest = (PercolateRequest) percolateRequests.get(slot);, +                                percolateRequests.set(slot, new PercolateRequest(originalRequest, getResponse.getSourceAsBytesRef()));, +                    new ASyncAction(percolateRequests, listener, clusterState).run();, +            new ASyncAction(percolateRequests, listener, clusterState).run();, +    private class ASyncAction {, +, +        final ActionListener<MultiPercolateResponse> listener;, +        final Map<ShardId, TransportShardMultiPercolateAction.Request> requestsByShard;, +        final AtomicReferenceArray<Object> percolateRequests;, +, +        final AtomicInteger expectedOperations;, +        final AtomicArray<Object> reducedResponses;, +        final ConcurrentMap<ShardId, AtomicIntegerArray> shardToSlots;, +        final AtomicReferenceArray<AtomicInteger> expectedOperationsPerItem;, +        final AtomicReferenceArray<AtomicReferenceArray> responsesByItemAndShard;, +, +        ASyncAction(AtomicReferenceArray<Object> percolateRequests, ActionListener<MultiPercolateResponse> listener, ClusterState clusterState) {, +            this.listener = listener;, +            this.percolateRequests = percolateRequests;, +            responsesByItemAndShard = new AtomicReferenceArray<AtomicReferenceArray>(percolateRequests.length());, +            expectedOperationsPerItem = new AtomicReferenceArray<AtomicInteger>(percolateRequests.length());, +            reducedResponses = new AtomicArray<Object>(percolateRequests.length());, +            requestsByShard = new HashMap<ShardId, TransportShardMultiPercolateAction.Request>();, +            for (int slot = 0;  slot < percolateRequests.length(); slot++) {, +                Object element = percolateRequests.get(slot);, +                    Map<String, Set<String>> routing = clusterState.metaData().resolveSearchRouting(percolateRequest.routing(), percolateRequest.indices());, +                    responsesByItemAndShard.set(slot, new AtomicReferenceArray(shards.size()));, +                    expectedOperationsPerItem.set(slot, new AtomicInteger(shards.size()));, +                        requests.add(new TransportShardMultiPercolateAction.Request.Item(slot, new PercolateShardRequest(shardId, percolateRequest)));, +                        items.add(slot);, +                } else if (element instanceof Throwable || element instanceof MultiGetResponse.Failure) {, +                    reducedResponses.set(slot, element);, +                    responsesByItemAndShard.set(slot, new AtomicReferenceArray(0));, +                    expectedOperationsPerItem.set(slot, new AtomicInteger(0));, +            expectedOperations = new AtomicInteger(expectedResults);, +            shardToSlots = ConcurrentCollections.newConcurrentMap();, +        }, +        void run() {, +            if (expectedOperations.get() == 0) {, +                finish();, +                return;, +            }, +, +                final int shardId = entry.getKey().id();, +                final String index =  entry.getKey().index().name();, +, +                TransportShardMultiPercolateAction.Request shardRequest = entry.getValue();, +                        onShardResponse(new ShardId(index, shardId), response);, +                    }, +, +                    @Override, +                    public void onFailure(Throwable e) {, +                        onShardFailure(new ShardId(index, shardId), e);, +                    }, +, +                });, +            }, +        }, +, +        @SuppressWarnings("unchecked"), +        void onShardResponse(ShardId shardId, TransportShardMultiPercolateAction.Response response) {, +                        assert false : "shardResults can't be null";, +                        reduce(item.slot());, +        void onShardFailure(ShardId shardId, Throwable e) {, +                        reduce(slot);, +        void reduce(int slot) {, +                finish();, +        void finish() {, +            for (int slot = 0; slot < reducedResponses.length(); slot++) {, +                Object element = reducedResponses.get(slot);, +                assert element != null : "Element[" + slot + "] shouldn't be null";, +                    finalResponse[slot] = new MultiPercolateResponse.Item((PercolateResponse) element);, +                    finalResponse[slot] = new MultiPercolateResponse.Item(ExceptionsHelper.detailedMessage((Throwable) element));, +                } else if (element instanceof MultiGetResponse.Failure) {, +                    finalResponse[slot] = new MultiPercolateResponse.Item(((MultiGetResponse.Failure)element).getMessage());, +    }, +, +++ b/src/main/java/org/elasticsearch/action/percolate/TransportMultiPercolateAction.java, +                                PercolateRequest originalRequest = (PercolateRequest) percolateRequests.get(slot);, +                                percolateRequests.set(slot, new PercolateRequest(originalRequest, getResponse.getSourceAsBytesRef()));, +                    new ASyncAction(percolateRequests, listener, clusterState).run();, +            new ASyncAction(percolateRequests, listener, clusterState).run();, +    private class ASyncAction {, +, +        final ActionListener<MultiPercolateResponse> listener;, +        final Map<ShardId, TransportShardMultiPercolateAction.Request> requestsByShard;, +        final AtomicReferenceArray<Object> percolateRequests;, +, +        final AtomicInteger expectedOperations;, +        final AtomicArray<Object> reducedResponses;, +        final ConcurrentMap<ShardId, AtomicIntegerArray> shardToSlots;, +        final AtomicReferenceArray<AtomicInteger> expectedOperationsPerItem;, +        final AtomicReferenceArray<AtomicReferenceArray> responsesByItemAndShard;, +, +        ASyncAction(AtomicReferenceArray<Object> percolateRequests, ActionListener<MultiPercolateResponse> listener, ClusterState clusterState) {, +            this.listener = listener;, +            this.percolateRequests = percolateRequests;, +            responsesByItemAndShard = new AtomicReferenceArray<AtomicReferenceArray>(percolateRequests.length());, +            expectedOperationsPerItem = new AtomicReferenceArray<AtomicInteger>(percolateRequests.length());]