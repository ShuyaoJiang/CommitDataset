[+++ b/x-pack/plugin/watcher/src/main/java/org/elasticsearch/xpack/watcher/WatcherLifeCycleService.java, +            this.state.set(WatcherState.STARTING);, +++ b/x-pack/plugin/watcher/src/main/java/org/elasticsearch/xpack/watcher/WatcherLifeCycleService.java, +            this.state.set(WatcherState.STARTING);, +++ b/x-pack/plugin/watcher/src/main/java/org/elasticsearch/xpack/watcher/WatcherService.java, +            return false;, +        // also this is the place where we pause the trigger service execution and clear the current execution service, so that we make sure, +        // that existing executions finish, but no new ones are executed, +            triggerService.pauseExecution();, +            int cancelledTaskCount = executionService.clearExecutionsAndQueue();, +            logger.info("reloading watcher, reason [{}], cancelled [{}] queued tasks", reason, cancelledTaskCount);, +, +++ b/x-pack/plugin/watcher/src/main/java/org/elasticsearch/xpack/watcher/WatcherLifeCycleService.java, +            this.state.set(WatcherState.STARTING);, +++ b/x-pack/plugin/watcher/src/main/java/org/elasticsearch/xpack/watcher/WatcherService.java, +            return false;, +        // also this is the place where we pause the trigger service execution and clear the current execution service, so that we make sure, +        // that existing executions finish, but no new ones are executed, +            triggerService.pauseExecution();, +            int cancelledTaskCount = executionService.clearExecutionsAndQueue();, +            logger.info("reloading watcher, reason [{}], cancelled [{}] queued tasks", reason, cancelledTaskCount);, +, +++ b/x-pack/plugin/watcher/src/main/java/org/elasticsearch/xpack/watcher/trigger/schedule/engine/TickerScheduleTriggerEngine.java, +        this.schedules = schedules;, +++ b/x-pack/plugin/watcher/src/main/java/org/elasticsearch/xpack/watcher/WatcherLifeCycleService.java, +            this.state.set(WatcherState.STARTING);, +++ b/x-pack/plugin/watcher/src/main/java/org/elasticsearch/xpack/watcher/WatcherService.java, +            return false;, +        // also this is the place where we pause the trigger service execution and clear the current execution service, so that we make sure, +        // that existing executions finish, but no new ones are executed, +            triggerService.pauseExecution();, +            int cancelledTaskCount = executionService.clearExecutionsAndQueue();, +            logger.info("reloading watcher, reason [{}], cancelled [{}] queued tasks", reason, cancelledTaskCount);, +, +++ b/x-pack/plugin/watcher/src/main/java/org/elasticsearch/xpack/watcher/trigger/schedule/engine/TickerScheduleTriggerEngine.java, +        this.schedules = schedules;, +++ b/x-pack/plugin/watcher/src/test/java/org/elasticsearch/xpack/watcher/trigger/schedule/engine/TickerScheduleEngineTests.java, +import static org.hamcrest.Matchers.everyItem;, +import static org.hamcrest.Matchers.startsWith;, +        Settings settings = Settings.EMPTY;, +        // having a low value here speeds up the tests tremendously, we still want to run with the defaults every now and then, +        if (usually()) {, +            settings = Settings.builder().put(TickerScheduleTriggerEngine.TICKER_INTERVAL_SETTING.getKey(), "10ms").build();, +        }, +        return new TickerScheduleTriggerEngine(settings, mock(ScheduleRegistry.class), clock);, +    public void testStartClearsExistingSchedules() throws Exception {, +        final CountDownLatch latch = new CountDownLatch(1);, +        List<String> firedWatchIds = new ArrayList<>();, +        engine.register(new Consumer<Iterable<TriggerEvent>>() {, +            @Override, +            public void accept(Iterable<TriggerEvent> events) {, +                for (TriggerEvent event : events) {, +                    firedWatchIds.add(event.jobName());, +                }, +                latch.countDown();, +            }, +        });, +, +        int count = randomIntBetween(2, 5);, +        List<Watch> watches = new ArrayList<>();, +        for (int i = 0; i < count; i++) {, +            watches.add(createWatch(String.valueOf(i), interval("1s")));, +        }, +        engine.start(watches);, +, +        watches.clear();, +        for (int i = 0; i < count; i++) {, +            watches.add(createWatch("another_id" + i, interval("1s")));, +        }, +        engine.start(watches);, +, +        advanceClockIfNeeded(new DateTime(clock.millis(), UTC).plusMillis(1100));, +        if (!latch.await(3 * count, TimeUnit.SECONDS)) {, +            fail("waiting too long for all watches to be triggered");, +        }, +, +        assertThat(firedWatchIds, everyItem(startsWith("another_id")));, +    }, +]