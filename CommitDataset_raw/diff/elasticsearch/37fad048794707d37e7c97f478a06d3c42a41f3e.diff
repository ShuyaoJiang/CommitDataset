[+++ b/server/src/main/java/org/elasticsearch/persistent/AllocatedPersistentTask.java, +/*, + * Licensed to Elasticsearch under one or more contributor, + * license agreements. See the NOTICE file distributed with, + * this work for additional information regarding copyright, + * ownership. Elasticsearch licenses this file to you under, + * the Apache License, Version 2.0 (the "License"); you may, + * not use this file except in compliance with the License., + * You may obtain a copy of the License at, + *, + *    http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing,, + * software distributed under the License is distributed on an, + * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY, + * KIND, either express or implied.  See the License for the, + * specific language governing permissions and limitations, + * under the License., + */, +package org.elasticsearch.persistent;, +, +import org.elasticsearch.action.ActionListener;, +import org.elasticsearch.client.Client;, +import org.elasticsearch.common.Nullable;, +import org.elasticsearch.tasks.CancellableTask;, +import org.elasticsearch.tasks.Task;, +import org.elasticsearch.tasks.TaskId;, +, +import java.util.concurrent.atomic.AtomicReference;, +, +/**, + * Represents a executor node operation that corresponds to a persistent task, + */, +public class AllocatedPersistentTask extends CancellableTask {, +    private long persistentTaskId;, +, +    private final AtomicReference<State> state;, +    @Nullable, +    private Exception failure;, +, +    private PersistentTasksService persistentTasksService;, +, +, +    public AllocatedPersistentTask(long id, String type, String action, String description, TaskId parentTask) {, +        super(id, type, action, description, parentTask);, +        this.state = new AtomicReference<>(State.STARTED);, +    }, +, +    @Override, +    public boolean shouldCancelChildrenOnCancellation() {, +        return true;, +    }, +, +    // In case of persistent tasks we always need to return: `false`, +    // because in case of persistent task the parent task isn't a task in the task manager, but in cluster state., +    // This instructs the task manager not to try to kill this persistent task when the task manager cannot find, +    // a fake parent node id "cluster" in the cluster state, +    @Override, +    public final boolean cancelOnParentLeaving() {, +        return false;, +    }, +, +    @Override, +    public Status getStatus() {, +        return new PersistentTasksNodeService.Status(state.get());, +    }, +, +    /**, +     * Updates the persistent state for the corresponding persistent task., +     *, +     * This doesn't affect the status of this allocated task., +     */, +    public void updatePersistentStatus(Task.Status status, PersistentTasksService.PersistentTaskOperationListener listener) {, +        persistentTasksService.updateStatus(persistentTaskId, status, listener);, +    }, +, +    public long getPersistentTaskId() {, +        return persistentTaskId;, +    }, +, +    void init(PersistentTasksService persistentTasksService, long persistentTaskId) {, +        this.persistentTasksService = persistentTasksService;, +        this.persistentTaskId = persistentTaskId;, +    }, +, +    public Exception getFailure() {, +        return failure;, +    }, +, +    boolean startNotification(Exception failure) {, +        boolean result = state.compareAndSet(AllocatedPersistentTask.State.STARTED, AllocatedPersistentTask.State.FAILED);, +        if (result) {, +            this.failure = failure;, +        }, +        return result;, +    }, +, +    boolean notificationFailed() {, +        return state.compareAndSet(AllocatedPersistentTask.State.FAILED, AllocatedPersistentTask.State.FAILED_NOTIFICATION);, +    }]