[+++ b/src/main/java/org/elasticsearch/transport/TransportService.java, +        try {, +        } finally {, +            // in case the transport is not connected to our local node (thus cleaned on node disconnect), +            // make sure to clean any leftover on going handles, +            for (Map.Entry<Long, RequestHolder> entry : clientHandlers.entrySet()) {, +                final RequestHolder holderToNotify = clientHandlers.remove(entry.getKey());, +                if (holderToNotify != null) {, +                    // callback that an exception happened, but on a different thread since we don't, +                    // want handlers to worry about stack overflows, +                    threadPool.generic().execute(new Runnable() {, +                        @Override, +                        public void run() {, +                            holderToNotify.handler().handleException(new TransportException("transport stopped, action: " + holderToNotify.action()));, +                        }, +                    });, +                }, +            }, +        }, +            try {, +                for (final TransportConnectionListener connectionListener : connectionListeners) {, +                    });, +                }, +++ b/src/main/java/org/elasticsearch/transport/TransportService.java, +        try {, +        } finally {, +            // in case the transport is not connected to our local node (thus cleaned on node disconnect), +            // make sure to clean any leftover on going handles, +            for (Map.Entry<Long, RequestHolder> entry : clientHandlers.entrySet()) {, +                final RequestHolder holderToNotify = clientHandlers.remove(entry.getKey());, +                if (holderToNotify != null) {, +                    // callback that an exception happened, but on a different thread since we don't, +                    // want handlers to worry about stack overflows, +                    threadPool.generic().execute(new Runnable() {, +                        @Override, +                        public void run() {, +                            holderToNotify.handler().handleException(new TransportException("transport stopped, action: " + holderToNotify.action()));, +                        }, +                    });, +                }, +            }, +        }, +            try {, +                for (final TransportConnectionListener connectionListener : connectionListeners) {, +                    });, +                }, +++ b/src/test/java/org/elasticsearch/transport/AbstractSimpleTransportTests.java, +    public void testNotifyOnShutdown() throws Exception {, +        final CountDownLatch latch2 = new CountDownLatch(1);, +, +        serviceA.registerHandler("foobar", new BaseTransportRequestHandler<StringMessageRequest>() {, +            @Override, +            public StringMessageRequest newInstance() {, +                return new StringMessageRequest();, +            }, +, +            @Override, +            public String executor() {, +                return ThreadPool.Names.GENERIC;, +            }, +, +            @Override, +            public void messageReceived(StringMessageRequest request, TransportChannel channel) {, +, +                try {, +                    latch2.await();, +                    logger.info("Stop ServiceB now");, +                    serviceB.stop();, +                } catch (Exception e) {, +                    fail(e.getMessage());, +                }, +            }, +        });, +        TransportFuture<TransportResponse.Empty> foobar = serviceB.submitRequest(nodeA, "foobar",, +                new StringMessageRequest(""), options(), EmptyTransportResponseHandler.INSTANCE_SAME);, +        latch2.countDown();, +        try {, +            foobar.txGet();, +            fail("TransportException expected");, +        } catch (TransportException ex) {, +, +        }, +        serviceA.removeHandler("sayHelloTimeoutDelayedResponse");, +    }, +, +    @Test]