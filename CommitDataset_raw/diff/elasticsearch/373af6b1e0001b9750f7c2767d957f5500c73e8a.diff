[+++ b/modules/elasticsearch/src/main/java/org/elasticsearch/index/translog/fs/FsTranslog.java, +import java.nio.ByteBuffer;, +import java.util.concurrent.atomic.AtomicLong;, +    private AtomicLong lastPosition = new AtomicLong(0);, +    private AtomicLong lastWrittenPosition = new AtomicLong(0);, +            lastPosition.set(0);, +            lastWrittenPosition.set(0);, +            lastPosition.set(0);, +            lastWrittenPosition.set(0);, +            long position = lastPosition.getAndAdd(size);, +            // use channel#write and not raf#write since it allows for concurrent writes, +            // with regards to positions, +            raf.channel().write(ByteBuffer.wrap(out.unsafeByteArray(), 0, size), position);, +                raf.channel().force(false);, +            synchronized (mutex) {, +                lastWrittenPosition.getAndAdd(size);, +                raf.channel().force(true);  // sync here, so we make sure we read back teh data?, +                    return new FsStreamSnapshot(shardId, this.id, raf, lastWrittenPosition.get(), operationCounter.get(), operationCounter.get());, +                    return new FsChannelSnapshot(shardId, this.id, raf, lastWrittenPosition.get(), operationCounter.get(), operationCounter.get());, +                raf.channel().force(true); // sync here, so we make sure we read back teh data?, +                    FsStreamSnapshot newSnapshot = new FsStreamSnapshot(shardId, id, raf, lastWrittenPosition.get(), operationCounter.get(), operationCounter.get() - snapshot.totalOperations());, +                    FsChannelSnapshot newSnapshot = new FsChannelSnapshot(shardId, id, raf, lastWrittenPosition.get(), operationCounter.get(), operationCounter.get() - snapshot.totalOperations());, +                    raf.channel().force(true);, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/index/translog/fs/FsTranslog.java, +import java.nio.ByteBuffer;, +import java.util.concurrent.atomic.AtomicLong;, +    private AtomicLong lastPosition = new AtomicLong(0);, +    private AtomicLong lastWrittenPosition = new AtomicLong(0);, +            lastPosition.set(0);, +            lastWrittenPosition.set(0);, +            lastPosition.set(0);, +            lastWrittenPosition.set(0);, +            long position = lastPosition.getAndAdd(size);, +            // use channel#write and not raf#write since it allows for concurrent writes, +            // with regards to positions, +            raf.channel().write(ByteBuffer.wrap(out.unsafeByteArray(), 0, size), position);, +                raf.channel().force(false);, +            synchronized (mutex) {, +                lastWrittenPosition.getAndAdd(size);, +                raf.channel().force(true);  // sync here, so we make sure we read back teh data?, +                    return new FsStreamSnapshot(shardId, this.id, raf, lastWrittenPosition.get(), operationCounter.get(), operationCounter.get());, +                    return new FsChannelSnapshot(shardId, this.id, raf, lastWrittenPosition.get(), operationCounter.get(), operationCounter.get());, +                raf.channel().force(true); // sync here, so we make sure we read back teh data?, +                    FsStreamSnapshot newSnapshot = new FsStreamSnapshot(shardId, id, raf, lastWrittenPosition.get(), operationCounter.get(), operationCounter.get() - snapshot.totalOperations());, +                    FsChannelSnapshot newSnapshot = new FsChannelSnapshot(shardId, id, raf, lastWrittenPosition.get(), operationCounter.get(), operationCounter.get() - snapshot.totalOperations());, +                    raf.channel().force(true);, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/index/translog/fs/RafReference.java, +import java.nio.channels.FileChannel;, +    private final FileChannel channel;, +, +        this.channel = raf.getChannel();, +    public FileChannel channel() {, +        return this.channel;, +    }, +]