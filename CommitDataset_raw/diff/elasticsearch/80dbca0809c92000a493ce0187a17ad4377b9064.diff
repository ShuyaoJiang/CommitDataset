[+++ b/src/main/java/org/elasticsearch/index/fielddata/plain/IntArrayIndexFieldData.java, +import gnu.trove.iterator.TIntIterator;, +public class IntArrayIndexFieldData extends AbstractIndexFieldData<AtomicNumericFieldData> implements IndexNumericFieldData<AtomicNumericFieldData> {, +    public AtomicNumericFieldData load(AtomicReaderContext context) {, +    public AtomicNumericFieldData loadDirect(AtomicReaderContext context) throws Exception {, +            int max = Integer.MIN_VALUE;, +            int min = Integer.MAX_VALUE;, +            BytesRefIterator iter = builder.buildFromTerms(builder.wrapNumeric32Bit(terms.iterator(null)), reader.getLiveDocs());, +                int value = NumericUtils.prefixCodedToInt(term);, +                values.add(value);, +                if (value > max) {, +                    max = value;, +                if (value < min) {, +                    min = value;, +                }, +            }, +, +            if (fieldDataType.getSettings().getAsBoolean("optimize_type", true)) {, +                // if we can fit all our values in a byte or short we should do this!, +                if (min >= Byte.MIN_VALUE && max <= Byte.MAX_VALUE) {, +                    return ByteArrayIndexFieldData.build(reader, fieldDataType, builder, build, new ByteArrayIndexFieldData.BuilderBytes() {, +                        @Override, +                        public byte get(int index) {, +                            return (byte) values.get(index);, +                        }, +, +                        @Override, +                        public byte[] toArray() {, +                            byte[] bValues = new byte[values.size()];, +                            int i = 0;, +                            for (TIntIterator it = values.iterator(); it.hasNext(); ) {, +                                bValues[i++] = (byte) it.next();, +                            }, +                            return bValues;, +                        }, +                    });, +                } else if (min >= Short.MIN_VALUE && max <= Short.MAX_VALUE) {, +                    return ShortArrayIndexFieldData.build(reader, fieldDataType, builder, build, new ShortArrayIndexFieldData.BuilderShorts() {, +                        @Override, +                        public short get(int index) {, +                            return (short) values.get(index);, +                        }, +, +                        @Override, +                        public short[] toArray() {, +                            short[] sValues = new short[values.size()];, +                            int i = 0;, +                            for (TIntIterator it = values.iterator(); it.hasNext(); ) {, +                                sValues[i++] = (short) it.next();, +                            }, +                            return sValues;, +                        }, +                    });, +                }, +            }, +, +++ b/src/main/java/org/elasticsearch/index/fielddata/plain/IntArrayIndexFieldData.java, +import gnu.trove.iterator.TIntIterator;, +public class IntArrayIndexFieldData extends AbstractIndexFieldData<AtomicNumericFieldData> implements IndexNumericFieldData<AtomicNumericFieldData> {, +    public AtomicNumericFieldData load(AtomicReaderContext context) {, +    public AtomicNumericFieldData loadDirect(AtomicReaderContext context) throws Exception {, +            int max = Integer.MIN_VALUE;, +            int min = Integer.MAX_VALUE;, +            BytesRefIterator iter = builder.buildFromTerms(builder.wrapNumeric32Bit(terms.iterator(null)), reader.getLiveDocs());, +                int value = NumericUtils.prefixCodedToInt(term);, +                values.add(value);, +                if (value > max) {, +                    max = value;, +                if (value < min) {, +                    min = value;, +                }, +            }, +, +            if (fieldDataType.getSettings().getAsBoolean("optimize_type", true)) {, +                // if we can fit all our values in a byte or short we should do this!, +                if (min >= Byte.MIN_VALUE && max <= Byte.MAX_VALUE) {, +                    return ByteArrayIndexFieldData.build(reader, fieldDataType, builder, build, new ByteArrayIndexFieldData.BuilderBytes() {, +                        @Override, +                        public byte get(int index) {, +                            return (byte) values.get(index);, +                        }, +, +                        @Override, +                        public byte[] toArray() {, +                            byte[] bValues = new byte[values.size()];, +                            int i = 0;, +                            for (TIntIterator it = values.iterator(); it.hasNext(); ) {, +                                bValues[i++] = (byte) it.next();, +                            }, +                            return bValues;, +                        }, +                    });, +                } else if (min >= Short.MIN_VALUE && max <= Short.MAX_VALUE) {, +                    return ShortArrayIndexFieldData.build(reader, fieldDataType, builder, build, new ShortArrayIndexFieldData.BuilderShorts() {, +                        @Override, +                        public short get(int index) {, +                            return (short) values.get(index);, +                        }, +, +                        @Override]