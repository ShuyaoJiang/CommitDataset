[+++ b/core/src/main/java/org/elasticsearch/action/admin/cluster/node/stats/NodeStats.java, +            fs = new FsInfo(in);, +++ b/core/src/main/java/org/elasticsearch/action/admin/cluster/node/stats/NodeStats.java, +            fs = new FsInfo(in);, +++ b/core/src/main/java/org/elasticsearch/action/admin/cluster/stats/ClusterStatsNodes.java, +, +        this.fs = new FsInfo.Path(in);, +        /**, +         * Build the stats from information about each node., +         */, +        /**, +         * Read from a stream., +         */, +        private OsStats(StreamInput in) throws IOException {, +            this.availableProcessors = in.readVInt();, +            this.allocatedProcessors = in.readVInt();, +            int size = in.readVInt();, +            this.names = new ObjectIntHashMap<>();, +            for (int i = 0; i < size; i++) {, +                names.addTo(in.readString(), in.readVInt());, +        public int getAvailableProcessors() {, +            return availableProcessors;, +        }, +, +        public int getAllocatedProcessors() {, +            return allocatedProcessors;, +        }, +, +        /**, +         * Build from looking at a list of node statistics., +         */, +         * Read from a stream., +         */, +        private ProcessStats(StreamInput in) throws IOException {, +            this.count = in.readVInt();, +            this.cpuPercent = in.readVInt();, +            this.totalOpenFileDescriptors = in.readVLong();, +            this.minOpenFileDescriptors = in.readLong();, +            this.maxOpenFileDescriptors = in.readLong();, +        }, +, +        @Override, +        public void writeTo(StreamOutput out) throws IOException {, +            out.writeVInt(count);, +            out.writeVInt(cpuPercent);, +            out.writeVLong(totalOpenFileDescriptors);, +            out.writeLong(minOpenFileDescriptors);, +            out.writeLong(maxOpenFileDescriptors);, +        }, +, +, +        /**, +        /**, +         * Build from lists of information about each node., +         */, +        /**, +         * Read from a stream., +         */, +        private JvmStats(StreamInput in) throws IOException {, +            int size = in.readVInt();, +            this.versions = new ObjectIntHashMap<>(size);, +            for (int i = 0; i < size; i++) {, +                this.versions.addTo(new JvmVersion(in), in.readVInt());, +            }, +            this.threads = in.readVLong();, +            this.maxUptime = in.readVLong();, +            this.heapUsed = in.readVLong();, +            this.heapMax = in.readVLong();, +        }, +, +        @Override, +        public void writeTo(StreamOutput out) throws IOException {, +            out.writeVInt(versions.size());, +            for (ObjectIntCursor<JvmVersion> v : versions) {, +                v.key.writeTo(out);, +                out.writeVInt(v.value);, +            }, +            out.writeVLong(threads);, +            out.writeVLong(maxUptime);, +            out.writeVLong(heapUsed);, +            out.writeVLong(heapMax);, +        }, +, +    public static class JvmVersion implements Writeable {, +        /**, +         * Read from a stream., +         */, +        JvmVersion(StreamInput in) throws IOException {, +            version = in.readString();, +            vmName = in.readString();, +            vmVersion = in.readString();, +            vmVendor = in.readString();, +        }, +, +        @Override, +        public void writeTo(StreamOutput out) throws IOException {, +            out.writeString(version);, +            out.writeString(vmName);, +            out.writeString(vmVersion);, +            out.writeString(vmVendor);]