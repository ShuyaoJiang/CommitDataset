[+++ b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/scheduler/SchedulerEngine.java, +            final boolean terminated = scheduler.awaitTermination(5L, TimeUnit.SECONDS);, +            if (terminated == false) {, +                logger.warn("scheduler engine was not terminated after waiting 5s");, +            }, +            logger.warn("interrupted while waiting for scheduler engine termination");, +++ b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/scheduler/SchedulerEngine.java, +            final boolean terminated = scheduler.awaitTermination(5L, TimeUnit.SECONDS);, +            if (terminated == false) {, +                logger.warn("scheduler engine was not terminated after waiting 5s");, +            }, +            logger.warn("interrupted while waiting for scheduler engine termination");, +++ b/x-pack/plugin/data-frame/src/main/java/org/elasticsearch/xpack/dataframe/DataFrame.java, +    private final SetOnce<SchedulerEngine> schedulerEngine = new SetOnce<>();, +        schedulerEngine.set(new SchedulerEngine(settings, Clock.systemUTC()));, +        return Collections.singletonList(new DataFrameTransformPersistentTasksExecutor(client, dataFrameTransformsConfigManager.get(),, +            schedulerEngine.get(), threadPool));, +, +    @Override, +    public void close() {, +        if (schedulerEngine.get() != null) {, +            schedulerEngine.get().stop();, +        }, +    }, +++ b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/scheduler/SchedulerEngine.java, +            final boolean terminated = scheduler.awaitTermination(5L, TimeUnit.SECONDS);, +            if (terminated == false) {, +                logger.warn("scheduler engine was not terminated after waiting 5s");, +            }, +            logger.warn("interrupted while waiting for scheduler engine termination");, +++ b/x-pack/plugin/data-frame/src/main/java/org/elasticsearch/xpack/dataframe/DataFrame.java, +    private final SetOnce<SchedulerEngine> schedulerEngine = new SetOnce<>();, +        schedulerEngine.set(new SchedulerEngine(settings, Clock.systemUTC()));, +        return Collections.singletonList(new DataFrameTransformPersistentTasksExecutor(client, dataFrameTransformsConfigManager.get(),, +            schedulerEngine.get(), threadPool));, +, +    @Override, +    public void close() {, +        if (schedulerEngine.get() != null) {, +            schedulerEngine.get().stop();, +        }, +    }, +++ b/x-pack/plugin/data-frame/src/main/java/org/elasticsearch/xpack/dataframe/transforms/DataFrameTransformPersistentTasksExecutor.java, +++ b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/scheduler/SchedulerEngine.java, +            final boolean terminated = scheduler.awaitTermination(5L, TimeUnit.SECONDS);, +            if (terminated == false) {, +                logger.warn("scheduler engine was not terminated after waiting 5s");, +            }, +            logger.warn("interrupted while waiting for scheduler engine termination");, +++ b/x-pack/plugin/data-frame/src/main/java/org/elasticsearch/xpack/dataframe/DataFrame.java, +    private final SetOnce<SchedulerEngine> schedulerEngine = new SetOnce<>();, +        schedulerEngine.set(new SchedulerEngine(settings, Clock.systemUTC()));, +        return Collections.singletonList(new DataFrameTransformPersistentTasksExecutor(client, dataFrameTransformsConfigManager.get(),, +            schedulerEngine.get(), threadPool));, +, +    @Override, +    public void close() {, +        if (schedulerEngine.get() != null) {, +            schedulerEngine.get().stop();, +        }, +    }, +++ b/x-pack/plugin/data-frame/src/main/java/org/elasticsearch/xpack/dataframe/transforms/DataFrameTransformPersistentTasksExecutor.java, +++ b/x-pack/plugin/ilm/src/main/java/org/elasticsearch/xpack/indexlifecycle/IndexLifecycleService.java, +import org.elasticsearch.common.component.Lifecycle.State;, +    private synchronized void maybeScheduleJob() {, +                // don't create scheduler if the node is shutting down, +                if (isClusterServiceStoppedOrClosed() == false) {, +            }, +, +            // scheduler could be null if the node might be shutting down, +            if (scheduler.get() != null) {, +    }, +    public synchronized void close() {, +        // this assertion is here to ensure that the check we use in maybeScheduleJob is accurate for detecting a shutdown in, +        // progress, which is that the cluster service is stopped and closed at some point prior to closing plugins, +        assert isClusterServiceStoppedOrClosed() : "close is called by closing the plugin, which is expected to happen after " +, +            "the cluster service is stopped";, +, +    /**, +     * Method that checks if the lifecycle state of the cluster service is stopped or closed. This, +     * enhances the readability of the code., +     */, +    private boolean isClusterServiceStoppedOrClosed() {, +        final State state = clusterService.lifecycleState();, +        return state == State.STOPPED || state == State.CLOSED;, +    }, +++ b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/scheduler/SchedulerEngine.java, +            final boolean terminated = scheduler.awaitTermination(5L, TimeUnit.SECONDS);, +            if (terminated == false) {, +                logger.warn("scheduler engine was not terminated after waiting 5s");, +            }, +            logger.warn("interrupted while waiting for scheduler engine termination");, +++ b/x-pack/plugin/data-frame/src/main/java/org/elasticsearch/xpack/dataframe/DataFrame.java, +    private final SetOnce<SchedulerEngine> schedulerEngine = new SetOnce<>();, +        schedulerEngine.set(new SchedulerEngine(settings, Clock.systemUTC()));, +        return Collections.singletonList(new DataFrameTransformPersistentTasksExecutor(client, dataFrameTransformsConfigManager.get(),, +            schedulerEngine.get(), threadPool));, +, +    @Override, +    public void close() {]