[+++ b/src/test/java/org/elasticsearch/discovery/DiscoveryWithNetworkFailuresTests.java, +//    @LuceneTestCase.AwaitsFix(bugUrl = "MvG will fix"), +                                .put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, randomInt(2)), +        final List<Exception> exceptedExceptions = Collections.synchronizedList(new ArrayList<Exception>());, +        logger.info("starting indexers");, +        try {, +                                exceptedExceptions.add(e);, +                assertTrue(countDownLatchRef.get().await(30000 + disruptionScheme.expectedTimeToHeal().millis() * (docsPerIndexer * indexers.size()), TimeUnit.MILLISECONDS));, +                ensureStableCluster(3, TimeValue.timeValueMillis(disruptionScheme.expectedTimeToHeal().millis() + 30000));, +        } finally {, +            logger.debug("Excepted exception during disruption [{}]", exceptedExceptions);, +    }, +++ b/src/test/java/org/elasticsearch/discovery/DiscoveryWithNetworkFailuresTests.java, +//    @LuceneTestCase.AwaitsFix(bugUrl = "MvG will fix"), +                                .put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, randomInt(2)), +        final List<Exception> exceptedExceptions = Collections.synchronizedList(new ArrayList<Exception>());, +        logger.info("starting indexers");, +        try {, +                                exceptedExceptions.add(e);, +                assertTrue(countDownLatchRef.get().await(30000 + disruptionScheme.expectedTimeToHeal().millis() * (docsPerIndexer * indexers.size()), TimeUnit.MILLISECONDS));, +                ensureStableCluster(3, TimeValue.timeValueMillis(disruptionScheme.expectedTimeToHeal().millis() + 30000));, +        } finally {, +            logger.debug("Excepted exception during disruption [{}]", exceptedExceptions);, +    }, +++ b/src/test/java/org/elasticsearch/test/ElasticsearchIntegrationTest.java, +++ b/src/test/java/org/elasticsearch/discovery/DiscoveryWithNetworkFailuresTests.java, +//    @LuceneTestCase.AwaitsFix(bugUrl = "MvG will fix"), +                                .put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, randomInt(2)), +        final List<Exception> exceptedExceptions = Collections.synchronizedList(new ArrayList<Exception>());, +        logger.info("starting indexers");, +        try {, +                                exceptedExceptions.add(e);, +                assertTrue(countDownLatchRef.get().await(30000 + disruptionScheme.expectedTimeToHeal().millis() * (docsPerIndexer * indexers.size()), TimeUnit.MILLISECONDS));, +                ensureStableCluster(3, TimeValue.timeValueMillis(disruptionScheme.expectedTimeToHeal().millis() + 30000));, +        } finally {, +            logger.debug("Excepted exception during disruption [{}]", exceptedExceptions);, +    }, +++ b/src/test/java/org/elasticsearch/test/ElasticsearchIntegrationTest.java, +++ b/src/test/java/org/elasticsearch/test/disruption/NetworkDelaysPartition.java, +    public TimeValue expectedTimeToHeal() {, +        return TimeValue.timeValueMillis(delayMax);, +++ b/src/test/java/org/elasticsearch/discovery/DiscoveryWithNetworkFailuresTests.java, +//    @LuceneTestCase.AwaitsFix(bugUrl = "MvG will fix"), +                                .put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, randomInt(2)), +        final List<Exception> exceptedExceptions = Collections.synchronizedList(new ArrayList<Exception>());, +        logger.info("starting indexers");, +        try {, +                                exceptedExceptions.add(e);, +                assertTrue(countDownLatchRef.get().await(30000 + disruptionScheme.expectedTimeToHeal().millis() * (docsPerIndexer * indexers.size()), TimeUnit.MILLISECONDS));, +                ensureStableCluster(3, TimeValue.timeValueMillis(disruptionScheme.expectedTimeToHeal().millis() + 30000));, +        } finally {, +            logger.debug("Excepted exception during disruption [{}]", exceptedExceptions);, +    }, +++ b/src/test/java/org/elasticsearch/test/ElasticsearchIntegrationTest.java, +++ b/src/test/java/org/elasticsearch/test/disruption/NetworkDelaysPartition.java, +    public TimeValue expectedTimeToHeal() {, +        return TimeValue.timeValueMillis(delayMax);, +++ b/src/test/java/org/elasticsearch/test/disruption/NetworkDisconnectPartition.java, +import org.elasticsearch.common.unit.TimeValue;, +, +    @Override, +    public TimeValue expectedTimeToHeal() {, +        return TimeValue.timeValueSeconds(0);, +    }, +++ b/src/test/java/org/elasticsearch/discovery/DiscoveryWithNetworkFailuresTests.java, +//    @LuceneTestCase.AwaitsFix(bugUrl = "MvG will fix"), +                                .put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, randomInt(2)), +        final List<Exception> exceptedExceptions = Collections.synchronizedList(new ArrayList<Exception>());, +        logger.info("starting indexers");, +        try {, +                                exceptedExceptions.add(e);, +                assertTrue(countDownLatchRef.get().await(30000 + disruptionScheme.expectedTimeToHeal().millis() * (docsPerIndexer * indexers.size()), TimeUnit.MILLISECONDS));, +                ensureStableCluster(3, TimeValue.timeValueMillis(disruptionScheme.expectedTimeToHeal().millis() + 30000));, +        } finally {, +            logger.debug("Excepted exception during disruption [{}]", exceptedExceptions);, +    }, +++ b/src/test/java/org/elasticsearch/test/ElasticsearchIntegrationTest.java, +++ b/src/test/java/org/elasticsearch/test/disruption/NetworkDelaysPartition.java, +    public TimeValue expectedTimeToHeal() {, +        return TimeValue.timeValueMillis(delayMax);, +++ b/src/test/java/org/elasticsearch/test/disruption/NetworkDisconnectPartition.java, +import org.elasticsearch.common.unit.TimeValue;, +, +    @Override, +    public TimeValue expectedTimeToHeal() {, +        return TimeValue.timeValueSeconds(0);, +    }, +++ b/src/test/java/org/elasticsearch/test/disruption/NetworkPartition.java, +++ b/src/test/java/org/elasticsearch/discovery/DiscoveryWithNetworkFailuresTests.java, +//    @LuceneTestCase.AwaitsFix(bugUrl = "MvG will fix"), +                                .put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, randomInt(2)), +        final List<Exception> exceptedExceptions = Collections.synchronizedList(new ArrayList<Exception>());, +        logger.info("starting indexers");, +        try {, +                                exceptedExceptions.add(e);, +                assertTrue(countDownLatchRef.get().await(30000 + disruptionScheme.expectedTimeToHeal().millis() * (docsPerIndexer * indexers.size()), TimeUnit.MILLISECONDS));, +                ensureStableCluster(3, TimeValue.timeValueMillis(disruptionScheme.expectedTimeToHeal().millis() + 30000));, +        } finally {, +            logger.debug("Excepted exception during disruption [{}]", exceptedExceptions);, +    }]