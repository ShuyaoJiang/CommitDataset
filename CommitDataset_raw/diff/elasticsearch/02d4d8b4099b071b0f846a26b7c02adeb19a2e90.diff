[+++ b/server/src/test/java/org/elasticsearch/cluster/MinimumMasterNodesIT.java, +import org.elasticsearch.action.admin.cluster.configuration.AddVotingConfigExclusionsAction;, +import org.elasticsearch.action.admin.cluster.configuration.AddVotingConfigExclusionsRequest;, +import org.elasticsearch.action.admin.cluster.configuration.ClearVotingConfigExclusionsAction;, +import org.elasticsearch.action.admin.cluster.configuration.ClearVotingConfigExclusionsRequest;, +import org.elasticsearch.cluster.coordination.ClusterBootstrapService;, +import org.elasticsearch.cluster.node.DiscoveryNode;, +import org.elasticsearch.node.Node;, +import org.elasticsearch.test.InternalTestCluster;, +import java.util.ArrayList;, +import java.util.List;, +import static org.hamcrest.Matchers.notNullValue;, +    private int bootstrapNodeId;, +, +    protected List<Settings> addExtraClusterBootstrapSettings(List<Settings> allNodesSettings) {, +        if (internalCluster().size() + allNodesSettings.size()  == bootstrapNodeId) {, +            List<String> nodeNames = new ArrayList<>();, +            Collections.addAll(nodeNames, internalCluster().getNodeNames());, +            allNodesSettings.forEach(settings -> nodeNames.add(Node.NODE_NAME_SETTING.get(settings)));, +, +            List<Settings> otherNodesSettings = allNodesSettings.subList(0, allNodesSettings.size() - 1);, +            Settings lastNodeSettings = allNodesSettings.get(allNodesSettings.size()-1);, +            List<Settings> newSettings = new ArrayList<>();, +            newSettings.addAll(otherNodesSettings);, +            newSettings.add(Settings.builder().put(lastNodeSettings), +                    .putList(ClusterBootstrapService.INITIAL_MASTER_NODES_SETTING.getKey(), nodeNames), +                    .build());, +            return newSettings;, +        }, +        return allNodesSettings;, +    public void testTwoNodesNoMasterBlock() throws Exception {, +        //bootstrap cluster once second node is started, +        bootstrapNodeId = 2;, +        String node1Name = internalCluster().startNode(settings);, +        String node2Name = internalCluster().startNode(settings);, +        logger.info("--> verify we get the data back");, +        String masterNode = internalCluster().getMasterName();, +        String otherNode = node1Name.equals(masterNode) ? node2Name : node1Name;, +        logger.info("--> add voting config exclusion for non-master node, to be sure it's not elected");, +        client().execute(AddVotingConfigExclusionsAction.INSTANCE, new AddVotingConfigExclusionsRequest(new String[]{otherNode})).get();, +        logger.info("--> stop master node, no master block should appear");, +        internalCluster().stopRandomNode(InternalTestCluster.nameFilter(masterNode));, +, +        node2Name = internalCluster().startNode(settings);, +        logger.info("--> verify we get the data back after cluster reform");, +        logger.info("--> clearing voting config exclusions");, +        ClearVotingConfigExclusionsRequest clearRequest = new ClearVotingConfigExclusionsRequest();, +        clearRequest.setWaitForRemoval(false);, +        client().execute(ClearVotingConfigExclusionsAction.INSTANCE, clearRequest).get();, +, +        masterNode = internalCluster().getMasterName();, +        otherNode = node1Name.equals(masterNode) ? node2Name : node1Name;, +        logger.info("--> add voting config exclusion for master node, to be sure it's not elected");, +        client().execute(AddVotingConfigExclusionsAction.INSTANCE, new AddVotingConfigExclusionsRequest(new String[]{masterNode})).get();, +        logger.info("--> stop non-master node, no master block should appear");, +        internalCluster().stopRandomNode(InternalTestCluster.nameFilter(otherNode));, +, +    public void testThreeNodesNoMasterBlock() throws Exception {, +        //bootstrap cluster once 3rd node is started, +        bootstrapNodeId = 3;, +, +        logger.info("--> start one more node");, +        internalCluster().startNode(settings);, +            .setWaitForEvents(Priority.LANGUID).setWaitForNodes("3").execute().actionGet();, +        assertThat(state.nodes().getSize(), equalTo(3));, +        logger.info("--> verify we get the data back");, +        logger.info("--> verify that there is no master anymore on remaining node");, +        assertBusy(() -> {, +            ClusterState st = client().admin().cluster().prepareState().setLocal(true).execute().actionGet().getState();, +            assertThat(st.blocks().hasGlobalBlockWithId(DiscoverySettings.NO_MASTER_BLOCK_ID), equalTo(true));, +        });, +        internalCluster().startNodes(2, settings);, +        assertThat(state.nodes().getSize(), equalTo(3));, +    public void testCannotCommitStateThreeNodes() throws Exception {, +        //bootstrap cluster once 3rd node is started, +        bootstrapNodeId = 3;, +                .put("discovery.initial_state_timeout", "500ms"), +, +, +, +        logger.debug("--> check that there is no master in minor partition");, +        // let major partition to elect new master, to ensure that old master is not elected once partition is restored,, +        // otherwise persistent setting (which is a part of accepted state on old master) will be propagated to other nodes, +        logger.debug("--> wait for master to be elected in major partition");, +        assertBusy(() -> {, +            DiscoveryNode masterNode =, +                    internalCluster().client(randomFrom(otherNodes)), +                            .admin().cluster().prepareState().execute().actionGet().getState().nodes().getMasterNode();, +            assertThat(masterNode, notNullValue());, +            assertThat(masterNode.getName(), not(equalTo(master)));, +        });, +]