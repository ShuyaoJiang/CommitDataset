[+++ b/core/src/main/java/org/elasticsearch/common/logging/ESLoggerFactory.java, +            Setting.prefixKeySetting("logger.", LogLevel.INFO.name(), LogLevel::parse, true, Setting.Scope.CLUSTER);, +++ b/core/src/main/java/org/elasticsearch/common/logging/ESLoggerFactory.java, +            Setting.prefixKeySetting("logger.", LogLevel.INFO.name(), LogLevel::parse, true, Setting.Scope.CLUSTER);, +++ b/core/src/main/java/org/elasticsearch/common/lucene/all/AllTermQuery.java, +import org.apache.lucene.util.SmallFloat;, +                    } else if (payload.length == 1) {, +                        boost = SmallFloat.byte315ToFloat(payload.bytes[payload.offset]);, +                    } else if (payload.length == 4) {, +                        // TODO: for bw compat only, remove this in 6.0, +                    } else {, +                        throw new IllegalStateException("Payloads are expected to have a length of 1 or 4 but got: " + payload);, +++ b/core/src/main/java/org/elasticsearch/common/logging/ESLoggerFactory.java, +            Setting.prefixKeySetting("logger.", LogLevel.INFO.name(), LogLevel::parse, true, Setting.Scope.CLUSTER);, +++ b/core/src/main/java/org/elasticsearch/common/lucene/all/AllTermQuery.java, +import org.apache.lucene.util.SmallFloat;, +                    } else if (payload.length == 1) {, +                        boost = SmallFloat.byte315ToFloat(payload.bytes[payload.offset]);, +                    } else if (payload.length == 4) {, +                        // TODO: for bw compat only, remove this in 6.0, +                    } else {, +                        throw new IllegalStateException("Payloads are expected to have a length of 1 or 4 but got: " + payload);, +++ b/core/src/main/java/org/elasticsearch/common/lucene/all/AllTokenStream.java, +import org.apache.lucene.util.SmallFloat;, +    private final BytesRef payloadSpare = new BytesRef(new byte[1]);, +            payloadSpare.bytes[0] = SmallFloat.floatToByte315(boost);, +++ b/core/src/main/java/org/elasticsearch/common/logging/ESLoggerFactory.java, +            Setting.prefixKeySetting("logger.", LogLevel.INFO.name(), LogLevel::parse, true, Setting.Scope.CLUSTER);, +++ b/core/src/main/java/org/elasticsearch/common/lucene/all/AllTermQuery.java, +import org.apache.lucene.util.SmallFloat;, +                    } else if (payload.length == 1) {, +                        boost = SmallFloat.byte315ToFloat(payload.bytes[payload.offset]);, +                    } else if (payload.length == 4) {, +                        // TODO: for bw compat only, remove this in 6.0, +                    } else {, +                        throw new IllegalStateException("Payloads are expected to have a length of 1 or 4 but got: " + payload);, +++ b/core/src/main/java/org/elasticsearch/common/lucene/all/AllTokenStream.java, +import org.apache.lucene.util.SmallFloat;, +    private final BytesRef payloadSpare = new BytesRef(new byte[1]);, +            payloadSpare.bytes[0] = SmallFloat.floatToByte315(boost);, +++ b/core/src/main/java/org/elasticsearch/common/settings/AbstractScopedSettings.java, +                assert assertMatcher(key, 1);, +    private boolean assertMatcher(String key, int numComplexMatchers) {, +        List<Setting<?>> list = new ArrayList<>();, +        for (Map.Entry<String, Setting<?>> entry : complexMatchers.entrySet()) {, +            if (entry.getValue().match(key)) {, +                list.add(entry.getValue().getConcreteSetting(key));, +            }, +        }, +        assert list.size() == numComplexMatchers : "Expected " + numComplexMatchers + " complex matchers to match key [" +, +            key + "] but got: "  + list.toString();, +        return true;, +    }, +, +++ b/core/src/main/java/org/elasticsearch/common/logging/ESLoggerFactory.java, +            Setting.prefixKeySetting("logger.", LogLevel.INFO.name(), LogLevel::parse, true, Setting.Scope.CLUSTER);, +++ b/core/src/main/java/org/elasticsearch/common/lucene/all/AllTermQuery.java, +import org.apache.lucene.util.SmallFloat;, +                    } else if (payload.length == 1) {, +                        boost = SmallFloat.byte315ToFloat(payload.bytes[payload.offset]);, +                    } else if (payload.length == 4) {, +                        // TODO: for bw compat only, remove this in 6.0, +                    } else {, +                        throw new IllegalStateException("Payloads are expected to have a length of 1 or 4 but got: " + payload);, +++ b/core/src/main/java/org/elasticsearch/common/lucene/all/AllTokenStream.java, +import org.apache.lucene.util.SmallFloat;, +    private final BytesRef payloadSpare = new BytesRef(new byte[1]);, +            payloadSpare.bytes[0] = SmallFloat.floatToByte315(boost);, +++ b/core/src/main/java/org/elasticsearch/common/settings/AbstractScopedSettings.java, +                assert assertMatcher(key, 1);, +    private boolean assertMatcher(String key, int numComplexMatchers) {, +        List<Setting<?>> list = new ArrayList<>();, +        for (Map.Entry<String, Setting<?>> entry : complexMatchers.entrySet()) {, +            if (entry.getValue().match(key)) {, +                list.add(entry.getValue().getConcreteSetting(key));, +            }, +        }, +        assert list.size() == numComplexMatchers : "Expected " + numComplexMatchers + " complex matchers to match key [" +, +            key + "] but got: "  + list.toString();, +        return true;, +    }, +, +++ b/core/src/main/java/org/elasticsearch/common/settings/Setting.java, +    private final Key key;, +    public Setting(Key key, Function<Settings, String> defaultValue, Function<String, T> parser, boolean dynamic, Scope scope) {, +     * @param defaultValue a default value function that returns the default values string representation., +     * @param parser a parser that parses the string rep into a complex datatype., +     * @param dynamic true iff this setting can be dynamically updateable, +     * @param scope the scope of this setting, +     */, +    public Setting(String key, Function<Settings, String> defaultValue, Function<String, T> parser, boolean dynamic, Scope scope) {, +        this(new SimpleKey(key), defaultValue, parser, dynamic, scope);, +    }, +, +    /**, +     * Creates a new Setting instance, +     * @param key the settings key for this setting., +        return key.toString();, +    }, +]