[+++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/Definition.java, +    private static final Map<String, Method> methodCache = new HashMap<>();, +    private static final Map<String, Field> fieldCache = new HashMap<>();, +, +    private static String buildMethodCacheKey(String structName, String methodName, List<Type> arguments) {, +        StringBuilder key = new StringBuilder();, +        key.append(structName);, +        key.append(methodName);, +, +        for (Type argument : arguments) {, +            key.append(argument.name);, +        }, +, +        return key.toString();, +    }, +, +    private static String buildFieldCacheKey(String structName, String fieldName, String typeName) {, +        return structName + fieldName + typeName;, +    }, +, +            painlessConstructor = methodCache.computeIfAbsent(buildMethodCacheKey(ownerStruct.name, "<init>", painlessParametersTypes),, +                    key -> new Method("<init>", ownerStruct, null, getTypeInternal("void"), painlessParametersTypes,, +                            asmConstructor, javaConstructor.getModifiers(), javaHandle));, +, +        Class<?> javaAugmentedClass;, +        } else {, +            javaAugmentedClass = null;, +                painlessMethod = methodCache.computeIfAbsent(, +                        buildMethodCacheKey(ownerStruct.name, whitelistMethod.javaMethodName, painlessParametersTypes),, +                        key -> new Method(whitelistMethod.javaMethodName, ownerStruct, null, painlessReturnType, painlessParametersTypes,, +                                asmMethod, javaMethod.getModifiers(), javaMethodHandle));, +                painlessMethod = methodCache.computeIfAbsent(, +                        buildMethodCacheKey(ownerStruct.name, whitelistMethod.javaMethodName, painlessParametersTypes),, +                        key -> new Method(whitelistMethod.javaMethodName, ownerStruct, javaAugmentedClass, painlessReturnType,, +                                painlessParametersTypes, asmMethod, javaMethod.getModifiers(), javaMethodHandle));, +                painlessField = fieldCache.computeIfAbsent(, +                        buildFieldCacheKey(ownerStruct.name, whitelistField.javaFieldName, painlessFieldType.name),, +                        key -> new Field(whitelistField.javaFieldName, javaField.getName(),, +                                ownerStruct, painlessFieldType, javaField.getModifiers(), null, null));, +            MethodHandle javaMethodHandleGetter;, +            MethodHandle javaMethodHandleSetter;, +                } else {, +                    javaMethodHandleGetter = null;, +                    javaMethodHandleSetter = null;, +            Field painlessField = ownerStruct.members.get(whitelistField.javaFieldName);, +                painlessField = fieldCache.computeIfAbsent(, +                        buildFieldCacheKey(ownerStruct.name, whitelistField.javaFieldName, painlessFieldType.name),, +                        key -> new Field(whitelistField.javaFieldName, javaField.getName(),, +                                ownerStruct, painlessFieldType, javaField.getModifiers(), javaMethodHandleGetter, javaMethodHandleSetter));, +                ownerStruct.members.put(whitelistField.javaFieldName, painlessField);]