[+++ b/core/src/main/java/org/elasticsearch/cluster/SnapshotsInProgress.java, +        public Entry(SnapshotId snapshotId, boolean includeGlobalState, State state, List<String> indices, long startTime, ImmutableOpenMap<ShardId, ShardSnapshotStatus> shards) {, +            this(entry.snapshotId, entry.includeGlobalState, state, entry.indices, entry.startTime, shards);, +            entries[i] = new Entry(snapshotId, includeGlobalState, state, Collections.unmodifiableList(indexBuilder), startTime, builder.build());, +++ b/core/src/main/java/org/elasticsearch/cluster/SnapshotsInProgress.java, +        public Entry(SnapshotId snapshotId, boolean includeGlobalState, State state, List<String> indices, long startTime, ImmutableOpenMap<ShardId, ShardSnapshotStatus> shards) {, +            this(entry.snapshotId, entry.includeGlobalState, state, entry.indices, entry.startTime, shards);, +            entries[i] = new Entry(snapshotId, includeGlobalState, state, Collections.unmodifiableList(indexBuilder), startTime, builder.build());, +++ b/core/src/main/java/org/elasticsearch/cluster/metadata/MetaDataDeleteIndexService.java, +import java.util.Arrays;, +import java.util.Collection;, +        Collection<String> indices = Arrays.asList(request.indices);, +++ b/core/src/main/java/org/elasticsearch/cluster/SnapshotsInProgress.java, +        public Entry(SnapshotId snapshotId, boolean includeGlobalState, State state, List<String> indices, long startTime, ImmutableOpenMap<ShardId, ShardSnapshotStatus> shards) {, +            this(entry.snapshotId, entry.includeGlobalState, state, entry.indices, entry.startTime, shards);, +            entries[i] = new Entry(snapshotId, includeGlobalState, state, Collections.unmodifiableList(indexBuilder), startTime, builder.build());, +++ b/core/src/main/java/org/elasticsearch/cluster/metadata/MetaDataDeleteIndexService.java, +import java.util.Arrays;, +import java.util.Collection;, +        Collection<String> indices = Arrays.asList(request.indices);, +++ b/core/src/main/java/org/elasticsearch/cluster/metadata/MetaDataIndexStateService.java, +import com.carrotsearch.hppc.cursors.ObjectObjectCursor;, +import org.elasticsearch.cluster.RestoreInProgress;, +import org.elasticsearch.index.shard.ShardId;, +                // Check if any of the indices to be closed are currently being restored from a snapshot and fail closing if such an index, +                // is found as closing an index that is being restored makes the index unusable (it cannot be recovered)., +                RestoreInProgress restore = currentState.custom(RestoreInProgress.TYPE);, +                if (restore != null) {, +                    Set<String> indicesToFail = null;, +                    for (RestoreInProgress.Entry entry : restore.entries()) {, +                        for (ObjectObjectCursor<ShardId, RestoreInProgress.ShardRestoreStatus> shard : entry.shards()) {, +                            if (!shard.value.state().completed()) {, +                                if (indicesToClose.contains(shard.key.getIndexName())) {, +                                    if (indicesToFail == null) {, +                                        indicesToFail = new HashSet<>();, +                                    }, +                                    indicesToFail.add(shard.key.getIndexName());, +                                }, +                            }, +                        }, +                    }, +                    if (indicesToFail != null) {, +                        throw new IllegalArgumentException("Cannot close indices that are being restored: " + indicesToFail);, +                    }, +                }, +++ b/core/src/main/java/org/elasticsearch/cluster/SnapshotsInProgress.java, +        public Entry(SnapshotId snapshotId, boolean includeGlobalState, State state, List<String> indices, long startTime, ImmutableOpenMap<ShardId, ShardSnapshotStatus> shards) {, +            this(entry.snapshotId, entry.includeGlobalState, state, entry.indices, entry.startTime, shards);, +            entries[i] = new Entry(snapshotId, includeGlobalState, state, Collections.unmodifiableList(indexBuilder), startTime, builder.build());, +++ b/core/src/main/java/org/elasticsearch/cluster/metadata/MetaDataDeleteIndexService.java, +import java.util.Arrays;, +import java.util.Collection;, +        Collection<String> indices = Arrays.asList(request.indices);, +++ b/core/src/main/java/org/elasticsearch/cluster/metadata/MetaDataIndexStateService.java, +import com.carrotsearch.hppc.cursors.ObjectObjectCursor;, +import org.elasticsearch.cluster.RestoreInProgress;, +import org.elasticsearch.index.shard.ShardId;, +                // Check if any of the indices to be closed are currently being restored from a snapshot and fail closing if such an index, +                // is found as closing an index that is being restored makes the index unusable (it cannot be recovered)., +                RestoreInProgress restore = currentState.custom(RestoreInProgress.TYPE);, +                if (restore != null) {, +                    Set<String> indicesToFail = null;, +                    for (RestoreInProgress.Entry entry : restore.entries()) {, +                        for (ObjectObjectCursor<ShardId, RestoreInProgress.ShardRestoreStatus> shard : entry.shards()) {, +                            if (!shard.value.state().completed()) {, +                                if (indicesToClose.contains(shard.key.getIndexName())) {, +                                    if (indicesToFail == null) {, +                                        indicesToFail = new HashSet<>();, +                                    }, +                                    indicesToFail.add(shard.key.getIndexName());, +                                }, +                            }, +                        }, +                    }, +                    if (indicesToFail != null) {, +                        throw new IllegalArgumentException("Cannot close indices that are being restored: " + indicesToFail);, +                    }, +                }, +++ b/core/src/main/java/org/elasticsearch/index/mapper/DocumentParser.java, +import java.io.Closeable;, +import java.io.IOException;, +import java.util.ArrayList;, +import java.util.Collections;, +import java.util.HashSet;, +import java.util.Iterator;, +import java.util.List;, +import java.util.Set;, +, +import org.elasticsearch.common.settings.Settings;, +final class DocumentParser implements Closeable {, +        ParsedDocument doc = parsedDocument(source, context, createDynamicUpdate(mapping, docMapper, context.getDynamicMappers()));, +            parseObjectOrNested(context, mapping.root, true);, +    /** Creates a Mapping containing any dynamically added fields, or returns null if there were no dynamic mappings. */, +    static Mapping createDynamicUpdate(Mapping mapping, DocumentMapper docMapper, List<Mapper> dynamicMappers) {, +        if (dynamicMappers.isEmpty()) {, +            return null;, +        }, +        // We build a mapping by first sorting the mappers, so that all mappers containing a common prefix, +        // will be processed in a contiguous block. When the prefix is no longer seen, we pop the extra elements, +        // off the stack, merging them upwards into the existing mappers.]