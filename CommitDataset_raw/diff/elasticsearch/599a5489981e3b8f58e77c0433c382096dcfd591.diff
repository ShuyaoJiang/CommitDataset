[+++ b/core/src/test/java/org/elasticsearch/common/lucene/LuceneTests.java, +import org.apache.lucene.analysis.core.KeywordAnalyzer;, +import org.apache.lucene.index.LeafReader;, +import org.apache.lucene.index.LeafReaderContext;, +import org.apache.lucene.search.Weight;, +import org.apache.lucene.util.Bits;, +    public void testAsSequentialAccessBits() throws Exception {, +        Directory dir = newDirectory();, +        IndexWriter w = new IndexWriter(dir, new IndexWriterConfig(new KeywordAnalyzer()));, +, +        Document doc = new Document();, +        doc.add(new StringField("foo", "bar", Store.NO));, +        w.addDocument(doc);, +, +        doc = new Document();, +        w.addDocument(doc);, +, +        doc = new Document();, +        doc.add(new StringField("foo", "bar", Store.NO));, +        w.addDocument(doc);, +, +, +        try (DirectoryReader reader = DirectoryReader.open(w)) {, +            IndexSearcher searcher = newSearcher(reader);, +            Weight termWeight = new TermQuery(new Term("foo", "bar")).createWeight(searcher, false);, +            assertEquals(1, reader.leaves().size());, +            LeafReaderContext leafReaderContext = reader.leaves().get(0);, +            Bits bits = Lucene.asSequentialAccessBits(leafReaderContext.reader().maxDoc(), termWeight.scorer(leafReaderContext));, +, +            expectThrows(IndexOutOfBoundsException.class, () -> bits.get(-1));, +            expectThrows(IndexOutOfBoundsException.class, () -> bits.get(leafReaderContext.reader().maxDoc()));, +            assertTrue(bits.get(0));, +            assertTrue(bits.get(0));, +            assertFalse(bits.get(1));, +            assertFalse(bits.get(1));, +            expectThrows(IllegalArgumentException.class, () -> bits.get(0));, +            assertTrue(bits.get(2));, +            assertTrue(bits.get(2));, +            expectThrows(IllegalArgumentException.class, () -> bits.get(1));, +        }, +, +        w.close();, +        dir.close();, +    }, +, +++ b/core/src/test/java/org/elasticsearch/common/lucene/LuceneTests.java, +import org.apache.lucene.analysis.core.KeywordAnalyzer;, +import org.apache.lucene.index.LeafReader;, +import org.apache.lucene.index.LeafReaderContext;, +import org.apache.lucene.search.Weight;, +import org.apache.lucene.util.Bits;, +    public void testAsSequentialAccessBits() throws Exception {, +        Directory dir = newDirectory();, +        IndexWriter w = new IndexWriter(dir, new IndexWriterConfig(new KeywordAnalyzer()));, +, +        Document doc = new Document();, +        doc.add(new StringField("foo", "bar", Store.NO));, +        w.addDocument(doc);, +, +        doc = new Document();, +        w.addDocument(doc);, +, +        doc = new Document();, +        doc.add(new StringField("foo", "bar", Store.NO));, +        w.addDocument(doc);, +, +, +        try (DirectoryReader reader = DirectoryReader.open(w)) {, +            IndexSearcher searcher = newSearcher(reader);, +            Weight termWeight = new TermQuery(new Term("foo", "bar")).createWeight(searcher, false);, +            assertEquals(1, reader.leaves().size());, +            LeafReaderContext leafReaderContext = reader.leaves().get(0);, +            Bits bits = Lucene.asSequentialAccessBits(leafReaderContext.reader().maxDoc(), termWeight.scorer(leafReaderContext));, +, +            expectThrows(IndexOutOfBoundsException.class, () -> bits.get(-1));, +            expectThrows(IndexOutOfBoundsException.class, () -> bits.get(leafReaderContext.reader().maxDoc()));, +            assertTrue(bits.get(0));, +            assertTrue(bits.get(0));, +            assertFalse(bits.get(1));, +            assertFalse(bits.get(1));, +            expectThrows(IllegalArgumentException.class, () -> bits.get(0));, +            assertTrue(bits.get(2));, +            assertTrue(bits.get(2));, +            expectThrows(IllegalArgumentException.class, () -> bits.get(1));, +        }, +, +        w.close();, +        dir.close();, +    }, +, +++ b/modules/percolator/src/main/java/org/elasticsearch/percolator/ExtractQueryTermsService.java, +import java.util.HashMap;, +import java.util.Map;, +import java.util.function.Function;, +    public static final String EXTRACTION_COMPLETE = "complete";, +    public static final String EXTRACTION_PARTIAL = "partial";, +    public static final String EXTRACTION_FAILED = "failed";, +, +    static final Map<Class<? extends Query>, Function<Query, Result>> queryProcessors;, +]