[+++ b/server/src/main/java/org/elasticsearch/index/shard/StoreRecovery.java, +                final long localCheckpoint = Long.parseLong(segmentInfos.userData.get(SequenceNumbers.LOCAL_CHECKPOINT_KEY));, +                    indexShard.shardPath().resolveTranslog(), localCheckpoint, shardId, indexShard.getPendingPrimaryTerm());, +            final long localCheckpoint = Long.parseLong(segmentInfos.userData.get(SequenceNumbers.LOCAL_CHECKPOINT_KEY));, +                indexShard.shardPath().resolveTranslog(), localCheckpoint, shardId, indexShard.getPendingPrimaryTerm());, +++ b/server/src/main/java/org/elasticsearch/index/shard/StoreRecovery.java, +                final long localCheckpoint = Long.parseLong(segmentInfos.userData.get(SequenceNumbers.LOCAL_CHECKPOINT_KEY));, +                    indexShard.shardPath().resolveTranslog(), localCheckpoint, shardId, indexShard.getPendingPrimaryTerm());, +            final long localCheckpoint = Long.parseLong(segmentInfos.userData.get(SequenceNumbers.LOCAL_CHECKPOINT_KEY));, +                indexShard.shardPath().resolveTranslog(), localCheckpoint, shardId, indexShard.getPendingPrimaryTerm());, +++ b/server/src/main/java/org/elasticsearch/index/store/Store.java, +            final long localCheckpoint = Long.parseLong(userData.get(SequenceNumbers.LOCAL_CHECKPOINT_KEY));, +            bootstrapNewHistory(localCheckpoint, maxSeqNo);, +     * Marks an existing lucene index with a new history uuid and sets the given local checkpoint, +     * This is used to make sure no existing shard will recover from this index using ops based recovery., +    public void bootstrapNewHistory(long localCheckpoint, long maxSeqNo) throws IOException {, +            map.put(SequenceNumbers.LOCAL_CHECKPOINT_KEY, Long.toString(localCheckpoint));, +++ b/server/src/main/java/org/elasticsearch/index/shard/StoreRecovery.java, +                final long localCheckpoint = Long.parseLong(segmentInfos.userData.get(SequenceNumbers.LOCAL_CHECKPOINT_KEY));, +                    indexShard.shardPath().resolveTranslog(), localCheckpoint, shardId, indexShard.getPendingPrimaryTerm());, +            final long localCheckpoint = Long.parseLong(segmentInfos.userData.get(SequenceNumbers.LOCAL_CHECKPOINT_KEY));, +                indexShard.shardPath().resolveTranslog(), localCheckpoint, shardId, indexShard.getPendingPrimaryTerm());, +++ b/server/src/main/java/org/elasticsearch/index/store/Store.java, +            final long localCheckpoint = Long.parseLong(userData.get(SequenceNumbers.LOCAL_CHECKPOINT_KEY));, +            bootstrapNewHistory(localCheckpoint, maxSeqNo);, +     * Marks an existing lucene index with a new history uuid and sets the given local checkpoint, +     * This is used to make sure no existing shard will recover from this index using ops based recovery., +    public void bootstrapNewHistory(long localCheckpoint, long maxSeqNo) throws IOException {, +            map.put(SequenceNumbers.LOCAL_CHECKPOINT_KEY, Long.toString(localCheckpoint));, +++ b/server/src/test/java/org/elasticsearch/index/shard/IndexShardTests.java, +        IndexShard target = newStartedShard(true, Settings.builder(), +            .put(IndexSettings.INDEX_SOFT_DELETES_SETTING.getKey(), source.indexSettings().isSoftDeleteEnabled()).build());, +        EngineTestCase.generateNewSeqNo(source.getEngine()); // create a gap in the history, +        indexDoc(source, "_doc", "2");, +        assertThat(target.getLocalCheckpoint(), equalTo(2L));, +        assertThat(target.seqNoStats().getMaxSeqNo(), equalTo(2L));, +        assertThat(target.seqNoStats().getGlobalCheckpoint(), equalTo(0L));, +            target.routingEntry().allocationId().getId()).getLocalCheckpoint(), equalTo(2L));, +        assertThat(target.seqNoStats().getGlobalCheckpoint(), equalTo(2L));, +        assertDocs(target, "0", "2");, +        closeShard(source, false);, +        closeShards(target);, +++ b/server/src/main/java/org/elasticsearch/index/shard/StoreRecovery.java, +                final long localCheckpoint = Long.parseLong(segmentInfos.userData.get(SequenceNumbers.LOCAL_CHECKPOINT_KEY));, +                    indexShard.shardPath().resolveTranslog(), localCheckpoint, shardId, indexShard.getPendingPrimaryTerm());, +            final long localCheckpoint = Long.parseLong(segmentInfos.userData.get(SequenceNumbers.LOCAL_CHECKPOINT_KEY));, +                indexShard.shardPath().resolveTranslog(), localCheckpoint, shardId, indexShard.getPendingPrimaryTerm());, +++ b/server/src/main/java/org/elasticsearch/index/store/Store.java, +            final long localCheckpoint = Long.parseLong(userData.get(SequenceNumbers.LOCAL_CHECKPOINT_KEY));, +            bootstrapNewHistory(localCheckpoint, maxSeqNo);, +     * Marks an existing lucene index with a new history uuid and sets the given local checkpoint, +     * This is used to make sure no existing shard will recover from this index using ops based recovery., +    public void bootstrapNewHistory(long localCheckpoint, long maxSeqNo) throws IOException {, +            map.put(SequenceNumbers.LOCAL_CHECKPOINT_KEY, Long.toString(localCheckpoint));, +++ b/server/src/test/java/org/elasticsearch/index/shard/IndexShardTests.java, +        IndexShard target = newStartedShard(true, Settings.builder(), +            .put(IndexSettings.INDEX_SOFT_DELETES_SETTING.getKey(), source.indexSettings().isSoftDeleteEnabled()).build());, +        EngineTestCase.generateNewSeqNo(source.getEngine()); // create a gap in the history, +        indexDoc(source, "_doc", "2");, +        assertThat(target.getLocalCheckpoint(), equalTo(2L));, +        assertThat(target.seqNoStats().getMaxSeqNo(), equalTo(2L));, +        assertThat(target.seqNoStats().getGlobalCheckpoint(), equalTo(0L));, +            target.routingEntry().allocationId().getId()).getLocalCheckpoint(), equalTo(2L));, +        assertThat(target.seqNoStats().getGlobalCheckpoint(), equalTo(2L));, +        assertDocs(target, "0", "2");, +        closeShard(source, false);, +        closeShards(target);, +++ b/test/framework/src/main/java/org/elasticsearch/index/shard/RestoreOnlyRepository.java, +/*, + * Licensed to Elasticsearch under one or more contributor, + * license agreements. See the NOTICE file distributed with, + * this work for additional information regarding copyright, + * ownership. Elasticsearch licenses this file to you under, + * the Apache License, Version 2.0 (the "License"); you may, + * not use this file except in compliance with the License., + * You may obtain a copy of the License at, + *, + *    http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing,, + * software distributed under the License is distributed on an, + * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY, + * KIND, either express or implied.  See the License for the, + * specific language governing permissions and limitations, + * under the License., + */, +package org.elasticsearch.index.shard;, +, +import org.apache.lucene.index.IndexCommit;, +import org.elasticsearch.Version;, +import org.elasticsearch.cluster.metadata.IndexMetaData;, +import org.elasticsearch.cluster.metadata.MetaData;, +import org.elasticsearch.cluster.metadata.RepositoryMetaData;, +import org.elasticsearch.cluster.node.DiscoveryNode;, +import org.elasticsearch.common.component.AbstractLifecycleComponent;, +import org.elasticsearch.index.snapshots.IndexShardSnapshotStatus;, +import org.elasticsearch.index.store.Store;, +import org.elasticsearch.repositories.IndexId;, +import org.elasticsearch.repositories.Repository;, +import org.elasticsearch.repositories.RepositoryData;]