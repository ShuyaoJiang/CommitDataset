[+++ b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ml/job/persistence/AnomalyDetectorsIndex.java, +import org.elasticsearch.ResourceAlreadyExistsException;, +import org.elasticsearch.action.ActionListener;, +import org.elasticsearch.action.admin.indices.alias.Alias;, +import org.elasticsearch.action.admin.indices.alias.IndicesAliasesRequest;, +import org.elasticsearch.action.admin.indices.create.CreateIndexRequest;, +import org.elasticsearch.action.admin.indices.create.CreateIndexResponse;, +import org.elasticsearch.action.support.IndicesOptions;, +import org.elasticsearch.action.support.master.AcknowledgedResponse;, +import org.elasticsearch.client.Client;, +import org.elasticsearch.cluster.ClusterState;, +import org.elasticsearch.cluster.metadata.IndexNameExpressionResolver;, +, +import java.util.Arrays;, +import java.util.Collections;, +, +import static org.elasticsearch.xpack.core.ClientHelper.ML_ORIGIN;, +import static org.elasticsearch.xpack.core.ClientHelper.executeAsyncWithOrigin;, +, +     * The name of the alias pointing to the appropriate index for writing job state, +     * @return The write alias name, +    public static String jobStateIndexWriteAlias() {, +        return AnomalyDetectorsIndexFields.STATE_INDEX_PREFIX + "-write";, +    /**, +     * Create the .ml-state index (if necessary), +     * Create the .ml-state-write alias for the .ml-state index (if necessary), +     */, +    public static void createStateIndexAndAliasIfNecessary(Client client, ClusterState state, final ActionListener<Boolean> finalListener) {, +, +        if (state.getMetaData().getAliasAndIndexLookup().containsKey(jobStateIndexWriteAlias())) {, +            finalListener.onResponse(false);, +            return;, +        }, +, +        final ActionListener<String> createAliasListener = ActionListener.wrap(, +            concreteIndexName -> {, +                final IndicesAliasesRequest request = client.admin(), +                    .indices(), +                    .prepareAliases(), +                    .addAlias(concreteIndexName, jobStateIndexWriteAlias()), +                    .request();, +                executeAsyncWithOrigin(client.threadPool().getThreadContext(),, +                    ML_ORIGIN,, +                    request,, +                    ActionListener.<AcknowledgedResponse>wrap(, +                        resp -> finalListener.onResponse(resp.isAcknowledged()),, +                        finalListener::onFailure),, +                    client.admin().indices()::aliases);, +            },, +            finalListener::onFailure, +        );, +, +        IndexNameExpressionResolver indexNameExpressionResolver = new IndexNameExpressionResolver();, +        String[] stateIndices = indexNameExpressionResolver.concreteIndexNames(state,, +            IndicesOptions.lenientExpandOpen(),, +            jobStateIndexPattern());, +        if (stateIndices.length > 0) {, +            Arrays.sort(stateIndices, Collections.reverseOrder());, +            createAliasListener.onResponse(stateIndices[0]);, +        } else {, +            CreateIndexRequest createIndexRequest = client.admin(), +                .indices(), +                .prepareCreate(AnomalyDetectorsIndexFields.STATE_INDEX_PREFIX), +                .addAlias(new Alias(jobStateIndexWriteAlias())), +                .request();, +            executeAsyncWithOrigin(client.threadPool().getThreadContext(),, +                ML_ORIGIN,, +                createIndexRequest,, +                ActionListener.<CreateIndexResponse>wrap(, +                    createIndexResponse -> finalListener.onResponse(true),, +                    createIndexFailure -> {, +                        // If it was created between our last check, and this request being handled, we should add the alias, +                        // Adding an alias that already exists is idempotent. So, no need to double check if the alias exists, +                        // as well., +                        if (createIndexFailure instanceof ResourceAlreadyExistsException) {, +                            createAliasListener.onResponse(AnomalyDetectorsIndexFields.STATE_INDEX_PREFIX);, +                        } else {, +                            finalListener.onFailure(createIndexFailure);, +                        }, +                    }),, +                client.admin().indices()::create);, +        }, +    }, +, +++ b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ml/job/persistence/AnomalyDetectorsIndex.java, +import org.elasticsearch.ResourceAlreadyExistsException;, +import org.elasticsearch.action.ActionListener;, +import org.elasticsearch.action.admin.indices.alias.Alias;, +import org.elasticsearch.action.admin.indices.alias.IndicesAliasesRequest;, +import org.elasticsearch.action.admin.indices.create.CreateIndexRequest;, +import org.elasticsearch.action.admin.indices.create.CreateIndexResponse;, +import org.elasticsearch.action.support.IndicesOptions;, +import org.elasticsearch.action.support.master.AcknowledgedResponse;, +import org.elasticsearch.client.Client;, +import org.elasticsearch.cluster.ClusterState;, +import org.elasticsearch.cluster.metadata.IndexNameExpressionResolver;, +, +import java.util.Arrays;, +import java.util.Collections;, +]