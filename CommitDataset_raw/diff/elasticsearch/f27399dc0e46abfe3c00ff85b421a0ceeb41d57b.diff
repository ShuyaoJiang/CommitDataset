[+++ b/core/src/main/java/org/elasticsearch/search/sort/FieldSortBuilder.java, +                        throw new ParsingException(parser.getTokenLocation(), "Sort order [{}] not supported.", sortOrder);, +                    throw new ParsingException(parser.getTokenLocation(), "Option [{}] not supported.", currentFieldName);, +++ b/core/src/main/java/org/elasticsearch/search/sort/FieldSortBuilder.java, +                        throw new ParsingException(parser.getTokenLocation(), "Sort order [{}] not supported.", sortOrder);, +                    throw new ParsingException(parser.getTokenLocation(), "Option [{}] not supported.", currentFieldName);, +++ b/core/src/main/java/org/elasticsearch/search/sort/GeoDistanceSortBuilder.java, +import org.elasticsearch.common.ParsingException;, +import org.elasticsearch.common.xcontent.XContentParser.Token;, +    public static final ParseField REVERSE_FORBIDDEN = new ParseField("reverse");, +                    if (fieldName != null && fieldName.equals(currentName) == false) {, +                        throw new ParsingException(, +                                parser.getTokenLocation(),, +                                "Trying to reset fieldName to [{}], already set to [{}].",, +                                currentName,, +                                fieldName);, +                    }, +                if (parseFieldMatcher.match(currentName, ORDER_FIELD)) {, +                } else if (token == Token.VALUE_STRING){, +                    if (fieldName != null && fieldName.equals(currentName) == false) {, +                        throw new ParsingException(, +                                parser.getTokenLocation(),, +                                "Trying to reset fieldName to [{}], already set to [{}].",, +                                currentName,, +                                fieldName);, +                    }, +, +                } else {, +                    throw new ParsingException(, +                            parser.getTokenLocation(),, +                            "Only geohashes of type string supported for field [{}]",, +                            currentName);, +                    throw new ElasticsearchParseException(, +                            "illegal latitude value [{}] for [GeoDistanceSort] for field [{}].", , +                            point.lat(),, +                            fieldName);, +                    throw new ElasticsearchParseException(, +                            "illegal longitude value [{}] for [GeoDistanceSort] for field [{}].",, +                            point.lon(),, +                            fieldName);, +++ b/core/src/main/java/org/elasticsearch/search/sort/FieldSortBuilder.java, +                        throw new ParsingException(parser.getTokenLocation(), "Sort order [{}] not supported.", sortOrder);, +                    throw new ParsingException(parser.getTokenLocation(), "Option [{}] not supported.", currentFieldName);, +++ b/core/src/main/java/org/elasticsearch/search/sort/GeoDistanceSortBuilder.java, +import org.elasticsearch.common.ParsingException;, +import org.elasticsearch.common.xcontent.XContentParser.Token;, +    public static final ParseField REVERSE_FORBIDDEN = new ParseField("reverse");, +                    if (fieldName != null && fieldName.equals(currentName) == false) {, +                        throw new ParsingException(, +                                parser.getTokenLocation(),, +                                "Trying to reset fieldName to [{}], already set to [{}].",, +                                currentName,, +                                fieldName);, +                    }, +                if (parseFieldMatcher.match(currentName, ORDER_FIELD)) {, +                } else if (token == Token.VALUE_STRING){, +                    if (fieldName != null && fieldName.equals(currentName) == false) {, +                        throw new ParsingException(, +                                parser.getTokenLocation(),, +                                "Trying to reset fieldName to [{}], already set to [{}].",, +                                currentName,, +                                fieldName);, +                    }, +, +                } else {, +                    throw new ParsingException(, +                            parser.getTokenLocation(),, +                            "Only geohashes of type string supported for field [{}]",, +                            currentName);, +                    throw new ElasticsearchParseException(, +                            "illegal latitude value [{}] for [GeoDistanceSort] for field [{}].", , +                            point.lat(),, +                            fieldName);, +                    throw new ElasticsearchParseException(, +                            "illegal longitude value [{}] for [GeoDistanceSort] for field [{}].",, +                            point.lon(),, +                            fieldName);, +++ b/core/src/main/java/org/elasticsearch/search/sort/ScoreSortBuilder.java, +    private static final ParseField REVERSE_FORBIDDEN = new ParseField("reverse");, +                if (matcher.match(currentName, ORDER_FIELD)) {, +++ b/core/src/main/java/org/elasticsearch/search/sort/FieldSortBuilder.java, +                        throw new ParsingException(parser.getTokenLocation(), "Sort order [{}] not supported.", sortOrder);, +                    throw new ParsingException(parser.getTokenLocation(), "Option [{}] not supported.", currentFieldName);, +++ b/core/src/main/java/org/elasticsearch/search/sort/GeoDistanceSortBuilder.java, +import org.elasticsearch.common.ParsingException;, +import org.elasticsearch.common.xcontent.XContentParser.Token;, +    public static final ParseField REVERSE_FORBIDDEN = new ParseField("reverse");, +                    if (fieldName != null && fieldName.equals(currentName) == false) {, +                        throw new ParsingException(, +                                parser.getTokenLocation(),, +                                "Trying to reset fieldName to [{}], already set to [{}].",, +                                currentName,, +                                fieldName);, +                    }, +                if (parseFieldMatcher.match(currentName, ORDER_FIELD)) {, +                } else if (token == Token.VALUE_STRING){, +                    if (fieldName != null && fieldName.equals(currentName) == false) {, +                        throw new ParsingException(, +                                parser.getTokenLocation(),, +                                "Trying to reset fieldName to [{}], already set to [{}].",]