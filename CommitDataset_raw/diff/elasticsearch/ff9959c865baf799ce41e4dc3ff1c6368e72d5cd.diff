[+++ b/core/src/main/java/org/elasticsearch/discovery/zen/UnicastZenPing.java, +     * The pings that are sent carry a timeout of 1.25 times the specified {@link TimeValue}. When pinging each node, a connection and, +     * handshake is performed, with a connection timeout of the specified {@link TimeValue}., +++ b/core/src/main/java/org/elasticsearch/discovery/zen/UnicastZenPing.java, +     * The pings that are sent carry a timeout of 1.25 times the specified {@link TimeValue}. When pinging each node, a connection and, +     * handshake is performed, with a connection timeout of the specified {@link TimeValue}., +++ b/core/src/main/java/org/elasticsearch/indices/recovery/RecoveryFailedException.java, +        super(shardId + ": Recovery failed " + (sourceNode != null ? "from " + sourceNode + " into " : "on ") +, +                  targetNode + (extraInfo == null ? "" : " (" + extraInfo + ")"), cause);, +++ b/core/src/main/java/org/elasticsearch/discovery/zen/UnicastZenPing.java, +     * The pings that are sent carry a timeout of 1.25 times the specified {@link TimeValue}. When pinging each node, a connection and, +     * handshake is performed, with a connection timeout of the specified {@link TimeValue}., +++ b/core/src/main/java/org/elasticsearch/indices/recovery/RecoveryFailedException.java, +        super(shardId + ": Recovery failed " + (sourceNode != null ? "from " + sourceNode + " into " : "on ") +, +                  targetNode + (extraInfo == null ? "" : " (" + extraInfo + ")"), cause);, +++ b/core/src/test/java/org/elasticsearch/discovery/zen/UnicastZenPingTests.java, +import org.elasticsearch.test.junit.annotations.TestLogging;, +    @TestLogging("org.elasticsearch.transport:TRACE,org.elasticsearch.discovery.zen.UnicastZenPing:TRACE"), +        Collection<ZenPing.PingResponse> pingResponses = zenPingA.pingAndWait(TimeValue.timeValueMillis(500));, +        assertCountersMoreThan(handleA, handleB, handleC, handleD);, +        pingResponses = zenPingB.pingAndWait(TimeValue.timeValueMillis(500));, +        assertCountersMoreThan(handleB, handleA, handleC, handleD);, +        pingResponses = zenPingC.pingAndWait(TimeValue.timeValueMillis(500));, +        assertCountersMoreThan(handleC, handleA, handleB, handleD);, +        pingResponses = zenPingD.pingAndWait(TimeValue.timeValueMillis(500));, +        assertCountersMoreThan(handleD, handleA, handleB, handleC);, +            final Collection<ZenPing.PingResponse> pingResponses = zenPingA.pingAndWait(TimeValue.timeValueMillis(500));, +            assertCountersMoreThan(handleA, handleC);, +        final HashMap<TransportAddress, Integer> moreThan = new HashMap<>();, +        // we should see at least one ping to UZP_B, and one more ping than we have already seen to UZP_C, +        moreThan.put(handleB.address, 0);, +        moreThan.put(handleC.address, handleA.counters.get(handleC.address).intValue());, +, +            final Collection<ZenPing.PingResponse> secondPingResponses = zenPingA.pingAndWait(TimeValue.timeValueMillis(500));, +            assertThat(ids, equalTo(new HashSet<>(Arrays.asList("UZP_B", "UZP_C"))));, +            assertCountersMoreThan(moreThan, handleA, handleB, handleC);, +        final TimeValue resolveTimeout = TimeValue.timeValueSeconds(randomIntBetween(1, 3));, +            TimeValue.timeValueSeconds(1));, +    private void assertCountersMoreThan(final NetworkHandle that, final NetworkHandle...handles) {, +        final HashMap<TransportAddress, Integer> moreThan = new HashMap<>();, +        for (final NetworkHandle handle : handles) {, +            assert handle != that;, +            moreThan.put(handle.address, 0);, +        assertCountersMoreThan(moreThan, that, handles);, +    }, +, +    private void assertCountersMoreThan(, +            final Map<TransportAddress, Integer> moreThan,, +            final NetworkHandle that,, +            final NetworkHandle... handles) {, +        for (final NetworkHandle handle : handles) {, +            assert handle != that;, +            assertThat(that.counters.get(handle.address).get(), greaterThan(moreThan.get(handle.address)));, +++ b/core/src/main/java/org/elasticsearch/discovery/zen/UnicastZenPing.java, +     * The pings that are sent carry a timeout of 1.25 times the specified {@link TimeValue}. When pinging each node, a connection and, +     * handshake is performed, with a connection timeout of the specified {@link TimeValue}., +++ b/core/src/main/java/org/elasticsearch/indices/recovery/RecoveryFailedException.java, +        super(shardId + ": Recovery failed " + (sourceNode != null ? "from " + sourceNode + " into " : "on ") +, +                  targetNode + (extraInfo == null ? "" : " (" + extraInfo + ")"), cause);, +++ b/core/src/test/java/org/elasticsearch/discovery/zen/UnicastZenPingTests.java, +import org.elasticsearch.test.junit.annotations.TestLogging;, +    @TestLogging("org.elasticsearch.transport:TRACE,org.elasticsearch.discovery.zen.UnicastZenPing:TRACE"), +        Collection<ZenPing.PingResponse> pingResponses = zenPingA.pingAndWait(TimeValue.timeValueMillis(500));, +        assertCountersMoreThan(handleA, handleB, handleC, handleD);, +        pingResponses = zenPingB.pingAndWait(TimeValue.timeValueMillis(500));, +        assertCountersMoreThan(handleB, handleA, handleC, handleD);, +        pingResponses = zenPingC.pingAndWait(TimeValue.timeValueMillis(500));, +        assertCountersMoreThan(handleC, handleA, handleB, handleD);, +        pingResponses = zenPingD.pingAndWait(TimeValue.timeValueMillis(500));, +        assertCountersMoreThan(handleD, handleA, handleB, handleC);, +            final Collection<ZenPing.PingResponse> pingResponses = zenPingA.pingAndWait(TimeValue.timeValueMillis(500));, +            assertCountersMoreThan(handleA, handleC);, +        final HashMap<TransportAddress, Integer> moreThan = new HashMap<>();, +        // we should see at least one ping to UZP_B, and one more ping than we have already seen to UZP_C, +        moreThan.put(handleB.address, 0);, +        moreThan.put(handleC.address, handleA.counters.get(handleC.address).intValue());, +, +            final Collection<ZenPing.PingResponse> secondPingResponses = zenPingA.pingAndWait(TimeValue.timeValueMillis(500));, +            assertThat(ids, equalTo(new HashSet<>(Arrays.asList("UZP_B", "UZP_C"))));, +            assertCountersMoreThan(moreThan, handleA, handleB, handleC);, +        final TimeValue resolveTimeout = TimeValue.timeValueSeconds(randomIntBetween(1, 3));, +            TimeValue.timeValueSeconds(1));, +    private void assertCountersMoreThan(final NetworkHandle that, final NetworkHandle...handles) {, +        final HashMap<TransportAddress, Integer> moreThan = new HashMap<>();, +        for (final NetworkHandle handle : handles) {, +            assert handle != that;, +            moreThan.put(handle.address, 0);, +        assertCountersMoreThan(moreThan, that, handles);, +    }, +, +    private void assertCountersMoreThan(, +            final Map<TransportAddress, Integer> moreThan,, +            final NetworkHandle that,, +            final NetworkHandle... handles) {, +        for (final NetworkHandle handle : handles) {, +            assert handle != that;, +            assertThat(that.counters.get(handle.address).get(), greaterThan(moreThan.get(handle.address)));, +++ b/docs/plugins/discovery-ec2.asciidoc, +* `ap-south-1` for Asia Pacific (Mumbai), +++ b/core/src/main/java/org/elasticsearch/discovery/zen/UnicastZenPing.java]