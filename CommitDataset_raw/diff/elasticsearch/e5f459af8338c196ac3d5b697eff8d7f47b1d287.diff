[+++ b/src/main/java/org/elasticsearch/cluster/service/InternalClusterService.java, +                logger.debug("Set cluster state to version {}. Broadcasting to listeners.", newClusterState.version());, +                logger.debug("processing [{}]: done applying updated cluster_state (version: {})", source, newClusterState.version());, +++ b/src/main/java/org/elasticsearch/cluster/service/InternalClusterService.java, +                logger.debug("Set cluster state to version {}. Broadcasting to listeners.", newClusterState.version());, +                logger.debug("processing [{}]: done applying updated cluster_state (version: {})", source, newClusterState.version());, +++ b/src/main/java/org/elasticsearch/index/mapper/internal/SourceFieldMapper.java, +            if (sourceMergeWith.includes != null) {, +                this.includes = sourceMergeWith.includes;, +            }, +            if (sourceMergeWith.excludes != null) {, +                this.excludes = sourceMergeWith.excludes;, +            }, +++ b/src/main/java/org/elasticsearch/cluster/service/InternalClusterService.java, +                logger.debug("Set cluster state to version {}. Broadcasting to listeners.", newClusterState.version());, +                logger.debug("processing [{}]: done applying updated cluster_state (version: {})", source, newClusterState.version());, +++ b/src/main/java/org/elasticsearch/index/mapper/internal/SourceFieldMapper.java, +            if (sourceMergeWith.includes != null) {, +                this.includes = sourceMergeWith.includes;, +            }, +            if (sourceMergeWith.excludes != null) {, +                this.excludes = sourceMergeWith.excludes;, +            }, +++ b/src/test/java/org/elasticsearch/test/integration/AbstractSharedClusterTest.java, +    protected IndexResponse index(String index, String type, String id, XContentBuilder source) {, +        return client().prepareIndex(index, type, id).setSource(source).execute().actionGet();, +    }, +, +++ b/src/main/java/org/elasticsearch/cluster/service/InternalClusterService.java, +                logger.debug("Set cluster state to version {}. Broadcasting to listeners.", newClusterState.version());, +                logger.debug("processing [{}]: done applying updated cluster_state (version: {})", source, newClusterState.version());, +++ b/src/main/java/org/elasticsearch/index/mapper/internal/SourceFieldMapper.java, +            if (sourceMergeWith.includes != null) {, +                this.includes = sourceMergeWith.includes;, +            }, +            if (sourceMergeWith.excludes != null) {, +                this.excludes = sourceMergeWith.excludes;, +            }, +++ b/src/test/java/org/elasticsearch/test/integration/AbstractSharedClusterTest.java, +    protected IndexResponse index(String index, String type, String id, XContentBuilder source) {, +        return client().prepareIndex(index, type, id).setSource(source).execute().actionGet();, +    }, +, +++ b/src/test/java/org/elasticsearch/test/integration/indices/mapping/UpdateMappingTests.java, +import org.elasticsearch.action.get.GetResponse;, +import org.elasticsearch.cluster.metadata.MappingMetaData;, +    public void updateIncludeExclude() throws Exception {, +        createIndexMapped("test", "type", "normal", "long", "exclude", "long", "include", "long");, +, +        logger.info("Index doc 1");, +        index("test", "type", "1", JsonXContent.contentBuilder().startObject(), +                .field("normal", 1).field("exclude", 1).field("include", 1), +                .endObject(), +        );, +        refresh(); // commit it for later testing., +, +, +        logger.info("Adding exclude settings");, +        PutMappingResponse putResponse = client().admin().indices().preparePutMapping("test").setType("type").setSource(, +                JsonXContent.contentBuilder().startObject().startObject("type"), +                        .startObject("_source"), +                        .startArray("excludes").value("exclude").endArray(), +                        .endObject().endObject(), +        ).get();, +, +        assertTrue(putResponse.isAcknowledged());, +, +        logger.info("Index doc 2");, +        index("test", "type", "2", JsonXContent.contentBuilder().startObject(), +                .field("normal", 2).field("exclude", 1).field("include", 2), +                .endObject(), +        );, +, +        GetResponse getResponse = get("test", "type", "2");, +        assertThat(getResponse.getSource(), hasKey("normal"));, +        assertThat(getResponse.getSource(), not(hasKey("exclude")));, +        assertThat(getResponse.getSource(), hasKey("include"));, +, +, +        putResponse = client().admin().indices().preparePutMapping("test").setType("type").setSource(, +                JsonXContent.contentBuilder().startObject().startObject("type"), +                        .startObject("_source"), +                        .startArray("excludes").endArray(), +                        .startArray("includes").value("include").endArray(), +                        .endObject().endObject(), +        ).get();, +        assertTrue(putResponse.isAcknowledged());, +, +        GetMappingsResponse getMappingsResponse = client().admin().indices().prepareGetMappings("test").get();, +        MappingMetaData typeMapping = getMappingsResponse.getMappings().get("test").get("type");, +        assertThat((Map<String, Object>) typeMapping.getSourceAsMap().get("_source"), hasKey("includes"));, +        assertThat((Map<String, Object>) typeMapping.getSourceAsMap().get("_source"), not(hasKey("excludes")));, +, +, +        index("test", "type", "3", JsonXContent.contentBuilder().startObject(), +                .field("normal", 3).field("exclude", 3).field("include", 3), +                .endObject(), +        );, +, +        getResponse = get("test", "type", "3");]