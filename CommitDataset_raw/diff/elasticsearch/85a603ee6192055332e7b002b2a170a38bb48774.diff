[+++ b/server/src/main/java/org/elasticsearch/search/aggregations/pipeline/BucketSortPipelineAggregator.java, +        List<ComparableBucket> ordered = new ArrayList<>();, +                ordered.add(comparableBucket);, +        Collections.sort(ordered);, +        // We just have to get as many elements as we expect in results and store them in the same order starting from, +        // the specified offset and taking currentSize into consideration., +        int limit = Math.min(from + currentSize, ordered.size());, +        List<InternalMultiBucketAggregation.InternalBucket> newBuckets = new ArrayList<>();, +        for (int i = from; i < limit; ++i) {, +            newBuckets.add(ordered.get(i).internalBucket);, +                } else if (thatValue == null) {, +                    return -1;, +                    compareResult = sort.order() == SortOrder.DESC ? -thisValue.compareTo(thatValue) : thisValue.compareTo(thatValue);, +++ b/server/src/main/java/org/elasticsearch/search/aggregations/pipeline/BucketSortPipelineAggregator.java, +        List<ComparableBucket> ordered = new ArrayList<>();, +                ordered.add(comparableBucket);, +        Collections.sort(ordered);, +        // We just have to get as many elements as we expect in results and store them in the same order starting from, +        // the specified offset and taking currentSize into consideration., +        int limit = Math.min(from + currentSize, ordered.size());, +        List<InternalMultiBucketAggregation.InternalBucket> newBuckets = new ArrayList<>();, +        for (int i = from; i < limit; ++i) {, +            newBuckets.add(ordered.get(i).internalBucket);, +                } else if (thatValue == null) {, +                    return -1;, +                    compareResult = sort.order() == SortOrder.DESC ? -thisValue.compareTo(thatValue) : thisValue.compareTo(thatValue);, +++ b/server/src/test/java/org/elasticsearch/search/aggregations/pipeline/BucketSortIT.java, +import static org.elasticsearch.search.aggregations.AggregationBuilders.max;, +    public void testSortTermsOnKeyWithSize() {, +        SearchResponse response = client().prepareSearch(INDEX), +            .setSize(0), +            .addAggregation(terms("foos").field(TERM_FIELD), +                .subAggregation(bucketSort("bucketSort", Arrays.asList(new FieldSortBuilder("_key"))).size(3))), +            .get();, +, +        assertSearchResponse(response);, +, +        Terms terms = response.getAggregations().get("foos");, +        assertThat(terms, notNullValue());, +        List<? extends Terms.Bucket> termsBuckets = terms.getBuckets();, +        assertEquals(3, termsBuckets.size());, +        String previousKey = (String) termsBuckets.get(0).getKey();, +        for (Terms.Bucket termBucket : termsBuckets) {, +            assertThat(previousKey, lessThanOrEqualTo((String) termBucket.getKey()));, +            previousKey = (String) termBucket.getKey();, +        }, +    }, +, +    public void testSortTermsOnSubAggregationPreservesOrderOnEquals() {, +        SearchResponse response = client().prepareSearch(INDEX), +            .setSize(0), +            .addAggregation(terms("foos").field(TERM_FIELD), +                .subAggregation(bucketSort("keyBucketSort", Arrays.asList(new FieldSortBuilder("_key")))), +                .subAggregation(max("max").field("missingValue").missing(1)), +                .subAggregation(bucketSort("maxBucketSort", Arrays.asList(new FieldSortBuilder("max"))))), +            .get();, +, +        assertSearchResponse(response);, +, +        Terms terms = response.getAggregations().get("foos");, +        assertThat(terms, notNullValue());, +        List<? extends Terms.Bucket> termsBuckets = terms.getBuckets();, +, +        // Since all max values are equal, we expect the order of keyBucketSort to have been preserved, +        String previousKey = (String) termsBuckets.get(0).getKey();, +        for (Terms.Bucket termBucket : termsBuckets) {, +            assertThat(previousKey, lessThanOrEqualTo((String) termBucket.getKey()));, +            previousKey = (String) termBucket.getKey();, +        }, +    }, +]