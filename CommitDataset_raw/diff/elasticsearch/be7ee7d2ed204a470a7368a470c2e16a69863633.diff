[+++ b/x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/job/persistence/JobResultsProvider.java, +import org.elasticsearch.action.admin.indices.mapping.get.GetMappingsRequest;, +import org.elasticsearch.action.admin.indices.mapping.get.GetMappingsResponse;, +import org.elasticsearch.common.collect.ImmutableOpenMap;, +                                    // Add the term field mappings and alias.  The complication is that the state at the, +                                    // beginning of the operation doesn't have any knowledge of the index, as it's only, +                                    // just been created.  So we need yet another operation to get the mappings for it., +                                    getLatestIndexMappings(indexName, ActionListener.wrap(, +                                        response -> {, +                                            // Expect one index and one type.  If this is not the case then it means the, +                                            // index has been deleted almost immediately after being created, and this is, +                                            // so unlikely that it's reasonable to fail the whole operation., +                                            ImmutableOpenMap<String, MappingMetaData> indexMappings =, +                                                response.getMappings().iterator().next().value;, +                                            MappingMetaData typeMappings = indexMappings.iterator().next().value;, +                                            addTermsAndAliases(typeMappings, indexName, termFields, createAliasListener);, +                                        },, +                                        finalListener::onFailure, +                                    ));, +            MappingMetaData mapping = state.metaData().index(indexName).mapping();, +            addTermsAndAliases(mapping, indexName, termFields, createAliasListener);, +        }, +    }, +    private void getLatestIndexMappings(final String indexName, final ActionListener<GetMappingsResponse> listener) {, +, +        GetMappingsRequest getMappingsRequest = client.admin().indices().prepareGetMappings(indexName).request();, +        executeAsyncWithOrigin(client.threadPool().getThreadContext(), ML_ORIGIN, getMappingsRequest, listener,, +            client.admin().indices()::getMappings);, +    }, +, +    private void addTermsAndAliases(final MappingMetaData mapping, final String indexName, final Collection<String> termFields,, +                                    final ActionListener<Boolean> listener) {, +        long fieldCountLimit = MapperService.INDEX_MAPPING_TOTAL_FIELDS_LIMIT_SETTING.get(settings);, +, +        if (violatedFieldCountLimit(termFields.size(), fieldCountLimit, mapping)) {, +            listener.onFailure(new IllegalArgumentException(message));, +            updateIndexMappingWithTermFields(indexName, mapping.type(), termFields, listener);, +    public static boolean violatedFieldCountLimit(long additionalFieldCount, long fieldCountLimit, MappingMetaData mapping) {, +++ b/x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/job/persistence/JobResultsProvider.java, +import org.elasticsearch.action.admin.indices.mapping.get.GetMappingsRequest;, +import org.elasticsearch.action.admin.indices.mapping.get.GetMappingsResponse;, +import org.elasticsearch.common.collect.ImmutableOpenMap;, +                                    // Add the term field mappings and alias.  The complication is that the state at the, +                                    // beginning of the operation doesn't have any knowledge of the index, as it's only, +                                    // just been created.  So we need yet another operation to get the mappings for it., +                                    getLatestIndexMappings(indexName, ActionListener.wrap(, +                                        response -> {, +                                            // Expect one index and one type.  If this is not the case then it means the, +                                            // index has been deleted almost immediately after being created, and this is, +                                            // so unlikely that it's reasonable to fail the whole operation., +                                            ImmutableOpenMap<String, MappingMetaData> indexMappings =, +                                                response.getMappings().iterator().next().value;, +                                            MappingMetaData typeMappings = indexMappings.iterator().next().value;, +                                            addTermsAndAliases(typeMappings, indexName, termFields, createAliasListener);, +                                        },, +                                        finalListener::onFailure, +                                    ));, +            MappingMetaData mapping = state.metaData().index(indexName).mapping();, +            addTermsAndAliases(mapping, indexName, termFields, createAliasListener);, +        }, +    }, +    private void getLatestIndexMappings(final String indexName, final ActionListener<GetMappingsResponse> listener) {, +, +        GetMappingsRequest getMappingsRequest = client.admin().indices().prepareGetMappings(indexName).request();, +        executeAsyncWithOrigin(client.threadPool().getThreadContext(), ML_ORIGIN, getMappingsRequest, listener,, +            client.admin().indices()::getMappings);, +    }, +, +    private void addTermsAndAliases(final MappingMetaData mapping, final String indexName, final Collection<String> termFields,, +                                    final ActionListener<Boolean> listener) {, +        long fieldCountLimit = MapperService.INDEX_MAPPING_TOTAL_FIELDS_LIMIT_SETTING.get(settings);, +, +        if (violatedFieldCountLimit(termFields.size(), fieldCountLimit, mapping)) {, +            listener.onFailure(new IllegalArgumentException(message));, +            updateIndexMappingWithTermFields(indexName, mapping.type(), termFields, listener);, +    public static boolean violatedFieldCountLimit(long additionalFieldCount, long fieldCountLimit, MappingMetaData mapping) {, +++ b/x-pack/plugin/ml/src/test/java/org/elasticsearch/xpack/ml/integration/JobResultsProviderIT.java, +import org.elasticsearch.action.ActionFuture;, +import org.elasticsearch.action.admin.indices.mapping.get.GetMappingsAction;, +import org.elasticsearch.action.admin.indices.mapping.get.GetMappingsRequest;, +import org.elasticsearch.action.admin.indices.mapping.get.GetMappingsResponse;, +import org.elasticsearch.cluster.metadata.MappingMetaData;, +import org.elasticsearch.common.collect.ImmutableOpenMap;, +import org.elasticsearch.xpack.core.ml.job.persistence.AnomalyDetectorsIndexFields;, +import java.util.Map;, +    public void testMultipleSimultaneousJobCreations() {, +, +        int numJobs = randomIntBetween(4, 7);, +, +        // Each job should result in one extra field being added to the results index mappings: field1, field2, field3, etc., +        // Due to all being created simultaneously this test may reveal race conditions in the code that updates the mappings., +        List<PutJobAction.Request> requests = new ArrayList<>(numJobs);, +        for (int i = 1; i <= numJobs; ++i) {, +            Job.Builder builder = new Job.Builder("job" + i);, +            AnalysisConfig.Builder ac = createAnalysisConfig("field" + i, Collections.emptyList());, +            DataDescription.Builder dc = new DataDescription.Builder();, +            builder.setAnalysisConfig(ac);, +            builder.setDataDescription(dc);, +, +            requests.add(new PutJobAction.Request(builder));]