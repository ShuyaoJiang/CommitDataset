[+++ b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/parser/ExpressionBuilder.java, +import java.math.BigInteger;, +        boolean value;, +        try {, +            value = Booleans.parseBoolean(ctx.getText().toLowerCase(Locale.ROOT), false);, +        } catch(IllegalArgumentException iae) {, +            throw new ParsingException(source(ctx), iae.getMessage());, +        }, +        return new Literal(source(ctx), Boolean.valueOf(value), DataType.BOOLEAN);, +        double value;, +        try {, +            value = Double.parseDouble(ctx.getText());, +        } catch (NumberFormatException nfe) {, +            throw new ParsingException(source(ctx), "Cannot parse number [{}]", ctx.getText());, +        }, +        if (Double.isInfinite(value)) {, +            throw new ParsingException(source(ctx), "Number [{}] is too large", ctx.getText());, +        }, +        if (Double.isNaN(value)) {, +            throw new ParsingException(source(ctx), "[{}] cannot be parsed as a number (NaN)", ctx.getText());, +        }, +        return new Literal(source(ctx), Double.valueOf(value), DataType.DOUBLE);, +        long value;, +        try {, +            value = Long.parseLong(ctx.getText());, +        } catch (NumberFormatException nfe) {, +            try {, +                BigInteger bi = new BigInteger(ctx.getText());, +                try {, +                    bi.longValueExact();, +                } catch (ArithmeticException ae) {, +                    throw new ParsingException(source(ctx), "Number [{}] is too large", ctx.getText());, +                }, +            } catch (NumberFormatException ex) {, +                // parsing fails, go through, +            }, +            throw new ParsingException(source(ctx), "Cannot parse number [{}]", ctx.getText());, +        }, +++ b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/parser/ExpressionBuilder.java, +import java.math.BigInteger;, +        boolean value;, +        try {, +            value = Booleans.parseBoolean(ctx.getText().toLowerCase(Locale.ROOT), false);, +        } catch(IllegalArgumentException iae) {, +            throw new ParsingException(source(ctx), iae.getMessage());, +        }, +        return new Literal(source(ctx), Boolean.valueOf(value), DataType.BOOLEAN);, +        double value;, +        try {, +            value = Double.parseDouble(ctx.getText());, +        } catch (NumberFormatException nfe) {, +            throw new ParsingException(source(ctx), "Cannot parse number [{}]", ctx.getText());, +        }, +        if (Double.isInfinite(value)) {, +            throw new ParsingException(source(ctx), "Number [{}] is too large", ctx.getText());, +        }, +        if (Double.isNaN(value)) {, +            throw new ParsingException(source(ctx), "[{}] cannot be parsed as a number (NaN)", ctx.getText());, +        }, +        return new Literal(source(ctx), Double.valueOf(value), DataType.DOUBLE);, +        long value;, +        try {, +            value = Long.parseLong(ctx.getText());, +        } catch (NumberFormatException nfe) {, +            try {, +                BigInteger bi = new BigInteger(ctx.getText());, +                try {, +                    bi.longValueExact();, +                } catch (ArithmeticException ae) {, +                    throw new ParsingException(source(ctx), "Number [{}] is too large", ctx.getText());, +                }, +            } catch (NumberFormatException ex) {, +                // parsing fails, go through, +            }, +            throw new ParsingException(source(ctx), "Cannot parse number [{}]", ctx.getText());, +        }, +++ b/x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/parser/ExpressionTests.java, +, +    public void testLiteralBoolean() throws Exception {, +        Expression lt = parser.createExpression("TRUE");, +        assertEquals(Literal.class, lt.getClass());, +        Literal l = (Literal) lt;, +        assertEquals(Boolean.TRUE, l.value());, +        assertEquals(DataType.BOOLEAN, l.dataType());, +    }, +, +, +    public void testLiteralIntegerInvalid() throws Exception {, +        ParsingException ex = expectThrows(ParsingException.class, () -> parser.createExpression("123456789098765432101"));, +        assertEquals("Number [123456789098765432101] is too large", ex.getErrorMessage());, +    }, +, +    public void testLiteralDecimalTooBig() throws Exception {, +        ParsingException ex = expectThrows(ParsingException.class, () -> parser.createExpression("1.9976931348623157e+308"));, +        assertEquals("Number [1.9976931348623157e+308] is too large", ex.getErrorMessage());, +    }]