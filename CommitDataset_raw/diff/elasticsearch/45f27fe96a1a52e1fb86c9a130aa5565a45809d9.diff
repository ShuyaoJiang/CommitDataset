[+++ b/src/main/java/org/elasticsearch/index/fielddata/IndexFieldDataService.java, +                .put(Tuple.tuple("string", "packed_bytes"), new PackedBytesIndexFieldData.Builder()), +++ b/src/main/java/org/elasticsearch/index/fielddata/IndexFieldDataService.java, +                .put(Tuple.tuple("string", "packed_bytes"), new PackedBytesIndexFieldData.Builder()), +++ b/src/main/java/org/elasticsearch/index/fielddata/plain/PackedBytesAtomicFieldData.java, +/*, + * Licensed to ElasticSearch and Shay Banon under one, + * or more contributor license agreements.  See the NOTICE file, + * distributed with this work for additional information, + * regarding copyright ownership. ElasticSearch licenses this, + * file to you under the Apache License, Version 2.0 (the, + * "License"); you may not use this file except in compliance, + * with the License.  You may obtain a copy of the License at, + *, + *    http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing,, + * software distributed under the License is distributed on an, + * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY, + * KIND, either express or implied.  See the License for the, + * specific language governing permissions and limitations, + * under the License., + */, +, +package org.elasticsearch.index.fielddata.plain;, +, +import org.apache.lucene.util.BytesRef;, +import org.apache.lucene.util.PagedBytes;, +import org.apache.lucene.util.packed.PackedInts;, +import org.elasticsearch.common.RamUsage;, +import org.elasticsearch.common.lucene.HashedBytesRef;, +import org.elasticsearch.index.fielddata.*;, +import org.elasticsearch.index.fielddata.ordinals.Ordinals;, +import org.elasticsearch.index.fielddata.util.BytesRefArrayRef;, +import org.elasticsearch.index.fielddata.util.IntArrayRef;, +import org.elasticsearch.index.fielddata.util.StringArrayRef;, +, +/**, + */, +public class PackedBytesAtomicFieldData implements AtomicOrdinalFieldData<ScriptDocValues.Strings> {, +, +    // 0 ordinal in values means no value (its null), +    private final PagedBytes.Reader bytes;, +    private final PackedInts.Reader termOrdToBytesOffset;, +    private final Ordinals ordinals;, +, +    private int[] hashes;, +    private long size = -1;, +, +    public PackedBytesAtomicFieldData(PagedBytes.Reader bytes, PackedInts.Reader termOrdToBytesOffset, Ordinals ordinals) {, +        this.bytes = bytes;, +        this.termOrdToBytesOffset = termOrdToBytesOffset;, +        this.ordinals = ordinals;, +    }, +, +    @Override, +    public boolean isMultiValued() {, +        return ordinals.isMultiValued();, +    }, +, +    @Override, +    public int getNumDocs() {, +        return ordinals.getNumDocs();, +    }, +, +    @Override, +    public boolean isValuesOrdered() {, +        return true;, +    }, +, +    @Override, +    public long getMemorySizeInBytes() {, +        if (size == -1) {, +            long size = ordinals.getMemorySizeInBytes();, +            // PackedBytes, +            size += RamUsage.NUM_BYTES_ARRAY_HEADER + bytes.getBlocks().length;, +            for (byte[] b : bytes.getBlocks()) {, +                size += b.length;, +            }, +            // PackedInts, +            size += termOrdToBytesOffset.ramBytesUsed();, +            this.size = size;, +        }, +        return size;, +    }, +, +    @Override, +    public OrdinalsBytesValues getBytesValues() {, +        return ordinals.isMultiValued() ? new BytesValues.Multi(bytes, termOrdToBytesOffset, ordinals.ordinals()) : new BytesValues.Single(bytes, termOrdToBytesOffset, ordinals.ordinals());, +    }, +, +    @Override, +    public OrdinalsHashedBytesValues getHashedBytesValues() {, +        if (hashes == null) {, +            int numberOfValues = termOrdToBytesOffset.size();, +            int[] hashes = new int[numberOfValues];, +            BytesRef scratch = new BytesRef();, +            for (int i = 0; i < numberOfValues; i++) {, +                BytesRef value = bytes.fill(scratch, termOrdToBytesOffset.get(i));, +                hashes[i] = value == null ? 0 : value.hashCode();]