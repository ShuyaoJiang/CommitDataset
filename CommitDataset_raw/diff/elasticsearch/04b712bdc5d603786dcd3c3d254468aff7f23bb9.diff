[+++ b/core/src/main/java/org/elasticsearch/client/transport/support/TransportProxyClient.java, +++ b/core/src/main/java/org/elasticsearch/client/transport/support/TransportProxyClient.java, +++ b/core/src/main/java/org/elasticsearch/script/Script.java, +            Map<String, String> options = (Map<String, String>)(Map)in.readMap();, +            Map<String, Object> options = (Map<String, Object>)(Map)this.options;, +++ b/core/src/main/java/org/elasticsearch/client/transport/support/TransportProxyClient.java, +++ b/core/src/main/java/org/elasticsearch/script/Script.java, +            Map<String, String> options = (Map<String, String>)(Map)in.readMap();, +            Map<String, Object> options = (Map<String, Object>)(Map)this.options;, +++ b/docs/reference/ingest/ingest-node.asciidoc, +          "timestamp" : "2016-11-08T19:43:03.850+0000", +// TESTRESPONSE[s/2016-11-08T19:43:03.850\+0000/$body.docs.0.doc._ingest.timestamp/], +[[trace-match]], +==== Providing Multiple Match Patterns, +, +Sometimes one pattern is not enough to capture the potential structure of a field. Let's assume we, +want to match all messages that contain your favorite pet breeds of either cats or dogs. One way to accomplish, +this is to provide two distinct patterns that can be matched, instead of one really complicated expression capturing, +the same `or` behavior., +, +Here is an example of such a configuration executed against the simulate API:, +, +[source,js], +--------------------------------------------------, +POST _ingest/pipeline/_simulate, +{, +  "pipeline": {, +  "description" : "parse multiple patterns",, +  "processors": [, +    {, +      "grok": {, +        "field": "message",, +        "patterns": ["%{FAVORITE_DOG:pet}", "%{FAVORITE_CAT:pet}"],, +        "pattern_definitions" : {, +          "FAVORITE_DOG" : "beagle",, +          "FAVORITE_CAT" : "burmese", +        }, +      }, +    }, +  ], +},, +"docs":[, +  {, +    "_source": {, +      "message": "I love burmese cats!", +    }, +  }, +  ], +}, +--------------------------------------------------, +// CONSOLE, +, +response:, +, +[source,js], +--------------------------------------------------, +{, +  "docs": [, +    {, +      "doc": {, +        "_type": "_type",, +        "_index": "_index",, +        "_id": "_id",, +        "_source": {, +          "message": "I love burmese cats!",, +          "pet": "burmese", +        },, +        "_ingest": {, +          "timestamp": "2016-11-08T19:43:03.850+0000", +        }, +      }, +    }, +  ], +}, +--------------------------------------------------, +// TESTRESPONSE[s/2016-11-08T19:43:03.850\+0000/$body.docs.0.doc._ingest.timestamp/], +, +Both patterns will set the field `pet` with the appropriate match, but what if we want to trace which of our, +patterns matched and populated our fields? We can do this with the `trace_match` parameter. Here is the output of, +that same pipeline, but with `"trace_match": true` configured:, +, +////, +Hidden setup for example:, +[source,js], +--------------------------------------------------, +POST _ingest/pipeline/_simulate, +{, +  "pipeline": {, +  "description" : "parse multiple patterns",, +  "processors": [, +    {, +      "grok": {, +        "field": "message",, +        "patterns": ["%{FAVORITE_DOG:pet}", "%{FAVORITE_CAT:pet}"],, +        "trace_match": true,, +        "pattern_definitions" : {, +          "FAVORITE_DOG" : "beagle",, +          "FAVORITE_CAT" : "burmese", +        }, +      }]