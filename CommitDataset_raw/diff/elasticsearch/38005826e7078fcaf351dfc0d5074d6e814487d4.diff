[+++ b/modules/elasticsearch/src/main/java/org/elasticsearch/transport/Transport.java, +    <T extends Streamable> void sendRequest(DiscoveryNode node, long requestId, String action, Streamable message) throws IOException, TransportException;, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/transport/Transport.java, +    <T extends Streamable> void sendRequest(DiscoveryNode node, long requestId, String action, Streamable message) throws IOException, TransportException;, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/transport/TransportService.java, +            transport.sendRequest(node, requestId, action, message);, +        @Override public void raiseNodeDisconnected(final DiscoveryNode node) {, +                    final RequestHolder holderToNotify = clientHandlers.remove(entry.getKey());, +                    if (holderToNotify != null) {, +                        // callback that an exception happened, but on a different thread since we don't, +                        // want handlers to worry about stack overflows, +                        threadPool.execute(new Runnable() {, +                            @Override public void run() {, +                                holderToNotify.handler().handleException(new NodeDisconnectedTransportException(node, holderToNotify.action()));, +                            }, +                        });, +            final RequestHolder holder = clientHandlers.remove(requestId);, +                // callback that an exception happened, but on a different thread since we don't, +                // want handlers to worry about stack overflows, +                threadPool.execute(new Runnable() {, +                    @Override public void run() {, +                });, +            }, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/transport/Transport.java, +    <T extends Streamable> void sendRequest(DiscoveryNode node, long requestId, String action, Streamable message) throws IOException, TransportException;, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/transport/TransportService.java, +            transport.sendRequest(node, requestId, action, message);, +        @Override public void raiseNodeDisconnected(final DiscoveryNode node) {, +                    final RequestHolder holderToNotify = clientHandlers.remove(entry.getKey());, +                    if (holderToNotify != null) {, +                        // callback that an exception happened, but on a different thread since we don't, +                        // want handlers to worry about stack overflows, +                        threadPool.execute(new Runnable() {, +                            @Override public void run() {, +                                holderToNotify.handler().handleException(new NodeDisconnectedTransportException(node, holderToNotify.action()));, +                            }, +                        });, +            final RequestHolder holder = clientHandlers.remove(requestId);, +                // callback that an exception happened, but on a different thread since we don't, +                // want handlers to worry about stack overflows, +                threadPool.execute(new Runnable() {, +                    @Override public void run() {, +                });, +            }, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/transport/local/LocalTransport.java, +    @Override public <T extends Streamable> void sendRequest(final DiscoveryNode node, final long requestId, final String action, final Streamable message) throws IOException, TransportException {, +                targetTransport.messageReceived(data, action, LocalTransport.this, requestId);, +    void messageReceived(byte[] data, String action, LocalTransport sourceTransport, @Nullable final Long sendRequestId) {, +            if (sendRequestId != null) {, +                TransportResponseHandler handler = transportServiceAdapter.remove(sendRequestId);, +                if (handler != null) {, +                    handler.handleException(new RemoteTransportException(nodeName(), localAddress, action, e));, +                }, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/transport/Transport.java, +    <T extends Streamable> void sendRequest(DiscoveryNode node, long requestId, String action, Streamable message) throws IOException, TransportException;, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/transport/TransportService.java, +            transport.sendRequest(node, requestId, action, message);, +        @Override public void raiseNodeDisconnected(final DiscoveryNode node) {, +                    final RequestHolder holderToNotify = clientHandlers.remove(entry.getKey());, +                    if (holderToNotify != null) {, +                        // callback that an exception happened, but on a different thread since we don't, +                        // want handlers to worry about stack overflows, +                        threadPool.execute(new Runnable() {, +                            @Override public void run() {, +                                holderToNotify.handler().handleException(new NodeDisconnectedTransportException(node, holderToNotify.action()));, +                            }, +                        });, +            final RequestHolder holder = clientHandlers.remove(requestId);, +                // callback that an exception happened, but on a different thread since we don't, +                // want handlers to worry about stack overflows, +                threadPool.execute(new Runnable() {, +                    @Override public void run() {, +                });, +            }, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/transport/local/LocalTransport.java, +    @Override public <T extends Streamable> void sendRequest(final DiscoveryNode node, final long requestId, final String action, final Streamable message) throws IOException, TransportException {, +                targetTransport.messageReceived(data, action, LocalTransport.this, requestId);, +    void messageReceived(byte[] data, String action, LocalTransport sourceTransport, @Nullable final Long sendRequestId) {, +            if (sendRequestId != null) {, +                TransportResponseHandler handler = transportServiceAdapter.remove(sendRequestId);, +                if (handler != null) {, +                    handler.handleException(new RemoteTransportException(nodeName(), localAddress, action, e));, +                }, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/transport/netty/NettyTransport.java, +    @Override public <T extends Streamable> void sendRequest(final DiscoveryNode node, final long requestId, final String action, final Streamable streamable) throws IOException, TransportException {, +            throw new ElasticSearchIllegalStateException("Trying to send a stream with 0 size");, +        channelFuture.addListener(new ChannelFutureListener() {, +            @Override public void operationComplete(ChannelFuture future) throws Exception {, +                if (!future.isSuccess()) {, +                    // maybe add back the retry?, +                    TransportResponseHandler handler = transportServiceAdapter.remove(requestId);, +                    if (handler != null) {, +                        handler.handleException(new RemoteTransportException("Failed write request", new SendRequestTransportException(node, action, future.getCause())));, +                    }, +                }, +            }, +        });]