[+++ b/README.textile, +* Run @bin/elasticsearch@ on unix, or @bin\elasticsearch.bat@ on windows., +++ b/README.textile, +* Run @bin/elasticsearch@ on unix, or @bin\elasticsearch.bat@ on windows., +++ b/docs/java-api/client.asciidoc, +file in your project. As long as `elasticsearch.yml` is present in the, +[source,yaml], +cluster.name: yourclustername, +++ b/README.textile, +* Run @bin/elasticsearch@ on unix, or @bin\elasticsearch.bat@ on windows., +++ b/docs/java-api/client.asciidoc, +file in your project. As long as `elasticsearch.yml` is present in the, +[source,yaml], +cluster.name: yourclustername, +++ b/docs/java-api/index_.asciidoc, +There are several different ways of generating a JSON document:, +++ b/README.textile, +* Run @bin/elasticsearch@ on unix, or @bin\elasticsearch.bat@ on windows., +++ b/docs/java-api/client.asciidoc, +file in your project. As long as `elasticsearch.yml` is present in the, +[source,yaml], +cluster.name: yourclustername, +++ b/docs/java-api/index_.asciidoc, +There are several different ways of generating a JSON document:, +++ b/docs/reference/mapping/types/nested-type.asciidoc, +The `nested` type works like the <<mapping-object-type,`object` type>> except, +that an array of `objects` is flattened, while an array of `nested`  objects, +allows each object to be queried independently.  To explain, consider this, +document:, +    "group" : "fans",, +    "user" : [, +            "first" : "John",, +            "last" :  "Smith", +            "first" : "Alice",, +            "last" :  "White", +        },, +If the `user` field is of type `object`, this document would be indexed, +internally something like this:, +[source,js], +--------------------------------------------------, +{, +    "group" :        "fans",, +    "user.first" : [ "alice", "john" ],, +    "user.last" :  [ "smith", "white" ], +}, +--------------------------------------------------, +, +The `first` and `last` fields are flattened, and the association between, +`alice` and `white` is lost.  This document would incorrectly match a query, +for `alice AND smith`., +, +If the `user` field is of type `nested`, each object is indexed as a separate, +document, something like this:, +, +[source,js], +--------------------------------------------------, +{ <1>, +    "user.first" : "alice",, +    "user.last" :  "white", +}, +{ <1>, +    "user.first" : "john",, +    "user.last" :  "smith", +}, +{ <2>, +    "group" :       "fans", +}, +--------------------------------------------------, +<1> Hidden nested documents., +<2> Visible ``parent'' document., +, +By keeping each nested object separate, the association between the, +`user.first` and `user.last` fields is maintained. The query for `alice AND, +smith` would *not* match this document., +, +Searching on nested docs can be done using either the, +<<query-dsl-nested-query,nested query>> or, +<<query-dsl-nested-filter,nested filter>>., +, +==== Mapping, +, +The mapping for `nested` fields is the same as `object` fields, except that it, +uses type `nested`:, +            "users" : {, +                    "first" : {"type": "string" },, +                    "last"  : {"type": "string" }, +NOTE: changing an `object` type to `nested` type requires reindexing., +You may want to index inner objects both as `nested` fields *and*  as flattened, +`object` fields, eg for highlighting.  This can be achieved by setting, +`include_in_parent` to `true`:, +[source,js], +--------------------------------------------------, +{, +    "type1" : {, +        "properties" : {, +            "users" : {, +                "type" : "nested",, +                "include_in_parent": true,, +                "properties": {, +                    "first" : {"type": "string" },]