[+++ b/core/src/main/java/org/elasticsearch/indices/IndexingMemoryController.java, +    private final Iterable<IndexShard> indexShards;, +    IndexingMemoryController(Settings settings, ThreadPool threadPool, Iterable<IndexShard>indexServices) {, +        this(settings, threadPool, indexServices, JvmInfo.jvmInfo().getMem().getHeapMax().bytes());, +    IndexingMemoryController(Settings settings, ThreadPool threadPool, Iterable<IndexShard> indexServices, long jvmMemoryInBytes) {, +        this.indexShards = indexServices;, +        for (IndexShard shard : indexShards) {, +++ b/core/src/main/java/org/elasticsearch/indices/IndexingMemoryController.java, +    private final Iterable<IndexShard> indexShards;, +    IndexingMemoryController(Settings settings, ThreadPool threadPool, Iterable<IndexShard>indexServices) {, +        this(settings, threadPool, indexServices, JvmInfo.jvmInfo().getMem().getHeapMax().bytes());, +    IndexingMemoryController(Settings settings, ThreadPool threadPool, Iterable<IndexShard> indexServices, long jvmMemoryInBytes) {, +        this.indexShards = indexServices;, +        for (IndexShard shard : indexShards) {, +++ b/core/src/main/java/org/elasticsearch/indices/IndicesService.java, +import org.elasticsearch.common.util.iterable.Iterables;, +        indexingMemoryController = new IndexingMemoryController(settings, threadPool, Iterables.flatten(this));, +++ b/core/src/main/java/org/elasticsearch/indices/IndexingMemoryController.java, +    private final Iterable<IndexShard> indexShards;, +    IndexingMemoryController(Settings settings, ThreadPool threadPool, Iterable<IndexShard>indexServices) {, +        this(settings, threadPool, indexServices, JvmInfo.jvmInfo().getMem().getHeapMax().bytes());, +    IndexingMemoryController(Settings settings, ThreadPool threadPool, Iterable<IndexShard> indexServices, long jvmMemoryInBytes) {, +        this.indexShards = indexServices;, +        for (IndexShard shard : indexShards) {, +++ b/core/src/main/java/org/elasticsearch/indices/IndicesService.java, +import org.elasticsearch.common.util.iterable.Iterables;, +        indexingMemoryController = new IndexingMemoryController(settings, threadPool, Iterables.flatten(this));, +++ b/core/src/test/java/org/elasticsearch/index/shard/IndexShardTests.java, +    public static final IndexShard reinitWithWrapper(IndexService indexService, IndexShard shard, IndexSearcherWrapper wrapper, IndexingOperationListener... listeners) throws IOException {, +    public  static final IndexShard recoverShard(IndexShard newShard, ShardRouting oldRouting) throws IOException {, +    public  static final IndexShard newIndexShard(IndexService indexService, IndexShard shard, IndexSearcherWrapper wrapper, IndexingOperationListener... listeners) throws IOException {, +++ b/core/src/main/java/org/elasticsearch/indices/IndexingMemoryController.java, +    private final Iterable<IndexShard> indexShards;, +    IndexingMemoryController(Settings settings, ThreadPool threadPool, Iterable<IndexShard>indexServices) {, +        this(settings, threadPool, indexServices, JvmInfo.jvmInfo().getMem().getHeapMax().bytes());, +    IndexingMemoryController(Settings settings, ThreadPool threadPool, Iterable<IndexShard> indexServices, long jvmMemoryInBytes) {, +        this.indexShards = indexServices;, +        for (IndexShard shard : indexShards) {, +++ b/core/src/main/java/org/elasticsearch/indices/IndicesService.java, +import org.elasticsearch.common.util.iterable.Iterables;, +        indexingMemoryController = new IndexingMemoryController(settings, threadPool, Iterables.flatten(this));, +++ b/core/src/test/java/org/elasticsearch/index/shard/IndexShardTests.java, +    public static final IndexShard reinitWithWrapper(IndexService indexService, IndexShard shard, IndexSearcherWrapper wrapper, IndexingOperationListener... listeners) throws IOException {, +    public  static final IndexShard recoverShard(IndexShard newShard, ShardRouting oldRouting) throws IOException {, +    public  static final IndexShard newIndexShard(IndexService indexService, IndexShard shard, IndexSearcherWrapper wrapper, IndexingOperationListener... listeners) throws IOException {, +++ b/core/src/test/java/org/elasticsearch/indices/IndexingMemoryControllerTests.java, +import org.elasticsearch.ExceptionsHelper;, +import org.elasticsearch.Version;, +import org.elasticsearch.action.index.IndexRequestBuilder;, +import org.elasticsearch.cluster.node.DiscoveryNode;, +import org.elasticsearch.cluster.routing.ShardRouting;, +import org.elasticsearch.cluster.routing.ShardRoutingHelper;, +import org.elasticsearch.common.transport.DummyTransportAddress;, +import org.elasticsearch.index.shard.IndexSearcherWrapper;, +import org.elasticsearch.index.shard.IndexShardTests;, +import org.elasticsearch.index.shard.IndexingOperationListener;, +import org.elasticsearch.indices.recovery.RecoveryState;, +import java.io.IOException;, +import java.util.Iterator;, +import java.util.concurrent.atomic.AtomicInteger;, +import java.util.concurrent.atomic.AtomicReference;, +import static java.util.Collections.emptyMap;, +import static java.util.Collections.emptySet;, +, +    public void testTranslogRecoveryWorksWithIMC() throws IOException {, +        createIndex("test");, +        ensureGreen();, +        IndicesService indicesService = getInstanceFromNode(IndicesService.class);, +        IndexService indexService = indicesService.indexService(resolveIndex("test"));, +        IndexShard shard = indexService.getShardOrNull(0);, +        for (int i = 0; i < 100; i++) {, +            client().prepareIndex("test", "test", Integer.toString(i)).setSource("{\"foo\" : \"bar\"}").get();, +        }, +, +        IndexSearcherWrapper wrapper = new IndexSearcherWrapper() {};, +        shard.close("simon says", false);, +        AtomicReference<IndexShard> shardRef = new AtomicReference<>();, +        Settings settings = Settings.builder().put(IndexingMemoryController.INDEX_BUFFER_SIZE_SETTING, "50kb").build();, +        Iterable<IndexShard> iterable = () -> (shardRef.get() == null) ? Collections.<IndexShard>emptyList().iterator(), +            : Collections.singleton(shardRef.get()).iterator();, +        AtomicInteger flushes = new AtomicInteger();, +        IndexingMemoryController imc = new IndexingMemoryController(settings, client().threadPool(), iterable) {, +            @Override, +            protected void writeIndexingBufferAsync(IndexShard shard) {, +                assertEquals(shard, shardRef.get());, +                flushes.incrementAndGet();, +                shard.writeIndexingBuffer();, +            }, +        };, +        final IndexShard newShard = IndexShardTests.newIndexShard(indexService, shard, wrapper, imc);, +        shardRef.set(newShard);, +        try {, +            assertEquals(0, imc.availableShards().size());, +            ShardRouting routing = new ShardRouting(shard.routingEntry());, +            ShardRoutingHelper.reinit(routing);, +            newShard.updateRoutingEntry(routing, false);, +            DiscoveryNode localNode = new DiscoveryNode("foo", DummyTransportAddress.INSTANCE, emptyMap(), emptySet(), Version.CURRENT);, +            newShard.markAsRecovering("store", new RecoveryState(newShard.shardId(), routing.primary(), RecoveryState.Type.STORE, localNode, localNode));, +, +            assertEquals(1, imc.availableShards().size());]