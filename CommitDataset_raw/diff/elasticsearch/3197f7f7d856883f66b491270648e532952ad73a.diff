[+++ b/core/src/main/java/org/elasticsearch/search/SearchModule.java, +import org.elasticsearch.search.aggregations.bucket.filter.FilterAggregatorBuilder;, +        registerAggregation(FilterAggregatorBuilder::new, FilterAggregatorBuilder::parse, FilterAggregatorBuilder.AGGREGATION_NAME_FIELD);, +++ b/core/src/main/java/org/elasticsearch/search/SearchModule.java, +import org.elasticsearch.search.aggregations.bucket.filter.FilterAggregatorBuilder;, +        registerAggregation(FilterAggregatorBuilder::new, FilterAggregatorBuilder::parse, FilterAggregatorBuilder.AGGREGATION_NAME_FIELD);, +++ b/core/src/main/java/org/elasticsearch/search/aggregations/bucket/filter/FilterAggregatorBuilder.java, +import org.elasticsearch.common.ParseField;, +import org.elasticsearch.common.ParsingException;, +import org.elasticsearch.common.xcontent.XContentParser;, +import org.elasticsearch.index.query.QueryParseContext;, +    public static final String NAME = InternalFilter.TYPE.name();, +    public static final ParseField AGGREGATION_NAME_FIELD = new ParseField(NAME);, +    /**, +     * Read from a stream., +     */, +    public FilterAggregatorBuilder(StreamInput in) throws IOException {, +        super(in, InternalFilter.TYPE);, +        filter = in.readQuery();, +    }, +, +    @Override, +    protected void doWriteTo(StreamOutput out) throws IOException {, +        out.writeQuery(filter);, +    }, +, +    @Override, +    protected boolean usesNewStyleSerialization() {, +        return true;, +    }, +, +    public static FilterAggregatorBuilder parse(String aggregationName, QueryParseContext context), +            throws IOException {, +        QueryBuilder<?> filter = context.parseInnerQueryBuilder();, +, +        if (filter == null) {, +            throw new ParsingException(null, "filter cannot be null in filter aggregation [{}]", aggregationName);, +        return new FilterAggregatorBuilder(aggregationName, filter);, +, +    @Override, +    public String getWriteableName() {, +        return NAME;, +    }, +++ b/core/src/main/java/org/elasticsearch/search/SearchModule.java, +import org.elasticsearch.search.aggregations.bucket.filter.FilterAggregatorBuilder;, +        registerAggregation(FilterAggregatorBuilder::new, FilterAggregatorBuilder::parse, FilterAggregatorBuilder.AGGREGATION_NAME_FIELD);, +++ b/core/src/main/java/org/elasticsearch/search/aggregations/bucket/filter/FilterAggregatorBuilder.java, +import org.elasticsearch.common.ParseField;, +import org.elasticsearch.common.ParsingException;, +import org.elasticsearch.common.xcontent.XContentParser;, +import org.elasticsearch.index.query.QueryParseContext;, +    public static final String NAME = InternalFilter.TYPE.name();, +    public static final ParseField AGGREGATION_NAME_FIELD = new ParseField(NAME);, +    /**, +     * Read from a stream., +     */, +    public FilterAggregatorBuilder(StreamInput in) throws IOException {, +        super(in, InternalFilter.TYPE);, +        filter = in.readQuery();, +    }, +, +    @Override, +    protected void doWriteTo(StreamOutput out) throws IOException {, +        out.writeQuery(filter);, +    }, +, +    @Override, +    protected boolean usesNewStyleSerialization() {, +        return true;, +    }, +, +    public static FilterAggregatorBuilder parse(String aggregationName, QueryParseContext context), +            throws IOException {, +        QueryBuilder<?> filter = context.parseInnerQueryBuilder();, +, +        if (filter == null) {, +            throw new ParsingException(null, "filter cannot be null in filter aggregation [{}]", aggregationName);, +        return new FilterAggregatorBuilder(aggregationName, filter);, +, +    @Override, +    public String getWriteableName() {, +        return NAME;, +    }, +++ /dev/null]