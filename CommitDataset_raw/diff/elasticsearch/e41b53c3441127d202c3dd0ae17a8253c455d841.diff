[+++ b/elasticsearch/src/main/java/org/elasticsearch/license/XPackLicenseState.java, +import java.util.List;, +import java.util.Objects;, +import java.util.concurrent.CopyOnWriteArrayList;, +    private final List<Runnable> listeners = new CopyOnWriteArrayList<>();, +        listeners.forEach(Runnable::run);, +    }, +, +    /** Add a listener to be notified on license change */, +    public void addListener(Runnable runnable) {, +        listeners.add(Objects.requireNonNull(runnable));, +++ b/elasticsearch/src/main/java/org/elasticsearch/license/XPackLicenseState.java, +import java.util.List;, +import java.util.Objects;, +import java.util.concurrent.CopyOnWriteArrayList;, +    private final List<Runnable> listeners = new CopyOnWriteArrayList<>();, +        listeners.forEach(Runnable::run);, +    }, +, +    /** Add a listener to be notified on license change */, +    public void addListener(Runnable runnable) {, +        listeners.add(Objects.requireNonNull(runnable));, +++ b/elasticsearch/src/main/java/org/elasticsearch/xpack/security/Security.java, +        final FileRolesStore fileRolesStore = new FileRolesStore(settings, env, resourceWatcherService, licenseState);, +        final NativeRolesStore nativeRolesStore = new NativeRolesStore(settings, client, licenseState);, +        final CompositeRolesStore allRolesStore =, +                new CompositeRolesStore(settings, fileRolesStore, nativeRolesStore, reservedRolesStore, licenseState);, +        // to keep things simple, just invalidate all cached entries on license change. this happens so rarely that the impact should be, +        // minimal, +        licenseState.addListener(allRolesStore::invalidateAll);, +++ b/elasticsearch/src/main/java/org/elasticsearch/license/XPackLicenseState.java, +import java.util.List;, +import java.util.Objects;, +import java.util.concurrent.CopyOnWriteArrayList;, +    private final List<Runnable> listeners = new CopyOnWriteArrayList<>();, +        listeners.forEach(Runnable::run);, +    }, +, +    /** Add a listener to be notified on license change */, +    public void addListener(Runnable runnable) {, +        listeners.add(Objects.requireNonNull(runnable));, +++ b/elasticsearch/src/main/java/org/elasticsearch/xpack/security/Security.java, +        final FileRolesStore fileRolesStore = new FileRolesStore(settings, env, resourceWatcherService, licenseState);, +        final NativeRolesStore nativeRolesStore = new NativeRolesStore(settings, client, licenseState);, +        final CompositeRolesStore allRolesStore =, +                new CompositeRolesStore(settings, fileRolesStore, nativeRolesStore, reservedRolesStore, licenseState);, +        // to keep things simple, just invalidate all cached entries on license change. this happens so rarely that the impact should be, +        // minimal, +        licenseState.addListener(allRolesStore::invalidateAll);, +++ b/elasticsearch/src/main/java/org/elasticsearch/xpack/security/authc/esnative/ESNativeRealmMigrateTool.java, +            rd.toXContent(builder, ToXContent.EMPTY_PARAMS, false);, +            Map<String, RoleDescriptor> roles = FileRolesStore.parseRoleDescriptors(rolesFile, logger, true, Settings.EMPTY);, +++ b/elasticsearch/src/main/java/org/elasticsearch/license/XPackLicenseState.java, +import java.util.List;, +import java.util.Objects;, +import java.util.concurrent.CopyOnWriteArrayList;, +    private final List<Runnable> listeners = new CopyOnWriteArrayList<>();, +        listeners.forEach(Runnable::run);, +    }, +, +    /** Add a listener to be notified on license change */, +    public void addListener(Runnable runnable) {, +        listeners.add(Objects.requireNonNull(runnable));, +++ b/elasticsearch/src/main/java/org/elasticsearch/xpack/security/Security.java, +        final FileRolesStore fileRolesStore = new FileRolesStore(settings, env, resourceWatcherService, licenseState);, +        final NativeRolesStore nativeRolesStore = new NativeRolesStore(settings, client, licenseState);, +        final CompositeRolesStore allRolesStore =, +                new CompositeRolesStore(settings, fileRolesStore, nativeRolesStore, reservedRolesStore, licenseState);, +        // to keep things simple, just invalidate all cached entries on license change. this happens so rarely that the impact should be, +        // minimal, +        licenseState.addListener(allRolesStore::invalidateAll);, +++ b/elasticsearch/src/main/java/org/elasticsearch/xpack/security/authc/esnative/ESNativeRealmMigrateTool.java, +            rd.toXContent(builder, ToXContent.EMPTY_PARAMS, false);, +            Map<String, RoleDescriptor> roles = FileRolesStore.parseRoleDescriptors(rolesFile, logger, true, Settings.EMPTY);, +++ b/elasticsearch/src/main/java/org/elasticsearch/xpack/security/authz/RoleDescriptor.java, +import org.elasticsearch.Version;, +    private final Map<String, Object> transientMetadata;, +        this(name, clusterPrivileges, indicesPrivileges, runAs, metadata, null);, +    }, +, +    public RoleDescriptor(String name,, +                          @Nullable String[] clusterPrivileges,, +                          @Nullable IndicesPrivileges[] indicesPrivileges,, +                          @Nullable String[] runAs,, +                          @Nullable Map<String, Object> metadata,, +                          @Nullable Map<String, Object> transientMetadata) {, +        this.transientMetadata = transientMetadata != null ? Collections.unmodifiableMap(transientMetadata) :, +                Collections.singletonMap("enabled", true);, +    public Map<String, Object> getTransientMetadata() {, +        return transientMetadata;, +    }, +, +    public boolean isUsingDocumentOrFieldLevelSecurity() {, +        return Arrays.stream(indicesPrivileges).anyMatch(ip -> ip.isUsingDocumentLevelSecurity() || ip.isUsingFieldLevelSecurity());, +    }, +, +    @Override, +        return toXContent(builder, params, true);, +    }, +]