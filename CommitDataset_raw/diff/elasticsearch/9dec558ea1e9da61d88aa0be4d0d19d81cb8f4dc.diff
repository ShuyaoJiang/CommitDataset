[+++ b/docs/reference/mapping/types/core-types.asciidoc, +++ b/docs/reference/mapping/types/core-types.asciidoc, +++ b/src/main/java/org/elasticsearch/client/transport/TransportClient.java, +++ b/docs/reference/mapping/types/core-types.asciidoc, +++ b/src/main/java/org/elasticsearch/client/transport/TransportClient.java, +++ /dev/null, +++ b/docs/reference/mapping/types/core-types.asciidoc, +++ b/src/main/java/org/elasticsearch/client/transport/TransportClient.java, +++ /dev/null, +++ b/src/main/java/org/elasticsearch/common/xcontent/XContentParser.java, +++ b/docs/reference/mapping/types/core-types.asciidoc, +++ b/src/main/java/org/elasticsearch/client/transport/TransportClient.java, +++ /dev/null, +++ b/src/main/java/org/elasticsearch/common/xcontent/XContentParser.java, +++ b/src/main/java/org/elasticsearch/common/xcontent/json/JsonXContentParser.java, +++ b/docs/reference/mapping/types/core-types.asciidoc, +++ b/src/main/java/org/elasticsearch/client/transport/TransportClient.java, +++ /dev/null, +++ b/src/main/java/org/elasticsearch/common/xcontent/XContentParser.java, +++ b/src/main/java/org/elasticsearch/common/xcontent/json/JsonXContentParser.java, +++ b/src/main/java/org/elasticsearch/env/Environment.java, +            throw new IllegalStateException("path.home is not configured");, +        // first, try it as a path in the config directory, +        Path f = configFile.resolve(path);, +        if (Files.exists(f)) {, +                return f.toUri().toURL();, +                throw new FailedToResolveConfigException("Failed to resolve path [" + f + "]", e);, +        throw new FailedToResolveConfigException("Failed to resolve config path [" + path + "], tried config path [" + f + "] and classpath");, +++ b/docs/reference/mapping/types/core-types.asciidoc, +++ b/src/main/java/org/elasticsearch/client/transport/TransportClient.java, +++ /dev/null, +++ b/src/main/java/org/elasticsearch/common/xcontent/XContentParser.java, +++ b/src/main/java/org/elasticsearch/common/xcontent/json/JsonXContentParser.java, +++ b/src/main/java/org/elasticsearch/env/Environment.java, +            throw new IllegalStateException("path.home is not configured");, +        // first, try it as a path in the config directory, +        Path f = configFile.resolve(path);, +        if (Files.exists(f)) {, +                return f.toUri().toURL();, +                throw new FailedToResolveConfigException("Failed to resolve path [" + f + "]", e);, +        throw new FailedToResolveConfigException("Failed to resolve config path [" + path + "], tried config path [" + f + "] and classpath");, +++ b/src/main/java/org/elasticsearch/gateway/GatewayMetaState.java, +import org.elasticsearch.cluster.routing.DjbHashFunction;, +import org.elasticsearch.cluster.routing.HashFunction;, +import org.elasticsearch.cluster.routing.SimpleHashFunction;, +    private volatile MetaData currentMetaData;, +        if (DiscoveryNode.masterNode(settings)) {, +            this.currentMetaData = null;, +        // only applied to master node, writing the global and index level states, +        if (state.nodes().localNode().masterNode()) {, +            if (currentMetaData == null || !MetaData.isGlobalStateEquals(currentMetaData, newMetaData)) {, +            for (IndexMetaData indexMetaData : newMetaData) {, +                String writeReason = null;, +                IndexMetaData currentIndexMetaData;, +                if (currentMetaData == null) {, +                    // a new event..., check from the state stored, +                        currentIndexMetaData = metaStateService.loadIndexState(indexMetaData.index());, +                    } catch (IOException ex) {, +                        throw new ElasticsearchException("failed to load index state", ex);, +                    }, +                } else {, +                    currentIndexMetaData = currentMetaData.index(indexMetaData.index());, +                }, +                if (currentIndexMetaData == null) {, +                    writeReason = "freshly created";, +                } else if (currentIndexMetaData.version() != indexMetaData.version()) {, +                    writeReason = "version changed from [" + currentIndexMetaData.version() + "] to [" + indexMetaData.version() + "]";, +                }, +, +                // we update the writeReason only if we really need to write it, +                if (writeReason == null) {, +                    continue;, +                }, +, +                try {, +                    metaStateService.writeIndex(writeReason, indexMetaData, currentIndexMetaData);, +            currentMetaData = newMetaData;, +++ b/docs/reference/mapping/types/core-types.asciidoc, +++ b/src/main/java/org/elasticsearch/client/transport/TransportClient.java, +++ /dev/null, +++ b/src/main/java/org/elasticsearch/common/xcontent/XContentParser.java, +++ b/src/main/java/org/elasticsearch/common/xcontent/json/JsonXContentParser.java, +++ b/src/main/java/org/elasticsearch/env/Environment.java, +            throw new IllegalStateException("path.home is not configured");, +        // first, try it as a path in the config directory, +        Path f = configFile.resolve(path);, +        if (Files.exists(f)) {, +                return f.toUri().toURL();, +                throw new FailedToResolveConfigException("Failed to resolve path [" + f + "]", e);, +        throw new FailedToResolveConfigException("Failed to resolve config path [" + path + "], tried config path [" + f + "] and classpath");, +++ b/src/main/java/org/elasticsearch/gateway/GatewayMetaState.java, +import org.elasticsearch.cluster.routing.DjbHashFunction;, +import org.elasticsearch.cluster.routing.HashFunction;, +import org.elasticsearch.cluster.routing.SimpleHashFunction;, +    private volatile MetaData currentMetaData;, +        if (DiscoveryNode.masterNode(settings)) {, +            this.currentMetaData = null;, +        // only applied to master node, writing the global and index level states, +        if (state.nodes().localNode().masterNode()) {, +            if (currentMetaData == null || !MetaData.isGlobalStateEquals(currentMetaData, newMetaData)) {]