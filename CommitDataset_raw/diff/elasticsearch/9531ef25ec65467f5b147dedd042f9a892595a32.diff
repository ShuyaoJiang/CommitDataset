[+++ b/core/src/test/java/org/elasticsearch/bwcompat/OldIndexBackwardsCompatibilityIT.java, +++ b/core/src/test/java/org/elasticsearch/bwcompat/OldIndexBackwardsCompatibilityIT.java, +++ b/qa/full-cluster-restart/src/test/java/org/elasticsearch/upgrades/FullClusterRestartIT.java, +import org.elasticsearch.client.Response;, +import org.elasticsearch.common.CheckedFunction;, +import org.elasticsearch.common.xcontent.XContentHelper;, +import org.elasticsearch.common.xcontent.support.XContentMapValues;, +import java.util.Collections;, +import static org.elasticsearch.common.xcontent.XContentFactory.jsonBuilder;, +    public void testSearch() throws Exception {, +        if (runningAgainstOldCluster) {, +            XContentBuilder mappingsAndSettings = jsonBuilder();, +            mappingsAndSettings.startObject();, +            {, +                mappingsAndSettings.startObject("settings");, +                mappingsAndSettings.field("number_of_shards", 1);, +                mappingsAndSettings.field("number_of_replicas", 0);, +                mappingsAndSettings.endObject();, +            }, +            {, +                mappingsAndSettings.startObject("mappings");, +                mappingsAndSettings.startObject("doc");, +                mappingsAndSettings.startObject("properties");, +                {, +                    mappingsAndSettings.startObject("string");, +                    mappingsAndSettings.field("type", "text");, +                    mappingsAndSettings.endObject();, +                }, +                {, +                    mappingsAndSettings.startObject("dots_in_field_names");, +                    mappingsAndSettings.field("type", "text");, +                    mappingsAndSettings.endObject();, +                }, +                mappingsAndSettings.endObject();, +                mappingsAndSettings.endObject();, +                mappingsAndSettings.endObject();, +            }, +            mappingsAndSettings.endObject();, +            client().performRequest("PUT", "/index", Collections.emptyMap(),, +                new StringEntity(mappingsAndSettings.string(), ContentType.APPLICATION_JSON));, +, +            int numDocs = randomIntBetween(2000, 3000);, +            indexRandomDocuments("index", numDocs, true, i -> {, +                return JsonXContent.contentBuilder().startObject(), +                .field("string", randomAlphaOfLength(10)), +                .field("int", randomInt(100)), +                .field("float", randomFloat()), +                // be sure to create a "proper" boolean (True, False) for the first document so that automapping is correct, +                .field("bool", i > 0 && supportsLenientBooleans ? randomLenientBoolean() : randomBoolean()), +                .field("field.with.dots", randomAlphaOfLength(10)), +                // TODO a binary field, +                .endObject();, +            });, +            client().performRequest("POST", "/_flush");, +        }, +        assertBasicSearchWorks();, +    }, +, +    void assertBasicSearchWorks() throws IOException {, +        logger.info("--> testing basic search");, +        Map<String, Object> response = toMap(client().performRequest("GET", "/index/_search"));, +        assertNoFailures(response);, +        int numDocs1 = (int) XContentMapValues.extractValue("hits.total", response);, +        logger.info("Found {} in old index", numDocs1);, +, +        logger.info("--> testing basic search with sort");, +        String searchRequestBody = "{ \"sort\": [{ \"int\" : \"asc\" }]}";, +        response = toMap(client().performRequest("GET", "/index/_search", Collections.emptyMap(),, +            new StringEntity(searchRequestBody, ContentType.APPLICATION_JSON)));, +        assertNoFailures(response);, +        int numDocs2 = (int) XContentMapValues.extractValue("hits.total", response);, +        assertEquals(numDocs1, numDocs2);, +, +        logger.info("--> testing exists filter");, +        searchRequestBody = "{ \"query\": { \"exists\" : {\"field\": \"string\"} }}";, +        response = toMap(client().performRequest("GET", "/index/_search", Collections.emptyMap(),, +            new StringEntity(searchRequestBody, ContentType.APPLICATION_JSON)));, +        assertNoFailures(response);, +        numDocs2 = (int) XContentMapValues.extractValue("hits.total", response);, +        assertEquals(numDocs1, numDocs2);, +, +        searchRequestBody = "{ \"query\": { \"exists\" : {\"field\": \"field.with.dots\"} }}";, +        response = toMap(client().performRequest("GET", "/index/_search", Collections.emptyMap(),, +            new StringEntity(searchRequestBody, ContentType.APPLICATION_JSON)));, +        assertNoFailures(response);, +        numDocs2 = (int) XContentMapValues.extractValue("hits.total", response);, +        assertEquals(numDocs1, numDocs2);, +    }, +, +    static Map<String, Object> toMap(Response response) throws IOException {, +        return XContentHelper.convertToMap(JsonXContent.jsonXContent, EntityUtils.toString(response.getEntity()), false);, +    }, +, +    static void assertNoFailures(Map<String, Object> response) {, +        int failed = (int) XContentMapValues.extractValue("_shards.failed", response);, +        assertEquals(0, failed);, +    }, +, +            indexRandomDocuments(index, count, true, i -> jsonBuilder().startObject().field("field", "value").endObject());, +                indexRandomDocuments(index, count / 10, false /* Flushing here would invalidate the whole thing....*/,]