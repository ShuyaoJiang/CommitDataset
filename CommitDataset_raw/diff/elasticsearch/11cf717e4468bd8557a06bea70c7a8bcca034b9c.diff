[+++ b/core/src/main/java/org/elasticsearch/client/support/AbstractClient.java, +                try (ThreadContext.StoredContext ctx = threadContext.stashContext(headers)) {, +++ b/core/src/main/java/org/elasticsearch/client/support/AbstractClient.java, +                try (ThreadContext.StoredContext ctx = threadContext.stashContext(headers)) {, +++ b/core/src/main/java/org/elasticsearch/common/util/concurrent/EsThreadPoolExecutor.java, +import java.util.stream.Stream;, +    /**, +     * Returns a stream of all pending tasks. This is similar to {@link #getQueue()} but will expose the originally submitted, +     * {@link Runnable} instances rather than potentially wrapped ones., +     */, +    public Stream<Runnable> getTasks() {, +        return this.getQueue().stream().map(this::unwrap);, +    }, +, +++ b/core/src/main/java/org/elasticsearch/client/support/AbstractClient.java, +                try (ThreadContext.StoredContext ctx = threadContext.stashContext(headers)) {, +++ b/core/src/main/java/org/elasticsearch/common/util/concurrent/EsThreadPoolExecutor.java, +import java.util.stream.Stream;, +    /**, +     * Returns a stream of all pending tasks. This is similar to {@link #getQueue()} but will expose the originally submitted, +     * {@link Runnable} instances rather than potentially wrapped ones., +     */, +    public Stream<Runnable> getTasks() {, +        return this.getQueue().stream().map(this::unwrap);, +    }, +, +++ b/core/src/main/java/org/elasticsearch/common/util/concurrent/ThreadContext.java, +     * Removes the current context and resets a new context that contains a merge of the current context and the given headers. The removed context can be, +     * restored when closing the returned {@link StoredContext}, +     */, +    public StoredContext stashContext(Map<String, String> headers) {, +        final ThreadContextStruct context = threadLocal.get();, +        threadLocal.set(context.putHeaders(headers));, +        return () -> {, +            threadLocal.set(context);, +        };, +    }, +, +    /**, +                Map<String, String> newHeaders = new HashMap<>(headers); // first add the new headers, +                newHeaders.putAll(this.headers); // now add the new ones - we do a merge and preserve already existing ones, +++ b/core/src/main/java/org/elasticsearch/client/support/AbstractClient.java, +                try (ThreadContext.StoredContext ctx = threadContext.stashContext(headers)) {, +++ b/core/src/main/java/org/elasticsearch/common/util/concurrent/EsThreadPoolExecutor.java, +import java.util.stream.Stream;, +    /**, +     * Returns a stream of all pending tasks. This is similar to {@link #getQueue()} but will expose the originally submitted, +     * {@link Runnable} instances rather than potentially wrapped ones., +     */, +    public Stream<Runnable> getTasks() {, +        return this.getQueue().stream().map(this::unwrap);, +    }, +, +++ b/core/src/main/java/org/elasticsearch/common/util/concurrent/ThreadContext.java, +     * Removes the current context and resets a new context that contains a merge of the current context and the given headers. The removed context can be, +     * restored when closing the returned {@link StoredContext}, +     */, +    public StoredContext stashContext(Map<String, String> headers) {, +        final ThreadContextStruct context = threadLocal.get();, +        threadLocal.set(context.putHeaders(headers));, +        return () -> {, +            threadLocal.set(context);, +        };, +    }, +, +    /**, +                Map<String, String> newHeaders = new HashMap<>(headers); // first add the new headers, +                newHeaders.putAll(this.headers); // now add the new ones - we do a merge and preserve already existing ones, +++ b/core/src/test/java/org/elasticsearch/common/util/concurrent/EsExecutorsTests.java, +            executor.execute(() -> {, +    }, +, +    public void testGetTasks() throws InterruptedException {, +        int pool = between(1, 10);, +        int queue = between(0, 100);, +        final CountDownLatch latch = new CountDownLatch(1);, +        final CountDownLatch executed = new CountDownLatch(1);, +        EsThreadPoolExecutor executor = EsExecutors.newFixed(getTestName(), pool, queue, EsExecutors.daemonThreadFactory("dummy"), threadContext);, +        try {, +            Runnable r = () -> {, +                latch.countDown();, +                try {, +                    executed.await();, +                } catch (InterruptedException e) {, +                    fail();, +                }, +            };, +            executor.execute(r);, +            latch.await();, +            executor.getTasks().forEach((runnable) -> assertSame(runnable, r));, +            executed.countDown();, +, +        } finally {, +            latch.countDown();, +            terminate(executor);, +        }, +++ b/core/src/main/java/org/elasticsearch/client/support/AbstractClient.java, +                try (ThreadContext.StoredContext ctx = threadContext.stashContext(headers)) {, +++ b/core/src/main/java/org/elasticsearch/common/util/concurrent/EsThreadPoolExecutor.java, +import java.util.stream.Stream;]