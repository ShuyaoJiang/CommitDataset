[+++ b/src/main/java/org/elasticsearch/cluster/settings/ClusterDynamicSettingsModule.java, +        clusterDynamicSettings.addDynamicSetting(IndicesFilterCache.INDICES_CACHE_FILTER_CONCURRENCY_LEVEL, Validator.POSITIVE_INTEGER);, +++ b/src/main/java/org/elasticsearch/cluster/settings/ClusterDynamicSettingsModule.java, +        clusterDynamicSettings.addDynamicSetting(IndicesFilterCache.INDICES_CACHE_FILTER_CONCURRENCY_LEVEL, Validator.POSITIVE_INTEGER);, +++ b/src/main/java/org/elasticsearch/indices/cache/filter/IndicesFilterCache.java, +import org.elasticsearch.ElasticsearchIllegalArgumentException;, +    private volatile int concurrencyLevel;, +    public static final String INDICES_CACHE_FILTER_CONCURRENCY_LEVEL = "indices.cache.filter.concurrency_level";, +            final int concurrencyLevel = settings.getAsInt(INDICES_CACHE_FILTER_CONCURRENCY_LEVEL, IndicesFilterCache.this.concurrencyLevel);, +            if (concurrencyLevel <= 0) {, +                throw new ElasticsearchIllegalArgumentException("concurrency_level must be > 0 but was: " + concurrencyLevel);, +            }, +            if (!Objects.equal(concurrencyLevel, IndicesFilterCache.this.concurrencyLevel)) {, +                logger.info("updating [indices.cache.filter.concurrency_level] from [{}] to [{}]", IndicesFilterCache.this.concurrencyLevel, concurrencyLevel);, +                IndicesFilterCache.this.concurrencyLevel = concurrencyLevel;, +                replace = true;, +            }, +        this.concurrencyLevel =  settings.getAsInt(INDICES_CACHE_FILTER_CONCURRENCY_LEVEL, 16);, +        if (concurrencyLevel <= 0) {, +            throw new ElasticsearchIllegalArgumentException("concurrency_level must be > 0 but was: " + concurrencyLevel);, +        }, +++ b/src/main/java/org/elasticsearch/cluster/settings/ClusterDynamicSettingsModule.java, +        clusterDynamicSettings.addDynamicSetting(IndicesFilterCache.INDICES_CACHE_FILTER_CONCURRENCY_LEVEL, Validator.POSITIVE_INTEGER);, +++ b/src/main/java/org/elasticsearch/indices/cache/filter/IndicesFilterCache.java, +import org.elasticsearch.ElasticsearchIllegalArgumentException;, +    private volatile int concurrencyLevel;, +    public static final String INDICES_CACHE_FILTER_CONCURRENCY_LEVEL = "indices.cache.filter.concurrency_level";, +            final int concurrencyLevel = settings.getAsInt(INDICES_CACHE_FILTER_CONCURRENCY_LEVEL, IndicesFilterCache.this.concurrencyLevel);, +            if (concurrencyLevel <= 0) {, +                throw new ElasticsearchIllegalArgumentException("concurrency_level must be > 0 but was: " + concurrencyLevel);, +            }, +            if (!Objects.equal(concurrencyLevel, IndicesFilterCache.this.concurrencyLevel)) {, +                logger.info("updating [indices.cache.filter.concurrency_level] from [{}] to [{}]", IndicesFilterCache.this.concurrencyLevel, concurrencyLevel);, +                IndicesFilterCache.this.concurrencyLevel = concurrencyLevel;, +                replace = true;, +            }, +        this.concurrencyLevel =  settings.getAsInt(INDICES_CACHE_FILTER_CONCURRENCY_LEVEL, 16);, +        if (concurrencyLevel <= 0) {, +            throw new ElasticsearchIllegalArgumentException("concurrency_level must be > 0 but was: " + concurrencyLevel);, +        }, +++ b/src/main/java/org/elasticsearch/indices/cache/query/IndicesQueryCache.java, +import org.elasticsearch.ElasticsearchIllegalArgumentException;, +    public static final String INDICES_CACHE_QUERY_CONCURRENCY_LEVEL = "indices.cache.query.concurrency_level";, +, +    private final String size;, +    private final TimeValue expire;, +    private final int concurrencyLevel;, +, +        // defaults to 4, but this is a busy map for all indices, increase it a bit by default, +        this.concurrencyLevel =  settings.getAsInt(INDICES_CACHE_QUERY_CONCURRENCY_LEVEL, 16);, +        if (concurrencyLevel <= 0) {, +            throw new ElasticsearchIllegalArgumentException("concurrency_level must be > 0 but was: " + concurrencyLevel);, +        }, +        cacheBuilder.concurrencyLevel(concurrencyLevel);, +++ b/src/main/java/org/elasticsearch/cluster/settings/ClusterDynamicSettingsModule.java, +        clusterDynamicSettings.addDynamicSetting(IndicesFilterCache.INDICES_CACHE_FILTER_CONCURRENCY_LEVEL, Validator.POSITIVE_INTEGER);, +++ b/src/main/java/org/elasticsearch/indices/cache/filter/IndicesFilterCache.java, +import org.elasticsearch.ElasticsearchIllegalArgumentException;, +    private volatile int concurrencyLevel;, +    public static final String INDICES_CACHE_FILTER_CONCURRENCY_LEVEL = "indices.cache.filter.concurrency_level";, +            final int concurrencyLevel = settings.getAsInt(INDICES_CACHE_FILTER_CONCURRENCY_LEVEL, IndicesFilterCache.this.concurrencyLevel);, +            if (concurrencyLevel <= 0) {, +                throw new ElasticsearchIllegalArgumentException("concurrency_level must be > 0 but was: " + concurrencyLevel);, +            }, +            if (!Objects.equal(concurrencyLevel, IndicesFilterCache.this.concurrencyLevel)) {, +                logger.info("updating [indices.cache.filter.concurrency_level] from [{}] to [{}]", IndicesFilterCache.this.concurrencyLevel, concurrencyLevel);, +                IndicesFilterCache.this.concurrencyLevel = concurrencyLevel;, +                replace = true;, +            }, +        this.concurrencyLevel =  settings.getAsInt(INDICES_CACHE_FILTER_CONCURRENCY_LEVEL, 16);, +        if (concurrencyLevel <= 0) {, +            throw new ElasticsearchIllegalArgumentException("concurrency_level must be > 0 but was: " + concurrencyLevel);, +        }, +++ b/src/main/java/org/elasticsearch/indices/cache/query/IndicesQueryCache.java, +import org.elasticsearch.ElasticsearchIllegalArgumentException;, +    public static final String INDICES_CACHE_QUERY_CONCURRENCY_LEVEL = "indices.cache.query.concurrency_level";, +, +    private final String size;, +    private final TimeValue expire;, +    private final int concurrencyLevel;, +, +        // defaults to 4, but this is a busy map for all indices, increase it a bit by default, +        this.concurrencyLevel =  settings.getAsInt(INDICES_CACHE_QUERY_CONCURRENCY_LEVEL, 16);, +        if (concurrencyLevel <= 0) {, +            throw new ElasticsearchIllegalArgumentException("concurrency_level must be > 0 but was: " + concurrencyLevel);, +        }, +        cacheBuilder.concurrencyLevel(concurrencyLevel);, +++ b/src/main/java/org/elasticsearch/indices/fielddata/cache/IndicesFieldDataCache.java, +import org.elasticsearch.ElasticsearchIllegalArgumentException;, +    public static final String FIELDDATA_CACHE_CONCURRENCY_LEVEL = "indices.fielddata.cache.concurrency_level";, +, +        // defaults to 4, but this is a busy map for all indices, increase it a bit by default, +        final int concurrencyLevel =  settings.getAsInt(FIELDDATA_CACHE_CONCURRENCY_LEVEL, 16);, +        if (concurrencyLevel <= 0) {, +            throw new ElasticsearchIllegalArgumentException("concurrency_level must be > 0 but was: " + concurrencyLevel);, +        }, +        cacheBuilder.concurrencyLevel(concurrencyLevel);, +++ b/src/main/java/org/elasticsearch/cluster/settings/ClusterDynamicSettingsModule.java, +        clusterDynamicSettings.addDynamicSetting(IndicesFilterCache.INDICES_CACHE_FILTER_CONCURRENCY_LEVEL, Validator.POSITIVE_INTEGER);, +++ b/src/main/java/org/elasticsearch/indices/cache/filter/IndicesFilterCache.java]