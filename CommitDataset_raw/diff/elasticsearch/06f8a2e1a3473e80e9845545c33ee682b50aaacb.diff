[+++ b/src/main/java/org/elasticsearch/common/lucene/docset/AndDocIdSet.java, +            return IteratorBasedIterator.newDocIdSetIterator(iterators.toArray(new DocIdSet[iterators.size()]));, +                IteratorBasedIterator.newDocIdSetIterator(iterators.toArray(new DocIdSet[iterators.size()])),, +        private int lastReturn = -1;, +        private final DocIdSetIterator[] iterators;, +, +        public static DocIdSetIterator newDocIdSetIterator(DocIdSet[] sets) throws IOException {, +            if (sets.length == 0) {, +                return  DocIdSetIterator.empty();, +            }, +            final DocIdSetIterator[] iterators = new DocIdSetIterator[sets.length];, +                    return DocIdSetIterator.empty();, +                    DocIdSetIterator docIdSetIterator = set.iterator();, +                    if (docIdSetIterator == null) {, +                        return DocIdSetIterator.empty();// non matching, +                    }, +                    iterators[j++] = docIdSetIterator;, +                    cost = Math.min(cost, docIdSetIterator.cost());, +                }, +            }, +            if (sets.length == 1) {, +               // shortcut if there is only one valid iterator., +               return iterators[0];, +            }, +            return new IteratorBasedIterator(iterators, cost);, +        }, +        private IteratorBasedIterator(DocIdSetIterator[] iterators, long cost) throws IOException {, +            this.iterators = iterators;, +            if (lastReturn == DocIdSetIterator.NO_MORE_DOCS) {, +                assert false : "Illegal State - DocIdSetIterator is already exhausted";, +                return DocIdSetIterator.NO_MORE_DOCS;, +            }, +            if (lastReturn == DocIdSetIterator.NO_MORE_DOCS) {, +                assert false : "Illegal State - DocIdSetIterator is already exhausted";, +                return DocIdSetIterator.NO_MORE_DOCS;, +            }, +++ b/src/main/java/org/elasticsearch/common/lucene/docset/AndDocIdSet.java, +            return IteratorBasedIterator.newDocIdSetIterator(iterators.toArray(new DocIdSet[iterators.size()]));, +                IteratorBasedIterator.newDocIdSetIterator(iterators.toArray(new DocIdSet[iterators.size()])),, +        private int lastReturn = -1;, +        private final DocIdSetIterator[] iterators;, +, +        public static DocIdSetIterator newDocIdSetIterator(DocIdSet[] sets) throws IOException {, +            if (sets.length == 0) {, +                return  DocIdSetIterator.empty();, +            }, +            final DocIdSetIterator[] iterators = new DocIdSetIterator[sets.length];, +                    return DocIdSetIterator.empty();, +                    DocIdSetIterator docIdSetIterator = set.iterator();, +                    if (docIdSetIterator == null) {, +                        return DocIdSetIterator.empty();// non matching, +                    }, +                    iterators[j++] = docIdSetIterator;, +                    cost = Math.min(cost, docIdSetIterator.cost());, +                }, +            }, +            if (sets.length == 1) {, +               // shortcut if there is only one valid iterator., +               return iterators[0];, +            }, +            return new IteratorBasedIterator(iterators, cost);, +        }, +        private IteratorBasedIterator(DocIdSetIterator[] iterators, long cost) throws IOException {, +            this.iterators = iterators;, +            if (lastReturn == DocIdSetIterator.NO_MORE_DOCS) {, +                assert false : "Illegal State - DocIdSetIterator is already exhausted";, +                return DocIdSetIterator.NO_MORE_DOCS;, +            }, +            if (lastReturn == DocIdSetIterator.NO_MORE_DOCS) {, +                assert false : "Illegal State - DocIdSetIterator is already exhausted";, +                return DocIdSetIterator.NO_MORE_DOCS;, +            }, +++ b/src/test/java/org/elasticsearch/percolator/PercolatorTests.java, +    @Test, +    public void percolateNonMatchingConstantScoreQuery() throws Exception {, +        assertAcked(client().admin().indices().prepareCreate("test"));, +        ensureGreen();, +, +        logger.info("--> register a query");, +        client().prepareIndex("test", PercolatorService.TYPE_NAME, "1"), +                .setSource(jsonBuilder().startObject(), +                        .field("query", QueryBuilders.constantScoreQuery(FilterBuilders.andFilter(, +                                FilterBuilders.queryFilter(QueryBuilders.queryString("root")),, +                                FilterBuilders.termFilter("message", "tree")))), +                        .endObject()), +                .setRefresh(true), +                .execute().actionGet();, +, +        PercolateResponse percolate = client().preparePercolate(), +                .setIndices("test").setDocumentType("doc"), +                .setSource(jsonBuilder().startObject(), +                        .startObject("doc").field("message", "A new bonsai tree ").endObject(), +                        .endObject()), +                .execute().actionGet();, +        assertThat(percolate.getFailedShards(), equalTo(0));, +        assertMatchCount(percolate, 0l);, +    }, +]