[+++ b/x-pack/plugin/ccr/src/test/java/org/elasticsearch/xpack/ccr/IndexFollowingIT.java, +import org.elasticsearch.ExceptionsHelper;, +import org.elasticsearch.ResourceAlreadyExistsException;, +import org.elasticsearch.ResourceNotFoundException;, +import org.elasticsearch.action.admin.indices.flush.FlushRequest;, +import org.elasticsearch.action.admin.indices.forcemerge.ForceMergeRequest;, +import org.elasticsearch.action.admin.indices.refresh.RefreshRequest;, +import org.elasticsearch.snapshots.SnapshotRestoreException;, +import java.util.Set;, +import static org.hamcrest.Matchers.greaterThan;, +    public void testMustCloseIndexAndPauseToRestartWithPutFollowing() throws Exception {, +        final int numberOfPrimaryShards = randomIntBetween(1, 3);, +        final String leaderIndexSettings = getIndexSettings(numberOfPrimaryShards, between(0, 1),, +            singletonMap(IndexSettings.INDEX_SOFT_DELETES_SETTING.getKey(), "true"));, +        assertAcked(leaderClient().admin().indices().prepareCreate("index1").setSource(leaderIndexSettings, XContentType.JSON));, +        ensureLeaderYellow("index1");, +, +        final PutFollowAction.Request followRequest = putFollow("index1", "index2");, +        PutFollowAction.Response response = followerClient().execute(PutFollowAction.INSTANCE, followRequest).get();, +        assertTrue(response.isFollowIndexCreated());, +        assertTrue(response.isFollowIndexShardsAcked());, +        assertTrue(response.isIndexFollowingStarted());, +, +        final PutFollowAction.Request followRequest2 = putFollow("index1", "index2");, +        expectThrows(SnapshotRestoreException.class,, +            () -> followerClient().execute(PutFollowAction.INSTANCE, followRequest2).actionGet());, +, +        followerClient().admin().indices().prepareClose("index2").get();, +        expectThrows(ResourceAlreadyExistsException.class,, +            () -> followerClient().execute(PutFollowAction.INSTANCE, followRequest2).actionGet());, +    }, +, +    public void testIndexFallBehind() throws Exception {, +        final int numberOfPrimaryShards = randomIntBetween(1, 3);, +        final String leaderIndexSettings = getIndexSettings(numberOfPrimaryShards, between(0, 1),, +            singletonMap(IndexSettings.INDEX_SOFT_DELETES_SETTING.getKey(), "true"));, +        assertAcked(leaderClient().admin().indices().prepareCreate("index1").setSource(leaderIndexSettings, XContentType.JSON));, +        ensureLeaderYellow("index1");, +, +        final int numDocs = randomIntBetween(2, 64);, +        logger.info("Indexing [{}] docs as first batch", numDocs);, +        for (int i = 0; i < numDocs; i++) {, +            final String source = String.format(Locale.ROOT, "{\"f\":%d}", i);, +            leaderClient().prepareIndex("index1", "doc", Integer.toString(i)).setSource(source, XContentType.JSON).get();, +        }, +, +        final PutFollowAction.Request followRequest = putFollow("index1", "index2");, +        PutFollowAction.Response response = followerClient().execute(PutFollowAction.INSTANCE, followRequest).get();, +        assertTrue(response.isFollowIndexCreated());, +        assertTrue(response.isFollowIndexShardsAcked());, +        assertTrue(response.isIndexFollowingStarted());, +, +        assertIndexFullyReplicatedToFollower("index1", "index2");, +        for (int i = 0; i < numDocs; i++) {, +            assertBusy(assertExpectedDocumentRunnable(i));, +        }, +, +        pauseFollow("index2");, +, +        for (int i = 0; i < numDocs; i++) {, +            final String source = String.format(Locale.ROOT, "{\"f\":%d}", i * 2);, +            leaderClient().prepareIndex("index1", "doc", Integer.toString(i)).setSource(source, XContentType.JSON).get();, +        }, +        leaderClient().prepareDelete("index1", "doc", "1").get();, +        leaderClient().admin().indices().refresh(new RefreshRequest("index1")).actionGet();, +        leaderClient().admin().indices().flush(new FlushRequest("index1").force(true)).actionGet();, +        ForceMergeRequest forceMergeRequest = new ForceMergeRequest("index1");, +        forceMergeRequest.maxNumSegments(1);, +        leaderClient().admin().indices().forceMerge(forceMergeRequest).actionGet();, +, +        followerClient().execute(ResumeFollowAction.INSTANCE, followRequest.getFollowRequest()).get();, +, +        assertBusy(() -> {, +            List<ShardFollowNodeTaskStatus> statuses = getFollowTaskStatuses("index2");, +            Set<ResourceNotFoundException> exceptions = statuses.stream(), +                .map(ShardFollowNodeTaskStatus::getFatalException), +                .filter(Objects::nonNull), +                .map(ExceptionsHelper::unwrapCause), +                .filter(e -> e instanceof ResourceNotFoundException), +                .map(e -> (ResourceNotFoundException) e), +                .filter(e -> e.getMetadataKeys().contains("es.requested_operations_missing")), +                .collect(Collectors.toSet());, +            assertThat(exceptions.size(), greaterThan(0));, +        });, +, +        followerClient().admin().indices().prepareClose("index2").get();, +        pauseFollow("index2");, +, +, +        final PutFollowAction.Request followRequest2 = putFollow("index1", "index2");, +        PutFollowAction.Response response2 = followerClient().execute(PutFollowAction.INSTANCE, followRequest2).get();, +        assertTrue(response2.isFollowIndexCreated());, +        assertTrue(response2.isFollowIndexShardsAcked());, +        assertTrue(response2.isIndexFollowingStarted());, +, +        ensureFollowerGreen("index2");, +        assertIndexFullyReplicatedToFollower("index1", "index2");, +        for (int i = 2; i < numDocs; i++) {, +            assertBusy(assertExpectedDocumentRunnable(i, i * 2));, +        }]