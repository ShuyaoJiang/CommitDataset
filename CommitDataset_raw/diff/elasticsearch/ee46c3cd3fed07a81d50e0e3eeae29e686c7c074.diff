[+++ b/src/main/java/org/elasticsearch/index/mapper/core/TypeParsers.java, +, +            final Map<String, Object> multiFieldsPropNodes;, +, +            if (propNode instanceof List && ((List<?>) propNode).isEmpty()) {, +                multiFieldsPropNodes = Collections.emptyMap();, +            } else if (propNode instanceof Map) {, +                multiFieldsPropNodes = (Map<String, Object>) propNode;, +            } else {, +                throw new MapperParsingException("Expected map for property [fields] on field [" + propNode + "] or " +, +                        "[" + propName + "] but got a " + propNode.getClass());, +            }, +, +++ b/src/main/java/org/elasticsearch/index/mapper/core/TypeParsers.java, +, +            final Map<String, Object> multiFieldsPropNodes;, +, +            if (propNode instanceof List && ((List<?>) propNode).isEmpty()) {, +                multiFieldsPropNodes = Collections.emptyMap();, +            } else if (propNode instanceof Map) {, +                multiFieldsPropNodes = (Map<String, Object>) propNode;, +            } else {, +                throw new MapperParsingException("Expected map for property [fields] on field [" + propNode + "] or " +, +                        "[" + propName + "] but got a " + propNode.getClass());, +            }, +, +++ b/src/main/java/org/elasticsearch/index/mapper/object/ObjectMapper.java, +                //Should accept empty arrays, as a work around for when the user can't provide an empty Map. (PHP for example), +                boolean isEmptyList = entry.getValue() instanceof List && ((List<?>) entry.getValue()).isEmpty();, +                if (entry.getValue() instanceof  Map) {, +                    @SuppressWarnings("unchecked"), +                    Map<String, Object> propNode = (Map<String, Object>) entry.getValue();, +                } else if (!isEmptyList) {, +                    throw new MapperParsingException("Expected map for property [fields] on field [" + propName + "] but got a " + propName.getClass());, +                }, +++ b/src/main/java/org/elasticsearch/index/mapper/core/TypeParsers.java, +, +            final Map<String, Object> multiFieldsPropNodes;, +, +            if (propNode instanceof List && ((List<?>) propNode).isEmpty()) {, +                multiFieldsPropNodes = Collections.emptyMap();, +            } else if (propNode instanceof Map) {, +                multiFieldsPropNodes = (Map<String, Object>) propNode;, +            } else {, +                throw new MapperParsingException("Expected map for property [fields] on field [" + propNode + "] or " +, +                        "[" + propName + "] but got a " + propNode.getClass());, +            }, +, +++ b/src/main/java/org/elasticsearch/index/mapper/object/ObjectMapper.java, +                //Should accept empty arrays, as a work around for when the user can't provide an empty Map. (PHP for example), +                boolean isEmptyList = entry.getValue() instanceof List && ((List<?>) entry.getValue()).isEmpty();, +                if (entry.getValue() instanceof  Map) {, +                    @SuppressWarnings("unchecked"), +                    Map<String, Object> propNode = (Map<String, Object>) entry.getValue();, +                } else if (!isEmptyList) {, +                    throw new MapperParsingException("Expected map for property [fields] on field [" + propName + "] but got a " + propName.getClass());, +                }, +++ b/src/test/java/org/elasticsearch/index/mapper/object/SimpleObjectMappingTests.java, +, +    @Test, +    public void emptyFieldsArrayMultiFieldsTest() throws Exception {, +        String mapping = XContentFactory.jsonBuilder(), +                                        .startObject(), +                                            .startObject("tweet"), +                                                .startObject("properties"), +                                                    .startObject("name"), +                                                        .field("type", "string"), +                                                        .field("index", "analyzed"), +                                                        .startArray("fields"), +                                                        .endArray(), +                                                    .endObject(), +                                                .endObject(), +                                            .endObject(), +                                        .endObject(), +                                        .string();, +        createIndex("test").mapperService().documentMapperParser().parse(mapping);, +    }, +, +    @Test(expected = MapperParsingException.class), +    public void fieldsArrayMultiFieldsShouldThrowExceptionTest() throws Exception {, +        String mapping = XContentFactory.jsonBuilder(), +                .startObject(), +                    .startObject("tweet"), +                        .startObject("properties"), +                            .startObject("name"), +                                .field("type", "string"), +                                .field("index", "analyzed"), +                                .startArray("fields"), +                                    .field("test", "string"), +                                    .field("test2", "string"), +                                .endArray(), +                            .endObject(), +                        .endObject(), +                    .endObject(), +                .endObject(), +                .string();, +        createIndex("test").mapperService().documentMapperParser().parse(mapping);, +    }, +, +    @Test]