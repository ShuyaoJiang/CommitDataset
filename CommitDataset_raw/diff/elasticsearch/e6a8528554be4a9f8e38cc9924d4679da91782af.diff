[+++ b/server/src/main/java/org/elasticsearch/search/aggregations/bucket/nested/NestedAggregator.java, +public class NestedAggregator extends BucketsAggregator implements SingleBucketAggregator {, +++ b/server/src/main/java/org/elasticsearch/search/aggregations/bucket/nested/NestedAggregator.java, +public class NestedAggregator extends BucketsAggregator implements SingleBucketAggregator {, +++ b/server/src/main/java/org/elasticsearch/search/aggregations/bucket/terms/TermsAggregator.java, +import org.elasticsearch.search.aggregations.bucket.nested.NestedAggregator;, +        if (subAggsNeedScore() && descendsFromNestedAggregator(parent)) {, +            /**, +             * Force the execution to depth_first because we need to access the score of, +             * nested documents in a sub-aggregation and we are not able to generate this score, +             * while replaying deferred documents., +             */, +            this.collectMode = SubAggCollectionMode.DEPTH_FIRST;, +        } else {, +        }, +    static boolean descendsFromNestedAggregator(Aggregator parent) {, +        while (parent != null) {, +            if (parent.getClass() == NestedAggregator.class) {, +                return true;, +            }, +            parent = parent.parent();, +        }, +        return false;, +    }, +, +    private boolean subAggsNeedScore() {, +        for (Aggregator subAgg : subAggregators) {, +            if (subAgg.needsScores()) {, +                return true;, +            }, +        }, +        return false;, +    }, +, +++ b/server/src/main/java/org/elasticsearch/search/aggregations/bucket/nested/NestedAggregator.java, +public class NestedAggregator extends BucketsAggregator implements SingleBucketAggregator {, +++ b/server/src/main/java/org/elasticsearch/search/aggregations/bucket/terms/TermsAggregator.java, +import org.elasticsearch.search.aggregations.bucket.nested.NestedAggregator;, +        if (subAggsNeedScore() && descendsFromNestedAggregator(parent)) {, +            /**, +             * Force the execution to depth_first because we need to access the score of, +             * nested documents in a sub-aggregation and we are not able to generate this score, +             * while replaying deferred documents., +             */, +            this.collectMode = SubAggCollectionMode.DEPTH_FIRST;, +        } else {, +        }, +    static boolean descendsFromNestedAggregator(Aggregator parent) {, +        while (parent != null) {, +            if (parent.getClass() == NestedAggregator.class) {, +                return true;, +            }, +            parent = parent.parent();, +        }, +        return false;, +    }, +, +    private boolean subAggsNeedScore() {, +        for (Aggregator subAgg : subAggregators) {, +            if (subAgg.needsScores()) {, +                return true;, +            }, +        }, +        return false;, +    }, +, +++ b/server/src/test/java/org/elasticsearch/search/aggregations/bucket/terms/TermsAggregatorTests.java, +import org.apache.lucene.index.Term;, +import org.apache.lucene.search.DocValuesFieldExistsQuery;, +import org.apache.lucene.search.TermQuery;, +import org.elasticsearch.index.mapper.SeqNoFieldMapper;, +import org.elasticsearch.index.mapper.TypeFieldMapper;, +import org.elasticsearch.index.mapper.UidFieldMapper;, +import org.elasticsearch.search.aggregations.bucket.nested.InternalNested;, +import org.elasticsearch.search.aggregations.bucket.nested.NestedAggregationBuilder;, +import org.elasticsearch.search.aggregations.bucket.nested.NestedAggregator;, +import org.elasticsearch.search.sort.FieldSortBuilder;, +import org.elasticsearch.search.sort.ScoreSortBuilder;, +import static org.elasticsearch.index.mapper.SeqNoFieldMapper.PRIMARY_TERM_NAME;, +    public void testWithNestedAggregations() throws IOException {, +        try (Directory directory = newDirectory()) {, +            try (RandomIndexWriter indexWriter = new RandomIndexWriter(random(), directory)) {, +                for (int i = 0; i < 10; i++) {, +                    int[] nestedValues = new int[i];, +                    for (int j = 0; j < i; j++) {, +                        nestedValues[j] = j;, +                    }, +                    indexWriter.addDocuments(generateDocsWithNested(Integer.toString(i), i, nestedValues));, +                }, +                indexWriter.commit();, +                for (Aggregator.SubAggCollectionMode mode : Aggregator.SubAggCollectionMode.values()) {, +                    for (boolean withScore : new boolean[]{true, false}) {, +                        NestedAggregationBuilder nested = new NestedAggregationBuilder("nested", "nested_object"), +                            .subAggregation(new TermsAggregationBuilder("terms", ValueType.LONG), +                                .field("nested_value"), +                                // force the breadth_first mode, +                                .collectMode(mode), +                                .order(BucketOrder.key(true)), +                                .subAggregation(, +                                    new TopHitsAggregationBuilder("top_hits")]