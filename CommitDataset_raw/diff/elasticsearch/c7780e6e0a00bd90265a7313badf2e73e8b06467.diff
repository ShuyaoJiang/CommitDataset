[+++ b/buildSrc/src/main/resources/checkstyle_suppressions.xml, +++ b/buildSrc/src/main/resources/checkstyle_suppressions.xml, +++ b/core/src/main/java/org/elasticsearch/common/xcontent/ObjectParser.java, +import java.lang.reflect.Array;, +import java.util.function.Consumer;, +import static org.elasticsearch.common.xcontent.XContentParser.Token.START_ARRAY;, +import static org.elasticsearch.common.xcontent.XContentParser.Token.START_OBJECT;, +import static org.elasticsearch.common.xcontent.XContentParser.Token.VALUE_BOOLEAN;, +import static org.elasticsearch.common.xcontent.XContentParser.Token.VALUE_EMBEDDED_OBJECT;, +import static org.elasticsearch.common.xcontent.XContentParser.Token.VALUE_NULL;, +import static org.elasticsearch.common.xcontent.XContentParser.Token.VALUE_NUMBER;, +import static org.elasticsearch.common.xcontent.XContentParser.Token.VALUE_STRING;, +, + * A declarative Object parser to parse any kind of XContent structures into existing object with setters. The Parser is designed to be, + * declarative and stateless. A single parser is defined for one object level, nested elements can be added via, + * {@link #declareObject(BiConsumer, BiFunction, ParseField)} which is commonly done by declaring yet another instance of, + * {@link ObjectParser}. Instances of {@link ObjectParser} are thread-safe and can be re-used across parsing operations. It's recommended to, + * use the high level declare methods like {@link #declareString(BiConsumer, ParseField)} instead of {@link #declareField} which can be used, + * to implement exceptional parsing operations not covered by the high level methods., +    /**, +     * Adapts an array (or varags) setter into a list setter., +     */, +    public static <Value, ElementValue> BiConsumer<Value, List<ElementValue>> fromList(Class<ElementValue> c,, +            BiConsumer<Value, ElementValue[]> consumer) {, +        return (Value v, List<ElementValue> l) -> {, +            @SuppressWarnings("unchecked"), +            ElementValue[] array = (ElementValue[]) Array.newInstance(c, l.size());, +            consumer.accept(v, l.toArray(array));, +        };, +    }, +    private void parseArray(XContentParser parser, FieldParser<Value> fieldParser, String currentFieldName, Value value, Context context), +            throws IOException {, +    private void parseValue(XContentParser parser, FieldParser<Value> fieldParser, String currentFieldName, Value value, Context context), +            throws IOException {, +    private void parseSub(XContentParser parser, FieldParser<Value> fieldParser, String currentFieldName, Value value, Context context), +            throws IOException {, +    public <T> void declareObjectArray(BiConsumer<Value, List<T>> consumer, BiFunction<XContentParser, Context, T> objectParser,, +            ParseField field) {, +    public <T> void declareObjectOrDefault(BiConsumer<Value, T> consumer, BiFunction<XContentParser, Context, T> objectParser,, +            Supplier<T> defaultValue, ParseField field) {, +        declareField((p, v, c) -> consumer.accept(v, p.currentToken() == XContentParser.Token.VALUE_NULL ? null : p.text()), field,, +                ValueType.STRING_OR_NULL);, +    /**, +     * Declares named objects in the style of highlighting's field element. These are usually named inside and object like this:, +     * <pre><code>, +     * {, +     *   "highlight": {, +     *     "fields": {        &lt;------ this one, +     *       "title": {},, +     *       "body": {},, +     *       "category": {}, +     *     }, +     *   }, +     * }, +     * </code></pre>, +     * but, when order is important, some may be written this way:, +     * <pre><code>, +     * {, +     *   "highlight": {, +     *     "fields": [        &lt;------ this one, +     *       {"title": {}},, +     *       {"body": {}},, +     *       {"category": {}}, +     *     ], +     *   }, +     * }, +     * </code></pre>, +     * This is because json doesn't enforce ordering. Elasticsearch reads it in the order sent but tools that generate json are free to put, +     * object members in an unordered Map, jumbling them. Thus, if you care about order you can send the object in the second way., +     *, +     * See NamedObjectHolder in ObjectParserTests for examples of how to invoke this., +     *, +     * @param consumer sets the values once they have been parsed, +     * @param namedObjectParser parses each named object, +     * @param orderedModeCallback called when the named object is parsed using the "ordered" mode (the array of objects), +     * @param field the field to parse, +     */, +    public <T> void declareNamedObjects(BiConsumer<Value, List<T>> consumer, NamedObjectParser<T, Context> namedObjectParser,, +            Consumer<Value> orderedModeCallback, ParseField field) {, +        // This creates and parses the named object, +        BiFunction<XContentParser, Context, T> objectParser = (XContentParser p, Context c) -> {, +            if (p.currentToken() != XContentParser.Token.FIELD_NAME) {, +                throw new ParsingException(p.getTokenLocation(), "[" + field + "] can be a single object with any number of ", +                        + "fields or an array where each entry is an object with a single field");, +            }, +            // This messy exception nesting has the nice side effect of telling the use which field failed to parse, +            try {, +                String name = p.currentName();, +                try {, +                    return namedObjectParser.parse(p, c, name);, +                } catch (Exception e) {, +                    throw new ParsingException(p.getTokenLocation(), "[" + field + "] failed to parse field [" + name + "]", e);, +                }, +            } catch (IOException e) {, +                throw new ParsingException(p.getTokenLocation(), "[" + field + "] error while parsing", e);, +            }, +        };, +        declareField((XContentParser p, Value v, Context c) -> {, +            List<T> fields = new ArrayList<>();, +            XContentParser.Token token;]