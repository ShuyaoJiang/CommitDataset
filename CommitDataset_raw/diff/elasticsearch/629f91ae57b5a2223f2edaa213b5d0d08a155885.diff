[+++ b/src/main/java/org/elasticsearch/index/fielddata/FieldData.java, +     * Return a {@link SortedBinaryDocValues} that doesn't contain any value., +     */, +    public static SortedBinaryDocValues emptySortedBinary(int maxDoc) {, +        return singleton(DocValues.emptyBinary(), new Bits.MatchNoBits(maxDoc));, +    }, +, +    /**, +++ b/src/main/java/org/elasticsearch/index/fielddata/FieldData.java, +     * Return a {@link SortedBinaryDocValues} that doesn't contain any value., +     */, +    public static SortedBinaryDocValues emptySortedBinary(int maxDoc) {, +        return singleton(DocValues.emptyBinary(), new Bits.MatchNoBits(maxDoc));, +    }, +, +    /**, +++ b/src/main/java/org/elasticsearch/index/fielddata/IndexFieldData.java, +import org.apache.lucene.search.*;, +import org.apache.lucene.util.FixedBitSet;, +import org.elasticsearch.index.fielddata.IndexFieldData.XFieldComparatorSource.Nested;, +import java.io.IOException;, +, +    XFieldComparatorSource comparatorSource(@Nullable Object missingValue, MultiValueMode sortMode, Nested nested);, +        /**, +         * Simple wrapper class around a filter that matches parent documents, +         * and a filter that matches child documents. For every root document R,, +         * R will be in the parent filter and its children documents will be the, +         * documents that are contained in the inner set between the previous, +         * parent + 1, or 0 if there is no previous parent, and R (excluded)., +         */, +        public static class Nested {, +            private final Filter rootFilter, innerFilter;, +, +            public Nested(Filter rootFilter, Filter innerFilter) {, +                this.rootFilter = rootFilter;, +                this.innerFilter = innerFilter;, +            }, +, +            // TODO: nested docs should not be random filters but specialized, +            // ones that guarantee that you always get a FixedBitSet, +            @Deprecated, +            private static FixedBitSet toFixedBitSet(DocIdSet set, int maxDoc) throws IOException {, +                if (set == null || set instanceof FixedBitSet) {, +                    return (FixedBitSet) set;, +                } else {, +                    final FixedBitSet fixedBitSet = new FixedBitSet(maxDoc);, +                    final DocIdSetIterator it = set.iterator();, +                    if (it != null) {, +                        fixedBitSet.or(it);, +                    }, +                    return fixedBitSet;, +                }, +            }, +, +            /**, +             * Get a {@link FixedBitSet} that matches the root documents., +             */, +            public FixedBitSet rootDocs(AtomicReaderContext ctx) throws IOException {, +                return toFixedBitSet(rootFilter.getDocIdSet(ctx, null), ctx.reader().maxDoc());, +            }, +, +            /**, +             * Get a {@link FixedBitSet} that matches the inner documents., +             */, +            public FixedBitSet innerDocs(AtomicReaderContext ctx) throws IOException {, +                return toFixedBitSet(innerFilter.getDocIdSet(ctx, null), ctx.reader().maxDoc());, +            }, +        }, +, +++ b/src/main/java/org/elasticsearch/index/fielddata/FieldData.java, +     * Return a {@link SortedBinaryDocValues} that doesn't contain any value., +     */, +    public static SortedBinaryDocValues emptySortedBinary(int maxDoc) {, +        return singleton(DocValues.emptyBinary(), new Bits.MatchNoBits(maxDoc));, +    }, +, +    /**, +++ b/src/main/java/org/elasticsearch/index/fielddata/IndexFieldData.java, +import org.apache.lucene.search.*;, +import org.apache.lucene.util.FixedBitSet;, +import org.elasticsearch.index.fielddata.IndexFieldData.XFieldComparatorSource.Nested;, +import java.io.IOException;, +, +    XFieldComparatorSource comparatorSource(@Nullable Object missingValue, MultiValueMode sortMode, Nested nested);, +        /**, +         * Simple wrapper class around a filter that matches parent documents, +         * and a filter that matches child documents. For every root document R,, +         * R will be in the parent filter and its children documents will be the, +         * documents that are contained in the inner set between the previous, +         * parent + 1, or 0 if there is no previous parent, and R (excluded)., +         */, +        public static class Nested {, +            private final Filter rootFilter, innerFilter;, +, +            public Nested(Filter rootFilter, Filter innerFilter) {, +                this.rootFilter = rootFilter;, +                this.innerFilter = innerFilter;, +            }, +, +            // TODO: nested docs should not be random filters but specialized]