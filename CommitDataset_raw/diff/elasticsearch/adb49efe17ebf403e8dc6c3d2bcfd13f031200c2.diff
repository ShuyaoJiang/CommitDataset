[+++ b/core/src/main/java/org/elasticsearch/index/engine/InternalEngine.java, +                final SequenceNumbers.CommitInfo seqNoStats = store.loadSeqNoInfo();, +                maxSeqNo = seqNoStats.maxSeqNo;, +                localCheckpoint = seqNoStats.localCheckpoint;, +++ b/core/src/main/java/org/elasticsearch/index/engine/InternalEngine.java, +                final SequenceNumbers.CommitInfo seqNoStats = store.loadSeqNoInfo();, +                maxSeqNo = seqNoStats.maxSeqNo;, +                localCheckpoint = seqNoStats.localCheckpoint;, +++ b/core/src/main/java/org/elasticsearch/index/seqno/SequenceNumbers.java, +    public static CommitInfo loadSeqNoInfoFromLuceneCommit(, +        return new CommitInfo(maxSeqNo, localCheckpoint);, +    public static final class CommitInfo {, +        public final long maxSeqNo;, +        public final long localCheckpoint;, +, +        public CommitInfo(long maxSeqNo, long localCheckpoint) {, +            this.maxSeqNo = maxSeqNo;, +            this.localCheckpoint = localCheckpoint;, +        }, +    }, +++ b/core/src/main/java/org/elasticsearch/index/engine/InternalEngine.java, +                final SequenceNumbers.CommitInfo seqNoStats = store.loadSeqNoInfo();, +                maxSeqNo = seqNoStats.maxSeqNo;, +                localCheckpoint = seqNoStats.localCheckpoint;, +++ b/core/src/main/java/org/elasticsearch/index/seqno/SequenceNumbers.java, +    public static CommitInfo loadSeqNoInfoFromLuceneCommit(, +        return new CommitInfo(maxSeqNo, localCheckpoint);, +    public static final class CommitInfo {, +        public final long maxSeqNo;, +        public final long localCheckpoint;, +, +        public CommitInfo(long maxSeqNo, long localCheckpoint) {, +            this.maxSeqNo = maxSeqNo;, +            this.localCheckpoint = localCheckpoint;, +        }, +    }, +++ b/core/src/main/java/org/elasticsearch/index/shard/IndexShard.java, +    /** creates an empty index and translog and opens the engine **/, +    public void createIndexAndTranslog() throws IOException {, +        assert recoveryState.getRecoverySource().getType() == RecoverySource.Type.EMPTY_STORE;, +        assert shardRouting.primary() && shardRouting.isRelocationTarget() == false;, +        globalCheckpointTracker.updateGlobalCheckpointOnReplica(SequenceNumbers.NO_OPS_PERFORMED, "index created");, +        innerOpenEngineAndTranslog(EngineConfig.OpenMode.CREATE_INDEX_AND_TRANSLOG, false);, +    /** opens the engine on top of the existing lucene engine but creates an empty translog **/, +    public void openIndexAndCreateTranslog(boolean forceNewHistoryUUID, long globalCheckpoint) throws IOException {, +        assert recoveryState.getRecoverySource().getType() != RecoverySource.Type.EMPTY_STORE &&, +            recoveryState.getRecoverySource().getType() != RecoverySource.Type.EXISTING_STORE;, +        SequenceNumbers.CommitInfo commitInfo = store.loadSeqNoInfo();, +        assert commitInfo.localCheckpoint >= globalCheckpoint :, +            "trying to create a shard whose local checkpoint [" + commitInfo.localCheckpoint + "] is < global checkpoint [", +                    + globalCheckpoint + "]";, +        globalCheckpointTracker.updateGlobalCheckpointOnReplica(globalCheckpoint, "opening index with a new translog");, +        innerOpenEngineAndTranslog(EngineConfig.OpenMode.OPEN_INDEX_CREATE_TRANSLOG, forceNewHistoryUUID);, +    }, +, +    /**, +     * opens the engine on top of the existing lucene engine and translog., +     * Operations from the translog will be replayed to bring lucene up to date., +     **/, +    public void openIndexAndTranslog() throws IOException {, +        assert recoveryState.getRecoverySource().getType() == RecoverySource.Type.EXISTING_STORE;, +        innerOpenEngineAndTranslog(EngineConfig.OpenMode.OPEN_INDEX_AND_TRANSLOG, false);, +    }, +, +    private void innerOpenEngineAndTranslog(final EngineConfig.OpenMode openMode, final boolean forceNewHistoryUUID) throws IOException {, +        assert openMode == EngineConfig.OpenMode.CREATE_INDEX_AND_TRANSLOG || assertMaxUnsafeAutoIdInCommit();, +        final EngineConfig config = newEngineConfig(openMode, forceNewHistoryUUID);, +            // we have to set it before we recover from the translog as acquring a snapshot from the translog causes a sync which, +            // causes the global checkpoint to be pulled in., +            globalCheckpointTracker.updateGlobalCheckpointOnReplica(getEngine().getTranslog().getLastSyncedGlobalCheckpoint(),, +                "read from translog");, +        assert recoveryState.getStage() == RecoveryState.Stage.TRANSLOG : "TRANSLOG stage expected but was: " + recoveryState.getStage();, +    private EngineConfig newEngineConfig(EngineConfig.OpenMode openMode, final boolean forceNewHistoryUUID) {, +++ b/core/src/main/java/org/elasticsearch/index/engine/InternalEngine.java, +                final SequenceNumbers.CommitInfo seqNoStats = store.loadSeqNoInfo();, +                maxSeqNo = seqNoStats.maxSeqNo;, +                localCheckpoint = seqNoStats.localCheckpoint;, +++ b/core/src/main/java/org/elasticsearch/index/seqno/SequenceNumbers.java, +    public static CommitInfo loadSeqNoInfoFromLuceneCommit(, +        return new CommitInfo(maxSeqNo, localCheckpoint);, +    public static final class CommitInfo {, +        public final long maxSeqNo;, +        public final long localCheckpoint;, +, +        public CommitInfo(long maxSeqNo, long localCheckpoint) {, +            this.maxSeqNo = maxSeqNo;, +            this.localCheckpoint = localCheckpoint;, +        }, +    }, +++ b/core/src/main/java/org/elasticsearch/index/shard/IndexShard.java, +    /** creates an empty index and translog and opens the engine **/, +    public void createIndexAndTranslog() throws IOException {, +        assert recoveryState.getRecoverySource().getType() == RecoverySource.Type.EMPTY_STORE;, +        assert shardRouting.primary() && shardRouting.isRelocationTarget() == false;, +        globalCheckpointTracker.updateGlobalCheckpointOnReplica(SequenceNumbers.NO_OPS_PERFORMED, "index created");, +        innerOpenEngineAndTranslog(EngineConfig.OpenMode.CREATE_INDEX_AND_TRANSLOG, false);, +    /** opens the engine on top of the existing lucene engine but creates an empty translog **/, +    public void openIndexAndCreateTranslog(boolean forceNewHistoryUUID, long globalCheckpoint) throws IOException {, +        assert recoveryState.getRecoverySource().getType() != RecoverySource.Type.EMPTY_STORE &&, +            recoveryState.getRecoverySource().getType() != RecoverySource.Type.EXISTING_STORE;]