[+++ b/core/src/main/java/org/elasticsearch/search/aggregations/bucket/filter/FiltersAggregationBuilder.java, +        this(name, Arrays.asList(filters), true);, +    private FiltersAggregationBuilder(String name, List<KeyedFilter> filters, boolean keyed) {, +        if (keyed) {, +            // internally we want to have a fixed order of filters, regardless of the order of the filters in the request, +        } else {, +            this.keyed = false;, +        }, +     * @return true if this builders filters have a key, +     */, +    public boolean isKeyed() {, +        return this.keyed;, +    }, +, +    /**, +            return new FiltersAggregationBuilder(getName(), rewrittenFilters, this.keyed);, +++ b/core/src/main/java/org/elasticsearch/search/aggregations/bucket/filter/FiltersAggregationBuilder.java, +        this(name, Arrays.asList(filters), true);, +    private FiltersAggregationBuilder(String name, List<KeyedFilter> filters, boolean keyed) {, +        if (keyed) {, +            // internally we want to have a fixed order of filters, regardless of the order of the filters in the request, +        } else {, +            this.keyed = false;, +        }, +     * @return true if this builders filters have a key, +     */, +    public boolean isKeyed() {, +        return this.keyed;, +    }, +, +    /**, +            return new FiltersAggregationBuilder(getName(), rewrittenFilters, this.keyed);, +++ b/core/src/test/java/org/elasticsearch/search/aggregations/bucket/FiltersTests.java, +import org.elasticsearch.index.query.BoolQueryBuilder;, +import org.elasticsearch.index.query.MatchAllQueryBuilder;, +import org.elasticsearch.index.query.QueryRewriteContext;, +import org.elasticsearch.search.aggregations.AggregationBuilder;, +import static org.hamcrest.Matchers.instanceOf;, +, +, +    public void testRewrite() throws IOException {, +        // test non-keyed filter that doesn't rewrite, +        AggregationBuilder original = new FiltersAggregationBuilder("my-agg", new MatchAllQueryBuilder());, +        AggregationBuilder rewritten = original.rewrite(new QueryRewriteContext(xContentRegistry(), null, null, () -> 0L));, +        assertSame(original, rewritten);, +, +        // test non-keyed filter that does rewrite, +        original = new FiltersAggregationBuilder("my-agg", new BoolQueryBuilder());, +        rewritten = original.rewrite(new QueryRewriteContext(xContentRegistry(), null, null, () -> 0L));, +        assertNotSame(original, rewritten);, +        assertThat(rewritten, instanceOf(FiltersAggregationBuilder.class));, +        assertEquals("my-agg", ((FiltersAggregationBuilder) rewritten).getName());, +        assertEquals(1, ((FiltersAggregationBuilder) rewritten).filters().size());, +        assertEquals("0", ((FiltersAggregationBuilder) rewritten).filters().get(0).key());, +        assertThat(((FiltersAggregationBuilder) rewritten).filters().get(0).filter(), instanceOf(MatchAllQueryBuilder.class));, +        assertFalse(((FiltersAggregationBuilder) rewritten).isKeyed());, +, +        // test keyed filter that doesn't rewrite, +        original = new FiltersAggregationBuilder("my-agg", new KeyedFilter("my-filter",  new MatchAllQueryBuilder()));, +        rewritten = original.rewrite(new QueryRewriteContext(xContentRegistry(), null, null, () -> 0L));, +        assertSame(original, rewritten);, +, +        // test non-keyed filter that does rewrite, +        original = new FiltersAggregationBuilder("my-agg", new KeyedFilter("my-filter",  new BoolQueryBuilder()));, +        rewritten = original.rewrite(new QueryRewriteContext(xContentRegistry(), null, null, () -> 0L));, +        assertNotSame(original, rewritten);, +        assertThat(rewritten, instanceOf(FiltersAggregationBuilder.class));, +        assertEquals("my-agg", ((FiltersAggregationBuilder) rewritten).getName());, +        assertEquals(1, ((FiltersAggregationBuilder) rewritten).filters().size());, +        assertEquals("my-filter", ((FiltersAggregationBuilder) rewritten).filters().get(0).key());, +        assertThat(((FiltersAggregationBuilder) rewritten).filters().get(0).filter(), instanceOf(MatchAllQueryBuilder.class));, +        assertTrue(((FiltersAggregationBuilder) rewritten).isKeyed());, +    }, +++ b/core/src/main/java/org/elasticsearch/search/aggregations/bucket/filter/FiltersAggregationBuilder.java, +        this(name, Arrays.asList(filters), true);, +    private FiltersAggregationBuilder(String name, List<KeyedFilter> filters, boolean keyed) {, +        if (keyed) {, +            // internally we want to have a fixed order of filters, regardless of the order of the filters in the request, +        } else {, +            this.keyed = false;, +        }, +     * @return true if this builders filters have a key, +     */, +    public boolean isKeyed() {, +        return this.keyed;, +    }, +, +    /**, +            return new FiltersAggregationBuilder(getName(), rewrittenFilters, this.keyed);, +++ b/core/src/test/java/org/elasticsearch/search/aggregations/bucket/FiltersTests.java, +import org.elasticsearch.index.query.BoolQueryBuilder;, +import org.elasticsearch.index.query.MatchAllQueryBuilder;, +import org.elasticsearch.index.query.QueryRewriteContext;, +import org.elasticsearch.search.aggregations.AggregationBuilder;, +import static org.hamcrest.Matchers.instanceOf;, +, +, +    public void testRewrite() throws IOException {, +        // test non-keyed filter that doesn't rewrite, +        AggregationBuilder original = new FiltersAggregationBuilder("my-agg", new MatchAllQueryBuilder());]