[+++ b/core/src/main/java/org/elasticsearch/action/index/TransportIndexAction.java, +        SourceToParse sourceToParse = SourceToParse.source(SourceToParse.Origin.REPLICA, request.source()).index(shardId.getIndexName()).type(request.type()).id(request.id()), +        SourceToParse sourceToParse = SourceToParse.source(SourceToParse.Origin.PRIMARY, request.source()).index(request.index()).type(request.type()).id(request.id()), +++ b/core/src/main/java/org/elasticsearch/action/index/TransportIndexAction.java, +        SourceToParse sourceToParse = SourceToParse.source(SourceToParse.Origin.REPLICA, request.source()).index(shardId.getIndexName()).type(request.type()).id(request.id()), +        SourceToParse sourceToParse = SourceToParse.source(SourceToParse.Origin.PRIMARY, request.source()).index(request.index()).type(request.type()).id(request.id()), +++ b/core/src/main/java/org/elasticsearch/common/lucene/uid/PerThreadIDAndVersionLookup.java, +import org.elasticsearch.common.Numbers;, +    /** Only true when versions are indexed as payloads instead of docvalues */, +    private final boolean hasPayloads;, +    /** Only used for back compat, to lookup a version from payload */, +    private PostingsEnum posEnum;, +        boolean hasPayloads = false;, +                hasPayloads = terms.hasPayloads();, +        this.hasPayloads = hasPayloads;, +            if (versions != null || hasPayloads == false) {, +                // Use NDV to retrieve the version, in which case we only need PostingsEnum:, +, +                    if (versions != null) {, +                    } else {, +                        // _uid found, but no doc values and no payloads, +                        return new DocIdAndVersion(docID, Versions.NOT_SET, context);, +                    }, +                }, +            }, +, +            // ... but used to be stored as payloads; in this case we must use PostingsEnum, +            posEnum = termsEnum.postings(posEnum, PostingsEnum.PAYLOADS);, +            assert posEnum != null; // terms has payloads, +            for (int d = posEnum.nextDoc(); d != DocIdSetIterator.NO_MORE_DOCS; d = posEnum.nextDoc()) {, +                if (liveDocs != null && liveDocs.get(d) == false) {, +                    continue;, +                }, +                posEnum.nextPosition();, +                final BytesRef payload = posEnum.getPayload();, +                if (payload != null && payload.length == 8) {, +                    // TODO: does this break the nested docs case?  we are not returning the last matching docID here?, +                    return new DocIdAndVersion(d, Numbers.bytesToLong(payload), context);, +                }, +++ b/core/src/main/java/org/elasticsearch/action/index/TransportIndexAction.java, +        SourceToParse sourceToParse = SourceToParse.source(SourceToParse.Origin.REPLICA, request.source()).index(shardId.getIndexName()).type(request.type()).id(request.id()), +        SourceToParse sourceToParse = SourceToParse.source(SourceToParse.Origin.PRIMARY, request.source()).index(request.index()).type(request.type()).id(request.id()), +++ b/core/src/main/java/org/elasticsearch/common/lucene/uid/PerThreadIDAndVersionLookup.java, +import org.elasticsearch.common.Numbers;, +    /** Only true when versions are indexed as payloads instead of docvalues */, +    private final boolean hasPayloads;, +    /** Only used for back compat, to lookup a version from payload */, +    private PostingsEnum posEnum;, +        boolean hasPayloads = false;, +                hasPayloads = terms.hasPayloads();, +        this.hasPayloads = hasPayloads;, +            if (versions != null || hasPayloads == false) {, +                // Use NDV to retrieve the version, in which case we only need PostingsEnum:, +, +                    if (versions != null) {, +                    } else {, +                        // _uid found, but no doc values and no payloads, +                        return new DocIdAndVersion(docID, Versions.NOT_SET, context);, +                    }, +                }, +            }, +, +            // ... but used to be stored as payloads; in this case we must use PostingsEnum, +            posEnum = termsEnum.postings(posEnum, PostingsEnum.PAYLOADS);, +            assert posEnum != null; // terms has payloads, +            for (int d = posEnum.nextDoc(); d != DocIdSetIterator.NO_MORE_DOCS; d = posEnum.nextDoc()) {, +                if (liveDocs != null && liveDocs.get(d) == false) {, +                    continue;, +                }, +                posEnum.nextPosition();, +                final BytesRef payload = posEnum.getPayload();, +                if (payload != null && payload.length == 8) {, +                    // TODO: does this break the nested docs case?  we are not returning the last matching docID here?, +                    return new DocIdAndVersion(d, Numbers.bytesToLong(payload), context);, +                }, +++ b/core/src/main/java/org/elasticsearch/common/lucene/uid/Versions.java, +    /**, +     * used when the document is old and doesn't contain any version information in the index, +     * see {@link PerThreadIDAndVersionLookup#lookup}, +     */, +    public static final long NOT_SET = -2L;, +     * <li>a doc ID and a version otherwise, the version being potentially set to {@link #NOT_SET} if the uid has no associated version, +     * <li>{@link #NOT_SET} if no version is available,, +++ b/core/src/main/java/org/elasticsearch/action/index/TransportIndexAction.java, +        SourceToParse sourceToParse = SourceToParse.source(SourceToParse.Origin.REPLICA, request.source()).index(shardId.getIndexName()).type(request.type()).id(request.id()), +        SourceToParse sourceToParse = SourceToParse.source(SourceToParse.Origin.PRIMARY, request.source()).index(request.index()).type(request.type()).id(request.id()), +++ b/core/src/main/java/org/elasticsearch/common/lucene/uid/PerThreadIDAndVersionLookup.java, +import org.elasticsearch.common.Numbers;, +    /** Only true when versions are indexed as payloads instead of docvalues */, +    private final boolean hasPayloads;, +    /** Only used for back compat, to lookup a version from payload */, +    private PostingsEnum posEnum;, +        boolean hasPayloads = false;, +                hasPayloads = terms.hasPayloads();, +        this.hasPayloads = hasPayloads;, +            if (versions != null || hasPayloads == false) {, +                // Use NDV to retrieve the version, in which case we only need PostingsEnum:, +, +                    if (versions != null) {, +                    } else {]