[+++ b/buildSrc/src/main/groovy/org/elasticsearch/gradle/AntTask.groovy, +        // otherwise groovy replaces System.out, and you have no chance to debug, +        // ant.saveStreams = false, +, +++ b/buildSrc/src/main/groovy/org/elasticsearch/gradle/AntTask.groovy, +        // otherwise groovy replaces System.out, and you have no chance to debug, +        // ant.saveStreams = false, +, +++ b/buildSrc/src/main/groovy/org/elasticsearch/gradle/precommit/ThirdPartyAuditTask.groovy, +package org.elasticsearch.gradle.precommit;, +import org.apache.tools.ant.BuildEvent;, +import org.apache.tools.ant.BuildException;, +import org.apache.tools.ant.BuildListener;, +import org.apache.tools.ant.BuildLogger;, +import org.apache.tools.ant.DefaultLogger;, +import org.apache.tools.ant.Project;, +import org.elasticsearch.gradle.AntTask;, +import org.gradle.api.artifacts.Configuration;, +import org.gradle.api.file.FileCollection;, +import java.nio.file.FileVisitResult;, +import java.nio.file.Files;, +import java.nio.file.Path;, +import java.nio.file.SimpleFileVisitor;, +import java.nio.file.attribute.BasicFileAttributes;, +import java.util.regex.Matcher;, +import java.util.regex.Pattern;, +        // we depend on this because its the only reliable configuration, +        // this probably makes the build slower: gradle you suck here when it comes to configurations, you pay the price., +        dependsOn(project.configurations.testCompile);, +        description = "Checks third party JAR bytecode for missing classes, use of internal APIs, and other horrors'";, +                throw new IllegalArgumentException("illegal third party audit exclusion: '" + s + "', wildcards are not permitted!");, +    // yes, we parse Uwe Schindler's errors to find missing classes, and to keep a continuous audit. Just don't let him know!, +    static final Pattern MISSING_CLASS_PATTERN =, +        Pattern.compile(/WARNING: The referenced class '(.*)' cannot be loaded\. Please fix the classpath\!/);, +        , +    static final Pattern VIOLATION_PATTERN = , +        Pattern.compile(/\s\sin ([a-zA-Z0-9\$\.]+) \(.*\)/);, +, +    // we log everything and capture errors and handle them with our whitelist, +    // this is important, as we detect stale whitelist entries, workaround forbidden apis bugs,, +    // and it also allows whitelisting missing classes!, +    static class EvilLogger extends DefaultLogger {, +        final Set<String> missingClasses = new TreeSet<>();, +        final Map<String,List<String>> violations = new TreeMap<>();, +        String previousLine = null;, +, +        @Override, +        public void messageLogged(BuildEvent event) {, +            if (event.getTask().getClass() == de.thetaphi.forbiddenapis.ant.AntTask.class) {, +                if (event.getPriority() == Project.MSG_WARN) {, +                    Matcher m = MISSING_CLASS_PATTERN.matcher(event.getMessage());, +                    if (m.matches()) {, +                        missingClasses.add(m.group(1).replace('.', '/') + ".class");, +                    }, +                } else if (event.getPriority() == Project.MSG_ERR) {, +                    Matcher m = VIOLATION_PATTERN.matcher(event.getMessage());, +                    if (m.matches()) {, +                        String violation = previousLine + '\n' + event.getMessage();, +                        String clazz = m.group(1).replace('.', '/') + ".class";, +                        List<String> current = violations.get(clazz);, +                        if (current == null) {, +                            current = new ArrayList<>();, +                            violations.put(clazz, current);, +                        }, +                        current.add(violation);, +                    }, +                    previousLine = event.getMessage();, +                }, +            }, +            super.messageLogged(event);, +        }, +    }, +, +        DefaultLogger log = new EvilLogger();, +        log.errorPrintStream = stream;, +        log.outputPrintStream = stream;, +        log.messageOutputLevel = outputLevel;, +        return log;, +        Configuration configuration = project.configurations.findByName('runtime');, +        if (configuration == null) {, +            // some projects apparently do not have 'runtime'? what a nice inconsistency,, +            // basically only serves to waste time in build logic!, +            configuration = project.configurations.findByName('testCompile');, +        }, +        assert configuration != null;, +        ant.project.addTaskDefinition('thirdPartyAudit', de.thetaphi.forbiddenapis.ant.AntTask);, +        FileCollection jars = configuration.fileCollection({ dependency ->, +        });, +        Configuration provided = project.configurations.findByName('provided');, +            jars -= provided;, +        Set<String> names = new TreeSet<>();, +            names.add(jar.getName());, +        File tmpDir = new File(project.buildDir, 'tmp/thirdPartyAudit');, +        ant.delete(dir: tmpDir.getAbsolutePath());, +        tmpDir.mkdirs();, +            ant.unzip(src: jar.getAbsolutePath(), dest: tmpDir.getAbsolutePath());, +            excludedFiles[i] = excludes[i].replace('.', '/') + ".class";, +        Set<String> excludedSet = new TreeSet<>(Arrays.asList(excludedFiles));, +        Set<String> sheistySet = getSheistyClasses(tmpDir.toPath());, +        try { ]