[+++ b/src/main/java/org/elasticsearch/index/engine/internal/InternalEngine.java, +import com.google.common.collect.Lists;, +, +import java.io.IOException;, +import java.util.*;, +import java.util.concurrent.CopyOnWriteArrayList;, +import java.util.concurrent.TimeUnit;, +import java.util.concurrent.atomic.AtomicBoolean;, +import java.util.concurrent.atomic.AtomicInteger;, +import java.util.concurrent.atomic.AtomicLong;, +import java.util.concurrent.locks.Condition;, +import java.util.concurrent.locks.Lock;, +import java.util.concurrent.locks.ReentrantLock;, +import java.util.concurrent.locks.ReentrantReadWriteLock;, +    /** return the current indexing buffer size setting * */, +    public ByteSizeValue indexingBufferSize() {, +        return indexingBufferSize;, +    }, +, +        public void lock() {, +        }, +++ b/src/main/java/org/elasticsearch/index/engine/internal/InternalEngine.java, +import com.google.common.collect.Lists;, +, +import java.io.IOException;, +import java.util.*;, +import java.util.concurrent.CopyOnWriteArrayList;, +import java.util.concurrent.TimeUnit;, +import java.util.concurrent.atomic.AtomicBoolean;, +import java.util.concurrent.atomic.AtomicInteger;, +import java.util.concurrent.atomic.AtomicLong;, +import java.util.concurrent.locks.Condition;, +import java.util.concurrent.locks.Lock;, +import java.util.concurrent.locks.ReentrantLock;, +import java.util.concurrent.locks.ReentrantReadWriteLock;, +    /** return the current indexing buffer size setting * */, +    public ByteSizeValue indexingBufferSize() {, +        return indexingBufferSize;, +    }, +, +        public void lock() {, +        }, +++ b/src/main/java/org/elasticsearch/indices/memory/IndexingMemoryController.java, +import org.elasticsearch.index.shard.IndexShardState;, +import java.util.EnumSet;, +    private final AtomicBoolean shardsRecoveredOrDeleted = new AtomicBoolean();, +    private static final EnumSet<IndexShardState> CAN_UPDATE_INDEX_BUFFER_STATES = EnumSet.of(IndexShardState.POST_RECOVERY, IndexShardState.STARTED, IndexShardState.RELOCATED);, +, +    /**, +     * returns the current budget for the total amount of indexing buffers of, +     * active shards on this node, +     */, +    public ByteSizeValue indexingBufferSize() {, +        return indexingBuffer;, +    }, +, +                boolean shardsRecoveredOrDeleted = IndexingMemoryController.this.shardsRecoveredOrDeleted.compareAndSet(true, false);, +                if (shardsRecoveredOrDeleted || activeInactiveStatusChanges) {, +                    calcAndSetShardBuffers("active/inactive[" + activeInactiveStatusChanges + "] recovered/deleted[" + shardsRecoveredOrDeleted + "]");, +        public void afterIndexShardPostRecovery(IndexShard indexShard) {, +                shardsRecoveredOrDeleted.set(true);, +                shardsRecoveredOrDeleted.set(true);, +        int shardsCount = countActiveShards();, +                IndexShardState state = indexShard.state();, +                if (!CAN_UPDATE_INDEX_BUFFER_STATES.contains(state)) {, +                    logger.trace("shard [{}] is not yet ready for index buffer update. index shard state: [{}]", indexShard.shardId(), state);, +                    continue;, +                }, +                        logger.warn("failed to set shard {} index buffer to [{}]", indexShard.shardId(), shardIndexingBufferSize);, +    private int countActiveShards() {, +++ b/src/main/java/org/elasticsearch/index/engine/internal/InternalEngine.java, +import com.google.common.collect.Lists;, +, +import java.io.IOException;, +import java.util.*;, +import java.util.concurrent.CopyOnWriteArrayList;, +import java.util.concurrent.TimeUnit;, +import java.util.concurrent.atomic.AtomicBoolean;, +import java.util.concurrent.atomic.AtomicInteger;, +import java.util.concurrent.atomic.AtomicLong;, +import java.util.concurrent.locks.Condition;, +import java.util.concurrent.locks.Lock;, +import java.util.concurrent.locks.ReentrantLock;, +import java.util.concurrent.locks.ReentrantReadWriteLock;, +    /** return the current indexing buffer size setting * */, +    public ByteSizeValue indexingBufferSize() {, +        return indexingBufferSize;, +    }, +, +        public void lock() {, +        }, +++ b/src/main/java/org/elasticsearch/indices/memory/IndexingMemoryController.java, +import org.elasticsearch.index.shard.IndexShardState;, +import java.util.EnumSet;, +    private final AtomicBoolean shardsRecoveredOrDeleted = new AtomicBoolean();, +    private static final EnumSet<IndexShardState> CAN_UPDATE_INDEX_BUFFER_STATES = EnumSet.of(IndexShardState.POST_RECOVERY, IndexShardState.STARTED, IndexShardState.RELOCATED);, +, +    /**, +     * returns the current budget for the total amount of indexing buffers of, +     * active shards on this node]