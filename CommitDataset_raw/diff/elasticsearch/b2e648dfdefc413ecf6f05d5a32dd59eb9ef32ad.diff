[+++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/Variables.java, +++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/Variables.java, +++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/antlr/Walker.java, +            return new SFor(location(ctx), settings.getMaxLoopCounter(), initializer, expression, afterthought, block);, +            return new SFor(location(ctx), settings.getMaxLoopCounter(), initializer, expression, afterthought, null);, +        if (settings.getMaxLoopCounter() > 0) {, +            reserved.usesLoop();, +        }, +, +        return new SEach(location(ctx), settings.getMaxLoopCounter(), type, name, expression, block);, +++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/Variables.java, +++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/antlr/Walker.java, +            return new SFor(location(ctx), settings.getMaxLoopCounter(), initializer, expression, afterthought, block);, +            return new SFor(location(ctx), settings.getMaxLoopCounter(), initializer, expression, afterthought, null);, +        if (settings.getMaxLoopCounter() > 0) {, +            reserved.usesLoop();, +        }, +, +        return new SEach(location(ctx), settings.getMaxLoopCounter(), type, name, expression, block);, +++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/LBrace.java, +        Sort sort = before.sort;, +++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/Variables.java, +++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/antlr/Walker.java, +            return new SFor(location(ctx), settings.getMaxLoopCounter(), initializer, expression, afterthought, block);, +            return new SFor(location(ctx), settings.getMaxLoopCounter(), initializer, expression, afterthought, null);, +        if (settings.getMaxLoopCounter() > 0) {, +            reserved.usesLoop();, +        }, +, +        return new SEach(location(ctx), settings.getMaxLoopCounter(), type, name, expression, block);, +++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/LBrace.java, +        Sort sort = before.sort;, +++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/SEach.java, +import org.elasticsearch.painless.AnalyzerCaster;, +import org.elasticsearch.painless.Definition;, +import org.elasticsearch.painless.Definition.Cast;, +import org.elasticsearch.painless.Definition.Method;, +import org.elasticsearch.painless.Definition.MethodKey;, +import org.elasticsearch.painless.Definition.Sort;, +import org.elasticsearch.painless.Definition.Type;, +import org.elasticsearch.painless.Variables.Variable;, +import org.objectweb.asm.Label;, +import org.objectweb.asm.Opcodes;, +, +    final int maxLoopCounter;, +    Variable variable = null;, +    Variable iterator = null;, +    Method method = null;, +    Method hasNext = null;, +    Method next = null;, +    Cast cast = null;, +, +    public SEach(final Location location, final int maxLoopCounter,, +                 final String type, final String name, final AExpression expression, final SBlock block) {, +        this.maxLoopCounter = maxLoopCounter;, +        expression.analyze(variables);, +        expression.expected = expression.actual;, +        expression = expression.cast(variables);, +, +        Sort sort = expression.actual.sort;, +, +        if (sort == Sort.ARRAY) {, +            throw location.createError(new UnsupportedOperationException("Cannot execute for each against array type."));, +        } else if (sort == Sort.DEF) {, +            throw location.createError(new UnsupportedOperationException("Cannot execute for each against def type."));, +        } else if (Iterable.class.isAssignableFrom(expression.actual.clazz)) {, +            final Type type;, +, +            try {, +                type = Definition.getType(this.type);, +            } catch (IllegalArgumentException exception) {, +                throw createError(new IllegalArgumentException("Not a type [" + this.type + "]."));, +            }, +, +            variables.incrementScope();, +, +            Type itr = Definition.getType("Iterator");, +, +            variable = variables.addVariable(location, type, name, false, false);, +            iterator = variables.addVariable(location, itr, "#itr" + location.getOffset(), true, false);, +, +            method = expression.actual.struct.methods.get(new MethodKey("iterator", 0));, +, +            if (method == null) {, +                throw location.createError(new IllegalArgumentException(, +                    "Unable to create iterator for the type [" + expression.actual.name + "]."));, +            }, +, +            hasNext = itr.struct.methods.get(new MethodKey("hasNext", 0));, +, +            if (hasNext == null) {, +                throw location.createError(new IllegalArgumentException("Method [hasNext] does not exist for type [Iterator]."));, +            } else if (hasNext.rtn.sort != Sort.BOOL) {, +                throw location.createError(new IllegalArgumentException("Method [hasNext] does not return type [boolean]."));, +            }, +, +            next = itr.struct.methods.get(new MethodKey("next", 0));, +, +            if (next == null) {, +                throw location.createError(new IllegalArgumentException("Method [next] does not exist for type [Iterator]."));]