[+++ b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/analysis/analyzer/Analyzer.java, +        return resolveAgainstList(u, attrList, false);, +    }, +, +    private static Attribute resolveAgainstList(UnresolvedAttribute u, Collection<Attribute> attrList, boolean allowCompound) {, +            return handleSpecialFields(u, matches.get(0), allowCompound);, +    private static Attribute handleSpecialFields(UnresolvedAttribute u, Attribute named, boolean allowCompound) {, +        // if it's a object/compound type, keep it unresolved with a nice error message, +        if (named instanceof FieldAttribute) {, +            FieldAttribute fa = (FieldAttribute) named;, +            // unsupported types, +            if (DataTypes.isUnsupported(fa.dataType())) {, +                UnsupportedEsField unsupportedField = (UnsupportedEsField) fa.field();, +                named = u.withUnresolvedMessage(, +                        "Cannot use field [" + fa.name() + "] type [" + unsupportedField.getOriginalType() + "] as is unsupported");, +            }, +            // compound fields, +            else if (allowCompound == false && fa.dataType().isPrimitive() == false) {, +                named = u.withUnresolvedMessage(, +                        "Cannot use field [" + fa.name() + "] type [" + fa.dataType().esType + "] only its subfields");, +            }, +        }, +        return named;, +    }, +, +                Attribute q = resolveAgainstList(us.qualifier(), output, true);, +                    return singletonList(us.qualifier());, +                // qualifier is unknown (e.g. unsupported type), bail out early, +                else if (q.resolved() == false) {, +                    return singletonList(q);, +                }, +, +++ b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/analysis/analyzer/Analyzer.java, +        return resolveAgainstList(u, attrList, false);, +    }, +, +    private static Attribute resolveAgainstList(UnresolvedAttribute u, Collection<Attribute> attrList, boolean allowCompound) {, +            return handleSpecialFields(u, matches.get(0), allowCompound);, +    private static Attribute handleSpecialFields(UnresolvedAttribute u, Attribute named, boolean allowCompound) {, +        // if it's a object/compound type, keep it unresolved with a nice error message, +        if (named instanceof FieldAttribute) {, +            FieldAttribute fa = (FieldAttribute) named;, +            // unsupported types, +            if (DataTypes.isUnsupported(fa.dataType())) {, +                UnsupportedEsField unsupportedField = (UnsupportedEsField) fa.field();, +                named = u.withUnresolvedMessage(, +                        "Cannot use field [" + fa.name() + "] type [" + unsupportedField.getOriginalType() + "] as is unsupported");, +            }, +            // compound fields, +            else if (allowCompound == false && fa.dataType().isPrimitive() == false) {, +                named = u.withUnresolvedMessage(, +                        "Cannot use field [" + fa.name() + "] type [" + fa.dataType().esType + "] only its subfields");, +            }, +        }, +        return named;, +    }, +, +                Attribute q = resolveAgainstList(us.qualifier(), output, true);, +                    return singletonList(us.qualifier());, +                // qualifier is unknown (e.g. unsupported type), bail out early, +                else if (q.resolved() == false) {, +                    return singletonList(q);, +                }, +, +++ b/x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/analysis/analyzer/VerifierErrorMessagesTests.java, +    private String error(String sql) {, +        return error(IndexResolution.valid(test), sql);, +    private String error(IndexResolution getIndexResult, String sql) {, +    private LogicalPlan accept(String sql) {, +        return accept(IndexResolution.valid(test), sql);, +    }, +, +    private LogicalPlan accept(IndexResolution resolution, String sql) {, +        Analyzer analyzer = new Analyzer(new FunctionRegistry(), resolution, TimeZone.getTimeZone("UTC"));, +        assertEquals("1:17: Unknown index [missing]", error(IndexResolution.notFound("missing"), "SELECT foo FROM missing"));, +        assertEquals("1:8: Unknown column [xxx]", error("SELECT xxx FROM test"));, +    }, +, +    public void testMissingColumnFilter() {, +        assertEquals("1:26: Unknown column [xxx]", error("SELECT * FROM test WHERE xxx > 1"));, +        assertEquals("1:8: Unknown column [xxx]", error("SELECT xxx.* FROM test"));, +        assertEquals("1:8: Unknown column [tex], did you mean [text]?", error("SELECT tex.* FROM test"));, +        assertEquals("1:8: Cannot determine columns for [text.*]", error("SELECT text.* FROM test"));, +                "line 1:25: Unknown column [tex], did you mean [text]?", error("SELECT bool, a, b.*, c, tex.* FROM test"));, +                "line 1:31: Unknown column [c]", error("SELECT tex.*, bool, a, dat.*, c FROM test"));, +                "line 1:29: Unknown column [da], did you mean [date]?" , error("SELECT ate.*, bool, keyw.*, da FROM test"));, +        assertEquals("1:8: Unknown column [txt], did you mean [text]?", error("SELECT txt FROM test"));, +        assertEquals("1:12: Unknown column [xxx]", error("SELECT ABS(xxx) FROM test"));, +    }, +, +    public void testFunctionOverMissingFieldInFilter() {, +        assertEquals("1:30: Unknown column [xxx]", error("SELECT * FROM test WHERE ABS(xxx) > 1"));, +        assertEquals("1:8: Unknown function [ZAZ]", error("SELECT ZAZ(bool) FROM test"));, +        assertEquals("1:8: Unknown function [COONT], did you mean any of [COUNT, COT, CONCAT]?", error("SELECT COONT(bool) FROM test"));, +        assertEquals("1:41: Unknown column [xxx]", error("SELECT * FROM test GROUP BY DAY_OF_YEAR(xxx)"));, +        assertEquals("1:26: Unknown column [xxx]", error("SELECT * FROM test WHERE xxx = 1"));, +        assertEquals("1:29: Unknown column [xxx]", error("SELECT * FROM test ORDER BY xxx"));, +        assertEquals("1:41: Unknown column [xxx]", error("SELECT * FROM test ORDER BY DAY_oF_YEAR(xxx)"));, +        assertEquals("1:8: Unknown datetime field [ZAZ]", error("SELECT EXTRACT(ZAZ FROM date) FROM test"));, +        assertEquals("1:8: Unknown datetime field [DAP], did you mean [DAY]?", error("SELECT EXTRACT(DAP FROM date) FROM test"));]