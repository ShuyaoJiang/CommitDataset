[+++ b/src/main/java/org/elasticsearch/index/mapper/DocumentMapper.java, +import org.elasticsearch.common.util.concurrent.ReleasableLock;, +    private final ReleasableLock mappingWriteLock;, +        this.documentParser = new DocumentParser(index, indexSettings, docMapperParser, this, new ReleasableLock(mappingLock.readLock()));, +        this.mappingWriteLock = new ReleasableLock(mappingLock.writeLock());, +        try (ReleasableLock lock = mappingWriteLock.acquire()) {, +    }, +        try (ReleasableLock lock = mappingWriteLock.acquire()) {, +++ b/src/main/java/org/elasticsearch/index/mapper/DocumentMapper.java, +import org.elasticsearch.common.util.concurrent.ReleasableLock;, +    private final ReleasableLock mappingWriteLock;, +        this.documentParser = new DocumentParser(index, indexSettings, docMapperParser, this, new ReleasableLock(mappingLock.readLock()));, +        this.mappingWriteLock = new ReleasableLock(mappingLock.writeLock());, +        try (ReleasableLock lock = mappingWriteLock.acquire()) {, +    }, +        try (ReleasableLock lock = mappingWriteLock.acquire()) {, +++ b/src/main/java/org/elasticsearch/index/mapper/DocumentParser.java, +import org.elasticsearch.common.util.concurrent.ReleasableLock;, +    private final ReleasableLock parseLock;, +    public DocumentParser(String index, Settings indexSettings, DocumentMapperParser docMapperParser, DocumentMapper docMapper, ReleasableLock parseLock) {, +        try (ReleasableLock lock = parseLock.acquire()){, +++ b/src/main/java/org/elasticsearch/index/mapper/DocumentMapper.java, +import org.elasticsearch.common.util.concurrent.ReleasableLock;, +    private final ReleasableLock mappingWriteLock;, +        this.documentParser = new DocumentParser(index, indexSettings, docMapperParser, this, new ReleasableLock(mappingLock.readLock()));, +        this.mappingWriteLock = new ReleasableLock(mappingLock.writeLock());, +        try (ReleasableLock lock = mappingWriteLock.acquire()) {, +    }, +        try (ReleasableLock lock = mappingWriteLock.acquire()) {, +++ b/src/main/java/org/elasticsearch/index/mapper/DocumentParser.java, +import org.elasticsearch.common.util.concurrent.ReleasableLock;, +    private final ReleasableLock parseLock;, +    public DocumentParser(String index, Settings indexSettings, DocumentMapperParser docMapperParser, DocumentMapper docMapper, ReleasableLock parseLock) {, +        try (ReleasableLock lock = parseLock.acquire()){, +++ b/src/main/java/org/elasticsearch/index/mapper/MapperService.java, +import org.elasticsearch.common.util.concurrent.ReleasableLock;, +    private final ReleasableLock mappingWriteLock = new ReleasableLock(mappingLock.writeLock());, +            try (ReleasableLock lock = mappingWriteLock.acquire()) {, +        try (ReleasableLock lock = mappingWriteLock.acquire()) {, +++ b/src/main/java/org/elasticsearch/index/mapper/DocumentMapper.java, +import org.elasticsearch.common.util.concurrent.ReleasableLock;, +    private final ReleasableLock mappingWriteLock;, +        this.documentParser = new DocumentParser(index, indexSettings, docMapperParser, this, new ReleasableLock(mappingLock.readLock()));, +        this.mappingWriteLock = new ReleasableLock(mappingLock.writeLock());, +        try (ReleasableLock lock = mappingWriteLock.acquire()) {, +    }, +        try (ReleasableLock lock = mappingWriteLock.acquire()) {, +++ b/src/main/java/org/elasticsearch/index/mapper/DocumentParser.java, +import org.elasticsearch.common.util.concurrent.ReleasableLock;, +    private final ReleasableLock parseLock;, +    public DocumentParser(String index, Settings indexSettings, DocumentMapperParser docMapperParser, DocumentMapper docMapper, ReleasableLock parseLock) {, +        try (ReleasableLock lock = parseLock.acquire()){, +++ b/src/main/java/org/elasticsearch/index/mapper/MapperService.java, +import org.elasticsearch.common.util.concurrent.ReleasableLock;, +    private final ReleasableLock mappingWriteLock = new ReleasableLock(mappingLock.writeLock());, +            try (ReleasableLock lock = mappingWriteLock.acquire()) {, +        try (ReleasableLock lock = mappingWriteLock.acquire()) {, +++ b/src/test/java/org/elasticsearch/index/mapper/merge/TestMergeMapperTests.java, +import org.elasticsearch.common.bytes.BytesArray;, +import org.elasticsearch.common.collect.Tuple;, +import org.elasticsearch.common.compress.CompressedString;, +import org.elasticsearch.index.analysis.FieldNameAnalyzer;, +import org.elasticsearch.index.mapper.*;, +import java.io.IOException;, +import java.util.ArrayList;, +import java.util.List;, +import java.util.concurrent.BrokenBarrierException;, +import java.util.concurrent.CyclicBarrier;, +import java.util.concurrent.atomic.AtomicBoolean;, +import java.util.concurrent.atomic.AtomicInteger;, +, +    public void testConcurrentMergeTest() throws IOException, BrokenBarrierException, InterruptedException {, +        final MapperService mapperService = createIndex("test").mapperService();, +        final AtomicInteger counter = new AtomicInteger(0);, +        Tuple<DocumentMapper, Mapping> docMapper = mapperService.documentMapperWithAutoCreate("test");, +        final DocumentMapper documentMapper = docMapper.v1();, +        int id = counter.incrementAndGet();, +        ParsedDocument doc = documentMapper.parse("test", Integer.toString(id), new BytesArray("{ \"test_field_" + id + "\" : \"test\" }"));, +        if (docMapper.v2() != null) {, +            doc.addDynamicMappingsUpdate(docMapper.v2());, +        }, +        Mapping mapping = doc.dynamicMappingsUpdate();, +        mapperService.merge("test", new CompressedString(mapping.toString()), false);, +        try {, +            int nextID = counter.get() + 1;, +            DocumentFieldMappers mappers = mapperService.documentMapper("test").mappers();, +            FieldMapper mapper = mappers.getMapper("test_field_" + nextID);, +            assertNull(mapper);, +            ((FieldNameAnalyzer)mappers.indexAnalyzer()).getWrappedAnalyzer("test_field_" + nextID);, +            fail("field not there yet");, +        } catch (IllegalArgumentException ex) {, +            assertEquals(ex.getMessage(), "Field [test_field_2] has no associated analyzer");, +        }, +        final AtomicBoolean stopped = new AtomicBoolean(false);, +        final CyclicBarrier barrier = new CyclicBarrier(2);, +        final Thread updater = new Thread() {, +            @Override, +            public void run() {, +                try {, +                    barrier.await();]