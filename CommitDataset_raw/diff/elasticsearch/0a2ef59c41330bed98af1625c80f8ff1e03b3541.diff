[+++ b/x-pack/plugin/watcher/src/main/java/org/elasticsearch/xpack/watcher/transport/actions/ack/TransportAckWatchAction.java, +import org.elasticsearch.xpack.core.watcher.transport.actions.stats.WatcherStatsAction;, +import org.elasticsearch.xpack.core.watcher.transport.actions.stats.WatcherStatsRequest;, +                                   Clock clock, XPackLicenseState licenseState, WatchParser parser,, +        WatcherStatsRequest watcherStatsRequest = new WatcherStatsRequest();, +        watcherStatsRequest.includeCurrentWatches(true);, +, +        executeAsyncWithOrigin(client, WATCHER_ORIGIN, WatcherStatsAction.INSTANCE, watcherStatsRequest, ActionListener.wrap(response -> {, +            boolean isWatchRunning = response.getNodes().stream(), +                .anyMatch(node -> node.getSnapshots().stream().anyMatch(snapshot -> snapshot.watchId().equals(request.getWatchId())));, +            } else {, +                    ActionListener.<GetResponse>wrap(getResponse -> {, +                        if (getResponse.isExists() == false) {, +                            Watch watch = parser.parseWithSecrets(request.getWatchId(), true, getResponse.getSourceAsBytesRef(),, +                            watch.version(getResponse.getVersion());, +                            watch.status().version(getResponse.getVersion());, +                            updateRequest.version(getResponse.getVersion());, +, +            }, +, +        }, listener::onFailure));, +++ b/x-pack/plugin/watcher/src/main/java/org/elasticsearch/xpack/watcher/transport/actions/ack/TransportAckWatchAction.java, +import org.elasticsearch.xpack.core.watcher.transport.actions.stats.WatcherStatsAction;, +import org.elasticsearch.xpack.core.watcher.transport.actions.stats.WatcherStatsRequest;, +                                   Clock clock, XPackLicenseState licenseState, WatchParser parser,, +        WatcherStatsRequest watcherStatsRequest = new WatcherStatsRequest();, +        watcherStatsRequest.includeCurrentWatches(true);, +, +        executeAsyncWithOrigin(client, WATCHER_ORIGIN, WatcherStatsAction.INSTANCE, watcherStatsRequest, ActionListener.wrap(response -> {, +            boolean isWatchRunning = response.getNodes().stream(), +                .anyMatch(node -> node.getSnapshots().stream().anyMatch(snapshot -> snapshot.watchId().equals(request.getWatchId())));, +            } else {, +                    ActionListener.<GetResponse>wrap(getResponse -> {, +                        if (getResponse.isExists() == false) {, +                            Watch watch = parser.parseWithSecrets(request.getWatchId(), true, getResponse.getSourceAsBytesRef(),, +                            watch.version(getResponse.getVersion());, +                            watch.status().version(getResponse.getVersion());, +                            updateRequest.version(getResponse.getVersion());, +, +            }, +, +        }, listener::onFailure));, +++ b/x-pack/plugin/watcher/src/test/java/org/elasticsearch/xpack/watcher/transport/actions/ack/TransportAckWatchActionTests.java, +import org.elasticsearch.Version;, +import org.elasticsearch.action.support.ContextPreservingActionListener;, +import org.elasticsearch.cluster.ClusterName;, +import org.elasticsearch.cluster.node.DiscoveryNode;, +import org.elasticsearch.xpack.core.watcher.WatcherMetaData;, +import org.elasticsearch.xpack.core.watcher.transport.actions.stats.WatcherStatsAction;, +import org.elasticsearch.xpack.core.watcher.transport.actions.stats.WatcherStatsResponse;, +import static org.mockito.Matchers.eq;, +            Clock.systemUTC(), new XPackLicenseState(Settings.EMPTY), watchParser, client);, +        doAnswer(invocation -> {, +            ContextPreservingActionListener listener = (ContextPreservingActionListener) invocation.getArguments()[2];, +            listener.onResponse(new WatcherStatsResponse(new ClusterName("clusterName"), new WatcherMetaData(false),, +                Collections.emptyList(), Collections.emptyList()));, +            return null;, +        }).when(client).execute(eq(WatcherStatsAction.INSTANCE), anyObject(), anyObject());, +, +, +        doAnswer(invocation -> {, +            ContextPreservingActionListener listener = (ContextPreservingActionListener) invocation.getArguments()[2];, +            DiscoveryNode discoveryNode = new DiscoveryNode("node_2", buildNewFakeTransportAddress(), Version.CURRENT);, +            WatcherStatsResponse.Node node = new WatcherStatsResponse.Node(discoveryNode);, +            node.setSnapshots(Collections.singletonList(snapshot));, +            listener.onResponse(new WatcherStatsResponse(new ClusterName("clusterName"),, +                new WatcherMetaData(false), Collections.singletonList(node), Collections.emptyList()));, +            return null;, +        }).when(client).execute(eq(WatcherStatsAction.INSTANCE), anyObject(), anyObject());]