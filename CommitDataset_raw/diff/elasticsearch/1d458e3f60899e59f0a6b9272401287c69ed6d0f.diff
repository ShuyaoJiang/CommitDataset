[+++ b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/literal/Intervals.java, +import org.elasticsearch.common.Strings;, +        private boolean optional = false;, +            tokens.add(new Token((char) 0, maxValue, optional));, +            tokens.add(new Token(ch, 0, optional));, +            return this;, +        }, +, +        ParserBuilder optional() {, +            optional = true;, +        private final boolean optional;, +        Token(char ch, int maxValue, boolean optional) {, +            this.optional = optional;, +            return ch > 0 ? String.valueOf(ch) : "[numeric]";, +                if (startToken >= string.length()) {, +                    // consumed the string, bail out, +                    if (token.optional) {, +                        break;, +                    }, +                    throw new ParsingException(source, invalidIntervalMessage(string) + ": incorrect format, expecting {}",, +                            Strings.collectionToDelimitedString(tokens, ""));, +                }, +                , +                 .optional(), +                 .separator(DOT).unit(TimeUnit.MILLISECOND, MAX_MILLI), +                .optional(), +                .optional(), +                .optional(), +                .separator(DOT).unit(TimeUnit.MILLISECOND, MAX_MILLI), +++ b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/literal/Intervals.java, +import org.elasticsearch.common.Strings;, +        private boolean optional = false;, +            tokens.add(new Token((char) 0, maxValue, optional));, +            tokens.add(new Token(ch, 0, optional));, +            return this;, +        }, +, +        ParserBuilder optional() {, +            optional = true;, +        private final boolean optional;, +        Token(char ch, int maxValue, boolean optional) {, +            this.optional = optional;, +            return ch > 0 ? String.valueOf(ch) : "[numeric]";, +                if (startToken >= string.length()) {, +                    // consumed the string, bail out, +                    if (token.optional) {, +                        break;, +                    }, +                    throw new ParsingException(source, invalidIntervalMessage(string) + ": incorrect format, expecting {}",, +                            Strings.collectionToDelimitedString(tokens, ""));, +                }, +                , +                 .optional(), +                 .separator(DOT).unit(TimeUnit.MILLISECOND, MAX_MILLI), +                .optional(), +                .optional(), +                .optional(), +                .separator(DOT).unit(TimeUnit.MILLISECOND, MAX_MILLI), +++ b/x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/literal/IntervalsTests.java, +    public void testSecondNoMillisInterval() throws Exception {, +        int randomSeconds = randomNonNegativeInt();, +        String value = format(Locale.ROOT, "%s%d", sign, randomSeconds);, +        TemporalAmount amount = parseInterval(EMPTY, value, INTERVAL_SECOND);, +        assertEquals(maybeNegate(sign, Duration.ofSeconds(randomSeconds)), amount);, +    }, +, +        boolean withMillis = randomBoolean();, +        int randomMilli = withMillis ? randomInt(999999999) : 0;, +        String millisString = withMillis ? "." + randomMilli : "";, +, +        String value = format(Locale.ROOT, "%s%d %d:%d:%d%s", sign, randomDay, randomHour, randomMinute, randomSecond, millisString);, +        boolean withMillis = randomBoolean();, +        int randomMilli = withMillis ? randomInt(999999999) : 0;, +        String millisString = withMillis ? "." + randomMilli : "";, +, +        String value = format(Locale.ROOT, "%s%d:%d:%d%s", sign, randomHour, randomMinute, randomSecond, millisString);, +        boolean withMillis = randomBoolean();, +        int randomMilli = withMillis ? randomInt(999999999) : 0;, +        String millisString = withMillis ? "." + randomMilli : "";, +, +        String value = format(Locale.ROOT, "%s%d:%d%s", sign, randomMinute, randomSecond, millisString);, +    public void testIncompleteYearToMonthInterval() throws Exception {, +        String value = "123-";, +        ParsingException pe = expectThrows(ParsingException.class, () -> parseInterval(EMPTY, value, INTERVAL_YEAR_TO_MONTH));, +        assertEquals("line -1:0: Invalid [INTERVAL YEAR TO MONTH] value [123-]: incorrect format, expecting [numeric]-[numeric]",, +                pe.getMessage());, +    }, +, +    public void testIncompleteDayToHourInterval() throws Exception {, +        String value = "123 23:";, +        ParsingException pe = expectThrows(ParsingException.class, () -> parseInterval(EMPTY, value, INTERVAL_DAY_TO_HOUR));, +        assertEquals("line -1:0: Invalid [INTERVAL DAY TO HOUR] value [123 23:]: unexpected trailing characters found [:]",, +                pe.getMessage());, +    }, +]