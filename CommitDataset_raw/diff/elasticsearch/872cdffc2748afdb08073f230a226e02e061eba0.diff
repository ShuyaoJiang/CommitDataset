[+++ b/core/src/main/java/org/elasticsearch/common/bytes/BytesArray.java, +++ b/core/src/main/java/org/elasticsearch/common/bytes/BytesArray.java, +++ b/core/src/main/java/org/elasticsearch/common/bytes/BytesReference.java, +import org.apache.lucene.util.BytesRefIterator;, +    class Helper {, +, +    /**, +     * Returns a BytesRefIterator for this BytesReference. This method allows, +     * access to the internal pages of this reference without copying them. Use with care!, +     * @see BytesRefIterator, +     */, +    default BytesRefIterator iterator() {, +        return new BytesRefIterator() {, +            BytesRef ref = toBytesRef();, +            @Override, +            public BytesRef next() throws IOException {, +                BytesRef r = ref;, +                ref = null; // only return it once..., +                return r;, +            }, +        };, +    }, +, +++ b/core/src/main/java/org/elasticsearch/common/bytes/BytesArray.java, +++ b/core/src/main/java/org/elasticsearch/common/bytes/BytesReference.java, +import org.apache.lucene.util.BytesRefIterator;, +    class Helper {, +, +    /**, +     * Returns a BytesRefIterator for this BytesReference. This method allows, +     * access to the internal pages of this reference without copying them. Use with care!, +     * @see BytesRefIterator, +     */, +    default BytesRefIterator iterator() {, +        return new BytesRefIterator() {, +            BytesRef ref = toBytesRef();, +            @Override, +            public BytesRef next() throws IOException {, +                BytesRef r = ref;, +                ref = null; // only return it once..., +                return r;, +            }, +        };, +    }, +, +++ /dev/null, +++ b/core/src/main/java/org/elasticsearch/common/bytes/BytesArray.java, +++ b/core/src/main/java/org/elasticsearch/common/bytes/BytesReference.java, +import org.apache.lucene.util.BytesRefIterator;, +    class Helper {, +, +    /**, +     * Returns a BytesRefIterator for this BytesReference. This method allows, +     * access to the internal pages of this reference without copying them. Use with care!, +     * @see BytesRefIterator, +     */, +    default BytesRefIterator iterator() {, +        return new BytesRefIterator() {, +            BytesRef ref = toBytesRef();, +            @Override, +            public BytesRef next() throws IOException {, +                BytesRef r = ref;, +                ref = null; // only return it once..., +                return r;, +            }, +        };, +    }, +, +++ /dev/null, +++ b/core/src/main/java/org/elasticsearch/common/bytes/PagedBytesReference.java, +import org.apache.lucene.util.BytesRefIterator;, +, +    @Override, +    public final BytesRefIterator iterator() {, +        final int offset = this.offset;, +        final int length = this.length;, +        // this iteration is page aligned to ensure we do NOT materialize the pages from the ByteArray, +        // we calculate the initial fragment size here to ensure that if this reference is a slice we are still page aligned, +        // across the entire iteration. The first page is smaller if our offset != 0 then we start in the middle of the page, +        // otherwise we iterate full pages until we reach the last chunk which also might end within a page., +        final int initialFragmentSize = offset != 0 ? PAGE_SIZE - (offset % PAGE_SIZE) : PAGE_SIZE;, +        return new BytesRefIterator() {, +            int position = 0;, +            int nextFragmentSize = Math.min(length, initialFragmentSize);, +            // this BytesRef is reused across the iteration on purpose - BytesRefIterator interface was designed for this, +            final BytesRef slice = new BytesRef();, +, +            @Override, +            public BytesRef next() throws IOException {, +                if (nextFragmentSize != 0) {, +                    final boolean materialized = bytearray.get(offset + position, nextFragmentSize, slice);, +                    assert materialized == false : "iteration should be page aligned but array got materialized";, +                    position += nextFragmentSize;, +                    final int remaining = length - position;, +                    nextFragmentSize = Math.min(remaining, PAGE_SIZE);, +                    return slice;, +                } else {, +                    assert nextFragmentSize == 0 : "fragmentSize expected [0] but was: [" + nextFragmentSize + "]";, +                    return null; // we are done with this iteration, +                }]