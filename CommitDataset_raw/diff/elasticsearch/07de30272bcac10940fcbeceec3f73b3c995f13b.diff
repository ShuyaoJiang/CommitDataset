[+++ b/core/src/main/java/org/elasticsearch/common/collect/CopyOnWriteHashSet.java, +                p -> new AbstractMap.SimpleImmutableEntry<T, Boolean>(p, true), +++ b/core/src/main/java/org/elasticsearch/common/collect/CopyOnWriteHashSet.java, +                p -> new AbstractMap.SimpleImmutableEntry<T, Boolean>(p, true), +++ b/core/src/main/resources/org/elasticsearch/bootstrap/security.policy, +, +  // needed for top threads handling, +  permission java.lang.RuntimePermission "modifyThreadGroup";, +, +  // needed for stream redirection, +  permission java.lang.RuntimePermission "setIO";, +  // needed by ES threadpool termination... clean this up, +  // otherwise can be provided only to test libraries, +  // likely not low hanging fruit..., +, +  // needed by HotThreads and potentially more, +  // otherwise can be provided only to test libraries, +  // needed by ESTestCase for leniency of thread exceptions (?!), +  // otherwise can be provided only to test libraries, +  // needed for jimfs and NewPathForShardsTests, +  // otherwise can be provided only to test libraries, +++ b/core/src/main/java/org/elasticsearch/common/collect/CopyOnWriteHashSet.java, +                p -> new AbstractMap.SimpleImmutableEntry<T, Boolean>(p, true), +++ b/core/src/main/resources/org/elasticsearch/bootstrap/security.policy, +, +  // needed for top threads handling, +  permission java.lang.RuntimePermission "modifyThreadGroup";, +, +  // needed for stream redirection, +  permission java.lang.RuntimePermission "setIO";, +  // needed by ES threadpool termination... clean this up, +  // otherwise can be provided only to test libraries, +  // likely not low hanging fruit..., +, +  // needed by HotThreads and potentially more, +  // otherwise can be provided only to test libraries, +  // needed by ESTestCase for leniency of thread exceptions (?!), +  // otherwise can be provided only to test libraries, +  // needed for jimfs and NewPathForShardsTests, +  // otherwise can be provided only to test libraries, +++ b/core/src/test/java/org/elasticsearch/bootstrap/BootstrapForTesting.java, +import java.security.CodeSource;, +import java.security.Permission;, +import java.security.PermissionCollection;, +import java.security.cert.Certificate;, +import java.util.Collections;, +                // initialize paths the same exact way as bootstrap, +, +                // if its an insecure plugin, its not easy to simulate here, since we don't have a real plugin install., +                // we just do our best so unit testing can work. integration tests for such plugins are essential., +                String artifact = System.getProperty("tests.artifact");, +                String insecurePluginProp = Security.INSECURE_PLUGINS.get(artifact);, +                if (insecurePluginProp != null) {, +                    setInsecurePluginPermissions(perms, insecurePluginProp);, +                }, +    /**, +     * with a real plugin install, we just set a property to plugin/foo*, which matches, +     * plugin code and all dependencies. when running unit tests, things are disorganized,, +     * and might even be on different filesystem roots (windows), so we can't even make, +     * a URL that will match everything. instead, add the extra permissions globally., +     */, +    // TODO: maybe wrap with a policy so the extra permissions aren't applied to test classes/framework,, +    // so that stacks are always polluted and tests fail for missing AccessController blocks..., +    static void setInsecurePluginPermissions(Permissions permissions, String insecurePluginProp) throws Exception {, +        // the hack begins!, +        , +        // parse whole policy file, with and without the substitution, compute the delta, then add globally., +        URL bogus = new URL("file:/bogus");, +        ESPolicy policy = new ESPolicy(new Permissions());, +        PermissionCollection small = policy.template.getPermissions(new CodeSource(bogus, (Certificate[])null));, +        System.setProperty(insecurePluginProp, bogus.toString());, +        policy = new ESPolicy(new Permissions());, +        System.clearProperty(insecurePluginProp);, +        PermissionCollection big = policy.template.getPermissions(new CodeSource(bogus, (Certificate[])null));, +        , +        PermissionCollection delta = delta(small, big);, +        for (Permission p : Collections.list(delta.elements())) {, +            permissions.add(p);, +        }, +    }, +    , +    // computes delta of small and big, the slow way, +    static PermissionCollection delta(PermissionCollection small, PermissionCollection big) {, +        Permissions extra = new Permissions();, +        for (Permission p : Collections.list(big.elements())) {, +            // check big too, to remove UnresolvedPermissions (acts like NaN), +            if (big.implies(p) && small.implies(p) == false) {, +                extra.add(p);, +            }, +        }, +        return extra;, +    }, +, +++ b/core/src/main/java/org/elasticsearch/common/collect/CopyOnWriteHashSet.java, +                p -> new AbstractMap.SimpleImmutableEntry<T, Boolean>(p, true), +++ b/core/src/main/resources/org/elasticsearch/bootstrap/security.policy, +, +  // needed for top threads handling, +  permission java.lang.RuntimePermission "modifyThreadGroup";, +]