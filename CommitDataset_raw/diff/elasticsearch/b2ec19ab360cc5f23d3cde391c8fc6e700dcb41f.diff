[+++ b/src/main/java/org/elasticsearch/action/admin/indices/create/CreateIndexRequest.java, +import static org.elasticsearch.common.settings.ImmutableSettings.Builder.EMPTY_SETTINGS;, +++ b/src/main/java/org/elasticsearch/action/admin/indices/create/CreateIndexRequest.java, +import static org.elasticsearch.common.settings.ImmutableSettings.Builder.EMPTY_SETTINGS;, +++ b/src/main/java/org/elasticsearch/cluster/metadata/IndexMetaData.java, +    public static final String SETTING_DATA_PATH = "index.data_path";, +++ b/src/main/java/org/elasticsearch/action/admin/indices/create/CreateIndexRequest.java, +import static org.elasticsearch.common.settings.ImmutableSettings.Builder.EMPTY_SETTINGS;, +++ b/src/main/java/org/elasticsearch/cluster/metadata/IndexMetaData.java, +    public static final String SETTING_DATA_PATH = "index.data_path";, +++ b/src/main/java/org/elasticsearch/cluster/metadata/MetaDataCreateIndexService.java, +import org.elasticsearch.ElasticsearchIllegalArgumentException;, +import org.elasticsearch.env.NodeEnvironment;, +import org.elasticsearch.indices.IndexCreationException;, +    private final NodeEnvironment nodeEnv;, +    public MetaDataCreateIndexService(Settings settings, Environment environment, ThreadPool threadPool, ClusterService clusterService,, +                                      IndicesService indicesService, AllocationService allocationService, MetaDataService metaDataService,, +                                      Version version, @RiverIndexName String riverIndexName, AliasValidator aliasValidator,, +                                      Set<IndexTemplateFilter> indexTemplateFilters, NodeEnvironment nodeEnv) {, +        this.nodeEnv = nodeEnv;, +        String customPath = request.settings().get(IndexMetaData.SETTING_DATA_PATH, null);, +        if (customPath != null && nodeEnv.isCustomPathsEnabled() == false) {, +            throw new IndexCreationException(new Index(request.index()),, +                    new ElasticsearchIllegalArgumentException("custom data_paths for indices is disabled"));, +        }, +++ b/src/main/java/org/elasticsearch/action/admin/indices/create/CreateIndexRequest.java, +import static org.elasticsearch.common.settings.ImmutableSettings.Builder.EMPTY_SETTINGS;, +++ b/src/main/java/org/elasticsearch/cluster/metadata/IndexMetaData.java, +    public static final String SETTING_DATA_PATH = "index.data_path";, +++ b/src/main/java/org/elasticsearch/cluster/metadata/MetaDataCreateIndexService.java, +import org.elasticsearch.ElasticsearchIllegalArgumentException;, +import org.elasticsearch.env.NodeEnvironment;, +import org.elasticsearch.indices.IndexCreationException;, +    private final NodeEnvironment nodeEnv;, +    public MetaDataCreateIndexService(Settings settings, Environment environment, ThreadPool threadPool, ClusterService clusterService,, +                                      IndicesService indicesService, AllocationService allocationService, MetaDataService metaDataService,, +                                      Version version, @RiverIndexName String riverIndexName, AliasValidator aliasValidator,, +                                      Set<IndexTemplateFilter> indexTemplateFilters, NodeEnvironment nodeEnv) {, +        this.nodeEnv = nodeEnv;, +        String customPath = request.settings().get(IndexMetaData.SETTING_DATA_PATH, null);, +        if (customPath != null && nodeEnv.isCustomPathsEnabled() == false) {, +            throw new IndexCreationException(new Index(request.index()),, +                    new ElasticsearchIllegalArgumentException("custom data_paths for indices is disabled"));, +        }, +++ b/src/main/java/org/elasticsearch/env/NodeEnvironment.java, +import org.apache.lucene.store.*;, +import org.elasticsearch.ElasticsearchIllegalArgumentException;, +import org.elasticsearch.cluster.metadata.IndexMetaData;, +import org.elasticsearch.index.settings.IndexSettings;, +import java.util.concurrent.Semaphore;, +import java.util.concurrent.TimeUnit;, +    private final boolean addNodeId;, +    private final boolean customPathsEnabled;, +, +    public static final String ADD_NODE_ID_TO_CUSTOM_PATH = "node.add_id_to_custom_path";, +    public static final String SETTING_CUSTOM_DATA_PATH_ENABLED = "node.enable_custom_paths";, +, +        addNodeId = settings.getAsBoolean(ADD_NODE_ID_TO_CUSTOM_PATH, true);, +        this.customPathsEnabled = settings.getAsBoolean(SETTING_CUSTOM_DATA_PATH_ENABLED, false);, +, +    public void deleteShardDirectorySafe(ShardId shardId, @IndexSettings Settings indexSettings) throws IOException {, +        final Path[] paths = shardPaths(shardId, indexSettings);, +    public void deleteIndexDirectorySafe(Index index, @IndexSettings Settings indexSettings) throws IOException {, +        // This is to ensure someone doesn't use ImmutableSettings.EMPTY, +        assert indexSettings.get(IndexMetaData.SETTING_NUMBER_OF_SHARDS) != null : "real index settings with a shard number must be used";, +            final Path[] indexPaths = indexPaths(index, indexSettings);, +     * Returns all data paths including custom index paths, +    public Path[] indexPaths(Index index, @IndexSettings Settings indexSettings) {, +        if (hasCustomDataPath(indexSettings)) {, +            Path[] allPaths = new Path[nodeIndicesPaths.length + 1];, +            for (int i = 0; i < nodeIndicesPaths.length; i++) {, +                allPaths[i] = nodeIndicesPaths[i].resolve(index.name());, +            }, +            if (addNodeId) {, +                allPaths[nodeIndicesPaths.length] = Paths.get(indexSettings.get(IndexMetaData.SETTING_DATA_PATH),, +                        Integer.toString(this.localNodeId));, +            } else {, +                allPaths[nodeIndicesPaths.length] = Paths.get(indexSettings.get(IndexMetaData.SETTING_DATA_PATH));, +            }, +            return allPaths;, +        } else {, +    }, +     * Returns all paths where lucene data will be stored, +    public Path[] shardDataPaths(ShardId shardId, @IndexSettings Settings indexSettings) {, +        if (hasCustomDataPath(indexSettings)) {, +            return new Path[] {resolveCustomLocation(indexSettings, shardId)};, +        } else {, +    }, +, +    /**, +     * Returns all shard paths including custom shard path, +     */, +    public Path[] shardPaths(ShardId shardId, @IndexSettings Settings indexSettings) {, +        assert assertEnvIsLocked();, +        final Path[] nodePaths = nodeDataPaths();, +        int size = hasCustomDataPath(indexSettings) ? nodePaths.length + 1 : nodePaths.length;, +        final Path[] shardLocations = new Path[size];, +        for (int i = 0; i < nodePaths.length; i++) {, +            shardLocations[i] = nodePaths[i].resolve(Paths.get("indices", shardId.index().name(), Integer.toString(shardId.id())));, +        }]