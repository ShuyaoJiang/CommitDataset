[+++ b/plugin/src/main/java/org/elasticsearch/xpack/ml/job/persistence/JobStorageDeletionTask.java, +import com.carrotsearch.hppc.cursors.ObjectObjectCursor;, +import org.elasticsearch.cluster.metadata.AliasMetaData;, +                            // remove the aliases from the concrete indices found in the first step, +                            IndicesAliasesRequest removeRequest = buildRemoveAliasesRequest(getAliasesResponse);, +                            if (removeRequest == null) {, +, +    private IndicesAliasesRequest buildRemoveAliasesRequest(GetAliasesResponse getAliasesResponse) {, +        Set<String> aliases = new HashSet<>();, +        List<String> indices = new ArrayList<>();, +        for (ObjectObjectCursor<String, List<AliasMetaData>> entry : getAliasesResponse.getAliases()) {, +            // The response includes _all_ indices, but only those associated with, +            // the aliases we asked about will have associated AliasMetaData, +            if (entry.value.isEmpty() == false) {, +                indices.add(entry.key);, +                entry.value.forEach(metadata -> aliases.add(metadata.getAlias()));, +            }, +        }, +        return aliases.isEmpty() ? null : new IndicesAliasesRequest().addAliasAction(, +                IndicesAliasesRequest.AliasActions.remove(), +                        .aliases(aliases.toArray(new String[aliases.size()])), +                        .indices(indices.toArray(new String[indices.size()])));, +    }, +++ b/plugin/src/main/java/org/elasticsearch/xpack/ml/job/persistence/JobStorageDeletionTask.java, +import com.carrotsearch.hppc.cursors.ObjectObjectCursor;, +import org.elasticsearch.cluster.metadata.AliasMetaData;, +                            // remove the aliases from the concrete indices found in the first step, +                            IndicesAliasesRequest removeRequest = buildRemoveAliasesRequest(getAliasesResponse);, +                            if (removeRequest == null) {, +, +    private IndicesAliasesRequest buildRemoveAliasesRequest(GetAliasesResponse getAliasesResponse) {, +        Set<String> aliases = new HashSet<>();, +        List<String> indices = new ArrayList<>();, +        for (ObjectObjectCursor<String, List<AliasMetaData>> entry : getAliasesResponse.getAliases()) {, +            // The response includes _all_ indices, but only those associated with, +            // the aliases we asked about will have associated AliasMetaData, +            if (entry.value.isEmpty() == false) {, +                indices.add(entry.key);, +                entry.value.forEach(metadata -> aliases.add(metadata.getAlias()));, +            }, +        }, +        return aliases.isEmpty() ? null : new IndicesAliasesRequest().addAliasAction(, +                IndicesAliasesRequest.AliasActions.remove(), +                        .aliases(aliases.toArray(new String[aliases.size()])), +                        .indices(indices.toArray(new String[indices.size()])));, +    }, +++ b/plugin/src/test/java/org/elasticsearch/xpack/ml/integration/JobStorageDeletionTaskIT.java, +/*, + * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one, + * or more contributor license agreements. Licensed under the Elastic License;, + * you may not use this file except in compliance with the Elastic License., + */, +package org.elasticsearch.xpack.ml.integration;, +, +import org.elasticsearch.cluster.metadata.IndexMetaData;, +import org.elasticsearch.common.unit.ByteSizeUnit;, +import org.elasticsearch.common.unit.ByteSizeValue;, +import org.elasticsearch.xpack.ml.action.DeleteJobAction;, +import org.elasticsearch.xpack.ml.action.OpenJobAction;, +import org.elasticsearch.xpack.ml.action.PutJobAction;, +import org.elasticsearch.xpack.ml.job.config.Job;, +import org.elasticsearch.xpack.ml.support.BaseMlIntegTestCase;, +, +/**, + * Test that ML does not touch unnecessary indices when removing job index aliases, + */, +public class JobStorageDeletionTaskIT extends BaseMlIntegTestCase {, +, +    private static final String UNRELATED_INDEX = "unrelated-data";, +, +    public void testUnrelatedIndexNotTouched() throws Exception {, +        internalCluster().ensureAtLeastNumDataNodes(1);, +        ensureStableCluster(1);, +, +        client().admin().indices().prepareCreate(UNRELATED_INDEX).get();, +, +        enableIndexBlock(UNRELATED_INDEX, IndexMetaData.SETTING_READ_ONLY);, +, +        Job.Builder job = createJob("delete-aliases-test-job", new ByteSizeValue(2, ByteSizeUnit.MB));, +        PutJobAction.Request putJobRequest = new PutJobAction.Request(job);, +        PutJobAction.Response putJobResponse = client().execute(PutJobAction.INSTANCE, putJobRequest).actionGet();, +        assertTrue(putJobResponse.isAcknowledged());, +, +        OpenJobAction.Request openJobRequest = new OpenJobAction.Request(job.getId());, +        client().execute(OpenJobAction.INSTANCE, openJobRequest).actionGet();, +        awaitJobOpenedAndAssigned(job.getId(), null);, +, +        DeleteJobAction.Request deleteJobRequest = new DeleteJobAction.Request(job.getId());, +        deleteJobRequest.setForce(true);, +        client().execute(DeleteJobAction.INSTANCE, deleteJobRequest).actionGet();, +, +        // If the deletion of aliases touches the unrelated index with the block, +        // then the line above will throw a ClusterBlockException, +, +        disableIndexBlock(UNRELATED_INDEX, IndexMetaData.SETTING_READ_ONLY);, +    }, +}]