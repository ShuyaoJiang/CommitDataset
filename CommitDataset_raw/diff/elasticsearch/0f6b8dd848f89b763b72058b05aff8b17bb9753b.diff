[+++ b/core/src/main/java/org/elasticsearch/action/fieldstats/FieldStats.java, +import org.elasticsearch.index.mapper.ip.IpFieldMapper;, +import org.joda.time.DateTime;, +     * @param value, +     *            The value to be converted to a String, +     * @param optionalFormat, +     *            A string describing how to print the specified value. Whether, +     *            this parameter is supported depends on the implementation. If, +     *            optionalFormat is specified and the implementation doesn't, +     *            support it an {@link UnsupportedOperationException} is thrown, +     */, +    public abstract String stringValueOf(Object value, String optionalFormat);, +, +    /**, +        public String stringValueOf(Object value, String optionalFormat) {, +            if (optionalFormat != null) {, +                throw new UnsupportedOperationException("custom format isn't supported");, +            }, +            if (value instanceof Number) {, +                return java.lang.Long.toString(((Number) value).longValue());, +            } else {, +                throw new IllegalArgumentException("value must be a Long: " + value);, +            }, +        }, +, +        @Override, +        public String stringValueOf(Object value, String optionalFormat) {, +            if (optionalFormat != null) {, +                throw new UnsupportedOperationException("custom format isn't supported");, +            }, +            if (value instanceof Number) {, +                return java.lang.Float.toString(((Number) value).floatValue());, +            } else {, +                throw new IllegalArgumentException("value must be a Float: " + value);, +            }, +        }, +, +        @Override, +        public String stringValueOf(Object value, String optionalFormat) {, +            if (optionalFormat != null) {, +                throw new UnsupportedOperationException("custom format isn't supported");, +            }, +            if (value instanceof Number) {, +                return java.lang.Double.toString(((Number) value).doubleValue());, +            } else {, +                throw new IllegalArgumentException("value must be a Double: " + value);, +            }, +        }, +, +        @Override, +        public String stringValueOf(Object value, String optionalFormat) {, +            if (optionalFormat != null) {, +                throw new UnsupportedOperationException("custom format isn't supported");, +            }, +            if (value instanceof BytesRef) {, +                return ((BytesRef) value).utf8ToString();, +            } else {, +                throw new IllegalArgumentException("value must be a BytesRef: " + value);, +            }, +        }, +, +        @Override, +        public String stringValueOf(Object value, String optionalFormat) {, +            FormatDateTimeFormatter dateFormatter = this.dateFormatter;, +            if (optionalFormat != null) {, +                dateFormatter = Joda.forPattern(optionalFormat);, +            }, +            long millis;, +            if (value instanceof java.lang.Long) {, +                millis = ((java.lang.Long) value).longValue();, +            } else if (value instanceof DateTime) {, +                millis = ((DateTime) value).getMillis();, +            } else if (value instanceof BytesRef) {, +                millis = dateFormatter.parser().parseMillis(((BytesRef) value).utf8ToString());, +            } else {, +                throw new IllegalArgumentException("value must be either a DateTime or a long: " + value);, +            }, +            return dateFormatter.printer().print(millis);, +        }, +, +        @Override, +    public static class Ip extends Long {, +, +        public Ip(int maxDoc, int docCount, long sumDocFreq, long sumTotalTermFreq, long minValue, long maxValue) {, +            super(maxDoc, docCount, sumDocFreq, sumTotalTermFreq, minValue, maxValue);, +        }, +, +        protected Ip(int type, long maxDoc, long docCount, long sumDocFreq, long sumTotalTermFreq, long minValue, long maxValue) {, +            super(type, maxDoc, docCount, sumDocFreq, sumTotalTermFreq, minValue, maxValue);, +        }, +, +        public Ip() {, +        }, +, +        @Override, +        public String stringValueOf(Object value, String optionalFormat) {, +            if (value instanceof BytesRef) {, +                return super.stringValueOf(IpFieldMapper.ipToLong(((BytesRef) value).utf8ToString()), optionalFormat);, +            }, +            return super.stringValueOf(value, optionalFormat);]