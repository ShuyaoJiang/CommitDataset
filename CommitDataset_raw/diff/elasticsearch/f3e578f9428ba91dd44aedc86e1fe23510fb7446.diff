[+++ b/core/src/test/java/org/elasticsearch/discovery/DiscoveryWithServiceDisruptionsIT.java, +    private boolean disableBeforeIndexDeletion;, +, +    @Override, +    public void setDisruptionScheme(ServiceDisruptionScheme scheme) {, +        if (scheme instanceof NetworkDisruption &&, +            ((NetworkDisruption) scheme).getNetworkLinkDisruptionType() instanceof NetworkUnresponsive) {, +            // the network unresponsive disruption may leave operations in flight, +            // this is because this disruption scheme swallows requests by design, +            // as such, these operations will never be marked as finished, +            disableBeforeIndexDeletion = true;, +        }, +        super.setDisruptionScheme(scheme);, +    }, +, +        if (disableBeforeIndexDeletion == false) {, +            super.beforeIndexDeletion();, +        }, +++ b/core/src/test/java/org/elasticsearch/discovery/DiscoveryWithServiceDisruptionsIT.java, +    private boolean disableBeforeIndexDeletion;, +, +    @Override, +    public void setDisruptionScheme(ServiceDisruptionScheme scheme) {, +        if (scheme instanceof NetworkDisruption &&, +            ((NetworkDisruption) scheme).getNetworkLinkDisruptionType() instanceof NetworkUnresponsive) {, +            // the network unresponsive disruption may leave operations in flight, +            // this is because this disruption scheme swallows requests by design, +            // as such, these operations will never be marked as finished, +            disableBeforeIndexDeletion = true;, +        }, +        super.setDisruptionScheme(scheme);, +    }, +, +        if (disableBeforeIndexDeletion == false) {, +            super.beforeIndexDeletion();, +        }, +++ b/test/framework/src/main/java/org/elasticsearch/test/disruption/NetworkDisruption.java, +    public DisruptedLinks getDisruptedLinks() {, +        return disruptedLinks;, +    }, +, +    public NetworkLinkDisruptionType getNetworkLinkDisruptionType() {, +        return networkLinkDisruptionType;, +    }, +, +    @Override, +    public String toString() {, +        return "network disruption (disruption type: " + networkLinkDisruptionType + ", disrupted links: " + disruptedLinks + ")";, +    }, +, +++ b/core/src/test/java/org/elasticsearch/discovery/DiscoveryWithServiceDisruptionsIT.java, +    private boolean disableBeforeIndexDeletion;, +, +    @Override, +    public void setDisruptionScheme(ServiceDisruptionScheme scheme) {, +        if (scheme instanceof NetworkDisruption &&, +            ((NetworkDisruption) scheme).getNetworkLinkDisruptionType() instanceof NetworkUnresponsive) {, +            // the network unresponsive disruption may leave operations in flight, +            // this is because this disruption scheme swallows requests by design, +            // as such, these operations will never be marked as finished, +            disableBeforeIndexDeletion = true;, +        }, +        super.setDisruptionScheme(scheme);, +    }, +, +        if (disableBeforeIndexDeletion == false) {, +            super.beforeIndexDeletion();, +        }, +++ b/test/framework/src/main/java/org/elasticsearch/test/disruption/NetworkDisruption.java, +    public DisruptedLinks getDisruptedLinks() {, +        return disruptedLinks;, +    }, +, +    public NetworkLinkDisruptionType getNetworkLinkDisruptionType() {, +        return networkLinkDisruptionType;, +    }, +, +    @Override, +    public String toString() {, +        return "network disruption (disruption type: " + networkLinkDisruptionType + ", disrupted links: " + disruptedLinks + ")";, +    }, +, +++ b/test/framework/src/main/java/org/elasticsearch/test/transport/MockTransportService.java, +import java.util.Queue;, +import java.util.concurrent.ConcurrentLinkedQueue;, +import java.util.concurrent.atomic.AtomicBoolean;, +        Transport transport = transport().transports.remove(transportAddress);, +        if (transport instanceof ClearableTransport) {, +            ((ClearableTransport) transport).clearRule();, +        }, +        addDelegate(transportAddress, new ClearableTransport(original) {, +            private final Queue<Runnable> requestsToSendWhenCleared = new ConcurrentLinkedQueue<>();, +                Runnable runnable = new AbstractRunnable() {, +                    AtomicBoolean requestSent = new AtomicBoolean();, +, +                        if (requestSent.compareAndSet(false, true)) {, +                    }, +                };, +, +                // store the request to send it once the rule is cleared.]