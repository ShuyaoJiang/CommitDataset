[+++ b/core/src/test/java/org/elasticsearch/indices/cluster/AbstractIndicesClusterStateServiceTestCase.java, +                // initializing a shard should succeed when enableRandomFailures is disabled, +                // active shards can be failed if state persistence was disabled in an earlier CS update, +                if (failedShardsCache.values().stream().anyMatch(ShardRouting::initializing)) {, +                    fail("failed shard cache should not contain initializing shard routing: " + failedShardsCache.values());, +                }, +, +                if (state.blocks().disableStatePersistence()) {, +                    if (shard != null) {, +                        fail("Shard with id " + shardRouting + " should be removed from indicesService due to disabled state persistence");, +                } else {, +                    if (shard == null && failedShard == null) {, +                        // shard must either be there or there must be a failure, +                        fail("Shard with id " + shardRouting + " expected but missing in indicesService and failedShardsCache");, +                    }, +                    if (enableRandomFailures == false) {, +                        if (shard == null && shardRouting.initializing() && failedShard == shardRouting) {, +                            // initializing a shard should succeed when enableRandomFailures is disabled, +                            fail("Shard with id " + shardRouting + " expected but missing in indicesService " + failedShard);, +                            assertThat(shard.routingEntry() + " isn't updated with active aIDs", shard.activeAllocationIds,, +                                equalTo(activeIds));, +        }, +            if (state.blocks().disableStatePersistence()) {, +                fail("Index service " + indexService.index() + " should be removed from indicesService due to disabled state persistence");, +            }, +, +++ b/core/src/test/java/org/elasticsearch/indices/cluster/AbstractIndicesClusterStateServiceTestCase.java, +                // initializing a shard should succeed when enableRandomFailures is disabled, +                // active shards can be failed if state persistence was disabled in an earlier CS update, +                if (failedShardsCache.values().stream().anyMatch(ShardRouting::initializing)) {, +                    fail("failed shard cache should not contain initializing shard routing: " + failedShardsCache.values());, +                }, +, +                if (state.blocks().disableStatePersistence()) {, +                    if (shard != null) {, +                        fail("Shard with id " + shardRouting + " should be removed from indicesService due to disabled state persistence");, +                } else {, +                    if (shard == null && failedShard == null) {, +                        // shard must either be there or there must be a failure, +                        fail("Shard with id " + shardRouting + " expected but missing in indicesService and failedShardsCache");, +                    }, +                    if (enableRandomFailures == false) {, +                        if (shard == null && shardRouting.initializing() && failedShard == shardRouting) {, +                            // initializing a shard should succeed when enableRandomFailures is disabled, +                            fail("Shard with id " + shardRouting + " expected but missing in indicesService " + failedShard);, +                            assertThat(shard.routingEntry() + " isn't updated with active aIDs", shard.activeAllocationIds,, +                                equalTo(activeIds));, +        }, +            if (state.blocks().disableStatePersistence()) {, +                fail("Index service " + indexService.index() + " should be removed from indicesService due to disabled state persistence");, +            }, +, +++ b/core/src/test/java/org/elasticsearch/indices/cluster/IndicesClusterStateServiceRandomUpdatesTests.java, +import org.elasticsearch.cluster.block.ClusterBlock;, +import org.elasticsearch.cluster.block.ClusterBlocks;, +import org.elasticsearch.discovery.DiscoverySettings;, +        // randomly remove no_master blocks, +        if (randomBoolean() && state.blocks().hasGlobalBlock(DiscoverySettings.NO_MASTER_BLOCK_ID)) {, +            state = ClusterState.builder(state).blocks(, +                ClusterBlocks.builder().blocks(state.blocks()).removeGlobalBlock(DiscoverySettings.NO_MASTER_BLOCK_ID)).build();, +        }, +, +        // randomly add no_master blocks, +        if (rarely() && state.blocks().hasGlobalBlock(DiscoverySettings.NO_MASTER_BLOCK_ID) == false) {, +            ClusterBlock block = randomBoolean() ? DiscoverySettings.NO_MASTER_BLOCK_ALL : DiscoverySettings.NO_MASTER_BLOCK_WRITES;, +            state = ClusterState.builder(state).blocks(ClusterBlocks.builder().blocks(state.blocks()).addGlobalBlock(block)).build();, +        }, +, +        // if no_master block is in place, make no other cluster state changes, +        if (state.blocks().hasGlobalBlock(DiscoverySettings.NO_MASTER_BLOCK_ID)) {, +            return state;, +        }, +]