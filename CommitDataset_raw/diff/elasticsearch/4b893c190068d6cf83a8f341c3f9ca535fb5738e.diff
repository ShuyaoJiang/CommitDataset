[+++ b/server/src/main/java/org/elasticsearch/indices/flush/SyncedFlushService.java, +++ b/server/src/main/java/org/elasticsearch/indices/flush/SyncedFlushService.java, +++ b/server/src/test/java/org/elasticsearch/indices/flush/FlushIT.java, +    public void testSyncedFlush() throws Exception {, +++ b/server/src/main/java/org/elasticsearch/indices/flush/SyncedFlushService.java, +++ b/server/src/test/java/org/elasticsearch/indices/flush/FlushIT.java, +    public void testSyncedFlush() throws Exception {, +++ b/server/src/test/java/org/elasticsearch/indices/flush/SyncedFlushUtil.java, +import java.util.concurrent.atomic.AtomicReference;, +, +import static org.elasticsearch.test.ESTestCase.assertBusy;, +    public static ShardsSyncedFlushResult attemptSyncedFlush(Logger logger, InternalTestCluster cluster, ShardId shardId) throws Exception {, +        /*, +         * When the last indexing operation is completed, we will fire a global checkpoint sync., +         * Since a global checkpoint sync request is a replication request, it will acquire an index, +         * shard permit on the primary when executing. If this happens at the same time while we are, +         * issuing the synced-flush, the synced-flush request will fail as it thinks there are, +         * in-flight operations. We can avoid such situation by continuing issuing another synced-flush, +         * if the synced-flush failed due to the ongoing operations on the primary., +         */, +        AtomicReference<LatchedListener<ShardsSyncedFlushResult>> listenerHolder = new AtomicReference<>();, +        assertBusy(() -> {, +            listenerHolder.set(listener);, +            if (listener.result != null && listener.result.failureReason() != null, +                && listener.result.failureReason().contains("ongoing operations on primary")) {, +                throw new AssertionError(listener.result.failureReason()); // cause the assert busy to retry, +        });, +        if (listenerHolder.get().error != null) {, +            throw ExceptionsHelper.convertToElastic(listenerHolder.get().error);, +        return listenerHolder.get().result;]