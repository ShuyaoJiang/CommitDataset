[+++ b/plugin/src/main/java/org/elasticsearch/xpack/ml/action/ForecastJobAction.java, +import org.elasticsearch.ElasticsearchException;, +import org.elasticsearch.xpack.ml.job.persistence.JobProvider;, +import org.elasticsearch.xpack.ml.job.results.ForecastRequestStats; , +import org.elasticsearch.xpack.ml.job.results.ForecastRequestStats.ForecastRequestStatus;, +import java.util.List;, +import java.util.function.Consumer;, +        private final JobProvider jobProvider;, +                JobProvider jobProvider, AutodetectProcessManager processManager) {, +            this.jobProvider = jobProvider;, +                    Consumer<ForecastRequestStats> forecastRequestStatsHandler = forecastRequestStats -> {, +                        if (forecastRequestStats == null) {, +                            // paranoia case, it should not happen that we do not retrieve a result, +                            listener.onFailure(new ElasticsearchException("Cannot run forecast: internal error, please check the logs"));, +                        } else if (forecastRequestStats.getStatus() == ForecastRequestStatus.FAILED) {, +                            List<String> messages = forecastRequestStats.getMessages();, +                            if (messages.size() > 0) {, +                                listener.onFailure(ExceptionsHelper.badRequestException("Cannot run forecast: " + messages.get(0)));, +                            } else {, +                                // paranoia case, it should not be possible to have an empty message list, +                                listener.onFailure(, +                                        new ElasticsearchException("Cannot run forecast: internal error, please check the logs"));, +                            }, +                        } else {, +                        }, +                    };, +, +                    jobProvider.getForecastRequestStats(request.getJobId(), params.getForecastId(), forecastRequestStatsHandler,, +                            listener::onFailure);, +++ b/plugin/src/main/java/org/elasticsearch/xpack/ml/action/ForecastJobAction.java, +import org.elasticsearch.ElasticsearchException;, +import org.elasticsearch.xpack.ml.job.persistence.JobProvider;, +import org.elasticsearch.xpack.ml.job.results.ForecastRequestStats; , +import org.elasticsearch.xpack.ml.job.results.ForecastRequestStats.ForecastRequestStatus;, +import java.util.List;, +import java.util.function.Consumer;, +        private final JobProvider jobProvider;, +                JobProvider jobProvider, AutodetectProcessManager processManager) {, +            this.jobProvider = jobProvider;, +                    Consumer<ForecastRequestStats> forecastRequestStatsHandler = forecastRequestStats -> {, +                        if (forecastRequestStats == null) {, +                            // paranoia case, it should not happen that we do not retrieve a result, +                            listener.onFailure(new ElasticsearchException("Cannot run forecast: internal error, please check the logs"));, +                        } else if (forecastRequestStats.getStatus() == ForecastRequestStatus.FAILED) {, +                            List<String> messages = forecastRequestStats.getMessages();, +                            if (messages.size() > 0) {, +                                listener.onFailure(ExceptionsHelper.badRequestException("Cannot run forecast: " + messages.get(0)));, +                            } else {, +                                // paranoia case, it should not be possible to have an empty message list, +                                listener.onFailure(, +                                        new ElasticsearchException("Cannot run forecast: internal error, please check the logs"));, +                            }, +                        } else {, +                        }, +                    };, +, +                    jobProvider.getForecastRequestStats(request.getJobId(), params.getForecastId(), forecastRequestStatsHandler,, +                            listener::onFailure);, +++ b/plugin/src/main/java/org/elasticsearch/xpack/ml/job/persistence/JobProvider.java, +import org.elasticsearch.common.xcontent.XContentType;, +import org.elasticsearch.xpack.ml.job.results.ForecastRequestStats;, +    private <T, U> T parseGetHit(GetResponse getResponse, BiFunction<XContentParser, U, T> objectParser, , +                                 Consumer<Exception> errorHandler) {, +        BytesReference source = getResponse.getSourceAsBytesRef();, +, +        try (XContentParser parser = XContentFactory.xContent(XContentType.JSON).createParser(NamedXContentRegistry.EMPTY, source)) {, +            return objectParser.apply(parser, null);, +        } catch (IOException e) {, +            errorHandler.accept(new ElasticsearchParseException("failed to parse " + getResponse.getType(), e));, +            return null;, +        }, +    }, +, +    private <U, T> void getResult(String jobId, String resultDescription, GetRequest get, BiFunction<XContentParser, U, T> objectParser,, +            Consumer<Result<T>> handler, Consumer<Exception> errorHandler, Supplier<T> notFoundSupplier) {, +, +        executeAsyncWithOrigin(client.threadPool().getThreadContext(), ML_ORIGIN, get, ActionListener.<GetResponse>wrap(getDocResponse -> {, +            if (getDocResponse.isExists()) {, +                handler.accept(new Result<>(getDocResponse.getIndex(), parseGetHit(getDocResponse, objectParser, errorHandler)));, +            } else {, +                LOGGER.trace("No {} for job with id {}", resultDescription, jobId);, +                handler.accept(new Result<>(null, notFoundSupplier.get()));, +            }, +        }, errorHandler), client::get);, +    }, +, +    public void getForecastRequestStats(String jobId, String forecastId, Consumer<ForecastRequestStats> handler,, +            Consumer<Exception> errorHandler) {, +        String indexName = AnomalyDetectorsIndex.jobResultsAliasedName(jobId);, +        GetRequest getRequest = new GetRequest(indexName, ElasticsearchMappings.DOC_TYPE,, +                ForecastRequestStats.documentId(jobId, forecastId));, +, +        getResult(jobId, ForecastRequestStats.RESULTS_FIELD.getPreferredName(), getRequest, ForecastRequestStats.PARSER,, +                result -> handler.accept(result.result), errorHandler, () -> null);, +    }, +, +++ b/plugin/src/main/java/org/elasticsearch/xpack/ml/action/ForecastJobAction.java, +import org.elasticsearch.ElasticsearchException;, +import org.elasticsearch.xpack.ml.job.persistence.JobProvider;, +import org.elasticsearch.xpack.ml.job.results.ForecastRequestStats; ]