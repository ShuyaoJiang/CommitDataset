[+++ b/docs/reference/search/request/sort.asciidoc, +coming[1.4.0] Before 1.4.0 there was the `ignore_unmapped` boolean, +parameter, which was not enough information to decide on the sort, +values to emit, and didn't work for cross-index search. It is still, +supported but users are encouraged to migrate to the new, +`unmapped_type` instead., +, +associated with a field. The `unmapped_type` option allows to ignore, +fields that have no mapping and not sort by them. The value of this, +parameter is used to determine what sort values to emit. Here is an, +example of how it can be used:, +        { "price" : {"unmapped_type" : "long"} },, +If any of the indices that are queried doesn't have a mapping for `price`, +then Elasticsearch will handle it as if there was a mapping of type, +`long`, with all documents in this index having no value for this field., +, +++ b/docs/reference/search/request/sort.asciidoc, +coming[1.4.0] Before 1.4.0 there was the `ignore_unmapped` boolean, +parameter, which was not enough information to decide on the sort, +values to emit, and didn't work for cross-index search. It is still, +supported but users are encouraged to migrate to the new, +`unmapped_type` instead., +, +associated with a field. The `unmapped_type` option allows to ignore, +fields that have no mapping and not sort by them. The value of this, +parameter is used to determine what sort values to emit. Here is an, +example of how it can be used:, +        { "price" : {"unmapped_type" : "long"} },, +If any of the indices that are queried doesn't have a mapping for `price`, +then Elasticsearch will handle it as if there was a mapping of type, +`long`, with all documents in this index having no value for this field., +, +++ b/src/main/java/org/elasticsearch/common/text/StringAndBytesText.java, +        if (obj == null) {, +            return false;, +        }, +++ b/docs/reference/search/request/sort.asciidoc, +coming[1.4.0] Before 1.4.0 there was the `ignore_unmapped` boolean, +parameter, which was not enough information to decide on the sort, +values to emit, and didn't work for cross-index search. It is still, +supported but users are encouraged to migrate to the new, +`unmapped_type` instead., +, +associated with a field. The `unmapped_type` option allows to ignore, +fields that have no mapping and not sort by them. The value of this, +parameter is used to determine what sort values to emit. Here is an, +example of how it can be used:, +        { "price" : {"unmapped_type" : "long"} },, +If any of the indices that are queried doesn't have a mapping for `price`, +then Elasticsearch will handle it as if there was a mapping of type, +`long`, with all documents in this index having no value for this field., +, +++ b/src/main/java/org/elasticsearch/common/text/StringAndBytesText.java, +        if (obj == null) {, +            return false;, +        }, +++ b/src/main/java/org/elasticsearch/index/mapper/MapperService.java, +import org.elasticsearch.ElasticsearchIllegalArgumentException;, +import org.elasticsearch.index.mapper.Mapper.BuilderContext;, +    private volatile ImmutableMap<String, FieldMapper<?>> unmappedFieldMappers = ImmutableMap.of();, +, +    /**, +     * Given a type (eg. long, string, ...), return an anonymous field mapper that can be used for search operations., +     */, +    public FieldMapper<?> unmappedFieldMapper(String type) {, +        final ImmutableMap<String, FieldMapper<?>> unmappedFieldMappers = this.unmappedFieldMappers;, +        FieldMapper<?> mapper = unmappedFieldMappers.get(type);, +        if (mapper == null) {, +            final Mapper.TypeParser.ParserContext parserContext = documentMapperParser().parserContext();, +            Mapper.TypeParser typeParser = parserContext.typeParser(type);, +            if (typeParser == null) {, +                throw new ElasticsearchIllegalArgumentException("No mapper found for type [" + type + "]");, +            }, +            final Mapper.Builder<?, ?> builder = typeParser.parse("__anonymous_" + type, ImmutableMap.<String, Object>of(), parserContext);, +            final BuilderContext builderContext = new BuilderContext(indexSettings, new ContentPath(1));, +            mapper = (FieldMapper<?>) builder.build(builderContext);, +, +            // There is no need to synchronize writes here. In the case of concurrent access, we could just, +            // compute some mappers several times, which is not a big deal, +            this.unmappedFieldMappers = ImmutableMap.<String, FieldMapper<?>>builder(), +                    .putAll(unmappedFieldMappers), +                    .put(type, mapper), +                    .build();, +        }, +        return mapper;, +    }, +, +++ b/docs/reference/search/request/sort.asciidoc, +coming[1.4.0] Before 1.4.0 there was the `ignore_unmapped` boolean, +parameter, which was not enough information to decide on the sort, +values to emit, and didn't work for cross-index search. It is still, +supported but users are encouraged to migrate to the new, +`unmapped_type` instead., +, +associated with a field. The `unmapped_type` option allows to ignore, +fields that have no mapping and not sort by them. The value of this, +parameter is used to determine what sort values to emit. Here is an, +example of how it can be used:, +        { "price" : {"unmapped_type" : "long"} },, +If any of the indices that are queried doesn't have a mapping for `price`]