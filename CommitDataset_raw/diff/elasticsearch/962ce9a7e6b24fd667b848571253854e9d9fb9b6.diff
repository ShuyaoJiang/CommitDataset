[+++ b/modules/elasticsearch/src/main/java/org/elasticsearch/discovery/DiscoveryService.java, +    private volatile boolean initialStateReceived;, +, +                    initialStateReceived = true;, +                    initialStateReceived = false;, +    /**, +     * Returns <tt>true</tt> if the initial state was received within the timeout waiting for it, +     * on {@link #doStart()}., +     */, +    public boolean initialStateReceived() {, +        return initialStateReceived;, +    }, +, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/discovery/DiscoveryService.java, +    private volatile boolean initialStateReceived;, +, +                    initialStateReceived = true;, +                    initialStateReceived = false;, +    /**, +     * Returns <tt>true</tt> if the initial state was received within the timeout waiting for it, +     * on {@link #doStart()}., +     */, +    public boolean initialStateReceived() {, +        return initialStateReceived;, +    }, +, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/gateway/GatewayService.java, +import org.elasticsearch.discovery.DiscoveryService;, +import org.elasticsearch.util.Nullable;, +import org.elasticsearch.util.TimeValue;, +import java.util.concurrent.CountDownLatch;, +    private final TimeValue initialStateTimeout;, +, +    private final DiscoveryService discoveryService;, +, +    @Inject public GatewayService(Settings settings, Gateway gateway, ClusterService clusterService, DiscoveryService discoveryService,, +        this.discoveryService = discoveryService;, +        this.initialStateTimeout = componentSettings.getAsTime("initialStateTimeout", TimeValue.timeValueSeconds(30));, +        // if we received initial state, see if we can recover within the start phase, so we hold the, +        // server from starting until we recovered properly, +        if (discoveryService.initialStateReceived()) {, +            if (discoveryService.firstMaster()) {, +                if (firstMasterRead.compareAndSet(false, true)) {, +                    boolean waited = readFromGateway(initialStateTimeout);, +                    if (!waited) {, +                        logger.warn("Waited for {} for indices to be created from the gateway, and not all have been created", initialStateTimeout);, +                    }, +                }, +            }, +        } else {, +            logger.debug("Can't wait on start for (possibly) reading state from gateway, will do it asynchronously");, +        }, +                executor.execute(new Runnable() {, +                    @Override public void run() {, +                        readFromGateway(null);, +                    }, +                });, +    /**, +     * Reads from the gateway. If the waitTimeout is set, will wait till all the indices, +     * have been created from the meta data read from the gateway. Return value only applicable, +     * when waiting, and indicates that everything was created within teh wait timeout., +     */, +    private boolean readFromGateway(@Nullable TimeValue waitTimeout) {, +            return false;, +            return false;, +        final CountDownLatch latch = new CountDownLatch(fMetaData.indices().size());, +                                metaDataService.createIndex("gateway", indexMetaData.index(), indexMetaData.settings(), indexMetaData.mappings(), timeValueMillis(initialStateTimeout.millis() - 1000));, +                            } finally {, +                                latch.countDown();, +        if (waitTimeout != null) {, +            try {, +                return latch.await(waitTimeout.millis(), TimeUnit.MILLISECONDS);, +            } catch (InterruptedException e) {, +                // ignore, +        }, +        return false;, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/discovery/DiscoveryService.java, +    private volatile boolean initialStateReceived;, +, +                    initialStateReceived = true;, +                    initialStateReceived = false;, +    /**, +     * Returns <tt>true</tt> if the initial state was received within the timeout waiting for it, +     * on {@link #doStart()}., +     */, +    public boolean initialStateReceived() {, +        return initialStateReceived;, +    }, +, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/gateway/GatewayService.java, +import org.elasticsearch.discovery.DiscoveryService;, +import org.elasticsearch.util.Nullable;, +import org.elasticsearch.util.TimeValue;, +import java.util.concurrent.CountDownLatch;, +    private final TimeValue initialStateTimeout;, +, +    private final DiscoveryService discoveryService;, +, +    @Inject public GatewayService(Settings settings, Gateway gateway, ClusterService clusterService, DiscoveryService discoveryService,, +        this.discoveryService = discoveryService;]