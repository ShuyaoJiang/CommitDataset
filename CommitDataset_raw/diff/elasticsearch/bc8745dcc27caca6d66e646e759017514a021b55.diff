[+++ b/core/src/main/java/org/elasticsearch/search/highlight/AbstractHighlighterBuilder.java, +import org.elasticsearch.common.ParsingException;, +import org.elasticsearch.common.xcontent.XContentParser;, +import org.elasticsearch.index.query.QueryParseContext;, +import java.util.ArrayList;, +import java.util.List;, +    /**, +     * Creates a new {@link HighlightBuilder} from the highlighter held by the {@link QueryParseContext}, +     * in {@link org.elasticsearch.common.xcontent.XContent} format, +     *, +     * @param parseContext containing the parser positioned at the structure to be parsed from., +     * the state on the parser contained in this context will be changed as a side effect of this, +     * method call, +     * @return the new {@link AbstractHighlighterBuilder}, +     */, +    public HB fromXContent(QueryParseContext parseContext) throws IOException {, +        XContentParser parser = parseContext.parser();, +        XContentParser.Token token = parser.currentToken();, +        String currentFieldName = null;, +        HB highlightBuilder = createInstance(parser);, +        while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {, +            if (token == XContentParser.Token.FIELD_NAME) {, +                currentFieldName = parser.currentName();, +            } else if (token == XContentParser.Token.START_ARRAY) {, +                if (parseContext.parseFieldMatcher().match(currentFieldName, PRE_TAGS_FIELD)) {, +                    List<String> preTagsList = new ArrayList<>();, +                    while ((token = parser.nextToken()) != XContentParser.Token.END_ARRAY) {, +                        preTagsList.add(parser.text());, +                    }, +                    highlightBuilder.preTags(preTagsList.toArray(new String[preTagsList.size()]));, +                } else if (parseContext.parseFieldMatcher().match(currentFieldName, POST_TAGS_FIELD)) {, +                    List<String> postTagsList = new ArrayList<>();, +                    while ((token = parser.nextToken()) != XContentParser.Token.END_ARRAY) {, +                        postTagsList.add(parser.text());, +                    }, +                    highlightBuilder.postTags(postTagsList.toArray(new String[postTagsList.size()]));, +                } else if (false == highlightBuilder.doFromXContent(parseContext, currentFieldName, token)) {, +                    throw new ParsingException(parser.getTokenLocation(), "cannot parse array with name [{}]", currentFieldName);, +                }, +            } else if (token.isValue()) {, +                if (parseContext.parseFieldMatcher().match(currentFieldName, ORDER_FIELD)) {, +                    highlightBuilder.order(parser.text());, +                } else if (parseContext.parseFieldMatcher().match(currentFieldName, HIGHLIGHT_FILTER_FIELD)) {, +                    highlightBuilder.highlightFilter(parser.booleanValue());, +                } else if (parseContext.parseFieldMatcher().match(currentFieldName, FRAGMENT_SIZE_FIELD)) {, +                    highlightBuilder.fragmentSize(parser.intValue());, +                } else if (parseContext.parseFieldMatcher().match(currentFieldName, NUMBER_OF_FRAGMENTS_FIELD)) {, +                    highlightBuilder.numOfFragments(parser.intValue());, +                } else if (parseContext.parseFieldMatcher().match(currentFieldName, REQUIRE_FIELD_MATCH_FIELD)) {, +                    highlightBuilder.requireFieldMatch(parser.booleanValue());, +                } else if (parseContext.parseFieldMatcher().match(currentFieldName, BOUNDARY_MAX_SCAN_FIELD)) {, +                    highlightBuilder.boundaryMaxScan(parser.intValue());, +                } else if (parseContext.parseFieldMatcher().match(currentFieldName, BOUNDARY_CHARS_FIELD)) {, +                    highlightBuilder.boundaryChars(parser.text().toCharArray());, +                } else if (parseContext.parseFieldMatcher().match(currentFieldName, TYPE_FIELD)) {, +                    highlightBuilder.highlighterType(parser.text());, +                } else if (parseContext.parseFieldMatcher().match(currentFieldName, FRAGMENTER_FIELD)) {, +                    highlightBuilder.fragmenter(parser.text());, +                } else if (parseContext.parseFieldMatcher().match(currentFieldName, NO_MATCH_SIZE_FIELD)) {, +                    highlightBuilder.noMatchSize(parser.intValue());, +                } else if (parseContext.parseFieldMatcher().match(currentFieldName, FORCE_SOURCE_FIELD)) {, +                    highlightBuilder.forceSource(parser.booleanValue());, +                } else if (parseContext.parseFieldMatcher().match(currentFieldName, PHRASE_LIMIT_FIELD)) {, +                    highlightBuilder.phraseLimit(parser.intValue());, +                } else if (false == highlightBuilder.doFromXContent(parseContext, currentFieldName, token)) {, +                    throw new ParsingException(parser.getTokenLocation(), "unexpected fieldname [{}]", currentFieldName);, +                }, +            } else if (token == XContentParser.Token.START_OBJECT && currentFieldName != null) {, +                if (parseContext.parseFieldMatcher().match(currentFieldName, OPTIONS_FIELD)) {, +                    highlightBuilder.options(parser.map());, +                } else if (parseContext.parseFieldMatcher().match(currentFieldName, HIGHLIGHT_QUERY_FIELD)) {, +                    highlightBuilder.highlightQuery(parseContext.parseInnerQueryBuilder());, +                } else if (false == highlightBuilder.doFromXContent(parseContext, currentFieldName, token)) {, +                    throw new ParsingException(parser.getTokenLocation(), "cannot parse object with name [{}]", currentFieldName);, +                }, +            } else if (currentFieldName != null) {, +                throw new ParsingException(parser.getTokenLocation(), "unexpected token [{}] after [{}]", token, currentFieldName);, +            }, +        }, +, +        if (highlightBuilder.preTags() != null && highlightBuilder.postTags() == null) {, +            throw new ParsingException(parser.getTokenLocation(), "Highlighter global preTags are set, but global postTags are not set");, +        }, +        return highlightBuilder;, +    }, +, +    /**, +     * @param parser the input parser. Implementing classes might advance the parser depending on the, +     * information they need to instantiate a new instance, +     * @return a new instance, +     */, +    protected abstract HB createInstance(XContentParser parser) throws IOException;, +, +    /**, +     * Implementing subclasses can handle parsing special options depending on the, +     * current token, field name and the parse context., +     * @return <tt>true</tt> if an option was found and successfully parsed, otherwise <tt>false</tt>, +     */, +    protected abstract boolean doFromXContent(QueryParseContext parseContext, String currentFieldName, XContentParser.Token endMarkerToken) throws IOException;, +]