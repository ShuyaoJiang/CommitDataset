[+++ b/core/src/main/java/org/elasticsearch/common/network/NetworkUtils.java, +, +    /**, +     * True if we can bind to a v6 address. Its silly, but for *binding* we have a need to know, +     * if the stack works. this can prevent scary noise on IPv4-only hosts., +     * @deprecated transition mechanism only, do not use, +     */, +    @Deprecated, +    public static final boolean SUPPORTS_V6;, +, +    static {, +        boolean v = false;, +        try {, +            for (NetworkInterface nic : getInterfaces()) {, +                for (InetAddress address : Collections.list(nic.getInetAddresses())) {, +                    if (address instanceof Inet6Address) {, +                        v = true;, +                        break;, +                    }, +                }, +            }, +        } catch (SecurityException | SocketException misconfiguration) {, +            v = true; // be optimistic, you misconfigure, then you get noise to your screen, +        }, +        SUPPORTS_V6 = v;, +    }, +++ b/core/src/main/java/org/elasticsearch/common/network/NetworkUtils.java, +, +    /**, +     * True if we can bind to a v6 address. Its silly, but for *binding* we have a need to know, +     * if the stack works. this can prevent scary noise on IPv4-only hosts., +     * @deprecated transition mechanism only, do not use, +     */, +    @Deprecated, +    public static final boolean SUPPORTS_V6;, +, +    static {, +        boolean v = false;, +        try {, +            for (NetworkInterface nic : getInterfaces()) {, +                for (InetAddress address : Collections.list(nic.getInetAddresses())) {, +                    if (address instanceof Inet6Address) {, +                        v = true;, +                        break;, +                    }, +                }, +            }, +        } catch (SecurityException | SocketException misconfiguration) {, +            v = true; // be optimistic, you misconfigure, then you get noise to your screen, +        }, +        SUPPORTS_V6 = v;, +    }, +++ b/core/src/main/java/org/elasticsearch/transport/netty/NettyTransport.java, +        List<String> local = new ArrayList<>();, +        local.add("127.0.0.1");, +        // check if v6 is supported, if so, v4 will also work via mapped addresses., +        if (NetworkUtils.SUPPORTS_V6) {, +            local.add("::1");, +        }, +        return local;, +++ b/core/src/main/java/org/elasticsearch/common/network/NetworkUtils.java, +, +    /**, +     * True if we can bind to a v6 address. Its silly, but for *binding* we have a need to know, +     * if the stack works. this can prevent scary noise on IPv4-only hosts., +     * @deprecated transition mechanism only, do not use, +     */, +    @Deprecated, +    public static final boolean SUPPORTS_V6;, +, +    static {, +        boolean v = false;, +        try {, +            for (NetworkInterface nic : getInterfaces()) {, +                for (InetAddress address : Collections.list(nic.getInetAddresses())) {, +                    if (address instanceof Inet6Address) {, +                        v = true;, +                        break;, +                    }, +                }, +            }, +        } catch (SecurityException | SocketException misconfiguration) {, +            v = true; // be optimistic, you misconfigure, then you get noise to your screen, +        }, +        SUPPORTS_V6 = v;, +    }, +++ b/core/src/main/java/org/elasticsearch/transport/netty/NettyTransport.java, +        List<String> local = new ArrayList<>();, +        local.add("127.0.0.1");, +        // check if v6 is supported, if so, v4 will also work via mapped addresses., +        if (NetworkUtils.SUPPORTS_V6) {, +            local.add("::1");, +        }, +        return local;, +++ b/core/src/test/java/org/elasticsearch/test/test/InternalTestClusterTests.java, +        InternalTestCluster cluster0 = new InternalTestCluster(InternalTestCluster.configuredNodeMode(), clusterSeed, baseDir, minNumDataNodes, maxNumDataNodes, clusterName, settingsSource, numClientNodes, enableHttpPipelining, nodePrefix);, +        InternalTestCluster cluster1 = new InternalTestCluster(InternalTestCluster.configuredNodeMode(), clusterSeed, baseDir, minNumDataNodes, maxNumDataNodes, clusterName, settingsSource, numClientNodes, enableHttpPipelining, nodePrefix);, +        InternalTestCluster cluster0 = new InternalTestCluster(InternalTestCluster.configuredNodeMode(), clusterSeed, baseDir, minNumDataNodes, maxNumDataNodes, clusterName1, settingsSource, numClientNodes, enableHttpPipelining, nodePrefix);, +        InternalTestCluster cluster1 = new InternalTestCluster(InternalTestCluster.configuredNodeMode(), clusterSeed, baseDir, minNumDataNodes, maxNumDataNodes, clusterName2, settingsSource, numClientNodes, enableHttpPipelining, nodePrefix);, +]