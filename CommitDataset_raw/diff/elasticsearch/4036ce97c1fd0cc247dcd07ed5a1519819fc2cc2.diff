[+++ b/elasticsearch/x-pack/build.gradle, +, +forbiddenApisMain {, +  signaturesURLs += [file('signatures.txt').toURI().toURL()], +}, +++ b/elasticsearch/x-pack/build.gradle, +, +forbiddenApisMain {, +  signaturesURLs += [file('signatures.txt').toURI().toURL()], +}, +++ b/elasticsearch/x-pack/shield/src/main/java/org/elasticsearch/shield/authc/esnative/NativeUsersStore.java, +import org.elasticsearch.shield.support.SelfReschedulingRunnable;, +import org.elasticsearch.threadpool.ThreadPool.Names;, +    private SelfReschedulingRunnable userPoller;, +                userPoller = new SelfReschedulingRunnable(poller, threadPool,, +                        settings.getAsTime("shield.authc.native.reload.interval", TimeValue.timeValueSeconds(30L)), Names.GENERIC, logger);, +                userPoller.start();, +                userPoller.stop();, +++ b/elasticsearch/x-pack/build.gradle, +, +forbiddenApisMain {, +  signaturesURLs += [file('signatures.txt').toURI().toURL()], +}, +++ b/elasticsearch/x-pack/shield/src/main/java/org/elasticsearch/shield/authc/esnative/NativeUsersStore.java, +import org.elasticsearch.shield.support.SelfReschedulingRunnable;, +import org.elasticsearch.threadpool.ThreadPool.Names;, +    private SelfReschedulingRunnable userPoller;, +                userPoller = new SelfReschedulingRunnable(poller, threadPool,, +                        settings.getAsTime("shield.authc.native.reload.interval", TimeValue.timeValueSeconds(30L)), Names.GENERIC, logger);, +                userPoller.start();, +                userPoller.stop();, +++ b/elasticsearch/x-pack/shield/src/main/java/org/elasticsearch/shield/authz/store/NativeRolesStore.java, +import org.elasticsearch.shield.support.SelfReschedulingRunnable;, +import org.elasticsearch.threadpool.ThreadPool.Names;, +    private SelfReschedulingRunnable rolesPoller;, +                rolesPoller = new SelfReschedulingRunnable(poller, threadPool, pollInterval, Names.GENERIC, logger);, +                rolesPoller.start();, +                rolesPoller.stop();, +++ b/elasticsearch/x-pack/build.gradle, +, +forbiddenApisMain {, +  signaturesURLs += [file('signatures.txt').toURI().toURL()], +}, +++ b/elasticsearch/x-pack/shield/src/main/java/org/elasticsearch/shield/authc/esnative/NativeUsersStore.java, +import org.elasticsearch.shield.support.SelfReschedulingRunnable;, +import org.elasticsearch.threadpool.ThreadPool.Names;, +    private SelfReschedulingRunnable userPoller;, +                userPoller = new SelfReschedulingRunnable(poller, threadPool,, +                        settings.getAsTime("shield.authc.native.reload.interval", TimeValue.timeValueSeconds(30L)), Names.GENERIC, logger);, +                userPoller.start();, +                userPoller.stop();, +++ b/elasticsearch/x-pack/shield/src/main/java/org/elasticsearch/shield/authz/store/NativeRolesStore.java, +import org.elasticsearch.shield.support.SelfReschedulingRunnable;, +import org.elasticsearch.threadpool.ThreadPool.Names;, +    private SelfReschedulingRunnable rolesPoller;, +                rolesPoller = new SelfReschedulingRunnable(poller, threadPool, pollInterval, Names.GENERIC, logger);, +                rolesPoller.start();, +                rolesPoller.stop();, +++ b/elasticsearch/x-pack/shield/src/main/java/org/elasticsearch/shield/support/SelfReschedulingRunnable.java, +/*, + * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one, + * or more contributor license agreements. Licensed under the Elastic License;, + * you may not use this file except in compliance with the Elastic License., + */, +package org.elasticsearch.shield.support;, +, +import org.elasticsearch.common.logging.ESLogger;, +import org.elasticsearch.common.unit.TimeValue;, +import org.elasticsearch.common.util.concurrent.AbstractRunnable;, +import org.elasticsearch.common.util.concurrent.FutureUtils;, +import org.elasticsearch.threadpool.ThreadPool;, +, +import java.util.concurrent.ScheduledFuture;, +, +public class SelfReschedulingRunnable extends AbstractRunnable {, +, +    private final AbstractRunnable runnable;, +    private final ThreadPool threadPool;, +    private final TimeValue interval;, +    private final String executorName;, +    private final ESLogger logger;, +, +    private ScheduledFuture<?> scheduledFuture = null;, +    private volatile boolean run = false;, +, +    public SelfReschedulingRunnable(AbstractRunnable runnable, ThreadPool threadPool, TimeValue interval, String executorName,, +                                    ESLogger logger) {, +        this.runnable = runnable;, +        this.threadPool = threadPool;, +        this.interval = interval;, +        this.executorName = executorName;, +        this.logger = logger;, +    }, +, +    public synchronized void start() {, +        if (run != false || scheduledFuture != null) {, +            throw new IllegalStateException("start should not be called again before calling stop");, +        }, +        run = true;, +        scheduledFuture = threadPool.schedule(interval, executorName, this);]