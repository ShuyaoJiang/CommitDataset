[+++ b/core/src/main/java/org/elasticsearch/index/mapper/DocumentParser.java, +    final ParsedDocument parseDocument(SourceToParse source) throws MapperParsingException {, +        validateType(source);, +        final Mapping mapping = docMapper.mapping();, +        final ParseContext.InternalParseContext context = cache.get();, +        XContentParser parser = null;, +            parser = parser(source);, +            validateStart(parser);, +            internalParseDocument(mapping, context, parser);, +            validateEnd(source, parser);, +        } catch (Throwable t) {, +            throw wrapInMapperParsingException(source, t);, +        } finally {, +            // only close the parser when its not provided externally, +            if (internalParser(source, parser)) {, +                parser.close();, +            }, +        reverseOrder(context);, +        applyDocBoost(context);, +, +        ParsedDocument doc = parsedDocument(source, context, update(context, mapping));, +        // reset the context to free up memory, +        context.reset(null, null, null);, +        return doc;, +, +    private static void internalParseDocument(Mapping mapping, ParseContext.InternalParseContext context, XContentParser parser) throws IOException {, +        final boolean emptyDoc = isEmptyDoc(mapping, parser);, +    }, +    private void validateType(SourceToParse source) {, +        if (docMapper.type().equals(MapperService.DEFAULT_MAPPING)) {, +            throw new IllegalArgumentException("It is forbidden to index into the default mapping [" + MapperService.DEFAULT_MAPPING + "]");, +        }, +, +        if (source.type() != null && !source.type().equals(docMapper.type())) {, +            throw new MapperParsingException("Type mismatch, provide type [" + source.type() + "] but mapper is of type [" + docMapper.type() + "]");, +        }, +    }, +, +    private static XContentParser parser(SourceToParse source) throws IOException {, +        return source.parser() == null ? XContentHelper.createParser(source.source()) : source.parser();, +    }, +, +    private static boolean internalParser(SourceToParse source, XContentParser parser) {, +        return source.parser() == null && parser != null;, +    }, +, +    private static void validateStart(XContentParser parser) throws IOException {, +        // will result in START_OBJECT, +        XContentParser.Token token = parser.nextToken();, +        if (token != XContentParser.Token.START_OBJECT) {, +            throw new MapperParsingException("Malformed content, must start with an object");, +        }, +    }, +, +    private static void validateEnd(SourceToParse source, XContentParser parser) throws IOException {, +        XContentParser.Token token;// only check for end of tokens if we created the parser here, +        if (internalParser(source, parser)) {, +    private static boolean isEmptyDoc(Mapping mapping, XContentParser parser) throws IOException {, +        if (mapping.root.isEnabled()) {, +            final XContentParser.Token token = parser.nextToken();, +            if (token == XContentParser.Token.END_OBJECT) {, +                // empty doc, we can handle it..., +                return true;, +            } else if (token != XContentParser.Token.FIELD_NAME) {, +                throw new MapperParsingException("Malformed content, after first object, either the type field or the actual properties should exist");, +            }, +        }, +        return false;, +    private static void reverseOrder(ParseContext.InternalParseContext context) {, +    }, +, +    private static void applyDocBoost(ParseContext.InternalParseContext context) {, +    private static ParsedDocument parsedDocument(SourceToParse source, ParseContext.InternalParseContext context, Mapping update) {, +        return new ParsedDocument(, +            context.uid(),, +            context.version(),, +            context.id(),, +            context.type(),, +            source.routing(),, +            source.timestamp(),, +            source.ttl(),, +            context.docs(),, +            context.source(),, +            update, +        ).parent(source.parent());, +    }, +, +, +    private static Mapping update(ParseContext.InternalParseContext context, Mapping mapping) {, +        Mapper rootDynamicUpdate = context.dynamicMappingsUpdate();, +        return rootDynamicUpdate != null ? mapping.mappingUpdate(rootDynamicUpdate) : null;, +    }, +, +    private static MapperParsingException wrapInMapperParsingException(SourceToParse source, Throwable e) {, +        // if its already a mapper parsing exception, no need to wrap it..., +        if (e instanceof MapperParsingException) {, +            return (MapperParsingException) e;, +        }, +, +        // Throw a more meaningful message if the document is empty.]