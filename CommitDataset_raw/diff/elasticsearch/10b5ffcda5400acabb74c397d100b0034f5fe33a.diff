[+++ b/core/src/main/java/org/elasticsearch/action/admin/indices/flush/TransportShardFlushAction.java, +    protected Tuple<ReplicationResponse, ShardFlushRequest> shardOperationOnPrimary(MetaData metaData, ShardFlushRequest shardRequest) {, +++ b/core/src/main/java/org/elasticsearch/action/admin/indices/flush/TransportShardFlushAction.java, +    protected Tuple<ReplicationResponse, ShardFlushRequest> shardOperationOnPrimary(MetaData metaData, ShardFlushRequest shardRequest) {, +++ b/core/src/main/java/org/elasticsearch/action/admin/indices/refresh/TransportShardRefreshAction.java, +    protected Tuple<ReplicationResponse, BasicReplicationRequest> shardOperationOnPrimary(MetaData metaData, BasicReplicationRequest shardRequest) {, +++ b/core/src/main/java/org/elasticsearch/action/admin/indices/flush/TransportShardFlushAction.java, +    protected Tuple<ReplicationResponse, ShardFlushRequest> shardOperationOnPrimary(MetaData metaData, ShardFlushRequest shardRequest) {, +++ b/core/src/main/java/org/elasticsearch/action/admin/indices/refresh/TransportShardRefreshAction.java, +    protected Tuple<ReplicationResponse, BasicReplicationRequest> shardOperationOnPrimary(MetaData metaData, BasicReplicationRequest shardRequest) {, +++ b/core/src/main/java/org/elasticsearch/action/index/TransportIndexAction.java, +    protected Tuple<IndexResponse, IndexRequest> shardOperationOnPrimary(MetaData metaData, IndexRequest request) throws Exception {, +    public static WriteResult<IndexResponse> executeIndexRequestOnPrimary(IndexRequest request, IndexShard indexShard, MappingUpdatedAction mappingUpdatedAction) throws Exception {, +++ b/core/src/main/java/org/elasticsearch/action/admin/indices/flush/TransportShardFlushAction.java, +    protected Tuple<ReplicationResponse, ShardFlushRequest> shardOperationOnPrimary(MetaData metaData, ShardFlushRequest shardRequest) {, +++ b/core/src/main/java/org/elasticsearch/action/admin/indices/refresh/TransportShardRefreshAction.java, +    protected Tuple<ReplicationResponse, BasicReplicationRequest> shardOperationOnPrimary(MetaData metaData, BasicReplicationRequest shardRequest) {, +++ b/core/src/main/java/org/elasticsearch/action/index/TransportIndexAction.java, +    protected Tuple<IndexResponse, IndexRequest> shardOperationOnPrimary(MetaData metaData, IndexRequest request) throws Exception {, +    public static WriteResult<IndexResponse> executeIndexRequestOnPrimary(IndexRequest request, IndexShard indexShard, MappingUpdatedAction mappingUpdatedAction) throws Exception {, +++ b/core/src/main/java/org/elasticsearch/action/support/replication/TransportReplicationAction.java, +import org.elasticsearch.index.shard.IndexShardState;, +     *, +    protected abstract Tuple<Response, ReplicaRequest> shardOperationOnPrimary(MetaData metaData, Request shardRequest) throws Exception;, +, +            try (Releasable ignored = getIndexShardReferenceOnReplica(request.shardId())) {, +, +     * Responsible for performing primary operation locally or delegating primary operation to relocation target in case where shard has, +     * been marked as RELOCATED. Delegates to replication action once successful., +    class PrimaryPhase extends AbstractRunnable {, +        private final ShardId shardId;, +        private IndexShardReference indexShardReference;, +            assert request.shardId() != null : "request shardId must be set prior to primary phase";, +            this.shardId = request.shardId();, +        }, +, +        @Override, +        protected void doRun() throws Exception {, +            // request shardID was set in ReroutePhase, +            final String writeConsistencyFailure = checkWriteConsistency(shardId);, +            if (writeConsistencyFailure != null) {, +                finishBecauseUnavailable(shardId, writeConsistencyFailure);, +            // closed in finishAsFailed(e) in the case of error, +            indexShardReference = getIndexShardReferenceOnPrimary(shardId);, +            if (indexShardReference.isRelocated() == false) {, +                // execute locally, +                Tuple<Response, ReplicaRequest> primaryResponse = shardOperationOnPrimary(state.metaData(), request);, +                if (logger.isTraceEnabled()) {, +                    logger.trace("action [{}] completed on shard [{}] for request [{}] with cluster state version [{}]", transportPrimaryAction, shardId, request, state.version());, +                }, +                ReplicationPhase replicationPhase = new ReplicationPhase(primaryResponse.v2(), primaryResponse.v1(), shardId, channel, indexShardReference);, +            } else {, +                // delegate primary phase to relocation target, +                // it is safe to execute primary phase on relocation target as there are no more in-flight operations where primary, +                // phase is executed on local shard and all subsequent operations are executed on relocation target as primary phase., +                final ShardRouting primary = indexShardReference.routingEntry();, +                indexShardReference.close();, +                assert primary.relocating() : "indexShard is marked as relocated but routing isn't" + primary;, +                DiscoveryNode relocatingNode = state.nodes().get(primary.relocatingNodeId());, +                transportService.sendRequest(relocatingNode, transportPrimaryAction, request, transportOptions,, +                        TransportChannelResponseHandler.responseHandler(logger, TransportReplicationAction.this::newResponseInstance, channel,, +                                "rerouting indexing to target primary " + primary));, +            }, +    /**, +     * returns a new reference to {@link IndexShard} to perform a primary operation. Released after performing primary operation locally, +     * and replication of the operation to all replica shards is completed / failed (see {@link ReplicationPhase})., +     */, +    protected IndexShardReference getIndexShardReferenceOnPrimary(ShardId shardId) {, +        return new IndexShardReferenceImpl(indexShard, true);, +    }, +, +    /**, +     * returns a new reference to {@link IndexShard} on a node that the request is replicated to. The reference is closed as soon as, +     * replication is completed on the node., +     */, +    protected IndexShardReference getIndexShardReferenceOnReplica(ShardId shardId) {, +        IndexService indexService = indicesService.indexServiceSafe(shardId.getIndex());, +        IndexShard indexShard = indexService.getShard(shardId.id());, +        return new IndexShardReferenceImpl(indexShard, false);, +                // the following logic to select the shards to replicate to is mirrored and explained in the doRun method below, +                    continue;, +                }, +                if (shard.unassigned()) {, +                    continue;, +                }, +                if (nodes.localNodeId().equals(shard.currentNodeId()) == false) {, +                if (shard.relocating() && nodes.localNodeId().equals(shard.relocatingNodeId()) == false) {, +                // local shard can be a relocation target of a primary that is in relocated state, +                if (shard.relocating() && nodes.localNodeId().equals(shard.relocatingNodeId()) == false) {, +    interface IndexShardReference extends Releasable {, +        boolean isRelocated();, +        ShardRouting routingEntry();, +    }, +    static final class IndexShardReferenceImpl implements IndexShardReference {, +, +        private final IndexShard indexShard;, +        private final Releasable operationLock;, +, +        IndexShardReferenceImpl(IndexShard indexShard, boolean primaryAction) {, +            this.indexShard = indexShard;]