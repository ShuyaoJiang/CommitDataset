[+++ b/core/src/main/java/org/elasticsearch/common/settings/AbstractScopedSettings.java, +    /**, +     * Adds a settings consumer for affix settings. Affix settings have a namespace associated to it that needs to be available to the, +     * consumer in order to be processed correctly., +     */, +    public synchronized <T> void addAffixUpdateConsumer(Setting.AffixSetting<T> setting,  BiConsumer<String, T> consumer,, +                                                        BiConsumer<String, T> validator) {, +        final Setting<?> registeredSetting = this.complexMatchers.get(setting.getKey());, +        if (setting != registeredSetting) {, +            throw new IllegalArgumentException("Setting is not registered for key [" + setting.getKey() + "]");, +        }, +        addSettingsUpdater(setting.newAffixUpdater(consumer, logger, validator));, +    }, +, +++ b/core/src/main/java/org/elasticsearch/common/settings/AbstractScopedSettings.java, +    /**, +     * Adds a settings consumer for affix settings. Affix settings have a namespace associated to it that needs to be available to the, +     * consumer in order to be processed correctly., +     */, +    public synchronized <T> void addAffixUpdateConsumer(Setting.AffixSetting<T> setting,  BiConsumer<String, T> consumer,, +                                                        BiConsumer<String, T> validator) {, +        final Setting<?> registeredSetting = this.complexMatchers.get(setting.getKey());, +        if (setting != registeredSetting) {, +            throw new IllegalArgumentException("Setting is not registered for key [" + setting.getKey() + "]");, +        }, +        addSettingsUpdater(setting.newAffixUpdater(consumer, logger, validator));, +    }, +, +++ b/core/src/main/java/org/elasticsearch/common/settings/Setting.java, +import java.util.IdentityHashMap;, +import java.util.stream.Stream;, +     * Updates settings that depend on each other., +     * See {@link AbstractScopedSettings#addSettingsUpdateConsumer(Setting, Setting, BiConsumer)} and its usage for details., +    public static class AffixSetting<T> extends Setting<T> {, +        private final AffixKey key;, +        private final Function<String, Setting<T>> delegateFactory;, +, +        public AffixSetting(AffixKey key, Setting<T> delegate, Function<String, Setting<T>> delegateFactory) {, +            super(key, delegate.defaultValue, delegate.parser, delegate.properties.toArray(new Property[0]));, +            this.key = key;, +            this.delegateFactory = delegateFactory;, +        }, +, +        boolean isGroupSetting() {, +            return true;, +        }, +, +        private Stream<String> matchStream(Settings settings) {, +            return settings.getAsMap().keySet().stream().filter((key) -> match(key)).map(settingKey -> key.getConcreteString(settingKey));, +        }, +, +        AbstractScopedSettings.SettingUpdater<Map<AbstractScopedSettings.SettingUpdater<T>, T>> newAffixUpdater(, +            BiConsumer<String, T> consumer, Logger logger, BiConsumer<String, T> validator) {, +            return new AbstractScopedSettings.SettingUpdater<Map<AbstractScopedSettings.SettingUpdater<T>, T>>() {, +, +                @Override, +                public boolean hasChanged(Settings current, Settings previous) {, +                    return  Stream.concat(matchStream(current), matchStream(previous)).findAny().isPresent();, +                }, +, +                @Override, +                public Map<AbstractScopedSettings.SettingUpdater<T>, T> getValue(Settings current, Settings previous) {, +                    // we collect all concrete keys and then delegate to the actual setting for validation and settings extraction, +                    final Map<AbstractScopedSettings.SettingUpdater<T>, T> result = new IdentityHashMap<>();, +                    Stream.concat(matchStream(current), matchStream(previous)).forEach(aKey -> {, +                        String namespace = key.getNamespace(aKey);, +                        AbstractScopedSettings.SettingUpdater<T> updater =, +                            getConcreteSetting(aKey).newUpdater((v) -> consumer.accept(namespace, v), logger,, +                                (v) -> validator.accept(namespace, v));, +                        if (updater.hasChanged(current, previous)) {, +                            // only the ones that have changed otherwise we might get too many updates, +                            // the hasChanged above checks only if there are any changes, +                            T value = updater.getValue(current, previous);, +                            result.put(updater, value);, +                        }, +                    });, +                    return result;, +                }, +, +                @Override, +                public void apply(Map<AbstractScopedSettings.SettingUpdater<T>, T> value, Settings current, Settings previous) {, +                    for (Map.Entry<AbstractScopedSettings.SettingUpdater<T>, T> entry : value.entrySet()) {, +                        entry.getKey().apply(entry.getValue(), current, previous);, +                    }, +                }, +            };, +        }, +, +        @Override, +        public Setting<T> getConcreteSetting(String key) {, +            if (match(key)) {, +                return delegateFactory.apply(key);, +            } else {, +                throw new IllegalArgumentException("key [" + key + "] must match [" + getKey() + "] but didn't.");, +            }, +        }, +, +        @Override, +        public void diff(Settings.Builder builder, Settings source, Settings defaultSettings) {, +            matchStream(defaultSettings).forEach((key) -> getConcreteSetting(key).diff(builder, source, defaultSettings));]