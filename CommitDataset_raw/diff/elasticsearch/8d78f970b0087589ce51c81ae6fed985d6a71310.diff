[+++ b/buildSrc/src/main/groovy/org/elasticsearch/gradle/plugin/PluginPropertiesTask.groovy, +        project.clean.delete(generatedResourcesDir), +            if (extension.name == null) {, +                throw new InvalidUserDataException('name is a required setting for esplugin'), +            }, +                    String warning = "WARNING: Disabling plugin isolation in ${project.path} is deprecated and will be removed in the future", +            from(templateFile), +            into(generatedResourcesDir), +++ b/buildSrc/src/main/groovy/org/elasticsearch/gradle/plugin/PluginPropertiesTask.groovy, +        project.clean.delete(generatedResourcesDir), +            if (extension.name == null) {, +                throw new InvalidUserDataException('name is a required setting for esplugin'), +            }, +                    String warning = "WARNING: Disabling plugin isolation in ${project.path} is deprecated and will be removed in the future", +            from(templateFile), +            into(generatedResourcesDir), +++ b/core/src/main/java/org/apache/lucene/search/suggest/analyzing/XAnalyzingSuggester.java, +/*, + * Licensed to Elasticsearch under one or more contributor, + * license agreements. See the NOTICE file distributed with, + * this work for additional information regarding copyright, + * ownership. Elasticsearch licenses this file to you under, + * the Apache License, Version 2.0 (the "License"); you may, + * not use this file except in compliance with the License., + * You may obtain a copy of the License at, + *, + *    http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing,, + * software distributed under the License is distributed on an, + * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY, + * KIND, either express or implied.  See the License for the, + * specific language governing permissions and limitations, + * under the License., + */, +package org.apache.lucene.search.suggest.analyzing;, +, +import com.carrotsearch.hppc.ObjectIntHashMap;, +, +import org.apache.lucene.analysis.Analyzer;, +import org.apache.lucene.analysis.TokenStream;, +import org.apache.lucene.analysis.TokenStreamToAutomaton;, +import org.apache.lucene.search.suggest.InputIterator;, +import org.apache.lucene.search.suggest.Lookup;, +import org.apache.lucene.store.*;, +import org.apache.lucene.util.*;, +import org.apache.lucene.util.automaton.Automaton;, +import org.apache.lucene.util.automaton.LimitedFiniteStringsIterator;, +import org.apache.lucene.util.automaton.Operations;, +import org.apache.lucene.util.automaton.Transition;, +import org.apache.lucene.util.fst.*;, +import org.apache.lucene.util.fst.FST.BytesReader;, +import org.apache.lucene.util.fst.PairOutputs.Pair;, +import org.apache.lucene.util.fst.Util.Result;, +import org.apache.lucene.util.fst.Util.TopResults;, +import org.elasticsearch.common.collect.HppcMaps;, +, +import java.io.IOException;, +import java.io.InputStream;, +import java.io.OutputStream;, +import java.nio.file.Files;, +import java.nio.file.Path;, +import java.util.*;, +, +/**, + * Suggester that first analyzes the surface form, adds the, + * analyzed form to a weighted FST, and then does the same, + * thing at lookup time.  This means lookup is based on the, + * analyzed form while suggestions are still the surface, + * form(s)., + *, + * <p>, + * This can result in powerful suggester functionality.  For, + * example, if you use an analyzer removing stop words, , + * then the partial text "ghost chr..." could see the, + * suggestion "The Ghost of Christmas Past".  Note that, + * position increments MUST NOT be preserved for this example, + * to work, so you should call the constructor with, + * <code>preservePositionIncrements</code> parameter set to, + * false, + *, + * <p>, + * If SynonymFilter is used to map wifi and wireless network to, + * hotspot then the partial text "wirele..." could suggest, + * "wifi router".  Token normalization like stemmers, accent, + * removal, etc., would allow suggestions to ignore such, + * variations., + *, + * <p>, + * When two matching suggestions have the same weight, they, + * are tie-broken by the analyzed form.  If their analyzed, + * form is the same then the order is undefined., + *, + * <p>, + * There are some limitations:, + * <ul>, + *, + *   <li> A lookup from a query like "net" in English won't, + *        be any different than "net " (ie, user added a, + *        trailing space) because analyzers don't reflect]