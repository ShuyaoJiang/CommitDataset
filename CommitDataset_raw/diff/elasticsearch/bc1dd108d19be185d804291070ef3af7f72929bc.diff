[+++ b/modules/elasticsearch/src/main/java/org/elasticsearch/action/bulk/BulkRequest.java, +        return internalAdd(request);, +, +    private BulkRequest internalAdd(IndexRequest request) {, +                // we use internalAdd so we don't fork here, this allows us not to copy over the big byte array to small chunks, +                // of index request. All index requests are still unsafe if applicable., +                        internalAdd(new IndexRequest(index, type, id).routing(routing).parent(parent).timestamp(timestamp).version(version).versionType(versionType), +                        internalAdd(new IndexRequest(index, type, id).routing(routing).parent(parent).timestamp(timestamp).version(version).versionType(versionType), +                    internalAdd(new IndexRequest(index, type, id).routing(routing).parent(parent).timestamp(timestamp).version(version).versionType(versionType), +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/action/bulk/BulkRequest.java, +        return internalAdd(request);, +, +    private BulkRequest internalAdd(IndexRequest request) {, +                // we use internalAdd so we don't fork here, this allows us not to copy over the big byte array to small chunks, +                // of index request. All index requests are still unsafe if applicable., +                        internalAdd(new IndexRequest(index, type, id).routing(routing).parent(parent).timestamp(timestamp).version(version).versionType(versionType), +                        internalAdd(new IndexRequest(index, type, id).routing(routing).parent(parent).timestamp(timestamp).version(version).versionType(versionType), +                    internalAdd(new IndexRequest(index, type, id).routing(routing).parent(parent).timestamp(timestamp).version(version).versionType(versionType), +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/action/count/CountRequest.java, +        this.querySource = bos.underlyingBytes();, +            this.querySource = builder.underlyingBytes();, +            this.querySourceLength = builder.underlyingBytesLength();, +            this.querySourceUnsafe = false;, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/action/bulk/BulkRequest.java, +        return internalAdd(request);, +, +    private BulkRequest internalAdd(IndexRequest request) {, +                // we use internalAdd so we don't fork here, this allows us not to copy over the big byte array to small chunks, +                // of index request. All index requests are still unsafe if applicable., +                        internalAdd(new IndexRequest(index, type, id).routing(routing).parent(parent).timestamp(timestamp).version(version).versionType(versionType), +                        internalAdd(new IndexRequest(index, type, id).routing(routing).parent(parent).timestamp(timestamp).version(version).versionType(versionType), +                    internalAdd(new IndexRequest(index, type, id).routing(routing).parent(parent).timestamp(timestamp).version(version).versionType(versionType), +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/action/count/CountRequest.java, +        this.querySource = bos.underlyingBytes();, +            this.querySource = builder.underlyingBytes();, +            this.querySourceLength = builder.underlyingBytesLength();, +            this.querySourceUnsafe = false;, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/action/deletebyquery/DeleteByQueryRequest.java, +        this.querySource = bos.underlyingBytes();, +            this.querySource = builder.underlyingBytes();, +            this.querySourceLength = builder.underlyingBytesLength();, +            this.querySourceUnsafe = false;, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/action/bulk/BulkRequest.java, +        return internalAdd(request);, +, +    private BulkRequest internalAdd(IndexRequest request) {, +                // we use internalAdd so we don't fork here, this allows us not to copy over the big byte array to small chunks, +                // of index request. All index requests are still unsafe if applicable., +                        internalAdd(new IndexRequest(index, type, id).routing(routing).parent(parent).timestamp(timestamp).version(version).versionType(versionType), +                        internalAdd(new IndexRequest(index, type, id).routing(routing).parent(parent).timestamp(timestamp).version(version).versionType(versionType), +                    internalAdd(new IndexRequest(index, type, id).routing(routing).parent(parent).timestamp(timestamp).version(version).versionType(versionType), +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/action/count/CountRequest.java, +        this.querySource = bos.underlyingBytes();, +            this.querySource = builder.underlyingBytes();, +            this.querySourceLength = builder.underlyingBytesLength();, +            this.querySourceUnsafe = false;, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/action/deletebyquery/DeleteByQueryRequest.java, +        this.querySource = bos.underlyingBytes();, +            this.querySource = builder.underlyingBytes();, +            this.querySourceLength = builder.underlyingBytesLength();, +            this.querySourceUnsafe = false;, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/action/index/IndexRequest.java, +        // only fork if copy over if source is unsafe, +        if (sourceUnsafe) {, +        if (sourceUnsafe || sourceOffset > 0 || source.length != sourceLength) {, +            source = sourceBuilder.underlyingBytes();, +            sourceLength = sourceBuilder.underlyingBytesLength();, +            sourceUnsafe = false;, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/action/bulk/BulkRequest.java, +        return internalAdd(request);, +, +    private BulkRequest internalAdd(IndexRequest request) {, +                // we use internalAdd so we don't fork here, this allows us not to copy over the big byte array to small chunks, +                // of index request. All index requests are still unsafe if applicable., +                        internalAdd(new IndexRequest(index, type, id).routing(routing).parent(parent).timestamp(timestamp).version(version).versionType(versionType), +                        internalAdd(new IndexRequest(index, type, id).routing(routing).parent(parent).timestamp(timestamp).version(version).versionType(versionType), +                    internalAdd(new IndexRequest(index, type, id).routing(routing).parent(parent).timestamp(timestamp).version(version).versionType(versionType), +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/action/count/CountRequest.java, +        this.querySource = bos.underlyingBytes();, +            this.querySource = builder.underlyingBytes();, +            this.querySourceLength = builder.underlyingBytesLength();, +            this.querySourceUnsafe = false;, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/action/deletebyquery/DeleteByQueryRequest.java, +        this.querySource = bos.underlyingBytes();, +            this.querySource = builder.underlyingBytes();, +            this.querySourceLength = builder.underlyingBytesLength();, +            this.querySourceUnsafe = false;, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/action/index/IndexRequest.java, +        // only fork if copy over if source is unsafe, +        if (sourceUnsafe) {, +        if (sourceUnsafe || sourceOffset > 0 || source.length != sourceLength) {, +            source = sourceBuilder.underlyingBytes();, +            sourceLength = sourceBuilder.underlyingBytesLength();, +            sourceUnsafe = false;, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/action/mlt/MoreLikeThisRequest.java, +        this.searchSource = bos.underlyingBytes();, +            this.searchSource = builder.underlyingBytes();, +            this.searchSourceLength = builder.underlyingBytesLength();, +            this.searchSourceUnsafe = false;, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/action/bulk/BulkRequest.java]