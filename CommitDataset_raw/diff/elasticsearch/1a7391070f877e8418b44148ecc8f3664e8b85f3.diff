[+++ /dev/null, +++ /dev/null, +++ b/buildSrc/src/main/groovy/org/elasticsearch/gradle/test/ClusterFormationTasks.groovy, +        return project.tasks.create(name: name, type: Exec, dependsOn: setup) {, +            // only show output on failure, when not in info or debug mode, +            if (logger.isInfoEnabled() == false) {, +                standardOutput = new ByteArrayOutputStream(), +                errorOutput = standardOutput, +                ignoreExitValue = true, +                doLast {, +                    if (execResult.exitValue != 0) {, +                        logger.error(standardOutput.toString()), +                        throw new GradleException("Process '${execArgs.join(' ')}' finished with non-zero exit value ${execResult.exitValue}"), +                    }, +                }, +            }, +        return project.tasks.create(name: name, type: Exec, dependsOn: depends) {, +++ /dev/null, +++ b/buildSrc/src/main/groovy/org/elasticsearch/gradle/test/ClusterFormationTasks.groovy, +        return project.tasks.create(name: name, type: Exec, dependsOn: setup) {, +            // only show output on failure, when not in info or debug mode, +            if (logger.isInfoEnabled() == false) {, +                standardOutput = new ByteArrayOutputStream(), +                errorOutput = standardOutput, +                ignoreExitValue = true, +                doLast {, +                    if (execResult.exitValue != 0) {, +                        logger.error(standardOutput.toString()), +                        throw new GradleException("Process '${execArgs.join(' ')}' finished with non-zero exit value ${execResult.exitValue}"), +                    }, +                }, +            }, +        return project.tasks.create(name: name, type: Exec, dependsOn: depends) {, +++ b/core/src/main/java/org/elasticsearch/index/search/geo/GeoDistanceRangeQuery.java, +        return "GeoDistanceRangeFilter(" + indexFieldData.getFieldNames().indexName() + ", " + geoDistance + ", [" + inclusiveLowerPoint + " - " + inclusiveUpperPoint + "], " + lat + ", " + lon + ")";, +++ /dev/null, +++ b/buildSrc/src/main/groovy/org/elasticsearch/gradle/test/ClusterFormationTasks.groovy, +        return project.tasks.create(name: name, type: Exec, dependsOn: setup) {, +            // only show output on failure, when not in info or debug mode, +            if (logger.isInfoEnabled() == false) {, +                standardOutput = new ByteArrayOutputStream(), +                errorOutput = standardOutput, +                ignoreExitValue = true, +                doLast {, +                    if (execResult.exitValue != 0) {, +                        logger.error(standardOutput.toString()), +                        throw new GradleException("Process '${execArgs.join(' ')}' finished with non-zero exit value ${execResult.exitValue}"), +                    }, +                }, +            }, +        return project.tasks.create(name: name, type: Exec, dependsOn: depends) {, +++ b/core/src/main/java/org/elasticsearch/index/search/geo/GeoDistanceRangeQuery.java, +        return "GeoDistanceRangeFilter(" + indexFieldData.getFieldNames().indexName() + ", " + geoDistance + ", [" + inclusiveLowerPoint + " - " + inclusiveUpperPoint + "], " + lat + ", " + lon + ")";, +++ b/core/src/main/java/org/elasticsearch/index/search/geo/GeoPolygonQuery.java, +        StringBuilder sb = new StringBuilder("GeoPolygonFilter(");, +++ /dev/null, +++ b/buildSrc/src/main/groovy/org/elasticsearch/gradle/test/ClusterFormationTasks.groovy, +        return project.tasks.create(name: name, type: Exec, dependsOn: setup) {, +            // only show output on failure, when not in info or debug mode, +            if (logger.isInfoEnabled() == false) {, +                standardOutput = new ByteArrayOutputStream(), +                errorOutput = standardOutput, +                ignoreExitValue = true, +                doLast {, +                    if (execResult.exitValue != 0) {, +                        logger.error(standardOutput.toString()), +                        throw new GradleException("Process '${execArgs.join(' ')}' finished with non-zero exit value ${execResult.exitValue}"), +                    }, +                }, +            }, +        return project.tasks.create(name: name, type: Exec, dependsOn: depends) {, +++ b/core/src/main/java/org/elasticsearch/index/search/geo/GeoDistanceRangeQuery.java, +        return "GeoDistanceRangeFilter(" + indexFieldData.getFieldNames().indexName() + ", " + geoDistance + ", [" + inclusiveLowerPoint + " - " + inclusiveUpperPoint + "], " + lat + ", " + lon + ")";, +++ b/core/src/main/java/org/elasticsearch/index/search/geo/GeoPolygonQuery.java, +        StringBuilder sb = new StringBuilder("GeoPolygonFilter(");, +++ b/core/src/test/java/org/elasticsearch/search/aggregations/bucket/SignificantTermsBackwardCompatibilityIT.java, +import org.elasticsearch.action.index.IndexRequestBuilder;, +import org.elasticsearch.action.search.SearchResponse;, +import org.elasticsearch.search.aggregations.Aggregation;, +import org.elasticsearch.search.aggregations.bucket.significant.SignificantTerms;, +import org.elasticsearch.search.aggregations.bucket.significant.SignificantTermsBuilder;, +import org.elasticsearch.search.aggregations.bucket.terms.StringTerms;, +import org.elasticsearch.search.aggregations.bucket.terms.Terms;, +import org.elasticsearch.search.aggregations.bucket.terms.TermsBuilder;, +import java.util.ArrayList;, +import java.util.List;, +import java.util.Map;, +import static org.elasticsearch.test.hamcrest.ElasticsearchAssertions.assertAcked;, +import static org.elasticsearch.test.hamcrest.ElasticsearchAssertions.assertSearchResponse;, +import static org.hamcrest.Matchers.equalTo;, +, +/**, + */, +    static final String INDEX_NAME = "testidx";, +    static final String DOC_TYPE = "doc";, +    static final String TEXT_FIELD = "text";, +    static final String CLASS_FIELD = "class";, +, +    public void testBucketStreaming() throws IOException, ExecutionException, InterruptedException {, +        logger.debug("testBucketStreaming: indexing documents");]