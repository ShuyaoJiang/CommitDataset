[+++ b/core/src/main/java/org/elasticsearch/action/support/master/TransportMasterNodeAction.java, +import org.elasticsearch.cluster.ClusterChangedEvent;, +    private static final ClusterStateObserver.ChangePredicate masterNodeChangedPredicate = new ClusterStateObserver.ChangePredicate() {, +        @Override, +        public boolean apply(ClusterState previousState, ClusterState.ClusterStateStatus previousStatus,, +                             ClusterState newState, ClusterState.ClusterStateStatus newStatus) {, +            // The condition !newState.nodes().masterNodeId().equals(previousState.nodes().masterNodeId()) is not sufficient as the same master node might get reelected after a disruption., +            return newState.nodes().masterNodeId() != null && newState != previousState;, +        }, +, +        @Override, +        public boolean apply(ClusterChangedEvent event) {, +            return event.nodesDelta().masterNodeChanged();, +        }, +    };, +, +                                retry(t, masterNodeChangedPredicate);, +                    retry(null, masterNodeChangedPredicate);, +                                retry(cause, masterNodeChangedPredicate);, +++ b/core/src/main/java/org/elasticsearch/action/support/master/TransportMasterNodeAction.java, +import org.elasticsearch.cluster.ClusterChangedEvent;, +    private static final ClusterStateObserver.ChangePredicate masterNodeChangedPredicate = new ClusterStateObserver.ChangePredicate() {, +        @Override, +        public boolean apply(ClusterState previousState, ClusterState.ClusterStateStatus previousStatus,, +                             ClusterState newState, ClusterState.ClusterStateStatus newStatus) {, +            // The condition !newState.nodes().masterNodeId().equals(previousState.nodes().masterNodeId()) is not sufficient as the same master node might get reelected after a disruption., +            return newState.nodes().masterNodeId() != null && newState != previousState;, +        }, +, +        @Override, +        public boolean apply(ClusterChangedEvent event) {, +            return event.nodesDelta().masterNodeChanged();, +        }, +    };, +, +                                retry(t, masterNodeChangedPredicate);, +                    retry(null, masterNodeChangedPredicate);, +                                retry(cause, masterNodeChangedPredicate);, +++ /dev/null, +++ b/core/src/main/java/org/elasticsearch/action/support/master/TransportMasterNodeAction.java, +import org.elasticsearch.cluster.ClusterChangedEvent;, +    private static final ClusterStateObserver.ChangePredicate masterNodeChangedPredicate = new ClusterStateObserver.ChangePredicate() {, +        @Override, +        public boolean apply(ClusterState previousState, ClusterState.ClusterStateStatus previousStatus,, +                             ClusterState newState, ClusterState.ClusterStateStatus newStatus) {, +            // The condition !newState.nodes().masterNodeId().equals(previousState.nodes().masterNodeId()) is not sufficient as the same master node might get reelected after a disruption., +            return newState.nodes().masterNodeId() != null && newState != previousState;, +        }, +, +        @Override, +        public boolean apply(ClusterChangedEvent event) {, +            return event.nodesDelta().masterNodeChanged();, +        }, +    };, +, +                                retry(t, masterNodeChangedPredicate);, +                    retry(null, masterNodeChangedPredicate);, +                                retry(cause, masterNodeChangedPredicate);, +++ /dev/null, +++ b/core/src/main/java/org/elasticsearch/common/SearchScrollIterator.java, +/*, + * Licensed to Elasticsearch under one or more contributor, + * license agreements. See the NOTICE file distributed with, + * this work for additional information regarding copyright, + * ownership. Elasticsearch licenses this file to you under, + * the Apache License, Version 2.0 (the "License"); you may, + * not use this file except in compliance with the License., + * You may obtain a copy of the License at, + *, + *    http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing,, + * software distributed under the License is distributed on an, + * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY, + * KIND, either express or implied.  See the License for the, + * specific language governing permissions and limitations, + * under the License., + */, +, +package org.elasticsearch.common;, +, +import org.elasticsearch.action.search.SearchRequest;, +import org.elasticsearch.action.search.SearchResponse;, +import org.elasticsearch.action.search.SearchScrollRequest;, +import org.elasticsearch.client.Client;, +import org.elasticsearch.common.unit.TimeValue;, +import org.elasticsearch.search.SearchHit;, +, +import java.util.Collections;, +import java.util.Iterator;, +, +/**, + * An iterator that easily helps to consume all hits from a scroll search., + */, +public final class SearchScrollIterator implements Iterator<SearchHit> {, +, +    /**, +     * Creates an iterator that returns all matching hits of a scroll search via an iterator., +     * The iterator will return all hits per scroll search and execute additional scroll searches, +     * to get more hits until all hits have been returned by the scroll search on the ES side.]