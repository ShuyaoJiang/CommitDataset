[+++ b/server/src/main/java/org/elasticsearch/common/rounding/Rounding.java, +        private boolean unitRoundsToMidnight;, +            unitRoundsToMidnight = this.field.getDurationField().getUnitMillis() > 60L * 60L * 1000L;, +        /**, +         * @return The latest timestamp T which is strictly before utcMillis, +         * and such that timeZone.getOffset(T) != timeZone.getOffset(utcMillis)., +         * If there is no such T, returns Long.MAX_VALUE., +         */, +        private long previousTransition(long utcMillis) {, +            final int offsetAtInputTime = timeZone.getOffset(utcMillis);, +            do {, +                // Some timezones have transitions that do not change the offset, so we have to, +                // repeatedly call previousTransition until a nontrivial transition is found., +, +                long previousTransition = timeZone.previousTransition(utcMillis);, +                if (previousTransition == utcMillis) {, +                    // There are no earlier transitions, +                    return Long.MAX_VALUE;, +                }, +                assert previousTransition < utcMillis; // Progress was made, +                utcMillis = previousTransition;, +            } while (timeZone.getOffset(utcMillis) == offsetAtInputTime);, +, +            return utcMillis;, +        }, +, +, +            // field.roundFloor() works as long as the offset doesn't change.  It is worth getting this case out of the way first, as, +            // the calculations for fixing things near to offset changes are a little expensive and are unnecessary in the common case, +            // of working in UTC., +            if (timeZone.isFixed()) {, +                return field.roundFloor(utcMillis);, +            }, +, +            // When rounding to hours we consider any local time of the form 'xx:00:00' as rounded, even though this gives duplicate, +            // bucket names for the times when the clocks go back. Shorter units behave similarly. However, longer units round down to, +            // midnight, and on the days where there are two midnights we would rather pick the earlier one, so that buckets are, +            // uniquely identified by the date., +            if (unitRoundsToMidnight) {, +                final long anyLocalStartOfDay = field.roundFloor(utcMillis);, +                // `anyLocalStartOfDay` is _supposed_ to be the Unix timestamp for the start of the day in question in the current time, +                // zone.  Mostly this just means "midnight", which is fine, and on days with no local midnight it's the first time that, +                // does occur on that day which is also ok. However, on days with >1 local midnight this is _one_ of the midnights, but, +                // may not be the first. Check whether this is happening, and fix it if so., +, +                final long previousTransition = previousTransition(anyLocalStartOfDay);, +, +                if (previousTransition == Long.MAX_VALUE) {, +                    // No previous transitions, so there can't be another earlier local midnight., +                    return anyLocalStartOfDay;, +                }, +, +                final long currentOffset = timeZone.getOffset(anyLocalStartOfDay);, +                final long previousOffset = timeZone.getOffset(previousTransition);, +                assert currentOffset != previousOffset;, +, +                // NB we only assume interference from one previous transition. It's theoretically possible to have two transitions in, +                // quick succession, both of which have a midnight in them, but this doesn't appear to happen in the TZDB so (a) it's, +                // pointless to implement and (b) it won't be tested. I recognise that this comment is tempting fate and will likely, +                // cause this very situation to occur in the near future, and eagerly look forward to fixing this using a loop over, +                // previous transitions when it happens., +, +                final long alsoLocalStartOfDay = anyLocalStartOfDay + currentOffset - previousOffset;, +                // `alsoLocalStartOfDay` is the Unix timestamp for the start of the day in question if the previous offset were in, +                // effect., +, +                if (alsoLocalStartOfDay <= previousTransition) {, +                    // Therefore the previous offset _is_ in effect at `alsoLocalStartOfDay`, and it's earlier than anyLocalStartOfDay,, +                    // so this is the answer to use., +                    return alsoLocalStartOfDay;, +                }, +                else {, +                    // The previous offset is not in effect at `alsoLocalStartOfDay`, so the current offset must be., +                    return anyLocalStartOfDay;, +                }, +, +                do {, +                    long rounded = field.roundFloor(utcMillis);, +, +                    // field.roundFloor() mostly works as long as the offset hasn't changed in [rounded, utcMillis], so look at where, +                    // the offset most recently changed., +, +                    final long previousTransition = previousTransition(utcMillis);, +, +                    if (previousTransition == Long.MAX_VALUE || previousTransition < rounded) {, +                        // The offset did not change in [rounded, utcMillis], so roundFloor() worked as expected., +                    // The offset _did_ change in [rounded, utcMillis]. Put differently, this means that none of the times in, +                    // [previousTransition+1, utcMillis] were rounded, so the rounded time must be <= previousTransition.  This means, +                    // it's sufficient to try and round previousTransition down., +                    assert previousTransition < utcMillis;, +                    utcMillis = previousTransition;, +                } while (true);, +            }, +        }, +, +            unitRoundsToMidnight = field.getDurationField().getUnitMillis() > 60L * 60L * 1000L;, +++ b/server/src/main/java/org/elasticsearch/common/rounding/Rounding.java, +        private boolean unitRoundsToMidnight;, +            unitRoundsToMidnight = this.field.getDurationField().getUnitMillis() > 60L * 60L * 1000L;, +        /**]