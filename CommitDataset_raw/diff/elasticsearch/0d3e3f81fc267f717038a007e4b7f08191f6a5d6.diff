[+++ b/core/src/main/java/org/apache/lucene/queries/MinDocQuery.java, +            public Scorer scorer(LeafReaderContext context) throws IOException {, +++ b/core/src/main/java/org/apache/lucene/queries/MinDocQuery.java, +            public Scorer scorer(LeafReaderContext context) throws IOException {, +++ b/core/src/main/java/org/apache/lucene/queryparser/classic/MapperQueryParser.java, +                        q = applySlop(q, slop);, +                        q = applySlop(q, slop);, +    private Query applySlop(Query q, int slop) {, +            PhraseQuery pq = (PhraseQuery) q;, +            PhraseQuery.Builder builder = new PhraseQuery.Builder();, +            builder.setSlop(slop);, +            final Term[] terms = pq.getTerms();, +            final int[] positions = pq.getPositions();, +            for (int i = 0; i < terms.length; ++i) {, +                builder.add(terms[i], positions[i]);, +            }, +            pq = builder.build();, +            pq.setBoost(q.getBoost());, +            return pq;, +            return q;, +        } else {, +            return q;, +++ b/core/src/main/java/org/apache/lucene/queries/MinDocQuery.java, +            public Scorer scorer(LeafReaderContext context) throws IOException {, +++ b/core/src/main/java/org/apache/lucene/queryparser/classic/MapperQueryParser.java, +                        q = applySlop(q, slop);, +                        q = applySlop(q, slop);, +    private Query applySlop(Query q, int slop) {, +            PhraseQuery pq = (PhraseQuery) q;, +            PhraseQuery.Builder builder = new PhraseQuery.Builder();, +            builder.setSlop(slop);, +            final Term[] terms = pq.getTerms();, +            final int[] positions = pq.getPositions();, +            for (int i = 0; i < terms.length; ++i) {, +                builder.add(terms[i], positions[i]);, +            }, +            pq = builder.build();, +            pq.setBoost(q.getBoost());, +            return pq;, +            return q;, +        } else {, +            return q;, +++ /dev/null, +++ b/core/src/main/java/org/apache/lucene/queries/MinDocQuery.java, +            public Scorer scorer(LeafReaderContext context) throws IOException {, +++ b/core/src/main/java/org/apache/lucene/queryparser/classic/MapperQueryParser.java, +                        q = applySlop(q, slop);, +                        q = applySlop(q, slop);, +    private Query applySlop(Query q, int slop) {, +            PhraseQuery pq = (PhraseQuery) q;, +            PhraseQuery.Builder builder = new PhraseQuery.Builder();, +            builder.setSlop(slop);, +            final Term[] terms = pq.getTerms();, +            final int[] positions = pq.getPositions();, +            for (int i = 0; i < terms.length; ++i) {, +                builder.add(terms[i], positions[i]);, +            }, +            pq = builder.build();, +            pq.setBoost(q.getBoost());, +            return pq;, +            return q;, +        } else {, +            return q;, +++ /dev/null, +++ b/core/src/main/java/org/apache/lucene/search/suggest/analyzing/XAnalyzingSuggester.java, +import org.apache.lucene.util.automaton.LimitedFiniteStringsIterator;, +      for (BytesRef surfaceForm; (surfaceForm = iterator.next()) != null;) {, +        LimitedFiniteStringsIterator finiteStrings =, +                new LimitedFiniteStringsIterator(toAutomaton(surfaceForm, ts2a), maxGraphExpansions);, +        for (IntsRef string; (string = finiteStrings.next()) != null; count++) {, +          Util.toBytesRef(string, scratch);, +        maxAnalyzedPathsForOneInput = Math.max(maxAnalyzedPathsForOneInput, finiteStrings.size());, +  final Automaton toAutomaton(final BytesRef surfaceForm, final TokenStreamToAutomaton ts2a) throws IOException {, +      try (TokenStream ts = indexAnalyzer.tokenStream("", surfaceForm.utf8ToString())) {, +          return toAutomaton(ts, ts2a);, +      }, +  final Automaton toAutomaton(TokenStream ts, final TokenStreamToAutomaton ts2a) throws IOException {, +      Automaton automaton = ts2a.toAutomaton(ts);, +      return automaton;, +  }, +  // EDIT: Adrien, needed by lookup providers, +  // NOTE: these XForks are unmaintainable, we need to get rid of them..., +  public Set<IntsRef> toFiniteStrings(TokenStream stream) throws IOException {, +      final TokenStreamToAutomaton ts2a = getTokenStreamToAutomaton();, +      Automaton automaton;, +      try (TokenStream ts = stream) {, +          automaton = toAutomaton(ts, ts2a);, +      }, +      LimitedFiniteStringsIterator finiteStrings =, +              new LimitedFiniteStringsIterator(automaton, maxGraphExpansions);, +      Set<IntsRef> set = new HashSet<>();, +      for (IntsRef string = finiteStrings.next(); string != null; string = finiteStrings.next()) {, +          set.add(IntsRef.deepCopyOf(string));, +      }, +      return Collections.unmodifiableSet(set);, +++ b/core/src/main/java/org/apache/lucene/queries/MinDocQuery.java, +            public Scorer scorer(LeafReaderContext context) throws IOException {, +++ b/core/src/main/java/org/apache/lucene/queryparser/classic/MapperQueryParser.java, +                        q = applySlop(q, slop);, +                        q = applySlop(q, slop);]