[+++ b/src/main/java/org/elasticsearch/client/transport/TransportClient.java, +import org.elasticsearch.transport.netty.NettyTransport;, +        Settings settings = settingsBuilder(), +                .put(NettyTransport.PING_SCHEDULE, "5s") // enable by default the transport schedule ping interval, +                .put(tuple.v1()), +++ b/src/main/java/org/elasticsearch/client/transport/TransportClient.java, +import org.elasticsearch.transport.netty.NettyTransport;, +        Settings settings = settingsBuilder(), +                .put(NettyTransport.PING_SCHEDULE, "5s") // enable by default the transport schedule ping interval, +                .put(tuple.v1()), +++ b/src/main/java/org/elasticsearch/transport/netty/NettyHeader.java, +import org.jboss.netty.buffer.ChannelBuffers;, +    /**, +     * The magic number (must be lower than 0) for a ping message. This is handled, +     * specifically in {@link org.elasticsearch.transport.netty.SizeHeaderFrameDecoder}., +     */, +    public static final int PING_DATA_SIZE = -1;, +    private final static ChannelBuffer pingHeader;, +    static {, +        pingHeader = ChannelBuffers.buffer(6);, +        pingHeader.writeByte('E');, +        pingHeader.writeByte('S');, +        pingHeader.writeInt(PING_DATA_SIZE);, +    }, +, +    /**, +     * A ping header is same as regular header, just with -1 for the size of the message., +     */, +    public static ChannelBuffer pingHeader() {, +        return pingHeader.duplicate();, +    }, +, +++ b/src/main/java/org/elasticsearch/client/transport/TransportClient.java, +import org.elasticsearch.transport.netty.NettyTransport;, +        Settings settings = settingsBuilder(), +                .put(NettyTransport.PING_SCHEDULE, "5s") // enable by default the transport schedule ping interval, +                .put(tuple.v1()), +++ b/src/main/java/org/elasticsearch/transport/netty/NettyHeader.java, +import org.jboss.netty.buffer.ChannelBuffers;, +    /**, +     * The magic number (must be lower than 0) for a ping message. This is handled, +     * specifically in {@link org.elasticsearch.transport.netty.SizeHeaderFrameDecoder}., +     */, +    public static final int PING_DATA_SIZE = -1;, +    private final static ChannelBuffer pingHeader;, +    static {, +        pingHeader = ChannelBuffers.buffer(6);, +        pingHeader.writeByte('E');, +        pingHeader.writeByte('S');, +        pingHeader.writeInt(PING_DATA_SIZE);, +    }, +, +    /**, +     * A ping header is same as regular header, just with -1 for the size of the message., +     */, +    public static ChannelBuffer pingHeader() {, +        return pingHeader.duplicate();, +    }, +, +++ b/src/main/java/org/elasticsearch/transport/netty/NettyTransport.java, +import org.elasticsearch.common.metrics.CounterMetric;, +import java.util.concurrent.atomic.AtomicLong;, +    public static final String PING_SCHEDULE = "transport.ping_schedule"; // the scheduled internal ping interval setting, +    public static final TimeValue DEFAULT_PING_SCHEDULE = TimeValue.timeValueMillis(-1); // the default ping schedule, defaults to disabled (-1), +    private final TimeValue pingSchedule;, +, +    // package visibility for tests, +    final ScheduledPing scheduledPing;, +, +, +        this.scheduledPing = new ScheduledPing();, +        this.pingSchedule = settings.getAsTime(PING_SCHEDULE, DEFAULT_PING_SCHEDULE);, +        if (pingSchedule.millis() > 0) {, +            threadPool.schedule(pingSchedule, ThreadPool.Names.GENERIC, scheduledPing);, +        }, +                    nodeChannels.start();, +        ImmutableList<Channel> allChannels = ImmutableList.of();, +        public void start() {, +            this.allChannels = ImmutableList.<Channel>builder().add(recovery).add(bulk).add(reg).add(state).add(ping).build();, +        public boolean hasChannel(Channel channel) {, +            for (Channel channel1 : allChannels) {, +            for (Channel channel : allChannels) {, +            for (ChannelFuture future : futures) {, +                future.awaitUninterruptibly();, +            }, +        }, +    }, +, +    class ScheduledPing implements Runnable {, +, +        final CounterMetric successfulPings = new CounterMetric();, +        final CounterMetric failedPings = new CounterMetric();, +, +        @Override, +        public void run() {, +            if (lifecycle.stoppedOrClosed()) {, +                return;, +            }, +            for (Map.Entry<DiscoveryNode, NodeChannels> entry : connectedNodes.entrySet()) {, +                DiscoveryNode node = entry.getKey();]