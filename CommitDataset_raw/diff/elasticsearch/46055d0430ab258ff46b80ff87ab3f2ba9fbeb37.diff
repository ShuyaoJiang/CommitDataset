[+++ b/dev-tools/ci, +# Set the default gradle parameters for running tests, +gradleoptstring="--info check -Dtests.network=true -Dtests.badapples=true", +, +while [ $# -ge 1 ], +do, +key="$1", +case $key in, +    -g|--gradleoptstring), +        gradleoptstring="$2", +        shift 2;;, +    -h|--help), +        echo -e "Syntax:\n", +        echo -e "$0 [-g|--gradleoptstring] \"override gradle parameters for tests\"\n", +        exit 0;;, +    *), +        echo "Unknown argument: $key";, +        exit 1;;, +esac, +done, +, +gradle $gradleoptstring, +++ b/dev-tools/ci, +# Set the default gradle parameters for running tests, +gradleoptstring="--info check -Dtests.network=true -Dtests.badapples=true", +, +while [ $# -ge 1 ], +do, +key="$1", +case $key in, +    -g|--gradleoptstring), +        gradleoptstring="$2", +        shift 2;;, +    -h|--help), +        echo -e "Syntax:\n", +        echo -e "$0 [-g|--gradleoptstring] \"override gradle parameters for tests\"\n", +        exit 0;;, +    *), +        echo "Unknown argument: $key";, +        exit 1;;, +esac, +done, +, +gradle $gradleoptstring, +++ b/elasticsearch/src/test/java/org/elasticsearch/xpack/monitoring/OldMonitoringIndicesBackwardsCompatibilityTests.java, +import com.carrotsearch.randomizedtesting.annotations.ThreadLeakLingering;, +, +//Give ourselves 30 seconds instead o 5 to shut down. Sometimes it takes a while, especially on weak hardware. But we do get there., +@ThreadLeakLingering(linger = 30000), +                // Speed up the exporter so we don't have to wait around for it, +                .put(MonitoringSettings.INTERVAL.getKey(), timeValueSeconds(1).getStringRep());, +            checkVersionInternal(version);, +        } finally {, +            /* Shut down monitoring after every test because we've shrunk the collection interval enough that we'll have trouble shutting, +             * down cleanly unless we force monitoring to stop. */, +            internalCluster().getInstance(AgentService.class).stop();, +        }, +    private void checkVersionInternal(Version version) throws Exception {, +        if (version.before(Version.V_2_3_0)) {, +            // Slow down monitoring from its previously super fast pace so we can shut down without trouble, +            Settings.Builder settings = Settings.builder(), +                    .put(MonitoringSettings.INTERVAL.getKey(), timeValueSeconds(10).getStringRep());, +            /* We can't do anything with indexes created before 2.3 so we just assert that we didn't delete them or do anything otherwise, +             * crazy. */, +         * Monitoring doesn't really have a Java API so we can't test that, but we can test that we write the data we expected to write. */, +, +        if (httpExporter) {, +            // If we're using the http exporter we need feed it the port and enable it, +            NodesInfoResponse nodeInfos = client().admin().cluster().prepareNodesInfo().get();, +            TransportAddress publishAddress = nodeInfos.getNodes().get(0).getHttp().address().publishAddress();, +            InetSocketAddress address = publishAddress.address();, +            Settings.Builder settings = Settings.builder();, +            setupHttpExporter(settings, address.getPort());, +            logger.info("--> Enabling http exporter pointing to [localhost:{}]", address.getPort());, +            client().admin().cluster().prepareUpdateSettings().setTransientSettings(settings).get();, +        }, +, +        IndexStatsResolver resolver = new IndexStatsResolver(MonitoredSystem.ES, Settings.EMPTY);, +        logger.info("--> {} Waiting for [{}]", Thread.currentThread().getName(), resolver.indexPattern());, +        assertBusy(() -> assertTrue(client().admin().indices().prepareExists(resolver.indexPattern()).get().isExists()));, +        // Slow down monitoring from its previously super fast pace so we can shut down without trouble, +        Settings.Builder settings = Settings.builder(), +                .put(MonitoringSettings.INTERVAL.getKey(), timeValueSeconds(10).getStringRep());, +        assertAcked(client().admin().cluster().prepareUpdateSettings().setTransientSettings(settings).get());, +        SearchResponse firstIndicesStats = search(new IndicesStatsResolver(MonitoredSystem.ES, Settings.EMPTY), greaterThanOrEqualTo(3L));, +        SearchResponse firstNodeStats = search(new NodeStatsResolver(MonitoredSystem.ES, Settings.EMPTY), greaterThanOrEqualTo(3L));, +        SearchResponse firstClusterState = search(new ClusterStateResolver(MonitoredSystem.ES, Settings.EMPTY), greaterThanOrEqualTo(3L));, +        Arrays.stream(firstIndicesStats.getHits().hits()).forEach(hit -> checkIndicesStats(version, hit.sourceAsMap()));, +        Arrays.stream(firstNodeStats.getHits().hits()).forEach(hit -> checkNodeStats(version, masterNodeId, hit.sourceAsMap()));, +        Arrays.stream(firstClusterState.getHits().hits()).forEach(hit -> checkClusterState(version, hit.sourceAsMap()));, +                greaterThan(firstIndicesStats.getHits().totalHits())), 1, TimeUnit.MINUTES);, +                greaterThan(firstNodeStats.getHits().totalHits())), 1, TimeUnit.MINUTES);, +                greaterThan(firstClusterState.getHits().totalHits())), 1, TimeUnit.MINUTES);]