[+++ b/src/main/java/org/elasticsearch/alerts/AlertManager.java, +        manuallyStopped = !settings.getAsBoolean("alerts.start_immediately",  true);, +++ b/src/main/java/org/elasticsearch/alerts/AlertManager.java, +        manuallyStopped = !settings.getAsBoolean("alerts.start_immediately",  true);, +++ b/src/main/java/org/elasticsearch/alerts/AlertingModule.java, +import org.elasticsearch.alerts.transport.actions.config.TransportConfigAlertAction;, +        bind(TransportConfigAlertAction.class).asEagerSingleton();, +++ b/src/main/java/org/elasticsearch/alerts/AlertManager.java, +        manuallyStopped = !settings.getAsBoolean("alerts.start_immediately",  true);, +++ b/src/main/java/org/elasticsearch/alerts/AlertingModule.java, +import org.elasticsearch.alerts.transport.actions.config.TransportConfigAlertAction;, +        bind(TransportConfigAlertAction.class).asEagerSingleton();, +++ b/src/main/java/org/elasticsearch/alerts/AlertsStore.java, +    private final int scrollSize;, +    private final TimeValue scrollTimeout;, +        // Not using component settings, to let AlertsStore and AlertActionManager share the same settings, +        this.scrollTimeout = settings.getAsTime("alerts.scroll.timeout", TimeValue.timeValueSeconds(30));, +        this.scrollSize = settings.getAsInt("alerts.scroll.size", 100);, +, +        if (!configurationManager.isReady(state)) {, +++ b/src/main/java/org/elasticsearch/alerts/AlertManager.java, +        manuallyStopped = !settings.getAsBoolean("alerts.start_immediately",  true);, +++ b/src/main/java/org/elasticsearch/alerts/AlertingModule.java, +import org.elasticsearch.alerts.transport.actions.config.TransportConfigAlertAction;, +        bind(TransportConfigAlertAction.class).asEagerSingleton();, +++ b/src/main/java/org/elasticsearch/alerts/AlertsStore.java, +    private final int scrollSize;, +    private final TimeValue scrollTimeout;, +        // Not using component settings, to let AlertsStore and AlertActionManager share the same settings, +        this.scrollTimeout = settings.getAsTime("alerts.scroll.timeout", TimeValue.timeValueSeconds(30));, +        this.scrollSize = settings.getAsInt("alerts.scroll.size", 100);, +, +        if (!configurationManager.isReady(state)) {, +++ b/src/main/java/org/elasticsearch/alerts/ConfigurableComponentListener.java, +/*, + * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one, + * or more contributor license agreements. Licensed under the Elastic License;, + * you may not use this file except in compliance with the Elastic License., + */, +package org.elasticsearch.alerts;, +, +import org.elasticsearch.common.settings.Settings;, +, +/**, + * This interface allows a component to register itself for configuration updates, + */, +public interface ConfigurableComponentListener {, +    void receiveConfigurationUpdate(Settings settings);, +}, +++ b/src/main/java/org/elasticsearch/alerts/AlertManager.java, +        manuallyStopped = !settings.getAsBoolean("alerts.start_immediately",  true);, +++ b/src/main/java/org/elasticsearch/alerts/AlertingModule.java, +import org.elasticsearch.alerts.transport.actions.config.TransportConfigAlertAction;, +        bind(TransportConfigAlertAction.class).asEagerSingleton();, +++ b/src/main/java/org/elasticsearch/alerts/AlertsStore.java, +    private final int scrollSize;, +    private final TimeValue scrollTimeout;, +        // Not using component settings, to let AlertsStore and AlertActionManager share the same settings, +        this.scrollTimeout = settings.getAsTime("alerts.scroll.timeout", TimeValue.timeValueSeconds(30));, +        this.scrollSize = settings.getAsInt("alerts.scroll.size", 100);, +, +        if (!configurationManager.isReady(state)) {, +++ b/src/main/java/org/elasticsearch/alerts/ConfigurableComponentListener.java, +/*, + * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one, + * or more contributor license agreements. Licensed under the Elastic License;, + * you may not use this file except in compliance with the Elastic License., + */, +package org.elasticsearch.alerts;, +, +import org.elasticsearch.common.settings.Settings;, +, +/**, + * This interface allows a component to register itself for configuration updates, + */, +public interface ConfigurableComponentListener {, +    void receiveConfigurationUpdate(Settings settings);, +}, +++ b/src/main/java/org/elasticsearch/alerts/ConfigurationManager.java, +import org.elasticsearch.common.bytes.BytesReference;, +import org.elasticsearch.common.collect.ImmutableOpenMap;, +import org.elasticsearch.common.xcontent.XContentHelper;, +import java.util.List;, +import java.util.concurrent.CopyOnWriteArrayList;, +    private volatile ImmutableOpenMap<String, List<ConfigurableComponentListener>> componentNameToListener;, +        componentNameToListener = ImmutableOpenMap.<String, List<ConfigurableComponentListener>>builder().build();, +     * Notify the listeners of a new config, +     * @param componentName, +     * @param settingsSource, +    public void newConfig(String componentName, BytesReference settingsSource) {, +        Map<String, Object> settingsMap = XContentHelper.convertToMap(settingsSource, true).v2();, +        ImmutableSettings.Builder settingsBuilder = ImmutableSettings.builder();, +        for (Map.Entry<String, Object> configEntry : settingsMap.entrySet() ) {, +            settingsBuilder.put(configEntry.getKey(), configEntry.getValue());, +        }, +        Settings settings = settingsBuilder.build();, +        for (ConfigurableComponentListener componentListener : componentNameToListener.get(componentName)) {, +            componentListener.receiveConfigurationUpdate(settings);, +, +    /**]