[+++ b/modules/rank-eval/src/main/java/org/elasticsearch/index/rankeval/DiscountedCumulativeGainAt.java, +import java.util.Optional;, +        Map<RatedDocumentKey, RatedDocument> ratedDocsByKey = new HashMap<>(ratedDocs.size());, +        List<Integer> allRatings = new ArrayList<>(ratedDocs.size());, +            allRatings.add(doc.getRating());, +        List<RatedSearchHit> hitsAndRatings = new ArrayList<>();, +        List<Integer> ratingsInSearchHits = new ArrayList<>();, +                ratingsInSearchHits.add(ratedDoc.getRating());, +                hitsAndRatings.add(new RatedSearchHit(hits[i], Optional.of(ratedDoc.getRating())));, +                    ratingsInSearchHits.add(unknownDocRating);, +                    hitsAndRatings.add(new RatedSearchHit(hits[i], Optional.of(unknownDocRating)));, +                    ratingsInSearchHits.add(null);, +                    hitsAndRatings.add(new RatedSearchHit(hits[i], Optional.empty()));, +        double dcg = computeDCG(ratingsInSearchHits);, +            Collections.sort(allRatings, Comparator.nullsLast(Collections.reverseOrder()));, +            double idcg = computeDCG(allRatings.subList(0, Math.min(hits.length, allRatings.size())));, +        EvalQueryQuality evalQueryQuality = new EvalQueryQuality(taskId, dcg, unknownDocIds);, +        evalQueryQuality.addHitsAndRatings(hitsAndRatings);, +        return evalQueryQuality;, +++ b/modules/rank-eval/src/main/java/org/elasticsearch/index/rankeval/DiscountedCumulativeGainAt.java, +import java.util.Optional;, +        Map<RatedDocumentKey, RatedDocument> ratedDocsByKey = new HashMap<>(ratedDocs.size());, +        List<Integer> allRatings = new ArrayList<>(ratedDocs.size());, +            allRatings.add(doc.getRating());, +        List<RatedSearchHit> hitsAndRatings = new ArrayList<>();, +        List<Integer> ratingsInSearchHits = new ArrayList<>();, +                ratingsInSearchHits.add(ratedDoc.getRating());, +                hitsAndRatings.add(new RatedSearchHit(hits[i], Optional.of(ratedDoc.getRating())));, +                    ratingsInSearchHits.add(unknownDocRating);, +                    hitsAndRatings.add(new RatedSearchHit(hits[i], Optional.of(unknownDocRating)));, +                    ratingsInSearchHits.add(null);, +                    hitsAndRatings.add(new RatedSearchHit(hits[i], Optional.empty()));, +        double dcg = computeDCG(ratingsInSearchHits);, +            Collections.sort(allRatings, Comparator.nullsLast(Collections.reverseOrder()));, +            double idcg = computeDCG(allRatings.subList(0, Math.min(hits.length, allRatings.size())));, +        EvalQueryQuality evalQueryQuality = new EvalQueryQuality(taskId, dcg, unknownDocIds);, +        evalQueryQuality.addHitsAndRatings(hitsAndRatings);, +        return evalQueryQuality;, +++ b/modules/rank-eval/src/main/java/org/elasticsearch/index/rankeval/EvalQueryQuality.java, +import java.util.ArrayList;, +    private List<RatedSearchHit> hits = new ArrayList<>();, +        this.hits = in.readList(RatedSearchHit::new);, +    @Override, +    public void writeTo(StreamOutput out) throws IOException {, +        out.writeString(id);, +        out.writeDouble(qualityLevel);, +        out.writeList(unknownDocs);, +        out.writeList(hits);, +        out.writeOptionalNamedWriteable(this.optionalMetricDetails);, +    }, +, +    public void addHitsAndRatings(List<RatedSearchHit> hits) {, +        this.hits = hits;, +, +    public List<RatedSearchHit> getHitsAndRatings() {, +        return this.hits;, +        builder.startArray("hits");, +        for (RatedSearchHit hit : hits) {, +            hit.toXContent(builder, params);, +        }, +        builder.endArray();, +                Objects.equals(hits, other.hits) &&, +        return Objects.hash(id, qualityLevel, unknownDocs, hits, optionalMetricDetails);, +++ b/modules/rank-eval/src/main/java/org/elasticsearch/index/rankeval/DiscountedCumulativeGainAt.java, +import java.util.Optional;, +        Map<RatedDocumentKey, RatedDocument> ratedDocsByKey = new HashMap<>(ratedDocs.size());, +        List<Integer> allRatings = new ArrayList<>(ratedDocs.size());, +            allRatings.add(doc.getRating());, +        List<RatedSearchHit> hitsAndRatings = new ArrayList<>();, +        List<Integer> ratingsInSearchHits = new ArrayList<>();, +                ratingsInSearchHits.add(ratedDoc.getRating());, +                hitsAndRatings.add(new RatedSearchHit(hits[i], Optional.of(ratedDoc.getRating())));, +                    ratingsInSearchHits.add(unknownDocRating);, +                    hitsAndRatings.add(new RatedSearchHit(hits[i], Optional.of(unknownDocRating)));, +                    ratingsInSearchHits.add(null);, +                    hitsAndRatings.add(new RatedSearchHit(hits[i], Optional.empty()));, +        double dcg = computeDCG(ratingsInSearchHits);, +            Collections.sort(allRatings, Comparator.nullsLast(Collections.reverseOrder()));, +            double idcg = computeDCG(allRatings.subList(0, Math.min(hits.length, allRatings.size())));, +        EvalQueryQuality evalQueryQuality = new EvalQueryQuality(taskId, dcg, unknownDocIds);, +        evalQueryQuality.addHitsAndRatings(hitsAndRatings);, +        return evalQueryQuality;, +++ b/modules/rank-eval/src/main/java/org/elasticsearch/index/rankeval/EvalQueryQuality.java, +import java.util.ArrayList;, +    private List<RatedSearchHit> hits = new ArrayList<>();, +        this.hits = in.readList(RatedSearchHit::new);, +    @Override, +    public void writeTo(StreamOutput out) throws IOException {, +        out.writeString(id);, +        out.writeDouble(qualityLevel);, +        out.writeList(unknownDocs);, +        out.writeList(hits);, +        out.writeOptionalNamedWriteable(this.optionalMetricDetails);, +    }, +, +    public void addHitsAndRatings(List<RatedSearchHit> hits) {, +        this.hits = hits;, +, +    public List<RatedSearchHit> getHitsAndRatings() {, +        return this.hits;]