[+++ b/build.gradle, +    ant.delete { fileset(dir: explodedDistLibDir, includes: "jackson-*.jar") } // no need jackson, we jarjar it, +    ant.delete { fileset(dir: explodedDistLibDir, includes: "joda-*.jar") } // no need joda, we jarjar it, +++ b/build.gradle, +    ant.delete { fileset(dir: explodedDistLibDir, includes: "jackson-*.jar") } // no need jackson, we jarjar it, +    ant.delete { fileset(dir: explodedDistLibDir, includes: "joda-*.jar") } // no need joda, we jarjar it, +++ b/modules/elasticsearch/build.gradle, +configurations {, +    deployerJars, +    tools, +}, +, +dependencies {, +    deployerJars "org.apache.maven.wagon:wagon-http:1.0-beta-2", +    tools "com.google.code:jarjar:1.0", +}, +, +// add the source files to the dist jar, +//jar {, +//    from sourceSets.main.allJava, +//}, +, +jar << {, +    jarjarArchivePath = new File(jar.archivePath.absolutePath + ".jarjar.jar"), +    project.ant {, +        taskdef name: "jarjar", classname: "com.tonicsystems.jarjar.JarJarTask", classpath: configurations.tools.asPath, +        jarjar(jarfile: jarjarArchivePath) {, +            zipfileset(src: jar.archivePath), +            configurations.compile.files.findAll {file ->, +                ['jackson', 'joda'].any { file.name.contains(it) }, +            }.each { jarjarFile ->, +                zipfileset(src: jarjarFile) {, +                    exclude(name: "META-INF/**"), +                }, +            }, +            rule pattern: "org.codehaus.jackson.**", result: "org.elasticsearch.util.jackson.@1", +            rule pattern: "org.joda.**", result: "org.elasticsearch.util.joda.@1", +        }, +        delete(file: jar.archivePath), +        copy(file: jarjarArchivePath, tofile: jar.archivePath), +        delete(file: jarjarArchivePath), +    }, +}, +, +            pom.dependencies = pom.dependencies.findAll {dep -> !dep.artifactId.contains('jackson') }, +            pom.dependencies = pom.dependencies.findAll {dep -> !dep.artifactId.contains('joda') }, +++ b/build.gradle, +    ant.delete { fileset(dir: explodedDistLibDir, includes: "jackson-*.jar") } // no need jackson, we jarjar it, +    ant.delete { fileset(dir: explodedDistLibDir, includes: "joda-*.jar") } // no need joda, we jarjar it, +++ b/modules/elasticsearch/build.gradle, +configurations {, +    deployerJars, +    tools, +}, +, +dependencies {, +    deployerJars "org.apache.maven.wagon:wagon-http:1.0-beta-2", +    tools "com.google.code:jarjar:1.0", +}, +, +// add the source files to the dist jar, +//jar {, +//    from sourceSets.main.allJava, +//}, +, +jar << {, +    jarjarArchivePath = new File(jar.archivePath.absolutePath + ".jarjar.jar"), +    project.ant {, +        taskdef name: "jarjar", classname: "com.tonicsystems.jarjar.JarJarTask", classpath: configurations.tools.asPath, +        jarjar(jarfile: jarjarArchivePath) {, +            zipfileset(src: jar.archivePath), +            configurations.compile.files.findAll {file ->, +                ['jackson', 'joda'].any { file.name.contains(it) }, +            }.each { jarjarFile ->, +                zipfileset(src: jarjarFile) {, +                    exclude(name: "META-INF/**"), +                }, +            }, +            rule pattern: "org.codehaus.jackson.**", result: "org.elasticsearch.util.jackson.@1", +            rule pattern: "org.joda.**", result: "org.elasticsearch.util.joda.@1", +        }, +        delete(file: jar.archivePath), +        copy(file: jarjarArchivePath, tofile: jar.archivePath), +        delete(file: jarjarArchivePath), +    }, +}, +, +            pom.dependencies = pom.dependencies.findAll {dep -> !dep.artifactId.contains('jackson') }, +            pom.dependencies = pom.dependencies.findAll {dep -> !dep.artifactId.contains('joda') }, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/util/xcontent/XContentFactory.java, +import org.elasticsearch.ElasticSearchParseException;, +import java.util.Arrays;, +        try {, +        } catch (Throwable t) {, +            System.err.println("Failed to load xcontent");, +            t.printStackTrace();, +        }, +        XContentType type = xContentType(content);, +        if (type == null) {, +            throw new ElasticSearchParseException("Failed to derive xcontent from " + content);]