[+++ b/plugin/src/main/java/org/elasticsearch/xpack/XPackPlugin.java, +import org.elasticsearch.cluster.ClusterState;, +import org.elasticsearch.plugins.ClusterPlugin;, +public class XPackPlugin extends Plugin implements ScriptPlugin, ActionPlugin, IngestPlugin, NetworkPlugin, ClusterPlugin {, +    @Override, +    public Map<String, Supplier<ClusterState.Custom>> getInitialClusterStateCustomSupplier() {, +        return security.getInitialClusterStateCustomSupplier();, +    }, +++ b/plugin/src/main/java/org/elasticsearch/xpack/XPackPlugin.java, +import org.elasticsearch.cluster.ClusterState;, +import org.elasticsearch.plugins.ClusterPlugin;, +public class XPackPlugin extends Plugin implements ScriptPlugin, ActionPlugin, IngestPlugin, NetworkPlugin, ClusterPlugin {, +    @Override, +    public Map<String, Supplier<ClusterState.Custom>> getInitialClusterStateCustomSupplier() {, +        return security.getInitialClusterStateCustomSupplier();, +    }, +++ b/plugin/src/main/java/org/elasticsearch/xpack/security/Security.java, +import org.elasticsearch.cluster.ClusterState;, +import org.elasticsearch.cluster.LocalNodeMasterListener;, +import org.elasticsearch.cluster.NamedDiff;, +import org.elasticsearch.plugins.ClusterPlugin;, +import org.elasticsearch.xpack.security.authc.TokenMetaData;, +public class Security implements ActionPlugin, IngestPlugin, NetworkPlugin, ClusterPlugin {, +    private final SetOnce<TokenService> tokenService = new SetOnce<>();, +        final TokenService tokenService = new TokenService(settings, Clock.systemUTC(), client, securityLifecycleService, clusterService);, +        this.tokenService.set(tokenService);, +        List<NamedWriteableRegistry.Entry> entries = new ArrayList<>();, +        entries.add(new NamedWriteableRegistry.Entry(ClusterState.Custom.class, TokenMetaData.TYPE, TokenMetaData::new));, +        entries.add(new NamedWriteableRegistry.Entry(NamedDiff.class, TokenMetaData.TYPE, TokenMetaData::readDiffFrom));, +        entries.addAll(Arrays.asList(ExpressionParser.NAMED_WRITEABLES));, +        return entries;, +, +    @Override, +    public Map<String, Supplier<ClusterState.Custom>> getInitialClusterStateCustomSupplier() {, +        if (enabled) {, +            return Collections.singletonMap(TokenMetaData.TYPE, () -> tokenService.get().getTokenMetaData());, +        } else {, +            return Collections.emptyMap();, +        }, +    }, +++ b/plugin/src/main/java/org/elasticsearch/xpack/XPackPlugin.java, +import org.elasticsearch.cluster.ClusterState;, +import org.elasticsearch.plugins.ClusterPlugin;, +public class XPackPlugin extends Plugin implements ScriptPlugin, ActionPlugin, IngestPlugin, NetworkPlugin, ClusterPlugin {, +    @Override, +    public Map<String, Supplier<ClusterState.Custom>> getInitialClusterStateCustomSupplier() {, +        return security.getInitialClusterStateCustomSupplier();, +    }, +++ b/plugin/src/main/java/org/elasticsearch/xpack/security/Security.java, +import org.elasticsearch.cluster.ClusterState;, +import org.elasticsearch.cluster.LocalNodeMasterListener;, +import org.elasticsearch.cluster.NamedDiff;, +import org.elasticsearch.plugins.ClusterPlugin;, +import org.elasticsearch.xpack.security.authc.TokenMetaData;, +public class Security implements ActionPlugin, IngestPlugin, NetworkPlugin, ClusterPlugin {, +    private final SetOnce<TokenService> tokenService = new SetOnce<>();, +        final TokenService tokenService = new TokenService(settings, Clock.systemUTC(), client, securityLifecycleService, clusterService);, +        this.tokenService.set(tokenService);, +        List<NamedWriteableRegistry.Entry> entries = new ArrayList<>();, +        entries.add(new NamedWriteableRegistry.Entry(ClusterState.Custom.class, TokenMetaData.TYPE, TokenMetaData::new));, +        entries.add(new NamedWriteableRegistry.Entry(NamedDiff.class, TokenMetaData.TYPE, TokenMetaData::readDiffFrom));, +        entries.addAll(Arrays.asList(ExpressionParser.NAMED_WRITEABLES));, +        return entries;, +, +    @Override, +    public Map<String, Supplier<ClusterState.Custom>> getInitialClusterStateCustomSupplier() {, +        if (enabled) {, +            return Collections.singletonMap(TokenMetaData.TYPE, () -> tokenService.get().getTokenMetaData());, +        } else {, +            return Collections.emptyMap();, +        }, +    }, +++ b/plugin/src/main/java/org/elasticsearch/xpack/security/TokenPassphraseBootstrapCheck.java, +, +        this.tokenPassphrase = TokenService.TOKEN_PASSPHRASE.exists(settings) ? TokenService.TOKEN_PASSPHRASE.get(settings) : null;, +        if (tokenPassphrase == null) { // that's fine we bootstrap it ourself, +            return false;, +        }, +                return tokenPassphrase.length() < MINIMUM_PASSPHRASE_LENGTH;, +                "] that is at least " + MINIMUM_PASSPHRASE_LENGTH + " characters in length or " +, +++ b/plugin/src/main/java/org/elasticsearch/xpack/XPackPlugin.java, +import org.elasticsearch.cluster.ClusterState;, +import org.elasticsearch.plugins.ClusterPlugin;, +public class XPackPlugin extends Plugin implements ScriptPlugin, ActionPlugin, IngestPlugin, NetworkPlugin, ClusterPlugin {, +    @Override, +    public Map<String, Supplier<ClusterState.Custom>> getInitialClusterStateCustomSupplier() {, +        return security.getInitialClusterStateCustomSupplier();, +    }, +++ b/plugin/src/main/java/org/elasticsearch/xpack/security/Security.java, +import org.elasticsearch.cluster.ClusterState;, +import org.elasticsearch.cluster.LocalNodeMasterListener;, +import org.elasticsearch.cluster.NamedDiff;, +import org.elasticsearch.plugins.ClusterPlugin;, +import org.elasticsearch.xpack.security.authc.TokenMetaData;, +public class Security implements ActionPlugin, IngestPlugin, NetworkPlugin, ClusterPlugin {, +    private final SetOnce<TokenService> tokenService = new SetOnce<>();, +        final TokenService tokenService = new TokenService(settings, Clock.systemUTC(), client, securityLifecycleService, clusterService);, +        this.tokenService.set(tokenService);, +        List<NamedWriteableRegistry.Entry> entries = new ArrayList<>();, +        entries.add(new NamedWriteableRegistry.Entry(ClusterState.Custom.class, TokenMetaData.TYPE, TokenMetaData::new));]