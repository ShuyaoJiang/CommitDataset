[+++ b/.ci/packer_cache.sh, +#!/bin/bash, +, +SCRIPT="$0", +, +# SCRIPT might be an arbitrarily deep series of symbolic links; loop until we, +# have the concrete path, +while [ -h "$SCRIPT" ] ; do, +  ls=$(ls -ld "$SCRIPT"), +  # Drop everything prior to ->, +  link=$(expr "$ls" : '.*-> \(.*\)$'), +  if expr "$link" : '/.*' > /dev/null; then, +    SCRIPT="$link", +  else, +    SCRIPT=$(dirname "$SCRIPT")/"$link", +  fi, +done, +, +source $(dirname "${SCRIPT}")/java-versions.properties, +JAVA_HOME="${HOME}"/.java/${ES_BUILD_JAVA} ./gradlew resolveAllDependencies --parallel, +++ b/.ci/packer_cache.sh, +#!/bin/bash, +, +SCRIPT="$0", +, +# SCRIPT might be an arbitrarily deep series of symbolic links; loop until we, +# have the concrete path, +while [ -h "$SCRIPT" ] ; do, +  ls=$(ls -ld "$SCRIPT"), +  # Drop everything prior to ->, +  link=$(expr "$ls" : '.*-> \(.*\)$'), +  if expr "$link" : '/.*' > /dev/null; then, +    SCRIPT="$link", +  else, +    SCRIPT=$(dirname "$SCRIPT")/"$link", +  fi, +done, +, +source $(dirname "${SCRIPT}")/java-versions.properties, +JAVA_HOME="${HOME}"/.java/${ES_BUILD_JAVA} ./gradlew resolveAllDependencies --parallel, +++ b/build.gradle, +, +allprojects {, +  task resolveAllDependencies {, +    doLast {, +      configurations.findAll { it.isCanBeResolved() }.each { it.resolve() }, +    }, +  }, +}, +++ b/.ci/packer_cache.sh, +#!/bin/bash, +, +SCRIPT="$0", +, +# SCRIPT might be an arbitrarily deep series of symbolic links; loop until we, +# have the concrete path, +while [ -h "$SCRIPT" ] ; do, +  ls=$(ls -ld "$SCRIPT"), +  # Drop everything prior to ->, +  link=$(expr "$ls" : '.*-> \(.*\)$'), +  if expr "$link" : '/.*' > /dev/null; then, +    SCRIPT="$link", +  else, +    SCRIPT=$(dirname "$SCRIPT")/"$link", +  fi, +done, +, +source $(dirname "${SCRIPT}")/java-versions.properties, +JAVA_HOME="${HOME}"/.java/${ES_BUILD_JAVA} ./gradlew resolveAllDependencies --parallel, +++ b/build.gradle, +, +allprojects {, +  task resolveAllDependencies {, +    doLast {, +      configurations.findAll { it.isCanBeResolved() }.each { it.resolve() }, +    }, +  }, +}, +++ b/client/rest-high-level/src/main/java/org/elasticsearch/client/MLRequestConverters.java, +import org.elasticsearch.client.ml.DeleteDatafeedRequest;, +import org.elasticsearch.client.ml.PutCalendarRequest;, +    static Request deleteDatafeed(DeleteDatafeedRequest deleteDatafeedRequest) {, +        String endpoint = new EndpointBuilder(), +                .addPathPartAsIs("_xpack"), +                .addPathPartAsIs("ml"), +                .addPathPartAsIs("datafeeds"), +                .addPathPart(deleteDatafeedRequest.getDatafeedId()), +                .build();, +        Request request = new Request(HttpDelete.METHOD_NAME, endpoint);, +        RequestConverters.Params params = new RequestConverters.Params(request);, +        params.putParam("force", Boolean.toString(deleteDatafeedRequest.isForce()));, +        return request;, +    }, +, +, +    static Request putCalendar(PutCalendarRequest putCalendarRequest) throws IOException {, +        String endpoint = new EndpointBuilder(), +                .addPathPartAsIs("_xpack"), +                .addPathPartAsIs("ml"), +                .addPathPartAsIs("calendars")]