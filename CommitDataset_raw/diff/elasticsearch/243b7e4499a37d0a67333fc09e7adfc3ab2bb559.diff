[+++ b/server/src/main/java/org/elasticsearch/persistent/PersistentActionCoordinator.java, +import org.elasticsearch.action.admin.cluster.node.tasks.cancel.CancelTasksRequest;, +import org.elasticsearch.persistent.PersistentTasksInProgress.PersistentTaskInProgress;, +                if (CancelTasksRequest.DEFAULT_REASON.equals(task.getTask().getReasonCancelled())) {, +            } else {, +                startCompletionNotification(task, e);, +            }, +++ b/server/src/main/java/org/elasticsearch/persistent/PersistentActionCoordinator.java, +import org.elasticsearch.action.admin.cluster.node.tasks.cancel.CancelTasksRequest;, +import org.elasticsearch.persistent.PersistentTasksInProgress.PersistentTaskInProgress;, +                if (CancelTasksRequest.DEFAULT_REASON.equals(task.getTask().getReasonCancelled())) {, +            } else {, +                startCompletionNotification(task, e);, +            }, +++ b/server/src/main/java/org/elasticsearch/persistent/PersistentActionService.java, +import org.elasticsearch.common.util.concurrent.AbstractRunnable;, +import org.elasticsearch.threadpool.ThreadPool;, +    private final ThreadPool threadPool;, +    public PersistentActionService(Settings settings, ThreadPool threadPool, ClusterService clusterService, Client client) {, +        this.threadPool = threadPool;, +        // Need to fork otherwise: java.lang.AssertionError: should not be called by a cluster state applier., +        // reason [the applied cluster state is not yet available]), +            threadPool.executor(ThreadPool.Names.GENERIC).execute(new AbstractRunnable() {, +                @Override, +                public void onFailure(Exception e) {, +                    listener.onFailure(e);, +                }, +, +                @Override, +                protected void doRun() throws Exception {, +                }, +            });, +++ b/server/src/main/java/org/elasticsearch/persistent/PersistentActionCoordinator.java, +import org.elasticsearch.action.admin.cluster.node.tasks.cancel.CancelTasksRequest;, +import org.elasticsearch.persistent.PersistentTasksInProgress.PersistentTaskInProgress;, +                if (CancelTasksRequest.DEFAULT_REASON.equals(task.getTask().getReasonCancelled())) {, +            } else {, +                startCompletionNotification(task, e);, +            }, +++ b/server/src/main/java/org/elasticsearch/persistent/PersistentActionService.java, +import org.elasticsearch.common.util.concurrent.AbstractRunnable;, +import org.elasticsearch.threadpool.ThreadPool;, +    private final ThreadPool threadPool;, +    public PersistentActionService(Settings settings, ThreadPool threadPool, ClusterService clusterService, Client client) {, +        this.threadPool = threadPool;, +        // Need to fork otherwise: java.lang.AssertionError: should not be called by a cluster state applier., +        // reason [the applied cluster state is not yet available]), +            threadPool.executor(ThreadPool.Names.GENERIC).execute(new AbstractRunnable() {, +                @Override, +                public void onFailure(Exception e) {, +                    listener.onFailure(e);, +                }, +, +                @Override, +                protected void doRun() throws Exception {, +                }, +            });, +++ b/server/src/main/java/org/elasticsearch/persistent/PersistentTask.java, +    // In case of persistent tasks we always need to return: `false`, +    // because in case of persistent task the parent task isn't a task in the task manager, but in cluster state., +    // This instructs the task manager not to try to kill this persistent task when the task manager cannot find, +    // a fake parent node id "cluster" in the cluster state, +    @Override, +    public final boolean cancelOnParentLeaving() {, +        return false;, +    }, +, +++ b/server/src/main/java/org/elasticsearch/persistent/PersistentActionCoordinator.java, +import org.elasticsearch.action.admin.cluster.node.tasks.cancel.CancelTasksRequest;, +import org.elasticsearch.persistent.PersistentTasksInProgress.PersistentTaskInProgress;, +                if (CancelTasksRequest.DEFAULT_REASON.equals(task.getTask().getReasonCancelled())) {, +            } else {, +                startCompletionNotification(task, e);, +            }, +++ b/server/src/main/java/org/elasticsearch/persistent/PersistentActionService.java, +import org.elasticsearch.common.util.concurrent.AbstractRunnable;, +import org.elasticsearch.threadpool.ThreadPool;, +    private final ThreadPool threadPool;, +    public PersistentActionService(Settings settings, ThreadPool threadPool, ClusterService clusterService, Client client) {, +        this.threadPool = threadPool;, +        // Need to fork otherwise: java.lang.AssertionError: should not be called by a cluster state applier., +        // reason [the applied cluster state is not yet available]), +            threadPool.executor(ThreadPool.Names.GENERIC).execute(new AbstractRunnable() {, +                @Override, +                public void onFailure(Exception e) {, +                    listener.onFailure(e);, +                }, +, +                @Override, +                protected void doRun() throws Exception {, +                }, +            });, +++ b/server/src/main/java/org/elasticsearch/persistent/PersistentTask.java, +    // In case of persistent tasks we always need to return: `false`, +    // because in case of persistent task the parent task isn't a task in the task manager, but in cluster state., +    // This instructs the task manager not to try to kill this persistent task when the task manager cannot find, +    // a fake parent node id "cluster" in the cluster state, +    @Override, +    public final boolean cancelOnParentLeaving() {, +        return false;]