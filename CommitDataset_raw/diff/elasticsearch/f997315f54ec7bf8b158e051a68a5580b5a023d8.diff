[+++ b/src/main/java/org/apache/lucene/queryParser/ExistsFieldQueryExtension.java, +                filter = smartNameFieldMappers.mapper().rangeFilter(null, null, true, true, parseContext);, +++ b/src/main/java/org/apache/lucene/queryParser/ExistsFieldQueryExtension.java, +                filter = smartNameFieldMappers.mapper().rangeFilter(null, null, true, true, parseContext);, +++ b/src/main/java/org/apache/lucene/queryParser/MapperQueryParser.java, +                Query rangeQuery = currentMapper.rangeQuery(part1, part2, inclusive, inclusive, parseContext);, +++ b/src/main/java/org/apache/lucene/queryParser/ExistsFieldQueryExtension.java, +                filter = smartNameFieldMappers.mapper().rangeFilter(null, null, true, true, parseContext);, +++ b/src/main/java/org/apache/lucene/queryParser/MapperQueryParser.java, +                Query rangeQuery = currentMapper.rangeQuery(part1, part2, inclusive, inclusive, parseContext);, +++ b/src/main/java/org/apache/lucene/queryParser/MissingFieldQueryExtension.java, +                filter = smartNameFieldMappers.mapper().rangeFilter(null, null, true, true, parseContext);, +++ b/src/main/java/org/apache/lucene/queryParser/ExistsFieldQueryExtension.java, +                filter = smartNameFieldMappers.mapper().rangeFilter(null, null, true, true, parseContext);, +++ b/src/main/java/org/apache/lucene/queryParser/MapperQueryParser.java, +                Query rangeQuery = currentMapper.rangeQuery(part1, part2, inclusive, inclusive, parseContext);, +++ b/src/main/java/org/apache/lucene/queryParser/MissingFieldQueryExtension.java, +                filter = smartNameFieldMappers.mapper().rangeFilter(null, null, true, true, parseContext);, +++ b/src/main/java/org/elasticsearch/common/joda/DateMathParser.java, +package org.elasticsearch.common.joda;, +, +import org.elasticsearch.ElasticSearchParseException;, +import org.joda.time.DateTimeZone;, +import org.joda.time.MutableDateTime;, +, +import java.util.concurrent.TimeUnit;, +, +/**, + */, +public class DateMathParser {, +, +    private final FormatDateTimeFormatter dateTimeFormatter;, +, +    private final TimeUnit timeUnit;, +, +    public DateMathParser(FormatDateTimeFormatter dateTimeFormatter, TimeUnit timeUnit) {, +        this.dateTimeFormatter = dateTimeFormatter;, +        this.timeUnit = timeUnit;, +    }, +, +    public long parse(String text, long now) {, +        return parse(text, now, false, false);, +    }, +, +    public long parseUpperInclusive(String text, long now) {, +        return parse(text, now, true, true);, +    }, +, +    public long parse(String text, long now, boolean roundUp, boolean upperInclusive) {, +        long time;, +        String mathString;, +        if (text.startsWith("now")) {, +            time = now;, +            mathString = text.substring("now".length());, +        } else {, +            int index = text.indexOf("||");, +            String parseString;, +            if (index == -1) {, +                parseString = text;, +                mathString = ""; // nothing else, +            } else {, +                parseString = text.substring(0, index);, +                mathString = text.substring(index + 2);, +            }, +            if (upperInclusive) {, +                time = parseUpperInclusiveStringValue(parseString);, +            } else {, +                time = parseStringValue(parseString);, +            }, +        }, +, +        if (mathString.isEmpty()) {, +            return time;, +        }, +, +        return parseMath(mathString, time, roundUp);, +    }, +, +    private long parseMath(String mathString, long time, boolean roundUp) throws ElasticSearchParseException {, +        MutableDateTime dateTime = new MutableDateTime(time, DateTimeZone.UTC);, +        try {, +            for (int i = 0; i < mathString.length(); ) {, +                char c = mathString.charAt(i++);, +                int type;, +                if (c == '/') {, +                    type = 0;, +                } else if (c == '+') {, +                    type = 1;, +                } else if (c == '-') {, +                    type = 2;, +                } else {, +                    throw new ElasticSearchParseException("operator not supported for date math [" + mathString + "]");, +                }, +, +                int num;, +                if (!Character.isDigit(mathString.charAt(i))) {, +                    num = 1;, +                } else {, +                    int numFrom = i;, +                    while (Character.isDigit(mathString.charAt(i))) {]