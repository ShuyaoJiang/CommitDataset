[+++ b/src/main/java/org/elasticsearch/indices/recovery/RecoverySource.java, +import org.elasticsearch.cluster.ClusterState;, +import org.elasticsearch.cluster.ProcessedClusterStateNonMasterUpdateTask;, +import org.elasticsearch.common.Nullable;, +import org.elasticsearch.common.util.concurrent.ConcurrentCollections;, +import java.util.concurrent.*;, +                // we test that the cluster state is in sync with our in memory mapping stored by the mapperService, +                // we have to do it under the "cluster state update" thread to make sure that one doesn't modify it, +                // while we're checking, +                final BlockingQueue<DocumentMapper> documentMappersToUpdate = ConcurrentCollections.newBlockingQueue();, +                final CountDownLatch latch = new CountDownLatch(1);, +                clusterService.submitStateUpdateTask("recovery_mapping_check", new ProcessedClusterStateNonMasterUpdateTask() {, +                    @Override, +                    public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {, +                        latch.countDown();, +                    }, +, +                    @Override, +                    public ClusterState execute(ClusterState currentState) throws Exception {, +                        return currentState;, +                    }, +, +                    @Override, +                    public void onFailure(String source, @Nullable Throwable t) {, +                        logger.error("unexpected error while checking for pending mapping changes", t);, +                        latch.countDown();, +                    }, +                });, +                try {, +                    latch.await();, +                } catch (InterruptedException e) {, +                    Thread.currentThread().interrupt();, +                }, +                final CountDownLatch updatedOnMaster = new CountDownLatch(documentMappersToUpdate.size());, +                        updatedOnMaster.countDown();, +                        updatedOnMaster.countDown();, +                    if (!updatedOnMaster.await(internalActionTimeout.millis(), TimeUnit.MILLISECONDS)) {]