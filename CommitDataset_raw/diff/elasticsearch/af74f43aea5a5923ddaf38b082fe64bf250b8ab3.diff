[+++ b/core-signatures.txt, +, +@defaultMessage The LdapSslSocketFactory should never be cleared manually as it may lead to threading issues., +org.elasticsearch.shield.authc.support.ldap.LdapSslSocketFactory#clear(), +++ b/core-signatures.txt, +, +@defaultMessage The LdapSslSocketFactory should never be cleared manually as it may lead to threading issues., +org.elasticsearch.shield.authc.support.ldap.LdapSslSocketFactory#clear(), +++ b/src/main/java/org/elasticsearch/shield/authc/AuthenticationModule.java, +import org.elasticsearch.common.inject.multibindings.MapBinder;, +import org.elasticsearch.shield.authc.active_directory.ActiveDirectoryRealm;, +import org.elasticsearch.shield.authc.esusers.ESUsersRealm;, +import org.elasticsearch.shield.authc.ldap.LdapRealm;, +import org.elasticsearch.shield.authc.support.ldap.LdapSslSocketFactory;, +public class AuthenticationModule extends AbstractShieldModule.Node {, +, +        // This socket factory needs to be configured before any LDAP connections are created.  LDAP configuration, +        // for JNDI invokes a static getSocketFactory method from LdapSslSocketFactory., +        requestStaticInjection(LdapSslSocketFactory.class);, +, +        MapBinder<String, Realm.Factory> mapBinder = MapBinder.newMapBinder(binder(), String.class, Realm.Factory.class);, +        mapBinder.addBinding(ESUsersRealm.TYPE).to(ESUsersRealm.Factory.class).asEagerSingleton();, +        mapBinder.addBinding(ActiveDirectoryRealm.TYPE).to(ActiveDirectoryRealm.Factory.class).asEagerSingleton();, +        mapBinder.addBinding(LdapRealm.TYPE).to(LdapRealm.Factory.class).asEagerSingleton();, +, +        bind(Realms.class).asEagerSingleton();, +++ b/core-signatures.txt, +, +@defaultMessage The LdapSslSocketFactory should never be cleared manually as it may lead to threading issues., +org.elasticsearch.shield.authc.support.ldap.LdapSslSocketFactory#clear(), +++ b/src/main/java/org/elasticsearch/shield/authc/AuthenticationModule.java, +import org.elasticsearch.common.inject.multibindings.MapBinder;, +import org.elasticsearch.shield.authc.active_directory.ActiveDirectoryRealm;, +import org.elasticsearch.shield.authc.esusers.ESUsersRealm;, +import org.elasticsearch.shield.authc.ldap.LdapRealm;, +import org.elasticsearch.shield.authc.support.ldap.LdapSslSocketFactory;, +public class AuthenticationModule extends AbstractShieldModule.Node {, +, +        // This socket factory needs to be configured before any LDAP connections are created.  LDAP configuration, +        // for JNDI invokes a static getSocketFactory method from LdapSslSocketFactory., +        requestStaticInjection(LdapSslSocketFactory.class);, +, +        MapBinder<String, Realm.Factory> mapBinder = MapBinder.newMapBinder(binder(), String.class, Realm.Factory.class);, +        mapBinder.addBinding(ESUsersRealm.TYPE).to(ESUsersRealm.Factory.class).asEagerSingleton();, +        mapBinder.addBinding(ActiveDirectoryRealm.TYPE).to(ActiveDirectoryRealm.Factory.class).asEagerSingleton();, +        mapBinder.addBinding(LdapRealm.TYPE).to(LdapRealm.Factory.class).asEagerSingleton();, +, +        bind(Realms.class).asEagerSingleton();, +++ b/src/main/java/org/elasticsearch/shield/authc/InternalAuthenticationService.java, +    private final Realms realms;, +        this.realms = realms;, +++ b/core-signatures.txt, +, +@defaultMessage The LdapSslSocketFactory should never be cleared manually as it may lead to threading issues., +org.elasticsearch.shield.authc.support.ldap.LdapSslSocketFactory#clear(), +++ b/src/main/java/org/elasticsearch/shield/authc/AuthenticationModule.java, +import org.elasticsearch.common.inject.multibindings.MapBinder;, +import org.elasticsearch.shield.authc.active_directory.ActiveDirectoryRealm;, +import org.elasticsearch.shield.authc.esusers.ESUsersRealm;, +import org.elasticsearch.shield.authc.ldap.LdapRealm;, +import org.elasticsearch.shield.authc.support.ldap.LdapSslSocketFactory;, +public class AuthenticationModule extends AbstractShieldModule.Node {, +, +        // This socket factory needs to be configured before any LDAP connections are created.  LDAP configuration, +        // for JNDI invokes a static getSocketFactory method from LdapSslSocketFactory., +        requestStaticInjection(LdapSslSocketFactory.class);, +, +        MapBinder<String, Realm.Factory> mapBinder = MapBinder.newMapBinder(binder(), String.class, Realm.Factory.class);, +        mapBinder.addBinding(ESUsersRealm.TYPE).to(ESUsersRealm.Factory.class).asEagerSingleton();, +        mapBinder.addBinding(ActiveDirectoryRealm.TYPE).to(ActiveDirectoryRealm.Factory.class).asEagerSingleton();, +        mapBinder.addBinding(LdapRealm.TYPE).to(LdapRealm.Factory.class).asEagerSingleton();, +, +        bind(Realms.class).asEagerSingleton();, +++ b/src/main/java/org/elasticsearch/shield/authc/InternalAuthenticationService.java, +    private final Realms realms;, +        this.realms = realms;, +++ b/src/main/java/org/elasticsearch/shield/authc/Realm.java, +import org.elasticsearch.common.logging.ESLogger;, +import org.elasticsearch.common.logging.Loggers;, +import org.elasticsearch.common.settings.Settings;, +public abstract class Realm<T extends AuthenticationToken> implements Comparable<Realm> {, +, +    protected final ESLogger logger = Loggers.getLogger(getClass());, +, +    protected final String type;, +    protected final String name;, +    protected final Settings settings;, +    protected final int order;, +, +    public Realm(String type, String name, Settings settings) {, +        this.type = type;, +        this.name = name;, +        this.settings = settings;, +        this.order = settings.getAsInt("order", Integer.MAX_VALUE);, +    }, +    public String type() {, +        return type;, +    }, +, +    /**]