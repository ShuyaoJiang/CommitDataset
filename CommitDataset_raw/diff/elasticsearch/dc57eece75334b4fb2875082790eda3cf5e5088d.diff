[+++ b/x-pack/plugin/core/src/main/java/org/elasticsearch/license/XPackLicenseState.java, +        // 6.0+ requires TLS for production licenses, so if TLS is enabled and security is enabled, +        // we can interpret this as an explicit enabling of security if the security enabled, +        // setting is not explicitly set, +        this.isSecurityExplicitlyEnabled = isSecurityEnabled &&, +            (settings.hasValue(XPackSettings.SECURITY_ENABLED.getKey()) || XPackSettings.TRANSPORT_SSL_ENABLED.get(settings));, +++ b/x-pack/plugin/core/src/main/java/org/elasticsearch/license/XPackLicenseState.java, +        // 6.0+ requires TLS for production licenses, so if TLS is enabled and security is enabled, +        // we can interpret this as an explicit enabling of security if the security enabled, +        // setting is not explicitly set, +        this.isSecurityExplicitlyEnabled = isSecurityEnabled &&, +            (settings.hasValue(XPackSettings.SECURITY_ENABLED.getKey()) || XPackSettings.TRANSPORT_SSL_ENABLED.get(settings));, +++ b/x-pack/plugin/core/src/test/java/org/elasticsearch/license/XPackLicenseStateTests.java, +        licenseState =, +            new XPackLicenseState(Settings.builder().put(XPackSettings.TRANSPORT_SSL_ENABLED.getKey(), true).build());, +        assertThat(licenseState.isAuthAllowed(), is(true));, +        assertThat(licenseState.isIpFilteringAllowed(), is(true));, +        assertThat(licenseState.isAuditingAllowed(), is(true));, +        assertThat(licenseState.isStatsAndHealthAllowed(), is(true));, +        assertThat(licenseState.isDocumentAndFieldLevelSecurityAllowed(), is(true));, +        assertThat(licenseState.allowedRealmType(), is(XPackLicenseState.AllowedRealmType.ALL));, +        assertThat(licenseState.isCustomRoleProvidersAllowed(), is(true));, +, +++ b/x-pack/plugin/core/src/main/java/org/elasticsearch/license/XPackLicenseState.java, +        // 6.0+ requires TLS for production licenses, so if TLS is enabled and security is enabled, +        // we can interpret this as an explicit enabling of security if the security enabled, +        // setting is not explicitly set, +        this.isSecurityExplicitlyEnabled = isSecurityEnabled &&, +            (settings.hasValue(XPackSettings.SECURITY_ENABLED.getKey()) || XPackSettings.TRANSPORT_SSL_ENABLED.get(settings));, +++ b/x-pack/plugin/core/src/test/java/org/elasticsearch/license/XPackLicenseStateTests.java, +        licenseState =, +            new XPackLicenseState(Settings.builder().put(XPackSettings.TRANSPORT_SSL_ENABLED.getKey(), true).build());, +        assertThat(licenseState.isAuthAllowed(), is(true));, +        assertThat(licenseState.isIpFilteringAllowed(), is(true));, +        assertThat(licenseState.isAuditingAllowed(), is(true));, +        assertThat(licenseState.isStatsAndHealthAllowed(), is(true));, +        assertThat(licenseState.isDocumentAndFieldLevelSecurityAllowed(), is(true));, +        assertThat(licenseState.allowedRealmType(), is(XPackLicenseState.AllowedRealmType.ALL));, +        assertThat(licenseState.isCustomRoleProvidersAllowed(), is(true));, +, +++ b/x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/Security.java, +                authzService, getLicenseState(), getSslService(), securityContext.get(), destructiveOperations, clusterService));, +++ b/x-pack/plugin/core/src/main/java/org/elasticsearch/license/XPackLicenseState.java, +        // 6.0+ requires TLS for production licenses, so if TLS is enabled and security is enabled, +        // we can interpret this as an explicit enabling of security if the security enabled, +        // setting is not explicitly set, +        this.isSecurityExplicitlyEnabled = isSecurityEnabled &&, +            (settings.hasValue(XPackSettings.SECURITY_ENABLED.getKey()) || XPackSettings.TRANSPORT_SSL_ENABLED.get(settings));, +++ b/x-pack/plugin/core/src/test/java/org/elasticsearch/license/XPackLicenseStateTests.java, +        licenseState =, +            new XPackLicenseState(Settings.builder().put(XPackSettings.TRANSPORT_SSL_ENABLED.getKey(), true).build());, +        assertThat(licenseState.isAuthAllowed(), is(true));, +        assertThat(licenseState.isIpFilteringAllowed(), is(true));, +        assertThat(licenseState.isAuditingAllowed(), is(true));, +        assertThat(licenseState.isStatsAndHealthAllowed(), is(true));, +        assertThat(licenseState.isDocumentAndFieldLevelSecurityAllowed(), is(true));, +        assertThat(licenseState.allowedRealmType(), is(XPackLicenseState.AllowedRealmType.ALL));, +        assertThat(licenseState.isCustomRoleProvidersAllowed(), is(true));, +, +++ b/x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/Security.java, +                authzService, getLicenseState(), getSslService(), securityContext.get(), destructiveOperations, clusterService));, +++ b/x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/transport/SecurityServerTransportInterceptor.java, +import org.elasticsearch.cluster.service.ClusterService;, +import org.elasticsearch.gateway.GatewayService;, +    private volatile boolean isStateNotRecovered = true;, +, +                                              DestructiveOperations destructiveOperations,, +                                              ClusterService clusterService) {, +        clusterService.addListener(e -> isStateNotRecovered = e.state().blocks().hasGlobalBlock(GatewayService.STATE_NOT_RECOVERED_BLOCK));, +                // make a local copy of isStateNotRecovered as this is a volatile variable and it, +                // is used multiple times in the method. The copy to a local variable allows us to, +                // guarantee we use the same value wherever we would check the value for the state, +                // being recovered, +                final boolean stateNotRecovered = isStateNotRecovered;, +                final boolean sendWithAuth = (licenseState.isSecurityEnabled() && licenseState.isAuthAllowed()) || stateNotRecovered;, +                if (sendWithAuth) {, +                                        , handler), sender, stateNotRecovered), minVersion);, +                                                , handler), sender, stateNotRecovered));, +                            new ContextRestoreResponseHandler<>(threadPool.getThreadContext().wrapRestorable(original), handler), sender,, +                            stateNotRecovered), minVersion);, +                        sendWithUser(connection, action, request, options, handler, sender, stateNotRecovered);, +                                                            AsyncSender sender, final boolean stateNotRecovered) {, +        // There cannot be a request outgoing from this node that is not associated with a user, +        // unless we do not know the actual license of the cluster, +        if (securityContext.getAuthentication() == null && stateNotRecovered == false) {, +++ b/x-pack/plugin/core/src/main/java/org/elasticsearch/license/XPackLicenseState.java, +        // 6.0+ requires TLS for production licenses, so if TLS is enabled and security is enabled, +        // we can interpret this as an explicit enabling of security if the security enabled, +        // setting is not explicitly set, +        this.isSecurityExplicitlyEnabled = isSecurityEnabled &&, +            (settings.hasValue(XPackSettings.SECURITY_ENABLED.getKey()) || XPackSettings.TRANSPORT_SSL_ENABLED.get(settings));, +++ b/x-pack/plugin/core/src/test/java/org/elasticsearch/license/XPackLicenseStateTests.java, +        licenseState =, +            new XPackLicenseState(Settings.builder().put(XPackSettings.TRANSPORT_SSL_ENABLED.getKey(), true).build());, +        assertThat(licenseState.isAuthAllowed(), is(true));, +        assertThat(licenseState.isIpFilteringAllowed(), is(true));, +        assertThat(licenseState.isAuditingAllowed(), is(true));, +        assertThat(licenseState.isStatsAndHealthAllowed(), is(true));, +        assertThat(licenseState.isDocumentAndFieldLevelSecurityAllowed(), is(true));, +        assertThat(licenseState.allowedRealmType(), is(XPackLicenseState.AllowedRealmType.ALL));]