[+++ b/Vagrantfile, +          apt-get update), +++ b/Vagrantfile, +          apt-get update), +++ b/core/pom.xml, +                                <include>org/elasticsearch/bootstrap/XTestSecurityManager*.class</include>, +++ b/Vagrantfile, +          apt-get update), +++ b/core/pom.xml, +                                <include>org/elasticsearch/bootstrap/XTestSecurityManager*.class</include>, +++ b/core/src/test/java/org/elasticsearch/bootstrap/BootstrapForTesting.java, +import java.security.CodeSource;, +import java.security.Permission;, +import java.security.PermissionCollection;, +import java.security.cert.Certificate;, +import java.util.Collections;, +                // if its an insecure plugin, its not easy to simulate here, since we don't have a real plugin install., +                // we just do our best so unit testing can work. integration tests for such plugins are essential., +                    setInsecurePluginPermissions(perms, insecurePluginProp);, +                Policy.setPolicy(new ESPolicy(perms));, +    /**, +     * with a real plugin install, we just set a property to plugin/foo*, which matches, +     * plugin code and all dependencies. when running unit tests, things are disorganized,, +     * and might even be on different filesystem roots (windows), so we can't even make, +     * a URL that will match everything. instead, add the extra permissions globally., +     */, +    // TODO: maybe wrap with a policy so the extra permissions aren't applied to test classes/framework,, +    // so that stacks are always polluted and tests fail for missing AccessController blocks..., +    static void setInsecurePluginPermissions(Permissions permissions, String insecurePluginProp) throws Exception {, +        // the hack begins!, +        , +        // parse whole policy file, with and without the substitution, compute the delta, then add globally., +        URL bogus = new URL("file:/bogus");, +        ESPolicy policy = new ESPolicy(new Permissions());, +        PermissionCollection small = policy.template.getPermissions(new CodeSource(bogus, (Certificate[])null));, +        System.setProperty(insecurePluginProp, bogus.toString());, +        policy = new ESPolicy(new Permissions());, +        System.clearProperty(insecurePluginProp);, +        PermissionCollection big = policy.template.getPermissions(new CodeSource(bogus, (Certificate[])null));, +        , +        PermissionCollection delta = delta(small, big);, +        for (Permission p : Collections.list(delta.elements())) {, +            permissions.add(p);, +        }, +    }, +    , +    // computes delta of small and big, the slow way, +    static PermissionCollection delta(PermissionCollection small, PermissionCollection big) {, +        Permissions extra = new Permissions();, +        for (Permission p : Collections.list(big.elements())) {, +            // check big too, to remove UnresolvedPermissions (acts like NaN), +            if (big.implies(p) && small.implies(p) == false) {, +                extra.add(p);, +            }, +        }, +        return extra;, +    }, +, +++ b/Vagrantfile, +          apt-get update), +++ b/core/pom.xml, +                                <include>org/elasticsearch/bootstrap/XTestSecurityManager*.class</include>, +++ b/core/src/test/java/org/elasticsearch/bootstrap/BootstrapForTesting.java, +import java.security.CodeSource;, +import java.security.Permission;, +import java.security.PermissionCollection;, +import java.security.cert.Certificate;, +import java.util.Collections;, +                // if its an insecure plugin, its not easy to simulate here, since we don't have a real plugin install., +                // we just do our best so unit testing can work. integration tests for such plugins are essential., +                    setInsecurePluginPermissions(perms, insecurePluginProp);, +                Policy.setPolicy(new ESPolicy(perms));, +    /**, +     * with a real plugin install, we just set a property to plugin/foo*, which matches, +     * plugin code and all dependencies. when running unit tests, things are disorganized,, +     * and might even be on different filesystem roots (windows), so we can't even make, +     * a URL that will match everything. instead, add the extra permissions globally., +     */, +    // TODO: maybe wrap with a policy so the extra permissions aren't applied to test classes/framework,, +    // so that stacks are always polluted and tests fail for missing AccessController blocks..., +    static void setInsecurePluginPermissions(Permissions permissions, String insecurePluginProp) throws Exception {, +        // the hack begins!, +        , +        // parse whole policy file, with and without the substitution, compute the delta, then add globally., +        URL bogus = new URL("file:/bogus");, +        ESPolicy policy = new ESPolicy(new Permissions());, +        PermissionCollection small = policy.template.getPermissions(new CodeSource(bogus, (Certificate[])null));, +        System.setProperty(insecurePluginProp, bogus.toString());, +        policy = new ESPolicy(new Permissions());, +        System.clearProperty(insecurePluginProp);, +        PermissionCollection big = policy.template.getPermissions(new CodeSource(bogus, (Certificate[])null));, +        , +        PermissionCollection delta = delta(small, big);, +        for (Permission p : Collections.list(delta.elements())) {, +            permissions.add(p);, +        }, +    }, +    , +    // computes delta of small and big, the slow way, +    static PermissionCollection delta(PermissionCollection small, PermissionCollection big) {]