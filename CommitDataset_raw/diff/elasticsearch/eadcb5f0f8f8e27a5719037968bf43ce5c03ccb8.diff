[+++ b/server/src/main/java/org/elasticsearch/cluster/coordination/DiscoveryUpgradeService.java, +import java.util.HashSet;, +import java.util.Iterator;, +        final Set<String> knownMasterNodeIds = new HashSet<>();, +        lastAcceptedClusterState.nodes().getMasterNodes().forEach(c -> knownMasterNodeIds.add(c.key));, +, +        joiningRound, +            = new JoiningRound(enableUnsafeBootstrappingOnUpgrade && lastKnownLeader.isPresent(), minimumMasterNodes, knownMasterNodeIds);, +        private final Set<String> knownMasterNodeIds;, +        JoiningRound(boolean upgrading, int minimumMasterNodes, Set<String> knownMasterNodeIds) {, +            this.knownMasterNodeIds = knownMasterNodeIds;, +                                Set<String> nodeIds = new HashSet<>();, +                                discoveryNodes.forEach(n -> nodeIds.add(n.getId()));, +, +                                final Iterator<String> knownNodeIdIterator = knownMasterNodeIds.iterator();, +                                while (nodeIds.size() < 2 * minimumMasterNodes - 1 && knownNodeIdIterator.hasNext()) {, +                                    nodeIds.add(knownNodeIdIterator.next());, +                                }, +, +                                final VotingConfiguration votingConfiguration = new VotingConfiguration(nodeIds);, +                                assert votingConfiguration.hasQuorum(, +                                    discoveryNodes.stream().map(DiscoveryNode::getId).collect(Collectors.toList()));, +                                assert 2 * minimumMasterNodes - 2 <= nodeIds.size() : nodeIds + " too small for " + minimumMasterNodes;, +, +                                initialConfigurationConsumer.accept(votingConfiguration);, +++ b/server/src/main/java/org/elasticsearch/cluster/coordination/DiscoveryUpgradeService.java, +import java.util.HashSet;, +import java.util.Iterator;, +        final Set<String> knownMasterNodeIds = new HashSet<>();, +        lastAcceptedClusterState.nodes().getMasterNodes().forEach(c -> knownMasterNodeIds.add(c.key));, +, +        joiningRound, +            = new JoiningRound(enableUnsafeBootstrappingOnUpgrade && lastKnownLeader.isPresent(), minimumMasterNodes, knownMasterNodeIds);, +        private final Set<String> knownMasterNodeIds;, +        JoiningRound(boolean upgrading, int minimumMasterNodes, Set<String> knownMasterNodeIds) {, +            this.knownMasterNodeIds = knownMasterNodeIds;, +                                Set<String> nodeIds = new HashSet<>();, +                                discoveryNodes.forEach(n -> nodeIds.add(n.getId()));, +, +                                final Iterator<String> knownNodeIdIterator = knownMasterNodeIds.iterator();, +                                while (nodeIds.size() < 2 * minimumMasterNodes - 1 && knownNodeIdIterator.hasNext()) {, +                                    nodeIds.add(knownNodeIdIterator.next());, +                                }, +, +                                final VotingConfiguration votingConfiguration = new VotingConfiguration(nodeIds);, +                                assert votingConfiguration.hasQuorum(, +                                    discoveryNodes.stream().map(DiscoveryNode::getId).collect(Collectors.toList()));, +                                assert 2 * minimumMasterNodes - 2 <= nodeIds.size() : nodeIds + " too small for " + minimumMasterNodes;, +, +                                initialConfigurationConsumer.accept(votingConfiguration);, +++ b/server/src/test/java/org/elasticsearch/cluster/coordination/Zen1IT.java, +import org.elasticsearch.action.admin.cluster.health.ClusterHealthRequest;, +import org.elasticsearch.action.admin.indices.create.CreateIndexRequest;, +import org.elasticsearch.discovery.Discovery;, +import org.elasticsearch.plugins.Plugin;, +import org.elasticsearch.test.transport.MockTransportService;, +import org.elasticsearch.transport.TransportService;, +import java.util.Collection;, +import java.util.Collections;, +import static org.elasticsearch.cluster.coordination.FollowersChecker.FOLLOWER_CHECK_ACTION_NAME;, +import static org.elasticsearch.cluster.coordination.JoinHelper.START_JOIN_ACTION_NAME;, +import static org.elasticsearch.cluster.coordination.PublicationTransportHandler.PUBLISH_STATE_ACTION_NAME;, +import static org.elasticsearch.test.hamcrest.ElasticsearchAssertions.assertAcked;, +    protected Collection<Class<? extends Plugin>> nodePlugins() {, +        return Collections.singletonList(MockTransportService.TestPlugin.class);, +    }, +, +    public void testMixedClusterDisruption() throws Exception {, +        final List<String> nodes = internalCluster().startNodes(IntStream.range(0, 5), +            .mapToObj(i -> i < 2 ? ZEN1_SETTINGS : ZEN2_SETTINGS).toArray(Settings[]::new));, +, +        final List<MockTransportService> transportServices = nodes.stream(), +            .map(n -> (MockTransportService) internalCluster().getInstance(TransportService.class, n)).collect(Collectors.toList());, +, +        logger.info("--> disrupting communications");, +, +        // The idea here is to make some of the Zen2 nodes believe the Zen1 nodes have gone away by introducing a network partition, so that, +        // they bootstrap themselves, but keep the Zen1 side of the cluster alive., +, +        // Set up a bridged network partition with the Zen1 nodes {0,1} on one side, Zen2 nodes {3,4} on the other, and node {2} in both, +        transportServices.get(0).addFailToSendNoConnectRule(transportServices.get(3));, +        transportServices.get(0).addFailToSendNoConnectRule(transportServices.get(4));, +        transportServices.get(1).addFailToSendNoConnectRule(transportServices.get(3));, +        transportServices.get(1).addFailToSendNoConnectRule(transportServices.get(4));, +        transportServices.get(3).addFailToSendNoConnectRule(transportServices.get(0));, +        transportServices.get(3).addFailToSendNoConnectRule(transportServices.get(1));, +        transportServices.get(4).addFailToSendNoConnectRule(transportServices.get(0));, +        transportServices.get(4).addFailToSendNoConnectRule(transportServices.get(1));, +, +        // Nodes 3 and 4 will bootstrap, but we want to keep node 2 as part of the Zen1 cluster, so prevent any messages that might switch, +        // its allegiance, +        transportServices.get(3).addFailToSendNoConnectRule(transportServices.get(2),, +            PUBLISH_STATE_ACTION_NAME, FOLLOWER_CHECK_ACTION_NAME, START_JOIN_ACTION_NAME);, +        transportServices.get(4).addFailToSendNoConnectRule(transportServices.get(2),, +            PUBLISH_STATE_ACTION_NAME, FOLLOWER_CHECK_ACTION_NAME, START_JOIN_ACTION_NAME);, +, +        logger.info("--> waiting for disconnected nodes to be removed");, +        ensureStableCluster(3, nodes.get(0));, +, +        logger.info("--> creating index on Zen1 side");]