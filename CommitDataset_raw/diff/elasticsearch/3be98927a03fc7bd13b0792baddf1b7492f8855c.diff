[+++ b/core/src/main/java/org/elasticsearch/action/bulk/BulkRequest.java, +        request.beforeLocalFork();, +        request.beforeLocalFork();, +++ b/core/src/main/java/org/elasticsearch/action/bulk/BulkRequest.java, +        request.beforeLocalFork();, +        request.beforeLocalFork();, +++ b/core/src/main/java/org/elasticsearch/action/support/single/instance/InstanceShardOperationRequest.java, +        // no need to pass threading over the network, they are always false when coming throw a thread pool, +    public void beforeLocalFork() {, +    }, +++ b/core/src/main/java/org/elasticsearch/action/bulk/BulkRequest.java, +        request.beforeLocalFork();, +        request.beforeLocalFork();, +++ b/core/src/main/java/org/elasticsearch/action/support/single/instance/InstanceShardOperationRequest.java, +        // no need to pass threading over the network, they are always false when coming throw a thread pool, +    public void beforeLocalFork() {, +    }, +++ b/core/src/main/java/org/elasticsearch/action/support/single/instance/TransportInstanceSingleOperationAction.java, +    protected abstract void shardOperation(InternalRequest request, ActionListener<Response> listener);, +    protected ClusterBlockException checkRequestBlock(ClusterState state, InternalRequest request) {, +    protected abstract boolean resolveRequest(ClusterState state, InternalRequest request, ActionListener<Response> listener);, +    protected abstract ShardIterator shards(ClusterState clusterState, InternalRequest request);, +        private final InternalRequest internalRequest;, +            this.internalRequest = new InternalRequest(request);, +            this.observer = new ClusterStateObserver(clusterService, internalRequest.request().timeout(), logger);, +                internalRequest.concreteIndex(indexNameExpressionResolver.concreteSingleIndex(observer.observedState(), internalRequest.request()));, +                if (!resolveRequest(observer.observedState(), internalRequest, listener)) {, +                blockException = checkRequestBlock(observer.observedState(), internalRequest);, +                shardIt = shards(observer.observedState(), internalRequest);, +            internalRequest.request().shardId = shardIt.shardId().id();, +            if (shard.currentNodeId().equals(nodes.localNodeId())) {, +                internalRequest.request().beforeLocalFork();, +                try {, +                    threadPool.executor(executor).execute(new Runnable() {, +                        @Override, +                        public void run() {, +                            try {, +                                shardOperation(internalRequest, listener);, +                            } catch (Throwable e) {, +                                if (retryOnFailure(e)) {, +                                    operationStarted.set(false);, +                                    // we already marked it as started when we executed it (removed the listener) so pass false, +                                    // to re-add to the cluster listener, +                                    retry(null);, +                                } else {, +                                    listener.onFailure(e);, +                                }, +                            }, +                        }, +                    });, +                } catch (Throwable e) {, +                    if (retryOnFailure(e)) {, +                        retry(null);, +                    } else {, +                        listener.onFailure(e);, +                    }, +                }, +            } else {, +                transportService.sendRequest(node, actionName, internalRequest.request(), transportOptions(), new BaseTransportResponseHandler<Response>() {, +            }, +            // make it threaded operation so we fork on the discovery listener thread, +            internalRequest.request().beforeLocalFork();, +                                listenFailure = new UnavailableShardsException(new ShardId(internalRequest.concreteIndex(), -1), "Timeout waiting for [" + timeout + "], request: " + internalRequest.request().toString());, +                                listenFailure = new UnavailableShardsException(shardIt.shardId(), "[" + shardIt.size() + "] shardIt, [" + shardIt.sizeActive() + "] active : Timeout waiting for [" + timeout + "], request: " + internalRequest.request().toString());, +            }, internalRequest.request().timeout());, +    /**, +     * Internal request class that gets built on each node. Holds the original request plus additional info., +     */, +    protected class InternalRequest {, +        final Request request;, +        String concreteIndex;, +        InternalRequest(Request request) {, +            this.request = request;, +        public Request request() {, +            return request;, +        void concreteIndex(String concreteIndex) {, +            this.concreteIndex = concreteIndex;, +        }, +, +        public String concreteIndex() {, +            return concreteIndex;, +++ b/core/src/main/java/org/elasticsearch/action/bulk/BulkRequest.java, +        request.beforeLocalFork();, +        request.beforeLocalFork();, +++ b/core/src/main/java/org/elasticsearch/action/support/single/instance/InstanceShardOperationRequest.java, +        // no need to pass threading over the network, they are always false when coming throw a thread pool, +    public void beforeLocalFork() {, +    }, +++ b/core/src/main/java/org/elasticsearch/action/support/single/instance/TransportInstanceSingleOperationAction.java, +    protected abstract void shardOperation(InternalRequest request, ActionListener<Response> listener);, +    protected ClusterBlockException checkRequestBlock(ClusterState state, InternalRequest request) {, +    protected abstract boolean resolveRequest(ClusterState state, InternalRequest request, ActionListener<Response> listener);, +    protected abstract ShardIterator shards(ClusterState clusterState, InternalRequest request);, +        private final InternalRequest internalRequest;, +            this.internalRequest = new InternalRequest(request);, +            this.observer = new ClusterStateObserver(clusterService, internalRequest.request().timeout(), logger);, +                internalRequest.concreteIndex(indexNameExpressionResolver.concreteSingleIndex(observer.observedState(), internalRequest.request()));, +                if (!resolveRequest(observer.observedState(), internalRequest, listener)) {, +                blockException = checkRequestBlock(observer.observedState(), internalRequest);, +                shardIt = shards(observer.observedState(), internalRequest);]