[+++ b/src/main/java/org/elasticsearch/discovery/zen/ping/unicast/UnicastZenPing.java, +import org.apache.lucene.util.IOUtils;, +import org.elasticsearch.common.util.concurrent.AbstractRunnable;, +import java.io.Closeable;, +import java.util.concurrent.atomic.AtomicBoolean;, +    private final Map<Integer, SendPingsHandler> receivedResponses = newConcurrentMap();, +    private final ExecutorService unicastConnectExecutor;, +, +    private volatile boolean closed = false;, +, +, +        ThreadFactory threadFactory = EsExecutors.daemonThreadFactory(settings, "[unicast_connect]");, +        unicastConnectExecutor = EsExecutors.newScaling(0, concurrentConnects, 60, TimeUnit.SECONDS, threadFactory);, +        ThreadPool.terminate(unicastConnectExecutor, 0, TimeUnit.SECONDS);, +        try {, +            IOUtils.close(receivedResponses.values());, +        } catch (IOException e) {, +            throw new ElasticsearchException("Error wile closing send ping handlers", e);, +        }, +        closed = true;, +        receivedResponses.put(sendPingsHandler.id(), sendPingsHandler);, +        } catch (RejectedExecutionException e) {, +            logger.debug("Ping execution rejected", e);, +            // The RejectedExecutionException can come from the fact unicastConnectExecutor is at its max down in sendPings, +            // But don't bail here, we can retry later on after the send ping has been scheduled., +        }, +        threadPool.schedule(TimeValue.timeValueMillis(timeout.millis() / 2), ThreadPool.Names.GENERIC, new AbstractRunnable() {, +            protected void doRun() {, +                sendPings(timeout, null, sendPingsHandler);, +                threadPool.schedule(TimeValue.timeValueMillis(timeout.millis() / 2), ThreadPool.Names.GENERIC, new AbstractRunnable() {, +                    @Override, +                    protected void doRun() throws Exception {, +                        listener.onPing(sendPingsHandler.pingCollection().toArray());, +, +                    @Override, +                    public void onFailure(Throwable t) {, +                        logger.debug("Ping execution failed", t);, +                        sendPingsHandler.close();, +            @Override, +            public void onFailure(Throwable t) {, +                logger.debug("Ping execution failed", t);, +                sendPingsHandler.close();, +            }, +        });, +    }, +, +    class SendPingsHandler implements Closeable {, +        private final PingCollection pingCollection;, +, +        private AtomicBoolean closed = new AtomicBoolean(false);, +            this.pingCollection = new PingCollection();, +            return this.closed.get();, +        public PingCollection pingCollection() {, +            return pingCollection;, +            if (closed.compareAndSet(false, true)) {, +                receivedResponses.remove(id);, +            }, +                unicastConnectExecutor.execute(new Runnable() {, +                        SendPingsHandler sendPingsHandler = receivedResponses.get(response.id);, +                        if (sendPingsHandler == null) {, +                            if (!closed) {, +                                // Only log when we're not closing the node. Having no send ping handler is then expected, +                            }, +                            sendPingsHandler.pingCollection().addPing(pingResponse);]