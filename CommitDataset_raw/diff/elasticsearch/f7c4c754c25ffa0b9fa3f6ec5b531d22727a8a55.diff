[+++ b/dev-tools/checkstyle_suppressions.xml, +++ b/dev-tools/checkstyle_suppressions.xml, +++ b/plugin/src/main/java/org/elasticsearch/xpack/ml/action/StartDatafeedAction.java, +import org.elasticsearch.ElasticsearchParseException;, +import org.elasticsearch.action.ValidateActions;, +import org.elasticsearch.common.joda.DateMathParser;, +import org.elasticsearch.index.mapper.DateFieldMapper;, +import org.elasticsearch.xpack.ml.job.messages.Messages;, +import java.util.function.LongSupplier;, +            PARSER.declareString((request, startTime) -> request.startTime = parseDateOrThrow(, +                    startTime, START_TIME, () -> System.currentTimeMillis()), START_TIME);, +            PARSER.declareString(Request::setEndTime, END_TIME);, +        static long parseDateOrThrow(String date, ParseField paramName, LongSupplier now) {, +            DateMathParser dateMathParser = new DateMathParser(DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER);, +, +            try {, +                return dateMathParser.parse(date, now);, +            } catch (Exception e) {, +                String msg = Messages.getMessage(Messages.REST_INVALID_DATETIME_PARAMS, paramName.getPreferredName(), date);, +                throw new ElasticsearchParseException(msg, e);, +            }, +        }, +, +        public Request(String datafeedId, String startTime) {, +            this(datafeedId, parseDateOrThrow(startTime, START_TIME, () -> System.currentTimeMillis()));, +        }, +, +        public void setEndTime(String endTime) {, +            setEndTime(parseDateOrThrow(endTime, END_TIME, () -> System.currentTimeMillis()));, +        }, +, +            ActionRequestValidationException e = null;, +            if (endTime != null && endTime <= startTime) {, +                e = ValidateActions.addValidationError(START_TIME.getPreferredName() + " [", +                        + startTime + "] must be earlier than " + END_TIME.getPreferredName(), +                        + " [" + endTime + "]", e);, +            }, +            return e;, +            builder.field(START_TIME.getPreferredName(), String.valueOf(startTime));, +                builder.field(END_TIME.getPreferredName(), String.valueOf(endTime));, +            this.startTime = request.getStartTime();, +            this.endTime = request.getEndTime();, +++ b/dev-tools/checkstyle_suppressions.xml, +++ b/plugin/src/main/java/org/elasticsearch/xpack/ml/action/StartDatafeedAction.java, +import org.elasticsearch.ElasticsearchParseException;, +import org.elasticsearch.action.ValidateActions;, +import org.elasticsearch.common.joda.DateMathParser;, +import org.elasticsearch.index.mapper.DateFieldMapper;, +import org.elasticsearch.xpack.ml.job.messages.Messages;, +import java.util.function.LongSupplier;, +            PARSER.declareString((request, startTime) -> request.startTime = parseDateOrThrow(, +                    startTime, START_TIME, () -> System.currentTimeMillis()), START_TIME);, +            PARSER.declareString(Request::setEndTime, END_TIME);, +        static long parseDateOrThrow(String date, ParseField paramName, LongSupplier now) {, +            DateMathParser dateMathParser = new DateMathParser(DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER);, +, +            try {, +                return dateMathParser.parse(date, now);, +            } catch (Exception e) {, +                String msg = Messages.getMessage(Messages.REST_INVALID_DATETIME_PARAMS, paramName.getPreferredName(), date);, +                throw new ElasticsearchParseException(msg, e);, +            }, +        }, +, +        public Request(String datafeedId, String startTime) {, +            this(datafeedId, parseDateOrThrow(startTime, START_TIME, () -> System.currentTimeMillis()));, +        }, +, +        public void setEndTime(String endTime) {, +            setEndTime(parseDateOrThrow(endTime, END_TIME, () -> System.currentTimeMillis()));, +        }, +, +            ActionRequestValidationException e = null;, +            if (endTime != null && endTime <= startTime) {, +                e = ValidateActions.addValidationError(START_TIME.getPreferredName() + " [", +                        + startTime + "] must be earlier than " + END_TIME.getPreferredName(), +                        + " [" + endTime + "]", e);, +            }, +            return e;, +            builder.field(START_TIME.getPreferredName(), String.valueOf(startTime));, +                builder.field(END_TIME.getPreferredName(), String.valueOf(endTime));, +            this.startTime = request.getStartTime();, +            this.endTime = request.getEndTime();, +++ b/plugin/src/main/java/org/elasticsearch/xpack/ml/rest/datafeeds/RestStartDatafeedAction.java, +            String startTime = restRequest.param(StartDatafeedAction.START_TIME.getPreferredName(), DEFAULT_START);, +            jobDatafeedRequest = new StartDatafeedAction.Request(datafeedId, startTime);, +                jobDatafeedRequest.setEndTime(restRequest.param(StartDatafeedAction.END_TIME.getPreferredName()));, +++ b/dev-tools/checkstyle_suppressions.xml, +++ b/plugin/src/main/java/org/elasticsearch/xpack/ml/action/StartDatafeedAction.java, +import org.elasticsearch.ElasticsearchParseException;, +import org.elasticsearch.action.ValidateActions;, +import org.elasticsearch.common.joda.DateMathParser;, +import org.elasticsearch.index.mapper.DateFieldMapper;, +import org.elasticsearch.xpack.ml.job.messages.Messages;, +import java.util.function.LongSupplier;, +            PARSER.declareString((request, startTime) -> request.startTime = parseDateOrThrow(, +                    startTime, START_TIME, () -> System.currentTimeMillis()), START_TIME);, +            PARSER.declareString(Request::setEndTime, END_TIME);, +        static long parseDateOrThrow(String date, ParseField paramName, LongSupplier now) {, +            DateMathParser dateMathParser = new DateMathParser(DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER);]