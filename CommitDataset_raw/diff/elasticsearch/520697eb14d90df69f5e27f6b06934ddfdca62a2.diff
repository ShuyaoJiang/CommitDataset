[+++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/DynamicCallSite.java, +// NOTE: this class must be public, because generated painless classes are in a different classloader,, +    private DynamicCallSite() {} // no instance!, +, +    static final class InliningCacheCallSite extends MutableCallSite {, +        private final String name;, +        private final int flavor;, +        int depth; // pkg-protected for testing, +        InliningCacheCallSite(String name, MethodType type, int flavor) {, +            MethodHandle fallback = FALLBACK.bindTo(this);, +            setTarget(fallback);, +        Object fallback(Object[] args) throws Throwable {, +            MethodType type = type();, +            MethodHandle target = lookup(flavor, receiverClass, name);, +            if (depth >= MAX_DEPTH) {, +                setTarget(target);, +            MethodHandle guard = MethodHandles.guardWithTest(test, target, getTarget());, +            depth++;, +            setTarget(guard);, +            final Lookup lookup = MethodHandles.lookup();, +                CHECK_CLASS = lookup.findStatic(lookup.lookupClass(), "checkClass",, +                FALLBACK = lookup.findVirtual(lookup.lookupClass(), "fallback",, +                                             MethodType.methodType(Object.class, Object[].class));, +, +    /**, +     * invokeDynamic bootstrap method, +     * <p>, +     * In addition to ordinary parameters, we also take a static parameter {@code flavor} which, +     * tells us what type of dynamic call it is (and which part of whitelist to look at)., +     * <p>, +     * see https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-6.html#jvms-6.5.invokedynamic, +     */, +    public static CallSite bootstrap(Lookup lookup, String name, MethodType type, int flavor) {, +        return new InliningCacheCallSite(name, type, flavor);, +    }, +, +}]