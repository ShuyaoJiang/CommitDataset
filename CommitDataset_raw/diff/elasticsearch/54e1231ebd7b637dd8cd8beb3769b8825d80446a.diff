[+++ b/x-pack/plugin/ccr/src/test/java/org/elasticsearch/xpack/CcrIntegTestCase.java, +import org.elasticsearch.action.admin.indices.stats.ShardStats;, +import org.elasticsearch.cluster.routing.ShardRouting;, +import org.elasticsearch.common.Randomness;, +import org.elasticsearch.index.engine.DocIdSeqNoAndTerm;, +import org.elasticsearch.index.seqno.SeqNoStats;, +import java.util.HashMap;, +import java.util.List;, +import java.util.stream.Collectors;, +import static org.hamcrest.Matchers.greaterThanOrEqualTo;, +        logger.info("ensure green leader indices {}", Arrays.toString(indices));, +        logger.info("ensure green follower indices {}", Arrays.toString(indices));, +    /**, +     * This asserts the index is fully replicated from the leader index to the follower index. It first verifies that the seq_no_stats, +     * on the follower equal the leader's; then verifies the existing pairs of (docId, seqNo) on the follower also equal the leader., +     */, +    protected void assertIndexFullyReplicatedToFollower(String leaderIndex, String followerIndex) throws Exception {, +        logger.info("--> asserting seq_no_stats between {} and {}", leaderIndex, followerIndex);, +            Map<Integer, SeqNoStats> leaderStats = new HashMap<>();, +            for (ShardStats shardStat : leaderClient().admin().indices().prepareStats(leaderIndex).clear().get().getShards()) {, +                if (shardStat.getSeqNoStats() == null) {, +                    throw new AssertionError("leader seq_no_stats is not available [" + Strings.toString(shardStat) + "]");, +                }, +                leaderStats.put(shardStat.getShardRouting().shardId().id(), shardStat.getSeqNoStats());, +            }, +            Map<Integer, SeqNoStats> followerStats = new HashMap<>();, +            for (ShardStats shardStat : followerClient().admin().indices().prepareStats(followerIndex).clear().get().getShards()) {, +                if (shardStat.getSeqNoStats() == null) {, +                    throw new AssertionError("follower seq_no_stats is not available [" + Strings.toString(shardStat) + "]");, +                }, +                followerStats.put(shardStat.getShardRouting().shardId().id(), shardStat.getSeqNoStats());, +            }, +            assertThat(leaderStats, equalTo(followerStats));, +        logger.info("--> asserting <<docId,seqNo>> between {} and {}", leaderIndex, followerIndex);, +        assertBusy(() -> {, +            assertThat(getDocIdAndSeqNos(clusterGroup.leaderCluster, leaderIndex),, +                equalTo(getDocIdAndSeqNos(clusterGroup.followerCluster, followerIndex)));, +        }, 60, TimeUnit.SECONDS);, +    }, +, +    private Map<Integer, List<DocIdSeqNoAndTerm>> getDocIdAndSeqNos(InternalTestCluster cluster, String index) throws IOException {, +        final ClusterState state = cluster.client().admin().cluster().prepareState().get().getState();, +        List<ShardRouting> shardRoutings = state.routingTable().allShards(index);, +        Randomness.shuffle(shardRoutings);, +        final Map<Integer, List<DocIdSeqNoAndTerm>> docs = new HashMap<>();, +        for (ShardRouting shardRouting : shardRoutings) {, +            if (shardRouting == null || shardRouting.assignedToNode() == false || docs.containsKey(shardRouting.shardId().id())) {, +                continue;, +            }, +            IndexShard indexShard = cluster.getInstance(IndicesService.class, state.nodes().get(shardRouting.currentNodeId()).getName()), +                .indexServiceSafe(shardRouting.index()).getShard(shardRouting.id());, +            docs.put(shardRouting.shardId().id(), IndexShardTestCase.getDocIdAndSeqNos(indexShard).stream(), +                .map(d -> new DocIdSeqNoAndTerm(d.getId(), d.getSeqNo(), 1L))  // normalize primary term as the follower use its own term, +                .collect(Collectors.toList()));, +        }, +        return docs;, +    protected void awaitGlobalCheckpointAtLeast(Client client, ShardId shardId, long minimumGlobalCheckpoint) throws Exception {, +        logger.info("waiting for the global checkpoint on [{}] at least [{}]", shardId, minimumGlobalCheckpoint);, +        assertBusy(() -> {, +            ShardStats stats = client.admin().indices().prepareStats(shardId.getIndexName()).clear().get(), +                .asMap().entrySet().stream().filter(e -> e.getKey().shardId().equals(shardId)), +                .map(Map.Entry::getValue).findFirst().orElse(null);, +            if (stats == null || stats.getSeqNoStats() == null) {, +                throw new AssertionError("seq_no_stats for shard [" + shardId + "] is not found"); // causes assertBusy to retry, +            }, +            assertThat(Strings.toString(stats.getSeqNoStats()),, +                stats.getSeqNoStats().getGlobalCheckpoint(), greaterThanOrEqualTo(minimumGlobalCheckpoint));, +        }, 60, TimeUnit.SECONDS);, +    }, +, +++ b/x-pack/plugin/ccr/src/test/java/org/elasticsearch/xpack/CcrIntegTestCase.java, +import org.elasticsearch.action.admin.indices.stats.ShardStats;, +import org.elasticsearch.cluster.routing.ShardRouting;, +import org.elasticsearch.common.Randomness;, +import org.elasticsearch.index.engine.DocIdSeqNoAndTerm;, +import org.elasticsearch.index.seqno.SeqNoStats;, +import java.util.HashMap;, +import java.util.List;, +import java.util.stream.Collectors;, +import static org.hamcrest.Matchers.greaterThanOrEqualTo;, +        logger.info("ensure green leader indices {}", Arrays.toString(indices));, +        logger.info("ensure green follower indices {}", Arrays.toString(indices));, +    /**, +     * This asserts the index is fully replicated from the leader index to the follower index. It first verifies that the seq_no_stats, +     * on the follower equal the leader's; then verifies the existing pairs of (docId, seqNo) on the follower also equal the leader., +     */, +    protected void assertIndexFullyReplicatedToFollower(String leaderIndex, String followerIndex) throws Exception {, +        logger.info("--> asserting seq_no_stats between {} and {}", leaderIndex, followerIndex);, +            Map<Integer, SeqNoStats> leaderStats = new HashMap<>();, +            for (ShardStats shardStat : leaderClient().admin().indices().prepareStats(leaderIndex).clear().get().getShards()) {, +                if (shardStat.getSeqNoStats() == null) {, +                    throw new AssertionError("leader seq_no_stats is not available [" + Strings.toString(shardStat) + "]");, +                }, +                leaderStats.put(shardStat.getShardRouting().shardId().id(), shardStat.getSeqNoStats());, +            }, +            Map<Integer, SeqNoStats> followerStats = new HashMap<>();, +            for (ShardStats shardStat : followerClient().admin().indices().prepareStats(followerIndex).clear().get().getShards()) {, +                if (shardStat.getSeqNoStats() == null) {, +                    throw new AssertionError("follower seq_no_stats is not available [" + Strings.toString(shardStat) + "]");, +                }]