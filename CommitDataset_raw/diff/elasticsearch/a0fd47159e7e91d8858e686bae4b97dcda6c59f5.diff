[+++ b/modules/elasticsearch/src/main/java/org/elasticsearch/action/search/type/TransportSearchCountAction.java, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/action/search/type/TransportSearchCountAction.java, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/action/search/type/TransportSearchScanAction.java, +import org.elasticsearch.common.collect.ImmutableMap;, +import org.elasticsearch.search.controller.ShardDoc;, +import org.elasticsearch.search.fetch.FetchSearchResultProvider;, +import org.elasticsearch.search.query.QuerySearchResult;, +import org.elasticsearch.search.query.QuerySearchResultProvider;, +import static org.elasticsearch.action.search.type.TransportSearchHelper.*;, +, +    private class AsyncAction extends BaseAsyncAction<QuerySearchResult> {, +        private final Map<SearchShardTarget, QuerySearchResultProvider> queryResults = searchCache.obtainQueryResults();, +        @Override protected void sendExecuteFirstPhase(DiscoveryNode node, InternalSearchRequest request, SearchServiceListener<QuerySearchResult> listener) {, +        @Override protected void processFirstPhaseResult(ShardRouting shard, QuerySearchResult result) {, +            queryResults.put(result.shardTarget(), result);, +            final InternalSearchResponse internalResponse = searchPhaseController.merge(EMPTY_DOCS, queryResults, ImmutableMap.<SearchShardTarget, FetchSearchResultProvider>of());, +                scrollId = buildScrollId(request.searchType(), queryResults.values());, +            searchCache.releaseQueryResults(queryResults);, +, +    private static ShardDoc[] EMPTY_DOCS = new ShardDoc[0];, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/action/search/type/TransportSearchCountAction.java, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/action/search/type/TransportSearchScanAction.java, +import org.elasticsearch.common.collect.ImmutableMap;, +import org.elasticsearch.search.controller.ShardDoc;, +import org.elasticsearch.search.fetch.FetchSearchResultProvider;, +import org.elasticsearch.search.query.QuerySearchResult;, +import org.elasticsearch.search.query.QuerySearchResultProvider;, +import static org.elasticsearch.action.search.type.TransportSearchHelper.*;, +, +    private class AsyncAction extends BaseAsyncAction<QuerySearchResult> {, +        private final Map<SearchShardTarget, QuerySearchResultProvider> queryResults = searchCache.obtainQueryResults();, +        @Override protected void sendExecuteFirstPhase(DiscoveryNode node, InternalSearchRequest request, SearchServiceListener<QuerySearchResult> listener) {, +        @Override protected void processFirstPhaseResult(ShardRouting shard, QuerySearchResult result) {, +            queryResults.put(result.shardTarget(), result);, +            final InternalSearchResponse internalResponse = searchPhaseController.merge(EMPTY_DOCS, queryResults, ImmutableMap.<SearchShardTarget, FetchSearchResultProvider>of());, +                scrollId = buildScrollId(request.searchType(), queryResults.values());, +            searchCache.releaseQueryResults(queryResults);, +, +    private static ShardDoc[] EMPTY_DOCS = new ShardDoc[0];, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/search/SearchService.java, +    public QuerySearchResult executeScan(InternalSearchRequest request) throws ElasticSearchException {, +        assert context.searchType() == SearchType.SCAN;, +        context.searchType(SearchType.COUNT); // move to COUNT, and then, when scrolling, move to SCAN, +        assert context.searchType() == SearchType.COUNT;, +            contextProcessing(context);, +            queryPhase.execute(context);, +            return context.queryResult();, +            if (context.searchType() == SearchType.COUNT) {, +                context.searchType(SearchType.SCAN);, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/action/search/type/TransportSearchCountAction.java, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/action/search/type/TransportSearchScanAction.java, +import org.elasticsearch.common.collect.ImmutableMap;, +import org.elasticsearch.search.controller.ShardDoc;, +import org.elasticsearch.search.fetch.FetchSearchResultProvider;, +import org.elasticsearch.search.query.QuerySearchResult;, +import org.elasticsearch.search.query.QuerySearchResultProvider;, +import static org.elasticsearch.action.search.type.TransportSearchHelper.*;, +, +    private class AsyncAction extends BaseAsyncAction<QuerySearchResult> {, +        private final Map<SearchShardTarget, QuerySearchResultProvider> queryResults = searchCache.obtainQueryResults();, +        @Override protected void sendExecuteFirstPhase(DiscoveryNode node, InternalSearchRequest request, SearchServiceListener<QuerySearchResult> listener) {, +        @Override protected void processFirstPhaseResult(ShardRouting shard, QuerySearchResult result) {, +            queryResults.put(result.shardTarget(), result);, +            final InternalSearchResponse internalResponse = searchPhaseController.merge(EMPTY_DOCS, queryResults, ImmutableMap.<SearchShardTarget, FetchSearchResultProvider>of());, +                scrollId = buildScrollId(request.searchType(), queryResults.values());, +            searchCache.releaseQueryResults(queryResults);, +, +    private static ShardDoc[] EMPTY_DOCS = new ShardDoc[0];, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/search/SearchService.java, +    public QuerySearchResult executeScan(InternalSearchRequest request) throws ElasticSearchException {, +        assert context.searchType() == SearchType.SCAN;, +        context.searchType(SearchType.COUNT); // move to COUNT, and then, when scrolling, move to SCAN, +        assert context.searchType() == SearchType.COUNT;, +            contextProcessing(context);, +            queryPhase.execute(context);, +            return context.queryResult();, +            if (context.searchType() == SearchType.COUNT) {, +                context.searchType(SearchType.SCAN);, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/search/action/SearchServiceTransportAction.java, +    public void sendExecuteScan(DiscoveryNode node, final InternalSearchRequest request, final SearchServiceListener<QuerySearchResult> listener) {, +                QuerySearchResult result = searchService.executeScan(request);, +            transportService.sendRequest(node, SearchScanTransportHandler.ACTION, request, new BaseTransportResponseHandler<QuerySearchResult>() {, +                @Override public QuerySearchResult newInstance() {, +                    return new QuerySearchResult();, +                @Override public void handleResponse(QuerySearchResult response) {, +            QuerySearchResult result = searchService.executeScan(request);, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/action/search/type/TransportSearchCountAction.java, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/action/search/type/TransportSearchScanAction.java, +import org.elasticsearch.common.collect.ImmutableMap;, +import org.elasticsearch.search.controller.ShardDoc;, +import org.elasticsearch.search.fetch.FetchSearchResultProvider;, +import org.elasticsearch.search.query.QuerySearchResult;, +import org.elasticsearch.search.query.QuerySearchResultProvider;, +import static org.elasticsearch.action.search.type.TransportSearchHelper.*;, +, +    private class AsyncAction extends BaseAsyncAction<QuerySearchResult> {, +        private final Map<SearchShardTarget, QuerySearchResultProvider> queryResults = searchCache.obtainQueryResults();, +        @Override protected void sendExecuteFirstPhase(DiscoveryNode node, InternalSearchRequest request, SearchServiceListener<QuerySearchResult> listener) {, +        @Override protected void processFirstPhaseResult(ShardRouting shard, QuerySearchResult result) {, +            queryResults.put(result.shardTarget(), result);]