[+++ b/x-pack/plugin/watcher/src/main/java/org/elasticsearch/xpack/watcher/execution/ExecutionService.java, +    public static final class WatchExecutionTask implements Runnable {, +        public WatchExecutionTask(WatchExecutionContext ctx, Runnable runnable) {, +++ b/x-pack/plugin/watcher/src/main/java/org/elasticsearch/xpack/watcher/execution/ExecutionService.java, +    public static final class WatchExecutionTask implements Runnable {, +        public WatchExecutionTask(WatchExecutionContext ctx, Runnable runnable) {, +++ b/x-pack/plugin/watcher/src/main/java/org/elasticsearch/xpack/watcher/transport/actions/execute/TransportExecuteWatchAction.java, +import org.elasticsearch.xpack.core.watcher.execution.WatchExecutionContext;, +    private void executeWatch(, +            final ExecuteWatchRequest request,, +            final ActionListener<ExecuteWatchResponse> listener,, +            final Watch watch,, +            final boolean knownWatch) {, +        try {, +            /*, +             * Ensure that the headers from the incoming request are used instead those of the stored watch otherwise the watch would run, +             * as the user who stored the watch, but it needs to run as the user who executes this request., +             */, +            final Map<String, String> headers = new HashMap<>(threadPool.getThreadContext().getHeaders());, +            final String triggerType = watch.trigger().type();, +            final TriggerEvent triggerEvent = triggerService.simulateEvent(triggerType, watch.id(), request.getTriggerData());, +            final ManualExecutionContext.Builder ctxBuilder = ManualExecutionContext.builder(, +                    watch,, +                    knownWatch,, +            final ZonedDateTime executionTime = clock.instant().atZone(ZoneOffset.UTC);, +            for (final Map.Entry<String, ActionExecutionMode> entry : request.getActionModes().entrySet()) {, +            final WatchExecutionContext ctx = ctxBuilder.build();, +            // use execute so that the runnable is not wrapped in a RunnableFuture<?>, +            threadPool.executor(XPackField.WATCHER).execute(new ExecutionService.WatchExecutionTask(ctx, new AbstractRunnable() {, +, +                @Override, +                public void onFailure(final Exception e) {, +                    listener.onFailure(e);, +                }, +, +                @Override, +                protected void doRun() throws Exception {, +                    final WatchRecord record = executionService.execute(ctx);, +                    final XContentBuilder builder = XContentFactory.jsonBuilder();, +, +            }));, +        } catch (final Exception e) {, +            listener.onFailure(e);, +        }, +, +, +++ b/x-pack/plugin/watcher/src/main/java/org/elasticsearch/xpack/watcher/execution/ExecutionService.java, +    public static final class WatchExecutionTask implements Runnable {, +        public WatchExecutionTask(WatchExecutionContext ctx, Runnable runnable) {, +++ b/x-pack/plugin/watcher/src/main/java/org/elasticsearch/xpack/watcher/transport/actions/execute/TransportExecuteWatchAction.java, +import org.elasticsearch.xpack.core.watcher.execution.WatchExecutionContext;, +    private void executeWatch(, +            final ExecuteWatchRequest request,, +            final ActionListener<ExecuteWatchResponse> listener,, +            final Watch watch,, +            final boolean knownWatch) {, +        try {, +            /*, +             * Ensure that the headers from the incoming request are used instead those of the stored watch otherwise the watch would run, +             * as the user who stored the watch, but it needs to run as the user who executes this request., +             */, +            final Map<String, String> headers = new HashMap<>(threadPool.getThreadContext().getHeaders());, +            final String triggerType = watch.trigger().type();, +            final TriggerEvent triggerEvent = triggerService.simulateEvent(triggerType, watch.id(), request.getTriggerData());, +            final ManualExecutionContext.Builder ctxBuilder = ManualExecutionContext.builder(, +                    watch,, +                    knownWatch,, +            final ZonedDateTime executionTime = clock.instant().atZone(ZoneOffset.UTC);, +            for (final Map.Entry<String, ActionExecutionMode> entry : request.getActionModes().entrySet()) {, +            final WatchExecutionContext ctx = ctxBuilder.build();, +            // use execute so that the runnable is not wrapped in a RunnableFuture<?>, +            threadPool.executor(XPackField.WATCHER).execute(new ExecutionService.WatchExecutionTask(ctx, new AbstractRunnable() {, +, +                @Override, +                public void onFailure(final Exception e) {, +                    listener.onFailure(e);, +                }, +, +                @Override, +                protected void doRun() throws Exception {, +                    final WatchRecord record = executionService.execute(ctx);, +                    final XContentBuilder builder = XContentFactory.jsonBuilder();, +, +            }));, +        } catch (final Exception e) {, +            listener.onFailure(e);, +        }, +, +, +++ b/x-pack/plugin/watcher/src/test/java/org/elasticsearch/xpack/watcher/execution/ExecuteWatchQueuedStatsTests.java, +/*, + * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one, + * or more contributor license agreements. Licensed under the Elastic License;, + * you may not use this file except in compliance with the Elastic License., + */, +, +package org.elasticsearch.xpack.watcher.execution;, +, +import org.elasticsearch.action.ActionFuture;, +import org.elasticsearch.action.FailedNodeException;]