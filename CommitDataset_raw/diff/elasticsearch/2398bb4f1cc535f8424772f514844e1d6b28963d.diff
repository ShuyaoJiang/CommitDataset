[+++ b/core-signatures.txt, +, +@defaultMessage Only use wait / notify when really needed try to use concurrency primitives, latches or callbacks instead. , +java.lang.Object#wait(), +java.lang.Object#wait(long), +java.lang.Object#wait(long,int), +java.lang.Object#notify(), +java.lang.Object#notifyAll(), +++ b/core-signatures.txt, +, +@defaultMessage Only use wait / notify when really needed try to use concurrency primitives, latches or callbacks instead. , +java.lang.Object#wait(), +java.lang.Object#wait(long), +java.lang.Object#wait(long,int), +java.lang.Object#notify(), +java.lang.Object#notifyAll(), +++ b/src/main/java/org/elasticsearch/common/blobstore/fs/FsImmutableBlobContainer.java, +import org.apache.lucene.util.IOUtils;, +                } catch (Throwable e) {, +                boolean success = false;, +                    boolean innerSuccess = false;, +                        innerSuccess = true;, +                        if (innerSuccess) {, +                            IOUtils.close(is, raf);, +                        } else {, +                            IOUtils.closeWhileHandlingException(is, raf);, +                    success = true;, +                } catch (Throwable e) {, +                    listener.onFailure(e);, +                } finally {, +                   if (success) {, +                       listener.onCompleted();, +                   }, +++ b/core-signatures.txt, +, +@defaultMessage Only use wait / notify when really needed try to use concurrency primitives, latches or callbacks instead. , +java.lang.Object#wait(), +java.lang.Object#wait(long), +java.lang.Object#wait(long,int), +java.lang.Object#notify(), +java.lang.Object#notifyAll(), +++ b/src/main/java/org/elasticsearch/common/blobstore/fs/FsImmutableBlobContainer.java, +import org.apache.lucene.util.IOUtils;, +                } catch (Throwable e) {, +                boolean success = false;, +                    boolean innerSuccess = false;, +                        innerSuccess = true;, +                        if (innerSuccess) {, +                            IOUtils.close(is, raf);, +                        } else {, +                            IOUtils.closeWhileHandlingException(is, raf);, +                    success = true;, +                } catch (Throwable e) {, +                    listener.onFailure(e);, +                } finally {, +                   if (success) {, +                       listener.onCompleted();, +                   }, +++ b/src/main/java/org/elasticsearch/index/engine/internal/InternalEngine.java, +import org.elasticsearch.common.lease.Releasable;, +import org.elasticsearch.common.lease.Releasables;, +        store.incRef();, +                Releasables.releaseWhileHandlingException(searcher);, +                    Releasables.release(searcher);, +                Releasables.release(searcher);, +        Translog.Snapshot translogSnapshot = null;, +            translogSnapshot = translog.snapshot();, +            Releasables.releaseWhileHandlingException(snapshotIndexCommit);, +            return snapshotHandler.snapshot(snapshotIndexCommit, translogSnapshot);, +            Releasables.release(snapshotIndexCommit, translogSnapshot);, +            onGoingRecoveries.startRecovery();, +            Releasables.releaseWhileHandlingException(onGoingRecoveries);, +            Releasables.releaseWhileHandlingException(onGoingRecoveries, phase1Snapshot);, +            Releasables.releaseWhileHandlingException(onGoingRecoveries, phase1Snapshot);, +            Releasables.releaseWhileHandlingException(onGoingRecoveries, phase1Snapshot, phase2Snapshot);, +        boolean success = false;, +            success = true;, +            Releasables.release(success, onGoingRecoveries);, +            Releasables.release(success, phase1Snapshot, phase2Snapshot, phase3Snapshot);, +            // TODO - should we acquire the writeLock here?, +        if (!closed) {, +            try {, +                indexSettingsService.removeListener(applySettings);, +                store.decRef();, +            }, +            store.incRef();, +            } finally {, +                store.decRef();, +                    Releasables.release(currentSearcher);, +    private final class RecoveryCounter implements Releasable {, +        private final AtomicInteger onGoingRecoveries = new AtomicInteger();, +        public void startRecovery() {, +            store.incRef();, +            onGoingRecoveries.incrementAndGet();, +        public int get() {, +            return onGoingRecoveries.get();, +        public void endRecovery() throws ElasticsearchException {, +            store.decRef();, +            onGoingRecoveries.decrementAndGet();, +            assert onGoingRecoveries.get() >= 0 : "ongoingRecoveries must be >= 0 but was: " + onGoingRecoveries.get();]