[+++ b/core/src/main/java/org/elasticsearch/search/aggregations/bucket/range/AbstractRangeAggregatorFactory.java, +    private final R[] ranges;, +    public AbstractRangeAggregatorFactory(String name, Type type, ValuesSourceConfig<Numeric> config, R[] ranges, boolean keyed,, +        return new Unmapped<>(name, ranges, keyed, config.format(), context, parent, rangeFactory, pipelineAggregators, metaData);, +++ b/core/src/main/java/org/elasticsearch/search/aggregations/bucket/range/AbstractRangeAggregatorFactory.java, +    private final R[] ranges;, +    public AbstractRangeAggregatorFactory(String name, Type type, ValuesSourceConfig<Numeric> config, R[] ranges, boolean keyed,, +        return new Unmapped<>(name, ranges, keyed, config.format(), context, parent, rangeFactory, pipelineAggregators, metaData);, +++ b/core/src/main/java/org/elasticsearch/search/aggregations/bucket/range/AbstractRangeBuilder.java, +import org.apache.lucene.util.InPlaceMergeSorter;, +import org.elasticsearch.search.aggregations.support.AggregationContext;, +import org.elasticsearch.search.aggregations.support.ValuesSourceConfig;, +import org.elasticsearch.search.aggregations.support.ValuesSource.Numeric;, +    /**, +     * Resolve any strings in the ranges so we have a number value for the from, +     * and to of each range. The ranges are also sorted before being returned., +     */, +    protected Range[] processRanges(AggregationContext context, ValuesSourceConfig<Numeric> config) {, +        Range[] ranges = new Range[this.ranges.size()];, +        for (int i = 0; i < ranges.length; i++) {, +            ranges[i] = this.ranges.get(i).process(config.format(), context.searchContext());, +        }, +        sortRanges(ranges);, +        return ranges;, +    }, +, +    private static void sortRanges(final Range[] ranges) {, +        new InPlaceMergeSorter() {, +, +            @Override, +            protected void swap(int i, int j) {, +                final Range tmp = ranges[i];, +                ranges[i] = ranges[j];, +                ranges[j] = tmp;, +            }, +, +            @Override, +            protected int compare(int i, int j) {, +                int cmp = Double.compare(ranges[i].from, ranges[j].from);, +                if (cmp == 0) {, +                    cmp = Double.compare(ranges[i].to, ranges[j].to);, +                }, +                return cmp;, +            }, +        }.sort(0, ranges.length);, +    }, +, +++ b/core/src/main/java/org/elasticsearch/search/aggregations/bucket/range/AbstractRangeAggregatorFactory.java, +    private final R[] ranges;, +    public AbstractRangeAggregatorFactory(String name, Type type, ValuesSourceConfig<Numeric> config, R[] ranges, boolean keyed,, +        return new Unmapped<>(name, ranges, keyed, config.format(), context, parent, rangeFactory, pipelineAggregators, metaData);, +++ b/core/src/main/java/org/elasticsearch/search/aggregations/bucket/range/AbstractRangeBuilder.java, +import org.apache.lucene.util.InPlaceMergeSorter;, +import org.elasticsearch.search.aggregations.support.AggregationContext;, +import org.elasticsearch.search.aggregations.support.ValuesSourceConfig;, +import org.elasticsearch.search.aggregations.support.ValuesSource.Numeric;, +    /**, +     * Resolve any strings in the ranges so we have a number value for the from, +     * and to of each range. The ranges are also sorted before being returned., +     */, +    protected Range[] processRanges(AggregationContext context, ValuesSourceConfig<Numeric> config) {, +        Range[] ranges = new Range[this.ranges.size()];, +        for (int i = 0; i < ranges.length; i++) {, +            ranges[i] = this.ranges.get(i).process(config.format(), context.searchContext());, +        }, +        sortRanges(ranges);, +        return ranges;, +    }, +, +    private static void sortRanges(final Range[] ranges) {, +        new InPlaceMergeSorter() {, +, +            @Override, +            protected void swap(int i, int j) {, +                final Range tmp = ranges[i];, +                ranges[i] = ranges[j];, +                ranges[j] = tmp;, +            }, +, +            @Override, +            protected int compare(int i, int j) {, +                int cmp = Double.compare(ranges[i].from, ranges[j].from);, +                if (cmp == 0) {, +                    cmp = Double.compare(ranges[i].to, ranges[j].to);, +                }, +                return cmp;, +            }, +        }.sort(0, ranges.length);, +    }, +, +++ b/core/src/main/java/org/elasticsearch/search/aggregations/bucket/range/RangeAggregationBuilder.java, +        // We need to call processRanges here so they are parsed before we make the decision of whether to cache the request, +        Range[] ranges = processRanges(context, config);, +++ b/core/src/main/java/org/elasticsearch/search/aggregations/bucket/range/AbstractRangeAggregatorFactory.java, +    private final R[] ranges;, +    public AbstractRangeAggregatorFactory(String name, Type type, ValuesSourceConfig<Numeric> config, R[] ranges, boolean keyed,, +        return new Unmapped<>(name, ranges, keyed, config.format(), context, parent, rangeFactory, pipelineAggregators, metaData);, +++ b/core/src/main/java/org/elasticsearch/search/aggregations/bucket/range/AbstractRangeBuilder.java, +import org.apache.lucene.util.InPlaceMergeSorter;, +import org.elasticsearch.search.aggregations.support.AggregationContext;]