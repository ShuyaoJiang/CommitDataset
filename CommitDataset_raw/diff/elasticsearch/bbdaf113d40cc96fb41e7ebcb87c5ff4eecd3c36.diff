[+++ b/core/src/main/java/org/elasticsearch/index/engine/Engine.java, +    public abstract int fillSeqNoGaps(long primaryTerm) throws IOException;, +++ b/core/src/main/java/org/elasticsearch/index/engine/Engine.java, +    public abstract int fillSeqNoGaps(long primaryTerm) throws IOException;, +++ b/core/src/main/java/org/elasticsearch/index/engine/InternalEngine.java, +    public int fillSeqNoGaps(long primaryTerm) throws IOException {, +        try (ReleasableLock ignored = writeLock.acquire()) {, +            final long localCheckpoint = seqNoService().getLocalCheckpoint();, +            final long maxSeqNo = seqNoService().getMaxSeqNo();, +            for (, +                    long seqNo = localCheckpoint + 1;, +                    seqNo <= maxSeqNo;, +                    seqNo = seqNoService().getLocalCheckpoint() + 1 /* the local checkpoint might have advanced so we leap-frog */) {, +                innerNoOp(new NoOp(seqNo, primaryTerm, Operation.Origin.PRIMARY, System.nanoTime(), "filling gaps"));, +                assert seqNo <= seqNoService().getLocalCheckpoint(), +                        : "local checkpoint did not advance; was [" + seqNo + "], now [" + seqNoService().getLocalCheckpoint() + "]";, +++ b/core/src/main/java/org/elasticsearch/index/engine/Engine.java, +    public abstract int fillSeqNoGaps(long primaryTerm) throws IOException;, +++ b/core/src/main/java/org/elasticsearch/index/engine/InternalEngine.java, +    public int fillSeqNoGaps(long primaryTerm) throws IOException {, +        try (ReleasableLock ignored = writeLock.acquire()) {, +            final long localCheckpoint = seqNoService().getLocalCheckpoint();, +            final long maxSeqNo = seqNoService().getMaxSeqNo();, +            for (, +                    long seqNo = localCheckpoint + 1;, +                    seqNo <= maxSeqNo;, +                    seqNo = seqNoService().getLocalCheckpoint() + 1 /* the local checkpoint might have advanced so we leap-frog */) {, +                innerNoOp(new NoOp(seqNo, primaryTerm, Operation.Origin.PRIMARY, System.nanoTime(), "filling gaps"));, +                assert seqNo <= seqNoService().getLocalCheckpoint(), +                        : "local checkpoint did not advance; was [" + seqNo + "], now [" + seqNoService().getLocalCheckpoint() + "]";, +++ b/core/src/main/java/org/elasticsearch/index/shard/StoreRecovery.java, +                indexShard.getEngine().fillSeqNoGaps(indexShard.getPrimaryTerm());, +++ b/core/src/main/java/org/elasticsearch/index/engine/Engine.java, +    public abstract int fillSeqNoGaps(long primaryTerm) throws IOException;, +++ b/core/src/main/java/org/elasticsearch/index/engine/InternalEngine.java, +    public int fillSeqNoGaps(long primaryTerm) throws IOException {, +        try (ReleasableLock ignored = writeLock.acquire()) {, +            final long localCheckpoint = seqNoService().getLocalCheckpoint();, +            final long maxSeqNo = seqNoService().getMaxSeqNo();, +            for (, +                    long seqNo = localCheckpoint + 1;, +                    seqNo <= maxSeqNo;, +                    seqNo = seqNoService().getLocalCheckpoint() + 1 /* the local checkpoint might have advanced so we leap-frog */) {, +                innerNoOp(new NoOp(seqNo, primaryTerm, Operation.Origin.PRIMARY, System.nanoTime(), "filling gaps"));, +                assert seqNo <= seqNoService().getLocalCheckpoint(), +                        : "local checkpoint did not advance; was [" + seqNo + "], now [" + seqNoService().getLocalCheckpoint() + "]";, +++ b/core/src/main/java/org/elasticsearch/index/shard/StoreRecovery.java, +                indexShard.getEngine().fillSeqNoGaps(indexShard.getPrimaryTerm());, +++ b/core/src/test/java/org/elasticsearch/index/engine/InternalEngineTests.java, +            recoveringEngine.recoverFromTranslog();, +            recoveringEngine.fillSeqNoGaps(2);, +            recoveringEngine.recoverFromTranslog();, +            recoveringEngine.fillSeqNoGaps(1);, +            noOpEngine = new InternalEngine(copy(engine.config(), EngineConfig.OpenMode.OPEN_INDEX_AND_TRANSLOG)) {, +                @Override, +                public SequenceNumbersService seqNoService() {, +                    return seqNoService;, +                }, +            };, +            noOpEngine.recoverFromTranslog();, +            final int gapsFilled = noOpEngine.fillSeqNoGaps(primaryTerm);, +            assertThat(noOpEngine.getTranslog().totalOperations(), equalTo(1 + gapsFilled));, +            // skip to the op that we added to the translog, +            Translog.Operation op;, +            Translog.Operation last = null;, +            final Translog.Snapshot snapshot = noOpEngine.getTranslog().newSnapshot();, +            while ((op = snapshot.next()) != null) {, +                last = op;, +            }, +            assertNotNull(last);, +            assertThat(last, instanceOf(Translog.NoOp.class));, +            final Translog.NoOp noOp = (Translog.NoOp) last;, +            assertEquals((maxSeqIDOnReplica + 1) - numDocsOnReplica, recoveringEngine.fillSeqNoGaps(2));, +            assertEquals(0, recoveringEngine.fillSeqNoGaps(3));]