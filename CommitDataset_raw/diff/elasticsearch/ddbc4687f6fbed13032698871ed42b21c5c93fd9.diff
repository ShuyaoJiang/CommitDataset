[+++ b/core/src/main/java/org/elasticsearch/index/shard/IndexShard.java, +import java.util.concurrent.CountDownLatch;, +     * Notifies the shard of an increase in the primary term., +     *, +     * @param newPrimaryTerm the new primary term, +    public void updatePrimaryTerm(final long newPrimaryTerm) {, +            if (newPrimaryTerm != primaryTerm) {, +                                + "new term [" + newPrimaryTerm + "]";, +                assert newPrimaryTerm > primaryTerm :, +                        "primary terms can only go up; current term [" + primaryTerm + "], new term [" + newPrimaryTerm + "]";, +                /*, +                 * Before this call returns, we are guaranteed that all future operations are delayed and so this happens before we, +                 * increment the primary term. The latch is needed to ensure that we do not unblock operations before the primary term is, +                 * incremented., +                 */, +                final CountDownLatch latch = new CountDownLatch(1);, +                indexShardOperationPermits.asyncBlockOperations(, +                        30,, +                        TimeUnit.MINUTES,, +                        latch::await,, +                        e -> failShard("exception during primary term transition", e));, +                primaryTerm = newPrimaryTerm;, +                latch.countDown();, +++ b/core/src/main/java/org/elasticsearch/index/shard/IndexShard.java, +import java.util.concurrent.CountDownLatch;, +     * Notifies the shard of an increase in the primary term., +     *, +     * @param newPrimaryTerm the new primary term, +    public void updatePrimaryTerm(final long newPrimaryTerm) {, +            if (newPrimaryTerm != primaryTerm) {, +                                + "new term [" + newPrimaryTerm + "]";, +                assert newPrimaryTerm > primaryTerm :, +                        "primary terms can only go up; current term [" + primaryTerm + "], new term [" + newPrimaryTerm + "]";, +                /*, +                 * Before this call returns, we are guaranteed that all future operations are delayed and so this happens before we, +                 * increment the primary term. The latch is needed to ensure that we do not unblock operations before the primary term is, +                 * incremented., +                 */, +                final CountDownLatch latch = new CountDownLatch(1);, +                indexShardOperationPermits.asyncBlockOperations(, +                        30,, +                        TimeUnit.MINUTES,, +                        latch::await,, +                        e -> failShard("exception during primary term transition", e));, +                primaryTerm = newPrimaryTerm;, +                latch.countDown();, +++ b/core/src/main/java/org/elasticsearch/index/shard/IndexShardOperationPermits.java, +import org.elasticsearch.Assertions;, +import org.elasticsearch.common.util.concurrent.AbstractRunnable;, +import java.util.function.Consumer;, +/**, + * Tracks shard operation permits. Each operation on the shard obtains a permit. When we need to block operations (e.g., to transition, + * between terms) we immediately delay all operations to a queue, obtain all available permits, and wait for outstanding operations to drain, + * and return their permits. Delayed operations will acquire permits and be completed after the operation that blocked all operations has, + * completed., + */, +, +    final Semaphore semaphore = new Semaphore(TOTAL_PERMITS, true); // fair to ensure a blocking thread is not starved, +    private final List<ActionListener<Releasable>> delayedOperations = new ArrayList<>(); // operations that are delayed, +    private boolean delayed; // does not need to be volatile as all accesses are done under a lock on this, +    /**, +     * Construct operation permits for the specified shards., +     *, +     * @param shardId    the shard, +     * @param logger     the logger for the shard, +     * @param threadPool the thread pool (used to execute delayed operations), +     */, +    IndexShardOperationPermits(final ShardId shardId, final Logger logger, final ThreadPool threadPool) {, +     * Wait for in-flight operations to finish and executes {@code onBlocked} under the guarantee that no new operations are started. Queues, +     * operations that are occurring in the meanwhile and runs them once {@code onBlocked} has executed., +     * @param <E>       the type of checked exception thrown by {@code onBlocked}, +    <E extends Exception> void blockOperations(, +            final long timeout,, +            final TimeUnit timeUnit,, +            final CheckedRunnable<E> onBlocked) throws InterruptedException, TimeoutException, E {, +        delayOperations();, +            doBlockOperations(timeout, timeUnit, onBlocked);, +        } finally {, +            releaseDelayedOperations();, +        }, +    }, +, +    /**, +     * Immediately delays operations and on another thread waits for in-flight operations to finish and then executes {@code onBlocked}, +     * under the guarantee that no new operations are started. Delayed operations are run after {@code onBlocked} has executed. After, +     * operations are delayed and the blocking is forked to another thread, returns to the caller. If a failure occurs while blocking, +     * operations or executing {@code onBlocked} then the {@code onFailure} handler will be invoked., +     *, +     * @param timeout   the maximum time to wait for the in-flight operations block, +     * @param timeUnit  the time unit of the {@code timeout} argument, +     * @param onBlocked the action to run once the block has been acquired, +     * @param onFailure the action to run if a failure occurs while blocking operations, +     * @param <E>       the type of checked exception thrown by {@code onBlocked} (not thrown on the calling thread), +     */, +    <E extends Exception> void asyncBlockOperations(, +            final long timeout, final TimeUnit timeUnit, final CheckedRunnable<E> onBlocked, final Consumer<Exception> onFailure) {, +        delayOperations();, +        threadPool.executor(ThreadPool.Names.GENERIC).execute(new AbstractRunnable() {, +            @Override, +            public void onFailure(final Exception e) {]