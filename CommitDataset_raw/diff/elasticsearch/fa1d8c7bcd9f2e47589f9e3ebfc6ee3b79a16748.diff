[+++ b/modules/elasticsearch/src/main/java/org/elasticsearch/index/service/IndexService.java, +    /**, +     * Removes the shard, does not delete local data or the gateway., +     */, +    void removeShard(int shardId) throws ElasticSearchException;, +, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/index/service/IndexService.java, +    /**, +     * Removes the shard, does not delete local data or the gateway., +     */, +    void removeShard(int shardId) throws ElasticSearchException;, +, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/index/service/InternalIndexService.java, +    @Override public synchronized void removeShard(int shardId) throws ElasticSearchException {, +        deleteShard(shardId, false, false, false);, +    }, +, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/index/service/IndexService.java, +    /**, +     * Removes the shard, does not delete local data or the gateway., +     */, +    void removeShard(int shardId) throws ElasticSearchException;, +, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/index/service/InternalIndexService.java, +    @Override public synchronized void removeShard(int shardId) throws ElasticSearchException {, +        deleteShard(shardId, false, false, false);, +    }, +, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/index/shard/recovery/RecoveryTarget.java, +//            logger.trace("[{}][{}] Got exception on recovery", e, request.shardId().index().name(), request.shardId().id());, +            // here, we would add checks against exception that need to be retried (and not removeAndClean in this case), +, +, +            // here, we check against ignore recovery options, +, +            // in general, no need to clean the shard on ignored recovery, since we want to try and reuse it later, +            // it will get deleted in the IndicesStore if all are allocated and no shard exists on this node..., +, +            if (cause instanceof IndexShardNotStartedException || cause instanceof IndexMissingException || cause instanceof IndexShardMissingException) {, +                // no need to retry here, since we only get to try and recover when there is an existing shard on the other side, +                listener.onIgnoreRecovery(true, "shard does not exists on source, ignore...");, +                return;, +            }, +            logger.trace("[{}][{}] recovery from [{}] failed", e, request.shardId().index().name(), request.shardId().id(), request.sourceNode());, +        void onIgnoreRecovery(boolean removeShard, String reason);, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/index/service/IndexService.java, +    /**, +     * Removes the shard, does not delete local data or the gateway., +     */, +    void removeShard(int shardId) throws ElasticSearchException;, +, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/index/service/InternalIndexService.java, +    @Override public synchronized void removeShard(int shardId) throws ElasticSearchException {, +        deleteShard(shardId, false, false, false);, +    }, +, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/index/shard/recovery/RecoveryTarget.java, +//            logger.trace("[{}][{}] Got exception on recovery", e, request.shardId().index().name(), request.shardId().id());, +            // here, we would add checks against exception that need to be retried (and not removeAndClean in this case), +, +, +            // here, we check against ignore recovery options, +, +            // in general, no need to clean the shard on ignored recovery, since we want to try and reuse it later, +            // it will get deleted in the IndicesStore if all are allocated and no shard exists on this node..., +, +            if (cause instanceof IndexShardNotStartedException || cause instanceof IndexMissingException || cause instanceof IndexShardMissingException) {, +                // no need to retry here, since we only get to try and recover when there is an existing shard on the other side, +                listener.onIgnoreRecovery(true, "shard does not exists on source, ignore...");, +                return;, +            }, +            logger.trace("[{}][{}] recovery from [{}] failed", e, request.shardId().index().name(), request.shardId().id(), request.sourceNode());, +        void onIgnoreRecovery(boolean removeShard, String reason);, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/indices/cluster/IndicesClusterStateService.java, +        @Override public void onIgnoreRecovery(boolean removeShard, String reason) {, +            if (!removeShard) {, +                    indexService.removeShard(shardRouting.shardId().id());]