[+++ b/server/src/test/java/org/elasticsearch/common/breaker/MemoryCircuitBreakerTests.java, +            threads[i] = new Thread(() -> {, +++ b/server/src/test/java/org/elasticsearch/common/breaker/MemoryCircuitBreakerTests.java, +            threads[i] = new Thread(() -> {, +++ b/server/src/test/java/org/elasticsearch/indices/breaker/HierarchyCircuitBreakerServiceTests.java, +/*, + * Licensed to Elasticsearch under one or more contributor, + * license agreements. See the NOTICE file distributed with, + * this work for additional information regarding copyright, + * ownership. Elasticsearch licenses this file to you under, + * the Apache License, Version 2.0 (the "License"); you may, + * not use this file except in compliance with the License., + * You may obtain a copy of the License at, + *, + *    http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing,, + * software distributed under the License is distributed on an, + * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY, + * KIND, either express or implied.  See the License for the, + * specific language governing permissions and limitations, + * under the License., + */, +, +package org.elasticsearch.indices.breaker;, +, +, +import org.elasticsearch.common.breaker.ChildMemoryCircuitBreaker;, +import org.elasticsearch.common.breaker.CircuitBreaker;, +import org.elasticsearch.common.breaker.CircuitBreakingException;, +import org.elasticsearch.common.breaker.MemoryCircuitBreaker;, +import org.elasticsearch.common.settings.ClusterSettings;, +import org.elasticsearch.common.settings.Settings;, +import org.elasticsearch.common.unit.ByteSizeUnit;, +import org.elasticsearch.common.unit.ByteSizeValue;, +import org.elasticsearch.test.ESTestCase;, +, +import java.util.concurrent.atomic.AtomicBoolean;, +import java.util.concurrent.atomic.AtomicInteger;, +import java.util.concurrent.atomic.AtomicReference;, +, +import static org.hamcrest.Matchers.containsString;, +import static org.hamcrest.Matchers.equalTo;, +import static org.hamcrest.Matchers.greaterThanOrEqualTo;, +, +public class HierarchyCircuitBreakerServiceTests extends ESTestCase {, +    public void testThreadedUpdatesToChildBreaker() throws Exception {, +        final int NUM_THREADS = scaledRandomIntBetween(3, 15);, +        final int BYTES_PER_THREAD = scaledRandomIntBetween(500, 4500);, +        final Thread[] threads = new Thread[NUM_THREADS];, +        final AtomicBoolean tripped = new AtomicBoolean(false);, +        final AtomicReference<Throwable> lastException = new AtomicReference<>(null);, +, +        final AtomicReference<ChildMemoryCircuitBreaker> breakerRef = new AtomicReference<>(null);, +        final CircuitBreakerService service = new HierarchyCircuitBreakerService(Settings.EMPTY,, +            new ClusterSettings(Settings.EMPTY, ClusterSettings.BUILT_IN_CLUSTER_SETTINGS)) {, +, +            @Override, +            public CircuitBreaker getBreaker(String name) {, +                return breakerRef.get();, +            }, +, +            @Override, +            public void checkParentLimit(String label) throws CircuitBreakingException {, +                // never trip, +            }, +        };, +        final BreakerSettings settings = new BreakerSettings(CircuitBreaker.REQUEST, (BYTES_PER_THREAD * NUM_THREADS) - 1, 1.0);, +        final ChildMemoryCircuitBreaker breaker = new ChildMemoryCircuitBreaker(settings, logger,, +            (HierarchyCircuitBreakerService)service, CircuitBreaker.REQUEST);, +        breakerRef.set(breaker);, +, +        for (int i = 0; i < NUM_THREADS; i++) {, +            threads[i] = new Thread(() -> {, +                for (int j = 0; j < BYTES_PER_THREAD; j++) {, +                    try {, +                        breaker.addEstimateBytesAndMaybeBreak(1L, "test");, +                    } catch (CircuitBreakingException e) {, +                        if (tripped.get()) {, +                            assertThat("tripped too many times", true, equalTo(false));, +                        } else {, +                            assertThat(tripped.compareAndSet(false, true), equalTo(true));, +                        }, +                    } catch (Exception e) {, +                        lastException.set(e);, +                    }, +                }, +            });, +, +            threads[i].start();, +        }, +, +        for (Thread t : threads) {, +            t.join();, +        }, +, +        assertThat("no other exceptions were thrown", lastException.get(), equalTo(null));, +        assertThat("breaker was tripped", tripped.get(), equalTo(true));, +        assertThat("breaker was tripped at least once", breaker.getTrippedCount(), greaterThanOrEqualTo(1L));, +    }]