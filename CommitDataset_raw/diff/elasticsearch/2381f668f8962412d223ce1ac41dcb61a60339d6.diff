[+++ b/modules/elasticsearch/src/main/java/org/elasticsearch/cluster/action/index/NodeMappingCreatedAction.java, +import org.elasticsearch.common.unit.TimeValue;, +    public void add(final Listener listener, TimeValue timeout) {, +        threadPool.schedule(new Runnable() {, +            @Override public void run() {, +                boolean removed = listeners.remove(listener);, +                if (removed) {, +                    listener.onTimeout();, +                }, +            }, +        }, timeout);, +, +        void onTimeout();, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/cluster/action/index/NodeMappingCreatedAction.java, +import org.elasticsearch.common.unit.TimeValue;, +    public void add(final Listener listener, TimeValue timeout) {, +        threadPool.schedule(new Runnable() {, +            @Override public void run() {, +                boolean removed = listeners.remove(listener);, +                if (removed) {, +                    listener.onTimeout();, +                }, +            }, +        }, timeout);, +, +        void onTimeout();, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/cluster/metadata/MetaDataMappingService.java, +import org.elasticsearch.cluster.action.index.NodeMappingCreatedAction;, +import org.elasticsearch.cluster.routing.IndexRoutingTable;, +import java.util.concurrent.atomic.AtomicInteger;, +    private final NodeMappingCreatedAction mappingCreatedAction;, +, +    @Inject public MetaDataMappingService(Settings settings, ClusterService clusterService, IndicesService indicesService, NodeMappingCreatedAction mappingCreatedAction) {, +        this.mappingCreatedAction = mappingCreatedAction;, +                int counter = 0;, +                for (String index : request.indices) {, +                    IndexRoutingTable indexRoutingTable = clusterState.routingTable().index(index);, +                    if (indexRoutingTable != null) {, +                        counter += indexRoutingTable.numberOfNodesShardsAreAllocatedOn();, +                    }, +                }, +, +                if (counter > 0) {, +                    counter = counter - 1; // we already added the mapping on the master here..., +                }, +                if (counter == 0) {, +                    return;, +                }, +, +                final AtomicInteger countDown = new AtomicInteger(counter);, +                mappingCreatedAction.add(new NodeMappingCreatedAction.Listener() {, +                    @Override public void onNodeMappingCreated(NodeMappingCreatedAction.NodeMappingCreatedResponse response) {, +                        if (countDown.decrementAndGet() == 0) {, +                            mappingCreatedAction.remove(this);, +                            listener.onResponse(new Response(true));, +                        }, +                    }, +, +                    @Override public void onTimeout() {, +                        listener.onResponse(new Response(false));, +                    }, +                }, request.timeout);, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/cluster/action/index/NodeMappingCreatedAction.java, +import org.elasticsearch.common.unit.TimeValue;, +    public void add(final Listener listener, TimeValue timeout) {, +        threadPool.schedule(new Runnable() {, +            @Override public void run() {, +                boolean removed = listeners.remove(listener);, +                if (removed) {, +                    listener.onTimeout();, +                }, +            }, +        }, timeout);, +, +        void onTimeout();, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/cluster/metadata/MetaDataMappingService.java, +import org.elasticsearch.cluster.action.index.NodeMappingCreatedAction;, +import org.elasticsearch.cluster.routing.IndexRoutingTable;, +import java.util.concurrent.atomic.AtomicInteger;, +    private final NodeMappingCreatedAction mappingCreatedAction;, +, +    @Inject public MetaDataMappingService(Settings settings, ClusterService clusterService, IndicesService indicesService, NodeMappingCreatedAction mappingCreatedAction) {, +        this.mappingCreatedAction = mappingCreatedAction;, +                int counter = 0;, +                for (String index : request.indices) {, +                    IndexRoutingTable indexRoutingTable = clusterState.routingTable().index(index);, +                    if (indexRoutingTable != null) {, +                        counter += indexRoutingTable.numberOfNodesShardsAreAllocatedOn();, +                    }, +                }, +, +                if (counter > 0) {, +                    counter = counter - 1; // we already added the mapping on the master here..., +                }, +                if (counter == 0) {, +                    return;, +                }, +, +                final AtomicInteger countDown = new AtomicInteger(counter);, +                mappingCreatedAction.add(new NodeMappingCreatedAction.Listener() {]