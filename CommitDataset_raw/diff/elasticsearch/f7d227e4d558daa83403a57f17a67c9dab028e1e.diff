[+++ b/src/main/java/org/elasticsearch/cluster/settings/ClusterDynamicSettingsModule.java, +++ b/src/main/java/org/elasticsearch/cluster/settings/ClusterDynamicSettingsModule.java, +++ b/src/main/java/org/elasticsearch/indices/breaker/HierarchyCircuitBreakerService.java, +            if (newRequestMax != null || newRequestOverhead != null) {, +                newRequestSettings = new BreakerSettings(CircuitBreaker.Name.REQUEST, newRequestLimitBytes, newRequestOverhead,, +                        HierarchyCircuitBreakerService.this.requestSettings.getType());, +++ b/src/main/java/org/elasticsearch/cluster/settings/ClusterDynamicSettingsModule.java, +++ b/src/main/java/org/elasticsearch/indices/breaker/HierarchyCircuitBreakerService.java, +            if (newRequestMax != null || newRequestOverhead != null) {, +                newRequestSettings = new BreakerSettings(CircuitBreaker.Name.REQUEST, newRequestLimitBytes, newRequestOverhead,, +                        HierarchyCircuitBreakerService.this.requestSettings.getType());, +++ b/src/test/java/org/elasticsearch/indices/memory/breaker/CircuitBreakerNoopTests.java, +/*, + * Licensed to Elasticsearch under one or more contributor, + * license agreements. See the NOTICE file distributed with, + * this work for additional information regarding copyright, + * ownership. Elasticsearch licenses this file to you under, + * the Apache License, Version 2.0 (the "License"); you may, + * not use this file except in compliance with the License., + * You may obtain a copy of the License at, + *, + *    http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing,, + * software distributed under the License is distributed on an, + * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY, + * KIND, either express or implied.  See the License for the, + * specific language governing permissions and limitations, + * under the License., + */, +, +package org.elasticsearch.indices.memory.breaker;, +, +import org.elasticsearch.action.index.IndexRequestBuilder;, +import org.elasticsearch.client.Client;, +import org.elasticsearch.common.settings.ImmutableSettings;, +import org.elasticsearch.common.settings.Settings;, +import org.elasticsearch.indices.breaker.HierarchyCircuitBreakerService;, +import org.elasticsearch.search.sort.SortOrder;, +import org.elasticsearch.test.ElasticsearchIntegrationTest;, +import org.junit.Test;, +, +import java.util.List;, +, +import static com.google.common.collect.Lists.newArrayList;, +import static org.elasticsearch.cluster.metadata.IndexMetaData.SETTING_NUMBER_OF_REPLICAS;, +import static org.elasticsearch.common.settings.ImmutableSettings.settingsBuilder;, +import static org.elasticsearch.index.query.QueryBuilders.matchAllQuery;, +import static org.elasticsearch.search.aggregations.AggregationBuilders.cardinality;, +import static org.elasticsearch.test.hamcrest.ElasticsearchAssertions.assertAcked;, +, +/** Tests for the noop breakers, which are non-dynamic settings */, +@ElasticsearchIntegrationTest.ClusterScope(scope=ElasticsearchIntegrationTest.Scope.SUITE, numDataNodes=0), +public class CircuitBreakerNoopTests extends ElasticsearchIntegrationTest {, +, +    @Override, +    protected Settings nodeSettings(int nodeOrdinal) {, +        return ImmutableSettings.builder(), +                .put(HierarchyCircuitBreakerService.FIELDDATA_CIRCUIT_BREAKER_TYPE_SETTING, "noop"), +                // This is set low, because if the "noop" is not a noop, it will break, +                .put(HierarchyCircuitBreakerService.FIELDDATA_CIRCUIT_BREAKER_LIMIT_SETTING, "10b"), +                .put(HierarchyCircuitBreakerService.REQUEST_CIRCUIT_BREAKER_TYPE_SETTING, "noop"), +                // This is set low, because if the "noop" is not a noop, it will break, +                .put(HierarchyCircuitBreakerService.REQUEST_CIRCUIT_BREAKER_LIMIT_SETTING, "10b"), +                .build();, +    }, +, +    @Test, +    public void testNoopRequestBreaker() throws Exception {, +        assertAcked(prepareCreate("cb-test", 1, settingsBuilder().put(SETTING_NUMBER_OF_REPLICAS, between(0, 1))));, +        Client client = client();, +, +        // index some different terms so we have some field data for loading, +        int docCount = scaledRandomIntBetween(300, 1000);, +        List<IndexRequestBuilder> reqs = newArrayList();, +        for (long id = 0; id < docCount; id++) {, +            reqs.add(client.prepareIndex("cb-test", "type", Long.toString(id)).setSource("test", id));, +        }, +        indexRandom(true, reqs);, +, +        // A cardinality aggregation uses BigArrays and thus the REQUEST breaker, +        client.prepareSearch("cb-test").setQuery(matchAllQuery()).addAggregation(cardinality("card").field("test")).get();, +        // no exception because the breaker is a noop, +    }, +, +    @Test, +    public void testNoopFielddataBreaker() throws Exception {, +        assertAcked(prepareCreate("cb-test", 1, settingsBuilder().put(SETTING_NUMBER_OF_REPLICAS, between(0, 1))));, +        Client client = client();, +, +        // index some different terms so we have some field data for loading, +        int docCount = scaledRandomIntBetween(300, 1000);, +        List<IndexRequestBuilder> reqs = newArrayList();, +        for (long id = 0; id < docCount; id++) {, +            reqs.add(client.prepareIndex("cb-test", "type", Long.toString(id)).setSource("test", id));, +        }, +        indexRandom(true, reqs);, +, +        // Sorting using fielddata and thus the FIELDDATA breaker, +        client.prepareSearch("cb-test").setQuery(matchAllQuery()).addSort("test", SortOrder.DESC).get();]