[+++ b/core/bin/elasticsearch.in.bat, +set ES_CLASSPATH=%ES_CLASSPATH%;%ES_HOME%/lib/${project.build.finalName}.jar;%ES_HOME%/lib/*;%ES_HOME%/lib/sigar/*, +++ b/core/bin/elasticsearch.in.bat, +set ES_CLASSPATH=%ES_CLASSPATH%;%ES_HOME%/lib/${project.build.finalName}.jar;%ES_HOME%/lib/*;%ES_HOME%/lib/sigar/*, +++ b/core/bin/elasticsearch.in.sh, +ES_CLASSPATH="$ES_CLASSPATH:$ES_HOME/lib/${project.build.finalName}.jar:$ES_HOME/lib/*:$ES_HOME/lib/sigar/*", +++ b/core/bin/elasticsearch.in.bat, +set ES_CLASSPATH=%ES_CLASSPATH%;%ES_HOME%/lib/${project.build.finalName}.jar;%ES_HOME%/lib/*;%ES_HOME%/lib/sigar/*, +++ b/core/bin/elasticsearch.in.sh, +ES_CLASSPATH="$ES_CLASSPATH:$ES_HOME/lib/${project.build.finalName}.jar:$ES_HOME/lib/*:$ES_HOME/lib/sigar/*", +++ b/core/src/main/java/org/apache/lucene/queryparser/classic/ExistsFieldQueryExtension.java, +import org.elasticsearch.index.query.ExistsQueryBuilder;, +        return new ConstantScoreQuery(ExistsQueryBuilder.newFilter(parseContext, queryText));, +++ b/core/bin/elasticsearch.in.bat, +set ES_CLASSPATH=%ES_CLASSPATH%;%ES_HOME%/lib/${project.build.finalName}.jar;%ES_HOME%/lib/*;%ES_HOME%/lib/sigar/*, +++ b/core/bin/elasticsearch.in.sh, +ES_CLASSPATH="$ES_CLASSPATH:$ES_HOME/lib/${project.build.finalName}.jar:$ES_HOME/lib/*:$ES_HOME/lib/sigar/*", +++ b/core/src/main/java/org/apache/lucene/queryparser/classic/ExistsFieldQueryExtension.java, +import org.elasticsearch.index.query.ExistsQueryBuilder;, +        return new ConstantScoreQuery(ExistsQueryBuilder.newFilter(parseContext, queryText));, +++ b/core/src/main/java/org/apache/lucene/queryparser/classic/MissingFieldQueryExtension.java, +        Query query = MissingQueryParser.newFilter(parseContext, queryText, MissingQueryParser.DEFAULT_EXISTENCE_VALUE, MissingQueryParser.DEFAULT_NULL_VALUE);, +        if (query != null) {, +            return new ConstantScoreQuery(query);, +        }, +        return null;, +++ b/core/bin/elasticsearch.in.bat, +set ES_CLASSPATH=%ES_CLASSPATH%;%ES_HOME%/lib/${project.build.finalName}.jar;%ES_HOME%/lib/*;%ES_HOME%/lib/sigar/*, +++ b/core/bin/elasticsearch.in.sh, +ES_CLASSPATH="$ES_CLASSPATH:$ES_HOME/lib/${project.build.finalName}.jar:$ES_HOME/lib/*:$ES_HOME/lib/sigar/*", +++ b/core/src/main/java/org/apache/lucene/queryparser/classic/ExistsFieldQueryExtension.java, +import org.elasticsearch.index.query.ExistsQueryBuilder;, +        return new ConstantScoreQuery(ExistsQueryBuilder.newFilter(parseContext, queryText));, +++ b/core/src/main/java/org/apache/lucene/queryparser/classic/MissingFieldQueryExtension.java, +        Query query = MissingQueryParser.newFilter(parseContext, queryText, MissingQueryParser.DEFAULT_EXISTENCE_VALUE, MissingQueryParser.DEFAULT_NULL_VALUE);, +        if (query != null) {, +            return new ConstantScoreQuery(query);, +        }, +        return null;, +++ b/core/src/main/java/org/elasticsearch/ElasticsearchException.java, +import com.google.common.collect.ImmutableMap;, +import com.google.common.collect.Lists;, +import com.google.common.collect.Maps;, +import org.elasticsearch.common.collect.Tuple;, +import org.elasticsearch.rest.HasRestHeaders;, +    /**, +     * A base class for exceptions that should carry rest headers, +     */, +    @SuppressWarnings("unchecked"), +    public static class WithRestHeadersException extends ElasticsearchException implements HasRestHeaders {, +, +        private final Map<String, List<String>> headers;, +, +        public WithRestHeadersException(String msg, Tuple<String, String[]>... headers) {, +            super(msg);, +            this.headers = headers(headers);, +        }, +, +        protected WithRestHeadersException(String msg, Throwable cause, Map<String, List<String>> headers) {, +            super(msg, cause);, +            this.headers = headers;, +        }, +, +        public WithRestHeadersException(StreamInput in) throws IOException {, +            super(in);, +            int numKeys = in.readVInt();, +            ImmutableMap.Builder<String, List<String>> builder = ImmutableMap.builder();, +            for (int i = 0; i < numKeys; i++) {, +                final String key = in.readString();, +                final int numValues = in.readVInt();, +                final ArrayList<String> headers = new ArrayList<>(numValues);, +                for (int j = 0; j < numValues; j++) {, +                    headers.add(in.readString());, +                }, +                builder.put(key, headers);, +            }, +            headers = builder.build();, +        }, +, +        @Override, +        public void writeTo(StreamOutput out) throws IOException {, +            super.writeTo(out);, +            out.writeVInt(headers.size());, +            for (Map.Entry<String, List<String>> entry : headers.entrySet()) {, +                out.writeString(entry.getKey());, +                out.writeVInt(entry.getValue().size());, +                for (String v : entry.getValue()) {, +                    out.writeString(v);, +                }, +            }, +        }, +, +        @Override, +        public Map<String, List<String>> getHeaders() {, +            return headers;, +        }, +, +        protected static Tuple<String, String[]> header(String name, String... values) {, +            return Tuple.tuple(name, values);, +        }]