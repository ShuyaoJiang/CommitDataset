[+++ b/src/main/java/org/apache/lucene/util/packed/XAbstractAppendingLongBuffer.java, +package org.apache.lucene.util.packed;, +, +/*, + * Licensed to the Apache Software Foundation (ASF) under one or more, + * contributor license agreements.  See the NOTICE file distributed with, + * this work for additional information regarding copyright ownership., + * The ASF licenses this file to You under the Apache License, Version 2.0, + * (the "License"); you may not use this file except in compliance with, + * the License.  You may obtain a copy of the License at, + *, + *     http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS,, + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied., + * See the License for the specific language governing permissions and, + * limitations under the License., + */, +, +import org.apache.lucene.util.ArrayUtil;, +import org.apache.lucene.util.RamUsageEstimator;, +import org.apache.lucene.util.Version;, +import org.elasticsearch.common.lucene.Lucene;, +, +import java.util.Arrays;, +, +import static org.apache.lucene.util.packed.PackedInts.checkBlockSize;, +, +/**, + * Common functionality shared by {@link AppendingDeltaPackedLongBuffer} and {@link MonotonicAppendingLongBuffer}., + */, +abstract class XAbstractAppendingLongBuffer {, +    static {, +        // LUCENE MONITOR: this should be in Lucene 4.5., +        assert Lucene.VERSION == Version.LUCENE_44 : "Elasticsearch has upgraded to Lucene Version: [" + Lucene.VERSION + "] this class should be removed";, +    }, +, +, +    static final int MIN_PAGE_SIZE = 64;, +    // More than 1M doesn't really makes sense with these appending buffers, +    // since their goal is to try to have small numbers of bits per value, +    static final int MAX_PAGE_SIZE = 1 << 20;, +, +    final int pageShift, pageMask;, +    PackedInts.Reader[] values;, +    private long valuesBytes;, +    int valuesOff;, +    long[] pending;, +    int pendingOff;, +    float acceptableOverheadRatio;, +, +    XAbstractAppendingLongBuffer(int initialBlockCount, int pageSize, float acceptableOverheadRatio) {, +        values = new PackedInts.Reader[initialBlockCount];, +        pending = new long[pageSize];, +        pageShift = checkBlockSize(pageSize, MIN_PAGE_SIZE, MAX_PAGE_SIZE);, +        pageMask = pageSize - 1;, +        valuesOff = 0;, +        pendingOff = 0;, +        this.acceptableOverheadRatio = acceptableOverheadRatio;, +    }, +, +    final int pageSize() {, +        return pageMask + 1;, +    }, +, +    /**, +     * Get the number of values that have been added to the buffer., +     */, +    public final long size() {, +        long size = pendingOff;, +        if (valuesOff > 0) {, +            size += values[valuesOff - 1].size();, +        }, +        if (valuesOff > 1) {, +            size += (long) (valuesOff - 1) * pageSize();, +        }, +        return size;, +    }, +, +    /**, +     * Append a value to this buffer., +     */, +    public final void add(long l) {, +        if (pending == null) {, +            throw new IllegalStateException("This buffer is frozen");, +        }, +        if (pendingOff == pending.length) {, +            // check size, +            if (values.length == valuesOff) {, +                final int newLength = ArrayUtil.oversize(valuesOff + 1, 8);, +                grow(newLength);, +            }, +            packPendingValues();, +            valuesBytes += values[valuesOff].ramBytesUsed();, +            ++valuesOff;, +            // reset pending buffer, +            pendingOff = 0;, +        }, +        pending[pendingOff++] = l;]