[+++ b/docs/reference/indices/flush.asciidoc, +                   "generation" : 4,, +++ b/docs/reference/indices/flush.asciidoc, +                   "generation" : 4,, +++ b/server/src/main/java/org/elasticsearch/index/IndexService.java, +import org.elasticsearch.core.internal.io.IOUtils;, +++ b/docs/reference/indices/flush.asciidoc, +                   "generation" : 4,, +++ b/server/src/main/java/org/elasticsearch/index/IndexService.java, +import org.elasticsearch.core.internal.io.IOUtils;, +++ /dev/null, +++ b/docs/reference/indices/flush.asciidoc, +                   "generation" : 4,, +++ b/server/src/main/java/org/elasticsearch/index/IndexService.java, +import org.elasticsearch.core.internal.io.IOUtils;, +++ /dev/null, +++ b/server/src/main/java/org/elasticsearch/index/shard/StoreRecovery.java, +import org.elasticsearch.index.translog.Translog;, +                store.bootstrapNewHistory();, +                final SegmentInfos segmentInfos = store.readLastCommittedSegmentsInfo();, +                final long maxSeqNo = Long.parseLong(segmentInfos.userData.get(SequenceNumbers.MAX_SEQ_NO));, +                final String translogUUID = Translog.createEmptyTranslog(indexShard.shardPath().resolveTranslog(), maxSeqNo, shardId);, +                store.associateIndexWithNewTranslog(translogUUID);, +                store.createEmpty();, +                final String translogUUID = Translog.createEmptyTranslog(indexShard.shardPath().resolveTranslog(),, +                    SequenceNumbers.NO_OPS_PERFORMED, shardId);, +                store.associateIndexWithNewTranslog(translogUUID);, +            final Store store = indexShard.store();, +            store.bootstrapNewHistory();, +            final SegmentInfos segmentInfos = store.readLastCommittedSegmentsInfo();, +            final long maxSeqNo = Long.parseLong(segmentInfos.userData.get(SequenceNumbers.MAX_SEQ_NO));, +            final String translogUUID = Translog.createEmptyTranslog(indexShard.shardPath().resolveTranslog(), maxSeqNo, shardId);, +            store.associateIndexWithNewTranslog(translogUUID);, +++ b/docs/reference/indices/flush.asciidoc, +                   "generation" : 4,, +++ b/server/src/main/java/org/elasticsearch/index/IndexService.java, +import org.elasticsearch.core.internal.io.IOUtils;, +++ /dev/null, +++ b/server/src/main/java/org/elasticsearch/index/shard/StoreRecovery.java, +import org.elasticsearch.index.translog.Translog;, +                store.bootstrapNewHistory();, +                final SegmentInfos segmentInfos = store.readLastCommittedSegmentsInfo();, +                final long maxSeqNo = Long.parseLong(segmentInfos.userData.get(SequenceNumbers.MAX_SEQ_NO));, +                final String translogUUID = Translog.createEmptyTranslog(indexShard.shardPath().resolveTranslog(), maxSeqNo, shardId);, +                store.associateIndexWithNewTranslog(translogUUID);, +                store.createEmpty();, +                final String translogUUID = Translog.createEmptyTranslog(indexShard.shardPath().resolveTranslog(),, +                    SequenceNumbers.NO_OPS_PERFORMED, shardId);, +                store.associateIndexWithNewTranslog(translogUUID);, +            final Store store = indexShard.store();, +            store.bootstrapNewHistory();, +            final SegmentInfos segmentInfos = store.readLastCommittedSegmentsInfo();, +            final long maxSeqNo = Long.parseLong(segmentInfos.userData.get(SequenceNumbers.MAX_SEQ_NO));, +            final String translogUUID = Translog.createEmptyTranslog(indexShard.shardPath().resolveTranslog(), maxSeqNo, shardId);, +            store.associateIndexWithNewTranslog(translogUUID);, +++ b/server/src/main/java/org/elasticsearch/index/store/Store.java, +import org.apache.lucene.index.IndexWriterConfig;, +import org.apache.lucene.index.NoMergePolicy;, +import org.elasticsearch.core.internal.io.IOUtils;, +import org.elasticsearch.index.engine.InternalEngine;, +    public Store(ShardId shardId, IndexSettings indexSettings, DirectoryService directoryService, ShardLock shardLock,, +                 OnClose onClose) throws IOException {, +    /**, +     * creates an empty lucene index and a corresponding empty translog. Any existing data will be deleted., +     */, +    public void createEmpty() throws IOException {, +        metadataLock.writeLock().lock();, +        try (IndexWriter writer = newIndexWriter(IndexWriterConfig.OpenMode.CREATE, directory)) {, +            final Map<String, String> map = new HashMap<>();, +            map.put(Engine.HISTORY_UUID_KEY, UUIDs.randomBase64UUID());, +            map.put(SequenceNumbers.LOCAL_CHECKPOINT_KEY, Long.toString(SequenceNumbers.NO_OPS_PERFORMED));, +            map.put(SequenceNumbers.MAX_SEQ_NO, Long.toString(SequenceNumbers.NO_OPS_PERFORMED));, +            map.put(InternalEngine.MAX_UNSAFE_AUTO_ID_TIMESTAMP_COMMIT_ID, "-1");, +            updateCommitData(writer, map);, +        } finally {, +            metadataLock.writeLock().unlock();, +        }, +    }, +, +, +    /**, +     * Marks an existing lucene index with a new history uuid., +     * This is used to make sure no existing shard will recovery from this index using ops based recovery., +     */, +    public void bootstrapNewHistory() throws IOException {, +        metadataLock.writeLock().lock();, +        try (IndexWriter writer = newIndexWriter(IndexWriterConfig.OpenMode.APPEND, directory)) {, +            final Map<String, String> userData = getUserData(writer);, +            final long maxSeqNo = Long.parseLong(userData.get(SequenceNumbers.MAX_SEQ_NO));, +            final Map<String, String> map = new HashMap<>();, +            map.put(Engine.HISTORY_UUID_KEY, UUIDs.randomBase64UUID());, +            map.put(SequenceNumbers.LOCAL_CHECKPOINT_KEY, Long.toString(maxSeqNo));, +            updateCommitData(writer, map);, +        } finally {, +            metadataLock.writeLock().unlock();, +        }, +    }, +, +    /**, +     * Force bakes the given translog generation as recovery information in the lucene index. This is]