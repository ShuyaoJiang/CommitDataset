[+++ b/server/src/main/java/org/elasticsearch/env/NodeEnvironment.java, +import org.apache.logging.log4j.Logger;, +import org.elasticsearch.common.CheckedFunction;, +import org.elasticsearch.common.lease.Releasable;, +import org.elasticsearch.core.internal.io.IOUtils;, +import java.io.UncheckedIOException;, +import java.util.Iterator;, +import java.util.stream.Collectors;, +import java.util.stream.Stream;, +        try (ShardLock lock = shardLock(shardId, "shard deletion under lock")) {, +            shardLock(id, "checking if shard is locked").close();, +        final List<ShardLock> locks = lockAllForIndex(index, indexSettings, "deleting index directory", lockTimeoutMS);, +    public List<ShardLock> lockAllForIndex(final Index index, final IndexSettings settings,, +                                           final String lockDetails, final long lockTimeoutMS) throws ShardLockObtainFailedException {, +                allLocks.add(shardLock(new ShardId(index, i), lockDetails, timeoutLeftMS));, +     * @param details information about why the shard is being locked, +    public ShardLock shardLock(ShardId id, final String details) throws ShardLockObtainFailedException {, +        return shardLock(id, details, 0);, +     * @param details information about why the shard is being locked, +    public ShardLock shardLock(final ShardId shardId, final String details,, +                               final long lockTimeoutMS) throws ShardLockObtainFailedException {, +        logger.trace("acquiring node shardlock on [{}], timeout [{}], details [{}]", shardId, lockTimeoutMS, details);, +                shardLock = new InternalShardLock(shardId, details);, +                shardLock.acquire(lockTimeoutMS, details);, +     * A functional interface that people can use to reference {@link #shardLock(ShardId, String, long)}, +        ShardLock lock(ShardId shardId, String lockDetails, long lockTimeoutMS) throws ShardLockObtainFailedException;, +        private String lockDetails;, +        InternalShardLock(final ShardId shardId, final String details) {, +            lockDetails = details;, +        void acquire(long timeoutInMillis, final String details) throws ShardLockObtainFailedException {, +                if (mutex.tryAcquire(timeoutInMillis, TimeUnit.MILLISECONDS)) {, +                    lockDetails = details;, +                } else {, +                        "obtaining shard lock timed out after " + timeoutInMillis + "ms, previous lock details: [" + lockDetails +, +                            "] trying to lock for [" + details + "]");, +++ b/server/src/main/java/org/elasticsearch/env/NodeEnvironment.java, +import org.apache.logging.log4j.Logger;, +import org.elasticsearch.common.CheckedFunction;, +import org.elasticsearch.common.lease.Releasable;, +import org.elasticsearch.core.internal.io.IOUtils;, +import java.io.UncheckedIOException;, +import java.util.Iterator;, +import java.util.stream.Collectors;, +import java.util.stream.Stream;, +        try (ShardLock lock = shardLock(shardId, "shard deletion under lock")) {, +            shardLock(id, "checking if shard is locked").close();, +        final List<ShardLock> locks = lockAllForIndex(index, indexSettings, "deleting index directory", lockTimeoutMS);, +    public List<ShardLock> lockAllForIndex(final Index index, final IndexSettings settings,, +                                           final String lockDetails, final long lockTimeoutMS) throws ShardLockObtainFailedException {, +                allLocks.add(shardLock(new ShardId(index, i), lockDetails, timeoutLeftMS));, +     * @param details information about why the shard is being locked, +    public ShardLock shardLock(ShardId id, final String details) throws ShardLockObtainFailedException {, +        return shardLock(id, details, 0);, +     * @param details information about why the shard is being locked, +    public ShardLock shardLock(final ShardId shardId, final String details,, +                               final long lockTimeoutMS) throws ShardLockObtainFailedException {, +        logger.trace("acquiring node shardlock on [{}], timeout [{}], details [{}]", shardId, lockTimeoutMS, details);, +                shardLock = new InternalShardLock(shardId, details);, +                shardLock.acquire(lockTimeoutMS, details);, +     * A functional interface that people can use to reference {@link #shardLock(ShardId, String, long)}, +        ShardLock lock(ShardId shardId, String lockDetails, long lockTimeoutMS) throws ShardLockObtainFailedException;, +        private String lockDetails;, +        InternalShardLock(final ShardId shardId, final String details) {, +            lockDetails = details;, +        void acquire(long timeoutInMillis, final String details) throws ShardLockObtainFailedException {, +                if (mutex.tryAcquire(timeoutInMillis, TimeUnit.MILLISECONDS)) {, +                    lockDetails = details;, +                } else {, +                        "obtaining shard lock timed out after " + timeoutInMillis + "ms, previous lock details: [" + lockDetails +, +                            "] trying to lock for [" + details + "]");, +++ b/server/src/main/java/org/elasticsearch/index/IndexService.java, +            lock = nodeEnv.shardLock(shardId, "shard creation", TimeUnit.SECONDS.toMillis(5));, +++ b/server/src/main/java/org/elasticsearch/env/NodeEnvironment.java, +import org.apache.logging.log4j.Logger;, +import org.elasticsearch.common.CheckedFunction;, +import org.elasticsearch.common.lease.Releasable;, +import org.elasticsearch.core.internal.io.IOUtils;, +import java.io.UncheckedIOException;, +import java.util.Iterator;, +import java.util.stream.Collectors;, +import java.util.stream.Stream;, +        try (ShardLock lock = shardLock(shardId, "shard deletion under lock")) {, +            shardLock(id, "checking if shard is locked").close();, +        final List<ShardLock> locks = lockAllForIndex(index, indexSettings, "deleting index directory", lockTimeoutMS);, +    public List<ShardLock> lockAllForIndex(final Index index, final IndexSettings settings,, +                                           final String lockDetails, final long lockTimeoutMS) throws ShardLockObtainFailedException {, +                allLocks.add(shardLock(new ShardId(index, i), lockDetails, timeoutLeftMS));, +     * @param details information about why the shard is being locked, +    public ShardLock shardLock(ShardId id, final String details) throws ShardLockObtainFailedException {, +        return shardLock(id, details, 0);, +     * @param details information about why the shard is being locked, +    public ShardLock shardLock(final ShardId shardId, final String details,, +                               final long lockTimeoutMS) throws ShardLockObtainFailedException {, +        logger.trace("acquiring node shardlock on [{}], timeout [{}], details [{}]", shardId, lockTimeoutMS, details);, +                shardLock = new InternalShardLock(shardId, details);, +                shardLock.acquire(lockTimeoutMS, details);, +     * A functional interface that people can use to reference {@link #shardLock(ShardId, String, long)}, +        ShardLock lock(ShardId shardId, String lockDetails, long lockTimeoutMS) throws ShardLockObtainFailedException;, +        private String lockDetails;, +        InternalShardLock(final ShardId shardId, final String details) {]