[+++ b/src/test/java/org/elasticsearch/discovery/DiscoveryWithNetworkFailuresTests.java, +        ensureStableCluster(3, new TimeValue(30000 + networkPartition.expectedTimeToHeal().millis()));, +        ensureStableCluster(3, new TimeValue(30000 + scheme.expectedTimeToHeal().millis()));, +                                } catch (ElasticsearchException e) {, +                                    exceptedExceptions.add(e);, +                                    logger.trace("[{}] failed id [{}] through node [{}]", e, name, id, node);, +                            } catch (InterruptedException e) {, +                                // fine - semaphore interrupt, +                assertTrue(countDownLatchRef.get().await(60000 + disruptionScheme.expectedTimeToHeal().millis() * (docsPerIndexer * indexers.size()), TimeUnit.MILLISECONDS));, +            if (exceptedExceptions.size() > 0) {, +                StringBuilder sb = new StringBuilder("Indexing exceptions during disruption:");, +                for (Exception e : exceptedExceptions) {, +                    sb.append("\n").append(e.getMessage());, +                }, +                logger.debug(sb.toString());, +            }, +        ensureStableCluster(nodeCount, TimeValue.timeValueSeconds(30), viaNode);, +        logger.debug("ensuring cluster is stable with [{}] nodes. access node: [{}]. timeout: [{}]", nodeCount, viaNode, timeValue);, +++ b/src/test/java/org/elasticsearch/discovery/DiscoveryWithNetworkFailuresTests.java, +        ensureStableCluster(3, new TimeValue(30000 + networkPartition.expectedTimeToHeal().millis()));, +        ensureStableCluster(3, new TimeValue(30000 + scheme.expectedTimeToHeal().millis()));, +                                } catch (ElasticsearchException e) {, +                                    exceptedExceptions.add(e);, +                                    logger.trace("[{}] failed id [{}] through node [{}]", e, name, id, node);, +                            } catch (InterruptedException e) {, +                                // fine - semaphore interrupt, +                assertTrue(countDownLatchRef.get().await(60000 + disruptionScheme.expectedTimeToHeal().millis() * (docsPerIndexer * indexers.size()), TimeUnit.MILLISECONDS));, +            if (exceptedExceptions.size() > 0) {, +                StringBuilder sb = new StringBuilder("Indexing exceptions during disruption:");, +                for (Exception e : exceptedExceptions) {, +                    sb.append("\n").append(e.getMessage());, +                }, +                logger.debug(sb.toString());, +            }, +        ensureStableCluster(nodeCount, TimeValue.timeValueSeconds(30), viaNode);, +        logger.debug("ensuring cluster is stable with [{}] nodes. access node: [{}]. timeout: [{}]", nodeCount, viaNode, timeValue);, +++ b/src/test/java/org/elasticsearch/test/InternalTestCluster.java, +        TimeValue expectedHealingTime = activeDisruptionScheme != null ? activeDisruptionScheme.expectedTimeToHeal() : null;, +        if (expectedHealingTime != null && expectedHealingTime.millis() > 0) {, +            try {, +                Thread.sleep(expectedHealingTime.millis());, +            } catch (InterruptedException e) {, +                Thread.currentThread().interrupt();, +            }, +        }]