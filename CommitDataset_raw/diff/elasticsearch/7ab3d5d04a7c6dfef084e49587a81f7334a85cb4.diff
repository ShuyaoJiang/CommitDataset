[+++ b/core/src/main/java/org/apache/lucene/queries/MinDocQuery.java, +                final DocIdSetIterator disi = new MinDocIterator(segmentMinDoc, maxDoc);, +                return new ConstantScoreScorer(this, score(), disi);, +            }, +        };, +    }, +    static class MinDocIterator extends DocIdSetIterator {, +        final int segmentMinDoc;, +        final int maxDoc;, +        MinDocIterator(int segmentMinDoc, int maxDoc) {, +            this.segmentMinDoc = segmentMinDoc;, +            this.maxDoc = maxDoc;, +        }, +, +    }, +++ b/core/src/main/java/org/apache/lucene/queries/MinDocQuery.java, +                final DocIdSetIterator disi = new MinDocIterator(segmentMinDoc, maxDoc);, +                return new ConstantScoreScorer(this, score(), disi);, +            }, +        };, +    }, +    static class MinDocIterator extends DocIdSetIterator {, +        final int segmentMinDoc;, +        final int maxDoc;, +        MinDocIterator(int segmentMinDoc, int maxDoc) {, +            this.segmentMinDoc = segmentMinDoc;, +            this.maxDoc = maxDoc;, +        }, +, +    }, +++ b/core/src/main/java/org/apache/lucene/queries/SearchAfterSortedDocQuery.java, +/*, + * Licensed to Elasticsearch under one or more contributor, + * license agreements. See the NOTICE file distributed with, + * this work for additional information regarding copyright, + * ownership. Elasticsearch licenses this file to you under, + * the Apache License, Version 2.0 (the "License"); you may, + * not use this file except in compliance with the License., + * You may obtain a copy of the License at, + *, + *    http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing,, + * software distributed under the License is distributed on an, + * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY, + * KIND, either express or implied.  See the License for the, + * specific language governing permissions and limitations, + * under the License., + */, +, +package org.apache.lucene.queries;, +, +import org.apache.lucene.index.LeafReaderContext;, +import org.apache.lucene.search.ConstantScoreScorer;, +import org.apache.lucene.search.ConstantScoreWeight;, +import org.apache.lucene.search.DocIdSetIterator;, +import org.apache.lucene.search.EarlyTerminatingSortingCollector;, +import org.apache.lucene.search.FieldComparator;, +import org.apache.lucene.search.FieldDoc;, +import org.apache.lucene.search.IndexSearcher;, +import org.apache.lucene.search.LeafFieldComparator;, +import org.apache.lucene.search.Query;, +import org.apache.lucene.search.Scorer;, +import org.apache.lucene.search.Sort;, +import org.apache.lucene.search.SortField;, +import org.apache.lucene.search.Weight;, +, +import java.io.IOException;, +import java.util.ArrayList;, +import java.util.Arrays;, +import java.util.List;, +import java.util.Objects;, +, +/**, + * A {@link Query} that only matches documents that are greater than the provided {@link FieldDoc}., + * This works only if the index is sorted according to the given search {@link Sort}., + */, +public class SearchAfterSortedDocQuery extends Query {, +    private final Sort sort;, +    private final FieldDoc after;, +    private final FieldComparator<?>[] fieldComparators;, +    private final int[] reverseMuls;, +, +    public SearchAfterSortedDocQuery(Sort sort, FieldDoc after) {, +        if (sort.getSort().length != after.fields.length) {, +            throw new IllegalArgumentException("after doc  has " + after.fields.length + " value(s) but sort has ", +                    + sort.getSort().length + ".");, +        }, +        this.sort = sort;, +        this.after = after;, +        int numFields = sort.getSort().length;, +        this.fieldComparators = new FieldComparator[numFields];, +        this.reverseMuls = new int[numFields];, +        for (int i = 0; i < numFields; i++) {, +            SortField sortField = sort.getSort()[i];, +            FieldComparator<?> fieldComparator = sortField.getComparator(1, i);, +            @SuppressWarnings("unchecked"), +            FieldComparator<Object> comparator = (FieldComparator<Object>) fieldComparator;, +            comparator.setTopValue(after.fields[i]);, +            fieldComparators[i] = fieldComparator;]