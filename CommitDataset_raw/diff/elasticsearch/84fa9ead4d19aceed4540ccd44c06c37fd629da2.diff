[+++ b/src/main/java/org/elasticsearch/common/geo/GeoHashUtils.java, +                String neighbor = neighbor(geohash, level - 1, dx, dy);, +                if(neighbor != null) {, +                    return neighbor + encode(nx, ny); , +                } else {, +                    return null;, +                }, +++ b/src/main/java/org/elasticsearch/common/geo/GeoHashUtils.java, +                String neighbor = neighbor(geohash, level - 1, dx, dy);, +                if(neighbor != null) {, +                    return neighbor + encode(nx, ny); , +                } else {, +                    return null;, +                }, +++ b/src/main/java/org/elasticsearch/common/geo/GeoPoint.java, +import java.io.IOException;, +, +import org.elasticsearch.ElasticSearchParseException;, +import org.elasticsearch.common.xcontent.XContentParser;, +import org.elasticsearch.common.xcontent.XContentParser.Token;, +import org.elasticsearch.index.mapper.geo.GeoPointFieldMapper;, +, +    public static final String LATITUDE = GeoPointFieldMapper.Names.LAT;, +    public static final String LONGITUDE = GeoPointFieldMapper.Names.LON;, +    , +    , +    /**, +     * Parse a {@link GeoPoint} with a {@link XContentParser}:, +     * , +     * @param parser {@link XContentParser} to parse the value from, +     * @return new {@link GeoPoint} parsed from the parse, +     * , +     * @throws IOException, +     * @throws ElasticSearchParseException, +     */, +    public static GeoPoint parse(XContentParser parser) throws IOException, ElasticSearchParseException {, +        return parse(parser, new GeoPoint());, +    }, +, +    /**, +     * Parse a {@link GeoPoint} with a {@link XContentParser}. A geopoint has one of the following forms:, +     * , +     * <ul>, +     *     <li>Object: <pre>{&quot;lat&quot;: <i>&lt;latitude&gt;</i>, &quot;lon&quot;: <i>&lt;longitude&gt;</i>}</pre></li>, +     *     <li>String: <pre>&quot;<i>&lt;latitude&gt;</i>,<i>&lt;longitude&gt;</i>&quot;</pre></li>, +     *     <li>Geohash: <pre>&quot;<i>&lt;geohash&gt;</i>&quot;</pre></li>, +     *     <li>Array: <pre>[<i>&lt;longitude&gt;</i>,<i>&lt;latitude&gt;</i>]</pre></li>, +     * </ul>, +     * , +     * @param parser {@link XContentParser} to parse the value from, +     * @param point A {@link GeoPoint} that will be reset by the values parsed, +     * @return new {@link GeoPoint} parsed from the parse, +     * , +     * @throws IOException, +     * @throws ElasticSearchParseException, +     */, +    public static GeoPoint parse(XContentParser parser, GeoPoint point) throws IOException, ElasticSearchParseException {, +        if(parser.currentToken() == Token.START_OBJECT) {, +            while(parser.nextToken() != Token.END_OBJECT) {, +                if(parser.currentToken() == Token.FIELD_NAME) {, +                    String field = parser.text();, +                    if(LATITUDE.equals(field)) {, +                        if(parser.nextToken() == Token.VALUE_NUMBER) {, +                            point.resetLat(parser.doubleValue());, +                        } else {, +                            throw new ElasticSearchParseException("latitude must be a number");, +                        }, +                    } else if (LONGITUDE.equals(field)) {, +                        if(parser.nextToken() == Token.VALUE_NUMBER) {, +                            point.resetLon(parser.doubleValue());, +                        } else {, +                            throw new ElasticSearchParseException("latitude must be a number");, +                        }, +                    } else {, +                        throw new ElasticSearchParseException("field must be either '"+LATITUDE+"' or '"+LONGITUDE+"'");, +                    }, +                } else {, +                    throw new ElasticSearchParseException("Token '"+parser.currentToken()+"' not allowed");, +                }, +            }, +            return point;, +        } else if(parser.currentToken() == Token.START_ARRAY) {, +            int element = 0;, +            while(parser.nextToken() != Token.END_ARRAY) {, +                if(parser.currentToken() == Token.VALUE_NUMBER) {, +                    element++;, +                    if(element == 1) {, +                        point.resetLon(parser.doubleValue());, +                    } else if(element == 2) {, +                        point.resetLat(parser.doubleValue());, +                    } else {, +                        throw new ElasticSearchParseException("only two values allowed");, +                    }, +                } else {, +                    throw new ElasticSearchParseException("Numeric value expected");, +                }, +            }, +            return point;, +        } else if(parser.currentToken() == Token.VALUE_STRING) {, +            String data = parser.text();]