[+++ b/core/src/main/java/org/elasticsearch/transport/TcpTransport.java, +import org.elasticsearch.common.util.iterable.Iterables;, +import static org.elasticsearch.common.util.concurrent.ConcurrentCollections.newConcurrentSet;, +    private final Set<NodeChannels> openConnections = newConcurrentSet();, +, +        public NodeChannels(DiscoveryNode node, Channel[] channels, ConnectionProfile connectionProfile) {, +                    onNodeChannelsClosed(this);, +                boolean success = false;, +                    success = true;, +                } finally {, +                    if (success == false) { // close the connection if there is a failure, +                        logger.trace(, +                            (Supplier<?>) () -> new ParameterizedMessage(, +                                "failed to connect to [{}], cleaning dangling connections", node));, +                        IOUtils.closeWhileHandlingException(nodeChannels);, +                    }, +                AtomicBoolean runOnce = new AtomicBoolean(false);, +                Consumer<Channel> onClose = c -> {, +                    assert isOpen(c) == false : "channel is still open when onClose is called";, +                    try {, +                        onChannelClosed(c);, +                    } finally {, +                        // we only need to disconnect from the nodes once since all other channels, +                        // will also try to run this we protect it from running multiple times., +                        if (runOnce.compareAndSet(false, true)) {, +                            disconnectFromNodeChannel(c, "channel closed");, +                        }, +                    }, +                };, +                nodeChannels = connectToChannels(node, connectionProfile, onClose);, +                transportServiceAdapter.onConnectionOpened(nodeChannels);, +                openConnections.add(nodeChannels);, +    protected final void disconnectFromNodeChannel(final Channel channel, final String reason) {, +                if (isOpen(channel)) {, +                outer:, +                {, +                    for (Map.Entry<DiscoveryNode, NodeChannels> entry : connectedNodes.entrySet()) {, +                        if (disconnectFromNode(entry.getKey(), channel, reason)) {, +                            // if we managed to find this channel and disconnect from it, then break, no need to check on, +                            // the rest of the nodes, +                            // #onNodeChannelsClosed will remove it.., +                            assert openConnections.contains(entry.getValue()) == false : "NodeChannel#close should remove the connetion";, +                            // we can only be connected and published to a single node with one connection. So if disconnectFromNode, +                            // returns true we can safely break out from here since we cleaned up everything needed, +                            break outer;, +                        }, +                    }, +                    // now if we haven't found the right connection in the connected nodes we have to go through the open connections, +                    // it might be that the channel belongs to a connection that is not published, +                    for (NodeChannels channels : openConnections) {, +                        if (channels.hasChannel(channel)) {, +                            IOUtils.closeWhileHandlingException(channels);, +                            break;, +                        }, +                    }, +                }, +                // we are holding a write lock so nobody modifies the connectedNodes / openConnections map - it's safe to first close, +                // all instances and then clear them maps, +                IOUtils.closeWhileHandlingException(Iterables.concat(connectedNodes.values(), openConnections));, +                openConnections.clear();, +                connectedNodes.clear();, +        String reason = ExceptionsHelper.detailedMessage(e);, +            disconnectFromNodeChannel(channel, reason);, +, +            disconnectFromNodeChannel(channel, reason);, +            disconnectFromNodeChannel(channel, reason);, +            disconnectFromNodeChannel(channel, reason);, +            disconnectFromNodeChannel(channel, reason);, +            disconnectFromNodeChannel(channel, reason);, +    protected abstract NodeChannels connectToChannels(DiscoveryNode node, ConnectionProfile connectionProfile,, +                                                      Consumer<Channel> onChannelClose) throws IOException;, +    private void onChannelClosed(Channel channel) {, +, +    private void onNodeChannelsClosed(NodeChannels channels) {, +        // don't assert here since the channel / connection might not have been registered yet, +        final boolean remove = openConnections.remove(channels);, +        if (remove) {, +            transportServiceAdapter.onConnectionClosed(channels);, +        }, +    }, +, +    final int getNumOpenConnections() {, +        return openConnections.size();, +    }, +, +    final int getNumConnectedNodes() {, +        return connectedNodes.size();, +    }, +++ b/core/src/main/java/org/elasticsearch/transport/TcpTransport.java, +import org.elasticsearch.common.util.iterable.Iterables;, +import static org.elasticsearch.common.util.concurrent.ConcurrentCollections.newConcurrentSet;, +    private final Set<NodeChannels> openConnections = newConcurrentSet();, +, +        public NodeChannels(DiscoveryNode node, Channel[] channels, ConnectionProfile connectionProfile) {, +                    onNodeChannelsClosed(this);, +                boolean success = false;, +                    success = true;, +                } finally {, +                    if (success == false) { // close the connection if there is a failure, +                        logger.trace(]