[+++ b/src/main/java/org/elasticsearch/cluster/routing/allocation/allocator/BalancedShardsAllocator.java, +        private boolean initialize(RoutingNodes routing, List<MutableShardRouting> unassigned) {, +            return allocateUnassigned(unassigned, routing.ignoredUnassigned());, +            final TransactionalList<MutableShardRouting> unassigned = new TransactionalList<MutableShardRouting>(allocation.routingNodes().unassigned());, +            boolean changed = initialize(allocation.routingNodes(), unassigned);, +            unassigned.commit();, +            final TransactionalList<MutableShardRouting> unassigned = new TransactionalList<MutableShardRouting>(allocation.routingNodes().unassigned());, +            boolean changed = initialize(allocation.routingNodes(), unassigned);, +            , +                    changed = true;, +                    break;, +            unassigned.commit();, +    , +    /**, +     * A list that makes a full copy of the original list and applies all, +     * modification to the copied list once {@link TransactionalList#commit()}, +     * is called., +     * , +     */, +    @SuppressWarnings("serial"), +    private static final class TransactionalList<T> extends ArrayList<T> {, +        , +        private final List<T> originalList;, +        private List<T> assertingList; // only with assert, +, +        TransactionalList(List<T> originalList) {, +            super(originalList);, +            assert copyAsseringList(originalList);, +            this.originalList = originalList;, +        }, +        , +        private boolean copyAsseringList(List<T> orig) {, +            this.assertingList = new ArrayList<T>(orig);, +            return true;, +        }, +        , +        public void commit() {, +            /* Ensure that the actual source list is not modified while, +             * the transaction is running */, +            assert assertingList.equals(originalList) : "The list was modified outside of the scope";, +            originalList.clear();, +            originalList.addAll(this);    , +            , +        }, +    }, +++ b/src/main/java/org/elasticsearch/cluster/routing/allocation/allocator/BalancedShardsAllocator.java, +        private boolean initialize(RoutingNodes routing, List<MutableShardRouting> unassigned) {, +            return allocateUnassigned(unassigned, routing.ignoredUnassigned());, +            final TransactionalList<MutableShardRouting> unassigned = new TransactionalList<MutableShardRouting>(allocation.routingNodes().unassigned());, +            boolean changed = initialize(allocation.routingNodes(), unassigned);, +            unassigned.commit();, +            final TransactionalList<MutableShardRouting> unassigned = new TransactionalList<MutableShardRouting>(allocation.routingNodes().unassigned());, +            boolean changed = initialize(allocation.routingNodes(), unassigned);, +            , +                    changed = true;, +                    break;, +            unassigned.commit();, +    , +    /**, +     * A list that makes a full copy of the original list and applies all, +     * modification to the copied list once {@link TransactionalList#commit()}, +     * is called., +     * , +     */, +    @SuppressWarnings("serial"), +    private static final class TransactionalList<T> extends ArrayList<T> {, +        , +        private final List<T> originalList;, +        private List<T> assertingList; // only with assert, +, +        TransactionalList(List<T> originalList) {, +            super(originalList);, +            assert copyAsseringList(originalList);, +            this.originalList = originalList;, +        }, +        , +        private boolean copyAsseringList(List<T> orig) {, +            this.assertingList = new ArrayList<T>(orig);, +            return true;, +        }, +        , +        public void commit() {, +            /* Ensure that the actual source list is not modified while, +             * the transaction is running */, +            assert assertingList.equals(originalList) : "The list was modified outside of the scope";, +            originalList.clear();, +            originalList.addAll(this);    , +            , +        }, +    }, +++ b/src/main/java/org/elasticsearch/cluster/routing/allocation/decider/ThrottlingAllocationDecider.java, +            assert shardRouting.unassigned() || shardRouting.active();, +            if (shardRouting.unassigned()) {, +++ b/src/main/java/org/elasticsearch/cluster/routing/allocation/allocator/BalancedShardsAllocator.java, +        private boolean initialize(RoutingNodes routing, List<MutableShardRouting> unassigned) {, +            return allocateUnassigned(unassigned, routing.ignoredUnassigned());, +            final TransactionalList<MutableShardRouting> unassigned = new TransactionalList<MutableShardRouting>(allocation.routingNodes().unassigned());, +            boolean changed = initialize(allocation.routingNodes(), unassigned);, +            unassigned.commit();, +            final TransactionalList<MutableShardRouting> unassigned = new TransactionalList<MutableShardRouting>(allocation.routingNodes().unassigned());]