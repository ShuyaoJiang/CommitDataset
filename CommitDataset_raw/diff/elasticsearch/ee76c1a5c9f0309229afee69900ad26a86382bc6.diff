[+++ b/core/src/main/java/org/elasticsearch/cluster/ClusterState.java, +                sb.append("isa_ids ").append(indexMetaData.inSyncAllocationIds(shard)).append("\n");, +++ b/core/src/main/java/org/elasticsearch/cluster/ClusterState.java, +                sb.append("isa_ids ").append(indexMetaData.inSyncAllocationIds(shard)).append("\n");, +++ b/core/src/main/java/org/elasticsearch/cluster/action/shard/ShardStateAction.java, +                maybeUpdatedState = allocationService.applyStartedShards(currentState, shardRoutingsToBeApplied);, +++ b/core/src/main/java/org/elasticsearch/cluster/ClusterState.java, +                sb.append("isa_ids ").append(indexMetaData.inSyncAllocationIds(shard)).append("\n");, +++ b/core/src/main/java/org/elasticsearch/cluster/action/shard/ShardStateAction.java, +                maybeUpdatedState = allocationService.applyStartedShards(currentState, shardRoutingsToBeApplied);, +++ b/core/src/main/java/org/elasticsearch/cluster/routing/IndexRoutingTable.java, +                final Set<String> inSyncAllocationIds = indexMetaData.inSyncAllocationIds(shardRouting.id());, +                    inSyncAllocationIds.contains(shardRouting.allocationId().getId()) == false) {, +                        "allocation set " + inSyncAllocationIds);, +, +                if (indexMetaData.getCreationVersion().onOrAfter(Version.V_5_0_0_alpha1) &&, +                    IndexMetaData.isIndexUsingShadowReplicas(indexMetaData.getSettings()) == false && // see #20650, +                    shardRouting.primary() && shardRouting.initializing() && shardRouting.relocating() == false &&, +                    RecoverySource.isInitialRecovery(shardRouting.recoverySource().getType()) == false &&, +                    inSyncAllocationIds.contains(shardRouting.allocationId().getId()) == false), +                    throw new IllegalStateException("a primary shard routing " + shardRouting + " is a primary that is recovering from " +, +                        "a known allocation id but has no corresponding entry in the in-sync " +, +                        "allocation set " + inSyncAllocationIds);, +, +++ b/core/src/main/java/org/elasticsearch/cluster/ClusterState.java, +                sb.append("isa_ids ").append(indexMetaData.inSyncAllocationIds(shard)).append("\n");, +++ b/core/src/main/java/org/elasticsearch/cluster/action/shard/ShardStateAction.java, +                maybeUpdatedState = allocationService.applyStartedShards(currentState, shardRoutingsToBeApplied);, +++ b/core/src/main/java/org/elasticsearch/cluster/routing/IndexRoutingTable.java, +                final Set<String> inSyncAllocationIds = indexMetaData.inSyncAllocationIds(shardRouting.id());, +                    inSyncAllocationIds.contains(shardRouting.allocationId().getId()) == false) {, +                        "allocation set " + inSyncAllocationIds);, +, +                if (indexMetaData.getCreationVersion().onOrAfter(Version.V_5_0_0_alpha1) &&, +                    IndexMetaData.isIndexUsingShadowReplicas(indexMetaData.getSettings()) == false && // see #20650, +                    shardRouting.primary() && shardRouting.initializing() && shardRouting.relocating() == false &&, +                    RecoverySource.isInitialRecovery(shardRouting.recoverySource().getType()) == false &&, +                    inSyncAllocationIds.contains(shardRouting.allocationId().getId()) == false), +                    throw new IllegalStateException("a primary shard routing " + shardRouting + " is a primary that is recovering from " +, +                        "a known allocation id but has no corresponding entry in the in-sync " +, +                        "allocation set " + inSyncAllocationIds);, +, +++ b/core/src/main/java/org/elasticsearch/cluster/routing/allocation/AllocationService.java, +++ b/core/src/main/java/org/elasticsearch/cluster/ClusterState.java, +                sb.append("isa_ids ").append(indexMetaData.inSyncAllocationIds(shard)).append("\n");, +++ b/core/src/main/java/org/elasticsearch/cluster/action/shard/ShardStateAction.java, +                maybeUpdatedState = allocationService.applyStartedShards(currentState, shardRoutingsToBeApplied);, +++ b/core/src/main/java/org/elasticsearch/cluster/routing/IndexRoutingTable.java, +                final Set<String> inSyncAllocationIds = indexMetaData.inSyncAllocationIds(shardRouting.id());, +                    inSyncAllocationIds.contains(shardRouting.allocationId().getId()) == false) {, +                        "allocation set " + inSyncAllocationIds);, +, +                if (indexMetaData.getCreationVersion().onOrAfter(Version.V_5_0_0_alpha1) &&, +                    IndexMetaData.isIndexUsingShadowReplicas(indexMetaData.getSettings()) == false && // see #20650, +                    shardRouting.primary() && shardRouting.initializing() && shardRouting.relocating() == false &&, +                    RecoverySource.isInitialRecovery(shardRouting.recoverySource().getType()) == false &&, +                    inSyncAllocationIds.contains(shardRouting.allocationId().getId()) == false), +                    throw new IllegalStateException("a primary shard routing " + shardRouting + " is a primary that is recovering from " +, +                        "a known allocation id but has no corresponding entry in the in-sync " +, +                        "allocation set " + inSyncAllocationIds);, +, +++ b/core/src/main/java/org/elasticsearch/cluster/routing/allocation/AllocationService.java, +++ b/core/src/main/java/org/elasticsearch/gateway/GatewayAllocator.java, +        innerAllocatedUnassigned(allocation, primaryShardAllocator, replicaShardAllocator);, +    }, +, +    // allow for testing infra to change shard allocators implementation, +    protected static void innerAllocatedUnassigned(RoutingAllocation allocation,, +                                                   PrimaryShardAllocator primaryShardAllocator,, +                                                   ReplicaShardAllocator replicaShardAllocator) {, +++ b/core/src/main/java/org/elasticsearch/cluster/ClusterState.java, +                sb.append("isa_ids ").append(indexMetaData.inSyncAllocationIds(shard)).append("\n");, +++ b/core/src/main/java/org/elasticsearch/cluster/action/shard/ShardStateAction.java, +                maybeUpdatedState = allocationService.applyStartedShards(currentState, shardRoutingsToBeApplied);, +++ b/core/src/main/java/org/elasticsearch/cluster/routing/IndexRoutingTable.java, +                final Set<String> inSyncAllocationIds = indexMetaData.inSyncAllocationIds(shardRouting.id());, +                    inSyncAllocationIds.contains(shardRouting.allocationId().getId()) == false) {, +                        "allocation set " + inSyncAllocationIds);, +, +                if (indexMetaData.getCreationVersion().onOrAfter(Version.V_5_0_0_alpha1) &&, +                    IndexMetaData.isIndexUsingShadowReplicas(indexMetaData.getSettings()) == false && // see #20650, +                    shardRouting.primary() && shardRouting.initializing() && shardRouting.relocating() == false &&, +                    RecoverySource.isInitialRecovery(shardRouting.recoverySource().getType()) == false &&, +                    inSyncAllocationIds.contains(shardRouting.allocationId().getId()) == false), +                    throw new IllegalStateException("a primary shard routing " + shardRouting + " is a primary that is recovering from " +, +                        "a known allocation id but has no corresponding entry in the in-sync " +, +                        "allocation set " + inSyncAllocationIds);, +, +++ b/core/src/main/java/org/elasticsearch/cluster/routing/allocation/AllocationService.java, +++ b/core/src/main/java/org/elasticsearch/gateway/GatewayAllocator.java, +        innerAllocatedUnassigned(allocation, primaryShardAllocator, replicaShardAllocator);, +    }, +, +    // allow for testing infra to change shard allocators implementation, +    protected static void innerAllocatedUnassigned(RoutingAllocation allocation,, +                                                   PrimaryShardAllocator primaryShardAllocator,, +                                                   ReplicaShardAllocator replicaShardAllocator) {, +++ b/core/src/main/java/org/elasticsearch/gateway/PrimaryShardAllocator.java, +                "trying to allocate a primary with an empty in sync allocation id set, but index is new. index: ", +                    + indexMetaData.getIndex();]