[+++ b/buildSrc/src/main/groovy/org/elasticsearch/gradle/BuildPlugin.groovy, +                // compile with compact 3 profile by default, +                // NOTE: this is just a compile time check: does not replace testing with a compact3 JRE, +                options.compilerArgs << '-profile' << 'compact3', +++ b/buildSrc/src/main/groovy/org/elasticsearch/gradle/BuildPlugin.groovy, +                // compile with compact 3 profile by default, +                // NOTE: this is just a compile time check: does not replace testing with a compact3 JRE, +                options.compilerArgs << '-profile' << 'compact3', +++ b/core/src/main/java/org/elasticsearch/search/builder/SearchSourceBuilder.java, +            highlightBuilder.innerXContent(builder, EMPTY_PARAMS);, +++ b/buildSrc/src/main/groovy/org/elasticsearch/gradle/BuildPlugin.groovy, +                // compile with compact 3 profile by default, +                // NOTE: this is just a compile time check: does not replace testing with a compact3 JRE, +                options.compilerArgs << '-profile' << 'compact3', +++ b/core/src/main/java/org/elasticsearch/search/builder/SearchSourceBuilder.java, +            highlightBuilder.innerXContent(builder, EMPTY_PARAMS);, +++ /dev/null, +++ b/buildSrc/src/main/groovy/org/elasticsearch/gradle/BuildPlugin.groovy, +                // compile with compact 3 profile by default, +                // NOTE: this is just a compile time check: does not replace testing with a compact3 JRE, +                options.compilerArgs << '-profile' << 'compact3', +++ b/core/src/main/java/org/elasticsearch/search/builder/SearchSourceBuilder.java, +            highlightBuilder.innerXContent(builder, EMPTY_PARAMS);, +++ /dev/null, +++ b/core/src/main/java/org/elasticsearch/search/highlight/HighlightBuilder.java, +import org.apache.lucene.search.highlight.SimpleFragmenter;, +import org.apache.lucene.search.highlight.SimpleSpanFragmenter;, +import org.elasticsearch.index.query.QueryBuilder;, +import java.util.Map;, +public class HighlightBuilder implements ToXContent {, +    private List<Field> fields;, +    private String tagsSchema;, +, +    private Boolean highlightFilter;, +, +    private Integer fragmentSize;, +, +    private Integer numOfFragments;, +, +    private String[] preTags;, +, +    private String[] postTags;, +, +    private String order;, +    private Boolean requireFieldMatch;, +, +    private Integer boundaryMaxScan;, +, +    private char[] boundaryChars;, +, +    private String highlighterType;, +, +    private String fragmenter;, +, +    private QueryBuilder highlightQuery;, +, +    private Integer noMatchSize;, +, +    private Integer phraseLimit;, +, +    private Map<String, Object> options;, +, +    private Boolean forceSource;, +, +        if (fields == null) {, +            fields = new ArrayList<>();, +        fields.add(new Field(name));, +        return this;, +    }, +, +        if (fields == null) {, +            fields = new ArrayList<>();, +        }, +        fields.add(new Field(name).fragmentSize(fragmentSize));, +        return this;, +        if (fields == null) {, +            fields = new ArrayList<>();, +        fields.add(new Field(name).fragmentSize(fragmentSize).numOfFragments(numberOfFragments));, +        return this;, +    }, +, +        if (fields == null) {, +            fields = new ArrayList<>();, +        }, +        fields.add(new Field(name).fragmentSize(fragmentSize).numOfFragments(numberOfFragments), +        return this;, +        if (fields == null) {, +            fields = new ArrayList<>();, +        }, +     * Set a tag scheme that encapsulates a built in pre and post tags. The allows schemes, +        this.tagsSchema = schemaName;, +        return this;, +, +    /**, +     * Set this to true when using the highlighterType <tt>fvh</tt>, +     * and you want to provide highlighting on filter clauses in your, +     * query. Default is <tt>false</tt>., +     */, +    public HighlightBuilder highlightFilter(boolean highlightFilter) {, +        this.highlightFilter = highlightFilter;]