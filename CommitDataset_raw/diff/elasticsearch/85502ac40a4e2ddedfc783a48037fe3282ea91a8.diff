[+++ b/src/main/java/org/elasticsearch/common/geo/builders/BasePolygonBuilder.java, +            // 2. the second logic check ensures the two candidate edges aren't already connected by an, +            //    existing edge along the dateline - this is necessary due to a logic change in, +            //    ShapeBuilder.intersection that computes dateline edges as valid intersect points , +            //    in support of OGC standards, +++ b/src/main/java/org/elasticsearch/common/geo/builders/BasePolygonBuilder.java, +            // 2. the second logic check ensures the two candidate edges aren't already connected by an, +            //    existing edge along the dateline - this is necessary due to a logic change in, +            //    ShapeBuilder.intersection that computes dateline edges as valid intersect points , +            //    in support of OGC standards, +++ b/src/main/java/org/elasticsearch/common/geo/builders/ShapeBuilder.java, +            //   1.  shell orientation is cw and range is greater than a hemisphere (180 degrees) but not spanning 2 hemispheres , +            //       (translation would result in a collapsed poly), +            if ((rng > DATELINE && rng != 2*DATELINE && orientation && component == 0) || (shell.translated && component != 0)) {, +                translate(points);, +        protected static void translate(Coordinate[] points) {, +++ b/src/main/java/org/elasticsearch/common/geo/builders/BasePolygonBuilder.java, +            // 2. the second logic check ensures the two candidate edges aren't already connected by an, +            //    existing edge along the dateline - this is necessary due to a logic change in, +            //    ShapeBuilder.intersection that computes dateline edges as valid intersect points , +            //    in support of OGC standards, +++ b/src/main/java/org/elasticsearch/common/geo/builders/ShapeBuilder.java, +            //   1.  shell orientation is cw and range is greater than a hemisphere (180 degrees) but not spanning 2 hemispheres , +            //       (translation would result in a collapsed poly), +            if ((rng > DATELINE && rng != 2*DATELINE && orientation && component == 0) || (shell.translated && component != 0)) {, +                translate(points);, +        protected static void translate(Coordinate[] points) {, +++ b/src/test/java/org/elasticsearch/common/geo/GeoJSONShapeParserTests.java, +    public void testParse_OGCPolygonWithoutHoles() throws IOException {, +        // test ccw poly not crossing dateline, +        ElasticsearchGeoAssertions.assertPolygon(shape);, +, +        // test ccw poly crossing dateline, +        , +        ElasticsearchGeoAssertions.assertMultiPolygon(shape);, +    @Test, +    public void testParse_OGCPolygonWithHoles() throws IOException {, +        // test ccw poly not crossing dateline, +        String polygonGeoJson = XContentFactory.jsonBuilder().startObject().field("type", "Polygon"), +                .startArray("coordinates"), +                .startArray(), +                .startArray().value(176.0).value(15.0).endArray(), +                .startArray().value(-177.0).value(10.0).endArray(), +                .startArray().value(-177.0).value(-10.0).endArray(), +                .startArray().value(176.0).value(-15.0).endArray(), +                .startArray().value(172.0).value(0.0).endArray(), +                .startArray().value(176.0).value(15.0).endArray(), +                .endArray(), +                .startArray(), +                .startArray().value(-172.0).value(8.0).endArray(), +                .startArray().value(174.0).value(10.0).endArray(), +                .startArray().value(-172.0).value(-8.0).endArray(), +                .startArray().value(-172.0).value(8.0).endArray(), +                .endArray(), +                .endArray(), +                .endObject().string();, +, +        XContentParser parser = JsonXContent.jsonXContent.createParser(polygonGeoJson);, +        parser.nextToken();, +        Shape shape = ShapeBuilder.parse(parser).build();, +, +        ElasticsearchGeoAssertions.assertPolygon(shape);, +, +        // test ccw poly crossing dateline, +        polygonGeoJson = XContentFactory.jsonBuilder().startObject().field("type", "Polygon"), +                .startArray("coordinates"), +                .startArray(), +                .startArray().value(-177.0).value(10.0).endArray(), +                .startArray().value(176.0).value(15.0).endArray(), +                .startArray().value(172.0).value(0.0).endArray(), +                .startArray().value(176.0).value(-15.0).endArray(), +                .startArray().value(-177.0).value(-10.0).endArray(), +                .startArray().value(-177.0).value(10.0).endArray(), +                .endArray(), +                .startArray(), +                .startArray().value(178.0).value(8.0).endArray(), +                .startArray().value(-178.0).value(8.0).endArray(), +                .startArray().value(-180.0).value(-8.0).endArray(), +                .startArray().value(178.0).value(8.0).endArray(), +                .endArray(), +                .endArray(), +                .endObject().string();, +, +        parser = JsonXContent.jsonXContent.createParser(polygonGeoJson);, +        parser.nextToken();, +        shape = ShapeBuilder.parse(parser).build();, +, +        ElasticsearchGeoAssertions.assertMultiPolygon(shape);, +    }, +++ b/src/main/java/org/elasticsearch/common/geo/builders/BasePolygonBuilder.java, +            // 2. the second logic check ensures the two candidate edges aren't already connected by an, +            //    existing edge along the dateline - this is necessary due to a logic change in, +            //    ShapeBuilder.intersection that computes dateline edges as valid intersect points , +            //    in support of OGC standards, +++ b/src/main/java/org/elasticsearch/common/geo/builders/ShapeBuilder.java, +            //   1.  shell orientation is cw and range is greater than a hemisphere (180 degrees) but not spanning 2 hemispheres , +            //       (translation would result in a collapsed poly), +            if ((rng > DATELINE && rng != 2*DATELINE && orientation && component == 0) || (shell.translated && component != 0)) {, +                translate(points);, +        protected static void translate(Coordinate[] points) {]