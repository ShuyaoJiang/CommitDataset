[+++ b/dev-tools/create-bwc-index.py, +  name = 'index-%s' % version.lower(), +  client.indices.delete(index=name, ignore=404), +  client.indices.create(index=name, body={, +  index_documents(client, name, 'doc', num_docs), +  run_basic_asserts(client, name, 'doc', num_docs), +++ b/dev-tools/create-bwc-index.py, +  name = 'index-%s' % version.lower(), +  client.indices.delete(index=name, ignore=404), +  client.indices.create(index=name, body={, +  index_documents(client, name, 'doc', num_docs), +  run_basic_asserts(client, name, 'doc', num_docs), +++ b/src/test/java/org/elasticsearch/bwcompat/OldIndexBackwardsCompatibilityTests.java, +import com.carrotsearch.randomizedtesting.LifecycleScope;, +import com.google.common.util.concurrent.ListenableFuture;, +import org.apache.lucene.util.LuceneTestCase;, +import org.apache.lucene.util.TestUtil;, +import org.elasticsearch.action.admin.indices.get.GetIndexResponse;, +import org.elasticsearch.common.io.FileSystemUtils;, +import org.elasticsearch.env.NodeEnvironment;, +import org.elasticsearch.index.engine.EngineConfig;, +import org.elasticsearch.test.ElasticsearchIntegrationTest;, +import org.junit.AfterClass;, +import java.io.InputStream;, +import java.util.Locale;, +import static org.hamcrest.Matchers.greaterThanOrEqualTo;, +@LuceneTestCase.SuppressCodecs({"Lucene3x", "MockFixedIntBlock", "MockVariableIntBlock", "MockSep", "MockRandom", "Lucene40", "Lucene41", "Appending", "Lucene42", "Lucene45", "Lucene46", "Lucene49"}), +@ElasticsearchIntegrationTest.ClusterScope(scope = ElasticsearchIntegrationTest.Scope.TEST, numDataNodes = 0), +public class OldIndexBackwardsCompatibilityTests extends ElasticsearchIntegrationTest {, +    static Path indicesDir;, +    public static void initIndexesList() throws Exception {, +    @AfterClass, +    public static void tearDownStatics() {, +        indexes = null;, +        indicesDir = null;, +    }, +, +    @Override, +    public Settings nodeSettings(int ord) {, +        return ImmutableSettings.builder(), +            .put(Node.HTTP_ENABLED, true) // for _upgrade, +            .put(MergePolicyModule.MERGE_POLICY_TYPE_KEY, NoMergePolicyProvider.class) // disable merging so no segments will be upgraded, +            .build();, +    }, +, +    void setupCluster() throws Exception {, +        ListenableFuture<List<String>> replicas = internalCluster().startNodesAsync(2); // for replicas, +, +        Path dataDir = newTempDirPath(LifecycleScope.SUITE);, +        ImmutableSettings.Builder nodeSettings = ImmutableSettings.builder(), +            .put("path.data", dataDir.toAbsolutePath()), +            .put("node.master", false); // workaround for dangling index loading issue when node is master, +        String loadingNode = internalCluster().startNode(nodeSettings.build());, +, +        Path[] nodePaths = internalCluster().getInstance(NodeEnvironment.class, loadingNode).nodeDataPaths();, +        assertEquals(1, nodePaths.length);, +        indicesDir = nodePaths[0].resolve(NodeEnvironment.INDICES_FOLDER);, +        assertFalse(Files.exists(indicesDir));, +        Files.createDirectories(indicesDir);, +, +        replicas.get(); // wait for replicas, +    }, +, +    String loadIndex(String indexFile) throws Exception {, +        Path unzipDir = newTempDirPath();, +        Path unzipDataDir = unzipDir.resolve("data");, +        String indexName = indexFile.replace(".zip", "").toLowerCase(Locale.ROOT);, +, +        // decompress the index, +        Path backwardsIndex = Paths.get(getClass().getResource(indexFile).toURI());, +        try (InputStream stream = Files.newInputStream(backwardsIndex)) {, +            TestUtil.unzip(stream, unzipDir);, +        }, +, +        // check it is unique, +        assertTrue(Files.exists(unzipDataDir));, +        Path[] list = FileSystemUtils.files(unzipDataDir);, +        if (list.length != 1) {, +            throw new IllegalStateException("Backwards index must contain exactly one cluster");, +        }, +, +        // the bwc scripts packs the indices under this path, +        Path src = list[0].resolve("nodes/0/indices/" + indexName);, +        Path dest = indicesDir.resolve(indexName);, +        assertTrue("[" + indexFile + "] missing index dir: " + src.toString(), Files.exists(src));, +, +        logger.info("--> injecting index [{}] into path [{}]", indexName, dest);, +        Files.move(src, dest);, +        assertFalse(Files.exists(src));, +        assertTrue(Files.exists(dest));, +, +        // force reloading dangling indices with a cluster state republish, +        client().admin().cluster().prepareReroute().get();, +        ensureGreen(indexName);, +        return indexName;, +    }, +, +    void unloadIndex(String indexName) throws Exception {, +        ElasticsearchAssertions.assertAcked(client().admin().indices().prepareDelete(indexName).get());, +        ElasticsearchAssertions.assertAllFilesClosed();]