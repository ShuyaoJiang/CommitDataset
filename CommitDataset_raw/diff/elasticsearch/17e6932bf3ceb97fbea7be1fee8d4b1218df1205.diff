[+++ /dev/null, +++ /dev/null, +++ b/server/src/test/java/org/elasticsearch/index/mapper/DocumentMapperParserTests.java, +++ /dev/null, +++ b/server/src/test/java/org/elasticsearch/index/mapper/DocumentMapperParserTests.java, +++ b/server/src/test/java/org/elasticsearch/index/mapper/DocumentMapperTests.java, +/*, + * Licensed to Elasticsearch under one or more contributor, + * license agreements. See the NOTICE file distributed with, + * this work for additional information regarding copyright, + * ownership. Elasticsearch licenses this file to you under, + * the Apache License, Version 2.0 (the "License"); you may, + * not use this file except in compliance with the License., + * You may obtain a copy of the License at, + *, + *    http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing,, + * software distributed under the License is distributed on an, + * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY, + * KIND, either express or implied.  See the License for the, + * specific language governing permissions and limitations, + * under the License., + */, +, +package org.elasticsearch.index.mapper;, +, +import org.elasticsearch.common.Strings;, +import org.elasticsearch.common.bytes.BytesArray;, +import org.elasticsearch.common.bytes.BytesReference;, +import org.elasticsearch.common.compress.CompressedXContent;, +import org.elasticsearch.common.settings.Settings;, +import org.elasticsearch.common.xcontent.XContentBuilder;, +import org.elasticsearch.common.xcontent.XContentFactory;, +import org.elasticsearch.common.xcontent.XContentType;, +import org.elasticsearch.test.ESSingleNodeTestCase;, +, +import java.io.IOException;, +import java.util.concurrent.CyclicBarrier;, +import java.util.concurrent.atomic.AtomicBoolean;, +import java.util.concurrent.atomic.AtomicReference;, +, +import static org.hamcrest.Matchers.containsString;, +import static org.hamcrest.Matchers.equalTo;, +import static org.hamcrest.Matchers.notNullValue;, +import static org.hamcrest.Matchers.nullValue;, +, +public class DocumentMapperTests extends ESSingleNodeTestCase {, +, +    public void test1Merge() throws Exception {, +, +        String stage1Mapping = Strings.toString(XContentFactory.jsonBuilder().startObject().startObject("person").startObject("properties"), +                .startObject("name").field("type", "text").endObject(), +                .endObject().endObject().endObject());, +        DocumentMapperParser parser = createIndex("test").mapperService().documentMapperParser();, +        DocumentMapper stage1 = parser.parse("person", new CompressedXContent(stage1Mapping));, +        String stage2Mapping = Strings.toString(XContentFactory.jsonBuilder().startObject().startObject("person").startObject("properties"), +                .startObject("name").field("type", "text").endObject(), +                .startObject("age").field("type", "integer").endObject(), +                .startObject("obj1").startObject("properties").startObject("prop1").field("type", "integer").endObject().endObject(), +                .endObject(), +                .endObject().endObject().endObject());, +        DocumentMapper stage2 = parser.parse("person", new CompressedXContent(stage2Mapping));, +, +        DocumentMapper merged = stage1.merge(stage2.mapping());, +        // stage1 mapping should not have been modified, +        assertThat(stage1.mappers().getMapper("age"), nullValue());, +        assertThat(stage1.mappers().getMapper("obj1.prop1"), nullValue());, +        // but merged should, +        assertThat(merged.mappers().getMapper("age"), notNullValue());, +        assertThat(merged.mappers().getMapper("obj1.prop1"), notNullValue());, +    }, +, +    public void testMergeObjectDynamic() throws Exception {, +        DocumentMapperParser parser = createIndex("test").mapperService().documentMapperParser();, +        String objectMapping = Strings.toString(XContentFactory.jsonBuilder().startObject().startObject("type1").endObject().endObject());, +        DocumentMapper mapper = parser.parse("type1", new CompressedXContent(objectMapping));, +        assertNull(mapper.root().dynamic());, +, +        String withDynamicMapping = Strings.toString(, +                XContentFactory.jsonBuilder().startObject().startObject("type1").field("dynamic", "false").endObject().endObject());, +        DocumentMapper withDynamicMapper = parser.parse("type1", new CompressedXContent(withDynamicMapping));, +        assertThat(withDynamicMapper.root().dynamic(), equalTo(ObjectMapper.Dynamic.FALSE));, +, +        DocumentMapper merged = mapper.merge(withDynamicMapper.mapping());, +        assertThat(merged.root().dynamic(), equalTo(ObjectMapper.Dynamic.FALSE));, +    }, +, +    public void testMergeObjectAndNested() throws Exception {, +        DocumentMapperParser parser = createIndex("test").mapperService().documentMapperParser();, +        String objectMapping = Strings.toString(XContentFactory.jsonBuilder().startObject().startObject("type1").startObject("properties"), +                .startObject("obj").field("type", "object").endObject(), +                .endObject().endObject().endObject());, +        DocumentMapper objectMapper = parser.parse("type1", new CompressedXContent(objectMapping));, +        String nestedMapping = Strings.toString(XContentFactory.jsonBuilder().startObject().startObject("type1").startObject("properties"), +                .startObject("obj").field("type", "nested").endObject(), +                .endObject().endObject().endObject());, +        DocumentMapper nestedMapper = parser.parse("type1", new CompressedXContent(nestedMapping));, +, +        try {]