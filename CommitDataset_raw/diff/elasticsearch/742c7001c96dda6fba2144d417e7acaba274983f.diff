[+++ b/plugin/watcher/src/main/java/org/elasticsearch/xpack/watcher/WatcherLifeCycleService.java, +import org.elasticsearch.common.util.concurrent.AbstractRunnable;, +import java.util.function.Consumer;, +                executor.execute(wrapWatcherService(() -> watcherService.pauseExecution("no watcher index found"),, +                        e -> logger.error("error pausing watch execution", e)));, +                executor.execute(wrapWatcherService(, +                        () -> watcherService.pauseExecution("no routing node for local node found, network issue?"),, +                        e -> logger.error("error pausing watch execution", e)));, +                executor.execute(wrapWatcherService(() -> watcherService.pauseExecution("no local watcher shards found"),, +                        e -> logger.error("error pausing watch execution", e)));, +                executor.execute(wrapWatcherService(() -> watcherService.reload(state, "new local watcher shard allocation ids"),, +                        e -> logger.error("error reloading watcher", e)));, +, +    /**, +     * Wraps an abstract runnable to easier supply onFailure and doRun methods via lambdas, +     * This ensures that the uncaught exception handler in the executing threadpool does not get called, +     *, +     * @param run                 The code to be executed in the runnable, +     * @param exceptionConsumer   The exception handling code to be executed, if the runnable fails, +     * @return                    The AbstractRunnable instance to pass to the executor, +     */, +    private static AbstractRunnable wrapWatcherService(Runnable run, Consumer<Exception> exceptionConsumer) {, +, +        return new AbstractRunnable() {, +            @Override, +            public void onFailure(Exception e) {, +                exceptionConsumer.accept(e);, +            }, +, +            @Override, +            protected void doRun() throws Exception {, +                run.run();, +            }, +        };, +    }, +++ b/plugin/watcher/src/main/java/org/elasticsearch/xpack/watcher/WatcherLifeCycleService.java, +import org.elasticsearch.common.util.concurrent.AbstractRunnable;, +import java.util.function.Consumer;, +                executor.execute(wrapWatcherService(() -> watcherService.pauseExecution("no watcher index found"),, +                        e -> logger.error("error pausing watch execution", e)));, +                executor.execute(wrapWatcherService(, +                        () -> watcherService.pauseExecution("no routing node for local node found, network issue?"),, +                        e -> logger.error("error pausing watch execution", e)));, +                executor.execute(wrapWatcherService(() -> watcherService.pauseExecution("no local watcher shards found"),, +                        e -> logger.error("error pausing watch execution", e)));, +                executor.execute(wrapWatcherService(() -> watcherService.reload(state, "new local watcher shard allocation ids"),, +                        e -> logger.error("error reloading watcher", e)));, +, +    /**, +     * Wraps an abstract runnable to easier supply onFailure and doRun methods via lambdas, +     * This ensures that the uncaught exception handler in the executing threadpool does not get called, +     *, +     * @param run                 The code to be executed in the runnable, +     * @param exceptionConsumer   The exception handling code to be executed, if the runnable fails, +     * @return                    The AbstractRunnable instance to pass to the executor, +     */, +    private static AbstractRunnable wrapWatcherService(Runnable run, Consumer<Exception> exceptionConsumer) {, +, +        return new AbstractRunnable() {, +            @Override, +            public void onFailure(Exception e) {, +                exceptionConsumer.accept(e);, +            }, +, +            @Override, +            protected void doRun() throws Exception {, +                run.run();, +            }, +        };, +    }, +++ b/plugin/watcher/src/test/java/org/elasticsearch/xpack/watcher/WatcherLifeCycleServiceTests.java, +import com.carrotsearch.randomizedtesting.annotations.Repeat;, +import org.elasticsearch.ElasticsearchSecurityException;, +    public void testWatcherServiceExceptionsAreCaught() {, +        Index index = new Index(Watch.INDEX, "foo");, +        IndexRoutingTable.Builder indexRoutingTableBuilder = IndexRoutingTable.builder(index);, +        indexRoutingTableBuilder.addShard(, +                TestShardRouting.newShardRouting(Watch.INDEX, 0, "node_1", true, ShardRoutingState.STARTED));, +        IndexMetaData indexMetaData = IndexMetaData.builder(Watch.INDEX).settings(settings(Version.CURRENT), +                .put(IndexMetaData.INDEX_FORMAT_SETTING.getKey(), 6)) // the internal index format, required, +                .numberOfShards(1).numberOfReplicas(0).build();, +, +        // special setup for one of the following cluster states, +        DiscoveryNodes discoveryNodes = mock(DiscoveryNodes.class);, +        DiscoveryNode localNode = mock(DiscoveryNode.class);, +        when(discoveryNodes.getMasterNodeId()).thenReturn("node_1");, +        when(discoveryNodes.getLocalNode()).thenReturn(localNode);, +        when(localNode.isDataNode()).thenReturn(true);, +        when(localNode.getId()).thenReturn("does_not_exist");, +, +        ClusterState clusterState = randomFrom(, +                // cluster state with no watcher index, +                ClusterState.builder(new ClusterName("my-cluster")), +                        .nodes(new DiscoveryNodes.Builder().masterNodeId("node_1").localNodeId("node_1").add(newNode("node_1"))), +                        .metaData(MetaData.builder(), +                                .put(IndexTemplateMetaData.builder(HISTORY_TEMPLATE_NAME).patterns(randomIndexPatterns())), +                                .put(IndexTemplateMetaData.builder(TRIGGERED_TEMPLATE_NAME).patterns(randomIndexPatterns())), +                                .put(IndexTemplateMetaData.builder(WATCHES_TEMPLATE_NAME).patterns(randomIndexPatterns())), +                                .build()), +                        .build(),]