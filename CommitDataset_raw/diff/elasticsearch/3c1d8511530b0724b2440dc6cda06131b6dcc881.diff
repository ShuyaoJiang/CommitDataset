[+++ b/x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authc/ApiKeyService.java, +import org.elasticsearch.action.search.SearchAction;, +            checkDuplicateApiKeyNameAndCreateApiKey(authentication, request, roleDescriptorSet, listener);, +        }, +    }, +, +    private void checkDuplicateApiKeyNameAndCreateApiKey(Authentication authentication, CreateApiKeyRequest request,, +                                                         Set<RoleDescriptor> roleDescriptorSet,, +                                                         ActionListener<CreateApiKeyResponse> listener) {, +        final BoolQueryBuilder boolQuery = QueryBuilders.boolQuery(), +                .filter(QueryBuilders.termQuery("doc_type", "api_key")), +                .filter(QueryBuilders.termQuery("name", request.getName())), +                .filter(QueryBuilders.termQuery("api_key_invalidated", false));, +        final BoolQueryBuilder expiredQuery = QueryBuilders.boolQuery(), +                .should(QueryBuilders.rangeQuery("expiration_time").lte(Instant.now().toEpochMilli())), +                .should(QueryBuilders.boolQuery().mustNot(QueryBuilders.existsQuery("expiration_time")));, +        boolQuery.filter(expiredQuery);, +, +        final SearchRequest searchRequest = client.prepareSearch(SECURITY_INDEX_NAME), +            .setScroll(DEFAULT_KEEPALIVE_SETTING.get(settings)), +            .setQuery(boolQuery), +            .setVersion(false), +            .setSize(1), +            .request();, +        securityIndex.prepareIndexIfNeededThenExecute(listener::onFailure, () ->, +        executeAsyncWithOrigin(client, SECURITY_ORIGIN, SearchAction.INSTANCE, searchRequest,, +                ActionListener.wrap(, +                        indexResponse -> {, +                            if (indexResponse.getHits().getTotalHits().value > 0) {, +                                listener.onFailure(traceLog("create api key", new ElasticsearchSecurityException(, +                                        "Error creating api key as api key with name [{}] already exists", request.getName())));, +                            } else {, +                                createApiKeyAndIndexIt(authentication, request, roleDescriptorSet, listener);, +                            }, +                        },, +                        listener::onFailure)));, +    }, +, +    private void createApiKeyAndIndexIt(Authentication authentication, CreateApiKeyRequest request, Set<RoleDescriptor> roleDescriptorSet,, +                                        ActionListener<CreateApiKeyResponse> listener) {, +++ b/x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authc/ApiKeyService.java, +import org.elasticsearch.action.search.SearchAction;, +            checkDuplicateApiKeyNameAndCreateApiKey(authentication, request, roleDescriptorSet, listener);, +        }, +    }, +, +    private void checkDuplicateApiKeyNameAndCreateApiKey(Authentication authentication, CreateApiKeyRequest request,, +                                                         Set<RoleDescriptor> roleDescriptorSet,, +                                                         ActionListener<CreateApiKeyResponse> listener) {, +        final BoolQueryBuilder boolQuery = QueryBuilders.boolQuery(), +                .filter(QueryBuilders.termQuery("doc_type", "api_key")), +                .filter(QueryBuilders.termQuery("name", request.getName())), +                .filter(QueryBuilders.termQuery("api_key_invalidated", false));, +        final BoolQueryBuilder expiredQuery = QueryBuilders.boolQuery(), +                .should(QueryBuilders.rangeQuery("expiration_time").lte(Instant.now().toEpochMilli())), +                .should(QueryBuilders.boolQuery().mustNot(QueryBuilders.existsQuery("expiration_time")));, +        boolQuery.filter(expiredQuery);, +, +        final SearchRequest searchRequest = client.prepareSearch(SECURITY_INDEX_NAME), +            .setScroll(DEFAULT_KEEPALIVE_SETTING.get(settings)), +            .setQuery(boolQuery), +            .setVersion(false), +            .setSize(1), +            .request();, +        securityIndex.prepareIndexIfNeededThenExecute(listener::onFailure, () ->, +        executeAsyncWithOrigin(client, SECURITY_ORIGIN, SearchAction.INSTANCE, searchRequest,, +                ActionListener.wrap(, +                        indexResponse -> {, +                            if (indexResponse.getHits().getTotalHits().value > 0) {, +                                listener.onFailure(traceLog("create api key", new ElasticsearchSecurityException(, +                                        "Error creating api key as api key with name [{}] already exists", request.getName())));, +                            } else {, +                                createApiKeyAndIndexIt(authentication, request, roleDescriptorSet, listener);, +                            }, +                        },, +                        listener::onFailure)));, +    }, +, +    private void createApiKeyAndIndexIt(Authentication authentication, CreateApiKeyRequest request, Set<RoleDescriptor> roleDescriptorSet,, +                                        ActionListener<CreateApiKeyResponse> listener) {, +++ b/x-pack/plugin/src/test/resources/rest-api-spec/test/api_key/10_basic.yml, +      security.put_role:, +        name: "admin_role", +        body:  >, +            {, +              "cluster": ["all"],, +              "indices": [, +                {, +                  "names": "*",, +                  "privileges": ["all"], +                }, +              ],, +              "applications": [, +                {, +                  "application": "myapp",, +                  "privileges": ["*"],, +                  "resources": ["*"], +                }, +              ], +            }]