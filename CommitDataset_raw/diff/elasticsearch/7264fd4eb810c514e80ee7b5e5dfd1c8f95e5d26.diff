[+++ b/src/main/java/org/elasticsearch/index/shard/TranslogRecoveryPerformer.java, +import org.elasticsearch.Version;, +import org.elasticsearch.common.xcontent.XContentHelper;, +import org.elasticsearch.common.xcontent.XContentParser;, +import org.elasticsearch.index.query.ParsedQuery;, +import org.elasticsearch.index.query.QueryParsingException;, +        Query query;, +        try {, +            query = queryParserService.parseQuery(source).query();, +        } catch (QueryParsingException ex) {, +            // for BWC we try to parse directly the query since pre 1.0.0.Beta2 we didn't require a top level query field, +            if ( queryParserService.getIndexCreatedVersion().onOrBefore(Version.V_1_0_0_Beta2)) {, +                try {, +                    XContentParser parser = XContentHelper.createParser(source);, +                    ParsedQuery parse = queryParserService.parse(parser);, +                    query = parse.query();, +                } catch (Throwable t) {, +                    ex.addSuppressed(t);, +                    throw ex;, +                }, +            } else {, +                throw ex;, +            }, +        }, +++ b/src/main/java/org/elasticsearch/index/shard/TranslogRecoveryPerformer.java, +import org.elasticsearch.Version;, +import org.elasticsearch.common.xcontent.XContentHelper;, +import org.elasticsearch.common.xcontent.XContentParser;, +import org.elasticsearch.index.query.ParsedQuery;, +import org.elasticsearch.index.query.QueryParsingException;, +        Query query;, +        try {, +            query = queryParserService.parseQuery(source).query();, +        } catch (QueryParsingException ex) {, +            // for BWC we try to parse directly the query since pre 1.0.0.Beta2 we didn't require a top level query field, +            if ( queryParserService.getIndexCreatedVersion().onOrBefore(Version.V_1_0_0_Beta2)) {, +                try {, +                    XContentParser parser = XContentHelper.createParser(source);, +                    ParsedQuery parse = queryParserService.parse(parser);, +                    query = parse.query();, +                } catch (Throwable t) {, +                    ex.addSuppressed(t);, +                    throw ex;, +                }, +            } else {, +                throw ex;, +            }, +        }, +++ b/src/test/java/org/elasticsearch/index/shard/IndexShardTests.java, +import org.elasticsearch.Version;, +import org.elasticsearch.common.bytes.BytesArray;, +import org.elasticsearch.index.query.QueryParsingException;, +import org.elasticsearch.test.VersionUtils;, +, +    public void testDeleteByQueryBWC() {, +        Version version = VersionUtils.randomVersion(random());, +        assertAcked(client().admin().indices().prepareCreate("test"), +                .setSettings(SETTING_NUMBER_OF_SHARDS, 1, SETTING_NUMBER_OF_REPLICAS, 0, IndexMetaData.SETTING_VERSION_CREATED, version.id));, +        ensureGreen("test");, +        client().prepareIndex("test", "person").setSource("{ \"user\" : \"kimchy\" }").get();, +, +        IndicesService indicesService = getInstanceFromNode(IndicesService.class);, +        IndexService test = indicesService.indexService("test");, +        IndexShard shard = test.shard(0);, +        int numDocs = 1;, +        shard.state = IndexShardState.RECOVERING;, +        try {, +            shard.recoveryState().getTranslog().totalOperations(1);, +            shard.engine().config().getTranslogRecoveryPerformer().performRecoveryOperation(shard.engine(), new Translog.DeleteByQuery(new Engine.DeleteByQuery(null, new BytesArray("{\"term\" : { \"user\" : \"kimchy\" }}"), null, null, null, Engine.Operation.Origin.RECOVERY, 0, "person")));, +            assertTrue(version.onOrBefore(Version.V_1_0_0_Beta2));, +            numDocs = 0;, +        } catch (QueryParsingException ex) {, +            assertTrue(version.after(Version.V_1_0_0_Beta2));, +        } finally {, +            shard.state = IndexShardState.STARTED;, +        }, +        shard.engine().refresh("foo");, +, +        try (Engine.Searcher searcher = shard.engine().acquireSearcher("foo")) {, +            assertEquals(numDocs, searcher.reader().numDocs());, +        }, +    }]