[+++ b/src/main/java/org/elasticsearch/cluster/routing/allocation/command/CancelAllocationCommand.java, +            return new CancelAllocationCommand(ShardId.readShardId(in), in.readString(), in.readBoolean());, +            out.writeBoolean(command.allowPrimary());, +            boolean allowPrimary = false;, +                    } else if ("allow_primary".equals(currentFieldName) || "allowPrimary".equals(currentFieldName)) {, +                        allowPrimary = parser.booleanValue();, +            return new CancelAllocationCommand(new ShardId(index, shardId), nodeId, allowPrimary);, +            builder.field("allow_primary", command.allowPrimary());, +    private final boolean allowPrimary;, +    public CancelAllocationCommand(ShardId shardId, String node, boolean allowPrimary) {, +        this.allowPrimary = allowPrimary;, +    public boolean allowPrimary() {, +        return this.allowPrimary;, +    }, +, +                    if (!allowPrimary && shardRouting.primary()) {, +                if (!allowPrimary && shardRouting.primary()) {, +                    throw new ElasticSearchIllegalArgumentException("[cancel_allocation] can't cancel " + shardId + " on node " + discoNode + ", shard is primary and started");, +++ b/src/main/java/org/elasticsearch/cluster/routing/allocation/command/CancelAllocationCommand.java, +            return new CancelAllocationCommand(ShardId.readShardId(in), in.readString(), in.readBoolean());, +            out.writeBoolean(command.allowPrimary());, +            boolean allowPrimary = false;, +                    } else if ("allow_primary".equals(currentFieldName) || "allowPrimary".equals(currentFieldName)) {, +                        allowPrimary = parser.booleanValue();, +            return new CancelAllocationCommand(new ShardId(index, shardId), nodeId, allowPrimary);, +            builder.field("allow_primary", command.allowPrimary());, +    private final boolean allowPrimary;, +    public CancelAllocationCommand(ShardId shardId, String node, boolean allowPrimary) {, +        this.allowPrimary = allowPrimary;, +    public boolean allowPrimary() {, +        return this.allowPrimary;, +    }, +, +                    if (!allowPrimary && shardRouting.primary()) {, +                if (!allowPrimary && shardRouting.primary()) {, +                    throw new ElasticSearchIllegalArgumentException("[cancel_allocation] can't cancel " + shardId + " on node " + discoNode + ", shard is primary and started");, +++ b/src/test/java/org/elasticsearch/test/unit/cluster/routing/allocation/AllocationCommandsTests.java, +            allocation.reroute(clusterState, new AllocationCommands(new CancelAllocationCommand(new ShardId("test", 0), "node1", false)));, +            allocation.reroute(clusterState, new AllocationCommands(new CancelAllocationCommand(new ShardId("test", 0), "node1", false)));, +        rerouteResult = allocation.reroute(clusterState, new AllocationCommands(new CancelAllocationCommand(new ShardId("test", 0), "node2", false)));, +        logger.info("--> cancel the primary being replicated, make sure it fails");, +            allocation.reroute(clusterState, new AllocationCommands(new CancelAllocationCommand(new ShardId("test", 0), "node1", false)));, +        rerouteResult = allocation.reroute(clusterState, new AllocationCommands(new CancelAllocationCommand(new ShardId("test", 0), "node2", false)));, +, +        logger.info("--> allocate the replica shard on on the second node");, +        rerouteResult = allocation.reroute(clusterState, new AllocationCommands(new AllocateAllocationCommand(new ShardId("test", 0), "node2", false)));, +        clusterState = newClusterStateBuilder().state(clusterState).routingTable(rerouteResult.routingTable()).build();, +        assertThat(rerouteResult.changed(), equalTo(true));, +        assertThat(clusterState.routingNodes().node("node1").shards().size(), equalTo(1));, +        assertThat(clusterState.routingNodes().node("node1").shardsWithState(STARTED).size(), equalTo(1));, +        assertThat(clusterState.routingNodes().node("node2").shards().size(), equalTo(1));, +        assertThat(clusterState.routingNodes().node("node2").shardsWithState(INITIALIZING).size(), equalTo(1));, +        logger.info("--> start the replica shard");, +        rerouteResult = allocation.applyStartedShards(clusterState, clusterState.routingNodes().shardsWithState(INITIALIZING));, +        clusterState = newClusterStateBuilder().state(clusterState).routingTable(rerouteResult.routingTable()).build();, +        assertThat(clusterState.routingNodes().node("node1").shards().size(), equalTo(1));, +        assertThat(clusterState.routingNodes().node("node1").shardsWithState(STARTED).size(), equalTo(1));, +        assertThat(clusterState.routingNodes().node("node2").shards().size(), equalTo(1));, +        assertThat(clusterState.routingNodes().node("node2").shardsWithState(STARTED).size(), equalTo(1));, +, +        logger.info("--> cancel the primary allocation (with allow_primary set to true)");, +        rerouteResult = allocation.reroute(clusterState, new AllocationCommands(new CancelAllocationCommand(new ShardId("test", 0), "node1", true)));, +        clusterState = newClusterStateBuilder().state(clusterState).routingTable(rerouteResult.routingTable()).build();, +        assertThat(rerouteResult.changed(), equalTo(true));, +        assertThat(clusterState.routingNodes().node("node2").shardsWithState(STARTED).get(0).primary(), equalTo(true));, +        assertThat(clusterState.routingNodes().node("node1").shards().size(), equalTo(0));, +        assertThat(clusterState.routingNodes().node("node3").shards().size(), equalTo(0));, +                new CancelAllocationCommand(new ShardId("test", 4), "node5", true), +        assertThat(((CancelAllocationCommand) (sCommands.commands().get(2))).allowPrimary(), equalTo(true));, +                "       ,{\"cancel\" : {\"index\" : \"test\", \"shard\" : 4, \"node\" : \"node5\", \"allow_primary\" : true}} \n" +, +        assertThat(((CancelAllocationCommand) (sCommands.commands().get(2))).allowPrimary(), equalTo(true));]