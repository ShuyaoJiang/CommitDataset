[+++ b/modules/elasticsearch/src/main/java/org/elasticsearch/action/get/TransportGetAction.java, +import org.apache.lucene.index.IndexReader;, +import org.apache.lucene.index.Term;, +import org.apache.lucene.util.UnicodeUtil;, +import org.elasticsearch.common.Unicode;, +import org.elasticsearch.common.bloom.BloomFilter;, +import org.elasticsearch.index.cache.bloom.BloomCache;, +import org.elasticsearch.index.mapper.*;, +        BloomCache bloomCache = indexService.cache().bloomCache();, +            UidField.DocIdAndVersion docIdAndVersion = loadCurrentVersionFromIndex(bloomCache, searcher, docMapper.uidMapper().term(request.type(), request.id()));, +            if (docIdAndVersion != null && docIdAndVersion.docId != Lucene.NO_DOC) {, +                    Document doc = docIdAndVersion.reader.document(docIdAndVersion.docId, fieldSelector);, +    private UidField.DocIdAndVersion loadCurrentVersionFromIndex(BloomCache bloomCache, Engine.Searcher searcher, Term uid) {, +        UnicodeUtil.UTF8Result utf8 = Unicode.fromStringAsUtf8(uid.text());, +        for (IndexReader reader : searcher.searcher().subReaders()) {, +            BloomFilter filter = bloomCache.filter(reader, UidFieldMapper.NAME, true);, +            // we know that its not there..., +            if (!filter.isPresent(utf8.result, 0, utf8.length)) {, +                continue;, +            }, +            UidField.DocIdAndVersion docIdAndVersion = UidField.loadDocIdAndVersion(reader, uid);, +            // either -2 (its there, but no version associated), or an actual version, +            if (docIdAndVersion.docId != -1) {, +                return docIdAndVersion;, +            }, +        }, +        return null;, +    }, +, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/action/get/TransportGetAction.java, +import org.apache.lucene.index.IndexReader;, +import org.apache.lucene.index.Term;, +import org.apache.lucene.util.UnicodeUtil;, +import org.elasticsearch.common.Unicode;, +import org.elasticsearch.common.bloom.BloomFilter;, +import org.elasticsearch.index.cache.bloom.BloomCache;, +import org.elasticsearch.index.mapper.*;, +        BloomCache bloomCache = indexService.cache().bloomCache();, +            UidField.DocIdAndVersion docIdAndVersion = loadCurrentVersionFromIndex(bloomCache, searcher, docMapper.uidMapper().term(request.type(), request.id()));, +            if (docIdAndVersion != null && docIdAndVersion.docId != Lucene.NO_DOC) {, +                    Document doc = docIdAndVersion.reader.document(docIdAndVersion.docId, fieldSelector);, +    private UidField.DocIdAndVersion loadCurrentVersionFromIndex(BloomCache bloomCache, Engine.Searcher searcher, Term uid) {, +        UnicodeUtil.UTF8Result utf8 = Unicode.fromStringAsUtf8(uid.text());, +        for (IndexReader reader : searcher.searcher().subReaders()) {, +            BloomFilter filter = bloomCache.filter(reader, UidFieldMapper.NAME, true);, +            // we know that its not there..., +            if (!filter.isPresent(utf8.result, 0, utf8.length)) {, +                continue;, +            }, +            UidField.DocIdAndVersion docIdAndVersion = UidField.loadDocIdAndVersion(reader, uid);, +            // either -2 (its there, but no version associated), or an actual version, +            if (docIdAndVersion.docId != -1) {, +                return docIdAndVersion;, +            }, +        }, +        return null;, +    }, +, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/common/lucene/uid/UidField.java, +        public final IndexReader reader;, +        public DocIdAndVersion(int docId, long version, IndexReader reader) {, +            this.reader = reader;, +                return new DocIdAndVersion(Lucene.NO_DOC, -1, reader);, +                return new DocIdAndVersion(docId, -2, reader);, +                return new DocIdAndVersion(docId, -2, reader);, +            return new DocIdAndVersion(docId, Numbers.bytesToLong(payload), reader);, +            return new DocIdAndVersion(docId, -2, reader);, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/action/get/TransportGetAction.java, +import org.apache.lucene.index.IndexReader;, +import org.apache.lucene.index.Term;, +import org.apache.lucene.util.UnicodeUtil;, +import org.elasticsearch.common.Unicode;, +import org.elasticsearch.common.bloom.BloomFilter;, +import org.elasticsearch.index.cache.bloom.BloomCache;, +import org.elasticsearch.index.mapper.*;, +        BloomCache bloomCache = indexService.cache().bloomCache();, +            UidField.DocIdAndVersion docIdAndVersion = loadCurrentVersionFromIndex(bloomCache, searcher, docMapper.uidMapper().term(request.type(), request.id()));, +            if (docIdAndVersion != null && docIdAndVersion.docId != Lucene.NO_DOC) {, +                    Document doc = docIdAndVersion.reader.document(docIdAndVersion.docId, fieldSelector);, +    private UidField.DocIdAndVersion loadCurrentVersionFromIndex(BloomCache bloomCache, Engine.Searcher searcher, Term uid) {, +        UnicodeUtil.UTF8Result utf8 = Unicode.fromStringAsUtf8(uid.text());, +        for (IndexReader reader : searcher.searcher().subReaders()) {, +            BloomFilter filter = bloomCache.filter(reader, UidFieldMapper.NAME, true);, +            // we know that its not there..., +            if (!filter.isPresent(utf8.result, 0, utf8.length)) {, +                continue;, +            }, +            UidField.DocIdAndVersion docIdAndVersion = UidField.loadDocIdAndVersion(reader, uid);, +            // either -2 (its there, but no version associated), or an actual version, +            if (docIdAndVersion.docId != -1) {, +                return docIdAndVersion;, +            }, +        }, +        return null;, +    }, +, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/common/lucene/uid/UidField.java, +        public final IndexReader reader;, +        public DocIdAndVersion(int docId, long version, IndexReader reader) {, +            this.reader = reader;]