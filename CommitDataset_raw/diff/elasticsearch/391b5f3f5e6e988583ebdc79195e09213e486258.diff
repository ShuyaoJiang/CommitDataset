[+++ b/src/main/java/org/elasticsearch/search/aggregations/bucket/range/InternalRange.java, +, +import org.elasticsearch.search.aggregations.AggregationStreams;, +import org.elasticsearch.search.aggregations.Aggregations;, +import org.elasticsearch.search.aggregations.InternalAggregation;, +import org.elasticsearch.search.aggregations.InternalAggregations;, +import org.elasticsearch.search.aggregations.InternalMultiBucketAggregation;, +        public String getFromAsString() {, +            if (Double.isInfinite(from)) {, +                return null;, +            } else if (formatter == null) {, +                return ValueFormatter.RAW.format(from);, +            } else {, +                return formatter.format(from);, +            }, +        }, +, +        @Override, +        public String getToAsString() {, +            if (Double.isInfinite(to)) {, +                return null;, +            } else if (formatter == null) {, +                return ValueFormatter.RAW.format(to);, +            } else {, +                return formatter.format(to);, +            }, +        }, +, +        @Override, +++ b/src/main/java/org/elasticsearch/search/aggregations/bucket/range/InternalRange.java, +, +import org.elasticsearch.search.aggregations.AggregationStreams;, +import org.elasticsearch.search.aggregations.Aggregations;, +import org.elasticsearch.search.aggregations.InternalAggregation;, +import org.elasticsearch.search.aggregations.InternalAggregations;, +import org.elasticsearch.search.aggregations.InternalMultiBucketAggregation;, +        public String getFromAsString() {, +            if (Double.isInfinite(from)) {, +                return null;, +            } else if (formatter == null) {, +                return ValueFormatter.RAW.format(from);, +            } else {, +                return formatter.format(from);, +            }, +        }, +, +        @Override, +        public String getToAsString() {, +            if (Double.isInfinite(to)) {, +                return null;, +            } else if (formatter == null) {, +                return ValueFormatter.RAW.format(to);, +            } else {, +                return formatter.format(to);, +            }, +        }, +, +        @Override, +++ b/src/main/java/org/elasticsearch/search/aggregations/bucket/range/Range.java, +         * @return The string value for the lower bound of the range, +         */, +        String getFromAsString();, +, +        /**, +, +        /**, +         * @return The string value for the upper bound of the range (excluding), +         */, +        String getToAsString();, +++ b/src/main/java/org/elasticsearch/search/aggregations/bucket/range/InternalRange.java, +, +import org.elasticsearch.search.aggregations.AggregationStreams;, +import org.elasticsearch.search.aggregations.Aggregations;, +import org.elasticsearch.search.aggregations.InternalAggregation;, +import org.elasticsearch.search.aggregations.InternalAggregations;, +import org.elasticsearch.search.aggregations.InternalMultiBucketAggregation;, +        public String getFromAsString() {, +            if (Double.isInfinite(from)) {, +                return null;, +            } else if (formatter == null) {, +                return ValueFormatter.RAW.format(from);, +            } else {, +                return formatter.format(from);, +            }, +        }, +, +        @Override, +        public String getToAsString() {, +            if (Double.isInfinite(to)) {, +                return null;, +            } else if (formatter == null) {, +                return ValueFormatter.RAW.format(to);, +            } else {, +                return formatter.format(to);, +            }, +        }, +, +        @Override, +++ b/src/main/java/org/elasticsearch/search/aggregations/bucket/range/Range.java, +         * @return The string value for the lower bound of the range]