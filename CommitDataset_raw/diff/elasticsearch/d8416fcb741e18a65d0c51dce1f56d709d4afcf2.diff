[+++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/Def.java, +            throw new ClassCastException("cannot cast " +, +                    "def [" + PainlessLookupUtility.typeToUnboxedType(value.getClass()).getCanonicalName() + "] to " +, +                    boolean.class.getCanonicalName());, +                    "def [" + PainlessLookupUtility.typeToUnboxedType(value.getClass()).getCanonicalName() + "] to " +, +                    byte.class.getCanonicalName());, +                    "def [" + PainlessLookupUtility.typeToUnboxedType(value.getClass()).getCanonicalName() + "] to " +, +                    short.class.getCanonicalName());, +                    "def [" + PainlessLookupUtility.typeToUnboxedType(value.getClass()).getCanonicalName() + "] to " +, +                    char.class.getCanonicalName());, +                    "def [" + PainlessLookupUtility.typeToUnboxedType(value.getClass()).getCanonicalName() + "] to " +, +                    int.class.getCanonicalName());, +            throw new ClassCastException("cannot implicitly cast " +, +                    "def [" + PainlessLookupUtility.typeToUnboxedType(value.getClass()).getCanonicalName() + "] to " +, +                    long.class.getCanonicalName());, +            throw new ClassCastException("cannot implicitly cast " +, +                    "def [" + PainlessLookupUtility.typeToUnboxedType(value.getClass()).getCanonicalName() + "] to " +, +                    float.class.getCanonicalName());, +            throw new ClassCastException("cannot implicitly cast " +, +                    "def [" + PainlessLookupUtility.typeToUnboxedType(value.getClass()).getCanonicalName() + "] to " +, +                    double.class.getCanonicalName());, +            throw new ClassCastException("cannot explicitly cast " +, +                    "def [" + PainlessLookupUtility.typeToUnboxedType(value.getClass()).getCanonicalName() + "] to " +, +                    byte.class.getCanonicalName());, +            throw new ClassCastException("cannot explicitly cast " +, +                    "def [" + PainlessLookupUtility.typeToUnboxedType(value.getClass()).getCanonicalName() + "] to " +, +                    short.class.getCanonicalName());, +        if (value instanceof String) {, +            return Utility.StringTochar((String)value);, +        } else if (value instanceof Character) {, +            throw new ClassCastException("cannot explicitly cast " +, +                    "def [" + PainlessLookupUtility.typeToUnboxedType(value.getClass()).getCanonicalName() + "] to " +, +                    char.class.getCanonicalName());, +            throw new ClassCastException("cannot explicitly cast " +, +                    "def [" + PainlessLookupUtility.typeToUnboxedType(value.getClass()).getCanonicalName() + "] to " +, +                    int.class.getCanonicalName());, +            throw new ClassCastException("cannot explicitly cast " +, +                    "def [" + PainlessLookupUtility.typeToUnboxedType(value.getClass()).getCanonicalName() + "] to " +, +                    long.class.getCanonicalName());, +            throw new ClassCastException("cannot explicitly cast " +, +                    "float [" + PainlessLookupUtility.typeToUnboxedType(value.getClass()).getCanonicalName() + "] to " +, +                    byte.class.getCanonicalName());, +            throw new ClassCastException("cannot explicitly cast " +, +                    "def [" + PainlessLookupUtility.typeToUnboxedType(value.getClass()).getCanonicalName() + "] to " +, +                    byte.class.getCanonicalName());, +                    "def [" + PainlessLookupUtility.typeToUnboxedType(value.getClass()).getCanonicalName() + "] to " +, +                    Double.class.getCanonicalName());, +                    "def [" + PainlessLookupUtility.typeToUnboxedType(value.getClass()).getCanonicalName() + "] to " +, +                    Byte.class.getCanonicalName());, +                    "def [" + PainlessLookupUtility.typeToUnboxedType(value.getClass()).getCanonicalName() + "] to " +, +                    Short.class.getCanonicalName());, +        } else if (value instanceof String) {, +            return Utility.StringTochar((String)value);, +                    "def [" + PainlessLookupUtility.typeToUnboxedType(value.getClass()).getCanonicalName() + "] to " +, +                    Character.class.getCanonicalName());, +                    "def [" + PainlessLookupUtility.typeToUnboxedType(value.getClass()).getCanonicalName() + "] to " +, +                    Integer.class.getCanonicalName());, +                    "def [" + PainlessLookupUtility.typeToUnboxedType(value.getClass()).getCanonicalName() + "] to " +, +                    Long.class.getCanonicalName());, +                    "def [" + PainlessLookupUtility.typeToUnboxedType(value.getClass()).getCanonicalName() + "] to " +, +                    Float.class.getCanonicalName());, +                    "def [" + PainlessLookupUtility.typeToUnboxedType(value.getClass()).getCanonicalName() + "] to " +, +                    Double.class.getCanonicalName());, +        }, +    }, +, +    public static String defToStringImplicit(final Object value) {, +        if (value == null) {, +            return null;, +        } else if (value instanceof String) {, +            return (String)value;, +        } else {, +            throw new ClassCastException("cannot implicitly cast " +, +                    "def [" + PainlessLookupUtility.typeToUnboxedType(value.getClass()).getCanonicalName() + "] to " +, +                    String.class.getCanonicalName());, +        }, +    }, +, +    public static String defToStringExplicit(final Object value) {, +        if (value == null) {, +            return null;, +        } else if (value instanceof Character) {, +            return Utility.charToString((char)value);, +        } else if (value instanceof String) {, +            return (String)value;, +        } else {, +             throw new ClassCastException("cannot explicitly cast " +, +                     "def [" + PainlessLookupUtility.typeToUnboxedType(value.getClass()).getCanonicalName() + "] to " +, +                     String.class.getCanonicalName());, +++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/Def.java, +            throw new ClassCastException("cannot cast " +, +                    "def [" + PainlessLookupUtility.typeToUnboxedType(value.getClass()).getCanonicalName() + "] to " +, +                    boolean.class.getCanonicalName());, +                    "def [" + PainlessLookupUtility.typeToUnboxedType(value.getClass()).getCanonicalName() + "] to " +, +                    byte.class.getCanonicalName());, +                    "def [" + PainlessLookupUtility.typeToUnboxedType(value.getClass()).getCanonicalName() + "] to " +, +                    short.class.getCanonicalName());, +                    "def [" + PainlessLookupUtility.typeToUnboxedType(value.getClass()).getCanonicalName() + "] to " +, +                    char.class.getCanonicalName());, +                    "def [" + PainlessLookupUtility.typeToUnboxedType(value.getClass()).getCanonicalName() + "] to " +]