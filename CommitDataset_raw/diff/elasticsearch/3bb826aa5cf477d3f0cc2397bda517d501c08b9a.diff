[+++ b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/authz/permission/IndicesPermission.java, +                    && (allowRestrictedIndices || (false == RestrictedIndicesNames.RESTRICTED_NAMES.contains(index)));, +                    .and(index -> false == RestrictedIndicesNames.RESTRICTED_NAMES.contains(index));, +                         .and(index -> false == RestrictedIndicesNames.RESTRICTED_NAMES.contains(index)));, +++ b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/authz/permission/IndicesPermission.java, +                    && (allowRestrictedIndices || (false == RestrictedIndicesNames.RESTRICTED_NAMES.contains(index)));, +                    .and(index -> false == RestrictedIndicesNames.RESTRICTED_NAMES.contains(index));, +                         .and(index -> false == RestrictedIndicesNames.RESTRICTED_NAMES.contains(index)));, +++ b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/index/RestrictedIndicesNames.java, +    public static final String INTERNAL_SECURITY_INDEX_6 = ".security-6";, +    public static final String INTERNAL_SECURITY_INDEX_7 = ".security-7";, +    public static final Set<String> RESTRICTED_NAMES = Collections.unmodifiableSet(, +        Sets.newHashSet(SECURITY_INDEX_NAME, INTERNAL_SECURITY_INDEX_6, INTERNAL_SECURITY_INDEX_7));, +, +    public static final Automaton NAMES_AUTOMATON = Automatons.patterns(RESTRICTED_NAMES);, +++ b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/authz/permission/IndicesPermission.java, +                    && (allowRestrictedIndices || (false == RestrictedIndicesNames.RESTRICTED_NAMES.contains(index)));, +                    .and(index -> false == RestrictedIndicesNames.RESTRICTED_NAMES.contains(index));, +                         .and(index -> false == RestrictedIndicesNames.RESTRICTED_NAMES.contains(index)));, +++ b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/index/RestrictedIndicesNames.java, +    public static final String INTERNAL_SECURITY_INDEX_6 = ".security-6";, +    public static final String INTERNAL_SECURITY_INDEX_7 = ".security-7";, +    public static final Set<String> RESTRICTED_NAMES = Collections.unmodifiableSet(, +        Sets.newHashSet(SECURITY_INDEX_NAME, INTERNAL_SECURITY_INDEX_6, INTERNAL_SECURITY_INDEX_7));, +, +    public static final Automaton NAMES_AUTOMATON = Automatons.patterns(RESTRICTED_NAMES);, +++ b/x-pack/plugin/core/src/test/java/org/elasticsearch/xpack/core/security/authz/store/ReservedRolesStoreTests.java, +        for (String index : RestrictedIndicesNames.RESTRICTED_NAMES) {, +            // This test might cease to be true if we ever have non-security restricted names, +            // but that depends on how users are supposed to perform snapshots of those new indices., +            assertThat(snapshotUserRole.indices().allowedIndicesMatcher(GetIndexAction.NAME).test(index), is(true));, +        }, +, +        assertNoAccessAllowed(snapshotUserRole, RestrictedIndicesNames.RESTRICTED_NAMES);, +        assertNoAccessAllowed(ingestAdminRole, RestrictedIndicesNames.RESTRICTED_NAMES);, +        assertNoAccessAllowed(kibanaRole, RestrictedIndicesNames.RESTRICTED_NAMES);, +        assertNoAccessAllowed(kibanaUserRole, RestrictedIndicesNames.RESTRICTED_NAMES);, +        assertNoAccessAllowed(monitoringUserRole, RestrictedIndicesNames.RESTRICTED_NAMES);, +        assertNoAccessAllowed(remoteMonitoringAgentRole, RestrictedIndicesNames.RESTRICTED_NAMES);, +        // These tests might need to change if we add new non-security restricted indices that the monitoring user isn't supposed to see, +        // (but ideally, the monitoring user should see all indices)., +                .test(randomFrom(RestrictedIndicesNames.RESTRICTED_NAMES)), is(true));, +                .test(randomFrom(RestrictedIndicesNames.RESTRICTED_NAMES)), is(true));, +                .test(randomFrom(RestrictedIndicesNames.RESTRICTED_NAMES)), is(true));, +                .test(randomFrom(RestrictedIndicesNames.RESTRICTED_NAMES)), is(true));, +                .test(randomFrom(RestrictedIndicesNames.RESTRICTED_NAMES)), is(true));, +                .test(randomFrom(RestrictedIndicesNames.RESTRICTED_NAMES)), is(true));, +, +                .test(randomFrom(RestrictedIndicesNames.RESTRICTED_NAMES)), is(false));, +                .test(randomFrom(RestrictedIndicesNames.RESTRICTED_NAMES)), is(false));, +                .test(randomFrom(RestrictedIndicesNames.RESTRICTED_NAMES)), is(false));, +                .test(randomFrom(RestrictedIndicesNames.RESTRICTED_NAMES)), is(false));, +        assertNoAccessAllowed(remoteMonitoringAgentRole, RestrictedIndicesNames.RESTRICTED_NAMES);, +        final String internalSecurityIndex = randomFrom(RestrictedIndicesNames.INTERNAL_SECURITY_INDEX_6,, +            RestrictedIndicesNames.INTERNAL_SECURITY_INDEX_7);, +                .put(new IndexMetaData.Builder(internalSecurityIndex), +                Sets.newHashSet(internalSecurityIndex, RestrictedIndicesNames.SECURITY_INDEX_NAME),, +            assertThat(authzMap.get(internalSecurityIndex).isGranted(), is(true));, +        assertNoAccessAllowed(reportingUserRole, RestrictedIndicesNames.RESTRICTED_NAMES);, +        assertNoAccessAllowed(dashboardsOnlyUserRole, RestrictedIndicesNames.RESTRICTED_NAMES);, +        final String internalSecurityIndex = randomFrom(RestrictedIndicesNames.INTERNAL_SECURITY_INDEX_6,, +            RestrictedIndicesNames.INTERNAL_SECURITY_INDEX_7);, +                .put(new IndexMetaData.Builder(internalSecurityIndex), +        assertThat(authzMap.get(internalSecurityIndex).isGranted(), is(true));, +                .test(internalSecurityIndex), is(true));, +        assertNoAccessAllowed(logstashSystemRole, RestrictedIndicesNames.RESTRICTED_NAMES);, +        assertNoAccessAllowed(beatsAdminRole, RestrictedIndicesNames.RESTRICTED_NAMES);, +        assertNoAccessAllowed(logstashSystemRole, RestrictedIndicesNames.RESTRICTED_NAMES);, +        assertNoAccessAllowed(APMSystemRole, RestrictedIndicesNames.RESTRICTED_NAMES);, +        assertNoAccessAllowed(role, RestrictedIndicesNames.RESTRICTED_NAMES);, +        assertNoAccessAllowed(role, RestrictedIndicesNames.RESTRICTED_NAMES);, +        assertNoAccessAllowed(role, RestrictedIndicesNames.RESTRICTED_NAMES);, +        assertNoAccessAllowed(role, RestrictedIndicesNames.RESTRICTED_NAMES);, +        assertNoAccessAllowed(role, RestrictedIndicesNames.RESTRICTED_NAMES);, +++ b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/authz/permission/IndicesPermission.java, +                    && (allowRestrictedIndices || (false == RestrictedIndicesNames.RESTRICTED_NAMES.contains(index)));, +                    .and(index -> false == RestrictedIndicesNames.RESTRICTED_NAMES.contains(index));, +                         .and(index -> false == RestrictedIndicesNames.RESTRICTED_NAMES.contains(index)));, +++ b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/index/RestrictedIndicesNames.java, +    public static final String INTERNAL_SECURITY_INDEX_6 = ".security-6";, +    public static final String INTERNAL_SECURITY_INDEX_7 = ".security-7";, +    public static final Set<String> RESTRICTED_NAMES = Collections.unmodifiableSet(, +        Sets.newHashSet(SECURITY_INDEX_NAME, INTERNAL_SECURITY_INDEX_6, INTERNAL_SECURITY_INDEX_7));, +, +    public static final Automaton NAMES_AUTOMATON = Automatons.patterns(RESTRICTED_NAMES);, +++ b/x-pack/plugin/core/src/test/java/org/elasticsearch/xpack/core/security/authz/store/ReservedRolesStoreTests.java, +        for (String index : RestrictedIndicesNames.RESTRICTED_NAMES) {, +            // This test might cease to be true if we ever have non-security restricted names, +            // but that depends on how users are supposed to perform snapshots of those new indices., +            assertThat(snapshotUserRole.indices().allowedIndicesMatcher(GetIndexAction.NAME).test(index), is(true));, +        }, +, +        assertNoAccessAllowed(snapshotUserRole, RestrictedIndicesNames.RESTRICTED_NAMES);, +        assertNoAccessAllowed(ingestAdminRole, RestrictedIndicesNames.RESTRICTED_NAMES);, +        assertNoAccessAllowed(kibanaRole, RestrictedIndicesNames.RESTRICTED_NAMES);, +        assertNoAccessAllowed(kibanaUserRole, RestrictedIndicesNames.RESTRICTED_NAMES);, +        assertNoAccessAllowed(monitoringUserRole, RestrictedIndicesNames.RESTRICTED_NAMES);, +        assertNoAccessAllowed(remoteMonitoringAgentRole, RestrictedIndicesNames.RESTRICTED_NAMES);, +        // These tests might need to change if we add new non-security restricted indices that the monitoring user isn't supposed to see, +        // (but ideally, the monitoring user should see all indices).]