[+++ b/core/src/main/java/org/elasticsearch/index/mapper/internal/SourceFieldMapper.java, +import org.elasticsearch.Version;, +            return new SourceFieldMapper(enabled, includes, excludes, context.indexSettings());, +                } else if ("format".equals(fieldName) && parserContext.indexVersionCreated().before(Version.V_3_0_0)) {, +                    // ignore on old indices, reject on and after 3.0, +        this(Defaults.ENABLED, null, null, indexSettings);, +    private SourceFieldMapper(boolean enabled, String[] includes, String[] excludes, Settings indexSettings) {, +            XContentType contentType = mapTuple.v1();, +++ b/core/src/main/java/org/elasticsearch/index/mapper/internal/SourceFieldMapper.java, +import org.elasticsearch.Version;, +            return new SourceFieldMapper(enabled, includes, excludes, context.indexSettings());, +                } else if ("format".equals(fieldName) && parserContext.indexVersionCreated().before(Version.V_3_0_0)) {, +                    // ignore on old indices, reject on and after 3.0, +        this(Defaults.ENABLED, null, null, indexSettings);, +    private SourceFieldMapper(boolean enabled, String[] includes, String[] excludes, Settings indexSettings) {, +            XContentType contentType = mapTuple.v1();, +++ b/core/src/test/java/org/elasticsearch/index/mapper/source/DefaultSourceMappingTests.java, +import org.elasticsearch.test.VersionUtils;, +    public void testFormatBackCompat() throws Exception {, +        Settings settings = Settings.builder(), +                .put(IndexMetaData.SETTING_VERSION_CREATED, VersionUtils.randomVersionBetween(random(), Version.V_2_0_0, Version.V_2_2_0)), +                .build();, +        DocumentMapperParser parser = createIndex("test", settings).mapperService().documentMapperParser();, +        parser.parse(mapping); // no exception, +++ b/core/src/main/java/org/elasticsearch/index/mapper/internal/SourceFieldMapper.java, +import org.elasticsearch.Version;, +            return new SourceFieldMapper(enabled, includes, excludes, context.indexSettings());, +                } else if ("format".equals(fieldName) && parserContext.indexVersionCreated().before(Version.V_3_0_0)) {, +                    // ignore on old indices, reject on and after 3.0, +        this(Defaults.ENABLED, null, null, indexSettings);, +    private SourceFieldMapper(boolean enabled, String[] includes, String[] excludes, Settings indexSettings) {, +            XContentType contentType = mapTuple.v1();, +++ b/core/src/test/java/org/elasticsearch/index/mapper/source/DefaultSourceMappingTests.java, +import org.elasticsearch.test.VersionUtils;, +    public void testFormatBackCompat() throws Exception {, +        Settings settings = Settings.builder(), +                .put(IndexMetaData.SETTING_VERSION_CREATED, VersionUtils.randomVersionBetween(random(), Version.V_2_0_0, Version.V_2_2_0)), +                .build();, +        DocumentMapperParser parser = createIndex("test", settings).mapperService().documentMapperParser();, +        parser.parse(mapping); // no exception, +++ b/docs/reference/migration/migrate_3_0.asciidoc, +==== `_source`'s `format` option, +, +The `_source` mapping does not support the `format` option anymore. This option, +will still be accepted for indices created before the upgrade to 3.0 for backward, +compatibility, but it will have no effect. Indices created on or after 3.0 will, +reject this option., +]