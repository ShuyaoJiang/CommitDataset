[+++ b/docs/painless/painless-casting.asciidoc, +the target type and forcefully occurs as its own operation.  Use the `cast, +operator '()'` to specify an explicit cast., +, +Refer to the <<allowed-casts, cast table>> for a quick reference on all, +allowed casts., +, +    store `int 5` to `i`, +    store `Map reference` to `m`, +    load from `m` -> `Map reference`;, +    store `HashMap reference` to `hm`, +    store `int 1` to `a`, +    load from `a` -> `int 1`;, +    store `long 1` to `b`, +    load from `b` -> `long 1`;, +    store `short 1` value to `c`, +    load from `a` -> `int 1`;, +    store `double 1.0` to `e`;, +    store `int 2` to `b`, +    load from `b` -> `int 2`;, +    store default value `null` to `x`, +    store `ArrayList reference` to `y`;, +<3> load from `y` -> `ArrayList reference`;, +    store `List reference` to `x`;, +<4> load from `x` -> `List reference`;, +    store `ArrayList reference` to `y`;, +<5> load from `y` -> `ArrayList reference`;, +    store `List reference` to `x`;, +    store `List reference` to `x`, +    load from `x` -> `List reference`;, +    load from `x` -> `List reference`;, +    (note no cast is valid since neither `List` nor `Map` is a descendant of the, +            other), +    store `int 3` to `d0`, +    store `def` to `d0`, +    store `Object reference` to `o`, +    load from `o` -> `Object reference`;, +    store `def` to `d1`, +    load from `d1` -> `def`;, +    store `int 0` to `i`;, +    store `def` to `d`, +    load from `d` -> `def`;, +    store `int 1` to `i`;, +    (note the explicit cast is necessary since a `double` type value is not, +            converted to an `int` type value implicitly), +<3> store `int 1` to `d`;, +    load from `d` -> `def`;, +    store `float 1.0` to `f`, +    store `ArrayList reference` to `d`;, +    load from `d` -> `def`;, +    store `List reference` to `l`, +    store `def` to `d`, +    load from `d` -> `def`;, +    store `def` to `d`, +    load from `d` -> `def`;, +    (note no cast is valid since neither `HashMap` nor `List` is a descendant of, +            the other), +Use the cast operator to convert a <<string-type, `String` type>> value into a, +<1> char c = (char)"C";, +<2> c = (char)'c';, +    store `char C` to `c`, +    store `char c` to `c`, +* Casting a `String` reference into a `char` type value., +    store `String "s"` to `s`;, +    load from `s` -> `String "s"`;, +    store `char s` to `c`, +* Conversions between a `def` type and a primitive type are implicitly, +* Method/function call arguments are implicitly boxed/unboxed as necessary., +* A primitive type value is implicitly boxed when a reference type method, +  is called on it., +    store `ArrayList reference` to `l`;, +<2> load from `l` -> `List reference`;, +    store `Integer 0` to `I`;, +    load from `I` -> `Integer 0`;, +    load from `l` -> `List reference`;, +    store `int 1` to `i`;, +value promoted to a `def` type at compile-time is promoted again at run-time, +based on the type the `def` value represents., +    promote `int 2` and `double 2.0 @0`: result `double`;, +    store `double 4.0` to `d`, +    store `def` to `x`;, +    load from `x` -> `def`;, +    promote `int 1` and `float 2.0`: result `float`;, +    store `float 3.0` to `f`;, +, +[[allowed-casts]], +==== Allowed Casts, +, +The following tables show all allowed casts. Read the tables row by row, where, +the original type is shown in the first column, and each subsequent column, +indicates whether a cast to the specified target type is implicit (I), explicit, +(E), or is not allowed (-)., +, +*Primitive/Reference Types*, +, +[cols="<3,^1,^1,^1,^1,^1,^1,^1,^1,^1,^1,^1,^1,^1,^1,^1,^1,^1,^1,^1"], +|====, +|                  | o | b | s | c | i | j | f | d | O | B | S | C | I | L | F | D | T | R | def, +| boolean   ( o )  |   | - | - | - | - | - | - | - | - | - | - | - | - | - | - | - | - | - | I, +| byte      ( b )  | - |   | I | I | I | I | I | I | - | - | - | - | - | - | - | - | - | - | I]