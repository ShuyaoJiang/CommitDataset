[+++ b/src/main/java/org/elasticsearch/transport/local/LocalTransport.java, +    public static final String TRANSPORT_LOCAL_ADDRESS = "transport.local_address";, +, +        String address = settings.get(TRANSPORT_LOCAL_ADDRESS);, +        if (address == null) {, +            address = Long.toString(transportAddressIdGenerator.incrementAndGet());, +        }, +        localAddress = new LocalTransportAddress(address);, +        LocalTransport previous = transports.put(localAddress, this);, +        if (previous != null) {, +            throw new ElasticsearchException("local address [" + address + "] is already bound");, +        }, +++ b/src/main/java/org/elasticsearch/transport/local/LocalTransport.java, +    public static final String TRANSPORT_LOCAL_ADDRESS = "transport.local_address";, +, +        String address = settings.get(TRANSPORT_LOCAL_ADDRESS);, +        if (address == null) {, +            address = Long.toString(transportAddressIdGenerator.incrementAndGet());, +        }, +        localAddress = new LocalTransportAddress(address);, +        LocalTransport previous = transports.put(localAddress, this);, +        if (previous != null) {, +            throw new ElasticsearchException("local address [" + address + "] is already bound");, +        }, +++ b/src/test/java/org/elasticsearch/discovery/ZenUnicastDiscoveryTests.java, +import org.elasticsearch.transport.local.LocalTransport;, +import org.junit.Before;, +import java.util.List;, +import java.util.concurrent.ExecutionException;, +, +@ClusterScope(scope = Scope.TEST, numDataNodes = 0), +    private static int currentNumNodes = -1;, +, +    static int currentBaseHttpPort = -1;, +    static int currentNumOfUnicastHosts = -1;, +, +    @Before, +    public void setUP() throws Exception {, +        ElasticsearchIntegrationTest.beforeClass();, +        currentNumNodes = randomIntBetween(3, 5);, +        currentNumOfUnicastHosts = randomIntBetween(1, currentNumNodes);, +        currentBaseHttpPort = 25000 + randomInt(100);, +    }, +, +        ImmutableSettings.Builder builder = ImmutableSettings.settingsBuilder(), +                .put("discovery.type", "zen"), +                .put("http.enabled", false) // just to make test quicker, +                .put(super.nodeSettings(nodeOrdinal));, +, +        String[] unicastHosts = new String[currentNumOfUnicastHosts];, +        if (internalCluster().getDefaultSettings().get("node.mode").equals("local")) {, +            builder.put(LocalTransport.TRANSPORT_LOCAL_ADDRESS, "unicast_test_" + nodeOrdinal);, +            for (int i = 0; i < unicastHosts.length; i++) {, +                unicastHosts[i] = "unicast_test_" + i;, +            }, +        } else {, +            // we need to pin the node ports so we'd know where to point things, +            builder.put("transport.tcp.port", currentBaseHttpPort + nodeOrdinal);, +            for (int i = 0; i < unicastHosts.length; i++) {, +                unicastHosts[i] = "localhost:" + (currentBaseHttpPort + i);, +            }, +        }, +        builder.putArray("discovery.zen.ping.unicast.hosts", unicastHosts);, +        return builder.build();, +    public void testNormalClusterForming() throws ExecutionException, InterruptedException {, +        internalCluster().startNodesAsync(currentNumNodes).get();, +, +        if (client().admin().cluster().prepareHealth().setWaitForNodes("" + currentNumNodes).get().isTimedOut()) {, +            logger.info("cluster forming timed out, cluster state:\n{}", client().admin().cluster().prepareState().get().getState().prettyPrint());, +            fail("timed out waiting for cluster to form with [" + currentNumNodes + "] nodes");, +, +    @Test, +    // Without the 'include temporalResponses responses to nodesToConnect' improvement in UnicastZenPing#sendPings this, +    // test fails, because 2 nodes elect themselves as master and the health request times out b/c waiting_for_nodes=N, +    // can't be satisfied., +    public void testMinimumMasterNodes() throws Exception {, +        final Settings settings = ImmutableSettings.settingsBuilder().put("discovery.zen.minimum_master_nodes", currentNumNodes / 2 + 1).build();, +, +        List<String> nodes = internalCluster().startNodesAsync(currentNumNodes, settings).get();, +, +        ensureGreen();, +, +        DiscoveryNode masterDiscoNode = null;, +        for (String node : nodes) {, +            ClusterState state = internalCluster().client(node).admin().cluster().prepareState().setLocal(true).execute().actionGet().getState();, +            assertThat(state.nodes().size(), equalTo(currentNumNodes));, +            if (masterDiscoNode == null) {, +                masterDiscoNode = state.nodes().masterNode();, +            } else {, +                assertThat(masterDiscoNode.equals(state.nodes().masterNode()), equalTo(true));, +            }, +++ b/src/main/java/org/elasticsearch/transport/local/LocalTransport.java, +    public static final String TRANSPORT_LOCAL_ADDRESS = "transport.local_address";, +, +        String address = settings.get(TRANSPORT_LOCAL_ADDRESS);, +        if (address == null) {, +            address = Long.toString(transportAddressIdGenerator.incrementAndGet());, +        }, +        localAddress = new LocalTransportAddress(address);, +        LocalTransport previous = transports.put(localAddress, this);]