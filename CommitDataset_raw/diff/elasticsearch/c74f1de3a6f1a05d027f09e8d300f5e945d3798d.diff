[+++ b/src/main/java/org/elasticsearch/discovery/zen/ZenDiscovery.java, +        final int prevMinimumMasterNode = ZenDiscovery.this.electMaster.minimumMasterNodes();, +        ZenDiscovery.this.electMaster.minimumMasterNodes(minimumMasterNodes);, +            // We only set the new value. If the master doesn't see enough nodes it will revoke it's mastership., +++ b/src/main/java/org/elasticsearch/discovery/zen/ZenDiscovery.java, +        final int prevMinimumMasterNode = ZenDiscovery.this.electMaster.minimumMasterNodes();, +        ZenDiscovery.this.electMaster.minimumMasterNodes(minimumMasterNodes);, +            // We only set the new value. If the master doesn't see enough nodes it will revoke it's mastership., +++ b/src/test/java/org/elasticsearch/cluster/MinimumMasterNodesTests.java, +        assertNoMasterBlockOnAllNodes();, +, +    @Test, +    public void dynamicUpdateMinimumMasterNodes() throws InterruptedException {, +        Settings settings = settingsBuilder(), +                .put("discovery.type", "zen"), +                .put("discovery.zen.ping_timeout", "200ms"), +                .put("discovery.initial_state_timeout", "500ms"), +                .put("gateway.type", "local"), +                .build();, +, +        logger.info("--> start 2 nodes");, +        cluster().startNode(settings);, +        cluster().startNode(settings);, +, +        // wait until second node join the cluster, +        ClusterHealthResponse clusterHealthResponse = client().admin().cluster().prepareHealth().setWaitForEvents(Priority.LANGUID).setWaitForNodes("2").get();, +        assertThat(clusterHealthResponse.isTimedOut(), equalTo(false));, +, +        logger.info("--> setting minimum master node to 2");, +        setMinimumMasterNodes(2);, +, +        // make sure it has been processed on all nodes (master node spawns a secondary cluster state update task), +        for (Client client : cluster()) {, +            assertThat(client.admin().cluster().prepareHealth().setWaitForEvents(Priority.LANGUID).setLocal(true).get().isTimedOut(),, +                    equalTo(false));, +        }, +, +        logger.info("--> stopping a node");, +        cluster().stopRandomNode();, +        logger.info("--> verifying min master node has effect");, +        assertNoMasterBlockOnAllNodes();, +, +        logger.info("--> bringing another node up");, +        cluster().startNode(settings);, +        clusterHealthResponse = client().admin().cluster().prepareHealth().setWaitForEvents(Priority.LANGUID).setWaitForNodes("2").get();, +        assertThat(clusterHealthResponse.isTimedOut(), equalTo(false));, +    }, +, +    private void assertNoMasterBlockOnAllNodes() throws InterruptedException {, +        assertThat(awaitBusy(new Predicate<Object>() {, +            public boolean apply(Object obj) {, +                boolean success = true;, +                for (Client client : cluster()) {, +                    ClusterState state = client.admin().cluster().prepareState().setLocal(true).execute().actionGet().getState();, +                    success &= state.blocks().hasGlobalBlock(Discovery.NO_MASTER_BLOCK);, +                    if (logger.isDebugEnabled()) {, +                        logger.debug("Checking for NO_MASTER_BLOCK on client: {} NO_MASTER_BLOCK: [{}]", client, state.blocks().hasGlobalBlock(Discovery.NO_MASTER_BLOCK));, +                    }, +                }, +                return success;, +            }, +        }, 20, TimeUnit.SECONDS), equalTo(true));, +    }]