[+++ b/plugin/src/main/java/org/elasticsearch/xpack/ml/MachineLearning.java, +import org.elasticsearch.xpack.ml.action.FinalizeJobExecutionAction;, +                new ActionHandler<>(FinalizeJobExecutionAction.INSTANCE, FinalizeJobExecutionAction.TransportAction.class),, +++ b/plugin/src/main/java/org/elasticsearch/xpack/ml/MachineLearning.java, +import org.elasticsearch.xpack.ml.action.FinalizeJobExecutionAction;, +                new ActionHandler<>(FinalizeJobExecutionAction.INSTANCE, FinalizeJobExecutionAction.TransportAction.class),, +++ b/plugin/src/main/java/org/elasticsearch/xpack/ml/MlMetadata.java, +                throw ExceptionsHelper.conflictStatusException("Cannot delete job [" + jobId + "] because datafeed [", +            PersistentTask<?> jobTask = getJobTask(jobId, tasks);, +            if (jobTask != null) {, +                throw ExceptionsHelper.conflictStatusException("Cannot delete job [" + jobId + "] because the job hasn't been closed");, +++ b/plugin/src/main/java/org/elasticsearch/xpack/ml/MachineLearning.java, +import org.elasticsearch.xpack.ml.action.FinalizeJobExecutionAction;, +                new ActionHandler<>(FinalizeJobExecutionAction.INSTANCE, FinalizeJobExecutionAction.TransportAction.class),, +++ b/plugin/src/main/java/org/elasticsearch/xpack/ml/MlMetadata.java, +                throw ExceptionsHelper.conflictStatusException("Cannot delete job [" + jobId + "] because datafeed [", +            PersistentTask<?> jobTask = getJobTask(jobId, tasks);, +            if (jobTask != null) {, +                throw ExceptionsHelper.conflictStatusException("Cannot delete job [" + jobId + "] because the job hasn't been closed");, +++ b/plugin/src/main/java/org/elasticsearch/xpack/ml/action/CloseJobAction.java, +import org.elasticsearch.action.support.tasks.BaseTasksResponse;, +import org.elasticsearch.common.io.stream.Writeable;, +import org.elasticsearch.tasks.Task;, +import org.elasticsearch.xpack.ml.job.process.autodetect.AutodetectProcessManager;, +import org.elasticsearch.xpack.ml.utils.JobStateObserver;, +import org.elasticsearch.xpack.security.InternalClient;, +    public static class Request extends TransportJobTaskAction.JobTaskRequest<Request> implements ToXContent {, +                    request.setCloseTimeout(TimeValue.parseTimeValue(val, TIMEOUT.getPreferredName())), TIMEOUT);, +            super(jobId);, +        public TimeValue getCloseTimeout() {, +        public void setCloseTimeout(TimeValue timeout) {, +            builder.field(FORCE.getPreferredName(), force);, +            return Objects.hash(jobId, timeout, force);, +    public static class Response extends BaseTasksResponse implements Writeable, ToXContentObject {, +        Response(StreamInput in) throws IOException {, +            readFrom(in);, +        }, +, +            super(null, null);, +    public static class TransportAction extends TransportJobTaskAction<OpenJobAction.JobTask, Request, Response> {, +        private final InternalClient client;, +                               ClusterService clusterService, AutodetectProcessManager manager, Client client) {, +            super(settings, CloseJobAction.NAME, threadPool, clusterService, transportService, actionFilters,, +                    indexNameExpressionResolver, Request::new, Response::new, ThreadPool.Names.MANAGEMENT, manager);, +            this.client = new InternalClient(settings, threadPool, client);, +        protected void doExecute(Task task, Request request, ActionListener<Response> listener) {, +                forceCloseJob(request.getJobId(), listener);, +                ActionListener<Response> finalListener =, +                        ActionListener.wrap(r -> waitForJobClosed(request, r, listener), listener::onFailure);, +                super.doExecute(task, request, finalListener);, +        protected void innerTaskOperation(Request request, OpenJobAction.JobTask task, ActionListener<Response> listener,, +                                          ClusterState state) {, +            validate(request.getJobId(), state);, +            task.closeJob("close job (api)");, +            listener.onResponse(new Response(true));, +        protected Response readTaskResponse(StreamInput in) throws IOException {, +            return new Response(in);, +        private void forceCloseJob(String jobId, ActionListener<Response> listener) {, +            ClusterState currentState = clusterService.state();, +        // Wait for job to be marked as closed in cluster state, which means the job persistent task has been removed, +        // This api returns when job has been closed, but that doesn't mean the persistent task has been removed from cluster state,, +        // so wait for that to happen here., +        void waitForJobClosed(Request request, Response response, ActionListener<Response> listener) {, +            JobStateObserver observer = new JobStateObserver(threadPool, clusterService);, +            observer.waitForState(request.getJobId(), request.getCloseTimeout(), JobState.CLOSED, e -> {, +                if (e != null) {, +                    listener.onFailure(e);, +                } else {, +                    FinalizeJobExecutionAction.Request finalizeRequest =, +                            new FinalizeJobExecutionAction.Request(request.getJobId());, +                    client.execute(FinalizeJobExecutionAction.INSTANCE, finalizeRequest,, +                            ActionListener.wrap(r-> listener.onResponse(response), listener::onFailure));, +                }, +            });, +    }, +, +    static void validate(String jobId, ClusterState state) {, +++ b/plugin/src/main/java/org/elasticsearch/xpack/ml/MachineLearning.java, +import org.elasticsearch.xpack.ml.action.FinalizeJobExecutionAction;, +                new ActionHandler<>(FinalizeJobExecutionAction.INSTANCE, FinalizeJobExecutionAction.TransportAction.class),, +++ b/plugin/src/main/java/org/elasticsearch/xpack/ml/MlMetadata.java, +                throw ExceptionsHelper.conflictStatusException("Cannot delete job [" + jobId + "] because datafeed [", +            PersistentTask<?> jobTask = getJobTask(jobId, tasks);, +            if (jobTask != null) {, +                throw ExceptionsHelper.conflictStatusException("Cannot delete job [" + jobId + "] because the job hasn't been closed");, +++ b/plugin/src/main/java/org/elasticsearch/xpack/ml/action/CloseJobAction.java, +import org.elasticsearch.action.support.tasks.BaseTasksResponse;, +import org.elasticsearch.common.io.stream.Writeable;, +import org.elasticsearch.tasks.Task;, +import org.elasticsearch.xpack.ml.job.process.autodetect.AutodetectProcessManager;, +import org.elasticsearch.xpack.ml.utils.JobStateObserver;, +import org.elasticsearch.xpack.security.InternalClient;, +    public static class Request extends TransportJobTaskAction.JobTaskRequest<Request> implements ToXContent {, +                    request.setCloseTimeout(TimeValue.parseTimeValue(val, TIMEOUT.getPreferredName())), TIMEOUT);, +            super(jobId);, +        public TimeValue getCloseTimeout() {, +        public void setCloseTimeout(TimeValue timeout) {, +            builder.field(FORCE.getPreferredName(), force);, +            return Objects.hash(jobId, timeout, force);, +    public static class Response extends BaseTasksResponse implements Writeable, ToXContentObject {]