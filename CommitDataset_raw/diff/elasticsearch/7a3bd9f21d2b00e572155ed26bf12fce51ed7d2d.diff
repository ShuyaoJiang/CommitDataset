[+++ b/server/src/main/java/org/elasticsearch/action/search/AbstractSearchAsyncAction.java, +                Transport.Connection connection = getConnection(searchShardTarget.getClusterAlias(), searchShardTarget.getNodeId());, +++ b/server/src/main/java/org/elasticsearch/action/search/AbstractSearchAsyncAction.java, +                Transport.Connection connection = getConnection(searchShardTarget.getClusterAlias(), searchShardTarget.getNodeId());, +++ b/server/src/test/java/org/elasticsearch/action/search/AbstractSearchAsyncActionTests.java, +import org.elasticsearch.action.ActionListener;, +import org.elasticsearch.common.collect.Tuple;, +import org.elasticsearch.search.SearchShardTarget;, +import org.elasticsearch.search.internal.InternalSearchResponse;, +import org.elasticsearch.transport.Transport;, +import java.util.ArrayList;, +import java.util.HashSet;, +import java.util.List;, +import java.util.Set;, +import java.util.concurrent.CopyOnWriteArraySet;, +import java.util.concurrent.atomic.AtomicReference;, +import java.util.function.BiFunction;, +import static org.hamcrest.Matchers.instanceOf;, +    private final List<Tuple<String, String>> resolvedNodes = new ArrayList<>();, +    private final Set<Long> releasedContexts = new CopyOnWriteArraySet<>();, +, +    private AbstractSearchAsyncAction<SearchPhaseResult> createAction(SearchRequest request,, +                                                                      InitialSearchPhase.ArraySearchPhaseResults<SearchPhaseResult> results,, +                                                                      ActionListener<SearchResponse> listener,, +        BiFunction<String, String, Transport.Connection> nodeIdToConnection = (cluster, node) -> {, +            resolvedNodes.add(Tuple.tuple(cluster, node));, +            return null;, +        };, +, +        return new AbstractSearchAsyncAction<SearchPhaseResult>("test", null, null, nodeIdToConnection,, +                Collections.singletonMap("name", Sets.newHashSet("bar", "baz")), null, request, listener,, +                results, request.getMaxConcurrentShardRequests(),, +, +            @Override, +            public void sendReleaseSearchContext(long contextId, Transport.Connection connection, OriginalIndices originalIndices) {, +                releasedContexts.add(contextId);, +            }, +        AbstractSearchAsyncAction<SearchPhaseResult> action = createAction(new SearchRequest(),, +            new InitialSearchPhase.ArraySearchPhaseResults<>(10), null, controlled, expected);, +        SearchRequest searchRequest = new SearchRequest().allowPartialSearchResults(randomBoolean()).preference("_shards:1,3");, +        AbstractSearchAsyncAction<SearchPhaseResult> action = createAction(searchRequest,, +            new InitialSearchPhase.ArraySearchPhaseResults<>(10), null, false, expected);, +, +    public void testBuildSearchResponse() {, +        SearchRequest searchRequest = new SearchRequest().allowPartialSearchResults(randomBoolean());, +        AbstractSearchAsyncAction<SearchPhaseResult> action = createAction(searchRequest,, +            new InitialSearchPhase.ArraySearchPhaseResults<>(10), null, false, new AtomicLong());, +        String scrollId = randomBoolean() ? null : randomAlphaOfLengthBetween(5, 10);, +        InternalSearchResponse internalSearchResponse = InternalSearchResponse.empty();, +        SearchResponse searchResponse = action.buildSearchResponse(internalSearchResponse, scrollId);, +        assertEquals(scrollId, searchResponse.getScrollId());, +        assertSame(searchResponse.getAggregations(), internalSearchResponse.aggregations());, +        assertSame(searchResponse.getSuggest(), internalSearchResponse.suggest());, +        assertSame(searchResponse.getProfileResults(), internalSearchResponse.profile());, +        assertSame(searchResponse.getHits(), internalSearchResponse.hits());, +    }, +, +    public void testBuildSearchResponseAllowPartialFailures() {, +        SearchRequest searchRequest = new SearchRequest().allowPartialSearchResults(true);, +        AbstractSearchAsyncAction<SearchPhaseResult> action = createAction(searchRequest,, +            new InitialSearchPhase.ArraySearchPhaseResults<>(10), null, false, new AtomicLong());, +        action.onShardFailure(0, new SearchShardTarget("node", new ShardId("index", "index-uuid", 0), null, OriginalIndices.NONE),, +            new IllegalArgumentException());, +        String scrollId = randomBoolean() ? null : randomAlphaOfLengthBetween(5, 10);, +        InternalSearchResponse internalSearchResponse = InternalSearchResponse.empty();, +        SearchResponse searchResponse = action.buildSearchResponse(internalSearchResponse, scrollId);, +        assertEquals(scrollId, searchResponse.getScrollId());, +        assertSame(searchResponse.getAggregations(), internalSearchResponse.aggregations());, +        assertSame(searchResponse.getSuggest(), internalSearchResponse.suggest());, +        assertSame(searchResponse.getProfileResults(), internalSearchResponse.profile());, +        assertSame(searchResponse.getHits(), internalSearchResponse.hits());, +    }, +, +    public void testBuildSearchResponseDisallowPartialFailures() {, +        SearchRequest searchRequest = new SearchRequest().allowPartialSearchResults(false);, +        AtomicReference<Exception> exception = new AtomicReference<>();, +        ActionListener<SearchResponse> listener = ActionListener.wrap(response -> fail("onResponse should not be called"), exception::set);, +        Set<Long> requestIds = new HashSet<>();, +        List<Tuple<String, String>> nodeLookups = new ArrayList<>();, +        int numFailures = randomIntBetween(1, 5);, +        InitialSearchPhase.ArraySearchPhaseResults<SearchPhaseResult> phaseResults = phaseResults(requestIds, nodeLookups, numFailures);, +        AbstractSearchAsyncAction<SearchPhaseResult> action = createAction(searchRequest, phaseResults, listener, false, new AtomicLong());, +        for (int i = 0; i < numFailures; i++) {, +            ShardId failureShardId = new ShardId("index", "index-uuid", i);, +            String failureClusterAlias = randomBoolean() ? null : randomAlphaOfLengthBetween(5, 10);, +            String failureNodeId = randomAlphaOfLengthBetween(5, 10);, +            action.onShardFailure(i, new SearchShardTarget(failureNodeId, failureShardId, failureClusterAlias, OriginalIndices.NONE),, +                new IllegalArgumentException());, +        }, +        action.buildSearchResponse(InternalSearchResponse.empty(), randomBoolean() ? null : randomAlphaOfLengthBetween(5, 10));, +        assertThat(exception.get(), instanceOf(SearchPhaseExecutionException.class));, +        SearchPhaseExecutionException searchPhaseExecutionException = (SearchPhaseExecutionException)exception.get();, +        assertEquals(0, searchPhaseExecutionException.getSuppressed().length);, +        assertEquals(numFailures, searchPhaseExecutionException.shardFailures().length);, +        for (ShardSearchFailure shardSearchFailure : searchPhaseExecutionException.shardFailures()) {, +            assertThat(shardSearchFailure.getCause(), instanceOf(IllegalArgumentException.class));, +        }, +        assertEquals(nodeLookups, resolvedNodes);, +        assertEquals(requestIds, releasedContexts);, +    }]