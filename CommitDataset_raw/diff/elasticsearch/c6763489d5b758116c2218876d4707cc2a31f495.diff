[+++ b/elasticsearch/src/main/java/org/elasticsearch/xpack/ml/MlPlugin.java, +import org.elasticsearch.cluster.routing.UnassignedInfo;, +import org.elasticsearch.common.unit.TimeValue;, +import org.elasticsearch.tasks.Task;, +import org.elasticsearch.xpack.ml.job.config.JobState;, +                new NamedWriteableRegistry.Entry(Task.Status.class, PersistentActionCoordinator.Status.NAME,, +                        PersistentActionCoordinator.Status::new),, +                new NamedWriteableRegistry.Entry(PersistentActionRequest.class, StartDatafeedAction.NAME, StartDatafeedAction.Request::new),, +                new NamedWriteableRegistry.Entry(PersistentActionRequest.class, OpenJobAction.NAME, OpenJobAction.Request::new),, +                new NamedWriteableRegistry.Entry(Task.Status.class, JobState.NAME, JobState::fromStream), +        // Whether we are using native process is a good way to detect whether we are in dev / test mode:, +        TimeValue delayedNodeTimeOutSetting;, +        if (USE_NATIVE_PROCESS_OPTION.get(settings)) {, +            delayedNodeTimeOutSetting = UnassignedInfo.INDEX_DELAYED_NODE_LEFT_TIMEOUT_SETTING.get(settings);, +        } else {, +            delayedNodeTimeOutSetting = TimeValue.timeValueNanos(0);, +        }, +        JobProvider jobProvider = new JobProvider(client, 1, delayedNodeTimeOutSetting);, +        PersistentActionService persistentActionService = new PersistentActionService(Settings.EMPTY, threadPool, clusterService, client);, +++ b/elasticsearch/src/main/java/org/elasticsearch/xpack/ml/MlPlugin.java, +import org.elasticsearch.cluster.routing.UnassignedInfo;, +import org.elasticsearch.common.unit.TimeValue;, +import org.elasticsearch.tasks.Task;, +import org.elasticsearch.xpack.ml.job.config.JobState;, +                new NamedWriteableRegistry.Entry(Task.Status.class, PersistentActionCoordinator.Status.NAME,, +                        PersistentActionCoordinator.Status::new),, +                new NamedWriteableRegistry.Entry(PersistentActionRequest.class, StartDatafeedAction.NAME, StartDatafeedAction.Request::new),, +                new NamedWriteableRegistry.Entry(PersistentActionRequest.class, OpenJobAction.NAME, OpenJobAction.Request::new),, +                new NamedWriteableRegistry.Entry(Task.Status.class, JobState.NAME, JobState::fromStream), +        // Whether we are using native process is a good way to detect whether we are in dev / test mode:, +        TimeValue delayedNodeTimeOutSetting;, +        if (USE_NATIVE_PROCESS_OPTION.get(settings)) {, +            delayedNodeTimeOutSetting = UnassignedInfo.INDEX_DELAYED_NODE_LEFT_TIMEOUT_SETTING.get(settings);, +        } else {, +            delayedNodeTimeOutSetting = TimeValue.timeValueNanos(0);, +        }, +        JobProvider jobProvider = new JobProvider(client, 1, delayedNodeTimeOutSetting);, +        PersistentActionService persistentActionService = new PersistentActionService(Settings.EMPTY, threadPool, clusterService, client);, +++ b/elasticsearch/src/main/java/org/elasticsearch/xpack/ml/action/CloseJobAction.java, +import org.elasticsearch.action.support.master.MasterNodeRequest;, +import org.elasticsearch.action.support.master.TransportMasterNodeAction;, +import org.elasticsearch.cluster.ClusterState;, +import org.elasticsearch.cluster.ClusterStateUpdateTask;, +import org.elasticsearch.cluster.block.ClusterBlockException;, +import org.elasticsearch.cluster.block.ClusterBlockLevel;, +import org.elasticsearch.cluster.metadata.MetaData;, +import org.elasticsearch.common.ParseField;, +import org.elasticsearch.common.xcontent.ObjectParser;, +import org.elasticsearch.common.xcontent.ToXContent;, +import org.elasticsearch.common.xcontent.XContentParser;, +import org.elasticsearch.xpack.persistent.PersistentTaskClusterService;, +import org.elasticsearch.xpack.persistent.PersistentTasksInProgress;, +import org.elasticsearch.xpack.persistent.PersistentTasksInProgress.PersistentTaskInProgress;, +import java.util.Date;, +import java.util.HashMap;, +import java.util.Map;, +import java.util.function.Predicate;, +    public static class Request extends MasterNodeRequest<Request> implements ToXContent {, +, +        public static final ParseField TIMEOUT = new ParseField("timeout");, +        public static ObjectParser<Request, Void> PARSER = new ObjectParser<>(NAME, Request::new);, +, +        static {, +            PARSER.declareString(Request::setJobId, Job.ID);, +            PARSER.declareString((request, val) ->, +                    request.setTimeout(TimeValue.parseTimeValue(val, TIMEOUT.getPreferredName())), TIMEOUT);, +        }, +, +        public static Request parseRequest(String jobId, XContentParser parser) {, +            Request request = PARSER.apply(parser, null);, +            if (jobId != null) {, +                request.jobId = jobId;, +            }, +            return request;, +        }, +        private TimeValue timeout = TimeValue.timeValueMinutes(20);, +        public void setJobId(String jobId) {, +            this.jobId = jobId;, +        public TimeValue getTimeout() {, +            return timeout;, +        }, +, +        public void setTimeout(TimeValue timeout) {, +            this.timeout = timeout;, +            timeout = new TimeValue(in);, +            timeout.writeTo(out);, +        }, +, +        @Override, +        public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {, +            builder.startObject();, +            builder.field(Job.ID.getPreferredName(), jobId);, +            builder.field(TIMEOUT.getPreferredName(), timeout.getStringRep());, +            builder.endObject();, +            return builder;, +            return Objects.hash(jobId, timeout);, +                    Objects.equals(timeout, other.timeout);, +    public static class TransportAction extends TransportMasterNodeAction<Request, Response> {, +        private final PersistentTaskClusterService persistentTaskClusterService;, +                               ClusterService clusterService, TransportListTasksAction listTasksAction,]