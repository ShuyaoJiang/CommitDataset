[+++ b/test/framework/src/main/java/org/elasticsearch/index/replication/ESIndexLevelReplicationTestCase.java, +        public synchronized void reinitPrimaryShard() throws IOException {, +            primary = reinitShard(primary);, +        }, +, +++ b/test/framework/src/main/java/org/elasticsearch/index/replication/ESIndexLevelReplicationTestCase.java, +        public synchronized void reinitPrimaryShard() throws IOException {, +            primary = reinitShard(primary);, +        }, +, +++ b/x-pack/plugin/ccr/qa/multi-cluster-with-security/src/test/java/org/elasticsearch/xpack/ccr/FollowIndexSecurityIT.java, +            assertThat(e.getMessage(), containsString("action [indices:monitor/stats] is unauthorized for user [test_ccr]"));, +++ b/test/framework/src/main/java/org/elasticsearch/index/replication/ESIndexLevelReplicationTestCase.java, +        public synchronized void reinitPrimaryShard() throws IOException {, +            primary = reinitShard(primary);, +        }, +, +++ b/x-pack/plugin/ccr/qa/multi-cluster-with-security/src/test/java/org/elasticsearch/xpack/ccr/FollowIndexSecurityIT.java, +            assertThat(e.getMessage(), containsString("action [indices:monitor/stats] is unauthorized for user [test_ccr]"));, +++ b/x-pack/plugin/ccr/src/main/java/org/elasticsearch/xpack/ccr/Ccr.java, +    public static final String CCR_CUSTOM_METADATA_KEY = "ccr";, +    public static final String CCR_CUSTOM_METADATA_LEADER_INDEX_SHARD_HISTORY_UUIDS = "leader_index_shard_history_uuids";, +++ b/test/framework/src/main/java/org/elasticsearch/index/replication/ESIndexLevelReplicationTestCase.java, +        public synchronized void reinitPrimaryShard() throws IOException {, +            primary = reinitShard(primary);, +        }, +, +++ b/x-pack/plugin/ccr/qa/multi-cluster-with-security/src/test/java/org/elasticsearch/xpack/ccr/FollowIndexSecurityIT.java, +            assertThat(e.getMessage(), containsString("action [indices:monitor/stats] is unauthorized for user [test_ccr]"));, +++ b/x-pack/plugin/ccr/src/main/java/org/elasticsearch/xpack/ccr/Ccr.java, +    public static final String CCR_CUSTOM_METADATA_KEY = "ccr";, +    public static final String CCR_CUSTOM_METADATA_LEADER_INDEX_SHARD_HISTORY_UUIDS = "leader_index_shard_history_uuids";, +++ b/x-pack/plugin/ccr/src/main/java/org/elasticsearch/xpack/ccr/CcrLicenseChecker.java, +import org.elasticsearch.action.admin.indices.stats.IndexShardStats;, +import org.elasticsearch.action.admin.indices.stats.IndexStats;, +import org.elasticsearch.action.admin.indices.stats.IndicesStatsRequest;, +import org.elasticsearch.action.admin.indices.stats.IndicesStatsResponse;, +import org.elasticsearch.action.admin.indices.stats.ShardStats;, +import org.elasticsearch.common.CheckedConsumer;, +import org.elasticsearch.index.engine.CommitStats;, +import org.elasticsearch.index.engine.Engine;, +import org.elasticsearch.index.shard.ShardId;, +import java.util.function.BiConsumer;, +     * Fetches the leader index metadata and history UUIDs for leader index shards from the remote cluster., +     * Before fetching the index metadata, the remote cluster is checked for license compatibility with CCR., +     * If the remote cluster is not licensed for CCR, the {@code onFailure} consumer is is invoked. Otherwise,, +     * the specified consumer is invoked with the leader index metadata fetched from the remote cluster., +     * @param consumer      the consumer for supplying the leader index metadata and historyUUIDs of all leader shards, +    public <T> void checkRemoteClusterLicenseAndFetchLeaderIndexMetadataAndHistoryUUIDs(, +            final BiConsumer<String[], IndexMetaData> consumer) {, +                leaderClusterState -> {, +                    IndexMetaData leaderIndexMetaData = leaderClusterState.getMetaData().index(leaderIndex);, +                    final Client leaderClient = client.getRemoteClusterClient(clusterAlias);, +                    fetchLeaderHistoryUUIDs(leaderClient, leaderIndexMetaData, onFailure, historyUUIDs -> {, +                        consumer.accept(historyUUIDs, leaderIndexMetaData);, +                    });, +                },, +    /**, +     * Fetches the history UUIDs for leader index on per shard basis using the specified leaderClient., +     *, +     * @param leaderClient                              the leader client, +     * @param leaderIndexMetaData                       the leader index metadata, +     * @param onFailure                                 the failure consumer, +     * @param historyUUIDConsumer                       the leader index history uuid and consumer, +     */, +    // NOTE: Placed this method here; in order to avoid duplication of logic for fetching history UUIDs, +    // in case of following a local or a remote cluster., +    public void fetchLeaderHistoryUUIDs(, +        final Client leaderClient,, +        final IndexMetaData leaderIndexMetaData,, +        final Consumer<Exception> onFailure,, +        final Consumer<String[]> historyUUIDConsumer) {, +, +        String leaderIndex = leaderIndexMetaData.getIndex().getName();, +        CheckedConsumer<IndicesStatsResponse, Exception> indicesStatsHandler = indicesStatsResponse -> {, +            IndexStats indexStats = indicesStatsResponse.getIndices().get(leaderIndex);, +            String[] historyUUIDs = new String[leaderIndexMetaData.getNumberOfShards()];, +            for (IndexShardStats indexShardStats : indexStats) {, +                for (ShardStats shardStats : indexShardStats) {, +                    // Ignore replica shards as they may not have yet started and, +                    // we just end up overwriting slots in historyUUIDs, +                    if (shardStats.getShardRouting().primary() == false) {, +                        continue;, +                    }, +, +                    CommitStats commitStats = shardStats.getCommitStats();, +                    if (commitStats == null) {, +                        onFailure.accept(new IllegalArgumentException("leader index's commit stats are missing"));, +                        return;, +                    }, +                    String historyUUID = commitStats.getUserData().get(Engine.HISTORY_UUID_KEY);, +                    ShardId shardId = shardStats.getShardRouting().shardId();, +                    historyUUIDs[shardId.id()] = historyUUID;, +                }, +            }, +            for (int i = 0; i < historyUUIDs.length; i++) {, +                if (historyUUIDs[i] == null) {, +                    onFailure.accept(new IllegalArgumentException("no history uuid for [" + leaderIndex + "][" + i + "]"));, +                    return;, +                }]