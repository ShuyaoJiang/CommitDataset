[+++ b/server/src/main/java/org/elasticsearch/index/shard/IndexShard.java, +     * @see org.elasticsearch.indices.recovery.RecoveryTarget#indexTranslogOperations(List, int, long, long, ActionListener), +++ b/server/src/main/java/org/elasticsearch/index/shard/IndexShard.java, +     * @see org.elasticsearch.indices.recovery.RecoveryTarget#indexTranslogOperations(List, int, long, long, ActionListener), +++ b/server/src/main/java/org/elasticsearch/indices/recovery/PeerRecoveryTargetService.java, +                final ActionListener<RecoveryTranslogOperationsResponse> listener =, +                    new HandledTransportAction.ChannelActionListener<>(channel, Actions.TRANSLOG_OPS, request);, +                final Consumer<Exception> retryOnMappingException = exception -> {, +                                listener.onFailure(e);, +                            listener.onFailure(new ElasticsearchException(, +                                "cluster service was closed while waiting for mapping updates"));, +                            listener.onFailure(new ElasticsearchTimeoutException("timed out waiting for mapping updates " +, +                                "(timeout [" + timeout + "])"));, +                };, +                recoveryTarget.indexTranslogOperations(request.operations(), request.totalTranslogOps(),, +                    request.maxSeenAutoIdTimestampOnPrimary(), request.maxSeqNoOfUpdatesOrDeletesOnPrimary(),, +                    ActionListener.wrap(, +                        checkpoint -> listener.onResponse(new RecoveryTranslogOperationsResponse(checkpoint)),, +                        e -> {, +                            if (e instanceof MapperException) {, +                                retryOnMappingException.accept(e);, +                            } else {, +                                listener.onFailure(e);, +                        }), +                );, +++ b/server/src/main/java/org/elasticsearch/index/shard/IndexShard.java, +     * @see org.elasticsearch.indices.recovery.RecoveryTarget#indexTranslogOperations(List, int, long, long, ActionListener), +++ b/server/src/main/java/org/elasticsearch/indices/recovery/PeerRecoveryTargetService.java, +                final ActionListener<RecoveryTranslogOperationsResponse> listener =, +                    new HandledTransportAction.ChannelActionListener<>(channel, Actions.TRANSLOG_OPS, request);, +                final Consumer<Exception> retryOnMappingException = exception -> {, +                                listener.onFailure(e);, +                            listener.onFailure(new ElasticsearchException(, +                                "cluster service was closed while waiting for mapping updates"));, +                            listener.onFailure(new ElasticsearchTimeoutException("timed out waiting for mapping updates " +, +                                "(timeout [" + timeout + "])"));, +                };, +                recoveryTarget.indexTranslogOperations(request.operations(), request.totalTranslogOps(),, +                    request.maxSeenAutoIdTimestampOnPrimary(), request.maxSeqNoOfUpdatesOrDeletesOnPrimary(),, +                    ActionListener.wrap(, +                        checkpoint -> listener.onResponse(new RecoveryTranslogOperationsResponse(checkpoint)),, +                        e -> {, +                            if (e instanceof MapperException) {, +                                retryOnMappingException.accept(e);, +                            } else {, +                                listener.onFailure(e);, +                        }), +                );, +++ b/server/src/main/java/org/elasticsearch/indices/recovery/RecoverySourceHandler.java, +import org.elasticsearch.action.support.PlainActionFuture;, +, +            final Translog.Snapshot phase2Snapshot = shard.getHistoryOperations("peer-recovery", startingSeqNo);, +            resources.add(phase2Snapshot);, +            IOUtils.close(retentionLock);, +            final StepListener<SendSnapshotResult> sendSnapshotStep = new StepListener<>();, +            phase2(startingSeqNo, requiredSeqNoRangeStart, endingSeqNo, phase2Snapshot, maxSeenAutoIdTimestamp,, +                maxSeqNoOfUpdatesOrDeletes, sendSnapshotStep);, +            sendSnapshotStep.whenComplete(, +                r -> IOUtils.close(phase2Snapshot),, +                e -> onFailure.accept(new RecoveryEngineException(shard.shardId(), 2, "phase2 failed", e)));, +            sendSnapshotStep.whenComplete(r -> finalizeRecovery(r.targetLocalCheckpoint, finalizeStep), onFailure);, +, +                final SendSnapshotResult sendSnapshotResult = sendSnapshotStep.result();, +     * @param listener                   a listener which will be notified with the local checkpoint on the target., +    void phase2(long startingSeqNo, long requiredSeqNoRangeStart, long endingSeqNo, Translog.Snapshot snapshot, long maxSeenAutoIdTimestamp,, +                long maxSeqNoOfUpdatesOrDeletes, ActionListener<SendSnapshotResult> listener) throws IOException {, +        ActionListener.completeWith(listener, () -> sendSnapshotBlockingly(, +            startingSeqNo, requiredSeqNoRangeStart, endingSeqNo, snapshot, maxSeenAutoIdTimestamp, maxSeqNoOfUpdatesOrDeletes));, +    }, +, +    private SendSnapshotResult sendSnapshotBlockingly(long startingSeqNo, long requiredSeqNoRangeStart, long endingSeqNo,, +                                                      Translog.Snapshot snapshot, long maxSeenAutoIdTimestamp,, +                                                      long maxSeqNoOfUpdatesOrDeletes) throws IOException {, +            // TODO: Make this non-blocking, +            final PlainActionFuture<Long> future = new PlainActionFuture<>();, +            recoveryTarget.indexTranslogOperations(, +                operations, expectedTotalOps, maxSeenAutoIdTimestamp, maxSeqNoOfUpdatesOrDeletes, future);, +            targetLocalCheckpoint.set(future.actionGet());, +++ b/server/src/main/java/org/elasticsearch/index/shard/IndexShard.java, +     * @see org.elasticsearch.indices.recovery.RecoveryTarget#indexTranslogOperations(List, int, long, long, ActionListener), +++ b/server/src/main/java/org/elasticsearch/indices/recovery/PeerRecoveryTargetService.java, +                final ActionListener<RecoveryTranslogOperationsResponse> listener =, +                    new HandledTransportAction.ChannelActionListener<>(channel, Actions.TRANSLOG_OPS, request);, +                final Consumer<Exception> retryOnMappingException = exception -> {, +                                listener.onFailure(e);, +                            listener.onFailure(new ElasticsearchException(, +                                "cluster service was closed while waiting for mapping updates"));, +                            listener.onFailure(new ElasticsearchTimeoutException("timed out waiting for mapping updates " +, +                                "(timeout [" + timeout + "])"));, +                };, +                recoveryTarget.indexTranslogOperations(request.operations(), request.totalTranslogOps(),, +                    request.maxSeenAutoIdTimestampOnPrimary(), request.maxSeqNoOfUpdatesOrDeletesOnPrimary(),, +                    ActionListener.wrap(, +                        checkpoint -> listener.onResponse(new RecoveryTranslogOperationsResponse(checkpoint)),, +                        e -> {, +                            if (e instanceof MapperException) {, +                                retryOnMappingException.accept(e);, +                            } else {, +                                listener.onFailure(e);, +                        })]