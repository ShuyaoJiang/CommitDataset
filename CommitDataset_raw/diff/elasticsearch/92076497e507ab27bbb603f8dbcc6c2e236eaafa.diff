[+++ b/server/src/main/java/org/elasticsearch/transport/ConnectionManager.java, +import java.util.concurrent.atomic.AtomicBoolean;, +    private final AtomicBoolean closed = new AtomicBoolean(false);, +        if (connectionListener.listeners.contains(listener) == false) {, +    }, +    /**, +     * Returns the number of nodes this manager is connected to., +     */, +    public int size() {, +        if (closed.compareAndSet(false, true)) {, +    }, +++ b/server/src/main/java/org/elasticsearch/transport/ConnectionManager.java, +import java.util.concurrent.atomic.AtomicBoolean;, +    private final AtomicBoolean closed = new AtomicBoolean(false);, +        if (connectionListener.listeners.contains(listener) == false) {, +    }, +    /**, +     * Returns the number of nodes this manager is connected to., +     */, +    public int size() {, +        if (closed.compareAndSet(false, true)) {, +    }, +++ b/server/src/main/java/org/elasticsearch/transport/RemoteClusterConnection.java, +import org.elasticsearch.common.io.stream.StreamInput;, +    private final ConnectionManager connectionManager;, +    private final ThreadPool threadPool;, +     * @param connectionManager the connection manager to use for this remote connection, +            TransportService transportService, ConnectionManager connectionManager, int maxNumRemoteConnections,, +                            Predicate<DiscoveryNode> nodePredicate) {, +        this.threadPool = transportService.threadPool;, +        this.connectionManager = connectionManager;, +        connectionManager.addListener(this);, +        // we register the transport service here as a listener to make sure we notify handlers on disconnect etc., +        connectionManager.addListener(transportService);, +        final DiscoveryNode node = getAnyConnectedNode();, +        Transport.Connection connection = connectionManager.getConnection(node);, +        transportService.sendRequest(connection, ClusterSearchShardsAction.NAME, searchShardsRequest, TransportRequestOptions.EMPTY,, +            final DiscoveryNode node = getAnyConnectedNode();, +            Transport.Connection connection = connectionManager.getConnection(node);, +            transportService.sendRequest(connection, ClusterStateAction.NAME, request, TransportRequestOptions.EMPTY,, +, +                    public ClusterStateResponse read(StreamInput in) throws IOException {, +                        ClusterStateResponse response = new ClusterStateResponse();, +                        response.readFrom(in);, +                        return response;, +        if (connectionManager.nodeConnected(remoteClusterNode)) {, +            return connectionManager.getConnection(remoteClusterNode);, +        DiscoveryNode discoveryNode = getAnyConnectedNode();, +        Transport.Connection connection = connectionManager.getConnection(discoveryNode);, +        return connectionManager.getConnection(getAnyConnectedNode());, +        IOUtils.close(connectHandler, connectionManager);, +                ContextPreservingActionListener.wrapPreservingContext(connectListener, threadPool.getThreadContext());, +                    collectRemoteNodes(seedNodes.iterator(), transportService, connectionManager, listener);, +                                final TransportService transportService, final ConnectionManager manager, ActionListener<Void> listener) {, +                        Transport.Connection connection = manager.openConnection(seedNode,, +                                manager.connectToNode(handshakeNode, remoteProfile, transportService.connectionValidator(handshakeNode));, +                    collectRemoteNodes(seedNodes, transportService, manager, listener);, +                                        connectionManager.connectToNode(node, remoteProfile,, +                                            transportService.connectionValidator(node)); // noop if node is connected, +                    collectRemoteNodes(seedNodes, transportService, connectionManager, listener);, +                    collectRemoteNodes(seedNodes, transportService, connectionManager, listener);, +, +    ConnectionManager getConnectionManager() {, +        return connectionManager;, +    }, +++ b/server/src/main/java/org/elasticsearch/transport/ConnectionManager.java, +import java.util.concurrent.atomic.AtomicBoolean;, +    private final AtomicBoolean closed = new AtomicBoolean(false);, +        if (connectionListener.listeners.contains(listener) == false) {, +    }, +    /**, +     * Returns the number of nodes this manager is connected to., +     */, +    public int size() {, +        if (closed.compareAndSet(false, true)) {, +    }, +++ b/server/src/main/java/org/elasticsearch/transport/RemoteClusterConnection.java, +import org.elasticsearch.common.io.stream.StreamInput;, +    private final ConnectionManager connectionManager;, +    private final ThreadPool threadPool;, +     * @param connectionManager the connection manager to use for this remote connection, +            TransportService transportService, ConnectionManager connectionManager, int maxNumRemoteConnections,, +                            Predicate<DiscoveryNode> nodePredicate) {, +        this.threadPool = transportService.threadPool;, +        this.connectionManager = connectionManager;, +        connectionManager.addListener(this);, +        // we register the transport service here as a listener to make sure we notify handlers on disconnect etc., +        connectionManager.addListener(transportService);, +        final DiscoveryNode node = getAnyConnectedNode();, +        Transport.Connection connection = connectionManager.getConnection(node);, +        transportService.sendRequest(connection, ClusterSearchShardsAction.NAME, searchShardsRequest, TransportRequestOptions.EMPTY,, +            final DiscoveryNode node = getAnyConnectedNode();, +            Transport.Connection connection = connectionManager.getConnection(node);, +            transportService.sendRequest(connection, ClusterStateAction.NAME, request, TransportRequestOptions.EMPTY,, +, +                    public ClusterStateResponse read(StreamInput in) throws IOException {, +                        ClusterStateResponse response = new ClusterStateResponse();, +                        response.readFrom(in);, +                        return response;, +        if (connectionManager.nodeConnected(remoteClusterNode)) {]