[+++ b/CONTRIBUTING.md, +### Gradle Build, +, +We use Gradle to build Elasticsearch because it is flexible enough to not only, +build and package Elasticsearch, but also orchestrate all of the ways that we, +have to test Elasticsearch., +, +#### Configurations, +, +Gradle organizes dependencies and build artifacts into "configurations" and, +allows you to use these configurations arbitrarilly. Here are some of the most, +common configurations in our build and how we use them:, +, +<dl>, +<dt>`compile`</dt><dd>Code that is on the classpath at both compile and, +runtime. If the [`shadow`][shadow-plugin] plugin is applied to the project then, +this code is bundled into the jar produced by the project.</dd>, +<dt>`runtime`</dt><dd>Code that is not on the classpath at compile time but is, +on the classpath at runtime. We mostly use this configuration to make sure that, +we do not accidentally compile against dependencies of our dependencies also, +known as "transitive" dependencies".</dd>, +<dt>`compileOnly`</dt><dd>Code that is on the classpath at comile time but that, +should not be shipped with the project because it is "provided" by the runtime, +somehow. Elasticsearch plugins use this configuration to include dependencies, +that are bundled with Elasticsearch's server.</dd>, +<dt>`shadow`</dt><dd>Only available in projects with the shadow plugin. Code, +that is on the classpath at both compile and runtime but it *not* bundled into, +the jar produced by the project. If you depend on a project with the `shadow`, +plugin then you need to depend on this configuration because it will bring, +along all of the dependencies you need at runtime.</dd>, +<dt>`testCompile`</dt><dd>Code that is on the classpath for compiling tests, +that are part of this project but not production code. The canonical example, +of this is `junit`.</dd>, +</dl>, +[shadow-plugin]: https://github.com/johnrengelman/shadow, +++ b/CONTRIBUTING.md, +### Gradle Build, +, +We use Gradle to build Elasticsearch because it is flexible enough to not only, +build and package Elasticsearch, but also orchestrate all of the ways that we, +have to test Elasticsearch., +, +#### Configurations, +, +Gradle organizes dependencies and build artifacts into "configurations" and, +allows you to use these configurations arbitrarilly. Here are some of the most, +common configurations in our build and how we use them:, +, +<dl>, +<dt>`compile`</dt><dd>Code that is on the classpath at both compile and, +runtime. If the [`shadow`][shadow-plugin] plugin is applied to the project then, +this code is bundled into the jar produced by the project.</dd>, +<dt>`runtime`</dt><dd>Code that is not on the classpath at compile time but is, +on the classpath at runtime. We mostly use this configuration to make sure that, +we do not accidentally compile against dependencies of our dependencies also, +known as "transitive" dependencies".</dd>, +<dt>`compileOnly`</dt><dd>Code that is on the classpath at comile time but that, +should not be shipped with the project because it is "provided" by the runtime, +somehow. Elasticsearch plugins use this configuration to include dependencies, +that are bundled with Elasticsearch's server.</dd>, +<dt>`shadow`</dt><dd>Only available in projects with the shadow plugin. Code, +that is on the classpath at both compile and runtime but it *not* bundled into, +the jar produced by the project. If you depend on a project with the `shadow`, +plugin then you need to depend on this configuration because it will bring, +along all of the dependencies you need at runtime.</dd>, +<dt>`testCompile`</dt><dd>Code that is on the classpath for compiling tests, +that are part of this project but not production code. The canonical example, +of this is `junit`.</dd>, +</dl>, +[shadow-plugin]: https://github.com/johnrengelman/shadow, +++ b/build.gradle, +allprojects {, +  /*, +   * IntelliJ and Eclipse don't know about the shadow plugin so when we're, +   * in "IntelliJ mode" or "Eclipse mode" add "runtime" dependencies, +   * eveywhere where we see a "shadow" dependency which will cause them to, +   * reference shadowed projects directly rather than rely on the shadowing, +   * to include them. This is the correct thing for it to do because it, +   * doesn't run the jar shadowing at all. This isn't needed for the project, +   * itself because the IDE configuration is done by SourceSets but it is, +   * *is* needed for projects that depends on the project doing the shadowing., +   * Without this they won't properly depend on the shadowed project., +   */, +  if (isEclipse || isIdea) {, +	configurations.all { Configuration configuration ->, +	  dependencies.all { Dependency dep ->, +		if (dep instanceof ProjectDependency) {, +		  if (dep.getTargetConfiguration() == 'shadow') {, +			configuration.dependencies.add(project.dependencies.project(path: dep.dependencyProject.path, configuration: 'runtime')), +		  }, +		}, +	  }, +	}, +  }, +}, +, +++ b/CONTRIBUTING.md, +### Gradle Build, +, +We use Gradle to build Elasticsearch because it is flexible enough to not only]