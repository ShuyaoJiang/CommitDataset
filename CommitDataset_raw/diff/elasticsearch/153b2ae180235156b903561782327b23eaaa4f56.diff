[+++ b/buildSrc/src/main/resources/checkstyle_suppressions.xml, +++ b/buildSrc/src/main/resources/checkstyle_suppressions.xml, +++ b/core/src/main/java/org/elasticsearch/search/fetch/package-info.java, + * Search phase that fetches the top hits from the shards after the results of the query phase have been merged. Pluggable by implementing, + * {@link org.elasticsearch.search.fetch.FetchSubPhase} and, +++ b/buildSrc/src/main/resources/checkstyle_suppressions.xml, +++ b/core/src/main/java/org/elasticsearch/search/fetch/package-info.java, + * Search phase that fetches the top hits from the shards after the results of the query phase have been merged. Pluggable by implementing, + * {@link org.elasticsearch.search.fetch.FetchSubPhase} and, +++ b/core/src/main/java/org/elasticsearch/search/fetch/subphase/ExplainFetchSubPhase.java, + * Explains the scoring calculations for the top hits., +            throw new FetchPhaseExecutionException(context, "Failed to explain doc [" + hitContext.hit().type() + "#" , +                    + hitContext.hit().id() + "]", e);, +++ b/buildSrc/src/main/resources/checkstyle_suppressions.xml, +++ b/core/src/main/java/org/elasticsearch/search/fetch/package-info.java, + * Search phase that fetches the top hits from the shards after the results of the query phase have been merged. Pluggable by implementing, + * {@link org.elasticsearch.search.fetch.FetchSubPhase} and, +++ b/core/src/main/java/org/elasticsearch/search/fetch/subphase/ExplainFetchSubPhase.java, + * Explains the scoring calculations for the top hits., +            throw new FetchPhaseExecutionException(context, "Failed to explain doc [" + hitContext.hit().type() + "#" , +                    + hitContext.hit().id() + "]", e);, +++ b/core/src/main/java/org/elasticsearch/search/fetch/subphase/FetchSourceContext.java, + * Context used to fetch the {@code _source}., +                                throw new ParsingException(parser.getTokenLocation(), "Unknown key for a " + token, +                                        + " in [" + currentFieldName + "].", parser.getTokenLocation());, +                                throw new ParsingException(parser.getTokenLocation(), "Unknown key for a " + token, +                                        + " in [" + currentFieldName + "].", parser.getTokenLocation());, +                        throw new ParsingException(parser.getTokenLocation(), "Unknown key for a " + token, +                                + " in [" + currentFieldName + "].", parser.getTokenLocation());, +++ b/buildSrc/src/main/resources/checkstyle_suppressions.xml, +++ b/core/src/main/java/org/elasticsearch/search/fetch/package-info.java, + * Search phase that fetches the top hits from the shards after the results of the query phase have been merged. Pluggable by implementing, + * {@link org.elasticsearch.search.fetch.FetchSubPhase} and, +++ b/core/src/main/java/org/elasticsearch/search/fetch/subphase/ExplainFetchSubPhase.java, + * Explains the scoring calculations for the top hits., +            throw new FetchPhaseExecutionException(context, "Failed to explain doc [" + hitContext.hit().type() + "#" , +                    + hitContext.hit().id() + "]", e);, +++ b/core/src/main/java/org/elasticsearch/search/fetch/subphase/FetchSourceContext.java, + * Context used to fetch the {@code _source}., +                                throw new ParsingException(parser.getTokenLocation(), "Unknown key for a " + token, +                                        + " in [" + currentFieldName + "].", parser.getTokenLocation());, +                                throw new ParsingException(parser.getTokenLocation(), "Unknown key for a " + token, +                                        + " in [" + currentFieldName + "].", parser.getTokenLocation());, +                        throw new ParsingException(parser.getTokenLocation(), "Unknown key for a " + token, +                                + " in [" + currentFieldName + "].", parser.getTokenLocation());, +++ b/core/src/main/java/org/elasticsearch/search/fetch/subphase/highlight/FastVectorHighlighter.java, +            throw new IllegalArgumentException("the field [" + highlighterContext.fieldName, +                    + "] should be indexed with term vector with position offsets to be used with fast vector highlighter");, +                    /*, +                     * we use top level reader to rewrite the query against all readers, with use caching it across hits (and across, +                     * readers...), +                     */, +                    cache.fieldMatchFieldQuery = new CustomFieldQuery(highlighterContext.query, hitContext.topLevelReader(),, +                            true, field.fieldOptions().requireFieldMatch());, +                    /*, +                     * we use top level reader to rewrite the query against all readers, with use caching it across hits (and across, +                     * readers...), +                     */, +                    cache.noFieldMatchFieldQuery = new CustomFieldQuery(highlighterContext.query, hitContext.topLevelReader(),, +                            true, field.fieldOptions().requireFieldMatch());, +                if (field.fieldOptions().boundaryMaxScan() != SimpleBoundaryScanner.DEFAULT_MAX_SCAN, +                        || field.fieldOptions().boundaryChars() != SimpleBoundaryScanner.DEFAULT_BOUNDARY_CHARS) {, +                    boundaryScanner = new SimpleBoundaryScanner(field.fieldOptions().boundaryMaxScan(),, +                            field.fieldOptions().boundaryChars());, +                        fragmentsBuilder = new SimpleFragmentsBuilder(mapper, field.fieldOptions().preTags(),, +                                field.fieldOptions().postTags(), boundaryScanner);, +                        fragmentsBuilder = new SourceSimpleFragmentsBuilder(mapper, context,, +                                field.fieldOptions().preTags(), field.fieldOptions().postTags(), boundaryScanner);, +                    fragListBuilder = field.fieldOptions().fragmentOffset() == -1 ?, +                            new SimpleFragListBuilder() : new SimpleFragListBuilder(field.fieldOptions().fragmentOffset());, +                            fragmentsBuilder = new ScoreOrderFragmentsBuilder(field.fieldOptions().preTags(),, +                                    field.fieldOptions().postTags(), boundaryScanner);, +                            fragmentsBuilder = new SourceScoreOrderFragmentsBuilder(mapper, context,, +                                    field.fieldOptions().preTags(), field.fieldOptions().postTags(), boundaryScanner);, +                            fragmentsBuilder = new SimpleFragmentsBuilder(mapper, field.fieldOptions().preTags(),, +                                    field.fieldOptions().postTags(), boundaryScanner);, +                            fragmentsBuilder = new SourceSimpleFragmentsBuilder(mapper, context, field.fieldOptions().preTags(),, +                                    field.fieldOptions().postTags(), boundaryScanner);, +            int numberOfFragments = field.fieldOptions().numberOfFragments() == 0 ?, +                    Integer.MAX_VALUE : field.fieldOptions().numberOfFragments();, +            int fragmentCharSize = field.fieldOptions().numberOfFragments() == 0 ?, +                    Integer.MAX_VALUE : field.fieldOptions().fragmentCharSize();, +                fragments = cache.fvh.getBestFragments(fieldQuery, hitContext.reader(), hitContext.docId(), mapper.fieldType().name(),, +                        field.fieldOptions().matchedFields(), fragmentCharSize, numberOfFragments, entry.fragListBuilder,, +                        entry.fragmentsBuilder, field.fieldOptions().preTags(), field.fieldOptions().postTags(), encoder);, +                fragments = cache.fvh.getBestFragments(fieldQuery, hitContext.reader(), hitContext.docId(), mapper.fieldType().name(),, +                        fragmentCharSize, numberOfFragments, entry.fragListBuilder, entry.fragmentsBuilder, field.fieldOptions().preTags(),, +                        field.fieldOptions().postTags(), encoder);, +        return fieldMapper.fieldType().storeTermVectors() && fieldMapper.fieldType().storeTermVectorOffsets(), +                && fieldMapper.fieldType().storeTermVectorPositions();, +++ b/buildSrc/src/main/resources/checkstyle_suppressions.xml, +++ b/core/src/main/java/org/elasticsearch/search/fetch/package-info.java, + * Search phase that fetches the top hits from the shards after the results of the query phase have been merged. Pluggable by implementing, + * {@link org.elasticsearch.search.fetch.FetchSubPhase} and, +++ b/core/src/main/java/org/elasticsearch/search/fetch/subphase/ExplainFetchSubPhase.java, + * Explains the scoring calculations for the top hits., +            throw new FetchPhaseExecutionException(context, "Failed to explain doc [" + hitContext.hit().type() + "#" , +                    + hitContext.hit().id() + "]", e);, +++ b/core/src/main/java/org/elasticsearch/search/fetch/subphase/FetchSourceContext.java, + * Context used to fetch the {@code _source}.]