[+++ b/buildSrc/src/main/groovy/org/elasticsearch/gradle/test/ClusterFormationTasks.groovy, +        String packaging = distro == 'tar' ? 'tar.gz' : distro, +++ b/buildSrc/src/main/groovy/org/elasticsearch/gradle/test/ClusterFormationTasks.groovy, +        String packaging = distro == 'tar' ? 'tar.gz' : distro, +++ b/distribution/tar/build.gradle, +  extension = 'tar.gz', +++ b/buildSrc/src/main/groovy/org/elasticsearch/gradle/test/ClusterFormationTasks.groovy, +        String packaging = distro == 'tar' ? 'tar.gz' : distro, +++ b/distribution/tar/build.gradle, +  extension = 'tar.gz', +++ b/plugins/lang-groovy/src/test/java/org/elasticsearch/script/groovy/GroovySecurityTests.java, +import org.elasticsearch.action.search.SearchResponse;, +import org.elasticsearch.action.search.ShardSearchFailure;, +import org.elasticsearch.index.query.QueryBuilders;, +import org.elasticsearch.plugins.Plugin;, +import org.elasticsearch.script.Script;, +import org.elasticsearch.script.ScriptService.ScriptType;, +import org.elasticsearch.search.builder.SearchSourceBuilder;, +import org.elasticsearch.search.sort.SortBuilders;, +import org.elasticsearch.test.ESIntegTestCase;, +import java.util.Collection;, +import java.util.Locale;, +, +import static org.elasticsearch.test.hamcrest.ElasticsearchAssertions.assertNoFailures;, +import static org.hamcrest.CoreMatchers.equalTo;, +import static org.hamcrest.CoreMatchers.instanceOf;, +@ESIntegTestCase.ClusterScope(scope = ESIntegTestCase.Scope.TEST, numDataNodes = 0), +// TODO: refactor into unit test, or, proper REST test, +public class GroovySecurityTests extends ESIntegTestCase {, +    protected Collection<Class<? extends Plugin>> nodePlugins() {, +        return Collections.singleton(GroovyPlugin.class);, +        int nodes = randomIntBetween(1, 3);, +        Settings nodeSettings = Settings.builder(), +                .put("script.inline", true), +                .put("script.indexed", true), +                .build();, +        internalCluster().startNodesAsync(nodes, nodeSettings).get();, +        client().admin().cluster().prepareHealth().setWaitForNodes(nodes + "").get();, +, +        client().prepareIndex("test", "doc", "1").setSource("foo", 5, "bar", "baz").setRefresh(true).get();, +, +        // numeric field access, +        // string field access, +        assertSuccess("def bar = doc['bar'].value; if (bar == null) { return 5; }");, +        logger.info("--> script: " + script);, +        SearchResponse resp = client(), +                .prepareSearch("test"), +                .setSource(, +                        new SearchSourceBuilder().query(QueryBuilders.matchAllQuery()).sort(, +                                SortBuilders.scriptSort(new Script(script + "; doc['foo'].value + 2", ScriptType.INLINE, "groovy", null),, +                                        "number"))).get();, +        assertNoFailures(resp);, +        assertEquals(1, resp.getHits().getTotalHits());, +        assertThat(resp.getHits().getAt(0).getSortValues(), equalTo(new Object[]{7.0}));, +        logger.info("--> script: " + script);, +        SearchResponse resp = client(), +                .prepareSearch("test"), +                .setSource(, +                        new SearchSourceBuilder().query(QueryBuilders.matchAllQuery()).sort(, +                                SortBuilders.scriptSort(new Script(script + "; doc['foo'].value + 2", ScriptType.INLINE, "groovy", null),, +                                        "number"))).get();, +        assertEquals(0, resp.getHits().getTotalHits());, +        ShardSearchFailure fails[] = resp.getShardFailures();, +        // TODO: GroovyScriptExecutionException needs work:, +        // fix it to preserve cause so we don't do this flaky string-check stuff, +        for (ShardSearchFailure fail : fails) {, +            assertThat(fail.getCause(), instanceOf(ScriptException.class));, +            assertTrue("unexpected exception" + fail.getCause(),, +                       // different casing, depending on jvm impl..., +                       fail.getCause().toString().toLowerCase(Locale.ROOT).contains("[access denied"));]