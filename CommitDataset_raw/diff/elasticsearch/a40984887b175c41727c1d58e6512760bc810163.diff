[+++ b/src/test/java/org/elasticsearch/test/disruption/SlowClusterStateProcessing.java, +import java.util.concurrent.CountDownLatch;, +        logger.info("stopping to slow down cluster state processing on [{}]", disruptedNode);, +        worker.interrupt();, +    private boolean interruptClusterStateProcessing(final TimeValue duration) throws InterruptedException {, +        final String disruptionNodeCopy = disruptedNode;, +        if (disruptionNodeCopy == null) {, +        logger.info("delaying cluster state updates on node [{}] for [{}]", disruptionNodeCopy, duration);, +        final CountDownLatch countDownLatch = new CountDownLatch(1);, +        ClusterService clusterService = cluster.getInstance(ClusterService.class, disruptionNodeCopy);, +        if (clusterService == null) {, +            return false;, +        }, +                countDownLatch.countDown();, +                countDownLatch.countDown();, +        try {, +            countDownLatch.await();, +        } catch (InterruptedException e) {, +            // try to wait again, we really want the cluster state thread to be freed up when stopping disruption, +            countDownLatch.await();, +        }, +        return TimeValue.timeValueMillis(0);, +            while (disrupting && disruptedNode != null) {, +, +                    duration = new TimeValue(intervalBetweenDelaysMin + random.nextInt((int) (intervalBetweenDelaysMax - intervalBetweenDelaysMin)));, +                    if (disrupting && disruptedNode != null) {, +                } catch (InterruptedException e) {]