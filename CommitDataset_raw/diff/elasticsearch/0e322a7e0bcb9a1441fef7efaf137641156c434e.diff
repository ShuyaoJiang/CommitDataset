[+++ b/buildSrc/src/main/groovy/org/elasticsearch/gradle/test/ClusterFormationTasks.groovy, +            ant.waitfor(maxwait: '30', maxwaitunit: 'second', checkevery: '500', checkeveryunit: 'millisecond', timeoutproperty: "failed${name}") {, +                waitFailed(project, nodes, logger, 'Failed to start elasticsearch'), +                    waitFailed(project, nodes, logger, 'Elasticsearch cluster failed to pass wait condition'), +    static void waitFailed(Project project, List<NodeInfo> nodes, Logger logger, String msg) {, +            if (node.pidFile.exists() && node.failedMarker.exists() == false &&, +                (node.httpPortsFile.exists() == false || node.transportPortsFile.exists() == false)) {, +                logger.error("|\n|  [jstack]"), +                String pid = node.pidFile.getText('UTF-8'), +                ByteArrayOutputStream output = new ByteArrayOutputStream(), +                project.exec {, +                    commandLine = ["${project.javaHome}/bin/jstack", pid], +                    standardOutput = output, +                }, +                output.toString('UTF-8').eachLine { line -> logger.error("|    ${line}") }, +            }, +++ b/buildSrc/src/main/groovy/org/elasticsearch/gradle/test/ClusterFormationTasks.groovy, +            ant.waitfor(maxwait: '30', maxwaitunit: 'second', checkevery: '500', checkeveryunit: 'millisecond', timeoutproperty: "failed${name}") {, +                waitFailed(project, nodes, logger, 'Failed to start elasticsearch'), +                    waitFailed(project, nodes, logger, 'Elasticsearch cluster failed to pass wait condition'), +    static void waitFailed(Project project, List<NodeInfo> nodes, Logger logger, String msg) {, +            if (node.pidFile.exists() && node.failedMarker.exists() == false &&, +                (node.httpPortsFile.exists() == false || node.transportPortsFile.exists() == false)) {, +                logger.error("|\n|  [jstack]"), +                String pid = node.pidFile.getText('UTF-8'), +                ByteArrayOutputStream output = new ByteArrayOutputStream(), +                project.exec {, +                    commandLine = ["${project.javaHome}/bin/jstack", pid], +                    standardOutput = output, +                }, +                output.toString('UTF-8').eachLine { line -> logger.error("|    ${line}") }, +            }, +++ b/buildSrc/src/main/resources/checkstyle_suppressions.xml, +++ b/buildSrc/src/main/groovy/org/elasticsearch/gradle/test/ClusterFormationTasks.groovy, +            ant.waitfor(maxwait: '30', maxwaitunit: 'second', checkevery: '500', checkeveryunit: 'millisecond', timeoutproperty: "failed${name}") {, +                waitFailed(project, nodes, logger, 'Failed to start elasticsearch'), +                    waitFailed(project, nodes, logger, 'Elasticsearch cluster failed to pass wait condition'), +    static void waitFailed(Project project, List<NodeInfo> nodes, Logger logger, String msg) {, +            if (node.pidFile.exists() && node.failedMarker.exists() == false &&, +                (node.httpPortsFile.exists() == false || node.transportPortsFile.exists() == false)) {, +                logger.error("|\n|  [jstack]"), +                String pid = node.pidFile.getText('UTF-8'), +                ByteArrayOutputStream output = new ByteArrayOutputStream(), +                project.exec {, +                    commandLine = ["${project.javaHome}/bin/jstack", pid], +                    standardOutput = output, +                }, +                output.toString('UTF-8').eachLine { line -> logger.error("|    ${line}") }, +            }, +++ b/buildSrc/src/main/resources/checkstyle_suppressions.xml, +++ b/core/src/main/java/org/elasticsearch/action/DocWriteResponse.java, +    private static final String _PRIMARY_TERM = "_primary_term";, +    private long primaryTerm;, +    public DocWriteResponse(ShardId shardId, String type, String id, long seqNo, long primaryTerm, long version, Result result) {, +        this.primaryTerm = primaryTerm;, +     * The primary term for this change., +     *, +     * @return the primary term, +     */, +    public long getPrimaryTerm() {, +        return primaryTerm;, +    }, +, +    /**, +            primaryTerm = in.readVLong();, +            primaryTerm = 0;, +            out.writeVLong(primaryTerm);, +            builder.field(_PRIMARY_TERM, getPrimaryTerm());, +            } else if (_PRIMARY_TERM.equals(currentFieldName)) {, +                context.setPrimaryTerm(parser.longValue());, +        protected Long primaryTerm = 0L;, +        public void setPrimaryTerm(Long primaryTerm) {, +            this.primaryTerm = primaryTerm;, +        }, +, +++ b/buildSrc/src/main/groovy/org/elasticsearch/gradle/test/ClusterFormationTasks.groovy, +            ant.waitfor(maxwait: '30', maxwaitunit: 'second', checkevery: '500', checkeveryunit: 'millisecond', timeoutproperty: "failed${name}") {, +                waitFailed(project, nodes, logger, 'Failed to start elasticsearch'), +                    waitFailed(project, nodes, logger, 'Elasticsearch cluster failed to pass wait condition'), +    static void waitFailed(Project project, List<NodeInfo> nodes, Logger logger, String msg) {, +            if (node.pidFile.exists() && node.failedMarker.exists() == false &&, +                (node.httpPortsFile.exists() == false || node.transportPortsFile.exists() == false)) {, +                logger.error("|\n|  [jstack]"), +                String pid = node.pidFile.getText('UTF-8'), +                ByteArrayOutputStream output = new ByteArrayOutputStream(), +                project.exec {, +                    commandLine = ["${project.javaHome}/bin/jstack", pid], +                    standardOutput = output, +                }, +                output.toString('UTF-8').eachLine { line -> logger.error("|    ${line}") }, +            }, +++ b/buildSrc/src/main/resources/checkstyle_suppressions.xml, +++ b/core/src/main/java/org/elasticsearch/action/DocWriteResponse.java, +    private static final String _PRIMARY_TERM = "_primary_term";, +    private long primaryTerm;, +    public DocWriteResponse(ShardId shardId, String type, String id, long seqNo, long primaryTerm, long version, Result result) {, +        this.primaryTerm = primaryTerm;, +     * The primary term for this change., +     *, +     * @return the primary term]