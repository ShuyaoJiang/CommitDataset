[+++ b/build.gradle, +final boolean bwc_tests_enabled = true, +final String bwc_tests_disabled_issue = "" /* place a PR link here when committing bwc changes */, +++ b/build.gradle, +final boolean bwc_tests_enabled = true, +final String bwc_tests_disabled_issue = "" /* place a PR link here when committing bwc changes */, +++ /dev/null, +++ b/build.gradle, +final boolean bwc_tests_enabled = true, +final String bwc_tests_disabled_issue = "" /* place a PR link here when committing bwc changes */, +++ /dev/null, +++ /dev/null, +++ b/build.gradle, +final boolean bwc_tests_enabled = true, +final String bwc_tests_disabled_issue = "" /* place a PR link here when committing bwc changes */, +++ /dev/null, +++ /dev/null, +++ b/buildSrc/src/main/groovy/org/elasticsearch/gradle/precommit/PrecommitTasks.groovy, +import com.github.jengelman.gradle.plugins.shadow.ShadowPlugin, +        // We want to get any compilation error before running the pre-commit checks., +        project.sourceSets.all { sourceSet ->, +            precommitTasks.each { task ->, +                task.shouldRunAfter(sourceSet.getClassesTaskName()), +            }, +        }, +        return project.tasks.create([, +        ]), +        if (project.plugins.hasPlugin(ShadowPlugin)) {, +            task.classpath += project.configurations.bundle, +        }, +        task.dependsOn(project.sourceSets.test.classesTaskName), +        task.javaHome = project.runtimeJavaHome, +            Task namingConventionsTask = project.tasks.create('namingConventions', NamingConventionsTask), +            namingConventionsTask.javaHome = project.runtimeJavaHome, +            return namingConventionsTask, +        return project.tasks.create('loggerUsageCheck', LoggerUsageTask.class) {, +            javaHome = project.runtimeJavaHome, +++ b/build.gradle, +final boolean bwc_tests_enabled = true, +final String bwc_tests_disabled_issue = "" /* place a PR link here when committing bwc changes */, +++ /dev/null, +++ /dev/null, +++ b/buildSrc/src/main/groovy/org/elasticsearch/gradle/precommit/PrecommitTasks.groovy, +import com.github.jengelman.gradle.plugins.shadow.ShadowPlugin, +        // We want to get any compilation error before running the pre-commit checks., +        project.sourceSets.all { sourceSet ->, +            precommitTasks.each { task ->, +                task.shouldRunAfter(sourceSet.getClassesTaskName()), +            }, +        }, +        return project.tasks.create([, +        ]), +        if (project.plugins.hasPlugin(ShadowPlugin)) {, +            task.classpath += project.configurations.bundle, +        }, +        task.dependsOn(project.sourceSets.test.classesTaskName), +        task.javaHome = project.runtimeJavaHome, +            Task namingConventionsTask = project.tasks.create('namingConventions', NamingConventionsTask), +            namingConventionsTask.javaHome = project.runtimeJavaHome, +            return namingConventionsTask, +        return project.tasks.create('loggerUsageCheck', LoggerUsageTask.class) {, +            javaHome = project.runtimeJavaHome, +++ b/buildSrc/src/main/java/org/elasticsearch/gradle/LoggedExec.java, +import org.gradle.api.Action;, +import org.gradle.api.Project;, +import org.gradle.process.BaseExecSpec;, +import org.gradle.process.ExecResult;, +import org.gradle.process.ExecSpec;, +import org.gradle.process.JavaExecSpec;, +import java.util.function.Function;, +        ByteArrayOutputStream output = new ByteArrayOutputStream();, +, +    public static ExecResult exec(Project project, Action<ExecSpec> action) {, +        return genericExec(project, project::exec, action);, +    }, +, +    public static ExecResult javaexec(Project project, Action<JavaExecSpec> action) {, +        return genericExec(project, project::javaexec, action);, +    }, +, +    private static <T extends BaseExecSpec>  ExecResult genericExec(, +        Project project,, +        Function<Action<T>,ExecResult> function,, +        Action<T> action, +    ) {, +        if (project.getLogger().isInfoEnabled()) {, +            return function.apply(action);, +        }, +        ByteArrayOutputStream output = new ByteArrayOutputStream();, +        try {, +            return function.apply(spec -> {, +                spec.setStandardOutput(output);, +                spec.setErrorOutput(output);, +                action.execute(spec);, +            });, +        } catch (Exception e) {, +            try {, +                for (String line : output.toString("UTF-8").split("\\R")) {, +                    project.getLogger().error(line);, +                }]