[+++ b/src/main/java/org/elasticsearch/discovery/zen/ping/ZenPing.java, +import java.util.HashMap;, +import java.util.Map;, +import java.util.concurrent.atomic.AtomicLong;, +        private static final AtomicLong idGenerator = new AtomicLong();, +, +        // an always increasing unique identifier for this ping response., +        // lower values means older pings., +        private long id;, +, +            this.id = idGenerator.incrementAndGet();, +        /**, +         * an always increasing unique identifier for this ping response., +         * lower values means older pings., +         */, +        public long id() {, +            return this.id;, +        }, +, +            this.id = in.readLong();, +            out.writeLong(id);, +            return "ping_response{node [" + node + "], id[" + id + "], master [" + master + "], hasJoinedOnce [" + hasJoinedOnce + "], cluster_name[" + clusterName.value() + "]}";, +, +, +    /**, +     * a utility collection of pings where only the most recent ping is stored per node, +     */, +    public static class PingCollection {, +, +        Map<DiscoveryNode, PingResponse> pings;, +, +        public PingCollection() {, +            pings = new HashMap<>();, +        }, +, +        /**, +         * adds a ping if newer than previous pings from the same node, +         *, +         * @return true if added, false o.w., +         */, +        public synchronized boolean addPing(PingResponse ping) {, +            PingResponse existingResponse = pings.get(ping.node());, +            // in case both existing and new ping have the same id (probably because they come, +            // from nodes from version <1.4.0) we prefer to use the last added one., +            if (existingResponse == null || existingResponse.id() <= ping.id()) {, +                pings.put(ping.node(), ping);, +                return true;, +            }, +            return false;, +        }, +, +        /** adds multiple pings if newer than previous pings from the same node */, +        public synchronized void addPings(PingResponse[] pings) {, +            for (PingResponse ping : pings) {, +                addPing(ping);, +            }, +        }, +, +        /** serialize current pings to an array */, +        public synchronized PingResponse[] toArray() {, +            return pings.values().toArray(new PingResponse[pings.size()]);, +        }, +, +    }, +++ b/src/main/java/org/elasticsearch/discovery/zen/ping/ZenPing.java, +import java.util.HashMap;, +import java.util.Map;, +import java.util.concurrent.atomic.AtomicLong;, +        private static final AtomicLong idGenerator = new AtomicLong();, +, +        // an always increasing unique identifier for this ping response., +        // lower values means older pings., +        private long id;, +, +            this.id = idGenerator.incrementAndGet();, +        /**, +         * an always increasing unique identifier for this ping response., +         * lower values means older pings., +         */, +        public long id() {, +            return this.id;, +        }, +, +            this.id = in.readLong();, +            out.writeLong(id);, +            return "ping_response{node [" + node + "], id[" + id + "], master [" + master + "], hasJoinedOnce [" + hasJoinedOnce + "], cluster_name[" + clusterName.value() + "]}";, +, +, +    /**, +     * a utility collection of pings where only the most recent ping is stored per node, +     */, +    public static class PingCollection {, +, +        Map<DiscoveryNode, PingResponse> pings;, +, +        public PingCollection() {, +            pings = new HashMap<>();, +        }, +, +        /**]