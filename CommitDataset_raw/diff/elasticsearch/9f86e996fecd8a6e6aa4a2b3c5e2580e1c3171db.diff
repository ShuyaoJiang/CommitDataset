[+++ b/server/src/main/java/org/elasticsearch/cluster/coordination/CoordinationState.java, +import static org.elasticsearch.cluster.coordination.Coordinator.ZEN1_BWC_TERM;, +, +            if (clusterState.term() == ZEN1_BWC_TERM, +                && clusterState.nodes().getMasterNode().equals(getLastAcceptedState().nodes().getMasterNode()) == false) {, +                logger.debug("handling publish request in compatibility mode despite version mismatch (expected: >[{}], actual: [{}])",, +                    getLastAcceptedVersion(), clusterState.version());, +            } else {, +        }, +++ b/server/src/main/java/org/elasticsearch/cluster/coordination/CoordinationState.java, +import static org.elasticsearch.cluster.coordination.Coordinator.ZEN1_BWC_TERM;, +, +            if (clusterState.term() == ZEN1_BWC_TERM, +                && clusterState.nodes().getMasterNode().equals(getLastAcceptedState().nodes().getMasterNode()) == false) {, +                logger.debug("handling publish request in compatibility mode despite version mismatch (expected: >[{}], actual: [{}])",, +                    getLastAcceptedVersion(), clusterState.version());, +            } else {, +        }, +++ b/server/src/main/java/org/elasticsearch/cluster/coordination/Coordinator.java, +import org.elasticsearch.common.Booleans;, +, +    public static final long ZEN1_BWC_TERM = 0;, +, +    private final DiscoveryUpgradeService discoveryUpgradeService;, +        this.discoveryUpgradeService = new DiscoveryUpgradeService(settings, clusterSettings, transportService, this::isBootstrapped,, +            joinHelper, peerFinder::getFoundPeers, this::unsafelySetConfigurationForUpgrade);, +            if (publishRequest.getAcceptedState().term() == ZEN1_BWC_TERM && getCurrentTerm() == ZEN1_BWC_TERM, +                && mode == Mode.FOLLOWER && Optional.of(sourceNode).equals(lastKnownLeader) == false) {, +, +                logger.debug("received cluster state from {} but currently following {}, rejecting", sourceNode, lastKnownLeader);, +                throw new CoordinationStateRejectedException("received cluster state from " + sourceNode + " but currently following ", +                    + lastKnownLeader + ", rejecting");, +            }, +, +                getDiscoveredNodes().forEach(node -> {, +                    if (isZen1Node(node) == false) {, +                        joinHelper.sendStartJoinRequest(startJoinRequest, node);, +                    }, +                });, +, +            if (getCurrentTerm() == ZEN1_BWC_TERM) {, +                discoveryUpgradeService.activate(lastKnownLeader);, +            }, +, +        discoveryUpgradeService.deactivate();, +        discoveryUpgradeService.deactivate();, +    private boolean isBootstrapped() {, +        return getLastAcceptedState().getLastAcceptedConfiguration().isEmpty() == false;, +    }, +, +    private void unsafelySetConfigurationForUpgrade(VotingConfiguration votingConfiguration) {, +        assert Version.CURRENT.major == Version.V_6_6_0.major + 1 : "remove this method once unsafe upgrades are no longer needed";, +        synchronized (mutex) {, +            if (mode != Mode.CANDIDATE) {, +                throw new IllegalStateException("Cannot overwrite configuration in mode " + mode);, +            }, +, +            if (isBootstrapped()) {, +                throw new IllegalStateException("Cannot overwrite configuration: configuration is already set to ", +                    + getLastAcceptedState().getLastAcceptedConfiguration());, +            }, +, +            if (lastKnownLeader.map(Coordinator::isZen1Node).orElse(false) == false) {, +                throw new IllegalStateException("Cannot upgrade from last-known leader: " + lastKnownLeader);, +            }, +, +            if (getCurrentTerm() != ZEN1_BWC_TERM) {, +                throw new IllegalStateException("Cannot upgrade, term is " + getCurrentTerm());, +            }, +, +            logger.info("automatically bootstrapping during rolling upgrade, using initial configuration {}", votingConfiguration);, +, +            final ClusterState currentState = getStateForMasterService();, +            final Builder builder = masterService.incrementVersion(currentState);, +            builder.metaData(MetaData.builder(currentState.metaData()).coordinationMetaData(, +                CoordinationMetaData.builder(currentState.metaData().coordinationMetaData()), +                    .term(1), +                    .lastAcceptedConfiguration(votingConfiguration), +                    .lastCommittedConfiguration(votingConfiguration), +                    .build()));, +            final ClusterState newClusterState = builder.build();, +, +            coordinationState.get().handleStartJoin(new StartJoinRequest(getLocalNode(), newClusterState.term()));, +            coordinationState.get().handlePublishRequest(new PublishRequest(newClusterState));, +, +            followersChecker.clearCurrentNodes();, +            followersChecker.updateFastResponseState(getCurrentTerm(), mode);, +, +            peerFinder.deactivate(getLocalNode());, +            peerFinder.activate(newClusterState.nodes());, +        }, +    }, +, +            .filter(this::hasJoinVoteFrom).filter(discoveryNode -> isZen1Node(discoveryNode) == false).collect(Collectors.toSet());, +                        final List<DiscoveryNode> discoveredNodes, +                            = getDiscoveredNodes().stream().filter(n -> isZen1Node(n) == false).collect(Collectors.toList());, +                        prevotingRound = preVoteCollector.start(lastAcceptedState, discoveredNodes);, +    public static Settings.Builder addZen1Attribute(boolean isZen1Node, Settings.Builder builder) {, +        return builder.put("node.attr.zen1", isZen1Node);, +            (Booleans.isTrue(discoveryNode.getAttributes().getOrDefault("zen1", "false")));]