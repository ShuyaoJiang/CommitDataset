[+++ b/src/main/java/org/elasticsearch/index/merge/scheduler/ConcurrentMergeSchedulerProvider.java, +            int maxThreadCount = settings.getAsInt(MAX_THREAD_COUNT, ConcurrentMergeSchedulerProvider.this.maxThreadCount);, +                logger.info("updating [{}] from [{}] to [{}]", MAX_THREAD_COUNT_KEY, ConcurrentMergeSchedulerProvider.this.maxThreadCount, maxThreadCount);, +            int maxMergeCount = settings.getAsInt(MAX_MERGE_COUNT, ConcurrentMergeSchedulerProvider.this.maxMergeCount);, +                logger.info("updating [{}] from [{}] to [{}]", MAX_MERGE_COUNT_KEY, ConcurrentMergeSchedulerProvider.this.maxMergeCount, maxMergeCount);, +++ b/src/main/java/org/elasticsearch/index/merge/scheduler/ConcurrentMergeSchedulerProvider.java, +            int maxThreadCount = settings.getAsInt(MAX_THREAD_COUNT, ConcurrentMergeSchedulerProvider.this.maxThreadCount);, +                logger.info("updating [{}] from [{}] to [{}]", MAX_THREAD_COUNT_KEY, ConcurrentMergeSchedulerProvider.this.maxThreadCount, maxThreadCount);, +            int maxMergeCount = settings.getAsInt(MAX_MERGE_COUNT, ConcurrentMergeSchedulerProvider.this.maxMergeCount);, +                logger.info("updating [{}] from [{}] to [{}]", MAX_MERGE_COUNT_KEY, ConcurrentMergeSchedulerProvider.this.maxMergeCount, maxMergeCount);, +++ b/src/main/java/org/elasticsearch/index/settings/IndexDynamicSettingsModule.java, +import org.elasticsearch.index.merge.scheduler.ConcurrentMergeSchedulerProvider;, +        indexDynamicSettings.addDynamicSetting(ConcurrentMergeSchedulerProvider.MAX_THREAD_COUNT);, +        indexDynamicSettings.addDynamicSetting(ConcurrentMergeSchedulerProvider.MAX_MERGE_COUNT);, +++ b/src/main/java/org/elasticsearch/index/merge/scheduler/ConcurrentMergeSchedulerProvider.java, +            int maxThreadCount = settings.getAsInt(MAX_THREAD_COUNT, ConcurrentMergeSchedulerProvider.this.maxThreadCount);, +                logger.info("updating [{}] from [{}] to [{}]", MAX_THREAD_COUNT_KEY, ConcurrentMergeSchedulerProvider.this.maxThreadCount, maxThreadCount);, +            int maxMergeCount = settings.getAsInt(MAX_MERGE_COUNT, ConcurrentMergeSchedulerProvider.this.maxMergeCount);, +                logger.info("updating [{}] from [{}] to [{}]", MAX_MERGE_COUNT_KEY, ConcurrentMergeSchedulerProvider.this.maxMergeCount, maxMergeCount);, +++ b/src/main/java/org/elasticsearch/index/settings/IndexDynamicSettingsModule.java, +import org.elasticsearch.index.merge.scheduler.ConcurrentMergeSchedulerProvider;, +        indexDynamicSettings.addDynamicSetting(ConcurrentMergeSchedulerProvider.MAX_THREAD_COUNT);, +        indexDynamicSettings.addDynamicSetting(ConcurrentMergeSchedulerProvider.MAX_MERGE_COUNT);, +++ b/src/test/java/org/elasticsearch/indices/settings/UpdateSettingsTests.java, +import org.apache.log4j.AppenderSkeleton;, +import org.apache.log4j.Level;, +import org.apache.log4j.Logger;, +import org.apache.log4j.spi.LoggingEvent;, +, +    private static class MockAppender extends AppenderSkeleton {, +        public boolean sawIndexWriterMessage;, +        public boolean sawFlushDeletes;, +        public boolean sawMergeThreadPaused;, +        public boolean sawUpdateSetting;, +, +        @Override, +        protected void append(LoggingEvent event) {, +            String message = event.getMessage().toString();, +            if (event.getLevel() == Level.TRACE &&, +                event.getLoggerName().endsWith("lucene.iw")) {, +                sawFlushDeletes |= message.contains("IW: apply all deletes during flush");, +                sawMergeThreadPaused |= message.contains("CMS: pause thread");, +            }, +            if (event.getLevel() == Level.INFO && message.contains("updating [max_thread_count] from [10000] to [1]")) {, +                sawUpdateSetting = true;, +            }, +        }, +, +        @Override, +        public boolean requiresLayout() {, +            return false;, +        }, +, +        @Override, +        public void close() {, +        }, +    }, +, +    // #6882: make sure we can change index.merge.scheduler.max_thread_count live, +    @Test, +    @Slow, +    public void testUpdateMergeMaxThreadCount() {, +, +        MockAppender mockAppender = new MockAppender();, +        Logger rootLogger = Logger.getRootLogger();, +        Level savedLevel = rootLogger.getLevel();, +        rootLogger.addAppender(mockAppender);, +        rootLogger.setLevel(Level.TRACE);, +, +        try {, +, +            // Tons of merge threads allowed, only 1 non-replicated shard, force lots of merging, throttle so they fall behind:, +            assertAcked(prepareCreate("test"), +                        .setSettings(ImmutableSettings.builder(), +                                     .put(AbstractIndexStore.INDEX_STORE_THROTTLE_TYPE, "merge"), +                                     .put(AbstractIndexStore.INDEX_STORE_THROTTLE_MAX_BYTES_PER_SEC, "1mb"), +                                     .put(IndexMetaData.SETTING_NUMBER_OF_SHARDS, "1"), +                                     .put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, "0"), +                                     .put(TieredMergePolicyProvider.INDEX_MERGE_POLICY_MAX_MERGE_AT_ONCE, "2"), +                                     .put(TieredMergePolicyProvider.INDEX_MERGE_POLICY_SEGMENTS_PER_TIER, "2"), +                                     .put(ConcurrentMergeSchedulerProvider.MAX_THREAD_COUNT, "10000"), +                                     .put(ConcurrentMergeSchedulerProvider.MAX_MERGE_COUNT, "10000"), +                                     ));, +            ensureGreen();, +            long termUpto = 0;, +            for(int i=0;i<100;i++) {, +                // Provoke slowish merging by making many unique terms:, +                StringBuilder sb = new StringBuilder();, +                for(int j=0;j<100;j++) {, +                    sb.append(' ');, +                    sb.append(termUpto++);, +                }, +                client().prepareIndex("test", "type", ""+termUpto).setSource("field" + (i%10), sb.toString()).get();, +                if (i % 2 == 0) {, +                    refresh();, +                }, +            }, +, +            assertTrue(mockAppender.sawFlushDeletes);, +            assertFalse(mockAppender.sawMergeThreadPaused);]