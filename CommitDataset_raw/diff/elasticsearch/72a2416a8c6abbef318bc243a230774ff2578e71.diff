[+++ b/src/main/java/org/apache/lucene/search/vectorhighlight/CustomFieldQuery.java, +import org.apache.lucene.index.Term;, +import java.util.List;, +        } else if (sourceQuery instanceof MultiPhraseQuery) {, +            MultiPhraseQuery q = ((MultiPhraseQuery) sourceQuery);, +            convertMultiPhraseQuery(0, new int[q.getTermArrays().size()] , q, q.getTermArrays(), q.getPositions(), reader, flatQueries);, +    private void convertMultiPhraseQuery(int currentPos, int[] termsIdx, MultiPhraseQuery orig, List<Term[]> terms, int[] pos, IndexReader reader, Collection<Query> flatQueries) throws IOException {, +        /*, +         * we walk all possible ways and for each path down the MPQ we create a PhraseQuery this is what FieldQuery supports., +         * It seems expensive but most queries will pretty small., +         */, +        if (currentPos == terms.size()) {, +            PhraseQuery query = new PhraseQuery();, +            query.setBoost(orig.getBoost());, +            query.setSlop(orig.getSlop());, +            for (int i = 0; i < termsIdx.length; i++) {, +                query.add(terms.get(i)[termsIdx[i]], pos[i]);, +            }, +            this.flatten(query, reader, flatQueries);, +        } else {, +            Term[] t = terms.get(currentPos);, +            for (int i = 0; i < t.length; i++) {, +                termsIdx[currentPos] = i;, +                convertMultiPhraseQuery(currentPos+1, termsIdx, orig, terms, pos, reader, flatQueries);, +            }, +        }, +    }, +    , +++ b/src/main/java/org/apache/lucene/search/vectorhighlight/CustomFieldQuery.java, +import org.apache.lucene.index.Term;, +import java.util.List;, +        } else if (sourceQuery instanceof MultiPhraseQuery) {, +            MultiPhraseQuery q = ((MultiPhraseQuery) sourceQuery);, +            convertMultiPhraseQuery(0, new int[q.getTermArrays().size()] , q, q.getTermArrays(), q.getPositions(), reader, flatQueries);, +    private void convertMultiPhraseQuery(int currentPos, int[] termsIdx, MultiPhraseQuery orig, List<Term[]> terms, int[] pos, IndexReader reader, Collection<Query> flatQueries) throws IOException {, +        /*, +         * we walk all possible ways and for each path down the MPQ we create a PhraseQuery this is what FieldQuery supports., +         * It seems expensive but most queries will pretty small., +         */, +        if (currentPos == terms.size()) {, +            PhraseQuery query = new PhraseQuery();, +            query.setBoost(orig.getBoost());, +            query.setSlop(orig.getSlop());, +            for (int i = 0; i < termsIdx.length; i++) {, +                query.add(terms.get(i)[termsIdx[i]], pos[i]);, +            }, +            this.flatten(query, reader, flatQueries);, +        } else {, +            Term[] t = terms.get(currentPos);, +            for (int i = 0; i < t.length; i++) {, +                termsIdx[currentPos] = i;, +                convertMultiPhraseQuery(currentPos+1, termsIdx, orig, terms, pos, reader, flatQueries);, +            }, +        }, +    }, +    , +++ b/src/main/java/org/elasticsearch/common/lucene/search/MultiPhrasePrefixQuery.java, +    , +    public String getField() {, +        return field;, +    }, +++ b/src/main/java/org/apache/lucene/search/vectorhighlight/CustomFieldQuery.java, +import org.apache.lucene.index.Term;, +import java.util.List;, +        } else if (sourceQuery instanceof MultiPhraseQuery) {, +            MultiPhraseQuery q = ((MultiPhraseQuery) sourceQuery);, +            convertMultiPhraseQuery(0, new int[q.getTermArrays().size()] , q, q.getTermArrays(), q.getPositions(), reader, flatQueries);, +    private void convertMultiPhraseQuery(int currentPos, int[] termsIdx, MultiPhraseQuery orig, List<Term[]> terms, int[] pos, IndexReader reader, Collection<Query> flatQueries) throws IOException {, +        /*, +         * we walk all possible ways and for each path down the MPQ we create a PhraseQuery this is what FieldQuery supports., +         * It seems expensive but most queries will pretty small., +         */, +        if (currentPos == terms.size()) {, +            PhraseQuery query = new PhraseQuery();, +            query.setBoost(orig.getBoost());, +            query.setSlop(orig.getSlop());, +            for (int i = 0; i < termsIdx.length; i++) {, +                query.add(terms.get(i)[termsIdx[i]], pos[i]);, +            }, +            this.flatten(query, reader, flatQueries);, +        } else {, +            Term[] t = terms.get(currentPos);, +            for (int i = 0; i < t.length; i++) {, +                termsIdx[currentPos] = i;, +                convertMultiPhraseQuery(currentPos+1, termsIdx, orig, terms, pos, reader, flatQueries);, +            }, +        }, +    }, +    , +++ b/src/main/java/org/elasticsearch/common/lucene/search/MultiPhrasePrefixQuery.java, +    , +    public String getField() {, +        return field;, +    }, +++ b/src/main/java/org/elasticsearch/search/highlight/CustomQueryScorer.java, +import org.apache.lucene.index.AtomicReader;, +import org.elasticsearch.common.lucene.search.MultiPhrasePrefixQuery;, +            } else if (query instanceof MultiPhrasePrefixQuery) {, +                MultiPhrasePrefixQuery q = ((MultiPhrasePrefixQuery)query);, +                AtomicReader atomicReader = getLeafContextForField(q.getField()).reader();]