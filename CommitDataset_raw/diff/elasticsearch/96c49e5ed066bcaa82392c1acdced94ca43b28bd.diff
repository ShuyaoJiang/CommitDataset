[+++ b/x-pack/plugin/ccr/src/main/java/org/elasticsearch/xpack/ccr/action/PutAutoFollowPatternAction.java, +            PARSER.declareField(Request::setMaxRetryDelay,, +                ShardFollowTask.MAX_RETRY_DELAY, ObjectParser.ValueType.STRING);, +        private TimeValue maxRetryDelay;, +        public TimeValue getMaxRetryDelay() {, +            return maxRetryDelay;, +        public void setMaxRetryDelay(TimeValue maxRetryDelay) {, +            this.maxRetryDelay = maxRetryDelay;, +            maxRetryDelay = in.readOptionalTimeValue();, +            out.writeOptionalTimeValue(maxRetryDelay);, +                if (maxRetryDelay != null) {, +                    builder.field(ShardFollowTask.MAX_RETRY_DELAY.getPreferredName(), maxRetryDelay.getStringRep());, +                Objects.equals(maxRetryDelay, request.maxRetryDelay) &&, +                maxRetryDelay,, +++ b/x-pack/plugin/ccr/src/main/java/org/elasticsearch/xpack/ccr/action/PutAutoFollowPatternAction.java, +            PARSER.declareField(Request::setMaxRetryDelay,, +                ShardFollowTask.MAX_RETRY_DELAY, ObjectParser.ValueType.STRING);, +        private TimeValue maxRetryDelay;, +        public TimeValue getMaxRetryDelay() {, +            return maxRetryDelay;, +        public void setMaxRetryDelay(TimeValue maxRetryDelay) {, +            this.maxRetryDelay = maxRetryDelay;, +            maxRetryDelay = in.readOptionalTimeValue();, +            out.writeOptionalTimeValue(maxRetryDelay);, +                if (maxRetryDelay != null) {, +                    builder.field(ShardFollowTask.MAX_RETRY_DELAY.getPreferredName(), maxRetryDelay.getStringRep());, +                Objects.equals(maxRetryDelay, request.maxRetryDelay) &&, +                maxRetryDelay,, +++ b/x-pack/plugin/ccr/src/main/java/org/elasticsearch/xpack/ccr/action/ShardFollowNodeTask.java, +import org.elasticsearch.common.Randomness;, +    private static final int DELAY_MILLIS = 50;, +    private final TimeValue maxRetryDelay;, +        this.maxRetryDelay = params.getMaxRetryDelay();, +        if (shouldRetry(e) && isStopped() == false) {, +            int currentRetry = retryCounter.incrementAndGet();, +            LOGGER.debug(new ParameterizedMessage("{} error during follow shard task, retrying [{}]",, +                params.getFollowShardId(), currentRetry), e);, +            long delay = computeDelay(currentRetry, maxRetryDelay.getMillis());, +            scheduler.accept(TimeValue.timeValueMillis(delay), task);, +    static long computeDelay(int currentRetry, long maxRetryDelayInMillis) {, +        // Cap currentRetry to avoid overflow when computing n variable, +        int maxCurrentRetry = Math.min(currentRetry, 24);, +        long n = Math.round(Math.pow(2, maxCurrentRetry - 1));, +        // + 1 here, because nextInt(...) bound is exclusive and otherwise the first delay would always be zero., +        int k = Randomness.get().nextInt(Math.toIntExact(n + 1));, +        int backOffDelay = k * DELAY_MILLIS;, +        return Math.min(backOffDelay, maxRetryDelayInMillis);, +    }, +, +    private static boolean shouldRetry(Exception e) {, +++ b/x-pack/plugin/ccr/src/main/java/org/elasticsearch/xpack/ccr/action/PutAutoFollowPatternAction.java, +            PARSER.declareField(Request::setMaxRetryDelay,, +                ShardFollowTask.MAX_RETRY_DELAY, ObjectParser.ValueType.STRING);, +        private TimeValue maxRetryDelay;, +        public TimeValue getMaxRetryDelay() {, +            return maxRetryDelay;, +        public void setMaxRetryDelay(TimeValue maxRetryDelay) {, +            this.maxRetryDelay = maxRetryDelay;, +            maxRetryDelay = in.readOptionalTimeValue();, +            out.writeOptionalTimeValue(maxRetryDelay);, +                if (maxRetryDelay != null) {, +                    builder.field(ShardFollowTask.MAX_RETRY_DELAY.getPreferredName(), maxRetryDelay.getStringRep());, +                Objects.equals(maxRetryDelay, request.maxRetryDelay) &&, +                maxRetryDelay,, +++ b/x-pack/plugin/ccr/src/main/java/org/elasticsearch/xpack/ccr/action/ShardFollowNodeTask.java, +import org.elasticsearch.common.Randomness;, +    private static final int DELAY_MILLIS = 50;, +    private final TimeValue maxRetryDelay;, +        this.maxRetryDelay = params.getMaxRetryDelay();, +        if (shouldRetry(e) && isStopped() == false) {, +            int currentRetry = retryCounter.incrementAndGet();, +            LOGGER.debug(new ParameterizedMessage("{} error during follow shard task, retrying [{}]",, +                params.getFollowShardId(), currentRetry), e);, +            long delay = computeDelay(currentRetry, maxRetryDelay.getMillis());, +            scheduler.accept(TimeValue.timeValueMillis(delay), task);, +    static long computeDelay(int currentRetry, long maxRetryDelayInMillis) {, +        // Cap currentRetry to avoid overflow when computing n variable, +        int maxCurrentRetry = Math.min(currentRetry, 24);, +        long n = Math.round(Math.pow(2, maxCurrentRetry - 1));, +        // + 1 here, because nextInt(...) bound is exclusive and otherwise the first delay would always be zero., +        int k = Randomness.get().nextInt(Math.toIntExact(n + 1));, +        int backOffDelay = k * DELAY_MILLIS;, +        return Math.min(backOffDelay, maxRetryDelayInMillis);, +    }, +, +    private static boolean shouldRetry(Exception e) {, +++ b/x-pack/plugin/ccr/src/main/java/org/elasticsearch/xpack/ccr/action/ShardFollowTask.java, +    public static final ParseField MAX_RETRY_DELAY = new ParseField("max_retry_delay");, +            (p, c) -> TimeValue.parseTimeValue(p.text(), MAX_RETRY_DELAY.getPreferredName()),, +            MAX_RETRY_DELAY, ObjectParser.ValueType.STRING);, +    private final TimeValue maxRetryDelay;, +                    int maxWriteBufferSize, TimeValue maxRetryDelay, TimeValue idleShardRetryDelay, Map<String, String> headers) {, +        this.maxRetryDelay = maxRetryDelay;, +        this.maxRetryDelay = in.readTimeValue();, +    public TimeValue getMaxRetryDelay() {, +        return maxRetryDelay;, +        out.writeTimeValue(maxRetryDelay);, +        builder.field(MAX_RETRY_DELAY.getPreferredName(), maxRetryDelay.getStringRep());, +                Objects.equals(maxRetryDelay, that.maxRetryDelay) &&, +            maxConcurrentWriteBatches, maxBatchSizeInBytes, maxWriteBufferSize, maxRetryDelay, idleShardRetryDelay, headers);]