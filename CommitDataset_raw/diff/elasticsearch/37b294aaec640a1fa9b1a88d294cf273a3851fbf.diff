[+++ b/src/main/java/org/elasticsearch/index/engine/internal/InternalEngine.java, +import org.elasticsearch.common.util.concurrent.AbstractRunnable;, +    private void waitForMerges(boolean flushAfter) {, +        try {, +            currentIndexWriter().waitForMerges();, +        } catch (IOException e) {, +            throw new OptimizeFailedEngineException(shardId, e);, +        }, +        if (flushAfter) {, +    }, +, +    @Override, +    public void optimize(Optimize optimize) throws EngineException {, +        , +            waitForMerges(optimize.flush());, +        } else if (optimize.flush()) {, +            // we only need to monitor merges for async calls if we are going to flush, +            threadPool.executor(ThreadPool.Names.OPTIMIZE).execute(new AbstractRunnable() {, +                @Override, +                public void onFailure(Throwable t) {, +                    logger.error("Exception while waiting for merges asynchronously after optimize", t);, +                @Override, +                protected void doRun() throws Exception {, +                    waitForMerges(true);, +            });, +++ b/src/main/java/org/elasticsearch/index/engine/internal/InternalEngine.java, +import org.elasticsearch.common.util.concurrent.AbstractRunnable;, +    private void waitForMerges(boolean flushAfter) {, +        try {, +            currentIndexWriter().waitForMerges();, +        } catch (IOException e) {, +            throw new OptimizeFailedEngineException(shardId, e);, +        }, +        if (flushAfter) {, +    }, +, +    @Override, +    public void optimize(Optimize optimize) throws EngineException {, +        , +            waitForMerges(optimize.flush());, +        } else if (optimize.flush()) {, +            // we only need to monitor merges for async calls if we are going to flush, +            threadPool.executor(ThreadPool.Names.OPTIMIZE).execute(new AbstractRunnable() {, +                @Override, +                public void onFailure(Throwable t) {, +                    logger.error("Exception while waiting for merges asynchronously after optimize", t);, +                @Override, +                protected void doRun() throws Exception {, +                    waitForMerges(true);, +            });, +++ b/src/main/java/org/elasticsearch/index/merge/policy/ElasticsearchMergePolicy.java, +        MergeSpecification spec = delegate.findForcedMerges(segmentInfos, maxSegmentCount, segmentsToMerge, writer);, +, +        if (spec == null && force) {, +                spec = new IndexUpgraderMergeSpecification();, +        return upgradedMergeSpecification(spec);, +++ b/src/main/java/org/elasticsearch/index/engine/internal/InternalEngine.java, +import org.elasticsearch.common.util.concurrent.AbstractRunnable;, +    private void waitForMerges(boolean flushAfter) {, +        try {, +            currentIndexWriter().waitForMerges();, +        } catch (IOException e) {, +            throw new OptimizeFailedEngineException(shardId, e);, +        }, +        if (flushAfter) {, +    }, +, +    @Override, +    public void optimize(Optimize optimize) throws EngineException {, +        , +            waitForMerges(optimize.flush());, +        } else if (optimize.flush()) {, +            // we only need to monitor merges for async calls if we are going to flush, +            threadPool.executor(ThreadPool.Names.OPTIMIZE).execute(new AbstractRunnable() {, +                @Override, +                public void onFailure(Throwable t) {, +                    logger.error("Exception while waiting for merges asynchronously after optimize", t);, +                @Override, +                protected void doRun() throws Exception {, +                    waitForMerges(true);, +            });, +++ b/src/main/java/org/elasticsearch/index/merge/policy/ElasticsearchMergePolicy.java, +        MergeSpecification spec = delegate.findForcedMerges(segmentInfos, maxSegmentCount, segmentsToMerge, writer);, +, +        if (spec == null && force) {, +                spec = new IndexUpgraderMergeSpecification();, +        return upgradedMergeSpecification(spec);, +++ b/src/test/java/org/elasticsearch/index/engine/internal/InternalEngineTests.java, +import com.google.common.base.Predicate;, +import org.apache.lucene.index.SegmentInfos;, +        final Engine engine = createEngine(engineSettingsService, store, createTranslog(), mergeSchedulerProvider);, +        final long gen1 = store.readLastCommittedSegmentsInfo().getGeneration();, +        // we could have multiple underlying merges, so the generation may increase more than once, +        assertTrue(store.readLastCommittedSegmentsInfo().getGeneration() > gen1);, +        final boolean flush = randomBoolean();, +        final long gen2 = store.readLastCommittedSegmentsInfo().getGeneration();, +        engine.optimize(new Engine.Optimize().flush(flush).maxNumSegments(1).force(force).waitForMerge(false));, +        if (flush) {, +            awaitBusy(new Predicate<Object>() {, +                @Override]