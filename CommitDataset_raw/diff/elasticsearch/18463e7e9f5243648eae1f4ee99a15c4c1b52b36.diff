[+++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/Compiler.java, +import org.elasticsearch.painless.spi.Whitelist;, +++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/Compiler.java, +import org.elasticsearch.painless.spi.Whitelist;, +++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/Definition.java, +import org.elasticsearch.painless.spi.Whitelist;, +++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/Compiler.java, +import org.elasticsearch.painless.spi.Whitelist;, +++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/Definition.java, +import org.elasticsearch.painless.spi.Whitelist;, +++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/PainlessPlugin.java, +import org.elasticsearch.painless.spi.PainlessExtension;, +import org.elasticsearch.painless.spi.Whitelist;, +import java.util.ArrayList;, +import java.util.HashMap;, +import java.util.Map;, +import java.util.ServiceLoader;, +    private final Map<ScriptContext<?>, List<Whitelist>> extendedWhitelists = new HashMap<>();, +, +        Map<ScriptContext<?>, List<Whitelist>> contextsWithWhitelists = new HashMap<>();, +        for (ScriptContext<?> context : contexts) {, +            // we might have a context that only uses the base whitelists, so would not have been filled in by reloadSPI, +            List<Whitelist> whitelists = extendedWhitelists.get(context);, +            if (whitelists == null) {, +                whitelists = new ArrayList<>(Whitelist.BASE_WHITELISTS);, +            }, +            contextsWithWhitelists.put(context, whitelists);, +        }, +        return new PainlessScriptEngine(settings, contextsWithWhitelists);, +, +    @Override, +    public void reloadSPI(ClassLoader loader) {, +        for (PainlessExtension extension : ServiceLoader.load(PainlessExtension.class, loader)) {, +            for (Map.Entry<ScriptContext<?>, List<Whitelist>> entry : extension.getContextWhitelists().entrySet()) {, +                List<Whitelist> existing = extendedWhitelists.computeIfAbsent(entry.getKey(),, +                    c -> new ArrayList<>(Whitelist.BASE_WHITELISTS));, +                existing.addAll(entry.getValue());, +            }, +        }, +    }, +++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/Compiler.java, +import org.elasticsearch.painless.spi.Whitelist;, +++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/Definition.java, +import org.elasticsearch.painless.spi.Whitelist;, +++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/PainlessPlugin.java, +import org.elasticsearch.painless.spi.PainlessExtension;, +import org.elasticsearch.painless.spi.Whitelist;, +import java.util.ArrayList;, +import java.util.HashMap;, +import java.util.Map;, +import java.util.ServiceLoader;, +    private final Map<ScriptContext<?>, List<Whitelist>> extendedWhitelists = new HashMap<>();, +, +        Map<ScriptContext<?>, List<Whitelist>> contextsWithWhitelists = new HashMap<>();, +        for (ScriptContext<?> context : contexts) {, +            // we might have a context that only uses the base whitelists, so would not have been filled in by reloadSPI, +            List<Whitelist> whitelists = extendedWhitelists.get(context);, +            if (whitelists == null) {, +                whitelists = new ArrayList<>(Whitelist.BASE_WHITELISTS);, +            }, +            contextsWithWhitelists.put(context, whitelists);, +        }, +        return new PainlessScriptEngine(settings, contextsWithWhitelists);, +, +    @Override, +    public void reloadSPI(ClassLoader loader) {, +        for (PainlessExtension extension : ServiceLoader.load(PainlessExtension.class, loader)) {, +            for (Map.Entry<ScriptContext<?>, List<Whitelist>> entry : extension.getContextWhitelists().entrySet()) {, +                List<Whitelist> existing = extendedWhitelists.computeIfAbsent(entry.getKey(),, +                    c -> new ArrayList<>(Whitelist.BASE_WHITELISTS));, +                existing.addAll(entry.getValue());, +            }, +        }, +    }, +++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/PainlessScriptEngine.java, +import org.elasticsearch.painless.spi.Whitelist;, +     * of {@link PainlessScriptEngine#PainlessScriptEngine(Settings, Map)}., +    public PainlessScriptEngine(Settings settings, Map<ScriptContext<?>, List<Whitelist>> contexts) {, +        for (Map.Entry<ScriptContext<?>, List<Whitelist>> entry : contexts.entrySet()) {, +            ScriptContext<?> context = entry.getKey();, +                contextsToCompilers.put(context, new Compiler(GenericElasticsearchScript.class, new Definition(entry.getValue())));, +                contextsToCompilers.put(context, new Compiler(context.instanceClazz, new Definition(entry.getValue())));, +++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/Compiler.java, +import org.elasticsearch.painless.spi.Whitelist;, +++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/Definition.java, +import org.elasticsearch.painless.spi.Whitelist;, +++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/PainlessPlugin.java, +import org.elasticsearch.painless.spi.PainlessExtension;, +import org.elasticsearch.painless.spi.Whitelist;, +import java.util.ArrayList;, +import java.util.HashMap;, +import java.util.Map;, +import java.util.ServiceLoader;, +    private final Map<ScriptContext<?>, List<Whitelist>> extendedWhitelists = new HashMap<>();, +, +        Map<ScriptContext<?>, List<Whitelist>> contextsWithWhitelists = new HashMap<>();, +        for (ScriptContext<?> context : contexts) {, +            // we might have a context that only uses the base whitelists, so would not have been filled in by reloadSPI, +            List<Whitelist> whitelists = extendedWhitelists.get(context);, +            if (whitelists == null) {]