[+++ b/server/src/main/java/org/elasticsearch/common/util/concurrent/ListenableFuture.java, +import org.elasticsearch.action.support.ContextPreservingActionListener;, +    public void addListener(ActionListener<V> listener, ExecutorService executor, ThreadContext threadContext) {, +                    listeners.add(new Tuple<>(ContextPreservingActionListener.wrapPreservingContext(listener, threadContext), executor));, +++ b/server/src/main/java/org/elasticsearch/common/util/concurrent/ListenableFuture.java, +import org.elasticsearch.action.support.ContextPreservingActionListener;, +    public void addListener(ActionListener<V> listener, ExecutorService executor, ThreadContext threadContext) {, +                    listeners.add(new Tuple<>(ContextPreservingActionListener.wrapPreservingContext(listener, threadContext), executor));, +++ b/server/src/test/java/org/elasticsearch/common/util/concurrent/ListenableFutureTests.java, +import org.apache.logging.log4j.message.ParameterizedMessage;, +import static org.hamcrest.Matchers.is;, +, +    private ThreadContext threadContext = new ThreadContext(Settings.EMPTY);, +            future.addListener(ActionListener.wrap(notifications::incrementAndGet), EsExecutors.newDirectExecutorService(), threadContext);, +            }), EsExecutors.newDirectExecutorService(), threadContext);, +            EsExecutors.daemonThreadFactory("listener"), threadContext);, +                threadContext.putTransient("key", threadNum);, +                        // we need to do more than just call onResponse as this often results in synchronous, +                        // execution of the listeners instead of actually going async, +                        final int waitTime = randomIntBetween(0, 50);, +                        Thread.sleep(waitTime);, +                        logger.info("completing the future after sleeping {}ms", waitTime);, +                        logger.info("future received response");, +                        logger.info("adding listener {}", threadNum);, +                            logger.info("listener {} received value {}", threadNum, s);, +                            assertThat(threadContext.getTransient("key"), is(threadNum));, +                            logger.error(new ParameterizedMessage("listener {} caught unexpected exception", threadNum), e);, +                        }), executorService, threadContext);, +                        logger.info("listener {} added", threadNum);, +++ b/server/src/main/java/org/elasticsearch/common/util/concurrent/ListenableFuture.java, +import org.elasticsearch.action.support.ContextPreservingActionListener;, +    public void addListener(ActionListener<V> listener, ExecutorService executor, ThreadContext threadContext) {, +                    listeners.add(new Tuple<>(ContextPreservingActionListener.wrapPreservingContext(listener, threadContext), executor));, +++ b/server/src/test/java/org/elasticsearch/common/util/concurrent/ListenableFutureTests.java, +import org.apache.logging.log4j.message.ParameterizedMessage;, +import static org.hamcrest.Matchers.is;, +, +    private ThreadContext threadContext = new ThreadContext(Settings.EMPTY);, +            future.addListener(ActionListener.wrap(notifications::incrementAndGet), EsExecutors.newDirectExecutorService(), threadContext);, +            }), EsExecutors.newDirectExecutorService(), threadContext);, +            EsExecutors.daemonThreadFactory("listener"), threadContext);, +                threadContext.putTransient("key", threadNum);, +                        // we need to do more than just call onResponse as this often results in synchronous, +                        // execution of the listeners instead of actually going async, +                        final int waitTime = randomIntBetween(0, 50);, +                        Thread.sleep(waitTime);, +                        logger.info("completing the future after sleeping {}ms", waitTime);, +                        logger.info("future received response");, +                        logger.info("adding listener {}", threadNum);, +                            logger.info("listener {} received value {}", threadNum, s);, +                            assertThat(threadContext.getTransient("key"), is(threadNum));, +                            logger.error(new ParameterizedMessage("listener {} caught unexpected exception", threadNum), e);, +                        }), executorService, threadContext);, +                        logger.info("listener {} added", threadNum);, +++ b/x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authc/support/CachingUsernamePasswordRealm.java, +                }), threadPool.executor(ThreadPool.Names.GENERIC), threadPool.getThreadContext());, +            }, listener::onFailure), threadPool.executor(ThreadPool.Names.GENERIC), threadPool.getThreadContext());, +++ b/server/src/main/java/org/elasticsearch/common/util/concurrent/ListenableFuture.java, +import org.elasticsearch.action.support.ContextPreservingActionListener;, +    public void addListener(ActionListener<V> listener, ExecutorService executor, ThreadContext threadContext) {, +                    listeners.add(new Tuple<>(ContextPreservingActionListener.wrapPreservingContext(listener, threadContext), executor));, +++ b/server/src/test/java/org/elasticsearch/common/util/concurrent/ListenableFutureTests.java, +import org.apache.logging.log4j.message.ParameterizedMessage;, +import static org.hamcrest.Matchers.is;, +, +    private ThreadContext threadContext = new ThreadContext(Settings.EMPTY);, +            future.addListener(ActionListener.wrap(notifications::incrementAndGet), EsExecutors.newDirectExecutorService(), threadContext);, +            }), EsExecutors.newDirectExecutorService(), threadContext);, +            EsExecutors.daemonThreadFactory("listener"), threadContext);, +                threadContext.putTransient("key", threadNum);, +                        // we need to do more than just call onResponse as this often results in synchronous, +                        // execution of the listeners instead of actually going async, +                        final int waitTime = randomIntBetween(0, 50);, +                        Thread.sleep(waitTime);, +                        logger.info("completing the future after sleeping {}ms", waitTime);, +                        logger.info("future received response");, +                        logger.info("adding listener {}", threadNum);, +                            logger.info("listener {} received value {}", threadNum, s);, +                            assertThat(threadContext.getTransient("key"), is(threadNum));, +                            logger.error(new ParameterizedMessage("listener {} caught unexpected exception", threadNum), e);, +                        }), executorService, threadContext);, +                        logger.info("listener {} added", threadNum);, +++ b/x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authc/support/CachingUsernamePasswordRealm.java, +                }), threadPool.executor(ThreadPool.Names.GENERIC), threadPool.getThreadContext());, +            }, listener::onFailure), threadPool.executor(ThreadPool.Names.GENERIC), threadPool.getThreadContext());, +++ b/x-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/authc/support/CachingUsernamePasswordRealmTests.java, +            final int threadNum = i;, +                threadPool.getThreadContext().putTransient("key", threadNum);, +                            assertThat(threadPool.getThreadContext().getTransient("key"), is(threadNum));, +            final int threadNum = i;, +                    threadPool.getThreadContext().putTransient("key", threadNum);, +                            assertThat(threadPool.getThreadContext().getTransient("key"), is(threadNum));]