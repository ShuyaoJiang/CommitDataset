[+++ b/core/src/main/java/org/elasticsearch/index/engine/InternalEngine.java, +++ b/core/src/main/java/org/elasticsearch/index/engine/InternalEngine.java, +++ b/core/src/main/java/org/elasticsearch/index/shard/IndexShard.java, +                if (newRouting.primary() && currentRouting.isRelocationTarget() == false) {, +                                 * replaying the translog and marking any operations there are completed., +                                final Engine engine = getEngine();, +                                engine.restoreLocalCheckpointFromTranslog();, +                                /* Rolling the translog generation is not strictly needed here (as we will never have collisions between, +                                 * sequence numbers in a translog generation in a new primary as it takes the last known sequence number, +                                 * as a starting point), but it simplifies reasoning about the relationship between primary terms and, +                                 * translog generations., +                                 */, +                                engine.rollTranslogGeneration();, +                                engine.fillSeqNoGaps(newPrimaryTerm);, +                                engine.seqNoService().updateLocalCheckpointForShard(currentRouting.allocationId().getId(),, +        assertSequenceNumbersInCommit();, +    }, +, +    private boolean assertSequenceNumbersInCommit() throws IOException {, +        final Map<String, String> userData = SegmentInfos.readLatestCommit(store.directory()).getUserData();, +        assert userData.containsKey(SequenceNumbers.LOCAL_CHECKPOINT_KEY) : "commit point doesn't contains a local checkpoint";, +        assert userData.containsKey(SequenceNumbers.MAX_SEQ_NO) : "commit point doesn't contains a maximum sequence number";, +        assert userData.containsKey(Engine.HISTORY_UUID_KEY) : "commit point doesn't contains a history uuid";, +        assert userData.get(Engine.HISTORY_UUID_KEY).equals(getHistoryUUID()) : "commit point history uuid [", +            + userData.get(Engine.HISTORY_UUID_KEY) + "] is different than engine [" + getHistoryUUID() + "]";, +        return true;, +++ b/core/src/main/java/org/elasticsearch/index/engine/InternalEngine.java, +++ b/core/src/main/java/org/elasticsearch/index/shard/IndexShard.java, +                if (newRouting.primary() && currentRouting.isRelocationTarget() == false) {, +                                 * replaying the translog and marking any operations there are completed., +                                final Engine engine = getEngine();, +                                engine.restoreLocalCheckpointFromTranslog();, +                                /* Rolling the translog generation is not strictly needed here (as we will never have collisions between, +                                 * sequence numbers in a translog generation in a new primary as it takes the last known sequence number, +                                 * as a starting point), but it simplifies reasoning about the relationship between primary terms and, +                                 * translog generations., +                                 */, +                                engine.rollTranslogGeneration();, +                                engine.fillSeqNoGaps(newPrimaryTerm);, +                                engine.seqNoService().updateLocalCheckpointForShard(currentRouting.allocationId().getId(),, +        assertSequenceNumbersInCommit();, +    }, +, +    private boolean assertSequenceNumbersInCommit() throws IOException {, +        final Map<String, String> userData = SegmentInfos.readLatestCommit(store.directory()).getUserData();, +        assert userData.containsKey(SequenceNumbers.LOCAL_CHECKPOINT_KEY) : "commit point doesn't contains a local checkpoint";, +        assert userData.containsKey(SequenceNumbers.MAX_SEQ_NO) : "commit point doesn't contains a maximum sequence number";, +        assert userData.containsKey(Engine.HISTORY_UUID_KEY) : "commit point doesn't contains a history uuid";, +        assert userData.get(Engine.HISTORY_UUID_KEY).equals(getHistoryUUID()) : "commit point history uuid [", +            + userData.get(Engine.HISTORY_UUID_KEY) + "] is different than engine [" + getHistoryUUID() + "]";, +        return true;, +++ b/core/src/main/java/org/elasticsearch/indices/recovery/RecoverySourceHandler.java, +            final long requiredSeqNoRangeStart;, +                requiredSeqNoRangeStart = startingSeqNo;, +                // we set this to 0 to create a translog roughly according to the retention policy, +                // on the target. Note that it will still filter out legacy operations with no sequence numbers, +                startingSeqNo = 0;, +                // but we must have everything above the local checkpoint in the commit, +                requiredSeqNoRangeStart =, +                    Long.parseLong(phase1Snapshot.getIndexCommit().getUserData().get(SequenceNumbers.LOCAL_CHECKPOINT_KEY)) + 1;, +            assert startingSeqNo >= 0 : "startingSeqNo must be non negative. got: " + startingSeqNo;, +            assert requiredSeqNoRangeStart >= startingSeqNo : "requiredSeqNoRangeStart [" + requiredSeqNoRangeStart + "] is lower than [", +                + startingSeqNo + "]";, +            final long endingSeqNo = shard.seqNoStats().getMaxSeqNo();, +            /*, +             * We need to wait for all operations up to the current max to complete, otherwise we can not guarantee that all, +             * operations in the required range will be available for replaying from the translog of the source., +             */, +            cancellableThreads.execute(() -> shard.waitForOpsToComplete(endingSeqNo));, +, +            logger.trace("all operations up to [{}] completed, which will be used as an ending sequence number", endingSeqNo);, +, +                targetLocalCheckpoint = phase2(startingSeqNo, requiredSeqNoRangeStart, endingSeqNo, snapshot);, +     * translog contains all operations above the local checkpoint on the target. We already know the that translog contains or will contain, +     * all ops above the source local checkpoint, so we can stop check there., +        final long localCheckpoint = shard.getLocalCheckpoint();, +        logger.trace("testing sequence numbers in range: [{}, {}]", startingSeqNo, localCheckpoint);, +        if (startingSeqNo - 1 <= localCheckpoint) {, +            return tracker.getCheckpoint() >= localCheckpoint;, +     * @param requiredSeqNoRangeStart the lower sequence number of the required range (ending with endingSeqNo), +     * @param endingSeqNo             the highest sequence number that should be sent, +    long phase2(final long startingSeqNo, long requiredSeqNoRangeStart, long endingSeqNo, final Translog.Snapshot snapshot), +        throws IOException {, +        logger.trace("recovery [phase2]: sending transaction log operations (seq# from [" +  startingSeqNo  + "], " +, +            "required [" + requiredSeqNoRangeStart + ":" + endingSeqNo + "]");, +        final SendSnapshotResult result = sendSnapshot(startingSeqNo, requiredSeqNoRangeStart, endingSeqNo, snapshot);, +     * @param requiredSeqNoRangeStart the lower sequence number of the required range, +     * @param endingSeqNo             the upper bound of the sequence number range to be sent (inclusive), +     * @param snapshot                the translog snapshot to replay operations from  @return the local checkpoint on the target and the, +     *                                total number of operations sent, +    protected SendSnapshotResult sendSnapshot(final long startingSeqNo, long requiredSeqNoRangeStart, long endingSeqNo,, +                                              final Translog.Snapshot snapshot) throws IOException {, +        assert requiredSeqNoRangeStart <= endingSeqNo + 1:, +            "requiredSeqNoRangeStart " + requiredSeqNoRangeStart + " is larger than endingSeqNo " + endingSeqNo;, +        assert startingSeqNo <= requiredSeqNoRangeStart :, +            "startingSeqNo " + startingSeqNo + " is larger than requiredSeqNoRangeStart " + requiredSeqNoRangeStart;, +        final LocalCheckpointTracker requiredOpsTracker = new LocalCheckpointTracker(endingSeqNo, requiredSeqNoRangeStart - 1);, +, +            if (seqNo < startingSeqNo || seqNo > endingSeqNo) {, +            requiredOpsTracker.markSeqNoAsCompleted(seqNo);]