[+++ b/buildSrc/src/main/resources/checkstyle_suppressions.xml, +++ b/buildSrc/src/main/resources/checkstyle_suppressions.xml, +++ b/server/src/main/java/org/elasticsearch/index/mapper/CompletionFieldMapper.java, +        public Mapper.Builder<?, ?> parse(String name, Map<String, Object> node, ParserContext parserContext), +                throws MapperParsingException {, +                throw new IllegalArgumentException(Fields.MAX_INPUT_LENGTH.getPreferredName(), +                    + " must be > 0 but was [" + maxInputLength + "]");, +            return new CompletionFieldMapper(name, this.fieldType, context.indexSettings(),, +                multiFieldsBuilder.build(this, context), copyTo, maxInputLength);, +    public CompletionFieldMapper(String simpleName, MappedFieldType fieldType, Settings indexSettings,, +                                 MultiFields multiFields, CopyTo copyTo, int maxInputLength) {, +    private void parse(ParseContext parseContext, Token token,, +                       XContentParser parser, Map<String, CompletionInputMetaData> inputMap) throws IOException {, +                        throw new IllegalArgumentException("unknown field name [" + currentFieldName, +                            + "], must be one of " + ALLOWED_CONTENT_FIELD_NAMES);, +                                    throw new IllegalArgumentException("input array must have string values, but was [", +                                        + token.name() + "]");, +                        // always parse a long to make sure we don't get overflow, +                        if (weightValue.longValue() < 0 || weightValue.longValue() > Integer.MAX_VALUE) {, +                            throw new IllegalArgumentException("weight must be in the interval [0..2147483647], but was [", +                                + weightValue.longValue() + "]");, +            throw new ParsingException(parser.getTokenLocation(), "failed to parse [" + parser.currentName(), +                + "]: expected text or object, but got " + token.name());, +++ b/buildSrc/src/main/resources/checkstyle_suppressions.xml, +++ b/server/src/main/java/org/elasticsearch/index/mapper/CompletionFieldMapper.java, +        public Mapper.Builder<?, ?> parse(String name, Map<String, Object> node, ParserContext parserContext), +                throws MapperParsingException {, +                throw new IllegalArgumentException(Fields.MAX_INPUT_LENGTH.getPreferredName(), +                    + " must be > 0 but was [" + maxInputLength + "]");, +            return new CompletionFieldMapper(name, this.fieldType, context.indexSettings(),, +                multiFieldsBuilder.build(this, context), copyTo, maxInputLength);, +    public CompletionFieldMapper(String simpleName, MappedFieldType fieldType, Settings indexSettings,, +                                 MultiFields multiFields, CopyTo copyTo, int maxInputLength) {, +    private void parse(ParseContext parseContext, Token token,, +                       XContentParser parser, Map<String, CompletionInputMetaData> inputMap) throws IOException {, +                        throw new IllegalArgumentException("unknown field name [" + currentFieldName, +                            + "], must be one of " + ALLOWED_CONTENT_FIELD_NAMES);, +                                    throw new IllegalArgumentException("input array must have string values, but was [", +                                        + token.name() + "]");, +                        // always parse a long to make sure we don't get overflow, +                        if (weightValue.longValue() < 0 || weightValue.longValue() > Integer.MAX_VALUE) {, +                            throw new IllegalArgumentException("weight must be in the interval [0..2147483647], but was [", +                                + weightValue.longValue() + "]");, +            throw new ParsingException(parser.getTokenLocation(), "failed to parse [" + parser.currentName(), +                + "]: expected text or object, but got " + token.name());, +++ b/server/src/main/java/org/elasticsearch/index/mapper/DocumentMapper.java, +            final DocumentMapper existingMapper = mapperService.documentMapper(type);, +            final Map<String, TypeParser> metadataMapperParsers = mapperService.mapperRegistry.getMetadataMapperParsers();, +            for (Map.Entry<String, MetadataFieldMapper.TypeParser> entry : metadataMapperParsers.entrySet()) {, +++ b/buildSrc/src/main/resources/checkstyle_suppressions.xml, +++ b/server/src/main/java/org/elasticsearch/index/mapper/CompletionFieldMapper.java, +        public Mapper.Builder<?, ?> parse(String name, Map<String, Object> node, ParserContext parserContext), +                throws MapperParsingException {, +                throw new IllegalArgumentException(Fields.MAX_INPUT_LENGTH.getPreferredName(), +                    + " must be > 0 but was [" + maxInputLength + "]");, +            return new CompletionFieldMapper(name, this.fieldType, context.indexSettings(),, +                multiFieldsBuilder.build(this, context), copyTo, maxInputLength);, +    public CompletionFieldMapper(String simpleName, MappedFieldType fieldType, Settings indexSettings,, +                                 MultiFields multiFields, CopyTo copyTo, int maxInputLength) {, +    private void parse(ParseContext parseContext, Token token,, +                       XContentParser parser, Map<String, CompletionInputMetaData> inputMap) throws IOException {, +                        throw new IllegalArgumentException("unknown field name [" + currentFieldName, +                            + "], must be one of " + ALLOWED_CONTENT_FIELD_NAMES);, +                                    throw new IllegalArgumentException("input array must have string values, but was [", +                                        + token.name() + "]");, +                        // always parse a long to make sure we don't get overflow, +                        if (weightValue.longValue() < 0 || weightValue.longValue() > Integer.MAX_VALUE) {, +                            throw new IllegalArgumentException("weight must be in the interval [0..2147483647], but was [", +                                + weightValue.longValue() + "]");, +            throw new ParsingException(parser.getTokenLocation(), "failed to parse [" + parser.currentName(), +                + "]: expected text or object, but got " + token.name());, +++ b/server/src/main/java/org/elasticsearch/index/mapper/DocumentMapper.java, +            final DocumentMapper existingMapper = mapperService.documentMapper(type);, +            final Map<String, TypeParser> metadataMapperParsers = mapperService.mapperRegistry.getMetadataMapperParsers();, +            for (Map.Entry<String, MetadataFieldMapper.TypeParser> entry : metadataMapperParsers.entrySet()) {, +++ b/server/src/main/java/org/elasticsearch/index/mapper/DocumentParser.java, +            throw new MapperParsingException("Type mismatch, provide type [" + source.type() + "] but mapper is of type [", +                + docMapper.type() + "]");, +                throw new MapperParsingException("Malformed content, after first object, either the type field", +                    + " or the actual properties should exist");, +            throw new MapperParsingException("object mapping for [" + mapper.name() + "] tried to parse field [" + currentFieldName, +                + "] as object, but found a concrete value");, +    private static void innerParseObject(ParseContext context, ObjectMapper mapper, XContentParser parser,, +                                         String currentFieldName, XContentParser.Token token) throws IOException {, +                    throw new MapperParsingException("Field [" + currentFieldName + "] is a metadata field and cannot be added inside", +                        + " a document. Use the index API request parameters.");, +                throw new MapperParsingException("object mapping for [" + mapper.name() + "] tried to parse field [" + currentFieldName, +                    + "] as object, but got EOF, has a concrete value been provided to it?");, +    private static void parseNonDynamicArray(ParseContext context, ObjectMapper mapper,, +                                             String lastFieldName, String arrayFieldName) throws IOException {, +                throw new MapperParsingException("object mapping for [" + mapper.name() + "] with array for [" + arrayFieldName, +                    + "] tried to parse as array, but got EOF, is there a mismatch in types for the same field?");, +    private static void parseValue(final ParseContext context, ObjectMapper parentMapper,, +                                   String currentFieldName, XContentParser.Token token) throws IOException {, +            throw new MapperParsingException("object mapping [" + parentMapper.name() + "] trying to serialize a value with", +                + " no field associated with it, current value [" + context.parser().textOrNull() + "]");, +    private static Mapper.Builder<?,?> createBuilderFromFieldType(final ParseContext context,, +                                                                  MappedFieldType fieldType, String currentFieldName) {, +    private static Mapper.Builder<?,?> createBuilderFromDynamicValue(final ParseContext context,, +                                                                     XContentParser.Token token,]