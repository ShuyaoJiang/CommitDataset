[+++ b/qa/rolling-upgrade/src/test/java/org/elasticsearch/upgrades/RecoveryIT.java, +++ b/qa/rolling-upgrade/src/test/java/org/elasticsearch/upgrades/RecoveryIT.java, +++ b/server/src/main/java/org/elasticsearch/index/engine/Engine.java, +     * This method replays translog to restore the Lucene index which might be reverted previously., +     * This ensures that all acknowledged writes are restored correctly when this engine is promoted., +     * @return the number of translog operations have been recovered, +    public abstract int restoreLocalHistoryFromTranslog(TranslogRecoveryRunner translogRecoveryRunner) throws IOException;, +++ b/qa/rolling-upgrade/src/test/java/org/elasticsearch/upgrades/RecoveryIT.java, +++ b/server/src/main/java/org/elasticsearch/index/engine/Engine.java, +     * This method replays translog to restore the Lucene index which might be reverted previously., +     * This ensures that all acknowledged writes are restored correctly when this engine is promoted., +     * @return the number of translog operations have been recovered, +    public abstract int restoreLocalHistoryFromTranslog(TranslogRecoveryRunner translogRecoveryRunner) throws IOException;, +++ b/server/src/main/java/org/elasticsearch/index/engine/InternalEngine.java, +    public int restoreLocalHistoryFromTranslog(TranslogRecoveryRunner translogRecoveryRunner) throws IOException {, +        try (ReleasableLock ignored = readLock.acquire()) {, +                return translogRecoveryRunner.run(this, snapshot);, +++ b/qa/rolling-upgrade/src/test/java/org/elasticsearch/upgrades/RecoveryIT.java, +++ b/server/src/main/java/org/elasticsearch/index/engine/Engine.java, +     * This method replays translog to restore the Lucene index which might be reverted previously., +     * This ensures that all acknowledged writes are restored correctly when this engine is promoted., +     * @return the number of translog operations have been recovered, +    public abstract int restoreLocalHistoryFromTranslog(TranslogRecoveryRunner translogRecoveryRunner) throws IOException;, +++ b/server/src/main/java/org/elasticsearch/index/engine/InternalEngine.java, +    public int restoreLocalHistoryFromTranslog(TranslogRecoveryRunner translogRecoveryRunner) throws IOException {, +        try (ReleasableLock ignored = readLock.acquire()) {, +                return translogRecoveryRunner.run(this, snapshot);, +++ b/server/src/main/java/org/elasticsearch/index/engine/ReadOnlyEngine.java, +    public int restoreLocalHistoryFromTranslog(TranslogRecoveryRunner translogRecoveryRunner) {, +        return 0;, +++ b/qa/rolling-upgrade/src/test/java/org/elasticsearch/upgrades/RecoveryIT.java, +++ b/server/src/main/java/org/elasticsearch/index/engine/Engine.java, +     * This method replays translog to restore the Lucene index which might be reverted previously., +     * This ensures that all acknowledged writes are restored correctly when this engine is promoted., +     * @return the number of translog operations have been recovered, +    public abstract int restoreLocalHistoryFromTranslog(TranslogRecoveryRunner translogRecoveryRunner) throws IOException;, +++ b/server/src/main/java/org/elasticsearch/index/engine/InternalEngine.java, +    public int restoreLocalHistoryFromTranslog(TranslogRecoveryRunner translogRecoveryRunner) throws IOException {, +        try (ReleasableLock ignored = readLock.acquire()) {, +                return translogRecoveryRunner.run(this, snapshot);, +++ b/server/src/main/java/org/elasticsearch/index/engine/ReadOnlyEngine.java, +    public int restoreLocalHistoryFromTranslog(TranslogRecoveryRunner translogRecoveryRunner) {, +        return 0;, +++ b/server/src/main/java/org/elasticsearch/index/shard/IndexShard.java, +                                 * If this shard was serving as a replica shard when another shard was promoted to primary then, +                                 * its Lucene index was reset during the primary term transition. In particular, the Lucene index, +                                 * on this shard was reset to the global checkpoint and the operations above the local checkpoint, +                                 * were reverted. If the other shard that was promoted to primary subsequently fails before the, +                                 * primary/replica re-sync completes successfully and we are now being promoted, we have to restore, +                                 * the reverted operations on this shard by replaying the translog to avoid losing acknowledged writes., +                                engine.restoreLocalHistoryFromTranslog((resettingEngine, snapshot) ->, +                                    runTranslogRecovery(resettingEngine, snapshot, Engine.Operation.Origin.LOCAL_RESET, () -> {}));, +            } else if (origin == Engine.Operation.Origin.REPLICA) {, +            } else {, +                assert origin == Engine.Operation.Origin.LOCAL_RESET;, +                assert getActiveOperationsCount() == 0 : "Ongoing writes [" + getActiveOperations() + "]";, +++ b/qa/rolling-upgrade/src/test/java/org/elasticsearch/upgrades/RecoveryIT.java, +++ b/server/src/main/java/org/elasticsearch/index/engine/Engine.java, +     * This method replays translog to restore the Lucene index which might be reverted previously., +     * This ensures that all acknowledged writes are restored correctly when this engine is promoted., +     * @return the number of translog operations have been recovered, +    public abstract int restoreLocalHistoryFromTranslog(TranslogRecoveryRunner translogRecoveryRunner) throws IOException;, +++ b/server/src/main/java/org/elasticsearch/index/engine/InternalEngine.java, +    public int restoreLocalHistoryFromTranslog(TranslogRecoveryRunner translogRecoveryRunner) throws IOException {, +        try (ReleasableLock ignored = readLock.acquire()) {, +                return translogRecoveryRunner.run(this, snapshot);, +++ b/server/src/main/java/org/elasticsearch/index/engine/ReadOnlyEngine.java, +    public int restoreLocalHistoryFromTranslog(TranslogRecoveryRunner translogRecoveryRunner) {, +        return 0;, +++ b/server/src/main/java/org/elasticsearch/index/shard/IndexShard.java, +                                 * If this shard was serving as a replica shard when another shard was promoted to primary then, +                                 * its Lucene index was reset during the primary term transition. In particular, the Lucene index, +                                 * on this shard was reset to the global checkpoint and the operations above the local checkpoint, +                                 * were reverted. If the other shard that was promoted to primary subsequently fails before the, +                                 * primary/replica re-sync completes successfully and we are now being promoted, we have to restore, +                                 * the reverted operations on this shard by replaying the translog to avoid losing acknowledged writes., +                                engine.restoreLocalHistoryFromTranslog((resettingEngine, snapshot) ->, +                                    runTranslogRecovery(resettingEngine, snapshot, Engine.Operation.Origin.LOCAL_RESET, () -> {}));, +            } else if (origin == Engine.Operation.Origin.REPLICA) {, +            } else {, +                assert origin == Engine.Operation.Origin.LOCAL_RESET;, +                assert getActiveOperationsCount() == 0 : "Ongoing writes [" + getActiveOperations() + "]";, +++ b/server/src/test/java/org/elasticsearch/index/engine/InternalEngineTests.java, +import org.elasticsearch.index.seqno.SeqNoStats;, +    public void testRestoreLocalHistoryFromTranslog() throws IOException {, +        final AtomicLong globalCheckpoint = new AtomicLong(SequenceNumbers.NO_OPS_PERFORMED);, +        try (Store store = createStore()) {, +            final ArrayList<Long> seqNos = new ArrayList<>();, +            final int numOps = randomIntBetween(0, 1024);, +            for (int i = 0; i < numOps; i++) {, +                if (rarely()) {, +                seqNos.add((long) i);, +            final EngineConfig engineConfig;, +            final SeqNoStats prevSeqNoStats;, +            final List<DocIdSeqNoAndTerm> prevDocs;, +            final int totalTranslogOps;, +            try (InternalEngine engine = createEngine(store, createTempDir(), globalCheckpoint::get)) {, +                engineConfig = engine.config();, +                    engine.index(replicaIndexForDoc(doc, 1, seqNo, false));, +                        engine.rollTranslogGeneration();]