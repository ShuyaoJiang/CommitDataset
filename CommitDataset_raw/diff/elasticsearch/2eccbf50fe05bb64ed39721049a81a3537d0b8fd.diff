[+++ b/src/main/java/org/elasticsearch/index/store/Store.java, +import java.util.zip.Adler32;, +        return checkIntegrity(md, directory());, +    }, +, +    public static boolean checkIntegrity(final StoreFileMetaData md, final Directory directory) {, +        try (IndexInput input = directory.openInput(md.name(), IOContext.READONCE)) {, +            if (input.length() != md.length()) { // first check the length no matter how old this file is, +            if (md.writtenBy() != null && md.writtenBy().onOrAfter(Version.LUCENE_4_8_0)) {, +                return Store.digestToString(CodecUtil.checksumEntireFile(input)).equals(md.checksum());, +            } else if (md.hasLegacyChecksum()) {, +                // legacy checksum verification - no footer that we need to omit in the checksum!, +                final Checksum checksum = new Adler32();, +                final byte[] buffer = new byte[md.length() > 4096 ? 4096 : (int) md.length()];, +                final long len = input.length();, +                long read = 0;, +                while (len > read) {, +                    final long bytesLeft = len - read;, +                    final int bytesToRead = bytesLeft < buffer.length ? (int) bytesLeft : buffer.length;, +                    input.readBytes(buffer, 0, bytesToRead, false);, +                    checksum.update(buffer, 0, bytesToRead);, +                    read += bytesToRead;, +                }, +                return Store.digestToString(checksum.getValue()).equals(md.checksum());, +            }, +        } catch (IOException ex) {, +            return false;, +++ b/src/main/java/org/elasticsearch/index/store/Store.java, +import java.util.zip.Adler32;, +        return checkIntegrity(md, directory());, +    }, +, +    public static boolean checkIntegrity(final StoreFileMetaData md, final Directory directory) {, +        try (IndexInput input = directory.openInput(md.name(), IOContext.READONCE)) {, +            if (input.length() != md.length()) { // first check the length no matter how old this file is, +            if (md.writtenBy() != null && md.writtenBy().onOrAfter(Version.LUCENE_4_8_0)) {, +                return Store.digestToString(CodecUtil.checksumEntireFile(input)).equals(md.checksum());, +            } else if (md.hasLegacyChecksum()) {, +                // legacy checksum verification - no footer that we need to omit in the checksum!, +                final Checksum checksum = new Adler32();, +                final byte[] buffer = new byte[md.length() > 4096 ? 4096 : (int) md.length()];, +                final long len = input.length();, +                long read = 0;, +                while (len > read) {, +                    final long bytesLeft = len - read;, +                    final int bytesToRead = bytesLeft < buffer.length ? (int) bytesLeft : buffer.length;, +                    input.readBytes(buffer, 0, bytesToRead, false);, +                    checksum.update(buffer, 0, bytesToRead);, +                    read += bytesToRead;, +                }, +                return Store.digestToString(checksum.getValue()).equals(md.checksum());, +            }, +        } catch (IOException ex) {, +            return false;, +++ b/src/test/java/org/elasticsearch/index/store/StoreTest.java, +import com.carrotsearch.randomizedtesting.annotations.Repeat;, +import java.util.zip.Adler32;, +    public void testCheckIntegrity() throws IOException {, +        Directory dir = newDirectory();, +        long luceneFileLength = 0;, +, +        try (IndexOutput output = dir.createOutput("lucene_checksum.bin", IOContext.DEFAULT)) {, +            int iters = scaledRandomIntBetween(10, 100);, +            for (int i = 0; i < iters; i++) {, +                BytesRef bytesRef = new BytesRef(TestUtil.randomRealisticUnicodeString(random(), 10, 1024));, +                output.writeBytes(bytesRef.bytes, bytesRef.offset, bytesRef.length);, +                luceneFileLength += bytesRef.length;, +            }, +            CodecUtil.writeFooter(output);, +            luceneFileLength += CodecUtil.footerLength();, +, +        }, +, +        final Adler32 adler32 = new Adler32();, +        long legacyFileLength = 0;, +        try (IndexOutput output = dir.createOutput("legacy.bin", IOContext.DEFAULT)) {, +            int iters = scaledRandomIntBetween(10, 100);, +            for (int i = 0; i < iters; i++) {, +                BytesRef bytesRef = new BytesRef(TestUtil.randomRealisticUnicodeString(random(), 10, 1024));, +                output.writeBytes(bytesRef.bytes, bytesRef.offset, bytesRef.length);, +                adler32.update(bytesRef.bytes, bytesRef.offset, bytesRef.length);, +                legacyFileLength += bytesRef.length;, +            }, +        }, +        final long luceneChecksum;, +        final long adler32LegacyChecksum = adler32.getValue();, +        try(IndexInput indexInput = dir.openInput("lucene_checksum.bin", IOContext.DEFAULT)) {, +            assertEquals(luceneFileLength, indexInput.length());, +            luceneChecksum = CodecUtil.retrieveChecksum(indexInput);, +        }, +, +        { // positive check, +            StoreFileMetaData lucene = new StoreFileMetaData("lucene_checksum.bin", luceneFileLength, Store.digestToString(luceneChecksum), Version.LUCENE_4_8_0);, +            StoreFileMetaData legacy = new StoreFileMetaData("legacy.bin", legacyFileLength, Store.digestToString(adler32LegacyChecksum));, +            assertTrue(legacy.hasLegacyChecksum());, +            assertFalse(lucene.hasLegacyChecksum());, +            assertTrue(Store.checkIntegrity(lucene, dir));, +            assertTrue(Store.checkIntegrity(legacy, dir));, +        }, +]