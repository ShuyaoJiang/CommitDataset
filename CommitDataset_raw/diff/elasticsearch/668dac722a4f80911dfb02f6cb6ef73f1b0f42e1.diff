[+++ b/core/src/main/java/org/elasticsearch/index/engine/Engine.java, +                return getSearcherManager().isSearcherCurrent() == false;, +++ b/core/src/main/java/org/elasticsearch/index/engine/Engine.java, +                return getSearcherManager().isSearcherCurrent() == false;, +++ b/core/src/main/java/org/elasticsearch/index/engine/EngineSearcher.java, +            // This means there's a bug somewhere: don't suppress it, +            throw new AssertionError(e);, +++ b/core/src/main/java/org/elasticsearch/index/engine/Engine.java, +                return getSearcherManager().isSearcherCurrent() == false;, +++ b/core/src/main/java/org/elasticsearch/index/engine/EngineSearcher.java, +            // This means there's a bug somewhere: don't suppress it, +            throw new AssertionError(e);, +++ b/core/src/main/java/org/elasticsearch/index/engine/InternalEngine.java, +            failOnTragicEvent(e);, +            throw e;, +            failOnTragicEvent(e);, +            throw e;, +        } catch (AlreadyClosedException ex) {, +            /* in this case we first check if the engine is still open. If so this exception is just fine, +             * and expected. We don't hold any locks while we block on forceMerge otherwise it would block, +             * closing the engine as well. If we are not closed we pass it on to failOnTragicEvent which ensures, +             * we are handling a tragic even exception here */, +            ensureOpen();, +            failOnTragicEvent(ex);, +            throw ex;, +    private void failOnTragicEvent(AlreadyClosedException ex) {, +        } else {, +            // this smells like a bug - we only expect ACE if we are in a fatal case ie. either translog or IW is closed by, +            // a tragic event or has closed itself. if that is not the case we are in a buggy state and raise an assertion error, +            throw new AssertionError("Unexpected AlreadyClosedException", ex);, +    }, +, +    @Override, +    protected boolean maybeFailEngine(String source, Exception e) {, +        boolean shouldFail = super.maybeFailEngine(source, e);, +        if (shouldFail) {, +            return true;, +        }, +        // Check for AlreadyClosedException -- ACE is a very special, +        // exception that should only be thrown in a tragic event. we pass on the checks to failOnTragicEvent which will, +        // throw and AssertionError if the tragic event condition is not met., +        if (e instanceof AlreadyClosedException) {, +            failOnTragicEvent((AlreadyClosedException)e);, +        // We don't guard w/ readLock here, so we could throw AlreadyClosedException, +                } catch (AlreadyClosedException ex) {, +                    failOnTragicEvent(ex);, +                    throw ex;, +++ b/core/src/main/java/org/elasticsearch/index/engine/Engine.java, +                return getSearcherManager().isSearcherCurrent() == false;, +++ b/core/src/main/java/org/elasticsearch/index/engine/EngineSearcher.java, +            // This means there's a bug somewhere: don't suppress it, +            throw new AssertionError(e);, +++ b/core/src/main/java/org/elasticsearch/index/engine/InternalEngine.java, +            failOnTragicEvent(e);, +            throw e;, +            failOnTragicEvent(e);, +            throw e;, +        } catch (AlreadyClosedException ex) {, +            /* in this case we first check if the engine is still open. If so this exception is just fine, +             * and expected. We don't hold any locks while we block on forceMerge otherwise it would block, +             * closing the engine as well. If we are not closed we pass it on to failOnTragicEvent which ensures, +             * we are handling a tragic even exception here */, +            ensureOpen();, +            failOnTragicEvent(ex);, +            throw ex;, +    private void failOnTragicEvent(AlreadyClosedException ex) {, +        } else {, +            // this smells like a bug - we only expect ACE if we are in a fatal case ie. either translog or IW is closed by, +            // a tragic event or has closed itself. if that is not the case we are in a buggy state and raise an assertion error, +            throw new AssertionError("Unexpected AlreadyClosedException", ex);, +    }, +, +    @Override, +    protected boolean maybeFailEngine(String source, Exception e) {, +        boolean shouldFail = super.maybeFailEngine(source, e);, +        if (shouldFail) {, +            return true;, +        }, +        // Check for AlreadyClosedException -- ACE is a very special, +        // exception that should only be thrown in a tragic event. we pass on the checks to failOnTragicEvent which will, +        // throw and AssertionError if the tragic event condition is not met., +        if (e instanceof AlreadyClosedException) {, +            failOnTragicEvent((AlreadyClosedException)e);, +        // We don't guard w/ readLock here, so we could throw AlreadyClosedException, +                } catch (AlreadyClosedException ex) {, +                    failOnTragicEvent(ex);, +                    throw ex;, +++ b/core/src/main/java/org/elasticsearch/index/engine/ShadowEngine.java, +            // This means there's a bug somewhere: don't suppress it, +            throw new AssertionError(e);]