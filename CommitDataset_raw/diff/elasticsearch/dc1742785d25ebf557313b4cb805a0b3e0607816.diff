[+++ b/src/main/java/org/elasticsearch/index/mapper/core/StringFieldMapper.java, +        if (searchQuotedAnalyzer != null && !searchQuotedAnalyzer.name().equals(searchAnalyzer.name())) {, +++ b/src/main/java/org/elasticsearch/index/mapper/core/StringFieldMapper.java, +        if (searchQuotedAnalyzer != null && !searchQuotedAnalyzer.name().equals(searchAnalyzer.name())) {, +++ b/src/test/java/org/elasticsearch/index/mapper/string/SimpleStringMappingTests.java, +import com.google.common.collect.Lists;, +, +import org.elasticsearch.common.xcontent.XContentBuilder;, +import org.elasticsearch.common.xcontent.json.JsonXContent;, +import java.util.Map;, +    public void testSearchQuoteAnalyzerSerialization() throws Exception {, +        // Cases where search_quote_analyzer should not be added to the mapping., +        String mapping = XContentFactory.jsonBuilder().startObject().startObject("type"), +                .startObject("properties"), +                .startObject("field1"), +                    .field("type", "string"), +                    .field("position_offset_gap", 1000), +                .endObject(), +                .startObject("field2"), +                    .field("type", "string"), +                    .field("position_offset_gap", 1000), +                    .field("analyzer", "standard"), +                .endObject(), +                .startObject("field3"), +                    .field("type", "string"), +                    .field("position_offset_gap", 1000), +                    .field("analyzer", "standard"), +                    .field("search_analyzer", "simple"), +                .endObject(), +                .startObject("field4"), +                    .field("type", "string"), +                    .field("position_offset_gap", 1000), +                    .field("analyzer", "standard"), +                    .field("search_analyzer", "simple"), +                    .field("search_quote_analyzer", "simple"), +                .endObject(), +                .endObject(), +                .endObject().endObject().string();, +, +        DocumentMapper mapper = parser.parse(mapping);, +        for (String fieldName : Lists.newArrayList("field1", "field2", "field3", "field4")) {, +            Map<String, Object> serializedMap = getSerializedMap(fieldName, mapper);, +            assertFalse(serializedMap.containsKey("search_quote_analyzer"));, +        }, +        , +        // Cases where search_quote_analyzer should be present., +        mapping = XContentFactory.jsonBuilder().startObject().startObject("type"), +                .startObject("properties"), +                .startObject("field1"), +                    .field("type", "string"), +                    .field("position_offset_gap", 1000), +                    .field("search_quote_analyzer", "simple"), +                .endObject(), +                .startObject("field2"), +                    .field("type", "string"), +                    .field("position_offset_gap", 1000), +                    .field("analyzer", "standard"), +                    .field("search_analyzer", "standard"), +                    .field("search_quote_analyzer", "simple"), +                .endObject(), +                .endObject(), +                .endObject().endObject().string();, +        , +        mapper = parser.parse(mapping);, +        for (String fieldName : Lists.newArrayList("field1", "field2")) {, +            Map<String, Object> serializedMap = getSerializedMap(fieldName, mapper);, +            assertEquals(serializedMap.get("search_quote_analyzer"), "simple");, +        }, +    }, +    , +    private Map<String, Object> getSerializedMap(String fieldName, DocumentMapper mapper) throws Exception {, +        FieldMapper<?> fieldMapper = mapper.mappers().smartNameFieldMapper(fieldName);, +        XContentBuilder builder = JsonXContent.contentBuilder().startObject();, +        fieldMapper.toXContent(builder, ToXContent.EMPTY_PARAMS).endObject();, +        builder.close();, +        , +        Map<String, Object> fieldMap = JsonXContent.jsonXContent.createParser(builder.bytes()).mapAndClose();, +        @SuppressWarnings("unchecked"), +        Map<String, Object> result = (Map<String, Object>) fieldMap.get(fieldName);, +        return result;, +    }, +, +    @Test]