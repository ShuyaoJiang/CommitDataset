[+++ b/modules/elasticsearch/src/main/java/org/elasticsearch/cluster/ClusterModule.java, +        bind(ShardsRoutingStrategy.class).asEagerSingleton();, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/cluster/ClusterModule.java, +        bind(ShardsRoutingStrategy.class).asEagerSingleton();, +++ /dev/null, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/cluster/ClusterModule.java, +        bind(ShardsRoutingStrategy.class).asEagerSingleton();, +++ /dev/null, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/cluster/routing/strategy/ShardsRoutingStrategy.java, +import org.elasticsearch.cluster.node.DiscoveryNode;, +import org.elasticsearch.cluster.routing.*;, +, +import java.util.Iterator;, +import java.util.List;, +import java.util.Set;, +, +import static org.elasticsearch.cluster.routing.ShardRoutingState.*;, +import static org.elasticsearch.common.collect.Sets.*;, + * @author kimchy (shay.banon), +public class ShardsRoutingStrategy {, +    public RoutingTable applyStartedShards(ClusterState clusterState, Iterable<? extends ShardRouting> startedShardEntries) {, +        RoutingNodes routingNodes = clusterState.routingNodes();, +        if (!applyStartedShards(routingNodes, startedShardEntries)) {, +            return clusterState.routingTable();, +        }, +        return new RoutingTable.Builder().updateNodes(routingNodes).build().validateRaiseException(clusterState.metaData());, +    }, +    public RoutingTable applyFailedShards(ClusterState clusterState, Iterable<? extends ShardRouting> failedShardEntries) {, +        RoutingNodes routingNodes = clusterState.routingNodes();, +        if (!applyFailedShards(routingNodes, failedShardEntries)) {, +            return clusterState.routingTable();, +        }, +        return new RoutingTable.Builder().updateNodes(routingNodes).build().validateRaiseException(clusterState.metaData());, +    }, +    public RoutingTable reroute(ClusterState clusterState) {, +        RoutingNodes routingNodes = clusterState.routingNodes();, +, +        Iterable<DiscoveryNode> dataNodes = clusterState.nodes().dataNodes().values();, +, +        boolean changed = false;, +        // first, clear from the shards any node id they used to belong to that is now dead, +        changed |= deassociateDeadNodes(routingNodes, dataNodes);, +, +        // create a sorted list of from nodes with least number of shards to the maximum ones, +        applyNewNodes(routingNodes, dataNodes);, +, +        // now allocate all the unassigned to available nodes, +        if (routingNodes.hasUnassigned()) {, +            changed |= allocateUnassigned(routingNodes);, +        }, +, +        // elect new primaries (backups that should become primaries), +        changed |= electPrimaries(routingNodes);, +, +        // rebalance, +        changed |= rebalance(routingNodes);, +, +        if (!changed) {, +            return clusterState.routingTable();, +        }, +, +        return new RoutingTable.Builder().updateNodes(routingNodes).build().validateRaiseException(clusterState.metaData());, +    }, +, +    private boolean rebalance(RoutingNodes routingNodes) {, +        boolean changed = false;, +        List<RoutingNode> sortedNodesLeastToHigh = routingNodes.sortedNodesLeastToHigh();, +        if (sortedNodesLeastToHigh.isEmpty()) {, +            return false;, +        }, +        int lowIndex = 0;, +        int highIndex = sortedNodesLeastToHigh.size() - 1;, +        boolean relocationPerformed;, +        do {, +            relocationPerformed = false;, +            while (lowIndex != highIndex) {, +                RoutingNode lowRoutingNode = sortedNodesLeastToHigh.get(lowIndex);, +                RoutingNode highRoutingNode = sortedNodesLeastToHigh.get(highIndex);, +                int averageNumOfShards = routingNodes.requiredAverageNumberOfShardsPerNode();, +, +                // only active shards can be removed so must count only active ones., +                if (highRoutingNode.numberOfOwningShards() <= averageNumOfShards) {, +                    highIndex--;, +                    continue;, +                }, +, +                if (lowRoutingNode.shards().size() >= averageNumOfShards) {, +                    lowIndex++;, +                    continue;, +                }, +, +                boolean relocated = false;, +                List<MutableShardRouting> activeShards = highRoutingNode.shardsWithState(STARTED);, +                for (MutableShardRouting activeShard : activeShards) {, +                    if (lowRoutingNode.canAllocate(routingNodes.metaData(), routingNodes.routingTable()) && lowRoutingNode.canAllocate(activeShard)) {, +                        changed = true;, +                        lowRoutingNode.add(new MutableShardRouting(activeShard.index(), activeShard.id(),, +                                lowRoutingNode.nodeId(), activeShard.currentNodeId(),, +                                activeShard.primary(), INITIALIZING));, +]