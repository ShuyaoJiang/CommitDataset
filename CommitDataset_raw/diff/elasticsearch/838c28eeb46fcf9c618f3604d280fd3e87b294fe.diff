[+++ b/Vagrantfile, +++ b/Vagrantfile, +++ b/buildSrc/src/main/groovy/org/elasticsearch/gradle/plugin/PluginBuildPlugin.groovy, +++ b/Vagrantfile, +++ b/buildSrc/src/main/groovy/org/elasticsearch/gradle/plugin/PluginBuildPlugin.groovy, +++ b/core/src/main/java/org/elasticsearch/cluster/routing/allocation/allocator/BalancedShardsAllocator.java, +        Setting.floatSetting("cluster.routing.allocation.balance.index", 0.55f, Property.Dynamic, Property.NodeScope);, +        Setting.floatSetting("cluster.routing.allocation.balance.shard", 0.45f, Property.Dynamic, Property.NodeScope);, +        private final Map<String, ModelNode> nodes = new HashMap<>();, +            buildModelFromAssigned();, +            final NodeSorter sorter = newNodeSorter();, +            buildWeightOrderedIndices(sorter);, +         * shards only if the delta exceeds the threshold. If the default case, +            final NodeSorter sorter = newNodeSorter();, +            for (String index : buildWeightOrderedIndices(sorter)) {, +                // find nodes that have a shard of this index or where shards of this index are allowed to stay, +         * with 3 shards and 1 shard. At the first stage all three nodes hold, +         * 2 shard for each index. now we add another node and the first index, +         * is balanced moving 3 two of the nodes over to the new node since it, +        private String[] buildWeightOrderedIndices(NodeSorter sorter) {, +            final NodeSorter sorter = newNodeSorter();, +                        moveShard(sorter, shardRouting, sourceNode, routingNode);, +        private void moveShard(NodeSorter sorter, ShardRouting shardRouting, ModelNode sourceNode, RoutingNode routingNode) {, +        private void buildModelFromAssigned() {, +                        final Decision decision = deciders.canAllocate(shard, allocation);, +                        if (decision.type() == Type.NO) {, +                            UnassignedInfo.AllocationStatus allocationStatus = UnassignedInfo.AllocationStatus.fromDecision(decision);, +                            unassigned.ignoreShard(shard, allocationStatus, allocation.changes());, +                            while(i < primaryLength-1 && comparator.compare(primary[i], primary[i+1]) == 0) {, +                                unassigned.ignoreShard(primary[++i], allocationStatus, allocation.changes());, +                            }, +                            continue;, +                        } else {, +                    assert !shard.assignedToNode() : shard;, +                                    Decision currentDecision = deciders.canAllocate(shard, node.getRoutingNode(), allocation);, +                                    NOUPDATE:, +                                                if ((((nodeHigh > repId && minNodeHigh > repId) || (nodeHigh < repId && minNodeHigh < repId)) && (nodeHigh < minNodeHigh)), +                                                        || (nodeHigh > minNodeHigh && nodeHigh > repId && minNodeHigh < repId)) {, +                                                    // nothing to set here; the minNode, minWeight, and decision get set below, +                                                    break NOUPDATE;, +                                            } else if (currentDecision.type() != Type.YES) {, +                                                break NOUPDATE;, +                                        }, +                    assert (decision == null) == (minNode == null);, +                    if (minNode != null) {, +                        final long shardSize = DiskThresholdDecider.getExpectedShardSize(shard, allocation,, +                            ShardRouting.UNAVAILABLE_EXPECTED_SHARD_SIZE);, +                        if (decision.type() == Type.YES) {, +                            if (logger.isTraceEnabled()) {, +                                logger.trace("Assigned shard [{}] to [{}]", shard, minNode.getNodeId());, +, +                            shard = routingNodes.initializeShard(shard, minNode.getNodeId(), null, shardSize, allocation.changes());, +                            minNode.addShard(shard);, +                            continue; // don't add to ignoreUnassigned, +                        } else {, +                            minNode.addShard(shard.initialize(minNode.getNodeId(), null, shardSize));, +                            final RoutingNode node = minNode.getRoutingNode();, +                            final Decision.Type nodeLevelDecision = deciders.canAllocate(node, allocation).type();, +                            if (nodeLevelDecision != Type.YES) {, +                                if (logger.isTraceEnabled()) {, +                                    logger.trace("Can not allocate on node [{}] remove from round decision [{}]", node, decision.type());, +                                assert nodeLevelDecision == Type.NO;, +                                throttledNodes.add(minNode);, +                            }, +                        }, +                        if (logger.isTraceEnabled()) {, +                            logger.trace("No eligible node found to assign shard [{}] decision [{}]", shard, decision.type());, +                        }, +                    } else if (logger.isTraceEnabled()) {, +                        logger.trace("No Node found to assign shard [{}]", shard);, +                    }, +                    assert decision == null || decision.type() == Type.THROTTLE;, +                    UnassignedInfo.AllocationStatus allocationStatus =, +                        decision == null ? UnassignedInfo.AllocationStatus.DECIDERS_NO :, +                                           UnassignedInfo.AllocationStatus.fromDecision(decision);, +                    unassigned.ignoreShard(shard, allocationStatus, allocation.changes());, +                    if (!shard.primary()) { // we could not allocate it and we are a replica - check if we can ignore the other replicas, +                        while(secondaryLength > 0 && comparator.compare(shard, secondary[secondaryLength-1]) == 0) {, +                            unassigned.ignoreShard(secondary[--secondaryLength], allocationStatus, allocation.changes());, +                        }, +                    }, +                }, +                primaryLength = secondaryLength;, +                ShardRouting[] tmp = primary;, +                primary = secondary;, +                secondary = tmp;, +                secondaryLength = 0;, +            } while (primaryLength > 0);, +            // clear everything we have either added it or moved to ignoreUnassigned, +++ b/Vagrantfile, +++ b/buildSrc/src/main/groovy/org/elasticsearch/gradle/plugin/PluginBuildPlugin.groovy, +++ b/core/src/main/java/org/elasticsearch/cluster/routing/allocation/allocator/BalancedShardsAllocator.java, +        Setting.floatSetting("cluster.routing.allocation.balance.index", 0.55f, Property.Dynamic, Property.NodeScope);, +        Setting.floatSetting("cluster.routing.allocation.balance.shard", 0.45f, Property.Dynamic, Property.NodeScope);, +        private final Map<String, ModelNode> nodes = new HashMap<>();, +            buildModelFromAssigned();, +            final NodeSorter sorter = newNodeSorter();, +            buildWeightOrderedIndices(sorter);, +         * shards only if the delta exceeds the threshold. If the default case, +            final NodeSorter sorter = newNodeSorter();]