[+++ b/core/src/main/java/org/elasticsearch/ElasticsearchException.java, +        // 124 used to be Script.ScriptParseException, +++ b/core/src/main/java/org/elasticsearch/ElasticsearchException.java, +        // 124 used to be Script.ScriptParseException, +++ b/core/src/main/java/org/elasticsearch/index/query/QueryBuilders.java, +++ b/core/src/main/java/org/elasticsearch/ElasticsearchException.java, +        // 124 used to be Script.ScriptParseException, +++ b/core/src/main/java/org/elasticsearch/index/query/QueryBuilders.java, +++ /dev/null, +++ b/core/src/main/java/org/elasticsearch/ElasticsearchException.java, +        // 124 used to be Script.ScriptParseException, +++ b/core/src/main/java/org/elasticsearch/index/query/QueryBuilders.java, +++ /dev/null, +++ /dev/null, +++ b/core/src/main/java/org/elasticsearch/ElasticsearchException.java, +        // 124 used to be Script.ScriptParseException, +++ b/core/src/main/java/org/elasticsearch/index/query/QueryBuilders.java, +++ /dev/null, +++ /dev/null, +++ b/core/src/main/java/org/elasticsearch/script/Script.java, +import org.elasticsearch.ElasticsearchParseException;, +import org.elasticsearch.common.bytes.BytesArray;, +import org.elasticsearch.common.xcontent.XContentFactory;, +import org.elasticsearch.common.xcontent.XContentType;, +import java.util.Objects;, +public final class Script implements ToXContent, Writeable {, +    private ScriptType type;, +    @Nullable private XContentType contentType;, +     * Constructor for simple inline script. The script will have no lang or params set., +     * @param script The inline script to execute., +        this(script, ScriptType.INLINE, null, null);, +    public Script(String script, ScriptType type, @Nullable String lang, @Nullable Map<String, ?> params) {, +        this(script, type, lang, params, null);, +     * @param script        The cache key of the script to be compiled/executed. For inline scripts this is the actual, +     *                      script source code. For indexed scripts this is the id used in the request. For on file, +     *                      scripts this is the file name., +     * @param type          The type of script -- dynamic, stored, or file., +     * @param lang          The language of the script to be compiled/executed., +     * @param params        The map of parameters the script will be executed with., +     * @param contentType   The {@link XContentType} of the script. Only relevant for inline scripts that have not been, +     *                      defined as a plain string, but as json or yaml content. This class needs this information, +     *                      when serializing the script back to xcontent., +    @SuppressWarnings("unchecked"), +    public Script(String script, ScriptType type, @Nullable String lang, @Nullable Map<String, ?> params,, +                  @Nullable XContentType  contentType) {, +        if (contentType != null && type != ScriptType.INLINE) {, +            throw new IllegalArgumentException("The parameter contentType only makes sense for inline scripts");, +        this.script = Objects.requireNonNull(script);, +        this.type = Objects.requireNonNull(type);, +        this.contentType = contentType;, +        if (in.readBoolean()) {, +            contentType = XContentType.readFrom(in);, +    public void writeTo(StreamOutput out) throws IOException {, +        boolean hasContentType = contentType != null;, +        out.writeBoolean(hasContentType);, +        if (hasContentType) {, +            XContentType.writeTo(contentType, out);, +     * @return The type of script -- inline, stored, or file., +    /**, +     * @return The content type of the script if it is an inline script and the script has been defined as json, +     *         or yaml content instead of a plain string., +     */, +    public XContentType getContentType() {, +        return contentType;, +    }, +, +    public XContentBuilder toXContent(XContentBuilder builder, Params builderParams) throws IOException {, +        if (type == ScriptType.INLINE && contentType != null && builder.contentType() == contentType) {, +            builder.rawField(type.getParseField().getPreferredName(), new BytesArray(script));, +        } else {, +            builder.field(type.getParseField().getPreferredName(), script);, +        }, +        return parse(parser, parseFieldMatcher, null);, +    }, +, +    public static Script parse(XContentParser parser, ParseFieldMatcher parseFieldMatcher, @Nullable String lang) throws IOException {, +        XContentParser.Token token = parser.currentToken();, +        // If the parser hasn't yet been pushed to the first token, do it now, +        if (token == null) {, +            token = parser.nextToken();, +        }, +        if (token == XContentParser.Token.VALUE_STRING) {, +            return new Script(parser.text());, +        }, +        if (token != XContentParser.Token.START_OBJECT) {, +            throw new ElasticsearchParseException("expected a string value or an object, but found [{}] instead", token);, +        }, +        String script = null;, +        ScriptType type = null;, +        Map<String, Object> params = null;, +        XContentType contentType = null;, +        String cfn = null;, +        while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {, +            if (token == XContentParser.Token.FIELD_NAME) {, +                cfn = parser.currentName();, +            } else if (parseFieldMatcher.match(cfn, ScriptType.INLINE.getParseField())) {, +                type = ScriptType.INLINE;, +                if (parser.currentToken() == XContentParser.Token.START_OBJECT) {, +                    contentType = parser.contentType();, +                    XContentBuilder builder = XContentFactory.contentBuilder(contentType);]