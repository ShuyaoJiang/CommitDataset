[+++ b/src/main/java/org/elasticsearch/cluster/settings/ClusterDynamicSettingsModule.java, +        clusterDynamicSettings.addDynamicSetting(RecoverySettings.INDICES_RECOVERY_RETRY_DELAY, Validator.TIME_NON_NEGATIVE);, +++ b/src/main/java/org/elasticsearch/cluster/settings/ClusterDynamicSettingsModule.java, +        clusterDynamicSettings.addDynamicSetting(RecoverySettings.INDICES_RECOVERY_RETRY_DELAY, Validator.TIME_NON_NEGATIVE);, +++ b/src/main/java/org/elasticsearch/indices/recovery/RecoverySettings.java, +import org.elasticsearch.common.unit.TimeValue;, +    public static final String INDICES_RECOVERY_RETRY_DELAY = "indices.recovery.retry_delay";, +    private volatile TimeValue retryDelay;, +        this.retryDelay = componentSettings.getAsTime("retry_delay", TimeValue.timeValueMillis(500));, +    public TimeValue retryDelay() { return retryDelay; }, +, +            final TimeValue retryDelay = settings.getAsTime(INDICES_RECOVERY_RETRY_DELAY, RecoverySettings.this.retryDelay);, +            if (retryDelay.equals(RecoverySettings.this.retryDelay) == false) {, +                logger.info("updating [] from [{}] to [{}]",INDICES_RECOVERY_RETRY_DELAY,  RecoverySettings.this.retryDelay, retryDelay);, +                RecoverySettings.this.retryDelay = retryDelay;, +            }, +++ b/src/main/java/org/elasticsearch/cluster/settings/ClusterDynamicSettingsModule.java, +        clusterDynamicSettings.addDynamicSetting(RecoverySettings.INDICES_RECOVERY_RETRY_DELAY, Validator.TIME_NON_NEGATIVE);, +++ b/src/main/java/org/elasticsearch/indices/recovery/RecoverySettings.java, +import org.elasticsearch.common.unit.TimeValue;, +    public static final String INDICES_RECOVERY_RETRY_DELAY = "indices.recovery.retry_delay";, +    private volatile TimeValue retryDelay;, +        this.retryDelay = componentSettings.getAsTime("retry_delay", TimeValue.timeValueMillis(500));, +    public TimeValue retryDelay() { return retryDelay; }, +, +            final TimeValue retryDelay = settings.getAsTime(INDICES_RECOVERY_RETRY_DELAY, RecoverySettings.this.retryDelay);, +            if (retryDelay.equals(RecoverySettings.this.retryDelay) == false) {, +                logger.info("updating [] from [{}] to [{}]",INDICES_RECOVERY_RETRY_DELAY,  RecoverySettings.this.retryDelay, retryDelay);, +                RecoverySettings.this.retryDelay = retryDelay;, +            }, +++ b/src/main/java/org/elasticsearch/indices/recovery/RecoveryTarget.java, +                retryRecovery(recoveryStatus.recoveryId(), recoverySettings.retryDelay());, +                retryRecovery(recoveryStatus.recoveryId(), recoverySettings.retryDelay());, +++ b/src/main/java/org/elasticsearch/cluster/settings/ClusterDynamicSettingsModule.java, +        clusterDynamicSettings.addDynamicSetting(RecoverySettings.INDICES_RECOVERY_RETRY_DELAY, Validator.TIME_NON_NEGATIVE);, +++ b/src/main/java/org/elasticsearch/indices/recovery/RecoverySettings.java, +import org.elasticsearch.common.unit.TimeValue;, +    public static final String INDICES_RECOVERY_RETRY_DELAY = "indices.recovery.retry_delay";, +    private volatile TimeValue retryDelay;, +        this.retryDelay = componentSettings.getAsTime("retry_delay", TimeValue.timeValueMillis(500));, +    public TimeValue retryDelay() { return retryDelay; }, +, +            final TimeValue retryDelay = settings.getAsTime(INDICES_RECOVERY_RETRY_DELAY, RecoverySettings.this.retryDelay);, +            if (retryDelay.equals(RecoverySettings.this.retryDelay) == false) {, +                logger.info("updating [] from [{}] to [{}]",INDICES_RECOVERY_RETRY_DELAY,  RecoverySettings.this.retryDelay, retryDelay);, +                RecoverySettings.this.retryDelay = retryDelay;, +            }, +++ b/src/main/java/org/elasticsearch/indices/recovery/RecoveryTarget.java, +                retryRecovery(recoveryStatus.recoveryId(), recoverySettings.retryDelay());, +                retryRecovery(recoveryStatus.recoveryId(), recoverySettings.retryDelay());, +++ b/src/test/java/org/elasticsearch/test/InternalTestCluster.java, +            builder.put(RecoverySettings.INDICES_RECOVERY_RETRY_DELAY, TimeValue.timeValueMillis(RandomInts.randomIntBetween(random, 10, 25))); // more shared - we need to retry more often, +            builder.put(RecoverySettings.INDICES_RECOVERY_RETRY_DELAY, TimeValue.timeValueMillis(RandomInts.randomIntBetween(random, 20, 100)));]