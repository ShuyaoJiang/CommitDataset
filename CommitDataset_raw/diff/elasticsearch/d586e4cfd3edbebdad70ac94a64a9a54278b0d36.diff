[+++ b/x-pack/protocol/src/main/java/org/elasticsearch/protocol/xpack/ml/job/config/AnalysisConfig.java, +/*, + * Licensed to Elasticsearch under one or more contributor, + * license agreements. See the NOTICE file distributed with, + * this work for additional information regarding copyright, + * ownership. Elasticsearch licenses this file to you under, + * the Apache License, Version 2.0 (the "License"); you may, + * not use this file except in compliance with the License., + * You may obtain a copy of the License at, + *, + *    http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing,, + * software distributed under the License is distributed on an, + * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY, + * KIND, either express or implied.  See the License for the, + * specific language governing permissions and limitations, + * under the License., + */, +package org.elasticsearch.protocol.xpack.ml.job.config;, +, +import org.elasticsearch.common.ParseField;, +import org.elasticsearch.common.unit.TimeValue;, +import org.elasticsearch.common.xcontent.ConstructingObjectParser;, +import org.elasticsearch.common.xcontent.ObjectParser;, +import org.elasticsearch.common.xcontent.ToXContentObject;, +import org.elasticsearch.common.xcontent.XContentBuilder;, +, +import java.io.IOException;, +import java.util.ArrayList;, +import java.util.Collections;, +import java.util.HashSet;, +import java.util.List;, +import java.util.Objects;, +import java.util.Set;, +import java.util.function.Function;, +, +/**, + * Analysis configuration options that describe which fields are, + * analyzed and which functions are used to detect anomalies., + * <p>, + * The configuration can contain multiple detectors, a new anomaly detector will, + * be created for each detector configuration. The fields, + * <code>bucketSpan, summaryCountFieldName and categorizationFieldName</code>, + * apply to all detectors., + * <p>, + * If a value has not been set it will be <code>null</code>, + * Object wrappers are used around integral types &amp; booleans so they can take, + * <code>null</code> values., + */, +public class AnalysisConfig implements ToXContentObject {, +    /**, +     * Serialisation names, +     */, +    public static final ParseField ANALYSIS_CONFIG = new ParseField("analysis_config");, +    public static final ParseField BUCKET_SPAN = new ParseField("bucket_span");, +    public static final ParseField CATEGORIZATION_FIELD_NAME = new ParseField("categorization_field_name");, +    public static final ParseField CATEGORIZATION_FILTERS = new ParseField("categorization_filters");, +    public static final ParseField CATEGORIZATION_ANALYZER = CategorizationAnalyzerConfig.CATEGORIZATION_ANALYZER;, +    public static final ParseField LATENCY = new ParseField("latency");, +    public static final ParseField SUMMARY_COUNT_FIELD_NAME = new ParseField("summary_count_field_name");, +    public static final ParseField DETECTORS = new ParseField("detectors");, +    public static final ParseField INFLUENCERS = new ParseField("influencers");, +    public static final ParseField OVERLAPPING_BUCKETS = new ParseField("overlapping_buckets");, +    public static final ParseField RESULT_FINALIZATION_WINDOW = new ParseField("result_finalization_window");, +    public static final ParseField MULTIVARIATE_BY_FIELDS = new ParseField("multivariate_by_fields");, +, +    @SuppressWarnings("unchecked"), +    public static final ConstructingObjectParser<Builder, Void> PARSER = new ConstructingObjectParser<>(ANALYSIS_CONFIG.getPreferredName(),, +        true, a -> new AnalysisConfig.Builder((List<Detector>) a[0]));, +, +    static {, +        PARSER.declareObjectArray(ConstructingObjectParser.constructorArg(),, +            (p, c) -> (Detector.PARSER).apply(p, c).build(), DETECTORS);, +        PARSER.declareString((builder, val) ->, +            builder.setBucketSpan(TimeValue.parseTimeValue(val, BUCKET_SPAN.getPreferredName())), BUCKET_SPAN);, +        PARSER.declareString(Builder::setCategorizationFieldName, CATEGORIZATION_FIELD_NAME);, +        PARSER.declareStringArray(Builder::setCategorizationFilters, CATEGORIZATION_FILTERS);, +        // This one is nasty - the syntax for analyzers takes either names or objects at many levels, hence it's not, +        // possible to simply declare whether the field is a string or object and a completely custom parser is required, +        PARSER.declareField(Builder::setCategorizationAnalyzerConfig,, +            (p, c) -> CategorizationAnalyzerConfig.buildFromXContentFragment(p),, +            CATEGORIZATION_ANALYZER, ObjectParser.ValueType.OBJECT_OR_STRING);, +        PARSER.declareString((builder, val) ->, +            builder.setLatency(TimeValue.parseTimeValue(val, LATENCY.getPreferredName())), LATENCY);, +        PARSER.declareString(Builder::setSummaryCountFieldName, SUMMARY_COUNT_FIELD_NAME);, +        PARSER.declareStringArray(Builder::setInfluencers, INFLUENCERS);, +        PARSER.declareBoolean(Builder::setOverlappingBuckets, OVERLAPPING_BUCKETS);, +        PARSER.declareLong(Builder::setResultFinalizationWindow, RESULT_FINALIZATION_WINDOW);, +        PARSER.declareBoolean(Builder::setMultivariateByFields, MULTIVARIATE_BY_FIELDS);, +    }, +, +    /**, +     * These values apply to all detectors, +     */, +    private final TimeValue bucketSpan;, +    private final String categorizationFieldName;, +    private final List<String> categorizationFilters;, +    private final CategorizationAnalyzerConfig categorizationAnalyzerConfig;, +    private final TimeValue latency;]