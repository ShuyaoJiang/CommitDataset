[+++ b/src/main/java/org/elasticsearch/client/transport/TransportClientNodesService.java, +                if (i >= nodes.size()) {, +, +        /**, +         * validates a set of potentially newly discovered nodes and returns an immutable, +         * list of the nodes that has passed., +         */, +        protected ImmutableList<DiscoveryNode> validateNewNodes(Set<DiscoveryNode> nodes) {, +            for (Iterator<DiscoveryNode> it = nodes.iterator(); it.hasNext(); ) {, +                DiscoveryNode node = it.next();, +                if (!transportService.nodeConnected(node)) {, +                    try {, +                        logger.trace("connecting to node [{}]", node);, +                        transportService.connectToNode(node);, +                    } catch (Throwable e) {, +                        it.remove();, +                        logger.debug("failed to connect to discovered node [" + node + "]", e);, +                    }, +                }, +            }, +, +            return new ImmutableList.Builder<DiscoveryNode>().addAll(nodes).build();, +        }, +, +            for (DiscoveryNode listedNode : listedNodes) {, +                if (!transportService.nodeConnected(listedNode)) {, +                        // its a listed node, light connect to it..., +                        logger.trace("connecting to listed node (light) [{}]", listedNode);, +                        transportService.connectToNodeLight(listedNode);, +                        logger.debug("failed to connect to node [{}], removed from nodes list", e, listedNode);, +                    NodesInfoResponse nodeInfo = transportService.submitRequest(listedNode, NodesInfoAction.NAME,, +                        logger.warn("node {} not part of the cluster {}, ignoring...", listedNode, clusterName);, +                    } else if (nodeInfo.getNodes().length != 0) {, +                        // use discovered information but do keep the original transport address, so people can control which address, +                        // is exactly used., +, +                        DiscoveryNode nodeWithInfo = nodeInfo.getNodes()[0].getNode();, +                        newNodes.add(new DiscoveryNode(nodeWithInfo.name(), nodeWithInfo.id(), listedNode.address(), nodeWithInfo.attributes(), nodeWithInfo.version()));, +                        // although we asked for one node, our target may not have completed initialization yet and doesn't have, +                        // cluster nodes, +                        logger.debug("node {} didn't return any discovery info, temporarily using transport discovery node", listedNode);, +                        newNodes.add(listedNode);, +                    logger.info("failed to get node info for {}, disconnecting...", e, listedNode);, +                    transportService.disconnectFromNode(listedNode);, +, +            nodes = validateNewNodes(newNodes);, +, +            nodes = validateNewNodes(newNodes);, +++ b/src/main/java/org/elasticsearch/client/transport/TransportClientNodesService.java, +                if (i >= nodes.size()) {, +, +        /**, +         * validates a set of potentially newly discovered nodes and returns an immutable, +         * list of the nodes that has passed., +         */, +        protected ImmutableList<DiscoveryNode> validateNewNodes(Set<DiscoveryNode> nodes) {, +            for (Iterator<DiscoveryNode> it = nodes.iterator(); it.hasNext(); ) {, +                DiscoveryNode node = it.next();, +                if (!transportService.nodeConnected(node)) {, +                    try {, +                        logger.trace("connecting to node [{}]", node);, +                        transportService.connectToNode(node);, +                    } catch (Throwable e) {, +                        it.remove();, +                        logger.debug("failed to connect to discovered node [" + node + "]", e);, +                    }, +                }, +            }, +, +            return new ImmutableList.Builder<DiscoveryNode>().addAll(nodes).build();, +        }, +, +            for (DiscoveryNode listedNode : listedNodes) {, +                if (!transportService.nodeConnected(listedNode)) {, +                        // its a listed node, light connect to it..., +                        logger.trace("connecting to listed node (light) [{}]", listedNode);, +                        transportService.connectToNodeLight(listedNode);, +                        logger.debug("failed to connect to node [{}], removed from nodes list", e, listedNode);, +                    NodesInfoResponse nodeInfo = transportService.submitRequest(listedNode, NodesInfoAction.NAME,, +                        logger.warn("node {} not part of the cluster {}, ignoring...", listedNode, clusterName);, +                    } else if (nodeInfo.getNodes().length != 0) {, +                        // use discovered information but do keep the original transport address, so people can control which address, +                        // is exactly used., +, +                        DiscoveryNode nodeWithInfo = nodeInfo.getNodes()[0].getNode();, +                        newNodes.add(new DiscoveryNode(nodeWithInfo.name(), nodeWithInfo.id(), listedNode.address(), nodeWithInfo.attributes(), nodeWithInfo.version()));, +                        // although we asked for one node, our target may not have completed initialization yet and doesn't have, +                        // cluster nodes, +                        logger.debug("node {} didn't return any discovery info, temporarily using transport discovery node", listedNode);, +                        newNodes.add(listedNode);, +                    logger.info("failed to get node info for {}, disconnecting...", e, listedNode);, +                    transportService.disconnectFromNode(listedNode);, +, +            nodes = validateNewNodes(newNodes);, +, +            nodes = validateNewNodes(newNodes);, +++ b/src/test/java/org/elasticsearch/client/transport/TransportClientTests.java, +package org.elasticsearch.client.transport;, +/*, + * Licensed to ElasticSearch under one]