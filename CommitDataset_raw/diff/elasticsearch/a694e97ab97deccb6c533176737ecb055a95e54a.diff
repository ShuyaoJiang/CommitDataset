[+++ b/src/main/java/org/elasticsearch/index/get/ShardGetService.java, +import org.elasticsearch.common.collect.Tuple;, +import org.elasticsearch.common.xcontent.XContentFactory;, +import org.elasticsearch.common.xcontent.XContentHelper;, +import org.elasticsearch.common.xcontent.XContentType;, +import org.elasticsearch.common.xcontent.support.XContentMapValues;, +                // Cater for source excludes/includes at the cost of performance, +                BytesReference sourceToBeReturned = null;, +                if (sourceRequested) {, +                    sourceToBeReturned = source.source;, +, +                    SourceFieldMapper sourceFieldMapper = docMapper.sourceMapper();, +                    if (sourceFieldMapper.enabled()) {, +                        boolean filtered = sourceFieldMapper.includes().length > 0 || sourceFieldMapper.excludes().length > 0;, +                        if (filtered) {, +                            Tuple<XContentType, Map<String, Object>> mapTuple = XContentHelper.convertToMap(source.source, true);, +                            Map<String, Object> filteredSource = XContentMapValues.filter(mapTuple.v2(), sourceFieldMapper.includes(), sourceFieldMapper.excludes());, +                            try {, +                                sourceToBeReturned = XContentFactory.contentBuilder(mapTuple.v1()).map(filteredSource).bytes();, +                            } catch (IOException e) {, +                                throw new ElasticSearchException("Failed to get type [" + type + "] and id [" + id + "] with includes/excludes set", e);, +                            }, +                        }, +                    }, +                }, +, +                return new GetResult(shardId.index().name(), type, id, get.version(), get.exists(), sourceToBeReturned, fields);, +++ b/src/main/java/org/elasticsearch/index/get/ShardGetService.java, +import org.elasticsearch.common.collect.Tuple;, +import org.elasticsearch.common.xcontent.XContentFactory;, +import org.elasticsearch.common.xcontent.XContentHelper;, +import org.elasticsearch.common.xcontent.XContentType;, +import org.elasticsearch.common.xcontent.support.XContentMapValues;, +                // Cater for source excludes/includes at the cost of performance, +                BytesReference sourceToBeReturned = null;, +                if (sourceRequested) {, +                    sourceToBeReturned = source.source;, +, +                    SourceFieldMapper sourceFieldMapper = docMapper.sourceMapper();, +                    if (sourceFieldMapper.enabled()) {, +                        boolean filtered = sourceFieldMapper.includes().length > 0 || sourceFieldMapper.excludes().length > 0;, +                        if (filtered) {, +                            Tuple<XContentType, Map<String, Object>> mapTuple = XContentHelper.convertToMap(source.source, true);, +                            Map<String, Object> filteredSource = XContentMapValues.filter(mapTuple.v2(), sourceFieldMapper.includes(), sourceFieldMapper.excludes());, +                            try {, +                                sourceToBeReturned = XContentFactory.contentBuilder(mapTuple.v1()).map(filteredSource).bytes();, +                            } catch (IOException e) {, +                                throw new ElasticSearchException("Failed to get type [" + type + "] and id [" + id + "] with includes/excludes set", e);, +                            }, +                        }, +                    }, +                }, +, +                return new GetResult(shardId.index().name(), type, id, get.version(), get.exists(), sourceToBeReturned, fields);, +++ b/src/main/java/org/elasticsearch/index/mapper/internal/SourceFieldMapper.java, +    public String[] excludes() {, +        return this.excludes;, +, +    }, +    public String[] includes() {, +        return this.includes;, +    }, +, +++ b/src/main/java/org/elasticsearch/index/get/ShardGetService.java, +import org.elasticsearch.common.collect.Tuple;, +import org.elasticsearch.common.xcontent.XContentFactory;, +import org.elasticsearch.common.xcontent.XContentHelper;, +import org.elasticsearch.common.xcontent.XContentType;, +import org.elasticsearch.common.xcontent.support.XContentMapValues;, +                // Cater for source excludes/includes at the cost of performance, +                BytesReference sourceToBeReturned = null;, +                if (sourceRequested) {, +                    sourceToBeReturned = source.source;, +, +                    SourceFieldMapper sourceFieldMapper = docMapper.sourceMapper();, +                    if (sourceFieldMapper.enabled()) {, +                        boolean filtered = sourceFieldMapper.includes().length > 0 || sourceFieldMapper.excludes().length > 0;, +                        if (filtered) {, +                            Tuple<XContentType, Map<String, Object>> mapTuple = XContentHelper.convertToMap(source.source, true);, +                            Map<String, Object> filteredSource = XContentMapValues.filter(mapTuple.v2(), sourceFieldMapper.includes(), sourceFieldMapper.excludes());, +                            try {, +                                sourceToBeReturned = XContentFactory.contentBuilder(mapTuple.v1()).map(filteredSource).bytes();, +                            } catch (IOException e) {, +                                throw new ElasticSearchException("Failed to get type [" + type + "] and id [" + id + "] with includes/excludes set", e);, +                            }, +                        }, +                    }, +                }, +, +                return new GetResult(shardId.index().name(), type, id, get.version(), get.exists(), sourceToBeReturned, fields);, +++ b/src/main/java/org/elasticsearch/index/mapper/internal/SourceFieldMapper.java, +    public String[] excludes() {, +        return this.excludes;, +, +    }, +    public String[] includes() {, +        return this.includes;, +    }, +, +++ b/src/test/java/org/elasticsearch/test/integration/get/GetActionTests.java]