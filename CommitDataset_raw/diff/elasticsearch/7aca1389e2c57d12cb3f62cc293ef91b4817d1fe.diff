[+++ b/core/src/main/java/org/elasticsearch/ingest/processor/DateIndexNameProcessor.java, +/*, + * Licensed to Elasticsearch under one or more contributor, + * license agreements. See the NOTICE file distributed with, + * this work for additional information regarding copyright, + * ownership. Elasticsearch licenses this file to you under, + * the Apache License, Version 2.0 (the "License"); you may, + * not use this file except in compliance with the License., + * You may obtain a copy of the License at, + *, + *    http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing,, + * software distributed under the License is distributed on an, + * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY, + * KIND, either express or implied.  See the License for the, + * specific language governing permissions and limitations, + * under the License., + */, +, +package org.elasticsearch.ingest.processor;, +, +import org.elasticsearch.ExceptionsHelper;, +import org.elasticsearch.ingest.core.AbstractProcessor;, +import org.elasticsearch.ingest.core.AbstractProcessorFactory;, +import org.elasticsearch.ingest.core.ConfigurationUtils;, +import org.elasticsearch.ingest.core.IngestDocument;, +import org.joda.time.DateTime;, +import org.joda.time.DateTimeZone;, +import org.joda.time.format.DateTimeFormat;, +import org.joda.time.format.DateTimeFormatter;, +, +import java.util.ArrayList;, +import java.util.Collections;, +import java.util.IllformedLocaleException;, +import java.util.List;, +import java.util.Locale;, +import java.util.Map;, +import java.util.function.Function;, +, +public final class DateIndexNameProcessor extends AbstractProcessor {, +, +    public static final String TYPE = "date_index_name";, +, +    private final String field;, +    private final String indexNamePrefix;, +    private final String dateRounding;, +    private final String indexNameFormat;, +    private final DateTimeZone timezone;, +    private final List<Function<String, DateTime>> dateFormats;, +, +    DateIndexNameProcessor(String tag, String field, List<Function<String, DateTime>> dateFormats, DateTimeZone timezone,, +                           String indexNamePrefix, String dateRounding, String indexNameFormat) {, +        super(tag);, +        this.field = field;, +        this.timezone = timezone;, +        this.dateFormats = dateFormats;, +        this.indexNamePrefix = indexNamePrefix;, +        this.dateRounding = dateRounding;, +        this.indexNameFormat = indexNameFormat;, +    }, +, +    @Override, +    public void execute(IngestDocument ingestDocument) throws Exception {, +        String date = ingestDocument.getFieldValue(field, String.class);, +, +        DateTime dateTime = null;, +        Exception lastException = null;, +        for (Function<String, DateTime> dateParser : dateFormats) {, +            try {, +                dateTime = dateParser.apply(date);, +            } catch (Exception e) {, +                //try the next parser and keep track of the exceptions, +                lastException = ExceptionsHelper.useOrSuppress(lastException, e);, +            }, +        }, +, +        if (dateTime == null) {, +            throw new IllegalArgumentException("unable to parse date [" + date + "]", lastException);, +        }, +, +        DateTimeFormatter formatter = DateTimeFormat.forPattern(indexNameFormat);, +        StringBuilder builder = new StringBuilder(), +                .append('<'), +                .append(indexNamePrefix), +                    .append('{'), +                        .append(formatter.print(dateTime)).append("||/").append(dateRounding), +                            .append('{').append(indexNameFormat).append('|').append(timezone).append('}'), +                    .append('}'), +                .append('>');, +        String dynamicIndexName  = builder.toString();, +        ingestDocument.setFieldValue(IngestDocument.MetaData.INDEX.getFieldName(), dynamicIndexName);, +    }, +, +    @Override, +    public String getType() {, +        return TYPE;, +    }, +, +    String getField() {]