[+++ b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/parser/SqlParser.java, +import static org.elasticsearch.xpack.sql.parser.AbstractBuilder.source;, +        private static final short MAX_RULE_DEPTH = 200;, +            if (ctx.getClass() != SqlBaseParser.UnquoteIdentifierContext.class &&, +                ctx.getClass() != SqlBaseParser.QuoteIdentifierContext.class &&, +                ctx.getClass() != SqlBaseParser.BackQuotedIdentifierContext.class) {, +                int currentDepth = depthCounts.putOrAdd(ctx.getClass().getSimpleName(), (short) 1, (short) 1);, +                    throw new ParsingException(source(ctx), "SQL statement too large; " +, +                        "halt parsing to prevent memory errors (stopped at depth {})", MAX_RULE_DEPTH);, +                }, +            // Avoid having negative numbers, +            if (depthCounts.containsKey(ctx.getClass().getSimpleName())) {, +            }, +++ b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/parser/SqlParser.java, +import static org.elasticsearch.xpack.sql.parser.AbstractBuilder.source;, +        private static final short MAX_RULE_DEPTH = 200;, +            if (ctx.getClass() != SqlBaseParser.UnquoteIdentifierContext.class &&, +                ctx.getClass() != SqlBaseParser.QuoteIdentifierContext.class &&, +                ctx.getClass() != SqlBaseParser.BackQuotedIdentifierContext.class) {, +                int currentDepth = depthCounts.putOrAdd(ctx.getClass().getSimpleName(), (short) 1, (short) 1);, +                    throw new ParsingException(source(ctx), "SQL statement too large; " +, +                        "halt parsing to prevent memory errors (stopped at depth {})", MAX_RULE_DEPTH);, +                }, +            // Avoid having negative numbers, +            if (depthCounts.containsKey(ctx.getClass().getSimpleName())) {, +            }, +++ b/x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/parser/SqlParserTests.java, +    public void testLimitToPreventStackOverflowFromLongListOfQuotedIdentifiers() {, +        // Create expression in the form of "t"."field","t"."field", ..., +, +        // 200 elements is ok, +        new SqlParser().createStatement("SELECT " +, +            Joiner.on(",").join(nCopies(200, "\"t\".\"field\"")) + " FROM t");, +, +        // 201 elements parser's "circuit breaker" is triggered, +        ParsingException e = expectThrows(ParsingException.class, () -> new SqlParser().createStatement("SELECT " +, +            Joiner.on(",").join(nCopies(201, "\"t\".\"field\"")) + " FROM t"));, +        assertEquals("line 1:2409: SQL statement too large; halt parsing to prevent memory errors (stopped at depth 200)",, +            e.getMessage());, +    }, +, +    public void testLimitToPreventStackOverflowFromLongListOfUnQuotedIdentifiers() {, +        // Create expression in the form of t.field,t.field, ..., +, +        // 250 elements is ok, +        new SqlParser().createStatement("SELECT " +, +            Joiner.on(",").join(nCopies(200, "t.field")) + " FROM t");, +, +        // 251 elements parser's "circuit breaker" is triggered, +        ParsingException e = expectThrows(ParsingException.class, () -> new SqlParser().createStatement("SELECT " +, +            Joiner.on(",").join(nCopies(201, "t.field")) + " FROM t"));, +        assertEquals("line 1:1609: SQL statement too large; halt parsing to prevent memory errors (stopped at depth 200)",, +            e.getMessage());, +    }, +, +        // 99 elements is ok, +            Joiner.on("").join(nCopies(99, "NOT(")).concat("b").concat(Joiner.on("").join(nCopies(99, ")"))));, +        assertEquals("line 1:402: SQL statement too large; halt parsing to prevent memory errors (stopped at depth 200)",, +            e.getMessage());, +        // 100 elements is ok, +        new SqlParser().createExpression(Joiner.on(" OR ").join(nCopies(100, "a = b")));, +        // 101 elements parser's "circuit breaker" is triggered, +            new SqlParser().createExpression(Joiner.on(" OR ").join(nCopies(101, "a = b"))));, +        assertEquals("line 1:902: SQL statement too large; halt parsing to prevent memory errors (stopped at depth 200)",, +            e.getMessage());, +        // 199 elements is ok, +            Joiner.on("").join(nCopies(199, "abs(")).concat("i").concat(Joiner.on("").join(nCopies(199, ")"))));, +        // 200 elements parser's "circuit breaker" is triggered, +            Joiner.on("").join(nCopies(200, "abs(")).concat("i").concat(Joiner.on("").join(nCopies(200, ")")))));, +        assertEquals("line 1:802: SQL statement too large; halt parsing to prevent memory errors (stopped at depth 200)",, +            e.getMessage());, +        // 200 elements is ok, +        new SqlParser().createExpression(Joiner.on(" + ").join(nCopies(200, "a")));, +        // 201 elements parser's "circuit breaker" is triggered, +            new SqlParser().createExpression(Joiner.on(" + ").join(nCopies(201, "a"))));, +        assertEquals("line 1:802: SQL statement too large; halt parsing to prevent memory errors (stopped at depth 200)",, +            e.getMessage());, +        // 200 elements is ok, +            Joiner.on(" (").join(nCopies(200, "SELECT * FROM")), +                .concat(Joiner.on("").join(nCopies(199, ")"))));, +        // 201 elements parser's "circuit breaker" is triggered, +            Joiner.on(" (").join(nCopies(201, "SELECT * FROM")), +                .concat(Joiner.on("").join(nCopies(200, ")")))));, +        assertEquals("line 1:3002: SQL statement too large; halt parsing to prevent memory errors (stopped at depth 200)",, +            e.getMessage());, +                concat(Joiner.on(" OR ").join(nCopies(180, "true"))).concat(" FROM"), +                concat(Joiner.on(" OR ").join(nCopies(190, "true"))).concat(" FROM"), +        assertEquals("line 1:1628: SQL statement too large; halt parsing to prevent memory errors (stopped at depth 200)",, +            e.getMessage());]