[+++ b/core/src/main/java/org/elasticsearch/cluster/routing/allocation/AllocationService.java, +        changed |= shardsAllocators.moveShards(allocation);, +++ b/core/src/main/java/org/elasticsearch/cluster/routing/allocation/AllocationService.java, +        changed |= shardsAllocators.moveShards(allocation);, +++ b/core/src/main/java/org/elasticsearch/cluster/routing/allocation/allocator/BalancedShardsAllocator.java, +import java.util.ArrayList;, +import java.util.List;, +    public boolean moveShards(RoutingAllocation allocation) {, +        return balancer.moveShards();, +         * Move started shards that can not be allocated to a node anymore, +         *, +         * For each shard to be moved this function executes a move operation, +         * to the minimal eligible node with respect to the, +         * weight function. If a shard is moved the shard will be set to, +         * @return <code>true</code> if the allocation has changed, otherwise <code>false</code>, +        public boolean moveShards() {, +            if (nodes.isEmpty()) {, +                /* with no nodes this is pointless */, +, +            // Create a copy of the started shards interleaving between nodes, and check if they can remain. In the presence of throttling, +            // shard movements, the goal of this iteration order is to achieve a fairer movement of shards from the nodes that are, +            // offloading the shards., +            List<ShardRouting> shards = new ArrayList<>();, +            int index = 0;, +            boolean found = true;, +            while (found) {, +                found = false;, +                for (RoutingNode routingNode : routingNodes) {, +                    if (index >= routingNode.size()) {, +                        continue;, +                    found = true;, +                    ShardRouting shardRouting = routingNode.get(index);, +                    // we can only move started shards..., +                    if (shardRouting.started()) {, +                        shards.add(shardRouting);, +                    }, +                }, +                index++;, +            }, +            if (shards.isEmpty()) {, +                return false;, +            }, +, +            if (changed == false) {, +                final ModelNode[] modelNodes = sorter.modelNodes;, +                for (ShardRouting shardRouting : shards) {, +                    final ModelNode sourceNode = nodes.get(shardRouting.currentNodeId());, +                    assert sourceNode != null && sourceNode.containsShard(shardRouting);, +                    final RoutingNode routingNode = sourceNode.getRoutingNode(routingNodes);, +                    Decision decision = allocation.deciders().canRemain(shardRouting, routingNode, allocation);, +                    if (decision.type() == Decision.Type.NO) {, +                        logger.debug("[{}][{}] allocated on [{}], but can no longer be allocated on it, moving...", shardRouting.index(), shardRouting.id(), routingNode.node());, +                        sorter.reset(shardRouting.getIndexName());, +                        boolean moved = false;, +                        for (ModelNode currentNode : modelNodes) {, +                            if (currentNode == sourceNode) {, +                            Decision allocationDecision = allocation.deciders().canAllocate(shardRouting, target, allocation);, +                            Decision rebalanceDecision = allocation.deciders().canRebalance(shardRouting, allocation);, +                            if (allocationDecision.type() == Type.YES && rebalanceDecision.type() == Type.YES) { // TODO maybe we can respect throttling here too?, +                                Decision sourceDecision = sourceNode.removeShard(shardRouting);, +                                ShardRouting targetRelocatingShard = routingNodes.relocate(shardRouting, target.nodeId(), allocation.clusterInfo().getShardSize(shardRouting, ShardRouting.UNAVAILABLE_EXPECTED_SHARD_SIZE));, +                                // re-add (now relocating shard) to source node, +                                sourceNode.addShard(shardRouting, sourceDecision);, +                                Decision targetDecision = new Decision.Multi().add(allocationDecision).add(rebalanceDecision);, +                                currentNode.addShard(targetRelocatingShard, targetDecision);, +                                    logger.trace("Moved shard [{}] to node [{}]", shardRouting, routingNode.node());, +                                moved = true;, +                        if (moved == false) {, +                            logger.debug("[{}][{}] can't move", shardRouting.index(), shardRouting.id());, +                        }, +                    }, +                }, +++ b/core/src/main/java/org/elasticsearch/cluster/routing/allocation/AllocationService.java, +        changed |= shardsAllocators.moveShards(allocation);, +++ b/core/src/main/java/org/elasticsearch/cluster/routing/allocation/allocator/BalancedShardsAllocator.java, +import java.util.ArrayList;, +import java.util.List;, +    public boolean moveShards(RoutingAllocation allocation) {, +        return balancer.moveShards();, +         * Move started shards that can not be allocated to a node anymore, +         *, +         * For each shard to be moved this function executes a move operation, +         * to the minimal eligible node with respect to the, +         * weight function. If a shard is moved the shard will be set to, +         * @return <code>true</code> if the allocation has changed, otherwise <code>false</code>, +        public boolean moveShards() {, +            if (nodes.isEmpty()) {, +                /* with no nodes this is pointless */, +, +            // Create a copy of the started shards interleaving between nodes, and check if they can remain. In the presence of throttling, +            // shard movements, the goal of this iteration order is to achieve a fairer movement of shards from the nodes that are, +            // offloading the shards., +            List<ShardRouting> shards = new ArrayList<>();, +            int index = 0;, +            boolean found = true;, +            while (found) {, +                found = false;, +                for (RoutingNode routingNode : routingNodes) {, +                    if (index >= routingNode.size()) {, +                        continue;]