[+++ b/plugins/mapper-annotated-text/src/test/java/org/elasticsearch/index/mapper/annotatedtext/AnnotatedTextFieldMapperTests.java, +import org.elasticsearch.index.seqno.SequenceNumbers;, +            sourceToParse, SequenceNumbers.UNASSIGNED_SEQ_NO, 0, IndexRequest.UNSET_AUTO_GENERATED_TIMESTAMP, false);, +            sourceToParse, SequenceNumbers.UNASSIGNED_SEQ_NO, 0, IndexRequest.UNSET_AUTO_GENERATED_TIMESTAMP, false);, +            sourceToParse, SequenceNumbers.UNASSIGNED_SEQ_NO, 0, IndexRequest.UNSET_AUTO_GENERATED_TIMESTAMP, false);, +            sourceToParse, SequenceNumbers.UNASSIGNED_SEQ_NO, 0, IndexRequest.UNSET_AUTO_GENERATED_TIMESTAMP, false);, +++ b/plugins/mapper-annotated-text/src/test/java/org/elasticsearch/index/mapper/annotatedtext/AnnotatedTextFieldMapperTests.java, +import org.elasticsearch.index.seqno.SequenceNumbers;, +            sourceToParse, SequenceNumbers.UNASSIGNED_SEQ_NO, 0, IndexRequest.UNSET_AUTO_GENERATED_TIMESTAMP, false);, +            sourceToParse, SequenceNumbers.UNASSIGNED_SEQ_NO, 0, IndexRequest.UNSET_AUTO_GENERATED_TIMESTAMP, false);, +            sourceToParse, SequenceNumbers.UNASSIGNED_SEQ_NO, 0, IndexRequest.UNSET_AUTO_GENERATED_TIMESTAMP, false);, +            sourceToParse, SequenceNumbers.UNASSIGNED_SEQ_NO, 0, IndexRequest.UNSET_AUTO_GENERATED_TIMESTAMP, false);, +++ b/server/src/main/java/org/elasticsearch/action/bulk/BulkRequest.java, +import org.elasticsearch.index.seqno.SequenceNumbers;, +    private static final ParseField IF_SEQ_NO_MATCH = new ParseField("if_seq_no_match");, +    private static final ParseField IF_PRIMARY_TERM_MATCH = new ParseField("if_primary_term_match");, +                long ifSeqNoMatch = SequenceNumbers.UNASSIGNED_SEQ_NO;, +                long ifPrimaryTermMatch = 0;, +                            } else if (IF_SEQ_NO_MATCH.match(currentFieldName, parser.getDeprecationHandler())) {, +                                ifSeqNoMatch = parser.longValue();, +                            } else if (IF_PRIMARY_TERM_MATCH.match(currentFieldName, parser.getDeprecationHandler())) {, +                                ifPrimaryTermMatch = parser.longValue();, +                    add(new DeleteRequest(index, type, id).routing(routing), +                        .version(version).versionType(versionType).setIfMatch(ifSeqNoMatch, ifPrimaryTermMatch), payload);, +                                    .setPipeline(pipeline).ifMatch(ifSeqNoMatch, ifPrimaryTermMatch), +                                    .create("create".equals(opType)).setPipeline(pipeline).ifMatch(ifSeqNoMatch, ifPrimaryTermMatch), +                                .create(true).setPipeline(pipeline).ifMatch(ifSeqNoMatch, ifPrimaryTermMatch), +++ b/plugins/mapper-annotated-text/src/test/java/org/elasticsearch/index/mapper/annotatedtext/AnnotatedTextFieldMapperTests.java, +import org.elasticsearch.index.seqno.SequenceNumbers;, +            sourceToParse, SequenceNumbers.UNASSIGNED_SEQ_NO, 0, IndexRequest.UNSET_AUTO_GENERATED_TIMESTAMP, false);, +            sourceToParse, SequenceNumbers.UNASSIGNED_SEQ_NO, 0, IndexRequest.UNSET_AUTO_GENERATED_TIMESTAMP, false);, +            sourceToParse, SequenceNumbers.UNASSIGNED_SEQ_NO, 0, IndexRequest.UNSET_AUTO_GENERATED_TIMESTAMP, false);, +            sourceToParse, SequenceNumbers.UNASSIGNED_SEQ_NO, 0, IndexRequest.UNSET_AUTO_GENERATED_TIMESTAMP, false);, +++ b/server/src/main/java/org/elasticsearch/action/bulk/BulkRequest.java, +import org.elasticsearch.index.seqno.SequenceNumbers;, +    private static final ParseField IF_SEQ_NO_MATCH = new ParseField("if_seq_no_match");, +    private static final ParseField IF_PRIMARY_TERM_MATCH = new ParseField("if_primary_term_match");, +                long ifSeqNoMatch = SequenceNumbers.UNASSIGNED_SEQ_NO;, +                long ifPrimaryTermMatch = 0;, +                            } else if (IF_SEQ_NO_MATCH.match(currentFieldName, parser.getDeprecationHandler())) {, +                                ifSeqNoMatch = parser.longValue();, +                            } else if (IF_PRIMARY_TERM_MATCH.match(currentFieldName, parser.getDeprecationHandler())) {, +                                ifPrimaryTermMatch = parser.longValue();, +                    add(new DeleteRequest(index, type, id).routing(routing), +                        .version(version).versionType(versionType).setIfMatch(ifSeqNoMatch, ifPrimaryTermMatch), payload);, +                                    .setPipeline(pipeline).ifMatch(ifSeqNoMatch, ifPrimaryTermMatch), +                                    .create("create".equals(opType)).setPipeline(pipeline).ifMatch(ifSeqNoMatch, ifPrimaryTermMatch), +                                .create(true).setPipeline(pipeline).ifMatch(ifSeqNoMatch, ifPrimaryTermMatch), +++ b/server/src/main/java/org/elasticsearch/action/bulk/TransportShardBulkAction.java, +import org.apache.logging.log4j.Logger;, +                    request.ifSeqNoMatch(), request.ifPrimaryTermMatch(), request.getAutoGeneratedTimestamp(), request.isRetry()),, +            () -> primary.applyDeleteOperationOnPrimary(request.version(), request.type(), request.id(), request.versionType(),, +                request.ifSeqNoMatch(), request.ifPrimaryTermMatch()),, +++ b/plugins/mapper-annotated-text/src/test/java/org/elasticsearch/index/mapper/annotatedtext/AnnotatedTextFieldMapperTests.java, +import org.elasticsearch.index.seqno.SequenceNumbers;, +            sourceToParse, SequenceNumbers.UNASSIGNED_SEQ_NO, 0, IndexRequest.UNSET_AUTO_GENERATED_TIMESTAMP, false);, +            sourceToParse, SequenceNumbers.UNASSIGNED_SEQ_NO, 0, IndexRequest.UNSET_AUTO_GENERATED_TIMESTAMP, false);, +            sourceToParse, SequenceNumbers.UNASSIGNED_SEQ_NO, 0, IndexRequest.UNSET_AUTO_GENERATED_TIMESTAMP, false);, +            sourceToParse, SequenceNumbers.UNASSIGNED_SEQ_NO, 0, IndexRequest.UNSET_AUTO_GENERATED_TIMESTAMP, false);, +++ b/server/src/main/java/org/elasticsearch/action/bulk/BulkRequest.java, +import org.elasticsearch.index.seqno.SequenceNumbers;, +    private static final ParseField IF_SEQ_NO_MATCH = new ParseField("if_seq_no_match");, +    private static final ParseField IF_PRIMARY_TERM_MATCH = new ParseField("if_primary_term_match");, +                long ifSeqNoMatch = SequenceNumbers.UNASSIGNED_SEQ_NO;, +                long ifPrimaryTermMatch = 0;, +                            } else if (IF_SEQ_NO_MATCH.match(currentFieldName, parser.getDeprecationHandler())) {, +                                ifSeqNoMatch = parser.longValue();, +                            } else if (IF_PRIMARY_TERM_MATCH.match(currentFieldName, parser.getDeprecationHandler())) {, +                                ifPrimaryTermMatch = parser.longValue();, +                    add(new DeleteRequest(index, type, id).routing(routing), +                        .version(version).versionType(versionType).setIfMatch(ifSeqNoMatch, ifPrimaryTermMatch), payload);, +                                    .setPipeline(pipeline).ifMatch(ifSeqNoMatch, ifPrimaryTermMatch), +                                    .create("create".equals(opType)).setPipeline(pipeline).ifMatch(ifSeqNoMatch, ifPrimaryTermMatch), +                                .create(true).setPipeline(pipeline).ifMatch(ifSeqNoMatch, ifPrimaryTermMatch), +++ b/server/src/main/java/org/elasticsearch/action/bulk/TransportShardBulkAction.java, +import org.apache.logging.log4j.Logger;, +                    request.ifSeqNoMatch(), request.ifPrimaryTermMatch(), request.getAutoGeneratedTimestamp(), request.isRetry()),, +            () -> primary.applyDeleteOperationOnPrimary(request.version(), request.type(), request.id(), request.versionType(),, +                request.ifSeqNoMatch(), request.ifPrimaryTermMatch()),, +++ b/server/src/main/java/org/elasticsearch/action/delete/DeleteRequest.java, +import org.elasticsearch.index.seqno.SequenceNumbers;, +    private long ifSeqNoMatch = SequenceNumbers.UNASSIGNED_SEQ_NO;, +    private long ifPrimaryTermMatch = 0;, +, +        if (ifSeqNoMatch != SequenceNumbers.UNASSIGNED_SEQ_NO && (, +            versionType != VersionType.INTERNAL || version != Versions.MATCH_ANY, +        )) {, +            validationException = addValidationError("compare and write operations can not use versioning", validationException);, +        }, +    public long ifSeqNoMatch() {, +        return ifSeqNoMatch;, +    }, +, +    public long ifPrimaryTermMatch() {, +        return ifPrimaryTermMatch;, +    }, +, +    public DeleteRequest setIfMatch(long seqNo, long term) {, +        if (term == 0 && seqNo != SequenceNumbers.UNASSIGNED_SEQ_NO) {, +            throw new IllegalArgumentException("seqNo is set, but primary term is [0]");]