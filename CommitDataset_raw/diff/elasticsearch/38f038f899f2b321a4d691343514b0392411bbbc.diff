[+++ b/src/main/java/org/elasticsearch/index/cache/id/simple/SimpleIdCache.java, +import org.elasticsearch.index.mapper.DocumentMapper;, +import org.elasticsearch.index.mapper.DocumentTypeListener;, +import java.util.concurrent.atomic.AtomicReference;, +public class SimpleIdCache extends AbstractIndexComponent implements IdCache, SegmentReader.CoreClosedListener, DocumentTypeListener {, +    private final ConcurrentMap<Object, SimpleIdReaderCache> idReaders;, +    private final AtomicReference<NavigableSet<HashedBytesArray>> parentTypesHolder;, +        reuse = componentSettings.getAsBoolean("reuse", false);, +        parentTypesHolder = new AtomicReference<NavigableSet<HashedBytesArray>>(new TreeSet<HashedBytesArray>(UTF8SortedAsUnicodeComparator.utf8SortedAsUnicodeSortOrder));, +        indexService.mapperService().addTypeListener(this);, +        indexService.mapperService().removeTypeListener(this);, +                NavigableSet<HashedBytesArray> parentTypes = this.parentTypesHolder.get();, +                    if (!refreshNeeded(context)) {, +                            // We don't want to load uid of child documents, this allows us to not load uids of child types., +                    if (!refreshNeeded(context)) {, +            if (refreshNeeded(atomicReaderContext)) {, +    private boolean refreshNeeded(AtomicReaderContext atomicReaderContext) {, +        return !idReaders.containsKey(atomicReaderContext.reader().getCoreCacheKey());, +    }, +, +    @Override, +    public void beforeCreate(DocumentMapper mapper) {, +        NavigableSet<HashedBytesArray> parentTypes = parentTypesHolder.get();, +        ParentFieldMapper parentFieldMapper = mapper.parentFieldMapper();, +        if (parentFieldMapper.active()) {, +            // A _parent field can never be added to an existing mapping, so a _parent field either exists on, +            // a new created or doesn't exists. This is why we can update the known parent types via DocumentTypeListener, +            if (parentTypes.add(new HashedBytesArray(Strings.toUTF8Bytes(parentFieldMapper.type(), new BytesRef())))) {, +                parentTypesHolder.set(parentTypes);, +                clear();, +            }, +        }, +    }, +, +    @Override, +    public void afterRemove(DocumentMapper mapper) {, +        NavigableSet<HashedBytesArray> parentTypes = parentTypesHolder.get();, +        ParentFieldMapper parentFieldMapper = mapper.parentFieldMapper();, +        if (parentFieldMapper.active()) {, +            parentTypes.remove(new HashedBytesArray(Strings.toUTF8Bytes(parentFieldMapper.type(), new BytesRef())));, +            parentTypesHolder.set(parentTypes);, +        }, +    }, +, +++ b/src/main/java/org/elasticsearch/index/cache/id/simple/SimpleIdCache.java, +import org.elasticsearch.index.mapper.DocumentMapper;, +import org.elasticsearch.index.mapper.DocumentTypeListener;, +import java.util.concurrent.atomic.AtomicReference;, +public class SimpleIdCache extends AbstractIndexComponent implements IdCache, SegmentReader.CoreClosedListener, DocumentTypeListener {, +    private final ConcurrentMap<Object, SimpleIdReaderCache> idReaders;, +    private final AtomicReference<NavigableSet<HashedBytesArray>> parentTypesHolder;, +        reuse = componentSettings.getAsBoolean("reuse", false);, +        parentTypesHolder = new AtomicReference<NavigableSet<HashedBytesArray>>(new TreeSet<HashedBytesArray>(UTF8SortedAsUnicodeComparator.utf8SortedAsUnicodeSortOrder));, +        indexService.mapperService().addTypeListener(this);, +        indexService.mapperService().removeTypeListener(this);, +                NavigableSet<HashedBytesArray> parentTypes = this.parentTypesHolder.get();, +                    if (!refreshNeeded(context)) {, +                            // We don't want to load uid of child documents, this allows us to not load uids of child types., +                    if (!refreshNeeded(context)) {, +            if (refreshNeeded(atomicReaderContext)) {, +    private boolean refreshNeeded(AtomicReaderContext atomicReaderContext) {, +        return !idReaders.containsKey(atomicReaderContext.reader().getCoreCacheKey());, +    }, +, +    @Override, +    public void beforeCreate(DocumentMapper mapper) {, +        NavigableSet<HashedBytesArray> parentTypes = parentTypesHolder.get();, +        ParentFieldMapper parentFieldMapper = mapper.parentFieldMapper();, +        if (parentFieldMapper.active()) {, +            // A _parent field can never be added to an existing mapping, so a _parent field either exists on, +            // a new created or doesn't exists. This is why we can update the known parent types via DocumentTypeListener, +            if (parentTypes.add(new HashedBytesArray(Strings.toUTF8Bytes(parentFieldMapper.type(), new BytesRef())))) {, +                parentTypesHolder.set(parentTypes);, +                clear();, +            }, +        }, +    }, +, +    @Override, +    public void afterRemove(DocumentMapper mapper) {, +        NavigableSet<HashedBytesArray> parentTypes = parentTypesHolder.get();, +        ParentFieldMapper parentFieldMapper = mapper.parentFieldMapper();, +        if (parentFieldMapper.active()) {, +            parentTypes.remove(new HashedBytesArray(Strings.toUTF8Bytes(parentFieldMapper.type(), new BytesRef())));, +            parentTypesHolder.set(parentTypes);, +        }, +    }, +, +++ b/src/main/java/org/elasticsearch/index/mapper/DocumentTypeListener.java, +     * @param mapper The new document mapper of the type being added, +    void beforeCreate(DocumentMapper mapper);, +     * @param mapper The existing document mapper of the type being removed, +    void afterRemove(DocumentMapper mapper);, +++ b/src/main/java/org/elasticsearch/index/cache/id/simple/SimpleIdCache.java, +import org.elasticsearch.index.mapper.DocumentMapper;, +import org.elasticsearch.index.mapper.DocumentTypeListener;, +import java.util.concurrent.atomic.AtomicReference;, +public class SimpleIdCache extends AbstractIndexComponent implements IdCache, SegmentReader.CoreClosedListener, DocumentTypeListener {, +    private final ConcurrentMap<Object, SimpleIdReaderCache> idReaders;, +    private final AtomicReference<NavigableSet<HashedBytesArray>> parentTypesHolder;]