[+++ b/modules/ingest-common/src/main/java/org/elasticsearch/ingest/common/DateFormat.java, +, +            // support the 6.x BWC compatible way of parsing java 8 dates, +                format = format.substring(1);, +            }, +, +            int year = LocalDate.now(ZoneOffset.UTC).getYear();, +++ b/modules/ingest-common/src/main/java/org/elasticsearch/ingest/common/DateFormat.java, +, +            // support the 6.x BWC compatible way of parsing java 8 dates, +                format = format.substring(1);, +            }, +, +            int year = LocalDate.now(ZoneOffset.UTC).getYear();, +++ b/modules/ingest-common/src/main/java/org/elasticsearch/ingest/common/DateIndexNameProcessor.java, +                dateFormatStrings = Collections.singletonList("yyyy-MM-dd'T'HH:mm:ss.SSSXX");, +++ b/modules/ingest-common/src/main/java/org/elasticsearch/ingest/common/DateFormat.java, +, +            // support the 6.x BWC compatible way of parsing java 8 dates, +                format = format.substring(1);, +            }, +, +            int year = LocalDate.now(ZoneOffset.UTC).getYear();, +++ b/modules/ingest-common/src/main/java/org/elasticsearch/ingest/common/DateIndexNameProcessor.java, +                dateFormatStrings = Collections.singletonList("yyyy-MM-dd'T'HH:mm:ss.SSSXX");, +++ b/modules/ingest-common/src/test/java/org/elasticsearch/ingest/common/DateIndexNameProcessorTests.java, +    public void testJavaPattern() throws Exception {, +        Function<String, DateTime> function = DateFormat.Java.getFunction("yyyy-MM-dd'T'HH:mm:ss.SSSXX", DateTimeZone.UTC, Locale.ROOT);, +        String indexNameFormat = randomFrom("yyyy-MM-dd'T'HH:mm:ss.SSSXX", "yyyyMMdd", "MM/dd/yyyy");, +++ b/modules/ingest-common/src/main/java/org/elasticsearch/ingest/common/DateFormat.java, +, +            // support the 6.x BWC compatible way of parsing java 8 dates, +                format = format.substring(1);, +            }, +, +            int year = LocalDate.now(ZoneOffset.UTC).getYear();, +++ b/modules/ingest-common/src/main/java/org/elasticsearch/ingest/common/DateIndexNameProcessor.java, +                dateFormatStrings = Collections.singletonList("yyyy-MM-dd'T'HH:mm:ss.SSSXX");, +++ b/modules/ingest-common/src/test/java/org/elasticsearch/ingest/common/DateIndexNameProcessorTests.java, +    public void testJavaPattern() throws Exception {, +        Function<String, DateTime> function = DateFormat.Java.getFunction("yyyy-MM-dd'T'HH:mm:ss.SSSXX", DateTimeZone.UTC, Locale.ROOT);, +        String indexNameFormat = randomFrom("yyyy-MM-dd'T'HH:mm:ss.SSSXX", "yyyyMMdd", "MM/dd/yyyy");, +++ b/modules/ingest-common/src/test/java/org/elasticsearch/ingest/common/DateProcessorTests.java, +, +    public void testJavaPattern() {, +                "date_as_string", Collections.singletonList("yyyy dd MM HH:mm:ss"), "date_as_date");, +    public void testJavaPatternMultipleFormats() {, +    public void testInvalidJavaPattern() {, +            assertThat(e.getCause().getMessage(), equalTo("Invalid format: [invalid pattern]: Unknown pattern letter: i"));, +    public void testJavaPatternLocale() {, +                "date_as_string", Collections.singletonList("yyyy dd MMMM"), "date_as_date");, +    public void testJavaPatternDefaultYear() {, +++ b/modules/ingest-common/src/main/java/org/elasticsearch/ingest/common/DateFormat.java, +, +            // support the 6.x BWC compatible way of parsing java 8 dates, +                format = format.substring(1);, +            }, +, +            int year = LocalDate.now(ZoneOffset.UTC).getYear();, +++ b/modules/ingest-common/src/main/java/org/elasticsearch/ingest/common/DateIndexNameProcessor.java, +                dateFormatStrings = Collections.singletonList("yyyy-MM-dd'T'HH:mm:ss.SSSXX");, +++ b/modules/ingest-common/src/test/java/org/elasticsearch/ingest/common/DateIndexNameProcessorTests.java, +    public void testJavaPattern() throws Exception {, +        Function<String, DateTime> function = DateFormat.Java.getFunction("yyyy-MM-dd'T'HH:mm:ss.SSSXX", DateTimeZone.UTC, Locale.ROOT);, +        String indexNameFormat = randomFrom("yyyy-MM-dd'T'HH:mm:ss.SSSXX", "yyyyMMdd", "MM/dd/yyyy");, +++ b/modules/ingest-common/src/test/java/org/elasticsearch/ingest/common/DateProcessorTests.java, +, +    public void testJavaPattern() {, +                "date_as_string", Collections.singletonList("yyyy dd MM HH:mm:ss"), "date_as_date");, +    public void testJavaPatternMultipleFormats() {, +    public void testInvalidJavaPattern() {, +            assertThat(e.getCause().getMessage(), equalTo("Invalid format: [invalid pattern]: Unknown pattern letter: i"));, +    public void testJavaPatternLocale() {, +                "date_as_string", Collections.singletonList("yyyy dd MMMM"), "date_as_date");, +    public void testJavaPatternDefaultYear() {, +++ b/qa/smoke-test-ingest-with-all-dependencies/src/test/resources/rest-api-spec/test/ingest/20_combine_processors.yml, +"Test with date processor":, +      reason: pre-7.0.0 requires the 8 prefix for Java time formats, so would treat the format in this test as a Joda time format, +                  "formats" : ["dd/MMM/yyyy:HH:mm:ss xx"]]