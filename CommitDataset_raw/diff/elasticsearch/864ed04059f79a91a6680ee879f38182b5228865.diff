[+++ b/core/src/main/java/org/elasticsearch/common/unit/Fuzziness.java, +        return Math.min(2, (int) asFloat());, +++ b/core/src/main/java/org/elasticsearch/common/unit/Fuzziness.java, +        return Math.min(2, (int) asFloat());, +++ b/core/src/main/java/org/elasticsearch/index/mapper/MappedFieldType.java, +import org.apache.lucene.search.BooleanClause.Occur;, +import org.apache.lucene.search.BooleanQuery;, +    public abstract Query termQuery(Object value, @Nullable QueryShardContext context);, +    /** Build a constant-scoring query that matches all values. The default implementation uses a, +     * {@link ConstantScoreQuery} around a {@link BooleanQuery} whose {@link Occur#SHOULD} clauses, +     * are generated with {@link #termQuery}. */, +    public Query termsQuery(List<?> values, @Nullable QueryShardContext context) {, +        BooleanQuery.Builder builder = new BooleanQuery.Builder();, +        for (Object value : values) {, +            builder.add(termQuery(value, context), Occur.SHOULD);, +        return new ConstantScoreQuery(builder.build());, +        throw new IllegalArgumentException("Field [" + name + "] of type [" + typeName() + "] does not support range queries");, +        throw new IllegalArgumentException("Can only use fuzzy queries on keyword and text fields - not on [" + name + "] which is of type [" + typeName() + "]");, +    public Query prefixQuery(String value, @Nullable MultiTermQuery.RewriteMethod method, QueryShardContext context) {, +        throw new QueryShardException(context, "Can only use prefix queries on keyword and text fields - not on [" + name + "] which is of type [" + typeName() + "]");, +    public Query regexpQuery(String value, int flags, int maxDeterminizedStates, @Nullable MultiTermQuery.RewriteMethod method, QueryShardContext context) {, +        throw new QueryShardException(context, "Can only use regexp queries on keyword and text fields - not on [" + name + "] which is of type [" + typeName() + "]");, +++ b/core/src/main/java/org/elasticsearch/common/unit/Fuzziness.java, +        return Math.min(2, (int) asFloat());, +++ b/core/src/main/java/org/elasticsearch/index/mapper/MappedFieldType.java, +import org.apache.lucene.search.BooleanClause.Occur;, +import org.apache.lucene.search.BooleanQuery;, +    public abstract Query termQuery(Object value, @Nullable QueryShardContext context);, +    /** Build a constant-scoring query that matches all values. The default implementation uses a, +     * {@link ConstantScoreQuery} around a {@link BooleanQuery} whose {@link Occur#SHOULD} clauses, +     * are generated with {@link #termQuery}. */, +    public Query termsQuery(List<?> values, @Nullable QueryShardContext context) {, +        BooleanQuery.Builder builder = new BooleanQuery.Builder();, +        for (Object value : values) {, +            builder.add(termQuery(value, context), Occur.SHOULD);, +        return new ConstantScoreQuery(builder.build());, +        throw new IllegalArgumentException("Field [" + name + "] of type [" + typeName() + "] does not support range queries");, +        throw new IllegalArgumentException("Can only use fuzzy queries on keyword and text fields - not on [" + name + "] which is of type [" + typeName() + "]");, +    public Query prefixQuery(String value, @Nullable MultiTermQuery.RewriteMethod method, QueryShardContext context) {, +        throw new QueryShardException(context, "Can only use prefix queries on keyword and text fields - not on [" + name + "] which is of type [" + typeName() + "]");, +    public Query regexpQuery(String value, int flags, int maxDeterminizedStates, @Nullable MultiTermQuery.RewriteMethod method, QueryShardContext context) {, +        throw new QueryShardException(context, "Can only use regexp queries on keyword and text fields - not on [" + name + "] which is of type [" + typeName() + "]");, +++ b/core/src/main/java/org/elasticsearch/index/mapper/StringFieldType.java, +/*, + * Licensed to Elasticsearch under one or more contributor, + * license agreements. See the NOTICE file distributed with, + * this work for additional information regarding copyright, + * ownership. Elasticsearch licenses this file to you under, + * the Apache License, Version 2.0 (the "License"); you may, + * not use this file except in compliance with the License., + * You may obtain a copy of the License at, + *, + *    http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing,, + * software distributed under the License is distributed on an, + * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY, + * KIND, either express or implied.  See the License for the, + * specific language governing permissions and limitations, + * under the License., + */, +, +package org.elasticsearch.index.mapper;, +, +import java.util.List;, +, +import org.apache.lucene.index.Term;, +import org.apache.lucene.queries.TermsQuery;, +import org.apache.lucene.search.FuzzyQuery;, +import org.apache.lucene.search.MultiTermQuery;, +import org.apache.lucene.search.PrefixQuery;, +import org.apache.lucene.search.Query;, +import org.apache.lucene.search.RegexpQuery;, +import org.apache.lucene.search.TermRangeQuery;, +import org.apache.lucene.util.BytesRef;, +import org.elasticsearch.common.lucene.BytesRefs;, +import org.elasticsearch.common.unit.Fuzziness;, +import org.elasticsearch.index.query.QueryShardContext;, +, +/** Base class for {@link MappedFieldType} implementations that use the same, + * representation for internal index terms as the external representation so, + * that partial matching queries such as prefix, wildcard and fuzzy queries, + * can be implemented. */, +public abstract class StringFieldType extends TermBasedFieldType {, +, +    public StringFieldType() {}, +, +    protected StringFieldType(MappedFieldType ref) {, +        super(ref);, +    }, +, +    public Query termsQuery(List<?> values, QueryShardContext context) {, +        failIfNotIndexed();, +        BytesRef[] bytesRefs = new BytesRef[values.size()];, +        for (int i = 0; i < bytesRefs.length; i++) {, +            bytesRefs[i] = indexedValueForSearch(values.get(i));, +        }, +        return new TermsQuery(name(), bytesRefs);, +    }, +]