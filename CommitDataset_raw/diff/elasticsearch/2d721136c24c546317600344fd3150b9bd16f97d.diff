[+++ b/x-pack/plugin/index-lifecycle/src/main/java/org/elasticsearch/xpack/indexlifecycle/IndexLifecycleService.java, +                scheduleJob(pollInterval);, +            } else if (scheduledJob == null) {, +                scheduleJob(pollInterval);, +                scheduleJob(pollInterval);, +            }, +        } else {, +            cancelJob();, +        }, +    }, +, +    private void cancelJob() {, +        if (scheduler.get() != null) {, +            scheduler.get().remove(IndexLifecycle.NAME);, +            scheduledJob = null;, +        }, +    }, +, +    private void scheduleJob(TimeValue pollInterval) {, +        scheduledJob = new SchedulerEngine.Job(IndexLifecycle.NAME, new TimeValueSchedule(pollInterval));, +++ b/x-pack/plugin/index-lifecycle/src/main/java/org/elasticsearch/xpack/indexlifecycle/IndexLifecycleService.java, +                scheduleJob(pollInterval);, +            } else if (scheduledJob == null) {, +                scheduleJob(pollInterval);, +                scheduleJob(pollInterval);, +            }, +        } else {, +            cancelJob();, +        }, +    }, +, +    private void cancelJob() {, +        if (scheduler.get() != null) {, +            scheduler.get().remove(IndexLifecycle.NAME);, +            scheduledJob = null;, +        }, +    }, +, +    private void scheduleJob(TimeValue pollInterval) {, +        scheduledJob = new SchedulerEngine.Job(IndexLifecycle.NAME, new TimeValueSchedule(pollInterval));, +++ b/x-pack/plugin/index-lifecycle/src/test/java/org/elasticsearch/xpack/indexlifecycle/IndexLifecycleServiceTests.java, +    public void testElectUnElectMaster() throws Exception {, +        MetaData metaData = MetaData.builder(), +            .persistentSettings(settings(Version.CURRENT), +                .put(IndexLifecycle.LIFECYCLE_POLL_INTERVAL_SETTING.getKey(), TimeValue.timeValueSeconds(3)).build()), +                .putCustom(IndexLifecycleMetadata.TYPE, new IndexLifecycleMetadata(Collections.emptySortedMap())), +            .build();, +, +        // First check that when the node has never been master the scheduler, +        // and job are not set up, +        ClusterState state = ClusterState.builder(ClusterName.DEFAULT), +            .metaData(metaData), +            .nodes(DiscoveryNodes.builder().localNodeId(nodeId + "not").masterNodeId(nodeId).add(masterNode).build()), +            .build();, +        ClusterChangedEvent event = new ClusterChangedEvent("_source", state, state);, +, +        indexLifecycleService.clusterChanged(event);, +        verify(clusterService, only()).addListener(any());, +        assertNull(indexLifecycleService.getScheduler());, +        assertNull(indexLifecycleService.getScheduledJob());, +        , +        Mockito.reset(clusterService);, +        state = ClusterState.builder(ClusterName.DEFAULT), +                .metaData(metaData), +                .nodes(DiscoveryNodes.builder().localNodeId(nodeId).masterNodeId(nodeId).add(masterNode).build()), +                .build();, +        event = new ClusterChangedEvent("_source", state, state);, +, +        // Check that when the node is first elected as master it sets up, +        // the scheduler and job, +        indexLifecycleService.clusterChanged(event);, +        Mockito.verifyZeroInteractions(clusterService);, +        assertNotNull(indexLifecycleService.getScheduler());, +        assertEquals(1, indexLifecycleService.getScheduler().jobCount());, +        assertNotNull(indexLifecycleService.getScheduledJob());, +        , +        Mockito.reset(clusterService);, +        state = ClusterState.builder(ClusterName.DEFAULT), +                .metaData(metaData), +                .nodes(DiscoveryNodes.builder().localNodeId(nodeId + "not").masterNodeId(nodeId).add(masterNode).build()), +                .build();, +        event = new ClusterChangedEvent("_source", state, state);, +, +        // Check that when the node is un-elected as master it cancels the job, +        indexLifecycleService.clusterChanged(event);, +        Mockito.verifyZeroInteractions(clusterService);, +        assertNotNull(indexLifecycleService.getScheduler());, +        assertEquals(0, indexLifecycleService.getScheduler().jobCount());, +        assertNull(indexLifecycleService.getScheduledJob());, +        , +        Mockito.reset(clusterService);, +        state = ClusterState.builder(ClusterName.DEFAULT), +                .metaData(metaData), +                .nodes(DiscoveryNodes.builder().localNodeId(nodeId).masterNodeId(nodeId).add(masterNode).build()), +                .build();, +        event = new ClusterChangedEvent("_source", state, state);, +, +        // Check that when the node is re-elected as master it cancels the job, +        indexLifecycleService.clusterChanged(event);, +        Mockito.verifyZeroInteractions(clusterService);]