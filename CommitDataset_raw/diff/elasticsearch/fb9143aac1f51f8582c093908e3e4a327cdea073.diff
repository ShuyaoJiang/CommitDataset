[+++ b/src/main/java/org/elasticsearch/cluster/metadata/MetaDataCreateIndexService.java, +                            mapperService.merge(MapperService.DEFAULT_MAPPING, XContentFactory.jsonBuilder().map(mappings.get(MapperService.DEFAULT_MAPPING)).string(), false);, +                            mapperService.merge(entry.getKey(), XContentFactory.jsonBuilder().map(entry.getValue()).string(), true);, +++ b/src/main/java/org/elasticsearch/cluster/metadata/MetaDataCreateIndexService.java, +                            mapperService.merge(MapperService.DEFAULT_MAPPING, XContentFactory.jsonBuilder().map(mappings.get(MapperService.DEFAULT_MAPPING)).string(), false);, +                            mapperService.merge(entry.getKey(), XContentFactory.jsonBuilder().map(entry.getValue()).string(), true);, +++ b/src/main/java/org/elasticsearch/cluster/metadata/MetaDataMappingService.java, +                                indexService.mapperService().merge(type, indexMetaData.mappings().get(type).source().string(), false);, +                            indexService.mapperService().merge(type, indexMetaData.mappings().get(type).source().string(), false);, +                    DocumentMapper updatedMapper = indexService.mapperService().merge(type, mappingSource.string(), false);, +                    if (indexMetaData.mappings().containsKey(type) && indexMetaData.mapping(type).source().equals(updatedMapper.mappingSource())) {, +                            logger.debug("[{}] update_mapping [{}] (dynamic) with source [{}]", index, type, updatedMapper.mappingSource().string());, +                    builder.put(newIndexMetaDataBuilder(indexMetaData).putMapping(new MappingMetaData(updatedMapper)));, +                            indexService.mapperService().merge(request.mappingType, indexMetaData.mappings().get(request.mappingType).source().string(), false);, +                        IndexService indexService = indicesService.indexService(index);, +                        CompressedString existingSource = null;, +                            existingSource = existingMappers.get(entry.getKey()).mappingSource();, +                        }, +                        DocumentMapper mergedMapper = indexService.mapperService().merge(newMapper.type(), newMapper.mappingSource().string(), false);, +                        CompressedString updatedSource = mergedMapper.mappingSource();, +                        if (existingSource != null) {, +                                mappings.put(index, new MappingMetaData(mergedMapper));, +                                    logger.debug("[{}] update_mapping [{}] with source [{}]", index, mergedMapper.type(), updatedSource);, +                                    logger.info("[{}] update_mapping [{}]", index, mergedMapper.type());, +                            mappings.put(index, new MappingMetaData(mergedMapper));, +                                logger.debug("[{}] create_mapping [{}] with source [{}]", index, newMapper.type(), updatedSource);, +++ b/src/main/java/org/elasticsearch/cluster/metadata/MetaDataCreateIndexService.java, +                            mapperService.merge(MapperService.DEFAULT_MAPPING, XContentFactory.jsonBuilder().map(mappings.get(MapperService.DEFAULT_MAPPING)).string(), false);, +                            mapperService.merge(entry.getKey(), XContentFactory.jsonBuilder().map(entry.getValue()).string(), true);, +++ b/src/main/java/org/elasticsearch/cluster/metadata/MetaDataMappingService.java, +                                indexService.mapperService().merge(type, indexMetaData.mappings().get(type).source().string(), false);, +                            indexService.mapperService().merge(type, indexMetaData.mappings().get(type).source().string(), false);, +                    DocumentMapper updatedMapper = indexService.mapperService().merge(type, mappingSource.string(), false);, +                    if (indexMetaData.mappings().containsKey(type) && indexMetaData.mapping(type).source().equals(updatedMapper.mappingSource())) {, +                            logger.debug("[{}] update_mapping [{}] (dynamic) with source [{}]", index, type, updatedMapper.mappingSource().string());, +                    builder.put(newIndexMetaDataBuilder(indexMetaData).putMapping(new MappingMetaData(updatedMapper)));, +                            indexService.mapperService().merge(request.mappingType, indexMetaData.mappings().get(request.mappingType).source().string(), false);, +                        IndexService indexService = indicesService.indexService(index);, +                        CompressedString existingSource = null;, +                            existingSource = existingMappers.get(entry.getKey()).mappingSource();, +                        }, +                        DocumentMapper mergedMapper = indexService.mapperService().merge(newMapper.type(), newMapper.mappingSource().string(), false);, +                        CompressedString updatedSource = mergedMapper.mappingSource();, +                        if (existingSource != null) {, +                                mappings.put(index, new MappingMetaData(mergedMapper));, +                                    logger.debug("[{}] update_mapping [{}] with source [{}]", index, mergedMapper.type(), updatedSource);, +                                    logger.info("[{}] update_mapping [{}]", index, mergedMapper.type());, +                            mappings.put(index, new MappingMetaData(mergedMapper));, +                                logger.debug("[{}] create_mapping [{}] with source [{}]", index, newMapper.type(), updatedSource);, +++ b/src/main/java/org/elasticsearch/index/mapper/MapperService.java, +import java.util.Arrays;, +import static org.elasticsearch.index.mapper.DocumentMapper.MergeFlags.mergeFlags;, +    public DocumentMapper merge(String type, String mappingSource, boolean applyDefault) {, +            return mapper;, +            return merge(parse(type, mappingSource, applyDefault));, +    private DocumentMapper merge(DocumentMapper mapper) {, +            if (oldMapper != null) {, +                DocumentMapper.MergeResult result = oldMapper.merge(mapper, mergeFlags().simulate(false));, +                if (result.hasConflicts()) {, +                    // TODO: What should we do???, +                    if (logger.isDebugEnabled()) {, +                        logger.debug("merging mapping for type [{}] resulted in conflicts: [{}]", mapper.type(), Arrays.toString(result.conflicts()));, +                    }, +                }, +                return oldMapper;, +            } else {, +                return mapper;, +            merge(type, null, true);, +++ b/src/main/java/org/elasticsearch/cluster/metadata/MetaDataCreateIndexService.java, +                            mapperService.merge(MapperService.DEFAULT_MAPPING, XContentFactory.jsonBuilder().map(mappings.get(MapperService.DEFAULT_MAPPING)).string(), false);, +                            mapperService.merge(entry.getKey(), XContentFactory.jsonBuilder().map(entry.getValue()).string(), true);, +++ b/src/main/java/org/elasticsearch/cluster/metadata/MetaDataMappingService.java, +                                indexService.mapperService().merge(type, indexMetaData.mappings().get(type).source().string(), false);, +                            indexService.mapperService().merge(type, indexMetaData.mappings().get(type).source().string(), false);, +                    DocumentMapper updatedMapper = indexService.mapperService().merge(type, mappingSource.string(), false);, +                    if (indexMetaData.mappings().containsKey(type) && indexMetaData.mapping(type).source().equals(updatedMapper.mappingSource())) {, +                            logger.debug("[{}] update_mapping [{}] (dynamic) with source [{}]", index, type, updatedMapper.mappingSource().string());, +                    builder.put(newIndexMetaDataBuilder(indexMetaData).putMapping(new MappingMetaData(updatedMapper)));, +                            indexService.mapperService().merge(request.mappingType, indexMetaData.mappings().get(request.mappingType).source().string(), false);, +                        IndexService indexService = indicesService.indexService(index);, +                        CompressedString existingSource = null;, +                            existingSource = existingMappers.get(entry.getKey()).mappingSource();, +                        }, +                        DocumentMapper mergedMapper = indexService.mapperService().merge(newMapper.type(), newMapper.mappingSource().string(), false);, +                        CompressedString updatedSource = mergedMapper.mappingSource();, +                        if (existingSource != null) {, +                                mappings.put(index, new MappingMetaData(mergedMapper));, +                                    logger.debug("[{}] update_mapping [{}] with source [{}]", index, mergedMapper.type(), updatedSource);, +                                    logger.info("[{}] update_mapping [{}]", index, mergedMapper.type());, +                            mappings.put(index, new MappingMetaData(mergedMapper));, +                                logger.debug("[{}] create_mapping [{}] with source [{}]", index, newMapper.type(), updatedSource);, +++ b/src/main/java/org/elasticsearch/index/mapper/MapperService.java, +import java.util.Arrays;, +import static org.elasticsearch.index.mapper.DocumentMapper.MergeFlags.mergeFlags;, +    public DocumentMapper merge(String type, String mappingSource, boolean applyDefault) {, +            return mapper;, +            return merge(parse(type, mappingSource, applyDefault));, +    private DocumentMapper merge(DocumentMapper mapper) {, +            if (oldMapper != null) {, +                DocumentMapper.MergeResult result = oldMapper.merge(mapper, mergeFlags().simulate(false));]