[+++ b/core/src/main/java/org/elasticsearch/action/admin/cluster/state/TransportClusterStateAction.java, +                String[] indices = indexNameExpressionResolver.concreteIndexNames(currentState, request);, +                for (String filteredIndex : indices) {, +++ b/core/src/main/java/org/elasticsearch/action/admin/cluster/state/TransportClusterStateAction.java, +                String[] indices = indexNameExpressionResolver.concreteIndexNames(currentState, request);, +                for (String filteredIndex : indices) {, +++ b/core/src/test/java/org/elasticsearch/cluster/SimpleClusterStateIT.java, +import org.elasticsearch.cluster.metadata.MetaData;, +import org.elasticsearch.cluster.routing.RoutingTable;, +import org.elasticsearch.common.Strings;, +import org.elasticsearch.common.collect.ImmutableOpenMap;, +        testFilteringByIndexWorks(new String[]{"foo", "fuu", "non-existent"}, new String[]{"foo", "fuu"});, +        testFilteringByIndexWorks(new String[]{"baz"}, new String[]{"baz"});, +        testFilteringByIndexWorks(new String[]{"f*"}, new String[]{"foo", "fuu"});, +        testFilteringByIndexWorks(new String[]{"b*"}, new String[]{"baz"});, +        testFilteringByIndexWorks(new String[]{"*u"}, new String[]{"fuu"});, +        String[] randomIndices = randomFrom(new String[]{"*"}, new String[]{MetaData.ALL}, Strings.EMPTY_ARRAY, new String[]{"f*", "b*"});, +        testFilteringByIndexWorks(randomIndices, new String[]{"foo", "fuu", "baz"});, +    }, +    /**, +     * Retrieves the cluster state for the given indices and then checks, +     * that the cluster state returns coherent data for both routing table and metadata., +     */, +    private void testFilteringByIndexWorks(String[] indices, String[] expected) {, +        ClusterStateResponse clusterState = client().admin().cluster().prepareState(), +                                                                            .clear(), +                                                                            .setMetaData(true), +                                                                            .setRoutingTable(true), +                                                                            .setIndices(indices), +                                                                            .get();, +, +        ImmutableOpenMap<String, IndexMetaData> metaData = clusterState.getState().getMetaData().indices();, +        assertThat(metaData.size(), is(expected.length));, +, +        RoutingTable routingTable = clusterState.getState().getRoutingTable();, +        assertThat(routingTable.indicesRouting().size(), is(expected.length));, +, +        for (String expectedIndex : expected) {, +            assertThat(metaData, CollectionAssertions.hasKey(expectedIndex));, +            assertThat(routingTable.hasIndex(expectedIndex), is(true));, +        }, +++ b/core/src/main/java/org/elasticsearch/action/admin/cluster/state/TransportClusterStateAction.java, +                String[] indices = indexNameExpressionResolver.concreteIndexNames(currentState, request);, +                for (String filteredIndex : indices) {, +++ b/core/src/test/java/org/elasticsearch/cluster/SimpleClusterStateIT.java, +import org.elasticsearch.cluster.metadata.MetaData;, +import org.elasticsearch.cluster.routing.RoutingTable;, +import org.elasticsearch.common.Strings;, +import org.elasticsearch.common.collect.ImmutableOpenMap;, +        testFilteringByIndexWorks(new String[]{"foo", "fuu", "non-existent"}, new String[]{"foo", "fuu"});, +        testFilteringByIndexWorks(new String[]{"baz"}, new String[]{"baz"});, +        testFilteringByIndexWorks(new String[]{"f*"}, new String[]{"foo", "fuu"});, +        testFilteringByIndexWorks(new String[]{"b*"}, new String[]{"baz"});, +        testFilteringByIndexWorks(new String[]{"*u"}, new String[]{"fuu"});, +        String[] randomIndices = randomFrom(new String[]{"*"}, new String[]{MetaData.ALL}, Strings.EMPTY_ARRAY, new String[]{"f*", "b*"});, +        testFilteringByIndexWorks(randomIndices, new String[]{"foo", "fuu", "baz"});, +    }, +    /**, +     * Retrieves the cluster state for the given indices and then checks, +     * that the cluster state returns coherent data for both routing table and metadata., +     */, +    private void testFilteringByIndexWorks(String[] indices, String[] expected) {, +        ClusterStateResponse clusterState = client().admin().cluster().prepareState(), +                                                                            .clear(), +                                                                            .setMetaData(true), +                                                                            .setRoutingTable(true), +                                                                            .setIndices(indices), +                                                                            .get();, +, +        ImmutableOpenMap<String, IndexMetaData> metaData = clusterState.getState().getMetaData().indices();, +        assertThat(metaData.size(), is(expected.length));, +, +        RoutingTable routingTable = clusterState.getState().getRoutingTable();, +        assertThat(routingTable.indicesRouting().size(), is(expected.length));, +, +        for (String expectedIndex : expected) {, +            assertThat(metaData, CollectionAssertions.hasKey(expectedIndex));, +            assertThat(routingTable.hasIndex(expectedIndex), is(true));, +        }, +++ b/rest-api-spec/src/main/resources/rest-api-spec/test/cluster.state/20_filtering.yaml, +, +---, +"Filtering the cluster state by indices using wildcards should work in routing table and metadata":, +  - do:, +      index:, +        index: index1, +        type:  type, +        id:    testing_document, +        body:, +            "text" : "The quick brown fox is brown.", +, +  - do:, +      index:, +        index: index2, +        type:  type, +        id:    testing_document, +        body:, +            "text" : "The quick brown fox is brown.", +, +  - do:]