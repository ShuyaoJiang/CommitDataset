[+++ b/core/src/main/java/org/elasticsearch/index/engine/DeleteVersionValue.java, +import org.apache.lucene.util.RamUsageEstimator;, +, +    private static final long BASE_RAM_BYTES_USED = RamUsageEstimator.shallowSizeOfInstance(DeleteVersionValue.class);, +, +        Translog.Location translogLocation = translogLocation();, +        return BASE_RAM_BYTES_USED + (translogLocation != null ? translogLocation.ramBytesUsed() : 0);, +++ b/core/src/main/java/org/elasticsearch/index/engine/DeleteVersionValue.java, +import org.apache.lucene.util.RamUsageEstimator;, +, +    private static final long BASE_RAM_BYTES_USED = RamUsageEstimator.shallowSizeOfInstance(DeleteVersionValue.class);, +, +        Translog.Location translogLocation = translogLocation();, +        return BASE_RAM_BYTES_USED + (translogLocation != null ? translogLocation.ramBytesUsed() : 0);, +++ b/core/src/main/java/org/elasticsearch/index/engine/LiveVersionMap.java, +    private ReferenceManager<?> mgr;, +     * In this base value, we account for the {@link BytesRef} object itself as, +     * well as the header of the byte[] array it holds, and some lost bytes due, +     * to object alignment. So consumers of this constant just have to add the, +     * length of the byte[] (assuming it is not shared between multiple, +     * instances). */, +    private static final long BASE_BYTES_PER_BYTESREF =, +            // shallow memory usage of the BytesRef object, +            RamUsageEstimator.shallowSizeOfInstance(BytesRef.class) +, +            // header of the byte[] array, +            RamUsageEstimator.NUM_BYTES_ARRAY_HEADER +, +            // with an alignment size (-XX:ObjectAlignmentInBytes) of 8 (default),, +            // there could be between 0 and 7 lost bytes, so we account for 3, +            // lost bytes on average, +            3;, +    /** Bytes used by having CHM point to a key/value. */, +    private static final long BASE_BYTES_PER_CHM_ENTRY;, +    static {, +        // use the same impl as the Maps does, +        Map<Integer, Integer> map = ConcurrentCollections.newConcurrentMapWithAggressiveConcurrency();, +        map.put(0, 0);, +        long chmEntryShallowSize = RamUsageEstimator.shallowSizeOf(map.entrySet().iterator().next());, +        // assume a load factor of 50%, +        // for each entry, we need two object refs, one for the entry itself, +        // and one for the free space that is due to the fact hash tables can, +        // not be fully loaded, +        BASE_BYTES_PER_CHM_ENTRY = chmEntryShallowSize + 2 * RamUsageEstimator.NUM_BYTES_OBJECT_REF;, +    }, +    synchronized void setManager(ReferenceManager<?> newMgr) {, +        assert uid.bytes.length == uid.length : "Oversized _uid! UID length: " + uid.length + ", bytes length: " + uid.bytes.length;, +++ b/core/src/main/java/org/elasticsearch/index/engine/DeleteVersionValue.java, +import org.apache.lucene.util.RamUsageEstimator;, +, +    private static final long BASE_RAM_BYTES_USED = RamUsageEstimator.shallowSizeOfInstance(DeleteVersionValue.class);, +, +        Translog.Location translogLocation = translogLocation();, +        return BASE_RAM_BYTES_USED + (translogLocation != null ? translogLocation.ramBytesUsed() : 0);, +++ b/core/src/main/java/org/elasticsearch/index/engine/LiveVersionMap.java, +    private ReferenceManager<?> mgr;, +     * In this base value, we account for the {@link BytesRef} object itself as, +     * well as the header of the byte[] array it holds, and some lost bytes due, +     * to object alignment. So consumers of this constant just have to add the, +     * length of the byte[] (assuming it is not shared between multiple, +     * instances). */, +    private static final long BASE_BYTES_PER_BYTESREF =, +            // shallow memory usage of the BytesRef object, +            RamUsageEstimator.shallowSizeOfInstance(BytesRef.class) +, +            // header of the byte[] array, +            RamUsageEstimator.NUM_BYTES_ARRAY_HEADER +, +            // with an alignment size (-XX:ObjectAlignmentInBytes) of 8 (default),, +            // there could be between 0 and 7 lost bytes, so we account for 3, +            // lost bytes on average, +            3;, +    /** Bytes used by having CHM point to a key/value. */, +    private static final long BASE_BYTES_PER_CHM_ENTRY;, +    static {, +        // use the same impl as the Maps does, +        Map<Integer, Integer> map = ConcurrentCollections.newConcurrentMapWithAggressiveConcurrency();, +        map.put(0, 0);, +        long chmEntryShallowSize = RamUsageEstimator.shallowSizeOf(map.entrySet().iterator().next());, +        // assume a load factor of 50%, +        // for each entry, we need two object refs, one for the entry itself, +        // and one for the free space that is due to the fact hash tables can, +        // not be fully loaded, +        BASE_BYTES_PER_CHM_ENTRY = chmEntryShallowSize + 2 * RamUsageEstimator.NUM_BYTES_OBJECT_REF;, +    }, +    synchronized void setManager(ReferenceManager<?> newMgr) {, +        assert uid.bytes.length == uid.length : "Oversized _uid! UID length: " + uid.length + ", bytes length: " + uid.bytes.length;, +++ b/core/src/main/java/org/elasticsearch/index/engine/VersionValue.java, +    private static final long BASE_RAM_BYTES_USED = RamUsageEstimator.shallowSizeOfInstance(VersionValue.class);, +, +        return BASE_RAM_BYTES_USED + (translogLocation != null ? translogLocation.ramBytesUsed() : 0);, +++ b/core/src/main/java/org/elasticsearch/index/engine/DeleteVersionValue.java, +import org.apache.lucene.util.RamUsageEstimator;, +, +    private static final long BASE_RAM_BYTES_USED = RamUsageEstimator.shallowSizeOfInstance(DeleteVersionValue.class);, +, +        Translog.Location translogLocation = translogLocation();, +        return BASE_RAM_BYTES_USED + (translogLocation != null ? translogLocation.ramBytesUsed() : 0);, +++ b/core/src/main/java/org/elasticsearch/index/engine/LiveVersionMap.java, +    private ReferenceManager<?> mgr;, +     * In this base value, we account for the {@link BytesRef} object itself as, +     * well as the header of the byte[] array it holds, and some lost bytes due, +     * to object alignment. So consumers of this constant just have to add the, +     * length of the byte[] (assuming it is not shared between multiple]