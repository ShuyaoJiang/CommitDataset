[+++ b/plugin/src/main/java/org/elasticsearch/xpack/ml/action/StartDatafeedAction.java, +            stop(reason, StopDatafeedAction.DEFAULT_TIMEOUT);, +++ b/plugin/src/main/java/org/elasticsearch/xpack/ml/action/StartDatafeedAction.java, +            stop(reason, StopDatafeedAction.DEFAULT_TIMEOUT);, +++ b/plugin/src/main/java/org/elasticsearch/xpack/ml/action/StopDatafeedAction.java, +    public static final TimeValue DEFAULT_TIMEOUT = TimeValue.timeValueMinutes(5);, +                    request.setStopTimeout(TimeValue.parseTimeValue(val, TIMEOUT.getPreferredName())), TIMEOUT);, +        private TimeValue stopTimeout = DEFAULT_TIMEOUT;, +        public TimeValue getStopTimeout() {, +            return stopTimeout;, +        }, +, +        public void setStopTimeout(TimeValue stopTimeout) {, +            this.stopTimeout = ExceptionsHelper.requireNonNull(stopTimeout, TIMEOUT.getPreferredName());, +        }, +, +            stopTimeout = new TimeValue(in);, +            stopTimeout.writeTo(out);, +            return Objects.hash(datafeedId, stopTimeout, force);, +            builder.field(TIMEOUT.getPreferredName(), stopTimeout.getStringRep());, +            builder.field(FORCE.getPreferredName(), force);, +                    Objects.equals(stopTimeout, other.stopTimeout) &&, +            persistentTasksService.waitForPersistentTaskStatus(persistentTaskId, Objects::isNull, request.getStopTimeout(),, +            task.stop("stop_datafeed (api)", request.getStopTimeout());, +++ b/plugin/src/main/java/org/elasticsearch/xpack/ml/action/StartDatafeedAction.java, +            stop(reason, StopDatafeedAction.DEFAULT_TIMEOUT);, +++ b/plugin/src/main/java/org/elasticsearch/xpack/ml/action/StopDatafeedAction.java, +    public static final TimeValue DEFAULT_TIMEOUT = TimeValue.timeValueMinutes(5);, +                    request.setStopTimeout(TimeValue.parseTimeValue(val, TIMEOUT.getPreferredName())), TIMEOUT);, +        private TimeValue stopTimeout = DEFAULT_TIMEOUT;, +        public TimeValue getStopTimeout() {, +            return stopTimeout;, +        }, +, +        public void setStopTimeout(TimeValue stopTimeout) {, +            this.stopTimeout = ExceptionsHelper.requireNonNull(stopTimeout, TIMEOUT.getPreferredName());, +        }, +, +            stopTimeout = new TimeValue(in);, +            stopTimeout.writeTo(out);, +            return Objects.hash(datafeedId, stopTimeout, force);, +            builder.field(TIMEOUT.getPreferredName(), stopTimeout.getStringRep());, +            builder.field(FORCE.getPreferredName(), force);, +                    Objects.equals(stopTimeout, other.stopTimeout) &&, +            persistentTasksService.waitForPersistentTaskStatus(persistentTaskId, Objects::isNull, request.getStopTimeout(),, +            task.stop("stop_datafeed (api)", request.getStopTimeout());, +++ b/plugin/src/main/java/org/elasticsearch/xpack/ml/datafeed/DatafeedJob.java, +        // If the datafeed was stopped, then it is possible that by the time, +        // we call flush the job is closed. Thus, we don't flush unless the, +        // datafeed is stilll running., +        if (isRunning()) {, +    }, +++ b/plugin/src/main/java/org/elasticsearch/xpack/ml/action/StartDatafeedAction.java, +            stop(reason, StopDatafeedAction.DEFAULT_TIMEOUT);, +++ b/plugin/src/main/java/org/elasticsearch/xpack/ml/action/StopDatafeedAction.java, +    public static final TimeValue DEFAULT_TIMEOUT = TimeValue.timeValueMinutes(5);, +                    request.setStopTimeout(TimeValue.parseTimeValue(val, TIMEOUT.getPreferredName())), TIMEOUT);, +        private TimeValue stopTimeout = DEFAULT_TIMEOUT;, +        public TimeValue getStopTimeout() {, +            return stopTimeout;, +        }, +, +        public void setStopTimeout(TimeValue stopTimeout) {, +            this.stopTimeout = ExceptionsHelper.requireNonNull(stopTimeout, TIMEOUT.getPreferredName());, +        }, +, +            stopTimeout = new TimeValue(in);, +            stopTimeout.writeTo(out);, +            return Objects.hash(datafeedId, stopTimeout, force);, +            builder.field(TIMEOUT.getPreferredName(), stopTimeout.getStringRep());, +            builder.field(FORCE.getPreferredName(), force);, +                    Objects.equals(stopTimeout, other.stopTimeout) &&, +            persistentTasksService.waitForPersistentTaskStatus(persistentTaskId, Objects::isNull, request.getStopTimeout(),, +            task.stop("stop_datafeed (api)", request.getStopTimeout());, +++ b/plugin/src/main/java/org/elasticsearch/xpack/ml/datafeed/DatafeedJob.java, +        // If the datafeed was stopped, then it is possible that by the time, +        // we call flush the job is closed. Thus, we don't flush unless the, +        // datafeed is stilll running., +        if (isRunning()) {, +    }, +++ b/plugin/src/main/java/org/elasticsearch/xpack/ml/datafeed/DatafeedManager.java, +                    logger.info("[{}] datafeed [{}] for job [{}] has been stopped{}", source, datafeed.getId(), datafeed.getJobId(),, +                            acquired ? "" : ", but there may be pending tasks as the timeout [" + timeout.getStringRep() + "] expired");, +++ b/plugin/src/main/java/org/elasticsearch/xpack/ml/action/StartDatafeedAction.java, +            stop(reason, StopDatafeedAction.DEFAULT_TIMEOUT);, +++ b/plugin/src/main/java/org/elasticsearch/xpack/ml/action/StopDatafeedAction.java, +    public static final TimeValue DEFAULT_TIMEOUT = TimeValue.timeValueMinutes(5);, +                    request.setStopTimeout(TimeValue.parseTimeValue(val, TIMEOUT.getPreferredName())), TIMEOUT);, +        private TimeValue stopTimeout = DEFAULT_TIMEOUT;, +        public TimeValue getStopTimeout() {, +            return stopTimeout;, +        }, +, +        public void setStopTimeout(TimeValue stopTimeout) {, +            this.stopTimeout = ExceptionsHelper.requireNonNull(stopTimeout, TIMEOUT.getPreferredName());, +        }, +, +            stopTimeout = new TimeValue(in);, +            stopTimeout.writeTo(out);, +            return Objects.hash(datafeedId, stopTimeout, force);]