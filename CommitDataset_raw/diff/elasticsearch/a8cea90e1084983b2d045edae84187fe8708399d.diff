[+++ b/server/src/main/java/org/elasticsearch/action/admin/cluster/repositories/verify/VerifyRepositoryResponse.java, +import org.elasticsearch.Version;, +import org.elasticsearch.common.ParseField;, +import org.elasticsearch.common.io.stream.Writeable;, +import org.elasticsearch.common.transport.TransportAddress;, +import org.elasticsearch.common.xcontent.ObjectParser;, +import java.util.Arrays;, +import java.util.Collections;, +import java.util.List;, +import java.util.Objects;, +import java.util.stream.Collectors;, + * Verify repository response, +    static final String NODES = "nodes";, +    static final String NAME = "name";, +, +    public static class NodeView implements Writeable, ToXContentObject {, +        private static final ObjectParser.NamedObjectParser<NodeView, Void> PARSER;, +        static {, +            ObjectParser<NodeView, Void> internalParser = new ObjectParser<>(NODES);, +            internalParser.declareString(NodeView::setName, new ParseField(NAME));, +            PARSER = (p, v, name) -> internalParser.parse(p, new NodeView(name), null);, +        }, +, +        final String nodeId;, +        String name;, +, +        public NodeView(String nodeId) { this.nodeId = nodeId; }, +, +        public NodeView(String nodeId, String name) {, +            this(nodeId);, +            this.name = name;, +        }, +, +        public NodeView(StreamInput in) throws IOException {, +            this(in.readString(), in.readString());, +        }, +, +        @Override, +        public void writeTo(StreamOutput out) throws IOException {, +            out.writeString(nodeId);, +            out.writeString(name);, +        }, +, +        void setName(String name) { this.name = name; }, +, +        public String getName() { return name; }, +, +        public String getNodeId() { return nodeId; }, +, +        public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {, +            builder.startObject(nodeId);, +            {, +                builder.field(NAME, name);, +            }, +            builder.endObject();, +            return builder;, +        }, +, +        /**, +         * Temporary method that allows turning a {@link NodeView} into a {@link DiscoveryNode}. This representation will never be used in, +         * practice, because in >= 6.4 a consumer of the response will only be able to retrieve a representation of {@link NodeView}, +         * objects., +         *, +         * Effectively this will be used to hold the state of the object in 6.x so there is no need to have 2 backing objects that, +         * represent the state of the Response. In practice these will always be read by a consumer as a NodeView, but it eases the, +         * transition to master which will not contain any representation of a {@link DiscoveryNode}., +         */, +        DiscoveryNode convertToDiscoveryNode() {, +            return new DiscoveryNode(name, nodeId, "", "", "", new TransportAddress(TransportAddress.META_ADDRESS, 0),, +                Collections.emptyMap(), Collections.emptySet(), Version.CURRENT);, +        }, +, +        @Override, +        public boolean equals(Object obj) {, +            if (obj == null) {, +                return false;, +            }, +            if (getClass() != obj.getClass()) {, +                return false;, +            }, +            NodeView other = (NodeView) obj;, +            return Objects.equals(nodeId, other.nodeId) &&, +                Objects.equals(name, other.name);, +        }, +, +        @Override, +        public int hashCode() {, +            return Objects.hash(nodeId, name);, +        }, +    }, +, +    private List<DiscoveryNode> nodes;, +        this.nodes = Arrays.asList(nodes);, +        if (in.getVersion().onOrAfter(Version.V_7_0_0_alpha1)) {, +            this.nodes = in.readList(NodeView::new).stream().map(n -> n.convertToDiscoveryNode()).collect(Collectors.toList());, +        } else {, +            this.nodes = in.readList(DiscoveryNode::new);, +        if (Version.CURRENT.onOrAfter(Version.V_7_0_0_alpha1)) {, +            out.writeList(getNodes());, +        } else {]