[+++ b/core/src/main/java/org/elasticsearch/common/io/stream/StreamInput.java, +     * Reads a long stored in variable-length format. Reads between one and ten bytes. Smaller values take fewer bytes. Negative numbers, +     * are encoded in ten bytes so prefer {@link #readLong()} or {@link #readZLong()} for negative numbers., +        i |= ((b & 0x7FL) << 56);, +        if ((b & 0x80) == 0) {, +            return i;, +        }, +        b = readByte();, +        if (b != 0 && b != 1) {, +            throw new IOException("Invalid vlong (" + Integer.toHexString(b) + " << 63) | " + Long.toHexString(i));, +        }, +        i |= ((long) b) << 63;, +        return i;, +++ b/core/src/main/java/org/elasticsearch/common/io/stream/StreamInput.java, +     * Reads a long stored in variable-length format. Reads between one and ten bytes. Smaller values take fewer bytes. Negative numbers, +     * are encoded in ten bytes so prefer {@link #readLong()} or {@link #readZLong()} for negative numbers., +        i |= ((b & 0x7FL) << 56);, +        if ((b & 0x80) == 0) {, +            return i;, +        }, +        b = readByte();, +        if (b != 0 && b != 1) {, +            throw new IOException("Invalid vlong (" + Integer.toHexString(b) + " << 63) | " + Long.toHexString(i));, +        }, +        i |= ((long) b) << 63;, +        return i;, +++ b/core/src/main/java/org/elasticsearch/common/io/stream/StreamOutput.java, +     * Writes a non-negative long in a variable-length format. Writes between one and ten bytes. Smaller values take fewer bytes. Negative, +     * numbers use ten bytes and trip assertions (if running in tests) so prefer {@link #writeLong(long)} or {@link #writeZLong(long)} for, +     * negative numbers., +        if (i < 0) {, +            throw new IllegalStateException("Negative longs unsupported, use writeLong or writeZLong for negative numbers [" + i + "]");, +        }, +        writeVLongNoCheck(i);, +    }, +, +    /**, +     * Writes a long in a variable-length format without first checking if it is negative. Package private for testing. Use, +     * {@link #writeVLong(long)} instead., +     */, +    void writeVLongNoCheck(long i) throws IOException {, +++ b/core/src/main/java/org/elasticsearch/common/io/stream/StreamInput.java, +     * Reads a long stored in variable-length format. Reads between one and ten bytes. Smaller values take fewer bytes. Negative numbers, +     * are encoded in ten bytes so prefer {@link #readLong()} or {@link #readZLong()} for negative numbers., +        i |= ((b & 0x7FL) << 56);, +        if ((b & 0x80) == 0) {, +            return i;, +        }, +        b = readByte();, +        if (b != 0 && b != 1) {, +            throw new IOException("Invalid vlong (" + Integer.toHexString(b) + " << 63) | " + Long.toHexString(i));, +        }, +        i |= ((long) b) << 63;, +        return i;, +++ b/core/src/main/java/org/elasticsearch/common/io/stream/StreamOutput.java, +     * Writes a non-negative long in a variable-length format. Writes between one and ten bytes. Smaller values take fewer bytes. Negative, +     * numbers use ten bytes and trip assertions (if running in tests) so prefer {@link #writeLong(long)} or {@link #writeZLong(long)} for, +     * negative numbers., +        if (i < 0) {, +            throw new IllegalStateException("Negative longs unsupported, use writeLong or writeZLong for negative numbers [" + i + "]");, +        }, +        writeVLongNoCheck(i);, +    }, +, +    /**, +     * Writes a long in a variable-length format without first checking if it is negative. Package private for testing. Use, +     * {@link #writeVLong(long)} instead., +     */, +    void writeVLongNoCheck(long i) throws IOException {, +++ b/core/src/test/java/org/elasticsearch/common/io/stream/BytesStreamsTests.java, +import org.elasticsearch.Version;, +import java.util.Base64;, +, +    public void testVInt() throws IOException {, +        final int value = randomInt();, +        BytesStreamOutput output = new BytesStreamOutput();, +        output.writeVInt(value);, +        StreamInput input = output.bytes().streamInput();, +        assertEquals(value, input.readVInt());, +    }, +, +    public void testVLong() throws IOException {, +        final long value = randomLong();, +        {, +            // Read works for positive and negative numbers, +            BytesStreamOutput output = new BytesStreamOutput();, +            output.writeVLongNoCheck(value); // Use NoCheck variant so we can write negative numbers, +            StreamInput input = output.bytes().streamInput();, +            assertEquals(value, input.readVLong());, +        }, +        if (value < 0) {, +            // Write doesn't work for negative numbers, +            BytesStreamOutput output = new BytesStreamOutput();, +            Exception e = expectThrows(IllegalStateException.class, () -> output.writeVLong(value));, +            assertEquals("Negative longs unsupported, use writeLong or writeZLong for negative numbers [" + value + "]", e.getMessage());, +        }, +, +        assertTrue("If we're not compatible with 5.1.1 we can drop the assertion below",, +                Version.CURRENT.minimumCompatibilityVersion().onOrBefore(Version.V_5_1_1_UNRELEASED));, +        /* Read -1 as serialized by a version of Elasticsearch that supported writing negative numbers with writeVLong. Note that this]