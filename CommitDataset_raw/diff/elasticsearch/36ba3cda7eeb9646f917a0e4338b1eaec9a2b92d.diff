[+++ b/server/src/main/java/org/elasticsearch/common/util/concurrent/FutureUtils.java, +import org.elasticsearch.common.Nullable;, +    /**, +     * Cancel execution of this future without interrupting a running thread. See {@link Future#cancel(boolean)} for details., +     *, +     * @param toCancel the future to cancel, +     * @return false if the future could not be cancelled, otherwise true, +     */, +    public static boolean cancel(@Nullable final Future<?> toCancel) {, +++ b/server/src/main/java/org/elasticsearch/common/util/concurrent/FutureUtils.java, +import org.elasticsearch.common.Nullable;, +    /**, +     * Cancel execution of this future without interrupting a running thread. See {@link Future#cancel(boolean)} for details., +     *, +     * @param toCancel the future to cancel, +     * @return false if the future could not be cancelled, otherwise true, +     */, +    public static boolean cancel(@Nullable final Future<?> toCancel) {, +++ b/server/src/main/java/org/elasticsearch/index/shard/GlobalCheckpointListeners.java, +import org.elasticsearch.common.unit.TimeValue;, +import org.elasticsearch.common.util.concurrent.FutureUtils;, +import java.util.LinkedHashMap;, +import java.util.Map;, +import java.util.concurrent.ScheduledExecutorService;, +import java.util.concurrent.ScheduledFuture;, +import java.util.concurrent.TimeUnit;, +import java.util.concurrent.TimeoutException;, +         * will be set to {@link org.elasticsearch.index.seqno.SequenceNumbers#UNASSIGNED_SEQ_NO} and the exception will be non-null and an, +         * instance of {@link IndexShardClosedException }. If the listener timed out waiting for notification then the exception will be, +         * non-null and an instance of {@link TimeoutException}. If the global checkpoint is updated, the exception will be null., +         * @param e                if non-null, the shard is closed or the listener timed out, +        void accept(long globalCheckpoint, Exception e);, +    private volatile Map<GlobalCheckpointListener, ScheduledFuture<?>> listeners;, +    private final ScheduledExecutorService scheduler;, +     * @param scheduler the executor used for scheduling timeouts, +            final ScheduledExecutorService scheduler,, +        this.shardId = Objects.requireNonNull(shardId, "shardId");, +        this.executor = Objects.requireNonNull(executor, "executor");, +        this.scheduler = Objects.requireNonNull(scheduler, "scheduler");, +        this.logger = Objects.requireNonNull(logger, "logger");, +     * is closed. A listener must re-register after one of these events to receive subsequent events. Callers may add a timeout to be, +     * notified after if the timeout elapses. In this case, the listener will be notified with a {@link TimeoutException}. Passing null for, +     * the timeout means no timeout will be associated to the listener., +     * @param timeout                 the listener timeout, or null if no timeout, +    synchronized void add(final long currentGlobalCheckpoint, final GlobalCheckpointListener listener, final TimeValue timeout) {, +                listeners = new LinkedHashMap<>();, +            if (timeout == null) {, +                listeners.put(listener, null);, +            } else {, +                listeners.put(, +                        listener,, +                        scheduler.schedule(, +                                () -> {, +                                    final boolean removed;, +                                    synchronized (this) {, +                                        /*, +                                         * Note that the listeners map can be null if a notification nulled out the map reference when, +                                         * notifying listeners, and then our scheduled execution occurred before we could be cancelled by, +                                         * the notification. In this case, we would have blocked waiting for access to this critical, +                                         * section., +                                         *, +                                         * What is more, we know that this listener has a timeout associated with it (otherwise we would, +                                         * not be here) so the return value from remove being null is an indication that we are not in the, +                                         * map. This can happen if a notification nulled out the listeners, and then our scheduled execution, +                                         * occurred before we could be cancelled by the notification, and then another thread added a, +                                         * listener causing the listeners map reference to be non-null again. In this case, our listener, +                                         * here would not be in the map and we should not fire the timeout logic., +                                         */, +                                        removed = listeners != null && listeners.remove(listener) != null;, +                                    }, +                                    if (removed) {, +                                        final TimeoutException e = new TimeoutException(timeout.getStringRep());, +                                        logger.trace("global checkpoint listener timed out", e);, +                                        executor.execute(() -> notifyListener(listener, UNASSIGNED_SEQ_NO, e));, +                                    }, +                                },, +                                timeout.nanos(),, +                                TimeUnit.NANOSECONDS));, +            }, +    /**, +     * The number of listeners currently pending for notification., +     *, +     * @return the number of listeners pending notification, +     */, +     * The scheduled future for a listener that has a timeout associated with it, otherwise null., +     *, +     * @param listener the listener to get the scheduled future for, +     * @return a scheduled future representing the timeout future for the listener, otherwise null, +     */, +    synchronized ScheduledFuture<?> getTimeoutFuture(final GlobalCheckpointListener listener) {, +        return listeners.get(listener);, +    }, +, +    /**, +            final Map<GlobalCheckpointListener, ScheduledFuture<?>> currentListeners = listeners;, +                    for (final Map.Entry<GlobalCheckpointListener, ScheduledFuture<?>> listener : currentListeners.entrySet()) {, +                        /*, +                         * We do not want to interrupt any timeouts that fired, these will detect that the listener has been notified and, +                         * not trigger the timeout., +                         */]