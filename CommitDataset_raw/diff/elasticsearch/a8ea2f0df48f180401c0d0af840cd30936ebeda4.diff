[+++ b/core/src/main/java/org/elasticsearch/common/lucene/Lucene.java, +import org.apache.lucene.search.ScorerSupplier;, +     * Given a {@link ScorerSupplier}, return a {@link Bits} instance that will match, +    public static Bits asSequentialAccessBits(final int maxDoc, @Nullable ScorerSupplier scorerSupplier) throws IOException {, +        if (scorerSupplier == null) {, +        // Since we want bits, we need random-access, +        final Scorer scorer = scorerSupplier.get(true); // this never returns null, +++ b/core/src/main/java/org/elasticsearch/common/lucene/Lucene.java, +import org.apache.lucene.search.ScorerSupplier;, +     * Given a {@link ScorerSupplier}, return a {@link Bits} instance that will match, +    public static Bits asSequentialAccessBits(final int maxDoc, @Nullable ScorerSupplier scorerSupplier) throws IOException {, +        if (scorerSupplier == null) {, +        // Since we want bits, we need random-access, +        final Scorer scorer = scorerSupplier.get(true); // this never returns null, +++ b/core/src/main/java/org/elasticsearch/common/lucene/search/FilteredCollector.java, +import org.apache.lucene.search.ScorerSupplier;, +        final ScorerSupplier filterScorerSupplier = filter.scorerSupplier(context);, +        final Bits bits = Lucene.asSequentialAccessBits(context.reader().maxDoc(), filterScorerSupplier);, +++ b/core/src/main/java/org/elasticsearch/common/lucene/Lucene.java, +import org.apache.lucene.search.ScorerSupplier;, +     * Given a {@link ScorerSupplier}, return a {@link Bits} instance that will match, +    public static Bits asSequentialAccessBits(final int maxDoc, @Nullable ScorerSupplier scorerSupplier) throws IOException {, +        if (scorerSupplier == null) {, +        // Since we want bits, we need random-access, +        final Scorer scorer = scorerSupplier.get(true); // this never returns null, +++ b/core/src/main/java/org/elasticsearch/common/lucene/search/FilteredCollector.java, +import org.apache.lucene.search.ScorerSupplier;, +        final ScorerSupplier filterScorerSupplier = filter.scorerSupplier(context);, +        final Bits bits = Lucene.asSequentialAccessBits(context.reader().maxDoc(), filterScorerSupplier);, +++ b/core/src/main/java/org/elasticsearch/common/lucene/search/function/FiltersFunctionScoreQuery.java, +import org.apache.lucene.search.ScorerSupplier;, +                ScorerSupplier filterScorerSupplier = filterWeights[i].scorerSupplier(context);, +                docSets[i] = Lucene.asSequentialAccessBits(context.reader().maxDoc(), filterScorerSupplier);, +                        filterWeights[i].scorerSupplier(context));, +++ b/core/src/main/java/org/elasticsearch/common/lucene/Lucene.java, +import org.apache.lucene.search.ScorerSupplier;, +     * Given a {@link ScorerSupplier}, return a {@link Bits} instance that will match, +    public static Bits asSequentialAccessBits(final int maxDoc, @Nullable ScorerSupplier scorerSupplier) throws IOException {, +        if (scorerSupplier == null) {, +        // Since we want bits, we need random-access, +        final Scorer scorer = scorerSupplier.get(true); // this never returns null, +++ b/core/src/main/java/org/elasticsearch/common/lucene/search/FilteredCollector.java, +import org.apache.lucene.search.ScorerSupplier;, +        final ScorerSupplier filterScorerSupplier = filter.scorerSupplier(context);, +        final Bits bits = Lucene.asSequentialAccessBits(context.reader().maxDoc(), filterScorerSupplier);, +++ b/core/src/main/java/org/elasticsearch/common/lucene/search/function/FiltersFunctionScoreQuery.java, +import org.apache.lucene.search.ScorerSupplier;, +                ScorerSupplier filterScorerSupplier = filterWeights[i].scorerSupplier(context);, +                docSets[i] = Lucene.asSequentialAccessBits(context.reader().maxDoc(), filterScorerSupplier);, +                        filterWeights[i].scorerSupplier(context));, +++ b/core/src/main/java/org/elasticsearch/search/aggregations/bucket/adjacency/AdjacencyMatrixAggregator.java, +            bits[i] = Lucene.asSequentialAccessBits(ctx.reader().maxDoc(), filters[i].scorerSupplier(ctx));, +++ b/core/src/main/java/org/elasticsearch/common/lucene/Lucene.java, +import org.apache.lucene.search.ScorerSupplier;, +     * Given a {@link ScorerSupplier}, return a {@link Bits} instance that will match, +    public static Bits asSequentialAccessBits(final int maxDoc, @Nullable ScorerSupplier scorerSupplier) throws IOException {, +        if (scorerSupplier == null) {, +        // Since we want bits, we need random-access, +        final Scorer scorer = scorerSupplier.get(true); // this never returns null, +++ b/core/src/main/java/org/elasticsearch/common/lucene/search/FilteredCollector.java, +import org.apache.lucene.search.ScorerSupplier;, +        final ScorerSupplier filterScorerSupplier = filter.scorerSupplier(context);, +        final Bits bits = Lucene.asSequentialAccessBits(context.reader().maxDoc(), filterScorerSupplier);, +++ b/core/src/main/java/org/elasticsearch/common/lucene/search/function/FiltersFunctionScoreQuery.java, +import org.apache.lucene.search.ScorerSupplier;, +                ScorerSupplier filterScorerSupplier = filterWeights[i].scorerSupplier(context);, +                docSets[i] = Lucene.asSequentialAccessBits(context.reader().maxDoc(), filterScorerSupplier);, +                        filterWeights[i].scorerSupplier(context));, +++ b/core/src/main/java/org/elasticsearch/search/aggregations/bucket/adjacency/AdjacencyMatrixAggregator.java, +            bits[i] = Lucene.asSequentialAccessBits(ctx.reader().maxDoc(), filters[i].scorerSupplier(ctx));, +++ b/core/src/main/java/org/elasticsearch/search/aggregations/bucket/filter/FilterAggregator.java, +        final Bits bits = Lucene.asSequentialAccessBits(ctx.reader().maxDoc(), filter.scorerSupplier(ctx));, +++ b/core/src/main/java/org/elasticsearch/common/lucene/Lucene.java, +import org.apache.lucene.search.ScorerSupplier;, +     * Given a {@link ScorerSupplier}, return a {@link Bits} instance that will match, +    public static Bits asSequentialAccessBits(final int maxDoc, @Nullable ScorerSupplier scorerSupplier) throws IOException {, +        if (scorerSupplier == null) {, +        // Since we want bits, we need random-access, +        final Scorer scorer = scorerSupplier.get(true); // this never returns null, +++ b/core/src/main/java/org/elasticsearch/common/lucene/search/FilteredCollector.java, +import org.apache.lucene.search.ScorerSupplier;, +        final ScorerSupplier filterScorerSupplier = filter.scorerSupplier(context);, +        final Bits bits = Lucene.asSequentialAccessBits(context.reader().maxDoc(), filterScorerSupplier);, +++ b/core/src/main/java/org/elasticsearch/common/lucene/search/function/FiltersFunctionScoreQuery.java, +import org.apache.lucene.search.ScorerSupplier;, +                ScorerSupplier filterScorerSupplier = filterWeights[i].scorerSupplier(context);, +                docSets[i] = Lucene.asSequentialAccessBits(context.reader().maxDoc(), filterScorerSupplier);, +                        filterWeights[i].scorerSupplier(context));, +++ b/core/src/main/java/org/elasticsearch/search/aggregations/bucket/adjacency/AdjacencyMatrixAggregator.java, +            bits[i] = Lucene.asSequentialAccessBits(ctx.reader().maxDoc(), filters[i].scorerSupplier(ctx));, +++ b/core/src/main/java/org/elasticsearch/search/aggregations/bucket/filter/FilterAggregator.java, +        final Bits bits = Lucene.asSequentialAccessBits(ctx.reader().maxDoc(), filter.scorerSupplier(ctx));, +++ b/core/src/main/java/org/elasticsearch/search/aggregations/bucket/filters/FiltersAggregator.java, +            bits[i] = Lucene.asSequentialAccessBits(ctx.reader().maxDoc(), filters[i].scorerSupplier(ctx));, +++ b/core/src/main/java/org/elasticsearch/common/lucene/Lucene.java, +import org.apache.lucene.search.ScorerSupplier;, +     * Given a {@link ScorerSupplier}, return a {@link Bits} instance that will match, +    public static Bits asSequentialAccessBits(final int maxDoc, @Nullable ScorerSupplier scorerSupplier) throws IOException {, +        if (scorerSupplier == null) {, +        // Since we want bits, we need random-access]