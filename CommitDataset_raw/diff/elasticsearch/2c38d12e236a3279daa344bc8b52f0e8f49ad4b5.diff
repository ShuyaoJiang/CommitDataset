[+++ b/docs/CHANGELOG.asciidoc, +The cluster state listener to decide if watcher should be, +stopped/started/paused now runs far less code in an executor but is more, +synchronous and predictable. Also the trigger engine thread is only started on, +data nodes. And the Execute Watch API can be triggered regardless is watcher is, +started or stopped. ({pull}30118[#30118]), +++ b/docs/CHANGELOG.asciidoc, +The cluster state listener to decide if watcher should be, +stopped/started/paused now runs far less code in an executor but is more, +synchronous and predictable. Also the trigger engine thread is only started on, +data nodes. And the Execute Watch API can be triggered regardless is watcher is, +started or stopped. ({pull}30118[#30118]), +++ b/x-pack/plugin/src/test/java/org/elasticsearch/xpack/test/rest/XPackRestIT.java, +import org.elasticsearch.client.Response;, +import org.elasticsearch.test.rest.yaml.ObjectPath;, +, +                switch (state) {, +                    case "stopped":, +                        ClientYamlTestResponse startResponse =, +                        boolean isAcknowledged = (boolean) startResponse.evaluate("acknowledged");, +                        assertThat(isAcknowledged, is(true));, +                        break;, +                    case "stopping":, +                        throw new AssertionError("waiting until stopping state reached stopped state to start again");, +                    case "starting":, +                        throw new AssertionError("waiting until starting state reached started state");, +                    case "started":, +                        // all good here, we are done, +                        break;, +                    default:, +                        throw new AssertionError("unknown state[" + state + "]");, +, +            for (String template : WatcherIndexTemplateRegistryField.TEMPLATE_NAMES) {, +                awaitCallApi("indices.exists_template", singletonMap("name", template), emptyList(),, +                    response -> true,, +                    () -> "Exception when waiting for [" + template + "] template to be created");, +            }, +, +            boolean existsWatcherIndex = adminClient().performRequest("HEAD", ".watches").getStatusLine().getStatusCode() == 200;, +            if (existsWatcherIndex == false) {, +                return;, +            }, +            Response response = adminClient().performRequest("GET", ".watches/_search", Collections.singletonMap("size", "1000"));, +            ObjectPath objectPathResponse = ObjectPath.createFromResponse(response);, +            int totalHits = objectPathResponse.evaluate("hits.total");, +            if (totalHits > 0) {, +                List<Map<String, Object>> hits = objectPathResponse.evaluate("hits.hits");, +                for (Map<String, Object> hit : hits) {, +                    String id = (String) hit.get("_id");, +                    assertOK(adminClient().performRequest("DELETE", "_xpack/watcher/watch/" + id));, +                }, +            }, +++ b/docs/CHANGELOG.asciidoc, +The cluster state listener to decide if watcher should be, +stopped/started/paused now runs far less code in an executor but is more, +synchronous and predictable. Also the trigger engine thread is only started on, +data nodes. And the Execute Watch API can be triggered regardless is watcher is, +started or stopped. ({pull}30118[#30118]), +++ b/x-pack/plugin/src/test/java/org/elasticsearch/xpack/test/rest/XPackRestIT.java, +import org.elasticsearch.client.Response;, +import org.elasticsearch.test.rest.yaml.ObjectPath;, +, +                switch (state) {, +                    case "stopped":, +                        ClientYamlTestResponse startResponse =, +                        boolean isAcknowledged = (boolean) startResponse.evaluate("acknowledged");, +                        assertThat(isAcknowledged, is(true));, +                        break;, +                    case "stopping":, +                        throw new AssertionError("waiting until stopping state reached stopped state to start again");, +                    case "starting":, +                        throw new AssertionError("waiting until starting state reached started state");, +                    case "started":, +                        // all good here, we are done, +                        break;, +                    default:, +                        throw new AssertionError("unknown state[" + state + "]");, +, +            for (String template : WatcherIndexTemplateRegistryField.TEMPLATE_NAMES) {, +                awaitCallApi("indices.exists_template", singletonMap("name", template), emptyList(),, +                    response -> true,, +                    () -> "Exception when waiting for [" + template + "] template to be created");, +            }, +, +            boolean existsWatcherIndex = adminClient().performRequest("HEAD", ".watches").getStatusLine().getStatusCode() == 200;, +            if (existsWatcherIndex == false) {, +                return;, +            }, +            Response response = adminClient().performRequest("GET", ".watches/_search", Collections.singletonMap("size", "1000"));, +            ObjectPath objectPathResponse = ObjectPath.createFromResponse(response);, +            int totalHits = objectPathResponse.evaluate("hits.total");, +            if (totalHits > 0) {, +                List<Map<String, Object>> hits = objectPathResponse.evaluate("hits.hits");, +                for (Map<String, Object> hit : hits) {, +                    String id = (String) hit.get("_id");, +                    assertOK(adminClient().performRequest("DELETE", "_xpack/watcher/watch/" + id));, +                }, +            }, +++ b/x-pack/plugin/watcher/src/main/java/org/elasticsearch/xpack/watcher/Watcher.java, +                getClock(), watchParser, clusterService, client, threadPool.generic());]