[+++ b/core/src/main/java/org/elasticsearch/ElasticsearchException.java, +import org.elasticsearch.discovery.Discovery;, +                NotSerializableExceptionWrapper.class,, +                Discovery.FailedToCommitClusterStateException.class, +++ b/core/src/main/java/org/elasticsearch/ElasticsearchException.java, +import org.elasticsearch.discovery.Discovery;, +                NotSerializableExceptionWrapper.class,, +                Discovery.FailedToCommitClusterStateException.class, +++ b/core/src/main/java/org/elasticsearch/cluster/ClusterModule.java, +        registerClusterDynamicSetting(DiscoverySettings.COMMIT_TIMEOUT, Validator.TIME_NON_NEGATIVE);, +++ b/core/src/main/java/org/elasticsearch/ElasticsearchException.java, +import org.elasticsearch.discovery.Discovery;, +                NotSerializableExceptionWrapper.class,, +                Discovery.FailedToCommitClusterStateException.class, +++ b/core/src/main/java/org/elasticsearch/cluster/ClusterModule.java, +        registerClusterDynamicSetting(DiscoverySettings.COMMIT_TIMEOUT, Validator.TIME_NON_NEGATIVE);, +++ b/core/src/main/java/org/elasticsearch/cluster/ClusterState.java, +import java.util.*;, +    public boolean wasReadFromDiff() {, +    /**, +     * a cluster state supersedes another state iff they are from the same master and the version this state is higher thant the other state., +     * <p/>, +     * In essence that means that all the changes from the other cluster state are also reflected by the current one, +     */, +    public boolean supersedes(ClusterState other) {, +        return this.nodes().masterNodeId() != null && this.nodes().masterNodeId().equals(other.nodes().masterNodeId()) && this.version() > other.version();, +, +    }, +, +, +++ b/core/src/main/java/org/elasticsearch/ElasticsearchException.java, +import org.elasticsearch.discovery.Discovery;, +                NotSerializableExceptionWrapper.class,, +                Discovery.FailedToCommitClusterStateException.class, +++ b/core/src/main/java/org/elasticsearch/cluster/ClusterModule.java, +        registerClusterDynamicSetting(DiscoverySettings.COMMIT_TIMEOUT, Validator.TIME_NON_NEGATIVE);, +++ b/core/src/main/java/org/elasticsearch/cluster/ClusterState.java, +import java.util.*;, +    public boolean wasReadFromDiff() {, +    /**, +     * a cluster state supersedes another state iff they are from the same master and the version this state is higher thant the other state., +     * <p/>, +     * In essence that means that all the changes from the other cluster state are also reflected by the current one, +     */, +    public boolean supersedes(ClusterState other) {, +        return this.nodes().masterNodeId() != null && this.nodes().masterNodeId().equals(other.nodes().masterNodeId()) && this.version() > other.version();, +, +    }, +, +, +++ b/core/src/main/java/org/elasticsearch/cluster/service/InternalClusterService.java, +                    logger.debug("publishing cluster state version [{}]", newClusterState.version());, +                    try {, +                    } catch (Discovery.FailedToCommitClusterStateException t) {, +                        logger.warn("failing [{}]: failed to commit cluster state version [{}]", t, source, newClusterState.version());, +                        updateTask.onFailure(source, t);, +                        return;, +                    }, +++ b/core/src/main/java/org/elasticsearch/ElasticsearchException.java, +import org.elasticsearch.discovery.Discovery;, +                NotSerializableExceptionWrapper.class,, +                Discovery.FailedToCommitClusterStateException.class, +++ b/core/src/main/java/org/elasticsearch/cluster/ClusterModule.java, +        registerClusterDynamicSetting(DiscoverySettings.COMMIT_TIMEOUT, Validator.TIME_NON_NEGATIVE);, +++ b/core/src/main/java/org/elasticsearch/cluster/ClusterState.java, +import java.util.*;, +    public boolean wasReadFromDiff() {, +    /**, +     * a cluster state supersedes another state iff they are from the same master and the version this state is higher thant the other state., +     * <p/>, +     * In essence that means that all the changes from the other cluster state are also reflected by the current one, +     */, +    public boolean supersedes(ClusterState other) {, +        return this.nodes().masterNodeId() != null && this.nodes().masterNodeId().equals(other.nodes().masterNodeId()) && this.version() > other.version();, +, +    }, +, +, +++ b/core/src/main/java/org/elasticsearch/cluster/service/InternalClusterService.java, +                    logger.debug("publishing cluster state version [{}]", newClusterState.version());, +                    try {, +                    } catch (Discovery.FailedToCommitClusterStateException t) {, +                        logger.warn("failing [{}]: failed to commit cluster state version [{}]", t, source, newClusterState.version());, +                        updateTask.onFailure(source, t);, +                        return;, +                    }, +++ b/core/src/main/java/org/elasticsearch/discovery/Discovery.java, +import org.elasticsearch.ElasticsearchException;, +import org.elasticsearch.common.io.stream.StreamInput;, +import java.io.IOException;, +, +     *, +     * The method is guaranteed to throw a {@link FailedToCommitClusterStateException} if the change is not committed and should be rejected., +     * Any other exception signals the something wrong happened but the change is committed., +    interface AckListener {, +, +    class FailedToCommitClusterStateException extends ElasticsearchException {, +, +        public FailedToCommitClusterStateException(StreamInput in) throws IOException {, +            super(in);]