[+++ b/modules/elasticsearch/src/main/java/org/elasticsearch/gateway/blobstore/BlobReuseExistingNodeAllocation.java, +                // we only check for NO, since if this node is THROTTLING and it has enough "same data", +                // then we will try and assign it next time, +                if (nodeAllocations.canAllocate(shard, node, routingNodes) == Decision.NO) {, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/gateway/blobstore/BlobReuseExistingNodeAllocation.java, +                // we only check for NO, since if this node is THROTTLING and it has enough "same data", +                // then we will try and assign it next time, +                if (nodeAllocations.canAllocate(shard, node, routingNodes) == Decision.NO) {, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/index/gateway/IndexShardGatewayService.java, +                    if (indexShard.state() == IndexShardState.CLOSED) {, +                        // got closed on us, just ignore this recovery, +                        listener.onIgnoreRecovery("shard closed");, +                        return;, +                    }, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/gateway/blobstore/BlobReuseExistingNodeAllocation.java, +                // we only check for NO, since if this node is THROTTLING and it has enough "same data", +                // then we will try and assign it next time, +                if (nodeAllocations.canAllocate(shard, node, routingNodes) == Decision.NO) {, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/index/gateway/IndexShardGatewayService.java, +                    if (indexShard.state() == IndexShardState.CLOSED) {, +                        // got closed on us, just ignore this recovery, +                        listener.onIgnoreRecovery("shard closed");, +                        return;, +                    }, +++ b/modules/test/integration/src/test/java/org/elasticsearch/test/integration/gateway/AbstractSimpleIndexGatewayTests.java, +    protected boolean isPersistentStorage() {, +        return true;, +    }, +, +                    if (fullRecovery || !isPersistentStorage()) {, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/gateway/blobstore/BlobReuseExistingNodeAllocation.java, +                // we only check for NO, since if this node is THROTTLING and it has enough "same data", +                // then we will try and assign it next time, +                if (nodeAllocations.canAllocate(shard, node, routingNodes) == Decision.NO) {, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/index/gateway/IndexShardGatewayService.java, +                    if (indexShard.state() == IndexShardState.CLOSED) {, +                        // got closed on us, just ignore this recovery, +                        listener.onIgnoreRecovery("shard closed");, +                        return;, +                    }, +++ b/modules/test/integration/src/test/java/org/elasticsearch/test/integration/gateway/AbstractSimpleIndexGatewayTests.java, +    protected boolean isPersistentStorage() {, +        return true;, +    }, +, +                    if (fullRecovery || !isPersistentStorage()) {, +++ b/modules/test/integration/src/test/java/org/elasticsearch/test/integration/gateway/fs/SimpleFsIndexInRamIndexGatewayTests.java, +    @Override protected boolean isPersistentStorage() {, +        return false;, +    }]