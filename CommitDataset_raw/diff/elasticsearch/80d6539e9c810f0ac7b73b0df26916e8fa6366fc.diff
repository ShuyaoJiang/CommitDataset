[+++ b/core/src/main/java/org/elasticsearch/transport/TcpTransport.java, +import java.util.Optional;, +import java.util.concurrent.ConcurrentHashMap;, +    private final ConcurrentMap<Long, HandshakeResponseHandler> pendingHandshakes = new ConcurrentHashMap<>();, +    private static class HandshakeResponseHandler<Channel> implements TransportResponseHandler<VersionHandshakeResponse> {, +        final AtomicReference<Version> versionRef = new AtomicReference<>();, +        final CountDownLatch latch = new CountDownLatch(1);, +        final AtomicBoolean handshakeNotSupported = new AtomicBoolean(false);, +        final AtomicReference<Exception> exceptionRef = new AtomicReference<>();, +        final Channel channel;, +, +        public HandshakeResponseHandler(Channel channel) {, +            this.channel = channel;, +        }, +, +        @Override, +        public VersionHandshakeResponse newInstance() {, +            return new VersionHandshakeResponse();, +        }, +, +        @Override, +        public void handleResponse(VersionHandshakeResponse response) {, +            final boolean success = versionRef.compareAndSet(null, response.version);, +            assert success;, +            latch.countDown();, +        }, +, +        @Override, +        public void handleException(TransportException exp) {, +            Throwable cause = exp.getCause();, +            if (cause != null, +                && cause instanceof ActionNotFoundTransportException, +                // this will happen if we talk to a node (pre 5.2) that doesn't have a handshake handler, +                // we will just treat the node as a 5.0.0 node unless the discovery node that is used to connect has a higher version., +                && cause.getMessage().equals("No handler for action [internal:tcp/handshake]")) {, +                    handshakeNotSupported.set(true);, +            } else {, +                final boolean success = exceptionRef.compareAndSet(null, exp);, +                assert success;, +            }, +            latch.countDown();, +        }, +, +        @Override, +        public String executor() {, +            return ThreadPool.Names.SAME;, +        }, +    }, +, +        try {, +        } catch (ConnectTransportException e) {, +            throw e;, +        } catch (Exception e) {, +            // ConnectTransportExceptions are handled specifically on the caller end - we wrap the actual exception to ensure, +            // only relevant exceptions are logged on the caller end.. this is the same as in connectToNode, +            throw new ConnectTransportException(node, "general node connection failure", e);, +        }, +        final HandshakeResponseHandler handler = new HandshakeResponseHandler(channel);, +        AtomicReference<Version> versionRef = handler.versionRef;, +        AtomicReference<Exception> exceptionRef = handler.exceptionRef;, +        pendingHandshakes.put(requestId, handler);, +            if (handler.latch.await(timeout.millis(), TimeUnit.MILLISECONDS) == false) {, +            if (handler.handshakeNotSupported.get()) {, +, +    /**, +     * Called by sub-classes for each channel that is closed, +     */, +    protected final void onChannelClosed(Channel channel) {, +        Optional<Map.Entry<Long, HandshakeResponseHandler>> first = pendingHandshakes.entrySet().stream(), +            .filter((entry) -> entry.getValue().channel == channel).findFirst();, +        if(first.isPresent()) {, +            final Long requestId = first.get().getKey();, +            HandshakeResponseHandler handler = first.get().getValue();, +            pendingHandshakes.remove(requestId);, +            handler.handleException(new TransportException("connection reset"));, +        }, +    }, +++ b/core/src/main/java/org/elasticsearch/transport/TcpTransport.java, +import java.util.Optional;, +import java.util.concurrent.ConcurrentHashMap;, +    private final ConcurrentMap<Long, HandshakeResponseHandler> pendingHandshakes = new ConcurrentHashMap<>();, +    private static class HandshakeResponseHandler<Channel> implements TransportResponseHandler<VersionHandshakeResponse> {, +        final AtomicReference<Version> versionRef = new AtomicReference<>();, +        final CountDownLatch latch = new CountDownLatch(1);, +        final AtomicBoolean handshakeNotSupported = new AtomicBoolean(false);, +        final AtomicReference<Exception> exceptionRef = new AtomicReference<>();, +        final Channel channel;, +, +        public HandshakeResponseHandler(Channel channel) {, +            this.channel = channel;, +        }, +, +        @Override, +        public VersionHandshakeResponse newInstance() {, +            return new VersionHandshakeResponse();, +        }, +, +        @Override, +        public void handleResponse(VersionHandshakeResponse response) {, +            final boolean success = versionRef.compareAndSet(null, response.version);]