[+++ b/modules/rank-eval/src/main/java/org/elasticsearch/index/rankeval/RatedSearchHit.java, +        this(new SearchHit(in), in.readBoolean() == true ? OptionalInt.of(in.readVInt()) : OptionalInt.empty());, +++ b/modules/rank-eval/src/main/java/org/elasticsearch/index/rankeval/RatedSearchHit.java, +        this(new SearchHit(in), in.readBoolean() == true ? OptionalInt.of(in.readVInt()) : OptionalInt.empty());, +++ b/server/src/main/java/org/elasticsearch/search/SearchHit.java, +public final class SearchHit implements Writeable, ToXContentObject, Iterable<DocumentField> {, +    private final transient int docId;, +    private final Text id;, +    private final Text type;, +    private final NestedIdentity nestedIdentity;, +    private Map<String, DocumentField> fields;, +    public SearchHit(StreamInput in) throws IOException {, +        docId = -1;, +        score = in.readFloat();, +        id = in.readOptionalText();, +        type = in.readOptionalText();, +        nestedIdentity = in.readOptionalWriteable(NestedIdentity::new);, +        version = in.readLong();, +        if (in.getVersion().onOrAfter(Version.V_6_7_0)) {, +            seqNo = in.readZLong();, +            primaryTerm = in.readVLong();, +        }, +        source = in.readBytesReference();, +        if (source.length() == 0) {, +            source = null;, +        }, +        if (in.readBoolean()) {, +            explanation = readExplanation(in);, +        }, +        int size = in.readVInt();, +        if (size == 0) {, +            fields = emptyMap();, +        } else if (size == 1) {, +            DocumentField hitField = DocumentField.readDocumentField(in);, +            fields = singletonMap(hitField.getName(), hitField);, +        } else {, +            Map<String, DocumentField> fields = new HashMap<>();, +            for (int i = 0; i < size; i++) {, +                DocumentField hitField = DocumentField.readDocumentField(in);, +                fields.put(hitField.getName(), hitField);, +            }, +            this.fields = unmodifiableMap(fields);, +        }, +, +        size = in.readVInt();, +        if (size == 0) {, +            highlightFields = emptyMap();, +        } else if (size == 1) {, +            HighlightField field = readHighlightField(in);, +            highlightFields = singletonMap(field.name(), field);, +        } else {, +            Map<String, HighlightField> highlightFields = new HashMap<>();, +            for (int i = 0; i < size; i++) {, +                HighlightField field = readHighlightField(in);, +                highlightFields.put(field.name(), field);, +            }, +            this.highlightFields = unmodifiableMap(highlightFields);, +        }, +, +        sortValues = new SearchSortValues(in);, +, +        size = in.readVInt();, +        if (size > 0) {, +            matchedQueries = new String[size];, +            for (int i = 0; i < size; i++) {, +                matchedQueries[i] = in.readString();, +            }, +        }, +        // we call the setter here because that also sets the local index parameter, +        shard(in.readOptionalWriteable(SearchShardTarget::new));, +        size = in.readVInt();, +        if (size > 0) {, +            innerHits = new HashMap<>(size);, +            for (int i = 0; i < size; i++) {, +                String key = in.readString();, +                SearchHits value = new SearchHits(in);, +                innerHits.put(key, value);, +            }, +        } else {, +            innerHits = null;, +        }, +    }, +, +    @Override, +    public void writeTo(StreamOutput out) throws IOException {, +        out.writeFloat(score);, +        out.writeOptionalText(id);, +        out.writeOptionalText(type);, +        out.writeOptionalWriteable(nestedIdentity);, +        out.writeLong(version);, +        if (out.getVersion().onOrAfter(Version.V_6_7_0)) {, +            out.writeZLong(seqNo);, +            out.writeVLong(primaryTerm);, +        }, +        out.writeBytesReference(source);, +        if (explanation == null) {, +            out.writeBoolean(false);, +        } else {, +            out.writeBoolean(true);, +            writeExplanation(out, explanation);]