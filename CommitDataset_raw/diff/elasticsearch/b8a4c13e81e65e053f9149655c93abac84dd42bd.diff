[+++ b/server/src/main/java/org/elasticsearch/index/engine/ReadOnlyEngine.java, +                    // Before 8.0 the global checkpoint is not known and up to date when the engine is created after, +                    // peer recovery, so we only check the max seq no / global checkpoint coherency when the global, +                    final Version indexVersionCreated = engineConfig.getIndexSettings().getIndexVersionCreated();, +                    if (indexVersionCreated.onOrAfter(Version.V_8_0_0) ||, +                        (globalCheckpoint != SequenceNumbers.UNASSIGNED_SEQ_NO && indexVersionCreated.onOrAfter(Version.V_6_7_0))) {, +++ b/server/src/main/java/org/elasticsearch/index/engine/ReadOnlyEngine.java, +                    // Before 8.0 the global checkpoint is not known and up to date when the engine is created after, +                    // peer recovery, so we only check the max seq no / global checkpoint coherency when the global, +                    final Version indexVersionCreated = engineConfig.getIndexSettings().getIndexVersionCreated();, +                    if (indexVersionCreated.onOrAfter(Version.V_8_0_0) ||, +                        (globalCheckpoint != SequenceNumbers.UNASSIGNED_SEQ_NO && indexVersionCreated.onOrAfter(Version.V_6_7_0))) {, +++ b/server/src/main/java/org/elasticsearch/indices/recovery/PeerRecoveryTargetService.java, +        transportService.registerRequestHandler(Actions.CLEAN_FILES, ThreadPool.Names.GENERIC,, +            RecoveryCleanFilesRequest::new, new CleanFilesRequestHandler());, +                recoveryRef.target().cleanFiles(request.totalTranslogOps(), request.getGlobalCheckpoint(), request.sourceMetaSnapshot());, +++ b/server/src/main/java/org/elasticsearch/index/engine/ReadOnlyEngine.java, +                    // Before 8.0 the global checkpoint is not known and up to date when the engine is created after, +                    // peer recovery, so we only check the max seq no / global checkpoint coherency when the global, +                    final Version indexVersionCreated = engineConfig.getIndexSettings().getIndexVersionCreated();, +                    if (indexVersionCreated.onOrAfter(Version.V_8_0_0) ||, +                        (globalCheckpoint != SequenceNumbers.UNASSIGNED_SEQ_NO && indexVersionCreated.onOrAfter(Version.V_6_7_0))) {, +++ b/server/src/main/java/org/elasticsearch/indices/recovery/PeerRecoveryTargetService.java, +        transportService.registerRequestHandler(Actions.CLEAN_FILES, ThreadPool.Names.GENERIC,, +            RecoveryCleanFilesRequest::new, new CleanFilesRequestHandler());, +                recoveryRef.target().cleanFiles(request.totalTranslogOps(), request.getGlobalCheckpoint(), request.sourceMetaSnapshot());, +++ b/server/src/main/java/org/elasticsearch/indices/recovery/RecoveryCleanFilesRequest.java, +import org.elasticsearch.Version;, +import org.elasticsearch.index.seqno.SequenceNumbers;, +    private final long recoveryId;, +    private final ShardId shardId;, +    private final Store.MetadataSnapshot snapshotFiles;, +    private final int totalTranslogOps;, +    private final long globalCheckpoint;, +    RecoveryCleanFilesRequest(long recoveryId, ShardId shardId, Store.MetadataSnapshot snapshotFiles,, +                              int totalTranslogOps, long globalCheckpoint) {, +        this.globalCheckpoint = globalCheckpoint;, +    }, +, +    RecoveryCleanFilesRequest(StreamInput in) throws IOException {, +        super(in);, +        recoveryId = in.readLong();, +        shardId = ShardId.readShardId(in);, +        snapshotFiles = new Store.MetadataSnapshot(in);, +        totalTranslogOps = in.readVInt();, +        if (in.getVersion().onOrAfter(Version.V_8_0_0)) {, +            globalCheckpoint = in.readZLong();, +        } else {, +            globalCheckpoint = SequenceNumbers.UNASSIGNED_SEQ_NO;, +        }, +    }, +, +    @Override, +    public void writeTo(StreamOutput out) throws IOException {, +        super.writeTo(out);, +        out.writeLong(recoveryId);, +        shardId.writeTo(out);, +        snapshotFiles.writeTo(out);, +        out.writeVInt(totalTranslogOps);, +        if (out.getVersion().onOrAfter(Version.V_8_0_0)) {, +            out.writeZLong(globalCheckpoint);, +        }, +    }, +, +    public Store.MetadataSnapshot sourceMetaSnapshot() {, +        return snapshotFiles;, +, +    public long getGlobalCheckpoint() {, +        return globalCheckpoint;, +    }, +++ b/server/src/main/java/org/elasticsearch/index/engine/ReadOnlyEngine.java, +                    // Before 8.0 the global checkpoint is not known and up to date when the engine is created after, +                    // peer recovery, so we only check the max seq no / global checkpoint coherency when the global, +                    final Version indexVersionCreated = engineConfig.getIndexSettings().getIndexVersionCreated();, +                    if (indexVersionCreated.onOrAfter(Version.V_8_0_0) ||, +                        (globalCheckpoint != SequenceNumbers.UNASSIGNED_SEQ_NO && indexVersionCreated.onOrAfter(Version.V_6_7_0))) {, +++ b/server/src/main/java/org/elasticsearch/indices/recovery/PeerRecoveryTargetService.java, +        transportService.registerRequestHandler(Actions.CLEAN_FILES, ThreadPool.Names.GENERIC,, +            RecoveryCleanFilesRequest::new, new CleanFilesRequestHandler());, +                recoveryRef.target().cleanFiles(request.totalTranslogOps(), request.getGlobalCheckpoint(), request.sourceMetaSnapshot());, +++ b/server/src/main/java/org/elasticsearch/indices/recovery/RecoveryCleanFilesRequest.java, +import org.elasticsearch.Version;, +import org.elasticsearch.index.seqno.SequenceNumbers;, +    private final long recoveryId;, +    private final ShardId shardId;, +    private final Store.MetadataSnapshot snapshotFiles;, +    private final int totalTranslogOps;, +    private final long globalCheckpoint;, +    RecoveryCleanFilesRequest(long recoveryId, ShardId shardId, Store.MetadataSnapshot snapshotFiles,, +                              int totalTranslogOps, long globalCheckpoint) {, +        this.globalCheckpoint = globalCheckpoint;, +    }, +, +    RecoveryCleanFilesRequest(StreamInput in) throws IOException {, +        super(in);, +        recoveryId = in.readLong();, +        shardId = ShardId.readShardId(in);, +        snapshotFiles = new Store.MetadataSnapshot(in);, +        totalTranslogOps = in.readVInt();, +        if (in.getVersion().onOrAfter(Version.V_8_0_0)) {]