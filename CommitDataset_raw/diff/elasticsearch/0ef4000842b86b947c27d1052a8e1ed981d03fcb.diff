[+++ b/modules/elasticsearch/src/main/java/org/elasticsearch/action/admin/indices/mapping/put/PutMappingRequest.java, + * that can't be merged are detected, the request will be rejected unless the {@link #ignoreConflicts(boolean)}, +    private boolean ignoreConflicts = true;, +     * {@link #ignoreConflicts(boolean)} is set. In such a case, the duplicate mappings will be rejected., +    public boolean ignoreConflicts() {, +        return ignoreConflicts;, +     * {@link #ignoreConflicts(boolean)} is set. In such a case, the duplicate mappings will be rejected., +    public PutMappingRequest ignoreConflicts(boolean ignoreDuplicates) {, +        this.ignoreConflicts = ignoreDuplicates;, +        ignoreConflicts = in.readBoolean();, +        out.writeBoolean(ignoreConflicts);, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/action/admin/indices/mapping/put/PutMappingRequest.java, + * that can't be merged are detected, the request will be rejected unless the {@link #ignoreConflicts(boolean)}, +    private boolean ignoreConflicts = true;, +     * {@link #ignoreConflicts(boolean)} is set. In such a case, the duplicate mappings will be rejected., +    public boolean ignoreConflicts() {, +        return ignoreConflicts;, +     * {@link #ignoreConflicts(boolean)} is set. In such a case, the duplicate mappings will be rejected., +    public PutMappingRequest ignoreConflicts(boolean ignoreDuplicates) {, +        this.ignoreConflicts = ignoreDuplicates;, +        ignoreConflicts = in.readBoolean();, +        out.writeBoolean(ignoreConflicts);, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/action/admin/indices/mapping/put/TransportPutMappingAction.java, +        MetaDataService.PutMappingResult result = metaDataService.putMapping(indices, request.type(), request.mappingSource(), request.ignoreConflicts(), request.timeout());, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/action/admin/indices/mapping/put/PutMappingRequest.java, + * that can't be merged are detected, the request will be rejected unless the {@link #ignoreConflicts(boolean)}, +    private boolean ignoreConflicts = true;, +     * {@link #ignoreConflicts(boolean)} is set. In such a case, the duplicate mappings will be rejected., +    public boolean ignoreConflicts() {, +        return ignoreConflicts;, +     * {@link #ignoreConflicts(boolean)} is set. In such a case, the duplicate mappings will be rejected., +    public PutMappingRequest ignoreConflicts(boolean ignoreDuplicates) {, +        this.ignoreConflicts = ignoreDuplicates;, +        ignoreConflicts = in.readBoolean();, +        out.writeBoolean(ignoreConflicts);, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/action/admin/indices/mapping/put/TransportPutMappingAction.java, +        MetaDataService.PutMappingResult result = metaDataService.putMapping(indices, request.type(), request.mappingSource(), request.ignoreConflicts(), request.timeout());, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/cluster/metadata/MetaDataService.java, +import org.elasticsearch.index.mapper.MergeMappingException;, +            // merge from the updated into the existing, ignore conflicts (we know we have them, we just want the new ones), +            existingMapper.merge(updatedMapper, mergeFlags().simulate(false));, +    public synchronized PutMappingResult putMapping(final String[] indices, String mappingType, final String mappingSource, boolean ignoreConflicts, TimeValue timeout) throws ElasticSearchException {, +                    // first, simulate, +                    DocumentMapper.MergeResult mergeResult = existingMapper.merge(newMapper, mergeFlags().simulate(true));, +                    // if we have conflicts, and we are not supposed to ignore them, throw an exception, +                    if (!ignoreConflicts && mergeResult.hasConflicts()) {, +                        throw new MergeMappingException(mergeResult.conflicts());, +                    }, +                existingMapper.merge(newMapper, mergeFlags().simulate(false));, +    /**, +     * The result of a putting mapping., +     */, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/action/admin/indices/mapping/put/PutMappingRequest.java, + * that can't be merged are detected, the request will be rejected unless the {@link #ignoreConflicts(boolean)}, +    private boolean ignoreConflicts = true;, +     * {@link #ignoreConflicts(boolean)} is set. In such a case, the duplicate mappings will be rejected., +    public boolean ignoreConflicts() {, +        return ignoreConflicts;, +     * {@link #ignoreConflicts(boolean)} is set. In such a case, the duplicate mappings will be rejected., +    public PutMappingRequest ignoreConflicts(boolean ignoreDuplicates) {, +        this.ignoreConflicts = ignoreDuplicates;, +        ignoreConflicts = in.readBoolean();, +        out.writeBoolean(ignoreConflicts);, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/action/admin/indices/mapping/put/TransportPutMappingAction.java, +        MetaDataService.PutMappingResult result = metaDataService.putMapping(indices, request.type(), request.mappingSource(), request.ignoreConflicts(), request.timeout());, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/cluster/metadata/MetaDataService.java, +import org.elasticsearch.index.mapper.MergeMappingException;, +            // merge from the updated into the existing, ignore conflicts (we know we have them, we just want the new ones), +            existingMapper.merge(updatedMapper, mergeFlags().simulate(false));, +    public synchronized PutMappingResult putMapping(final String[] indices, String mappingType, final String mappingSource, boolean ignoreConflicts, TimeValue timeout) throws ElasticSearchException {, +                    // first, simulate, +                    DocumentMapper.MergeResult mergeResult = existingMapper.merge(newMapper, mergeFlags().simulate(true));, +                    // if we have conflicts, and we are not supposed to ignore them, throw an exception, +                    if (!ignoreConflicts && mergeResult.hasConflicts()) {, +                        throw new MergeMappingException(mergeResult.conflicts());, +                    }, +                existingMapper.merge(newMapper, mergeFlags().simulate(false));, +    /**, +     * The result of a putting mapping., +     */, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/index/mapper/DocumentMapper.java, +     * Merges this document mapper with the provided document mapper. If there are conflicts, the, +     * {@link MergeResult} will hold them., +     */, +    MergeResult merge(DocumentMapper mergeWith, MergeFlags mergeFlags) throws MergeMappingException;, +, +    /**, +    /**, +     * A result of a merge., +     */, +    public static class MergeResult {, +, +        private final String[] conflicts;, +, +        public MergeResult(String[] conflicts) {, +            this.conflicts = conflicts;, +        }, +, +        /**, +         * Does the merge have conflicts or not?]