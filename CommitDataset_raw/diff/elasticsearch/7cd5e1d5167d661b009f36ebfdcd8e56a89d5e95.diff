[+++ b/plugin/security/src/main/java/org/elasticsearch/xpack/security/authc/esnative/tool/CommandLineHttpClient.java, +, +    /**, +     * Timeout HTTP(s) reads after 35 seconds., +     * The default timeout for discovering a master is 30s, and we want to be longer than this, otherwise a querying a disconnected node, +     * will trigger as client side timeout rather than giving clear error details., +     */, +    private static final int READ_TIMEOUT = 35 * 1000;, +, +        conn.setReadTimeout(READ_TIMEOUT);, +++ b/plugin/security/src/main/java/org/elasticsearch/xpack/security/authc/esnative/tool/CommandLineHttpClient.java, +, +    /**, +     * Timeout HTTP(s) reads after 35 seconds., +     * The default timeout for discovering a master is 30s, and we want to be longer than this, otherwise a querying a disconnected node, +     * will trigger as client side timeout rather than giving clear error details., +     */, +    private static final int READ_TIMEOUT = 35 * 1000;, +, +        conn.setReadTimeout(READ_TIMEOUT);, +++ b/plugin/security/src/main/java/org/elasticsearch/xpack/security/authc/esnative/tool/SetupPasswordTool.java, +import java.util.Objects;, +            checkClusterHealth(terminal);, +            checkClusterHealth(terminal);, +         * @param terminal where to write verbose info., +        void checkClusterHealth(Terminal terminal) throws Exception {, +            URL route = createURL(url, "/_cluster/health", "?pretty");, +            terminal.println(Verbosity.VERBOSE, "");, +            terminal.println(Verbosity.VERBOSE, "Checking cluster health: " + route.toString());, +            final HttpResponse httpResponse = client.execute("GET", route, elasticUser, elasticUserPassword, () -> null,, +                    is -> responseBuilder(is, terminal));, +            if (httpResponse.getHttpStatus() != HttpURLConnection.HTTP_OK) {, +                terminal.println("");, +                terminal.println("Failed to determine the health of the cluster running at " + url);, +                terminal.println("Unexpected response code [" + httpResponse.getHttpStatus() + "] from calling GET " + route.toString());, +                final String cause = getErrorCause(httpResponse);, +                if (cause != null) {, +                    terminal.println("Cause: " + cause);, +                }, +            } else {, +                final String clusterStatus = Objects.toString(httpResponse.getResponseBody().get("status"), "");, +                if (clusterStatus.isEmpty()) {, +                    terminal.println("");, +                    terminal.println("Failed to determine the health of the cluster running at " + url);, +                    terminal.println("Could not find a 'status' value at " + route.toString());, +                } else if ("red".equalsIgnoreCase(clusterStatus)) {, +                    terminal.println("");, +                    terminal.println("Your cluster health is currently RED.");, +                    terminal.println("This means that some cluster data is unavailable and your cluster is not fully functional.");, +                } else {, +                    // Cluster is yellow/green -> all OK, +                    return;, +                }, +            }, +            terminal.println("");, +            terminal.println("It is recommended that you resolve the issues with your cluster before running setup-passwords.");, +            terminal.println("It is very likely that the password changes will fail when run against an unhealthy cluster.");, +            terminal.println("");, +            if (shouldPrompt) {, +                final boolean keepGoing = terminal.promptYesNo("Do you want to continue with the password setup process", false);, +                if (keepGoing == false) {, +                    throw new UserException(ExitCodes.OK, "User cancelled operation");, +                }, +                terminal.println("");, +            }, +        }, +, +         * @param user     The user who's password will change., +         * @param password the new password of the user., +                    String cause = getErrorCause(httpResponse);, +                    if (cause != null) {, +                        terminal.println("Cause: " + cause);, +                        terminal.println("");, +                    }, +                    terminal.println("* Try running with the --verbose parameter for additional messages.");, +         * @param passwordFn      Function to generate or prompt for each user's password., +         * @param successCallback Callback for each successful operation, +    private String getErrorCause(HttpResponse httpResponse) {, +        final Object error = httpResponse.getResponseBody().get("error");, +        if (error == null) {, +            return null;, +        }, +        if (error instanceof Map) {, +            Object reason = ((Map) error).get("reason");, +            if (reason != null) {, +                return reason.toString();, +            }, +            final Object root = ((Map) error).get("root_cause");, +            if (root != null && root instanceof Map) {, +                reason = ((Map) root).get("reason");, +                if (reason != null) {, +                    return reason.toString();, +                }, +                final Object type = ((Map) root).get("type");, +                if (type != null) {, +                    return (String) type;, +                }, +            }, +            return String.valueOf(((Map) error).get("type"));, +        }]