[+++ b/src/test/java/org/elasticsearch/discovery/DiscoveryWithNetworkFailuresTests.java, +import org.elasticsearch.action.admin.cluster.health.ClusterHealthStatus;, +import org.elasticsearch.action.get.GetResponse;, +import org.elasticsearch.action.index.IndexRequestBuilder;, +import org.elasticsearch.action.search.SearchResponse;, +import org.elasticsearch.action.update.UpdateResponse;, +import org.elasticsearch.cluster.block.ClusterBlock;, +import org.elasticsearch.cluster.block.ClusterBlockException;, +import org.elasticsearch.cluster.routing.allocation.decider.ShardsLimitAllocationDecider;, +import org.elasticsearch.common.unit.TimeValue;, +import org.elasticsearch.rest.RestStatus;, +import org.elasticsearch.search.SearchHit;, +import org.elasticsearch.search.sort.SortOrder;, +import static org.elasticsearch.test.hamcrest.ElasticsearchAssertions.*;, +import static org.hamcrest.Matchers.*;, +    private static final Settings nodeSettings = ImmutableSettings.settingsBuilder(), +    @Override, +    protected int numberOfShards() {, +        return 3;, +    }, +, +    @Override, +    protected int numberOfReplicas() {, +        return 1;, +    }, +, +    @Override, +    public Settings indexSettings() {, +        Settings settings = super.indexSettings();, +        return ImmutableSettings.builder(), +                .put(settings), +                .put(ShardsLimitAllocationDecider.INDEX_TOTAL_SHARDS_PER_NODE, 2), +                .build();, +    }, +, +    @Test, +    @TestLogging("discovery.zen:TRACE"), +    public void failWithMinimumMasterNodesConfigured() throws Exception {, +, +        List<String> nodes = internalCluster().startNodesAsync(3, nodeSettings).get();, +    @Test, +    @TestLogging("discovery.zen:TRACE,action:TRACE,cluster.service:TRACE"), +    public void testDataConsistency() throws Exception {, +        List<String> nodes = internalCluster().startNodesAsync(3, nodeSettings).get();, +, +        // Wait until a green status has been reaches and 3 nodes are part of the cluster, +        ClusterHealthResponse clusterHealthResponse = client().admin().cluster().prepareHealth(), +                .setWaitForEvents(Priority.LANGUID), +                .setWaitForNodes("3"), +                .get();, +        assertThat(clusterHealthResponse.isTimedOut(), is(false));, +, +        assertAcked(prepareCreate("test"), +                .addMapping("type", "field", "type=long"), +                .get());, +, +        IndexRequestBuilder[] indexRequests = new IndexRequestBuilder[1 + randomInt(1000)];, +        for (int i = 0; i < indexRequests.length; i++) {, +            indexRequests[i] = client().prepareIndex("test", "type", String.valueOf(i)).setSource("field", i);, +        }, +        indexRandom(true, indexRequests);, +, +, +        for (int i = 0; i < indexRequests.length; i++) {, +            GetResponse getResponse = client().prepareGet("test", "type", String.valueOf(i)).get();, +            assertThat(getResponse.isExists(), is(true));, +            assertThat(getResponse.getVersion(), equalTo(1l));, +            assertThat(getResponse.getId(), equalTo(String.valueOf(i)));, +        }, +        SearchResponse searchResponse = client().prepareSearch("test").setTypes("type"), +                .addSort("field", SortOrder.ASC), +                .get();, +        assertHitCount(searchResponse, indexRequests.length);, +        for (int i = 0; i < searchResponse.getHits().getHits().length; i++) {, +            SearchHit searchHit = searchResponse.getHits().getAt(i);, +            assertThat(searchHit.id(), equalTo(String.valueOf(i)));, +            assertThat((long) searchHit.sortValues()[0], equalTo((long) i));, +        }, +, +        // Figure out what is the elected master node, +        DiscoveryNode masterDiscoNode = null;, +        for (String node : nodes) {, +            ClusterState state = internalCluster().client(node).admin().cluster().prepareState().setLocal(true).execute().actionGet().getState();, +            assertThat(state.nodes().size(), equalTo(3));, +            if (masterDiscoNode == null) {, +                masterDiscoNode = state.nodes().masterNode();, +            } else {, +                assertThat(state.nodes().masterNode(), equalTo(masterDiscoNode));, +            }, +        }, +        assert masterDiscoNode != null;, +        logger.info("---> legit elected master node=" + masterDiscoNode);, +        final Client masterClient = internalCluster().masterClient();, +, +        // Everything is stable now, it is now time to simulate evil..., +, +        // Pick a node that isn't the elected master., +        String unluckyNode = null;, +        for (String node : nodes) {, +            if (!node.equals(masterDiscoNode.getName())) {]