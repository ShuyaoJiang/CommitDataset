[+++ b/src/main/java/org/elasticsearch/license/core/DateUtils.java, +import org.elasticsearch.common.joda.time.format.ISODateTimeFormat;, +    private final static FormatDateTimeFormatter formatDateOnlyFormatter = Joda.forPattern("yyyy-MM-dd");, +    private final static DateTimeFormatter dateOnlyFormatter = formatDateOnlyFormatter.parser().withZoneUTC();, +, +    private final static DateTimeFormatter dateTimeFormatter = ISODateTimeFormat.dateTime().withZoneUTC();, +        try {, +            // Try parsing using complete date/time format, +            return dateTimeFormatter.parseDateTime(date).getMillis();, +        } catch (IllegalArgumentException ex) {, +            // Fall back to the date only format, +            MutableDateTime dateTime = dateOnlyFormatter.parseMutableDateTime(date);, +            dateTime.millisOfDay().set(dateTime.millisOfDay().getMaximumValue());, +    }, +        try {, +            // Try parsing using complete date/time format, +        } catch (IllegalArgumentException ex) {, +            // Fall back to the date only format, +            return dateOnlyFormatter.parseDateTime(date).getMillis();, +        }, +, +++ b/src/main/java/org/elasticsearch/license/core/DateUtils.java, +import org.elasticsearch.common.joda.time.format.ISODateTimeFormat;, +    private final static FormatDateTimeFormatter formatDateOnlyFormatter = Joda.forPattern("yyyy-MM-dd");, +    private final static DateTimeFormatter dateOnlyFormatter = formatDateOnlyFormatter.parser().withZoneUTC();, +, +    private final static DateTimeFormatter dateTimeFormatter = ISODateTimeFormat.dateTime().withZoneUTC();, +        try {, +            // Try parsing using complete date/time format, +            return dateTimeFormatter.parseDateTime(date).getMillis();, +        } catch (IllegalArgumentException ex) {, +            // Fall back to the date only format, +            MutableDateTime dateTime = dateOnlyFormatter.parseMutableDateTime(date);, +            dateTime.millisOfDay().set(dateTime.millisOfDay().getMaximumValue());, +    }, +        try {, +            // Try parsing using complete date/time format, +        } catch (IllegalArgumentException ex) {, +            // Fall back to the date only format, +            return dateOnlyFormatter.parseDateTime(date).getMillis();, +        }, +, +++ b/src/main/java/org/elasticsearch/license/core/ESLicense.java, +        builder.dateValueField(XFields.ISSUE_DATE_IN_MILLIS, XFields.ISSUE_DATE, issueDate);, +        builder.dateValueField(XFields.EXPIRY_DATE_IN_MILLIS, XFields.EXPIRY_DATE, expiryDate);, +        static final String ISSUE_DATE_IN_MILLIS = "issue_date_in_millis";, +        static final String EXPIRY_DATE_IN_MILLIS = "expiry_date_in_millis";, +        static final XContentBuilderString ISSUE_DATE_IN_MILLIS = new XContentBuilderString(Fields.ISSUE_DATE_IN_MILLIS);, +        static final XContentBuilderString EXPIRY_DATE_IN_MILLIS = new XContentBuilderString(Fields.EXPIRY_DATE_IN_MILLIS);, +    private static long parseDate(XContentParser parser, String description, boolean endOfTheDay) throws IOException {, +                if (endOfTheDay) {, +                    return DateUtils.endOfTheDay(parser.text());, +                } else {, +                    return DateUtils.beginningOfTheDay(parser.text());, +                }, +                                issueDate(parseDate(parser, "issue", false));, +                            } else if (Fields.ISSUE_DATE_IN_MILLIS.equals(currentFieldName)) {, +                                issueDate(parser.longValue());, +                                expiryDate(parseDate(parser, "expiration", true));, +                            } else if (Fields.EXPIRY_DATE_IN_MILLIS.equals(currentFieldName)) {, +                                expiryDate(parser.longValue());, +++ b/src/main/java/org/elasticsearch/license/core/DateUtils.java, +import org.elasticsearch.common.joda.time.format.ISODateTimeFormat;, +    private final static FormatDateTimeFormatter formatDateOnlyFormatter = Joda.forPattern("yyyy-MM-dd");, +    private final static DateTimeFormatter dateOnlyFormatter = formatDateOnlyFormatter.parser().withZoneUTC();, +, +    private final static DateTimeFormatter dateTimeFormatter = ISODateTimeFormat.dateTime().withZoneUTC();, +        try {, +            // Try parsing using complete date/time format, +            return dateTimeFormatter.parseDateTime(date).getMillis();, +        } catch (IllegalArgumentException ex) {, +            // Fall back to the date only format, +            MutableDateTime dateTime = dateOnlyFormatter.parseMutableDateTime(date);, +            dateTime.millisOfDay().set(dateTime.millisOfDay().getMaximumValue());, +    }, +        try {, +            // Try parsing using complete date/time format, +        } catch (IllegalArgumentException ex) {, +            // Fall back to the date only format, +            return dateOnlyFormatter.parseDateTime(date).getMillis();, +        }, +, +++ b/src/main/java/org/elasticsearch/license/core/ESLicense.java, +        builder.dateValueField(XFields.ISSUE_DATE_IN_MILLIS, XFields.ISSUE_DATE, issueDate);, +        builder.dateValueField(XFields.EXPIRY_DATE_IN_MILLIS, XFields.EXPIRY_DATE, expiryDate);, +        static final String ISSUE_DATE_IN_MILLIS = "issue_date_in_millis";, +        static final String EXPIRY_DATE_IN_MILLIS = "expiry_date_in_millis";, +        static final XContentBuilderString ISSUE_DATE_IN_MILLIS = new XContentBuilderString(Fields.ISSUE_DATE_IN_MILLIS);, +        static final XContentBuilderString EXPIRY_DATE_IN_MILLIS = new XContentBuilderString(Fields.EXPIRY_DATE_IN_MILLIS);, +    private static long parseDate(XContentParser parser, String description, boolean endOfTheDay) throws IOException {, +                if (endOfTheDay) {, +                    return DateUtils.endOfTheDay(parser.text());, +                } else {, +                    return DateUtils.beginningOfTheDay(parser.text());, +                }, +                                issueDate(parseDate(parser, "issue", false));, +                            } else if (Fields.ISSUE_DATE_IN_MILLIS.equals(currentFieldName)) {, +                                issueDate(parser.longValue());, +                                expiryDate(parseDate(parser, "expiration", true));, +                            } else if (Fields.EXPIRY_DATE_IN_MILLIS.equals(currentFieldName)) {]