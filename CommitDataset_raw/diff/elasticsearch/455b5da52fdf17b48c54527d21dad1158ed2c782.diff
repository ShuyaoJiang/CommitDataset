[+++ b/src/main/java/org/elasticsearch/index/fielddata/BytesValues.java, +     * Converts the provided bytes to "safe" ones from a "non" safe call made (if needed). Note,, +     * this calls makes the bytes safe for *reads*, not writes (into the same BytesRef). For example,, +     * it makes it safe to be placed in a map., +, +++ b/src/main/java/org/elasticsearch/index/fielddata/BytesValues.java, +     * Converts the provided bytes to "safe" ones from a "non" safe call made (if needed). Note,, +     * this calls makes the bytes safe for *reads*, not writes (into the same BytesRef). For example,, +     * it makes it safe to be placed in a map., +, +++ b/src/main/java/org/elasticsearch/index/fielddata/plain/FSTBytesAtomicFieldData.java, +import java.io.IOException;, +, +, +++ b/src/main/java/org/elasticsearch/index/fielddata/BytesValues.java, +     * Converts the provided bytes to "safe" ones from a "non" safe call made (if needed). Note,, +     * this calls makes the bytes safe for *reads*, not writes (into the same BytesRef). For example,, +     * it makes it safe to be placed in a map., +, +++ b/src/main/java/org/elasticsearch/index/fielddata/plain/FSTBytesAtomicFieldData.java, +import java.io.IOException;, +, +, +++ b/src/main/java/org/elasticsearch/index/fielddata/plain/PagedBytesAtomicFieldData.java, +        public BytesRef makeSafe(BytesRef bytes) {, +            // when we fill from the pages bytes, we just reference an existing buffer slice, its enough, +            // to create a shallow copy of the bytes to be safe for "reads"., +            return new BytesRef(bytes.bytes, bytes.offset, bytes.length);, +        }, +, +        @Override, +++ b/src/main/java/org/elasticsearch/index/fielddata/BytesValues.java, +     * Converts the provided bytes to "safe" ones from a "non" safe call made (if needed). Note,, +     * this calls makes the bytes safe for *reads*, not writes (into the same BytesRef). For example,, +     * it makes it safe to be placed in a map., +, +++ b/src/main/java/org/elasticsearch/index/fielddata/plain/FSTBytesAtomicFieldData.java, +import java.io.IOException;, +, +, +++ b/src/main/java/org/elasticsearch/index/fielddata/plain/PagedBytesAtomicFieldData.java, +        public BytesRef makeSafe(BytesRef bytes) {, +            // when we fill from the pages bytes, we just reference an existing buffer slice, its enough, +            // to create a shallow copy of the bytes to be safe for "reads"., +            return new BytesRef(bytes.bytes, bytes.offset, bytes.length);, +        }, +, +        @Override, +++ b/src/main/java/org/elasticsearch/search/facet/terms/strings/HashedAggregator.java, +import com.google.common.collect.ImmutableList;, +import java.util.Arrays;, +++ b/src/main/java/org/elasticsearch/index/fielddata/BytesValues.java, +     * Converts the provided bytes to "safe" ones from a "non" safe call made (if needed). Note,, +     * this calls makes the bytes safe for *reads*, not writes (into the same BytesRef). For example,, +     * it makes it safe to be placed in a map., +, +++ b/src/main/java/org/elasticsearch/index/fielddata/plain/FSTBytesAtomicFieldData.java, +import java.io.IOException;, +, +, +++ b/src/main/java/org/elasticsearch/index/fielddata/plain/PagedBytesAtomicFieldData.java, +        public BytesRef makeSafe(BytesRef bytes) {, +            // when we fill from the pages bytes, we just reference an existing buffer slice, its enough, +            // to create a shallow copy of the bytes to be safe for "reads"., +            return new BytesRef(bytes.bytes, bytes.offset, bytes.length);, +        }, +, +        @Override, +++ b/src/main/java/org/elasticsearch/search/facet/terms/strings/HashedAggregator.java, +import com.google.common.collect.ImmutableList;, +import java.util.Arrays;, +++ b/src/main/java/org/elasticsearch/search/facet/termsstats/strings/TermsStatsStringFacetExecutor.java, +import com.google.common.collect.ImmutableList;, +import com.google.common.collect.Lists;, +import java.io.IOException;, +import java.util.Arrays;, +import java.util.Comparator;, +import java.util.List;, +                HashedBytesRef theValue = new HashedBytesRef(values.makeSafe(value), hashCode);, +                HashedBytesRef theValue = new HashedBytesRef(values.makeSafe(value), hashCode);]