[+++ b/src/main/java/org/elasticsearch/index/cache/filter/weighted/WeightedFilterCache.java, +            indicesFilterCache.addReaderKeyToClean(readerKey);, +        indicesFilterCache.addReaderKeyToClean(reader.getCoreCacheKey());, +            return (readerKey.equals(that.readerKey) && filterKey.equals(that.filterKey));, +++ b/src/main/java/org/elasticsearch/index/cache/filter/weighted/WeightedFilterCache.java, +            indicesFilterCache.addReaderKeyToClean(readerKey);, +        indicesFilterCache.addReaderKeyToClean(reader.getCoreCacheKey());, +            return (readerKey.equals(that.readerKey) && filterKey.equals(that.filterKey));, +++ b/src/main/java/org/elasticsearch/index/shard/service/InternalIndexShard.java, +    class EngineRefresher implements Runnable {, +    class EngineMerger implements Runnable {, +++ b/src/main/java/org/elasticsearch/index/cache/filter/weighted/WeightedFilterCache.java, +            indicesFilterCache.addReaderKeyToClean(readerKey);, +        indicesFilterCache.addReaderKeyToClean(reader.getCoreCacheKey());, +            return (readerKey.equals(that.readerKey) && filterKey.equals(that.filterKey));, +++ b/src/main/java/org/elasticsearch/index/shard/service/InternalIndexShard.java, +    class EngineRefresher implements Runnable {, +    class EngineMerger implements Runnable {, +++ b/src/main/java/org/elasticsearch/indices/cache/filter/IndicesFilterCache.java, +import gnu.trove.set.hash.THashSet;, +import org.elasticsearch.common.CacheRecycler;, +import org.elasticsearch.common.util.concurrent.ConcurrentCollections;, +import org.elasticsearch.threadpool.ThreadPool;, +import java.util.Iterator;, +import java.util.Set;, +    private final ThreadPool threadPool;, +, +    private final TimeValue cleanInterval;, +, +    private final Set<Object> readersKeysToClean = ConcurrentCollections.newConcurrentSet();, +, +    private volatile boolean closed;, +, +    public IndicesFilterCache(Settings settings, ThreadPool threadPool, NodeSettingsService nodeSettingsService) {, +        this.threadPool = threadPool;, +        this.cleanInterval = componentSettings.getAsTime("clean_interval", TimeValue.timeValueSeconds(1));, +, +        threadPool.schedule(cleanInterval, ThreadPool.Names.SAME, new ReaderCleaner());, +        cacheBuilder.concurrencyLevel(16);, +    public void addReaderKeyToClean(Object readerKey) {, +        readersKeysToClean.add(readerKey);, +    }, +, +        closed = true;, +, +    /**, +     * The reason we need this class ie because we need to clean all the filters that are associated, +     * with a reader. We don't want to do it every time a reader closes, since iterating over all the map, +     * is expensive. There doesn't seem to be a nicer way to do it (and maintaining a list per reader, +     * of the filters will cost more)., +     */, +    class ReaderCleaner implements Runnable {, +, +        @Override, +        public void run() {, +            if (closed) {, +                return;, +            }, +            if (readersKeysToClean.isEmpty()) {, +                threadPool.schedule(cleanInterval, ThreadPool.Names.SAME, this);, +                return;, +            }, +            threadPool.executor(ThreadPool.Names.GENERIC).execute(new Runnable() {, +                @Override, +                public void run() {, +                    THashSet<Object> keys = CacheRecycler.popHashSet();, +                    try {, +                        for (Iterator<Object> it = readersKeysToClean.iterator(); it.hasNext(); ) {, +                            keys.add(it.next());, +                            it.remove();, +                        }, +                        cache.cleanUp();, +                        if (!keys.isEmpty()) {, +                            for (Iterator<WeightedFilterCache.FilterCacheKey> it = cache.asMap().keySet().iterator(); it.hasNext(); ) {, +                                WeightedFilterCache.FilterCacheKey filterCacheKey = it.next();, +                                if (keys.contains(filterCacheKey.readerKey())) {, +                                    // same as invalidate, +                                    it.remove();, +                                }, +                            }, +                        }, +                        threadPool.schedule(cleanInterval, ThreadPool.Names.SAME, ReaderCleaner.this);, +                    } finally {, +                        CacheRecycler.pushHashSet(keys);, +                    }, +                }, +            });, +        }, +    }]