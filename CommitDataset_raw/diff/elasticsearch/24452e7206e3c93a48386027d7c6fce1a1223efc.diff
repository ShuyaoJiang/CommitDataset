[+++ b/core/src/main/java/org/elasticsearch/common/lucene/all/AllTermQuery.java, +++ b/core/src/main/java/org/elasticsearch/common/lucene/all/AllTermQuery.java, +++ b/core/src/main/java/org/elasticsearch/env/NodeEnvironment.java, +import com.google.common.primitives.Ints;, +import org.elasticsearch.common.Nullable;, +    /**, +     * Tries to find all allocated shards for the given index, +     * on the current node. NOTE: This methods is prone to race-conditions on the filesystem layer since it might not, +     * see directories created concurrently or while it's traversing., +     * @param index the index to filter shards, +     * @return a set of shard IDs, +     * @throws IOException if an IOException occurs, +     */, +    public Set<ShardId> findAllShardIds(final Index index) throws IOException {, +        assert index != null;, +        if (nodePaths == null || locks == null) {, +            throw new IllegalStateException("node is not configured to store local location");, +        }, +        assert assertEnvIsLocked();, +        final Set<ShardId> shardIds = Sets.newHashSet();, +        String indexName = index.name();, +        for (final NodePath nodePath : nodePaths) {, +            Path location = nodePath.indicesPath;, +            if (Files.isDirectory(location)) {, +                try (DirectoryStream<Path> indexStream = Files.newDirectoryStream(location)) {, +                    for (Path indexPath : indexStream) {, +                        if (indexName.equals(indexPath.getFileName().toString())) {, +                            shardIds.addAll(findAllShardsForIndex(indexPath));, +                        }, +                    }, +                }, +            }, +        }, +        return shardIds;, +    }, +, +    private static Set<ShardId> findAllShardsForIndex(Path indexPath) throws IOException {, +        Set<ShardId> shardIds = new HashSet<>();, +        if (Files.isDirectory(indexPath)) {, +            try (DirectoryStream<Path> stream = Files.newDirectoryStream(indexPath)) {, +                String currentIndex = indexPath.getFileName().toString();, +                for (Path shardPath : stream) {, +                    if (Files.isDirectory(shardPath)) {, +                        Integer shardId = Ints.tryParse(shardPath.getFileName().toString());, +                        if (shardId != null) {, +                            ShardId id = new ShardId(currentIndex, shardId);, +                            shardIds.add(id);, +                        }, +                    }, +                }, +            }, +        }, +        return shardIds;, +    }, +, +++ b/core/src/main/java/org/elasticsearch/common/lucene/all/AllTermQuery.java, +++ b/core/src/main/java/org/elasticsearch/env/NodeEnvironment.java, +import com.google.common.primitives.Ints;, +import org.elasticsearch.common.Nullable;, +    /**, +     * Tries to find all allocated shards for the given index, +     * on the current node. NOTE: This methods is prone to race-conditions on the filesystem layer since it might not, +     * see directories created concurrently or while it's traversing., +     * @param index the index to filter shards, +     * @return a set of shard IDs, +     * @throws IOException if an IOException occurs, +     */, +    public Set<ShardId> findAllShardIds(final Index index) throws IOException {, +        assert index != null;, +        if (nodePaths == null || locks == null) {, +            throw new IllegalStateException("node is not configured to store local location");, +        }, +        assert assertEnvIsLocked();, +        final Set<ShardId> shardIds = Sets.newHashSet();, +        String indexName = index.name();, +        for (final NodePath nodePath : nodePaths) {, +            Path location = nodePath.indicesPath;, +            if (Files.isDirectory(location)) {, +                try (DirectoryStream<Path> indexStream = Files.newDirectoryStream(location)) {, +                    for (Path indexPath : indexStream) {, +                        if (indexName.equals(indexPath.getFileName().toString())) {, +                            shardIds.addAll(findAllShardsForIndex(indexPath));, +                        }, +                    }, +                }, +            }, +        }, +        return shardIds;, +    }, +, +    private static Set<ShardId> findAllShardsForIndex(Path indexPath) throws IOException {, +        Set<ShardId> shardIds = new HashSet<>();, +        if (Files.isDirectory(indexPath)) {, +            try (DirectoryStream<Path> stream = Files.newDirectoryStream(indexPath)) {, +                String currentIndex = indexPath.getFileName().toString();, +                for (Path shardPath : stream) {, +                    if (Files.isDirectory(shardPath)) {, +                        Integer shardId = Ints.tryParse(shardPath.getFileName().toString());, +                        if (shardId != null) {, +                            ShardId id = new ShardId(currentIndex, shardId);]