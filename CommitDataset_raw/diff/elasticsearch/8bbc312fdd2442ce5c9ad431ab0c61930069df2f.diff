[+++ b/core/src/main/java/org/elasticsearch/client/transport/support/TransportProxyClient.java, +++ b/core/src/main/java/org/elasticsearch/client/transport/support/TransportProxyClient.java, +++ b/core/src/main/java/org/elasticsearch/cluster/ClusterChangedEvent.java, +    /**, +     * Determines whether or not the current cluster state represents an entirely, +     * new cluster, either when a node joins a cluster for the first time or when, +     * the node receives a cluster state update from a brand new cluster (different, +     * UUID from the previous cluster), which will happen when a master node is, +     * elected that has never been part of the cluster before., +     */, +    public boolean isNewCluster() {, +++ b/core/src/main/java/org/elasticsearch/client/transport/support/TransportProxyClient.java, +++ b/core/src/main/java/org/elasticsearch/cluster/ClusterChangedEvent.java, +    /**, +     * Determines whether or not the current cluster state represents an entirely, +     * new cluster, either when a node joins a cluster for the first time or when, +     * the node receives a cluster state update from a brand new cluster (different, +     * UUID from the previous cluster), which will happen when a master node is, +     * elected that has never been part of the cluster before., +     */, +    public boolean isNewCluster() {, +++ b/core/src/main/java/org/elasticsearch/cluster/ClusterState.java, +        sb.append("cluster uuid: ").append(metaData.clusterUUID()).append("\n");, +++ b/core/src/main/java/org/elasticsearch/client/transport/support/TransportProxyClient.java, +++ b/core/src/main/java/org/elasticsearch/cluster/ClusterChangedEvent.java, +    /**, +     * Determines whether or not the current cluster state represents an entirely, +     * new cluster, either when a node joins a cluster for the first time or when, +     * the node receives a cluster state update from a brand new cluster (different, +     * UUID from the previous cluster), which will happen when a master node is, +     * elected that has never been part of the cluster before., +     */, +    public boolean isNewCluster() {, +++ b/core/src/main/java/org/elasticsearch/cluster/ClusterState.java, +        sb.append("cluster uuid: ").append(metaData.clusterUUID()).append("\n");, +++ b/core/src/main/java/org/elasticsearch/indices/cluster/IndicesClusterStateService.java, +        removeUnallocatedIndices(event); // also removes shards of removed indices, +     * @param event the cluster changed event, +    private void removeUnallocatedIndices(final ClusterChangedEvent event) {, +        final ClusterState state = event.state();, +                // if the cluster change indicates a brand new cluster, we only want, +                // to remove the in-memory structures for the index and not delete the, +                // contents on disk because the index will later be re-imported as a, +                // dangling index, +                assert state.metaData().index(index) != null || event.isNewCluster() :, +                    "index " + index + " does not exist in the cluster state, it should either " +, +                    "have been deleted or the cluster must be new";, +++ b/core/src/main/java/org/elasticsearch/client/transport/support/TransportProxyClient.java, +++ b/core/src/main/java/org/elasticsearch/cluster/ClusterChangedEvent.java, +    /**, +     * Determines whether or not the current cluster state represents an entirely, +     * new cluster, either when a node joins a cluster for the first time or when, +     * the node receives a cluster state update from a brand new cluster (different, +     * UUID from the previous cluster), which will happen when a master node is, +     * elected that has never been part of the cluster before., +     */, +    public boolean isNewCluster() {, +++ b/core/src/main/java/org/elasticsearch/cluster/ClusterState.java, +        sb.append("cluster uuid: ").append(metaData.clusterUUID()).append("\n");, +++ b/core/src/main/java/org/elasticsearch/indices/cluster/IndicesClusterStateService.java, +        removeUnallocatedIndices(event); // also removes shards of removed indices, +     * @param event the cluster changed event, +    private void removeUnallocatedIndices(final ClusterChangedEvent event) {, +        final ClusterState state = event.state();, +                // if the cluster change indicates a brand new cluster, we only want, +                // to remove the in-memory structures for the index and not delete the, +                // contents on disk because the index will later be re-imported as a, +                // dangling index, +                assert state.metaData().index(index) != null || event.isNewCluster() :, +                    "index " + index + " does not exist in the cluster state, it should either " +, +                    "have been deleted or the cluster must be new";, +++ b/core/src/test/java/org/elasticsearch/indices/cluster/IndicesClusterStateServiceRandomUpdatesTests.java, +import org.elasticsearch.cluster.metadata.MetaData;, +import org.elasticsearch.cluster.routing.RoutingTable;, +import org.elasticsearch.cluster.routing.ShardRoutingState;, +import org.elasticsearch.common.UUIDs;, +import org.elasticsearch.index.Index;, +import java.util.Arrays;, +import java.util.function.Supplier;, +import static org.elasticsearch.cluster.routing.ShardRoutingState.INITIALIZING;, +        ClusterState state = randomInitialClusterState(clusterStateServiceMap, MockIndicesService::new);, +                state = randomlyUpdateClusterState(state, clusterStateServiceMap, MockIndicesService::new);, +    /**, +     * This test ensures that when a node joins a brand new cluster (different cluster UUID),, +     * different from the cluster it was previously a part of, the in-memory index data structures, +     * are all removed but the on disk contents of those indices remain so that they can later be, +     * imported as dangling indices.  Normally, the first cluster state update that the node, +     * receives from the new cluster would contain a cluster block that would cause all in-memory, +     * structures to be removed (see {@link IndicesClusterStateService#clusterChanged(ClusterChangedEvent)}),, +     * but in the case where the node joined and was a few cluster state updates behind, it would, +     * not have received the cluster block, in which case we still need to remove the in-memory, +     * structures while ensuring the data remains on disk.  This test executes this particular, +     * scenario., +     */, +    public void testJoiningNewClusterOnlyRemovesInMemoryIndexStructures() {, +        // a cluster state derived from the initial state that includes a created index, +        String name = "index_" + randomAsciiOfLength(8).toLowerCase(Locale.ROOT);, +        ShardRoutingState[] replicaStates = new ShardRoutingState[randomIntBetween(0, 3)];, +        Arrays.fill(replicaStates, ShardRoutingState.INITIALIZING);, +        ClusterState stateWithIndex = ClusterStateCreationUtils.state(name, randomBoolean(), ShardRoutingState.INITIALIZING, replicaStates);]