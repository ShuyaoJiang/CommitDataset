[+++ b/src/main/java/org/elasticsearch/ExceptionsHelper.java, +            main = useOrSupress(main, ex);, +    /**, +     * Throws a runtime exception with all given exceptions added as suppressed., +     * If the given list is empty no exception is thrown, +     */, +    public static <T extends Throwable> void maybeThrowRuntimeAndSuppress(List<T> exceptions) {, +        T main = null;, +        for (T ex : exceptions) {, +            main = useOrSupress(main, ex);, +        }, +        if (main != null) {, +            throw new ElasticsearchException(main.getMessage(), main);, +        }, +    }, +, +    public static <T extends Throwable> T useOrSupress(T first, T second) {, +        if (first == null) {, +            return second;, +        } else {, +            first.addSuppressed(second);, +        }, +        return first;, +    }, +, +, +++ b/src/main/java/org/elasticsearch/ExceptionsHelper.java, +            main = useOrSupress(main, ex);, +    /**, +     * Throws a runtime exception with all given exceptions added as suppressed., +     * If the given list is empty no exception is thrown, +     */, +    public static <T extends Throwable> void maybeThrowRuntimeAndSuppress(List<T> exceptions) {, +        T main = null;, +        for (T ex : exceptions) {, +            main = useOrSupress(main, ex);, +        }, +        if (main != null) {, +            throw new ElasticsearchException(main.getMessage(), main);, +        }, +    }, +, +    public static <T extends Throwable> T useOrSupress(T first, T second) {, +        if (first == null) {, +            return second;, +        } else {, +            first.addSuppressed(second);, +        }, +        return first;, +    }, +, +, +++ b/src/main/java/org/elasticsearch/index/fielddata/IndexFieldDataService.java, +import org.elasticsearch.ExceptionsHelper;, +import org.elasticsearch.common.util.concurrent.KeyedLock;, +import java.util.ArrayList;, +import java.util.Collection;, +import java.util.List;, +    private final KeyedLock.GlobalLockable<String> fieldLoadingLock = new KeyedLock.GlobalLockable<>();, +        fieldLoadingLock.globalLock().lock();, +        try {, +            List<Throwable> exceptions = new ArrayList<>(0);, +            final Collection<IndexFieldData<?>> fieldDataValues = loadedFieldData.values();, +            for (IndexFieldData<?> fieldData : fieldDataValues) {, +                try {, +                } catch (Throwable t) {, +                    exceptions.add(t);, +            }, +            fieldDataValues.clear();, +            final Collection<IndexFieldDataCache> fieldDataCacheValues = fieldDataCaches.values();, +            for (IndexFieldDataCache cache : fieldDataCacheValues) {, +                try {, +                } catch (Throwable t) {, +                    exceptions.add(t);, +            }, +            fieldDataCacheValues.clear();, +            ExceptionsHelper.maybeThrowRuntimeAndSuppress(exceptions);, +        } finally {, +            fieldLoadingLock.globalLock().unlock();, +    public void clearField(final String fieldName) {, +        fieldLoadingLock.acquire(fieldName);, +        try {, +            List<Throwable> exceptions = new ArrayList<>(0);, +            final IndexFieldData<?> fieldData = loadedFieldData.remove(fieldName);, +                try {, +                } catch (Throwable t) {, +                    exceptions.add(t);, +            }, +            final IndexFieldDataCache cache = fieldDataCaches.remove(fieldName);, +                try {, +                } catch (Throwable t) {, +                    exceptions.add(t);, +            ExceptionsHelper.maybeThrowRuntimeAndSuppress(exceptions);, +        } finally {, +            fieldLoadingLock.release(fieldName);, +        }, +        fieldLoadingLock.globalLock().lock();, +        try {, +        } finally {, +            fieldLoadingLock.globalLock().unlock();]