[+++ b/core/src/test/java/org/elasticsearch/cluster/node/DiscoveryNodesTests.java, +/*, + * Licensed to Elasticsearch under one or more contributor, + * license agreements. See the NOTICE file distributed with, + * this work for additional information regarding copyright, + * ownership. Elasticsearch licenses this file to you under, + * the Apache License, Version 2.0 (the "License"); you may, + * not use this file except in compliance with the License., + * You may obtain a copy of the License at, + *, + *    http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing,, + * software distributed under the License is distributed on an, + * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY, + * KIND, either express or implied.  See the License for the, + * specific language governing permissions and limitations, + * under the License., + */, +, +package org.elasticsearch.cluster.node;, +, +import org.elasticsearch.Version;, +import org.elasticsearch.common.transport.DummyTransportAddress;, +import org.elasticsearch.test.ESTestCase;, +, +import java.util.ArrayList;, +import java.util.Arrays;, +import java.util.Collections;, +import java.util.HashMap;, +import java.util.HashSet;, +import java.util.List;, +import java.util.Map;, +import java.util.Set;, +, +import static org.hamcrest.CoreMatchers.containsString;, +import static org.hamcrest.CoreMatchers.equalTo;, +, +public class DiscoveryNodesTests extends ESTestCase {, +, +    public void testResolveNodeByIdOrName() {, +        DiscoveryNodes discoveryNodes = buildDiscoveryNodes();, +        DiscoveryNode[] nodes = discoveryNodes.nodes().values().toArray(DiscoveryNode.class);, +        DiscoveryNode node = randomFrom(nodes);, +        DiscoveryNode resolvedNode = discoveryNodes.resolveNode(randomBoolean() ? node.id() : node.name());, +        assertThat(resolvedNode.id(), equalTo(node.id()));, +    }, +, +    public void testResolveNodeByAttribute() {, +        DiscoveryNodes discoveryNodes = buildDiscoveryNodes();, +        NodeSelector nodeSelector = randomFrom(NodeSelector.values());, +        Set<String> matchingNodeIds = nodeSelector.matchingNodeIds(discoveryNodes);, +        try {, +            DiscoveryNode resolvedNode = discoveryNodes.resolveNode(nodeSelector.selector);, +            assertThat(matchingNodeIds.size(), equalTo(1));, +            assertThat(resolvedNode.id(), equalTo(matchingNodeIds.iterator().next()));, +        } catch(IllegalArgumentException e) {, +            if (matchingNodeIds.size() == 0) {, +                assertThat(e.getMessage(), equalTo("failed to resolve [" + nodeSelector.selector + "], no matching nodes"));, +            } else if (matchingNodeIds.size() > 1) {, +                assertThat(e.getMessage(), containsString("where expected to be resolved to a single node"));, +            } else {, +                fail("resolveNode shouldn't have failed for [" + nodeSelector.selector + "]");, +            }, +        }, +    }, +, +    public void testResolveNodesIds() {, +        DiscoveryNodes discoveryNodes = buildDiscoveryNodes();, +, +        int numSelectors = randomIntBetween(1, 5);, +        Set<String> nodeSelectors = new HashSet<>();, +        Set<String> expectedNodeIdsSet = new HashSet<>();, +        for (int i = 0; i < numSelectors; i++) {, +            NodeSelector nodeSelector = randomFrom(NodeSelector.values());, +            if (nodeSelectors.add(nodeSelector.selector)) {, +                expectedNodeIdsSet.addAll(nodeSelector.matchingNodeIds(discoveryNodes));, +            }, +        }, +        int numNodeIds = randomIntBetween(0, 3);, +        String[] nodeIds = discoveryNodes.nodes().keys().toArray(String.class);, +        for (int i = 0; i < numNodeIds; i++) {, +            String nodeId = randomFrom(nodeIds);, +            nodeSelectors.add(nodeId);, +            expectedNodeIdsSet.add(nodeId);, +        }, +        int numNodeNames = randomIntBetween(0, 3);, +        DiscoveryNode[] nodes = discoveryNodes.nodes().values().toArray(DiscoveryNode.class);, +        for (int i = 0; i < numNodeNames; i++) {, +            DiscoveryNode discoveryNode = randomFrom(nodes);, +            nodeSelectors.add(discoveryNode.name());, +            expectedNodeIdsSet.add(discoveryNode.id());, +        }, +, +        String[] resolvedNodesIds = discoveryNodes.resolveNodesIds(nodeSelectors.toArray(new String[nodeSelectors.size()]));, +        Arrays.sort(resolvedNodesIds);, +        String[] expectedNodesIds = expectedNodeIdsSet.toArray(new String[expectedNodeIdsSet.size()]);, +        Arrays.sort(expectedNodesIds);, +        assertThat(resolvedNodesIds, equalTo(expectedNodesIds));, +    }]