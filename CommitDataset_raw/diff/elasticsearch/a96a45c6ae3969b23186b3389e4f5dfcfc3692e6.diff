[+++ b/docs/painless/painless-casting.asciidoc, +A cast converts the value of an original type to the equivalent value of a, +target type. An implicit cast infers the target type and automatically occurs, +during certain <<painless-operators, operations>>. An explicit cast specifies, +the target type and forcefully occurs as its own operation.  Use the *cast, +operator* to specify an explicit cast., +*Errors*, +* If during a cast there exists no equivalent value for the target type., +* If an implicit cast is given, but an explicit cast is required., +*Grammar*, +*Examples*, +* Valid casts., ++, +[source,Painless], +----, +<1> int i = (int)5L;, +<2> Map m = new HashMap();, +<3> HashMap hm = (HashMap)m;, +----, ++, +<1> declare `int i`;, +    explicit cast `long 5` to `int 5` -> `int 5`;, +    assign `int 5` to `i`, +<2> declare `Map m`;, +    allocate `HashMap` instance -> `HashMap reference`;, +    implicit cast `HashMap reference` to `Map reference` -> `Map reference`;, +    assign `Map reference` to `m`, +<3> declare `HashMap hm`;, +    access `m` -> `Map reference`;, +    explicit cast `Map reference` to `HashMap reference` -> `HashMap reference`;, +    assign `HashMap reference` to `hm`, +[[numeric-type-casting]], +==== Numeric Type Casting, +, +A <<primitive-types, numeric type>> cast converts the value of an original, +numeric type to the equivalent value of a target numeric type. A cast between, +two numeric type values results in data loss when the value of the original, +numeric type is larger than the target numeric type can accommodate. A cast, +between an integer type value and a floating point type value can result in, +precision loss., +, +The allowed casts for values of each numeric type are shown as a row in the, +following table:, +*Examples*, +* Valid numeric type casts., ++, +[source,Painless], +<1> int a = 1;, +<2> long b = a;, +<3> short c = (short)b;, +<4> double e = (double)a;, ++, +<1> declare `int a`;, +    assign `int 1` to `a`, +<2> declare `long b`;, +    access `a` -> `int 1`;, +    implicit cast `int 1` to `long 1` -> `long 1`;, +    assign `long 1` to `b`, +<3> declare `short c`;, +    access `b` -> `long 1`;, +    explicit cast `long 1` to `short 1` -> `short 1`;, +    assign `short 1` value to `c`, +<4> declare `double e`;, +    access `a` -> `int 1`;, +    explicit cast `int 1` to `double 1.0`;, +    assign `double 1.0` to `e`;, +    (note the explicit cast is extraneous since an implicit cast is valid), ++, +* Invalid numeric type casts resulting in errors., ++, +[source,Painless], +<1> int a = 1.0; // error, +<2> int b = 2;, +<3> byte c = b;  // error, ++, +<1> declare `int i`;, +    *error* -> cannot implicit cast `double 1.0` to `int 1`;, +    (note an explicit cast is valid), +<2> declare `int b`;, +    assign `int 2` to `b`, +<3> declare byte `c`;, +    access `b` -> `int 2`;, +    *error* -> cannot implicit cast `int 2` to `byte 2`;, +    (note an explicit cast is valid), +[[reference-type-casting]], +==== Reference Type Casting, +A <<reference-types, reference type>> cast converts the value of an original, +reference type to the equivalent value of a target reference type. An implicit, +cast between two reference type values is allowed when the original reference, +type is a descendant of the target type. An explicit cast between two reference, +type values is allowed when the original type is a descendant of the target type, +or the target type is a descendant of the original type., +*Examples*, +* Valid reference type casts., ++, +[source,Painless], +<1> List x;, +<2> ArrayList y = new ArrayList();, +<3> x = y;, +<4> y = (ArrayList)x;]