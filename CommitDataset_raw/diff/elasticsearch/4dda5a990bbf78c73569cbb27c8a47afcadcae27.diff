[+++ b/libs/grok/src/main/java/org/elasticsearch/grok/ThreadWatchdog.java, +import java.util.concurrent.atomic.AtomicBoolean;, +import java.util.concurrent.atomic.AtomicInteger;, +        private final AtomicInteger registered = new AtomicInteger(0);, +        private final AtomicBoolean running = new AtomicBoolean(false);, +            registered.getAndIncrement();, +            if (running.compareAndSet(false, true) == true) {, +                scheduler.apply(interval, this::interruptLongRunningExecutions);, +            }, +            registered.decrementAndGet();, +            if (registered.get() > 0) {, +            } else {, +                running.set(false);, +            }, +++ b/libs/grok/src/main/java/org/elasticsearch/grok/ThreadWatchdog.java, +import java.util.concurrent.atomic.AtomicBoolean;, +import java.util.concurrent.atomic.AtomicInteger;, +        private final AtomicInteger registered = new AtomicInteger(0);, +        private final AtomicBoolean running = new AtomicBoolean(false);, +            registered.getAndIncrement();, +            if (running.compareAndSet(false, true) == true) {, +                scheduler.apply(interval, this::interruptLongRunningExecutions);, +            }, +            registered.decrementAndGet();, +            if (registered.get() > 0) {, +            } else {, +                running.set(false);, +            }, +++ b/libs/grok/src/test/java/org/elasticsearch/grok/ThreadWatchdogTests.java, +import java.util.concurrent.CompletableFuture;, +import java.util.concurrent.ScheduledExecutorService;, +import java.util.concurrent.TimeUnit;, +import org.elasticsearch.test.ESTestCase;, +import org.mockito.Mockito;, +import static org.mockito.Matchers.any;, +import static org.mockito.Matchers.eq;, +import static org.mockito.Mockito.doAnswer;, +import static org.mockito.Mockito.mock;, +import static org.mockito.Mockito.verify;, +import static org.mockito.Mockito.verifyNoMoreInteractions;, +import static org.mockito.Mockito.verifyZeroInteractions;, +    public void testIdleIfNothingRegistered() throws Exception {, +        long interval = 1L;, +        ScheduledExecutorService threadPool = mock(ScheduledExecutorService.class);, +        ThreadWatchdog watchdog = ThreadWatchdog.newInstance(interval, Long.MAX_VALUE, System::currentTimeMillis,, +            (delay, command) -> threadPool.schedule(command, delay, TimeUnit.MILLISECONDS));, +        // Periodic action is not scheduled because no thread is registered, +        verifyZeroInteractions(threadPool);, +        CompletableFuture<Runnable> commandFuture = new CompletableFuture<>();, +        // Periodic action is scheduled because a thread is registered, +        doAnswer(invocationOnMock -> {, +            commandFuture.complete((Runnable) invocationOnMock.getArguments()[0]);, +            return null;, +        }).when(threadPool).schedule(, +            any(Runnable.class), eq(interval), eq(TimeUnit.MILLISECONDS), +        );, +        watchdog.register();, +        // Registering the first thread should have caused the command to get scheduled again, +        Runnable command = commandFuture.get(1L, TimeUnit.MILLISECONDS);, +        Mockito.reset(threadPool);, +        watchdog.unregister();, +        command.run();, +        // Periodic action is not scheduled again because no thread is registered, +        verifyZeroInteractions(threadPool);, +        watchdog.register();, +        Thread otherThread = new Thread(watchdog::register);, +        try {, +            verify(threadPool).schedule(any(Runnable.class), eq(interval), eq(TimeUnit.MILLISECONDS));, +            // Registering a second thread does not cause the command to get scheduled twice, +            verifyNoMoreInteractions(threadPool);, +            otherThread.start();, +        } finally {, +            otherThread.join();, +        }, +    }]