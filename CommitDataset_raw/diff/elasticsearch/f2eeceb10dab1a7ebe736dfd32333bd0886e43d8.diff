[+++ b/core/src/main/java/org/elasticsearch/indices/IndicesService.java, +import org.apache.lucene.store.AlreadyClosedException;, +        return new NodeIndicesStats(oldStats, statsByShard(this, flags));, +    }, +, +    Map<Index, List<IndexShardStats>> statsByShard(final IndicesService indicesService, final CommonStatsFlags flags) {, +        final Map<Index, List<IndexShardStats>> statsByShard = new HashMap<>();, +, +        for (final IndexService indexService : indicesService) {, +            for (final IndexShard indexShard : indexService) {, +                    final IndexShardStats indexShardStats = indicesService.indexShardStats(indicesService, indexShard, flags);, +, +                    if (indexShardStats == null) {, +                    if (statsByShard.containsKey(indexService.index()) == false) {, +                } catch (IllegalIndexShardStateException | AlreadyClosedException e) {, +, +        return statsByShard;, +    }, +, +    IndexShardStats indexShardStats(final IndicesService indicesService, final IndexShard indexShard, final CommonStatsFlags flags) {, +        if (indexShard.routingEntry() == null) {, +            return null;, +        }, +, +        return new IndexShardStats(indexShard.shardId(),, +                                   new ShardStats[] {, +                                       new ShardStats(indexShard.routingEntry(),, +                                                      indexShard.shardPath(),, +                                                      new CommonStats(indicesService.getIndicesQueryCache(), indexShard, flags),, +                                                      indexShard.commitStats(),, +                                                      indexShard.seqNoStats()), +                                   });, +++ b/core/src/main/java/org/elasticsearch/indices/IndicesService.java, +import org.apache.lucene.store.AlreadyClosedException;, +        return new NodeIndicesStats(oldStats, statsByShard(this, flags));, +    }, +, +    Map<Index, List<IndexShardStats>> statsByShard(final IndicesService indicesService, final CommonStatsFlags flags) {, +        final Map<Index, List<IndexShardStats>> statsByShard = new HashMap<>();, +, +        for (final IndexService indexService : indicesService) {, +            for (final IndexShard indexShard : indexService) {, +                    final IndexShardStats indexShardStats = indicesService.indexShardStats(indicesService, indexShard, flags);, +, +                    if (indexShardStats == null) {, +                    if (statsByShard.containsKey(indexService.index()) == false) {, +                } catch (IllegalIndexShardStateException | AlreadyClosedException e) {, +, +        return statsByShard;, +    }, +, +    IndexShardStats indexShardStats(final IndicesService indicesService, final IndexShard indexShard, final CommonStatsFlags flags) {, +        if (indexShard.routingEntry() == null) {, +            return null;, +        }, +, +        return new IndexShardStats(indexShard.shardId(),, +                                   new ShardStats[] {, +                                       new ShardStats(indexShard.routingEntry(),, +                                                      indexShard.shardPath(),, +                                                      new CommonStats(indicesService.getIndicesQueryCache(), indexShard, flags),, +                                                      indexShard.commitStats(),, +                                                      indexShard.seqNoStats()), +                                   });, +++ b/core/src/test/java/org/elasticsearch/indices/IndicesServiceTests.java, +import org.apache.lucene.store.AlreadyClosedException;, +import org.elasticsearch.action.admin.indices.stats.CommonStatsFlags;, +import org.elasticsearch.action.admin.indices.stats.IndexShardStats;, +import org.elasticsearch.index.shard.IllegalIndexShardStateException;, +import org.elasticsearch.index.shard.IndexShard;, +import org.elasticsearch.index.shard.IndexShardState;, +import java.util.List;, +import static org.mockito.Mockito.mock;, +import static org.mockito.Mockito.when;, +, +    public void testStatsByShardDoesNotDieFromExpectedExceptions() {, +        final int shardCount = randomIntBetween(2, 5);, +        final int failedShardId = randomIntBetween(0, shardCount - 1);, +, +        final Index index = new Index("test-index", "abc123");, +        // the shard that is going to fail, +        final ShardId shardId = new ShardId(index, failedShardId);, +, +        final List<IndexShard> shards = new ArrayList<>(shardCount);, +        final List<IndexShardStats> shardStats = new ArrayList<>(shardCount - 1);, +, +        final IndexShardState state = randomFrom(IndexShardState.values());, +        final String message = "TEST - expected";, +, +        final RuntimeException expectedException =, +                randomFrom(new IllegalIndexShardStateException(shardId, state, message), new AlreadyClosedException(message));, +, +        // this allows us to control the indices that exist, +        final IndicesService mockIndicesService = mock(IndicesService.class);, +        final IndexService indexService = mock(IndexService.class);, +, +        // generate fake shards and their responses, +        for (int i = 0; i < shardCount; ++i) {, +            final IndexShard shard = mock(IndexShard.class);, +]