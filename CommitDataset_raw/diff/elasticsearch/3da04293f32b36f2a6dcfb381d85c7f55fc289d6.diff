[+++ b/core/src/main/java/org/elasticsearch/cluster/routing/allocation/decider/SameShardAllocationDecider.java, +        Decision decision = decideSameNode(shardRouting, node, allocation, assignedShards);, +        if (decision.type() == Decision.Type.NO || sameHost == false) {, +            // if its already a NO decision looking at the node, or we aren't configured to look at the host, return the decision, +            return decision;, +        return allocation.decision(Decision.YES, NAME, "the shard does not exist on the same host");, +, +    @Override, +    public Decision canForceAllocatePrimary(ShardRouting shardRouting, RoutingNode node, RoutingAllocation allocation) {, +        assert shardRouting.primary() : "must not call force allocate on a non-primary shard";, +        Iterable<ShardRouting> assignedShards = allocation.routingNodes().assignedShards(shardRouting.shardId());, +        return decideSameNode(shardRouting, node, allocation, assignedShards);, +    }, +, +    private Decision decideSameNode(ShardRouting shardRouting, RoutingNode node, RoutingAllocation allocation,, +                                    Iterable<ShardRouting> assignedShards) {, +        for (ShardRouting assignedShard : assignedShards) {, +            if (node.nodeId().equals(assignedShard.currentNodeId())) {, +                if (assignedShard.isSameAllocation(shardRouting)) {, +                    return allocation.decision(Decision.NO, NAME,, +                        "the shard cannot be allocated to the node on which it already exists [%s]",, +                        shardRouting.toString());, +                } else {, +                    return allocation.decision(Decision.NO, NAME,, +                        "the shard cannot be allocated to the same node on which a copy of the shard already exists [%s]",, +                        assignedShard.toString());, +                }, +            }, +        }, +        return allocation.decision(Decision.YES, NAME, "the shard does not exist on the same node");, +++ b/core/src/main/java/org/elasticsearch/cluster/routing/allocation/decider/SameShardAllocationDecider.java, +        Decision decision = decideSameNode(shardRouting, node, allocation, assignedShards);, +        if (decision.type() == Decision.Type.NO || sameHost == false) {, +            // if its already a NO decision looking at the node, or we aren't configured to look at the host, return the decision, +            return decision;, +        return allocation.decision(Decision.YES, NAME, "the shard does not exist on the same host");, +, +    @Override, +    public Decision canForceAllocatePrimary(ShardRouting shardRouting, RoutingNode node, RoutingAllocation allocation) {, +        assert shardRouting.primary() : "must not call force allocate on a non-primary shard";, +        Iterable<ShardRouting> assignedShards = allocation.routingNodes().assignedShards(shardRouting.shardId());, +        return decideSameNode(shardRouting, node, allocation, assignedShards);, +    }, +, +    private Decision decideSameNode(ShardRouting shardRouting, RoutingNode node, RoutingAllocation allocation,, +                                    Iterable<ShardRouting> assignedShards) {, +        for (ShardRouting assignedShard : assignedShards) {, +            if (node.nodeId().equals(assignedShard.currentNodeId())) {, +                if (assignedShard.isSameAllocation(shardRouting)) {, +                    return allocation.decision(Decision.NO, NAME,, +                        "the shard cannot be allocated to the node on which it already exists [%s]",, +                        shardRouting.toString());, +                } else {, +                    return allocation.decision(Decision.NO, NAME,, +                        "the shard cannot be allocated to the same node on which a copy of the shard already exists [%s]",, +                        assignedShard.toString());, +                }, +            }, +        }, +        return allocation.decision(Decision.YES, NAME, "the shard does not exist on the same node");, +++ b/core/src/test/java/org/elasticsearch/cluster/routing/allocation/SameShardRoutingTests.java, +import org.elasticsearch.action.support.replication.ClusterStateCreationUtils;, +import org.elasticsearch.cluster.ClusterInfo;, +import org.elasticsearch.cluster.routing.RoutingNode;, +import org.elasticsearch.cluster.routing.RoutingNodes;, +import org.elasticsearch.cluster.routing.TestShardRouting;, +import org.elasticsearch.cluster.routing.allocation.decider.AllocationDeciders;, +import org.elasticsearch.cluster.routing.allocation.decider.Decision;, +import org.elasticsearch.index.Index;, +, +import java.util.Collections;, +, +    public void testForceAllocatePrimaryOnSameNodeNotAllowed() {, +        SameShardAllocationDecider decider = new SameShardAllocationDecider(Settings.EMPTY);, +        ClusterState clusterState = ClusterStateCreationUtils.state("idx", randomIntBetween(2, 4), 1);, +        Index index = clusterState.getMetaData().index("idx").getIndex();, +        ShardRouting primaryShard = clusterState.routingTable().index(index).shard(0).primaryShard();, +        RoutingNode routingNode = clusterState.getRoutingNodes().node(primaryShard.currentNodeId());, +        RoutingAllocation routingAllocation = new RoutingAllocation(new AllocationDeciders(Settings.EMPTY, Collections.emptyList()),, +            new RoutingNodes(clusterState, false), clusterState, ClusterInfo.EMPTY, System.nanoTime(), false, +        );, +, +        // can't force allocate same shard copy to the same node, +        ShardRouting newPrimary = TestShardRouting.newShardRouting(primaryShard.shardId(), null, true, ShardRoutingState.UNASSIGNED);, +        Decision decision = decider.canForceAllocatePrimary(newPrimary, routingNode, routingAllocation);, +        assertEquals(Decision.Type.NO, decision.type());, +, +        // can force allocate to a different node, +        RoutingNode unassignedNode = null;, +        for (RoutingNode node : clusterState.getRoutingNodes()) {, +            if (node.isEmpty()) {, +                unassignedNode = node;, +                break;, +            }, +        }, +        decision = decider.canForceAllocatePrimary(newPrimary, unassignedNode, routingAllocation);, +        assertEquals(Decision.Type.YES, decision.type());, +    }]