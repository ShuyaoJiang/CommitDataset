[+++ b/core/src/main/java/org/elasticsearch/search/suggest/completion/CompletionSuggestionBuilder.java, +import org.elasticsearch.common.xcontent.NamedXContentRegistry;, +import org.elasticsearch.common.xcontent.XContentHelper;, +    private static final XContentType CONTEXT_BYTES_XCONTENT_TYPE = XContentType.JSON;, +            XContentBuilder builder = XContentFactory.contentBuilder(CONTEXT_BYTES_XCONTENT_TYPE);, +            XContentBuilder contentBuilder = XContentFactory.contentBuilder(CONTEXT_BYTES_XCONTENT_TYPE);, +        if (mappedFieldType == null || mappedFieldType instanceof CompletionFieldMapper.CompletionFieldType == false) {, +                Map<String, List<ContextMapping.InternalQueryContext>> queryContexts = parseContextBytes(contextBytes,, +                        context.getXContentRegistry(), type.getContextMappings());, +                suggestionContext.setQueryContexts(queryContexts);, +            } else if (contextBytes != null) {, +                throw new IllegalArgumentException("suggester [" + type.name() + "] doesn't expect any context");, +            }, +        }, +        assert suggestionContext.getFieldType() != null : "no completion field type set";, +        return suggestionContext;, +    }, +, +    static Map<String, List<ContextMapping.InternalQueryContext>> parseContextBytes(BytesReference contextBytes,, +            NamedXContentRegistry xContentRegistry, ContextMappings contextMappings) throws IOException {, +        try (XContentParser contextParser = XContentHelper.createParser(xContentRegistry, contextBytes, CONTEXT_BYTES_XCONTENT_TYPE)) {, +                    final ContextMapping<?> mapping = contextMappings.get(currentFieldName);, +            return queryContexts;, +++ b/core/src/main/java/org/elasticsearch/search/suggest/completion/CompletionSuggestionBuilder.java, +import org.elasticsearch.common.xcontent.NamedXContentRegistry;, +import org.elasticsearch.common.xcontent.XContentHelper;, +    private static final XContentType CONTEXT_BYTES_XCONTENT_TYPE = XContentType.JSON;, +            XContentBuilder builder = XContentFactory.contentBuilder(CONTEXT_BYTES_XCONTENT_TYPE);, +            XContentBuilder contentBuilder = XContentFactory.contentBuilder(CONTEXT_BYTES_XCONTENT_TYPE);, +        if (mappedFieldType == null || mappedFieldType instanceof CompletionFieldMapper.CompletionFieldType == false) {, +                Map<String, List<ContextMapping.InternalQueryContext>> queryContexts = parseContextBytes(contextBytes,, +                        context.getXContentRegistry(), type.getContextMappings());, +                suggestionContext.setQueryContexts(queryContexts);, +            } else if (contextBytes != null) {, +                throw new IllegalArgumentException("suggester [" + type.name() + "] doesn't expect any context");, +            }, +        }, +        assert suggestionContext.getFieldType() != null : "no completion field type set";, +        return suggestionContext;, +    }, +, +    static Map<String, List<ContextMapping.InternalQueryContext>> parseContextBytes(BytesReference contextBytes,, +            NamedXContentRegistry xContentRegistry, ContextMappings contextMappings) throws IOException {, +        try (XContentParser contextParser = XContentHelper.createParser(xContentRegistry, contextBytes, CONTEXT_BYTES_XCONTENT_TYPE)) {, +                    final ContextMapping<?> mapping = contextMappings.get(currentFieldName);, +            return queryContexts;, +++ b/core/src/test/java/org/elasticsearch/search/suggest/AbstractSuggestionBuilderTestCase.java, +            assertSuggestionContext(suggestionBuilder, suggestionContext);, +     * put implementation dependent assertions in the sub-type test, +    protected abstract void assertSuggestionContext(SB builder, SuggestionContext context) throws IOException;, +++ b/core/src/main/java/org/elasticsearch/search/suggest/completion/CompletionSuggestionBuilder.java, +import org.elasticsearch.common.xcontent.NamedXContentRegistry;, +import org.elasticsearch.common.xcontent.XContentHelper;, +    private static final XContentType CONTEXT_BYTES_XCONTENT_TYPE = XContentType.JSON;, +            XContentBuilder builder = XContentFactory.contentBuilder(CONTEXT_BYTES_XCONTENT_TYPE);, +            XContentBuilder contentBuilder = XContentFactory.contentBuilder(CONTEXT_BYTES_XCONTENT_TYPE);, +        if (mappedFieldType == null || mappedFieldType instanceof CompletionFieldMapper.CompletionFieldType == false) {, +                Map<String, List<ContextMapping.InternalQueryContext>> queryContexts = parseContextBytes(contextBytes,, +                        context.getXContentRegistry(), type.getContextMappings());, +                suggestionContext.setQueryContexts(queryContexts);, +            } else if (contextBytes != null) {, +                throw new IllegalArgumentException("suggester [" + type.name() + "] doesn't expect any context");, +            }, +        }, +        assert suggestionContext.getFieldType() != null : "no completion field type set";, +        return suggestionContext;, +    }, +, +    static Map<String, List<ContextMapping.InternalQueryContext>> parseContextBytes(BytesReference contextBytes,, +            NamedXContentRegistry xContentRegistry, ContextMappings contextMappings) throws IOException {, +        try (XContentParser contextParser = XContentHelper.createParser(xContentRegistry, contextBytes, CONTEXT_BYTES_XCONTENT_TYPE)) {, +                    final ContextMapping<?> mapping = contextMappings.get(currentFieldName);, +            return queryContexts;, +++ b/core/src/test/java/org/elasticsearch/search/suggest/AbstractSuggestionBuilderTestCase.java, +            assertSuggestionContext(suggestionBuilder, suggestionContext);, +     * put implementation dependent assertions in the sub-type test, +    protected abstract void assertSuggestionContext(SB builder, SuggestionContext context) throws IOException;, +++ b/core/src/test/java/org/elasticsearch/search/suggest/completion/CompletionSuggesterBuilderTests.java, +import org.elasticsearch.search.suggest.completion.context.ContextMapping.InternalQueryContext;, +import static org.hamcrest.Matchers.instanceOf;, +, +        // lazy initialization of context names and mappings, cannot be done in some init method because other test, +        if (contextMappings.isEmpty()) {, +            contextMappings.add(ContextBuilder.category(categoryContextName).build());, +            contextMappings.add(ContextBuilder.geo(geoQueryContextName).build());, +    protected void assertSuggestionContext(CompletionSuggestionBuilder builder, SuggestionContext context) throws IOException {, +        assertThat(context, instanceOf(CompletionSuggestionContext.class));, +        assertThat(context.getSuggester(), instanceOf(CompletionSuggester.class));, +        CompletionSuggestionContext completionSuggestionCtx = (CompletionSuggestionContext) context;, +        assertThat(completionSuggestionCtx.getFieldType(), instanceOf(CompletionFieldType.class) );, +        assertEquals(builder.fuzzyOptions, completionSuggestionCtx.getFuzzyOptions());, +        Map<String, List<InternalQueryContext>> parsedContextBytes;, +        parsedContextBytes = CompletionSuggestionBuilder.parseContextBytes(builder.contextBytes, xContentRegistry(),, +                new ContextMappings(contextMappings));, +        Map<String, List<InternalQueryContext>> queryContexts = completionSuggestionCtx.getQueryContexts();, +        assertEquals(parsedContextBytes.keySet(), queryContexts.keySet());, +        for (String contextName : queryContexts.keySet()) {, +            assertEquals(parsedContextBytes.get(contextName), queryContexts.get(contextName));, +        }, +        assertEquals(builder.regexOptions, completionSuggestionCtx.getRegexOptions());]