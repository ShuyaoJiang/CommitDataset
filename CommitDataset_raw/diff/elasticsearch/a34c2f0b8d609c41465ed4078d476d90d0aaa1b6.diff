[+++ b/core/src/main/java/org/elasticsearch/index/engine/Engine.java, +import org.apache.lucene.search.ReferenceManager;, +    protected Searcher newSearcher(String source, IndexSearcher searcher, ReferenceManager<IndexSearcher> manager) {, +            final ReferenceManager<IndexSearcher> manager = getSearcherManager(source, scope); // can never be null, +    protected static SegmentInfos readLastCommittedSegmentInfos(final ReferenceManager<IndexSearcher> sm, final Store store) throws IOException {, +              we need to inc the store here since we acquire a searcher and that might keep a file open on the, +                ReferenceManager<IndexSearcher> manager = getSearcherManager("refresh_needed", SearcherScope.EXTERNAL);, +                final IndexSearcher searcher =  manager.acquire();, +                try {, +                    final IndexReader r = searcher.getIndexReader();, +                    return ((DirectoryReader) r).isCurrent() == false;, +                } finally {, +                    manager.release(searcher);, +                }, +    protected abstract ReferenceManager<IndexSearcher> getSearcherManager(String source, SearcherScope scope);, +++ b/core/src/main/java/org/elasticsearch/index/engine/Engine.java, +import org.apache.lucene.search.ReferenceManager;, +    protected Searcher newSearcher(String source, IndexSearcher searcher, ReferenceManager<IndexSearcher> manager) {, +            final ReferenceManager<IndexSearcher> manager = getSearcherManager(source, scope); // can never be null, +    protected static SegmentInfos readLastCommittedSegmentInfos(final ReferenceManager<IndexSearcher> sm, final Store store) throws IOException {, +              we need to inc the store here since we acquire a searcher and that might keep a file open on the, +                ReferenceManager<IndexSearcher> manager = getSearcherManager("refresh_needed", SearcherScope.EXTERNAL);, +                final IndexSearcher searcher =  manager.acquire();, +                try {, +                    final IndexReader r = searcher.getIndexReader();, +                    return ((DirectoryReader) r).isCurrent() == false;, +                } finally {, +                    manager.release(searcher);, +                }, +    protected abstract ReferenceManager<IndexSearcher> getSearcherManager(String source, SearcherScope scope);, +++ b/core/src/main/java/org/elasticsearch/index/engine/EngineSearcher.java, +import org.apache.lucene.search.ReferenceManager;, +    private final ReferenceManager<IndexSearcher> manager;, +    public EngineSearcher(String source, IndexSearcher searcher, ReferenceManager<IndexSearcher> manager, Store store, Logger logger) {, +++ b/core/src/main/java/org/elasticsearch/index/engine/Engine.java, +import org.apache.lucene.search.ReferenceManager;, +    protected Searcher newSearcher(String source, IndexSearcher searcher, ReferenceManager<IndexSearcher> manager) {, +            final ReferenceManager<IndexSearcher> manager = getSearcherManager(source, scope); // can never be null, +    protected static SegmentInfos readLastCommittedSegmentInfos(final ReferenceManager<IndexSearcher> sm, final Store store) throws IOException {, +              we need to inc the store here since we acquire a searcher and that might keep a file open on the, +                ReferenceManager<IndexSearcher> manager = getSearcherManager("refresh_needed", SearcherScope.EXTERNAL);, +                final IndexSearcher searcher =  manager.acquire();, +                try {, +                    final IndexReader r = searcher.getIndexReader();, +                    return ((DirectoryReader) r).isCurrent() == false;, +                } finally {, +                    manager.release(searcher);, +                }, +    protected abstract ReferenceManager<IndexSearcher> getSearcherManager(String source, SearcherScope scope);, +++ b/core/src/main/java/org/elasticsearch/index/engine/EngineSearcher.java, +import org.apache.lucene.search.ReferenceManager;, +    private final ReferenceManager<IndexSearcher> manager;, +    public EngineSearcher(String source, IndexSearcher searcher, ReferenceManager<IndexSearcher> manager, Store store, Logger logger) {, +++ b/core/src/main/java/org/elasticsearch/index/engine/InternalEngine.java, +import org.elasticsearch.common.SuppressForbidden;, +    private final ExternalSearcherManager externalSearcherManager;, +        ExternalSearcherManager externalSearcherManager = null;, +            externalSearcherManager = createSearcherManager(new SearchFactory(logger, isClosed, engineConfig));, +            internalSearcherManager = externalSearcherManager.internalSearcherManager;, +                IOUtils.closeWhileHandlingException(writer, translog, internalSearcherManager, externalSearcherManager, scheduler);, +    /**, +     * This reference manager delegates all it's refresh calls to another (internal) SearcherManager, +     * The main purpose for this is that if we have external refreshes happening we don't issue extra, +     * refreshes to clear version map memory etc. this can cause excessive segment creation if heavy indexing, +     * is happening and the refresh interval is low (ie. 1 sec), +     *, +     * This also prevents segment starvation where an internal reader holds on to old segments literally forever, +     * since no indexing is happening and refreshes are only happening to the external reader manager, while with, +     * this specialized implementation an external refresh will immediately be reflected on the internal reader, +     * and old segments can be released in the same way previous version did this (as a side-effect of _refresh), +     */, +    @SuppressForbidden(reason = "reference counting is required here"), +    private static final class ExternalSearcherManager extends ReferenceManager<IndexSearcher> {, +        private final SearcherFactory searcherFactory;, +        private final SearcherManager internalSearcherManager;, +, +        ExternalSearcherManager(SearcherManager internalSearcherManager, SearcherFactory searcherFactory) throws IOException {, +            IndexSearcher acquire = internalSearcherManager.acquire();, +            try {, +                IndexReader indexReader = acquire.getIndexReader();, +                assert indexReader instanceof ElasticsearchDirectoryReader:, +                    "searcher's IndexReader should be an ElasticsearchDirectoryReader, but got " + indexReader;, +                indexReader.incRef(); // steal the reader - getSearcher will decrement if it fails, +                current = SearcherManager.getSearcher(searcherFactory, indexReader, null);, +            } finally {, +                internalSearcherManager.release(acquire);, +            }, +            this.searcherFactory = searcherFactory;, +            this.internalSearcherManager = internalSearcherManager;, +        }, +, +        @Override, +        protected IndexSearcher refreshIfNeeded(IndexSearcher referenceToRefresh) throws IOException {, +            // we simply run a blocking refresh on the internal reference manager and then steal it's reader, +            // it's a save operation since we acquire the reader which incs it's reference but then down the road, +            // steal it by calling incRef on the "stolen" reader, +            internalSearcherManager.maybeRefreshBlocking();, +            IndexSearcher acquire = internalSearcherManager.acquire();, +            final IndexReader previousReader = referenceToRefresh.getIndexReader();, +            assert previousReader instanceof ElasticsearchDirectoryReader:]