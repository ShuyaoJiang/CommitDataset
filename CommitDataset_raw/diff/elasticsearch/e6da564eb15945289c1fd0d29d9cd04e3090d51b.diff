[+++ b/core/src/main/java/org/elasticsearch/common/geo/builders/PolygonBuilder.java, +            // To do the assignment we assume (and later, elsewhere, check) that each hole is within, +            // a single component, and the components do not overlap. Based on this assumption, it's, +            // enough to find a component that contains some vertex of the hole, and, +            // holes[i].coordinate is such a vertex, so we use that one., +, +            // First, we sort all the edges according to their order of intersection with the line, +            // of longitude through holes[i].coordinate, in order from south to north. Edges that do, +            // not intersect this line are sorted to the end of the array and of no further interest, +            // here., +, +            if (intersections == 0) {, +                // There were no edges that intersect the line of longitude through, +                // holes[i].coordinate, so there's no way this hole is within the polygon., +, +            // Next we do a binary search to find the position of holes[i].coordinate in the array., +            // The binary search returns the index of an exact match, or (-insertionPoint - 1) if, +            // the vertex lies between the intersections of edges[insertionPoint] and, +            // edges[insertionPoint+1]. The latter case is vastly more common., +, +            final int pos;, +            boolean sharedVertex = false;, +            if (((pos = Arrays.binarySearch(edges, 0, intersections, current, INTERSECTION_ORDER)) >= 0), +                && !(sharedVertex = (edges[pos].intersect.compareTo(current.coordinate) == 0))) {, +                // The binary search returned an exact match, but we checked again using compareTo(), +                // and it didn't match after all., +, +                // TODO Can this actually happen? Needs a test to exercise it, or else needs to be removed., +                throw new InvalidShapeException("Invalid shape: Hole is not within polygon");, +            }, +, +            final int index;, +            if (sharedVertex) {, +                // holes[i].coordinate lies exactly on an edge., +                index = 0; // TODO Should this be pos instead of 0? This assigns exact matches to the southernmost component., +            } else if (pos == -1) {, +                // holes[i].coordinate is strictly south of all intersections. Assign it to the, +                // southernmost component, and allow later validation to spot that it is not, +                // entirely within the chosen component., +                index = 0;, +            } else {, +                // holes[i].coordinate is strictly north of at least one intersection. Assign it to, +                // the component immediately to its south., +                index = -(pos + 2);, +            }, +, +++ b/core/src/main/java/org/elasticsearch/common/geo/builders/PolygonBuilder.java, +            // To do the assignment we assume (and later, elsewhere, check) that each hole is within, +            // a single component, and the components do not overlap. Based on this assumption, it's, +            // enough to find a component that contains some vertex of the hole, and, +            // holes[i].coordinate is such a vertex, so we use that one., +, +            // First, we sort all the edges according to their order of intersection with the line, +            // of longitude through holes[i].coordinate, in order from south to north. Edges that do, +            // not intersect this line are sorted to the end of the array and of no further interest, +            // here., +, +            if (intersections == 0) {, +                // There were no edges that intersect the line of longitude through, +                // holes[i].coordinate, so there's no way this hole is within the polygon., +, +            // Next we do a binary search to find the position of holes[i].coordinate in the array., +            // The binary search returns the index of an exact match, or (-insertionPoint - 1) if, +            // the vertex lies between the intersections of edges[insertionPoint] and, +            // edges[insertionPoint+1]. The latter case is vastly more common., +, +            final int pos;, +            boolean sharedVertex = false;, +            if (((pos = Arrays.binarySearch(edges, 0, intersections, current, INTERSECTION_ORDER)) >= 0), +                && !(sharedVertex = (edges[pos].intersect.compareTo(current.coordinate) == 0))) {, +                // The binary search returned an exact match, but we checked again using compareTo(), +                // and it didn't match after all., +, +                // TODO Can this actually happen? Needs a test to exercise it, or else needs to be removed., +                throw new InvalidShapeException("Invalid shape: Hole is not within polygon");, +            }, +, +            final int index;, +            if (sharedVertex) {, +                // holes[i].coordinate lies exactly on an edge., +                index = 0; // TODO Should this be pos instead of 0? This assigns exact matches to the southernmost component., +            } else if (pos == -1) {, +                // holes[i].coordinate is strictly south of all intersections. Assign it to the, +                // southernmost component, and allow later validation to spot that it is not, +                // entirely within the chosen component., +                index = 0;, +            } else {, +                // holes[i].coordinate is strictly north of at least one intersection. Assign it to, +                // the component immediately to its south., +                index = -(pos + 2);, +            }, +, +++ b/core/src/test/java/org/elasticsearch/common/geo/builders/PolygonBuilderTests.java, +import org.locationtech.spatial4j.exception.InvalidShapeException;, +    public void testHoleThatIsSouthOfPolygon() {, +        InvalidShapeException e = expectThrows(InvalidShapeException.class, () -> {, +            PolygonBuilder pb = new PolygonBuilder(new CoordinatesBuilder().coordinate(4, 3).coordinate(3, 2).coordinate(3, 3).close());, +            pb.hole(new LineStringBuilder(new CoordinatesBuilder().coordinate(4, 2).coordinate(3, 1).coordinate(4, 1).close()));, +            pb.build();, +        });]