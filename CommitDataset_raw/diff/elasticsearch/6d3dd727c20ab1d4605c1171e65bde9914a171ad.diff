[+++ b/core/src/main/java/org/elasticsearch/common/geo/GeoPoint.java, +        GeoPoint geoPoint = (GeoPoint) o;, +        if (Double.compare(geoPoint.lat, lat) != 0) return false;, +        if (Double.compare(geoPoint.lon, lon) != 0) return false;, +++ b/core/src/main/java/org/elasticsearch/common/geo/GeoPoint.java, +        GeoPoint geoPoint = (GeoPoint) o;, +        if (Double.compare(geoPoint.lat, lat) != 0) return false;, +        if (Double.compare(geoPoint.lon, lon) != 0) return false;, +++ b/core/src/test/java/org/elasticsearch/index/search/geo/GeoPointParsingTests.java, +import org.elasticsearch.test.geo.RandomGeoGenerator;, +    static double TOLERANCE = 1E-5;, +        GeoPoint point2 = new GeoPoint(0, 0);, +        assertPointsEqual(point, point2);, +        assertPointsEqual(point.reset(lat, lon), point2.reset(lat, lon));, +        assertPointsEqual(point.reset(0, 0), point2.reset(0, 0));, +        assertPointsEqual(point.resetLat(lat), point2.reset(lat, 0));, +        assertPointsEqual(point.resetLat(0), point2.reset(0, 0));, +        assertPointsEqual(point.resetLon(lon), point2.reset(0, lon));, +        assertPointsEqual(point.resetLon(0), point2.reset(0, 0));, +        assertPointsEqual(point.reset(0, 0), point2.reset(0, 0));, +        assertPointsEqual(point.resetFromString(Double.toString(lat) + ", " + Double.toHexString(lon)), point2.reset(lat, lon));, +        assertPointsEqual(point.reset(0, 0), point2.reset(0, 0));, +    }, +, +    @Test, +    public void testEqualsHashCodeContract() {, +        // generate a random geopoint, +        final GeoPoint x = RandomGeoGenerator.randomPoint(random());, +        final GeoPoint y = new GeoPoint(x.lat(), x.lon());, +        final GeoPoint z = new GeoPoint(y.lat(), y.lon());, +        // GeoPoint doesn't care about coordinate system bounds, this simply validates inequality, +        final GeoPoint a = new GeoPoint(x.lat() + randomIntBetween(1, 5), x.lon() + randomIntBetween(1, 5));, +, +        /** equality test */, +        // reflexive, +        assertTrue(x.equals(x));, +        // symmetry, +        assertTrue(x.equals(y));, +        // transitivity, +        assertTrue(y.equals(z));, +        assertTrue(x.equals(z));, +        // inequality, +        assertFalse(x.equals(a));, +, +        /** hashCode test */, +        // symmetry, +        assertTrue(x.hashCode() == y.hashCode());, +        // transitivity, +        assertTrue(y.hashCode() == z.hashCode());, +        assertTrue(x.hashCode() == z.hashCode());, +        // inequality, +        assertFalse(x.hashCode() == a.hashCode());, +        GeoPoint randomPt = RandomGeoGenerator.randomPoint(random());, +        GeoPoint point = GeoUtils.parseGeoPoint(objectLatLon(randomPt.lat(), randomPt.lon()));, +        assertPointsEqual(point, randomPt);, +        GeoUtils.parseGeoPoint(arrayLatLon(randomPt.lat(), randomPt.lon()), point);, +        assertPointsEqual(point, randomPt);, +        GeoUtils.parseGeoPoint(geohash(randomPt.lat(), randomPt.lon()), point);, +        assertCloseTo(point, randomPt.lat(), randomPt.lon());, +        GeoUtils.parseGeoPoint(stringLatLon(randomPt.lat(), randomPt.lon()), point);, +        assertCloseTo(point, randomPt.lat(), randomPt.lon());, +        content.field("lat", 0).field("geohash", XGeoHashUtils.stringEncode(0d, 0d));, +        content.field("lon", 0).field("geohash", XGeoHashUtils.stringEncode(0d, 0d));, +    public static void assertPointsEqual(final GeoPoint point1, final GeoPoint point2) {, +        assertEquals(point1, point2);, +        assertEquals(point1.hashCode(), point2.hashCode());, +    }, +, +    public static void assertCloseTo(final GeoPoint point, final double lat, final double lon) {, +        assertEquals(point.lat(), lat, TOLERANCE);, +        assertEquals(point.lon(), lon, TOLERANCE);, +++ b/core/src/main/java/org/elasticsearch/common/geo/GeoPoint.java, +        GeoPoint geoPoint = (GeoPoint) o;, +        if (Double.compare(geoPoint.lat, lat) != 0) return false;, +        if (Double.compare(geoPoint.lon, lon) != 0) return false;, +++ b/core/src/test/java/org/elasticsearch/index/search/geo/GeoPointParsingTests.java, +import org.elasticsearch.test.geo.RandomGeoGenerator;, +    static double TOLERANCE = 1E-5;, +        GeoPoint point2 = new GeoPoint(0, 0);, +        assertPointsEqual(point, point2);, +        assertPointsEqual(point.reset(lat, lon), point2.reset(lat, lon));, +        assertPointsEqual(point.reset(0, 0), point2.reset(0, 0));, +        assertPointsEqual(point.resetLat(lat), point2.reset(lat, 0));, +        assertPointsEqual(point.resetLat(0), point2.reset(0, 0));, +        assertPointsEqual(point.resetLon(lon), point2.reset(0, lon));, +        assertPointsEqual(point.resetLon(0), point2.reset(0, 0));, +        assertPointsEqual(point.reset(0, 0), point2.reset(0, 0));, +        assertPointsEqual(point.resetFromString(Double.toString(lat) + ", " + Double.toHexString(lon)), point2.reset(lat, lon));, +        assertPointsEqual(point.reset(0, 0), point2.reset(0, 0));, +    }, +, +    @Test, +    public void testEqualsHashCodeContract() {, +        // generate a random geopoint, +        final GeoPoint x = RandomGeoGenerator.randomPoint(random());, +        final GeoPoint y = new GeoPoint(x.lat(), x.lon());, +        final GeoPoint z = new GeoPoint(y.lat(), y.lon());, +        // GeoPoint doesn't care about coordinate system bounds, this simply validates inequality, +        final GeoPoint a = new GeoPoint(x.lat() + randomIntBetween(1, 5), x.lon() + randomIntBetween(1, 5));, +]