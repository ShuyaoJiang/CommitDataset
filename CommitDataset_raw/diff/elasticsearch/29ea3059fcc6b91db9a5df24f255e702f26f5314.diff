[+++ b/core/src/main/java/org/elasticsearch/cluster/ClusterStateObserver.java, +        // sample a new state. This state maybe *older* than the supplied state if we are called from an applier,, +        // which wants to wait for something else to happen, +        if (lastObservedState.get().isOlderOrDifferentMaster(newState) && statePredicate.test(newState)) {, +            if (lastObservedState.get().isOlderOrDifferentMaster(newState) && context.statePredicate.test(newState)) {, +        /**, +         * returns true if stored state is older then given state or they are from a different master, meaning they can't be compared, +         * */, +        public boolean isOlderOrDifferentMaster(ClusterState clusterState) {, +            return version < clusterState.version() || Objects.equals(masterNodeId, clusterState.nodes().getMasterNodeId()) == false;, +++ b/core/src/main/java/org/elasticsearch/cluster/ClusterStateObserver.java, +        // sample a new state. This state maybe *older* than the supplied state if we are called from an applier,, +        // which wants to wait for something else to happen, +        if (lastObservedState.get().isOlderOrDifferentMaster(newState) && statePredicate.test(newState)) {, +            if (lastObservedState.get().isOlderOrDifferentMaster(newState) && context.statePredicate.test(newState)) {, +        /**, +         * returns true if stored state is older then given state or they are from a different master, meaning they can't be compared, +         * */, +        public boolean isOlderOrDifferentMaster(ClusterState clusterState) {, +            return version < clusterState.version() || Objects.equals(masterNodeId, clusterState.nodes().getMasterNodeId()) == false;, +++ b/core/src/main/java/org/elasticsearch/cluster/service/ClusterService.java, +import org.elasticsearch.cluster.ClusterStateObserver;, +                final String className = element.getClassName();, +                final String methodName = element.getMethodName();, +                if (className.equals(ClusterStateObserver.class.getName())) {, +                    // people may start an observer from an applier, +                    return true;, +                } else if (className.equals(ClusterService.class.getName()), +                    && methodName.equals("callClusterStateAppliers")) {, +++ b/core/src/main/java/org/elasticsearch/cluster/ClusterStateObserver.java, +        // sample a new state. This state maybe *older* than the supplied state if we are called from an applier,, +        // which wants to wait for something else to happen, +        if (lastObservedState.get().isOlderOrDifferentMaster(newState) && statePredicate.test(newState)) {, +            if (lastObservedState.get().isOlderOrDifferentMaster(newState) && context.statePredicate.test(newState)) {, +        /**, +         * returns true if stored state is older then given state or they are from a different master, meaning they can't be compared, +         * */, +        public boolean isOlderOrDifferentMaster(ClusterState clusterState) {, +            return version < clusterState.version() || Objects.equals(masterNodeId, clusterState.nodes().getMasterNodeId()) == false;, +++ b/core/src/main/java/org/elasticsearch/cluster/service/ClusterService.java, +import org.elasticsearch.cluster.ClusterStateObserver;, +                final String className = element.getClassName();, +                final String methodName = element.getMethodName();, +                if (className.equals(ClusterStateObserver.class.getName())) {, +                    // people may start an observer from an applier, +                    return true;, +                } else if (className.equals(ClusterService.class.getName()), +                    && methodName.equals("callClusterStateAppliers")) {, +++ b/core/src/test/java/org/elasticsearch/cluster/service/ClusterServiceTests.java, +import org.elasticsearch.cluster.ClusterStateObserver;, +    public void testClusterStateApplierCanCreateAnObserver() throws InterruptedException {, +        AtomicReference<Throwable> error = new AtomicReference<>();, +        AtomicBoolean applierCalled = new AtomicBoolean();, +        clusterService.addStateApplier(event -> {, +            try {, +                applierCalled.set(true);, +                ClusterStateObserver observer = new ClusterStateObserver(event.state(),, +                    clusterService, null, logger, threadPool.getThreadContext());, +                observer.waitForNextChange(new ClusterStateObserver.Listener() {, +                    @Override, +                    public void onNewClusterState(ClusterState state) {, +, +                    }, +, +                    @Override, +                    public void onClusterServiceClose() {, +, +                    }, +, +                    @Override, +                    public void onTimeout(TimeValue timeout) {, +, +                    }, +                });, +            } catch (AssertionError e) {, +                    error.set(e);, +            }, +        });, +, +        CountDownLatch latch = new CountDownLatch(1);, +        clusterService.submitStateUpdateTask("test", new ClusterStateUpdateTask() {, +            @Override, +            public ClusterState execute(ClusterState currentState) throws Exception {, +                return ClusterState.builder(currentState).build();, +            }, +, +            @Override, +            public void onFailure(String source, Exception e) {, +                error.compareAndSet(null, e);, +            }, +, +            @Override, +            public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {, +                latch.countDown();, +            }, +        });, +, +        latch.await();, +        assertNull(error.get());, +        assertTrue(applierCalled.get());]