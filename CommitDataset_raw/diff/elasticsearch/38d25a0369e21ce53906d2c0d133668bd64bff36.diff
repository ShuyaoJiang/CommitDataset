[+++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/Locals.java, +        Locals locals = new Locals(programScope, scriptInterface.getExecuteMethodReturnType(), KEYWORDS);, +        for (MethodArgument arg : scriptInterface.getExecuteArguments()) {, +++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/Locals.java, +        Locals locals = new Locals(programScope, scriptInterface.getExecuteMethodReturnType(), KEYWORDS);, +        for (MethodArgument arg : scriptInterface.getExecuteArguments()) {, +++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/ScriptInterface.java, +import java.util.function.Function;, +    private final Definition.Type executeMethodReturnType;, +    private final List<MethodArgument> executeArguments;, +        executeMethodReturnType = definitionTypeForClass(executeMethod.getReturnType(),, +                componentType -> "Painless can only implement execute methods returning a whitelisted type but [" + iface.getName(), +                        + "#execute] returns [" + componentType.getName() + "] which isn't whitelisted.");, +            arguments.add(methodArgument(types[arg], argumentNamesConstant[arg]));, +        this.executeArguments = unmodifiableList(arguments);, +    /**, +     * The interface that the Painless script should implement., +     */, +    /**, +     * An asm method descriptor for the {@code execute} method., +     */, +    /**, +     * The Painless {@link Definition.Type} or the return type of the {@code execute} method. This is used to generate the appropriate, +     * return bytecode., +     */, +    public Definition.Type getExecuteMethodReturnType() {, +        return executeMethodReturnType;, +    /**, +     * Painless {@link Definition.Type}s and names of the arguments to the {@code execute} method. The names are exposed to the Painless, +     * script., +     */, +    public List<MethodArgument> getExecuteArguments() {, +        return executeArguments;, +    }, +, +    /**, +     * The {@code uses$varName} methods that must be implemented by Painless to complete implementing the interface., +     */, +    /**, +     * Painless {@link Definition.Type}s and name of the argument to the {@code execute} method., +     */, +    private static MethodArgument methodArgument(Class<?> type, String argName) {, +        Definition.Type defType = definitionTypeForClass(type, componentType -> "[" + argName + "] is of unknown type [", +                + componentType.getName() + ". Painless interfaces can only accept arguments that are of whitelisted types.");, +        return new MethodArgument(defType, argName);, +    }, +, +    private static Definition.Type definitionTypeForClass(Class<?> type, Function<Class<?>, String> unknownErrorMessageSource) {, +        Class<?> componentType = type;, +        while (componentType.isArray()) {, +            componentType = componentType.getComponentType();, +        if (componentType.equals(Object.class)) {, +            Definition.RuntimeClass runtimeClass = Definition.getRuntimeClass(componentType);, +                throw new IllegalArgumentException(unknownErrorMessageSource.apply(componentType));, +++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/Locals.java, +        Locals locals = new Locals(programScope, scriptInterface.getExecuteMethodReturnType(), KEYWORDS);, +        for (MethodArgument arg : scriptInterface.getExecuteArguments()) {, +++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/ScriptInterface.java, +import java.util.function.Function;, +    private final Definition.Type executeMethodReturnType;, +    private final List<MethodArgument> executeArguments;, +        executeMethodReturnType = definitionTypeForClass(executeMethod.getReturnType(),, +                componentType -> "Painless can only implement execute methods returning a whitelisted type but [" + iface.getName(), +                        + "#execute] returns [" + componentType.getName() + "] which isn't whitelisted.");, +            arguments.add(methodArgument(types[arg], argumentNamesConstant[arg]));, +        this.executeArguments = unmodifiableList(arguments);, +    /**, +     * The interface that the Painless script should implement., +     */, +    /**, +     * An asm method descriptor for the {@code execute} method., +     */, +    /**, +     * The Painless {@link Definition.Type} or the return type of the {@code execute} method. This is used to generate the appropriate, +     * return bytecode., +     */, +    public Definition.Type getExecuteMethodReturnType() {, +        return executeMethodReturnType;, +    /**, +     * Painless {@link Definition.Type}s and names of the arguments to the {@code execute} method. The names are exposed to the Painless, +     * script., +     */, +    public List<MethodArgument> getExecuteArguments() {, +        return executeArguments;, +    }, +, +    /**, +     * The {@code uses$varName} methods that must be implemented by Painless to complete implementing the interface., +     */, +    /**, +     * Painless {@link Definition.Type}s and name of the argument to the {@code execute} method., +     */, +    private static MethodArgument methodArgument(Class<?> type, String argName) {, +        Definition.Type defType = definitionTypeForClass(type, componentType -> "[" + argName + "] is of unknown type [", +                + componentType.getName() + ". Painless interfaces can only accept arguments that are of whitelisted types.");, +        return new MethodArgument(defType, argName);, +    }, +, +    private static Definition.Type definitionTypeForClass(Class<?> type, Function<Class<?>, String> unknownErrorMessageSource) {, +        Class<?> componentType = type;]