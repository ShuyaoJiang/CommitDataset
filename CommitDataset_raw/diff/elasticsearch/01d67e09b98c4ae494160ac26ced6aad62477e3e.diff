[+++ b/core/src/main/java/org/elasticsearch/transport/TcpTransport.java, +    public final class NodeChannels implements Connection {, +        private final DiscoveryNode node;, +        private final AtomicBoolean closed = new AtomicBoolean(false);, +        public NodeChannels(DiscoveryNode node, Channel[] channels, ConnectionProfile connectionProfile) {, +            this.node = node;, +            if (closed.compareAndSet(false, true)) {, +                closeChannels(Arrays.stream(channels).filter(Objects::nonNull).collect(Collectors.toList()));, +            }, +        }, +, +        @Override, +        public DiscoveryNode getNode() {, +            return this.node;, +        }, +, +        @Override, +        public void sendRequest(long requestId, String action, TransportRequest request, TransportRequestOptions options), +            throws IOException, TransportException {, +            if (closed.get()) {, +                throw new NodeNotConnectedException(node, "connection already closed");, +            }, +            Channel channel = channel(options.type());, +            sendRequestToChannel(this.node, channel, requestId, action, request, options);, +                        nodeChannels = openConnection(node, connectionProfile);, +                    transportServiceAdapter.onNodeConnected(node);, +, +    @Override, +    public final NodeChannels openConnection(DiscoveryNode node, ConnectionProfile profile) throws IOException {, +        NodeChannels nodeChannels = connectToChannels(node, profile);, +        transportServiceAdapter.onConnectionOpened(node);, +        return nodeChannels;, +    }, +, +                    closeAndNotify(node, nodeChannels, reason);, +    private void closeAndNotify(DiscoveryNode node, NodeChannels nodeChannels, String reason) {, +        try {, +            logger.debug("disconnecting from [{}], {}", node, reason);, +            IOUtils.closeWhileHandlingException(nodeChannels);, +        } finally {, +            logger.trace("disconnected from [{}], {}", node, reason);, +            transportServiceAdapter.onNodeDisconnected(node);, +        }, +    }, +, +    @Override, +    public Connection getConnection(DiscoveryNode node) {, +        return nodeChannels;, +                closeAndNotify(node, nodeChannels, "due to explicit disconnect call");, +, +    protected void sendRequestToChannel(DiscoveryNode node, Channel targetChannel, final long requestId, final String action,, +                                        final TransportRequest request, TransportRequestOptions options) throws IOException,, +        TransportException {, +++ b/core/src/main/java/org/elasticsearch/transport/TcpTransport.java, +    public final class NodeChannels implements Connection {, +        private final DiscoveryNode node;, +        private final AtomicBoolean closed = new AtomicBoolean(false);, +        public NodeChannels(DiscoveryNode node, Channel[] channels, ConnectionProfile connectionProfile) {, +            this.node = node;, +            if (closed.compareAndSet(false, true)) {, +                closeChannels(Arrays.stream(channels).filter(Objects::nonNull).collect(Collectors.toList()));, +            }, +        }, +, +        @Override, +        public DiscoveryNode getNode() {, +            return this.node;, +        }, +, +        @Override, +        public void sendRequest(long requestId, String action, TransportRequest request, TransportRequestOptions options), +            throws IOException, TransportException {, +            if (closed.get()) {, +                throw new NodeNotConnectedException(node, "connection already closed");, +            }, +            Channel channel = channel(options.type());, +            sendRequestToChannel(this.node, channel, requestId, action, request, options);, +                        nodeChannels = openConnection(node, connectionProfile);, +                    transportServiceAdapter.onNodeConnected(node);, +, +    @Override, +    public final NodeChannels openConnection(DiscoveryNode node, ConnectionProfile profile) throws IOException {, +        NodeChannels nodeChannels = connectToChannels(node, profile);, +        transportServiceAdapter.onConnectionOpened(node);, +        return nodeChannels;, +    }, +, +                    closeAndNotify(node, nodeChannels, reason);, +    private void closeAndNotify(DiscoveryNode node, NodeChannels nodeChannels, String reason) {, +        try {, +            logger.debug("disconnecting from [{}], {}", node, reason);, +            IOUtils.closeWhileHandlingException(nodeChannels);, +        } finally {, +            logger.trace("disconnected from [{}], {}", node, reason);, +            transportServiceAdapter.onNodeDisconnected(node);, +        }, +    }, +, +    @Override, +    public Connection getConnection(DiscoveryNode node) {]