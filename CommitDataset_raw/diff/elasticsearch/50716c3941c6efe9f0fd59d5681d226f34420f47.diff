[+++ b/core/src/main/java/org/elasticsearch/indices/memory/IndexingMemoryController.java, +    protected List<IndexShard> availableShards() {, +        List<IndexShard> activeShards = new ArrayList<>();, +            for (IndexShard shard : indexService) {, +                if (shardAvailable(shard)) {, +                    activeShards.add(shard);, +        return activeShards;, +    protected void updateShardBuffers(IndexShard shard, ByteSizeValue shardIndexingBufferSize, ByteSizeValue shardTranslogBufferSize) {, +                logger.warn("failed to set shard {} index buffer to [{}]", e, shard.shardId(), shardIndexingBufferSize);, +            List<IndexShard> availableShards = availableShards();, +            List<IndexShard> activeShards = new ArrayList<>();, +            for (IndexShard shard : availableShards) {, +                if (!checkIdle(shard)) {, +                    activeShards.add(shard);, +            int activeShardCount = activeShards.size();, +                logger.debug("no active shards");, +            logger.debug("recalculating shard indexing buffer, total is [{}] with [{}] active shards, each shard set to indexing=[{}], translog=[{}]", indexingBuffer, activeShardCount, shardIndexingBufferSize, shardTranslogBufferSize);, +            for (IndexShard shard : activeShards) {, +                updateShardBuffers(shard, shardIndexingBufferSize, shardTranslogBufferSize);, +    /**, +     * ask this shard to check now whether it is inactive, and reduces its indexing and translog buffers if so., +     * return false if the shard is not idle, otherwise true, +     */, +    protected boolean checkIdle(IndexShard shard) {, +            boolean idle = shard.checkIdle();, +            if (idle && logger.isDebugEnabled()) {, +                    shard.shardId(),, +            return idle;, +        } catch (EngineClosedException | FlushNotAllowedEngineException e) {, +            logger.trace("ignore [{}] while marking shard {} as inactive", e.getClass().getSimpleName(), shard.shardId());, +            return true;, +++ b/core/src/main/java/org/elasticsearch/indices/memory/IndexingMemoryController.java, +    protected List<IndexShard> availableShards() {, +        List<IndexShard> activeShards = new ArrayList<>();, +            for (IndexShard shard : indexService) {, +                if (shardAvailable(shard)) {, +                    activeShards.add(shard);, +        return activeShards;, +    protected void updateShardBuffers(IndexShard shard, ByteSizeValue shardIndexingBufferSize, ByteSizeValue shardTranslogBufferSize) {, +                logger.warn("failed to set shard {} index buffer to [{}]", e, shard.shardId(), shardIndexingBufferSize);, +            List<IndexShard> availableShards = availableShards();, +            List<IndexShard> activeShards = new ArrayList<>();, +            for (IndexShard shard : availableShards) {, +                if (!checkIdle(shard)) {, +                    activeShards.add(shard);, +            int activeShardCount = activeShards.size();, +                logger.debug("no active shards");, +            logger.debug("recalculating shard indexing buffer, total is [{}] with [{}] active shards, each shard set to indexing=[{}], translog=[{}]", indexingBuffer, activeShardCount, shardIndexingBufferSize, shardTranslogBufferSize);, +            for (IndexShard shard : activeShards) {, +                updateShardBuffers(shard, shardIndexingBufferSize, shardTranslogBufferSize);, +    /**, +     * ask this shard to check now whether it is inactive, and reduces its indexing and translog buffers if so., +     * return false if the shard is not idle, otherwise true, +     */, +    protected boolean checkIdle(IndexShard shard) {, +            boolean idle = shard.checkIdle();, +            if (idle && logger.isDebugEnabled()) {, +                    shard.shardId(),, +            return idle;, +        } catch (EngineClosedException | FlushNotAllowedEngineException e) {, +            logger.trace("ignore [{}] while marking shard {} as inactive", e.getClass().getSimpleName(), shard.shardId());, +            return true;, +++ b/core/src/main/java/org/elasticsearch/plugins/PluginsService.java, +import java.nio.file.NoSuchFileException;, +                final PluginInfo info;, +                try {, +                    info = PluginInfo.readFromProperties(plugin);, +                } catch (NoSuchFileException e) {, +                    throw new IllegalStateException("Existing plugin [" + plugin.getFileName() + "] missing plugin descriptor. " +, +                        "Was the plugin built before 2.0?", e);, +                }, +, +++ b/core/src/main/java/org/elasticsearch/indices/memory/IndexingMemoryController.java, +    protected List<IndexShard> availableShards() {, +        List<IndexShard> activeShards = new ArrayList<>();, +            for (IndexShard shard : indexService) {, +                if (shardAvailable(shard)) {, +                    activeShards.add(shard);, +        return activeShards;, +    protected void updateShardBuffers(IndexShard shard, ByteSizeValue shardIndexingBufferSize, ByteSizeValue shardTranslogBufferSize) {, +                logger.warn("failed to set shard {} index buffer to [{}]", e, shard.shardId(), shardIndexingBufferSize);, +            List<IndexShard> availableShards = availableShards();, +            List<IndexShard> activeShards = new ArrayList<>();, +            for (IndexShard shard : availableShards) {, +                if (!checkIdle(shard)) {, +                    activeShards.add(shard);, +            int activeShardCount = activeShards.size();, +                logger.debug("no active shards");, +            logger.debug("recalculating shard indexing buffer, total is [{}] with [{}] active shards, each shard set to indexing=[{}], translog=[{}]", indexingBuffer, activeShardCount, shardIndexingBufferSize, shardTranslogBufferSize);, +            for (IndexShard shard : activeShards) {, +                updateShardBuffers(shard, shardIndexingBufferSize, shardTranslogBufferSize);, +    /**, +     * ask this shard to check now whether it is inactive, and reduces its indexing and translog buffers if so., +     * return false if the shard is not idle, otherwise true, +     */, +    protected boolean checkIdle(IndexShard shard) {, +            boolean idle = shard.checkIdle();, +            if (idle && logger.isDebugEnabled()) {, +                    shard.shardId(),, +            return idle;]