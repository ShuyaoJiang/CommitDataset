[+++ b/src/main/java/org/elasticsearch/common/geo/GeoHashUtils.java, +++ b/src/main/java/org/elasticsearch/common/geo/GeoHashUtils.java, +++ b/src/main/java/org/elasticsearch/search/aggregations/AggregatorFactories.java, +    private AggregatorFactory[] factories;, +++ b/src/main/java/org/elasticsearch/common/geo/GeoHashUtils.java, +++ b/src/main/java/org/elasticsearch/search/aggregations/AggregatorFactories.java, +    private AggregatorFactory[] factories;, +++ b/src/main/java/org/elasticsearch/search/aggregations/InternalAggregation.java, +, +        @Override, +        public String toString() {, +            return name;, +        }, +++ b/src/main/java/org/elasticsearch/common/geo/GeoHashUtils.java, +++ b/src/main/java/org/elasticsearch/search/aggregations/AggregatorFactories.java, +    private AggregatorFactory[] factories;, +++ b/src/main/java/org/elasticsearch/search/aggregations/InternalAggregation.java, +, +        @Override, +        public String toString() {, +            return name;, +        }, +++ b/src/main/java/org/elasticsearch/search/aggregations/bucket/geogrid/GeoHashGridParser.java, +import org.elasticsearch.index.fielddata.BytesValues;, +import org.elasticsearch.index.fielddata.DoubleValues;, +import org.elasticsearch.index.fielddata.GeoPointValues;, +import org.elasticsearch.index.fielddata.LongValues;, +        ValuesSourceParser vsParser = ValuesSourceParser.geoPoint(aggregationName, InternalGeoHashGrid.TYPE, context).build();, +, +            } else if (vsParser.token(currentFieldName, token, parser)) {, +                continue;, +        return new GeoGridFactory(aggregationName, vsParser.config(), precision, requiredSize, shardSize);, +        public GeoGridFactory(String name, ValuesSourceConfig<ValuesSource.GeoPoint> config, int precision, int requiredSize, int shardSize) {, +            super(name, InternalGeoHashGrid.TYPE.name(), config);, +++ b/src/main/java/org/elasticsearch/common/geo/GeoHashUtils.java, +++ b/src/main/java/org/elasticsearch/search/aggregations/AggregatorFactories.java, +    private AggregatorFactory[] factories;, +++ b/src/main/java/org/elasticsearch/search/aggregations/InternalAggregation.java, +, +        @Override, +        public String toString() {, +            return name;, +        }, +++ b/src/main/java/org/elasticsearch/search/aggregations/bucket/geogrid/GeoHashGridParser.java, +import org.elasticsearch.index.fielddata.BytesValues;, +import org.elasticsearch.index.fielddata.DoubleValues;, +import org.elasticsearch.index.fielddata.GeoPointValues;, +import org.elasticsearch.index.fielddata.LongValues;, +        ValuesSourceParser vsParser = ValuesSourceParser.geoPoint(aggregationName, InternalGeoHashGrid.TYPE, context).build();, +, +            } else if (vsParser.token(currentFieldName, token, parser)) {, +                continue;, +        return new GeoGridFactory(aggregationName, vsParser.config(), precision, requiredSize, shardSize);, +        public GeoGridFactory(String name, ValuesSourceConfig<ValuesSource.GeoPoint> config, int precision, int requiredSize, int shardSize) {, +            super(name, InternalGeoHashGrid.TYPE.name(), config);, +++ b/src/main/java/org/elasticsearch/search/aggregations/bucket/histogram/DateHistogramParser.java, +import org.elasticsearch.search.aggregations.support.ValueType;, +import org.elasticsearch.search.aggregations.support.ValuesSourceParser;, +        ValuesSourceParser vsParser = ValuesSourceParser.numeric(aggregationName, InternalDateHistogram.TYPE, context), +                .targetValueType(ValueType.DATE), +                .requiresSortedValues(true), +                .formattable(true), +                .build();, +            } else if (vsParser.token(currentFieldName, token, parser)) {, +                continue;, +                if ("time_zone".equals(currentFieldName) || "timeZone".equals(currentFieldName)) {, +                if ("order".equals(currentFieldName)) {, +        return new HistogramAggregator.Factory(aggregationName, vsParser.config(), rounding, order, keyed, minDocCount, extendedBounds, InternalDateHistogram.FACTORY);, +++ b/src/main/java/org/elasticsearch/common/geo/GeoHashUtils.java, +++ b/src/main/java/org/elasticsearch/search/aggregations/AggregatorFactories.java, +    private AggregatorFactory[] factories;, +++ b/src/main/java/org/elasticsearch/search/aggregations/InternalAggregation.java, +, +        @Override, +        public String toString() {, +            return name;, +        }, +++ b/src/main/java/org/elasticsearch/search/aggregations/bucket/geogrid/GeoHashGridParser.java, +import org.elasticsearch.index.fielddata.BytesValues;, +import org.elasticsearch.index.fielddata.DoubleValues;, +import org.elasticsearch.index.fielddata.GeoPointValues;, +import org.elasticsearch.index.fielddata.LongValues;, +        ValuesSourceParser vsParser = ValuesSourceParser.geoPoint(aggregationName, InternalGeoHashGrid.TYPE, context).build();, +, +            } else if (vsParser.token(currentFieldName, token, parser)) {, +                continue;, +        return new GeoGridFactory(aggregationName, vsParser.config(), precision, requiredSize, shardSize);, +        public GeoGridFactory(String name, ValuesSourceConfig<ValuesSource.GeoPoint> config, int precision, int requiredSize, int shardSize) {, +            super(name, InternalGeoHashGrid.TYPE.name(), config);, +++ b/src/main/java/org/elasticsearch/search/aggregations/bucket/histogram/DateHistogramParser.java, +import org.elasticsearch.search.aggregations.support.ValueType;, +import org.elasticsearch.search.aggregations.support.ValuesSourceParser;, +        ValuesSourceParser vsParser = ValuesSourceParser.numeric(aggregationName, InternalDateHistogram.TYPE, context), +                .targetValueType(ValueType.DATE), +                .requiresSortedValues(true), +                .formattable(true), +                .build();, +            } else if (vsParser.token(currentFieldName, token, parser)) {, +                continue;, +                if ("time_zone".equals(currentFieldName) || "timeZone".equals(currentFieldName)) {]