[+++ b/src/main/java/org/elasticsearch/index/service/InternalIndexService.java, +        indicesLifecycle.indexShardStateChanged(indexShard, null, "shard created");, +++ b/src/main/java/org/elasticsearch/index/service/InternalIndexService.java, +        indicesLifecycle.indexShardStateChanged(indexShard, null, "shard created");, +++ b/src/main/java/org/elasticsearch/index/shard/service/InternalIndexShard.java, +                        changeState(IndexShardState.STARTED, "global state is [" + newRouting.state() + "]");, +            return changeState(IndexShardState.RECOVERING, reason);, +            changeState(IndexShardState.RELOCATED, reason);, +    /**, +     * Changes the state of the current shard, +     * @param newState the new shard state, +     * @param reason the reason for the state change, +     * @return the previous shard state, +     */, +    private IndexShardState changeState(IndexShardState newState, String reason) {, +        logger.debug("state: [{}]->[{}], reason [{}]", state, newState, reason);, +        IndexShardState previousState = state;, +        state = newState;, +        this.indicesLifecycle.indexShardStateChanged(this, previousState, reason);, +        return previousState;, +    }, +, +            changeState(IndexShardState.CLOSED, reason);, +            changeState(IndexShardState.POST_RECOVERY, reason);, +            changeState(IndexShardState.POST_RECOVERY, "post recovery");, +++ b/src/main/java/org/elasticsearch/index/service/InternalIndexService.java, +        indicesLifecycle.indexShardStateChanged(indexShard, null, "shard created");, +++ b/src/main/java/org/elasticsearch/index/shard/service/InternalIndexShard.java, +                        changeState(IndexShardState.STARTED, "global state is [" + newRouting.state() + "]");, +            return changeState(IndexShardState.RECOVERING, reason);, +            changeState(IndexShardState.RELOCATED, reason);, +    /**, +     * Changes the state of the current shard, +     * @param newState the new shard state, +     * @param reason the reason for the state change, +     * @return the previous shard state, +     */, +    private IndexShardState changeState(IndexShardState newState, String reason) {, +        logger.debug("state: [{}]->[{}], reason [{}]", state, newState, reason);, +        IndexShardState previousState = state;, +        state = newState;, +        this.indicesLifecycle.indexShardStateChanged(this, previousState, reason);, +        return previousState;, +    }, +, +            changeState(IndexShardState.CLOSED, reason);, +            changeState(IndexShardState.POST_RECOVERY, reason);, +            changeState(IndexShardState.POST_RECOVERY, "post recovery");, +++ b/src/main/java/org/elasticsearch/indices/IndicesLifecycle.java, +import org.elasticsearch.index.shard.IndexShardState;, +, +        /**, +         * Called after a shard's {@link org.elasticsearch.index.shard.IndexShardState} changes., +         * The order of concurrent events is preserved. The execution must be lightweight., +         *, +         * @param indexShard the shard the new state was applied to, +         * @param previousState the previous index shard state if there was one, null otherwise, +         * @param currentState the new shard state, +         * @param reason the reason for the state change if there is one, null otherwise, +         */, +        public void indexShardStateChanged(IndexShard indexShard, @Nullable IndexShardState previousState, IndexShardState currentState, @Nullable String reason) {, +, +        }, +++ b/src/main/java/org/elasticsearch/index/service/InternalIndexService.java, +        indicesLifecycle.indexShardStateChanged(indexShard, null, "shard created");, +++ b/src/main/java/org/elasticsearch/index/shard/service/InternalIndexShard.java, +                        changeState(IndexShardState.STARTED, "global state is [" + newRouting.state() + "]");, +            return changeState(IndexShardState.RECOVERING, reason);, +            changeState(IndexShardState.RELOCATED, reason);, +    /**, +     * Changes the state of the current shard, +     * @param newState the new shard state, +     * @param reason the reason for the state change, +     * @return the previous shard state, +     */, +    private IndexShardState changeState(IndexShardState newState, String reason) {, +        logger.debug("state: [{}]->[{}], reason [{}]", state, newState, reason);, +        IndexShardState previousState = state;, +        state = newState;, +        this.indicesLifecycle.indexShardStateChanged(this, previousState, reason);, +        return previousState;, +    }, +, +            changeState(IndexShardState.CLOSED, reason);, +            changeState(IndexShardState.POST_RECOVERY, reason);, +            changeState(IndexShardState.POST_RECOVERY, "post recovery");, +++ b/src/main/java/org/elasticsearch/indices/IndicesLifecycle.java, +import org.elasticsearch.index.shard.IndexShardState;, +, +        /**, +         * Called after a shard's {@link org.elasticsearch.index.shard.IndexShardState} changes., +         * The order of concurrent events is preserved. The execution must be lightweight., +         *, +         * @param indexShard the shard the new state was applied to, +         * @param previousState the previous index shard state if there was one, null otherwise, +         * @param currentState the new shard state, +         * @param reason the reason for the state change if there is one, null otherwise, +         */, +        public void indexShardStateChanged(IndexShard indexShard, @Nullable IndexShardState previousState, IndexShardState currentState, @Nullable String reason) {, +]