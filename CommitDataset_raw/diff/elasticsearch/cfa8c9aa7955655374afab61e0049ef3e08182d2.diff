[+++ b/modules/elasticsearch/src/main/java/org/elasticsearch/cluster/metadata/MetaDataCreateIndexService.java, +                    // first, add the default mapping, +                    if (mappings.containsKey(MapperService.DEFAULT_MAPPING)) {, +                        try {, +                            mapperService.add(MapperService.DEFAULT_MAPPING, XContentFactory.jsonBuilder().map(mappings.get(MapperService.DEFAULT_MAPPING)).string());, +                        } catch (Exception e) {, +                            indicesService.deleteIndex(request.index);, +                            throw new MapperParsingException("mapping [" + MapperService.DEFAULT_MAPPING + "]", e);, +                        }, +                    }, +                        if (entry.getKey().equals(MapperService.DEFAULT_MAPPING)) {, +                            continue;, +                        }, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/cluster/metadata/MetaDataCreateIndexService.java, +                    // first, add the default mapping, +                    if (mappings.containsKey(MapperService.DEFAULT_MAPPING)) {, +                        try {, +                            mapperService.add(MapperService.DEFAULT_MAPPING, XContentFactory.jsonBuilder().map(mappings.get(MapperService.DEFAULT_MAPPING)).string());, +                        } catch (Exception e) {, +                            indicesService.deleteIndex(request.index);, +                            throw new MapperParsingException("mapping [" + MapperService.DEFAULT_MAPPING + "]", e);, +                        }, +                    }, +                        if (entry.getKey().equals(MapperService.DEFAULT_MAPPING)) {, +                            continue;, +                        }, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/index/mapper/MapperService.java, +     * Will create types automatically if they do not exists in the mapping definition yet, +            DocumentMapper mapper = documentParser.parse(type, mappingSource);, +            // still add it as a document mapper so we have it registered and, for example, persisted back into, +            // the cluster meta data if needed, or checked for existence, +            synchronized (mutex) {, +                mappers = newMapBuilder(mappers).put(type, mapper).immutableMap();, +            }, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/cluster/metadata/MetaDataCreateIndexService.java, +                    // first, add the default mapping, +                    if (mappings.containsKey(MapperService.DEFAULT_MAPPING)) {, +                        try {, +                            mapperService.add(MapperService.DEFAULT_MAPPING, XContentFactory.jsonBuilder().map(mappings.get(MapperService.DEFAULT_MAPPING)).string());, +                        } catch (Exception e) {, +                            indicesService.deleteIndex(request.index);, +                            throw new MapperParsingException("mapping [" + MapperService.DEFAULT_MAPPING + "]", e);, +                        }, +                    }, +                        if (entry.getKey().equals(MapperService.DEFAULT_MAPPING)) {, +                            continue;, +                        }, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/index/mapper/MapperService.java, +     * Will create types automatically if they do not exists in the mapping definition yet, +            DocumentMapper mapper = documentParser.parse(type, mappingSource);, +            // still add it as a document mapper so we have it registered and, for example, persisted back into, +            // the cluster meta data if needed, or checked for existence, +            synchronized (mutex) {, +                mappers = newMapBuilder(mappers).put(type, mapper).immutableMap();, +            }, +++ b/modules/elasticsearch/src/main/java/org/elasticsearch/indices/cluster/IndicesClusterStateService.java, +            // first, go over and update the _default_ mapping (if exists), +            if (indexMetaData.mappings().containsKey(MapperService.DEFAULT_MAPPING)) {, +                processMapping(event, index, mapperService, MapperService.DEFAULT_MAPPING, indexMetaData.mapping(MapperService.DEFAULT_MAPPING).source());, +            }, +, +                if (mappingType.equals(MapperService.DEFAULT_MAPPING)) { // we processed _default_ first, +                    continue;, +                }, +                processMapping(event, index, mapperService, mappingType, mappingSource);, +            }, +            // go over and remove mappings, +            for (DocumentMapper documentMapper : mapperService) {, +                if (seenMappings.containsKey(new Tuple<String, String>(index, documentMapper.type())) && !indexMetaData.mappings().containsKey(documentMapper.type())) {, +                    // we have it in our mappings, but not in the metadata, and we have seen it in the cluster state, remove it, +                    mapperService.remove(documentMapper.type());, +                    seenMappings.remove(new Tuple<String, String>(index, documentMapper.type()));, +                }, +            }, +        }, +    }, +, +    private void processMapping(ClusterChangedEvent event, String index, MapperService mapperService, String mappingType, CompressedString mappingSource) {]