[+++ /dev/null, +++ /dev/null, +++ b/server/src/test/java/org/elasticsearch/index/seqno/RetentionLeaseIT.java, +/*, + * Licensed to Elasticsearch under one or more contributor, + * license agreements. See the NOTICE file distributed with, + * this work for additional information regarding copyright, + * ownership. Elasticsearch licenses this file to you under, + * the Apache License, Version 2.0 (the "License"); you may, + * not use this file except in compliance with the License., + * You may obtain a copy of the License at, + *, + *    http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing,, + * software distributed under the License is distributed on an, + * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY, + * KIND, either express or implied.  See the License for the, + * specific language governing permissions and limitations, + * under the License., + */, +, +package org.elasticsearch.index.seqno;, +, +import org.elasticsearch.action.ActionListener;, +import org.elasticsearch.action.support.master.AcknowledgedResponse;, +import org.elasticsearch.action.support.replication.ReplicationResponse;, +import org.elasticsearch.cluster.routing.ShardRouting;, +import org.elasticsearch.common.settings.Setting;, +import org.elasticsearch.common.settings.Settings;, +import org.elasticsearch.common.unit.TimeValue;, +import org.elasticsearch.index.IndexService;, +import org.elasticsearch.index.IndexSettings;, +import org.elasticsearch.index.engine.Engine;, +import org.elasticsearch.index.shard.IndexShard;, +import org.elasticsearch.index.shard.ShardId;, +import org.elasticsearch.indices.IndicesService;, +import org.elasticsearch.plugins.Plugin;, +import org.elasticsearch.test.ESIntegTestCase;, +import org.elasticsearch.threadpool.ThreadPool;, +, +import java.io.Closeable;, +import java.util.ArrayList;, +import java.util.Collection;, +import java.util.Collections;, +import java.util.HashMap;, +import java.util.List;, +import java.util.Map;, +import java.util.concurrent.CountDownLatch;, +import java.util.concurrent.TimeUnit;, +import java.util.stream.Collectors;, +import java.util.stream.Stream;, +, +import static org.elasticsearch.test.hamcrest.ElasticsearchAssertions.assertAcked;, +import static org.hamcrest.Matchers.anyOf;, +import static org.hamcrest.Matchers.contains;, +import static org.hamcrest.Matchers.empty;, +import static org.hamcrest.Matchers.equalTo;, +, +@ESIntegTestCase.ClusterScope(scope = ESIntegTestCase.Scope.TEST), +public class RetentionLeaseIT extends ESIntegTestCase  {, +, +    public static final class RetentionLeaseSyncIntervalSettingPlugin extends Plugin {, +, +        @Override, +        public List<Setting<?>> getSettings() {, +            return Collections.singletonList(IndexService.RETENTION_LEASE_SYNC_INTERVAL_SETTING);, +        }, +, +    }, +, +    @Override, +    protected Collection<Class<? extends Plugin>> nodePlugins() {, +        return Stream.concat(, +                super.nodePlugins().stream(),, +                Stream.of(RetentionLeaseSyncIntervalSettingPlugin.class)), +                .collect(Collectors.toList());, +    }, +, +    public void testRetentionLeasesSyncedOnAdd() throws Exception {, +        final int numberOfReplicas = 2 - scaledRandomIntBetween(0, 2);, +        internalCluster().ensureAtLeastNumDataNodes(1 + numberOfReplicas);, +        final Settings settings = Settings.builder(), +                        .put("index.number_of_shards", 1), +                        .put("index.number_of_replicas", numberOfReplicas), +                        .build();, +        createIndex("index", settings);, +        ensureGreen("index");, +        final String primaryShardNodeId = clusterService().state().routingTable().index("index").shard(0).primaryShard().currentNodeId();, +        final String primaryShardNodeName = clusterService().state().nodes().get(primaryShardNodeId).getName();, +        final IndexShard primary = internalCluster(), +                .getInstance(IndicesService.class, primaryShardNodeName), +                .getShardOrNull(new ShardId(resolveIndex("index"), 0));, +        // we will add multiple retention leases and expect to see them synced to all replicas, +        final int length = randomIntBetween(1, 8);, +        final Map<String, RetentionLease> currentRetentionLeases = new HashMap<>();, +        for (int i = 0; i < length; i++) {, +            final String id = randomValueOtherThanMany(currentRetentionLeases.keySet()::contains, () -> randomAlphaOfLength(8));, +            final long retainingSequenceNumber = randomLongBetween(0, Long.MAX_VALUE);, +            final String source = randomAlphaOfLength(8);]