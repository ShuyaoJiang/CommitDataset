[+++ b/buildSrc/version.properties, +lucene            = 7.4.0-snapshot-0a7c3f462f, +++ b/buildSrc/version.properties, +lucene            = 7.4.0-snapshot-0a7c3f462f, +++ b/docs/reference/migration/migrate_7_0/search.asciidoc, +*   Attempts to generate multi-term phrase queries against non-text fields, +    with a custom analyzer will now throw an exception, +, +++ b/buildSrc/version.properties, +lucene            = 7.4.0-snapshot-0a7c3f462f, +++ b/docs/reference/migration/migrate_7_0/search.asciidoc, +*   Attempts to generate multi-term phrase queries against non-text fields, +    with a custom analyzer will now throw an exception, +, +++ b/docs/reference/query-dsl/span-multi-term-query.asciidoc, +, +WARNING: By default `span_multi queries are rewritten to a `span_or` query, +containing **all** the expanded terms. This can be expensive if the number of expanded, +terms is large. To avoid an unbounded expansion you can set the, +<<query-dsl-multi-term-rewrite,rewrite method>> of the multi term query to `top_terms_*`, +rewrite. Or, if you use `span_multi` on `prefix` query only, you can, +activate the <<index-prefix-config,`index_prefixes`>> field option of the `text` field instead. This will, +rewrite any prefix query on the field to a a single term query that matches the indexed prefix., +++ b/buildSrc/version.properties, +lucene            = 7.4.0-snapshot-0a7c3f462f, +++ b/docs/reference/migration/migrate_7_0/search.asciidoc, +*   Attempts to generate multi-term phrase queries against non-text fields, +    with a custom analyzer will now throw an exception, +, +++ b/docs/reference/query-dsl/span-multi-term-query.asciidoc, +, +WARNING: By default `span_multi queries are rewritten to a `span_or` query, +containing **all** the expanded terms. This can be expensive if the number of expanded, +terms is large. To avoid an unbounded expansion you can set the, +<<query-dsl-multi-term-rewrite,rewrite method>> of the multi term query to `top_terms_*`, +rewrite. Or, if you use `span_multi` on `prefix` query only, you can, +activate the <<index-prefix-config,`index_prefixes`>> field option of the `text` field instead. This will, +rewrite any prefix query on the field to a a single term query that matches the indexed prefix., +++ b/libs/x-content/src/main/java/org/elasticsearch/common/xcontent/ObjectParser.java, +                fieldParser = getParser(currentFieldName, parser);, +    private FieldParser getParser(String fieldName, XContentParser xContentParser) {, +            throw new XContentParseException(xContentParser.getTokenLocation(),, +                    "[" + name + "] unknown field [" + fieldName + "], parser not found");, +++ b/buildSrc/version.properties, +lucene            = 7.4.0-snapshot-0a7c3f462f, +++ b/docs/reference/migration/migrate_7_0/search.asciidoc, +*   Attempts to generate multi-term phrase queries against non-text fields, +    with a custom analyzer will now throw an exception, +, +++ b/docs/reference/query-dsl/span-multi-term-query.asciidoc, +, +WARNING: By default `span_multi queries are rewritten to a `span_or` query, +containing **all** the expanded terms. This can be expensive if the number of expanded, +terms is large. To avoid an unbounded expansion you can set the, +<<query-dsl-multi-term-rewrite,rewrite method>> of the multi term query to `top_terms_*`, +rewrite. Or, if you use `span_multi` on `prefix` query only, you can, +activate the <<index-prefix-config,`index_prefixes`>> field option of the `text` field instead. This will, +rewrite any prefix query on the field to a a single term query that matches the indexed prefix., +++ b/libs/x-content/src/main/java/org/elasticsearch/common/xcontent/ObjectParser.java, +                fieldParser = getParser(currentFieldName, parser);, +    private FieldParser getParser(String fieldName, XContentParser xContentParser) {, +            throw new XContentParseException(xContentParser.getTokenLocation(),, +                    "[" + name + "] unknown field [" + fieldName + "], parser not found");, +++ b/libs/x-content/src/test/java/org/elasticsearch/common/xcontent/ObjectParserTests.java, +        {, +            XContentParser parser = createParser(JsonXContent.jsonXContent, "{\"test\" : \"foo\"}");, +            XContentParseException ex = expectThrows(XContentParseException.class, () -> objectParser.parse(parser, s, null));, +        {, +            XContentParser parser = createParser(JsonXContent.jsonXContent, "{\"not_supported_field\" : \"foo\"}");, +            XContentParseException ex = expectThrows(XContentParseException.class, () -> objectParser.parse(parser, s, null));, +            assertEquals(ex.getMessage(), "[1:2] [the_parser] unknown field [not_supported_field], parser not found");, +++ b/buildSrc/version.properties, +lucene            = 7.4.0-snapshot-0a7c3f462f, +++ b/docs/reference/migration/migrate_7_0/search.asciidoc, +*   Attempts to generate multi-term phrase queries against non-text fields, +    with a custom analyzer will now throw an exception, +, +++ b/docs/reference/query-dsl/span-multi-term-query.asciidoc, +, +WARNING: By default `span_multi queries are rewritten to a `span_or` query, +containing **all** the expanded terms. This can be expensive if the number of expanded, +terms is large. To avoid an unbounded expansion you can set the, +<<query-dsl-multi-term-rewrite,rewrite method>> of the multi term query to `top_terms_*`, +rewrite. Or, if you use `span_multi` on `prefix` query only, you can, +activate the <<index-prefix-config,`index_prefixes`>> field option of the `text` field instead. This will, +rewrite any prefix query on the field to a a single term query that matches the indexed prefix., +++ b/libs/x-content/src/main/java/org/elasticsearch/common/xcontent/ObjectParser.java, +                fieldParser = getParser(currentFieldName, parser);, +    private FieldParser getParser(String fieldName, XContentParser xContentParser) {, +            throw new XContentParseException(xContentParser.getTokenLocation(),, +                    "[" + name + "] unknown field [" + fieldName + "], parser not found");, +++ b/libs/x-content/src/test/java/org/elasticsearch/common/xcontent/ObjectParserTests.java, +        {, +            XContentParser parser = createParser(JsonXContent.jsonXContent, "{\"test\" : \"foo\"}");, +            XContentParseException ex = expectThrows(XContentParseException.class, () -> objectParser.parse(parser, s, null));, +        {, +            XContentParser parser = createParser(JsonXContent.jsonXContent, "{\"not_supported_field\" : \"foo\"}");, +            XContentParseException ex = expectThrows(XContentParseException.class, () -> objectParser.parse(parser, s, null));, +            assertEquals(ex.getMessage(), "[1:2] [the_parser] unknown field [not_supported_field], parser not found");, +++ b/modules/lang-expression/licenses/lucene-expressions-7.4.0-snapshot-0a7c3f462f.jar.sha1]