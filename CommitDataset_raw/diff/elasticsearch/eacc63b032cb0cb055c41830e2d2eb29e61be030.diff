[+++ b/server/src/main/java/org/elasticsearch/cluster/coordination/Coordinator.java, +import org.elasticsearch.common.xcontent.XContentHelper;, +import org.elasticsearch.common.xcontent.json.JsonXContent;, +                assert assertPreviousStateConsistency(clusterChangedEvent);, +    // there is no equals on cluster state, so we just serialize it to XContent and compare Maps, +    // deserialized from the resulting JSON, +    private boolean assertPreviousStateConsistency(ClusterChangedEvent event) {, +        assert event.previousState() == coordinationState.get().getLastAcceptedState() ||, +            XContentHelper.convertToMap(, +                JsonXContent.jsonXContent, Strings.toString(event.previousState()), false, +            ).equals(, +                XContentHelper.convertToMap(, +                    JsonXContent.jsonXContent,, +                    Strings.toString(clusterStateWithNoMasterBlock(coordinationState.get().getLastAcceptedState())),, +                    false)), +            : Strings.toString(event.previousState()) + " vs ", +            + Strings.toString(clusterStateWithNoMasterBlock(coordinationState.get().getLastAcceptedState()));, +        return true;, +    }, +, +++ b/server/src/main/java/org/elasticsearch/cluster/coordination/Coordinator.java, +import org.elasticsearch.common.xcontent.XContentHelper;, +import org.elasticsearch.common.xcontent.json.JsonXContent;, +                assert assertPreviousStateConsistency(clusterChangedEvent);, +    // there is no equals on cluster state, so we just serialize it to XContent and compare Maps, +    // deserialized from the resulting JSON, +    private boolean assertPreviousStateConsistency(ClusterChangedEvent event) {, +        assert event.previousState() == coordinationState.get().getLastAcceptedState() ||, +            XContentHelper.convertToMap(, +                JsonXContent.jsonXContent, Strings.toString(event.previousState()), false, +            ).equals(, +                XContentHelper.convertToMap(, +                    JsonXContent.jsonXContent,, +                    Strings.toString(clusterStateWithNoMasterBlock(coordinationState.get().getLastAcceptedState())),, +                    false)), +            : Strings.toString(event.previousState()) + " vs ", +            + Strings.toString(clusterStateWithNoMasterBlock(coordinationState.get().getLastAcceptedState()));, +        return true;, +    }, +, +++ b/server/src/main/java/org/elasticsearch/cluster/service/ClusterApplierService.java, +        Collections.newSetFromMap(new ConcurrentHashMap<>());, +        threadPoolExecutor = createThreadPoolExecutor();, +    }, +, +    protected PrioritizedEsThreadPoolExecutor createThreadPoolExecutor() {, +        return EsExecutors.newSinglePrioritizing(, +++ b/server/src/main/java/org/elasticsearch/cluster/coordination/Coordinator.java, +import org.elasticsearch.common.xcontent.XContentHelper;, +import org.elasticsearch.common.xcontent.json.JsonXContent;, +                assert assertPreviousStateConsistency(clusterChangedEvent);, +    // there is no equals on cluster state, so we just serialize it to XContent and compare Maps, +    // deserialized from the resulting JSON, +    private boolean assertPreviousStateConsistency(ClusterChangedEvent event) {, +        assert event.previousState() == coordinationState.get().getLastAcceptedState() ||, +            XContentHelper.convertToMap(, +                JsonXContent.jsonXContent, Strings.toString(event.previousState()), false, +            ).equals(, +                XContentHelper.convertToMap(, +                    JsonXContent.jsonXContent,, +                    Strings.toString(clusterStateWithNoMasterBlock(coordinationState.get().getLastAcceptedState())),, +                    false)), +            : Strings.toString(event.previousState()) + " vs ", +            + Strings.toString(clusterStateWithNoMasterBlock(coordinationState.get().getLastAcceptedState()));, +        return true;, +    }, +, +++ b/server/src/main/java/org/elasticsearch/cluster/service/ClusterApplierService.java, +        Collections.newSetFromMap(new ConcurrentHashMap<>());, +        threadPoolExecutor = createThreadPoolExecutor();, +    }, +, +    protected PrioritizedEsThreadPoolExecutor createThreadPoolExecutor() {, +        return EsExecutors.newSinglePrioritizing(, +++ b/server/src/main/java/org/elasticsearch/cluster/service/ClusterService.java, +    public ClusterService(Settings settings, ClusterSettings clusterSettings, ThreadPool threadPool) {, +        this(settings, clusterSettings, new MasterService(Node.NODE_NAME_SETTING.get(settings), settings, threadPool),, +            new ClusterApplierService(Node.NODE_NAME_SETTING.get(settings), settings, clusterSettings, threadPool));, +    }, +, +    public ClusterService(Settings settings, ClusterSettings clusterSettings, MasterService masterService,, +        ClusterApplierService clusterApplierService) {, +        this.clusterApplierService = clusterApplierService;, +++ b/server/src/main/java/org/elasticsearch/cluster/coordination/Coordinator.java, +import org.elasticsearch.common.xcontent.XContentHelper;, +import org.elasticsearch.common.xcontent.json.JsonXContent;, +                assert assertPreviousStateConsistency(clusterChangedEvent);, +    // there is no equals on cluster state, so we just serialize it to XContent and compare Maps, +    // deserialized from the resulting JSON, +    private boolean assertPreviousStateConsistency(ClusterChangedEvent event) {, +        assert event.previousState() == coordinationState.get().getLastAcceptedState() ||, +            XContentHelper.convertToMap(, +                JsonXContent.jsonXContent, Strings.toString(event.previousState()), false, +            ).equals(, +                XContentHelper.convertToMap(, +                    JsonXContent.jsonXContent,, +                    Strings.toString(clusterStateWithNoMasterBlock(coordinationState.get().getLastAcceptedState())),, +                    false)), +            : Strings.toString(event.previousState()) + " vs ", +            + Strings.toString(clusterStateWithNoMasterBlock(coordinationState.get().getLastAcceptedState()));]