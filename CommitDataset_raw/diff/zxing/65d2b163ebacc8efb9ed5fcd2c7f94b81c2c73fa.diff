[+++ b/zxingorg/src/main/java/com/google/zxing/web/DecodeServlet.java, +      response.setStatus(HttpServletResponse.SC_BAD_REQUEST);, +++ b/zxingorg/src/main/java/com/google/zxing/web/DecodeServlet.java, +      response.setStatus(HttpServletResponse.SC_BAD_REQUEST);, +++ b/zxingorg/src/main/java/com/google/zxing/web/DoSFilter.java, +import java.util.Iterator;, +import java.util.concurrent.atomic.AtomicLong;, +  private static final int MAX_ACCESSES_PER_IP_PER_TIME = 50;, +  private static final long MAX_ACCESSES_TIME_MS = TimeUnit.MILLISECONDS.convert(5, TimeUnit.MINUTES);, +  private static final int MAX_RECENT_ACCESS_MAP_SIZE = 10_000;, +  private final Map<String,AtomicLong> numRecentAccesses;, +    numRecentAccesses = new LinkedHashMap<String,AtomicLong>() {, +      protected boolean removeEldestEntry(Map.Entry<String,AtomicLong> eldest) {, +    };, +    timer = new Timer("DoSFilter");, +            synchronized (numRecentAccesses) {, +              // Periodically reduce allowed accesses per IP, +              Iterator<Map.Entry<String,AtomicLong>> accessIt = numRecentAccesses.entrySet().iterator();, +              while (accessIt.hasNext()) {, +                Map.Entry<String,AtomicLong> entry = accessIt.next();, +                AtomicLong count = entry.getValue();, +                // If number of accesses is below the threshold, remove it entirely, +                if (count.get() <= MAX_ACCESSES_PER_IP_PER_TIME) {, +                  accessIt.remove();, +                } else {, +                  // Else it exceeded the max, so log it (again), +                  log.warning("Possible DoS attack from " + entry.getKey() + " (" + count + " outstanding)");, +                  // Reduce count of accesses held against the IP, +                  count.getAndAdd(-MAX_ACCESSES_PER_IP_PER_TIME);, +              log.info("Tracking accesses from " + numRecentAccesses.size() + " IPs");, +            }, +          }, +        }, MAX_ACCESSES_TIME_MS, MAX_ACCESSES_TIME_MS);, +    if (remoteIPAddress == null) {, +    AtomicLong count;, +    synchronized (numRecentAccesses) {, +      count = numRecentAccesses.get(remoteIPAddress);, +        count = new AtomicLong();, +        numRecentAccesses.put(remoteIPAddress, count);, +    return count.incrementAndGet() > MAX_ACCESSES_PER_IP_PER_TIME;, +  }, +++ b/zxingorg/src/main/java/com/google/zxing/web/DecodeServlet.java, +      response.setStatus(HttpServletResponse.SC_BAD_REQUEST);, +++ b/zxingorg/src/main/java/com/google/zxing/web/DoSFilter.java, +import java.util.Iterator;, +import java.util.concurrent.atomic.AtomicLong;, +  private static final int MAX_ACCESSES_PER_IP_PER_TIME = 50;, +  private static final long MAX_ACCESSES_TIME_MS = TimeUnit.MILLISECONDS.convert(5, TimeUnit.MINUTES);, +  private static final int MAX_RECENT_ACCESS_MAP_SIZE = 10_000;, +  private final Map<String,AtomicLong> numRecentAccesses;, +    numRecentAccesses = new LinkedHashMap<String,AtomicLong>() {, +      protected boolean removeEldestEntry(Map.Entry<String,AtomicLong> eldest) {, +    };, +    timer = new Timer("DoSFilter");, +            synchronized (numRecentAccesses) {, +              // Periodically reduce allowed accesses per IP, +              Iterator<Map.Entry<String,AtomicLong>> accessIt = numRecentAccesses.entrySet().iterator();, +              while (accessIt.hasNext()) {, +                Map.Entry<String,AtomicLong> entry = accessIt.next();, +                AtomicLong count = entry.getValue();, +                // If number of accesses is below the threshold, remove it entirely, +                if (count.get() <= MAX_ACCESSES_PER_IP_PER_TIME) {, +                  accessIt.remove();, +                } else {, +                  // Else it exceeded the max, so log it (again), +                  log.warning("Possible DoS attack from " + entry.getKey() + " (" + count + " outstanding)");, +                  // Reduce count of accesses held against the IP, +                  count.getAndAdd(-MAX_ACCESSES_PER_IP_PER_TIME);, +              log.info("Tracking accesses from " + numRecentAccesses.size() + " IPs");, +            }, +          }, +        }, MAX_ACCESSES_TIME_MS, MAX_ACCESSES_TIME_MS);, +    if (remoteIPAddress == null) {, +    AtomicLong count;, +    synchronized (numRecentAccesses) {, +      count = numRecentAccesses.get(remoteIPAddress);, +        count = new AtomicLong();, +        numRecentAccesses.put(remoteIPAddress, count);, +    return count.incrementAndGet() > MAX_ACCESSES_PER_IP_PER_TIME;, +  }, +++ b/zxingorg/src/main/webapp/.ebextensions/server.xml, +               prefix="localhost_access_log" suffix=".txt"]