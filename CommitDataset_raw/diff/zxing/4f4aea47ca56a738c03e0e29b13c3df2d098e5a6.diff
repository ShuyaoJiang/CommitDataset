[+++ b/cpp/core/src/zxing/qrcode/decoder/DecodedBitStreamParser.cpp, +  const bool ASSUME_SHIFT_JIS = false;, +  char const* const PLATFORM_DEFAULT_ENCODING="UTF-8";, +, +  bool canBeShiftJIS = true;, +  bool canBeUTF8 = true;, +  int utf8BytesLeft = 0;, +  int maybeDoubleByteCount = 0;, +  int maybeSingleByteKatakanaCount = 0;, +  bool sawLatin1Supplement = false;, +  bool sawUTF8Start = false;, +  for (int i = 0;, +       i < length && (canBeISO88591 || canBeShiftJIS || canBeUTF8);, +       i++) {, +, +    // UTF-8 stuff, +    if (value >= 0x80 && value <= 0xBF) {, +      if (utf8BytesLeft > 0) {, +        utf8BytesLeft--;, +      }, +    } else {, +      if (utf8BytesLeft > 0) {, +        canBeUTF8 = false;, +      }, +      if (value >= 0xC0 && value <= 0xFD) {, +        sawUTF8Start = true;, +        int valueCopy = value;, +        while ((valueCopy & 0x40) != 0) {, +          utf8BytesLeft++;, +          valueCopy <<= 1;, +        }, +      }, +    }, +, +    // Shift_JIS stuff, +, +    if (value >= 0xA1 && value <= 0xDF) {, +      // count the number of characters that might be a Shift_JIS single-byte Katakana character, +      if (!lastWasPossibleDoubleByteStart) {, +        maybeSingleByteKatakanaCount++;, +      }, +    }, +    if (!lastWasPossibleDoubleByteStart &&, +        ((value >= 0xF0 && value <= 0xFF) || value == 0x80 || value == 0xA0)) {, +      canBeShiftJIS = false;, +    }, +    if (((value >= 0x81 && value <= 0x9F) || (value >= 0xE0 && value <= 0xEF))) {, +      // These start double-byte characters in Shift_JIS. Let's see if it's followed by a valid, +      // second byte., +        // char, don't check starting on this byte. If this and the last byte, +        if (i >= length - 1) {, +          canBeShiftJIS = false;, +        } else {, +          if (nextValue < 0x40 || nextValue > 0xFC) {, +            canBeShiftJIS = false;, +          } else {, +            maybeDoubleByteCount++;, +          }, +          // There is some conflicting information out there about which bytes can follow which in, +          // double-byte Shift_JIS characters. The rule above seems to be the one that matches practice., +        }, +      lastWasPossibleDoubleByteStart = false;, +    }, +  }, +  if (utf8BytesLeft > 0) {, +    canBeUTF8 = false;, +  }, +, +  // Easy -- if assuming Shift_JIS and no evidence it can't be, done, +  if (canBeShiftJIS && ASSUME_SHIFT_JIS) {, +    return SHIFT_JIS;, +  }, +  if (canBeUTF8 && sawUTF8Start) {, +  // Distinguishing Shift_JIS and ISO-8859-1 can be a little tough. The crude heuristic is:, +  // - If we saw, +  //   - at least 3 bytes that starts a double-byte value (bytes that are rare in ISO-8859-1), or, +  //   - over 5% of bytes could be single-byte Katakana (also rare in ISO-8859-1),, +  // - and, saw no sequences that are invalid in Shift_JIS, then we conclude Shift_JIS, +  if (canBeShiftJIS && (maybeDoubleByteCount >= 3 || 20 * maybeSingleByteKatakanaCount > length)) {, +    return SHIFT_JIS;, +  // Otherwise, we default to ISO-8859-1 unless we know it can't be, +  if (!sawLatin1Supplement && canBeISO88591) {, +    return ISO88591;, +  // Otherwise, we take a wild guess with platform encoding, +  return PLATFORM_DEFAULT_ENCODING;]