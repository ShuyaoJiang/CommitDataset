[+++ b/NOTICE, +, +--------------------------------------------------------------------------------, +NOTICES FOR JCOMMANDER, +--------------------------------------------------------------------------------, +, +Copyright 2010 Cedric Beust cedric@beust.com, +++ b/NOTICE, +, +--------------------------------------------------------------------------------, +NOTICES FOR JCOMMANDER, +--------------------------------------------------------------------------------, +, +Copyright 2010 Cedric Beust cedric@beust.com, +++ b/javase/pom.xml, +    <dependency>, +      <groupId>com.beust</groupId>, +      <artifactId>jcommander</artifactId>, +      <version>1.48</version>, +    </dependency>, +++ b/NOTICE, +, +--------------------------------------------------------------------------------, +NOTICES FOR JCOMMANDER, +--------------------------------------------------------------------------------, +, +Copyright 2010 Cedric Beust cedric@beust.com, +++ b/javase/pom.xml, +    <dependency>, +      <groupId>com.beust</groupId>, +      <artifactId>jcommander</artifactId>, +      <version>1.48</version>, +    </dependency>, +++ b/javase/src/main/java/com/google/zxing/client/j2se/CommandLineRunner.java, +import com.beust.jcommander.JCommander;, +import java.net.URISyntaxException;, +import java.util.List;, +    DecoderConfig config = new DecoderConfig();, +    JCommander jCommander = new JCommander(config, args);, +    jCommander.setProgramName(CommandLineRunner.class.getSimpleName());, +    if (config.help) {, +      jCommander.usage();, +    List<URI> inputs = config.inputPaths;, +    do {, +      inputs = retainValid(expand(inputs), config.recursive);, +    } while (config.recursive && isExpandable(inputs));, +      jCommander.usage();, +    Queue<URI> syncInputs = new ConcurrentLinkedQueue<>(inputs);, +        futures.add(executor.submit(new DecodeWorker(config, syncInputs)));, +      successful += new DecodeWorker(config, syncInputs).call();, +    if (!config.brief && numInputs > 1) {, +  private static List<URI> expand(List<URI> inputs) throws IOException, URISyntaxException {, +    List<URI> expanded = new ArrayList<>();, +    for (URI input : inputs) {, +      if (isFileOrDir(input)) {, +        Path inputPath = Paths.get(input);, +        if (Files.isDirectory(inputPath)) {, +          try (DirectoryStream<Path> childPaths = Files.newDirectoryStream(inputPath)) {, +              expanded.add(childPath.toUri());, +          expanded.add(input);, +      } else {, +        expanded.add(input);, +      }, +    }, +    for (int i = 0; i < expanded.size(); i++) {, +      URI input = expanded.get(i);, +      if (input.getScheme() == null) {, +        expanded.set(i, new URI("file", input.getSchemeSpecificPart(), input.getFragment()));, +      }, +    }, +    return expanded;, +  private static List<URI> retainValid(List<URI> inputs, boolean recursive) {, +    List<URI> retained = new ArrayList<>();, +    for (URI input : inputs) {, +      boolean retain;, +      if (isFileOrDir(input)) {, +        Path inputPath = Paths.get(input);, +        retain =, +            !inputPath.getFileName().toString().startsWith(".") &&, +            (recursive || !Files.isDirectory(inputPath));, +        retain = true;, +      }, +      if (retain) {, +        retained.add(input);, +    return retained;, +  private static boolean isExpandable(List<URI> inputs) {, +    for (URI input : inputs) {, +      if (isFileOrDir(input) && Files.isDirectory(Paths.get(input))) {, +        return true;, +    }, +    return false;, +  }, +, +  private static boolean isFileOrDir(URI uri) {, +    return "file".equals(uri.getScheme());, +++ b/NOTICE, +, +--------------------------------------------------------------------------------, +NOTICES FOR JCOMMANDER, +--------------------------------------------------------------------------------]