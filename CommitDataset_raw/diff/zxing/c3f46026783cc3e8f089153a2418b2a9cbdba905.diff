[+++ b/AUTHORS, +Shiyuan Guo / 郭世元, +++ b/AUTHORS, +Shiyuan Guo / 郭世元, +++ b/core/src/com/google/zxing/common/StringUtils.java, +  public static final String GB2312 = "GB2312";, +++ b/AUTHORS, +Shiyuan Guo / 郭世元, +++ b/core/src/com/google/zxing/common/StringUtils.java, +  public static final String GB2312 = "GB2312";, +++ b/core/src/com/google/zxing/qrcode/decoder/DecodedBitStreamParser.java, +  private static final int GB2312_SUBSET = 1;, +          // First handle Hanzi mode which does not start with character count, +          if (mode.equals(Mode.HANZI)) {, +        		//chinese mode contains a sub set indicator right after mode indicator, +        		int subset = bits.readBits(4);, +        		int countHanzi = bits.readBits(mode.getCharacterCountBits(version));, +        		if (subset == GB2312_SUBSET) {, +        			decodeHanziSegment(bits, result, countHanzi);, +            }, +          } else {, +            // "Normal" QR code modes:, +      }, +  /**, +   * See specification GBT 18284-2000, +   */, +  private static void decodeHanziSegment(BitSource bits,, +                                         StringBuffer result,, +                                         int count) throws FormatException {, +    // Each character will require 2 bytes. Read the characters as 2-byte pairs, +    // and decode as GB2312 afterwards, +    byte[] buffer = new byte[2 * count];, +    int offset = 0;, +    while (count > 0) {, +      // Each 13 bits encodes a 2-byte character, +      int twoBytes = bits.readBits(13);, +      int assembledTwoBytes = ((twoBytes / 0x060) << 8) | (twoBytes % 0x060);, +      if (assembledTwoBytes < 0x003BF) {, +        // In the 0xA1A1 to 0xAAFE range, +        assembledTwoBytes += 0x0A1A1;, +      } else {, +        // In the 0xB0A1 to 0xFAFE range, +        assembledTwoBytes += 0x0A6A1;, +      }, +      buffer[offset] = (byte) ((assembledTwoBytes >> 8) & 0xFF);, +      buffer[offset + 1] = (byte) ((assembledTwoBytes) & 0xFF);, +      offset += 2;, +      count--;, +    }, +    , +    try {, +      result.append(new String(buffer, StringUtils.GB2312));, +    } catch (UnsupportedEncodingException uee) {, +      throw FormatException.getFormatInstance();, +    }, +  }, +, +++ b/AUTHORS, +Shiyuan Guo / 郭世元, +++ b/core/src/com/google/zxing/common/StringUtils.java, +  public static final String GB2312 = "GB2312";, +++ b/core/src/com/google/zxing/qrcode/decoder/DecodedBitStreamParser.java, +  private static final int GB2312_SUBSET = 1;, +          // First handle Hanzi mode which does not start with character count, +          if (mode.equals(Mode.HANZI)) {, +        		//chinese mode contains a sub set indicator right after mode indicator, +        		int subset = bits.readBits(4);, +        		int countHanzi = bits.readBits(mode.getCharacterCountBits(version));, +        		if (subset == GB2312_SUBSET) {, +        			decodeHanziSegment(bits, result, countHanzi);, +            }, +          } else {, +            // "Normal" QR code modes:, +      }, +  /**, +   * See specification GBT 18284-2000, +   */, +  private static void decodeHanziSegment(BitSource bits,, +                                         StringBuffer result,, +                                         int count) throws FormatException {, +    // Each character will require 2 bytes. Read the characters as 2-byte pairs, +    // and decode as GB2312 afterwards, +    byte[] buffer = new byte[2 * count];, +    int offset = 0;, +    while (count > 0) {, +      // Each 13 bits encodes a 2-byte character, +      int twoBytes = bits.readBits(13);, +      int assembledTwoBytes = ((twoBytes / 0x060) << 8) | (twoBytes % 0x060);, +      if (assembledTwoBytes < 0x003BF) {, +        // In the 0xA1A1 to 0xAAFE range, +        assembledTwoBytes += 0x0A1A1;, +      } else {, +        // In the 0xB0A1 to 0xFAFE range, +        assembledTwoBytes += 0x0A6A1;, +      }, +      buffer[offset] = (byte) ((assembledTwoBytes >> 8) & 0xFF);, +      buffer[offset + 1] = (byte) ((assembledTwoBytes) & 0xFF);, +      offset += 2;, +      count--;, +    }]