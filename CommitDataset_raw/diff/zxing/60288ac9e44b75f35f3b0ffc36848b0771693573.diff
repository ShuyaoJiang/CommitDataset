[+++ b/core/src/com/google/zxing/common/HybridBinarizer.java, +  private static final int BLOCK_SIZE = 1 << BLOCK_SIZE_POWER; // ...0100...00, +  private static final int BLOCK_SIZE_MASK = BLOCK_SIZE - 1;   // ...0011...11, +  /**, +   * Calculates the final BitMatrix once for all requests. This could be called once from the, +   * constructor instead, but there are some advantages to doing it lazily, such as making, +   * profiling easier, and not doing heavy lifting when callers don't expect it., +   */, +    if (width >= MINIMUM_DIMENSION && height >= MINIMUM_DIMENSION) {, +      byte[] luminances = source.getMatrix();, +      calculateThresholdForBlock(luminances, subWidth, subHeight, width, height, blackPoints, newMatrix);, +  /**, +   * For each block in the image, calculate the average black point using a 5x5 grid, +   * of the blocks around it. Also handles the corner cases (fractional blocks are computed based, +   * on the last pixels in the row/column which are also used in the previous block)., +   */, +  private static void calculateThresholdForBlock(byte[] luminances,, +                                                 int subWidth,, +                                                 int subHeight,, +                                                 int width,, +                                                 int height,, +                                                 int[][] blackPoints,, +                                                 BitMatrix matrix) {, +      int maxYOffset = height - BLOCK_SIZE;, +      if (yoffset > maxYOffset) {, +        yoffset = maxYOffset;, +        int maxXOffset = width - BLOCK_SIZE;, +        if (xoffset > maxXOffset) {, +          xoffset = maxXOffset;, +        int left = cap(x, 2, subWidth - 3);, +        int top = cap(y, 2, subHeight - 3);, +          sum += blackRow[left - 2] + blackRow[left - 1] + blackRow[left] + blackRow[left + 1] + blackRow[left + 2];, +        thresholdBlock(luminances, xoffset, yoffset, average, width, matrix);, +  private static int cap(int value, int min, int max) {, +    return value < min ? min : value > max ? max : value;, +  }, +, +  /**, +   * Applies a single threshold to a block of pixels., +   */, +  private static void thresholdBlock(byte[] luminances,, +                                     int xoffset,, +                                     int yoffset,, +                                     int threshold,, +                                     int stride,, +                                     BitMatrix matrix) {, +  /**, +   * Calculates a single black point for each block of pixels and saves it away., +   * See the following thread for a discussion of this algorithm:, +   *  http://groups.google.com/group/zxing/browse_thread/thread/d06efa2c35a7ddc0, +   */, +  private static int[][] calculateBlackPoints(byte[] luminances,, +                                              int subWidth,, +                                              int subHeight,, +                                              int width,, +                                              int height) {, +      int maxYOffset = height - BLOCK_SIZE;, +      if (yoffset > maxYOffset) {, +        yoffset = maxYOffset;, +        int maxXOffset = width - BLOCK_SIZE;, +        if (xoffset > maxXOffset) {, +          xoffset = maxXOffset;]