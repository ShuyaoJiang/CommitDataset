[+++ b/core/src/com/google/zxing/common/DefaultGridSampler.java, +    for (int y = 0; y < dimension; y++) {, +      float iValue = (float) y + 0.5f;, +      for (int x = 0; x < max; x += 2) {, +        points[x] = (float) (x >> 1) + 0.5f;, +        points[x + 1] = iValue;, +        for (int x = 0; x < max; x += 2) {, +          if (image.get((int) points[x], (int) points[x + 1])) {, +            bits.set(x >> 1, y);, +++ b/core/src/com/google/zxing/common/DefaultGridSampler.java, +    for (int y = 0; y < dimension; y++) {, +      float iValue = (float) y + 0.5f;, +      for (int x = 0; x < max; x += 2) {, +        points[x] = (float) (x >> 1) + 0.5f;, +        points[x + 1] = iValue;, +        for (int x = 0; x < max; x += 2) {, +          if (image.get((int) points[x], (int) points[x + 1])) {, +            bits.set(x >> 1, y);, +++ b/core/src/com/google/zxing/common/GlobalHistogramBinarizer.java, +    for (int x = 0; x < numBuckets; x++) {, +      if (buckets[x] > firstPeakSize) {, +        firstPeak = x;, +        firstPeakSize = buckets[x];, +      if (buckets[x] > maxBucketCount) {, +        maxBucketCount = buckets[x];, +    for (int x = 0; x < numBuckets; x++) {, +      int distanceToBiggest = x - firstPeak;, +      int score = buckets[x] * distanceToBiggest * distanceToBiggest;, +        secondPeak = x;, +    for (int x = secondPeak - 1; x > firstPeak; x--) {, +      int fromFirst = x - firstPeak;, +      int score = fromFirst * fromFirst * (secondPeak - x) * (maxBucketCount - buckets[x]);, +        bestValley = x;, +++ b/core/src/com/google/zxing/common/DefaultGridSampler.java, +    for (int y = 0; y < dimension; y++) {, +      float iValue = (float) y + 0.5f;, +      for (int x = 0; x < max; x += 2) {, +        points[x] = (float) (x >> 1) + 0.5f;, +        points[x + 1] = iValue;, +        for (int x = 0; x < max; x += 2) {, +          if (image.get((int) points[x], (int) points[x + 1])) {, +            bits.set(x >> 1, y);, +++ b/core/src/com/google/zxing/common/GlobalHistogramBinarizer.java, +    for (int x = 0; x < numBuckets; x++) {, +      if (buckets[x] > firstPeakSize) {, +        firstPeak = x;, +        firstPeakSize = buckets[x];, +      if (buckets[x] > maxBucketCount) {, +        maxBucketCount = buckets[x];, +    for (int x = 0; x < numBuckets; x++) {, +      int distanceToBiggest = x - firstPeak;, +      int score = buckets[x] * distanceToBiggest * distanceToBiggest;, +        secondPeak = x;, +    for (int x = secondPeak - 1; x > firstPeak; x--) {, +      int fromFirst = x - firstPeak;, +      int score = fromFirst * fromFirst * (secondPeak - x) * (maxBucketCount - buckets[x]);, +        bestValley = x;, +++ b/core/src/com/google/zxing/common/detector/MonochromeRectangleDetector.java, +    int deltaY = Math.max(1, height / (MAX_MODULES << 3));, +    int deltaX = Math.max(1, width / (MAX_MODULES << 3));, +    int top = 0;, +    int bottom = height;, +    int left = 0;, +    int right = width;, +    ResultPoint pointA = findCornerFromCenter(halfWidth, 0, left, right,, +        halfHeight, -deltaY, top, bottom, halfWidth >> 1);, +    top = (int) pointA.getY() - 1;, +    ResultPoint pointB = findCornerFromCenter(halfWidth, -deltaX, left, right,, +        halfHeight, 0, top, bottom, halfHeight >> 1);, +    left = (int) pointB.getX() - 1;, +    ResultPoint pointC = findCornerFromCenter(halfWidth, deltaX, left, right,, +        halfHeight, 0, top, bottom, halfHeight >> 1);, +    right = (int) pointC.getX() + 1;, +    ResultPoint pointD = findCornerFromCenter(halfWidth, 0, left, right,, +        halfHeight, deltaY, top, bottom, halfWidth >> 1);, +    bottom = (int) pointD.getY() + 1;, +, +    pointA = findCornerFromCenter(halfWidth, 0, left, right,, +        halfHeight, -deltaY, top, bottom, halfWidth >> 2);, +   * @param centerX center's x component (horizontal), +   * @param deltaX same as deltaY but change in x per step instead, +   * @param left minimum value of x, +   * @param right maximum value of x, +   * @param centerY center's y component (vertical), +   * @param deltaY change in y per step. If scanning up this is negative; down, positive;, +   * @param top minimum value of y to search through (meaningless when di == 0), +   * @param bottom maximum value of y, +  private ResultPoint findCornerFromCenter(int centerX, int deltaX, int left, int right,, +      int centerY, int deltaY, int top, int bottom, int maxWhiteRun) throws ReaderException {, +    for (int y = centerY, x = centerX;, +         y < bottom && y >= top && x < right && x >= left;, +         y += deltaY, x += deltaX) {, +      if (deltaX == 0) {, +        range = blackWhiteRange(y, maxWhiteRun, left, right, true);, +        range = blackWhiteRange(x, maxWhiteRun, top, bottom, false);, +        if (deltaX == 0) {, +          int lastY = y - deltaY;, +          if (lastRange[0] < centerX) {, +            if (lastRange[1] > centerX) {, +              return new ResultPoint(deltaY > 0 ? lastRange[0] : lastRange[1], lastY);]