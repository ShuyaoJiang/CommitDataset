[+++ b/core/src/com/google/zxing/datamatrix/DataMatrixReader.java, +import com.google.zxing.DecodeHintType;, +import com.google.zxing.common.DetectorResult;, +import com.google.zxing.datamatrix.detector.Detector;, +    if (hints != null && hints.containsKey(DecodeHintType.PURE_BARCODE)) {, +    } else {, +      DetectorResult result = new Detector(image).detect();, +      decoderResult = decoder.decode(result.getBits());, +      points = result.getPoints();, +    }, +++ b/core/src/com/google/zxing/datamatrix/DataMatrixReader.java, +import com.google.zxing.DecodeHintType;, +import com.google.zxing.common.DetectorResult;, +import com.google.zxing.datamatrix.detector.Detector;, +    if (hints != null && hints.containsKey(DecodeHintType.PURE_BARCODE)) {, +    } else {, +      DetectorResult result = new Detector(image).detect();, +      decoderResult = decoder.decode(result.getBits());, +      points = result.getPoints();, +    }, +++ b/core/src/com/google/zxing/datamatrix/detector/Detector.java, + * Copyright 2008 ZXing authors, +import com.google.zxing.ResultPoint;, +import com.google.zxing.BlackPointEstimationMethod;, +import com.google.zxing.common.BitMatrix;, +import com.google.zxing.common.Collections;, +import com.google.zxing.common.Comparator;, +import com.google.zxing.common.GenericResultPoint;, +import com.google.zxing.common.GridSampler;, +, +import java.util.Enumeration;, +import java.util.Hashtable;, +import java.util.Vector;, + * @author srowen@google.com (Sean Owen), +  private static final int MAX_MODULES = 32;, +, +  // Trick to avoid creating new Integer objects below -- a sort of crude copy of, +  // the Integer.valueOf(int) optimization added in Java 5, not in J2ME, +  private static final Integer[] INTEGERS =, +      { new Integer(0), new Integer(1), new Integer(2), new Integer(3), new Integer(4) };, +, +   * <p>Detects a Data Matrix Code in an image.</p>, +  public DetectorResult detect() throws ReaderException {, +, +    if (!BlackPointEstimationMethod.TWO_D_SAMPLING.equals(image.getLastEstimationMethod())) {, +      image.estimateBlackPoint(BlackPointEstimationMethod.TWO_D_SAMPLING, 0);, +    int height = image.getHeight();, +    int width = image.getWidth();, +    int halfHeight = height >> 1;, +    int halfWidth = width >> 1;, +    int iSkip = Math.max(1, height / (MAX_MODULES << 2));, +    int jSkip = Math.max(1, width / (MAX_MODULES << 2));, +, +    int minI = 0;, +    int maxI = height;, +    int minJ = 0;, +    int maxJ = width;, +    ResultPoint pointA = findCornerFromCenter(halfHeight, -iSkip, minI, maxI, halfWidth,      0, minJ, maxJ, halfWidth >> 2);, +    minI = (int) pointA.getY() - 1;, +    ResultPoint pointB = findCornerFromCenter(halfHeight, 0,      minI, maxI, halfWidth, -jSkip, minJ, maxJ, halfHeight >> 2);, +    minJ = (int) pointB.getX() - 1;, +    ResultPoint pointC = findCornerFromCenter(halfHeight, 0,      minI, maxI, halfWidth,  jSkip, minJ, maxJ, halfHeight >> 2);, +    maxJ = (int) pointC.getX() + 1;, +    ResultPoint pointD = findCornerFromCenter(halfHeight,  iSkip, minI, maxI, halfWidth,      0, minJ, maxJ, halfWidth >> 2);, +    maxI = (int) pointD.getY() + 1;, +    // Go try to find point A again with better information -- might have been off at first., +    pointA = findCornerFromCenter(halfHeight, -iSkip, minI, maxI, halfWidth,      0, minJ, maxJ, halfWidth >> 2);, +, +    // Point A and D are across the diagonal from one another,, +    // as are B and C. Figure out which are the solid black lines, +    // by counting transitions, +    Vector transitions = new Vector(4);, +    transitions.addElement(transitionsBetween(pointA, pointB));, +    transitions.addElement(transitionsBetween(pointA, pointC));, +    transitions.addElement(transitionsBetween(pointB, pointD));, +    transitions.addElement(transitionsBetween(pointC, pointD));, +    Collections.insertionSort(transitions, new ResultPointsAndTransitionsComparator());, +, +    // Sort by number of transitions. First two will be the two solid sides; last two, +    // will be the two alternating black/white sides, +    ResultPointsAndTransitions lSideOne = (ResultPointsAndTransitions) transitions.elementAt(0);, +    ResultPointsAndTransitions lSideTwo = (ResultPointsAndTransitions) transitions.elementAt(1);, +, +    // Figure out which point is their intersection by tallying up the number of times we see the, +    // endpoints in the four endpoints. One will show up twice., +    Hashtable pointCount = new Hashtable();, +    increment(pointCount, lSideOne.getFrom());, +    increment(pointCount, lSideOne.getTo());, +    increment(pointCount, lSideTwo.getFrom());, +    increment(pointCount, lSideTwo.getTo());, +, +    ResultPoint maybeTopLeft = null;, +    ResultPoint bottomLeft = null;, +    ResultPoint maybeBottomRight = null;, +    Enumeration points = pointCount.keys();, +    while (points.hasMoreElements()) {, +      ResultPoint point = (ResultPoint) points.nextElement();, +      Integer value = (Integer) pointCount.get(point);, +      if (value.intValue() == 2) {, +        bottomLeft = point; // this is definitely the bottom left, then -- end of two L sides]