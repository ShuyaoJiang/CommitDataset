[+++ b/core/src/com/google/zxing/common/HybridBinarizer.java, +      calculateThresholdForBlock(luminances, subWidth, subHeight, width, height, blackPoints,, +          newMatrix);, +  private static void calculateThresholdForBlock(byte[] luminances, int subWidth, int subHeight,, +      int width, int height, int[][] blackPoints, BitMatrix matrix) {, +          sum += blackRow[left - 2] + blackRow[left - 1] + blackRow[left] + blackRow[left + 1] +, +              blackRow[left + 2];, +  private static void threshold8x8Block(byte[] luminances, int xoffset, int yoffset, int threshold,, +      int stride, BitMatrix matrix) {, +        // Comparison needs to be <= so that black == 0 pixels are black even if the threshold is 0., +  // See the following thread for a discussion of this algorithm:, +  // http://groups.google.com/group/zxing/browse_thread/thread/d06efa2c35a7ddc0, +  private static int[][] calculateBlackPoints(byte[] luminances, int subWidth, int subHeight,, +      int width, int height) {, +        // The default estimate is the average of the values in the block., +          // If variation within the block is low, assume this is a block with only light or only, +          // dark pixels. In that case we do not want to use the average, as it would divide this, +          // low contrast area into black and white pixels, essentially creating data out of noise., +          //, +          // The default assumption is that the block is light/background. Since no estimate for, +          // the level of dark pixels exists locally, use half the min for the block., +            // Correct the "white background" assumption for blocks that have neighbors by comparing, +            // the pixels in this block to the previously calculated black points. This is based on, +            // the fact that dark barcode symbology is always surrounded by some amount of light, +            // background for which reasonable black point estimates were made. The bp estimated at, +            // the boundaries is used for the interior., +            // The (min < bp) is arbitrary but works better than other heuristics that were tried., +            int averageNeighborBlackPoint = (blackPoints[y - 1][x] + (2 * blackPoints[y][x - 1]) +, +                blackPoints[y - 1][x - 1]) >> 2;, +            if (min < averageNeighborBlackPoint) {, +              average = averageNeighborBlackPoint;]