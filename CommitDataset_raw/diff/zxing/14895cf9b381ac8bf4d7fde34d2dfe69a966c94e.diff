[+++ b/core/src/com/google/zxing/oned/AbstractOneDReader.java, +  private static final int INTEGER_MATH_SHIFT = 8;, +, +   * @return ratio of total variance between counters and pattern compared to total pattern size,, +   *  where the ratio has been multiplied by 256. So, 0 means no variance (perfect match); 256 means, +   *  the total variance between counters and patterns equals the pattern length, higher values mean, +   *  even more variance, +  static int patternMatchVariance(int[] counters, int[] pattern) {, +    int total = 0;, +    if (total < patternLength) {, +      // If we don't even have one pixel per unit of bar width, assume this is too small, +      // to reliably match, so fail:, +      return Integer.MAX_VALUE;, +    // We're going to fake floating-point math in integers. We just need to use more bits., +    // Scale up patternLength so that intermediate values below like scaledCounter will have, +    // more "significant digits", +    patternLength <<= INTEGER_MATH_SHIFT;, +    int patternRatio = patternLength / total;, +, +    int totalVariance = 0;, +    for (int x = 0; x < numCounters; x++) {, +      int scaledCounter = counters[x] * patternRatio;, +      int width = pattern[x] << INTEGER_MATH_SHIFT;, +      totalVariance += scaledCounter > width ? scaledCounter - width : width - scaledCounter;, +    }, +    return (totalVariance << 8) / patternLength;, +++ b/core/src/com/google/zxing/oned/AbstractOneDReader.java, +  private static final int INTEGER_MATH_SHIFT = 8;, +, +   * @return ratio of total variance between counters and pattern compared to total pattern size,, +   *  where the ratio has been multiplied by 256. So, 0 means no variance (perfect match); 256 means, +   *  the total variance between counters and patterns equals the pattern length, higher values mean, +   *  even more variance, +  static int patternMatchVariance(int[] counters, int[] pattern) {, +    int total = 0;, +    if (total < patternLength) {, +      // If we don't even have one pixel per unit of bar width, assume this is too small, +      // to reliably match, so fail:, +      return Integer.MAX_VALUE;, +    // We're going to fake floating-point math in integers. We just need to use more bits., +    // Scale up patternLength so that intermediate values below like scaledCounter will have, +    // more "significant digits", +    patternLength <<= INTEGER_MATH_SHIFT;, +    int patternRatio = patternLength / total;, +, +    int totalVariance = 0;, +    for (int x = 0; x < numCounters; x++) {, +      int scaledCounter = counters[x] * patternRatio;, +      int width = pattern[x] << INTEGER_MATH_SHIFT;, +      totalVariance += scaledCounter > width ? scaledCounter - width : width - scaledCounter;, +    }, +    return (totalVariance << 8) / patternLength;, +++ b/core/src/com/google/zxing/oned/AbstractUPCEANReader.java, +  private static final int MAX_VARIANCE = 104;, +  public final Result decodeRow(int rowNumber, BitArray row, int[] startGuardRange) throws ReaderException {, +    StringBuffer result = new StringBuffer(20);, +    int bestVariance = MAX_VARIANCE; // worst variance we'll accept, +    int max = patterns.length;, +    for (int i = 0; i < max; i++) {, +      int[] pattern = patterns[i];, +      int variance = patternMatchVariance(counters, pattern);, +        bestMatch = i;, +++ b/core/src/com/google/zxing/oned/AbstractOneDReader.java, +  private static final int INTEGER_MATH_SHIFT = 8;, +, +   * @return ratio of total variance between counters and pattern compared to total pattern size,, +   *  where the ratio has been multiplied by 256. So, 0 means no variance (perfect match); 256 means, +   *  the total variance between counters and patterns equals the pattern length, higher values mean, +   *  even more variance, +  static int patternMatchVariance(int[] counters, int[] pattern) {, +    int total = 0;, +    if (total < patternLength) {, +      // If we don't even have one pixel per unit of bar width, assume this is too small, +      // to reliably match, so fail:, +      return Integer.MAX_VALUE;, +    // We're going to fake floating-point math in integers. We just need to use more bits., +    // Scale up patternLength so that intermediate values below like scaledCounter will have, +    // more "significant digits", +    patternLength <<= INTEGER_MATH_SHIFT;, +    int patternRatio = patternLength / total;, +, +    int totalVariance = 0;, +    for (int x = 0; x < numCounters; x++) {, +      int scaledCounter = counters[x] * patternRatio;, +      int width = pattern[x] << INTEGER_MATH_SHIFT;, +      totalVariance += scaledCounter > width ? scaledCounter - width : width - scaledCounter;, +    }, +    return (totalVariance << 8) / patternLength;, +++ b/core/src/com/google/zxing/oned/AbstractUPCEANReader.java, +  private static final int MAX_VARIANCE = 104;, +  public final Result decodeRow(int rowNumber, BitArray row, int[] startGuardRange) throws ReaderException {, +    StringBuffer result = new StringBuffer(20);, +    int bestVariance = MAX_VARIANCE; // worst variance we'll accept, +    int max = patterns.length;, +    for (int i = 0; i < max; i++) {, +      int[] pattern = patterns[i];, +      int variance = patternMatchVariance(counters, pattern);, +        bestMatch = i;, +++ b/core/src/com/google/zxing/oned/Code128Reader.java, +  private static final int MAX_VARIANCE = 56;]