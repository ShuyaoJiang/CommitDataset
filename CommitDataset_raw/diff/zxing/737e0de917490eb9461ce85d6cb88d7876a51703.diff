[+++ b/core/src/com/google/zxing/common/StringUtils.java, +/*, + * Copyright (C) 2010 ZXing authors, + *, + * Licensed under the Apache License, Version 2.0 (the "License");, + * you may not use this file except in compliance with the License., + * You may obtain a copy of the License at, + *, + *      http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS,, + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied., + * See the License for the specific language governing permissions and, + * limitations under the License., + */, +, +package com.google.zxing.common;, +, +import java.util.Hashtable;, +, +import com.google.zxing.DecodeHintType;, +, +/**, + * Common string-related functions., + *, + * @author Sean Owen, + */, +public final class StringUtils {, +, +  private static final String PLATFORM_DEFAULT_ENCODING =, +      System.getProperty("file.encoding");, +  public static final String SHIFT_JIS = "SJIS";, +  private static final String EUC_JP = "EUC_JP";, +  private static final String UTF8 = "UTF8";, +  private static final String ISO88591 = "ISO8859_1";, +  private static final boolean ASSUME_SHIFT_JIS =, +      SHIFT_JIS.equalsIgnoreCase(PLATFORM_DEFAULT_ENCODING) ||, +      EUC_JP.equalsIgnoreCase(PLATFORM_DEFAULT_ENCODING);, +, +  private StringUtils() {}, +, +  /**, +   * @param bytes bytes encoding a string, whose encoding should be guessed, +   * @param hints decode hints if applicable, +   * @return name of guessed encoding; at the moment will only guess one of:, +   *  {@link #SHIFT_JIS}, {@link #UTF8}, {@link #ISO88591}, or the platform, +   *  default encoding if none of these can possibly be correct, +   */, +  public static String guessEncoding(byte[] bytes, Hashtable hints) {, +    if (hints != null) {, +      String characterSet = (String) hints.get(DecodeHintType.CHARACTER_SET);, +      if (characterSet != null) {, +        return characterSet;, +      }, +    }, +    // Does it start with the UTF-8 byte order mark? then guess it's UTF-8, +    if (bytes.length > 3 &&, +        bytes[0] == (byte) 0xEF &&, +        bytes[1] == (byte) 0xBB &&, +        bytes[2] == (byte) 0xBF) {, +      return UTF8;, +    }, +    // For now, merely tries to distinguish ISO-8859-1, UTF-8 and Shift_JIS,, +    // which should be by far the most common encodings. ISO-8859-1, +    // should not have bytes in the 0x80 - 0x9F range, while Shift_JIS, +    // uses this as a first byte of a two-byte character. If we see this, +    // followed by a valid second byte in Shift_JIS, assume it is Shift_JIS., +    // If we see something else in that second byte, we'll make the risky guess, +    // that it's UTF-8., +    int length = bytes.length;, +    boolean canBeISO88591 = true;, +    boolean canBeShiftJIS = true;, +    boolean canBeUTF8 = true;, +    int utf8BytesLeft = 0;, +    int maybeDoubleByteCount = 0;, +    int maybeSingleByteKatakanaCount = 0;, +    boolean sawLatin1Supplement = false;, +    boolean sawUTF8Start = false;, +    boolean lastWasPossibleDoubleByteStart = false;, +, +    for (int i = 0;, +         i < length && (canBeISO88591 || canBeShiftJIS || canBeUTF8);, +         i++) {, +, +      int value = bytes[i] & 0xFF;, +, +      // UTF-8 stuff, +      if (value >= 0x80 && value <= 0xBF) {, +        if (utf8BytesLeft > 0) {, +          utf8BytesLeft--;, +        }, +      } else {, +        if (utf8BytesLeft > 0) {, +          canBeUTF8 = false;, +        }, +        if (value >= 0xC0 && value <= 0xFD) {, +          sawUTF8Start = true;, +          int valueCopy = value;, +          while ((valueCopy & 0x40) != 0) {]