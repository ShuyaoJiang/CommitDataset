[+++ b/core/src/com/google/zxing/oned/AbstractUPCEANReader.java, +  private static final int MAX_AVG_VARIANCE = (int) (PATTERN_MATCH_RESULT_SCALE_FACTOR * 0.42f);, +      // Make sure there is a quiet zone at least as big as the start pattern before the barcode. If, +      // this check would run off the left edge of the image, do not accept this barcode, as it is, +      // very likely to be a false positive., +      int quietStart = start - (nextStart - start);, +      if (quietStart >= 0) {, +        foundStart = row.isRange(quietStart, start, false);, +      }, +    // Make sure there is a quiet zone at least as big as the end pattern after the barcode. The, +    // spec might want more whitespace, but in practice this is the maximum we can count on., +    int quietEnd = end + (end - endRange[0]);, +    if (quietEnd >= row.getSize() || !row.isRange(end, quietEnd, false)) {, +++ b/core/src/com/google/zxing/oned/AbstractUPCEANReader.java, +  private static final int MAX_AVG_VARIANCE = (int) (PATTERN_MATCH_RESULT_SCALE_FACTOR * 0.42f);, +      // Make sure there is a quiet zone at least as big as the start pattern before the barcode. If, +      // this check would run off the left edge of the image, do not accept this barcode, as it is, +      // very likely to be a false positive., +      int quietStart = start - (nextStart - start);, +      if (quietStart >= 0) {, +        foundStart = row.isRange(quietStart, start, false);, +      }, +    // Make sure there is a quiet zone at least as big as the end pattern after the barcode. The, +    // spec might want more whitespace, but in practice this is the maximum we can count on., +    int quietEnd = end + (end - endRange[0]);, +    if (quietEnd >= row.getSize() || !row.isRange(end, quietEnd, false)) {, +++ b/core/test/src/com/google/zxing/negative/FalsePositivesBlackBoxTestCase.java, +    addTest(2, 0.0f);, +    addTest(0, 90.0f);, +    addTest(0, 180.0f);, +++ b/core/src/com/google/zxing/oned/AbstractUPCEANReader.java, +  private static final int MAX_AVG_VARIANCE = (int) (PATTERN_MATCH_RESULT_SCALE_FACTOR * 0.42f);, +      // Make sure there is a quiet zone at least as big as the start pattern before the barcode. If, +      // this check would run off the left edge of the image, do not accept this barcode, as it is, +      // very likely to be a false positive., +      int quietStart = start - (nextStart - start);, +      if (quietStart >= 0) {, +        foundStart = row.isRange(quietStart, start, false);, +      }, +    // Make sure there is a quiet zone at least as big as the end pattern after the barcode. The, +    // spec might want more whitespace, but in practice this is the maximum we can count on., +    int quietEnd = end + (end - endRange[0]);, +    if (quietEnd >= row.getSize() || !row.isRange(end, quietEnd, false)) {, +++ b/core/test/src/com/google/zxing/negative/FalsePositivesBlackBoxTestCase.java, +    addTest(2, 0.0f);, +    addTest(0, 90.0f);, +    addTest(0, 180.0f);, +++ b/core/test/src/com/google/zxing/negative/PartialBlackBoxTestCase.java, +    addTest(0, 0.0f);, +    addTest(1, 90.0f);, +    addTest(1, 180.0f);, +    addTest(0, 270.0f);, +++ b/core/src/com/google/zxing/oned/AbstractUPCEANReader.java, +  private static final int MAX_AVG_VARIANCE = (int) (PATTERN_MATCH_RESULT_SCALE_FACTOR * 0.42f);, +      // Make sure there is a quiet zone at least as big as the start pattern before the barcode. If, +      // this check would run off the left edge of the image, do not accept this barcode, as it is, +      // very likely to be a false positive., +      int quietStart = start - (nextStart - start);, +      if (quietStart >= 0) {, +        foundStart = row.isRange(quietStart, start, false);, +      }, +    // Make sure there is a quiet zone at least as big as the end pattern after the barcode. The, +    // spec might want more whitespace, but in practice this is the maximum we can count on., +    int quietEnd = end + (end - endRange[0]);, +    if (quietEnd >= row.getSize() || !row.isRange(end, quietEnd, false)) {, +++ b/core/test/src/com/google/zxing/negative/FalsePositivesBlackBoxTestCase.java, +    addTest(2, 0.0f);, +    addTest(0, 90.0f);, +    addTest(0, 180.0f);, +++ b/core/test/src/com/google/zxing/negative/PartialBlackBoxTestCase.java, +    addTest(0, 0.0f);, +    addTest(1, 90.0f);, +    addTest(1, 180.0f);, +    addTest(0, 270.0f);, +++ b/core/test/src/com/google/zxing/oned/EAN13BlackBox1TestCase.java, +    addTest(27, 31, 180.0f);, +++ b/core/src/com/google/zxing/oned/AbstractUPCEANReader.java, +  private static final int MAX_AVG_VARIANCE = (int) (PATTERN_MATCH_RESULT_SCALE_FACTOR * 0.42f);, +      // Make sure there is a quiet zone at least as big as the start pattern before the barcode. If, +      // this check would run off the left edge of the image, do not accept this barcode, as it is, +      // very likely to be a false positive., +      int quietStart = start - (nextStart - start);, +      if (quietStart >= 0) {, +        foundStart = row.isRange(quietStart, start, false);, +      }, +    // Make sure there is a quiet zone at least as big as the end pattern after the barcode. The, +    // spec might want more whitespace, but in practice this is the maximum we can count on., +    int quietEnd = end + (end - endRange[0]);, +    if (quietEnd >= row.getSize() || !row.isRange(end, quietEnd, false)) {, +++ b/core/test/src/com/google/zxing/negative/FalsePositivesBlackBoxTestCase.java, +    addTest(2, 0.0f);, +    addTest(0, 90.0f);, +    addTest(0, 180.0f);, +++ b/core/test/src/com/google/zxing/negative/PartialBlackBoxTestCase.java, +    addTest(0, 0.0f);, +    addTest(1, 90.0f);, +    addTest(1, 180.0f);, +    addTest(0, 270.0f);, +++ b/core/test/src/com/google/zxing/oned/EAN13BlackBox1TestCase.java, +    addTest(27, 31, 180.0f);]