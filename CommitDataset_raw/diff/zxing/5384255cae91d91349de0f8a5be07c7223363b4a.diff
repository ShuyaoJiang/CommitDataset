[+++ b/core/src/com/google/zxing/qrcode/encoder/MaskUtil.java, + * @author Satoru Takabayashi, + * @author Daniel Switkin, + * @author Sean Owen, +  // Penalty weights from section 6.8.2.1, +  private static final int N1 = 3;, +  private static final int N2 = 3;, +  private static final int N3 = 40;, +  private static final int N4 = 10;, +, +  /**, +   * Apply mask penalty rule 1 and return the penalty. Find repetitive cells with the same color and, +   * give penalty to them. Example: 00000 or 11111., +   */, +  /**, +   * Apply mask penalty rule 2 and return the penalty. Find 2x2 blocks with the same color and give, +   * penalty to them. This is actually equivalent to the spec's rule, which is to find MxN blocks and give a, +   * penalty proportional to (M-1)x(N-1), because this is the number of 2x2 blocks inside such a block., +   */, +    for (int y = 0; y < height - 1; y++) {, +      for (int x = 0; x < width - 1; x++) {, +          penalty++;, +    return N2 * penalty;, +  /**, +   * Apply mask penalty rule 3 and return the penalty. Find consecutive cells of 00001011101 or, +   * 10111010000, and give penalty to them.  If we find patterns like 000010111010000, we give, +   * penalties twice (i.e. 40 * 2)., +   */, +    for (int y = 0; y < height; y++) {, +      for (int x = 0; x < width; x++) {, +          penalty += N3;, +          penalty += N3;, +  /**, +   * Apply mask penalty rule 4 and return the penalty. Calculate the ratio of dark cells and give, +   * penalty if the ratio is far from 50%. It gives 10 penalty for 5% distance., +   */, +    for (int y = 0; y < height; y++) {, +      byte[] arrayY = array[y];, +      for (int x = 0; x < width; x++) {, +        if (arrayY[x] == 1) {, +          numDarkCells++;, +    int fivePercentVariances = (int) (Math.abs(darkRatio - 0.5) * 20.0); // * 100.0 / 5.0, +    return fivePercentVariances * N4;, +  /**, +   * Return the mask bit for "getMaskPattern" at "x" and "y". See 8.8 of JISX0510:2004 for mask, +   * pattern conditions., +   */, +  /**, +   * Helper function for applyMaskPenaltyRule1. We need this for doing this calculation in both, +   * vertical and horizontal orders respectively., +   */, +    for (int i = 0; i < iLimit; i++) {, +      int numSameBitCells = 0;, +      int prevBit = -1;, +      for (int j = 0; j < jLimit; j++) {, +          numSameBitCells++;, +          if (numSameBitCells >= 5) {, +            penalty += N1 + (numSameBitCells - 5);, +          }, +      if (numSameBitCells > 5) {, +        penalty += N1 + (numSameBitCells - 5);, +      }]