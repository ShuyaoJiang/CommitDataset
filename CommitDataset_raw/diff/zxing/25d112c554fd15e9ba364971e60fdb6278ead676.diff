[+++ b/core/src/com/google/zxing/common/BlackPointEstimator.java, +   * @param histogram an array of <em>counts</em> of luminance values, +  public static int estimate(int[] histogram) {, +    int numBuckets = histogram.length;, +      if (histogram[i] > firstPeakSize) {, +        firstPeakSize = histogram[i];, +      int score = histogram[i] * distanceToBiggest * distanceToBiggest;, +    // Find a valley between them that is low and closer to the white peak, +    int bestValley = secondPeak;, +    int bestValleyScore = Integer.MAX_VALUE;, +    for (int i = secondPeak; i > firstPeak; i--) {, +      int distance = secondPeak - i + 3;, +      int score = distance * histogram[i];, +      if (score < bestValleyScore) {, +++ b/core/src/com/google/zxing/common/BlackPointEstimator.java, +   * @param histogram an array of <em>counts</em> of luminance values, +  public static int estimate(int[] histogram) {, +    int numBuckets = histogram.length;, +      if (histogram[i] > firstPeakSize) {, +        firstPeakSize = histogram[i];, +      int score = histogram[i] * distanceToBiggest * distanceToBiggest;, +    // Find a valley between them that is low and closer to the white peak, +    int bestValley = secondPeak;, +    int bestValleyScore = Integer.MAX_VALUE;, +    for (int i = secondPeak; i > firstPeak; i--) {, +      int distance = secondPeak - i + 3;, +      int score = distance * histogram[i];, +      if (score < bestValleyScore) {, +++ b/core/src/com/google/zxing/upc/UPCDecoder.java, +import com.google.zxing.BlackPointEstimationMethod;, +      bitmap.estimateBlackPoint(BlackPointEstimationMethod.ROW_SAMPLING, row);, +++ b/core/src/com/google/zxing/common/BlackPointEstimator.java, +   * @param histogram an array of <em>counts</em> of luminance values, +  public static int estimate(int[] histogram) {, +    int numBuckets = histogram.length;, +      if (histogram[i] > firstPeakSize) {, +        firstPeakSize = histogram[i];, +      int score = histogram[i] * distanceToBiggest * distanceToBiggest;, +    // Find a valley between them that is low and closer to the white peak, +    int bestValley = secondPeak;, +    int bestValleyScore = Integer.MAX_VALUE;, +    for (int i = secondPeak; i > firstPeak; i--) {, +      int distance = secondPeak - i + 3;, +      int score = distance * histogram[i];, +      if (score < bestValleyScore) {, +++ b/core/src/com/google/zxing/upc/UPCDecoder.java, +import com.google.zxing.BlackPointEstimationMethod;, +      bitmap.estimateBlackPoint(BlackPointEstimationMethod.ROW_SAMPLING, row);, +++ b/javame/src/com/google/zxing/client/j2me/LCDUIImageMonochromeBitmapSource.java, +  private int lastArgument;, +  , +  private static final int LUMINANCE_BITS = 5;, +  private static final int LUMINANCE_SHIFT = 8 - LUMINANCE_BITS;, +  private static final int LUMINANCE_BUCKETS = 1 << LUMINANCE_BITS;, +    lastMethod = null;, +    lastArgument = 0;, +    if (!method.equals(lastMethod) || argument != lastArgument) {, +      int[] histogram = new int[LUMINANCE_BUCKETS];, +          histogram[computeRGBLuminance(rgbPixels[offset]) >> LUMINANCE_SHIFT]++;, +        if (argument < 0 || argument >= height) {, +          throw new IllegalArgumentException("Row is not within the image: " + argument);, +        }, +        int offset = argument * width;, +        for (int x = 0; x < width; x++) {, +          histogram[computeRGBLuminance(rgbPixels[offset + x]) >> LUMINANCE_SHIFT]++;, +        }, +      blackPoint = BlackPointEstimator.estimate(histogram) << LUMINANCE_SHIFT;, +      lastArgument = argument;, +    }, +++ b/core/src/com/google/zxing/common/BlackPointEstimator.java, +   * @param histogram an array of <em>counts</em> of luminance values, +  public static int estimate(int[] histogram) {, +    int numBuckets = histogram.length;, +      if (histogram[i] > firstPeakSize) {, +        firstPeakSize = histogram[i];, +      int score = histogram[i] * distanceToBiggest * distanceToBiggest;, +    // Find a valley between them that is low and closer to the white peak, +    int bestValley = secondPeak;, +    int bestValleyScore = Integer.MAX_VALUE;, +    for (int i = secondPeak; i > firstPeak; i--) {, +      int distance = secondPeak - i + 3;, +      int score = distance * histogram[i];, +      if (score < bestValleyScore) {, +++ b/core/src/com/google/zxing/upc/UPCDecoder.java, +import com.google.zxing.BlackPointEstimationMethod;, +      bitmap.estimateBlackPoint(BlackPointEstimationMethod.ROW_SAMPLING, row);, +++ b/javame/src/com/google/zxing/client/j2me/LCDUIImageMonochromeBitmapSource.java, +  private int lastArgument;, +  , +  private static final int LUMINANCE_BITS = 5;, +  private static final int LUMINANCE_SHIFT = 8 - LUMINANCE_BITS;, +  private static final int LUMINANCE_BUCKETS = 1 << LUMINANCE_BITS;, +    lastMethod = null;, +    lastArgument = 0;, +    if (!method.equals(lastMethod) || argument != lastArgument) {, +      int[] histogram = new int[LUMINANCE_BUCKETS];, +          histogram[computeRGBLuminance(rgbPixels[offset]) >> LUMINANCE_SHIFT]++;, +        if (argument < 0 || argument >= height) {, +          throw new IllegalArgumentException("Row is not within the image: " + argument);, +        }]