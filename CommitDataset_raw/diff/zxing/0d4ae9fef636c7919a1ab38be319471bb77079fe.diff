[+++ b/cpp/core/src/zxing/qrcode/detector/Detector.cpp, +    } else if (otherToX >= (int)image_->getWidth()) {, +      scale = (float) (image_->getWidth() - 1 - fromX) / (float) (otherToX - fromX);, +      otherToX = image_->getWidth() - 1;, +    } else if (otherToY >= (int)image_->getHeight()) {, +      scale = (float) (image_->getHeight() - 1 - fromY) / (float) (otherToY - fromY);, +      otherToY = image_->getHeight() - 1;, +, +    // Middle pixel is double-counted this way; subtract 1, +    return result - 1.0f;, +    int ystep = fromY < toY ? 1 : -1;, +    // In black pixels, looking for white, first or second time., +    int state = 0;, +    // Loop up until x == toX, but not beyond, +    int xLimit = toX + xstep;, +    for (int x = fromX, y = fromY; x != xLimit; x += xstep) {, +      // Does current pixel mean we have moved white to black or vice versa?, +      if (!(state == 1 ^ image_->get(realX, realY))) {, +        if (state == 2) {, +        state++;, +      }, +, +        if (y == toY) {, +          break;, +        }, +    // Found black-white-black; give the benefit of the doubt that the next pixel outside the image, +    // is "white" so this last point at (toX+xStep,toY) is the right ending. This is really a, +    // small approximation; (toX+xStep,toY+yStep) might be really correct. Ignore this., +    if (state == 2) {, +      int diffX = toX + xstep - fromX;, +    // else we didn't find even black-white-black; no estimate is really possible, +    return NAN;, +}]