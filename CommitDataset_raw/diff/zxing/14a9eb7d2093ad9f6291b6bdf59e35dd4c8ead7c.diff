[+++ b/android/src/com/google/zxing/client/android/RGBMonochromeBitmapSource.java, +import com.google.zxing.ReaderException;, +  public void estimateBlackPoint(BlackPointEstimationMethod method, int argument) throws ReaderException {, +++ b/android/src/com/google/zxing/client/android/RGBMonochromeBitmapSource.java, +import com.google.zxing.ReaderException;, +  public void estimateBlackPoint(BlackPointEstimationMethod method, int argument) throws ReaderException {, +++ b/android/src/com/google/zxing/client/android/YUVMonochromeBitmapSource.java, +import com.google.zxing.ReaderException;, +  public void estimateBlackPoint(BlackPointEstimationMethod method, int argument) throws ReaderException {, +++ b/android/src/com/google/zxing/client/android/RGBMonochromeBitmapSource.java, +import com.google.zxing.ReaderException;, +  public void estimateBlackPoint(BlackPointEstimationMethod method, int argument) throws ReaderException {, +++ b/android/src/com/google/zxing/client/android/YUVMonochromeBitmapSource.java, +import com.google.zxing.ReaderException;, +  public void estimateBlackPoint(BlackPointEstimationMethod method, int argument) throws ReaderException {, +++ b/core/src/com/google/zxing/common/BlackPointEstimator.java, +import com.google.zxing.ReaderException;, +, +   * @throws ReaderException if "black" and "white" appear to be very close in luminance in the image, +  public static int estimate(int[] histogram, float biasTowardsWhite) throws ReaderException{, +    // Kind of aribtrary; if the two peaks are very close, then we figure there is so little, +    // dynamic range in the image, that discriminating black and white is too error-prone., +    // Decoding the image/line is either pointless, or may in some cases lead to a false positive, +    // for 1D formats, which are relatively lenient., +    // We arbitrarily say "close" is "fewer than 1/8 of the total histogram buckets apart", +    if (secondPeak - firstPeak < histogram.length >> 3) {, +      throw new ReaderException("Too little dynamic range in luminance");, +    }, +, +++ b/android/src/com/google/zxing/client/android/RGBMonochromeBitmapSource.java, +import com.google.zxing.ReaderException;, +  public void estimateBlackPoint(BlackPointEstimationMethod method, int argument) throws ReaderException {, +++ b/android/src/com/google/zxing/client/android/YUVMonochromeBitmapSource.java, +import com.google.zxing.ReaderException;, +  public void estimateBlackPoint(BlackPointEstimationMethod method, int argument) throws ReaderException {, +++ b/core/src/com/google/zxing/common/BlackPointEstimator.java, +import com.google.zxing.ReaderException;, +, +   * @throws ReaderException if "black" and "white" appear to be very close in luminance in the image, +  public static int estimate(int[] histogram, float biasTowardsWhite) throws ReaderException{, +    // Kind of aribtrary; if the two peaks are very close, then we figure there is so little, +    // dynamic range in the image, that discriminating black and white is too error-prone., +    // Decoding the image/line is either pointless, or may in some cases lead to a false positive, +    // for 1D formats, which are relatively lenient., +    // We arbitrarily say "close" is "fewer than 1/8 of the total histogram buckets apart", +    if (secondPeak - firstPeak < histogram.length >> 3) {, +      throw new ReaderException("Too little dynamic range in luminance");, +    }, +, +++ b/core/src/com/google/zxing/oned/AbstractOneDReader.java, +    // that moving up and down by about 1/16 of the image is pretty good; we try more of the image if, +    // "trying harder", +    int rowStep = Math.max(1, height >> (tryHarder ? 7 : 4));, +, +    Result lastResult = null;, +, +      try {, +      } catch (ReaderException re) {, +        continue;, +      }, +      for (int attempt = 0; attempt < 2; attempt++) {, +        if (attempt == 1) { // trying again?, +          if (tryHarder) { // only if "trying harder", +            row.reverse(); // reverse the row and continue, +            break;, +        }, +          if (lastResult == null || !lastResult.getText().equals(result.getText())) {, +            // Found new barcode, not just the last one again, +              lastResult = result; // Remember what we just saw, +              if (attempt == 1) {, +              }, +          }, +        } catch (ReaderException re) {, +++ b/android/src/com/google/zxing/client/android/RGBMonochromeBitmapSource.java, +import com.google.zxing.ReaderException;, +  public void estimateBlackPoint(BlackPointEstimationMethod method, int argument) throws ReaderException {, +++ b/android/src/com/google/zxing/client/android/YUVMonochromeBitmapSource.java, +import com.google.zxing.ReaderException;, +  public void estimateBlackPoint(BlackPointEstimationMethod method, int argument) throws ReaderException {, +++ b/core/src/com/google/zxing/common/BlackPointEstimator.java, +import com.google.zxing.ReaderException;, +, +   * @throws ReaderException if "black" and "white" appear to be very close in luminance in the image, +  public static int estimate(int[] histogram, float biasTowardsWhite) throws ReaderException{, +    // Kind of aribtrary; if the two peaks are very close, then we figure there is so little, +    // dynamic range in the image, that discriminating black and white is too error-prone., +    // Decoding the image/line is either pointless, or may in some cases lead to a false positive, +    // for 1D formats, which are relatively lenient., +    // We arbitrarily say "close" is "fewer than 1/8 of the total histogram buckets apart", +    if (secondPeak - firstPeak < histogram.length >> 3) {, +      throw new ReaderException("Too little dynamic range in luminance");, +    }, +, +++ b/core/src/com/google/zxing/oned/AbstractOneDReader.java, +    // that moving up and down by about 1/16 of the image is pretty good; we try more of the image if, +    // "trying harder", +    int rowStep = Math.max(1, height >> (tryHarder ? 7 : 4));, +, +    Result lastResult = null;, +]