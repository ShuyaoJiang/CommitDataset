[+++ b/javase/src/com/google/zxing/client/j2se/BufferedImageMonochromeBitmapSource.java, + * <p>This may also be used to construct a {@link MonochromeBitmapSource}, + * based on a region of a {@link BufferedImage}; see, + * {@link #BufferedImageMonochromeBitmapSource(BufferedImage, int, int, int, int)}.</p>, + *, +  private final int left;, +  private final int top;, +  private final int width;, +  private final int height;, +    this(image, 0, 0, image.getWidth(), image.getHeight());, +  }, +, +  public BufferedImageMonochromeBitmapSource(BufferedImage image, int left, int top, int right, int bottom) {, +    int sourceHeight = image.getHeight();, +    int sourceWidth = image.getWidth();, +    if (left < 0 || top < 0 || right >= sourceWidth || bottom >= sourceHeight || right <= left || bottom <= top) {, +      throw new IllegalArgumentException("Invalid bounds: (" + top + ',' + left + ") (" + right + ',' + bottom + ')');, +    }, +    this.left = left;, +    this.top = top;, +    this.width = right - left;, +    this.height = bottom - top;, +  /**, +   * @return underlying {@link BufferedImage} behind this instance. Note that even if this instance, +   *  only uses a subset of the full image, the returned value here represents the entire backing image., +   */, +  private int getRGB(int x, int y) {, +    return image.getRGB(left + x, top + y);, +  }, +, +  private void getRGBRow(int startX, int startY, int[] result) {, +    image.getRGB(left + startX, top + startY, result.length, 1, result, 0, result.length);, +  }, +, +    return computeRGBLuminance(getRGB(x, y)) < blackPoint;, +    int[] pixelRow = new int[getWidth];, +    getRGBRow(startX, y, pixelRow);, +    return height;, +    return width;, +          int pixel = getRGB(startJ + n, startI + n);, +        getRGBRow(0, argument, rgbArray);, +    int sourceWidth = image.getWidth();, +    int sourceHeight = image.getHeight();, +    AffineTransform transform = new AffineTransform(0.0, -1.0, 1.0, 0.0, 0.0, sourceWidth);, +    BufferedImage rotatedImage = new BufferedImage(sourceHeight, sourceWidth, image.getType());, +    return new BufferedImageMonochromeBitmapSource(rotatedImage,, +                                                   top,, +                                                   sourceWidth - (left + width),, +                                                   top + height,, +                                                   sourceWidth - left);]