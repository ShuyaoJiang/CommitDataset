[+++ b/core/src/com/google/zxing/qrcode/decoder/DecodedBitStreamParser.java, +    boolean canBeShiftJIS = true;, +    boolean sawDoubleByteStart = false;, +    int maybeSingleByteKatakanaCount = 0;, +    for (int i = 0; i < length && (canBeISO88591 || canBeShiftJIS); i++) {, +      if (value >= 0x7F && value <= 0x9F) {, +      }, +      if (value >= 0xA1 && value <= 0xDF) {, +        // count the number of characters that might be a Shift_JIS single-byte Katakana character, +        maybeSingleByteKatakanaCount++;, +      }, +      if (((value >= 0x81 && value <= 0x9F) || (value >= 0xE0 && value <= 0xEF)) && i < length - 1) {, +        // These start double-byte characters in Shift_JIS. Let's see if it's followed by a valid, +        // second byte., +        sawDoubleByteStart = true;, +            canBeShiftJIS = false;, +        }, +      }, +    }, +    // Distinguishing Shift_JIS and ISO-8859-1 can be a little tough. The crude heuristic is:, +    // - If we saw, +    //   - at least one byte that starts a double-byte value (bytes that are rare in ISO-8859-1), or, +    //   - over 5% of bytes that could be single-byte Katakana (also rare in ISO-8859-1),, +    // - and, saw no sequences that are invalid in Shift_JIS, then we conclude Shift_JIS, +    if ((sawDoubleByteStart || 20 * maybeSingleByteKatakanaCount > length) && canBeShiftJIS) {, +      return SHIFT_JIS;, +    }, +    // Otherwise, we default to ISO-8859-1 unless we know it can't be, +    if (canBeISO88591) {, +      return ISO88591;, +    }, +    // Otherwise, we take a wild guess with UTF-8, +++ b/core/src/com/google/zxing/qrcode/decoder/DecodedBitStreamParser.java, +    boolean canBeShiftJIS = true;, +    boolean sawDoubleByteStart = false;, +    int maybeSingleByteKatakanaCount = 0;, +    for (int i = 0; i < length && (canBeISO88591 || canBeShiftJIS); i++) {, +      if (value >= 0x7F && value <= 0x9F) {, +      }, +      if (value >= 0xA1 && value <= 0xDF) {, +        // count the number of characters that might be a Shift_JIS single-byte Katakana character, +        maybeSingleByteKatakanaCount++;, +      }, +      if (((value >= 0x81 && value <= 0x9F) || (value >= 0xE0 && value <= 0xEF)) && i < length - 1) {, +        // These start double-byte characters in Shift_JIS. Let's see if it's followed by a valid, +        // second byte., +        sawDoubleByteStart = true;, +            canBeShiftJIS = false;, +        }, +      }, +    }, +    // Distinguishing Shift_JIS and ISO-8859-1 can be a little tough. The crude heuristic is:, +    // - If we saw, +    //   - at least one byte that starts a double-byte value (bytes that are rare in ISO-8859-1), or, +    //   - over 5% of bytes that could be single-byte Katakana (also rare in ISO-8859-1),, +    // - and, saw no sequences that are invalid in Shift_JIS, then we conclude Shift_JIS, +    if ((sawDoubleByteStart || 20 * maybeSingleByteKatakanaCount > length) && canBeShiftJIS) {, +      return SHIFT_JIS;, +    }, +    // Otherwise, we default to ISO-8859-1 unless we know it can't be, +    if (canBeISO88591) {, +      return ISO88591;, +    }, +    // Otherwise, we take a wild guess with UTF-8, +++ b/core/test/src/com/google/zxing/qrcode/QRCodeBlackBox2TestCase.java, +    addTest(23, 23, 0.0f);, +    addTest(18, 18, 90.0f);, +    addTest(22, 22, 180.0f);, +    addTest(17, 17, 270.0f);, +++ b/core/src/com/google/zxing/qrcode/decoder/DecodedBitStreamParser.java, +    boolean canBeShiftJIS = true;, +    boolean sawDoubleByteStart = false;, +    int maybeSingleByteKatakanaCount = 0;, +    for (int i = 0; i < length && (canBeISO88591 || canBeShiftJIS); i++) {, +      if (value >= 0x7F && value <= 0x9F) {, +      }, +      if (value >= 0xA1 && value <= 0xDF) {, +        // count the number of characters that might be a Shift_JIS single-byte Katakana character, +        maybeSingleByteKatakanaCount++;, +      }, +      if (((value >= 0x81 && value <= 0x9F) || (value >= 0xE0 && value <= 0xEF)) && i < length - 1) {, +        // These start double-byte characters in Shift_JIS. Let's see if it's followed by a valid, +        // second byte., +        sawDoubleByteStart = true;, +            canBeShiftJIS = false;, +        }, +      }, +    }, +    // Distinguishing Shift_JIS and ISO-8859-1 can be a little tough. The crude heuristic is:, +    // - If we saw, +    //   - at least one byte that starts a double-byte value (bytes that are rare in ISO-8859-1), or, +    //   - over 5% of bytes that could be single-byte Katakana (also rare in ISO-8859-1),, +    // - and, saw no sequences that are invalid in Shift_JIS, then we conclude Shift_JIS, +    if ((sawDoubleByteStart || 20 * maybeSingleByteKatakanaCount > length) && canBeShiftJIS) {, +      return SHIFT_JIS;, +    }, +    // Otherwise, we default to ISO-8859-1 unless we know it can't be, +    if (canBeISO88591) {, +      return ISO88591;, +    }]