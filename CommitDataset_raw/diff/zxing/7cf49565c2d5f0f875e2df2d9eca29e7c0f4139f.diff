[+++ b/core/src/main/java/com/google/zxing/pdf417/decoder/DecodedBitStreamParser.java, +  private static final char[] PUNCT_CHARS =, +      ";<>@[\\]_`~!\r\t,:\n-.$/\"|*()?{}'".toCharArray();, +  private static final char[] MIXED_CHARS =, +      "0123456789&\r\t,:#-.$/+%*=^".toCharArray();, +++ b/core/src/main/java/com/google/zxing/pdf417/decoder/DecodedBitStreamParser.java, +  private static final char[] PUNCT_CHARS =, +      ";<>@[\\]_`~!\r\t,:\n-.$/\"|*()?{}'".toCharArray();, +  private static final char[] MIXED_CHARS =, +      "0123456789&\r\t,:#-.$/+%*=^".toCharArray();, +++ b/core/src/main/java/com/google/zxing/qrcode/decoder/BitMatrixParser.java, +    DataMask dataMask = DataMask.values()[formatInfo.getDataMask()];, +    DataMask dataMask = DataMask.values()[parsedFormatInfo.getDataMask()];, +++ b/core/src/main/java/com/google/zxing/pdf417/decoder/DecodedBitStreamParser.java, +  private static final char[] PUNCT_CHARS =, +      ";<>@[\\]_`~!\r\t,:\n-.$/\"|*()?{}'".toCharArray();, +  private static final char[] MIXED_CHARS =, +      "0123456789&\r\t,:#-.$/+%*=^".toCharArray();, +++ b/core/src/main/java/com/google/zxing/qrcode/decoder/BitMatrixParser.java, +    DataMask dataMask = DataMask.values()[formatInfo.getDataMask()];, +    DataMask dataMask = DataMask.values()[parsedFormatInfo.getDataMask()];, +++ b/core/src/main/java/com/google/zxing/qrcode/decoder/DataMask.java, +enum DataMask {, +, +  /**, +   * 000: mask bits for which (x + y) mod 2 == 0, +   */, +  DATA_MASK_000() {, +    @Override, +    boolean isMasked(int i, int j) {, +      return ((i + j) & 0x01) == 0;, +    }, +  },, +, +  /**, +   * 001: mask bits for which x mod 2 == 0, +   */, +  DATA_MASK_001() {, +    @Override, +    boolean isMasked(int i, int j) {, +      return (i & 0x01) == 0;, +    }, +  },, +, +  /**, +   * 010: mask bits for which y mod 3 == 0, +   */, +  DATA_MASK_010() {, +    @Override, +    boolean isMasked(int i, int j) {, +      return j % 3 == 0;, +    }, +  },, +, +  /**, +   * 011: mask bits for which (x + y) mod 3 == 0, +   */, +  DATA_MASK_011() {, +    @Override, +    boolean isMasked(int i, int j) {, +      return (i + j) % 3 == 0;, +    }, +  },, +, +  /**, +   * 100: mask bits for which (x/2 + y/3) mod 2 == 0, +   */, +  DATA_MASK_100() {, +    @Override, +    boolean isMasked(int i, int j) {, +      return (((i / 2) + (j /3)) & 0x01) == 0;, +    }, +  },, +, +  /**, +   * 101: mask bits for which xy mod 2 + xy mod 3 == 0, +   */, +  DATA_MASK_101() {, +    @Override, +    boolean isMasked(int i, int j) {, +      int temp = i * j;, +      return (temp & 0x01) + (temp % 3) == 0;, +    }, +  },, +, +  /**, +   * 110: mask bits for which (xy mod 2 + xy mod 3) mod 2 == 0, +   */, +  DATA_MASK_110() {, +    @Override, +    boolean isMasked(int i, int j) {, +      int temp = i * j;, +      return (((temp & 0x01) + (temp % 3)) & 0x01) == 0;, +    }, +  },, +, +  /**, +   * 111: mask bits for which ((x+y)mod 2 + xy mod 3) mod 2 == 0, +   */, +  DATA_MASK_111() {]