[+++ b/core/src/main/java/com/google/zxing/datamatrix/detector/Detector.java, +    ResultPoint[] points = detectSolid1(cornerPoints);, +    points = detectSolid2(points);, +    points[3] = correctTopRight(points);, +    if (points[3] == null) {, +    points = shiftToModuleCenter(points);, +    ResultPoint topLeft = points[0];, +    ResultPoint bottomLeft = points[1];, +    ResultPoint bottomRight = points[2];, +    ResultPoint topRight = points[3];, +    int dimensionTop = transitionsBetween(topLeft, topRight) + 1;, +    int dimensionRight = transitionsBetween(bottomRight, topRight) + 1;, +      dimensionTop += 1;, +      dimensionRight += 1;, +    if (4 * dimensionTop < 7 * dimensionRight && 4 * dimensionRight < 7 * dimensionTop) {, +      dimensionTop = dimensionRight = Math.max(dimensionTop, dimensionRight);, +    BitMatrix bits = sampleGrid(image, , +                                topRight,, +                                dimensionTop,, +                                dimensionRight);, +, +    return new DetectorResult(bits, new ResultPoint[]{topLeft, bottomLeft, bottomRight, topRight});, +  private ResultPoint shiftPoint(ResultPoint point, ResultPoint to, int div) {, +    float x = (to.getX() - point.getX()) / (div + 1);, +    float y = (to.getY() - point.getY()) / (div + 1);, +    return new ResultPoint(point.getX() + x, point.getY() + y);, +  }, +, +  private ResultPoint moveAway(ResultPoint point, float fromX, float fromY) {, +    float x = point.getX();, +    float y = point.getY();, +, +    if (x < fromX) {, +      x -= 1;, +    } else {, +      x += 1;, +    }, +, +    if (y < fromY) {, +      y -= 1;, +    } else {, +      y += 1;, +    }, +, +    return new ResultPoint(x, y);, +   * Detect a solid side which has minimum transition., +  private ResultPoint[] detectSolid1(ResultPoint[] cornerPoints) {, +    // 0  2, +    // 1  3, +    ResultPoint pointA = cornerPoints[0];, +    ResultPoint pointB = cornerPoints[1];, +    ResultPoint pointC = cornerPoints[3];, +    ResultPoint pointD = cornerPoints[2];, +    int trAB = transitionsBetween(pointA, pointB);, +    int trBC = transitionsBetween(pointB, pointC);, +    int trCD = transitionsBetween(pointC, pointD);, +    int trDA = transitionsBetween(pointD, pointA);, +    // 0..3, +    // :  :, +    // 1--2, +    int min = trAB;, +    ResultPoint[] points = {pointD, pointA, pointB, pointC};, +    if (min > trBC) {, +      min = trBC;, +      points[0] = pointA;, +      points[1] = pointB;, +      points[2] = pointC;, +      points[3] = pointD;, +    if (min > trCD) {, +      min = trCD;, +      points[0] = pointB;, +      points[1] = pointC;, +      points[2] = pointD;, +      points[3] = pointA;, +    if (min > trDA) {, +      points[0] = pointC;, +      points[1] = pointD;, +      points[2] = pointA;, +      points[3] = pointB;, +    return points;, +   * Detect a second solid side next to first solid side., +  private ResultPoint[] detectSolid2(ResultPoint[] points) {, +    // A..D, +    // :  :, +    // B--C, +    ResultPoint pointA = points[0];, +    ResultPoint pointB = points[1];, +    ResultPoint pointC = points[2];, +    ResultPoint pointD = points[3];, +    // Transition detection on the edge is not stable., +    // To safely detect, shift the points to the module center., +    int tr = transitionsBetween(pointA, pointD);, +    ResultPoint pointBs = shiftPoint(pointB, pointC, (tr + 1) * 4);, +    ResultPoint pointCs = shiftPoint(pointC, pointB, (tr + 1) * 4);, +    int trBA = transitionsBetween(pointBs, pointA);, +    int trCD = transitionsBetween(pointCs, pointD);, +    // 0..3, +    // |  :, +    // 1--2, +    if (trBA < trCD) {]