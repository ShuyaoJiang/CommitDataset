[+++ b/core/src/com/google/zxing/multi/qrcode/QRCodeMultiReader.java, +import com.google.zxing.qrcode.decoder.QRCodeDecoderMetaData;, +        // If the code was mirrored: swap the bottom-left and the top-right points., +        if (decoderResult.getOther() instanceof QRCodeDecoderMetaData) {, +          ((QRCodeDecoderMetaData) decoderResult.getOther()).applyMirroredCorrection(points);, +        }, +++ b/core/src/com/google/zxing/multi/qrcode/QRCodeMultiReader.java, +import com.google.zxing.qrcode.decoder.QRCodeDecoderMetaData;, +        // If the code was mirrored: swap the bottom-left and the top-right points., +        if (decoderResult.getOther() instanceof QRCodeDecoderMetaData) {, +          ((QRCodeDecoderMetaData) decoderResult.getOther()).applyMirroredCorrection(points);, +        }, +++ b/core/src/com/google/zxing/qrcode/QRCodeReader.java, +import com.google.zxing.qrcode.decoder.QRCodeDecoderMetaData;, +    // If the code was mirrored: swap the bottom-left and the top-right points., +    if (decoderResult.getOther() instanceof QRCodeDecoderMetaData) {, +      ((QRCodeDecoderMetaData) decoderResult.getOther()).applyMirroredCorrection(points);, +    }, +, +++ b/core/src/com/google/zxing/multi/qrcode/QRCodeMultiReader.java, +import com.google.zxing.qrcode.decoder.QRCodeDecoderMetaData;, +        // If the code was mirrored: swap the bottom-left and the top-right points., +        if (decoderResult.getOther() instanceof QRCodeDecoderMetaData) {, +          ((QRCodeDecoderMetaData) decoderResult.getOther()).applyMirroredCorrection(points);, +        }, +++ b/core/src/com/google/zxing/qrcode/QRCodeReader.java, +import com.google.zxing.qrcode.decoder.QRCodeDecoderMetaData;, +    // If the code was mirrored: swap the bottom-left and the top-right points., +    if (decoderResult.getOther() instanceof QRCodeDecoderMetaData) {, +      ((QRCodeDecoderMetaData) decoderResult.getOther()).applyMirroredCorrection(points);, +    }, +, +++ b/core/src/com/google/zxing/qrcode/decoder/BitMatrixParser.java, +  private boolean mirror;, +    boolean bit = mirror ? bitMatrix.get(j, i) : bitMatrix.get(i, j);, +    return bit ? (versionBits << 1) | 0x1 : versionBits << 1;, +   * correct order in order to reconstruct the codewords bytes contained within the, +    DataMask dataMask = DataMask.forReference(formatInfo.getDataMask());, +  /**, +   * Revert the mask removal done while reading the code words. The bit matrix should revert to its original state., +   */, +  void remask() {, +    if (parsedFormatInfo == null) {, +      return; // We have no format information, and have no data mask, +    }, +    DataMask dataMask = DataMask.forReference(parsedFormatInfo.getDataMask());, +    int dimension = bitMatrix.getHeight();, +    dataMask.unmaskBitMatrix(bitMatrix, dimension);, +  }, +, +  /**, +   * Prepare the parser for a mirrored operation., +   * This flag has effect only on the {@link #readFormatInformation()} and the, +   * {@link #readVersion()}. Before proceeding with {@link #readCodewords()} the, +   * {@link #mirror()} method should be called., +   * , +   * @param mirror Whether to read version and format information mirrored., +   */, +  void setMirror(boolean mirror) {, +    parsedVersion = null;, +    parsedFormatInfo = null;, +    this.mirror = mirror;, +  }, +, +  /** Mirror the bit matrix in order to attempt a second reading. */, +  void mirror() {, +    for (int x = 0; x < bitMatrix.getWidth(); x++) {, +      for (int y = x + 1; y < bitMatrix.getHeight(); y++) {, +        if (bitMatrix.get(x, y) != bitMatrix.get(y, x)) {, +          bitMatrix.flip(y, x);, +          bitMatrix.flip(x, y);          , +        }, +      }, +    }, +  }, +, +++ b/core/src/com/google/zxing/multi/qrcode/QRCodeMultiReader.java, +import com.google.zxing.qrcode.decoder.QRCodeDecoderMetaData;, +        // If the code was mirrored: swap the bottom-left and the top-right points., +        if (decoderResult.getOther() instanceof QRCodeDecoderMetaData) {, +          ((QRCodeDecoderMetaData) decoderResult.getOther()).applyMirroredCorrection(points);, +        }, +++ b/core/src/com/google/zxing/qrcode/QRCodeReader.java, +import com.google.zxing.qrcode.decoder.QRCodeDecoderMetaData;, +    // If the code was mirrored: swap the bottom-left and the top-right points., +    if (decoderResult.getOther() instanceof QRCodeDecoderMetaData) {, +      ((QRCodeDecoderMetaData) decoderResult.getOther()).applyMirroredCorrection(points);, +    }, +, +++ b/core/src/com/google/zxing/qrcode/decoder/BitMatrixParser.java, +  private boolean mirror;, +    boolean bit = mirror ? bitMatrix.get(j, i) : bitMatrix.get(i, j);, +    return bit ? (versionBits << 1) | 0x1 : versionBits << 1;, +   * correct order in order to reconstruct the codewords bytes contained within the, +    DataMask dataMask = DataMask.forReference(formatInfo.getDataMask());, +  /**, +   * Revert the mask removal done while reading the code words. The bit matrix should revert to its original state., +   */, +  void remask() {, +    if (parsedFormatInfo == null) {]