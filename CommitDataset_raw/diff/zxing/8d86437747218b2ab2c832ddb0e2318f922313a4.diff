[+++ b/core/src/com/google/zxing/BinaryBitmap.java, +   * Returns a new object with rotated image data by 90 degrees counterclockwise., +   * Only callable if {@link #isRotateSupported()} is true., +  /**, +   * Returns a new object with rotated image data by 45 degrees counterclockwise., +   * Only callable if {@link #isRotateSupported()} is true., +   *, +   * @return A rotated version of this object., +   */, +  public BinaryBitmap rotateCounterClockwise45() {, +    LuminanceSource newSource = binarizer.getLuminanceSource().rotateCounterClockwise45();, +    return new BinaryBitmap(binarizer.createBinarizer(newSource));, +  }, +, +++ b/core/src/com/google/zxing/BinaryBitmap.java, +   * Returns a new object with rotated image data by 90 degrees counterclockwise., +   * Only callable if {@link #isRotateSupported()} is true., +  /**, +   * Returns a new object with rotated image data by 45 degrees counterclockwise., +   * Only callable if {@link #isRotateSupported()} is true., +   *, +   * @return A rotated version of this object., +   */, +  public BinaryBitmap rotateCounterClockwise45() {, +    LuminanceSource newSource = binarizer.getLuminanceSource().rotateCounterClockwise45();, +    return new BinaryBitmap(binarizer.createBinarizer(newSource));, +  }, +, +++ b/core/src/com/google/zxing/LuminanceSource.java, +   * Returns a new object with rotated image data by 90 degrees counterclockwise., +   * Only callable if {@link #isRotateSupported()} is true., +    throw new UnsupportedOperationException("This luminance source does not support rotation by 90 degrees.");, +  }, +, +  /**, +   * Returns a new object with rotated image data by 45 degrees counterclockwise., +   * Only callable if {@link #isRotateSupported()} is true., +   *, +   * @return A rotated version of this object., +   */, +  public LuminanceSource rotateCounterClockwise45() {, +    throw new UnsupportedOperationException("This luminance source does not support rotation by 45 degrees.");, +++ b/core/src/com/google/zxing/BinaryBitmap.java, +   * Returns a new object with rotated image data by 90 degrees counterclockwise., +   * Only callable if {@link #isRotateSupported()} is true., +  /**, +   * Returns a new object with rotated image data by 45 degrees counterclockwise., +   * Only callable if {@link #isRotateSupported()} is true., +   *, +   * @return A rotated version of this object., +   */, +  public BinaryBitmap rotateCounterClockwise45() {, +    LuminanceSource newSource = binarizer.getLuminanceSource().rotateCounterClockwise45();, +    return new BinaryBitmap(binarizer.createBinarizer(newSource));, +  }, +, +++ b/core/src/com/google/zxing/LuminanceSource.java, +   * Returns a new object with rotated image data by 90 degrees counterclockwise., +   * Only callable if {@link #isRotateSupported()} is true., +    throw new UnsupportedOperationException("This luminance source does not support rotation by 90 degrees.");, +  }, +, +  /**, +   * Returns a new object with rotated image data by 45 degrees counterclockwise., +   * Only callable if {@link #isRotateSupported()} is true., +   *, +   * @return A rotated version of this object., +   */, +  public LuminanceSource rotateCounterClockwise45() {, +    throw new UnsupportedOperationException("This luminance source does not support rotation by 45 degrees.");, +++ b/core/test/src/com/google/zxing/BufferedImageLuminanceSource.java, +, +    // The color of fully-transparent pixels is irrelevant. They are often, technically, fully-transparent, +    // black (0 alpha, and then 0 RGB). They are often used, of course as the "white" area in a, +    // barcode image. Force any such pixel to be white:, +    for (int y = top; y < top + height; y++) {, +      for (int x = left; x < left + width; x++) {, +        if ((image.getRGB(x, y) & 0xFF000000) == 0) {, +          image.setRGB(x, y, 0xFFFFFFFF); // = white, +        }, +      }, +    }, +, +  @Override, +  public LuminanceSource rotateCounterClockwise45() {, +    int width = getWidth();, +    int height = getHeight();, +, +    int oldCenterX = left + width / 2;, +    int oldCenterY = top + height / 2;, +, +    // Rotate 45 degrees counterclockwise., +    AffineTransform transform = AffineTransform.getRotateInstance(Math.toRadians(-45.0), oldCenterX, oldCenterY);, +, +    int sourceDimension = Math.max(image.getWidth(), image.getHeight());, +    BufferedImage rotatedImage = new BufferedImage(sourceDimension, sourceDimension, BufferedImage.TYPE_BYTE_GRAY);, +, +    // Draw the original image into rotated, via transformation, +    Graphics2D g = rotatedImage.createGraphics();, +    g.drawImage(image, transform, null);]