[+++ b/AUTHORS, +Frank Yellin, +++ b/AUTHORS, +Frank Yellin, +++ b/core/src/com/google/zxing/aztec/detector/Detector.java, + * @author Frank Yellin, +    // 2. Get the center points of the four diagonal points just outside the bull's eye, +    //  [topRight, bottomRight, bottomLeft, topLeft], +    ResultPoint[] bullsEyeCorners = getBullsEyeCorners(pCenter);, +    // 3. Get the size of the matrix and other parameters from the bull's eye, +    extractParameters(bullsEyeCorners);, +    // 4. Sample the grid, +    BitMatrix bits = sampleGrid(image, , +      bullsEyeCorners[shift%4], bullsEyeCorners[(shift+1)%4], , +      bullsEyeCorners[(shift+2)%4], bullsEyeCorners[(shift+3)%4]);, +    // 5. Get the corners of the matrix., +    ResultPoint[] corners = getMatrixCornerPoints(bullsEyeCorners);, +   * @param bullsEyeCorners the array of bull's eye corners, +  private void extractParameters(ResultPoint[] bullsEyeCorners) throws NotFoundException {, +    boolean[] resab = sampleLine(bullsEyeCorners[0], bullsEyeCorners[1], twoCenterLayers+1);, +    boolean[] resbc = sampleLine(bullsEyeCorners[1], bullsEyeCorners[2], twoCenterLayers+1);, +    boolean[] rescd = sampleLine(bullsEyeCorners[2], bullsEyeCorners[3], twoCenterLayers+1);, +    boolean[] resda = sampleLine(bullsEyeCorners[3], bullsEyeCorners[0], twoCenterLayers+1);, +   * @param bullsEyeCorners the array of bull's eye corners, +  private ResultPoint[] getMatrixCornerPoints(ResultPoint[] bullsEyeCorners) throws NotFoundException {, +    return expandSquare(bullsEyeCorners, 2 * nbCenterLayers, getDimension());, +   * This returns the centers of the diagonal points just outside the bull's eye, +   * Returns [topRight, bottomRight, bottomLeft, topLeft], +  private ResultPoint[] getBullsEyeCorners(Point pCenter) throws NotFoundException {, +    // Expand the square by .5 pixel in each direction so that we're on the border, +    // between the white square and the black square, +    ResultPoint pinax = new ResultPoint(pina.getX() + 0.5f, pina.getY() - 0.5f);, +    ResultPoint pinbx = new ResultPoint(pinb.getX() + 0.5f, pinb.getY() + 0.5f);, +    ResultPoint pincx = new ResultPoint(pinc.getX() - 0.5f, pinc.getY() + 0.5f);, +    ResultPoint pindx = new ResultPoint(pind.getX() - 0.5f, pind.getY() - 0.5f);, +    // Expand the square so that its corners are the centers of the points, +    // just outside the bull's eye., +    return expandSquare(new ResultPoint[]{pinax, pinbx, pincx, pindx},, +                        2 * nbCenterLayers - 3,, +                        2 * nbCenterLayers);, +   * Creates a BitMatrix by sampling the provided image., +   * topLeft, topRight, bottomRight, and bottomLeft are the centers of the squares on the, +   * diagonal just outside the bull's eye., +                               ResultPoint topRight,, +                               ResultPoint bottomLeft) throws NotFoundException {, +    int dimension = getDimension();, +, +    float low = dimension/2.0f - nbCenterLayers;, +    float high = dimension/2.0f + nbCenterLayers;, +      low, low,   // topleft, +      high, low,  // topright, +      high, high, // bottomright, +      low, high,  // bottomleft, +      topLeft.getX(), topLeft.getY(),, +      topRight.getX(), topRight.getY(),, +      bottomRight.getX(), bottomRight.getY(),, +      bottomLeft.getX(), bottomLeft.getY());, +  private boolean[] sampleLine(ResultPoint p1, ResultPoint p2, int size) {, +    float errRatio = error / d;, +  /**, +   * Expand the square represented by the corner points by pushing out equally in all directions, +   *, +   * @param cornerPoints  the corners of the square, which has the bull's eye at its center, +   * @param oldSide the original length of the side of the square in the target bit matrix, +   * @param newSide the new length of the size of the square in the target bit matrix, +   * @return the corners of the expanded square, +   */, +  private ResultPoint[] expandSquare(ResultPoint[] cornerPoints, float oldSide, float newSide), +      throws NotFoundException {, +    float ratio = newSide / (2 * oldSide);, +    float dx = cornerPoints[0].getX() - cornerPoints[2].getX();, +    float dy = cornerPoints[0].getY() - cornerPoints[2].getY();, +    float centerx = (cornerPoints[0].getX() + cornerPoints[2].getX()) / 2.0f;, +    float centery = (cornerPoints[0].getY() + cornerPoints[2].getY()) / 2.0f;, +, +    ResultPoint result0 = new ResultPoint(centerx + ratio * dx, centery + ratio * dy);, +    ResultPoint result2 = new ResultPoint(centerx - ratio * dx, centery - ratio * dy);, +, +    dx = cornerPoints[1].getX() - cornerPoints[3].getX();, +    dy = cornerPoints[1].getY() - cornerPoints[3].getY();, +    centerx = (cornerPoints[1].getX() + cornerPoints[3].getX()) / 2.0f;, +    centery = (cornerPoints[1].getY() + cornerPoints[3].getY()) / 2.0f;, +    ResultPoint result1 = new ResultPoint(centerx + ratio * dx, centery + ratio * dy);, +    ResultPoint result3 = new ResultPoint(centerx - ratio * dx, centery - ratio * dy);, +, +    if (!isValid(result0) || !isValid(result1) || !isValid(result2) || !isValid(result3)) {, +      throw NotFoundException.getNotFoundInstance();, +    }, +    return new ResultPoint[] { result0, result1, result2, result3 };, +  }, +, +  private boolean isValid(ResultPoint point) {, +    int x = MathUtils.round(point.getX());, +    int y = MathUtils.round(point.getY());, +    return isValid(x, y);, +  }, +, +  private static float distance(ResultPoint a, ResultPoint b) {, +    return MathUtils.distance(a.getX(), a.getY(), b.getX(), b.getY());, +  }]