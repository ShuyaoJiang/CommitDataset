[+++ b/core/src/com/google/zxing/pdf417/detector/Detector.java, +, +  // 11111111 0 1 0 1 0 1 000, +  private static final int[] START_PATTERN = {8, 1, 1, 1, 1, 1, 1, 3};, +, +  // 11111111 0 1 0 1 0 1 000, +  private static final int[] START_PATTERN_REVERSE = {3, 1, 1, 1, 1, 1, 1, 8};, +, +  // 1111111 0 1 000 1 0 1 00 1, +  private static final int[] STOP_PATTERN = {7, 1, 1, 3, 1, 1, 1, 2, 1};, +  // 1111111 0 1 000 1 0 1 00 1, +  private static final int[] STOP_PATTERN_REVERSE = {1, 2, 1, 1, 1, 3, 1, 1, 7};, +    // Fetch the 1 bit matrix once up front., +    BitMatrix matrix = image.getBlackMatrix();, +    , +    ResultPoint[] vertices = findVertices(matrix);, +      vertices = findVertices180(matrix);, +      BitMatrix bits = sampleGrid(matrix, vertices[4], vertices[5],, +   * and Stop patterns as locators. Assumes that the barcode begins in the left half, +   * of the image, and ends in the right half., +   * TODO: Fix this assumption, allowing the barcode to be anywhere in the image., +   * TODO: Scanning every row is very expensive. We should only do this for TRY_HARDER., +   * @param matrix the scanned barcode image., +  private static ResultPoint[] findVertices(BitMatrix matrix) throws ReaderException {, +    int height = matrix.getHeight();, +    int width = matrix.getWidth();, +    int halfWidth = width >> 1;, +      loc = findGuardPattern(matrix, 0, i, halfWidth, START_PATTERN);, +        loc = findGuardPattern(matrix, 0, i, halfWidth, START_PATTERN);, +        loc = findGuardPattern(matrix, halfWidth, i, halfWidth, STOP_PATTERN);, +          result[2] = new ResultPoint(loc[1], i);, +          result[6] = new ResultPoint(loc[0], i);, +        loc = findGuardPattern(matrix, halfWidth, i, halfWidth, STOP_PATTERN);, +          result[3] = new ResultPoint(loc[1], i);, +          result[7] = new ResultPoint(loc[0], i);, +   * TODO: Change assumption about barcode location., +   * TODO: Scanning every row is very expensive. We should only do this for TRY_HARDER., +   * @param matrix the scanned barcode image., +  private static ResultPoint[] findVertices180(BitMatrix matrix) throws ReaderException {, +    int height = matrix.getHeight();, +    int width = matrix.getWidth();, +    int halfWidth = width >> 1;, +      loc = findGuardPattern(matrix, halfWidth, i, halfWidth, START_PATTERN_REVERSE);, +        result[0] = new ResultPoint(loc[1], i);, +        result[4] = new ResultPoint(loc[0], i);, +        loc = findGuardPattern(matrix, halfWidth, i, halfWidth, START_PATTERN_REVERSE);, +          result[1] = new ResultPoint(loc[1], i);, +          result[5] = new ResultPoint(loc[0], i);, +        loc = findGuardPattern(matrix, 0, i, halfWidth, STOP_PATTERN_REVERSE);, +        loc = findGuardPattern(matrix, 0, i, halfWidth, STOP_PATTERN_REVERSE);, +    return found ? result : null;, +  private static BitMatrix sampleGrid(BitMatrix matrix, ResultPoint topLeft,, +    return sampler.sampleGrid(matrix, dimension, 0.0f, // p1ToX, +   * @param matrix row of black/white values to search, +   * @param column x position to start search, +   * @param row y position to start search, +   * @param width the number of pixels to search on this row, +   * @return start/end horizontal offset of guard pattern, as an array of two ints., +  static int[] findGuardPattern(BitMatrix matrix, int column, int row, int width, int[] pattern) {, +    int patternStart = column;, +    for (int x = column; x < column + width; x++) {, +      boolean pixel = matrix.get(x, row);, +          if (patternMatchVariance(counters, pattern, MAX_INDIVIDUAL_VARIANCE) < MAX_AVG_VARIANCE) {, +++ b/core/src/com/google/zxing/pdf417/detector/Detector.java, +, +  // 11111111 0 1 0 1 0 1 000, +  private static final int[] START_PATTERN = {8, 1, 1, 1, 1, 1, 1, 3};, +, +  // 11111111 0 1 0 1 0 1 000, +  private static final int[] START_PATTERN_REVERSE = {3, 1, 1, 1, 1, 1, 1, 8};, +, +  // 1111111 0 1 000 1 0 1 00 1, +  private static final int[] STOP_PATTERN = {7, 1, 1, 3, 1, 1, 1, 2, 1};, +  // 1111111 0 1 000 1 0 1 00 1, +  private static final int[] STOP_PATTERN_REVERSE = {1, 2, 1, 1, 1, 3, 1, 1, 7};, +    // Fetch the 1 bit matrix once up front., +    BitMatrix matrix = image.getBlackMatrix();, +    , +    ResultPoint[] vertices = findVertices(matrix);, +      vertices = findVertices180(matrix);, +      BitMatrix bits = sampleGrid(matrix, vertices[4], vertices[5],, +   * and Stop patterns as locators. Assumes that the barcode begins in the left half, +   * of the image, and ends in the right half., +   * TODO: Fix this assumption, allowing the barcode to be anywhere in the image., +   * TODO: Scanning every row is very expensive. We should only do this for TRY_HARDER., +   * @param matrix the scanned barcode image., +  private static ResultPoint[] findVertices(BitMatrix matrix) throws ReaderException {, +    int height = matrix.getHeight();, +    int width = matrix.getWidth();, +    int halfWidth = width >> 1;, +      loc = findGuardPattern(matrix, 0, i, halfWidth, START_PATTERN);, +        loc = findGuardPattern(matrix, 0, i, halfWidth, START_PATTERN);, +        loc = findGuardPattern(matrix, halfWidth, i, halfWidth, STOP_PATTERN);, +          result[2] = new ResultPoint(loc[1], i);, +          result[6] = new ResultPoint(loc[0], i);, +        loc = findGuardPattern(matrix, halfWidth, i, halfWidth, STOP_PATTERN);, +          result[3] = new ResultPoint(loc[1], i);, +          result[7] = new ResultPoint(loc[0], i);, +   * TODO: Change assumption about barcode location., +   * TODO: Scanning every row is very expensive. We should only do this for TRY_HARDER.]