[+++ b/core/src/com/google/zxing/EncodeHintType.java, +  /**, +   * Specifies what character encoding to use where applicable (type String), +   */, +  public static final EncodeHintType CHARACTER_SET = new EncodeHintType();, +, +++ b/core/src/com/google/zxing/EncodeHintType.java, +  /**, +   * Specifies what character encoding to use where applicable (type String), +   */, +  public static final EncodeHintType CHARACTER_SET = new EncodeHintType();, +, +++ b/core/src/com/google/zxing/qrcode/encoder/Encoder.java, +import com.google.zxing.EncodeHintType;, +import java.util.Hashtable;, +  /**, +   *  Encode "bytes" with the error correction level "ecLevel". The encoding mode will be chosen, +   * internally by chooseMode(). On success, store the result in "qrCode"., +   *, +   * We recommend you to use QRCode.EC_LEVEL_L (the lowest level) for, +   * "getECLevel" since our primary use is to show QR code on desktop screens. We don't need very, +   * strong error correction for this purpose., +   *, +   * Note that there is no way to encode bytes in MODE_KANJI. We might want to add EncodeWithMode(), +   * with which clients can specify the encoding mode. For now, we don't need the functionality., +   */, +    encode(content, ecLevel, null, qrCode);, +  }, +, +  public static void encode(String content, ErrorCorrectionLevel ecLevel, Hashtable hints, QRCode qrCode), +      throws WriterException {, +, +    String characterEncoding = hints == null ? null : (String) hints.get(EncodeHintType.CHARACTER_SET);, +    if (characterEncoding == null) {, +      characterEncoding = "ISO-8859-1";, +    }, +, +    appendBytes(content, mode, dataBits, characterEncoding);, +  /**, +   * @return the code point of the table used in alphanumeric mode or, +   *  -1 if there is no corresponding code in the table., +   */, +  /**, +   * Choose the best mode by examining the content., +   *, +   * Note that this function does not return MODE_KANJI, as we cannot distinguish Shift_JIS from, +   * other encodings such as ISO-8859-1, from data bytes alone. For example "\xE0\xE0" can be, +   * interpreted as one character in Shift_JIS, but also two characters in ISO-8859-1., +   */, +  /**, +   * Initialize "qrCode" according to "numInputBytes", "ecLevel", and "mode". On success, modify "qrCode"., +   */, +  /**, +   * Terminate bits as described in 8.4.8 and 8.4.9 of JISX0510:2004 (p.24)., +   */, +  /**, +   * Get number of data bytes and number of error correction bytes for block id "blockID". Store, +   * the result in "numDataBytesInBlock", and "numECBytesInBlock". See table 12 in 8.5.1 of, +   * JISX0510:2004 (p.30), +   */, +  /**, +   * Interleave "bits" with corresponding error correction bytes. On success, store the result in, +   * "result". The interleave rule is complicated. See 8.6 of JISX0510:2004 (p.37) for details., +   */, +  /**, +   * Append mode info. On success, store the result in "bits"., +   */, +  /**, +   * Append length info. On success, store the result in "bits"., +   */, +  /**, +   * Append "bytes" in "mode" mode (encoding) into "bits". On success, store the result in "bits"., +   */, +  static void appendBytes(String content, Mode mode, BitVector bits, String encoding) throws WriterException {, +      append8BitBytes(content, bits, encoding);, +  static void append8BitBytes(String content, BitVector bits, String encoding) throws WriterException {, +      bytes = content.getBytes(encoding);]