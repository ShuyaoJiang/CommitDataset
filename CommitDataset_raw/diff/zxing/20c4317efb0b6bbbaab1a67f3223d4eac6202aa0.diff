[+++ b/core/src/com/google/zxing/upc/UPCDecoder.java, +   * To decode the image, we attempt to decode rows across from the middle outwards.For each row, we scan, +    //String longestResult = "";, +    boolean found = false;, +, +    // We're going to examine rows from the middle outward, searching alternately above and below the middle,, +    // and farther out each time. rowStep is the number of rows between each successive attempt above and below, +    // the middle. So we'd scan row middle, then middle - rowStep, then middle + rowStep,, +    // then middle - 2*rowStep, etc., +    // rowStep is bigger as the image is taller, but is always at least 1. We've somewhat arbitrarily decided, +    // that moving up and down by about 1/32 of the image is pretty good., +    int middle = height >> 1;, +    int rowStep = Math.max(1, height >> 5);, +    for (int x = 0; x < 11; x++) {, +, +      int rowStepsAboveOrBelow = (x + 1) >> 1;, +      boolean isAbove = (x & 0x01) == 0; // i.e. is x even?, +      int row = middle + rowStep * (isAbove ? rowStepsAboveOrBelow : -rowStepsAboveOrBelow);, +, +        found = true;, +      //if (result.length() > longestResult.length()) {, +      //  longestResult = result.toString();, +      //}, +        found = true;, +      //if (result.length() > longestResult.length()) {, +      //  longestResult = result.toString();, +      //}, +    if (found) {, +    boolean verified = verifyResult();, +    if (verified) {, +      points = new UPCPoint[] { new UPCPoint(startOffset, row), new UPCPoint(rowOffset, row) };, +    return verified;, +    int patternLength = pattern.length;, +    int[] counters = new int[patternLength];, +        if (counterPosition == patternLength - 1) {, +          for (int y = 2; y < patternLength; y++) {, +      byte[] pattern = DIGIT_PATTERNS[x];, +        int diff = counters[y] - pattern[y];, +        byte[] pattern = EVEN_PARITY_PATTERNS[x];, +          int diff = counters[y] - pattern[y];]