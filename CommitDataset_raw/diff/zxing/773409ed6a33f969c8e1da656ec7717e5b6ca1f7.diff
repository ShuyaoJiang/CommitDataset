[+++ b/core/src/com/google/zxing/common/BitArray.java, +, +      // Return false if we're looking for 1s and the masked bits[i] isn't all 1s (that is,, +      // equals the mask, or we're looking for 0s and the masked portion is not all 0s, +      if ((bits[i] & mask) != (value ? mask : 0)) {, +++ b/core/src/com/google/zxing/common/BitArray.java, +, +      // Return false if we're looking for 1s and the masked bits[i] isn't all 1s (that is,, +      // equals the mask, or we're looking for 0s and the masked portion is not all 0s, +      if ((bits[i] & mask) != (value ? mask : 0)) {, +++ b/core/src/com/google/zxing/oned/AbstractUPCEANReader.java, +      // maybe as wide as the 150% of the start pattern itself?, +      foundStart = row.isRange(Math.max(0, start - (3 * (nextStart - start)) / 2), start, false);, +    // Check for whitespace after the pattern -- 150% of size of end pattern, +++ b/core/src/com/google/zxing/common/BitArray.java, +, +      // Return false if we're looking for 1s and the masked bits[i] isn't all 1s (that is,, +      // equals the mask, or we're looking for 0s and the masked portion is not all 0s, +      if ((bits[i] & mask) != (value ? mask : 0)) {, +++ b/core/src/com/google/zxing/oned/AbstractUPCEANReader.java, +      // maybe as wide as the 150% of the start pattern itself?, +      foundStart = row.isRange(Math.max(0, start - (3 * (nextStart - start)) / 2), start, false);, +    // Check for whitespace after the pattern -- 150% of size of end pattern, +++ b/core/src/com/google/zxing/oned/Code128Reader.java, +            // Look for whitespace before start pattern, >= 50% of width of start pattern            , +            if (row.isRange(Math.max(0, patternStart - (i - patternStart) / 2), patternStart, false)) {, +          }, +    // Check for ample whitespice following pattern, but, to do this we first need to remember that we, +    // fudged decoding CODE_STOP since it actually has 7 bars, not 6. There is a black bar left to read off., +    // Would be slightly better to properly read. Here we just skip it:, +    while (row.get(nextStart)) {, +      nextStart++;, +    }, +    if (!row.isRange(nextStart, Math.min(row.getSize(), nextStart + (nextStart - lastStart) / 2), false)) {, +      throw new ReaderException("Pattern not followed by whitespace");, +    }, +, +++ b/core/src/com/google/zxing/common/BitArray.java, +, +      // Return false if we're looking for 1s and the masked bits[i] isn't all 1s (that is,, +      // equals the mask, or we're looking for 0s and the masked portion is not all 0s, +      if ((bits[i] & mask) != (value ? mask : 0)) {, +++ b/core/src/com/google/zxing/oned/AbstractUPCEANReader.java, +      // maybe as wide as the 150% of the start pattern itself?, +      foundStart = row.isRange(Math.max(0, start - (3 * (nextStart - start)) / 2), start, false);, +    // Check for whitespace after the pattern -- 150% of size of end pattern, +++ b/core/src/com/google/zxing/oned/Code128Reader.java, +            // Look for whitespace before start pattern, >= 50% of width of start pattern            , +            if (row.isRange(Math.max(0, patternStart - (i - patternStart) / 2), patternStart, false)) {, +          }, +    // Check for ample whitespice following pattern, but, to do this we first need to remember that we, +    // fudged decoding CODE_STOP since it actually has 7 bars, not 6. There is a black bar left to read off., +    // Would be slightly better to properly read. Here we just skip it:, +    while (row.get(nextStart)) {, +      nextStart++;, +    }, +    if (!row.isRange(nextStart, Math.min(row.getSize(), nextStart + (nextStart - lastStart) / 2), false)) {, +      throw new ReaderException("Pattern not followed by whitespace");, +    }, +, +++ b/core/src/com/google/zxing/oned/Code39Reader.java, + * <p>Decodes Code 39 barcodes. This does not support "Full ASCII Code 39" yet.</p>, +    // Look for whitespace after pattern:, +    int lastPatternSize = 0;, +    for (int i = 0; i < counters.length; i++) {, +      lastPatternSize += counters[i];, +    }, +    int whiteSpaceAfterEnd = nextStart - lastStart - lastPatternSize;, +    // If 50% of last pattern size, following last pattern, is not whitespace, fail, +    // (but if it's whitespace to the very end of the image, that's OK), +    if (nextStart != end && whiteSpaceAfterEnd / 2 < lastPatternSize) {, +      throw new ReaderException("Pattern not followed by whitespace");, +    }, +, +              // Look for whitespace before start pattern, >= 50% of width of start pattern, +              if (row.isRange(Math.max(0, patternStart - (i - patternStart) / 2), patternStart, false)) {, +            }]