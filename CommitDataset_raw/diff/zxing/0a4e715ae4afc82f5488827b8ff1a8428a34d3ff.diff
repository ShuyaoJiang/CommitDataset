[+++ b/javase/src/com/google/zxing/client/j2se/CommandLineRunner.java, +import com.google.zxing.BlackPointEstimationMethod;, +import com.google.zxing.common.BitArray;, +import java.io.OutputStream;, +    boolean dumpBlackPoint = false;, +      } else if ("--dump_black_point".equals(arg)) {, +        dumpBlackPoint = true;, +        decodeOneArgument(arg, hints, dumpResults, dumpBlackPoint);, +      boolean dumpResults, boolean dumpBlackPoint) throws IOException,, +      URISyntaxException {, +          // Skip the results of dumping the black point., +          if (filename.contains(".mono.png")) {, +            continue;, +          }, +          Result result = decode(input.toURI(), hints, dumpBlackPoint);, +        Result result = decode(inputFile.toURI(), hints, dumpBlackPoint);, +      decode(new URI(argument), hints, dumpBlackPoint);, +  private static Result decode(URI uri, Hashtable<DecodeHintType, Object> hints,, +      boolean dumpBlackPoint) throws IOException {, +      if (dumpBlackPoint) {, +        dumpBlackPoint(uri, image, source);, +      }, +  // Writes out a single PNG which is three times the width of the input image, containing from left, +  // to right: the original image, the row sampling monochrome version, and the 2D sampling, +  // monochrome version., +  // TODO: Currently fails on URLs. Would be nice to handle gracefully and write the output to pwd., +  private static void dumpBlackPoint(URI uri, BufferedImage image, MonochromeBitmapSource source) {, +    String inputName = uri.getPath();, +    if (inputName.contains(".mono.png")) {, +      return;, +    }, +, +    int width = source.getWidth();, +    int height = source.getHeight();, +    int stride = width * 3;, +    int[] pixels = new int[stride * height];, +, +    // The original image, +    int[] argb = new int[width];, +    for (int y = 0; y < height; y++) {, +      image.getRGB(0, y, width, 1, argb, 0, width);, +      System.arraycopy(argb, 0, pixels, y * stride, width);, +    }, +    argb = null;, +, +    // Row sampling, +    BitArray row = new BitArray(width);, +    for (int y = 0; y < height; y++) {, +      try {, +        source.estimateBlackPoint(BlackPointEstimationMethod.ROW_SAMPLING, y);, +      } catch (ReaderException e) {, +        // If the row histogram failed, draw a red line and keep going, +        int offset = y * stride + width;, +        for (int x = 0; x < width; x++) {, +          pixels[offset + x] = 0xffff0000;, +        }, +        continue;, +      }, +      source.getBlackRow(y, row, 0, width);, +      int offset = y * stride + width;, +      for (int x = 0; x < width; x++) {, +        if (row.get(x)) {, +          pixels[offset + x] = 0xff000000;, +        } else {, +          pixels[offset + x] = 0xffffffff;, +        }, +      }, +    }, +, +    // 2D sampling, +    try {, +      source.estimateBlackPoint(BlackPointEstimationMethod.TWO_D_SAMPLING, 0);, +      for (int y = 0; y < height; y++) {, +        source.getBlackRow(y, row, 0, width);, +        int offset = y * stride + width * 2;, +        for (int x = 0; x < width; x++) {, +          if (row.get(x)) {, +            pixels[offset + x] = 0xff000000;, +          } else {, +            pixels[offset + x] = 0xffffffff;, +          }, +        }, +      }, +    } catch (ReaderException e) {, +    }, +, +    // Write the result, +    BufferedImage result = new BufferedImage(stride, height, BufferedImage.TYPE_INT_ARGB);, +    result.setRGB(0, 0, stride, height, pixels, 0, stride);, +, +    String resultName = inputName;, +    int pos = resultName.lastIndexOf('.');, +    if (pos > 0) {, +      resultName = resultName.substring(0, pos);, +    }, +    resultName += ".mono.png";, +    try {, +      OutputStream outStream = new FileOutputStream(resultName);, +      ImageIO.write(result, "png", outStream);, +    } catch (FileNotFoundException e) {]