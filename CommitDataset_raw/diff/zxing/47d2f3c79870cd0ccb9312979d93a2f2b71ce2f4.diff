[+++ b/AUTHORS, +David Olivier, +++ b/AUTHORS, +David Olivier, +++ b/core/src/com/google/zxing/common/detector/WhiteRectangleDetector.java, +/*, + * Copyright 2010 ZXing authors, + *, + * Licensed under the Apache License, Version 2.0 (the "License");, + * you may not use this file except in compliance with the License., + * You may obtain a copy of the License at, + *, + *      http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS,, + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied., + * See the License for the specific language governing permissions and, + * limitations under the License., + */, +, +package com.google.zxing.common.detector;, +, +import com.google.zxing.NotFoundException;, +import com.google.zxing.ResultPoint;, +import com.google.zxing.common.BitMatrix;, +, +/**, + * <p>, + * Detects a candidate barcode-like rectangular region within an image. It, + * starts around the center of the image, increases the size of the candidate, + * region until it finds a white rectangular region. By keeping track of the, + * last black points it encountered, it determines the corners of the barcode., + * </p>, + *, + * @author David Olivier, + */, +public final class WhiteRectangleDetector {, +, +  private static final int INIT_SIZE = 40;, +  private static final int MIN_SIZE = 20;, +, +  private final BitMatrix image;, +  private final int height;, +  private final int width;, +, +  public WhiteRectangleDetector(BitMatrix image) {, +    this.image = image;, +    height = image.getHeight();, +    width = image.getWidth();, +  }, +, +  /**, +   * <p>, +   * Detects a candidate barcode-like rectangular region within an image. It, +   * starts around the center of the image, increases the size of the candidate, +   * region until it finds a white rectangular region., +   * </p>, +   *, +   * @return {@link ResultPoint}[] describing the corners of the rectangular, +   *         region. The first and last points are opposed on the diagonal, as, +   *         are the second and third. The first point will be the topmost, +   *         point and the last, the bottommost. The second point will be, +   *         leftmost and the third, the rightmost, +   * @throws NotFoundException if no Data Matrix Code can be found, +   */, +  public ResultPoint[] detect() throws NotFoundException {, +, +    int left = (width - INIT_SIZE) / 2;, +    int right = (width + INIT_SIZE) / 2;, +    int up = (height - INIT_SIZE) / 2;, +    int down = (height + INIT_SIZE) / 2;, +    boolean sizeExceeded = false;, +    boolean aBlackPointFoundOnBorder = true;, +    boolean atLeastOneBlackPointFoundOnBorder = false;, +, +    while (aBlackPointFoundOnBorder) {, +, +      aBlackPointFoundOnBorder = false;, +, +      // ....., +      // .   |, +      // ....., +      boolean rightBorderNotWhite = true;, +      while (rightBorderNotWhite && right < width) {, +        rightBorderNotWhite = containsBlackPoint(up, down, right, false);, +        if (rightBorderNotWhite) {, +          right++;, +          aBlackPointFoundOnBorder = true;, +        }, +      }, +, +      // ....., +      // .   ., +      // .___., +      boolean bottomBorderNotWhite = true;, +      while (bottomBorderNotWhite && down < height) {, +        bottomBorderNotWhite = containsBlackPoint(left, right, down, true);, +        if (bottomBorderNotWhite) {, +          down++;]