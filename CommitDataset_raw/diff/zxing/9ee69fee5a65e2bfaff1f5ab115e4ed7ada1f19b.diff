[+++ b/core/src/com/google/zxing/qrcode/decoder/DecodedBitStreamParser.java, +        if (mode.equals(Mode.ECI)) {, +          // Count doesn't apply to ECI, +          parseECI(bits);, +          // We don't currently do anything with ECI, since there seems to be no reference, +          // defining what each value means. AIM's "Extended Channel Interpretations" does, +          // not define it. I have never observed a QR Code using it. So for now, we at least, +          // parse it but don't know how to take action on it., +        } else {, +      }, +  private static int parseECI(BitSource bits) {, +    int firstByte = bits.readBits(8);, +    if (firstByte & 0x80 == 0) {, +      // just one byte, +      return firstByte & 0x7F;, +    } else if (firstByte & 0xC0 == 0x80) {, +      // two bytes, +      int secondByte = bits.readBits(8);, +      return ((firstByte & 0x3F) << 8) | secondByte;, +    } else if (firstByte & 0xE0 == 0xC0) {, +      // three bytes, +      int secondByte = bits.readBits(8);, +      int thirdByte = bits.readBits(8);, +      return ((firstByte & 0x1F) << 16) | (secondByte << 8) | thirdByte;, +    }, +  }, +, +++ b/core/src/com/google/zxing/qrcode/decoder/DecodedBitStreamParser.java, +        if (mode.equals(Mode.ECI)) {, +          // Count doesn't apply to ECI, +          parseECI(bits);, +          // We don't currently do anything with ECI, since there seems to be no reference, +          // defining what each value means. AIM's "Extended Channel Interpretations" does, +          // not define it. I have never observed a QR Code using it. So for now, we at least, +          // parse it but don't know how to take action on it., +        } else {, +      }, +  private static int parseECI(BitSource bits) {, +    int firstByte = bits.readBits(8);, +    if (firstByte & 0x80 == 0) {, +      // just one byte, +      return firstByte & 0x7F;, +    } else if (firstByte & 0xC0 == 0x80) {, +      // two bytes, +      int secondByte = bits.readBits(8);, +      return ((firstByte & 0x3F) << 8) | secondByte;, +    } else if (firstByte & 0xE0 == 0xC0) {, +      // three bytes, +      int secondByte = bits.readBits(8);, +      int thirdByte = bits.readBits(8);, +      return ((firstByte & 0x1F) << 16) | (secondByte << 8) | thirdByte;, +    }, +  }, +, +++ b/core/src/com/google/zxing/qrcode/decoder/Mode.java, +  static final Mode ECI = new Mode(null); // character counts don't apply, +      case 0x7:, +        return ECI;, +    if (this == ECI) {, +      throw new UnsupportedOperationException("Character count doesn't apply to ECI mode");, +    }]