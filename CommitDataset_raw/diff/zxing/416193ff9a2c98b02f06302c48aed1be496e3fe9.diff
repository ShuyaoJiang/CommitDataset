[+++ b/core/src/com/google/zxing/qrcode/QRCodeWriter.java, +    Encoder.encode(new ByteArray(contents), errorCorrectionLevel, code);, +    ByteMatrix input = code.getMatrix();, +++ b/core/src/com/google/zxing/qrcode/QRCodeWriter.java, +    Encoder.encode(new ByteArray(contents), errorCorrectionLevel, code);, +    ByteMatrix input = code.getMatrix();, +++ b/core/src/com/google/zxing/qrcode/encoder/BitVector.java, +    final int numBitsInLastByte = sizeInBits & 0x7;, +    if (numBitsInLastByte == 0) {, +    array[sizeInBits >> 3] |= (bit << (7 - numBitsInLastByte));, +  // Append "numBits" bits in "value" to the bit vector., +  // REQUIRES: 0<= numBits <= 32., +  public void appendBits(final int value, final int numBits) {, +    if (numBits < 0 || numBits > 32) {, +    int numBitsLeft = numBits;, +    while (numBitsLeft > 0) {, +      if ((sizeInBits & 0x7) == 0 && numBitsLeft >= 8) {, +        final int newByte = (value >> (numBitsLeft - 8)) & 0xff;, +        numBitsLeft -= 8;, +        final int bit = (value >> (numBitsLeft - 1)) & 1;, +        --numBitsLeft;, +++ b/core/src/com/google/zxing/qrcode/QRCodeWriter.java, +    Encoder.encode(new ByteArray(contents), errorCorrectionLevel, code);, +    ByteMatrix input = code.getMatrix();, +++ b/core/src/com/google/zxing/qrcode/encoder/BitVector.java, +    final int numBitsInLastByte = sizeInBits & 0x7;, +    if (numBitsInLastByte == 0) {, +    array[sizeInBits >> 3] |= (bit << (7 - numBitsInLastByte));, +  // Append "numBits" bits in "value" to the bit vector., +  // REQUIRES: 0<= numBits <= 32., +  public void appendBits(final int value, final int numBits) {, +    if (numBits < 0 || numBits > 32) {, +    int numBitsLeft = numBits;, +    while (numBitsLeft > 0) {, +      if ((sizeInBits & 0x7) == 0 && numBitsLeft >= 8) {, +        final int newByte = (value >> (numBitsLeft - 8)) & 0xff;, +        numBitsLeft -= 8;, +        final int bit = (value >> (numBitsLeft - 1)) & 1;, +        --numBitsLeft;, +++ b/core/src/com/google/zxing/qrcode/encoder/Encoder.java, +  private static final int[] ALPHANUMERIC_TABLE = {, +    final int numBytes;, +    final int[][] blockInfo;, +    public RSBlockInfo(int numBytes, int[][] blockInfo) {, +      this.numBytes = numBytes;, +      this.blockInfo = blockInfo;, +  // The table is from table 12 of JISX0510:2004 (p. 30). The "blockInfo" parts are ordered by, +  // L, M, Q, H. Within each blockInfo, the 0th element is getNumECBytes, and the 1st element is, +  // getNumRSBlocks. The table was doublechecked by komatsu., +  private static final RSBlockInfo[] RS_BLOCK_TABLE = {, +  // Encode "bytes" with the error correction level "getECLevel". The encoding mode will be chosen, +  // internally by chooseMode(). On success, store the result in "qrCode" and return true. On, +  // "getECLevel" since our primary use is to show QR code on desktop screens. We don't need very, +  public static void encode(final ByteArray bytes, int ecLevel, QRCode qrCode) throws WriterException {, +    final int mode = chooseMode(bytes);, +    // Step 2: Append "bytes" into "dataBits" in appropriate encoding., +    BitVector dataBits = new BitVector();, +    appendBytes(bytes, mode, dataBits);, +    // Step 3: Initialize QR code that can contain "dataBits"., +    final int numInputBytes = dataBits.sizeInBytes();, +    initQRCode(numInputBytes, ecLevel, mode, qrCode);, +    BitVector headerAndDataBits = new BitVector();, +    appendModeInfo(qrCode.getMode(), headerAndDataBits);, +    appendLengthInfo(bytes.size(), qrCode.getVersion(), qrCode.getMode(), headerAndDataBits);, +    headerAndDataBits.appendBitVector(dataBits);, +    terminateBits(qrCode.getNumDataBytes(), headerAndDataBits);, +    BitVector finalBits = new BitVector();, +    interleaveWithECBytes(headerAndDataBits, qrCode.getNumTotalBytes(), qrCode.getNumDataBytes(),, +        qrCode.getNumRSBlocks(), finalBits);, +    // Step 7: Choose the mask pattern and set to "qrCode"., +    ByteMatrix matrix = new ByteMatrix(qrCode.getMatrixWidth(), qrCode.getMatrixWidth());, +    qrCode.setMaskPattern(chooseMaskPattern(finalBits, qrCode.getECLevel(), qrCode.getVersion(),, +    // Step 8.  Build the matrix and set it to "qrCode"., +    MatrixUtil.buildMatrix(finalBits, qrCode.getECLevel(), qrCode.getVersion(),, +        qrCode.getMaskPattern(), matrix);, +    qrCode.setMatrix(matrix);, +    if (!qrCode.isValid()) {, +      throw new WriterException("Invalid QR code: " + qrCode.toString());, +  static int getAlphanumericCode(int code) {, +    if (code < ALPHANUMERIC_TABLE.length) {, +      return ALPHANUMERIC_TABLE[code];, +  public static int chooseMode(final ByteArray bytes) throws WriterException {, +    boolean hasNumeric = false;, +    boolean hasAlphanumeric = false;, +    boolean hasOther = false;, +        hasNumeric = true;, +      } else if (getAlphanumericCode(oneByte) != -1) {, +        hasAlphanumeric = true;, +        hasOther = true;, +    if (hasOther) {, +    } else if (hasAlphanumeric) {, +    } else if (hasNumeric) {, +  private static int chooseMaskPattern(final BitVector bits, int ecLevel, int version,, +    if (!QRCode.isValidMatrixWidth(matrix.width())) {, +    int minPenalty = Integer.MAX_VALUE;  // Lower penalty is better., +    int bestMaskPattern = -1;, +    for (int maskPattern = 0; maskPattern < QRCode.NUM_MASK_PATTERNS; maskPattern++) {, +      MatrixUtil.buildMatrix(bits, ecLevel, version, maskPattern, matrix);, +      final int penalty = MaskUtil.calculateMaskPenalty(matrix);, +      if (penalty < minPenalty) {]