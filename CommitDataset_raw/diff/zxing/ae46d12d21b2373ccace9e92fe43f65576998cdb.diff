[+++ b/core/src/com/google/zxing/common/reedsolomon/ReedSolomonDecoder.java, +   * @param dataMatrix if true, then uses a calculation that matches the Data Matrix, +   *  standard rather than the one used in QR Code, +   * @throws ReedSolomonException if decoding fails for any reason, +  public void decode(int[] received, int twoS, boolean dataMatrix) throws ReedSolomonException {, +      // This difference in syndrome calculation appears to be correct, but then causes issues below, +      int eval = poly.evaluateAt(field.exp(dataMatrix ? i + 1 : i));, +    if (dataMatrix) {, +      // TODO Not clear this is correct for DataMatrix, but it gives almost-correct behavior;, +      // works except when number of errors is the maximum allowable., +      syndrome = syndrome.multiply(field.buildMonomial(1, 1));, +    }, +    GF256Poly sigma = sigmaOmega[0];, +    GF256Poly omega = sigmaOmega[1];, +    int[] errorLocations = findErrorLocations(sigma);, +    int[] errorMagnitudes = findErrorMagnitudes(omega, errorLocations);, +++ b/core/src/com/google/zxing/common/reedsolomon/ReedSolomonDecoder.java, +   * @param dataMatrix if true, then uses a calculation that matches the Data Matrix, +   *  standard rather than the one used in QR Code, +   * @throws ReedSolomonException if decoding fails for any reason, +  public void decode(int[] received, int twoS, boolean dataMatrix) throws ReedSolomonException {, +      // This difference in syndrome calculation appears to be correct, but then causes issues below, +      int eval = poly.evaluateAt(field.exp(dataMatrix ? i + 1 : i));, +    if (dataMatrix) {, +      // TODO Not clear this is correct for DataMatrix, but it gives almost-correct behavior;, +      // works except when number of errors is the maximum allowable., +      syndrome = syndrome.multiply(field.buildMonomial(1, 1));, +    }, +    GF256Poly sigma = sigmaOmega[0];, +    GF256Poly omega = sigmaOmega[1];, +    int[] errorLocations = findErrorLocations(sigma);, +    int[] errorMagnitudes = findErrorMagnitudes(omega, errorLocations);, +++ b/core/src/com/google/zxing/datamatrix/decoder/Decoder.java, +      rsDecoder.decode(codewordsInts, numECCodewords, true);, +++ b/core/src/com/google/zxing/common/reedsolomon/ReedSolomonDecoder.java, +   * @param dataMatrix if true, then uses a calculation that matches the Data Matrix, +   *  standard rather than the one used in QR Code, +   * @throws ReedSolomonException if decoding fails for any reason, +  public void decode(int[] received, int twoS, boolean dataMatrix) throws ReedSolomonException {, +      // This difference in syndrome calculation appears to be correct, but then causes issues below, +      int eval = poly.evaluateAt(field.exp(dataMatrix ? i + 1 : i));, +    if (dataMatrix) {, +      // TODO Not clear this is correct for DataMatrix, but it gives almost-correct behavior;, +      // works except when number of errors is the maximum allowable., +      syndrome = syndrome.multiply(field.buildMonomial(1, 1));, +    }, +    GF256Poly sigma = sigmaOmega[0];, +    GF256Poly omega = sigmaOmega[1];, +    int[] errorLocations = findErrorLocations(sigma);, +    int[] errorMagnitudes = findErrorMagnitudes(omega, errorLocations);, +++ b/core/src/com/google/zxing/datamatrix/decoder/Decoder.java, +      rsDecoder.decode(codewordsInts, numECCodewords, true);, +++ b/core/src/com/google/zxing/qrcode/decoder/Decoder.java, +      rsDecoder.decode(codewordsInts, numECCodewords, false);, +++ b/core/src/com/google/zxing/common/reedsolomon/ReedSolomonDecoder.java, +   * @param dataMatrix if true, then uses a calculation that matches the Data Matrix, +   *  standard rather than the one used in QR Code, +   * @throws ReedSolomonException if decoding fails for any reason, +  public void decode(int[] received, int twoS, boolean dataMatrix) throws ReedSolomonException {, +      // This difference in syndrome calculation appears to be correct, but then causes issues below, +      int eval = poly.evaluateAt(field.exp(dataMatrix ? i + 1 : i));, +    if (dataMatrix) {, +      // TODO Not clear this is correct for DataMatrix, but it gives almost-correct behavior;, +      // works except when number of errors is the maximum allowable., +      syndrome = syndrome.multiply(field.buildMonomial(1, 1));, +    }, +    GF256Poly sigma = sigmaOmega[0];, +    GF256Poly omega = sigmaOmega[1];, +    int[] errorLocations = findErrorLocations(sigma);, +    int[] errorMagnitudes = findErrorMagnitudes(omega, errorLocations);, +++ b/core/src/com/google/zxing/datamatrix/decoder/Decoder.java, +      rsDecoder.decode(codewordsInts, numECCodewords, true);, +++ b/core/src/com/google/zxing/qrcode/decoder/Decoder.java, +      rsDecoder.decode(codewordsInts, numECCodewords, false);, +++ b/core/test/src/com/google/zxing/common/reedsolomon/ReedSolomonDecoderDataMatrixTestCase.java, +/*, + * Copyright 2008 ZXing authors, + *, + * Licensed under the Apache License, Version 2.0 (the "License");, + * you may not use this file except in compliance with the License., + * You may obtain a copy of the License at, + *, + *      http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS,, + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied., + * See the License for the specific language governing permissions and, + * limitations under the License., + */, +, +package com.google.zxing.common.reedsolomon;, +, +import junit.framework.TestCase;, +, +import java.util.BitSet;, +import java.util.Random;, +, +/**, + * @author srowen@google.com (Sean Owen)]