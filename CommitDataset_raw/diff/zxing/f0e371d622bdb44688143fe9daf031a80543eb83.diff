[+++ b/symbian/QQrDecoder/MyVideoSurface.cpp, +, +    timer = new QTimer(this);, +    connect(timer, SIGNAL(timeout()), this, SLOT(sendImageToDecode()));, +    timer->start(500);, +void MyVideoSurface::sendImageToDecode(), +{, +    if (m_frame.map(QAbstractVideoBuffer::ReadOnly)) {, +        QImage image(, +                m_frame.bits(),, +                m_frame.width(),, +                m_frame.height(),, +                m_frame.bytesPerLine(),, +                m_imageFormat);, +, +        if (!image.isNull()), +            emit imageCaptured(image);, +, +        m_frame.unmap();, +    }, +}, +, +++ b/symbian/QQrDecoder/MyVideoSurface.cpp, +, +    timer = new QTimer(this);, +    connect(timer, SIGNAL(timeout()), this, SLOT(sendImageToDecode()));, +    timer->start(500);, +void MyVideoSurface::sendImageToDecode(), +{, +    if (m_frame.map(QAbstractVideoBuffer::ReadOnly)) {, +        QImage image(, +                m_frame.bits(),, +                m_frame.width(),, +                m_frame.height(),, +                m_frame.bytesPerLine(),, +                m_imageFormat);, +, +        if (!image.isNull()), +            emit imageCaptured(image);, +, +        m_frame.unmap();, +    }, +}, +, +++ b/symbian/QQrDecoder/QCameraControllerWidget.cpp, +, +    zoomIn = new Button(this);, +    QObject::connect(zoomIn, SIGNAL(pressed()), this, SLOT(onZoomIn()));, +    QPixmap p = QPixmap(":/icons/zoomIn");, +    zoomIn->setPixmap(p.scaled(iconSize, Qt::KeepAspectRatio, Qt::SmoothTransformation));, +    vboxl->addWidget(zoomIn);, +    vboxl->setAlignment(zoomIn,Qt::AlignTop | Qt::AlignHCenter);, +    zoomOut = new Button(this);, +    QObject::connect(zoomOut, SIGNAL(pressed()), this, SLOT(onZoomOut()));, +    p = QPixmap(":/icons/zoomOut");, +    zoomOut->setPixmap(p.scaled(iconSize, Qt::KeepAspectRatio, Qt::SmoothTransformation));, +    vboxl->addWidget(zoomOut);, +    vboxl->setAlignment(zoomOut, Qt::AlignBottom | Qt::AlignHCenter);, +    //hboxl->addLayout(vboxl);, +    hboxl->addWidget(m_stackedWidget);, +, +    connect(m_camera, SIGNAL(stateChanged( QCamera::State) ), this, SLOT(onStateChanged(QCamera::State)));, +, +    connect(m_myVideoSurface, SIGNAL(imageCaptured(QImage)), this, SLOT(redirectImageSignalFromVideoFinder(QImage)));, +, +, +    cameraFocus = m_camera->focus();, +  //  cameraFocus->setFocusMode(QCameraFocus::ContinuousFocus);, +  //  cameraFocus->setFocusPointMode(QCameraFocus::FocusPointAuto);, +//        if (pictureCaptured) {, +//            // Paint captured image, +//            QPoint centerPic((qAbs(r.size().width() - m_capturedImage.size().width())) / 2, (qAbs(, +//                r.size().height() - m_capturedImage.size().height())) / 2);, +//            painter.drawImage(centerPic, m_capturedImage);, +//            // Paint filename, +//           // painter.drawText(r, Qt::AlignBottom | Qt::AlignCenter, m_imageName);, +//        }, +void QCameraControllerWidget::redirectImageSignalFromVideoFinder(QImage image), +{, +    emit imageCaptured(image);, +void QCameraControllerWidget::onZoomIn(), +{, +    qreal optical = cameraFocus->opticalZoom();, +    qreal digital = cameraFocus->digitalZoom();, +, +    if(optical == cameraFocus->maximumOpticalZoom()), +        cameraFocus->zoomTo(optical, digital + 0.1);, +    else, +        cameraFocus->zoomTo(optical + 0.1, 1.0);, +}, +, +void QCameraControllerWidget::onZoomOut(), +{, +    qreal optical = cameraFocus->opticalZoom();, +    qreal digital = cameraFocus->digitalZoom();, +, +, +    if(optical == cameraFocus->maximumOpticalZoom() && digital != 0.0), +    {, +        if(digital - 0.1 >= 1)]