[+++ b/AUTHORS, +David Walker (Google), +++ b/AUTHORS, +David Walker (Google), +++ b/android/src/com/google/zxing/client/android/DecodeFormatManager.java, +                               BarcodeFormat.ITF,, +                               BarcodeFormat.CODABAR);, +++ b/AUTHORS, +David Walker (Google), +++ b/android/src/com/google/zxing/client/android/DecodeFormatManager.java, +                               BarcodeFormat.ITF,, +                               BarcodeFormat.CODABAR);, +++ b/core/src/com/google/zxing/MultiFormatReader.java, +          formats.contains(BarcodeFormat.CODABAR) ||, +++ b/AUTHORS, +David Walker (Google), +++ b/android/src/com/google/zxing/client/android/DecodeFormatManager.java, +                               BarcodeFormat.ITF,, +                               BarcodeFormat.CODABAR);, +++ b/core/src/com/google/zxing/MultiFormatReader.java, +          formats.contains(BarcodeFormat.CODABAR) ||, +++ b/core/src/com/google/zxing/oned/CodaBarReader.java, + * @author David Walker, +  // These values are critical for determining how permissive the decoding, +  // will be. All stripe sizes must be within the window these define, as, +  // compared to the average stripe size., +  private static final int MAX_ACCEPTABLE = (int) (PATTERN_MATCH_RESULT_SCALE_FACTOR * 2.0f);, +  private static final int PADDING = (int) (PATTERN_MATCH_RESULT_SCALE_FACTOR * 1.5f);, +, +  private static final String ALPHABET_STRING = "0123456789-$:/.+ABCD";, +   * each int correspond to the pattern of wide and narrow, with 1s representing "wide" and 0s representing narrow., +  // under normal circumstances this should be set to 3, but can be set higher, +  // as a last-ditch attempt to reduce false positives., +  private static final int MIN_CHARACTER_LENGTH = 3;, +  private static final char[] STARTEND_ENCODING = {'A', 'B', 'C', 'D'};, +  // some codabar generator allow the codabar string to be closed by every, +  // character. This will cause lots of false positives!, +  // Keep some instance variables to avoid reallocations, +  private final StringBuilder decodeRowResult;, +  private int[] counters;, +  private int counterLength;, +, +  public CodaBarReader() {, +    decodeRowResult = new StringBuilder(20);, +    counters = new int[80];, +    counterLength = 0;, +  }, +, +  public Result decodeRow(int rowNumber, BitArray row, Map<DecodeHintType,?> hints) throws NotFoundException {, +    setCounters(row);, +    int startOffset = findStartPattern();, +    int nextStart = startOffset;, +    decodeRowResult.setLength(0);, +      int charOffset = toNarrowWidePattern(nextStart);, +      if (charOffset == -1) {, +      // Hack: We store the position in the alphabet table into a, +      // StringBuilder, so that we can access the decoded patterns in, +      // validatePattern. We'll translate to the actual characters later., +      decodeRowResult.append((char)charOffset);, +      nextStart += 8;, +      // Stop as soon as we see the end character., +      if (decodeRowResult.length() > 1 &&, +          arrayContains(STARTEND_ENCODING, ALPHABET[charOffset])) {, +    } while (nextStart < counterLength); // no fixed end pattern so keep on reading while data is available, +, +    // Look for whitespace after pattern:, +    int trailingWhitespace = counters[nextStart - 1];, +    int lastPatternSize = 0;, +    for (int i = -8; i < -1; i++) {, +      lastPatternSize += counters[nextStart + i];, +    // We need to see whitespace equal to 50% of the last pattern size,, +    // otherwise this is probably a false positive. The exception is if we are, +    // at the end of the row. (I.e. the barcode barely fits.), +    if (nextStart < counterLength && trailingWhitespace < lastPatternSize / 2) {, +      throw NotFoundException.getNotFoundInstance();, +    }, +, +    validatePattern(startOffset);, +, +    // Translate character table offsets to actual characters., +    for (int i = 0; i < decodeRowResult.length(); i++) {, +      decodeRowResult.setCharAt(i, ALPHABET[decodeRowResult.charAt(i)]);, +    }, +    // Ensure a valid start and end character, +    char startchar = decodeRowResult.charAt(0);, +    if (!arrayContains(STARTEND_ENCODING, startchar)) {, +      throw NotFoundException.getNotFoundInstance();, +    }, +    char endchar = decodeRowResult.charAt(decodeRowResult.length() - 1);, +    if (!arrayContains(STARTEND_ENCODING, endchar)) {, +      throw NotFoundException.getNotFoundInstance();, +    }, +, +    // remove stop/start characters character and check if a long enough string is contained, +    if (decodeRowResult.length() <= MIN_CHARACTER_LENGTH) {, +    decodeRowResult.deleteCharAt(decodeRowResult.length() - 1);, +    decodeRowResult.deleteCharAt(0);, +    int runningCount = 0;, +    for (int i = 0; i < startOffset; i++) {, +      runningCount += counters[i];]