[+++ b/AUTHORS, +David Phillip Oster (Google), +++ b/AUTHORS, +David Phillip Oster (Google), +++ b/cpp/core/src/zxing/Binarizer.h, +  Ref<BitMatrix> matrix_;, +++ b/AUTHORS, +David Phillip Oster (Google), +++ b/cpp/core/src/zxing/Binarizer.h, +  Ref<BitMatrix> matrix_;, +++ b/cpp/core/src/zxing/common/GlobalHistogramBinarizer.cpp, +Ref<BitArray> GlobalHistogramBinarizer::estimateBlackRow(int y,, +  Ref<BitArray> row){, +  if (row == NULL || static_cast<int>(row->getSize()) < width) {, +  // Quickly calculates the histogram by sampling four rows from the image., +  // This proved to be more robust on the blackbox tests than sampling a, +  // diagonal as we used to do., +  // Kind of arbitrary; if the two peaks are very close, then we figure there is, +  // so little dynamic range in the image, that discriminating black and white, +  // is too error-prone., +  // Decoding the image/line is either pointless, or may in some cases lead to, +  // a false positive for 1D formats, which are relatively lenient., +  // We arbitrarily say "close" is, +  // "<= 1/16 of the total histogram buckets apart", +    // Favor a "valley" that is not too close to either peak -- especially not, +    // the black peak -- and that has a low value of course, +    int score = fromFirst * fromFirst * (secondPeak - i) *, +      (maxBucketCount - histogram[i]);, +} // namespace zxing, +, +++ b/AUTHORS, +David Phillip Oster (Google), +++ b/cpp/core/src/zxing/Binarizer.h, +  Ref<BitMatrix> matrix_;, +++ b/cpp/core/src/zxing/common/GlobalHistogramBinarizer.cpp, +Ref<BitArray> GlobalHistogramBinarizer::estimateBlackRow(int y,, +  Ref<BitArray> row){, +  if (row == NULL || static_cast<int>(row->getSize()) < width) {, +  // Quickly calculates the histogram by sampling four rows from the image., +  // This proved to be more robust on the blackbox tests than sampling a, +  // diagonal as we used to do., +  // Kind of arbitrary; if the two peaks are very close, then we figure there is, +  // so little dynamic range in the image, that discriminating black and white, +  // is too error-prone., +  // Decoding the image/line is either pointless, or may in some cases lead to, +  // a false positive for 1D formats, which are relatively lenient., +  // We arbitrarily say "close" is, +  // "<= 1/16 of the total histogram buckets apart", +    // Favor a "valley" that is not too close to either peak -- especially not, +    // the black peak -- and that has a low value of course, +    int score = fromFirst * fromFirst * (secondPeak - i) *, +      (maxBucketCount - histogram[i]);, +} // namespace zxing, +, +++ b/cpp/core/src/zxing/common/PerspectiveTransform.cpp, +  a11(inA11), a12(inA12), a13(inA13), a21(inA21), a22(inA22), a23(inA23),, +  a31(inA31), a32(inA32), a33(inA33) {}, +++ b/AUTHORS, +David Phillip Oster (Google), +++ b/cpp/core/src/zxing/Binarizer.h, +  Ref<BitMatrix> matrix_;, +++ b/cpp/core/src/zxing/common/GlobalHistogramBinarizer.cpp, +Ref<BitArray> GlobalHistogramBinarizer::estimateBlackRow(int y,, +  Ref<BitArray> row){, +  if (row == NULL || static_cast<int>(row->getSize()) < width) {, +  // Quickly calculates the histogram by sampling four rows from the image., +  // This proved to be more robust on the blackbox tests than sampling a, +  // diagonal as we used to do., +  // Kind of arbitrary; if the two peaks are very close, then we figure there is, +  // so little dynamic range in the image, that discriminating black and white, +  // is too error-prone., +  // Decoding the image/line is either pointless, or may in some cases lead to, +  // a false positive for 1D formats, which are relatively lenient., +  // We arbitrarily say "close" is, +  // "<= 1/16 of the total histogram buckets apart", +    // Favor a "valley" that is not too close to either peak -- especially not, +    // the black peak -- and that has a low value of course, +    int score = fromFirst * fromFirst * (secondPeak - i) *, +      (maxBucketCount - histogram[i]);, +} // namespace zxing, +, +++ b/cpp/core/src/zxing/common/PerspectiveTransform.cpp, +  a11(inA11), a12(inA12), a13(inA13), a21(inA21), a22(inA22), a23(inA23),, +  a31(inA31), a32(inA32), a33(inA33) {}, +++ b/cpp/core/src/zxing/datamatrix/decoder/BitMatrixParser.cpp, +BitMatrixParser::BitMatrixParser(Ref<BitMatrix> bitMatrix) : bitMatrix_(NULL),, +                                                             parsedVersion_(NULL),, +++ b/AUTHORS, +David Phillip Oster (Google), +++ b/cpp/core/src/zxing/Binarizer.h, +  Ref<BitMatrix> matrix_;, +++ b/cpp/core/src/zxing/common/GlobalHistogramBinarizer.cpp, +Ref<BitArray> GlobalHistogramBinarizer::estimateBlackRow(int y,, +  Ref<BitArray> row){, +  if (row == NULL || static_cast<int>(row->getSize()) < width) {, +  // Quickly calculates the histogram by sampling four rows from the image., +  // This proved to be more robust on the blackbox tests than sampling a, +  // diagonal as we used to do., +  // Kind of arbitrary; if the two peaks are very close, then we figure there is, +  // so little dynamic range in the image, that discriminating black and white]