[+++ b/core/src/com/google/zxing/MultiFormatReader.java, +    Hashtable possibleFormats = hints == null ? null : (Hashtable) hints.get(DecodeHintType.POSSIBLE_FORMATS);, +      throw new ReaderException("POSSIBLE_FORMATS specifies no supported types");, +    throw new ReaderException("Could not locate and decode a barcode in the image");, +++ b/core/src/com/google/zxing/MultiFormatReader.java, +    Hashtable possibleFormats = hints == null ? null : (Hashtable) hints.get(DecodeHintType.POSSIBLE_FORMATS);, +      throw new ReaderException("POSSIBLE_FORMATS specifies no supported types");, +    throw new ReaderException("Could not locate and decode a barcode in the image");, +++ b/core/src/com/google/zxing/common/BitArray.java, +    int size = this.size;, +      if (get(size - i - 1)) {, +  private static int[] makeArray(int size) {, +    return new int[arraySize];, +++ b/core/src/com/google/zxing/MultiFormatReader.java, +    Hashtable possibleFormats = hints == null ? null : (Hashtable) hints.get(DecodeHintType.POSSIBLE_FORMATS);, +      throw new ReaderException("POSSIBLE_FORMATS specifies no supported types");, +    throw new ReaderException("Could not locate and decode a barcode in the image");, +++ b/core/src/com/google/zxing/common/BitArray.java, +    int size = this.size;, +      if (get(size - i - 1)) {, +  private static int[] makeArray(int size) {, +    return new int[arraySize];, +++ b/core/src/com/google/zxing/upc/UPCDecoder.java, +final class UPCDecoder {, +, +  private static final byte[] BITMAP_SEARCH_PATTERN = { 50, 49, 51, 48, 52, 46, 54, 43, 57, 40, 60 };, +  private static final byte[] START_END_PATTERN = { 1, 1, 1 };, +  private static final byte[] MIDDLE_PATTERN = { 1, 1, 1, 1, 1 };, +  private static final byte[][] DIGIT_PATTERNS = {, +    { 30, 20, 10, 10 }, // 0, +    { 20, 20, 20, 10 }, // 1, +    { 20, 10, 20, 20 }, // 2, +    { 10, 40, 10, 10 }, // 3, +    { 10, 10, 30, 20 }, // 4, +    { 10, 20, 30, 10 }, // 5, +    { 10, 10, 10, 40 }, // 6, +    { 10, 30, 10, 20 }, // 7, +    { 10, 20, 10, 30 }, // 8, +    { 30, 10, 10, 20 }  // 9, +  };, +  private static final int TOLERANCE = 5;, +, +  private MonochromeBitmapSource bitmap;, +  private int width;, +  private int height;, +  private StringBuffer result;, +, +	  this.bitmap = bitmap;, +    width = bitmap.getWidth();, +    height = bitmap.getHeight();, +  String decode() {, +    BitArray rowData = new BitArray(width);, +    for (int x = 0; x < BITMAP_SEARCH_PATTERN.length; x++) {, +      int row = height * BITMAP_SEARCH_PATTERN[x] / 100;, +      bitmap.getBlackRow(row, rowData, 0, width);, +      if (result.length() > longestResult.length()) {, +        longestResult = result.toString();, +      if (result.length() > longestResult.length()) {, +        longestResult = result.toString();, +    if (found >= 0) {, +      return result.toString();, +    } else {, +      return "";, +    }, +  /**, +   * UPC-A bar codes are made up of a left marker, six digits, a middle marker, six more digits,, +   * and an end marker, reading from left to right. For more information, see:, +   * <a href="http://en.wikipedia.org/wiki/Universal_Product_Code">, +   * http://en.wikipedia.org/wiki/Universal_Product_Code</a>, +   */, +  private boolean decodeRow(BitArray rowData) {, +    result = new StringBuffer();, +    int rowOffset = findPattern(rowData, 0, START_END_PATTERN, false);, +    if (rowOffset < 0) {, +      return false;, +    }, +    if (rowOffset < 0) {, +      return false;, +    }, +    rowOffset = findPattern(rowData, rowOffset, MIDDLE_PATTERN, true);, +    if (rowOffset < 0) {, +      return false;, +    }, +    if (rowOffset < 0) {, +      return false;, +    }, +    return result.length() == 12;, +    for (int x = 0; x < 6 && rowOffset < width; x++) {, +        result.append(c);, +    int width = this.width;, +    while (rowOffset < width) {, +      rowOffset++;, +  /**, +   * Records a pattern of alternating white and black pixels, returning an array of how many, +   * pixels of each color were seen. The pattern begins immediately based on the color of the, +   * first pixel encountered, so a patternSize of 3 could result in WBW or BWB., +   */, +    for (int i = 0; i < counters.length; i++) {, +      counters[i] = 0;, +    }]