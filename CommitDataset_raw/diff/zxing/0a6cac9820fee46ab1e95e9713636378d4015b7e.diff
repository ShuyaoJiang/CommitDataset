[+++ b/core/src/com/google/zxing/common/HybridBinarizer.java, +        if ((width & 0x07) != 0) {, +          subWidth++;, +        }, +        if ((height & 0x07) != 0) {, +          subHeight++;, +        }, +        int[][] blackPoints = calculateBlackPoints(luminances, subWidth, subHeight, width, height);, +        calculateThresholdForBlock(luminances, subWidth, subHeight, width, height, blackPoints, matrix);, +  // of the blocks around it. Also handles the corner cases (fractional blocks are computed based, +  // on the last 8 pixels in the row/column which are also used in the previous block)., +      int width, int height, int[][] blackPoints, BitMatrix matrix) {, +      int yoffset = y << 3;, +      if ((yoffset + 8) >= height) {, +        yoffset = height - 8;, +      }, +        int xoffset = x << 3;, +        if ((xoffset + 8) >= width) {, +            xoffset = width - 8;, +        }, +        threshold8x8Block(luminances, xoffset, yoffset, average, width, matrix);, +      int width, int height) {, +      int yoffset = y << 3;, +      if ((yoffset + 8) >= height) {, +        yoffset = height - 8;, +      }, +        int xoffset = x << 3;, +        if ((xoffset + 8) >= width) {, +            xoffset = width - 8;, +        }, +          int offset = (yoffset + yy) * width + xoffset;, +++ b/core/src/com/google/zxing/common/HybridBinarizer.java, +        if ((width & 0x07) != 0) {, +          subWidth++;, +        }, +        if ((height & 0x07) != 0) {, +          subHeight++;, +        }, +        int[][] blackPoints = calculateBlackPoints(luminances, subWidth, subHeight, width, height);, +        calculateThresholdForBlock(luminances, subWidth, subHeight, width, height, blackPoints, matrix);, +  // of the blocks around it. Also handles the corner cases (fractional blocks are computed based, +  // on the last 8 pixels in the row/column which are also used in the previous block)., +      int width, int height, int[][] blackPoints, BitMatrix matrix) {, +      int yoffset = y << 3;, +      if ((yoffset + 8) >= height) {, +        yoffset = height - 8;, +      }, +        int xoffset = x << 3;, +        if ((xoffset + 8) >= width) {, +            xoffset = width - 8;, +        }, +        threshold8x8Block(luminances, xoffset, yoffset, average, width, matrix);, +      int width, int height) {, +      int yoffset = y << 3;, +      if ((yoffset + 8) >= height) {, +        yoffset = height - 8;, +      }, +        int xoffset = x << 3;, +        if ((xoffset + 8) >= width) {, +            xoffset = width - 8;, +        }, +          int offset = (yoffset + yy) * width + xoffset;, +++ b/cpp/core/src/zxing/common/HybridBinarizer.cpp, +      if (width & 0x07) {, +        subWidth++;, +      }, +      if (height & 0x07) {, +        subHeight++;, +      }, +      int *blackPoints = calculateBlackPoints(luminances, subWidth, subHeight, width, height);, +      calculateThresholdForBlock(luminances, subWidth, subHeight, width, height, blackPoints, cached_matrix_);, +    int width, int height, int blackPoints[], Ref<BitMatrix> matrix) {, +    int yoffset = y << 3;, +    if (yoffset + 8 >= height) {, +      yoffset = height - 8;, +    }, +      int xoffset = x << 3;, +      if (xoffset + 8 >= width) {, +        xoffset = width - 8;, +      }, +      threshold8x8Block(luminances, xoffset, yoffset, average, width, matrix);, +    int width, int height) {, +    int yoffset = y << 3;, +    if (yoffset + 8 >= height) {, +      yoffset = height - 8;, +    }, +      int xoffset = x << 3;, +      if (xoffset + 8 >= width) {, +        xoffset = width - 8;, +      }, +        int offset = (yoffset + yy) * width + xoffset;, +++ b/core/src/com/google/zxing/common/HybridBinarizer.java, +        if ((width & 0x07) != 0) {, +          subWidth++;, +        }, +        if ((height & 0x07) != 0) {, +          subHeight++;, +        }, +        int[][] blackPoints = calculateBlackPoints(luminances, subWidth, subHeight, width, height);, +        calculateThresholdForBlock(luminances, subWidth, subHeight, width, height, blackPoints, matrix);]