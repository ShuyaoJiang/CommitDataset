[+++ b/android/build.xml, +++ b/android/build.xml, +++ b/android/src/com/google/zxing/client/android/AndroidGraphicsGridSampler.java, +/*, + * Copyright 2007 Google Inc., + *, + * Licensed under the Apache License, Version 2.0 (the "License");, + * you may not use this file except in compliance with the License., + * You may obtain a copy of the License at, + *, + *      http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS,, + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied., + * See the License for the specific language governing permissions and, + * limitations under the License., + */, +, +package com.google.zxing.client.android;, +, +import com.google.zxing.MonochromeBitmapSource;, +import com.google.zxing.ReaderException;, +import com.google.zxing.common.BitMatrix;, +import com.google.zxing.qrcode.detector.AlignmentPattern;, +import com.google.zxing.qrcode.detector.FinderPattern;, +import com.google.zxing.qrcode.detector.GridSampler;, +, +import android.graphics.Matrix;, +, +/**, + * Implementation based on Android's, + * {@link Matrix#setPolyToPoly(float[], int, float[], int, int)}, + * class, which should offer faster performance for these matrix, + * operations., + * , + * @author srowen@google.com (Sean Owen), + */, +public final class AndroidGraphicsGridSampler extends GridSampler {, +, +  @Override, +  protected BitMatrix sampleGrid(MonochromeBitmapSource image,, +                                 FinderPattern topLeft,, +                                 FinderPattern topRight,, +                                 FinderPattern bottomLeft,, +                                 AlignmentPattern alignmentPattern,, +                                 int dimension) throws ReaderException {, +    float dimMinusThree = (float) dimension - 3.5f;, +    float bottomRightX, bottomRightY;, +    float sourceBottomRightX, sourceBottomRightY;, +    if (alignmentPattern != null) {, +      bottomRightX = alignmentPattern.getX();, +      bottomRightY = alignmentPattern.getY();, +      sourceBottomRightX = sourceBottomRightY = dimMinusThree - 3.0f;, +    } else {, +      // Don't have an alignment pattern, just make up the bottom-right point, +      bottomRightX = (topRight.getX() - topLeft.getX()) + bottomLeft.getX();, +      bottomRightY = (topRight.getY() - topLeft.getY()) + bottomLeft.getY();, +      sourceBottomRightX = sourceBottomRightY = dimMinusThree;, +    }, +, +    Matrix transformMatrix = new Matrix();, +    boolean succeeded = transformMatrix.setPolyToPoly(, +      new float[] {, +        topLeft.getX(),, +        topLeft.getY(),, +        topRight.getX(),, +        topRight.getY(),, +        bottomLeft.getX(),, +        bottomLeft.getY(),, +        bottomRightX,, +        bottomRightY, +      },, +      0,, +      new float[] {, +        3.5f,, +        3.5f,, +        dimMinusThree,, +        3.5f,, +        3.5f,, +        dimMinusThree,, +        sourceBottomRightX,, +        sourceBottomRightY,, +      },, +      0,, +      4, +    );, +    if (!succeeded) {, +      throw new ReaderException("Could not establish transformation matrix");, +    }, +, +    BitMatrix bits = new BitMatrix(dimension);, +    float[] points = new float[dimension << 1];, +    for (int i = 0; i < dimension; i++) {, +      int max = points.length;, +      float iValue = (float) i + 0.5f;, +      for (int j = 0; j < max; j += 2) {, +        points[j] = (float) (j >> 1) + 0.5f;, +        points[j + 1] = iValue;, +      }]