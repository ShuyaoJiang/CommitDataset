[+++ b/cpp/core/src/zxing/common/HybridBinarizer.cpp, +  const int BLOCK_SIZE = 1 << BLOCK_SIZE_POWER; // ...0100...00, +  const int BLOCK_SIZE_MASK = BLOCK_SIZE - 1;   // ...0011...11, +, +/**, + * Calculates the final BitMatrix once for all requests. This could be called once from the, + * constructor instead, but there are some advantages to doing it lazily, such as making, + * profiling easier, and not doing heavy lifting when callers don't expect it., + */, +  if (width >= MINIMUM_DIMENSION && height >= MINIMUM_DIMENSION) {, +    unsigned char* luminances = source.getMatrix();, +namespace {, +  inline int cap(int value, int min, int max) {, +    return value < min ? min : value > max ? max : value;, +  }, +}, +, +    int maxYOffset = height - BLOCK_SIZE;, +    if (yoffset > maxYOffset) {, +      yoffset = maxYOffset;, +      int maxXOffset = width - BLOCK_SIZE;, +      if (xoffset > maxXOffset) {, +        xoffset = maxXOffset;, +      int left = cap(x, 2, subWidth - 3);, +      int top = cap(y, 2, subHeight - 3);, +      thresholdBlock(luminances, xoffset, yoffset, average, width, matrix);, +void HybridBinarizer::thresholdBlock(unsigned char* luminances,, +int* HybridBinarizer::calculateBlackPoints(unsigned char* luminances,, +                                           int subWidth,, +                                           int subHeight,, +                                           int width,, +                                           int height) {, +    int maxYOffset = height - BLOCK_SIZE;, +    if (yoffset > maxYOffset) {, +      yoffset = maxYOffset;, +      int maxXOffset = width - BLOCK_SIZE;, +      if (xoffset > maxXOffset) {, +        xoffset = maxXOffset;, +++ b/cpp/core/src/zxing/common/HybridBinarizer.cpp, +  const int BLOCK_SIZE = 1 << BLOCK_SIZE_POWER; // ...0100...00, +  const int BLOCK_SIZE_MASK = BLOCK_SIZE - 1;   // ...0011...11, +, +/**, + * Calculates the final BitMatrix once for all requests. This could be called once from the, + * constructor instead, but there are some advantages to doing it lazily, such as making, + * profiling easier, and not doing heavy lifting when callers don't expect it., + */, +  if (width >= MINIMUM_DIMENSION && height >= MINIMUM_DIMENSION) {, +    unsigned char* luminances = source.getMatrix();, +namespace {, +  inline int cap(int value, int min, int max) {, +    return value < min ? min : value > max ? max : value;, +  }, +}, +, +    int maxYOffset = height - BLOCK_SIZE;, +    if (yoffset > maxYOffset) {, +      yoffset = maxYOffset;, +      int maxXOffset = width - BLOCK_SIZE;, +      if (xoffset > maxXOffset) {, +        xoffset = maxXOffset;, +      int left = cap(x, 2, subWidth - 3);, +      int top = cap(y, 2, subHeight - 3);, +      thresholdBlock(luminances, xoffset, yoffset, average, width, matrix);, +void HybridBinarizer::thresholdBlock(unsigned char* luminances,, +int* HybridBinarizer::calculateBlackPoints(unsigned char* luminances,, +                                           int subWidth,, +                                           int subHeight,, +                                           int width,, +                                           int height) {, +    int maxYOffset = height - BLOCK_SIZE;, +    if (yoffset > maxYOffset) {, +      yoffset = maxYOffset;, +      int maxXOffset = width - BLOCK_SIZE;, +      if (xoffset > maxXOffset) {, +        xoffset = maxXOffset;, +++ b/cpp/core/src/zxing/common/HybridBinarizer.h, +    void thresholdBlock(unsigned char* luminances,]