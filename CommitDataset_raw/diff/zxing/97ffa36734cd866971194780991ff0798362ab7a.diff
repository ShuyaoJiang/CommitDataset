[+++ b/core/src/com/google/zxing/qrcode/encoder/Encoder.java, +++ b/core/src/com/google/zxing/qrcode/encoder/Encoder.java, +++ b/core/src/com/google/zxing/qrcode/encoder/MaskUtil.java, +  // The mask penalty calculation is complicated.  See Table 21 of JISX0510:2004 (p.45) for details., +  // Basically it applies four rules and summate all penalties., +  // Apply mask penalty rule 1 and return the penalty. Find repetitive cells with the same color and, +  // give penalty to them. Example: 00000 or 11111., +  // Apply mask penalty rule 2 and return the penalty. Find 2x2 blocks with the same color and give, +  // penalty to them., +  // Apply mask penalty rule 3 and return the penalty. Find consecutive cells of 00001011101 or, +  // 10111010000, and give penalty to them.  If we find patterns like 000010111010000, we give, +  // Apply mask penalty rule 4 and return the penalty. Calculate the ratio of dark cells and give, +  // penalty if the ratio is far from 50%. It gives 10 penalty for 5% distance. Examples:, +  // Return the mask bit for "mask_pattern" at "x" and "y". See 8.8 of JISX0510:2004 for mask, +  // pattern conditions., +  // Helper function for ApplyMaskPenaltyRule1. We need this for doing this calculation in both, +  // vertical and horizontal orders respectively., +++ b/core/src/com/google/zxing/qrcode/encoder/Encoder.java, +++ b/core/src/com/google/zxing/qrcode/encoder/MaskUtil.java, +  // The mask penalty calculation is complicated.  See Table 21 of JISX0510:2004 (p.45) for details., +  // Basically it applies four rules and summate all penalties., +  // Apply mask penalty rule 1 and return the penalty. Find repetitive cells with the same color and, +  // give penalty to them. Example: 00000 or 11111., +  // Apply mask penalty rule 2 and return the penalty. Find 2x2 blocks with the same color and give, +  // penalty to them., +  // Apply mask penalty rule 3 and return the penalty. Find consecutive cells of 00001011101 or, +  // 10111010000, and give penalty to them.  If we find patterns like 000010111010000, we give, +  // Apply mask penalty rule 4 and return the penalty. Calculate the ratio of dark cells and give, +  // penalty if the ratio is far from 50%. It gives 10 penalty for 5% distance. Examples:, +  // Return the mask bit for "mask_pattern" at "x" and "y". See 8.8 of JISX0510:2004 for mask, +  // pattern conditions., +  // Helper function for ApplyMaskPenaltyRule1. We need this for doing this calculation in both, +  // vertical and horizontal orders respectively., +++ b/core/src/com/google/zxing/qrcode/encoder/MatrixUtil.java, +  // From Appendix E. Table 1, JIS0510X:2004 (p 71). The table was double-checked by komatsu., +  // Set all cells to -1.  -1 means that the cell is empty (not set yet)., +  // Build 2D matrix of QR Code from "data_bits" with "ec_level", "version" and "mask_pattern". On, +  // success, store the result in "matrix" and return true.  On error, return false., +  // Embed basic patterns. On success, modify the matrix and return true. On error, return false., +  // The basic patterns are:, +  // Embed type information. On success, modify the matrix and return true. On error, return false., +      // Place bits in LSB to MSB order.  LSB (least significant bit) is the last value in, +      // "type_info_bits"., +      // Type info bits at the left top corner. See 8.9 of JISX0510:2004 (p.46)., +  // Embed version information if need be. On success, modify the matrix and return true. On error,, +  // return false. See 8.10 of JISX0510:2004 (p.47) for how to embed version information. Return, +  // true on success, otherwise return false., +  // Embed "data_bits" using "mask_pattern". On success, modify the matrix and return true. On, +  // error, return false. For debugging purposes, it skips masking process if "mask_pattern" is -1., +            // Padding bit. If there is no bit left, we'll fill the left cells with 0, as described, +            // in 8.4.9 of JISX0510:2004 (p. 24)., +  // Return the position of the most significant bit set (to one) in the "value". The most, +  // significant bit is position 32. If there is no bit set, return 0. Examples:, +  // Calculate BCH (Bose-Chaudhuri-Hocquenghem) code for "value" using polynomial "poly". The BCH, +  // code is used for encoding type information and version information., +  // Since all coefficients in the polynomials are 1 or 0, we can do the calculation by bit, +  // operations. We don't care if cofficients are positive or negative., +    // If poly is "1 1111 0010 0101" (version info poly), msb_set_in_poly is 13. We'll subtract 1, +    // from 13 to make it 12., +  // Make bit vector of type information. On success, store the result in "bits" and return true., +  // On error, return false. Encode error correction level and mask pattern. See 8.9 of, +  // Make bit vector of version information. On success, store the result in "bits" and return true., +  // On error, return false. See 8.10 of JISX0510:2004 (p.45) for details., +    // -8 is for skipping position detection patterns (size 7), and two horizontal/vertical, +    // separation patterns (size 1). Thus, 8 = 7 + 1., +  // Embed the lonely dark dot at left bottom corner. JISX0510:2004 (p.46), +  // Embed position detection patterns and surrounding vertical/horizontal separators., +        // If the cell is unset, we embed the position adjustment pattern here., +          // -2 is necessary since the x/y coordinates point to the center of the pattern, not the, +          // left top corner., +++ b/core/src/com/google/zxing/qrcode/encoder/Encoder.java, +++ b/core/src/com/google/zxing/qrcode/encoder/MaskUtil.java, +  // The mask penalty calculation is complicated.  See Table 21 of JISX0510:2004 (p.45) for details., +  // Basically it applies four rules and summate all penalties., +  // Apply mask penalty rule 1 and return the penalty. Find repetitive cells with the same color and, +  // give penalty to them. Example: 00000 or 11111., +  // Apply mask penalty rule 2 and return the penalty. Find 2x2 blocks with the same color and give, +  // penalty to them., +  // Apply mask penalty rule 3 and return the penalty. Find consecutive cells of 00001011101 or, +  // 10111010000, and give penalty to them.  If we find patterns like 000010111010000, we give, +  // Apply mask penalty rule 4 and return the penalty. Calculate the ratio of dark cells and give, +  // penalty if the ratio is far from 50%. It gives 10 penalty for 5% distance. Examples:, +  // Return the mask bit for "mask_pattern" at "x" and "y". See 8.8 of JISX0510:2004 for mask, +  // pattern conditions., +  // Helper function for ApplyMaskPenaltyRule1. We need this for doing this calculation in both, +  // vertical and horizontal orders respectively., +++ b/core/src/com/google/zxing/qrcode/encoder/MatrixUtil.java, +  // From Appendix E. Table 1, JIS0510X:2004 (p 71). The table was double-checked by komatsu., +  // Set all cells to -1.  -1 means that the cell is empty (not set yet)., +  // Build 2D matrix of QR Code from "data_bits" with "ec_level", "version" and "mask_pattern". On, +  // success, store the result in "matrix" and return true.  On error, return false., +  // Embed basic patterns. On success, modify the matrix and return true. On error, return false., +  // The basic patterns are:, +  // Embed type information. On success, modify the matrix and return true. On error, return false., +      // Place bits in LSB to MSB order.  LSB (least significant bit) is the last value in, +      // "type_info_bits"., +      // Type info bits at the left top corner. See 8.9 of JISX0510:2004 (p.46)., +  // Embed version information if need be. On success, modify the matrix and return true. On error,, +  // return false. See 8.10 of JISX0510:2004 (p.47) for how to embed version information. Return, +  // true on success, otherwise return false.]