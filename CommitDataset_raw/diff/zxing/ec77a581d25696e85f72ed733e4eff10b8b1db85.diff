[+++ b/core/src/com/google/zxing/common/BaseMonochromeBitmapSource.java, +    int[] localLuminances = getLuminanceRow(y, luminances);, +      int left = localLuminances[startX];, +      int center = localLuminances[startX + 1];, +        int right = localLuminances[startX + x + 1];, +        if (localLuminances[startX + x] < blackPoint) {, +    int[] localLuminances = getLuminanceColumn(x, luminances);, +      if (localLuminances[startY + y] < blackPoint) {, +++ b/core/src/com/google/zxing/common/BaseMonochromeBitmapSource.java, +    int[] localLuminances = getLuminanceRow(y, luminances);, +      int left = localLuminances[startX];, +      int center = localLuminances[startX + 1];, +        int right = localLuminances[startX + x + 1];, +        if (localLuminances[startX + x] < blackPoint) {, +    int[] localLuminances = getLuminanceColumn(x, luminances);, +      if (localLuminances[startY + y] < blackPoint) {, +++ b/core/src/com/google/zxing/common/BlackPointEstimator.java, + * <a href="http://webdiis.unizar.es/~neira/12082/thresholding.pdf">this paper</a>.</p>, +      // We used to sample a diagonal in the 2D case, but it missed a lot of pixels, and it required, +      // n calls to getLuminance(). We had a net improvement of 63 blackbox tests decoded by, +      // sampling several rows from the middle of the image, using getLuminanceRow(). We read more, +      // pixels total, but with fewer function calls, and more continguous memory., +      for (int y = 1; y < 5; y++) {, +        int row = height * y / 5;, +        int[] localLuminances = source.getLuminanceRow(row, luminances);, +        int right = width * 4 / 5;, +        for (int x = width / 5; x < right; x++) {, +          histogram[localLuminances[x] >> LUMINANCE_SHIFT]++;, +        }, +      int[] localLuminances = source.getLuminanceRow(argument, luminances);, +        histogram[localLuminances[x] >> LUMINANCE_SHIFT]++;, +++ b/core/src/com/google/zxing/common/BaseMonochromeBitmapSource.java, +    int[] localLuminances = getLuminanceRow(y, luminances);, +      int left = localLuminances[startX];, +      int center = localLuminances[startX + 1];, +        int right = localLuminances[startX + x + 1];, +        if (localLuminances[startX + x] < blackPoint) {, +    int[] localLuminances = getLuminanceColumn(x, luminances);, +      if (localLuminances[startY + y] < blackPoint) {, +++ b/core/src/com/google/zxing/common/BlackPointEstimator.java, + * <a href="http://webdiis.unizar.es/~neira/12082/thresholding.pdf">this paper</a>.</p>, +      // We used to sample a diagonal in the 2D case, but it missed a lot of pixels, and it required, +      // n calls to getLuminance(). We had a net improvement of 63 blackbox tests decoded by, +      // sampling several rows from the middle of the image, using getLuminanceRow(). We read more, +      // pixels total, but with fewer function calls, and more continguous memory., +      for (int y = 1; y < 5; y++) {, +        int row = height * y / 5;, +        int[] localLuminances = source.getLuminanceRow(row, luminances);, +        int right = width * 4 / 5;, +        for (int x = width / 5; x < right; x++) {, +          histogram[localLuminances[x] >> LUMINANCE_SHIFT]++;, +        }, +      int[] localLuminances = source.getLuminanceRow(argument, luminances);, +        histogram[localLuminances[x] >> LUMINANCE_SHIFT]++;, +++ b/core/test/src/com/google/zxing/datamatrix/DataMatrixBlackBox2TestCase.java, +    addTest(2, 2, 0.0f);, +++ b/core/src/com/google/zxing/common/BaseMonochromeBitmapSource.java, +    int[] localLuminances = getLuminanceRow(y, luminances);, +      int left = localLuminances[startX];, +      int center = localLuminances[startX + 1];, +        int right = localLuminances[startX + x + 1];, +        if (localLuminances[startX + x] < blackPoint) {, +    int[] localLuminances = getLuminanceColumn(x, luminances);, +      if (localLuminances[startY + y] < blackPoint) {, +++ b/core/src/com/google/zxing/common/BlackPointEstimator.java, + * <a href="http://webdiis.unizar.es/~neira/12082/thresholding.pdf">this paper</a>.</p>, +      // We used to sample a diagonal in the 2D case, but it missed a lot of pixels, and it required, +      // n calls to getLuminance(). We had a net improvement of 63 blackbox tests decoded by, +      // sampling several rows from the middle of the image, using getLuminanceRow(). We read more, +      // pixels total, but with fewer function calls, and more continguous memory., +      for (int y = 1; y < 5; y++) {, +        int row = height * y / 5;, +        int[] localLuminances = source.getLuminanceRow(row, luminances);, +        int right = width * 4 / 5;, +        for (int x = width / 5; x < right; x++) {, +          histogram[localLuminances[x] >> LUMINANCE_SHIFT]++;, +        }, +      int[] localLuminances = source.getLuminanceRow(argument, luminances);, +        histogram[localLuminances[x] >> LUMINANCE_SHIFT]++;, +++ b/core/test/src/com/google/zxing/datamatrix/DataMatrixBlackBox2TestCase.java, +    addTest(2, 2, 0.0f);, +++ b/core/test/src/com/google/zxing/qrcode/QRCodeBlackBox1TestCase.java, +    addTest(19, 19, 0.0f);, +    addTest(15, 15, 90.0f);, +    addTest(16, 16, 180.0f);, +++ b/core/src/com/google/zxing/common/BaseMonochromeBitmapSource.java, +    int[] localLuminances = getLuminanceRow(y, luminances);, +      int left = localLuminances[startX];, +      int center = localLuminances[startX + 1];, +        int right = localLuminances[startX + x + 1];, +        if (localLuminances[startX + x] < blackPoint) {, +    int[] localLuminances = getLuminanceColumn(x, luminances);, +      if (localLuminances[startY + y] < blackPoint) {, +++ b/core/src/com/google/zxing/common/BlackPointEstimator.java, + * <a href="http://webdiis.unizar.es/~neira/12082/thresholding.pdf">this paper</a>.</p>, +      // We used to sample a diagonal in the 2D case, but it missed a lot of pixels, and it required, +      // n calls to getLuminance(). We had a net improvement of 63 blackbox tests decoded by, +      // sampling several rows from the middle of the image, using getLuminanceRow(). We read more, +      // pixels total, but with fewer function calls, and more continguous memory., +      for (int y = 1; y < 5; y++) {]