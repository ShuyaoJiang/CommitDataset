[+++ b/javase/src/main/java/com/google/zxing/client/j2se/CommandLineRunner.java, +import java.net.URI;, + * @author Sean Owen, +    Queue<URI> inputs = new ConcurrentLinkedQueue<>();, +          URI argURI = URI.create(arg);, +          if (argURI.getScheme() == null) {, +            argURI = new URI("file", argURI.getSchemeSpecificPart(), argURI.getFragment());, +          }, +          addArgumentToInputs(argURI, config, inputs);, +, +    int numInputs = inputs.size();, +    if (numInputs == 0) {, +      System.err.println("No inputs specified");, +      printUsage();, +      return;, +    }, +, +    int numThreads = Math.min(numInputs, Runtime.getRuntime().availableProcessors());, +    if (numInputs > 1) {, +      System.out.println("\nDecoded " + successful + " files out of " + numInputs +, +          " successfully (" + (successful * 100 / numInputs) + "%)\n");, +  /**, +   * Build all the inputs up front into a single flat list, so the threads can atomically pull, +   * paths/URLs off the queue., +   */, +  private static void addArgumentToInputs(URI input, Config config, Queue<URI> inputs) throws IOException {, +    // Special case: a local directory, +    if ("file".equals(input.getScheme()) && Files.isDirectory(Paths.get(input))) {, +      try (DirectoryStream<Path> childPaths = Files.newDirectoryStream(Paths.get(input))) {, +        for (Path childPath : childPaths) {, +          Path realChildPath = childPath.toRealPath();, +          if (!realChildPath.getFileName().toString().startsWith(".")) {, +            if (config.isRecursive() && Files.isDirectory(realChildPath)) {, +              addArgumentToInputs(realChildPath.toUri(), config, inputs);, +            } else {, +              inputs.add(realChildPath.toUri());, +      inputs.add(input);, +++ b/javase/src/main/java/com/google/zxing/client/j2se/CommandLineRunner.java, +import java.net.URI;, + * @author Sean Owen, +    Queue<URI> inputs = new ConcurrentLinkedQueue<>();, +          URI argURI = URI.create(arg);, +          if (argURI.getScheme() == null) {, +            argURI = new URI("file", argURI.getSchemeSpecificPart(), argURI.getFragment());, +          }, +          addArgumentToInputs(argURI, config, inputs);, +, +    int numInputs = inputs.size();, +    if (numInputs == 0) {, +      System.err.println("No inputs specified");, +      printUsage();, +      return;, +    }, +, +    int numThreads = Math.min(numInputs, Runtime.getRuntime().availableProcessors());, +    if (numInputs > 1) {, +      System.out.println("\nDecoded " + successful + " files out of " + numInputs +, +          " successfully (" + (successful * 100 / numInputs) + "%)\n");, +  /**, +   * Build all the inputs up front into a single flat list, so the threads can atomically pull, +   * paths/URLs off the queue., +   */, +  private static void addArgumentToInputs(URI input, Config config, Queue<URI> inputs) throws IOException {, +    // Special case: a local directory, +    if ("file".equals(input.getScheme()) && Files.isDirectory(Paths.get(input))) {, +      try (DirectoryStream<Path> childPaths = Files.newDirectoryStream(Paths.get(input))) {, +        for (Path childPath : childPaths) {, +          Path realChildPath = childPath.toRealPath();, +          if (!realChildPath.getFileName().toString().startsWith(".")) {, +            if (config.isRecursive() && Files.isDirectory(realChildPath)) {, +              addArgumentToInputs(realChildPath.toUri(), config, inputs);, +            } else {, +              inputs.add(realChildPath.toUri());, +      inputs.add(input);, +++ b/javase/src/main/java/com/google/zxing/client/j2se/DecodeWorker.java, +  private final Queue<URI> inputs;, +  DecodeWorker(Config config, Queue<URI> inputs) {, +    for (URI input; (input = inputs.poll()) != null;) {, +      Result[] results = decode(input, config.getHints());, +          dumpResult(input, results);, +  private static Path buildOutputPath(URI input, String suffix) throws IOException {, +    Path outDir;, +    String inputFileName;, +    if ("file".equals(input.getScheme())) {, +      Path inputPath = Paths.get(input);, +      outDir = inputPath.getParent();, +      inputFileName = inputPath.getFileName().toString();, +    } else {, +      outDir = Paths.get(".").toRealPath();, +      String[] pathElements = input.getPath().split("/");, +      inputFileName = pathElements[pathElements.length - 1];, +    // Replace/add extension, +    int pos = inputFileName.lastIndexOf('.');, +      inputFileName = inputFileName.substring(0, pos) + suffix;, +    } else {, +      inputFileName += suffix;, +, +    return outDir.resolve(inputFileName);, +  }, +]