[+++ b/cpp/core/src/zxing/qrcode/QRCodeReader.cpp, +			Ref<DetectorResult> detectorResult(detector.detect(hints));, +++ b/cpp/core/src/zxing/qrcode/QRCodeReader.cpp, +			Ref<DetectorResult> detectorResult(detector.detect(hints));, +++ b/cpp/core/src/zxing/qrcode/detector/Detector.cpp, +#include <zxing/DecodeHints.h>, +Ref<DetectorResult> Detector::detect(DecodeHints const& hints) {, +  Ref<FinderPatternInfo> info(finder.find(hints));, +   float scale = 1.0f;, +     scale = (float) fromX / (float) (fromX - otherToX);, +     otherToX = 0;, +     scale = (float) (image_->getWidth() - 1 - fromX) / (float) (otherToX - fromX);, +     otherToX = image_->getWidth() - 1;, +   int otherToY = (int) (fromY - (toY - fromY) * scale);, +, +   scale = 1.0f;, +     scale = (float) fromY / (float) (fromY - otherToY);, +     otherToY = 0;, +     scale = (float) (image_->getHeight() - 1 - fromY) / (float) (otherToY - fromY);, +     otherToY = image_->getHeight() - 1;, +   otherToX = (int) (fromX + (otherToX - fromX) * scale);, +, +  if (alignmentAreaRightX - alignmentAreaLeftX < overallEstModuleSize * 3) {, +      throw zxing::ReaderException("region too small to hold alignment pattern");, +  }, +++ b/cpp/core/src/zxing/qrcode/QRCodeReader.cpp, +			Ref<DetectorResult> detectorResult(detector.detect(hints));, +++ b/cpp/core/src/zxing/qrcode/detector/Detector.cpp, +#include <zxing/DecodeHints.h>, +Ref<DetectorResult> Detector::detect(DecodeHints const& hints) {, +  Ref<FinderPatternInfo> info(finder.find(hints));, +   float scale = 1.0f;, +     scale = (float) fromX / (float) (fromX - otherToX);, +     otherToX = 0;, +     scale = (float) (image_->getWidth() - 1 - fromX) / (float) (otherToX - fromX);, +     otherToX = image_->getWidth() - 1;, +   int otherToY = (int) (fromY - (toY - fromY) * scale);, +, +   scale = 1.0f;, +     scale = (float) fromY / (float) (fromY - otherToY);, +     otherToY = 0;, +     scale = (float) (image_->getHeight() - 1 - fromY) / (float) (otherToY - fromY);, +     otherToY = image_->getHeight() - 1;, +   otherToX = (int) (fromX + (otherToX - fromX) * scale);, +, +  if (alignmentAreaRightX - alignmentAreaLeftX < overallEstModuleSize * 3) {, +      throw zxing::ReaderException("region too small to hold alignment pattern");, +  }, +++ b/cpp/core/src/zxing/qrcode/detector/Detector.h, +, +class DecodeHints;, +, +  Ref<DetectorResult> detect(DecodeHints const& hints);, +++ b/cpp/core/src/zxing/qrcode/QRCodeReader.cpp, +			Ref<DetectorResult> detectorResult(detector.detect(hints));, +++ b/cpp/core/src/zxing/qrcode/detector/Detector.cpp, +#include <zxing/DecodeHints.h>, +Ref<DetectorResult> Detector::detect(DecodeHints const& hints) {, +  Ref<FinderPatternInfo> info(finder.find(hints));, +   float scale = 1.0f;, +     scale = (float) fromX / (float) (fromX - otherToX);, +     otherToX = 0;, +     scale = (float) (image_->getWidth() - 1 - fromX) / (float) (otherToX - fromX);, +     otherToX = image_->getWidth() - 1;, +   int otherToY = (int) (fromY - (toY - fromY) * scale);, +, +   scale = 1.0f;, +     scale = (float) fromY / (float) (fromY - otherToY);, +     otherToY = 0;, +     scale = (float) (image_->getHeight() - 1 - fromY) / (float) (otherToY - fromY);, +     otherToY = image_->getHeight() - 1;, +   otherToX = (int) (fromX + (otherToX - fromX) * scale);, +, +  if (alignmentAreaRightX - alignmentAreaLeftX < overallEstModuleSize * 3) {, +      throw zxing::ReaderException("region too small to hold alignment pattern");, +  }, +++ b/cpp/core/src/zxing/qrcode/detector/Detector.h, +, +class DecodeHints;, +, +  Ref<DetectorResult> detect(DecodeHints const& hints);, +++ b/cpp/core/src/zxing/qrcode/detector/FinderPatternFinder.cpp, +#include <zxing/DecodeHints.h>, +    // N.B.: we want the result in descending order ..., +    return a->getCount() > b->getCount();, +                     - center->getY()))/2;, +  // 5% of the total module size estimates, it's too much., +  return totalDeviation <= 0.05f * totalModuleSize;, +  size_t startSize = possibleCenters_.size();, +  if (startSize < 3) {, +  // Filter outlier possibilities whose module size is too different, +  if (startSize > 3) {, +    // But we can only afford to do so if we have at least 4 possibilities to choose from, +    float totalModuleSize = 0.0f;, +    for (size_t i = 0; i < startSize; i++) {, +      totalModuleSize += possibleCenters_[i]->getEstimatedModuleSize();, +    }, +    float average = totalModuleSize / (float) startSize;, +    for (size_t i = 0; i < possibleCenters_.size() && possibleCenters_.size() > 3; i++) {, +      if (abs(possibleCenters_[i]->getEstimatedModuleSize() - average) > 0.2f * average) {]