[+++ b/core/src/com/google/zxing/qrcode/encoder/BitVector.java, +  private static final int DEFAULT_SIZE_IN_BYTES = 32;, +    sizeInBits = 0;, +    array = new byte[DEFAULT_SIZE_IN_BYTES];, +    final int value = array[index >> 3] & 0xff;, +    return (value >> (7 - (index & 0x7))) & 1;, +  // JAVAPORT: I would have made this ((sizeInBits + 7) >> 3), but apparently users of this class, +  // depend on the number of bytes being rounded down. I don't see how that works though., +    return sizeInBits >> 3;, +    final int num_bits_in_last_byte = sizeInBits & 0x7;, +      sizeInBits -= 8;, +    array[sizeInBits >> 3] |= (bit << (7 - num_bits_in_last_byte));, +      if ((sizeInBits & 0x7) == 0 && num_bits_left >= 8) {, +    int sizeInBytes = (sizeInBits + 7) >> 3;, +    for (int i = 0; i < sizeInBytes; ++i) {, +  // Callers should not assume that array.length is the exact number of bytes needed to hold, +  // sizeInBits - it will typically be larger for efficiency., +  public byte[] getArray() {, +    return array;, +  }, +, +    if ((sizeInBits >> 3) == array.length) {, +    array[sizeInBits >> 3] = (byte) value;, +    sizeInBits += 8;, +++ b/core/src/com/google/zxing/qrcode/encoder/BitVector.java, +  private static final int DEFAULT_SIZE_IN_BYTES = 32;, +    sizeInBits = 0;, +    array = new byte[DEFAULT_SIZE_IN_BYTES];, +    final int value = array[index >> 3] & 0xff;, +    return (value >> (7 - (index & 0x7))) & 1;, +  // JAVAPORT: I would have made this ((sizeInBits + 7) >> 3), but apparently users of this class, +  // depend on the number of bytes being rounded down. I don't see how that works though., +    return sizeInBits >> 3;, +    final int num_bits_in_last_byte = sizeInBits & 0x7;, +      sizeInBits -= 8;, +    array[sizeInBits >> 3] |= (bit << (7 - num_bits_in_last_byte));, +      if ((sizeInBits & 0x7) == 0 && num_bits_left >= 8) {, +    int sizeInBytes = (sizeInBits + 7) >> 3;, +    for (int i = 0; i < sizeInBytes; ++i) {, +  // Callers should not assume that array.length is the exact number of bytes needed to hold, +  // sizeInBits - it will typically be larger for efficiency., +  public byte[] getArray() {, +    return array;, +  }, +, +    if ((sizeInBits >> 3) == array.length) {, +    array[sizeInBits >> 3] = (byte) value;, +    sizeInBits += 8;, +++ b/core/src/com/google/zxing/qrcode/encoder/Debug.java, +    throw new IllegalStateException(message);, +    throw new IllegalStateException(message);, +++ b/core/src/com/google/zxing/qrcode/encoder/BitVector.java, +  private static final int DEFAULT_SIZE_IN_BYTES = 32;, +    sizeInBits = 0;, +    array = new byte[DEFAULT_SIZE_IN_BYTES];, +    final int value = array[index >> 3] & 0xff;, +    return (value >> (7 - (index & 0x7))) & 1;, +  // JAVAPORT: I would have made this ((sizeInBits + 7) >> 3), but apparently users of this class, +  // depend on the number of bytes being rounded down. I don't see how that works though., +    return sizeInBits >> 3;, +    final int num_bits_in_last_byte = sizeInBits & 0x7;, +      sizeInBits -= 8;, +    array[sizeInBits >> 3] |= (bit << (7 - num_bits_in_last_byte));, +      if ((sizeInBits & 0x7) == 0 && num_bits_left >= 8) {, +    int sizeInBytes = (sizeInBits + 7) >> 3;, +    for (int i = 0; i < sizeInBytes; ++i) {, +  // Callers should not assume that array.length is the exact number of bytes needed to hold, +  // sizeInBits - it will typically be larger for efficiency., +  public byte[] getArray() {, +    return array;, +  }, +, +    if ((sizeInBits >> 3) == array.length) {, +    array[sizeInBits >> 3] = (byte) value;, +    sizeInBits += 8;, +++ b/core/src/com/google/zxing/qrcode/encoder/Debug.java, +    throw new IllegalStateException(message);, +    throw new IllegalStateException(message);, +++ b/core/src/com/google/zxing/qrcode/encoder/Encoder.java, +++ b/core/src/com/google/zxing/qrcode/encoder/BitVector.java, +  private static final int DEFAULT_SIZE_IN_BYTES = 32;, +    sizeInBits = 0;, +    array = new byte[DEFAULT_SIZE_IN_BYTES];, +    final int value = array[index >> 3] & 0xff;, +    return (value >> (7 - (index & 0x7))) & 1;, +  // JAVAPORT: I would have made this ((sizeInBits + 7) >> 3), but apparently users of this class, +  // depend on the number of bytes being rounded down. I don't see how that works though., +    return sizeInBits >> 3;, +    final int num_bits_in_last_byte = sizeInBits & 0x7;, +      sizeInBits -= 8;, +    array[sizeInBits >> 3] |= (bit << (7 - num_bits_in_last_byte));, +      if ((sizeInBits & 0x7) == 0 && num_bits_left >= 8) {, +    int sizeInBytes = (sizeInBits + 7) >> 3;, +    for (int i = 0; i < sizeInBytes; ++i) {, +  // Callers should not assume that array.length is the exact number of bytes needed to hold, +  // sizeInBits - it will typically be larger for efficiency., +  public byte[] getArray() {, +    return array;, +  }, +]