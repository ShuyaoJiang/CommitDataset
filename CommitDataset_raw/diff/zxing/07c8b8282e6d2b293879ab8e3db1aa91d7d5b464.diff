[+++ b/android/src/com/google/zxing/client/android/history/HistoryManager.java, +  private static final DateFormat EXPORT_DATE_TIME_FORMAT =, +      DateFormat.getDateTimeInstance(DateFormat.MEDIUM, DateFormat.MEDIUM);, +++ b/android/src/com/google/zxing/client/android/history/HistoryManager.java, +  private static final DateFormat EXPORT_DATE_TIME_FORMAT =, +      DateFormat.getDateTimeInstance(DateFormat.MEDIUM, DateFormat.MEDIUM);, +++ b/android/src/com/google/zxing/client/android/result/AddressBookResultHandler.java, +import java.text.ParseException;, +  static {, +    for (DateFormat format : DATE_FORMATS) {, +      format.setLenient(false);, +    }, +  }, +, +    for (DateFormat currentFormat : DATE_FORMATS) {, +      try {, +        return currentFormat.parse(s);, +      } catch (ParseException e) {, +        // continue, +        ParsedResult.maybeAppend(DateFormat.getDateInstance(DateFormat.MEDIUM).format(date.getTime()), contents);, +++ b/android/src/com/google/zxing/client/android/history/HistoryManager.java, +  private static final DateFormat EXPORT_DATE_TIME_FORMAT =, +      DateFormat.getDateTimeInstance(DateFormat.MEDIUM, DateFormat.MEDIUM);, +++ b/android/src/com/google/zxing/client/android/result/AddressBookResultHandler.java, +import java.text.ParseException;, +  static {, +    for (DateFormat format : DATE_FORMATS) {, +      format.setLenient(false);, +    }, +  }, +, +    for (DateFormat currentFormat : DATE_FORMATS) {, +      try {, +        return currentFormat.parse(s);, +      } catch (ParseException e) {, +        // continue, +        ParsedResult.maybeAppend(DateFormat.getDateInstance(DateFormat.MEDIUM).format(date.getTime()), contents);, +++ b/android/src/com/google/zxing/client/android/result/CalendarResultHandler.java, + * @author Sean Owen, +                       calendarResult.isStartAllDay(),, +, +    ParsedResult.maybeAppend(calResult.getSummary(), result);, +, +    Date start = calResult.getStart();, +    ParsedResult.maybeAppend(format(calResult.isStartAllDay(), start), result);, +, +    Date end = calResult.getEnd();, +    if (end != null) {, +      if (calResult.isEndAllDay() && !start.equals(end)) {, +        // Show only year/month/day, +        // if it's all-day and this is the end date, it's exclusive, so show the user, +        // that it ends on the day before to make more intuitive sense., +        // But don't do it if the event already (incorrectly?) specifies the same start/end, +        end = new Date(end.getTime() - 24 * 60 * 60 * 1000);, +      }, +      ParsedResult.maybeAppend(format(calResult.isEndAllDay(), end), result);, +  private static String format(boolean allDay, Date date) {, +    if (date == null) {, +      return null;, +    DateFormat format = allDay, +        ? DateFormat.getDateInstance(DateFormat.MEDIUM), +        : DateFormat.getDateTimeInstance(DateFormat.MEDIUM, DateFormat.MEDIUM);, +    return format.format(date);, +++ b/android/src/com/google/zxing/client/android/history/HistoryManager.java, +  private static final DateFormat EXPORT_DATE_TIME_FORMAT =, +      DateFormat.getDateTimeInstance(DateFormat.MEDIUM, DateFormat.MEDIUM);, +++ b/android/src/com/google/zxing/client/android/result/AddressBookResultHandler.java, +import java.text.ParseException;, +  static {, +    for (DateFormat format : DATE_FORMATS) {, +      format.setLenient(false);, +    }, +  }, +, +    for (DateFormat currentFormat : DATE_FORMATS) {, +      try {, +        return currentFormat.parse(s);, +      } catch (ParseException e) {, +        // continue, +        ParsedResult.maybeAppend(DateFormat.getDateInstance(DateFormat.MEDIUM).format(date.getTime()), contents);, +++ b/android/src/com/google/zxing/client/android/result/CalendarResultHandler.java, + * @author Sean Owen, +                       calendarResult.isStartAllDay(),, +, +    ParsedResult.maybeAppend(calResult.getSummary(), result);, +, +    Date start = calResult.getStart();, +    ParsedResult.maybeAppend(format(calResult.isStartAllDay(), start), result);, +, +    Date end = calResult.getEnd();, +    if (end != null) {, +      if (calResult.isEndAllDay() && !start.equals(end)) {, +        // Show only year/month/day, +        // if it's all-day and this is the end date, it's exclusive, so show the user, +        // that it ends on the day before to make more intuitive sense., +        // But don't do it if the event already (incorrectly?) specifies the same start/end, +        end = new Date(end.getTime() - 24 * 60 * 60 * 1000);, +      }, +      ParsedResult.maybeAppend(format(calResult.isEndAllDay(), end), result);, +  private static String format(boolean allDay, Date date) {]