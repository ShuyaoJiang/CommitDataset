[+++ b/core/src/main/java/com/google/zxing/EncodeHintType.java, +, +  /**, +   * Specifies whether the data should be encoded to the GS1 standard (type {@link Boolean}, or "true" or "false", +   * {@link String } value)., +   */, +  GS1_FORMAT,, +++ b/core/src/main/java/com/google/zxing/EncodeHintType.java, +, +  /**, +   * Specifies whether the data should be encoded to the GS1 standard (type {@link Boolean}, or "true" or "false", +   * {@link String } value)., +   */, +  GS1_FORMAT,, +++ b/core/src/main/java/com/google/zxing/qrcode/encoder/Encoder.java, +    // Append the FNC1 mode header for GS1 formatted data if applicable, +    boolean hasGS1FormatHint = hints != null && hints.containsKey(EncodeHintType.GS1_FORMAT);, +    if (hasGS1FormatHint && Boolean.valueOf(hints.get(EncodeHintType.GS1_FORMAT).toString())) {, +      // GS1 formatted codes are prefixed with a FNC1 in first position mode header, +      appendModeInfo(Mode.FNC1_FIRST_POSITION, headerBits);, +    }, +, +++ b/core/src/main/java/com/google/zxing/EncodeHintType.java, +, +  /**, +   * Specifies whether the data should be encoded to the GS1 standard (type {@link Boolean}, or "true" or "false", +   * {@link String } value)., +   */, +  GS1_FORMAT,, +++ b/core/src/main/java/com/google/zxing/qrcode/encoder/Encoder.java, +    // Append the FNC1 mode header for GS1 formatted data if applicable, +    boolean hasGS1FormatHint = hints != null && hints.containsKey(EncodeHintType.GS1_FORMAT);, +    if (hasGS1FormatHint && Boolean.valueOf(hints.get(EncodeHintType.GS1_FORMAT).toString())) {, +      // GS1 formatted codes are prefixed with a FNC1 in first position mode header, +      appendModeInfo(Mode.FNC1_FIRST_POSITION, headerBits);, +    }, +, +++ b/core/src/test/java/com/google/zxing/qrcode/encoder/EncoderTestCase.java, +  public void testEncodeGS1WithStringTypeHint() throws WriterException {, +    Map<EncodeHintType, Object> hints = new EnumMap<>(EncodeHintType.class);, +    hints.put(EncodeHintType.GS1_FORMAT, "true");, +    QRCode qrCode = Encoder.encode("100001%11171218", ErrorCorrectionLevel.H, hints);, +    verifyGS1EncodedData(qrCode);, +  }, +, +  @Test, +  public void testEncodeGS1WithBooleanTypeHint() throws WriterException {, +    Map<EncodeHintType, Object> hints = new EnumMap<>(EncodeHintType.class);, +    hints.put(EncodeHintType.GS1_FORMAT, true);, +    QRCode qrCode = Encoder.encode("100001%11171218", ErrorCorrectionLevel.H, hints);, +    verifyGS1EncodedData(qrCode);, +  }, +, +  @Test, +  public void testDoesNotEncodeGS1WhenBooleanTypeHintExplicitlyFalse() throws WriterException {, +    Map<EncodeHintType, Object> hints = new EnumMap<>(EncodeHintType.class);, +    hints.put(EncodeHintType.GS1_FORMAT, false);, +    QRCode qrCode = Encoder.encode("ABCDEF", ErrorCorrectionLevel.H, hints);, +    verifyNotGS1EncodedData(qrCode);, +  }, +, +  @Test, +  public void testDoesNotEncodeGS1WhenStringTypeHintExplicitlyFalse() throws WriterException {, +    Map<EncodeHintType, Object> hints = new EnumMap<>(EncodeHintType.class);, +    hints.put(EncodeHintType.GS1_FORMAT, "false");, +    QRCode qrCode = Encoder.encode("ABCDEF", ErrorCorrectionLevel.H, hints);, +    verifyNotGS1EncodedData(qrCode);, +  }, +, +  @Test, +  public void testGS1ModeHeaderWithECI() throws WriterException {, +    Map<EncodeHintType,Object> hints = new EnumMap<>(EncodeHintType.class);, +    hints.put(EncodeHintType.CHARACTER_SET, "UTF8");, +    hints.put(EncodeHintType.GS1_FORMAT, true);, +    QRCode qrCode = Encoder.encode("hello", ErrorCorrectionLevel.H, hints);, +    String expected =, +      "<<\n" +, +          " mode: BYTE\n" +, +          " ecLevel: H\n" +, +          " version: 1\n" +, +          " maskPattern: 5\n" +, +          " matrix:\n" +, +          " 1 1 1 1 1 1 1 0 1 0 1 1 0 0 1 1 1 1 1 1 1\n" +, +          " 1 0 0 0 0 0 1 0 0 1 1 0 0 0 1 0 0 0 0 0 1\n" +, +          " 1 0 1 1 1 0 1 0 1 1 1 0 0 0 1 0 1 1 1 0 1\n" +, +          " 1 0 1 1 1 0 1 0 0 1 0 1 0 0 1 0 1 1 1 0 1\n" +, +          " 1 0 1 1 1 0 1 0 1 0 1 0 0 0 1 0 1 1 1 0 1\n" +, +          " 1 0 0 0 0 0 1 0 0 1 1 1 1 0 1 0 0 0 0 0 1\n" +, +          " 1 1 1 1 1 1 1 0 1 0 1 0 1 0 1 1 1 1 1 1 1\n" +, +          " 0 0 0 0 0 0 0 0 1 0 1 1 1 0 0 0 0 0 0 0 0\n" +, +          " 0 0 0 0 0 1 1 0 0 1 1 0 0 0 1 0 1 0 1 0 1\n" +, +          " 0 1 0 1 1 0 0 1 0 1 1 1 1 1 1 0 1 1 1 0 1\n" +, +          " 0 1 0 1 1 1 1 0 1 1 0 0 0 1 0 1 0 1 1 0 0\n" +, +          " 1 1 1 1 0 1 0 1 0 0 1 0 1 0 0 1 1 1 1 0 0\n" +, +          " 1 0 0 1 0 0 1 1 0 1 1 0 1 0 1 0 0 1 0 0 1\n" +, +          " 0 0 0 0 0 0 0 0 1 1 1 1 1 0 1 0 1 0 0 1 0\n" +, +          " 1 1 1 1 1 1 1 0 0 0 1 1 0 0 1 0 0 0 1 1 0\n" +, +          " 1 0 0 0 0 0 1 0 1 1 0 0 0 0 1 0 1 1 1 0 0\n" +, +          " 1 0 1 1 1 0 1 0 0 1 0 0 1 0 1 0 1 0 0 0 1\n" +, +          " 1 0 1 1 1 0 1 0 0 0 0 0 1 1 1 0 1 1 1 1 0\n" +]