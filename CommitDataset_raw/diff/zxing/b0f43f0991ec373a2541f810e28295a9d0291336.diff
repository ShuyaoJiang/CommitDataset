[+++ b/core/src/com/google/zxing/DecodeHintType.java, +   * @deprecated, +++ b/core/src/com/google/zxing/DecodeHintType.java, +   * @deprecated, +++ b/core/src/com/google/zxing/MultiFormatReader.java, +    boolean tryHarder = hints != null && hints.containsKey(DecodeHintType.TRY_HARDER);, +      boolean addOneDReader =, +          possibleFormats.contains(BarcodeFormat.UPC_A) ||, +          possibleFormats.contains(BarcodeFormat.CODE_128);, +      // Put 1D readers upfront in "normal" mode, +      if (addOneDReader && !tryHarder) {, +      // At end in "try harder" mode, +      if (addOneDReader && tryHarder) {, +        readers.addElement(new MultiFormatOneDReader());, +      }, +      if (!tryHarder) {, +      }, +      if (tryHarder) {, +        readers.addElement(new MultiFormatOneDReader());, +      }, +++ b/core/src/com/google/zxing/DecodeHintType.java, +   * @deprecated, +++ b/core/src/com/google/zxing/MultiFormatReader.java, +    boolean tryHarder = hints != null && hints.containsKey(DecodeHintType.TRY_HARDER);, +      boolean addOneDReader =, +          possibleFormats.contains(BarcodeFormat.UPC_A) ||, +          possibleFormats.contains(BarcodeFormat.CODE_128);, +      // Put 1D readers upfront in "normal" mode, +      if (addOneDReader && !tryHarder) {, +      // At end in "try harder" mode, +      if (addOneDReader && tryHarder) {, +        readers.addElement(new MultiFormatOneDReader());, +      }, +      if (!tryHarder) {, +      }, +      if (tryHarder) {, +        readers.addElement(new MultiFormatOneDReader());, +      }, +++ b/core/src/com/google/zxing/common/BlackPointEstimator.java, +    // We arbitrarily say "close" is "<= 1/16 of the total histogram buckets apart", +    if (secondPeak - firstPeak <= histogram.length >> 4) {, +++ b/core/src/com/google/zxing/DecodeHintType.java, +   * @deprecated, +++ b/core/src/com/google/zxing/MultiFormatReader.java, +    boolean tryHarder = hints != null && hints.containsKey(DecodeHintType.TRY_HARDER);, +      boolean addOneDReader =, +          possibleFormats.contains(BarcodeFormat.UPC_A) ||, +          possibleFormats.contains(BarcodeFormat.CODE_128);, +      // Put 1D readers upfront in "normal" mode, +      if (addOneDReader && !tryHarder) {, +      // At end in "try harder" mode, +      if (addOneDReader && tryHarder) {, +        readers.addElement(new MultiFormatOneDReader());, +      }, +      if (!tryHarder) {, +      }, +      if (tryHarder) {, +        readers.addElement(new MultiFormatOneDReader());, +      }, +++ b/core/src/com/google/zxing/common/BlackPointEstimator.java, +    // We arbitrarily say "close" is "<= 1/16 of the total histogram buckets apart", +    if (secondPeak - firstPeak <= histogram.length >> 4) {, +++ b/core/src/com/google/zxing/oned/AbstractOneDReader.java, +    //int barcodesToSkip = 0;, +    //if (hints != null) {, +    //  Integer number = (Integer) hints.get(DecodeHintType.SKIP_N_BARCODES);, +    //  if (number != null) {, +    //    barcodesToSkip = number.intValue();, +    //  }, +    //}, +    //if (tryHarder || barcodesToSkip > 0) {, +    if (tryHarder) {, +    //Result lastResult = null;, +      // Scanning from the middle out. Determine which row we're looking at next:, +        // Oops, if we run off the top or bottom, stop, +      // Estimate black point for this row and load it:, +      // We may try twice for each row, if "trying harder":, +, +, +, +          // Look for a barcode, +, +          //if (lastResult != null && lastResult.getText().equals(result.getText())) {, +            // Just saw the last barcode again, proceed, +            //continue;, +          //}, +, +          //if (barcodesToSkip > 0) { // See if we should skip and keep looking, +          //  barcodesToSkip--;, +          //  lastResult = result; // Remember what we just saw, +          //} else {, +            // We found our barcode, +              // But it was upside down, so note that, +          //}, +, +          // continue -- just couldn't decode this row, +]