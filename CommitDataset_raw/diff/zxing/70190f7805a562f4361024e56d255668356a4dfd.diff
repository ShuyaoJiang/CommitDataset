[+++ b/core/src/com/google/zxing/common/HybridBinarizer.java, +// -*- mode:java; tab-width:2; indent-tabs-mode:nil; c-basic-offset:2 -*-, +        // Comparison needs to be <= so that black == 0 pixels are black even if the threshold is 0, +        if ((luminances[offset + x] & 0xFF) <= threshold) {, +  // Esimates blackPoint from previously calculated neighbor esitmates, +  private static int getBlackPointFromNeighbors(int[][] blackPoints, int x, int y) {, +    return (blackPoints[y-1][x] +, +            2*blackPoints[y][x-1] +, +            blackPoints[y-1][x-1]) >> 2;, +  }, +, +        // See, +        // http://groups.google.com/group/zxing/browse_thread/thread/d06efa2c35a7ddc0, +, +        // The default estimate is the average of the values in the block, +        int average = sum >> 6;, +, +        if (max - min <= 24) {, +          // If variation wihthin the block is low, assume this is a, +          // block with only light or only dark pixels., +, +          // The default assumption is that the block is light/background., +          // Since no estimate for the level of dark pixels, +          // exists locally, use half the min for the block., +          average = min >> 1;, +          , +          if (y > 0 && x > 0) {, +            // Correct the "white/background" assumption for blocks, +            // that have neighbors by comparing the pixels in this, +            // block to the previously calculated blackpoints. This is, +            // based on the fact that dark barcode symbology is always, +            // surrounded by some amount of light background for which, +            // reasonable blackpoint esimates were made. The bp estimated, +            // at the bondaries is used for the interior., +          , +            // The (min < bp) seems pretty arbitrary but works better than, +            // other heurstics that were tried., +, +            int bp = getBlackPointFromNeighbors(blackPoints, x, y);, +            if (min < bp) {, +              average = bp;, +            }, +          }, +++ b/core/src/com/google/zxing/common/HybridBinarizer.java, +// -*- mode:java; tab-width:2; indent-tabs-mode:nil; c-basic-offset:2 -*-, +        // Comparison needs to be <= so that black == 0 pixels are black even if the threshold is 0, +        if ((luminances[offset + x] & 0xFF) <= threshold) {, +  // Esimates blackPoint from previously calculated neighbor esitmates, +  private static int getBlackPointFromNeighbors(int[][] blackPoints, int x, int y) {, +    return (blackPoints[y-1][x] +, +            2*blackPoints[y][x-1] +, +            blackPoints[y-1][x-1]) >> 2;, +  }, +, +        // See, +        // http://groups.google.com/group/zxing/browse_thread/thread/d06efa2c35a7ddc0, +, +        // The default estimate is the average of the values in the block, +        int average = sum >> 6;, +, +        if (max - min <= 24) {, +          // If variation wihthin the block is low, assume this is a, +          // block with only light or only dark pixels., +, +          // The default assumption is that the block is light/background., +          // Since no estimate for the level of dark pixels, +          // exists locally, use half the min for the block., +          average = min >> 1;, +          , +          if (y > 0 && x > 0) {, +            // Correct the "white/background" assumption for blocks, +            // that have neighbors by comparing the pixels in this, +            // block to the previously calculated blackpoints. This is, +            // based on the fact that dark barcode symbology is always, +            // surrounded by some amount of light background for which, +            // reasonable blackpoint esimates were made. The bp estimated, +            // at the bondaries is used for the interior., +          , +            // The (min < bp) seems pretty arbitrary but works better than, +            // other heurstics that were tried., +, +            int bp = getBlackPointFromNeighbors(blackPoints, x, y);, +            if (min < bp) {, +              average = bp;, +            }, +          }, +++ b/core/test/data/blackbox/qrcode-6/15.jpg, +++ b/core/src/com/google/zxing/common/HybridBinarizer.java, +// -*- mode:java; tab-width:2; indent-tabs-mode:nil; c-basic-offset:2 -*-, +        // Comparison needs to be <= so that black == 0 pixels are black even if the threshold is 0, +        if ((luminances[offset + x] & 0xFF) <= threshold) {, +  // Esimates blackPoint from previously calculated neighbor esitmates, +  private static int getBlackPointFromNeighbors(int[][] blackPoints, int x, int y) {, +    return (blackPoints[y-1][x] +, +            2*blackPoints[y][x-1] +, +            blackPoints[y-1][x-1]) >> 2;, +  }, +, +        // See, +        // http://groups.google.com/group/zxing/browse_thread/thread/d06efa2c35a7ddc0]