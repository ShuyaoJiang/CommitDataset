[+++ b/core/src/com/google/zxing/oned/ITFReader.java, + * <p>Implements decoding of the ITF format.</p>, + * <p>"ITF" stands for Interleaved Two of Five. This Reader will scan ITF barcode with 6, 10 or 14 digits., + * The checksum is optional and is not applied by this Reader. The consumer of the decoded value, + * will have to apply a checksum if required.</p>, + *, + * <p><a href="http://en.wikipedia.org/wiki/Interleaved_2_of_5">http://en.wikipedia.org/wiki/Interleaved_2_of_5</a>, + * is a great reference for Interleaved 2 of 5 information.</p>, +public final class ITFReader extends AbstractOneDReader {, +  static final int[][] PATTERNS = {, +      {N, N, W, W, N}, // 0, +    // Find out where the Middle section (payload) starts & ends, +    // To avoid false positives with 2D barcodes (and other patterns), make, +    // an assumption that the decoded string must be 6, 10 or 14 digits., +    int length = resultString.length();, +    if (length != 6 && length != 10 && length != 14) {, +      throw ReaderException.getInstance();, +    }, +, +    return new Result(, +        resultString,, +        new ResultPoint[] { new GenericResultPoint(startRange[1], (float) rowNumber),, +                            new GenericResultPoint(startRange[0], (float) rowNumber)},, +   * @param row          row of black/white values to search, +   * @param payloadStart offset of start pattern, +   * @param resultString {@link StringBuffer} to append decoded chars to, +   * @throws ReaderException if decoding could not complete successfully, +    while (payloadStart < payloadEnd) {, +        int twoK = k << 1;, +        counterBlack[k] = counterDigitPair[twoK];, +        counterWhite[k] = counterDigitPair[twoK + 1];, +   * @param row row of black/white values to search, +    // Determine the width of a narrow line in pixels. We can do this by, +    // getting the width of the start pattern and dividing by 4 because its, +    // made up of 4 narrow lines., +    this.narrowLineWidth = (startPattern[1] - startPattern[0]) >> 2;, +   * @param row bit array representing the scanned barcode., +   * @param startPattern index into row of the start or end pattern., +   * @throws ReaderException if the quiet zone cannot be found, a ReaderException is thrown., +    for (int i = startPattern - 1; quietCount > 0 && i >= 0; i--) {, +      if (row.get(i)) {, +      }, +    if (quietCount != 0) {, +   * @param row row of black/white values to search, +   * @throws ReaderException Throws exception if no black lines are found in the row, +    if (endStart == width) {, +    }, +   * @param row row of black/white values to search, +    int endPattern[];, +    // The start & end patterns must be pre/post fixed by a quiet zone. This, +    // zone must be at least 10 times the width of a narrow line., +    // ref: http://www.barcode-1.net/i25code.html, +   * @param row       row of black/white values to search, +   * @param rowOffset position to start search, +   * @param pattern   pattern of counts of number of black and white pixels that are, +   * @throws ReaderException if pattern is not found, +, +    // TODO: This is very similar to implementation in AbstractUPCEANReader. Consider if they can be merged to, +    // a single method., +, +   * @param counters the counts of runs of observed black/white/black/... values, +   * @throws ReaderException if digit cannot be decoded]