[+++ b/cpp/core/src/zxing/NotFoundException.cpp, +  NotFoundException::NotFoundException() {}, +, +++ b/cpp/core/src/zxing/NotFoundException.cpp, +  NotFoundException::NotFoundException() {}, +, +++ b/cpp/core/src/zxing/NotFoundException.h, +    NotFoundException();, +++ b/cpp/core/src/zxing/NotFoundException.cpp, +  NotFoundException::NotFoundException() {}, +, +++ b/cpp/core/src/zxing/NotFoundException.h, +    NotFoundException();, +++ b/cpp/core/src/zxing/ResultPoint.h, +  const float posX_;, +  const float posY_;, +++ b/cpp/core/src/zxing/NotFoundException.cpp, +  NotFoundException::NotFoundException() {}, +, +++ b/cpp/core/src/zxing/NotFoundException.h, +    NotFoundException();, +++ b/cpp/core/src/zxing/ResultPoint.h, +  const float posX_;, +  const float posY_;, +++ b/cpp/core/src/zxing/datamatrix/detector/Detector.cpp, +#include <map>, +#include <zxing/NotFoundException.h>, +using zxing::Ref;, +using zxing::BitMatrix;, +using zxing::ResultPoint;, +using zxing::DetectorResult;, +using zxing::PerspectiveTransform;, +using zxing::NotFoundException;, +using zxing::datamatrix::Detector;, +using zxing::datamatrix::ResultPointsAndTransitions;, +namespace {, +  typedef std::map<Ref<ResultPoint>, int> PointMap;, +  void increment(PointMap& table, Ref<ResultPoint> const& key) {, +    int& value = table[key];, +    value += 1;, +  }, +}, +  typedef std::map<Ref<ResultPoint>, int> PointMap;, +  PointMap pointCount;, +  increment(pointCount, lSideOne->getFrom());, +  increment(pointCount, lSideOne->getTo());, +  increment(pointCount, lSideTwo->getFrom());, +  increment(pointCount, lSideTwo->getTo());, +, +  // Figure out which point is their intersection by tallying up the number of times we see the, +  // endpoints in the four endpoints. One will show up twice., +  for (PointMap::const_iterator entry = pointCount.begin(), end = pointCount.end(); entry != end; ++entry) {, +    Ref<ResultPoint> const& point = entry->first;, +    int value = entry->second;, +    if (value == 2) {, +      bottomLeft = point; // this is definitely the bottom left, then -- end of two L sides, +      // Otherwise it's either top left or bottom right -- just assign the two arbitrarily now, +      if (maybeTopLeft == 0) {, +        maybeTopLeft = point;, +      } else {, +        maybeBottomRight = point;, +      }, +    }, +  }, +, +  if (maybeTopLeft == 0 || bottomLeft == 0 || maybeBottomRight == 0) {, +    throw NotFoundException();, +    int dimensionCorrected = std::max(transitionsBetween(topLeft, correctedTopRight)->getTransitions(),]