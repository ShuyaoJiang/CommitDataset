[+++ b/core/src/com/google/zxing/EncodeHintType.java, +   * For Aztec it is of type {@link Integer}, representing the minimal percentage of error correction words. , +   * Note: an Aztec symbol should have a minimum of 25% EC words., +++ b/core/src/com/google/zxing/EncodeHintType.java, +   * For Aztec it is of type {@link Integer}, representing the minimal percentage of error correction words. , +   * Note: an Aztec symbol should have a minimum of 25% EC words., +++ b/core/src/com/google/zxing/aztec/encoder/AztecWriter.java, +  private static final Charset DEFAULT_CHARSET = Charset.forName("ISO-8859-1");, +    return encode(contents, format, DEFAULT_CHARSET, Encoder.DEFAULT_EC_PERCENT);, +    String charset = (String) hints.get(EncodeHintType.CHARACTER_SET);, +    Number eccPercent = (Number) hints.get(EncodeHintType.ERROR_CORRECTION);, +    return encode(contents, , +                  format, , +                  charset == null ? DEFAULT_CHARSET : Charset.forName(charset),, +                  eccPercent == null ? Encoder.DEFAULT_EC_PERCENT : eccPercent.intValue());, +  }, +, +  private static BitMatrix encode(String contents, BarcodeFormat format, Charset charset, int eccPercent) {, +    if (format != BarcodeFormat.AZTEC) {, +      throw new IllegalArgumentException("Can only encode QR_AZTECCODE, but got " + format);, +    }, +    AztecCode aztec = Encoder.encode(contents.getBytes(charset), eccPercent);, +    return aztec.getMatrix();, +++ b/core/src/com/google/zxing/EncodeHintType.java, +   * For Aztec it is of type {@link Integer}, representing the minimal percentage of error correction words. , +   * Note: an Aztec symbol should have a minimum of 25% EC words., +++ b/core/src/com/google/zxing/aztec/encoder/AztecWriter.java, +  private static final Charset DEFAULT_CHARSET = Charset.forName("ISO-8859-1");, +    return encode(contents, format, DEFAULT_CHARSET, Encoder.DEFAULT_EC_PERCENT);, +    String charset = (String) hints.get(EncodeHintType.CHARACTER_SET);, +    Number eccPercent = (Number) hints.get(EncodeHintType.ERROR_CORRECTION);, +    return encode(contents, , +                  format, , +                  charset == null ? DEFAULT_CHARSET : Charset.forName(charset),, +                  eccPercent == null ? Encoder.DEFAULT_EC_PERCENT : eccPercent.intValue());, +  }, +, +  private static BitMatrix encode(String contents, BarcodeFormat format, Charset charset, int eccPercent) {, +    if (format != BarcodeFormat.AZTEC) {, +      throw new IllegalArgumentException("Can only encode QR_AZTECCODE, but got " + format);, +    }, +    AztecCode aztec = Encoder.encode(contents.getBytes(charset), eccPercent);, +    return aztec.getMatrix();, +++ b/core/test/src/com/google/zxing/aztec/encoder/EncoderTest.java, +import java.util.EnumMap;, +import java.util.Map;, +import com.google.zxing.FormatException;, +import com.google.zxing.BarcodeFormat;, +import com.google.zxing.EncodeHintType;, +  @Test, +  public void testAztecWriter() throws Exception {, +    testWriter("\u20AC 1 sample data.", "ISO-8859-1", 25, true, 2);, +    testWriter("\u20AC 1 sample data.", "ISO-8859-15", 25, true, 2);, +    testWriter("\u20AC 1 sample data.", "UTF-8",  25, true, 2);, +    testWriter("\u20AC 1 sample data.", "UTF-8", 100, true, 3);, +    testWriter("\u20AC 1 sample data.", "UTF-8", 300, true, 4);, +    testWriter("\u20AC 1 sample data.", "UTF-8", 500, false, 5);, +    // Test AztecWriter defaults, +    String data = "In ut magna vel mauris malesuada";, +    AztecWriter writer = new AztecWriter();, +    BitMatrix matrix = writer.encode(data, BarcodeFormat.AZTEC, 0, 0);, +    AztecCode aztec = Encoder.encode(data.getBytes(LATIN_1), Encoder.DEFAULT_EC_PERCENT);, +    BitMatrix expectedMatrix = aztec.getMatrix();, +    assertEquals(matrix, expectedMatrix);, +  }, +  , +    testHighLevelEncodeString(, +        "\0\0\0\0 \0\0\0\0 \0\0\0\0 \0\0\0\0 \0\0\0\0 \0\0\0\0 \u0082\u0084\u0088\0 \0\0\0\0 \0\0\0\0 ",, +    testHighLevelEncodeString(, +        "\0\0\0\0 \0\0\1\0 \0\0\2\0 \0\0\3\0 \0\0\4\0 \0\0\5\0 \0\0\6\0 \0\0\7\0 \0\0\u0008" +, +            "\0 \0\0\u0009\0 \0\0\u00F0\0 \0\0\u00F1\0 \0\0\u00F2\0A",, +  private static void testWriter(String data, , +                                 String charset, , +                                 int eccPercent, , +                                 boolean compact, , +                                 int layers) throws FormatException {, +    // 1. Perform an encode-decode round-trip because it can be lossy., +    // 2. Aztec Decoder currently always decodes the data with a LATIN-1 charset:, +    String expectedData = new String(data.getBytes(Charset.forName(charset)), LATIN_1);, +    Map<EncodeHintType,Object> hints = new EnumMap<EncodeHintType,Object>(EncodeHintType.class);, +    hints.put(EncodeHintType.CHARACTER_SET, charset);, +    hints.put(EncodeHintType.ERROR_CORRECTION, eccPercent);, +    AztecWriter writer = new AztecWriter();, +    BitMatrix matrix = writer.encode(data, BarcodeFormat.AZTEC, 0, 0, hints);, +    AztecCode aztec = Encoder.encode(data.getBytes(Charset.forName(charset)), eccPercent);, +    assertEquals("Unexpected symbol format (compact)", compact, aztec.isCompact());, +    assertEquals("Unexpected nr. of layers", layers, aztec.getLayers());, +    BitMatrix matrix2 = aztec.getMatrix();, +    assertEquals(matrix, matrix2);, +    AztecDetectorResult r = , +        new AztecDetectorResult(matrix, NO_POINTS, aztec.isCompact(), aztec.getCodeWords(), aztec.getLayers());, +    DecoderResult res = new Decoder().decode(r);, +    assertEquals(expectedData, res.getText());, +    // Check error correction by introducing up to eccPercent errors, +    int ecWords = aztec.getCodeWords() * eccPercent / 100;, +    Random random = getPseudoRandom();, +    for (int i = 0; i < ecWords; i++) {, +      // don't touch the core, +      int x = random.nextBoolean() ?, +                random.nextInt(aztec.getLayers() * 2)]