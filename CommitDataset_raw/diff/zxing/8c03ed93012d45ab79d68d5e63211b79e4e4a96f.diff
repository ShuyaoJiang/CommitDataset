[+++ b/javame/src/com/google/zxing/client/j2me/AdvancedMultimediaManager.java, +  private static final long FOCUS_TIME_MS = 750L;, +++ b/javame/src/com/google/zxing/client/j2me/AdvancedMultimediaManager.java, +  private static final long FOCUS_TIME_MS = 750L;, +++ b/javame/src/com/google/zxing/client/j2me/LCDUIImageMonochromeBitmapSource.java, +   * An optimized approximation of a more proper conversion from RGB to luminance which, +   * only uses shifts. See BufferedImageMonochromeBitmapSource for an original version., +    // Instead of multiplying by 306, 601, 117, we multiply by 256, 512, 256, so that, +    // the multiplies can be implemented as shifts., +    //, +    // Really, it's:, +    //, +    // return ((((pixel >> 16) & 0xFF) << 8) +, +    //         (((pixel >>  8) & 0xFF) << 9) +, +    //         (( pixel        & 0xFF) << 8)) >> 10;, +    //, +    // That is, we're replacing the coefficients in the original with powers of two,, +    // which can be implemented as shifts, even though changing the coefficients slightly, +    // corrupts the conversion. Not significant for our purposes., +    //, +    // But we can get even cleverer and eliminate a few shifts:, +    return (((pixel & 0x00FF0000) >> 8)  +, +            ((pixel & 0x0000FF00) << 1) +, +            ((pixel & 0x000000FF) << 8)) >> 10;, +++ b/javame/src/com/google/zxing/client/j2me/AdvancedMultimediaManager.java, +  private static final long FOCUS_TIME_MS = 750L;, +++ b/javame/src/com/google/zxing/client/j2me/LCDUIImageMonochromeBitmapSource.java, +   * An optimized approximation of a more proper conversion from RGB to luminance which, +   * only uses shifts. See BufferedImageMonochromeBitmapSource for an original version., +    // Instead of multiplying by 306, 601, 117, we multiply by 256, 512, 256, so that, +    // the multiplies can be implemented as shifts., +    //, +    // Really, it's:, +    //, +    // return ((((pixel >> 16) & 0xFF) << 8) +, +    //         (((pixel >>  8) & 0xFF) << 9) +, +    //         (( pixel        & 0xFF) << 8)) >> 10;, +    //, +    // That is, we're replacing the coefficients in the original with powers of two,, +    // which can be implemented as shifts, even though changing the coefficients slightly, +    // corrupts the conversion. Not significant for our purposes., +    //, +    // But we can get even cleverer and eliminate a few shifts:, +    return (((pixel & 0x00FF0000) >> 8)  +, +            ((pixel & 0x0000FF00) << 1) +, +            ((pixel & 0x000000FF) << 8)) >> 10;, +++ b/javame/src/com/google/zxing/client/j2me/SnapshotThread.java, + * Thread which does the work of capturing a frame and decoding it., + *, +  private final Object waitLock;, +  private boolean done;, +  SnapshotThread(ZXingMIDlet zXingMIDlet) {, +    waitLock = new Object();, +    done = false;, +  void continueRun() {, +    synchronized (waitLock) {, +      waitLock.notifyAll();, +  private void waitForSignal() {, +    synchronized (waitLock) {, +      try {, +        waitLock.wait();, +      } catch (InterruptedException ie) {, +        // continue, +      }, +    }, +  }, +, +  void stop() {, +    done = true;, +    continueRun();, +  }, +, +    do {, +      waitForSignal();, +    } while (!done);, +++ b/javame/src/com/google/zxing/client/j2me/AdvancedMultimediaManager.java, +  private static final long FOCUS_TIME_MS = 750L;, +++ b/javame/src/com/google/zxing/client/j2me/LCDUIImageMonochromeBitmapSource.java, +   * An optimized approximation of a more proper conversion from RGB to luminance which, +   * only uses shifts. See BufferedImageMonochromeBitmapSource for an original version., +    // Instead of multiplying by 306, 601, 117, we multiply by 256, 512, 256, so that, +    // the multiplies can be implemented as shifts., +    //, +    // Really, it's:, +    //, +    // return ((((pixel >> 16) & 0xFF) << 8) +, +    //         (((pixel >>  8) & 0xFF) << 9) +, +    //         (( pixel        & 0xFF) << 8)) >> 10;, +    //, +    // That is, we're replacing the coefficients in the original with powers of two,, +    // which can be implemented as shifts, even though changing the coefficients slightly, +    // corrupts the conversion. Not significant for our purposes., +    //, +    // But we can get even cleverer and eliminate a few shifts:, +    return (((pixel & 0x00FF0000) >> 8)  +, +            ((pixel & 0x0000FF00) << 1) +, +            ((pixel & 0x000000FF) << 8)) >> 10;, +++ b/javame/src/com/google/zxing/client/j2me/SnapshotThread.java, + * Thread which does the work of capturing a frame and decoding it., + *]