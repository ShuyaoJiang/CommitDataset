[+++ b/core/src/main/java/com/google/zxing/RGBLuminanceSource.java, +    //, +    // Total number of pixels suffices, can ignore shape, +    int size = width * height;, +    luminances = new byte[size];, +    for (int offset = 0; offset < size; offset++) {, +      int pixel = pixels[offset];, +      int r = (pixel >> 16) & 0xff; // red, +      int g2 = (pixel >> 7) & 0x1fe; // 2 * green, +      int b = pixel & 0xff; // blue, +      // Calculate green-favouring average cheaply, +      luminances[offset] = (byte) ((r + g2 + b) / 4);, +++ b/core/src/main/java/com/google/zxing/RGBLuminanceSource.java, +    //, +    // Total number of pixels suffices, can ignore shape, +    int size = width * height;, +    luminances = new byte[size];, +    for (int offset = 0; offset < size; offset++) {, +      int pixel = pixels[offset];, +      int r = (pixel >> 16) & 0xff; // red, +      int g2 = (pixel >> 7) & 0x1fe; // 2 * green, +      int b = pixel & 0xff; // blue, +      // Calculate green-favouring average cheaply, +      luminances[offset] = (byte) ((r + g2 + b) / 4);, +++ b/core/src/main/java/com/google/zxing/common/BitArray.java, +    if (end < start || start < 0 || end > size) {, +      // Ones from firstBit to lastBit, inclusive, +      int mask = (2 << lastBit) - (1 << firstBit);, +   * @throws IllegalArgumentException if end is less than start or the range is not contained in the array, +    if (end < start || start < 0 || end > size) {, +      // Ones from firstBit to lastBit, inclusive, +      int mask = (2 << lastBit) - (1 << firstBit);, +    if (size != other.size) {, +      // The last int could be incomplete (i.e. not have 32 bits in, +      int currentInt = (newBits[0] >>> leftOffset);, +        currentInt = (nextInt >>> leftOffset);]