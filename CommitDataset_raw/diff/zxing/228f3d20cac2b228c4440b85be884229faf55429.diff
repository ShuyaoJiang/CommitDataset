[+++ b/core/src/com/google/zxing/aztec/AztecWriter.java, +    return encode(contents, format, width, height, DEFAULT_CHARSET, Encoder.DEFAULT_EC_PERCENT);, +                  width,, +                  height,, +  private static BitMatrix encode(String contents,, +                                  BarcodeFormat format,, +                                  int width,, +                                  int height,, +                                  Charset charset,, +                                  int eccPercent) {, +    return renderResult(aztec, width, height);, +  }, +, +  private static BitMatrix renderResult(AztecCode code, int width, int height) {, +    BitMatrix input = code.getMatrix();, +    if (input == null) {, +      throw new IllegalStateException();, +    }, +    int inputWidth = input.getWidth();, +    int inputHeight = input.getHeight();, +    int outputWidth = Math.max(width, inputWidth);, +    int outputHeight = Math.max(height, inputHeight);, +, +    int multiple = Math.min(outputWidth / inputWidth, outputHeight / inputHeight);, +    int leftPadding = (outputWidth - (inputWidth * multiple)) / 2;, +    int topPadding = (outputHeight - (inputHeight * multiple)) / 2;, +, +    BitMatrix output = new BitMatrix(outputWidth, outputHeight);, +, +    for (int inputY = 0, outputY = topPadding; inputY < inputHeight; inputY++, outputY += multiple) {, +      // Write the contents of this row of the barcode, +      for (int inputX = 0, outputX = leftPadding; inputX < inputWidth; inputX++, outputX += multiple) {, +        if (input.get(inputX, inputY)) {, +          output.setRegion(outputX, outputY, multiple, multiple);, +        }, +      }, +    }, +, +    return output;, +++ b/core/src/com/google/zxing/aztec/AztecWriter.java, +    return encode(contents, format, width, height, DEFAULT_CHARSET, Encoder.DEFAULT_EC_PERCENT);, +                  width,, +                  height,, +  private static BitMatrix encode(String contents,, +                                  BarcodeFormat format,, +                                  int width,, +                                  int height,, +                                  Charset charset,, +                                  int eccPercent) {, +    return renderResult(aztec, width, height);, +  }, +, +  private static BitMatrix renderResult(AztecCode code, int width, int height) {, +    BitMatrix input = code.getMatrix();, +    if (input == null) {, +      throw new IllegalStateException();, +    }, +    int inputWidth = input.getWidth();, +    int inputHeight = input.getHeight();, +    int outputWidth = Math.max(width, inputWidth);, +    int outputHeight = Math.max(height, inputHeight);, +, +    int multiple = Math.min(outputWidth / inputWidth, outputHeight / inputHeight);, +    int leftPadding = (outputWidth - (inputWidth * multiple)) / 2;, +    int topPadding = (outputHeight - (inputHeight * multiple)) / 2;, +, +    BitMatrix output = new BitMatrix(outputWidth, outputHeight);, +, +    for (int inputY = 0, outputY = topPadding; inputY < inputHeight; inputY++, outputY += multiple) {, +      // Write the contents of this row of the barcode, +      for (int inputX = 0, outputX = leftPadding; inputX < inputWidth; inputX++, outputX += multiple) {, +        if (input.get(inputX, inputY)) {, +          output.setRegion(outputX, outputY, multiple, multiple);, +        }, +      }, +    }, +, +    return output;, +++ b/core/src/com/google/zxing/aztec/decoder/Decoder.java, +import java.util.Arrays;, +, +    boolean[] rawbits = extractBits(matrix);, +    boolean[] correctedBits = correctBits(rawbits);, +    String result = getEncodedData(correctedBits);, +    return new DecoderResult(null, result, null, null);, +  // This method is used for testing the high-level encoder, +  public static String highLevelDecode(boolean[] correctedBits) {, +    return getEncodedData(correctedBits);, +  private static String getEncodedData(boolean[] correctedBits) {, +    int endIndex = correctedBits.length;, +    Table latchTable = Table.UPPER; // table most recently latched to, +    Table shiftTable = Table.UPPER; // table to use for the next read, +    int index = 0;, +    while (index < endIndex) {, +      if (shiftTable == Table.BINARY) {, +        if (endIndex - index < 5) {, +        int length = readCode(correctedBits, index, 5);, +        index += 5;, +          if (endIndex - index < 11) {, +          length = readCode(correctedBits, index, 11) + 31;]