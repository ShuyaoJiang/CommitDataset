[+++ b/android/src/com/google/zxing/client/android/DecodeThread.java, +import com.google.zxing.common.HybridBinarizer;, +    BinaryBitmap bitmap = new BinaryBitmap(new HybridBinarizer(source));, +++ b/android/src/com/google/zxing/client/android/DecodeThread.java, +import com.google.zxing.common.HybridBinarizer;, +    BinaryBitmap bitmap = new BinaryBitmap(new HybridBinarizer(source));, +++ b/androidtest/src/com/google/zxing/client/androidtest/BenchmarkThread.java, +import com.google.zxing.common.HybridBinarizer;, +        BinaryBitmap bitmap = new BinaryBitmap(new HybridBinarizer(source));, +++ b/android/src/com/google/zxing/client/android/DecodeThread.java, +import com.google.zxing.common.HybridBinarizer;, +    BinaryBitmap bitmap = new BinaryBitmap(new HybridBinarizer(source));, +++ b/androidtest/src/com/google/zxing/client/androidtest/BenchmarkThread.java, +import com.google.zxing.common.HybridBinarizer;, +        BinaryBitmap bitmap = new BinaryBitmap(new HybridBinarizer(source));, +++ b/core/src/com/google/zxing/common/GlobalHistogramBinarizer.java, + * Faster mobile devices and all desktop applications should probably use HybridBinarizer instead., + *, +public class GlobalHistogramBinarizer extends Binarizer {, +++ b/android/src/com/google/zxing/client/android/DecodeThread.java, +import com.google.zxing.common.HybridBinarizer;, +    BinaryBitmap bitmap = new BinaryBitmap(new HybridBinarizer(source));, +++ b/androidtest/src/com/google/zxing/client/androidtest/BenchmarkThread.java, +import com.google.zxing.common.HybridBinarizer;, +        BinaryBitmap bitmap = new BinaryBitmap(new HybridBinarizer(source));, +++ b/core/src/com/google/zxing/common/GlobalHistogramBinarizer.java, + * Faster mobile devices and all desktop applications should probably use HybridBinarizer instead., + *, +public class GlobalHistogramBinarizer extends Binarizer {, +++ b/core/src/com/google/zxing/common/HybridBinarizer.java, +/*, + * Copyright 2009 ZXing authors, + *, + * Licensed under the Apache License, Version 2.0 (the "License");, + * you may not use this file except in compliance with the License., + * You may obtain a copy of the License at, + *, + *      http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS,, + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied., + * See the License for the specific language governing permissions and, + * limitations under the License., + */, +, +package com.google.zxing.common;, +, +import com.google.zxing.Binarizer;, +import com.google.zxing.LuminanceSource;, +import com.google.zxing.ReaderException;, +, +/**, + * This class implements a local thresholding algorithm, which while slower than the, + * GlobalHistogramBinarizer, is fairly efficient for what it does. It is designed for, + * high frequency images of barcodes with black data on white backgrounds. For this application,, + * it does a much better job than a global blackpoint with severe shadows and gradients., + * However it tends to produce artifacts on lower frequency images and is therefore not, + * a good general purpose binarizer for uses outside ZXing., + *, + * This class extends GlobalHistogramBinarizer, using the older histogram approach for 1D readers,, + * and the newer local approach for 2D readers. 1D decoding using a per-row histogram is already, + * inherently local, and only fails for horizontal gradients. We can revisit that problem later,, + * but for now it was not a win to use local blocks for 1D., + *, + * This Binarizer is the default for the unit tests and the recommended class for library users., + *, + * @author dswitkin@google.com (Daniel Switkin), + */, +public final class HybridBinarizer extends GlobalHistogramBinarizer {, +, +  // This class uses 5x5 blocks to compute local luminance, where each block is 8x8 pixels., +  // So this is the smallest dimension in each axis we can accept., +  private static final int MINIMUM_DIMENSION = 40;, +, +  private BitMatrix matrix = null;, +, +  public HybridBinarizer(LuminanceSource source) {, +    super(source);, +  }, +, +  public BitMatrix getBlackMatrix() throws ReaderException {, +    binarizeEntireImage();, +    return matrix;, +  }, +, +  public Binarizer createBinarizer(LuminanceSource source) {, +    return new HybridBinarizer(source);, +  }, +, +  // Calculates the final BitMatrix once for all requests. This could be called once from the, +  // constructor instead, but there are some advantages to doing it lazily, such as making, +  // profiling easier, and not doing heavy lifting when callers don't expect it., +  private void binarizeEntireImage() throws ReaderException {, +    if (matrix == null) {, +      LuminanceSource source = getLuminanceSource();, +      if (source.getWidth() >= MINIMUM_DIMENSION && source.getHeight() >= MINIMUM_DIMENSION) {, +        byte[] luminances = source.getMatrix();, +        int width = source.getWidth();, +        int height = source.getHeight();]