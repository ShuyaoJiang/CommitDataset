[+++ b/core/src/com/google/zxing/qrcode/detector/Detector.java, +    } else if (otherToX >= image.getWidth()) {, +      scale = (float) (image.getWidth() - 1 - fromX) / (float) (otherToX - fromX);, +      otherToX = image.getWidth() - 1;, +    } else if (otherToY >= image.getHeight()) {, +      scale = (float) (image.getHeight() - 1 - fromY) / (float) (otherToY - fromY);, +      otherToY = image.getHeight() - 1;, +, +    // Middle pixel is double-counted this way; subtract 1, +    return result - 1.0f;, +    // Loop up until x == toX, but not beyond, +    int xLimit = toX + xstep;, +    for (int x = fromX, y = fromY; x != xLimit; x += xstep) {, +      // Does current pixel mean we have moved white to black or vice versa?, +      if (!(state == 1 ^ image.get(realX, realY))) {, +        if (state == 2) {, +        state++;, +      }, +, +    // Found black-white-black; give the benefit of the doubt that the next pixel outside the image, +    // is "white" so this last point at (toX+xStep,toY) is the right ending. This is really a, +    // small approximation; (toX+xStep,toY+yStep) might be really correct. Ignore this., +    if (state == 2) {, +      int diffX = toX + xstep - fromX;, +    // else we didn't find even black-white-black; no estimate is really possible, +    return Float.NaN;, +  }]