[+++ b/core/src/com/google/zxing/qrcode/QRCodeWriter.java, +    QRCode code = Encoder.encode(contents, errorCorrectionLevel, hints);, +++ b/core/src/com/google/zxing/qrcode/QRCodeWriter.java, +    QRCode code = Encoder.encode(contents, errorCorrectionLevel, hints);, +++ b/core/src/com/google/zxing/qrcode/encoder/Encoder.java, +    return MaskUtil.applyMaskPenaltyRule1(matrix), +        + MaskUtil.applyMaskPenaltyRule2(matrix), +        + MaskUtil.applyMaskPenaltyRule3(matrix), +        + MaskUtil.applyMaskPenaltyRule4(matrix);, +  public static QRCode encode(String content, ErrorCorrectionLevel ecLevel) throws WriterException {, +    return encode(content, ecLevel, null);, +  public static QRCode encode(String content,, +                              Map<EncodeHintType,?> hints) throws WriterException {, +    // Determine what character encoding has been specified by the caller, if any, +    // Pick an encoding mode appropriate for the content. Note that this will not attempt to use, +    // multiple modes / segments even if that were more efficient. Twould be nice., +    // This will store the header information, like mode and, +    // length, as well as "header" segments like an ECI segment., +    BitArray headerBits = new BitArray();, +    // Append ECI segment if applicable, +        appendECI(eci, headerBits);, +    // (With ECI in place,) Write the mode marker, +    appendModeInfo(mode, headerBits);, +, +    // Collect data within the main segment, separately, to count its size if needed. Don't add it to, +    // main payload yet., +    BitArray dataBits = new BitArray();, +    // Hard part: need to know version to know how many bits length takes. But need to know how many, +    // bits it takes to know version. To pick version size assume length takes maximum bits, +    int bitsNeeded = headerBits.getSize(), +        + mode.getCharacterCountBits(Version.getVersionForNumber(40)), +        + dataBits.getSize();, +    Version version = chooseVersion(bitsNeeded, ecLevel);, +    headerAndDataBits.appendBitArray(headerBits);, +    // Find "length" of main segment and write it, +    appendLengthInfo(numLetters, version, mode, headerAndDataBits);, +    // Put data together into the overall payload, +    Version.ECBlocks ecBlocks = version.getECBlocksForLevel(ecLevel);, +    int numDataBytes = version.getTotalCodewords() - ecBlocks.getTotalECCodewords();, +    // Terminate the bits properly., +    terminateBits(numDataBytes, headerAndDataBits);, +    // Interleave data bits with error correction code., +    BitArray finalBits = interleaveWithECBytes(headerAndDataBits,, +                                               version.getTotalCodewords(),, +                                               numDataBytes,, +                                               ecBlocks.getNumBlocks());, +    QRCode qrCode = new QRCode();, +, +    qrCode.setECLevel(ecLevel);, +    qrCode.setMode(mode);, +    qrCode.setVersion(version);, +, +    //  Choose the mask pattern and set to "qrCode"., +    int dimension = version.getDimensionForVersion();, +    ByteMatrix matrix = new ByteMatrix(dimension, dimension);, +    int maskPattern = chooseMaskPattern(finalBits, ecLevel, version, matrix);, +    qrCode.setMaskPattern(maskPattern);, +, +    // Build the matrix and set it to "qrCode"., +    MatrixUtil.buildMatrix(finalBits, ecLevel, version, maskPattern, matrix);, +, +    return qrCode;, +                                       Version version,, +  private static Version chooseVersion(int numInputBits, ErrorCorrectionLevel ecLevel) throws WriterException {, +      int totalInputBytes = (numInputBits + 7) / 8;, +      if (numDataBytes >= totalInputBytes) {, +        return version;, +    throw new WriterException("Data too big");, +  static BitArray interleaveWithECBytes(BitArray bits,, +                                        int numRSBlocks) throws WriterException {, +    BitArray result = new BitArray();, +, +, +    return result;, +  static void appendLengthInfo(int numLetters, Version version, Mode mode, BitArray bits) throws WriterException {, +    int numBits = mode.getCharacterCountBits(version);, +    if (numLetters >= (1 << numBits)) {, +++ b/core/src/com/google/zxing/qrcode/QRCodeWriter.java, +    QRCode code = Encoder.encode(contents, errorCorrectionLevel, hints);, +++ b/core/src/com/google/zxing/qrcode/encoder/Encoder.java, +    return MaskUtil.applyMaskPenaltyRule1(matrix), +        + MaskUtil.applyMaskPenaltyRule2(matrix), +        + MaskUtil.applyMaskPenaltyRule3(matrix), +        + MaskUtil.applyMaskPenaltyRule4(matrix);, +  public static QRCode encode(String content, ErrorCorrectionLevel ecLevel) throws WriterException {, +    return encode(content, ecLevel, null);, +  public static QRCode encode(String content,, +                              Map<EncodeHintType,?> hints) throws WriterException {, +    // Determine what character encoding has been specified by the caller, if any, +    // Pick an encoding mode appropriate for the content. Note that this will not attempt to use, +    // multiple modes / segments even if that were more efficient. Twould be nice., +    // This will store the header information, like mode and, +    // length, as well as "header" segments like an ECI segment., +    BitArray headerBits = new BitArray();, +    // Append ECI segment if applicable, +        appendECI(eci, headerBits);, +    // (With ECI in place,) Write the mode marker, +    appendModeInfo(mode, headerBits);, +, +    // Collect data within the main segment, separately, to count its size if needed. Don't add it to]