[+++ b/cpp/core/src/bigint/.gitignore, +*.o, +sample, +testsuite, +testsuite.expected, +testsuite.out, +testsuite.err, +++ b/cpp/core/src/bigint/.gitignore, +*.o, +sample, +testsuite, +testsuite.expected, +testsuite.out, +testsuite.err, +++ b/cpp/core/src/bigint/BigInteger.cc, +#include "BigInteger.hh", +, +void BigInteger::operator =(const BigInteger &x) {, +	// Calls like a = a have no effect, +	if (this == &x), +		return;, +	// Copy sign, +	sign = x.sign;, +	// Copy the rest, +	mag = x.mag;, +}, +, +BigInteger::BigInteger(const Blk *b, Index blen, Sign s) : mag(b, blen) {, +	switch (s) {, +	case zero:, +		if (!mag.isZero()), +			throw "BigInteger::BigInteger(const Blk *, Index, Sign): Cannot use a sign of zero with a nonzero magnitude";, +		sign = zero;, +		break;, +	case positive:, +	case negative:, +		// If the magnitude is zero, force the sign to zero., +		sign = mag.isZero() ? zero : s;, +		break;, +	default:, +		/* g++ seems to be optimizing out this case on the assumption, +		 * that the sign is a valid member of the enumeration.  Oh well. */, +		throw "BigInteger::BigInteger(const Blk *, Index, Sign): Invalid sign";, +	}, +}, +, +BigInteger::BigInteger(const BigUnsigned &x, Sign s) : mag(x) {, +	switch (s) {, +	case zero:, +		if (!mag.isZero()), +			throw "BigInteger::BigInteger(const BigUnsigned &, Sign): Cannot use a sign of zero with a nonzero magnitude";, +		sign = zero;, +		break;, +	case positive:, +	case negative:, +		// If the magnitude is zero, force the sign to zero., +		sign = mag.isZero() ? zero : s;, +		break;, +	default:, +		/* g++ seems to be optimizing out this case on the assumption, +		 * that the sign is a valid member of the enumeration.  Oh well. */, +		throw "BigInteger::BigInteger(const BigUnsigned &, Sign): Invalid sign";, +	}, +}, +, +/* CONSTRUCTION FROM PRIMITIVE INTEGERS, + * Same idea as in BigUnsigned.cc, except that negative input results in a, + * negative BigInteger instead of an exception. */, +, +// Done longhand to let us use initialization., +BigInteger::BigInteger(unsigned long  x) : mag(x) { sign = mag.isZero() ? zero : positive; }, +BigInteger::BigInteger(unsigned int   x) : mag(x) { sign = mag.isZero() ? zero : positive; }, +BigInteger::BigInteger(unsigned short x) : mag(x) { sign = mag.isZero() ? zero : positive; }, +, +// For signed input, determine the desired magnitude and sign separately., +, +namespace {, +	template <class X, class UX>, +	BigInteger::Blk magOf(X x) {, +		/* UX(...) cast needed to stop short(-2^15), which negates to, +		 * itself, from sign-extending in the conversion to Blk. */, +		return BigInteger::Blk(x < 0 ? UX(-x) : x);, +	}, +	template <class X>, +	BigInteger::Sign signOf(X x) {, +		return (x == 0) ? BigInteger::zero, +			: (x > 0) ? BigInteger::positive, +			: BigInteger::negative;, +	}, +}, +, +BigInteger::BigInteger(long  x) : sign(signOf(x)), mag(magOf<long , unsigned long >(x)) {}, +BigInteger::BigInteger(int   x) : sign(signOf(x)), mag(magOf<int  , unsigned int  >(x)) {}, +BigInteger::BigInteger(short x) : sign(signOf(x)), mag(magOf<short, unsigned short>(x)) {}, +, +// CONVERSION TO PRIMITIVE INTEGERS, +, +/* Reuse BigUnsigned's conversion to an unsigned primitive integer., + * The friend is a separate function rather than, + * BigInteger::convertToUnsignedPrimitive to avoid requiring BigUnsigned to]