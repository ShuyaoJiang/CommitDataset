[+++ b/core/src/com/google/zxing/pdf417/decoder/Decoder.java, +    correctErrors(codewords, erasures, numECCodewords);, +   * @param erasures positions of any known erasures, +   * @param numECCodewords number of error correction codewards that were available in codewords, +                             int[] erasures,, +    if (erasures.length > numECCodewords / 2 + MAX_ERRORS ||, +    errorCorrection.decode(codewords, numECCodewords, erasures);, +++ b/core/src/com/google/zxing/pdf417/decoder/Decoder.java, +    correctErrors(codewords, erasures, numECCodewords);, +   * @param erasures positions of any known erasures, +   * @param numECCodewords number of error correction codewards that were available in codewords, +                             int[] erasures,, +    if (erasures.length > numECCodewords / 2 + MAX_ERRORS ||, +    errorCorrection.decode(codewords, numECCodewords, erasures);, +++ b/core/src/com/google/zxing/pdf417/decoder/ec/ErrorCorrection.java, +  public void decode(int[] received,, +                     int numECCodewords,, +                     int[] erasures) throws ChecksumException {, +, +, +, +      ModulusPoly knownErrors = field.getOne();, +      for (int erasure : erasures) {, +        int b = field.exp(received.length - 1 - erasure);, +        // Add (1 - bx) term:, +        ModulusPoly term = new ModulusPoly(field, new int[] { field.subtract(0, b), 1 });, +        knownErrors = knownErrors.multiply(term);, +      }, +, +      syndrome = syndrome.multiply(knownErrors);, +, +          runEuclideanAlgorithm(field.buildMonomial(numECCodewords, 1), syndrome, numECCodewords);, +, +      sigma = sigma.multiply(knownErrors);, +, +      int[] errorLocations = findErrorLocations(sigma);, +      int[] errorMagnitudes = findErrorMagnitudes(omega, sigma, errorLocations);, +, +++ b/core/src/com/google/zxing/pdf417/decoder/Decoder.java, +    correctErrors(codewords, erasures, numECCodewords);, +   * @param erasures positions of any known erasures, +   * @param numECCodewords number of error correction codewards that were available in codewords, +                             int[] erasures,, +    if (erasures.length > numECCodewords / 2 + MAX_ERRORS ||, +    errorCorrection.decode(codewords, numECCodewords, erasures);, +++ b/core/src/com/google/zxing/pdf417/decoder/ec/ErrorCorrection.java, +  public void decode(int[] received,, +                     int numECCodewords,, +                     int[] erasures) throws ChecksumException {, +, +, +, +      ModulusPoly knownErrors = field.getOne();, +      for (int erasure : erasures) {, +        int b = field.exp(received.length - 1 - erasure);, +        // Add (1 - bx) term:, +        ModulusPoly term = new ModulusPoly(field, new int[] { field.subtract(0, b), 1 });, +        knownErrors = knownErrors.multiply(term);, +      }, +, +      syndrome = syndrome.multiply(knownErrors);, +, +          runEuclideanAlgorithm(field.buildMonomial(numECCodewords, 1), syndrome, numECCodewords);, +, +      sigma = sigma.multiply(knownErrors);, +, +      int[] errorLocations = findErrorLocations(sigma);, +      int[] errorMagnitudes = findErrorMagnitudes(omega, sigma, errorLocations);, +, +++ b/core/test/src/com/google/zxing/pdf417/PDF417BlackBox2TestCase.java, +    addTest(19, 19, 0, 0, 0.0f);, +    addTest(17, 17, 0, 0, 180.0f);, +++ b/core/src/com/google/zxing/pdf417/decoder/Decoder.java, +    correctErrors(codewords, erasures, numECCodewords);, +   * @param erasures positions of any known erasures, +   * @param numECCodewords number of error correction codewards that were available in codewords, +                             int[] erasures,, +    if (erasures.length > numECCodewords / 2 + MAX_ERRORS ||, +    errorCorrection.decode(codewords, numECCodewords, erasures);, +++ b/core/src/com/google/zxing/pdf417/decoder/ec/ErrorCorrection.java, +  public void decode(int[] received,, +                     int numECCodewords,, +                     int[] erasures) throws ChecksumException {, +, +, +, +      ModulusPoly knownErrors = field.getOne();, +      for (int erasure : erasures) {, +        int b = field.exp(received.length - 1 - erasure);, +        // Add (1 - bx) term:, +        ModulusPoly term = new ModulusPoly(field, new int[] { field.subtract(0, b), 1 });, +        knownErrors = knownErrors.multiply(term);, +      }, +, +      syndrome = syndrome.multiply(knownErrors);, +, +          runEuclideanAlgorithm(field.buildMonomial(numECCodewords, 1), syndrome, numECCodewords);, +, +      sigma = sigma.multiply(knownErrors);, +]