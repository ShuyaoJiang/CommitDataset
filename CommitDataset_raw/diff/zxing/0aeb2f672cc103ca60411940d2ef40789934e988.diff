[+++ b/core/src/com/google/zxing/qrcode/detector/AlignmentPattern.java, + * <p>Encapsulates an alignment pattern, which are the smaller square patterns found in, + * all but the simplest QR Codes.</p>, + *, +  /**, +   * <p>Determines if this alignment pattern "about equals" an alignment pattern at the stated, +   * position and size -- meaning, it is at nearly the same center with nearly the same size.</p>, +   */, +++ b/core/src/com/google/zxing/qrcode/detector/AlignmentPattern.java, + * <p>Encapsulates an alignment pattern, which are the smaller square patterns found in, + * all but the simplest QR Codes.</p>, + *, +  /**, +   * <p>Determines if this alignment pattern "about equals" an alignment pattern at the stated, +   * position and size -- meaning, it is at nearly the same center with nearly the same size.</p>, +   */, +++ b/core/src/com/google/zxing/qrcode/detector/AlignmentPatternFinder.java, + * <p>This class attempts to find alignment patterns in a QR Code. Alignment patterns look like finder, + * patterns but are smaller and appear at regular intervals throughout the image.</p>, + *, + * <p>This is mostly a simplified copy of {@link FinderPatternFinder}. It is copied,, + * pasted and stripped down here for maximum performance but does unfortunately duplicate, + * some code.</p>, + *, +  /**, +   * <p>Creates a finder that will look in a portion of the whole image.</p>, +   *, +   * @param image image to search, +   * @param startX left column from which to start searching, +   * @param startY top row from which to start searching, +   * @param width width of region to search, +   * @param height height of region to search, +   * @param moduleSize estimated module size so far, +   */, +  /**, +   * <p>This method attempts to find the bottom-right alignment pattern in the image. It is a bit messy since, +   * it's pretty performance-critical and so is written to be fast foremost.</p>, +   *, +   * @return {@link AlignmentPattern} if found, +   * @throws ReaderException if not found, +   */, +    // We are looking for black/white/black modules in 1:1:1 ratio;, +    // this tracks the number of black/white/black modules seen so far, +    int[] stateCount = new int[3];, +      int i = middleI + ((iGen & 0x01) == 0 ? ((iGen + 1) >> 1) : -((iGen + 1) >> 1));, +                AlignmentPattern confirmed = handlePossibleCenter(stateCount, i, j);, +  /**, +   * Given a count of black/white/black pixels just seen and an end position,, +   * figures the location of the center of this black/white/black run., +   */, +  /**, +   * @param stateCount count of black/white/black pixels just read, +   * @return true iff the proportions of the counts is close enough to the 1/1/1 ratios, +   *  used by alignment patterns to be considered a match, +   */, +  /**, +   * <p>After a horizontal scan finds a potential alignment pattern, this method, +   * "cross-checks" by scanning down vertically through the center of the possible, +   * alignment pattern to see if the same proportion is detected.</p>, +   *, +   * @param startI row where an alignment pattern was detected, +   * @param centerJ center of the section that appears to cross an alignment pattern, +   * @param maxCount maximum reasonable number of modules that should be, +   *  observed in any reading state, based on the results of the horizontal scan, +   * @return vertical center of alignment pattern, or {@link Float#NaN} if not found, +   */, +, +    // Start counting up from center, +    // If already too many modules in this state or ran off the edge:, +    // Now also count down from center, +    while (i < maxI && image.isBlack(centerJ, i) && stateCount[1] <= maxCount) {, +    while (i < maxI && !image.isBlack(centerJ, i) && stateCount[2] <= maxCount) {, +    return foundPatternCross(stateCount) ? centerFromEnd(stateCount, i) : Float.NaN;, +  /**, +   * <p>This is called when a horizontal scan finds a possible alignment pattern. It will, +   * cross check with a vertical scan, and if successful, will see if this pattern had been, +   * found on a previous horizontal scan. If so, we consider it confirmed and conclude we have, +   * found the alignment pattern.</p>, +   *, +   * @param stateCount reading state module counts from horizontal scan, +   * @param i row where alignment pattern may be found, +   * @param j end of possible alignment pattern in row, +   * @return {@link AlignmentPattern} if we have found the same pattern twice, or null if not, +   */, +  private AlignmentPattern handlePossibleCenter(int[] stateCount, int i, int j) {, +      float estimatedModuleSize = (float) (stateCount[0] + stateCount[1] + stateCount[2]) / 3.0f;, +++ b/core/src/com/google/zxing/qrcode/detector/AlignmentPattern.java, + * <p>Encapsulates an alignment pattern, which are the smaller square patterns found in, + * all but the simplest QR Codes.</p>, + *, +  /**, +   * <p>Determines if this alignment pattern "about equals" an alignment pattern at the stated, +   * position and size -- meaning, it is at nearly the same center with nearly the same size.</p>, +   */, +++ b/core/src/com/google/zxing/qrcode/detector/AlignmentPatternFinder.java, + * <p>This class attempts to find alignment patterns in a QR Code. Alignment patterns look like finder, + * patterns but are smaller and appear at regular intervals throughout the image.</p>, + *, + * <p>This is mostly a simplified copy of {@link FinderPatternFinder}. It is copied,, + * pasted and stripped down here for maximum performance but does unfortunately duplicate]