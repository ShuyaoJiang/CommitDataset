[+++ b/AUTHORS, +fics.danmark, +++ b/AUTHORS, +fics.danmark, +++ b/core/src/main/java/com/google/zxing/multi/qrcode/detector/MultiFinderPatternFinder.java, +    boolean pureBarcode = hints != null && hints.containsKey(DecodeHintType.PURE_BARCODE);, +              if (foundPatternCross(stateCount) && handlePossibleCenter(stateCount, i, j, pureBarcode)) { // Yes, +        handlePossibleCenter(stateCount, i, maxJ, pureBarcode);, +++ b/AUTHORS, +fics.danmark, +++ b/core/src/main/java/com/google/zxing/multi/qrcode/detector/MultiFinderPatternFinder.java, +    boolean pureBarcode = hints != null && hints.containsKey(DecodeHintType.PURE_BARCODE);, +              if (foundPatternCross(stateCount) && handlePossibleCenter(stateCount, i, j, pureBarcode)) { // Yes, +        handlePossibleCenter(stateCount, i, maxJ, pureBarcode);, +++ b/core/src/main/java/com/google/zxing/qrcode/detector/FinderPatternFinder.java, +    boolean pureBarcode = hints != null && hints.containsKey(DecodeHintType.PURE_BARCODE);, +                boolean confirmed = handlePossibleCenter(stateCount, i, j, pureBarcode);, +        boolean confirmed = handlePossibleCenter(stateCount, i, maxJ, pureBarcode);, +   * After a vertical and horizontal scan finds a potential finder pattern, this method, +   * "cross-cross-cross-checks" by scanning down diagonally through the center of the possible, +   * finder pattern to see if the same proportion is detected., +   * , +   * @param startI row where a finder pattern was detected, +   * @param centerJ center of the section that appears to cross a finder pattern, +   * @param maxCount maximum reasonable number of modules that should be, +   *  observed in any reading state, based on the results of the horizontal scan, +   * @param originalStateCountTotal The original state count total., +   * @return true if proportions are withing expected limits, +   */, +  private boolean crossCheckDiagonal(int startI, int centerJ, int maxCount, int originalStateCountTotal) {, +    int maxI = image.getHeight();, +    int maxJ = image.getWidth();, +    int[] stateCount = getCrossCheckStateCount();, +, +    // Start counting up, left from center finding black center mass, +    int i = 0;, +    while (startI - i >= 0 && image.get(centerJ - i, startI - i)) {, +      stateCount[2]++;, +      i++;, +    }, +, +    if ((startI - i < 0) || (centerJ - i < 0)) {, +      return false;, +    }, +, +    // Continue up, left finding white space, +    while ((startI - i >= 0) && (centerJ - i >= 0) && !image.get(centerJ - i, startI - i) && stateCount[1] <= maxCount) {, +      stateCount[1]++;, +      i++;, +    }, +, +    // If already too many modules in this state or ran off the edge:, +    if ((startI - i < 0) || (centerJ - i < 0) || stateCount[1] > maxCount) {, +      return false;, +    }, +, +    // Continue up, left finding black border, +    while ((startI - i >= 0) && (centerJ - i >= 0) && image.get(centerJ - i, startI - i) && stateCount[0] <= maxCount) {, +      stateCount[0]++;, +      i++;, +    }, +    if (stateCount[0] > maxCount) {, +       return false;, +    }, +, +    // Now also count down, right from center, +    i = 1;, +    while ((startI + i < maxI) && (centerJ + i < maxJ) && image.get(centerJ + i, startI + i)) {, +      stateCount[2]++;, +      i++;, +    }, +, +    // Ran off the edge?, +    if ((startI + i >= maxI) || (centerJ + i >= maxJ)) {, +       return false;, +    }, +, +    while ((startI + i < maxI) && (centerJ + i < maxJ) && !image.get(centerJ + i, startI + i) && stateCount[3] < maxCount) {, +      stateCount[3]++;, +      i++;, +    }, +, +    if ((startI + i >= maxI) || (centerJ + i >= maxJ) || stateCount[3] >= maxCount) {, +      return false;, +    }, +, +    while ((startI + i < maxI) && (centerJ + i < maxJ) && image.get(centerJ + i, startI + i) && stateCount[4] < maxCount) {, +      stateCount[4]++;, +      i++;, +    }, +, +    if (stateCount[4] >= maxCount) {, +      return false;, +   }, +, +    // If we found a finder-pattern-like section, but its size is more than 100% different than, +    // the original, assume it's a false positive, +    int stateCountTotal = stateCount[0] + stateCount[1] + stateCount[2] + stateCount[3] + stateCount[4];, +    return, +        Math.abs(stateCountTotal - originalStateCountTotal) < 2 * originalStateCountTotal &&]