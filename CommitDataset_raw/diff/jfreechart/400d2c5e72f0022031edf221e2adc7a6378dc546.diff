[+++ b/ChangeLog, +	* experimental/org/jfree/experimental/chart/axis/LogAxis.java, +	(setSmallestValue): Added event notification,, +	(zoomRange): New method override., +, +2007-07-11  David Gilbert  <david.gilbert@object-refinery.com>, +, +++ b/ChangeLog, +	* experimental/org/jfree/experimental/chart/axis/LogAxis.java, +	(setSmallestValue): Added event notification,, +	(zoomRange): New method override., +, +2007-07-11  David Gilbert  <david.gilbert@object-refinery.com>, +, +++ b/experimental/org/jfree/experimental/chart/axis/LogAxis.java, + * 12-Jul-2007 : Fixed zooming bug (DG);, +     * , +     * @see #setBase(double), +     * , +     * @see #getBase(), +     * , +     * @see #setSmallestValue(double), +     * Sets the smallest value represented by the axis and sends an , +     * {@link AxisChangeEvent} to all registered listeners., +     * , +     * @see #getSmallestValue(), +        notifyListeners(new AxisChangeEvent(this));, +     * , +     * @see #setTickUnit(NumberTickUnit), +     * , +     * @see #getTickUnit(), +     * , +     * @see #getTickUnit(), +     * , +     * @see #setNumberFormatOverride(NumberFormat), +     * , +     * @see #getNumberFormatOverride(), +     * , +     * @see #setMinorTickCount(int), +     * Sets the number of minor tick marks to display, and sends an, +     * {@link AxisChangeEvent} to all registered listeners., +     * , +     * @see #getMinorTickCount(), +     * @see #calculateValue(double), +     * , +     * @see #calculateLog(double), +     * @see #getBase(), +     * Zooms in on the current range., +     * , +     * @param lowerPercent  the new lower bound., +     * @param upperPercent  the new upper bound., +     */, +    public void zoomRange(double lowerPercent, double upperPercent) {, +        Range range = getRange();, +        double start = range.getLowerBound();, +        double end = range.getUpperBound();, +        double log1 = calculateLog(start);, +        double log2 = calculateLog(end);, +        double length = log2 - log1;, +        Range adjusted = null;, +        if (isInverted()) {, +            double logA = log1 + length * (1 - upperPercent);, +            double logB = log1 + length * (1 - lowerPercent);, +            adjusted = new Range(calculateValue(logA), calculateValue(logB)); , +        }, +        else {, +            double logA = log1 + length * lowerPercent;, +            double logB = log1 + length * upperPercent;, +            adjusted = new Range(calculateValue(logA), calculateValue(logB)); , +        }, +        setRange(adjusted);, +    }, +, +    /**]