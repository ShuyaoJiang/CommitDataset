[+++ b/swt/org/jfree/experimental/swt/SWTGraphics2D.java, +import java.awt.geom.Area;, +        setStroke(new BasicStroke());, +     * @param paint  the paint (<code>null</code> permitted, ignored)., +        if (paint == null) {, +            return;  // to be consistent with other Graphics2D implementations, +        }, +     * @param color  the color (<code>null</code> permitted but ignored)., +        if (color == null) {, +            return;, +        }, +    private Color backgroundColor;, +    , +        // since this is only used by clearRect(), we don't update the GC yet, +        this.backgroundColor = color;, +     * @return The background colour (possibly <code>null</code>).., +        return this.backgroundColor;, +     * @param comp  the composite (<code>null</code> not permitted)., +        if (comp == null) {, +            throw new IllegalArgumentException("Null 'comp' argument.");, +        }, +        if (stroke == null) {, +            throw new IllegalArgumentException("Null 'stroke' argument.");, +        }, +        org.eclipse.swt.graphics.Rectangle r , +                = new org.eclipse.swt.graphics.Rectangle(x, y, width, height);, +        clip.intersect(r);, +        AffineTransform t = getTransform();, +        t.rotate(theta);, +        setTransform(t);, +        translate(x, y);, +        rotate(theta);, +        translate(-x, -y);, +        transform(AffineTransform.getShearInstance(shearX, shearY));, +        Color bgcolor = getBackground();, +        if (bgcolor == null) {, +            return;  // we can't do anything, +        }, +        setPaint(bgcolor);, +     * Draws the specified glyph vector at the location <code>(x, y)</code>., +     * , +     * @param g  the glyph vector (<code>null</code> not permitted)., +     * @param x  the x-coordinate., +     * @param y  the y-coordinate., +        fill(g.getOutline(x, y));, +        drawString(text, (float) x, (float) y);, +        if (text == null) {, +            throw new NullPointerException("Null 'text' argument.");, +        }, +     * Returns <code>true</code> if the rectangle (in device space) intersects, +     * with the shape (the interior, if <code>onStroke</code> is false, , +     * otherwise the stroked outline of the shape)., +     * @param rect  a rectangle (in device space)., +     * @param s the shape., +     * @param onStroke  test the stroked outline only?, +     * , +     * @return A boolean. , +    @Override, +    public boolean hit(Rectangle rect, Shape s, boolean onStroke) {, +        AffineTransform transform = getTransform();, +        Shape ts;, +        if (onStroke) {, +            Stroke stroke = getStroke();, +            ts = transform.createTransformedShape(stroke.createStrokedShape(s));, +        } else {, +            ts = transform.createTransformedShape(s);, +        }, +        if (!rect.getBounds2D().intersects(ts.getBounds2D())) {, +        Area a1 = new Area(rect);, +        Area a2 = new Area(ts);, +        a1.intersect(a2);, +        return !a1.isEmpty();, +    }]