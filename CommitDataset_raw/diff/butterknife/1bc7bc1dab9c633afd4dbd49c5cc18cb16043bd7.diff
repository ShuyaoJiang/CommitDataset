[+++ b/build.gradle, +    // Other, +    rxjava: 'io.reactivex:rxjava:1.1.2',, +, +++ b/build.gradle, +    // Other, +    rxjava: 'io.reactivex:rxjava:1.1.2',, +, +++ /dev/null, +++ b/build.gradle, +    // Other, +    rxjava: 'io.reactivex:rxjava:1.1.2',, +, +++ /dev/null, +++ b/butterknife-compiler/build.gradle, +sourceCompatibility = 1.7, +targetCompatibility = 1.7, +, +  compile deps.rxjava, +++ b/build.gradle, +    // Other, +    rxjava: 'io.reactivex:rxjava:1.1.2',, +, +++ /dev/null, +++ b/butterknife-compiler/build.gradle, +sourceCompatibility = 1.7, +targetCompatibility = 1.7, +, +  compile deps.rxjava, +++ b/butterknife-compiler/src/main/java/butterknife/compiler/BindingClass.java, +, +import java.util.LinkedHashSet;, +import butterknife.internal.ListenerClass;, +import butterknife.internal.ListenerMethod;, +, +  private static final ClassName BUTTERKNIFE = ClassName.get("butterknife", "ButterKnife");, +  private static final ClassName UNBINDER = ClassName.get("butterknife", "Unbinder");, +  public static final String UNBINDER_SIMPLE_NAME = "InnerUnbinder";, +  private final Set<BindingClass> descendantBindingClasses = new LinkedHashSet<>();, +  private final String classFqcn;, +  private BindingClass parentBinding;, +  private ClassName unbinderClassName;  // If this is null'd out, it has no unbinder and uses NOP., +  private ClassName highestUnbinderClassName; // If this is null'd out, there is no parent unbinder., +  BindingClass(String classPackage, String className, String targetClass, String classFqcn) {, +    this.classFqcn = classFqcn;, +, +    // Default to this, but this can be null'd out by the processor before we brew if it's not, +    // necessary., +    this.unbinderClassName = ClassName.get(classPackage, className, UNBINDER_SIMPLE_NAME);, +  void addDescendant(BindingClass bindingClass) {, +    descendantBindingClasses.add(bindingClass);, +  boolean addMethod(, +      int id,, +      ListenerClass listener,, +      ListenerMethod method,, +  void setParent(BindingClass parent) {, +    this.parentBinding = parent;, +    if (hasParentBinding()) {, +      result.superclass(ParameterizedTypeName.get(ClassName.bestGuess(parentBinding.classFqcn),, +    if (hasUnbinder() && hasViewBindings()) {, +      createUnbinderCreateUnbinderMethod(result);, +        TypeSpec.classBuilder(unbinderClassName.simpleName()), +            .addModifiers(PROTECTED, STATIC), +    if (hasParentBinding() && parentBinding.hasUnbinder()) {, +          parentBinding.getUnbinderClassName(), generic));, +      result.addSuperinterface(UNBINDER);, +    if (!hasParentBinding() || !parentBinding.hasUnbinder()) {, +    if (hasParentBinding() && parentBinding.hasUnbinder()) {, +    if (hasParentBinding() && parentBinding.hasUnbinder()) {, +  private void addFieldAndUnbindStatement(, +      TypeSpec.Builder result,, +      MethodSpec.Builder unbindMethod,, +    // Using unique view id for name uniqueness., +    String fieldName = "view" + bindings.getUniqueIdSuffix();, +  private void createUnbinderCreateUnbinderMethod(TypeSpec.Builder viewBindingClass) {, +    // Create type variable InnerUnbinder<T>, +    TypeName returnType = ParameterizedTypeName.get(, +        unbinderClassName, TypeVariableName.get("T"));, +        .addStatement("return new $T($L)", unbinderClassName, "target");, +    if (hasParentBinding() && parentBinding.hasUnbinder()) {, +        .returns(UNBINDER), +    if (hasParentBinding()) {, +      if (hasViewBindings()) {, +        if (highestUnbinderClassName != unbinderClassName) {, +          // This has an unbinder class and there exists an unbinder class farther up, so use super, +          // and let the super implementation create it for us., +          result.addStatement("$T unbinder = ($T) super.bind(finder, target, source)",, +              unbinderClassName,, +              unbinderClassName);, +          // This has an unbinder class and there is no implementation higher up, so we'll call, +          // super but ignore the result since it's just the NOP. Instead, create the unbinder here, +          // for our implementation and any descendant classes., +          result.addStatement("super.bind(finder, target, source)");, +          result.addStatement("$T unbinder = createUnbinder(target)", unbinderClassName);, +      } else {, +        // This has no unbinder class, just defer to super (which could be NOP or real,, +        // we don't care)., +        result.addStatement("$T unbinder = super.bind(finder, target, source)", UNBINDER);, +      }, +    } else if (hasViewBindings()) {]