[+++ b/butterknife/src/main/java/butterknife/Views.java, +import butterknife.internal.InjectViewProcessor;, +++ b/butterknife/src/main/java/butterknife/Views.java, +import butterknife.internal.InjectViewProcessor;, +++ b/butterknife/src/main/java/butterknife/internal/InjectViewProcessor.java, +package butterknife.internal;, +, +import butterknife.InjectView;, +import java.io.IOException;, +import java.io.Writer;, +import java.util.Collection;, +import java.util.LinkedHashMap;, +import java.util.LinkedHashSet;, +import java.util.Map;, +import java.util.Set;, +import javax.annotation.processing.AbstractProcessor;, +import javax.annotation.processing.Filer;, +import javax.annotation.processing.ProcessingEnvironment;, +import javax.annotation.processing.RoundEnvironment;, +import javax.annotation.processing.SupportedAnnotationTypes;, +import javax.lang.model.SourceVersion;, +import javax.lang.model.element.Element;, +import javax.lang.model.element.Modifier;, +import javax.lang.model.element.TypeElement;, +import javax.lang.model.type.DeclaredType;, +import javax.lang.model.type.TypeKind;, +import javax.lang.model.type.TypeMirror;, +import javax.lang.model.util.Elements;, +import javax.lang.model.util.Types;, +import javax.tools.JavaFileObject;, +, +import static javax.lang.model.element.ElementKind.CLASS;, +import static javax.lang.model.element.Modifier.PRIVATE;, +import static javax.lang.model.element.Modifier.STATIC;, +import static javax.tools.Diagnostic.Kind.ERROR;, +, +@SupportedAnnotationTypes("butterknife.InjectView"), +public class InjectViewProcessor extends AbstractProcessor {, +  public static final String SUFFIX = "$$ViewInjector";, +, +  private Elements elementUtils;, +  private Types typeUtils;, +  private Filer filer;, +, +  private TypeMirror viewType;, +, +  @Override public synchronized void init(ProcessingEnvironment env) {, +    super.init(env);, +, +    elementUtils = env.getElementUtils();, +    typeUtils = env.getTypeUtils();, +    filer = env.getFiler();, +, +    viewType = elementUtils.getTypeElement("android.view.View").asType();, +  }, +, +  @Override public boolean process(Set<? extends TypeElement> elements, RoundEnvironment env) {, +    Map<TypeElement, TargetClass> targetClassMap = findAndParseTargets(env);, +, +    for (Map.Entry<TypeElement, TargetClass> entry : targetClassMap.entrySet()) {, +      TypeElement typeElement = entry.getKey();, +      TargetClass targetClass = entry.getValue();, +, +      // Write the view injector class., +      try {, +        JavaFileObject jfo = filer.createSourceFile(targetClass.getFqcn(), typeElement);, +        Writer writer = jfo.openWriter();, +        writer.write(targetClass.brewJava());, +        writer.flush();, +        writer.close();, +      } catch (IOException e) {, +        error(typeElement, "Unable to write injector for type %s: %s", typeElement, e.getMessage());, +      }, +    }, +, +    return true;, +  }, +, +  private Map<TypeElement, TargetClass> findAndParseTargets(RoundEnvironment env) {, +    Map<TypeElement, TargetClass> targetClassMap = new LinkedHashMap<TypeElement, TargetClass>();, +    Set<TypeMirror> erasedTargetTypes = new LinkedHashSet<TypeMirror>();, +, +    for (Element element : env.getElementsAnnotatedWith(InjectView.class)) {, +      TypeElement enclosingElement = (TypeElement) element.getEnclosingElement();, +, +      // Verify that the target type extends from View., +      if (!typeUtils.isSubtype(element.asType(), viewType)) {, +        error(element, "@InjectView fields must extend from View (%s.%s).",, +            enclosingElement.getQualifiedName(), element);, +        continue;, +      }, +, +      // Verify field properties., +      Set<Modifier> modifiers = element.getModifiers();, +      if (modifiers.contains(PRIVATE) || modifiers.contains(STATIC)) {, +        error(element, "@InjectView fields must not be private or static (%s.%s).",, +            enclosingElement.getQualifiedName(), element);, +        continue;, +      }, +]