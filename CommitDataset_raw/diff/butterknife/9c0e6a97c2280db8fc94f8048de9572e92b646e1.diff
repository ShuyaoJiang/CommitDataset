[+++ b/butterknife-annotations/src/main/java/butterknife/OnTextChanged.java, +import static java.lang.annotation.RetentionPolicy.RUNTIME;, +@Retention(RUNTIME), +++ b/butterknife-annotations/src/main/java/butterknife/OnTextChanged.java, +import static java.lang.annotation.RetentionPolicy.RUNTIME;, +@Retention(RUNTIME), +++ b/butterknife-reflect/src/main/java/butterknife/ButterKnife.java, +import android.text.Editable;, +import android.text.TextWatcher;, +        unbinder = parseOnTextChanged(target, method, source);, +        if (unbinder != null) unbinders.add(unbinder);, +, +  private static @Nullable Unbinder parseOnTextChanged(Object target, Method method, View source) {, +    OnTextChanged onTextChanged = method.getAnnotation(OnTextChanged.class);, +    if (onTextChanged == null) {, +      return null;, +    }, +    validateMember(method);, +    validateReturnType(method, void.class);, +, +    List<TextView> views =, +        findViews(source, onTextChanged.value(), isRequired(method), method.getName(), View.class);, +, +    TextWatcher textWatcher;, +    switch (onTextChanged.callback()) {, +      case TEXT_CHANGED: {, +        ArgumentTransformer argumentTransformer =, +            createArgumentTransformer(method, ON_TEXT_CHANGED_TYPES);, +        textWatcher = new EmptyTextWatcher() {, +          @Override public void onTextChanged(CharSequence s, int start, int before, int count) {, +            tryInvoke(method, target, argumentTransformer.transform(s, start, before, count));, +          }, +        };, +        break;, +      }, +      case BEFORE_TEXT_CHANGED: {, +        ArgumentTransformer argumentTransformer =, +            createArgumentTransformer(method, BEFORE_TEXT_CHANGED_TYPES);, +        textWatcher = new EmptyTextWatcher() {, +          @Override public void beforeTextChanged(CharSequence s, int start, int count, int after) {, +            tryInvoke(method, target, argumentTransformer.transform(s, start, count, after));, +          }, +        };, +        break;, +      }, +      case AFTER_TEXT_CHANGED: {, +        ArgumentTransformer argumentTransformer =, +            createArgumentTransformer(method, AFTER_TEXT_CHANGED_TYPES);, +        textWatcher = new EmptyTextWatcher() {, +          @Override public void afterTextChanged(Editable s) {, +            tryInvoke(method, target, argumentTransformer.transform(s));, +          }, +        };, +        break;, +      }, +      default:, +        throw new AssertionError();, +    }, +, +    ViewCollections.set(views, ADD_TEXT_WATCHER, textWatcher);, +    return new ListenerUnbinder<>(views, REMOVE_TEXT_WATCHER, textWatcher);, +  }, +, +  private static final Setter<TextView, TextWatcher> ADD_TEXT_WATCHER =, +      (view, value, index) -> view.addTextChangedListener(value);, +  private static final Setter<TextView, TextWatcher> REMOVE_TEXT_WATCHER =, +      (view, value, index) -> view.removeTextChangedListener(value);, +  private static final Class<?>[] ON_TEXT_CHANGED_TYPES =, +      { CharSequence.class, int.class, int.class, int.class };, +  private static final Class<?>[] BEFORE_TEXT_CHANGED_TYPES = ON_TEXT_CHANGED_TYPES;, +  private static final Class<?>[] AFTER_TEXT_CHANGED_TYPES = { Editable.class };, +++ b/butterknife-annotations/src/main/java/butterknife/OnTextChanged.java, +import static java.lang.annotation.RetentionPolicy.RUNTIME;, +@Retention(RUNTIME), +++ b/butterknife-reflect/src/main/java/butterknife/ButterKnife.java, +import android.text.Editable;, +import android.text.TextWatcher;, +        unbinder = parseOnTextChanged(target, method, source);, +        if (unbinder != null) unbinders.add(unbinder);, +, +  private static @Nullable Unbinder parseOnTextChanged(Object target, Method method, View source) {, +    OnTextChanged onTextChanged = method.getAnnotation(OnTextChanged.class);, +    if (onTextChanged == null) {, +      return null;, +    }, +    validateMember(method);, +    validateReturnType(method, void.class);, +, +    List<TextView> views =, +        findViews(source, onTextChanged.value(), isRequired(method), method.getName(), View.class);, +, +    TextWatcher textWatcher;, +    switch (onTextChanged.callback()) {, +      case TEXT_CHANGED: {, +        ArgumentTransformer argumentTransformer =, +            createArgumentTransformer(method, ON_TEXT_CHANGED_TYPES);, +        textWatcher = new EmptyTextWatcher() {, +          @Override public void onTextChanged(CharSequence s, int start, int before, int count) {, +            tryInvoke(method, target, argumentTransformer.transform(s, start, before, count));, +          }]