[+++ b/butterknife/src/main/java/butterknife/OnClick.java, +import butterknife.internal.InjectableListener;, +import butterknife.internal.OnClickListenerHandler;, +@InjectableListener(OnClickListenerHandler.class), +++ b/butterknife/src/main/java/butterknife/OnClick.java, +import butterknife.internal.InjectableListener;, +import butterknife.internal.OnClickListenerHandler;, +@InjectableListener(OnClickListenerHandler.class), +++ b/butterknife/src/main/java/butterknife/internal/Binding.java, +++ b/butterknife/src/main/java/butterknife/OnClick.java, +import butterknife.internal.InjectableListener;, +import butterknife.internal.OnClickListenerHandler;, +@InjectableListener(OnClickListenerHandler.class), +++ b/butterknife/src/main/java/butterknife/internal/Binding.java, +++ b/butterknife/src/main/java/butterknife/internal/FieldBinding.java, +  public String getName() {, +  public String getType() {, +    return type;, +  }, +, +++ b/butterknife/src/main/java/butterknife/OnClick.java, +import butterknife.internal.InjectableListener;, +import butterknife.internal.OnClickListenerHandler;, +@InjectableListener(OnClickListenerHandler.class), +++ b/butterknife/src/main/java/butterknife/internal/Binding.java, +++ b/butterknife/src/main/java/butterknife/internal/FieldBinding.java, +  public String getName() {, +  public String getType() {, +    return type;, +  }, +, +++ b/butterknife/src/main/java/butterknife/internal/InjectViewProcessor.java, +import butterknife.InjectView;, +import butterknife.OnClick;, +import butterknife.Optional;, +import java.lang.annotation.Annotation;, +import static javax.lang.model.element.ElementKind.METHOD;, +  static final String VIEW_TYPE = "android.view.View";, +  static final Map<String, InjectableListenerHandler> LISTENER_HANDLER_MAP =, +      new LinkedHashMap<String, InjectableListenerHandler>();, +    // Process each annotation that corresponds to a listener., +    findAndParseListener(env, OnClick.class, targetClassMap, erasedTargetTypes);, +  private void findAndParseListener(RoundEnvironment env,, +      Class<? extends Annotation> annotationClass, Map<TypeElement, TargetClass> targetClassMap,, +      Set<TypeMirror> erasedTargetTypes) {, +    for (Element element : env.getElementsAnnotatedWith(annotationClass)) {, +      try {, +        parseListenerAnnotation(annotationClass, element, targetClassMap, erasedTargetTypes);, +      } catch (Exception e) {, +        error(element, "Unable to parse @%s: %s", annotationClass.getSimpleName(), e.getMessage());, +      }, +    }, +  }, +, +  private void parseListenerAnnotation(Class<? extends Annotation> annotationClass, Element element,, +      Map<TypeElement, TargetClass> targetClassMap, Set<TypeMirror> erasedTargetTypes), +      throws Exception {, +    // This should be guarded by the annotation's @Target but it's worth a check for safe casting., +    if (!(element instanceof ExecutableElement) || element.getKind() != METHOD) {, +      error(element, "@%s annotation must be on a method.", annotationClass.getSimpleName());, +    String annotationName = annotationClass.getName();, +    InjectableListenerHandler handler = LISTENER_HANDLER_MAP.get(annotationName);, +    if (handler == null) {, +      InjectableListener listener = annotationClass.getAnnotation(InjectableListener.class);, +      if (listener == null) {, +        error(element, "No @%s defined on @%s.", InjectableListener.class.getSimpleName(),, +            annotationClass.getSimpleName());, +        return;, +      }, +      Class<? extends InjectableListenerHandler> handlerClass = listener.value();, +      handler = handlerClass.newInstance();, +      LISTENER_HANDLER_MAP.put(annotationName, handler);, +    }, +, +    // Assemble information on the injection point., +    String name = executableElement.getSimpleName().toString();, +    Annotation annotation = element.getAnnotation(annotationClass);, +    int[] ids = (int[]) annotationClass.getDeclaredMethod("value").invoke(annotation);, +    boolean required = element.getAnnotation(Optional.class) == null;, +, +      throw new InjectableListenerException(element,, +          "@%s methods must not be private or static. (%s.%s)", annotationClass.getSimpleName(),, +          enclosingElement.getQualifiedName(), element.getSimpleName());, +      throw new InjectableListenerException(enclosingElement,, +          "@%s methods may only be contained in classes. (%s.%s)", annotationClass.getSimpleName(),, +          enclosingElement.getQualifiedName(), element.getSimpleName());, +      throw new InjectableListenerException(enclosingElement,, +          "@%s methods may not be contained in private classes. (%s.%s)",, +          annotationClass.getSimpleName(), enclosingElement.getQualifiedName(),, +          element.getSimpleName());, +      throw new InjectableListenerException(element,, +          "@%s methods must have a 'void' return type. (%s.%s)", annotationClass.getSimpleName(),, +          enclosingElement.getQualifiedName(), element.getSimpleName());, +        throw new InjectableListenerException(element,, +            "@%s annotation for method contains duplicate ID %d. (%s.%s)",, +            annotationClass.getSimpleName(), id, enclosingElement.getQualifiedName(),, +            element.getSimpleName());, +    String[] types;, +    try {, +      types = handler.parseParamTypesAndValidateMethod(this, executableElement);]