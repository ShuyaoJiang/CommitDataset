[+++ b/butterknife-gradle-plugin/src/main/java/butterknife/plugin/FinalRClassBuilder.java, +    String fieldValue = variable.getInitializer().map(Node::toString).orElse(null);, +++ b/butterknife-gradle-plugin/src/main/java/butterknife/plugin/FinalRClassBuilder.java, +    String fieldValue = variable.getInitializer().map(Node::toString).orElse(null);, +++ b/butterknife-reflect/src/main/java/butterknife/ButterKnife.java, +    validateReturnType(method, void.class);, +    final ArgumentTransformer argumentTransformer =, +        createArgumentTransformer(method, ON_CLICK_TYPES);, +        tryInvoke(method, target, argumentTransformer.transform(v));, +    final boolean propagateReturn = validateReturnType(method, boolean.class);, +    final ArgumentTransformer argumentTransformer =, +        createArgumentTransformer(method, ON_LONG_CLICK_TYPES);, +        Object returnValue = tryInvoke(method, target, argumentTransformer.transform(v));, +        //noinspection SimplifiableConditionalExpression, +        return propagateReturn, +            ? (boolean) returnValue, +            : false;, +    validateReturnType(method, void.class);, +    final ArgumentTransformer argumentTransformer =, +        createArgumentTransformer(method, ON_ITEM_CLICK_TYPES);, +        tryInvoke(method, target, argumentTransformer.transform(parent, view, position, id));, +  /** Returns true when the return value should be propagated. Use a default otherwise. */, +  private static boolean validateReturnType(Method method, Class<?> expected) {, +    Class<?> returnType = method.getReturnType();, +    if (returnType == void.class) {, +      return false;, +    }, +    if (returnType != expected) {, +      String expectedType = "'" + expected.getName() + "'";, +      if (expected != void.class) {, +        expectedType = "'void' or " + expectedType;, +      }, +      throw new IllegalStateException(method.getDeclaringClass().getName(), +          + ".", +          + method.getName(), +          + " must have return type of ", +          + expectedType);, +    }, +    return true;, +  }, +, +  private static ArgumentTransformer createArgumentTransformer(Method method,, +      Class<?>[] callbackParameterTypes) {, +    Class<?>[] targetParameterTypes = method.getParameterTypes();, +, +    int targetParameterLength = targetParameterTypes.length;, +    if (targetParameterLength == 0) {, +      // Special case the common case of no arguments., +      return ArgumentTransformer.EMPTY;, +    }, +, +    int callbackParameterLength = callbackParameterTypes.length;, +    if (targetParameterLength > callbackParameterLength) {, +      throw new IllegalStateException(method.getDeclaringClass().getName(), +          + ".", +          + method.getName(), +          + " must have at most ", +          + callbackParameterLength, +          + " parameter(s).");, +    }, +, +    if (Arrays.equals(targetParameterTypes, callbackParameterTypes)) {, +      // Special case the common case of exact argument match., +      return ArgumentTransformer.IDENTITY;, +    }, +, +    boolean[] callbackIndexUsed = new boolean[callbackParameterLength];, +    final int[] indexMap = new int[targetParameterLength];, +    nextTarget: for (int targetIndex = 0; targetIndex < targetParameterLength; targetIndex++) {, +      Class<?> targetParameterType = targetParameterTypes[targetIndex];, +      for (int callbackIndex = 0; callbackIndex < callbackParameterLength; callbackIndex++) {, +        if (callbackIndexUsed[callbackIndex]) {, +          continue; // We have already used this callback argument., +        }, +        Class<?> callbackParameterType = callbackParameterTypes[callbackIndex];, +, +        if (/* exact match */, +            callbackParameterType.equals(targetParameterType), +            /* or subtype of view */, +            || (View.class.isAssignableFrom(callbackParameterType), +                && callbackParameterType.isAssignableFrom(targetParameterType)), +            /* or interface (like Checkable) */, +            || targetParameterType.isInterface()) {, +          indexMap[targetIndex] = callbackIndex;, +          callbackIndexUsed[callbackIndex] = true;, +          continue nextTarget; // This avoids the error handling code if loop exits normally., +        }, +      }, +, +      StringBuilder builder = new StringBuilder();, +      builder.append("Unable to match "), +          .append(method.getDeclaringClass().getName()), +          .append('.'), +          .append(method.getName()), +          .append(" method arguments.");, +      for (int i = 0; i < targetParameterLength; i++) {, +        builder.append("\n\n  Parameter #"), +            .append(i + 1), +            .append(": "), +            .append(targetParameterTypes[i].getName())]