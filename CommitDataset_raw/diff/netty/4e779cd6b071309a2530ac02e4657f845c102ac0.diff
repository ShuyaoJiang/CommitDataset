[+++ b/buffer/src/main/java/io/netty/buffer/UnpooledByteBufAllocator.java, +    private final boolean disableLeakDetector;, +, +     * Default instance which uses leak-detection for direct buffers., +     * Create a new instance which uses leak-detection for direct buffers., +     *, +     * @param preferDirect {@code true} if {@link #buffer(int)} should try to allocate a direct buffer rather than, +     *                     a heap buffer, +     */, +    public UnpooledByteBufAllocator(boolean preferDirect) {, +        this(preferDirect, false);, +    }, +, +    /**, +     * @param disableLeakDetector {@code true} if the leak-detection should be disabled completely for this, +     *                            allocator. This can be useful if the user just want to depend on the GC to handle, +     *                            direct buffers when not explicit released., +    public UnpooledByteBufAllocator(boolean preferDirect, boolean disableLeakDetector) {, +        this.disableLeakDetector = disableLeakDetector;, +        ByteBuf buf = PlatformDependent.hasUnsafe() ?, +                new UnpooledUnsafeDirectByteBuf(this, initialCapacity, maxCapacity) :, +                new UnpooledDirectByteBuf(this, initialCapacity, maxCapacity);, +, +        return disableLeakDetector ? buf : toLeakAwareBuffer(buf);, +    @Override, +    public CompositeByteBuf compositeHeapBuffer(int maxNumComponents) {, +        CompositeByteBuf buf = new CompositeByteBuf(this, false, maxNumComponents);, +        return disableLeakDetector ? buf : toLeakAwareBuffer(buf);, +    }, +, +    @Override, +    public CompositeByteBuf compositeDirectBuffer(int maxNumComponents) {, +        CompositeByteBuf buf = new CompositeByteBuf(this, true, maxNumComponents);, +        return disableLeakDetector ? buf : toLeakAwareBuffer(buf);]