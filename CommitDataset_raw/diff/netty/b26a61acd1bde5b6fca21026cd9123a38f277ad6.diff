[+++ b/buffer/src/main/java/io/netty/buffer/AbstractPooledDerivedByteBuf.java, +            resetRefCnt();, +++ b/buffer/src/main/java/io/netty/buffer/AbstractPooledDerivedByteBuf.java, +            resetRefCnt();, +++ b/buffer/src/main/java/io/netty/buffer/AbstractReferenceCountedByteBuf.java, +import io.netty.util.internal.ReferenceCountUpdater;, +    private static final long REFCNT_FIELD_OFFSET =, +            ReferenceCountUpdater.getUnsafeOffset(AbstractReferenceCountedByteBuf.class, "refCnt");, +    private static final AtomicIntegerFieldUpdater<AbstractReferenceCountedByteBuf> AIF_UPDATER =, +    private static final ReferenceCountUpdater<AbstractReferenceCountedByteBuf> updater =, +            new ReferenceCountUpdater<AbstractReferenceCountedByteBuf>() {, +        @Override, +        protected AtomicIntegerFieldUpdater<AbstractReferenceCountedByteBuf> updater() {, +            return AIF_UPDATER;, +        }, +        @Override, +        protected long unsafeOffset() {, +            return REFCNT_FIELD_OFFSET;, +        }, +    };, +, +    // Value might not equal "real" reference count, all access should be via the updater, +    private volatile int refCnt = updater.initialValue();, +        return updater.isLiveNonVolatile(this);, +        return updater.refCnt(this);, +    protected final void setRefCnt(int refCnt) {, +        updater.setRefCnt(this, refCnt);, +    }, +, +    /**, +     * An unsafe operation intended for use by a subclass that resets the reference count of the buffer to 1, +     */, +    protected final void resetRefCnt() {, +        updater.resetRefCnt(this);, +        return updater.retain(this);, +        return updater.retain(this, increment);, +        return handleRelease(updater.release(this));, +        return handleRelease(updater.release(this, decrement));, +    private boolean handleRelease(boolean result) {, +        if (result) {, +        return result;, +++ b/buffer/src/main/java/io/netty/buffer/AbstractPooledDerivedByteBuf.java, +            resetRefCnt();, +++ b/buffer/src/main/java/io/netty/buffer/AbstractReferenceCountedByteBuf.java, +import io.netty.util.internal.ReferenceCountUpdater;, +    private static final long REFCNT_FIELD_OFFSET =, +            ReferenceCountUpdater.getUnsafeOffset(AbstractReferenceCountedByteBuf.class, "refCnt");, +    private static final AtomicIntegerFieldUpdater<AbstractReferenceCountedByteBuf> AIF_UPDATER =, +    private static final ReferenceCountUpdater<AbstractReferenceCountedByteBuf> updater =, +            new ReferenceCountUpdater<AbstractReferenceCountedByteBuf>() {, +        @Override, +        protected AtomicIntegerFieldUpdater<AbstractReferenceCountedByteBuf> updater() {, +            return AIF_UPDATER;, +        }, +        @Override, +        protected long unsafeOffset() {, +            return REFCNT_FIELD_OFFSET;, +        }, +    };, +, +    // Value might not equal "real" reference count, all access should be via the updater, +    private volatile int refCnt = updater.initialValue();, +        return updater.isLiveNonVolatile(this);, +        return updater.refCnt(this);, +    protected final void setRefCnt(int refCnt) {, +        updater.setRefCnt(this, refCnt);, +    }, +, +    /**, +     * An unsafe operation intended for use by a subclass that resets the reference count of the buffer to 1, +     */, +    protected final void resetRefCnt() {, +        updater.resetRefCnt(this);, +        return updater.retain(this);, +        return updater.retain(this, increment);, +        return handleRelease(updater.release(this));, +        return handleRelease(updater.release(this, decrement));, +    private boolean handleRelease(boolean result) {, +        if (result) {, +        return result;, +++ b/buffer/src/main/java/io/netty/buffer/ByteBufUtil.java, +            buf.resetRefCnt();, +            buf.resetRefCnt();, +++ b/buffer/src/main/java/io/netty/buffer/AbstractPooledDerivedByteBuf.java, +            resetRefCnt();, +++ b/buffer/src/main/java/io/netty/buffer/AbstractReferenceCountedByteBuf.java, +import io.netty.util.internal.ReferenceCountUpdater;, +    private static final long REFCNT_FIELD_OFFSET =, +            ReferenceCountUpdater.getUnsafeOffset(AbstractReferenceCountedByteBuf.class, "refCnt");, +    private static final AtomicIntegerFieldUpdater<AbstractReferenceCountedByteBuf> AIF_UPDATER =, +    private static final ReferenceCountUpdater<AbstractReferenceCountedByteBuf> updater =, +            new ReferenceCountUpdater<AbstractReferenceCountedByteBuf>() {, +        @Override, +        protected AtomicIntegerFieldUpdater<AbstractReferenceCountedByteBuf> updater() {, +            return AIF_UPDATER;, +        }, +        @Override, +        protected long unsafeOffset() {, +            return REFCNT_FIELD_OFFSET;, +        }]