[+++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, +        return ByteBufUtil.decodeString(this, index, length, charset);, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, +        return ByteBufUtil.decodeString(this, index, length, charset);, +++ b/buffer/src/main/java/io/netty/buffer/ByteBufUtil.java, +import io.netty.util.concurrent.FastThreadLocal;, +    private static final FastThreadLocal<CharBuffer> CHAR_BUFFERS = new FastThreadLocal<CharBuffer>() {, +        @Override, +        protected CharBuffer initialValue() throws Exception {, +            return CharBuffer.allocate(1024);, +        }, +    };, +    private static final int MAX_CHAR_BUFFER_SIZE;, +, +        MAX_CHAR_BUFFER_SIZE = SystemPropertyUtil.getInt("io.netty.maxThreadLocalCharBufferSize", 16 * 1024);, +        logger.debug("-Dio.netty.maxThreadLocalCharBufferSize: {}", MAX_CHAR_BUFFER_SIZE);, +    static String decodeString(ByteBuf src, int readerIndex, int len, Charset charset) {, +        if (len == 0) {, +            return StringUtil.EMPTY_STRING;, +        }, +        final int maxLength = (int) ((double) len * decoder.maxCharsPerByte());, +        CharBuffer dst = CHAR_BUFFERS.get();, +        if (dst.length() < maxLength) {, +            dst = CharBuffer.allocate(maxLength);, +            if (maxLength <= MAX_CHAR_BUFFER_SIZE) {, +                CHAR_BUFFERS.set(dst);, +            }, +        } else {, +            dst.clear();, +        }, +        if (src.nioBufferCount() == 1) {, +            // Use internalNioBuffer(...) to reduce object creation., +            decodeString(decoder, src.internalNioBuffer(readerIndex, len), dst);, +        } else {, +            // We use a heap buffer as CharsetDecoder is most likely able to use a fast-path if src and dst buffers, +            // are both backed by a byte array., +            ByteBuf buffer = src.alloc().heapBuffer(len);, +            try {, +                buffer.writeBytes(src, readerIndex, len);, +                // Use internalNioBuffer(...) to reduce object creation., +                decodeString(decoder, buffer.internalNioBuffer(readerIndex, len), dst);, +            } finally {, +                // Release the temporary buffer again., +                buffer.release();, +            }, +        }, +        return dst.flip().toString();, +    }, +, +    private static void decodeString(CharsetDecoder decoder, ByteBuffer src, CharBuffer dst) {, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, +        return ByteBufUtil.decodeString(this, index, length, charset);, +++ b/buffer/src/main/java/io/netty/buffer/ByteBufUtil.java, +import io.netty.util.concurrent.FastThreadLocal;, +    private static final FastThreadLocal<CharBuffer> CHAR_BUFFERS = new FastThreadLocal<CharBuffer>() {, +        @Override, +        protected CharBuffer initialValue() throws Exception {, +            return CharBuffer.allocate(1024);, +        }, +    };, +    private static final int MAX_CHAR_BUFFER_SIZE;, +, +        MAX_CHAR_BUFFER_SIZE = SystemPropertyUtil.getInt("io.netty.maxThreadLocalCharBufferSize", 16 * 1024);, +        logger.debug("-Dio.netty.maxThreadLocalCharBufferSize: {}", MAX_CHAR_BUFFER_SIZE);, +    static String decodeString(ByteBuf src, int readerIndex, int len, Charset charset) {, +        if (len == 0) {, +            return StringUtil.EMPTY_STRING;, +        }, +        final int maxLength = (int) ((double) len * decoder.maxCharsPerByte());, +        CharBuffer dst = CHAR_BUFFERS.get();, +        if (dst.length() < maxLength) {, +            dst = CharBuffer.allocate(maxLength);, +            if (maxLength <= MAX_CHAR_BUFFER_SIZE) {, +                CHAR_BUFFERS.set(dst);, +            }, +        } else {, +            dst.clear();, +        }, +        if (src.nioBufferCount() == 1) {, +            // Use internalNioBuffer(...) to reduce object creation., +            decodeString(decoder, src.internalNioBuffer(readerIndex, len), dst);, +        } else {, +            // We use a heap buffer as CharsetDecoder is most likely able to use a fast-path if src and dst buffers, +            // are both backed by a byte array., +            ByteBuf buffer = src.alloc().heapBuffer(len);, +            try {, +                buffer.writeBytes(src, readerIndex, len);, +                // Use internalNioBuffer(...) to reduce object creation., +                decodeString(decoder, buffer.internalNioBuffer(readerIndex, len), dst);, +            } finally {, +                // Release the temporary buffer again., +                buffer.release();, +            }, +        }, +        return dst.flip().toString();, +    }, +, +    private static void decodeString(CharsetDecoder decoder, ByteBuffer src, CharBuffer dst) {, +++ b/buffer/src/test/java/io/netty/buffer/ByteBufUtilTest.java, +import java.nio.charset.Charset;]