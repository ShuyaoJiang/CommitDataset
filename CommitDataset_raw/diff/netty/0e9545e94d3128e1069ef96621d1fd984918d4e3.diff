[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2RemoteFlowController.java, +import io.netty.channel.ChannelHandlerContext;, +import io.netty.handler.codec.http2.StreamByteDistributor.Writer;, +import io.netty.util.internal.logging.InternalLogger;, +import io.netty.util.internal.logging.InternalLoggerFactory;, +, +import java.util.ArrayDeque;, +import java.util.Deque;, +, +import static io.netty.handler.codec.http2.Http2Stream.State.HALF_CLOSED_LOCAL;, +    private static final InternalLogger logger =, +            InternalLoggerFactory.getInstance(DefaultHttp2RemoteFlowController.class);, +    private WritabilityMonitor monitor;, +        this(connection, (Listener) null);, +        this(connection, streamByteDistributor, null);, +    }, +, +    public DefaultHttp2RemoteFlowController(Http2Connection connection, final Listener listener) {, +        this(connection, new PriorityStreamByteDistributor(connection), listener);, +    }, +, +    public DefaultHttp2RemoteFlowController(Http2Connection connection,, +                                            StreamByteDistributor streamByteDistributor,, +                                            final Listener listener) {, +        connectionState = new DefaultState(connection.connectionStream(), initialWindowSize,, +                initialWindowSize > 0 && isChannelWritable());, +        // Monitor may depend upon connectionState, and so initialize after connectionState, +        listener(listener);, +, +                        new DefaultState(stream, 0,, +                                isWritable(DefaultHttp2RemoteFlowController.this.connection.connectionStream())));, +                    state = new ReducedState(state);, +                    stream.setProperty(stateKey, state);, +                // Tell the monitor after cancel has been called and after the new state is used., +                monitor.stateCancelled(state);, +                if (HALF_CLOSED_LOCAL.equals(stream.state())) {, +                    AbstractState state = state(stream);, +                    state.cancel();, +                    monitor.stateCancelled(state);, +        // Writing the pending bytes will not check writability change and instead a writability change notification, +        // to be provided by an explicit call., +        channelWritabilityChanged();, +, +        if (isChannelWritable()) {, +        monitor.initialWindowSize(newWindowSize);, +    public boolean isWritable(Http2Stream stream) {, +        return monitor.isWritable(state(stream));, +    }, +, +    @Override, +    public void channelWritabilityChanged() throws Http2Exception {, +        monitor.channelWritabilityChange();, +    }, +, +    private boolean isChannelWritable() {, +        return ctx != null && isChannelWritable0();, +    }, +, +    private boolean isChannelWritable0() {, +        return ctx.channel().isWritable();, +    }, +, +    @Override, +    public void listener(Listener listener) {, +        monitor = listener == null ? new DefaultWritabilityMonitor() : new ListenerWritabilityMonitor(listener);, +    }, +, +    @Override, +        monitor.incrementWindowSize(state(stream), delta);, +            monitor.enqueueFrame(state(stream), frame);, +        return max(ctx.channel().config().getWriteBufferLowWaterMark(), MIN_WRITABLE_CHUNK);, +        int channelWritableBytes = (int) min(Integer.MAX_VALUE, ctx.channel().bytesBeforeUnwritable());, +     * The amount of bytes that can be supported by underlying {@link io.netty.channel.Channel} without, +     * queuing "too-much"., +        return min(connectionWindowSize(), maxUsableChannelBytes());, +        monitor.writePendingBytes();, +        DefaultState(Http2Stream stream, int initialWindowSize, boolean markedWritable) {, +            super(stream, markedWritable);, +        @Override, +        public int streamableBytes() {, +            return max(0, min(pendingBytes, window));, +        }, +, +        /**, +         * Returns the maximum writable window (minimum of the stream and connection windows)., +         */, +        private int writableWindow() {, +        int pendingBytes() {, +            return pendingBytes;, +, +                // The frame still has data, but the amount of allocated bytes has been exhausted., +                    // The frame still has data, but the amount of allocated bytes has been exhausted., +, +            monitor.incrementPendingBytes(numBytes);, +            super(stream, false);, +        int pendingBytes() {, +            return 0;, +        }, +, +        @Override]