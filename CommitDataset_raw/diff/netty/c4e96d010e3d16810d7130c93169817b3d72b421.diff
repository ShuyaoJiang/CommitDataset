[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/WeightedFairQueueByteDistributor.java, +                        pState.activeCountChangeForTree(state.activeCountForTree);, +                        pState.activeCountChangeForTree(-state.activeCountForTree);, +        if (state.isActive()) {, +        childState.setDistributing();, +                "nextChildState[" + nextChildState.stream.id() + "].pseudoTime(" + nextChildState.pseudoTimeToWrite +, +                ") < " + " childState[" + childState.stream.id() + "].pseudoTime(" + childState.pseudoTimeToWrite + ")";, +            childState.unsetDistributing();, +            // Do in finally to ensure the internal flags is not corrupted if an exception is thrown., +        private static final int STATE_IS_ACTIVE = 0x1;, +        private static final int STATE_IS_DISTRIBUTING = 0x2;, +         * Count of nodes rooted at this sub tree with {@link #isActive()} equal to {@code true}., +         * A pseudo time maintained for immediate children to base their {@link #pseudoTimeToWrite} off of., +        private byte flags;, +        void activeCountChangeForTree(int increment) {, +                assert activeCountForTree != increment ||, +                       priorityQueueIndex == INDEX_NOT_IN_QUEUE ||, +                       pState.queue.contains(this) :, +                     "State[" + stream.id() + "].activeCountForTree changed from 0 to " + increment + " is in a queue" +, +                     ", but not in parent[ " + pState.stream.id() + "]'s queue";, +                } else if (activeCountForTree == increment && !isDistributing()) {, +                    // If frame count was 0 but is now not, and this node is not already in a queue (assumed to be, +                    // pState's queue) then enqueue it. If this State object is being processed the pseudoTime for this, +                    // node should not be adjusted, and the node will be added back to the queue/tree structure after it, +                    // is done being processed. This may happen if the activeCountForTree == 0 (a node which can't, +                    // stream anything and is blocked) is at/near root of the tree, and is poped off the queue during, +                    // processing, and then put back on the queue because a child changes position in the priority tree, +                    // (or is closed because it is not blocked and finished writing all data)., +                pState.activeCountChangeForTree(increment);, +            if (isActive() != isActive) {, +                if (isActive) {, +                    activeCountChangeForTree(1);, +                    setActive();, +                } else {, +                    activeCountChangeForTree(-1);, +                    unsetActive();, +                }, +        boolean isActive() {, +            return (flags & STATE_IS_ACTIVE) != 0;, +        }, +, +        private void setActive() {, +            flags |= STATE_IS_ACTIVE;, +        }, +, +        private void unsetActive() {, +            flags &= ~STATE_IS_ACTIVE;, +        }, +, +        boolean isDistributing() {, +            return (flags & STATE_IS_DISTRIBUTING) != 0;, +        }, +, +        void setDistributing() {, +            flags |= STATE_IS_DISTRIBUTING;, +        }, +, +        void unsetDistributing() {, +            flags &= ~STATE_IS_DISTRIBUTING;, +        }, +, +, +        @Override, +        public String toString() {, +            // Use activeCountForTree as a rough estimate for how many nodes are in this subtree., +            StringBuilder sb = new StringBuilder(256 * (activeCountForTree > 0 ? activeCountForTree : 1));, +            toString(sb);, +            return sb.toString();, +        }, +, +        private void toString(StringBuilder sb) {, +            sb.append("{stream ").append(stream.id()), +                    .append(" streamableBytes ").append(streamableBytes), +                    .append(" activeCountForTree ").append(activeCountForTree), +                    .append(" priorityQueueIndex ").append(priorityQueueIndex), +                    .append(" pseudoTimeToWrite ").append(pseudoTimeToWrite), +                    .append(" pseudoTime ").append(pseudoTime), +                    .append(" flags ").append(flags), +                    .append(" queue.size() ").append(queue.size()).append("} [");, +, +            if (!queue.isEmpty()) {, +                for (State s : queue) {, +                    s.toString(sb);, +                    sb.append(", ");, +                }, +                // Remove the last ", ", +                sb.setLength(sb.length() - 2);, +            }, +            sb.append(']');, +        }, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/WeightedFairQueueByteDistributor.java, +                        pState.activeCountChangeForTree(state.activeCountForTree);, +                        pState.activeCountChangeForTree(-state.activeCountForTree);, +        if (state.isActive()) {, +        childState.setDistributing();, +                "nextChildState[" + nextChildState.stream.id() + "].pseudoTime(" + nextChildState.pseudoTimeToWrite +, +                ") < " + " childState[" + childState.stream.id() + "].pseudoTime(" + childState.pseudoTimeToWrite + ")";, +            childState.unsetDistributing();, +            // Do in finally to ensure the internal flags is not corrupted if an exception is thrown., +        private static final int STATE_IS_ACTIVE = 0x1;]