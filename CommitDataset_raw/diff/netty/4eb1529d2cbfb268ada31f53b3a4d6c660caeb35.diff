[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocket08FrameDecoder.java, +import java.nio.ByteOrder;, +        int i = frame.readerIndex();, +        int end = frame.writerIndex();, +, +        ByteOrder order = frame.order();, +, +        // Remark: & 0xFF is necessary because Java will do signed expansion from, +        // byte to int which we don't want., +        int intMask = ((maskingKey[0] & 0xFF) << 24), +                    | ((maskingKey[1] & 0xFF) << 16), +                    | ((maskingKey[2] & 0xFF) << 8), +                    | (maskingKey[3] & 0xFF);, +, +        // If the byte order of our buffers it little endian we have to bring our mask, +        // into the same format, because getInt() and writeInt() will use a reversed byte order, +        if (order == ByteOrder.LITTLE_ENDIAN) {, +            intMask = Integer.reverseBytes(intMask);, +        }, +, +        for (; i + 3 < end; i += 4) {, +            int unmasked = frame.getInt(i) ^ intMask;, +            frame.setInt(i, unmasked);, +        }, +        for (; i < end; i++) {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocket08FrameDecoder.java, +import java.nio.ByteOrder;, +        int i = frame.readerIndex();, +        int end = frame.writerIndex();, +, +        ByteOrder order = frame.order();, +, +        // Remark: & 0xFF is necessary because Java will do signed expansion from, +        // byte to int which we don't want., +        int intMask = ((maskingKey[0] & 0xFF) << 24), +                    | ((maskingKey[1] & 0xFF) << 16), +                    | ((maskingKey[2] & 0xFF) << 8), +                    | (maskingKey[3] & 0xFF);, +, +        // If the byte order of our buffers it little endian we have to bring our mask, +        // into the same format, because getInt() and writeInt() will use a reversed byte order, +        if (order == ByteOrder.LITTLE_ENDIAN) {, +            intMask = Integer.reverseBytes(intMask);, +        }, +, +        for (; i + 3 < end; i += 4) {, +            int unmasked = frame.getInt(i) ^ intMask;, +            frame.setInt(i, unmasked);, +        }, +        for (; i < end; i++) {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocket08FrameEncoder.java, +import java.nio.ByteOrder;, +                ByteOrder srcOrder = data.order();, +                ByteOrder dstOrder = buf.order();, +, +                int i = data.readerIndex();, +                int end = data.writerIndex();, +, +                if (srcOrder == dstOrder) {, +                    // Use the optimized path only when byte orders match, +                    // Remark: & 0xFF is necessary because Java will do signed expansion from, +                    // byte to int which we don't want., +                    int intMask = ((mask[0] & 0xFF) << 24), +                                | ((mask[1] & 0xFF) << 16), +                                | ((mask[2] & 0xFF) << 8), +                                | (mask[3] & 0xFF);, +, +                    // If the byte order of our buffers it little endian we have to bring our mask, +                    // into the same format, because getInt() and writeInt() will use a reversed byte order, +                    if (srcOrder == ByteOrder.LITTLE_ENDIAN) {, +                        intMask = Integer.reverseBytes(intMask);, +                    }, +, +                    for (; i + 3 < end; i += 4) {, +                        int intData = data.getInt(i);, +                        buf.writeInt(intData ^ intMask);, +                    }, +                }, +                for (; i < end; i++) {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocket08FrameDecoder.java, +import java.nio.ByteOrder;, +        int i = frame.readerIndex();, +        int end = frame.writerIndex();, +, +        ByteOrder order = frame.order();, +, +        // Remark: & 0xFF is necessary because Java will do signed expansion from, +        // byte to int which we don't want., +        int intMask = ((maskingKey[0] & 0xFF) << 24), +                    | ((maskingKey[1] & 0xFF) << 16), +                    | ((maskingKey[2] & 0xFF) << 8), +                    | (maskingKey[3] & 0xFF);, +, +        // If the byte order of our buffers it little endian we have to bring our mask, +        // into the same format, because getInt() and writeInt() will use a reversed byte order, +        if (order == ByteOrder.LITTLE_ENDIAN) {, +            intMask = Integer.reverseBytes(intMask);, +        }, +, +        for (; i + 3 < end; i += 4) {]