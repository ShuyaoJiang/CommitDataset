[+++ b/handler/src/main/java/io/netty/handler/timeout/ReadTimeoutException.java, +    private static final long serialVersionUID = 169287984113283421L;, +    public static final ReadTimeoutException INSTANCE = new ReadTimeoutException();, +    private ReadTimeoutException() {}, +++ b/handler/src/main/java/io/netty/handler/timeout/ReadTimeoutException.java, +    private static final long serialVersionUID = 169287984113283421L;, +    public static final ReadTimeoutException INSTANCE = new ReadTimeoutException();, +    private ReadTimeoutException() {}, +++ b/handler/src/main/java/io/netty/handler/timeout/ReadTimeoutHandler.java, +, +    private boolean closed;, +, +        if (!closed) {, +            ctx.fireExceptionCaught(ReadTimeoutException.INSTANCE);, +            ctx.close();, +            closed = true;, +        }, +++ b/handler/src/main/java/io/netty/handler/timeout/ReadTimeoutException.java, +    private static final long serialVersionUID = 169287984113283421L;, +    public static final ReadTimeoutException INSTANCE = new ReadTimeoutException();, +    private ReadTimeoutException() {}, +++ b/handler/src/main/java/io/netty/handler/timeout/ReadTimeoutHandler.java, +, +    private boolean closed;, +, +        if (!closed) {, +            ctx.fireExceptionCaught(ReadTimeoutException.INSTANCE);, +            ctx.close();, +            closed = true;, +        }, +++ b/handler/src/main/java/io/netty/handler/timeout/TimeoutException.java, +    TimeoutException() {}, +    @Override, +    public Throwable fillInStackTrace() {, +        return this;, +++ b/handler/src/main/java/io/netty/handler/timeout/ReadTimeoutException.java, +    private static final long serialVersionUID = 169287984113283421L;, +    public static final ReadTimeoutException INSTANCE = new ReadTimeoutException();, +    private ReadTimeoutException() {}, +++ b/handler/src/main/java/io/netty/handler/timeout/ReadTimeoutHandler.java, +, +    private boolean closed;, +, +        if (!closed) {, +            ctx.fireExceptionCaught(ReadTimeoutException.INSTANCE);, +            ctx.close();, +            closed = true;, +        }, +++ b/handler/src/main/java/io/netty/handler/timeout/TimeoutException.java, +    TimeoutException() {}, +    @Override, +    public Throwable fillInStackTrace() {, +        return this;, +++ b/handler/src/main/java/io/netty/handler/timeout/WriteTimeoutException.java, +    private static final long serialVersionUID = -144786655770296065L;, +    public static final WriteTimeoutException INSTANCE = new WriteTimeoutException();, +    private WriteTimeoutException() {}, +++ b/handler/src/main/java/io/netty/handler/timeout/ReadTimeoutException.java, +    private static final long serialVersionUID = 169287984113283421L;, +    public static final ReadTimeoutException INSTANCE = new ReadTimeoutException();, +    private ReadTimeoutException() {}, +++ b/handler/src/main/java/io/netty/handler/timeout/ReadTimeoutHandler.java, +, +    private boolean closed;, +, +        if (!closed) {, +            ctx.fireExceptionCaught(ReadTimeoutException.INSTANCE);, +            ctx.close();, +            closed = true;, +        }, +++ b/handler/src/main/java/io/netty/handler/timeout/TimeoutException.java, +    TimeoutException() {}, +    @Override, +    public Throwable fillInStackTrace() {, +        return this;, +++ b/handler/src/main/java/io/netty/handler/timeout/WriteTimeoutException.java, +    private static final long serialVersionUID = -144786655770296065L;, +    public static final WriteTimeoutException INSTANCE = new WriteTimeoutException();, +    private WriteTimeoutException() {}, +++ b/handler/src/main/java/io/netty/handler/timeout/WriteTimeoutHandler.java, +import io.netty.channel.ChannelBufferHolder;, +import io.netty.channel.ChannelBufferHolders;, +import io.netty.channel.ChannelOutboundHandlerAdapter;, +import io.netty.channel.ChannelOutboundHandlerContext;, +, +import java.nio.channels.Channels;, +import java.util.concurrent.ScheduledFuture;, +import java.util.concurrent.TimeUnit;, +public class WriteTimeoutHandler extends ChannelOutboundHandlerAdapter<Object> {, +    private boolean closed;, +, +    public WriteTimeoutHandler(int timeoutSeconds) {, +        this(timeoutSeconds, TimeUnit.SECONDS);, +    public WriteTimeoutHandler(long timeout, TimeUnit unit) {, +    public ChannelBufferHolder<Object> newOutboundBuffer(ChannelOutboundHandlerContext<Object> ctx) throws Exception {, +        return ChannelBufferHolders.outboundBypassBuffer(ctx);, +    public void flush(final ChannelOutboundHandlerContext<Object> ctx, final ChannelFuture future) throws Exception {, +            // Schedule a timeout., +            final ScheduledFuture<?> sf = ctx.eventLoop().schedule(new Runnable() {, +                public void run() {]