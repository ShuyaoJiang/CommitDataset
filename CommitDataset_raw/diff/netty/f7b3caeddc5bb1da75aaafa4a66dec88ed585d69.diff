[+++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslContext.java, +    final SSLEngine newEngine0(ByteBufAllocator alloc, String peerHost, int peerPort, boolean jdkCompatibilityMode) {, +        return new OpenSslEngine(this, alloc, peerHost, peerPort, jdkCompatibilityMode);, +++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslContext.java, +    final SSLEngine newEngine0(ByteBufAllocator alloc, String peerHost, int peerPort, boolean jdkCompatibilityMode) {, +        return new OpenSslEngine(this, alloc, peerHost, peerPort, jdkCompatibilityMode);, +++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslEngine.java, +    OpenSslEngine(OpenSslContext context, ByteBufAllocator alloc, String peerHost, int peerPort,, +                  boolean jdkCompatibilityMode) {, +        super(context, alloc, peerHost, peerPort, jdkCompatibilityMode, false);, +++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslContext.java, +    final SSLEngine newEngine0(ByteBufAllocator alloc, String peerHost, int peerPort, boolean jdkCompatibilityMode) {, +        return new OpenSslEngine(this, alloc, peerHost, peerPort, jdkCompatibilityMode);, +++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslEngine.java, +    OpenSslEngine(OpenSslContext context, ByteBufAllocator alloc, String peerHost, int peerPort,, +                  boolean jdkCompatibilityMode) {, +        super(context, alloc, peerHost, peerPort, jdkCompatibilityMode, false);, +++ b/handler/src/main/java/io/netty/handler/ssl/ReferenceCountedOpenSslContext.java, +        return newEngine0(alloc, peerHost, peerPort, true);, +    @Override, +    final SslHandler newHandler(ByteBufAllocator alloc, boolean startTls) {, +        return new SslHandler(newEngine0(alloc, null, -1, false), startTls, false);, +    }, +, +    @Override, +    final SslHandler newHandler(ByteBufAllocator alloc, String peerHost, int peerPort, boolean startTls) {, +        return new SslHandler(newEngine0(alloc, peerHost, peerPort, false), startTls, false);, +    }, +, +    SSLEngine newEngine0(ByteBufAllocator alloc, String peerHost, int peerPort, boolean jdkCompatibilityMode) {, +        return new ReferenceCountedOpenSslEngine(this, alloc, peerHost, peerPort, jdkCompatibilityMode, true);, +++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslContext.java, +    final SSLEngine newEngine0(ByteBufAllocator alloc, String peerHost, int peerPort, boolean jdkCompatibilityMode) {, +        return new OpenSslEngine(this, alloc, peerHost, peerPort, jdkCompatibilityMode);, +++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslEngine.java, +    OpenSslEngine(OpenSslContext context, ByteBufAllocator alloc, String peerHost, int peerPort,, +                  boolean jdkCompatibilityMode) {, +        super(context, alloc, peerHost, peerPort, jdkCompatibilityMode, false);, +++ b/handler/src/main/java/io/netty/handler/ssl/ReferenceCountedOpenSslContext.java, +        return newEngine0(alloc, peerHost, peerPort, true);, +    @Override, +    final SslHandler newHandler(ByteBufAllocator alloc, boolean startTls) {, +        return new SslHandler(newEngine0(alloc, null, -1, false), startTls, false);, +    }, +, +    @Override, +    final SslHandler newHandler(ByteBufAllocator alloc, String peerHost, int peerPort, boolean startTls) {, +        return new SslHandler(newEngine0(alloc, peerHost, peerPort, false), startTls, false);, +    }, +, +    SSLEngine newEngine0(ByteBufAllocator alloc, String peerHost, int peerPort, boolean jdkCompatibilityMode) {, +        return new ReferenceCountedOpenSslEngine(this, alloc, peerHost, peerPort, jdkCompatibilityMode, true);, +++ b/handler/src/main/java/io/netty/handler/ssl/ReferenceCountedOpenSslEngine.java, +, +import static java.lang.Integer.MAX_VALUE;, +     * Depends upon tcnative ... only use if tcnative is available!, +    static final int MAX_PLAINTEXT_LENGTH = SSL.SSL_MAX_PLAINTEXT_LENGTH;, +    private final boolean jdkCompatibilityMode;, +    private int maxWrapOverhead;, +    private int maxWrapBufferSize;, +     * @param jdkCompatibilityMode {@code true} to behave like described in, +     *                             https://docs.oracle.com/javase/7/docs/api/javax/net/ssl/SSLEngine.html., +     *                             {@code false} allows for partial and/or multiple packets to be process in a single, +     *                             wrap or unwrap call., +                                  int peerPort, boolean jdkCompatibilityMode, boolean leakDetection) {, +        this.jdkCompatibilityMode = jdkCompatibilityMode;, +        ssl = SSL.newSSL(context.ctx, !context.isClient());, +, +            if (!jdkCompatibilityMode) {, +                SSL.setMode(ssl, SSL.getMode(ssl) | SSL.SSL_MODE_ENABLE_PARTIAL_WRITE);, +            }, +, +            // setMode may impact the overhead., +            calculateMaxWrapOverhead();, +            final int len = min(maxEncryptedPacketLength0(), limit - pos);, +    /**, +     * Visible only for testing!, +     */, +    final synchronized int maxWrapOverhead() {, +        return maxWrapOverhead;, +    }, +, +    /**, +     * Visible only for testing!, +     */, +    final synchronized int maxEncryptedPacketLength() {, +        return maxEncryptedPacketLength0();, +    }, +, +    /**, +     * This method is intentionally not synchronized, only use if you know you are in the EventLoop, +     * thread and visibility on {@link #maxWrapOverhead} is achieved via other synchronized blocks., +     */, +    final int maxEncryptedPacketLength0() {, +        return maxWrapOverhead + MAX_PLAINTEXT_LENGTH;, +    }, +, +    /**, +     * This method is intentionally not synchronized, only use if you know you are in the EventLoop, +     * thread and visibility on {@link #maxWrapBufferSize} and {@link #maxWrapOverhead} is achieved]