[+++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslClientContext.java, +            sessionContext = new OpenSslClientSessionContext(this);, +        private OpenSslClientSessionContext(OpenSslContext context) {, +++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslClientContext.java, +            sessionContext = new OpenSslClientSessionContext(this);, +        private OpenSslClientSessionContext(OpenSslContext context) {, +++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslContext.java, +    // IMPORTANT: This method must only be called from either the constructor or the finalizer as a user MUST never, +    //            get access to an OpenSslSessionContext after this method was called to prevent the user from, +    //            producing a segfault., +    final void destroy() {, +++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslClientContext.java, +            sessionContext = new OpenSslClientSessionContext(this);, +        private OpenSslClientSessionContext(OpenSslContext context) {, +++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslContext.java, +    // IMPORTANT: This method must only be called from either the constructor or the finalizer as a user MUST never, +    //            get access to an OpenSslSessionContext after this method was called to prevent the user from, +    //            producing a segfault., +    final void destroy() {, +++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslServerContext.java, +            sessionContext = new OpenSslServerSessionContext(this);, +++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslClientContext.java, +            sessionContext = new OpenSslClientSessionContext(this);, +        private OpenSslClientSessionContext(OpenSslContext context) {, +++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslContext.java, +    // IMPORTANT: This method must only be called from either the constructor or the finalizer as a user MUST never, +    //            get access to an OpenSslSessionContext after this method was called to prevent the user from, +    //            producing a segfault., +    final void destroy() {, +++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslServerContext.java, +            sessionContext = new OpenSslServerSessionContext(this);, +++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslServerSessionContext.java, +    OpenSslServerSessionContext(OpenSslContext context) {, +        SSLContext.setSessionCacheTimeout(context.ctx, seconds);, +        return (int) SSLContext.getSessionCacheTimeout(context.ctx);, +        SSLContext.setSessionCacheSize(context.ctx, size);, +        return (int) SSLContext.getSessionCacheSize(context.ctx);, +        SSLContext.setSessionCacheMode(context.ctx, mode);, +        return SSLContext.getSessionCacheMode(context.ctx) == SSL.SSL_SESS_CACHE_SERVER;, +        return SSLContext.setSessionIdContext(context.ctx, sidCtx);, +++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslClientContext.java, +            sessionContext = new OpenSslClientSessionContext(this);, +        private OpenSslClientSessionContext(OpenSslContext context) {, +++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslContext.java, +    // IMPORTANT: This method must only be called from either the constructor or the finalizer as a user MUST never, +    //            get access to an OpenSslSessionContext after this method was called to prevent the user from, +    //            producing a segfault., +    final void destroy() {, +++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslServerContext.java, +            sessionContext = new OpenSslServerSessionContext(this);, +++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslServerSessionContext.java, +    OpenSslServerSessionContext(OpenSslContext context) {, +        SSLContext.setSessionCacheTimeout(context.ctx, seconds);, +        return (int) SSLContext.getSessionCacheTimeout(context.ctx);, +        SSLContext.setSessionCacheSize(context.ctx, size);, +        return (int) SSLContext.getSessionCacheSize(context.ctx);, +        SSLContext.setSessionCacheMode(context.ctx, mode);, +        return SSLContext.getSessionCacheMode(context.ctx) == SSL.SSL_SESS_CACHE_SERVER;, +        return SSLContext.setSessionIdContext(context.ctx, sidCtx);, +++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslSessionContext.java, +    final OpenSslContext context;, +    // IMPORTANT: We take the OpenSslContext and not just the long (which points the native instance) to prevent, +    //            the GC to collect OpenSslContext as this would also free the pointer and so could result in a, +    //            segfault when the user calls any of the methods here that try to pass the pointer down to the native, +    //            level., +    OpenSslSessionContext(OpenSslContext context) {, +        SSLContext.setSessionTicketKeys(context.ctx, keys);, +        SSLContext.setSessionTicketKeys(context.ctx, ticketKeys);, +++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslClientContext.java, +            sessionContext = new OpenSslClientSessionContext(this);, +        private OpenSslClientSessionContext(OpenSslContext context) {, +++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslContext.java, +    // IMPORTANT: This method must only be called from either the constructor or the finalizer as a user MUST never, +    //            get access to an OpenSslSessionContext after this method was called to prevent the user from, +    //            producing a segfault., +    final void destroy() {, +++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslServerContext.java, +            sessionContext = new OpenSslServerSessionContext(this);, +++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslServerSessionContext.java, +    OpenSslServerSessionContext(OpenSslContext context) {, +        SSLContext.setSessionCacheTimeout(context.ctx, seconds);, +        return (int) SSLContext.getSessionCacheTimeout(context.ctx);, +        SSLContext.setSessionCacheSize(context.ctx, size);, +        return (int) SSLContext.getSessionCacheSize(context.ctx);, +        SSLContext.setSessionCacheMode(context.ctx, mode);, +        return SSLContext.getSessionCacheMode(context.ctx) == SSL.SSL_SESS_CACHE_SERVER;, +        return SSLContext.setSessionIdContext(context.ctx, sidCtx);, +++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslSessionContext.java, +    final OpenSslContext context;, +    // IMPORTANT: We take the OpenSslContext and not just the long (which points the native instance) to prevent, +    //            the GC to collect OpenSslContext as this would also free the pointer and so could result in a, +    //            segfault when the user calls any of the methods here that try to pass the pointer down to the native, +    //            level., +    OpenSslSessionContext(OpenSslContext context) {, +        SSLContext.setSessionTicketKeys(context.ctx, keys);, +        SSLContext.setSessionTicketKeys(context.ctx, ticketKeys);, +++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslSessionStats.java, +    private final OpenSslContext context;, +    // IMPORTANT: We take the OpenSslContext and not just the long (which points the native instance) to prevent, +    //            the GC to collect OpenSslContext as this would also free the pointer and so could result in a]