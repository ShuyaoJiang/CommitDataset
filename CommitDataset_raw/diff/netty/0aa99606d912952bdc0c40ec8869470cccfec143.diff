[+++ b/transport/src/main/java/io/netty/channel/DefaultChannelHandlerContext.java, +import io.netty.buffer.ChannelBuffers;, +import io.netty.util.internal.QueueFactory;, +import java.util.ArrayDeque;, +    EventExecutor executor; // not thread-safe but OK because it never changes once set., +    // each other's buffers can be accessed at the same time resulting in a race condition., +    final AtomicReference<MessageBridge> inMsgBridge;, +    final AtomicReference<MessageBridge> outMsgBridge;, +    final AtomicReference<StreamBridge> inByteBridge;, +    final AtomicReference<StreamBridge> outByteBridge;, +    final Runnable curCtxFireInboundBufferUpdatedTask = new Runnable() {, +    private final Runnable nextCtxFireInboundBufferUpdatedTask = new Runnable() {, +        @Override, +        public void run() {, +            DefaultChannelHandlerContext next =, +                    DefaultChannelPipeline.nextInboundContext(DefaultChannelHandlerContext.this.next);, +            if (next != null) {, +                next.fillBridge();, +                DefaultChannelPipeline.fireInboundBufferUpdated(next);, +            }, +        }, +    };, +                    inByteBridge = new AtomicReference<StreamBridge>();, +                    inMsgBridge = new AtomicReference<MessageBridge>();, +                    outByteBridge = new AtomicReference<StreamBridge>();, +                    outMsgBridge = new AtomicReference<MessageBridge>();, +    void fillBridge() {, +        if (inMsgBridge != null) {, +            MessageBridge bridge = inMsgBridge.get();, +            if (bridge != null) {, +                bridge.fill();, +            }, +        } else if (inByteBridge != null) {, +            StreamBridge bridge = inByteBridge.get();, +            if (bridge != null) {, +                bridge.fill();, +            }, +        }, +, +        if (outMsgBridge != null) {, +            MessageBridge bridge = outMsgBridge.get();, +            if (bridge != null) {, +                bridge.fill();, +            }, +        } else if (outByteBridge != null) {, +            StreamBridge bridge = outByteBridge.get();, +            if (bridge != null) {, +                bridge.fill();, +            }, +        }, +    }, +, +            MessageBridge bridge = inMsgBridge.get();, +                bridge.flush(in.messageBuffer());, +            }, +        } else if (inByteBridge != null) {, +            StreamBridge bridge = inByteBridge.get();, +            if (bridge != null) {, +                bridge.flush(in.byteBuffer());, +, +            MessageBridge bridge = outMsgBridge.get();, +                bridge.flush(out.messageBuffer());, +            }, +        } else if (outByteBridge != null) {, +            StreamBridge bridge = outByteBridge.get();, +            if (bridge != null) {, +                bridge.flush(out.byteBuffer());, +            return executor = channel.eventLoop();, +        return DefaultChannelPipeline.nextInboundByteBuffer(executor(), next);, +        return pipeline.nextOutboundByteBuffer(executor(), prev);, +        EventExecutor executor = executor();, +        if (executor.inEventLoop()) {, +            nextCtxFireInboundBufferUpdatedTask.run();, +        } else {, +            executor.execute(nextCtxFireInboundBufferUpdatedTask);, +    public ChannelFuture flush(final ChannelFuture future) {, +        EventExecutor executor = executor();, +        if (executor.inEventLoop()) {, +            DefaultChannelHandlerContext prev = DefaultChannelPipeline.nextOutboundContext(this.prev);, +            prev.fillBridge();, +            pipeline.flush(prev, future);, +        } else {, +            executor.execute(new Runnable() {, +                @Override, +                public void run() {, +                    flush(future);, +                }, +            });, +        }, +, +        return future;, +, +    static final class MessageBridge {, +        final Queue<Object> msgBuf = new ArrayDeque<Object>();, +        final BlockingQueue<Object[]> exchangeBuf = QueueFactory.createQueue();, +, +        void fill() {, +            if (msgBuf.isEmpty()) {, +                return;, +            }]