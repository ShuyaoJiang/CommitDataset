[+++ b/buffer/src/main/java/io/netty/buffer/ByteBufUtil.java, +, +        for (;;) {, +                return writeUtf8((AbstractByteBuf) buf, seq, len);, +            } else if (buf instanceof WrappedByteBuf) {, +                // Unwrap as the wrapped buffer may be an AbstractByteBuf and so we can use fast-path., +                buf = buf.unwrap();, +            } else {, +                byte[] bytes = seq.toString().getBytes(CharsetUtil.UTF_8);, +                buf.writeBytes(bytes);, +                return bytes.length;, +            }, +        }, +    }, +, +    // Fast-Path implementation, +    private static int writeUtf8(AbstractByteBuf buffer, CharSequence seq, int len) {, +        } else {, +            for (;;) {, +                if (buf instanceof AbstractByteBuf) {, +                    writeAscii((AbstractByteBuf) buf, seq, len);, +                    break;, +                } else if (buf instanceof WrappedByteBuf) {, +                    // Unwrap as the wrapped buffer may be an AbstractByteBuf and so we can use fast-path., +                    buf = buf.unwrap();, +                } else {, +                    buf.writeBytes(seq.toString().getBytes(CharsetUtil.US_ASCII));, +                }, +            }, +        }, +        return len;, +    }, +, +    // Fast-Path implementation, +    private static void writeAscii(AbstractByteBuf buffer, CharSequence seq, int len) {, +++ b/buffer/src/main/java/io/netty/buffer/ByteBufUtil.java, +, +        for (;;) {, +                return writeUtf8((AbstractByteBuf) buf, seq, len);, +            } else if (buf instanceof WrappedByteBuf) {, +                // Unwrap as the wrapped buffer may be an AbstractByteBuf and so we can use fast-path., +                buf = buf.unwrap();, +            } else {, +                byte[] bytes = seq.toString().getBytes(CharsetUtil.UTF_8);, +                buf.writeBytes(bytes);, +                return bytes.length;, +            }, +        }, +    }, +, +    // Fast-Path implementation, +    private static int writeUtf8(AbstractByteBuf buffer, CharSequence seq, int len) {, +        } else {, +            for (;;) {, +                if (buf instanceof AbstractByteBuf) {, +                    writeAscii((AbstractByteBuf) buf, seq, len);, +                    break;, +                } else if (buf instanceof WrappedByteBuf) {, +                    // Unwrap as the wrapped buffer may be an AbstractByteBuf and so we can use fast-path., +                    buf = buf.unwrap();, +                } else {, +                    buf.writeBytes(seq.toString().getBytes(CharsetUtil.US_ASCII));, +                }, +            }, +        }, +        return len;, +    }, +, +    // Fast-Path implementation, +    private static void writeAscii(AbstractByteBuf buffer, CharSequence seq, int len) {, +++ b/buffer/src/main/java/io/netty/buffer/WrappedByteBuf.java, +/**, + * Wraps another {@link ByteBuf}., + *, + * It's important that the {@link #readerIndex()} and {@link #writerIndex()} will not do any adjustments on the, + * indices on the fly because of internal optimizations made by {@link ByteBufUtil#writeAscii(ByteBuf, CharSequence)}, + * and {@link ByteBufUtil#writeUtf8(ByteBuf, CharSequence)}., + */, +class WrappedByteBuf extends ByteBuf {, +    public final boolean hasMemoryAddress() {, +    public final long memoryAddress() {, +    public final int capacity() {, +    public final int maxCapacity() {, +    public final ByteBufAllocator alloc() {, +    public final ByteOrder order() {, +    public final ByteBuf unwrap() {, +    public final boolean isDirect() {, +    public final int readerIndex() {, +    public final ByteBuf readerIndex(int readerIndex) {, +    public final int writerIndex() {, +    public final ByteBuf writerIndex(int writerIndex) {, +    public final int readableBytes() {, +    public final int writableBytes() {, +    public final int maxWritableBytes() {, +    public final boolean isReadable() {, +    public final boolean isWritable() {, +    public final ByteBuf clear() {, +    public final ByteBuf markReaderIndex() {, +    public final ByteBuf resetReaderIndex() {, +    public final ByteBuf markWriterIndex() {]