[+++ b/src/main/java/org/jboss/netty/handler/timeout/HashedWheelTimer.java, +import java.util.concurrent.ThreadFactory;, +import java.util.concurrent.atomic.AtomicBoolean;, +    private final Worker worker = new Worker();, +    private final Thread workerThread;, +    final AtomicBoolean shutdown = new AtomicBoolean();, +    private final long roundDuration;, +    public HashedWheelTimer(ThreadFactory threadFactory) {, +        this(threadFactory, 100, TimeUnit.MILLISECONDS, 512); // about 50 sec, +            ThreadFactory threadFactory,, +        if (threadFactory == null) {, +            throw new NullPointerException("threadFactory");, +, +        workerThread = threadFactory.newThread(worker);, +            wheel[i] = new MapBackedSet<HashedWheelTimeout>(, +                    new ConcurrentIdentityHashMap<HashedWheelTimeout, Boolean>(16, 0.95f, 4));, +    public void start() {, +        workerThread.start();, +    }, +, +    public void stop() {, +        if (!shutdown.compareAndSet(false, true)) {, +            return;, +        }, +        while (workerThread.isAlive()) {, +            workerThread.interrupt();, +            try {, +                workerThread.join(100);, +            } catch (InterruptedException e) {, +                // Ignore, +            }, +        }, +        if (!workerThread.isAlive()) {, +            start();, +        }, +, +        public synchronized void run() {, +            while (!shutdown.get()) {, +                waitForNextTick();, +                fetchExpiredTimeouts(expiredTimeouts);, +        private void fetchExpiredTimeouts(, +        private void waitForNextTick() {, +                    if (shutdown.get()) {, +                        return;, +                wheel[stopIndex].remove(this);, +                wheel[newStopIndex].add(this);, +++ b/src/main/java/org/jboss/netty/handler/timeout/HashedWheelTimer.java, +import java.util.concurrent.ThreadFactory;, +import java.util.concurrent.atomic.AtomicBoolean;, +    private final Worker worker = new Worker();, +    private final Thread workerThread;, +    final AtomicBoolean shutdown = new AtomicBoolean();, +    private final long roundDuration;, +    public HashedWheelTimer(ThreadFactory threadFactory) {, +        this(threadFactory, 100, TimeUnit.MILLISECONDS, 512); // about 50 sec, +            ThreadFactory threadFactory,, +        if (threadFactory == null) {, +            throw new NullPointerException("threadFactory");, +, +        workerThread = threadFactory.newThread(worker);, +            wheel[i] = new MapBackedSet<HashedWheelTimeout>(, +                    new ConcurrentIdentityHashMap<HashedWheelTimeout, Boolean>(16, 0.95f, 4));, +    public void start() {, +        workerThread.start();, +    }, +, +    public void stop() {, +        if (!shutdown.compareAndSet(false, true)) {, +            return;, +        }, +        while (workerThread.isAlive()) {, +            workerThread.interrupt();, +            try {, +                workerThread.join(100);, +            } catch (InterruptedException e) {, +                // Ignore, +            }, +        }, +        if (!workerThread.isAlive()) {, +            start();, +        }, +, +        public synchronized void run() {, +            while (!shutdown.get()) {, +                waitForNextTick();, +                fetchExpiredTimeouts(expiredTimeouts);, +        private void fetchExpiredTimeouts(, +        private void waitForNextTick() {, +                    if (shutdown.get()) {, +                        return;, +                wheel[stopIndex].remove(this);, +                wheel[newStopIndex].add(this);, +++ b/src/main/java/org/jboss/netty/handler/timeout/Timer.java, +public interface Timer {, +    // XXX Should we make stop() return the list of unfinished Timeouts?, +    void stop();]