[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FrameCodec.java, +import io.netty.channel.ChannelPromiseNotifier;, +import io.netty.handler.codec.http2.Http2Stream.State;, + * the {@link Http2FrameCodec} can be build with {@link Http2FrameCodecBuilder#bufferOutboundStreams} enabled, in which, +        return new Http2Stream2Impl(ctx0.channel());, +                    // TODO(buchgr): Remove once Http2Stream2 and Http2Stream are merged., +                    return true;, +            // Ensure that the listener gets executed before any listeners a user might have attached., +            // TODO(buchgr): Once Http2Stream2 and Http2Stream are merged this is no longer necessary., +            ChannelPromiseNotifier promiseNotifier = new ChannelPromiseNotifier(promise);, +            promise = ctx.newPromise();, +                        stream.legacyStream = connectionStream;, +            promise.addListener(promiseNotifier);, +            Http2Stream2Impl stream2 = new Http2Stream2Impl(ctx.channel()).id(stream.id());, +            stream2.legacyStream = stream;, +            stream.setProperty(streamKey, stream2);, +         * Exceptions for unknown streams, that is streams that have no {@link Http2Stream2} object attached, +    // TODO(buchgr): Merge Http2Stream2 and Http2Stream., +        private volatile Http2Stream legacyStream;, +        public State state() {, +            Http2Stream stream0 = legacyStream;, +            return stream0 == null, +                    ? State.IDLE, +                    : stream0.state();, +        }, +, +        @Override, +            if (state() == State.IDLE) {, +                throw new IllegalStateException("This method may not be called on IDLE streams.");, +            }, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FrameCodec.java, +import io.netty.channel.ChannelPromiseNotifier;, +import io.netty.handler.codec.http2.Http2Stream.State;, + * the {@link Http2FrameCodec} can be build with {@link Http2FrameCodecBuilder#bufferOutboundStreams} enabled, in which, +        return new Http2Stream2Impl(ctx0.channel());, +                    // TODO(buchgr): Remove once Http2Stream2 and Http2Stream are merged., +                    return true;, +            // Ensure that the listener gets executed before any listeners a user might have attached., +            // TODO(buchgr): Once Http2Stream2 and Http2Stream are merged this is no longer necessary., +            ChannelPromiseNotifier promiseNotifier = new ChannelPromiseNotifier(promise);, +            promise = ctx.newPromise();, +                        stream.legacyStream = connectionStream;, +            promise.addListener(promiseNotifier);, +            Http2Stream2Impl stream2 = new Http2Stream2Impl(ctx.channel()).id(stream.id());, +            stream2.legacyStream = stream;, +            stream.setProperty(streamKey, stream2);, +         * Exceptions for unknown streams, that is streams that have no {@link Http2Stream2} object attached, +    // TODO(buchgr): Merge Http2Stream2 and Http2Stream., +        private volatile Http2Stream legacyStream;, +        public State state() {, +            Http2Stream stream0 = legacyStream;, +            return stream0 == null, +                    ? State.IDLE, +                    : stream0.state();, +        }, +, +        @Override, +            if (state() == State.IDLE) {, +                throw new IllegalStateException("This method may not be called on IDLE streams.");, +            }, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2MultiplexCodec.java, +        stream.closeFuture().addListener(new ChannelFutureListener() {, +            @Override, +            public void operationComplete(ChannelFuture future)  {, +                childChannel.streamClosedWithoutError = true;, +                childChannel.fireChildRead(AbstractHttp2StreamChannel.CLOSE_MESSAGE);, +            }, +        });, +, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FrameCodec.java, +import io.netty.channel.ChannelPromiseNotifier;, +import io.netty.handler.codec.http2.Http2Stream.State;, + * the {@link Http2FrameCodec} can be build with {@link Http2FrameCodecBuilder#bufferOutboundStreams} enabled, in which, +        return new Http2Stream2Impl(ctx0.channel());, +                    // TODO(buchgr): Remove once Http2Stream2 and Http2Stream are merged., +                    return true;, +            // Ensure that the listener gets executed before any listeners a user might have attached., +            // TODO(buchgr): Once Http2Stream2 and Http2Stream are merged this is no longer necessary., +            ChannelPromiseNotifier promiseNotifier = new ChannelPromiseNotifier(promise);, +            promise = ctx.newPromise();, +                        stream.legacyStream = connectionStream;, +            promise.addListener(promiseNotifier);, +            Http2Stream2Impl stream2 = new Http2Stream2Impl(ctx.channel()).id(stream.id());, +            stream2.legacyStream = stream;, +            stream.setProperty(streamKey, stream2);, +         * Exceptions for unknown streams, that is streams that have no {@link Http2Stream2} object attached, +    // TODO(buchgr): Merge Http2Stream2 and Http2Stream., +        private volatile Http2Stream legacyStream;, +        public State state() {, +            Http2Stream stream0 = legacyStream;, +            return stream0 == null, +                    ? State.IDLE, +                    : stream0.state();, +        }, +, +        @Override, +            if (state() == State.IDLE) {, +                throw new IllegalStateException("This method may not be called on IDLE streams.");, +            }, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2MultiplexCodec.java]