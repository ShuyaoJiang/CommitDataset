[+++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, +        if (minWritableBytes <= writableBytes()) {, +            return;, +        }, +, +            throw new IndexOutOfBoundsException(String.format(, +    @Override, +    public int ensureWritableBytes(int minWritableBytes, boolean force) {, +        if (minWritableBytes < 0) {, +            throw new IllegalArgumentException(String.format(, +                    "minWritableBytes: %d (expected: >= 0)", minWritableBytes));, +        }, +, +        if (minWritableBytes <= writableBytes()) {, +            return 0;, +        }, +, +        if (minWritableBytes > maxCapacity - writerIndex) {, +            if (force) {, +                if (capacity() == maxCapacity()) {, +                    return 1;, +                }, +, +                capacity(maxCapacity());, +                return 3;, +            }, +        }, +, +        // Normalize the current capacity to the power of 2., +        int newCapacity = calculateNewCapacity(writerIndex + minWritableBytes);, +, +        // Adjust to the new capacity., +        capacity(newCapacity);, +        return 2;, +    }, +, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, +        if (minWritableBytes <= writableBytes()) {, +            return;, +        }, +, +            throw new IndexOutOfBoundsException(String.format(, +    @Override, +    public int ensureWritableBytes(int minWritableBytes, boolean force) {, +        if (minWritableBytes < 0) {, +            throw new IllegalArgumentException(String.format(, +                    "minWritableBytes: %d (expected: >= 0)", minWritableBytes));, +        }, +, +        if (minWritableBytes <= writableBytes()) {, +            return 0;, +        }, +, +        if (minWritableBytes > maxCapacity - writerIndex) {, +            if (force) {, +                if (capacity() == maxCapacity()) {, +                    return 1;, +                }, +, +                capacity(maxCapacity());, +                return 3;, +            }, +        }, +, +        // Normalize the current capacity to the power of 2., +        int newCapacity = calculateNewCapacity(writerIndex + minWritableBytes);, +, +        // Adjust to the new capacity., +        capacity(newCapacity);, +        return 2;, +    }, +, +++ b/buffer/src/main/java/io/netty/buffer/ByteBuf.java, +     * Otherwise, it raises an {@link IllegalArgumentException}., +     * @param minWritableBytes, +     *         if {@link #writerIndex()} + {@code minWritableBytes} > {@link #maxCapacity()}, +    void ensureWritableBytes(int minWritableBytes);, +, +    /**, +     * Tries to make sure the number of {@linkplain #writableBytes() the writable bytes}, +     * is equal to or greater than the specified value.  Unlike {@link #ensureWritableBytes(int)},, +     * this method does not raise an exception but returns a code., +     *, +     * @param minWritableBytes, +     *        the expected minimum number of writable bytes, +     * @param force, +     *        When {@link #writerIndex()} + {@code minWritableBytes} > {@link #maxCapacity()}:, +     *        <ul>, +     *        <li>{@code true} - the capacity of the buffer is expanded to {@link #maxCapacity()}</li>, +     *        <li>{@code false} - the capacity of the buffer is unchanged</li>, +     *        </ul>, +     * @return {@code 0} if the buffer has enough writable bytes, and its capacity is unchanged., +     *         {@code 1} if the buffer does not have enough bytes, and its capacity is unchanged., +     *         {@code 2} if the buffer has enough writable bytes, and its capacity has been increased., +     *         {@code 3} if the buffer does not have enough bytes, but its capacity has been, +     *                   increased to its maximum., +     */, +    int ensureWritableBytes(int minWritableBytes, boolean force);, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, +        if (minWritableBytes <= writableBytes()) {]