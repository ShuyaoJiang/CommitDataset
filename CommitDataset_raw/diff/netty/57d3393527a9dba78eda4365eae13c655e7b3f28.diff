[+++ b/handler/src/main/java/io/netty/handler/ssl/AbstractSniHandler.java, +/*, + * Copyright 2017 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + *   http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the, + * License for the specific language governing permissions and limitations, + * under the License., + */, +package io.netty.handler.ssl;, +, +import io.netty.buffer.ByteBuf;, +import io.netty.buffer.ByteBufUtil;, +import io.netty.channel.ChannelHandlerContext;, +import io.netty.channel.ChannelOutboundHandler;, +import io.netty.channel.ChannelPromise;, +import io.netty.handler.codec.ByteToMessageDecoder;, +import io.netty.handler.codec.DecoderException;, +import io.netty.util.CharsetUtil;, +import io.netty.util.concurrent.Future;, +import io.netty.util.concurrent.FutureListener;, +import io.netty.util.internal.PlatformDependent;, +import io.netty.util.internal.logging.InternalLogger;, +import io.netty.util.internal.logging.InternalLoggerFactory;, +, +import java.net.IDN;, +import java.net.SocketAddress;, +import java.util.List;, +import java.util.Locale;, +, +/**, + * <p>Enables <a href="https://tools.ietf.org/html/rfc3546#section-3.1">SNI, + * (Server Name Indication)</a> extension for server side SSL. For clients, + * support SNI, the server could have multiple host name bound on a single IP., + * The client will send host name in the handshake data so server could decide, + * which certificate to choose for the host name.</p>, + */, +public abstract class AbstractSniHandler<T> extends ByteToMessageDecoder implements ChannelOutboundHandler {, +, +    // Maximal number of ssl records to inspect before fallback to the default SslContext., +    private static final int MAX_SSL_RECORDS = 4;, +, +    private static final InternalLogger logger =, +            InternalLoggerFactory.getInstance(AbstractSniHandler.class);, +, +    private boolean handshakeFailed;, +    private boolean suppressRead;, +    private boolean readPending;, +, +    @Override, +    protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) throws Exception {, +        if (!suppressRead && !handshakeFailed) {, +            final int writerIndex = in.writerIndex();, +            try {, +                loop:, +                for (int i = 0; i < MAX_SSL_RECORDS; i++) {, +                    final int readerIndex = in.readerIndex();, +                    final int readableBytes = writerIndex - readerIndex;, +                    if (readableBytes < SslUtils.SSL_RECORD_HEADER_LENGTH) {, +                        // Not enough data to determine the record type and length., +                        return;, +                    }, +, +                    final int command = in.getUnsignedByte(readerIndex);, +, +                    // tls, but not handshake command, +                    switch (command) {, +                        case SslUtils.SSL_CONTENT_TYPE_CHANGE_CIPHER_SPEC:, +                        case SslUtils.SSL_CONTENT_TYPE_ALERT:, +                            final int len = SslUtils.getEncryptedPacketLength(in, readerIndex);, +, +                            // Not an SSL/TLS packet, +                            if (len == SslUtils.NOT_ENCRYPTED) {, +                                handshakeFailed = true;, +                                NotSslRecordException e = new NotSslRecordException(, +                                        "not an SSL/TLS record: " + ByteBufUtil.hexDump(in));, +                                in.skipBytes(in.readableBytes());, +, +                                SslUtils.notifyHandshakeFailure(ctx, e);, +                                throw e;, +                            }, +                            if (len == SslUtils.NOT_ENOUGH_DATA ||, +                                    writerIndex - readerIndex - SslUtils.SSL_RECORD_HEADER_LENGTH < len) {, +                                // Not enough data, +                                return;, +                            }, +                            // increase readerIndex and try again., +                            in.skipBytes(len);, +                            continue;, +                        case SslUtils.SSL_CONTENT_TYPE_HANDSHAKE:, +                            final int majorVersion = in.getUnsignedByte(readerIndex + 1);, +, +                            // SSLv3 or TLS]