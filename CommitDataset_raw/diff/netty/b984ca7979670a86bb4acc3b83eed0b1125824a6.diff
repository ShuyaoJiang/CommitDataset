[+++ b/transport-native-epoll/src/main/c/io_netty_channel_epoll_Native.c, +    uint32_t events = (flags & EPOLL_EDGE) ? EPOLLET : 0;, +++ b/transport-native-epoll/src/main/c/io_netty_channel_epoll_Native.c, +    uint32_t events = (flags & EPOLL_EDGE) ? EPOLLET : 0;, +++ b/transport-native-epoll/src/main/c/io_netty_channel_epoll_Native.h, +#define EPOLL_RDHUP 0x04, +#define EPOLL_EDGE 0x08, +, +++ b/transport-native-epoll/src/main/c/io_netty_channel_epoll_Native.c, +    uint32_t events = (flags & EPOLL_EDGE) ? EPOLLET : 0;, +++ b/transport-native-epoll/src/main/c/io_netty_channel_epoll_Native.h, +#define EPOLL_RDHUP 0x04, +#define EPOLL_EDGE 0x08, +, +++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/AbstractEpollChannel.java, +    protected int flags = Native.EPOLLET;, +, +    void setFlag(int flag) {, +        if (!isFlagSet(flag)) {, +            flags |= flag;, +            modifyEvents();, +        }, +    }, +, +    void clearFlag(int flag) {, +        if (isFlagSet(flag)) {, +            flags &= ~flag;, +            modifyEvents();, +        }, +    }, +, +    boolean isFlagSet(int flag) {, +        return (flags & flag) != 0;, +    }, +, +    public abstract EpollChannelConfig config();, +, +    @Override, +        setFlag(readFlag);, +        if (isOpen() && isRegistered()) {, +                    setFlag(Native.EPOLLOUT);, +                    setFlag(Native.EPOLLOUT);, +            if (isFlagSet(Native.EPOLLOUT)) {, +            clearFlag(readFlag);, +++ b/transport-native-epoll/src/main/c/io_netty_channel_epoll_Native.c, +    uint32_t events = (flags & EPOLL_EDGE) ? EPOLLET : 0;, +++ b/transport-native-epoll/src/main/c/io_netty_channel_epoll_Native.h, +#define EPOLL_RDHUP 0x04, +#define EPOLL_EDGE 0x08, +, +++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/AbstractEpollChannel.java, +    protected int flags = Native.EPOLLET;, +, +    void setFlag(int flag) {, +        if (!isFlagSet(flag)) {, +            flags |= flag;, +            modifyEvents();, +        }, +    }, +, +    void clearFlag(int flag) {, +        if (isFlagSet(flag)) {, +            flags &= ~flag;, +            modifyEvents();, +        }, +    }, +, +    boolean isFlagSet(int flag) {, +        return (flags & flag) != 0;, +    }, +, +    public abstract EpollChannelConfig config();, +, +    @Override, +        setFlag(readFlag);, +        if (isOpen() && isRegistered()) {, +                    setFlag(Native.EPOLLOUT);, +                    setFlag(Native.EPOLLOUT);, +            if (isFlagSet(Native.EPOLLOUT)) {, +            clearFlag(readFlag);, +++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/AbstractEpollServerChannel.java, +        super(fd, Native.EPOLLIN);, +                    boolean edgeTriggered = isFlagSet(Native.EPOLLET);, +                    // if edgeTriggered is used we need to read all messages as we are not notified again otherwise., +                    final int maxMessagesPerRead = edgeTriggered, +                            ? Integer.MAX_VALUE : config().getMaxMessagesPerRead();, +                    int messages = 0;, +                    do {, +                        } finally {, +                            if (!edgeTriggered && !config().isAutoRead()) {, +                                // This is not using EPOLLET so we can stop reading, +                                // ASAP as we will get notified again later with, +                                // pending data, +                                break;, +                    } while (++ messages < maxMessagesPerRead);, +++ b/transport-native-epoll/src/main/c/io_netty_channel_epoll_Native.c, +    uint32_t events = (flags & EPOLL_EDGE) ? EPOLLET : 0;, +++ b/transport-native-epoll/src/main/c/io_netty_channel_epoll_Native.h, +#define EPOLL_RDHUP 0x04, +#define EPOLL_EDGE 0x08]