[+++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, +        ensureAccessible();, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, +        ensureAccessible();, +++ b/buffer/src/main/java/io/netty/buffer/AbstractPooledDerivedByteBuf.java, +        ensureAccessible();, +        ensureAccessible();, +            ensureAccessible();, +            checkIndex(index, length);, +            ensureAccessible();, +            checkIndex(index, length);, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, +        ensureAccessible();, +++ b/buffer/src/main/java/io/netty/buffer/AbstractPooledDerivedByteBuf.java, +        ensureAccessible();, +        ensureAccessible();, +            ensureAccessible();, +            checkIndex(index, length);, +            ensureAccessible();, +            checkIndex(index, length);, +++ b/buffer/src/test/java/io/netty/buffer/AbstractByteBufTest.java, +    @Test(expected = IllegalReferenceCountException.class), +    public void testSliceAfterRelease() {, +        releasedBuffer().slice();, +    }, +, +    @Test(expected = IllegalReferenceCountException.class), +    public void testSliceAfterRelease2() {, +        releasedBuffer().slice(0, 1);, +    }, +, +    private static void assertSliceFailAfterRelease(ByteBuf... bufs) {, +        for (ByteBuf buf : bufs) {, +            if (buf.refCnt() > 0) {, +                buf.release();, +            }, +        }, +        for (ByteBuf buf : bufs) {, +            try {, +                assertEquals(0, buf.refCnt());, +                buf.slice();, +                fail();, +            } catch (IllegalReferenceCountException ignored) {, +                // as expected, +            }, +        }, +    }, +, +    @Test, +    public void testSliceAfterReleaseRetainedSlice() {, +        ByteBuf buf = newBuffer(1);, +        ByteBuf buf2 = buf.retainedSlice(0, 1);, +        assertSliceFailAfterRelease(buf, buf2);, +    }, +, +    @Test, +    public void testSliceAfterReleaseRetainedSliceDuplicate() {, +        ByteBuf buf = newBuffer(1);, +        ByteBuf buf2 = buf.retainedSlice(0, 1);, +        ByteBuf buf3 = buf2.duplicate();, +        assertSliceFailAfterRelease(buf, buf2, buf3);, +    }, +, +    @Test, +    public void testSliceAfterReleaseRetainedSliceRetainedDuplicate() {, +        ByteBuf buf = newBuffer(1);, +        ByteBuf buf2 = buf.retainedSlice(0, 1);, +        ByteBuf buf3 = buf2.retainedDuplicate();, +        assertSliceFailAfterRelease(buf, buf2, buf3);, +    }, +, +    @Test, +    public void testSliceAfterReleaseRetainedDuplicate() {, +        ByteBuf buf = newBuffer(1);, +        ByteBuf buf2 = buf.retainedDuplicate();, +        assertSliceFailAfterRelease(buf, buf2);, +    }, +, +    @Test, +    public void testSliceAfterReleaseRetainedDuplicateSlice() {, +        ByteBuf buf = newBuffer(1);, +        ByteBuf buf2 = buf.retainedDuplicate();, +        ByteBuf buf3 = buf2.slice(0, 1);, +        assertSliceFailAfterRelease(buf, buf2, buf3);, +    }, +, +    @Test(expected = IllegalReferenceCountException.class), +    public void testRetainedSliceAfterRelease() {, +        releasedBuffer().retainedSlice();, +    }, +, +    @Test(expected = IllegalReferenceCountException.class), +    public void testRetainedSliceAfterRelease2() {, +        releasedBuffer().retainedSlice(0, 1);, +    }, +, +    private static void assertRetainedSliceFailAfterRelease(ByteBuf... bufs) {, +        for (ByteBuf buf : bufs) {, +            if (buf.refCnt() > 0) {, +                buf.release();]