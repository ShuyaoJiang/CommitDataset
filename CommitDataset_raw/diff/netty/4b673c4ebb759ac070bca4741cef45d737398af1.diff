[+++ b/example/src/main/java/io/netty/example/echo/EchoClient.java, +import io.netty.buffer.ChannelBuffer;, +import io.netty.buffer.ChannelBuffers;, +import io.netty.channel.ChannelBufferHolder;, +import io.netty.channel.ChannelBufferHolders;, +import io.netty.channel.ChannelInboundHandlerAdapter;, +import io.netty.channel.ChannelInboundHandlerContext;, +import io.netty.channel.EventLoop;, +import io.netty.channel.MultithreadEventLoop;, +import io.netty.channel.socket.SocketChannel;, +import io.netty.channel.socket.nio.NioSocketChannel;, +import io.netty.channel.socket.nio.SelectorEventLoop;, +import io.netty.handler.logging.LoggingHandler;, +import io.netty.logging.InternalLogLevel;, +import java.net.InetSocketAddress;, +import java.util.concurrent.atomic.AtomicLong;, +    private final AtomicLong transferredBytes = new AtomicLong();, +    public void run() throws Exception {, +        EventLoop loop = new MultithreadEventLoop(SelectorEventLoop.class);, +        SocketChannel s = new NioSocketChannel();, +        s.config().setTcpNoDelay(true);, +        s.pipeline().addLast("logger", new LoggingHandler(InternalLogLevel.INFO));, +        s.pipeline().addLast("echoer", new ChannelInboundHandlerAdapter<Byte>() {, +            private final ChannelBuffer firstMessage;, +            {, +                if (firstMessageSize <= 0) {, +                    throw new IllegalArgumentException(, +                            "firstMessageSize: " + firstMessageSize);, +                }, +                firstMessage = ChannelBuffers.buffer(firstMessageSize);, +                for (int i = 0; i < firstMessage.capacity(); i ++) {, +                    firstMessage.writeByte((byte) i);, +                }, +            }, +, +            @Override, +            public ChannelBufferHolder<Byte> newInboundBuffer(ChannelInboundHandlerContext<Byte> ctx) {, +                return ChannelBufferHolders.byteBuffer(ChannelBuffers.dynamicBuffer());, +            }, +, +            @Override, +            public void channelActive(ChannelInboundHandlerContext<Byte> ctx), +                    throws Exception {, +                ctx.write(firstMessage);, +            }, +, +            @Override, +            public void inboundBufferUpdated(, +                    ChannelInboundHandlerContext<Byte> ctx) throws Exception {, +                ChannelBuffer in = ctx.in().byteBuffer();, +                ChannelBuffer out = ctx.out().byteBuffer();, +                transferredBytes.addAndGet(in.readableBytes());, +, +                out.discardReadBytes();, +                out.writeBytes(in);, +                in.clear();, +                ctx.flush();, +        loop.register(s).awaitUninterruptibly().rethrowIfFailed();, +        s.connect(new InetSocketAddress(host, port)).awaitUninterruptibly().rethrowIfFailed();, +        // FIXME: Wait until the connection is closed or the connection attempt fails., +        // FIXME: Show how to shut down., +++ b/example/src/main/java/io/netty/example/echo/EchoClient.java, +import io.netty.buffer.ChannelBuffer;, +import io.netty.buffer.ChannelBuffers;, +import io.netty.channel.ChannelBufferHolder;, +import io.netty.channel.ChannelBufferHolders;, +import io.netty.channel.ChannelInboundHandlerAdapter;, +import io.netty.channel.ChannelInboundHandlerContext;, +import io.netty.channel.EventLoop;, +import io.netty.channel.MultithreadEventLoop;, +import io.netty.channel.socket.SocketChannel;, +import io.netty.channel.socket.nio.NioSocketChannel;, +import io.netty.channel.socket.nio.SelectorEventLoop;, +import io.netty.handler.logging.LoggingHandler;, +import io.netty.logging.InternalLogLevel;, +import java.net.InetSocketAddress;, +import java.util.concurrent.atomic.AtomicLong;, +    private final AtomicLong transferredBytes = new AtomicLong();, +    public void run() throws Exception {, +        EventLoop loop = new MultithreadEventLoop(SelectorEventLoop.class);, +        SocketChannel s = new NioSocketChannel();, +        s.config().setTcpNoDelay(true);, +        s.pipeline().addLast("logger", new LoggingHandler(InternalLogLevel.INFO));, +        s.pipeline().addLast("echoer", new ChannelInboundHandlerAdapter<Byte>() {, +            private final ChannelBuffer firstMessage;, +            {, +                if (firstMessageSize <= 0) {, +                    throw new IllegalArgumentException(, +                            "firstMessageSize: " + firstMessageSize);, +                }, +                firstMessage = ChannelBuffers.buffer(firstMessageSize);, +                for (int i = 0; i < firstMessage.capacity(); i ++) {, +                    firstMessage.writeByte((byte) i);, +                }, +            }, +, +            @Override, +            public ChannelBufferHolder<Byte> newInboundBuffer(ChannelInboundHandlerContext<Byte> ctx) {, +                return ChannelBufferHolders.byteBuffer(ChannelBuffers.dynamicBuffer());, +            }]