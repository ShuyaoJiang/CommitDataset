[+++ b/common/src/main/java/io/netty/util/HashedWheelTimer.java, +, +                if (timeout.state() == HashedWheelTimeout.ST_CANCELLED, +                        || !timeout.compareAndSetState(HashedWheelTimeout.ST_INIT, HashedWheelTimeout.ST_IN_BUCKET)) {, +                    // Was cancelled in the meantime. So just remove it and continue with next HashedWheelTimeout, +                    // in the queue, +                    timeout.remove();, +                    continue;, +                }, +        private static final int ST_IN_BUCKET = 1;, +        private static final int ST_CANCELLED = 2;, +        private static final int ST_EXPIRED = 3;, +        // The bucket to which the timeout was added, +        HashedWheelBucket bucket;, +, +            int state = state();, +            if (state >= ST_CANCELLED) {, +                // fail fast if the task was cancelled or expired before., +            if (state != ST_IN_BUCKET && compareAndSetState(ST_INIT, ST_CANCELLED)) {, +                // Was cancelled before the HashedWheelTimeout was added to its HashedWheelBucket., +                // In this case we can just return here as it will be discarded by the WorkerThread when handling, +                // the adding of HashedWheelTimeout to the HashedWheelBuckets., +            // only update the state it will be removed from HashedWheelBucket on next tick., +            if (!compareAndSetState(ST_IN_BUCKET, ST_CANCELLED)) {, +                return false;, +            }, +            // Add the HashedWheelTimeout back to the timeouts queue so it will be picked up on the next tick, +            // and remove this HashedTimeTask from the HashedWheelBucket. After this is done it is ready to get, +            // GC'ed once the user has no reference to it anymore., +            timer.timeouts.add(this);, +            return true;, +        }, +, +        public void remove() {, +            if (bucket != null) {, +                bucket.remove(this);, +            }, +        }, +, +        public boolean compareAndSetState(int expected, int state) {, +            return STATE_UPDATER.compareAndSet(this, expected, state);, +        }, +, +        public int state() {, +            return state;, +        }, +            return state() == ST_CANCELLED;, +            return state() > ST_IN_BUCKET;, +            if (!compareAndSetState(ST_IN_BUCKET, ST_EXPIRED)) {, +                assert state() != ST_INIT;, +            assert timeout.bucket == null;, +            timeout.bucket = this;, +                    remove(timeout);, +                }, +                timeout = next;, +            }, +        }, +, +        public void remove(HashedWheelTimeout timeout) {, +            HashedWheelTimeout next = timeout.next;, +                timeout.prev.next = next;, +                if (timeout == tail) {, +                    tail = null;, +                    head = null;, +                } else {, +                    head = next;, +            // null out prev, next and bucket to allow for GC., +            timeout.bucket = null;, +            head.bucket = null;]