[+++ b/transport/src/main/java/io/netty/channel/Channels.java, +     * the specified {@link Channel} in the next io-thread., +     */, +    public static void fireWriteCompleteLater(Channel channel, long amount) {, +        if (amount == 0) {, +            return;, +        }, +, +        channel.getPipeline().sendUpstreamLater(, +                new DefaultWriteCompletionEvent(channel, amount));, +    }, +, +    , +    /**, +     * Sends a {@code "writeComplete"} event to the first, +     * {@link ChannelUpstreamHandler} in the {@link ChannelPipeline} of, +++ b/transport/src/main/java/io/netty/channel/Channels.java, +     * the specified {@link Channel} in the next io-thread., +     */, +    public static void fireWriteCompleteLater(Channel channel, long amount) {, +        if (amount == 0) {, +            return;, +        }, +, +        channel.getPipeline().sendUpstreamLater(, +                new DefaultWriteCompletionEvent(channel, amount));, +    }, +, +    , +    /**, +     * Sends a {@code "writeComplete"} event to the first, +     * {@link ChannelUpstreamHandler} in the {@link ChannelPipeline} of, +++ b/transport/src/main/java/io/netty/channel/socket/nio/AbstractNioWorker.java, +        boolean iothread = isIoThread(channel);, +                    if (iothread) {, +                    } else {, +                        fireExceptionCaughtLater(channel, t);, +                    }, +        if (iothread) {, +        } else {, +            fireWriteCompleteLater(channel, writtenBytes);, +        }, +    }, +, +    static boolean isIoThread(AbstractNioChannel<?> channel) {, +        return Thread.currentThread() == channel.worker.thread;, +        boolean iothread = isIoThread(channel);, +        , +                    if (iothread) {, +                    } else {, +                        fireChannelDisconnectedLater(channel);, +                    }, +                    if (iothread) {, +                    } else {, +                        fireChannelUnboundLater(channel);, +                    }, +                if (iothread) {, +                    fireChannelClosedLater(channel);, +                }, +            } else {, +            if (iothread) {, +            } else {, +                fireExceptionCaughtLater(channel, t);, +            }, +            if (isIoThread(channel)) {, +            } else {, +                fireExceptionCaughtLater(channel, cause);, +            }, +        boolean iothread = isIoThread(channel);, +                if (iothread) {, +                } else {, +                    fireChannelInterestChangedLater(channel);, +                }, +            if (iothread) {, +            } else {, +                fireExceptionCaughtLater(channel, cce);, +            }, +            if (iothread) {, +            } else {, +                fireExceptionCaughtLater(channel, t);, +            }, +++ b/transport/src/main/java/io/netty/channel/Channels.java, +     * the specified {@link Channel} in the next io-thread., +     */, +    public static void fireWriteCompleteLater(Channel channel, long amount) {, +        if (amount == 0) {, +            return;, +        }, +, +        channel.getPipeline().sendUpstreamLater(, +                new DefaultWriteCompletionEvent(channel, amount));, +    }, +, +    , +    /**, +     * Sends a {@code "writeComplete"} event to the first, +     * {@link ChannelUpstreamHandler} in the {@link ChannelPipeline} of, +++ b/transport/src/main/java/io/netty/channel/socket/nio/AbstractNioWorker.java, +        boolean iothread = isIoThread(channel);, +                    if (iothread) {]