[+++ b/buffer/src/main/java/io/netty/buffer/PoolArena.java, +import io.netty.util.internal.LongCounter;, +import java.util.ArrayList;, +import java.util.Collections;, +import java.util.List;, +abstract class PoolArena<T> implements PoolArenaMetric {, +    private final List<PoolChunkListMetric> chunkListMetrics;, +, +    // Metrics for allocations and deallocations, +    private long allocationsTiny;, +    private long allocationsSmall;, +    private long allocationsNormal;, +    // We need to use the LongCounter here as this is not guarded via synchronized block., +    private final LongCounter allocationsHuge = PlatformDependent.newLongCounter();, +, +    private long deallocationsTiny;, +    private long deallocationsSmall;, +    private long deallocationsNormal;, +    // We need to use the LongCounter here as this is not guarded via synchronized block., +    private final LongCounter deallocationsHuge = PlatformDependent.newLongCounter();, +, +, +        List<PoolChunkListMetric> metrics = new ArrayList<PoolChunkListMetric>(6);, +        metrics.add(qInit);, +        metrics.add(q000);, +        metrics.add(q025);, +        metrics.add(q050);, +        metrics.add(q075);, +        metrics.add(q100);, +        chunkListMetrics = Collections.unmodifiableList(metrics);, +            boolean tiny = isTiny(normCapacity);, +            if (tiny) { // < 512, +, +                    if (tiny) {, +                        ++allocationsTiny;, +                    } else {, +                        ++allocationsSmall;, +                    }, +        ++allocationsNormal;, +, +        allocationsHuge.increment();, +            allocationsHuge.decrement();, +            boolean tinyOrSmall = isTinyOrSmall(normCapacity);, +                if (!tinyOrSmall) {, +                    ++deallocationsNormal;, +                } else if (isTiny(normCapacity)) {, +                    ++deallocationsTiny;, +                } else {, +                    ++deallocationsSmall;, +                }, +    @Override, +    public int numTinySubpages() {, +        return tinySubpagePools.length;, +    }, +, +    @Override, +    public int numSmallSubpages() {, +        return smallSubpagePools.length;, +    }, +, +    @Override, +    public int numChunkLists() {, +        return chunkListMetrics.size();, +    }, +, +    @Override, +    public List<PoolSubpageMetric> tinySubpages() {, +        return subPageMetricList(tinySubpagePools);, +    }, +, +    @Override, +    public List<PoolSubpageMetric> smallSubpages() {, +        return subPageMetricList(smallSubpagePools);, +    }, +, +    @Override, +    public List<PoolChunkListMetric> chunkLists() {, +        return chunkListMetrics;, +    }, +, +    private static List<PoolSubpageMetric> subPageMetricList(PoolSubpage<?>[] pages) {, +        List<PoolSubpageMetric> metrics = new ArrayList<PoolSubpageMetric>();, +        for (int i = 1; i < pages.length; i ++) {, +            PoolSubpage<?> head = pages[i];, +            if (head.next == head) {, +                continue;, +            }, +            PoolSubpage<?> s = head.next;, +            for (;;) {, +                metrics.add(s);, +                s = s.next;, +                if (s == head) {, +                    break;, +                }, +            }, +        }, +        return metrics;, +    }, +, +    @Override]