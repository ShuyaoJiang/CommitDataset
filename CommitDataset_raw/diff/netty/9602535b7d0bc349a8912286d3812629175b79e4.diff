[+++ b/buffer/src/main/java/io/netty/buffer/ByteBufUtil.java, +import java.nio.charset.CodingErrorAction;, +    /**, +     * Returns {@code true} if the given {@link ByteBuf} is valid text using the given {@link Charset},, +     * otherwise return {@code false}., +     *, +     * @param buf The given {@link ByteBuf}., +     * @param charset The specified {@link Charset}., +     */, +    public static boolean isText(ByteBuf buf, Charset charset) {, +        return isText(buf, buf.readerIndex(), buf.readableBytes(), charset);, +    }, +, +    /**, +     * Returns {@code true} if the specified {@link ByteBuf} starting at {@code index} with {@code length} is valid, +     * text using the given {@link Charset}, otherwise return {@code false}., +     *, +     * @param buf The given {@link ByteBuf}., +     * @param index The start index of the specified buffer., +     * @param length The length of the specified buffer., +     * @param charset The specified {@link Charset}., +     *, +     * @throws IndexOutOfBoundsException if {@code index} + {@code length} is greater than {@code buf.readableBytes}, +     */, +    public static boolean isText(ByteBuf buf, int index, int length, Charset charset) {, +        checkNotNull(buf, "buf");, +        checkNotNull(charset, "charset");, +        final int maxIndex = buf.readerIndex() + buf.readableBytes();, +        if (index < 0 || length < 0 || index > maxIndex - length) {, +            throw new IndexOutOfBoundsException("index: " + index + " length: " + length);, +        }, +        if (charset.equals(CharsetUtil.UTF_8)) {, +            return isUtf8(buf, index, length);, +        } else if (charset.equals(CharsetUtil.US_ASCII)) {, +            return isAscii(buf, index, length);, +        } else {, +            CharsetDecoder decoder = CharsetUtil.decoder(charset, CodingErrorAction.REPORT, CodingErrorAction.REPORT);, +            try {, +                if (buf.nioBufferCount() == 1) {, +                    decoder.decode(buf.internalNioBuffer(index, length));, +                } else {, +                    ByteBuf heapBuffer =  buf.alloc().heapBuffer(length);, +                    try {, +                        heapBuffer.writeBytes(buf, index, length);, +                        decoder.decode(heapBuffer.internalNioBuffer(0, length));, +                    } finally {, +                        heapBuffer.release();, +                    }, +                }, +                return true;, +            } catch (CharacterCodingException ignore) {, +                return false;, +            }, +        }, +    }, +, +    /**, +     * Aborts on a byte which is not a valid ASCII character., +     */, +    private static final ByteProcessor FIND_NON_ASCII = new ByteProcessor() {, +        @Override, +        public boolean process(byte value) {, +            return value >= 0;, +        }, +    };, +, +    /**, +     * Returns {@code true} if the specified {@link ByteBuf} starting at {@code index} with {@code length} is valid, +     * ASCII text, otherwise return {@code false}., +     *, +     * @param buf    The given {@link ByteBuf}., +     * @param index  The start index of the specified buffer., +     * @param length The length of the specified buffer., +     */, +    private static boolean isAscii(ByteBuf buf, int index, int length) {, +        return buf.forEachByte(index, length, FIND_NON_ASCII) == -1;, +    }, +, +    /**, +     * Returns {@code true} if the specified {@link ByteBuf} starting at {@code index} with {@code length} is valid, +     * UTF8 text, otherwise return {@code false}., +     *, +     * @param buf The given {@link ByteBuf}., +     * @param index The start index of the specified buffer., +     * @param length The length of the specified buffer., +     *, +     * @see, +     * <a href=http://www.ietf.org/rfc/rfc3629.txt>UTF-8 Definition</a>, +     *, +     * <pre>, +     * 1. Bytes format of UTF-8, +     *, +     * The table below summarizes the format of these different octet types., +     * The letter x indicates bits available for encoding bits of the character number., +     *, +     * Char. number range  |        UTF-8 octet sequence, +     *    (hexadecimal)    |              (binary), +     * --------------------+---------------------------------------------, +     * 0000 0000-0000 007F | 0xxxxxxx, +     * 0000 0080-0000 07FF | 110xxxxx 10xxxxxx]