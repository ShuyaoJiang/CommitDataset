[+++ b/buffer/src/main/java/io/netty/buffer/UnpooledUnsafeDirectByteBuf.java, +    ByteBuffer buffer;, +        setByteBuffer(allocateDirect(initialCapacity), false);, +        setByteBuffer(initialBuffer.slice().order(ByteOrder.BIG_ENDIAN), false);, +    final void setByteBuffer(ByteBuffer buffer, boolean tryFree) {, +        if (tryFree) {, +        }, +            setByteBuffer(newBuffer, true);, +            setByteBuffer(newBuffer, true);, +++ b/buffer/src/main/java/io/netty/buffer/UnpooledUnsafeDirectByteBuf.java, +    ByteBuffer buffer;, +        setByteBuffer(allocateDirect(initialCapacity), false);, +        setByteBuffer(initialBuffer.slice().order(ByteOrder.BIG_ENDIAN), false);, +    final void setByteBuffer(ByteBuffer buffer, boolean tryFree) {, +        if (tryFree) {, +        }, +            setByteBuffer(newBuffer, true);, +            setByteBuffer(newBuffer, true);, +++ b/buffer/src/main/java/io/netty/buffer/UnpooledUnsafeNoCleanerDirectByteBuf.java, +, +    @Override, +    public ByteBuf capacity(int newCapacity) {, +        ensureAccessible();, +        if (newCapacity < 0 || newCapacity > maxCapacity()) {, +            throw new IllegalArgumentException("newCapacity: " + newCapacity);, +        }, +, +        int readerIndex = readerIndex();, +        int writerIndex = writerIndex();, +        int oldCapacity = capacity();, +, +        if (newCapacity > oldCapacity) {, +            ByteBuffer oldBuffer = buffer;, +            ByteBuffer newBuffer = PlatformDependent.reallocateDirectNoCleaner(oldBuffer, newCapacity);, +            setByteBuffer(newBuffer, false);, +        } else if (newCapacity < oldCapacity) {, +            ByteBuffer oldBuffer = buffer;, +            ByteBuffer newBuffer = allocateDirect(newCapacity);, +            if (readerIndex < newCapacity) {, +                if (writerIndex > newCapacity) {, +                    writerIndex = newCapacity;, +                    writerIndex(writerIndex);, +                }, +                oldBuffer.position(readerIndex).limit(writerIndex);, +                newBuffer.position(readerIndex).limit(writerIndex);, +                newBuffer.put(oldBuffer);, +                newBuffer.clear();, +            } else {, +                setIndex(newCapacity, newCapacity);, +            }, +            setByteBuffer(newBuffer, true);, +        }, +        return this;, +    }, +++ b/buffer/src/main/java/io/netty/buffer/UnpooledUnsafeDirectByteBuf.java, +    ByteBuffer buffer;, +        setByteBuffer(allocateDirect(initialCapacity), false);, +        setByteBuffer(initialBuffer.slice().order(ByteOrder.BIG_ENDIAN), false);, +    final void setByteBuffer(ByteBuffer buffer, boolean tryFree) {, +        if (tryFree) {, +        }, +            setByteBuffer(newBuffer, true);, +            setByteBuffer(newBuffer, true);, +++ b/buffer/src/main/java/io/netty/buffer/UnpooledUnsafeNoCleanerDirectByteBuf.java, +, +    @Override, +    public ByteBuf capacity(int newCapacity) {, +        ensureAccessible();, +        if (newCapacity < 0 || newCapacity > maxCapacity()) {, +            throw new IllegalArgumentException("newCapacity: " + newCapacity);, +        }, +, +        int readerIndex = readerIndex();, +        int writerIndex = writerIndex();, +        int oldCapacity = capacity();, +, +        if (newCapacity > oldCapacity) {, +            ByteBuffer oldBuffer = buffer;, +            ByteBuffer newBuffer = PlatformDependent.reallocateDirectNoCleaner(oldBuffer, newCapacity);, +            setByteBuffer(newBuffer, false);, +        } else if (newCapacity < oldCapacity) {, +            ByteBuffer oldBuffer = buffer;, +            ByteBuffer newBuffer = allocateDirect(newCapacity);, +            if (readerIndex < newCapacity) {, +                if (writerIndex > newCapacity) {, +                    writerIndex = newCapacity;, +                    writerIndex(writerIndex);, +                }, +                oldBuffer.position(readerIndex).limit(writerIndex);, +                newBuffer.position(readerIndex).limit(writerIndex);, +                newBuffer.put(oldBuffer);, +                newBuffer.clear();, +            } else {, +                setIndex(newCapacity, newCapacity);, +            }, +            setByteBuffer(newBuffer, true);, +        }, +        return this;, +    }, +++ b/common/src/main/java/io/netty/util/internal/PlatformDependent.java]