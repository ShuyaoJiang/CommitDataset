[+++ b/resolver-dns/src/main/java/io/netty/resolver/dns/DnsCache.java, +     * Be aware this <strong>won't</strong> be called with timeout / cancel / transport exceptions., +      *, +++ b/resolver-dns/src/main/java/io/netty/resolver/dns/DnsCache.java, +     * Be aware this <strong>won't</strong> be called with timeout / cancel / transport exceptions., +      *, +++ b/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java, +    /**, +     * Returns {@code true} if the {@link Throwable} was caused by an timeout or transport error., +     * These methods can be used on the {@link Future#cause()} that is returned by the various methods exposed by this, +     * {@link DnsNameResolver}., +     */, +    public static boolean isTransportOrTimeoutError(Throwable cause) {, +        return cause != null && cause.getCause() instanceof DnsNameResolverException;, +    }, +, +    /**, +     * Returns {@code true} if the {@link Throwable} was caused by an timeout., +     * These methods can be used on the {@link Future#cause()} that is returned by the various methods exposed by this, +     * {@link DnsNameResolver}., +     */, +    public static boolean isTimeoutError(Throwable cause) {, +        return cause != null && cause.getCause() instanceof DnsNameResolverTimeoutException;, +    }, +, +++ b/resolver-dns/src/main/java/io/netty/resolver/dns/DnsCache.java, +     * Be aware this <strong>won't</strong> be called with timeout / cancel / transport exceptions., +      *, +++ b/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java, +    /**, +     * Returns {@code true} if the {@link Throwable} was caused by an timeout or transport error., +     * These methods can be used on the {@link Future#cause()} that is returned by the various methods exposed by this, +     * {@link DnsNameResolver}., +     */, +    public static boolean isTransportOrTimeoutError(Throwable cause) {, +        return cause != null && cause.getCause() instanceof DnsNameResolverException;, +    }, +, +    /**, +     * Returns {@code true} if the {@link Throwable} was caused by an timeout., +     * These methods can be used on the {@link Future#cause()} that is returned by the various methods exposed by this, +     * {@link DnsNameResolver}., +     */, +    public static boolean isTimeoutError(Throwable cause) {, +        return cause != null && cause.getCause() instanceof DnsNameResolverTimeoutException;, +    }, +, +++ b/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverContext.java, +                    Throwable cause = future.cause();, +                    if (cause == null) {, +                    } else {, +                        if (DnsNameResolver.isTransportOrTimeoutError(cause)) {, +                            promise.tryFailure(new SearchDomainUnknownHostException(cause, hostname));, +                            promise.tryFailure(new SearchDomainUnknownHostException(cause, hostname));, +                        }, +, +            // Preserve the cause, +            initCause(cause.getCause());, +            if (!query(hostname, recordTypes[i], nameServerAddressStream.duplicate(), promise, null)) {, +        query(hostname, recordTypes[end], nameServerAddressStream, promise, null);, +                       final Promise<T> promise, Throwable cause) {, +                parent.dnsQueryLifecycleObserverFactory().newDnsQueryLifecycleObserver(question), promise, cause);, +                       final Promise<T> promise,, +                       final Throwable cause) {, +                               promise, cause);, +                final Throwable queryCause = future.cause();, +                    if (queryCause == null) {, +                        queryLifecycleObserver.queryFailed(queryCause);, +                        query(nameServerAddrStream, nameServerAddrStreamIndex + 1, question, promise, queryCause);, +                                       promise, queryCause);, +                      queryLifecycleObserver.queryNoAnswer(code), promise, null);, +                          queryLifecycleObserver.queryRedirected(unmodifiableList(nameServers)), promise, null);, +                            final Promise<T> promise,, +                            final Throwable cause) {, +                finishResolve(promise, cause);, +                    query(nameServerAddrStream, nameServerAddrStreamIndex + 1, question, promise, cause);, +                          promise, cause);, +, +            // If cause != null we know this was caused by a timeout / cancel / transport exception. In this case we, +            // won't try to resolve the CNAME as we only should do this if we could not get the A/AAAA records because, +            // these not exists and the DNS server did probably signal it., +            if (cause == null && !triedCNAME) {, +                query(hostname, DnsRecordType.CNAME, getNameServers(hostname), promise, null);, +        finishResolve(promise, cause);, +    private void finishResolve(Promise<T> promise, Throwable cause) {, +        final UnknownHostException unknownHostException = new UnknownHostException(buf.toString());, +        if (cause == null) {, +            // Only cache if the failure was not because of an IO error / timeout that was caused by the query, +            // itself., +            resolveCache.cache(hostname, additionals, unknownHostException, parent.ch.eventLoop());, +        } else {, +            unknownHostException.initCause(cause);, +        }, +        promise.tryFailure(unknownHostException);, +            query(stream, 0, cnameQuestion, queryLifecycleObserver.queryCNAMEd(cnameQuestion), promise, null);, +            query(stream, 0, cnameQuestion, queryLifecycleObserver.queryCNAMEd(cnameQuestion), promise, null);, +                          Promise<T> promise, Throwable cause) {, +        query(dnsServerAddressStream, 0, question, promise, cause);, +++ b/resolver-dns/src/main/java/io/netty/resolver/dns/DnsCache.java, +     * Be aware this <strong>won't</strong> be called with timeout / cancel / transport exceptions.]