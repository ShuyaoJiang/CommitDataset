[+++ b/NOTICE.txt, +This product optionally depends on 'SLF4J', a simple logging facade for Java., +The monitor registries implementation is based on the approach used by SLF4J., +, +Slf4j can be obtained at:, +++ b/NOTICE.txt, +This product optionally depends on 'SLF4J', a simple logging facade for Java., +The monitor registries implementation is based on the approach used by SLF4J., +, +Slf4j can be obtained at:, +++ b/common/src/main/java/io/netty/monitor/MonitorRegistries.java, +import io.netty.logging.InternalLogger;, +import io.netty.logging.InternalLoggerFactory;, +    private static final InternalLogger logger = InternalLoggerFactory.getInstance(MonitorRegistries.class);, +    //set of initialization states, +    private static final int UNINITIALIZED = 0;, +    private static final int ONGOING_INITIALIZATION = 1;, +    private static final int SUCCESSFUL_INITIALIZATION = 2;, +    private static final int NOP_FALLBACK_INITIALIZATION = 3;, +, +    private static int INITIALIZATION_STATE = UNINITIALIZED;, +    private static MonitorRegistry selectedRegistry;, +     *, +     *, +    public static MonitorRegistry forProvider(final MonitorProvider provider) {, +     * Look up and return <em>the</em> a uniquely determined, +     * {@link MonitorRegistry} implementation. This method will select, +     * exactly one {@link MonitorRegistryFactory} from those registered in, +     * if no implementation is found then a NOOP registry is returned., +     * If multiple implementations are found then the first one returned by, +     * {@link #iterator()} is used and a message is logged to say which one is, +     * selected., +     *, +     * @return <em>the</em> uniquely determined {@link MonitorRegistry}, +        //Implementation based on SLF4J's, +        if (INITIALIZATION_STATE == UNINITIALIZED) {, +            INITIALIZATION_STATE = ONGOING_INITIALIZATION;, +            performInitialization();, +        }, +        switch (INITIALIZATION_STATE) {, +            case SUCCESSFUL_INITIALIZATION:, +                return selectedRegistry;, +            case NOP_FALLBACK_INITIALIZATION:, +            case ONGOING_INITIALIZATION:, +            default:, +                return MonitorRegistry.NOOP;, +        }, +    }, +, +    private void performInitialization() {, +            selectedRegistry = registries.next();, +            INITIALIZATION_STATE = SUCCESSFUL_INITIALIZATION;, +        if (selectedRegistry != null && registries.hasNext()) {, +            logger.warn(String.format("Multiple metrics implementations found. " +, +                    "Selected %s, ignoring other implementations", selectedRegistry.getClass().getName()));, +        }, +        if (selectedRegistry == null) {, +            INITIALIZATION_STATE = NOP_FALLBACK_INITIALIZATION;, +            logger.debug("No metrics implementation found on the classpath.");, +        }, +++ b/NOTICE.txt, +This product optionally depends on 'SLF4J', a simple logging facade for Java., +The monitor registries implementation is based on the approach used by SLF4J., +, +Slf4j can be obtained at:, +++ b/common/src/main/java/io/netty/monitor/MonitorRegistries.java, +import io.netty.logging.InternalLogger;, +import io.netty.logging.InternalLoggerFactory;, +    private static final InternalLogger logger = InternalLoggerFactory.getInstance(MonitorRegistries.class);, +    //set of initialization states, +    private static final int UNINITIALIZED = 0;, +    private static final int ONGOING_INITIALIZATION = 1;, +    private static final int SUCCESSFUL_INITIALIZATION = 2;, +    private static final int NOP_FALLBACK_INITIALIZATION = 3;, +, +    private static int INITIALIZATION_STATE = UNINITIALIZED;, +    private static MonitorRegistry selectedRegistry;, +     *, +     *, +    public static MonitorRegistry forProvider(final MonitorProvider provider) {, +     * Look up and return <em>the</em> a uniquely determined, +     * {@link MonitorRegistry} implementation. This method will select, +     * exactly one {@link MonitorRegistryFactory} from those registered in, +     * if no implementation is found then a NOOP registry is returned., +     * If multiple implementations are found then the first one returned by, +     * {@link #iterator()} is used and a message is logged to say which one is, +     * selected., +     *, +     * @return <em>the</em> uniquely determined {@link MonitorRegistry}, +        //Implementation based on SLF4J's, +        if (INITIALIZATION_STATE == UNINITIALIZED) {, +            INITIALIZATION_STATE = ONGOING_INITIALIZATION;, +            performInitialization();, +        }, +        switch (INITIALIZATION_STATE) {, +            case SUCCESSFUL_INITIALIZATION:, +                return selectedRegistry;, +            case NOP_FALLBACK_INITIALIZATION:, +            case ONGOING_INITIALIZATION:, +            default:]