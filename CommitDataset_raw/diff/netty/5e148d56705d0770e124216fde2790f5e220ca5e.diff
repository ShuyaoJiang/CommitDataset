[+++ b/testsuite/src/main/java/io/netty/testsuite/transport/socket/SocketConnectTest.java, +import io.netty.channel.ChannelFutureListener;, +import java.util.concurrent.BlockingQueue;, +import java.util.concurrent.LinkedBlockingQueue;, +    @Test(timeout = 3000), +    public void testChannelEventsFiredWhenClosedDirectly() throws Throwable {, +        run();, +    }, +, +    public void testChannelEventsFiredWhenClosedDirectly(ServerBootstrap sb, Bootstrap cb) throws Throwable {, +        final BlockingQueue<Integer> events = new LinkedBlockingQueue<Integer>();, +, +        Channel sc = null;, +        Channel cc = null;, +        try {, +            sb.childHandler(new ChannelInboundHandlerAdapter());, +            sc = sb.bind(0).syncUninterruptibly().channel();, +, +            cb.handler(new ChannelInboundHandlerAdapter() {, +                @Override, +                public void channelActive(ChannelHandlerContext ctx) throws Exception {, +                    events.add(0);, +                }, +, +                @Override, +                public void channelInactive(ChannelHandlerContext ctx) throws Exception {, +                    events.add(1);, +                }, +            });, +            // Connect and directly close again., +            cc = cb.connect(sc.localAddress()).addListener(ChannelFutureListener.CLOSE)., +                    syncUninterruptibly().channel();, +            assertEquals(0, events.take().intValue());, +            assertEquals(1, events.take().intValue());, +        } finally {, +            if (cc != null) {, +                cc.close();, +            }, +            if (sc != null) {, +                sc.close();, +            }, +        }, +    }, +, +++ b/testsuite/src/main/java/io/netty/testsuite/transport/socket/SocketConnectTest.java, +import io.netty.channel.ChannelFutureListener;, +import java.util.concurrent.BlockingQueue;, +import java.util.concurrent.LinkedBlockingQueue;, +    @Test(timeout = 3000), +    public void testChannelEventsFiredWhenClosedDirectly() throws Throwable {, +        run();, +    }, +, +    public void testChannelEventsFiredWhenClosedDirectly(ServerBootstrap sb, Bootstrap cb) throws Throwable {, +        final BlockingQueue<Integer> events = new LinkedBlockingQueue<Integer>();, +, +        Channel sc = null;, +        Channel cc = null;, +        try {, +            sb.childHandler(new ChannelInboundHandlerAdapter());, +            sc = sb.bind(0).syncUninterruptibly().channel();, +, +            cb.handler(new ChannelInboundHandlerAdapter() {, +                @Override, +                public void channelActive(ChannelHandlerContext ctx) throws Exception {, +                    events.add(0);, +                }, +, +                @Override, +                public void channelInactive(ChannelHandlerContext ctx) throws Exception {, +                    events.add(1);, +                }, +            });, +            // Connect and directly close again., +            cc = cb.connect(sc.localAddress()).addListener(ChannelFutureListener.CLOSE)., +                    syncUninterruptibly().channel();, +            assertEquals(0, events.take().intValue());, +            assertEquals(1, events.take().intValue());, +        } finally {, +            if (cc != null) {, +                cc.close();, +            }, +            if (sc != null) {, +                sc.close();, +            }, +        }, +    }, +, +++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/AbstractEpollStreamChannel.java, +            // Get the state as trySuccess() may trigger an ChannelFutureListener that will close the Channel., +            // We still need to ensure we call fireChannelActive() in this case., +            boolean active = isActive();, +, +            if (!wasActive && active) {, +++ b/testsuite/src/main/java/io/netty/testsuite/transport/socket/SocketConnectTest.java, +import io.netty.channel.ChannelFutureListener;, +import java.util.concurrent.BlockingQueue;, +import java.util.concurrent.LinkedBlockingQueue;, +    @Test(timeout = 3000), +    public void testChannelEventsFiredWhenClosedDirectly() throws Throwable {]