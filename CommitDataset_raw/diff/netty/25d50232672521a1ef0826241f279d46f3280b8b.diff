[+++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/src/main/java/org/jboss/netty/channel/socket/http/HttpTunnelingClientSocketChannel.java, +import java.nio.channels.NotYetConnectedException;, +import org.jboss.netty.buffer.ChannelBuffers;, +import org.jboss.netty.channel.ChannelException;, +import org.jboss.netty.handler.codec.http.HttpResponseStatus;, +    final HttpTunnelingSocketChannelConfig config;, +    volatile boolean requestHeaderWritten;, +    final SocketChannel realChannel;, +        DefaultChannelPipeline channelPipeline = new DefaultChannelPipeline();, +        channelPipeline.addLast("decoder", new HttpResponseDecoder());, +        channelPipeline.addLast("encoder", new HttpRequestEncoder());, +        channelPipeline.addLast("handler", handler);, +        realChannel = clientSocketChannelFactory.newChannel(channelPipeline);, +, +        return realChannel.getLocalAddress();, +        return realChannel.getRemoteAddress();, +        return realChannel.isBound();, +        return realChannel.isConnected();, +        return realChannel.getInterestOps();, +        return realChannel.isWritable();, +    void bindReal(final SocketAddress localAddress, final ChannelFuture future) {, +        realChannel.bind(localAddress).addListener(new ChannelFutureListener() {, +                    future.setSuccess();, +                } else {, +                    future.setFailure(f.getCause());, +                }, +            }, +        });, +    }, +, +    void connectReal(final SocketAddress remoteAddress, final ChannelFuture future) {, +        final SocketChannel virtualChannel = this;, +        realChannel.connect(remoteAddress).addListener(new ChannelFutureListener() {, +            public void operationComplete(ChannelFuture f) {, +                final String serverName = config.getServerName();, +                final int serverPort = ((InetSocketAddress) remoteAddress).getPort();, +                final String serverPath = config.getServerPath();, +, +                if (f.isSuccess()) {, +                        // Create a new SSLEngine from the specified SSLContext., +                        SSLEngine engine;, +                        if (serverName != null) {, +                            engine = sslContext.createSSLEngine(serverName, serverPort);, +                        } else {, +                            engine = sslContext.createSSLEngine();, +                        }, +                        realChannel.getPipeline().addFirst("ssl", sslHandler);, +                            sslHandshakeFuture = sslHandler.handshake(realChannel);, +                            fireExceptionCaught(virtualChannel, e);, +                            HttpVersion.HTTP_1_1, HttpMethod.POST, serverPath);, +                    if (serverName != null) {, +                        req.setHeader(HttpHeaders.Names.HOST, serverName);, +                    }, +                    req.setHeader(HttpHeaders.Names.USER_AGENT, HttpTunnelingClientSocketChannel.class.getName());, +                        realChannel.write(req);, +                        requestHeaderWritten = true;, +                        fireChannelConnected(virtualChannel, remoteAddress);, +                            public void operationComplete(ChannelFuture f) {, +                                    fireChannelConnected(virtualChannel, remoteAddress);, +                                    fireExceptionCaught(virtualChannel, f.getCause());, +                    fireExceptionCaught(virtualChannel, f.getCause());, +    void writeReal(final ChannelBuffer a, final ChannelFuture future) {, +        if (!requestHeaderWritten) {, +            throw new NotYetConnectedException();, +        final ChannelFuture f;, +, +        if (size == 0) {, +            f = realChannel.write(ChannelBuffers.EMPTY_BUFFER);, +        } else {, +            f = realChannel.write(new DefaultHttpChunk(a));, +        }, +, +        f.addListener(new ChannelFutureListener() {, +            public void operationComplete(ChannelFuture f) {, +    private ChannelFuture writeLastChunk() {, +        if (!requestHeaderWritten) {, +            throw new NotYetConnectedException();, +        } else {, +            return realChannel.write(HttpChunk.LAST_CHUNK);, +    void setInterestOpsReal(final int interestOps, final ChannelFuture future) {, +        realChannel.setInterestOps(interestOps).addListener(new ChannelFutureListener() {, +            public void operationComplete(ChannelFuture f) {, +                if (f.isSuccess()) {, +                    future.setSuccess();, +                } else {, +                    future.setFailure(f.getCause());, +                }, +            }, +        });, +    }, +, +    void disconnectReal(final ChannelFuture future) {, +        writeLastChunk().addListener(new ChannelFutureListener() {, +            public void operationComplete(ChannelFuture f) {, +                realChannel.disconnect().addListener(new ChannelFutureListener() {]