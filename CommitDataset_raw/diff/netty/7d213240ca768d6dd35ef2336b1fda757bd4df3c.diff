[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/HttpConversionUtil.java, +import java.util.List;, +import static io.netty.handler.codec.http.HttpHeaderNames.CONNECTION;, +import static io.netty.handler.codec.http.HttpHeaderNames.COOKIE;, +import static io.netty.handler.codec.http.HttpHeaderNames.TE;, +import static io.netty.handler.codec.http.HttpHeaderValues.TRAILERS;, +import static io.netty.util.AsciiString.contentEqualsIgnoreCase;, +import static io.netty.util.AsciiString.indexOf;, +import static io.netty.util.AsciiString.trim;, +import static io.netty.util.internal.StringUtil.unescapeCsvFields;, +        HTTP_TO_HTTP2_HEADER_BLACKLIST.add(CONNECTION, EMPTY_STRING);, +    /**, +     * Filter the {@link HttpHeaderNames#TE} header according to the, +     * <a href="https://tools.ietf.org/html/rfc7540#section-8.1.2.2">special rules in the HTTP/2 RFC</a>., +     * @param entry An entry whose name is {@link HttpHeaderNames#TE}., +     * @param out the resulting HTTP/2 headers., +     */, +    private static void toHttp2HeadersFilterTE(Entry<CharSequence, CharSequence> entry,, +                                               Http2Headers out) {, +        if (indexOf(entry.getValue(), ',', 0) == -1) {, +            if (contentEqualsIgnoreCase(trim(entry.getValue()), TRAILERS)) {, +                out.add(TE, TRAILERS);, +            }, +        } else {, +            List<CharSequence> teValues = unescapeCsvFields(entry.getValue());, +            for (CharSequence teValue : teValues) {, +                if (contentEqualsIgnoreCase(trim(teValue), TRAILERS)) {, +                    out.add(TE, TRAILERS);, +                    break;, +                }, +            }, +        }, +    }, +, +            toLowercaseMap(inHeaders.valueCharSequenceIterator(CONNECTION), 8);, +            if (!HTTP_TO_HTTP2_HEADER_BLACKLIST.contains(aName) && !connectionBlacklist.contains(aName)) {, +                if (aName.contentEqualsIgnoreCase(TE)) {, +                    toHttp2HeadersFilterTE(entry, out);, +                } else if (aName.contentEqualsIgnoreCase(COOKIE)) {, +                                out.add(COOKIE, value.subSequence(start, index, false));, +                            out.add(COOKIE, value.subSequence(start, value.length(), false));, +                            out.add(COOKIE, value);, +                if (COOKIE.equals(name)) {, +                    String existingCookie = output.get(COOKIE);, +                    output.set(COOKIE,, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/HttpConversionUtil.java, +import java.util.List;, +import static io.netty.handler.codec.http.HttpHeaderNames.CONNECTION;, +import static io.netty.handler.codec.http.HttpHeaderNames.COOKIE;, +import static io.netty.handler.codec.http.HttpHeaderNames.TE;, +import static io.netty.handler.codec.http.HttpHeaderValues.TRAILERS;, +import static io.netty.util.AsciiString.contentEqualsIgnoreCase;, +import static io.netty.util.AsciiString.indexOf;, +import static io.netty.util.AsciiString.trim;, +import static io.netty.util.internal.StringUtil.unescapeCsvFields;, +        HTTP_TO_HTTP2_HEADER_BLACKLIST.add(CONNECTION, EMPTY_STRING);, +    /**, +     * Filter the {@link HttpHeaderNames#TE} header according to the, +     * <a href="https://tools.ietf.org/html/rfc7540#section-8.1.2.2">special rules in the HTTP/2 RFC</a>., +     * @param entry An entry whose name is {@link HttpHeaderNames#TE}., +     * @param out the resulting HTTP/2 headers., +     */, +    private static void toHttp2HeadersFilterTE(Entry<CharSequence, CharSequence> entry,, +                                               Http2Headers out) {, +        if (indexOf(entry.getValue(), ',', 0) == -1) {, +            if (contentEqualsIgnoreCase(trim(entry.getValue()), TRAILERS)) {, +                out.add(TE, TRAILERS);, +            }, +        } else {, +            List<CharSequence> teValues = unescapeCsvFields(entry.getValue());, +            for (CharSequence teValue : teValues) {, +                if (contentEqualsIgnoreCase(trim(teValue), TRAILERS)) {, +                    out.add(TE, TRAILERS);, +                    break;, +                }, +            }, +        }, +    }, +, +            toLowercaseMap(inHeaders.valueCharSequenceIterator(CONNECTION), 8);, +            if (!HTTP_TO_HTTP2_HEADER_BLACKLIST.contains(aName) && !connectionBlacklist.contains(aName)) {, +                if (aName.contentEqualsIgnoreCase(TE)) {, +                    toHttp2HeadersFilterTE(entry, out);, +                } else if (aName.contentEqualsIgnoreCase(COOKIE)) {, +                                out.add(COOKIE, value.subSequence(start, index, false));, +                            out.add(COOKIE, value.subSequence(start, value.length(), false));, +                            out.add(COOKIE, value);, +                if (COOKIE.equals(name)) {, +                    String existingCookie = output.get(COOKIE);, +                    output.set(COOKIE,, +++ b/codec-http2/src/test/java/io/netty/handler/codec/http2/HttpConversionUtilTest.java, +import static io.netty.handler.codec.http.HttpHeaderNames.CONNECTION;, +import static io.netty.handler.codec.http.HttpHeaderNames.TE;, +import static io.netty.handler.codec.http.HttpHeaderValues.GZIP;, +import static io.netty.handler.codec.http.HttpHeaderValues.TRAILERS;, +import static org.junit.Assert.assertEquals;, +import static org.junit.Assert.assertFalse;, +import static org.junit.Assert.assertNull;, +import static org.junit.Assert.assertSame;, +import static org.junit.Assert.assertTrue;]