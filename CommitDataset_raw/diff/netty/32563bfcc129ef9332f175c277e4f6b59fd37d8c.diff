[+++ b/codec-http/src/test/java/io/netty/handler/codec/http/HttpObjectAggregatorTest.java, +import io.netty.util.AsciiString;, +import io.netty.util.ReferenceCountUtil;, +, +import static org.junit.Assert.assertSame;, +, +    @Test, +    public void testSelectiveRequestAggregation() {, +        HttpObjectAggregator myPostAggregator = new HttpObjectAggregator(1024 * 1024) {, +            @Override, +            protected boolean isStartMessage(HttpObject msg) throws Exception {, +                if (msg instanceof HttpRequest) {, +                    HttpRequest request = (HttpRequest) msg;, +                    HttpMethod method = request.method();, +, +                    if (method.equals(HttpMethod.POST)) {, +                        return true;, +                    }, +                }, +, +                return false;, +            }, +        };, +, +        EmbeddedChannel channel = new EmbeddedChannel(myPostAggregator);, +, +        try {, +            // Aggregate: POST, +            HttpRequest request1 = new DefaultHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.POST, "/");, +            HttpContent content1 = new DefaultHttpContent(Unpooled.copiedBuffer("Hello, World!", CharsetUtil.UTF_8));, +            request1.headers().set(HttpHeaderNames.CONTENT_TYPE, HttpHeaderValues.TEXT_PLAIN);, +, +            assertTrue(channel.writeInbound(request1, content1, LastHttpContent.EMPTY_LAST_CONTENT));, +, +            // Getting an aggregated response out, +            Object msg1 = channel.readInbound();, +            try {, +                assertTrue(msg1 instanceof FullHttpRequest);, +            } finally {, +                ReferenceCountUtil.release(msg1);, +            }, +, +            // Don't aggregate: non-POST, +            HttpRequest request2 = new DefaultHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.PUT, "/");, +            HttpContent content2 = new DefaultHttpContent(Unpooled.copiedBuffer("Hello, World!", CharsetUtil.UTF_8));, +            request2.headers().set(HttpHeaderNames.CONTENT_TYPE, HttpHeaderValues.TEXT_PLAIN);, +, +            try {, +                assertTrue(channel.writeInbound(request2, content2, LastHttpContent.EMPTY_LAST_CONTENT));, +, +                // Getting the same response objects out, +                assertSame(request2, channel.readInbound());, +                assertSame(content2, channel.readInbound());, +                assertSame(LastHttpContent.EMPTY_LAST_CONTENT, channel.readInbound());, +            } finally {, +              ReferenceCountUtil.release(request2);, +              ReferenceCountUtil.release(content2);, +            }, +, +            assertFalse(channel.finish());, +        } finally {, +          channel.close();, +        }, +    }, +, +    @Test, +    public void testSelectiveResponseAggregation() {, +        HttpObjectAggregator myTextAggregator = new HttpObjectAggregator(1024 * 1024) {, +            @Override, +            protected boolean isStartMessage(HttpObject msg) throws Exception {, +                if (msg instanceof HttpResponse) {, +                    HttpResponse response = (HttpResponse) msg;, +                    HttpHeaders headers = response.headers();, +, +                    String contentType = headers.get(HttpHeaderNames.CONTENT_TYPE);, +                    if (AsciiString.contentEqualsIgnoreCase(contentType, HttpHeaderValues.TEXT_PLAIN)) {, +                        return true;, +                    }, +                }, +, +                return false;, +            }, +        };, +, +        EmbeddedChannel channel = new EmbeddedChannel(myTextAggregator);, +, +        try {, +            // Aggregate: text/plain, +            HttpResponse response1 = new DefaultHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.OK);, +            HttpContent content1 = new DefaultHttpContent(Unpooled.copiedBuffer("Hello, World!", CharsetUtil.UTF_8));, +            response1.headers().set(HttpHeaderNames.CONTENT_TYPE, HttpHeaderValues.TEXT_PLAIN);, +, +            assertTrue(channel.writeInbound(response1, content1, LastHttpContent.EMPTY_LAST_CONTENT));, +, +            // Getting an aggregated response out, +            Object msg1 = channel.readInbound();, +            try {, +                assertTrue(msg1 instanceof FullHttpResponse);, +            } finally {, +                ReferenceCountUtil.release(msg1);]