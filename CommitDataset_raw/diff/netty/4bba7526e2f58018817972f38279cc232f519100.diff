[+++ b/buffer/src/main/java/io/netty/buffer/AbstractDerivedByteBuf.java, +        return refCnt0();, +    }, +, +    int refCnt0() {, +        return retain0();, +    }, +, +    ByteBuf retain0() {, +        return retain0(increment);, +    }, +, +    ByteBuf retain0(int increment) {, +        return touch0();, +    }, +, +    ByteBuf touch0() {, +        return touch0(hint);, +    }, +, +    ByteBuf touch0(Object hint) {, +        return release0();, +    }, +, +    boolean release0() {, +    boolean release0(int decrement) {, +        return unwrap().release(decrement);, +    }, +, +++ b/buffer/src/main/java/io/netty/buffer/AbstractDerivedByteBuf.java, +        return refCnt0();, +    }, +, +    int refCnt0() {, +        return retain0();, +    }, +, +    ByteBuf retain0() {, +        return retain0(increment);, +    }, +, +    ByteBuf retain0(int increment) {, +        return touch0();, +    }, +, +    ByteBuf touch0() {, +        return touch0(hint);, +    }, +, +    ByteBuf touch0(Object hint) {, +        return release0();, +    }, +, +    boolean release0() {, +    boolean release0(int decrement) {, +        return unwrap().release(decrement);, +    }, +, +++ b/buffer/src/main/java/io/netty/buffer/AbstractPooledDerivedByteBuf.java, +import io.netty.util.ReferenceCounted;, +    private AbstractByteBuf rootParent;, +    /**, +     * Deallocations of a pooled derived buffer should always propagate through the entire chain of derived buffers., +     * This is because each pooled derived buffer maintains its own reference count and we should respect each one., +     * If deallocations cause a release of the "root parent" then then we may prematurely release the underlying, +     * content before all the derived buffers have been released., +     */, +    private ByteBuf parent;, +        return rootParent;, +        wrapped.retain(); // Retain up front to ensure the parent is accessible before doing more work., +        parent = wrapped;, +        rootParent = unwrapped;, +                parent = rootParent = null;, +        // We need to first store a reference to the parent before recycle this instance. This is needed as, +        // called before we actually have a chance to call release(). This leads to call release() on the wrong parent., +        ByteBuf parent = this.parent;, +        parent.release();, +, +    @Override, +    public ByteBuf slice(int index, int length) {, +        // All reference count methods should be inherited from this object (this is the "parent")., +        return new PooledNonRetainedSlicedByteBuf(this, unwrap(), index, length);, +    }, +, +    final ByteBuf duplicate0() {, +        // All reference count methods should be inherited from this object (this is the "parent")., +        return new PooledNonRetainedDuplicateByteBuf(this, unwrap());, +    }, +, +    private static final class PooledNonRetainedDuplicateByteBuf extends UnpooledDuplicatedByteBuf {, +        private final ReferenceCounted referenceCountDelegate;, +, +        PooledNonRetainedDuplicateByteBuf(ReferenceCounted referenceCountDelegate, AbstractByteBuf buffer) {, +            super(buffer);, +            this.referenceCountDelegate = referenceCountDelegate;, +        }, +, +        @Override, +        int refCnt0() {, +            return referenceCountDelegate.refCnt();]