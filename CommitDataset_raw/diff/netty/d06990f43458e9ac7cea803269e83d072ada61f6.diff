[+++ b/handler/src/main/java/io/netty/handler/ssl/ReferenceCountedOpenSslContext.java, +import io.netty.tcnative.jni.CertificateVerifier;, +import io.netty.tcnative.jni.SSL;, +import io.netty.tcnative.jni.SSLContext;, +import static io.netty.util.internal.ObjectUtil.checkPositiveOrZero;, +, +    private static final int DEFAULT_BIO_NON_APPLICATION_BUFFER_SIZE =, +            AccessController.doPrivileged(new PrivilegedAction<Integer>() {, +                @Override, +                public Integer run() {, +                    return Math.max(1,, +                            SystemPropertyUtil.getInt("io.netty.handler.ssl.openssl.bioNonApplicationBufferSize",, +                                                      2048));, +                }, +            });, +, +    private volatile boolean rejectRemoteInitiatedRenegotiation;, +    private volatile int bioNonApplicationBufferSize = DEFAULT_BIO_NON_APPLICATION_BUFFER_SIZE;, +                // We do not support compression at the moment so we should explicitly disable it., +     * Returns if remote initiated renegotiation is supported or not., +     */, +    public boolean getRejectRemoteInitiatedRenegotiation() {, +        return rejectRemoteInitiatedRenegotiation;, +    }, +, +    /**, +     * Set the size of the buffer used by the BIO for non-application based writes, +     * (e.g. handshake, renegotiation, etc...)., +     */, +    public void setBioNonApplicationBufferSize(int bioNonApplicationSize) {, +        this.bioNonApplicationBufferSize =, +                checkPositiveOrZero(bioNonApplicationSize, "bioNonApplicationBufferSize");, +    }, +, +    /**, +     * Returns the size of the buffer used by the BIO for non-application based writes, +     */, +    public int getBioNonApplicationBufferSize() {, +        return bioNonApplicationBufferSize;, +    }, +, +    /**, +            if (SSL.bioWrite(bio, OpenSsl.memoryAddress(buffer) + buffer.readerIndex(), readable) != readable) {, +++ b/handler/src/main/java/io/netty/handler/ssl/ReferenceCountedOpenSslContext.java, +import io.netty.tcnative.jni.CertificateVerifier;, +import io.netty.tcnative.jni.SSL;, +import io.netty.tcnative.jni.SSLContext;, +import static io.netty.util.internal.ObjectUtil.checkPositiveOrZero;, +, +    private static final int DEFAULT_BIO_NON_APPLICATION_BUFFER_SIZE =, +            AccessController.doPrivileged(new PrivilegedAction<Integer>() {, +                @Override, +                public Integer run() {, +                    return Math.max(1,, +                            SystemPropertyUtil.getInt("io.netty.handler.ssl.openssl.bioNonApplicationBufferSize",, +                                                      2048));, +                }, +            });, +, +    private volatile boolean rejectRemoteInitiatedRenegotiation;, +    private volatile int bioNonApplicationBufferSize = DEFAULT_BIO_NON_APPLICATION_BUFFER_SIZE;, +                // We do not support compression at the moment so we should explicitly disable it., +     * Returns if remote initiated renegotiation is supported or not., +     */, +    public boolean getRejectRemoteInitiatedRenegotiation() {, +        return rejectRemoteInitiatedRenegotiation;, +    }, +, +    /**, +     * Set the size of the buffer used by the BIO for non-application based writes, +     * (e.g. handshake, renegotiation, etc...)., +     */, +    public void setBioNonApplicationBufferSize(int bioNonApplicationSize) {, +        this.bioNonApplicationBufferSize =, +                checkPositiveOrZero(bioNonApplicationSize, "bioNonApplicationBufferSize");, +    }, +, +    /**, +     * Returns the size of the buffer used by the BIO for non-application based writes, +     */, +    public int getBioNonApplicationBufferSize() {, +        return bioNonApplicationBufferSize;, +    }, +, +    /**, +            if (SSL.bioWrite(bio, OpenSsl.memoryAddress(buffer) + buffer.readerIndex(), readable) != readable) {, +++ b/handler/src/main/java/io/netty/handler/ssl/ReferenceCountedOpenSslEngine.java, +import io.netty.tcnative.jni.Buffer;, +import io.netty.tcnative.jni.SSL;, +    private boolean renegotiationPending;, +        rejectRemoteInitiatedRenegation = context.getRejectRemoteInitiatedRenegotiation();, +        keyMaterialManager = context.keyMaterialManager();, +        ssl = SSL.newSSL(context.ctx, !context.isClient());, +        try {, +            networkBIO = SSL.bioNewByteBuffer(ssl, context.getBioNonApplicationBufferSize());, +        } catch (Throwable cause) {, +            SSL.freeSSL(ssl);, +            PlatformDependent.throwException(cause);, +        }, +            sslWrote = SSL.writeToSSL(ssl, Buffer.address(src) + pos, len);]