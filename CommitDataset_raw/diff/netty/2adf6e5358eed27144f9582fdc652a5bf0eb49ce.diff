[+++ b/codec-stomp/src/main/java/io/netty/handler/codec/stomp/StompSubframeDecoder.java, +import static io.netty.buffer.ByteBufUtil.indexOf;, +import static io.netty.buffer.ByteBufUtil.readBytes;, +    private long contentLength = -1;, +                    if (this.contentLength >= 0) {, +                            out.add(new DefaultStompContentSubframe(chunkBuffer));, +                    } else {, +                        int nulIndex = indexOf(in, in.readerIndex(), in.writerIndex(), StompConstants.NUL);, +                        if (nulIndex == in.readerIndex()) {, +                            checkpoint(State.FINALIZE_FRAME_READ);, +                        } else {, +                            if (nulIndex > 0) {, +                                toRead = nulIndex - in.readerIndex();, +                            } else {, +                                toRead = in.writerIndex() - in.readerIndex();, +                            }, +                            ByteBuf chunkBuffer = readBytes(ctx.alloc(), in, toRead);, +                            alreadyReadChunkSize += toRead;, +                            if (nulIndex > 0) {, +                                lastContent = new DefaultLastStompContentSubframe(chunkBuffer);, +                                checkpoint(State.FINALIZE_FRAME_READ);, +                            } else {, +                                out.add(new DefaultStompContentSubframe(chunkBuffer));, +                                return;, +                            }, +                        }, +                    }, +                    this.contentLength = getContentLength(headers, 0);, +                    if (this.contentLength == 0) {, +                return State.READ_CONTENT;, +            }, +        long contentLength = headers.getLong(StompHeaders.CONTENT_LENGTH, defaultValue);, +        if (contentLength < 0) {, +            throw new DecoderException(StompHeaders.CONTENT_LENGTH + " must be non-negative");, +        }, +        return contentLength;, +        contentLength = -1;, +++ b/codec-stomp/src/main/java/io/netty/handler/codec/stomp/StompSubframeDecoder.java, +import static io.netty.buffer.ByteBufUtil.indexOf;, +import static io.netty.buffer.ByteBufUtil.readBytes;, +    private long contentLength = -1;, +                    if (this.contentLength >= 0) {, +                            out.add(new DefaultStompContentSubframe(chunkBuffer));, +                    } else {, +                        int nulIndex = indexOf(in, in.readerIndex(), in.writerIndex(), StompConstants.NUL);, +                        if (nulIndex == in.readerIndex()) {, +                            checkpoint(State.FINALIZE_FRAME_READ);, +                        } else {, +                            if (nulIndex > 0) {, +                                toRead = nulIndex - in.readerIndex();, +                            } else {, +                                toRead = in.writerIndex() - in.readerIndex();, +                            }, +                            ByteBuf chunkBuffer = readBytes(ctx.alloc(), in, toRead);, +                            alreadyReadChunkSize += toRead;, +                            if (nulIndex > 0) {, +                                lastContent = new DefaultLastStompContentSubframe(chunkBuffer);, +                                checkpoint(State.FINALIZE_FRAME_READ);, +                            } else {, +                                out.add(new DefaultStompContentSubframe(chunkBuffer));, +                                return;, +                            }, +                        }, +                    }, +                    this.contentLength = getContentLength(headers, 0);, +                    if (this.contentLength == 0) {, +                return State.READ_CONTENT;, +            }, +        long contentLength = headers.getLong(StompHeaders.CONTENT_LENGTH, defaultValue);, +        if (contentLength < 0) {, +            throw new DecoderException(StompHeaders.CONTENT_LENGTH + " must be non-negative");, +        }, +        return contentLength;, +        contentLength = -1;, +++ b/codec-stomp/src/test/java/io/netty/handler/codec/stomp/StompSubframeAggregatorTest.java, +    public void testSingleFrameWithBodyAndNoContentLength() {, +        ByteBuf incoming = Unpooled.buffer();, +        incoming.writeBytes(StompTestConstants.SEND_FRAME_4.getBytes());, +        channel.writeInbound(incoming);, +, +        StompFrame frame = channel.readInbound();, +        Assert.assertNotNull(frame);, +        Assert.assertEquals(StompCommand.SEND, frame.command());, +        Assert.assertEquals("body", frame.content().toString(CharsetUtil.UTF_8));, +        frame.release();, +, +        Assert.assertNull(channel.readInbound());, +    }, +, +    @Test, +    public void testSingleFrameWithSplitBodyAndNoContentLength() {, +        for (int n = 0; n < StompTestConstants.SEND_FRAMES_3.length; ++n) {, +            ByteBuf incoming = Unpooled.buffer();, +            incoming.writeBytes(StompTestConstants.SEND_FRAMES_3[n].getBytes());, +            channel.writeInbound(incoming);, +            channel.flush();, +        }, +, +        StompFrame frame = channel.readInbound();, +        Assert.assertNotNull(frame);]