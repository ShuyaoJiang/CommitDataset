[+++ b/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java, +import io.netty.util.concurrent.EventExecutor;, +    private void doResolveAllUncached(final String hostname,, +                                      final DnsRecord[] additionals,, +                                      final Promise<List<InetAddress>> promise,, +                                      final DnsCache resolveCache) {, +        // Call doResolveUncached0(...) in the EventLoop as we may need to submit multiple queries which would need, +        // to submit multiple Runnable at the end if we are not already on the EventLoop., +        EventExecutor executor = executor();, +        if (executor.inEventLoop()) {, +            doResolveAllUncached0(hostname, additionals, promise, resolveCache);, +        } else {, +            executor.execute(new Runnable() {, +                @Override, +                public void run() {, +                    doResolveAllUncached0(hostname, additionals, promise, resolveCache);, +                }, +            });, +        }, +    }, +, +    private void doResolveAllUncached0(String hostname,, +, +        assert executor().inEventLoop();, +, +        return query0(nameServerAddr, question, EMPTY_ADDITIONALS, true, ch.newPromise(),, +        return query0(nameServerAddr, question, toArray(additionals, false), true, ch.newPromise(),, +        return query0(nameServerAddr, question, EMPTY_ADDITIONALS, true, ch.newPromise(), promise);, +        return query0(nameServerAddr, question, toArray(additionals, false), true, ch.newPromise(), promise);, +    final void flushQueries() {, +        ch.flush();, +            boolean flush,, +            new DnsQueryContext(this, nameServerAddr, question, additionals, castPromise), +                    .query(flush, writePromise);, +++ b/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java, +import io.netty.util.concurrent.EventExecutor;, +    private void doResolveAllUncached(final String hostname,, +                                      final DnsRecord[] additionals,, +                                      final Promise<List<InetAddress>> promise,, +                                      final DnsCache resolveCache) {, +        // Call doResolveUncached0(...) in the EventLoop as we may need to submit multiple queries which would need, +        // to submit multiple Runnable at the end if we are not already on the EventLoop., +        EventExecutor executor = executor();, +        if (executor.inEventLoop()) {, +            doResolveAllUncached0(hostname, additionals, promise, resolveCache);, +        } else {, +            executor.execute(new Runnable() {, +                @Override, +                public void run() {, +                    doResolveAllUncached0(hostname, additionals, promise, resolveCache);, +                }, +            });, +        }, +    }, +, +    private void doResolveAllUncached0(String hostname,, +, +        assert executor().inEventLoop();, +, +        return query0(nameServerAddr, question, EMPTY_ADDITIONALS, true, ch.newPromise(),, +        return query0(nameServerAddr, question, toArray(additionals, false), true, ch.newPromise(),, +        return query0(nameServerAddr, question, EMPTY_ADDITIONALS, true, ch.newPromise(), promise);, +        return query0(nameServerAddr, question, toArray(additionals, false), true, ch.newPromise(), promise);, +    final void flushQueries() {, +        ch.flush();, +            boolean flush,, +            new DnsQueryContext(this, nameServerAddr, question, additionals, castPromise), +                    .query(flush, writePromise);, +++ b/resolver-dns/src/main/java/io/netty/resolver/dns/DnsQueryContext.java, +    void query(boolean flush, ChannelPromise writePromise) {, +        sendQuery(query, flush, writePromise);, +    private void sendQuery(final DnsQuery query, final boolean flush, final ChannelPromise writePromise) {, +            writeQuery(query, flush, writePromise);, +                        // If the query is done in a late fashion (as the channel was not ready yet) we always flush, +                        // to ensure we did not race with a previous flush() that was done when the Channel was not, +                        // ready yet., +                        writeQuery(query, true, writePromise);, +    private void writeQuery(final DnsQuery query, final boolean flush, final ChannelPromise writePromise) {, +        final ChannelFuture writeFuture = flush ? parent.ch.writeAndFlush(query, writePromise) :, +                parent.ch.write(query, writePromise);, +++ b/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java, +import io.netty.util.concurrent.EventExecutor;, +    private void doResolveAllUncached(final String hostname,, +                                      final DnsRecord[] additionals,, +                                      final Promise<List<InetAddress>> promise,, +                                      final DnsCache resolveCache) {, +        // Call doResolveUncached0(...) in the EventLoop as we may need to submit multiple queries which would need, +        // to submit multiple Runnable at the end if we are not already on the EventLoop., +        EventExecutor executor = executor();, +        if (executor.inEventLoop()) {, +            doResolveAllUncached0(hostname, additionals, promise, resolveCache);, +        } else {, +            executor.execute(new Runnable() {, +                @Override, +                public void run() {, +                    doResolveAllUncached0(hostname, additionals, promise, resolveCache);, +                }, +            });, +        }, +    }]