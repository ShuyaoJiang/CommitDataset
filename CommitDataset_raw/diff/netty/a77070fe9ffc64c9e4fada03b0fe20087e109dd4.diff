[+++ b/handler/src/main/java/io/netty/handler/traffic/AbstractTrafficShapingHandler.java, +    protected AbstractTrafficShapingHandler(long writeLimit, long readLimit, long checkInterval, long maxTime) {, +, +        userDefinedWritabilityIndex = userDefinedWritabilityIndex();, +     * <p>- the {@code Channel.isWritable()} property and the corresponding, +     * {@code channelWritabilityChanged()}</p>, +     * <p>- the {@code ChannelFuture.addListener(new GenericFutureListener())}</p>, +        @Override, +                    logger.debug("Not unsuspend: " + config.isAutoRead() + ':' +, +                        logger.debug("Unsuspend: " + config.isAutoRead() + ':' +, +                        logger.debug("Normal unsuspend: " + config.isAutoRead() + ':', +                logger.debug("Unsupsend final status => " + config.isAutoRead() + ':', +                    logger.debug("Read suspend: " + wait + ':' + config.isAutoRead() + ':', +                        logger.debug("Suspend final status => " + config.isAutoRead() + ':', +                    logger.debug("Write suspend: " + wait + ':' + ctx.channel().config().isAutoRead() + ':', +    abstract void submitWrite(, +            ChannelHandlerContext ctx, Object msg, long size, long delay, long now, ChannelPromise promise);, +            builder.append(trafficCounter);, +++ b/handler/src/main/java/io/netty/handler/traffic/AbstractTrafficShapingHandler.java, +    protected AbstractTrafficShapingHandler(long writeLimit, long readLimit, long checkInterval, long maxTime) {, +, +        userDefinedWritabilityIndex = userDefinedWritabilityIndex();, +     * <p>- the {@code Channel.isWritable()} property and the corresponding, +     * {@code channelWritabilityChanged()}</p>, +     * <p>- the {@code ChannelFuture.addListener(new GenericFutureListener())}</p>, +        @Override, +                    logger.debug("Not unsuspend: " + config.isAutoRead() + ':' +, +                        logger.debug("Unsuspend: " + config.isAutoRead() + ':' +, +                        logger.debug("Normal unsuspend: " + config.isAutoRead() + ':', +                logger.debug("Unsupsend final status => " + config.isAutoRead() + ':', +                    logger.debug("Read suspend: " + wait + ':' + config.isAutoRead() + ':', +                        logger.debug("Suspend final status => " + config.isAutoRead() + ':', +                    logger.debug("Write suspend: " + wait + ':' + ctx.channel().config().isAutoRead() + ':', +    abstract void submitWrite(, +            ChannelHandlerContext ctx, Object msg, long size, long delay, long now, ChannelPromise promise);, +            builder.append(trafficCounter);, +++ b/handler/src/main/java/io/netty/handler/traffic/ChannelTrafficShapingHandler.java, +import java.util.ArrayDeque;, +import java.util.concurrent.TimeUnit;, +, + * <p>Note the index used in {@code OutboundBuffer.setUserDefinedWritability(index, boolean)} is <b>1</b>.</p>, + * <li>In your handler, you should consider to use the {@code channel.isWritable()} and, + * {@code channelWritabilityChanged(ctx)} to handle writability, or through, + * {@code future.addListener(new GenericFutureListener())} on the future returned by, + * {@code ctx.write()}.</li>, +            relativeTimeAction = delay;, +++ b/handler/src/main/java/io/netty/handler/traffic/AbstractTrafficShapingHandler.java, +    protected AbstractTrafficShapingHandler(long writeLimit, long readLimit, long checkInterval, long maxTime) {, +, +        userDefinedWritabilityIndex = userDefinedWritabilityIndex();, +     * <p>- the {@code Channel.isWritable()} property and the corresponding, +     * {@code channelWritabilityChanged()}</p>, +     * <p>- the {@code ChannelFuture.addListener(new GenericFutureListener())}</p>, +        @Override, +                    logger.debug("Not unsuspend: " + config.isAutoRead() + ':' +, +                        logger.debug("Unsuspend: " + config.isAutoRead() + ':' +, +                        logger.debug("Normal unsuspend: " + config.isAutoRead() + ':', +                logger.debug("Unsupsend final status => " + config.isAutoRead() + ':', +                    logger.debug("Read suspend: " + wait + ':' + config.isAutoRead() + ':', +                        logger.debug("Suspend final status => " + config.isAutoRead() + ':', +                    logger.debug("Write suspend: " + wait + ':' + ctx.channel().config().isAutoRead() + ':', +    abstract void submitWrite(, +            ChannelHandlerContext ctx, Object msg, long size, long delay, long now, ChannelPromise promise);, +            builder.append(trafficCounter);, +++ b/handler/src/main/java/io/netty/handler/traffic/ChannelTrafficShapingHandler.java, +import java.util.ArrayDeque;, +import java.util.concurrent.TimeUnit;, +, + * <p>Note the index used in {@code OutboundBuffer.setUserDefinedWritability(index, boolean)} is <b>1</b>.</p>, + * <li>In your handler, you should consider to use the {@code channel.isWritable()} and, + * {@code channelWritabilityChanged(ctx)} to handle writability, or through, + * {@code future.addListener(new GenericFutureListener())} on the future returned by, + * {@code ctx.write()}.</li>, +            relativeTimeAction = delay;, +++ b/handler/src/main/java/io/netty/handler/traffic/GlobalChannelTrafficCounter.java, +    @Override, +    @Override, +++ b/handler/src/main/java/io/netty/handler/traffic/AbstractTrafficShapingHandler.java, +    protected AbstractTrafficShapingHandler(long writeLimit, long readLimit, long checkInterval, long maxTime) {, +, +        userDefinedWritabilityIndex = userDefinedWritabilityIndex();, +     * <p>- the {@code Channel.isWritable()} property and the corresponding, +     * {@code channelWritabilityChanged()}</p>, +     * <p>- the {@code ChannelFuture.addListener(new GenericFutureListener())}</p>, +        @Override, +                    logger.debug("Not unsuspend: " + config.isAutoRead() + ':' +, +                        logger.debug("Unsuspend: " + config.isAutoRead() + ':' +, +                        logger.debug("Normal unsuspend: " + config.isAutoRead() + ':', +                logger.debug("Unsupsend final status => " + config.isAutoRead() + ':', +                    logger.debug("Read suspend: " + wait + ':' + config.isAutoRead() + ':', +                        logger.debug("Suspend final status => " + config.isAutoRead() + ':', +                    logger.debug("Write suspend: " + wait + ':' + ctx.channel().config().isAutoRead() + ':', +    abstract void submitWrite(, +            ChannelHandlerContext ctx, Object msg, long size, long delay, long now, ChannelPromise promise);, +            builder.append(trafficCounter);, +++ b/handler/src/main/java/io/netty/handler/traffic/ChannelTrafficShapingHandler.java, +import java.util.ArrayDeque;, +import java.util.concurrent.TimeUnit;, +, + * <p>Note the index used in {@code OutboundBuffer.setUserDefinedWritability(index, boolean)} is <b>1</b>.</p>]