[+++ b/buffer/src/main/java/io/netty/buffer/PoolThreadCache.java, +                    int maxCachedBufferCapacity, int freeSweepAllocationThreshold) {, +++ b/buffer/src/main/java/io/netty/buffer/PoolThreadCache.java, +                    int maxCachedBufferCapacity, int freeSweepAllocationThreshold) {, +++ b/buffer/src/main/java/io/netty/buffer/PooledByteBufAllocator.java, +                        DEFAULT_MAX_CACHED_BUFFER_CAPACITY, DEFAULT_CACHE_TRIM_INTERVAL);, +            // No caching so just use 0 as sizes., +            return new PoolThreadCache(heapArena, directArena, 0, 0, 0, 0, 0);, +++ b/buffer/src/main/java/io/netty/buffer/PoolThreadCache.java, +                    int maxCachedBufferCapacity, int freeSweepAllocationThreshold) {, +++ b/buffer/src/main/java/io/netty/buffer/PooledByteBufAllocator.java, +                        DEFAULT_MAX_CACHED_BUFFER_CAPACITY, DEFAULT_CACHE_TRIM_INTERVAL);, +            // No caching so just use 0 as sizes., +            return new PoolThreadCache(heapArena, directArena, 0, 0, 0, 0, 0);, +++ b/buffer/src/test/java/io/netty/buffer/PooledByteBufAllocatorTest.java, +    public void testThreadCacheDestroyedByThreadCleaner() throws InterruptedException {, +        testThreadCacheDestroyed(false);, +        testThreadCacheDestroyed(true);, +    private static void testThreadCacheDestroyed(boolean useRunnable) throws InterruptedException {, +            thread.join();, +            // Signal we want to have a GC run to ensure we can process our ThreadCleanerReference, +            System.gc();, +            System.runFinalization();, +++ b/buffer/src/main/java/io/netty/buffer/PoolThreadCache.java, +                    int maxCachedBufferCapacity, int freeSweepAllocationThreshold) {, +++ b/buffer/src/main/java/io/netty/buffer/PooledByteBufAllocator.java, +                        DEFAULT_MAX_CACHED_BUFFER_CAPACITY, DEFAULT_CACHE_TRIM_INTERVAL);, +            // No caching so just use 0 as sizes., +            return new PoolThreadCache(heapArena, directArena, 0, 0, 0, 0, 0);, +++ b/buffer/src/test/java/io/netty/buffer/PooledByteBufAllocatorTest.java, +    public void testThreadCacheDestroyedByThreadCleaner() throws InterruptedException {, +        testThreadCacheDestroyed(false);, +        testThreadCacheDestroyed(true);, +    private static void testThreadCacheDestroyed(boolean useRunnable) throws InterruptedException {, +            thread.join();, +            // Signal we want to have a GC run to ensure we can process our ThreadCleanerReference, +            System.gc();, +            System.runFinalization();, +++ b/common/src/main/java/io/netty/util/Recycler.java, +                    ? newQueue(stack, thread) : null;, +++ b/buffer/src/main/java/io/netty/buffer/PoolThreadCache.java, +                    int maxCachedBufferCapacity, int freeSweepAllocationThreshold) {, +++ b/buffer/src/main/java/io/netty/buffer/PooledByteBufAllocator.java, +                        DEFAULT_MAX_CACHED_BUFFER_CAPACITY, DEFAULT_CACHE_TRIM_INTERVAL);, +            // No caching so just use 0 as sizes., +            return new PoolThreadCache(heapArena, directArena, 0, 0, 0, 0, 0);, +++ b/buffer/src/test/java/io/netty/buffer/PooledByteBufAllocatorTest.java, +    public void testThreadCacheDestroyedByThreadCleaner() throws InterruptedException {, +        testThreadCacheDestroyed(false);, +        testThreadCacheDestroyed(true);, +    private static void testThreadCacheDestroyed(boolean useRunnable) throws InterruptedException {, +            thread.join();, +            // Signal we want to have a GC run to ensure we can process our ThreadCleanerReference, +            System.gc();, +            System.runFinalization();, +++ b/common/src/main/java/io/netty/util/Recycler.java, +                    ? newQueue(stack, thread) : null;, +++ b/common/src/main/java/io/netty/util/ThreadDeathWatcher.java, + *, + * @deprecated will be removed in the next major release, +@Deprecated, +++ b/buffer/src/main/java/io/netty/buffer/PoolThreadCache.java, +                    int maxCachedBufferCapacity, int freeSweepAllocationThreshold) {, +++ b/buffer/src/main/java/io/netty/buffer/PooledByteBufAllocator.java, +                        DEFAULT_MAX_CACHED_BUFFER_CAPACITY, DEFAULT_CACHE_TRIM_INTERVAL);, +            // No caching so just use 0 as sizes., +            return new PoolThreadCache(heapArena, directArena, 0, 0, 0, 0, 0);, +++ b/buffer/src/test/java/io/netty/buffer/PooledByteBufAllocatorTest.java, +    public void testThreadCacheDestroyedByThreadCleaner() throws InterruptedException {, +        testThreadCacheDestroyed(false);, +        testThreadCacheDestroyed(true);, +    private static void testThreadCacheDestroyed(boolean useRunnable) throws InterruptedException {, +            thread.join();, +            // Signal we want to have a GC run to ensure we can process our ThreadCleanerReference, +            System.gc();, +            System.runFinalization();, +++ b/common/src/main/java/io/netty/util/Recycler.java, +                    ? newQueue(stack, thread) : null;, +++ b/common/src/main/java/io/netty/util/ThreadDeathWatcher.java, + *, + * @deprecated will be removed in the next major release, +@Deprecated, +++ b/common/src/main/java/io/netty/util/concurrent/FastThreadLocal.java, +import io.netty.util.internal.ObjectCleaner;, +    @SuppressWarnings("unchecked"), +        final InternalThreadLocalMap threadLocalMap = InternalThreadLocalMap.get();, +        Object v = threadLocalMap.indexedVariable(index);, +        if (v != InternalThreadLocalMap.UNSET) {, +            return (V) v;, +        }, +, +        V value = initialize(threadLocalMap);, +        Thread current = Thread.currentThread();, +        if (!FastThreadLocalThread.willCleanupFastThreadLocals(current)) {, +            // We will need to ensure we will trigger remove(InternalThreadLocalMap) so everything will be released, +            // and FastThreadLocal.onRemoval(...) will be called., +            ObjectCleaner.register(current, new Runnable() {, +                @Override, +                public void run() {, +                    remove(threadLocalMap);]