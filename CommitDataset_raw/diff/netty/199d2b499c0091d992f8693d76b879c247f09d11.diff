[+++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollDatagramChannelConfig.java, +                ChannelOption.IP_TOS, ChannelOption.DATAGRAM_CHANNEL_ACTIVE_ON_REGISTRATION,, +                EpollChannelOption.SO_REUSEPORT);, +        if (option == EpollChannelOption.SO_REUSEPORT) {, +            return (T) Boolean.valueOf(isReusePort());, +        }, +        } else if (option == EpollChannelOption.SO_REUSEPORT) {, +            setReusePort((Boolean) value);, +    /**, +     * Returns {@code true} if the SO_REUSEPORT option is set., +     */, +    public boolean isReusePort() {, +        return Native.isReusePort(datagramChannel.fd) == 1;, +    }, +, +    /**, +     * Set the SO_REUSEPORT option on the underlying Channel. This will allow to bind multiple, +     * {@link EpollSocketChannel}s to the same port and so accept connections with multiple threads., +     *, +     * Be aware this method needs be called before {@link EpollDatagramChannel#bind(java.net.SocketAddress)} to have, +     * any affect., +     */, +    public EpollDatagramChannelConfig setReusePort(boolean reusePort) {, +        Native.setReusePort(datagramChannel.fd, reusePort ? 1 : 0);, +        return this;, +    }, +, +++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollDatagramChannelConfig.java, +                ChannelOption.IP_TOS, ChannelOption.DATAGRAM_CHANNEL_ACTIVE_ON_REGISTRATION,, +                EpollChannelOption.SO_REUSEPORT);, +        if (option == EpollChannelOption.SO_REUSEPORT) {, +            return (T) Boolean.valueOf(isReusePort());, +        }, +        } else if (option == EpollChannelOption.SO_REUSEPORT) {, +            setReusePort((Boolean) value);, +    /**, +     * Returns {@code true} if the SO_REUSEPORT option is set., +     */, +    public boolean isReusePort() {, +        return Native.isReusePort(datagramChannel.fd) == 1;, +    }, +, +    /**, +     * Set the SO_REUSEPORT option on the underlying Channel. This will allow to bind multiple, +     * {@link EpollSocketChannel}s to the same port and so accept connections with multiple threads., +     *, +     * Be aware this method needs be called before {@link EpollDatagramChannel#bind(java.net.SocketAddress)} to have, +     * any affect., +     */, +    public EpollDatagramChannelConfig setReusePort(boolean reusePort) {, +        Native.setReusePort(datagramChannel.fd, reusePort ? 1 : 0);, +        return this;, +    }, +, +++ b/transport-native-epoll/src/test/java/io/netty/channel/epoll/EpollReuseAddrTest.java, +import io.netty.bootstrap.AbstractBootstrap;, +import io.netty.bootstrap.Bootstrap;, +import io.netty.util.NetUtil;, +import io.netty.util.ReferenceCountUtil;, +import io.netty.util.ResourceLeakDetector;, +import java.net.DatagramPacket;, +import java.net.DatagramSocket;, +import java.util.concurrent.CountDownLatch;, +import java.util.concurrent.ExecutorService;, +import java.util.concurrent.Executors;, +    public void testMultipleBindSocketChannelWithoutReusePortFails() {, +        testMultipleBindDatagramChannelWithoutReusePortFails0(createServerBootstrap());, +    }, +, +    @Test, +    public void testMultipleBindDatagramChannelWithoutReusePortFails() {, +        Assume.assumeTrue(versionEqOrGt(3, 9, 0));, +        testMultipleBindDatagramChannelWithoutReusePortFails0(createBootstrap());, +    }, +, +    private static void testMultipleBindDatagramChannelWithoutReusePortFails0(AbstractBootstrap<?, ?> bootstrap) {, +        bootstrap.handler(new DummyHandler());, +    public void testMultipleBindSocketChannel() throws Exception {, +        ServerBootstrap bootstrap = createServerBootstrap();, +        bootstrap.childHandler(new ServerSocketTestHandler(accepted1));, +        InetSocketAddress address1 = (InetSocketAddress) future.channel().localAddress();, +        bootstrap.childHandler(new ServerSocketTestHandler(accepted2));, +        InetSocketAddress address2 = (InetSocketAddress) future2.channel().localAddress();, +        Assert.assertEquals(address1, address2);, +            Socket socket = new Socket(address1.getAddress(), address1.getPort());, +    @Test(timeout = 10000), +    public void testMultipleBindDatagramChannel() throws Exception {, +        ResourceLeakDetector.setLevel(ResourceLeakDetector.Level.ADVANCED);, +        Assume.assumeTrue(versionEqOrGt(3, 9, 0));, +        Bootstrap bootstrap = createBootstrap();, +        bootstrap.option(EpollChannelOption.SO_REUSEPORT, true);, +        final AtomicBoolean received1 = new AtomicBoolean();, +        bootstrap.handler(new DatagramSocketTestHandler(received1));, +        ChannelFuture future = bootstrap.bind().syncUninterruptibly();, +        final InetSocketAddress address1 = (InetSocketAddress) future.channel().localAddress();, +, +        final AtomicBoolean received2 = new AtomicBoolean();, +        bootstrap.handler(new DatagramSocketTestHandler(received2));, +        ChannelFuture future2 = bootstrap.bind().syncUninterruptibly();, +        final InetSocketAddress address2 = (InetSocketAddress) future2.channel().localAddress();]