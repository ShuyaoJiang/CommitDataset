[+++ b/common/src/main/java/io/netty/util/HashedWheelTimer.java, +import java.util.concurrent.locks.Lock;, +import java.util.concurrent.locks.ReentrantLock;, +                    int idx = (int) (tick & mask);, +                            wheel[idx];, +                    bucket.lock.lock();, +                    try {, +                        transferTimeoutsToBuckets();, +                    } finally {, +                        bucket.lock.unlock();, +                    }, +                if (timeout.state() == HashedWheelTimeout.ST_CANCELLED) {, +                    // Was cancelled in the meantime., +, +        private static final int ST_CANCELLED = 1;, +        private static final int ST_EXPIRED = 2;, +            if (!compareAndSetState(ST_INIT, ST_CANCELLED)) {, +            HashedWheelBucket bucket = this.bucket;, +                // if tryLock fails it means that HashedWheelBucket is currently processed and so there is nothing for, +                // us to do as the remove itself will be done while processing., +                if (bucket.lock.tryLock()) {, +                    try {, +                    } finally {, +                        bucket.lock.unlock();, +            }, +            return true;, +        }, +            return state() == ST_EXPIRED;, +            if (!compareAndSetState(ST_INIT, ST_EXPIRED)) {, +        // Lock used during processing of each HashedWheelBucket. The Lock will be acquired on each tick for the, +        // current HashedWheelBucket and also tried to acquired when a HashedWheelTimeout should be cancelled., +        // This allows fast GC for cancelled HashedWheelTimeouts., +        private final Lock lock = new ReentrantLock();, +, +++ b/common/src/main/java/io/netty/util/HashedWheelTimer.java, +import java.util.concurrent.locks.Lock;, +import java.util.concurrent.locks.ReentrantLock;, +                    int idx = (int) (tick & mask);, +                            wheel[idx];, +                    bucket.lock.lock();, +                    try {, +                        transferTimeoutsToBuckets();, +                    } finally {, +                        bucket.lock.unlock();, +                    }, +                if (timeout.state() == HashedWheelTimeout.ST_CANCELLED) {, +                    // Was cancelled in the meantime., +, +        private static final int ST_CANCELLED = 1;, +        private static final int ST_EXPIRED = 2;, +            if (!compareAndSetState(ST_INIT, ST_CANCELLED)) {, +            HashedWheelBucket bucket = this.bucket;, +                // if tryLock fails it means that HashedWheelBucket is currently processed and so there is nothing for, +                // us to do as the remove itself will be done while processing., +                if (bucket.lock.tryLock()) {, +                    try {, +                    } finally {, +                        bucket.lock.unlock();, +            }, +            return true;, +        }, +            return state() == ST_EXPIRED;, +            if (!compareAndSetState(ST_INIT, ST_EXPIRED)) {, +        // Lock used during processing of each HashedWheelBucket. The Lock will be acquired on each tick for the, +        // current HashedWheelBucket and also tried to acquired when a HashedWheelTimeout should be cancelled., +        // This allows fast GC for cancelled HashedWheelTimeouts., +        private final Lock lock = new ReentrantLock();, +, +++ b/common/src/test/java/io/netty/util/HashedWheelTimerTest.java, +import java.util.concurrent.BlockingQueue;, +import java.util.concurrent.LinkedBlockingQueue;, +        timer.stop();, +    }, +, +    @Test, +    public void testExecutionOnTime() throws InterruptedException {, +        int tickDuration = 200;, +        int timeout = 125;, +        int maxTimeout = tickDuration + timeout;, +        final HashedWheelTimer timer = new HashedWheelTimer(tickDuration, TimeUnit.MILLISECONDS);, +        final BlockingQueue<Long> queue = new LinkedBlockingQueue<Long>();, +, +        int scheduledTasks = 100000;, +        for (int i = 0; i < scheduledTasks; i++) {, +            final long start = System.nanoTime();, +            timer.newTimeout(new TimerTask() {, +                @Override, +                public void run(final Timeout timeout) throws Exception {, +                    queue.add(TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - start));, +                }, +            }, timeout, TimeUnit.MILLISECONDS);, +        }, +, +        for (int i = 0; i < scheduledTasks; i++) {, +            long delay = queue.take();, +            assertTrue("Timeout + " + scheduledTasks + " delay " + delay + " must be " + timeout + " <= " + maxTimeout,, +                    delay >= timeout && delay <= maxTimeout);, +        }, +, +        timer.stop();]