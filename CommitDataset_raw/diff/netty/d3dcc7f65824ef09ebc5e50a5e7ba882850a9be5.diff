[+++ b/transport/src/main/java/io/netty/channel/local/LocalChannel.java, +import io.netty.util.concurrent.Future;, +import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;, +    @SuppressWarnings({ "rawtypes" }), +    private static final AtomicReferenceFieldUpdater<LocalChannel, Future> FINISH_READ_FUTURE_UPDATER;, +    private volatile Future<?> finishReadFuture;, +, +    static {, +        @SuppressWarnings({ "rawtypes" }), +        AtomicReferenceFieldUpdater<LocalChannel, Future> finishReadFutureUpdater =, +                PlatformDependent.newAtomicReferenceFieldUpdater(LocalChannel.class, "finishReadFuture");, +        if (finishReadFutureUpdater == null) {, +            finishReadFutureUpdater =, +                AtomicReferenceFieldUpdater.newUpdater(LocalChannel.class, Future.class, "finishReadFuture");, +        }, +        FINISH_READ_FUTURE_UPDATER = finishReadFutureUpdater;, +    }, +            runFinishPeerReadTask(peer);, +        }, +    }, +, +    private void runFinishPeerReadTask(final LocalChannel peer) {, +        // If the peer is writing, we must wait until after reads are completed for that peer before we can read. So, +        // we keep track of the task, and coordinate later that our read can't happen until the peer is done., +        final Runnable finishPeerReadTask = new OneTimeTask() {, +        };, +        if (peer.writeInProgress) {, +            peer.finishReadFuture = peer.eventLoop().submit(finishPeerReadTask);, +        } else {, +            peer.eventLoop().execute(finishPeerReadTask);, +    private void finishPeerRead0(LocalChannel peer) {, +        Future<?> peerFinishReadFuture = peer.finishReadFuture;, +        if (peerFinishReadFuture != null) {, +            if (!peerFinishReadFuture.isDone()) {, +                runFinishPeerReadTask(peer);, +                return;, +            } else {, +                // Lazy unset to make sure we don't prematurely unset it while scheduling a new task., +                FINISH_READ_FUTURE_UPDATER.compareAndSet(peer, peerFinishReadFuture, null);, +            }, +        }, +++ b/transport/src/main/java/io/netty/channel/local/LocalChannel.java, +import io.netty.util.concurrent.Future;, +import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;, +    @SuppressWarnings({ "rawtypes" }), +    private static final AtomicReferenceFieldUpdater<LocalChannel, Future> FINISH_READ_FUTURE_UPDATER;, +    private volatile Future<?> finishReadFuture;, +, +    static {, +        @SuppressWarnings({ "rawtypes" }), +        AtomicReferenceFieldUpdater<LocalChannel, Future> finishReadFutureUpdater =, +                PlatformDependent.newAtomicReferenceFieldUpdater(LocalChannel.class, "finishReadFuture");, +        if (finishReadFutureUpdater == null) {, +            finishReadFutureUpdater =, +                AtomicReferenceFieldUpdater.newUpdater(LocalChannel.class, Future.class, "finishReadFuture");, +        }, +        FINISH_READ_FUTURE_UPDATER = finishReadFutureUpdater;, +    }, +            runFinishPeerReadTask(peer);, +        }, +    }, +, +    private void runFinishPeerReadTask(final LocalChannel peer) {, +        // If the peer is writing, we must wait until after reads are completed for that peer before we can read. So, +        // we keep track of the task, and coordinate later that our read can't happen until the peer is done., +        final Runnable finishPeerReadTask = new OneTimeTask() {, +        };, +        if (peer.writeInProgress) {, +            peer.finishReadFuture = peer.eventLoop().submit(finishPeerReadTask);, +        } else {, +            peer.eventLoop().execute(finishPeerReadTask);, +    private void finishPeerRead0(LocalChannel peer) {, +        Future<?> peerFinishReadFuture = peer.finishReadFuture;, +        if (peerFinishReadFuture != null) {, +            if (!peerFinishReadFuture.isDone()) {, +                runFinishPeerReadTask(peer);, +                return;, +            } else {, +                // Lazy unset to make sure we don't prematurely unset it while scheduling a new task., +                FINISH_READ_FUTURE_UPDATER.compareAndSet(peer, peerFinishReadFuture, null);, +            }, +        }, +++ b/transport/src/test/java/io/netty/channel/local/LocalChannelTest.java, +    private static final LocalAddress TEST_ADDRESS = new LocalAddress("test.id");, +                sc = sb.bind(TEST_ADDRESS).sync().channel();, +                cc = cb.connect(sc.localAddress()).sync().channel();, +                        LocalChannelRegistry.get(TEST_ADDRESS), TEST_ADDRESS), LocalChannelRegistry.get(TEST_ADDRESS));, +            sc = sb.bind(TEST_ADDRESS).sync().channel();, +            cc = cb.connect(sc.localAddress()).sync().channel();, +            sc = sb.bind(TEST_ADDRESS).sync().channel();, +            cc = b.connect(sc.localAddress()).sync().channel();, +                    bind(TEST_ADDRESS)., +            ChannelFuture future = bootstrap.connect(sc.localAddress());, +            sc = sb.bind(TEST_ADDRESS).syncUninterruptibly().channel();, +            cc = cb.connect(sc.localAddress()).syncUninterruptibly().channel();, +                sc = sb.bind(TEST_ADDRESS).syncUninterruptibly().channel();, +                cc = cb.connect(sc.localAddress()).syncUninterruptibly().channel();, +                sc = sb.bind(TEST_ADDRESS).syncUninterruptibly().channel();, +                cc = cb.connect(sc.localAddress()).syncUninterruptibly().channel();, +            sc = sb.bind(TEST_ADDRESS).syncUninterruptibly().channel();]