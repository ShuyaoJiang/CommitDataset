[+++ b/buffer/src/main/java/io/netty/buffer/FixedCompositeByteBuf.java, +    private final ByteBuf[] buffers;, +            this.buffers = buffers;, +            ByteBuf b = buffers[i];, +            if (b instanceof Component) {, +                comp = (Component) b;, +                if (comp == null) {, +        ByteBuf b = buffers[i];, +        return b instanceof Component ? ((Component) b).buf : b;, +    private static final class Component extends WrappedByteBuf {, +            super(buf);, +++ b/buffer/src/main/java/io/netty/buffer/FixedCompositeByteBuf.java, +    private final ByteBuf[] buffers;, +            this.buffers = buffers;, +            ByteBuf b = buffers[i];, +            if (b instanceof Component) {, +                comp = (Component) b;, +                if (comp == null) {, +        ByteBuf b = buffers[i];, +        return b instanceof Component ? ((Component) b).buf : b;, +    private static final class Component extends WrappedByteBuf {, +            super(buf);, +++ b/buffer/src/main/java/io/netty/buffer/Unpooled.java, +import java.util.Arrays;, +        return wrappedUnmodifiableBuffer(true, buffers);, +    }, +, +    /**, +     * Wrap the given {@link ByteBuf}s in an unmodifiable {@link ByteBuf}. Be aware the returned {@link ByteBuf} will, +     * not try to slice the given {@link ByteBuf}s to reduce GC-Pressure., +     *, +     * The returned {@link ByteBuf} wraps the provided array directly, and so should not be subsequently modified., +     */, +    public static ByteBuf wrappedUnmodifiableBuffer(ByteBuf... buffers) {, +        return wrappedUnmodifiableBuffer(false, buffers);, +    }, +, +    private static ByteBuf wrappedUnmodifiableBuffer(boolean copy, ByteBuf... buffers) {, +        switch (buffers.length) {, +        case 0:, +            return EMPTY_BUFFER;, +        case 1:, +            return buffers[0].asReadOnly();, +        default:, +            if (copy) {, +                buffers = Arrays.copyOf(buffers, buffers.length, ByteBuf[].class);, +            }, +    }]