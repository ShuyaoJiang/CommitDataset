[+++ b/handler/src/main/java/io/netty/handler/ssl/SslHandler.java, +            // Explicit start handshake processing once we send the first message. This will also ensure, +            // we will schedule the timeout if needed., +            startHandshakeProcessing();, +        if (!handshakeStarted) {, +                handshake(null, true);, +    }, +                    handshake(promise, false);, +        handshake(promise, false);, +    private void handshake(final Promise<Channel> newHandshakePromise, boolean initialHandshake) {, +            if (initialHandshake) {, +                // This is the intial handshake either triggered by handlerAdded(...), channelActive(...) or, +                // flush(...) when starttls was used. In all the cases we need to ensure we schedule a timeout., +                applyHandshakeTimeout(null);, +            }, +++ b/handler/src/main/java/io/netty/handler/ssl/SslHandler.java, +            // Explicit start handshake processing once we send the first message. This will also ensure, +            // we will schedule the timeout if needed., +            startHandshakeProcessing();, +        if (!handshakeStarted) {, +                handshake(null, true);, +    }, +                    handshake(promise, false);, +        handshake(promise, false);, +    private void handshake(final Promise<Channel> newHandshakePromise, boolean initialHandshake) {, +            if (initialHandshake) {, +                // This is the intial handshake either triggered by handlerAdded(...), channelActive(...) or, +                // flush(...) when starttls was used. In all the cases we need to ensure we schedule a timeout., +                applyHandshakeTimeout(null);, +            }, +++ b/handler/src/test/java/io/netty/handler/ssl/SslHandlerTest.java, +import static org.hamcrest.CoreMatchers.*;, +, +    @Test(timeout = 10000), +    public void testHandshakeTimeoutFlushStartsHandshake() throws Exception {, +        testHandshakeTimeout0(false);, +    }, +, +    @Test(timeout = 10000), +    public void testHandshakeTimeoutStartTLS() throws Exception {, +        testHandshakeTimeout0(true);, +    }, +, +    private static void testHandshakeTimeout0(final boolean startTls) throws Exception {, +        final SslContext sslClientCtx = SslContextBuilder.forClient(), +                                                         .startTls(true), +                                                         .trustManager(InsecureTrustManagerFactory.INSTANCE), +                                                         .sslProvider(SslProvider.JDK).build();, +, +        EventLoopGroup group = new NioEventLoopGroup();, +        Channel sc = null;, +        Channel cc = null;, +        final SslHandler sslHandler = sslClientCtx.newHandler(UnpooledByteBufAllocator.DEFAULT);, +        sslHandler.setHandshakeTimeout(500, TimeUnit.MILLISECONDS);, +, +        try {, +            sc = new ServerBootstrap(), +                    .group(group), +                    .channel(NioServerSocketChannel.class), +                    .childHandler(new ChannelInboundHandlerAdapter()), +                    .bind(new InetSocketAddress(0)).syncUninterruptibly().channel();, +, +            ChannelFuture future = new Bootstrap(), +                    .group(group), +                    .channel(NioSocketChannel.class), +                    .handler(new ChannelInitializer<Channel>() {, +                        @Override, +                        protected void initChannel(Channel ch) throws Exception {, +                            ch.pipeline().addLast(sslHandler);, +                            if (startTls) {, +                                ch.pipeline().addLast(new ChannelInboundHandlerAdapter() {, +                                    @Override, +                                    public void channelActive(ChannelHandlerContext ctx) throws Exception {, +                                        ctx.writeAndFlush(wrappedBuffer(new byte[] { 1, 2, 3, 4 }));, +                                    }, +                                });, +                            }, +                        }, +                    }).connect(sc.localAddress());, +            if (!startTls) {, +                future.addListener(new ChannelFutureListener() {, +                    @Override, +                    public void operationComplete(ChannelFuture future) throws Exception {, +                        // Write something to trigger the handshake before fireChannelActive is called., +                        future.channel().writeAndFlush(wrappedBuffer(new byte [] { 1, 2, 3, 4 }));, +                    }, +                });, +            }, +            cc = future.syncUninterruptibly().channel();, +, +            Throwable cause = sslHandler.handshakeFuture().await().cause();, +            assertThat(cause, CoreMatchers.<Throwable>instanceOf(SSLException.class));, +            assertThat(cause.getMessage(), containsString("timed out"));, +        } finally {, +            if (cc != null) {, +                cc.close().syncUninterruptibly();, +            }, +            if (sc != null) {, +                sc.close().syncUninterruptibly();, +            }]