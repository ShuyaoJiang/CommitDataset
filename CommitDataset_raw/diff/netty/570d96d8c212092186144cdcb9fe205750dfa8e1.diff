[+++ b/handler/src/main/java/io/netty/handler/ssl/SslHandler.java, +import io.netty.util.ReferenceCountUtil;, +        pendingUnencryptedWrites = null;, +    private static IllegalStateException newPendingWritesNullException() {, +        return new IllegalStateException("pendingUnencryptedWrites is null, handlerRemoved0 called?");, +    }, +, +            UnsupportedMessageTypeException exception = new UnsupportedMessageTypeException(msg, ByteBuf.class);, +            ReferenceCountUtil.safeRelease(msg);, +            promise.setFailure(exception);, +        } else if (pendingUnencryptedWrites == null) {, +            ReferenceCountUtil.safeRelease(msg);, +            promise.setFailure(newPendingWritesNullException());, +        } else {, +    }, +            if (pendingUnencryptedWrites != null) {, +    }, +        if (pendingUnencryptedWrites != null) {, +        } else {, +            promise.setFailure(newPendingWritesNullException());, +        }, +++ b/handler/src/main/java/io/netty/handler/ssl/SslHandler.java, +import io.netty.util.ReferenceCountUtil;, +        pendingUnencryptedWrites = null;, +    private static IllegalStateException newPendingWritesNullException() {, +        return new IllegalStateException("pendingUnencryptedWrites is null, handlerRemoved0 called?");, +    }, +, +            UnsupportedMessageTypeException exception = new UnsupportedMessageTypeException(msg, ByteBuf.class);, +            ReferenceCountUtil.safeRelease(msg);, +            promise.setFailure(exception);, +        } else if (pendingUnencryptedWrites == null) {, +            ReferenceCountUtil.safeRelease(msg);, +            promise.setFailure(newPendingWritesNullException());, +        } else {, +    }, +            if (pendingUnencryptedWrites != null) {, +    }, +        if (pendingUnencryptedWrites != null) {, +        } else {, +            promise.setFailure(newPendingWritesNullException());, +        }, +++ b/handler/src/test/java/io/netty/handler/ssl/SslHandlerTest.java, +import io.netty.util.AbstractReferenceCounted;, +    @Test, +    public void testNonByteBufWriteIsReleased() throws Exception {, +        SSLEngine engine = SSLContext.getDefault().createSSLEngine();, +        engine.setUseClientMode(false);, +, +        EmbeddedChannel ch = new EmbeddedChannel(new SslHandler(engine));, +, +        AbstractReferenceCounted referenceCounted = new AbstractReferenceCounted() {, +            @Override, +            public ReferenceCounted touch(Object hint) {, +                return this;, +            }, +, +            @Override, +            protected void deallocate() {, +            }, +        };, +        try {, +            ch.write(referenceCounted).get();, +            fail();, +        } catch (ExecutionException e) {, +            assertThat(e.getCause(), is(instanceOf(UnsupportedMessageTypeException.class)));, +        }, +        assertEquals(0, referenceCounted.refCnt());, +        assertTrue(ch.finishAndReleaseAll());, +    }, +]