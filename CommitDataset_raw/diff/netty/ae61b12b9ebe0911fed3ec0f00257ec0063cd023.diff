[+++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslEngine.java, +    static final int MAX_ENCRYPTION_OVERHEAD_LENGTH = MAX_ENCRYPTED_PACKET_LENGTH - MAX_PLAINTEXT_LENGTH;, +, +++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslEngine.java, +    static final int MAX_ENCRYPTION_OVERHEAD_LENGTH = MAX_ENCRYPTED_PACKET_LENGTH - MAX_PLAINTEXT_LENGTH;, +, +++ b/handler/src/main/java/io/netty/handler/ssl/SslHandler.java, +    /**, +     * {@code true} if and only if {@link SSLEngine#wrap(ByteBuffer, ByteBuffer)} requires the output buffer, +     * to be always as large as {@link #maxPacketBufferSize} even if the input buffer contains small amount of data., +     * <p>, +     * If this flag is {@code false}, we allocate a smaller output buffer., +     * </p>, +     */, +    private final boolean needsLargeOutNetBuf;, +        needsLargeOutNetBuf = !(engine instanceof OpenSslEngine);, +, +                if (out == null) {, +                    out = allocateOutNetBuf(ctx, buf.readableBytes());, +                }, +, +                    out = allocateOutNetBuf(ctx, 0);, +    /**, +     * Allocates an outbound network buffer for {@link SSLEngine#wrap(ByteBuffer, ByteBuffer)} which can encrypt, +     * the specified amount of pending bytes., +     */, +    private ByteBuf allocateOutNetBuf(ChannelHandlerContext ctx, int pendingBytes) {, +        if (needsLargeOutNetBuf) {, +            return allocate(ctx, maxPacketBufferSize);, +        } else {, +            return allocate(ctx, Math.min(, +                    pendingBytes + OpenSslEngine.MAX_ENCRYPTION_OVERHEAD_LENGTH,, +                    maxPacketBufferSize));, +        }, +    }, +]