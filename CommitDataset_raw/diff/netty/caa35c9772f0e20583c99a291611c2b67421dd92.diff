[+++ b/transport/src/main/java/io/netty/channel/DefaultChannelPipeline.java, +import java.util.concurrent.Callable;, +            Future<Throwable> future;, +                future = newCtx.executor().submit(new AsyncPipelineModification() {, +, +                    void doCall() {, +            Throwable result = future.get();, +            if (result != null) {, +                // re-throw exception that was caught , +                throw result;, +            }, +            Future<Throwable> future;, +                    future = newTail.executor().submit(new AsyncPipelineModification() {, +                        , +                        void doCall() {, +            Throwable result = future.get();, +            if (result != null) {, +                // re-throw exception that was caught , +                throw result;, +            }, +            return this;, +, +            Future<Throwable> future;, +                    future = newCtx.executor().submit(new AsyncPipelineModification() {, +                        , +                        void doCall() {, +            // Call Future.get() outside of synchronized block to prevent dead-lock, +            Throwable result = future.get();, +            if (result != null) {, +                // re-throw exception that was caught , +                throw result;, +            }, +            return this;, +            Future<Throwable> future;, +                    future = newCtx.executor().submit(new AsyncPipelineModification() {, +                        , +                        void doCall() {, +            // Call Future.get() outside of synchronized block to prevent dead-lock, +            Throwable result = future.get();, +            if (result != null) {, +                // re-throw exception that was caught , +                throw result;, +            }, +            Future<Throwable> future;, +                        future = oldTail.executor().submit(new AsyncPipelineModification() {, +                            , +                            void doCall() {, +                       future = ctx.executor().submit(new AsyncPipelineModification() {, +                        void doCall() {, +            // Call Future.get() outside of synchronized block to prevent dead-lock, +            Throwable result = future.get();, +            if (result != null) {, +                // re-throw exception that was caught , +                throw result;, +            }, +            , +            Future<Throwable> future;, +                    future = oldTail.executor().submit(new AsyncPipelineModification() {, +                        void doCall() {, +            // Call Future.get() outside of synchronized block to prevent dead-lock, +            Throwable result = future.get();, +            if (result != null) {, +                // re-throw exception that was caught , +                throw result;, +            }, +            , +            Future<Throwable> future;, +                            future = oldTail.executor().submit(new AsyncPipelineModification() {, +                                , +                                void doCall() {, +                        future = newCtx.executor().submit(new AsyncPipelineModification() {, +, +                            void doCall() {, +, +            // Call Future.get() outside of synchronized block to prevent dead-lock, +            Throwable result = future.get();, +            if (result != null) {, +                // re-throw exception that was caught , +                throw result;, +            }, +            , +    , +    /**, +     * Custom {@link Callable} implementation which will catch all {@link Throwable} which happens during execution of {@link AsyncPipelineModification#doCall()}, +     * and return them in the {@link Future}. This allows to re-throw them later., +     * , +     * It also handles the right synchronization of the {@link AsyncPipelineModification#doCall()} method., +     *, +     */, +    private abstract class AsyncPipelineModification implements Callable<Throwable> {, +, +        @Override, +        public Throwable call() {, +            try {, +                synchronized (DefaultChannelPipeline.this) {, +                    doCall();, +                }, +            } catch (Throwable t) {, +                return t;, +            }]