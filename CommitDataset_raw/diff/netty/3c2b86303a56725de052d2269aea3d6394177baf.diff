[+++ b/transport/src/main/java/io/netty/channel/AbstractChannelHandlerContext.java, +        ObjectUtil.checkNotNull(msg, "msg");, +        try {, +            if (isNotValidPromise(promise, true)) {, +                ReferenceCountUtil.release(msg);, +                // cancelled, +                return;, +            }, +        } catch (RuntimeException e) {, +            ReferenceCountUtil.release(msg);, +            throw e;, +        }, +, +++ b/transport/src/main/java/io/netty/channel/AbstractChannelHandlerContext.java, +        ObjectUtil.checkNotNull(msg, "msg");, +        try {, +            if (isNotValidPromise(promise, true)) {, +                ReferenceCountUtil.release(msg);, +                // cancelled, +                return;, +            }, +        } catch (RuntimeException e) {, +            ReferenceCountUtil.release(msg);, +            throw e;, +        }, +, +++ b/transport/src/test/java/io/netty/channel/DefaultChannelPipelineTest.java, +    @Test, +    public void testWriteThrowsReleaseMessage() {, +        testWriteThrowsReleaseMessage0(false);, +    }, +, +    @Test, +    public void testWriteAndFlushThrowsReleaseMessage() {, +        testWriteThrowsReleaseMessage0(true);, +    }, +, +    private void testWriteThrowsReleaseMessage0(boolean flush) {, +        ReferenceCounted referenceCounted = new AbstractReferenceCounted() {, +            @Override, +            protected void deallocate() {, +                // NOOP, +            }, +, +            @Override, +            public ReferenceCounted touch(Object hint) {, +                return this;, +            }, +        };, +        assertEquals(1, referenceCounted.refCnt());, +, +        Channel channel = new LocalChannel();, +        Channel channel2 = new LocalChannel();, +        group.register(channel).syncUninterruptibly();, +        group.register(channel2).syncUninterruptibly();, +, +        try {, +            if (flush) {, +                channel.writeAndFlush(referenceCounted, channel2.newPromise());, +            } else {, +                channel.write(referenceCounted, channel2.newPromise());, +            }, +            fail();, +        } catch (IllegalArgumentException expected) {, +            // expected, +        }, +        assertEquals(0, referenceCounted.refCnt());, +, +        channel.close().syncUninterruptibly();, +        channel2.close().syncUninterruptibly();, +    }, +]