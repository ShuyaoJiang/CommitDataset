[+++ b/transport/src/main/java/io/netty/channel/DefaultChannelHandlerContext.java, +    private static final int FLAG_FREED_INBOUND = 4;, +    private static final int FLAG_FREED_OUTBOUND = 8;, +        flags |= FLAG_FREED;, +        flags |= FLAG_FREED_INBOUND;, +, +        flags |= FLAG_FREED_OUTBOUND;, +, +        if ((flags & FLAG_FREED_INBOUND) != 0) {, +            return;, +        }, +, +                    if (handler instanceof ChannelInboundByteHandler && (flags & FLAG_FREED_INBOUND) == 0) {, +        if ((flags & FLAG_FREED_OUTBOUND) != 0) {, +            promise.setFailure(new ChannelPipelineException(, +                    "Unable to flush as outbound buffer of next handler was freed already"));, +            return;, +        }, +, +        if (!channel.isActive() && !channel.isRegistered()) {, +            if (handler instanceof ChannelOutboundByteHandler && (flags & FLAG_FREED_OUTBOUND) == 0) {, +        if ((flags & FLAG_FREED_OUTBOUND) != 0) {, +++ b/transport/src/main/java/io/netty/channel/DefaultChannelHandlerContext.java, +    private static final int FLAG_FREED_INBOUND = 4;, +    private static final int FLAG_FREED_OUTBOUND = 8;, +        flags |= FLAG_FREED;, +        flags |= FLAG_FREED_INBOUND;, +, +        flags |= FLAG_FREED_OUTBOUND;, +, +        if ((flags & FLAG_FREED_INBOUND) != 0) {, +            return;, +        }, +, +                    if (handler instanceof ChannelInboundByteHandler && (flags & FLAG_FREED_INBOUND) == 0) {, +        if ((flags & FLAG_FREED_OUTBOUND) != 0) {, +            promise.setFailure(new ChannelPipelineException(, +                    "Unable to flush as outbound buffer of next handler was freed already"));, +            return;, +        }, +, +        if (!channel.isActive() && !channel.isRegistered()) {, +            if (handler instanceof ChannelOutboundByteHandler && (flags & FLAG_FREED_OUTBOUND) == 0) {, +        if ((flags & FLAG_FREED_OUTBOUND) != 0) {, +++ b/transport/src/main/java/io/netty/channel/DefaultChannelPipeline.java]