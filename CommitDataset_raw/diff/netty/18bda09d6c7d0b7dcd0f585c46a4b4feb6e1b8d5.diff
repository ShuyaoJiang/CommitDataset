[+++ b/transport/src/main/java/io/netty/bootstrap/ServerBootstrap.java, +import io.netty.channel.ChannelConfig;, +import java.util.concurrent.TimeUnit;, +, +        @Override, +        public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {, +            final ChannelConfig config = ctx.channel().config();, +            if (config.isAutoRead()) {, +                // stop accept new connections for 1 second to allow the channel to recover, +                // See https://github.com/netty/netty/issues/1328, +                config.setAutoRead(false);, +                ctx.channel().eventLoop().schedule(new Runnable() {, +                    @Override, +                    public void run() {, +                       config.setAutoRead(true);, +                    }, +                }, 1, TimeUnit.SECONDS);, +            }, +            // still let the exceptionCaught event flow through the pipeline to give the user, +            // a chance to do something with it, +            ctx.fireExceptionCaught(cause);, +        }, +++ b/transport/src/main/java/io/netty/bootstrap/ServerBootstrap.java, +import io.netty.channel.ChannelConfig;, +import java.util.concurrent.TimeUnit;, +, +        @Override, +        public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {, +            final ChannelConfig config = ctx.channel().config();, +            if (config.isAutoRead()) {, +                // stop accept new connections for 1 second to allow the channel to recover, +                // See https://github.com/netty/netty/issues/1328, +                config.setAutoRead(false);, +                ctx.channel().eventLoop().schedule(new Runnable() {, +                    @Override, +                    public void run() {, +                       config.setAutoRead(true);, +                    }, +                }, 1, TimeUnit.SECONDS);, +            }, +            // still let the exceptionCaught event flow through the pipeline to give the user, +            // a chance to do something with it, +            ctx.fireExceptionCaught(cause);, +        }, +++ b/transport/src/main/java/io/netty/channel/socket/aio/AioServerSocketChannel.java, +                channel.pipeline().fireExceptionCaught(t);, +++ b/transport/src/main/java/io/netty/bootstrap/ServerBootstrap.java, +import io.netty.channel.ChannelConfig;, +import java.util.concurrent.TimeUnit;, +, +        @Override, +        public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {, +            final ChannelConfig config = ctx.channel().config();, +            if (config.isAutoRead()) {, +                // stop accept new connections for 1 second to allow the channel to recover, +                // See https://github.com/netty/netty/issues/1328, +                config.setAutoRead(false);, +                ctx.channel().eventLoop().schedule(new Runnable() {, +                    @Override, +                    public void run() {, +                       config.setAutoRead(true);, +                    }, +                }, 1, TimeUnit.SECONDS);, +            }, +            // still let the exceptionCaught event flow through the pipeline to give the user, +            // a chance to do something with it, +            ctx.fireExceptionCaught(cause);, +        }, +++ b/transport/src/main/java/io/netty/channel/socket/aio/AioServerSocketChannel.java, +                channel.pipeline().fireExceptionCaught(t);, +++ b/transport/src/main/java/io/netty/channel/socket/oio/OioServerSocketChannel.java, +            Socket s = socket.accept();, +            try {, +        } catch (SocketTimeoutException e) {, +            // Expected, +        }]