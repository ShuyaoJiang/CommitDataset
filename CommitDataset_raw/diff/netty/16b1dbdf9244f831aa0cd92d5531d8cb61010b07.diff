[+++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBufAllocator.java, +    static {, +        ResourceLeakDetector.addExclusions(AbstractByteBufAllocator.class, "toLeakAwareBuffer");, +    }, +, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBufAllocator.java, +    static {, +        ResourceLeakDetector.addExclusions(AbstractByteBufAllocator.class, "toLeakAwareBuffer");, +    }, +, +++ b/buffer/src/main/java/io/netty/buffer/AdvancedLeakAwareByteBuf.java, +import io.netty.util.ResourceLeakDetector;, +, +        ResourceLeakDetector.addExclusions(, +                AdvancedLeakAwareByteBuf.class, "touch", "recordLeakNonRefCountingOperation");, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBufAllocator.java, +    static {, +        ResourceLeakDetector.addExclusions(AbstractByteBufAllocator.class, "toLeakAwareBuffer");, +    }, +, +++ b/buffer/src/main/java/io/netty/buffer/AdvancedLeakAwareByteBuf.java, +import io.netty.util.ResourceLeakDetector;, +, +        ResourceLeakDetector.addExclusions(, +                AdvancedLeakAwareByteBuf.class, "touch", "recordLeakNonRefCountingOperation");, +++ b/common/src/main/java/io/netty/util/ReferenceCountUtil.java, +    static {, +        ResourceLeakDetector.addExclusions(ReferenceCountUtil.class, "touch");, +    }, +, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBufAllocator.java, +    static {, +        ResourceLeakDetector.addExclusions(AbstractByteBufAllocator.class, "toLeakAwareBuffer");, +    }, +, +++ b/buffer/src/main/java/io/netty/buffer/AdvancedLeakAwareByteBuf.java, +import io.netty.util.ResourceLeakDetector;, +, +        ResourceLeakDetector.addExclusions(, +                AdvancedLeakAwareByteBuf.class, "touch", "recordLeakNonRefCountingOperation");, +++ b/common/src/main/java/io/netty/util/ReferenceCountUtil.java, +    static {, +        ResourceLeakDetector.addExclusions(ReferenceCountUtil.class, "touch");, +    }, +, +++ b/common/src/main/java/io/netty/util/ResourceLeakDetector.java, +import io.netty.util.internal.EmptyArrays;, +import java.lang.reflect.Method;, +import java.util.Arrays;, +import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;, +import java.util.concurrent.atomic.AtomicReference;, +import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;, +    private static final String PROP_TARGET_RECORDS = "io.netty.leakDetection.targetRecords";, +    private static final int DEFAULT_TARGET_RECORDS = 4;, +    private static final int TARGET_RECORDS;, +        TARGET_RECORDS = SystemPropertyUtil.getInt(PROP_TARGET_RECORDS, DEFAULT_TARGET_RECORDS);, +            logger.debug("-D{}: {}", PROP_TARGET_RECORDS, TARGET_RECORDS);, +    // There is a minor performance benefit in TLR if this is a power of 2., +    private final ConcurrentMap<DefaultResourceLeak<?>, LeakEntry> allLeaks = PlatformDependent.newConcurrentHashMap();, +                return new DefaultResourceLeak(obj, refQueue, allLeaks);, +        return new DefaultResourceLeak(obj, refQueue, allLeaks);, +    private static final class DefaultResourceLeak<T>, +            extends PhantomReference<Object> implements ResourceLeakTracker<T>, ResourceLeak {, +        @SuppressWarnings("unchecked") // generics and updaters do not mix., +        private static final AtomicReferenceFieldUpdater<DefaultResourceLeak<?>, Record> headUpdater =, +                (AtomicReferenceFieldUpdater), +                        AtomicReferenceFieldUpdater.newUpdater(DefaultResourceLeak.class, Record.class, "head");, +        @SuppressWarnings("unchecked") // generics and updaters do not mix., +        private static final AtomicIntegerFieldUpdater<DefaultResourceLeak<?>> droppedRecordsUpdater =, +                (AtomicIntegerFieldUpdater), +                        AtomicIntegerFieldUpdater.newUpdater(DefaultResourceLeak.class, "droppedRecords");, +, +        @SuppressWarnings("unused"), +        private volatile Record head;, +        @SuppressWarnings("unused"), +        private volatile int droppedRecords;, +, +        private final ConcurrentMap<DefaultResourceLeak<?>, LeakEntry> allLeaks;, +        DefaultResourceLeak(, +                Object referent,, +                ReferenceQueue<Object> refQueue,, +                ConcurrentMap<DefaultResourceLeak<?>, LeakEntry> allLeaks) {, +            headUpdater.set(this, Record.BOTTOM);, +            this.allLeaks = allLeaks;, +        /**, +         * This method works by exponentially backing off as more records are present in the stack. Each record has a, +         * 1 / 2^n chance of dropping the top most record and replacing it with itself. This has a number of convenient, +         * properties. First, the first record is always recorded. Second, the very last access will always be, +         * recorded. Third, an arbitrary number of accesses can be accepted, rather than just the last few. Fourth,, +         * it is easy to keep a precise record of the number of elements in the stack, since each element has to know, +         * how tall the stack is., +         *, +         * In this particular implementation, there are also some advantages. A thread local random is used to decide, +         * if something should be recorded. This means that if there is a deterministic access pattern, it is now, +         * possible to see what other accesses occur, rather than always dropping them. Second, there is roughly a, +         * linear ramp up to {@link #TARGET_RECORDS}, after which backoff occurs. This matches typical access patterns,, +         * where there are either a high number of accesses (i.e. a cached buffer), or low (an ephemeral buffer), but, +         * not many in between., +         *, +         * The use of atomics avoids serializing a high number of accesses, when most of the records will be thrown]