[+++ b/common/src/main/java/io/netty/util/concurrent/DefaultPromise.java, +        return setSuccess0(result);, +        return setFailure0(cause);, +            if (checkNotifyWaiters()) {, +            }, +            if (checkNotifyWaiters()) {, +                notifyListeners();, +            }, +    /**, +     * Check if there are any waiters and if so notify these., +     * @return {@code true} if there are any listeners attached to the promise, {@code false} otherwise., +     */, +    private synchronized boolean checkNotifyWaiters() {, +        return listeners != null;, +++ b/common/src/main/java/io/netty/util/concurrent/DefaultPromise.java, +        return setSuccess0(result);, +        return setFailure0(cause);, +            if (checkNotifyWaiters()) {, +            }, +            if (checkNotifyWaiters()) {, +                notifyListeners();, +            }, +    /**, +     * Check if there are any waiters and if so notify these., +     * @return {@code true} if there are any listeners attached to the promise, {@code false} otherwise., +     */, +    private synchronized boolean checkNotifyWaiters() {, +        return listeners != null;, +++ b/common/src/test/java/io/netty/util/concurrent/DefaultPromiseTest.java, +import org.mockito.Mockito;, +    @Test, +    public void testCancelDoesNotScheduleWhenNoListeners() {, +        EventExecutor executor = Mockito.mock(EventExecutor.class);, +        Mockito.when(executor.inEventLoop()).thenReturn(false);, +, +        Promise<Void> promise = new DefaultPromise<Void>(executor);, +        promise.cancel(false);, +        Mockito.verify(executor, Mockito.never()).execute(Mockito.any(Runnable.class));, +        assertTrue(promise.isCancelled());, +    }, +, +    @Test, +    public void testSuccessDoesNotScheduleWhenNoListeners() {, +        EventExecutor executor = Mockito.mock(EventExecutor.class);, +        Mockito.when(executor.inEventLoop()).thenReturn(false);, +, +        Object value = new Object();, +        Promise<Object> promise = new DefaultPromise<Object>(executor);, +        promise.setSuccess(value);, +        Mockito.verify(executor, Mockito.never()).execute(Mockito.any(Runnable.class));, +        assertSame(value, promise.getNow());, +    }, +, +    @Test, +    public void testFailureDoesNotScheduleWhenNoListeners() {, +        EventExecutor executor = Mockito.mock(EventExecutor.class);, +        Mockito.when(executor.inEventLoop()).thenReturn(false);, +, +        Exception cause = new Exception();, +        Promise<Void> promise = new DefaultPromise<Void>(executor);, +        promise.setFailure(cause);, +        Mockito.verify(executor, Mockito.never()).execute(Mockito.any(Runnable.class));, +        assertSame(cause, promise.cause());, +    }, +]