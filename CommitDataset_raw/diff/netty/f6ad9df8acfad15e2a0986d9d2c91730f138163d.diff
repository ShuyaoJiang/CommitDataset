[+++ b/common/src/main/java/io/netty/util/concurrent/DefaultPromise.java, +     *        the {@link EventExecutor} which is used to notify the promise once it is complete., +     *        It is assumed this executor will protect against {@link StackOverflowError} exceptions., +     *        The executor may be used to avoid {@link StackOverflowError} by executing a {@link Runnable} if the stack, +     *        depth exceeds a threshold., +     *, +    /**, +     * See {@link #executor()} for expectations of the executor., +     */, +    /**, +     * Get the executor used to notify listeners when this promise is complete., +     * <p>, +     * It is assumed this executor will protect against {@link StackOverflowError} exceptions., +     * The executor may be used to avoid {@link StackOverflowError} by executing a {@link Runnable} if the stack, +     * depth exceeds a threshold., +     * @return The executor used to notify listeners when this promise is complete., +     */, +        checkNotNull(eventExecutor, "eventExecutor");, +        notifyListenerWithStackOverFlowProtection(eventExecutor, future, listener);, +        EventExecutor executor = executor();, +        if (executor.inEventLoop()) {, +                return;, +, +        safeExecute(executor, new OneTimeTask() {, +            @Override, +            public void run() {, +                notifyListenersNow();, +        });, +     * cannot share code because the listener(s) cannot be cached for an instance of {@link DefaultPromise} since the, +    private static void notifyListenerWithStackOverFlowProtection(final EventExecutor executor,, +                                                                  final Future<?> future,, +                                                                  final GenericFutureListener<?> listener) {, +        if (executor.inEventLoop()) {, +                return;, +, +        safeExecute(executor, new OneTimeTask() {, +            @Override, +            public void run() {, +                notifyListener0(future, listener);, +        });, +++ b/common/src/main/java/io/netty/util/concurrent/DefaultPromise.java, +     *        the {@link EventExecutor} which is used to notify the promise once it is complete., +     *        It is assumed this executor will protect against {@link StackOverflowError} exceptions., +     *        The executor may be used to avoid {@link StackOverflowError} by executing a {@link Runnable} if the stack, +     *        depth exceeds a threshold., +     *, +    /**, +     * See {@link #executor()} for expectations of the executor., +     */, +    /**, +     * Get the executor used to notify listeners when this promise is complete., +     * <p>, +     * It is assumed this executor will protect against {@link StackOverflowError} exceptions., +     * The executor may be used to avoid {@link StackOverflowError} by executing a {@link Runnable} if the stack, +     * depth exceeds a threshold., +     * @return The executor used to notify listeners when this promise is complete., +     */, +        checkNotNull(eventExecutor, "eventExecutor");, +        notifyListenerWithStackOverFlowProtection(eventExecutor, future, listener);, +        EventExecutor executor = executor();, +        if (executor.inEventLoop()) {, +                return;, +, +        safeExecute(executor, new OneTimeTask() {, +            @Override, +            public void run() {, +                notifyListenersNow();, +        });, +     * cannot share code because the listener(s) cannot be cached for an instance of {@link DefaultPromise} since the, +    private static void notifyListenerWithStackOverFlowProtection(final EventExecutor executor,, +                                                                  final Future<?> future,, +                                                                  final GenericFutureListener<?> listener) {, +        if (executor.inEventLoop()) {, +                return;, +, +        safeExecute(executor, new OneTimeTask() {, +            @Override, +            public void run() {, +                notifyListener0(future, listener);, +        });, +++ b/common/src/main/java/io/netty/util/concurrent/ImmediateEventExecutor.java, +import io.netty.util.internal.logging.InternalLogger;, +import io.netty.util.internal.logging.InternalLoggerFactory;, +, +import java.util.ArrayDeque;, +import java.util.Queue;, + * Executes {@link Runnable} objects in the caller's thread. If the {@link #execute(Runnable)} is reentrant it will be, + * queued until the original {@link Runnable} finishes execution., + * <p>, + * All {@link Throwable} objects thrown from {@link #execute(Runnable)} will be swallowed and logged. This is to ensure, + * that all queued {@link Runnable} objects have the chance to be run., +    private static final InternalLogger logger = InternalLoggerFactory.getInstance(ImmediateEventExecutor.class);, +    /**, +     * A Runnable will be queued if we are executing a Runnable. This is to prevent a {@link StackOverflowError}., +     */, +    private static final FastThreadLocal<Queue<Runnable>> DELAYED_RUNNABLES = new FastThreadLocal<Queue<Runnable>>() {, +        @Override, +        protected Queue<Runnable> initialValue() throws Exception {, +            return new ArrayDeque<Runnable>();, +        }]