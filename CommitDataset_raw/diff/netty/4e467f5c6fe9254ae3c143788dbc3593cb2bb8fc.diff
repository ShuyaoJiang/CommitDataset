[+++ b/buffer/src/main/java/io/netty/buffer/UnsafeByteBufUtil.java, +import java.nio.ReadOnlyBufferException;, +            if (dst.isReadOnly()) {, +                // We need to check if dst is ready-only so we not write something in it by using Unsafe., +                throw new ReadOnlyBufferException();, +            }, +            dst.position(dst.position() + bytesToCopy);, +        } else if (dst.hasArray()) {, +        } else  {, +            dst.put(buf.nioBuffer());, +        }, +++ b/buffer/src/main/java/io/netty/buffer/UnsafeByteBufUtil.java, +import java.nio.ReadOnlyBufferException;, +            if (dst.isReadOnly()) {, +                // We need to check if dst is ready-only so we not write something in it by using Unsafe., +                throw new ReadOnlyBufferException();, +            }, +            dst.position(dst.position() + bytesToCopy);, +        } else if (dst.hasArray()) {, +        } else  {, +            dst.put(buf.nioBuffer());, +        }, +++ b/buffer/src/test/java/io/netty/buffer/AbstractByteBufTest.java, +import java.nio.ReadOnlyBufferException;, +    @Test, +    public void testGetReadOnlyDirectDst() {, +        testGetReadOnlyDst(true);, +    }, +, +    @Test, +    public void testGetReadOnlyHeapDst() {, +        testGetReadOnlyDst(false);, +    }, +, +    private void testGetReadOnlyDst(boolean direct) {, +        byte[] bytes = { 'a', 'b', 'c', 'd' };, +, +        ByteBuf buffer = releaseLater(newBuffer(bytes.length));, +        buffer.writeBytes(bytes);, +, +        ByteBuffer dst = direct ? ByteBuffer.allocateDirect(bytes.length) : ByteBuffer.allocate(bytes.length);, +        ByteBuffer readOnlyDst = dst.asReadOnlyBuffer();, +        try {, +            buffer.getBytes(0, readOnlyDst);, +            fail();, +        } catch (ReadOnlyBufferException e) {, +            // expected, +        }, +        assertEquals(0, readOnlyDst.position());, +    }, +, +++ b/buffer/src/main/java/io/netty/buffer/UnsafeByteBufUtil.java, +import java.nio.ReadOnlyBufferException;, +            if (dst.isReadOnly()) {, +                // We need to check if dst is ready-only so we not write something in it by using Unsafe., +                throw new ReadOnlyBufferException();, +            }, +            dst.position(dst.position() + bytesToCopy);, +        } else if (dst.hasArray()) {, +        } else  {, +            dst.put(buf.nioBuffer());, +        }, +++ b/buffer/src/test/java/io/netty/buffer/AbstractByteBufTest.java, +import java.nio.ReadOnlyBufferException;, +    @Test, +    public void testGetReadOnlyDirectDst() {, +        testGetReadOnlyDst(true);, +    }, +, +    @Test, +    public void testGetReadOnlyHeapDst() {, +        testGetReadOnlyDst(false);, +    }, +, +    private void testGetReadOnlyDst(boolean direct) {, +        byte[] bytes = { 'a', 'b', 'c', 'd' };, +, +        ByteBuf buffer = releaseLater(newBuffer(bytes.length));, +        buffer.writeBytes(bytes);, +, +        ByteBuffer dst = direct ? ByteBuffer.allocateDirect(bytes.length) : ByteBuffer.allocate(bytes.length);, +        ByteBuffer readOnlyDst = dst.asReadOnlyBuffer();, +        try {, +            buffer.getBytes(0, readOnlyDst);, +            fail();, +        } catch (ReadOnlyBufferException e) {, +            // expected, +        }, +        assertEquals(0, readOnlyDst.position());, +    }, +, +++ b/buffer/src/test/java/io/netty/buffer/SlicedByteBufTest.java, +    @Test(expected = IndexOutOfBoundsException.class), +    @Override, +    public void testGetReadOnlyDirectDst() {, +        super.testGetReadOnlyDirectDst();, +    }, +, +    @Test(expected = IndexOutOfBoundsException.class), +    @Override]