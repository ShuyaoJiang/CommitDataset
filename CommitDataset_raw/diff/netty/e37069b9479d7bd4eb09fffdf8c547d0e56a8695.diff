[+++ b/transport/src/main/java/io/netty/channel/local/LocalChannel.java, +    private volatile boolean writeInProgress;, +            peer.eventLoop().execute(new OneTimeTask() {, +        final LocalChannel peer = this.peer;, +            // To preserve ordering of events we must process any pending reads, +            if (writeInProgress && peer != null) {, +                finishPeerRead(peer);, +            }, +            // Need to execute the close in the correct EventLoop (see https://github.com/netty/netty/issues/1777)., +            // to make sure its run after the registration completes (see https://github.com/netty/netty/issues/2144)., +            if (peer.eventLoop().inEventLoop() && !registerInProgress) {, +                doPeerClose(peer, peer.writeInProgress);, +                // This value may change, and so we should save it before executing the Runnable., +                final boolean peerWriteInProgress = peer.writeInProgress;, +                peer.eventLoop().execute(new OneTimeTask() {, +                        doPeerClose(peer, peerWriteInProgress);, +    private void doPeerClose(LocalChannel peer, boolean peerWriteInProgress) {, +        if (peerWriteInProgress) {, +            finishPeerRead0(this);, +        }, +        peer.unsafe().close(peer.unsafe().voidPromise());, +    }, +, +        writeInProgress = true;, +        try {, +        } finally {, +            // The following situation may cause trouble:, +            // 1. Write (with promise X), +            // 2. promise X is completed when in.remove() is called, and a listener on this promise calls close(), +            // 3. Then the close event will be executed for the peer before the write events, when the write events, +            // actually happened before the close event., +            writeInProgress = false;, +        }, +        finishPeerRead(peer);, +    }, +, +    private void finishPeerRead(final LocalChannel peer) {, +        // If the peer is also writing, then we must schedule the event on the event loop to preserve read order., +        if (peer.eventLoop() == eventLoop() && !peer.writeInProgress) {, +            finishPeerRead0(peer);, +            peer.eventLoop().execute(new OneTimeTask() {, +                    finishPeerRead0(peer);, +    private static void finishPeerRead0(LocalChannel peer) {, +        ChannelPipeline peerPipeline = peer.pipeline();, +++ b/transport/src/main/java/io/netty/channel/local/LocalChannel.java, +    private volatile boolean writeInProgress;, +            peer.eventLoop().execute(new OneTimeTask() {, +        final LocalChannel peer = this.peer;, +            // To preserve ordering of events we must process any pending reads, +            if (writeInProgress && peer != null) {, +                finishPeerRead(peer);, +            }, +            // Need to execute the close in the correct EventLoop (see https://github.com/netty/netty/issues/1777)., +            // to make sure its run after the registration completes (see https://github.com/netty/netty/issues/2144)., +            if (peer.eventLoop().inEventLoop() && !registerInProgress) {, +                doPeerClose(peer, peer.writeInProgress);, +                // This value may change, and so we should save it before executing the Runnable., +                final boolean peerWriteInProgress = peer.writeInProgress;, +                peer.eventLoop().execute(new OneTimeTask() {, +                        doPeerClose(peer, peerWriteInProgress);, +    private void doPeerClose(LocalChannel peer, boolean peerWriteInProgress) {, +        if (peerWriteInProgress) {, +            finishPeerRead0(this);, +        }, +        peer.unsafe().close(peer.unsafe().voidPromise());, +    }, +, +        writeInProgress = true;, +        try {, +        } finally {, +            // The following situation may cause trouble:, +            // 1. Write (with promise X), +            // 2. promise X is completed when in.remove() is called, and a listener on this promise calls close(), +            // 3. Then the close event will be executed for the peer before the write events, when the write events, +            // actually happened before the close event., +            writeInProgress = false;, +        }, +        finishPeerRead(peer);, +    }, +, +    private void finishPeerRead(final LocalChannel peer) {, +        // If the peer is also writing, then we must schedule the event on the event loop to preserve read order., +        if (peer.eventLoop() == eventLoop() && !peer.writeInProgress) {, +            finishPeerRead0(peer);, +            peer.eventLoop().execute(new OneTimeTask() {, +                    finishPeerRead0(peer);, +    private static void finishPeerRead0(LocalChannel peer) {, +        ChannelPipeline peerPipeline = peer.pipeline();, +++ b/transport/src/test/java/io/netty/channel/local/LocalChannelTest.java, +import io.netty.buffer.ByteBuf;, +import io.netty.buffer.Unpooled;, +import io.netty.channel.ChannelFutureListener;, +import io.netty.channel.ChannelPromise;, +import io.netty.util.ReferenceCountUtil;, +import io.netty.util.concurrent.Future;, +import io.netty.util.internal.OneTimeTask;, +import org.junit.AfterClass;, +import org.junit.BeforeClass;, +import java.util.concurrent.atomic.AtomicReference;, +import static java.util.concurrent.TimeUnit.SECONDS;]