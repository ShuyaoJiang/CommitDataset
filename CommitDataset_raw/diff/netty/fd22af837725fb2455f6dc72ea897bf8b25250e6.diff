[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2CodecUtil.java, +import io.netty.buffer.ByteBufUtil;, +        // Create the debug message. `* 3` because UTF-8 max character consumes 3 bytes., +        ByteBuf debugData = ctx.alloc().buffer(cause.getMessage().length() * 3);, +        ByteBufUtil.writeUtf8(debugData, cause.getMessage());, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2CodecUtil.java, +import io.netty.buffer.ByteBufUtil;, +        // Create the debug message. `* 3` because UTF-8 max character consumes 3 bytes., +        ByteBuf debugData = ctx.alloc().buffer(cause.getMessage().length() * 3);, +        ByteBufUtil.writeUtf8(debugData, cause.getMessage());, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2ConnectionHandler.java, +            // Need to retain before we write the buffer because if we do it after the refCnt could already be 0 and, +            // result in an IllegalRefCountException., +            debugData.retain();, +            if (future.isDone()) {, +                processGoAwayWriteResult(ctx, lastStreamId, errorCode, debugData, future);, +            } else {, +                future.addListener(new ChannelFutureListener() {, +                        processGoAwayWriteResult(ctx, lastStreamId, errorCode, debugData, future);, +                    }, +                });, +            }, +, +            return future;, +        } catch (Throwable cause) { // Make sure to catch Throwable because we are doing a retain() in this method., +            debugData.release();, +            return promise.setFailure(cause);, +        }, +    }, +, +    /**, +     * Close the remote endpoint with with a {@code GO_AWAY} frame. Does <strong>not</strong> flush, +     * immediately, this is the responsibility of the caller., +     */, +    private ChannelFuture goAway(ChannelHandlerContext ctx, Http2Exception cause) {, +        long errorCode = cause != null ? cause.error().code() : NO_ERROR.code();, +        ByteBuf debugData = Http2CodecUtil.toByteBuf(ctx, cause);, +        int lastKnownStream = connection().remote().lastStreamCreated();, +        return goAway(ctx, lastKnownStream, errorCode, debugData, ctx.newPromise());, +    }, +, +    /**, +     * Returns the client preface string if this is a client connection, otherwise returns {@code null}., +     */, +    private static ByteBuf clientPrefaceString(Http2Connection connection) {, +        return connection.isServer() ? connectionPrefaceBuf() : null;, +    }, +, +    private static void processGoAwayWriteResult(final ChannelHandlerContext ctx, final int lastStreamId,, +            final long errorCode, final ByteBuf debugData, ChannelFuture future) {, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2CodecUtil.java, +import io.netty.buffer.ByteBufUtil;, +        // Create the debug message. `* 3` because UTF-8 max character consumes 3 bytes., +        ByteBuf debugData = ctx.alloc().buffer(cause.getMessage().length() * 3);, +        ByteBufUtil.writeUtf8(debugData, cause.getMessage());, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2ConnectionHandler.java, +            // Need to retain before we write the buffer because if we do it after the refCnt could already be 0 and, +            // result in an IllegalRefCountException., +            debugData.retain();, +            if (future.isDone()) {, +                processGoAwayWriteResult(ctx, lastStreamId, errorCode, debugData, future);, +            } else {, +                future.addListener(new ChannelFutureListener() {, +                        processGoAwayWriteResult(ctx, lastStreamId, errorCode, debugData, future);, +                    }, +                });, +            }, +, +            return future;, +        } catch (Throwable cause) { // Make sure to catch Throwable because we are doing a retain() in this method., +            debugData.release();, +            return promise.setFailure(cause);, +        }, +    }, +, +    /**, +     * Close the remote endpoint with with a {@code GO_AWAY} frame. Does <strong>not</strong> flush, +     * immediately, this is the responsibility of the caller., +     */, +    private ChannelFuture goAway(ChannelHandlerContext ctx, Http2Exception cause) {, +        long errorCode = cause != null ? cause.error().code() : NO_ERROR.code();, +        ByteBuf debugData = Http2CodecUtil.toByteBuf(ctx, cause);, +        int lastKnownStream = connection().remote().lastStreamCreated();, +        return goAway(ctx, lastKnownStream, errorCode, debugData, ctx.newPromise());, +    }, +, +    /**, +     * Returns the client preface string if this is a client connection, otherwise returns {@code null}., +     */, +    private static ByteBuf clientPrefaceString(Http2Connection connection) {, +        return connection.isServer() ? connectionPrefaceBuf() : null;, +    }, +, +    private static void processGoAwayWriteResult(final ChannelHandlerContext ctx, final int lastStreamId,, +            final long errorCode, final ByteBuf debugData, ChannelFuture future) {, +++ b/codec-http2/src/test/java/io/netty/handler/codec/http2/Http2ConnectionHandlerTest.java, +import static org.junit.Assert.assertEquals;, +import static org.junit.Assert.assertNull;, +import io.netty.channel.ChannelFutureListener;, +import io.netty.util.CharsetUtil;]