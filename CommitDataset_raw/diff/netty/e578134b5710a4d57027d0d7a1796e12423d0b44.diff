[+++ b/buffer/src/main/java/io/netty/buffer/Unpooled.java, +     * @param buffer The buffer to wrap. Reference count ownership of this variable is transfered to this method., +     * @return The readable portion of the {@code buffer}, or an empty buffer if there is no readable portion., +     * The caller is responsible for releasing this buffer., +            buffer.release();, +     * @param buffers The buffers to wrap. Reference count ownership of all variables is transfered to this method., +     * @return The readable portion of the {@code buffers}. The caller is responsible for releasing this buffer., +     * @param maxNumComponents Advisement as to how many independent buffers are allowed to exist before, +     * consolidation occurs., +     * @param buffers The buffers to wrap. Reference count ownership of all variables is transfered to this method., +     * @return The readable portion of the {@code buffers}. The caller is responsible for releasing this buffer., +            ByteBuf buffer = buffers[0];, +            if (buffer.isReadable()) {, +                return wrappedBuffer(buffer.order(BIG_ENDIAN));, +            } else {, +                buffer.release();, +                } else {, +                    b.release();, +++ b/buffer/src/main/java/io/netty/buffer/Unpooled.java, +     * @param buffer The buffer to wrap. Reference count ownership of this variable is transfered to this method., +     * @return The readable portion of the {@code buffer}, or an empty buffer if there is no readable portion., +     * The caller is responsible for releasing this buffer., +            buffer.release();, +     * @param buffers The buffers to wrap. Reference count ownership of all variables is transfered to this method., +     * @return The readable portion of the {@code buffers}. The caller is responsible for releasing this buffer., +     * @param maxNumComponents Advisement as to how many independent buffers are allowed to exist before, +     * consolidation occurs., +     * @param buffers The buffers to wrap. Reference count ownership of all variables is transfered to this method., +     * @return The readable portion of the {@code buffers}. The caller is responsible for releasing this buffer., +            ByteBuf buffer = buffers[0];, +            if (buffer.isReadable()) {, +                return wrappedBuffer(buffer.order(BIG_ENDIAN));, +            } else {, +                buffer.release();, +                } else {, +                    b.release();, +++ b/buffer/src/test/java/io/netty/buffer/UnpooledTest.java, +    public void testSingleWrappedByteBufReleased() {, +        ByteBuf buf = buffer(12).writeByte(0);, +        ByteBuf wrapped = wrappedBuffer(buf);, +        assertTrue(wrapped.release());, +        assertEquals(0, buf.refCnt());, +    }, +, +    @Test, +    public void testSingleUnReadableWrappedByteBufReleased() {, +        ByteBuf buf = buffer(12);, +        ByteBuf wrapped = wrappedBuffer(buf);, +        assertFalse(wrapped.release()); // EMPTY_BUFFER cannot be released, +        assertEquals(0, buf.refCnt());, +    }, +, +    @Test, +    public void testMultiByteBufReleased() {, +        ByteBuf buf1 = buffer(12).writeByte(0);, +        ByteBuf buf2 = buffer(12).writeByte(0);, +        ByteBuf wrapped = wrappedBuffer(16, buf1, buf2);, +        assertTrue(wrapped.release());, +        assertEquals(0, buf1.refCnt());, +        assertEquals(0, buf2.refCnt());, +    }, +, +    @Test, +    public void testMultiUnReadableByteBufReleased() {, +        ByteBuf buf1 = buffer(12);, +        ByteBuf buf2 = buffer(12);, +        ByteBuf wrapped = wrappedBuffer(16, buf1, buf2);, +        assertFalse(wrapped.release()); // EMPTY_BUFFER cannot be released, +        assertEquals(0, buf1.refCnt());, +        assertEquals(0, buf2.refCnt());, +    }, +, +    @Test, +++ b/buffer/src/main/java/io/netty/buffer/Unpooled.java, +     * @param buffer The buffer to wrap. Reference count ownership of this variable is transfered to this method., +     * @return The readable portion of the {@code buffer}, or an empty buffer if there is no readable portion., +     * The caller is responsible for releasing this buffer., +            buffer.release();, +     * @param buffers The buffers to wrap. Reference count ownership of all variables is transfered to this method., +     * @return The readable portion of the {@code buffers}. The caller is responsible for releasing this buffer., +     * @param maxNumComponents Advisement as to how many independent buffers are allowed to exist before, +     * consolidation occurs., +     * @param buffers The buffers to wrap. Reference count ownership of all variables is transfered to this method., +     * @return The readable portion of the {@code buffers}. The caller is responsible for releasing this buffer., +            ByteBuf buffer = buffers[0];, +            if (buffer.isReadable()) {, +                return wrappedBuffer(buffer.order(BIG_ENDIAN));, +            } else {, +                buffer.release();, +                } else {, +                    b.release();, +++ b/buffer/src/test/java/io/netty/buffer/UnpooledTest.java, +    public void testSingleWrappedByteBufReleased() {, +        ByteBuf buf = buffer(12).writeByte(0);, +        ByteBuf wrapped = wrappedBuffer(buf);, +        assertTrue(wrapped.release());, +        assertEquals(0, buf.refCnt());, +    }, +, +    @Test]