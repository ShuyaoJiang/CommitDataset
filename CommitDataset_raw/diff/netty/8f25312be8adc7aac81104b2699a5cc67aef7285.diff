[+++ b/src/docbook/en-US/module/start.xml, +        time.writeInt((int) (System.currentTimeMillis() / 1000));, +++ b/src/docbook/en-US/module/start.xml, +        time.writeInt((int) (System.currentTimeMillis() / 1000));, +++ b/src/main/java/org/jboss/netty/buffer/ChannelBuffers.java, +            short va = bufferA.getUnsignedByte(aIndex);, +            short vb = bufferB.getUnsignedByte(bIndex);, +++ b/src/docbook/en-US/module/start.xml, +        time.writeInt((int) (System.currentTimeMillis() / 1000));, +++ b/src/main/java/org/jboss/netty/buffer/ChannelBuffers.java, +            short va = bufferA.getUnsignedByte(aIndex);, +            short vb = bufferB.getUnsignedByte(bIndex);, +++ b/src/main/java/org/jboss/netty/channel/AbstractChannel.java, +        // Deallocate the current channel's ID from allChannels so that other, +        // new channels can use it., +        allChannels.remove(id);, +, +++ b/src/docbook/en-US/module/start.xml, +        time.writeInt((int) (System.currentTimeMillis() / 1000));, +++ b/src/main/java/org/jboss/netty/buffer/ChannelBuffers.java, +            short va = bufferA.getUnsignedByte(aIndex);, +            short vb = bufferB.getUnsignedByte(bIndex);, +++ b/src/main/java/org/jboss/netty/channel/AbstractChannel.java, +        // Deallocate the current channel's ID from allChannels so that other, +        // new channels can use it., +        allChannels.remove(id);, +, +++ b/src/main/java/org/jboss/netty/channel/ChannelHandlerContext.java, + *                 {@link Channels}.succeededFuture(<b>this.ctx</t>.getChannel()</b>),, +++ b/src/docbook/en-US/module/start.xml, +        time.writeInt((int) (System.currentTimeMillis() / 1000));, +++ b/src/main/java/org/jboss/netty/buffer/ChannelBuffers.java, +            short va = bufferA.getUnsignedByte(aIndex);, +            short vb = bufferB.getUnsignedByte(bIndex);, +++ b/src/main/java/org/jboss/netty/channel/AbstractChannel.java, +        // Deallocate the current channel's ID from allChannels so that other, +        // new channels can use it., +        allChannels.remove(id);, +, +++ b/src/main/java/org/jboss/netty/channel/ChannelHandlerContext.java, + *                 {@link Channels}.succeededFuture(<b>this.ctx</t>.getChannel()</b>),, +++ b/src/main/java/org/jboss/netty/channel/ChannelPipeline.java, +import java.util.List;, +     * Returns the {@link List} of the handler names., +     */, +    List<String> getNames();, +, +    /**, +++ b/src/docbook/en-US/module/start.xml, +        time.writeInt((int) (System.currentTimeMillis() / 1000));, +++ b/src/main/java/org/jboss/netty/buffer/ChannelBuffers.java, +            short va = bufferA.getUnsignedByte(aIndex);, +            short vb = bufferB.getUnsignedByte(bIndex);, +++ b/src/main/java/org/jboss/netty/channel/AbstractChannel.java, +        // Deallocate the current channel's ID from allChannels so that other, +        // new channels can use it., +        allChannels.remove(id);, +, +++ b/src/main/java/org/jboss/netty/channel/ChannelHandlerContext.java, + *                 {@link Channels}.succeededFuture(<b>this.ctx</t>.getChannel()</b>),, +++ b/src/main/java/org/jboss/netty/channel/ChannelPipeline.java, +import java.util.List;, +     * Returns the {@link List} of the handler names., +     */, +    List<String> getNames();, +, +    /**, +++ b/src/main/java/org/jboss/netty/channel/DefaultChannelPipeline.java, +import java.util.ArrayList;, +import java.util.List;, +    public List<String> getNames() {, +        List<String> list = new ArrayList<String>();, +        if (name2ctx.isEmpty()) {, +            return list;, +        }, +, +        DefaultChannelHandlerContext ctx = head;, +        for (;;) {, +            list.add(ctx.getName());, +            ctx = ctx.next;, +            if (ctx == null) {, +                break;, +            }, +        }, +        return list;, +    }, +, +    @Override, +        if (e instanceof UpstreamMessageEvent) {, +            throw new IllegalArgumentException("cannot send an upstream event to downstream");, +        }, +        , +            // Unlike an upstream event, a downstream event usually has an, +            // incomplete future which is supposed to be updated by ChannelSink., +            // However, if an exception is raised before the event reaches at, +            // ChannelSink, the future is not going to be updated, so we update, +            // here., +            e.getFuture().setFailure(t);, +++ b/src/docbook/en-US/module/start.xml, +        time.writeInt((int) (System.currentTimeMillis() / 1000));]