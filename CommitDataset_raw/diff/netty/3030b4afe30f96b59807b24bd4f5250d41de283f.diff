[+++ b/transport-native-epoll/src/main/c/io_netty_channel_epoll_Native.c, +JNIEXPORT jint JNICALL Java_io_netty_channel_epoll_Native_recvFd0(JNIEnv* env, jclass clazz, jint fd) {, +    int socketFd;, +    struct msghdr descriptorMessage = { 0 };, +    struct iovec iov[1] = { 0 };, +    char control[CMSG_SPACE(sizeof(int))] = { 0 };, +    char iovecData[1];, +    descriptorMessage.msg_control = control;, +    descriptorMessage.msg_controllen = sizeof(control);, +    descriptorMessage.msg_iov = iov;, +    descriptorMessage.msg_iovlen = 1;, +    iov[0].iov_base = iovecData;, +    iov[0].iov_len = sizeof(iovecData);, +    ssize_t res;, +    int err;, +    for (;;) {, +        do {, +            res = recvmsg(fd, &descriptorMessage, 0);, +            // Keep on reading if we was interrupted, +        } while (res == -1 && ((err = errno) == EINTR));, +        if (res == 0) {, +            return 0;, +        if (res < 0) {, +            return -err;, +        struct cmsghdr* cmsg = CMSG_FIRSTHDR(&descriptorMessage);, +        if (!cmsg) {, +            return -errno;, +        }, +, +        if ((cmsg->cmsg_len == CMSG_LEN(sizeof(int))) && (cmsg->cmsg_level == SOL_SOCKET) && (cmsg->cmsg_type == SCM_RIGHTS)) {, +            socketFd = *((int *) CMSG_DATA(cmsg));, +                err = errno;, +                close(socketFd);, +                return -err;, +}, +, +JNIEXPORT jint JNICALL Java_io_netty_channel_epoll_Native_sendFd0(JNIEnv* env, jclass clazz, jint socketFd, jint fd) {, +    struct msghdr descriptorMessage = { 0 };, +    struct iovec iov[1] = { 0 };, +    char control[CMSG_SPACE(sizeof(int))] = { 0 };, +    char iovecData[1];, +, +    descriptorMessage.msg_control = control;, +    descriptorMessage.msg_controllen = sizeof(control);, +    struct cmsghdr* cmsg = CMSG_FIRSTHDR(&descriptorMessage);, +, +    if (cmsg) {, +        cmsg->cmsg_len = CMSG_LEN(sizeof(int));, +        cmsg->cmsg_level = SOL_SOCKET;, +        cmsg->cmsg_type = SCM_RIGHTS;, +        *((int *)CMSG_DATA(cmsg)) = fd;, +        descriptorMessage.msg_iov = iov;, +        descriptorMessage.msg_iovlen = 1;, +        iov[0].iov_base = iovecData;, +        iov[0].iov_len = sizeof(iovecData);, +, +        size_t res;, +        int err;, +        do {, +            res = sendmsg(socketFd, &descriptorMessage, 0);, +        // keep on writing if it was interrupted, +        } while (res == -1 && ((err = errno) == EINTR));, +, +        if (res < 0) {, +            return -err;, +        }, +        return (jint) res;, +    }, +, +++ b/transport-native-epoll/src/main/c/io_netty_channel_epoll_Native.c, +JNIEXPORT jint JNICALL Java_io_netty_channel_epoll_Native_recvFd0(JNIEnv* env, jclass clazz, jint fd) {, +    int socketFd;, +    struct msghdr descriptorMessage = { 0 };, +    struct iovec iov[1] = { 0 };, +    char control[CMSG_SPACE(sizeof(int))] = { 0 };, +    char iovecData[1];, +    descriptorMessage.msg_control = control;, +    descriptorMessage.msg_controllen = sizeof(control);, +    descriptorMessage.msg_iov = iov;, +    descriptorMessage.msg_iovlen = 1;, +    iov[0].iov_base = iovecData;, +    iov[0].iov_len = sizeof(iovecData);, +    ssize_t res;, +    int err;, +    for (;;) {, +        do {, +            res = recvmsg(fd, &descriptorMessage, 0);, +            // Keep on reading if we was interrupted, +        } while (res == -1 && ((err = errno) == EINTR));, +        if (res == 0) {, +            return 0;, +        if (res < 0) {, +            return -err;, +        struct cmsghdr* cmsg = CMSG_FIRSTHDR(&descriptorMessage);, +        if (!cmsg) {, +            return -errno;, +        }, +, +        if ((cmsg->cmsg_len == CMSG_LEN(sizeof(int))) && (cmsg->cmsg_level == SOL_SOCKET) && (cmsg->cmsg_type == SCM_RIGHTS)) {, +            socketFd = *((int *) CMSG_DATA(cmsg));]