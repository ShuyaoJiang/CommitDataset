[+++ b/common/src/main/java/io/netty/util/NetUtil.java, +            return validIpV4ToBytes(ipAddressString);, +    /**, +     * Convert ASCII hexadecimal character to the {@code int} value., +     * Unlike {@link Character#digit(char, int)}, returns {@code 0} if character is not a HEX-represented., +     */, +        if (c >= '0' && c <= '9') {, +            return c - '0';, +        }, +        if (c >= 'A' && c <= 'F') {, +            // 0xA - a start value in sequence 'A'..'F', +            return c - 'A' + 0xA;, +        }, +        if (c >= 'a' && c <= 'f') {, +            // 0xA - a start value in sequence 'a'..'f', +            return c - 'a' + 0xA;, +        }, +    private static int decimalDigit(String str, int pos) {, +        return str.charAt(pos) - '0';, +, +    private static byte ipv4WordToByte(String ip, int from, int toExclusive) {, +        int ret = decimalDigit(ip, from);, +        from++;, +        if (from == toExclusive) {, +            return (byte) ret;, +        }, +        ret = ret * 10 + decimalDigit(ip, from);, +        from++;, +        if (from == toExclusive) {, +            return (byte) ret;, +        }, +        return (byte) (ret * 10 + decimalDigit(ip, from));, +    }, +, +    // visible for tests, +    static byte[] validIpV4ToBytes(String ip) {, +        int i;, +        return new byte[] {, +                ipv4WordToByte(ip, 0, i = ip.indexOf('.', 1)),, +                ipv4WordToByte(ip, i + 1, i = ip.indexOf('.', i + 2)),, +                ipv4WordToByte(ip, i + 1, i = ip.indexOf('.', i + 2)),, +                ipv4WordToByte(ip, i + 1, ip.length()), +        };, +    public static boolean isValidIpV6Address(String ip) {, +        int end = ip.length();, +        if (end < 2) {, +        // strip "[]", +        int start;, +        char c = ip.charAt(0);, +        if (c == '[') {, +            end--;, +            if (ip.charAt(end) != ']') {, +                // must have a close ], +                return false;, +            }, +            start = 1;, +            c = ip.charAt(1);, +        } else {, +            start = 0;, +        int colons;, +        int compressBegin;, +        if (c == ':') {, +            // an IPv6 address can start with "::" or with a number, +            if (ip.charAt(start + 1) != ':') {, +                return false;, +            }, +            colons = 2;, +            compressBegin = start;, +            start += 2;, +        } else {, +            colons = 0;, +            compressBegin = -1;, +        int wordLen = 0;, +        loop:, +        for (int i = start; i < end; i++) {, +            c = ip.charAt(i);, +            if (isValidHexChar(c)) {, +                if (wordLen < 4) {, +                    wordLen++;, +                    continue;, +                }, +                return false;, +            case ':':, +                if (colons > 7) {, +                }, +                if (ip.charAt(i - 1) == ':') {, +                    if (compressBegin >= 0) {, +                        return false;, +                    }, +                    compressBegin = i - 1;, +                } else {, +                    wordLen = 0;, +                }, +                colons++;, +                break;, +            case '.':, +                // case for the last 32-bits represented as IPv4 x:x:x:x:x:x:d.d.d.d, +, +                // check a normal case (6 single colons), +                if (compressBegin < 0 && colons != 6 ||]