[+++ b/common/src/main/java/io/netty/util/AttributeMap.java, +, +    /**, +     * Returns {@code} true if and only if the given {@link Attribute} exists in this {@link AttributeMap}., +     */, +    <T> boolean hasAttr(AttributeKey<T> key);, +++ b/common/src/main/java/io/netty/util/AttributeMap.java, +, +    /**, +     * Returns {@code} true if and only if the given {@link Attribute} exists in this {@link AttributeMap}., +     */, +    <T> boolean hasAttr(AttributeKey<T> key);, +++ b/common/src/main/java/io/netty/util/DefaultAttributeMap.java, +import java.util.concurrent.atomic.AtomicReferenceArray;, + * Default {@link AttributeMap} implementation which use simple synchronization per bucket to keep the memory overhead, +    private static final AtomicReferenceFieldUpdater<DefaultAttributeMap, AtomicReferenceArray> updater;, +        AtomicReferenceFieldUpdater<DefaultAttributeMap, AtomicReferenceArray> referenceFieldUpdater =, +                PlatformDependent.newAtomicReferenceFieldUpdater(DefaultAttributeMap.class, "attributes");, +            referenceFieldUpdater = AtomicReferenceFieldUpdater, +                            .newUpdater(DefaultAttributeMap.class, AtomicReferenceArray.class, "attributes");, +    private static final int BUCKET_SIZE = 4;, +    private static final int MASK = BUCKET_SIZE  - 1;, +, +    private volatile AtomicReferenceArray<DefaultAttribute<?>> attributes;, +    @SuppressWarnings({ "unchecked", "rawtypes" }), +        if (key == null) {, +            throw new NullPointerException("key");, +        }, +        AtomicReferenceArray<DefaultAttribute<?>> attributes = this.attributes;, +        if (attributes == null) {, +            attributes = new AtomicReferenceArray<DefaultAttribute<?>>(BUCKET_SIZE);, +, +            if (!updater.compareAndSet(this, null, attributes)) {, +                attributes = this.attributes;, +        int i = index(key);, +        DefaultAttribute<?> head = attributes.get(i);, +        if (head == null) {, +            // No head exists yet which means we may be able to add the attribute without synchronization and just, +            // use compare and set. At worst we need to fallback to synchronization, +            head = new DefaultAttribute(key);, +            if (attributes.compareAndSet(i, null, head)) {, +                // we were able to add it so return the head right away, +                return (Attribute<T>) head;, +            } else {, +                head = attributes.get(i);, +        synchronized (head) {, +            DefaultAttribute<?> curr = head;, +            for (;;) {, +                if (!curr.removed && curr.key == key) {, +                    return (Attribute<T>) curr;, +                }, +, +                DefaultAttribute<?> next = curr.next;, +                if (next == null) {, +                    DefaultAttribute<T> attr = new DefaultAttribute<T>(head, key);, +                    curr.next =  attr;, +                    attr.prev = curr;, +                }, +            }, +        }, +    }, +, +    @Override, +    public <T> boolean hasAttr(AttributeKey<T> key) {, +        if (key == null) {, +            throw new NullPointerException("key");, +        }, +        AtomicReferenceArray<DefaultAttribute<?>> attributes = this.attributes;, +        if (attributes == null) {, +            // no attribute exists, +            return false;, +        }, +, +        int i = index(key);, +        DefaultAttribute<?> head = attributes.get(i);, +        if (head == null) {, +            // No attribute exists which point to the bucket in which the head should be located, +            return false;, +        }, +, +        // check on the head can be done without synchronization, +        if (head.key == key && !head.removed) {, +            return true;, +        }, +, +        synchronized (head) {, +            // we need to synchronize on the head, +            DefaultAttribute<?> curr = head.next;, +            while (curr != null) {, +                if (!curr.removed && curr.key == key) {, +                    return true;, +                }, +                curr = curr.next;, +            }, +            return false;, +        }, +    }, +, +    private static int index(AttributeKey<?> key) {, +        return key.id() & MASK;]