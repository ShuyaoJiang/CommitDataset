[+++ b/transport/src/main/java/io/netty/channel/local/LocalChannel.java, +import io.netty.channel.RecvByteBufAllocator;, +            // Ensure the inboundBuffer is not empty as readInbound() will always call fireChannelReadComplete(), +            if (!inboundBuffer.isEmpty()) {, +                readInbound();, +, +    private void readInbound() {, +        RecvByteBufAllocator.Handle handle = unsafe().recvBufAllocHandle();, +        handle.reset(config());, +        ChannelPipeline pipeline = pipeline();, +        do {, +            Object received = inboundBuffer.poll();, +            if (received == null) {, +                break;, +            }, +            pipeline.fireChannelRead(received);, +        } while (handle.continueReading());, +, +        pipeline.fireChannelReadComplete();, +    }, +, +                readInbound();, +            peer.readInbound();, +++ b/transport/src/main/java/io/netty/channel/local/LocalChannel.java, +import io.netty.channel.RecvByteBufAllocator;, +            // Ensure the inboundBuffer is not empty as readInbound() will always call fireChannelReadComplete(), +            if (!inboundBuffer.isEmpty()) {, +                readInbound();, +, +    private void readInbound() {, +        RecvByteBufAllocator.Handle handle = unsafe().recvBufAllocHandle();, +        handle.reset(config());, +        ChannelPipeline pipeline = pipeline();, +        do {, +            Object received = inboundBuffer.poll();, +            if (received == null) {, +                break;, +            }, +            pipeline.fireChannelRead(received);, +        } while (handle.continueReading());, +, +        pipeline.fireChannelReadComplete();, +    }, +, +                readInbound();, +            peer.readInbound();, +++ b/transport/src/main/java/io/netty/channel/local/LocalServerChannel.java, +import io.netty.channel.RecvByteBufAllocator;, +        readInbound();, +    private void readInbound() {, +        RecvByteBufAllocator.Handle handle = unsafe().recvBufAllocHandle();, +        handle.reset(config());, +        ChannelPipeline pipeline = pipeline();, +        do {, +            Object m = inboundBuffer.poll();, +            if (m == null) {, +                break;, +            }, +            pipeline.fireChannelRead(m);, +        } while (handle.continueReading());, +, +        pipeline.fireChannelReadComplete();, +    }, +, +, +            readInbound();, +++ b/transport/src/main/java/io/netty/channel/local/LocalChannel.java, +import io.netty.channel.RecvByteBufAllocator;, +            // Ensure the inboundBuffer is not empty as readInbound() will always call fireChannelReadComplete(), +            if (!inboundBuffer.isEmpty()) {, +                readInbound();, +, +    private void readInbound() {, +        RecvByteBufAllocator.Handle handle = unsafe().recvBufAllocHandle();, +        handle.reset(config());, +        ChannelPipeline pipeline = pipeline();, +        do {, +            Object received = inboundBuffer.poll();, +            if (received == null) {, +                break;, +            }, +            pipeline.fireChannelRead(received);, +        } while (handle.continueReading());, +, +        pipeline.fireChannelReadComplete();, +    }, +, +                readInbound();, +            peer.readInbound();, +++ b/transport/src/main/java/io/netty/channel/local/LocalServerChannel.java, +import io.netty.channel.RecvByteBufAllocator;, +        readInbound();, +    private void readInbound() {, +        RecvByteBufAllocator.Handle handle = unsafe().recvBufAllocHandle();, +        handle.reset(config());, +        ChannelPipeline pipeline = pipeline();, +        do {, +            Object m = inboundBuffer.poll();, +            if (m == null) {, +                break;]