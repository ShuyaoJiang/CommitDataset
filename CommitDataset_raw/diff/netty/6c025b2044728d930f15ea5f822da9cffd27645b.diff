[+++ b/testsuite/src/main/java/io/netty/testsuite/transport/sctp/SctpEchoTest.java, +        testSimpleEcho0(sb, cb, false);, +    @Test, +    public void testSimpleEchoUnordered() throws Throwable {, +        Assume.assumeTrue(TestUtils.isSctpSupported());, +        run();, +    }, +, +    public void testSimpleEchoUnordered(ServerBootstrap sb, Bootstrap cb) throws Throwable {, +        testSimpleEcho0(sb, cb, true);, +    }, +, +    private static void testSimpleEcho0(ServerBootstrap sb, Bootstrap cb, final boolean unordered) throws Throwable {, +                        new SctpOutboundByteStreamHandler(0, 0, unordered),, +                        new SctpOutboundByteStreamHandler(0, 0, unordered),, +++ b/testsuite/src/main/java/io/netty/testsuite/transport/sctp/SctpEchoTest.java, +        testSimpleEcho0(sb, cb, false);, +    @Test, +    public void testSimpleEchoUnordered() throws Throwable {, +        Assume.assumeTrue(TestUtils.isSctpSupported());, +        run();, +    }, +, +    public void testSimpleEchoUnordered(ServerBootstrap sb, Bootstrap cb) throws Throwable {, +        testSimpleEcho0(sb, cb, true);, +    }, +, +    private static void testSimpleEcho0(ServerBootstrap sb, Bootstrap cb, final boolean unordered) throws Throwable {, +                        new SctpOutboundByteStreamHandler(0, 0, unordered),, +                        new SctpOutboundByteStreamHandler(0, 0, unordered),, +++ b/transport-sctp/src/main/java/io/netty/channel/sctp/SctpMessage.java, +    private final boolean unordered;, +        this(protocolIdentifier, streamIdentifier, false, payloadBuffer);, +    }, +, +    /**, +     * Essential data that is being carried within SCTP Data Chunk, +     * @param protocolIdentifier of payload, +     * @param streamIdentifier that you want to send the payload, +     * @param unordered if {@literal true}, the SCTP Data Chunk will be sent with the U (unordered) flag set., +     * @param payloadBuffer channel buffer, +     */, +    public SctpMessage(int protocolIdentifier, int streamIdentifier, boolean unordered, ByteBuf payloadBuffer) {, +        this.unordered = unordered;, +        unordered = msgInfo.isUnordered();, +     * return the unordered flag, +     */, +    public boolean isUnordered() {, +        return unordered;, +    }, +, +    /**, +        if (unordered != sctpFrame.unordered) {, +            return false;, +        }, +, +            return new SctpMessage(protocolIdentifier, streamIdentifier, unordered, content().copy());, +            return new SctpMessage(protocolIdentifier, streamIdentifier, unordered, content().duplicate());, +                    ", unordered=" + unordered +, +                ", unordered=" + unordered +, +++ b/testsuite/src/main/java/io/netty/testsuite/transport/sctp/SctpEchoTest.java, +        testSimpleEcho0(sb, cb, false);, +    @Test, +    public void testSimpleEchoUnordered() throws Throwable {, +        Assume.assumeTrue(TestUtils.isSctpSupported());, +        run();, +    }, +, +    public void testSimpleEchoUnordered(ServerBootstrap sb, Bootstrap cb) throws Throwable {, +        testSimpleEcho0(sb, cb, true);, +    }, +, +    private static void testSimpleEcho0(ServerBootstrap sb, Bootstrap cb, final boolean unordered) throws Throwable {, +                        new SctpOutboundByteStreamHandler(0, 0, unordered),, +                        new SctpOutboundByteStreamHandler(0, 0, unordered),, +++ b/transport-sctp/src/main/java/io/netty/channel/sctp/SctpMessage.java, +    private final boolean unordered;, +        this(protocolIdentifier, streamIdentifier, false, payloadBuffer);, +    }, +, +    /**, +     * Essential data that is being carried within SCTP Data Chunk, +     * @param protocolIdentifier of payload, +     * @param streamIdentifier that you want to send the payload, +     * @param unordered if {@literal true}, the SCTP Data Chunk will be sent with the U (unordered) flag set., +     * @param payloadBuffer channel buffer, +     */, +    public SctpMessage(int protocolIdentifier, int streamIdentifier, boolean unordered, ByteBuf payloadBuffer) {, +        this.unordered = unordered;, +        unordered = msgInfo.isUnordered();, +     * return the unordered flag, +     */, +    public boolean isUnordered() {, +        return unordered;, +    }, +, +    /**, +        if (unordered != sctpFrame.unordered) {, +            return false;, +        }]