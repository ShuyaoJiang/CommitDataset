[+++ b/transport/src/test/java/io/netty/channel/DefaultChannelPipelineTest.java, +import io.netty.bootstrap.Bootstrap;, +import io.netty.bootstrap.ServerBootstrap;, +import io.netty.channel.local.LocalAddress;, +import io.netty.channel.local.LocalServerChannel;, +import org.junit.After;, +import org.junit.AfterClass;, +import java.util.concurrent.atomic.AtomicReference;, +, +    private static final EventLoopGroup group = new LocalEventLoopGroup(1);, +, +    private Channel self;, +    private Channel peer;, +, +    @AfterClass, +    public static void afterClass() {, +        group.shutdownGracefully();, +    }, +, +    private void setUp(final ChannelHandler... handlers) throws Exception {, +        final AtomicReference<Channel> peerRef = new AtomicReference<Channel>();, +        ServerBootstrap sb = new ServerBootstrap();, +        sb.group(group).channel(LocalServerChannel.class);, +        sb.childHandler(new ChannelInboundMessageHandlerAdapter<Object>() {, +            @Override, +            public void channelRegistered(ChannelHandlerContext ctx) throws Exception {, +                peerRef.set(ctx.channel());, +            }, +, +            @Override, +            public void messageReceived(ChannelHandlerContext ctx, Object msg) throws Exception {, +                // Swallow., +            }, +        });, +, +        ChannelFuture bindFuture = sb.bind(LocalAddress.ANY).sync();, +, +        Bootstrap b = new Bootstrap();, +        b.group(group).channel(LocalChannel.class);, +        b.handler(new ChannelInitializer<LocalChannel>() {, +            @Override, +            protected void initChannel(LocalChannel ch) throws Exception {, +                ch.pipeline().addLast(handlers);, +            }, +        });, +, +        self = b.connect(bindFuture.channel().localAddress()).sync().channel();, +        peer = peerRef.get();, +, +        bindFuture.channel().close().sync();, +    }, +, +    @After, +    public void tearDown() throws Exception {, +        if (peer != null) {, +            peer.close();, +            peer = null;, +        }, +        if (self != null) {, +            self = null;, +        }, +    }, +, +, +        setUp(new ChannelInboundMessageHandlerAdapter<Object>() {, +, +        peer.write(new Object()).sync();, +        setUp(new ChannelInboundByteHandlerAdapter() {, +, +        // Not using peer.write() because the pipeline will convert the bytes into a message automatically., +        self.eventLoop().submit(new Runnable() {, +                self.pipeline().inboundByteBuffer().writeByte(0);, +                self.pipeline().fireInboundBufferUpdated();, +        }).sync();, +        setUp(new ChannelOutboundByteHandlerAdapter() {, +, +        self.eventLoop().submit(new Runnable() {, +                self.pipeline().outboundByteBuffer().writeByte(0);, +                self.pipeline().flush();, +        }).sync();, +    public void testFreeCalled() throws Exception {, +        setUp(handler);, +, +        peer.write(holder).sync();, +        ChannelPipeline pipeline = new LocalChannel().pipeline();, +        ChannelPipeline pipeline = new LocalChannel().pipeline();, +        ChannelPipeline pipeline = new LocalChannel().pipeline();, +        ChannelPipeline pipeline = new LocalChannel().pipeline();, +, +        ChannelPipeline pipeline = new LocalChannel().pipeline();, +, +    @Test(timeout = 100000), +, +        setUp(handler1, handler2);, +, +        self.eventLoop().submit(new Runnable() {, +                ChannelPipeline p = self.pipeline();, +                p.context(handler1).inboundByteBuffer().writeLong(8);, +                assertEquals(8, p.context(handler1).inboundByteBuffer().readableBytes());, +                assertEquals(0, p.context(handler2).inboundByteBuffer().readableBytes());]