[+++ b/common/src/main/java/io/netty/util/internal/MacAddressUtil.java, +    // visible for testing, +    static int compareAddresses(byte[] current, byte[] candidate) {, +            if (current.length != 0 && (current[0] & 2) == 0) {, +        } else {, +            if (current.length != 0 && (current[0] & 2) == 0) {, +                // Only current is globally unique., +                return 1;, +            } else {, +        }, +    }, +++ b/common/src/main/java/io/netty/util/internal/MacAddressUtil.java, +    // visible for testing, +    static int compareAddresses(byte[] current, byte[] candidate) {, +            if (current.length != 0 && (current[0] & 2) == 0) {, +        } else {, +            if (current.length != 0 && (current[0] & 2) == 0) {, +                // Only current is globally unique., +                return 1;, +            } else {, +        }, +    }, +++ b/common/src/test/java/io/netty/util/internal/MacAddressUtilTest.java, +import static io.netty.util.internal.EmptyArrays.EMPTY_BYTES;, +import static org.junit.Assert.assertEquals;, +    public void testCompareAddresses() {, +        // should not prefer empty address when candidate is not globally unique, +        assertEquals(, +                0,, +                MacAddressUtil.compareAddresses(, +                        EMPTY_BYTES,, +                        new byte[]{(byte) 0x52, (byte) 0x54, (byte) 0x00, (byte) 0xf9, (byte) 0x32, (byte) 0xbd}));, +, +        // only candidate is globally unique, +        assertEquals(, +                -1,, +                MacAddressUtil.compareAddresses(, +                        EMPTY_BYTES,, +                        new byte[]{(byte) 0x50, (byte) 0x54, (byte) 0x00, (byte) 0xf9, (byte) 0x32, (byte) 0xbd}));, +, +        // only candidate is globally unique, +        assertEquals(, +                -1,, +                MacAddressUtil.compareAddresses(, +                        new byte[]{(byte) 0x52, (byte) 0x54, (byte) 0x00, (byte) 0xf9, (byte) 0x32, (byte) 0xbd},, +                        new byte[]{(byte) 0x50, (byte) 0x54, (byte) 0x00, (byte) 0xf9, (byte) 0x32, (byte) 0xbd}));, +, +        // only current is globally unique, +        assertEquals(, +                1,, +                MacAddressUtil.compareAddresses(, +                        new byte[]{(byte) 0x52, (byte) 0x54, (byte) 0x00, (byte) 0xf9, (byte) 0x32, (byte) 0xbd},, +                        EMPTY_BYTES));, +, +        // only current is globally unique, +        assertEquals(, +                1,, +                MacAddressUtil.compareAddresses(, +                        new byte[]{(byte) 0x50, (byte) 0x54, (byte) 0x00, (byte) 0xf9, (byte) 0x32, (byte) 0xbd},, +                        new byte[]{(byte) 0x52, (byte) 0x54, (byte) 0x00, (byte) 0xf9, (byte) 0x32, (byte) 0xbd}));, +, +        // both are globally unique, +        assertEquals(, +                0,, +                MacAddressUtil.compareAddresses(, +                        new byte[]{(byte) 0x50, (byte) 0x54, (byte) 0x00, (byte) 0xf9, (byte) 0x32, (byte) 0xbd},, +                        new byte[]{(byte) 0x50, (byte) 0x55, (byte) 0x01, (byte) 0xfa, (byte) 0x33, (byte) 0xbe}));, +    }, +, +    @Test]