[+++ b/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java, +            // There is nothing really wrong with not be able to notify the promise as we may have raced here because, +            // of multiple queries that have been executed. Log it with trace level anyway just in case the user, +            // wants to better understand what happened., +            logger.trace("Failed to notify success ({}) to a promise: {}", result, promise);, +            // There is nothing really wrong with not be able to notify the promise as we may have raced here because, +            // of multiple queries that have been executed. Log it with trace level anyway just in case the user, +            // wants to better understand what happened., +            logger.trace("Failed to notify failure to a promise: {}", promise, cause);, +++ b/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java, +            // There is nothing really wrong with not be able to notify the promise as we may have raced here because, +            // of multiple queries that have been executed. Log it with trace level anyway just in case the user, +            // wants to better understand what happened., +            logger.trace("Failed to notify success ({}) to a promise: {}", result, promise);, +            // There is nothing really wrong with not be able to notify the promise as we may have raced here because, +            // of multiple queries that have been executed. Log it with trace level anyway just in case the user, +            // wants to better understand what happened., +            logger.trace("Failed to notify failure to a promise: {}", promise, cause);, +++ b/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java, +, +    @Test, +    public void testDropAAAA() throws IOException {, +        String host = "somehost.netty.io";, +        TestDnsServer dnsServer2 = new TestDnsServer(Collections.singleton(host));, +        dnsServer2.start(true);, +        DnsNameResolver resolver = null;, +        try {, +            DnsNameResolverBuilder builder = newResolver(), +                    .recursionDesired(false), +                    .queryTimeoutMillis(500), +                    .resolvedAddressTypes(ResolvedAddressTypes.IPV4_PREFERRED), +                    .maxQueriesPerResolve(16), +                    .nameServerProvider(new SingletonDnsServerAddressStreamProvider(dnsServer2.localAddress()));, +, +            resolver = builder.build();, +            List<InetAddress> addressList = resolver.resolveAll(host).syncUninterruptibly().getNow();, +            assertEquals(1, addressList.size());, +            assertEquals(host, addressList.get(0).getHostName());, +        } finally {, +            dnsServer2.stop();, +            if (resolver != null) {, +                resolver.close();, +            }, +        }, +    }, +, +++ b/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java, +            // There is nothing really wrong with not be able to notify the promise as we may have raced here because, +            // of multiple queries that have been executed. Log it with trace level anyway just in case the user, +            // wants to better understand what happened., +            logger.trace("Failed to notify success ({}) to a promise: {}", result, promise);, +            // There is nothing really wrong with not be able to notify the promise as we may have raced here because, +            // of multiple queries that have been executed. Log it with trace level anyway just in case the user, +            // wants to better understand what happened., +            logger.trace("Failed to notify failure to a promise: {}", promise, cause);, +++ b/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java, +, +    @Test, +    public void testDropAAAA() throws IOException {, +        String host = "somehost.netty.io";, +        TestDnsServer dnsServer2 = new TestDnsServer(Collections.singleton(host));, +        dnsServer2.start(true);, +        DnsNameResolver resolver = null;, +        try {, +            DnsNameResolverBuilder builder = newResolver(), +                    .recursionDesired(false), +                    .queryTimeoutMillis(500), +                    .resolvedAddressTypes(ResolvedAddressTypes.IPV4_PREFERRED), +                    .maxQueriesPerResolve(16), +                    .nameServerProvider(new SingletonDnsServerAddressStreamProvider(dnsServer2.localAddress()));, +, +            resolver = builder.build();, +            List<InetAddress> addressList = resolver.resolveAll(host).syncUninterruptibly().getNow();, +            assertEquals(1, addressList.size());, +            assertEquals(host, addressList.get(0).getHostName());, +        } finally {, +            dnsServer2.stop();, +            if (resolver != null) {, +                resolver.close();, +            }, +        }, +    }, +, +++ b/resolver-dns/src/test/java/io/netty/resolver/dns/TestDnsServer.java, +import org.apache.directory.server.dns.io.decoder.DnsMessageDecoder;, +import org.apache.mina.filter.codec.ProtocolDecoderAdapter;, +import org.apache.mina.filter.codec.ProtocolDecoderOutput;, +        start(false);, +    }, +, +    /**, +     * Start the {@link TestDnsServer} but drop all {@code AAAA} queries and not send any response to these at all., +     */, +    public void start(final boolean dropAAAAQueries) throws IOException {, +                        .addFirst("codec", new ProtocolCodecFilter(, +                                new TestDnsProtocolUdpCodecFactory(dropAAAAQueries)));, +        private final boolean dropAAAArecords;, +, +        TestDnsProtocolUdpCodecFactory(boolean dropAAAArecords) {, +            this.dropAAAArecords = dropAAAArecords;]