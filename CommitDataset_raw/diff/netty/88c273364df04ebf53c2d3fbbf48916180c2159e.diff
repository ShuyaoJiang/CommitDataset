[+++ b/testsuite/src/test/java/io/netty/testsuite/transport/socket/TrafficShapingHandlerTest.java, +/*, + * Copyright 2012 The Netty Project, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + * http://www.apache.org/licenses/LICENSE-2.0, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the, + * License for the specific language governing permissions and limitations, + * under the License., + */, +package io.netty.testsuite.transport.socket;, +, +import io.netty.bootstrap.Bootstrap;, +import io.netty.bootstrap.ServerBootstrap;, +import io.netty.buffer.ByteBuf;, +import io.netty.buffer.Unpooled;, +import io.netty.channel.Channel;, +import io.netty.channel.ChannelHandlerContext;, +import io.netty.channel.ChannelInitializer;, +import io.netty.channel.SimpleChannelInboundHandler;, +import io.netty.channel.socket.SocketChannel;, +import io.netty.handler.traffic.AbstractTrafficShapingHandler;, +import io.netty.handler.traffic.ChannelTrafficShapingHandler;, +import io.netty.handler.traffic.GlobalTrafficShapingHandler;, +import io.netty.util.concurrent.DefaultEventExecutorGroup;, +import io.netty.util.concurrent.EventExecutorGroup;, +import io.netty.util.concurrent.Promise;, +import io.netty.util.internal.logging.InternalLogger;, +import io.netty.util.internal.logging.InternalLoggerFactory;, +import io.netty.util.internal.logging.Slf4JLoggerFactory;, +, +import org.junit.AfterClass;, +import org.junit.BeforeClass;, +import org.junit.Test;, +import org.slf4j.LoggerFactory;, +, +import ch.qos.logback.classic.Level;, +import ch.qos.logback.classic.Logger;, +, +import java.io.IOException;, +import java.util.Arrays;, +import java.util.Random;, +import java.util.concurrent.Executors;, +import java.util.concurrent.ScheduledExecutorService;, +import java.util.concurrent.TimeUnit;, +import java.util.concurrent.atomic.AtomicReference;, +, +import static org.junit.Assert.*;, +, +public class TrafficShapingHandlerTest extends AbstractSocketTest {, +    private static final InternalLogger logger = InternalLoggerFactory.getInstance(TrafficShapingHandlerTest.class);, +    private static final InternalLogger loggerServer = InternalLoggerFactory.getInstance("ServerTSH");, +    private static final InternalLogger loggerClient = InternalLoggerFactory.getInstance("ClientTSH");, +, +    static final int messageSize = 1024;, +    static final int bandwidthFactor = 12;, +    static final int minfactor = 3;, +    static final int maxfactor = bandwidthFactor + (bandwidthFactor / 2);, +    static final long stepms = 1000 / bandwidthFactor;, +    static final long minimalms = Math.max(stepms / 2, 20) / 10 * 10;, +    static final long check = 10;, +    private static final Random random = new Random();, +    static final byte[] data = new byte[messageSize];, +, +    private static final String TRAFFIC = "traffic";, +    private static String TESTNAME;, +    private static int TESTRUN;, +, +    private static EventExecutorGroup group;, +    private static EventExecutorGroup groupForGlobal;, +    private static ScheduledExecutorService executor = Executors.newScheduledThreadPool(10);, +    static {, +        random.nextBytes(data);, +    }, +, +    @BeforeClass, +    public static void createGroup() {, +        logger.info("Bandwidth: " + minfactor + " <= " + bandwidthFactor + " <= " + maxfactor +, +                    " StepMs: " + stepms + " MinMs: " + minimalms + " CheckMs: " + check);, +        InternalLoggerFactory.setDefaultFactory(new Slf4JLoggerFactory());, +        Logger logger = (Logger) LoggerFactory.getLogger("ROOT");, +        logger.setLevel(Level.INFO);, +        group = new DefaultEventExecutorGroup(8);, +        groupForGlobal = new DefaultEventExecutorGroup(8);, +    }, +, +    @AfterClass, +    public static void destroyGroup() throws Exception {, +        group.shutdownGracefully().sync();, +        groupForGlobal.shutdownGracefully().sync();, +        executor.shutdown();, +    }, +, +    private static long[] computeWaitRead(int[] multipleMessage) {, +        long[] minimalWaitBetween = new long[multipleMessage.length + 1];, +        minimalWaitBetween[0] = 0;, +        for (int i = 0; i < multipleMessage.length; i++) {]