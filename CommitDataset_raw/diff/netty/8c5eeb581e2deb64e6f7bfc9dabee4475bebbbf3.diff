[+++ b/handler/src/main/java/io/netty/handler/ssl/SslHandler.java, +                        pendingUnencryptedWrites.addFirst(buf, promise);, +                        // When we add the buffer/promise pair back we need to be sure we don't complete the promise, +                        // later in finishWrap. We only complete the promise if the buffer is completely consumed., +                        promise = null;, +            releaseAndFailAll(cause);, +        }, +    }, +, +    private void releaseAndFailAll(Throwable cause) {, +                try {, +                } finally {, +                    releaseAndFailAll(HANDSHAKE_TIMED_OUT);, +                }, +++ b/handler/src/main/java/io/netty/handler/ssl/SslHandler.java, +                        pendingUnencryptedWrites.addFirst(buf, promise);, +                        // When we add the buffer/promise pair back we need to be sure we don't complete the promise, +                        // later in finishWrap. We only complete the promise if the buffer is completely consumed., +                        promise = null;, +            releaseAndFailAll(cause);, +        }, +    }, +, +    private void releaseAndFailAll(Throwable cause) {, +                try {, +                } finally {, +                    releaseAndFailAll(HANDSHAKE_TIMED_OUT);, +                }, +++ b/handler/src/test/java/io/netty/handler/ssl/SslHandlerTest.java, +import io.netty.channel.ChannelPromise;, +import java.security.NoSuchAlgorithmException;, +    public void testIncompleteWriteDoesNotCompletePromisePrematurely() throws NoSuchAlgorithmException {, +        SSLEngine engine = SSLContext.getDefault().createSSLEngine();, +        engine.setUseClientMode(false);, +, +        EmbeddedChannel ch = new EmbeddedChannel(new SslHandler(engine));, +, +        ChannelPromise promise = ch.newPromise();, +        ByteBuf buf = Unpooled.buffer(10).writeZero(10);, +        ch.writeAndFlush(buf, promise);, +        assertFalse(promise.isDone());, +        assertTrue(ch.finishAndReleaseAll());, +        assertTrue(promise.isDone());, +        assertThat(promise.cause(), is(instanceOf(SSLException.class)));, +    }, +, +    @Test, +++ b/handler/src/main/java/io/netty/handler/ssl/SslHandler.java, +                        pendingUnencryptedWrites.addFirst(buf, promise);, +                        // When we add the buffer/promise pair back we need to be sure we don't complete the promise, +                        // later in finishWrap. We only complete the promise if the buffer is completely consumed., +                        promise = null;, +            releaseAndFailAll(cause);, +        }, +    }, +, +    private void releaseAndFailAll(Throwable cause) {, +                try {, +                } finally {, +                    releaseAndFailAll(HANDSHAKE_TIMED_OUT);, +                }, +++ b/handler/src/test/java/io/netty/handler/ssl/SslHandlerTest.java, +import io.netty.channel.ChannelPromise;, +import java.security.NoSuchAlgorithmException;, +    public void testIncompleteWriteDoesNotCompletePromisePrematurely() throws NoSuchAlgorithmException {, +        SSLEngine engine = SSLContext.getDefault().createSSLEngine();, +        engine.setUseClientMode(false);, +, +        EmbeddedChannel ch = new EmbeddedChannel(new SslHandler(engine));, +, +        ChannelPromise promise = ch.newPromise();, +        ByteBuf buf = Unpooled.buffer(10).writeZero(10);, +        ch.writeAndFlush(buf, promise);, +        assertFalse(promise.isDone());, +        assertTrue(ch.finishAndReleaseAll());, +        assertTrue(promise.isDone());, +        assertThat(promise.cause(), is(instanceOf(SSLException.class)));, +    }, +, +    @Test, +++ b/transport/src/main/java/io/netty/channel/AbstractCoalescingBufferQueue.java, +    public final void addFirst(ByteBuf buf, ChannelPromise promise) {, +        bufAndListenerPairs.addFirst(new DelegatingChannelPromiseNotifier(promise));]