[+++ b/common/src/main/java/io/netty/util/internal/logging/FormattingTuple.java, +final class FormattingTuple {, +    FormattingTuple(String message, Throwable throwable) {, +++ b/common/src/main/java/io/netty/util/internal/logging/FormattingTuple.java, +final class FormattingTuple {, +    FormattingTuple(String message, Throwable throwable) {, +++ b/common/src/main/java/io/netty/util/internal/logging/MessageFormatter.java, +import java.util.HashSet;, +import java.util.Set;, +    private static final String DELIM_STR = "{}";, +        if (argArray == null || argArray.length == 0) {, +            return new FormattingTuple(messagePattern, null);, +        }, +        int lastArrIdx = argArray.length - 1;, +        Object lastEntry = argArray[lastArrIdx];, +        Throwable throwable = lastEntry instanceof Throwable? (Throwable) lastEntry : null;, +            return new FormattingTuple(null, throwable);, +        int j = messagePattern.indexOf(DELIM_STR);, +            // this is a simple string, +            return new FormattingTuple(messagePattern, throwable);, +, +        StringBuilder sbuf = new StringBuilder(messagePattern.length() + 50);, +        int i = 0;, +        int L = 0;, +        do {, +            boolean notEscaped = j == 0 || messagePattern.charAt(j - 1) != ESCAPE_CHAR;, +            if (notEscaped) {, +                sbuf.append(messagePattern, i, j);, +                sbuf.append(messagePattern, i, j - 1);, +                // check that escape char is not is escaped: "abc x:\\{}", +                notEscaped = j >= 2 && messagePattern.charAt(j - 2) == ESCAPE_CHAR;, +            i = j + 2;, +            if (notEscaped) {, +                deeplyAppendParameter(sbuf, argArray[L], null);, +                L++;, +                if (L > lastArrIdx) {, +                    break;, +            } else {, +                sbuf.append(DELIM_STR);, +            j = messagePattern.indexOf(DELIM_STR, i);, +        } while (j != -1);, +        // append the characters following the last {} pair., +        sbuf.append(messagePattern, i, messagePattern.length());, +        return new FormattingTuple(sbuf.toString(), L <= lastArrIdx? throwable : null);, +    private static void deeplyAppendParameter(StringBuilder sbuf, Object o,, +                                              Set<Object[]> seenSet) {, +        Class<?> objClass = o.getClass();, +        if (!objClass.isArray()) {, +            if (Number.class.isAssignableFrom(objClass)) {, +                // Prevent String instantiation for some number types, +                if (objClass == Long.class) {, +                    sbuf.append(((Long) o).longValue());, +                } else if (objClass == Integer.class || objClass == Short.class || objClass == Byte.class) {, +                    sbuf.append(((Number) o).intValue());, +                } else if (objClass == Double.class) {, +                    sbuf.append(((Double) o).doubleValue());, +                } else if (objClass == Float.class) {, +                    sbuf.append(((Float) o).floatValue());, +                } else {, +                }, +            } else {, +                safeObjectAppend(sbuf, o);, +            }, +            sbuf.append('[');, +            if (objClass == boolean[].class) {, +            } else if (objClass == byte[].class) {, +            } else if (objClass == char[].class) {, +            } else if (objClass == short[].class) {, +            } else if (objClass == int[].class) {, +            } else if (objClass == long[].class) {, +            } else if (objClass == float[].class) {, +            } else if (objClass == double[].class) {, +                objectArrayAppend(sbuf, (Object[]) o, seenSet);, +            sbuf.append(']');, +    private static void safeObjectAppend(StringBuilder sbuf, Object o) {, +    private static void objectArrayAppend(StringBuilder sbuf, Object[] a, Set<Object[]> seenSet) {, +        if (a.length == 0) {, +            return;, +        if (seenSet == null) {, +            seenSet = new HashSet<Object[]>(a.length);, +        }, +        if (seenSet.add(a)) {, +            deeplyAppendParameter(sbuf, a[0], seenSet);, +            for (int i = 1; i < a.length; i++) {, +                sbuf.append(", ");, +                deeplyAppendParameter(sbuf, a[i], seenSet);, +            seenSet.remove(a);, +    private static void booleanArrayAppend(StringBuilder sbuf, boolean[] a) {, +        if (a.length == 0) {, +            return;, +        }, +        sbuf.append(a[0]);, +        for (int i = 1; i < a.length; i++) {, +            sbuf.append(a[i]);, +    private static void byteArrayAppend(StringBuilder sbuf, byte[] a) {, +        if (a.length == 0) {, +            return;, +        }, +        sbuf.append(a[0]);, +        for (int i = 1; i < a.length; i++) {]