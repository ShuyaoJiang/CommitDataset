[+++ b/buffer/src/main/java/io/netty/buffer/AdvancedLeakAwareCompositeByteBuf.java, +    public CompositeByteBuf addFlattenedComponents(boolean increaseWriterIndex, ByteBuf buffer) {, +        recordLeakNonRefCountingOperation(leak);, +        return super.addFlattenedComponents(increaseWriterIndex, buffer);, +    }, +, +    @Override, +++ b/buffer/src/main/java/io/netty/buffer/AdvancedLeakAwareCompositeByteBuf.java, +    public CompositeByteBuf addFlattenedComponents(boolean increaseWriterIndex, ByteBuf buffer) {, +        recordLeakNonRefCountingOperation(leak);, +        return super.addFlattenedComponents(increaseWriterIndex, buffer);, +    }, +, +    @Override, +++ b/buffer/src/main/java/io/netty/buffer/CompositeByteBuf.java, +                writerIndex += readableBytes;, +                writerIndex += components[ci - 1].endOffset - components[cIndex].offset;, +    /**, +     * Add the given {@link ByteBuf} and increase the {@code writerIndex} if {@code increaseWriterIndex} is, +     * {@code true}. If the provided buffer is a {@link CompositeByteBuf} itself, a "shallow copy" of its, +     * readable components will be performed. Thus the actual number of new components added may vary, +     * and in particular will be zero if the provided buffer is not readable., +     * <p>, +     * {@link ByteBuf#release()} ownership of {@code buffer} is transferred to this {@link CompositeByteBuf}., +     * @param buffer the {@link ByteBuf} to add. {@link ByteBuf#release()} ownership is transferred to this, +     * {@link CompositeByteBuf}., +     */, +    public CompositeByteBuf addFlattenedComponents(boolean increaseWriterIndex, ByteBuf buffer) {, +        checkNotNull(buffer, "buffer");, +        final int ridx = buffer.readerIndex();, +        final int widx = buffer.writerIndex();, +        if (ridx == widx) {, +            buffer.release();, +            return this;, +        }, +        if (!(buffer instanceof CompositeByteBuf)) {, +            addComponent0(increaseWriterIndex, componentCount, buffer);, +            consolidateIfNeeded();, +            return this;, +        }, +        final CompositeByteBuf from = (CompositeByteBuf) buffer;, +        from.checkIndex(ridx, widx - ridx);, +        final Component[] fromComponents = from.components;, +        final int compCountBefore = componentCount;, +        final int writerIndexBefore = writerIndex;, +        try {, +            for (int cidx = from.toComponentIndex0(ridx), newOffset = capacity();; cidx++) {, +                final Component component = fromComponents[cidx];, +                final int compOffset = component.offset;, +                final int fromIdx = Math.max(ridx, compOffset);, +                final int toIdx = Math.min(widx, component.endOffset);, +                final int len = toIdx - fromIdx;, +                if (len > 0) { // skip empty components, +                    // Note that it's safe to just retain the unwrapped buf here, even in the case, +                    // of PooledSlicedByteBufs - those slices will still be properly released by the, +                    // source Component's free() method., +                    addComp(componentCount, new Component(, +                            component.buf.retain(), component.idx(fromIdx), newOffset, len, null));, +                }, +                if (widx == toIdx) {, +                    break;, +                }, +                newOffset += len;, +            }, +            if (increaseWriterIndex) {, +                writerIndex = writerIndexBefore + (widx - ridx);, +            }, +            consolidateIfNeeded();, +            buffer.release();, +            buffer = null;, +            return this;, +        } finally {, +            if (buffer != null) {, +                // if we did not succeed, attempt to rollback any components that were added, +                if (increaseWriterIndex) {, +                    writerIndex = writerIndexBefore;, +                }, +                for (int cidx = componentCount - 1; cidx >= compCountBefore; cidx--) {, +                    components[cidx].free();, +                    removeComp(cidx);, +                }, +            }, +        }, +    }, +, +                setIndex0(newCapacity, newCapacity);, +            } else if (writerIndex > newCapacity) {, +                writerIndex = newCapacity;, +        if (size <= 2) { // fast-path for 1 and 2 component count, +            return size == 1 || offset < components[0].endOffset ? 0 : 1;, +        }, +        int firstComponentId = 0;, +        Component c = null;, +        for (int size = componentCount; firstComponentId < size; firstComponentId++) {, +            c = components[firstComponentId];, +            if (c.endOffset > readerIndex) {, +                break;, +            c.free();, +        }, +        if (firstComponentId == 0) {]