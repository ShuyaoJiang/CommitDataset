[+++ b/buffer/src/main/java/io/netty/buffer/AbstractDerivedByteBuf.java, +        if (unwrap().release()) {, +            deallocate();, +            return true;, +        }, +        return false;, +        if (unwrap().release(decrement)) {, +            deallocate();, +            return true;, +        }, +        return false;, +, +    /**, +     * Called when the wrapped {@link ByteBuf} was released due calling of {@link #release()} or {@link #release(int)}., +     */, +    protected void deallocate() { }, +++ b/buffer/src/main/java/io/netty/buffer/AbstractDerivedByteBuf.java, +        if (unwrap().release()) {, +            deallocate();, +            return true;, +        }, +        return false;, +        if (unwrap().release(decrement)) {, +            deallocate();, +            return true;, +        }, +        return false;, +, +    /**, +     * Called when the wrapped {@link ByteBuf} was released due calling of {@link #release()} or {@link #release(int)}., +     */, +    protected void deallocate() { }, +++ b/buffer/src/main/java/io/netty/buffer/DuplicatedByteBuf.java, +    private ByteBuf buffer;, +        init(buffer);, +    }, +    DuplicatedByteBuf(int maxCapacity) {, +        super(maxCapacity);, +    }, +, +    final void init(ByteBuf buffer) {, +        maxCapacity(buffer.maxCapacity());, +        markReaderIndex();, +        markWriterIndex();, +++ b/buffer/src/main/java/io/netty/buffer/AbstractDerivedByteBuf.java, +        if (unwrap().release()) {, +            deallocate();, +            return true;, +        }, +        return false;, +        if (unwrap().release(decrement)) {, +            deallocate();, +            return true;, +        }, +        return false;, +, +    /**, +     * Called when the wrapped {@link ByteBuf} was released due calling of {@link #release()} or {@link #release(int)}., +     */, +    protected void deallocate() { }, +++ b/buffer/src/main/java/io/netty/buffer/DuplicatedByteBuf.java, +    private ByteBuf buffer;, +        init(buffer);, +    }, +    DuplicatedByteBuf(int maxCapacity) {, +        super(maxCapacity);, +    }, +, +    final void init(ByteBuf buffer) {, +        maxCapacity(buffer.maxCapacity());, +        markReaderIndex();, +        markWriterIndex();, +++ b/buffer/src/main/java/io/netty/buffer/PooledByteBuf.java, +    public ByteBuf slice(int index, int length) {, +        return PooledSlicedByteBuf.newInstance(this, index, length);, +    }, +, +    @Override, +    public ByteBuf duplicate() {, +        return PooledDuplicatedByteBuf.newInstance(this);, +    }, +, +    @Override, +++ b/buffer/src/main/java/io/netty/buffer/AbstractDerivedByteBuf.java, +        if (unwrap().release()) {, +            deallocate();, +            return true;, +        }, +        return false;, +        if (unwrap().release(decrement)) {, +            deallocate();, +            return true;, +        }, +        return false;, +, +    /**, +     * Called when the wrapped {@link ByteBuf} was released due calling of {@link #release()} or {@link #release(int)}., +     */, +    protected void deallocate() { }, +++ b/buffer/src/main/java/io/netty/buffer/DuplicatedByteBuf.java]