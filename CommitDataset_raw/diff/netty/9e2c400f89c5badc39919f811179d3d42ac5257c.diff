[+++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslEngine.java, +import javax.net.ssl.SSLEngine;, +import javax.net.ssl.SSLEngineResult;, +import javax.net.ssl.SSLEngineResult.HandshakeStatus;, +import javax.net.ssl.SSLException;, +import javax.net.ssl.SSLHandshakeException;, +import javax.net.ssl.SSLParameters;, +import javax.net.ssl.SSLPeerUnverifiedException;, +import javax.net.ssl.SSLSession;, +import javax.net.ssl.SSLSessionBindingEvent;, +import javax.net.ssl.SSLSessionBindingListener;, +import javax.net.ssl.SSLSessionContext;, +import javax.security.cert.X509Certificate;, +, +import static javax.net.ssl.SSLEngineResult.HandshakeStatus.FINISHED;, +import static javax.net.ssl.SSLEngineResult.HandshakeStatus.NEED_UNWRAP;, +import static javax.net.ssl.SSLEngineResult.HandshakeStatus.NEED_WRAP;, +import static javax.net.ssl.SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING;, +import static javax.net.ssl.SSLEngineResult.Status.BUFFER_OVERFLOW;, +import static javax.net.ssl.SSLEngineResult.Status.CLOSED;, +import static javax.net.ssl.SSLEngineResult.Status.OK;, +        int bytesProduced = 0;, +                final SSLEngineResult pendingNetResult;, +, +                    pendingNetResult = readPendingBytesFromBIO(dst, bytesConsumed, bytesProduced, status);, +                    if (pendingNetResult != null) {, +                        return pendingNetResult;, +                    }, +                        pendingNetResult = readPendingBytesFromBIO(dst, bytesConsumed, bytesProduced, status);, +                        return pendingNetResult != null ? pendingNetResult : CLOSED_NOT_HANDSHAKING;, +                        // If there is no pending data to read from BIO we should go back to event loop and try to read, +                        // more data [1]. It is also possible that event loop will detect the socket has been closed., +                        // [1] https://www.openssl.org/docs/manmaster/ssl/SSL_write.html, +                        pendingNetResult = readPendingBytesFromBIO(dst, bytesConsumed, bytesProduced, status);, +                        return pendingNetResult != null ? pendingNetResult :, +                                new SSLEngineResult(getEngineStatus(), NEED_UNWRAP, bytesConsumed, bytesProduced);, +                        // SSL_ERROR_WANT_WRITE typically means that the underlying transport is not writable and we, +                        // should set the "want write" flag on the selector and try again when the underlying transport, +                        // is writable [1]. However we are not directly writing to the underlying transport and instead, +                        // writing to a BIO buffer. The OpenSsl documentation says we should do the following [1]:, +                        //, +                        // "When using a buffering BIO, like a BIO pair, data must be written into or retrieved out of, +                        // the BIO before being able to continue.", +                        //, +                        // So we attempt to drain the BIO buffer below, but if there is no data this condition is, +                        // undefined and we assume their is a fatal error with the openssl engine and close., +                        // [1] https://www.openssl.org/docs/manmaster/ssl/SSL_write.html, +                        pendingNetResult = readPendingBytesFromBIO(dst, bytesConsumed, bytesProduced, status);, +                        return pendingNetResult != null ? pendingNetResult : NEED_WRAP_CLOSED;]