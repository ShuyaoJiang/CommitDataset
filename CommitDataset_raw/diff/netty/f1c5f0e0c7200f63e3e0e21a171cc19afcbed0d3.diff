[+++ b/transport/src/main/java/io/netty/channel/PendingWriteQueue.java, +        // We need to guard against null as channel.unsafe().outboundBuffer() may returned null, +        // if the channel was already closed when constructing the PendingWriteQueue., +        // See https://github.com/netty/netty/issues/3967, +        if (buffer != null) {, +    }, +        // We need to guard against null as channel.unsafe().outboundBuffer() may returned null, +        // if the channel was already closed when constructing the PendingWriteQueue., +        // See https://github.com/netty/netty/issues/3967, +        if (buffer != null) {, +    }, +++ b/transport/src/main/java/io/netty/channel/PendingWriteQueue.java, +        // We need to guard against null as channel.unsafe().outboundBuffer() may returned null, +        // if the channel was already closed when constructing the PendingWriteQueue., +        // See https://github.com/netty/netty/issues/3967, +        if (buffer != null) {, +    }, +        // We need to guard against null as channel.unsafe().outboundBuffer() may returned null, +        // if the channel was already closed when constructing the PendingWriteQueue., +        // See https://github.com/netty/netty/issues/3967, +        if (buffer != null) {, +    }, +++ b/transport/src/test/java/io/netty/channel/PendingWriteQueueTest.java, +    // See https://github.com/netty/netty/issues/3967, +    @Test, +    public void testCloseChannelOnCreation() {, +        EmbeddedChannel channel = new EmbeddedChannel(new ChannelInboundHandlerAdapter());, +        channel.close().syncUninterruptibly();, +, +        final PendingWriteQueue queue = new PendingWriteQueue(channel.pipeline().firstContext());, +, +        IllegalStateException ex = new IllegalStateException();, +        ChannelPromise promise = channel.newPromise();, +        queue.add(1L, promise);, +        queue.removeAndFailAll(ex);, +        assertSame(ex, promise.cause());, +    }, +]