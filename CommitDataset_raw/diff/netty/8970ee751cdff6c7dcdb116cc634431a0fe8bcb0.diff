[+++ b/transport/src/main/java/io/netty/channel/DefaultChannelPipeline.java, +                future = newCtx.executor().submit(new AsyncPipelineModification(this) {, +                    future = newTail.executor().submit(new AsyncPipelineModification(this) {, +                    future = newCtx.executor().submit(new AsyncPipelineModification(this) {, +                    future = newCtx.executor().submit(new AsyncPipelineModification(this) {, +                        future = oldTail.executor().submit(new AsyncPipelineModification(this) {, +                       future = ctx.executor().submit(new AsyncPipelineModification(this) {, +                    future = oldTail.executor().submit(new AsyncPipelineModification(this) {, +                        future = oldTail.executor().submit(new AsyncPipelineModification(this) {, +                        future = newCtx.executor().submit(new AsyncPipelineModification(this) {, +}, + * Custom {@link Callable} implementation which will catch all {@link Throwable} which happens, + * during execution of {@link AsyncPipelineModification#doCall()} and return them in the, + * {@link Future}. This allows to re-throw them later., + * It also handles the right synchronization of the {@link AsyncPipelineModification#doCall()}, + * method., + * It was originally an inner class of {@link DefaultChannelPipeline}, but moved to a top level, + * type to work around a compiler bug., +abstract class AsyncPipelineModification implements Callable<Throwable> {, +, +    private final ChannelPipeline lock;, +, +    AsyncPipelineModification(ChannelPipeline lock) {, +        this.lock = lock;, +    }, +            synchronized (lock) {]