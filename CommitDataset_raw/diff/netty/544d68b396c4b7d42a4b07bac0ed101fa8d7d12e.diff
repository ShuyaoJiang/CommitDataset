[+++ b/transport/src/main/java/io/netty/channel/nio/AbstractNioByteChannel.java, +        private void removeReadOp() {, +            SelectionKey key = selectionKey();, +        private void closeOnRead(ChannelPipeline pipeline) {, +            SelectionKey key = selectionKey();, +, +        private void handleReadException(ChannelPipeline pipeline, ByteBuf byteBuf, Throwable cause, boolean close) {, +            if (byteBuf != null) {, +                if (byteBuf.isReadable()) {, +                    pipeline.fireChannelRead(byteBuf);, +                } else {, +                    byteBuf.release();, +                }, +            }, +            pipeline.fireChannelReadComplete();, +            if (close || cause instanceof IOException) {, +                closeOnRead(pipeline);, +            }, +        }, +, +        @Override, +        public void read() {, +            final ChannelConfig config = config();, +            final ChannelPipeline pipeline = pipeline();, +            final ByteBufAllocator allocator = config.getAllocator();, +            final int maxMessagesPerRead = config.getMaxMessagesPerRead();, +            RecvByteBufAllocator.Handle allocHandle = this.allocHandle;, +            if (allocHandle == null) {, +                this.allocHandle = allocHandle = config.getRecvByteBufAllocator().newHandle();, +            }, +            if (!config.isAutoRead()) {, +                removeReadOp();, +            }, +, +            ByteBuf byteBuf = null;, +            int messages = 0;, +            boolean close = false;, +            try {, +                do {, +                    byteBuf = allocHandle.allocate(allocator);, +                    int localReadAmount = doReadBytes(byteBuf);, +                    if (localReadAmount <= 0) {, +                        close = localReadAmount < 0;, +                        break;, +                    }, +                    pipeline.fireChannelRead(byteBuf);, +                    byteBuf = null;, +                    allocHandle.record(localReadAmount);, +                } while (++ messages < maxMessagesPerRead);, +, +                pipeline.fireChannelReadComplete();, +, +                if (close) {, +                    closeOnRead(pipeline);, +                    close = false;, +                }, +            } catch (Throwable t) {, +                handleReadException(pipeline, byteBuf, t, close);]