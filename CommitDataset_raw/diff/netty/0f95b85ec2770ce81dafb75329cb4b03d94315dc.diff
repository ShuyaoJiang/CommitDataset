[+++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslEngine.java, +    private final OpenSslSession session;, +        session = new OpenSslSession(ssl, sessionContext);, +        if (isDestroyed()) {, +        if (isDestroyed()) {, +        if (handshakeState != HandshakeState.NOT_STARTED && !isDestroyed()) {, +            if (!isDestroyed()) {, +            if (!isDestroyed()) {, +            if (!isDestroyed()) {, +            if (!isDestroyed()) {, +        if (engineClosed || isDestroyed()) {, +        session.handshakeFinished();, +, +        return handshakeState != HandshakeState.NOT_STARTED && !isDestroyed(), +    private boolean isDestroyed() {, +        return destroyed != 0;, +    }, +, +        private final OpenSslSessionContext sessionContext;, +        private final long creationTime;, +, +        // These are guarded by synchronized(OpenSslEngine.this) as handshakeFinished() may be triggered by any, +        // thread., +        private String protocol;, +        private String applicationProtocol;, +        private Certificate[] peerCerts;, +        private String cipher;, +        private byte[] id;, +        OpenSslSession(long ssl, OpenSslSessionContext sessionContext) {, +            creationTime = SSL.getTime(ssl) * 1000L;, +            this.sessionContext = sessionContext;, +        }, +, +                    return EmptyArrays.EMPTY_BYTES;, +                return id.clone();, +            }, +            return creationTime;, +        /**, +         * Finish the handshake and so init everything in the {@link OpenSslSession} that should be accessable by, +         * the user., +         */, +        void handshakeFinished() throws SSLException {, +            synchronized (OpenSslEngine.this) {, +                if (!isDestroyed()) {, +                    id = SSL.getSessionId(ssl);, +                    cipher = toJavaCipherSuite(SSL.getCipherForSSL(ssl));, +                    protocol = SSL.getVersion(ssl);, +, +                    initPeerCerts();, +                    selectApplicationProtocol();, +, +                    handshakeState = HandshakeState.FINISHED;, +                } else {, +                    throw new SSLException("Already closed");, +                }, +            }, +        }, +, +        /**, +         * Init peer certificates that can be obtained via {@link #getPeerCertificateChain()}, +         * and {@link #getPeerCertificates()}., +         */, +        private void initPeerCerts() {, +            // Return the full chain from the JNI layer., +            byte[][] chain = SSL.getPeerCertChain(ssl);, +            final byte[] clientCert;, +            if (!clientMode) {, +                // if used on the server side SSL_get_peer_cert_chain(...) will not include the remote peer, +                // certificate. We use SSL_get_peer_certificate to get it in this case and add it to our, +                // array later., +                //, +                // See https://www.openssl.org/docs/ssl/SSL_get_peer_cert_chain.html, +                clientCert = SSL.getPeerCertificate(ssl);, +            } else {, +                clientCert = null;, +            }, +, +            if (chain == null && clientCert == null) {, +                peerCerts = EMPTY_CERTIFICATES;, +                x509PeerCerts = EMPTY_X509_CERTIFICATES;, +            } else {, +                int len = chain != null ? chain.length : 0;, +, +                int i = 0;, +                Certificate[] peerCerts;, +                if (clientCert != null) {, +                    len++;, +                    peerCerts = new Certificate[len];, +                    peerCerts[i++] = new OpenSslX509Certificate(clientCert);, +                } else {, +                    peerCerts = new Certificate[len];, +                }, +                if (chain != null) {, +                    X509Certificate[] pCerts = new X509Certificate[chain.length];, +, +                    for (int a = 0; a < pCerts.length; ++i, ++a) {, +                        byte[] bytes = chain[a];, +                        pCerts[a] = new OpenSslJavaxX509Certificate(bytes);, +                        peerCerts[i] = new OpenSslX509Certificate(bytes);, +                    }]