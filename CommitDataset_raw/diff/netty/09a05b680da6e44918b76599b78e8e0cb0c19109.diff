[+++ b/buffer/src/main/java/io/netty/buffer/PoolThreadCache.java, +                    int maxCachedBufferCapacity, int freeSweepAllocationThreshold,, +                    boolean useThreadDeathWatcher) {, +        // Only check if there are caches in use., +        if ((tinySubPageDirectCaches != null || smallSubPageDirectCaches != null || normalDirectCaches != null, +                || tinySubPageHeapCaches != null || smallSubPageHeapCaches != null || normalHeapCaches != null), +                && freeSweepAllocationThreshold < 1) {, +, +        if (useThreadDeathWatcher) {, +, +++ b/buffer/src/main/java/io/netty/buffer/PoolThreadCache.java, +                    int maxCachedBufferCapacity, int freeSweepAllocationThreshold,, +                    boolean useThreadDeathWatcher) {, +        // Only check if there are caches in use., +        if ((tinySubPageDirectCaches != null || smallSubPageDirectCaches != null || normalDirectCaches != null, +                || tinySubPageHeapCaches != null || smallSubPageHeapCaches != null || normalHeapCaches != null), +                && freeSweepAllocationThreshold < 1) {, +, +        if (useThreadDeathWatcher) {, +, +++ b/buffer/src/main/java/io/netty/buffer/PooledByteBufAllocator.java, +            Thread current = Thread.currentThread();, +            boolean fastThread = current instanceof FastThreadLocalThread;, +            if (useCacheForAllThreads || current instanceof FastThreadLocalThread) {, +                // If our FastThreadLocalThread will call FastThreadLocal.removeAll() we not need to use, +                // the ThreadDeathWatcher to release memory from the PoolThreadCache once the Thread dies., +                boolean useTheadWatcher = fastThread ?, +                        !((FastThreadLocalThread) current).willCleanupFastThreadLocals() : true;, +                        DEFAULT_MAX_CACHED_BUFFER_CAPACITY, DEFAULT_CACHE_TRIM_INTERVAL, useTheadWatcher);, +            return new PoolThreadCache(heapArena, directArena, 0, 0, 0, 0, 0, false);, +        PoolThreadCache cache =  threadCache.get();, +        assert cache != null;, +        return cache;, +++ b/buffer/src/main/java/io/netty/buffer/PoolThreadCache.java, +                    int maxCachedBufferCapacity, int freeSweepAllocationThreshold,, +                    boolean useThreadDeathWatcher) {, +        // Only check if there are caches in use., +        if ((tinySubPageDirectCaches != null || smallSubPageDirectCaches != null || normalDirectCaches != null, +                || tinySubPageHeapCaches != null || smallSubPageHeapCaches != null || normalHeapCaches != null), +                && freeSweepAllocationThreshold < 1) {, +, +        if (useThreadDeathWatcher) {, +, +++ b/buffer/src/main/java/io/netty/buffer/PooledByteBufAllocator.java, +            Thread current = Thread.currentThread();, +            boolean fastThread = current instanceof FastThreadLocalThread;, +            if (useCacheForAllThreads || current instanceof FastThreadLocalThread) {, +                // If our FastThreadLocalThread will call FastThreadLocal.removeAll() we not need to use, +                // the ThreadDeathWatcher to release memory from the PoolThreadCache once the Thread dies., +                boolean useTheadWatcher = fastThread ?, +                        !((FastThreadLocalThread) current).willCleanupFastThreadLocals() : true;, +                        DEFAULT_MAX_CACHED_BUFFER_CAPACITY, DEFAULT_CACHE_TRIM_INTERVAL, useTheadWatcher);, +            return new PoolThreadCache(heapArena, directArena, 0, 0, 0, 0, 0, false);, +        PoolThreadCache cache =  threadCache.get();, +        assert cache != null;, +        return cache;, +++ b/buffer/src/test/java/io/netty/buffer/PooledByteBufAllocatorTest.java, +    @Test (timeout = 4000), +    public void testThreadCacheDestroyedByThreadDeathWatcher() throws InterruptedException {, +        testThreadCacheDestroyedByThreadDeathWatcher(false);, +    }, +, +    @Test (timeout = 4000), +    public void testThreadCacheDestroyedAfterExitRun() throws InterruptedException {, +        testThreadCacheDestroyedByThreadDeathWatcher(true);, +    }, +, +    private static void testThreadCacheDestroyedByThreadDeathWatcher(boolean useRunnable) throws InterruptedException {, +        final CountDownLatch latch = new CountDownLatch(numArenas);, +        final Runnable task = new Runnable() {, +                try {, +                } finally {, +                    latch.countDown();, +        };, +, +        for (int i = 0; i < numArenas; i++) {, +            final FastThreadLocalThread thread;, +            if (useRunnable) {, +                thread = new FastThreadLocalThread(task);, +                assertTrue(thread.willCleanupFastThreadLocals());, +            } else {, +                thread = new FastThreadLocalThread() {, +                    @Override, +                    public void run() {, +                        task.run();, +                    }, +                };, +                assertFalse(thread.willCleanupFastThreadLocals());, +            }, +            thread.start();, +        }, +, +        latch.await();, +++ b/buffer/src/main/java/io/netty/buffer/PoolThreadCache.java, +                    int maxCachedBufferCapacity, int freeSweepAllocationThreshold,, +                    boolean useThreadDeathWatcher) {, +        // Only check if there are caches in use., +        if ((tinySubPageDirectCaches != null || smallSubPageDirectCaches != null || normalDirectCaches != null, +                || tinySubPageHeapCaches != null || smallSubPageHeapCaches != null || normalHeapCaches != null), +                && freeSweepAllocationThreshold < 1) {]