[+++ b/transport/src/main/java/io/netty/channel/AbstractChannelHandlerContext.java, +    final boolean setAddComplete() {, +            if (oldState == REMOVE_COMPLETE) {, +                return false;, +            }, +            if (HANDLER_STATE_UPDATER.compareAndSet(this, oldState, ADD_COMPLETE)) {, +                return true;, +    final void callHandlerAdded() throws Exception {, +        // We must call setAddComplete before calling handlerAdded. Otherwise if the handlerAdded method generates, +        // any pipeline events ctx.handler() will miss them because the state will not allow it., +        if (setAddComplete()) {, +            handler().handlerAdded(this);, +        }, +    }, +, +    final void callHandlerRemoved() throws Exception {, +        try {, +            // Only call handlerRemoved(...) if we called handlerAdded(...) before., +            if (handlerState == ADD_COMPLETE) {, +                handler().handlerRemoved(this);, +            }, +        } finally {, +            // Mark the handler as removed in any case., +            setRemoved();, +        }, +    }, +, +++ b/transport/src/main/java/io/netty/channel/AbstractChannelHandlerContext.java, +    final boolean setAddComplete() {, +            if (oldState == REMOVE_COMPLETE) {, +                return false;, +            }, +            if (HANDLER_STATE_UPDATER.compareAndSet(this, oldState, ADD_COMPLETE)) {, +                return true;, +    final void callHandlerAdded() throws Exception {, +        // We must call setAddComplete before calling handlerAdded. Otherwise if the handlerAdded method generates, +        // any pipeline events ctx.handler() will miss them because the state will not allow it., +        if (setAddComplete()) {, +            handler().handlerAdded(this);, +        }, +    }, +, +    final void callHandlerRemoved() throws Exception {, +        try {, +            // Only call handlerRemoved(...) if we called handlerAdded(...) before., +            if (handlerState == ADD_COMPLETE) {, +                handler().handlerRemoved(this);, +            }, +        } finally {, +            // Mark the handler as removed in any case., +            setRemoved();, +        }, +    }, +, +++ b/transport/src/main/java/io/netty/channel/DefaultChannelPipeline.java, +            ctx.callHandlerAdded();, +                ctx.callHandlerRemoved();, +            ctx.callHandlerRemoved();, +++ b/transport/src/main/java/io/netty/channel/AbstractChannelHandlerContext.java, +    final boolean setAddComplete() {, +            if (oldState == REMOVE_COMPLETE) {, +                return false;, +            }, +            if (HANDLER_STATE_UPDATER.compareAndSet(this, oldState, ADD_COMPLETE)) {, +                return true;, +    final void callHandlerAdded() throws Exception {, +        // We must call setAddComplete before calling handlerAdded. Otherwise if the handlerAdded method generates, +        // any pipeline events ctx.handler() will miss them because the state will not allow it., +        if (setAddComplete()) {, +            handler().handlerAdded(this);, +        }, +    }, +, +    final void callHandlerRemoved() throws Exception {, +        try {, +            // Only call handlerRemoved(...) if we called handlerAdded(...) before., +            if (handlerState == ADD_COMPLETE) {, +                handler().handlerRemoved(this);, +            }, +        } finally {, +            // Mark the handler as removed in any case., +            setRemoved();, +        }, +    }, +, +++ b/transport/src/main/java/io/netty/channel/DefaultChannelPipeline.java, +            ctx.callHandlerAdded();, +                ctx.callHandlerRemoved();, +            ctx.callHandlerRemoved();, +++ b/transport/src/test/java/io/netty/channel/DefaultChannelPipelineTest.java, +import io.netty.channel.local.LocalEventLoopGroup;, +    // Test for https://github.com/netty/netty/issues/8676., +    @Test, +    public void testHandlerRemovedOnlyCalledWhenHandlerAddedCalled() throws Exception {, +        EventLoopGroup group = new DefaultEventLoopGroup(1);, +        try {, +            final AtomicReference<Error> errorRef = new AtomicReference<Error>();, +, +            // As this only happens via a race we will verify 500 times. This was good enough to have it failed most of, +            // the time.]