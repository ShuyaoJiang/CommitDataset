[+++ b/example/src/main/java/io/netty/example/securechat/SecureChatClientHandler.java, +++ b/example/src/main/java/io/netty/example/securechat/SecureChatClientHandler.java, +++ b/example/src/main/java/io/netty/example/securechat/SecureChatServerHandler.java, +        // Once session is secured, send a greeting., +        ctx.write(, +                "Welcome to " + InetAddress.getLocalHost().getHostName() +, +                " secure chat service!\n");, +        ctx.write(, +                "Your session is protected by " +, +                ctx.pipeline().get(SslHandler.class).getEngine().getSession().getCipherSuite() +, +                " cipher suite.\n");, +        // Register the channel to the global channel list, +        // so the channel received the messages from others., +        channels.add(ctx.channel());, +++ b/example/src/main/java/io/netty/example/securechat/SecureChatClientHandler.java, +++ b/example/src/main/java/io/netty/example/securechat/SecureChatServerHandler.java, +        // Once session is secured, send a greeting., +        ctx.write(, +                "Welcome to " + InetAddress.getLocalHost().getHostName() +, +                " secure chat service!\n");, +        ctx.write(, +                "Your session is protected by " +, +                ctx.pipeline().get(SslHandler.class).getEngine().getSession().getCipherSuite() +, +                " cipher suite.\n");, +        // Register the channel to the global channel list, +        // so the channel received the messages from others., +        channels.add(ctx.channel());, +++ b/handler/pom.xml, +++ b/example/src/main/java/io/netty/example/securechat/SecureChatClientHandler.java, +++ b/example/src/main/java/io/netty/example/securechat/SecureChatServerHandler.java, +        // Once session is secured, send a greeting., +        ctx.write(, +                "Welcome to " + InetAddress.getLocalHost().getHostName() +, +                " secure chat service!\n");, +        ctx.write(, +                "Your session is protected by " +, +                ctx.pipeline().get(SslHandler.class).getEngine().getSession().getCipherSuite() +, +                " cipher suite.\n");, +        // Register the channel to the global channel list, +        // so the channel received the messages from others., +        channels.add(ctx.channel());, +++ b/handler/pom.xml, +++ b/handler/src/main/java/io/netty/handler/ssl/SslHandler.java, +import io.netty.channel.ChannelBufferHolder;, +import io.netty.channel.ChannelBufferHolders;, +import io.netty.channel.ChannelHandlerAdapter;, +import io.netty.channel.ChannelInboundHandler;, +import io.netty.channel.ChannelOutboundHandler;, +import java.util.ArrayDeque;, +import java.util.Queue;, +import java.util.concurrent.ScheduledFuture;, +import java.util.concurrent.TimeUnit;, +public class SslHandler, +        extends ChannelHandlerAdapter, +        implements ChannelInboundHandler<Byte>, ChannelOutboundHandler<Byte> {, +    private volatile ChannelHandlerContext ctx;, +    private final Queue<ChannelFuture> handshakeFutures = new ArrayDeque<ChannelFuture>();, +    private final SSLEngineInboundCloseFuture sslCloseFuture = new SSLEngineInboundCloseFuture();, +        this(engine, ImmediateExecutor.INSTANCE);, +        this(engine, startTls, ImmediateExecutor.INSTANCE);, +        this(engine, false, delegatedTaskExecutor);, +    public ChannelFuture handshake() {, +        return handshake(ctx.newFuture());, +    }, +, +    public ChannelFuture handshake(final ChannelFuture future) {, +        final ChannelHandlerContext ctx = this.ctx;, +        ctx.executor().schedule(new Runnable() {, +                if (future.isDone()) {, +                    return;, +                }, +, +                SSLException e = new SSLException("handshake timed out");, +                future.setFailure(e);, +                ctx.fireExceptionCaught(e);, +                ctx.close();, +            }, +        }, 10, TimeUnit.SECONDS); // FIXME: Magic value, +        ctx.executor().execute(new Runnable() {, +            @Override, +            public void run() {, +                    handshakeFutures.add(future);, +                    flush(ctx, ctx.newFuture());, +                    future.setFailure(e);, +                    ctx.fireExceptionCaught(e);, +        return future;, +        return close(ctx.newFuture());, +    }, +, +    public ChannelFuture close(final ChannelFuture future) {, +        final ChannelHandlerContext ctx = this.ctx;, +        ctx.executor().execute(new Runnable() {, +            @Override, +            public void run() {, +                ctx.flush(future);, +        });, +        return future;, +    public ChannelFuture sslCloseFuture() {, +        return sslCloseFuture;, +    }]