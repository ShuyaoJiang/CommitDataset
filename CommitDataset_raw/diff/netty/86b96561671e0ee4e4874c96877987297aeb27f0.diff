[+++ b/transport/src/main/java/io/netty/channel/embedded/EmbeddedChannel.java, +import io.netty.channel.ChannelFutureListener;, +    private final ChannelFutureListener recordExceptionListener = new ChannelFutureListener() {, +        @Override, +        public void operationComplete(ChannelFuture future) throws Exception {, +            recordException(future);, +        }, +    };, +, +            // We need to call runPendingTasks first as a ChannelOutboundHandler may used eventloop.execute(...) to, +            // delay the write on the next eventloop run., +            runPendingTasks();, +                if (future.isDone()) {, +                    recordException(future);, +                } else {, +                    // The write may be delayed to run later by runPendingTasks(), +                    future.addListener(recordExceptionListener);, +        // We need to call runPendingTasks() before calling super.close() as there may be something in the queue, +        // that needs to be run before the actual close takes place., +        runPendingTasks();, +, +        // Now finish everything else and cancel all scheduled tasks that were not ready set., +    private void recordException(ChannelFuture future) {, +        if (!future.isSuccess()) {, +            recordException(future.cause());, +        }, +    }, +, +++ b/transport/src/main/java/io/netty/channel/embedded/EmbeddedChannel.java, +import io.netty.channel.ChannelFutureListener;, +    private final ChannelFutureListener recordExceptionListener = new ChannelFutureListener() {, +        @Override, +        public void operationComplete(ChannelFuture future) throws Exception {, +            recordException(future);, +        }, +    };, +, +            // We need to call runPendingTasks first as a ChannelOutboundHandler may used eventloop.execute(...) to, +            // delay the write on the next eventloop run., +            runPendingTasks();, +                if (future.isDone()) {, +                    recordException(future);, +                } else {, +                    // The write may be delayed to run later by runPendingTasks(), +                    future.addListener(recordExceptionListener);, +        // We need to call runPendingTasks() before calling super.close() as there may be something in the queue, +        // that needs to be run before the actual close takes place., +        runPendingTasks();, +, +        // Now finish everything else and cancel all scheduled tasks that were not ready set., +    private void recordException(ChannelFuture future) {, +        if (!future.isSuccess()) {, +            recordException(future.cause());, +        }, +    }, +, +++ b/transport/src/test/java/io/netty/channel/embedded/EmbeddedChannelTest.java, +    @Test, +    public void testWriteLater() {, +        EmbeddedChannel channel = new EmbeddedChannel(new ChannelOutboundHandlerAdapter() {, +            @Override, +            public void write(final ChannelHandlerContext ctx, final Object msg, final ChannelPromise promise), +                    throws Exception {, +                ctx.executor().execute(new Runnable() {, +                    @Override, +                    public void run() {, +                        ctx.write(msg, promise);, +                    }, +                });, +            }, +        });, +        Object msg = new Object();, +, +        assertTrue(channel.writeOutbound(msg));, +        assertTrue(channel.finish());, +        assertSame(msg, channel.readOutbound());, +        assertNull(channel.readOutbound());, +    }, +, +    @Test, +    public void testWriteScheduled() throws InterruptedException  {, +        final int delay = 500;, +        EmbeddedChannel channel = new EmbeddedChannel(new ChannelOutboundHandlerAdapter() {, +            @Override, +            public void write(final ChannelHandlerContext ctx, final Object msg, final ChannelPromise promise), +                    throws Exception {, +                ctx.executor().schedule(new Runnable() {, +                    @Override, +                    public void run() {, +                        ctx.writeAndFlush(msg, promise);, +                    }, +                }, delay, TimeUnit.MILLISECONDS);, +            }, +        });, +        Object msg = new Object();, +, +        assertFalse(channel.writeOutbound(msg));, +        Thread.sleep(delay  * 2);, +        assertTrue(channel.finish());, +        assertSame(msg, channel.readOutbound());]