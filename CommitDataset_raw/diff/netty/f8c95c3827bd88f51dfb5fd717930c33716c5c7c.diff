[+++ b/transport/src/main/java/io/netty/bootstrap/AbstractBootstrap.java, +            // as the Channel is not registered yet we need to force the usage of the GlobalEventExecutor, +            return new DefaultChannelPromise(channel, GlobalEventExecutor.INSTANCE).setFailure(t);, +            if (channel().isRegistered()) {, +                //, +                // See https://github.com/netty/netty/issues/2586, +++ b/transport/src/main/java/io/netty/bootstrap/AbstractBootstrap.java, +            // as the Channel is not registered yet we need to force the usage of the GlobalEventExecutor, +            return new DefaultChannelPromise(channel, GlobalEventExecutor.INSTANCE).setFailure(t);, +            if (channel().isRegistered()) {, +                //, +                // See https://github.com/netty/netty/issues/2586, +++ b/transport/src/test/java/io/netty/bootstrap/BootstrapTest.java, +import io.netty.channel.ServerChannel;, +import java.net.SocketAddress;, +import java.net.SocketException;, +                    queue.add(future.isSuccess());, +            Assert.assertTrue(queue.take());, +    public void testLateRegisterSuccessBindFailed() throws Exception {, +        TestEventLoopGroup group = new TestEventLoopGroup();, +            bootstrap.channelFactory(new ChannelFactory<ServerChannel>() {, +                @Override, +                public ServerChannel newChannel() {, +                    return new LocalServerChannel() {, +                        @Override, +                        public ChannelFuture bind(SocketAddress localAddress) {, +                            return newFailedFuture(new SocketException());, +                        }, +, +                        @Override, +                        public ChannelFuture bind(SocketAddress localAddress, ChannelPromise promise) {, +                            return promise.setFailure(new SocketException());, +                        }, +                    };, +                }, +            });, +            group.promise.setSuccess();, +                    queue.add(future.channel().eventLoop().inEventLoop(Thread.currentThread()));, +                    queue.add(future.isSuccess());, +            Assert.assertTrue(queue.take());, +        public ChannelFuture register(Channel channel, final ChannelPromise promise) {]