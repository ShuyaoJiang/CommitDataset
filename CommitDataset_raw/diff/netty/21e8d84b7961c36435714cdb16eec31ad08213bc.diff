[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2HeadersDecoder.java, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2HeadersDecoder.java, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/internal/hpack/Decoder.java, +import io.netty.handler.codec.http2.Http2Exception;, +import static io.netty.handler.codec.http2.Http2Error.COMPRESSION_ERROR;, +import static io.netty.handler.codec.http2.Http2Error.ENHANCE_YOUR_CALM;, +import static io.netty.handler.codec.http2.Http2Exception.connectionError;, +import static io.netty.util.internal.ThrowableUtil.unknownStackTrace;, +    private static final Http2Exception DECODE_DECOMPRESSION_EXCEPTION = unknownStackTrace(, +            connectionError(COMPRESSION_ERROR, "HPACK - decompression failure"), Decoder.class, "decode(...)");, +    private static final Http2Exception DECODE_ULE_128_DECOMPRESSION_EXCEPTION = unknownStackTrace(, +            connectionError(COMPRESSION_ERROR, "HPACK - decompression failure"), Decoder.class, "decodeULE128(...)");, +    private static final Http2Exception DECODE_ILLEGAL_INDEX_VALUE = unknownStackTrace(, +            connectionError(COMPRESSION_ERROR, "HPACK - illegal index value"), Decoder.class, "decode(...)");, +    private static final Http2Exception INDEX_HEADER_ILLEGAL_INDEX_VALUE = unknownStackTrace(, +            connectionError(COMPRESSION_ERROR, "HPACK - illegal index value"), Decoder.class, "indexHeader(...)");, +    private static final Http2Exception READ_NAME_ILLEGAL_INDEX_VALUE = unknownStackTrace(, +            connectionError(COMPRESSION_ERROR, "HPACK - illegal index value"), Decoder.class, "readName(...)");, +    private static final Http2Exception INVALID_MAX_DYNAMIC_TABLE_SIZE = unknownStackTrace(, +            connectionError(COMPRESSION_ERROR, "HPACK - invalid max dynamic table size"), Decoder.class,, +            "setDynamicTableSize(...)");, +    private static final Http2Exception MAX_DYNAMIC_TABLE_SIZE_CHANGE_REQUIRED = unknownStackTrace(, +            connectionError(COMPRESSION_ERROR, "HPACK - max dynamic table size change required"), Decoder.class,, +            "decode(...)");, +    private static final byte READ_HEADER_REPRESENTATION = 0;, +    private static final byte READ_MAX_DYNAMIC_TABLE_SIZE = 1;, +    private static final byte READ_INDEXED_HEADER = 2;, +    private static final byte READ_INDEXED_HEADER_NAME = 3;, +    private static final byte READ_LITERAL_HEADER_NAME_LENGTH_PREFIX = 4;, +    private static final byte READ_LITERAL_HEADER_NAME_LENGTH = 5;, +    private static final byte READ_LITERAL_HEADER_NAME = 6;, +    private static final byte READ_LITERAL_HEADER_VALUE_LENGTH_PREFIX = 7;, +    private static final byte READ_LITERAL_HEADER_VALUE_LENGTH = 8;, +    private static final byte READ_LITERAL_HEADER_VALUE = 9;, +    private final int maxHeadersLength;, +     * Create a new instance., +     * @param maxHeadersLength The maximum size (in bytes) that is allowed for a single header decode operation., +     * @param maxHeaderTableSize, +     * <a href="https://tools.ietf.org/html/rfc7540#section-6.5.2">SETTINGS_HEADER_TABLE_SIZE</a>., +     * @param initialHuffmanDecodeCapacity The initial size of the byte array used to do huffman decoding., +    public Decoder(int maxHeadersLength, int maxHeaderTableSize, int initialHuffmanDecodeCapacity) {, +        this.maxHeadersLength = maxHeadersLength;, +     * <p>, +     * This method assumes the entire header block is contained in {@code in}., +    public void decode(ByteBuf in, Http2Headers headers) throws Http2Exception {, +        int index = 0;, +        int headersLength = 0;, +        int nameLength = 0;, +        int valueLength = 0;, +        byte state = READ_HEADER_REPRESENTATION;, +        boolean huffmanEncoded = false;, +        CharSequence name = null;, +        IndexType indexType = IndexType.NONE;, +                        switch (index) {, +                            case 0:, +                            case 0x7F:, +                                state = READ_INDEXED_HEADER;, +                                break;, +                            default:, +                                headersLength = indexHeader(index, headers, headersLength);, +                        switch (index) {, +                            case 0:, +                                state = READ_LITERAL_HEADER_NAME_LENGTH_PREFIX;, +                                break;, +                            case 0x3F:, +                                state = READ_INDEXED_HEADER_NAME;, +                                break;, +                            default:, +                                name = readName(index);, +                                state = READ_LITERAL_HEADER_VALUE_LENGTH_PREFIX;, +                            state = READ_MAX_DYNAMIC_TABLE_SIZE;, +                            state = READ_HEADER_REPRESENTATION;, +                        switch (index) {, +                            case 0:, +                                state = READ_LITERAL_HEADER_NAME_LENGTH_PREFIX;, +                                break;, +                            case 0x0F:, +                                state = READ_INDEXED_HEADER_NAME;, +                                break;, +                            default:, +                            name = readName(index);, +                            state = READ_LITERAL_HEADER_VALUE_LENGTH_PREFIX;, +                    int maxSize = decodeULE128(in) + index;, +                    if (maxSize < 0) { // Check for numerical overflow, +                    setDynamicTableSize(maxSize);, +                    state = READ_HEADER_REPRESENTATION;, +                    int headerIndex = decodeULE128(in) + index;, +                    if (headerIndex < 0) { // Check for numerical overflow, +                    headersLength = indexHeader(headerIndex, headers, headersLength);, +                    state = READ_HEADER_REPRESENTATION;, +                    int nameIndex = decodeULE128(in) + index;, +                    if (nameIndex < 0) { // Check for numerical overflow, +                    name = readName(nameIndex);, +                    state = READ_LITERAL_HEADER_VALUE_LENGTH_PREFIX;, +                        state = READ_LITERAL_HEADER_NAME_LENGTH;, +                        if (nameLength > maxHeadersLength - headersLength) {, +                            maxHeaderSizeExceeded();, +                        }, +                        state = READ_LITERAL_HEADER_NAME;, +                    nameLength = decodeULE128(in) + index;]