[+++ b/common/src/main/java/io/netty/util/ThreadDeathWatcher.java, +    // visible for testing, +    static final ThreadFactory threadFactory;, +        // because the ThreadDeathWatcher is a singleton, tasks submitted to it can come from arbitrary threads and, +        // this can trigger the creation of a thread from arbitrary thread groups; for this reason, the thread factory, +        // must not be sticky about its thread group, +        threadFactory = new DefaultThreadFactory(poolName, true, Thread.MIN_PRIORITY, null);, +++ b/common/src/main/java/io/netty/util/ThreadDeathWatcher.java, +    // visible for testing, +    static final ThreadFactory threadFactory;, +        // because the ThreadDeathWatcher is a singleton, tasks submitted to it can come from arbitrary threads and, +        // this can trigger the creation of a thread from arbitrary thread groups; for this reason, the thread factory, +        // must not be sticky about its thread group, +        threadFactory = new DefaultThreadFactory(poolName, true, Thread.MIN_PRIORITY, null);, +++ b/common/src/main/java/io/netty/util/concurrent/DefaultThreadFactory.java, +    public static String toPoolName(Class<?> poolType) {, +        this.threadGroup = threadGroup;, +        this(poolName, daemon, priority, System.getSecurityManager() == null ?, +                Thread.currentThread().getThreadGroup() : System.getSecurityManager().getThreadGroup());, +++ b/common/src/main/java/io/netty/util/ThreadDeathWatcher.java, +    // visible for testing, +    static final ThreadFactory threadFactory;, +        // because the ThreadDeathWatcher is a singleton, tasks submitted to it can come from arbitrary threads and, +        // this can trigger the creation of a thread from arbitrary thread groups; for this reason, the thread factory, +        // must not be sticky about its thread group, +        threadFactory = new DefaultThreadFactory(poolName, true, Thread.MIN_PRIORITY, null);, +++ b/common/src/main/java/io/netty/util/concurrent/DefaultThreadFactory.java, +    public static String toPoolName(Class<?> poolType) {, +        this.threadGroup = threadGroup;, +        this(poolName, daemon, priority, System.getSecurityManager() == null ?, +                Thread.currentThread().getThreadGroup() : System.getSecurityManager().getThreadGroup());, +++ b/common/src/main/java/io/netty/util/concurrent/GlobalEventExecutor.java, +    // because the GlobalEventExecutor is a singleton, tasks submitted to it can come from arbitrary threads and this, +    // can trigger the creation of a thread from arbitrary thread groups; for this reason, the thread factory must not, +    // be sticky about its thread group, +    // visible for testing, +    final ThreadFactory threadFactory =, +            new DefaultThreadFactory(DefaultThreadFactory.toPoolName(getClass()), false, Thread.NORM_PRIORITY, null);, +++ b/common/src/main/java/io/netty/util/ThreadDeathWatcher.java, +    // visible for testing, +    static final ThreadFactory threadFactory;, +        // because the ThreadDeathWatcher is a singleton, tasks submitted to it can come from arbitrary threads and, +        // this can trigger the creation of a thread from arbitrary thread groups; for this reason, the thread factory, +        // must not be sticky about its thread group, +        threadFactory = new DefaultThreadFactory(poolName, true, Thread.MIN_PRIORITY, null);, +++ b/common/src/main/java/io/netty/util/concurrent/DefaultThreadFactory.java, +    public static String toPoolName(Class<?> poolType) {, +        this.threadGroup = threadGroup;, +        this(poolName, daemon, priority, System.getSecurityManager() == null ?, +                Thread.currentThread().getThreadGroup() : System.getSecurityManager().getThreadGroup());, +++ b/common/src/main/java/io/netty/util/concurrent/GlobalEventExecutor.java, +    // because the GlobalEventExecutor is a singleton, tasks submitted to it can come from arbitrary threads and this, +    // can trigger the creation of a thread from arbitrary thread groups; for this reason, the thread factory must not, +    // be sticky about its thread group, +    // visible for testing, +    final ThreadFactory threadFactory =, +            new DefaultThreadFactory(DefaultThreadFactory.toPoolName(getClass()), false, Thread.NORM_PRIORITY, null);, +++ b/common/src/test/java/io/netty/util/ThreadDeathWatcherTest.java, +import java.util.concurrent.atomic.AtomicReference;, +import static org.hamcrest.CoreMatchers.is;, +import static org.junit.Assert.assertEquals;, +import static org.junit.Assert.assertThat;, +import static org.junit.Assert.fail;, +, +    @Test(timeout = 2000), +    public void testThreadGroup() throws InterruptedException {, +        final ThreadGroup group = new ThreadGroup("group");, +        final AtomicReference<ThreadGroup> capturedGroup = new AtomicReference<ThreadGroup>();, +        final Thread thread = new Thread(group, new Runnable() {, +            @Override, +            public void run() {, +                final Thread t = ThreadDeathWatcher.threadFactory.newThread(new Runnable() {, +                    @Override, +                    public void run() {, +                    }, +                });, +                capturedGroup.set(t.getThreadGroup());, +            }, +        });, +        thread.start();, +        thread.join();, +, +        assertEquals(group, capturedGroup.get());, +    }, +++ b/common/src/main/java/io/netty/util/ThreadDeathWatcher.java, +    // visible for testing, +    static final ThreadFactory threadFactory;, +        // because the ThreadDeathWatcher is a singleton, tasks submitted to it can come from arbitrary threads and, +        // this can trigger the creation of a thread from arbitrary thread groups; for this reason, the thread factory, +        // must not be sticky about its thread group, +        threadFactory = new DefaultThreadFactory(poolName, true, Thread.MIN_PRIORITY, null);, +++ b/common/src/main/java/io/netty/util/concurrent/DefaultThreadFactory.java, +    public static String toPoolName(Class<?> poolType) {, +        this.threadGroup = threadGroup;, +        this(poolName, daemon, priority, System.getSecurityManager() == null ?, +                Thread.currentThread().getThreadGroup() : System.getSecurityManager().getThreadGroup());, +++ b/common/src/main/java/io/netty/util/concurrent/GlobalEventExecutor.java, +    // because the GlobalEventExecutor is a singleton, tasks submitted to it can come from arbitrary threads and this, +    // can trigger the creation of a thread from arbitrary thread groups; for this reason, the thread factory must not, +    // be sticky about its thread group]