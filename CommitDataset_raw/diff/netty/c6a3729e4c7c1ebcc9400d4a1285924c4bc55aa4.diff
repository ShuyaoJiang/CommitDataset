[+++ b/transport/src/main/java/io/netty/channel/AbstractChannel.java, +    private final DefaultChannelPipeline pipeline;, +, +                if (firstRegistration) {, +                    // We are now registered to the EventLoop. It's time to call the callbacks for the ChannelHandlers,, +                    // that were added before the registration was done., +                    pipeline.callHandlerAddedForAllHandlers();, +                }, +, +++ b/transport/src/main/java/io/netty/channel/AbstractChannel.java, +    private final DefaultChannelPipeline pipeline;, +, +                if (firstRegistration) {, +                    // We are now registered to the EventLoop. It's time to call the callbacks for the ChannelHandlers,, +                    // that were added before the registration was done., +                    pipeline.callHandlerAddedForAllHandlers();, +                }, +, +++ b/transport/src/main/java/io/netty/channel/AbstractChannelHandlerContext.java, +        invoker().invokeChannelRegistered(this);, +        invoker().invokeChannelUnregistered(this);, +        invoker().invokeChannelActive(this);, +        invoker().invokeChannelInactive(this);, +        invoker().invokeExceptionCaught(this, cause);, +        invoker().invokeUserEventTriggered(this, event);, +        invoker().invokeChannelRead(this, msg);, +        invoker().invokeChannelReadComplete(this);, +        invoker().invokeChannelWritabilityChanged(this);, +        invoker().invokeBind(this, localAddress, promise);, +        invoker().invokeConnect(this, remoteAddress, localAddress, promise);, +        invoker().invokeDisconnect(this, promise);, +        invoker().invokeClose(this, promise);, +        invoker().invokeDeregister(this, promise);, +        invoker().invokeRead(this);, +        invoker().invokeWrite(this, msg, promise);, +        invoker().invokeFlush(this);, +++ b/transport/src/main/java/io/netty/channel/AbstractChannel.java, +    private final DefaultChannelPipeline pipeline;, +, +                if (firstRegistration) {, +                    // We are now registered to the EventLoop. It's time to call the callbacks for the ChannelHandlers,, +                    // that were added before the registration was done., +                    pipeline.callHandlerAddedForAllHandlers();, +                }, +, +++ b/transport/src/main/java/io/netty/channel/AbstractChannelHandlerContext.java, +        invoker().invokeChannelRegistered(this);, +        invoker().invokeChannelUnregistered(this);, +        invoker().invokeChannelActive(this);, +        invoker().invokeChannelInactive(this);, +        invoker().invokeExceptionCaught(this, cause);, +        invoker().invokeUserEventTriggered(this, event);, +        invoker().invokeChannelRead(this, msg);, +        invoker().invokeChannelReadComplete(this);, +        invoker().invokeChannelWritabilityChanged(this);, +        invoker().invokeBind(this, localAddress, promise);, +        invoker().invokeConnect(this, remoteAddress, localAddress, promise);, +        invoker().invokeDisconnect(this, promise);, +        invoker().invokeClose(this, promise);, +        invoker().invokeDeregister(this, promise);, +        invoker().invokeRead(this);, +        invoker().invokeWrite(this, msg, promise);, +        invoker().invokeFlush(this);, +++ b/transport/src/main/java/io/netty/channel/DefaultChannelPipeline.java, +import java.util.concurrent.RejectedExecutionException;, +    /**, +     * This is the head of a linked list that is processed by {@link #callHandlerAddedForAllHandlers()} and so process, +     * all the pending {@link #callHandlerAdded0(AbstractChannelHandlerContext)}., +     *, +     * We only keep the head because it is expected that the list is used infrequently and its size is small., +     * Thus full iterations to do insertions is assumed to be a good compromised to saving memory and tail management, +     * complexity., +     */, +    private PendingHandlerCallback pendingHandlerCallbackHead;, +, +    /**, +     * Set to {@code true} once the {@link AbstractChannel} is registered.Once set to {@code true} the value will never, +     * change., +     */, +    private boolean registered;, +, +        return addFirst(null, null, name, handler);, +    public ChannelPipeline addFirst(EventExecutorGroup group, String name, ChannelHandler handler) {, +        return addFirst(group, null, name, handler);, +    }, +, +    @Override, +    public ChannelPipeline addFirst(ChannelHandlerInvoker invoker, String name, ChannelHandler handler) {, +        return addFirst(null, invoker, name, handler);, +    }, +, +    private ChannelPipeline addFirst(, +            EventExecutorGroup group, ChannelHandlerInvoker invoker, String name, ChannelHandler handler) {, +        final AbstractChannelHandlerContext newCtx;, +        final EventExecutor executor;, +        final boolean inEventLoop;, +        synchronized (this) {, +            checkMultiplicity(handler);, +, +            if (group != null) {]