[+++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBufAllocator.java, +    protected AbstractByteBufAllocator() {, +        this(false);, +    protected AbstractByteBufAllocator(boolean directByDefault) {, +        return heapBuffer(256, Integer.MAX_VALUE);, +        return heapBuffer(initialCapacity, Integer.MAX_VALUE);, +        return directBuffer(256, Integer.MAX_VALUE);, +        return directBuffer(initialCapacity, Integer.MAX_VALUE);, +    private static void validate(int initialCapacity, int maxCapacity) {, +        if (initialCapacity < 0) {, +            throw new IllegalArgumentException("initialCapacity: " + initialCapacity + " (expectd: 0+)");, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBufAllocator.java, +    protected AbstractByteBufAllocator() {, +        this(false);, +    protected AbstractByteBufAllocator(boolean directByDefault) {, +        return heapBuffer(256, Integer.MAX_VALUE);, +        return heapBuffer(initialCapacity, Integer.MAX_VALUE);, +        return directBuffer(256, Integer.MAX_VALUE);, +        return directBuffer(initialCapacity, Integer.MAX_VALUE);, +    private static void validate(int initialCapacity, int maxCapacity) {, +        if (initialCapacity < 0) {, +            throw new IllegalArgumentException("initialCapacity: " + initialCapacity + " (expectd: 0+)");, +++ b/buffer/src/main/java/io/netty/buffer/ByteBufAllocator.java, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBufAllocator.java, +    protected AbstractByteBufAllocator() {, +        this(false);, +    protected AbstractByteBufAllocator(boolean directByDefault) {, +        return heapBuffer(256, Integer.MAX_VALUE);, +        return heapBuffer(initialCapacity, Integer.MAX_VALUE);, +        return directBuffer(256, Integer.MAX_VALUE);, +        return directBuffer(initialCapacity, Integer.MAX_VALUE);, +    private static void validate(int initialCapacity, int maxCapacity) {, +        if (initialCapacity < 0) {, +            throw new IllegalArgumentException("initialCapacity: " + initialCapacity + " (expectd: 0+)");, +++ b/buffer/src/main/java/io/netty/buffer/ByteBufAllocator.java, +++ b/buffer/src/main/java/io/netty/buffer/PoolArena.java, +        } else if (normCapacity > chunkSize) {, +            allocateHuge(buf, reqCapacity);, +            return;, +    private void allocateHuge(PooledByteBuf<T> buf, int reqCapacity) {, +        buf.initUnpooled(newUnpooledChunk(reqCapacity), reqCapacity);, +    }, +, +        if (chunk.unpooled) {, +            destroyChunk(chunk);, +        } else {, +    }, +        if (reqCapacity < 0) {, +            throw new IllegalArgumentException("capacity: " + reqCapacity + " (expected: 0+)");, +        }, +        if (reqCapacity >= chunkSize) {, +            return reqCapacity;, +    protected abstract PoolChunk<T> newUnpooledChunk(int capacity);, +        protected PoolChunk<byte[]> newUnpooledChunk(int capacity) {, +            return new PoolChunk<byte[]>(this, new byte[capacity], capacity);, +        }, +, +        @Override, +        protected PoolChunk<ByteBuffer> newUnpooledChunk(int capacity) {, +            return new PoolChunk<ByteBuffer>(this, ByteBuffer.allocateDirect(capacity), capacity);, +        }, +, +        @Override, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBufAllocator.java, +    protected AbstractByteBufAllocator() {, +        this(false);, +    protected AbstractByteBufAllocator(boolean directByDefault) {, +        return heapBuffer(256, Integer.MAX_VALUE);, +        return heapBuffer(initialCapacity, Integer.MAX_VALUE);, +        return directBuffer(256, Integer.MAX_VALUE);, +        return directBuffer(initialCapacity, Integer.MAX_VALUE);, +    private static void validate(int initialCapacity, int maxCapacity) {, +        if (initialCapacity < 0) {, +            throw new IllegalArgumentException("initialCapacity: " + initialCapacity + " (expectd: 0+)");, +++ b/buffer/src/main/java/io/netty/buffer/ByteBufAllocator.java, +++ b/buffer/src/main/java/io/netty/buffer/PoolArena.java, +        } else if (normCapacity > chunkSize) {, +            allocateHuge(buf, reqCapacity);, +            return;, +    private void allocateHuge(PooledByteBuf<T> buf, int reqCapacity) {, +        buf.initUnpooled(newUnpooledChunk(reqCapacity), reqCapacity);, +    }, +, +        if (chunk.unpooled) {, +            destroyChunk(chunk);, +        } else {, +    }, +        if (reqCapacity < 0) {, +            throw new IllegalArgumentException("capacity: " + reqCapacity + " (expected: 0+)");, +        }, +        if (reqCapacity >= chunkSize) {, +            return reqCapacity;, +    protected abstract PoolChunk<T> newUnpooledChunk(int capacity);, +        protected PoolChunk<byte[]> newUnpooledChunk(int capacity) {, +            return new PoolChunk<byte[]>(this, new byte[capacity], capacity);, +        }, +, +        @Override, +        protected PoolChunk<ByteBuffer> newUnpooledChunk(int capacity) {, +            return new PoolChunk<ByteBuffer>(this, ByteBuffer.allocateDirect(capacity), capacity);]