[+++ b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttDecoder.java, +            int qos = buffer.readUnsignedByte();, +            if (qos != MqttQoS.FAILURE.value()) {, +                qos &= 0x03;, +            }, +++ b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttDecoder.java, +            int qos = buffer.readUnsignedByte();, +            if (qos != MqttQoS.FAILURE.value()) {, +                qos &= 0x03;, +            }, +++ b/codec-mqtt/src/test/java/io/netty/handler/codec/mqtt/MqttCodecTest.java, +    public void testSubAckMessageWithFailureInPayload() throws Exception {, +        MqttFixedHeader mqttFixedHeader =, +                new MqttFixedHeader(MqttMessageType.SUBACK, false, MqttQoS.AT_MOST_ONCE, false, 0);, +        MqttMessageIdVariableHeader mqttMessageIdVariableHeader = MqttMessageIdVariableHeader.from(12345);, +        MqttSubAckPayload mqttSubAckPayload = new MqttSubAckPayload(MqttQoS.FAILURE.value());, +        MqttSubAckMessage message =, +                new MqttSubAckMessage(mqttFixedHeader, mqttMessageIdVariableHeader, mqttSubAckPayload);, +, +        ByteBuf byteBuf = MqttEncoder.doEncode(ALLOCATOR, message);, +, +        List<Object> out = new LinkedList<Object>();, +        mqttDecoder.decode(ctx, byteBuf, out);, +, +        assertEquals("Expected one object but got " + out.size(), 1, out.size());, +, +        MqttSubAckMessage decodedMessage = (MqttSubAckMessage) out.get(0);, +        validateFixedHeaders(message.fixedHeader(), decodedMessage.fixedHeader());, +        validateMessageIdVariableHeader(message.variableHeader(), decodedMessage.variableHeader());, +        validateSubAckPayload(message.payload(), decodedMessage.payload());, +        assertEquals(1, decodedMessage.payload().grantedQoSLevels().size());, +        assertEquals(MqttQoS.FAILURE, MqttQoS.valueOf(decodedMessage.payload().grantedQoSLevels().get(0)));, +    }, +, +    @Test]