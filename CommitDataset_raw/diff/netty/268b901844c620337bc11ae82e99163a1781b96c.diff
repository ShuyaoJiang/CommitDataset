[+++ b/handler/src/main/java/io/netty/handler/ssl/AbstractSniHandler.java, +                                SslUtils.handleHandshakeFailure(ctx, e, true);, +++ b/handler/src/main/java/io/netty/handler/ssl/AbstractSniHandler.java, +                                SslUtils.handleHandshakeFailure(ctx, e, true);, +++ b/handler/src/main/java/io/netty/handler/ssl/SslHandler.java, +     * {@link #setHandshakeFailure(ChannelHandlerContext, Throwable, boolean, boolean, boolean)} or, +        setHandshakeFailure(ctx, CHANNEL_CLOSED, !outboundClosed, handshakeStarted, false);, +            // ensure we always flush and close the channel., +            setHandshakeFailure(ctx, cause, true, false, true);, +        setHandshakeFailure(ctx, cause, true, true, false);, +    private void setHandshakeFailure(ChannelHandlerContext ctx, Throwable cause, boolean closeInbound,, +                                     boolean notify, boolean alwaysFlushAndClose) {, +            if (handshakePromise.tryFailure(cause) || alwaysFlushAndClose) {, +                SslUtils.handleHandshakeFailure(ctx, cause, notify);, +            }, +                    if (handshakePromise.tryFailure(HANDSHAKE_TIMED_OUT)) {, +                        SslUtils.handleHandshakeFailure(ctx, HANDSHAKE_TIMED_OUT, true);, +                    }, +++ b/handler/src/main/java/io/netty/handler/ssl/AbstractSniHandler.java, +                                SslUtils.handleHandshakeFailure(ctx, e, true);, +++ b/handler/src/main/java/io/netty/handler/ssl/SslHandler.java, +     * {@link #setHandshakeFailure(ChannelHandlerContext, Throwable, boolean, boolean, boolean)} or, +        setHandshakeFailure(ctx, CHANNEL_CLOSED, !outboundClosed, handshakeStarted, false);, +            // ensure we always flush and close the channel., +            setHandshakeFailure(ctx, cause, true, false, true);, +        setHandshakeFailure(ctx, cause, true, true, false);, +    private void setHandshakeFailure(ChannelHandlerContext ctx, Throwable cause, boolean closeInbound,, +                                     boolean notify, boolean alwaysFlushAndClose) {, +            if (handshakePromise.tryFailure(cause) || alwaysFlushAndClose) {, +                SslUtils.handleHandshakeFailure(ctx, cause, notify);, +            }, +                    if (handshakePromise.tryFailure(HANDSHAKE_TIMED_OUT)) {, +                        SslUtils.handleHandshakeFailure(ctx, HANDSHAKE_TIMED_OUT, true);, +                    }, +++ b/handler/src/main/java/io/netty/handler/ssl/SslUtils.java, +    static void handleHandshakeFailure(ChannelHandlerContext ctx, Throwable cause, boolean notify) {, +++ b/handler/src/main/java/io/netty/handler/ssl/AbstractSniHandler.java, +                                SslUtils.handleHandshakeFailure(ctx, e, true);, +++ b/handler/src/main/java/io/netty/handler/ssl/SslHandler.java, +     * {@link #setHandshakeFailure(ChannelHandlerContext, Throwable, boolean, boolean, boolean)} or, +        setHandshakeFailure(ctx, CHANNEL_CLOSED, !outboundClosed, handshakeStarted, false);, +            // ensure we always flush and close the channel., +            setHandshakeFailure(ctx, cause, true, false, true);, +        setHandshakeFailure(ctx, cause, true, true, false);, +    private void setHandshakeFailure(ChannelHandlerContext ctx, Throwable cause, boolean closeInbound,, +                                     boolean notify, boolean alwaysFlushAndClose) {, +            if (handshakePromise.tryFailure(cause) || alwaysFlushAndClose) {, +                SslUtils.handleHandshakeFailure(ctx, cause, notify);, +            }, +                    if (handshakePromise.tryFailure(HANDSHAKE_TIMED_OUT)) {, +                        SslUtils.handleHandshakeFailure(ctx, HANDSHAKE_TIMED_OUT, true);, +                    }, +++ b/handler/src/main/java/io/netty/handler/ssl/SslUtils.java, +    static void handleHandshakeFailure(ChannelHandlerContext ctx, Throwable cause, boolean notify) {, +++ b/handler/src/test/java/io/netty/handler/ssl/SslHandlerTest.java, +, +    @Test(timeout = 10000), +    public void testCloseOnHandshakeFailure() throws Exception {, +        final SelfSignedCertificate ssc = new SelfSignedCertificate();, +, +        final SslContext sslServerCtx = SslContextBuilder.forServer(ssc.key(), ssc.cert()).build();, +        final SslContext sslClientCtx = SslContextBuilder.forClient(), +                .trustManager(new SelfSignedCertificate().cert()), +                .build();, +, +        EventLoopGroup group = new NioEventLoopGroup(1);, +        Channel sc = null;, +        Channel cc = null;, +        try {, +            LocalAddress address = new LocalAddress(getClass().getSimpleName() + ".testCloseOnHandshakeFailure");, +            ServerBootstrap sb = new ServerBootstrap(), +                    .group(group), +                    .channel(LocalServerChannel.class), +                    .childHandler(new ChannelInitializer<Channel>() {, +                        @Override, +                        protected void initChannel(Channel ch) {, +                            ch.pipeline().addLast(sslServerCtx.newHandler(ch.alloc()));, +                        }, +                    });, +            sc = sb.bind(address).syncUninterruptibly().channel();, +, +            Bootstrap b = new Bootstrap(), +                    .group(group), +                    .channel(LocalChannel.class), +                    .handler(new ChannelInitializer<Channel>() {, +                        @Override, +                        protected void initChannel(Channel ch) {, +                            ch.pipeline().addLast(sslClientCtx.newHandler(ch.alloc()));, +                        }, +                    });, +            cc = b.connect(sc.localAddress()).syncUninterruptibly().channel();, +            SslHandler handler = cc.pipeline().get(SslHandler.class);, +            handler.handshakeFuture().awaitUninterruptibly();, +            assertFalse(handler.handshakeFuture().isSuccess());, +, +            cc.closeFuture().syncUninterruptibly();, +        } finally {, +            if (cc != null) {, +                cc.close().syncUninterruptibly();, +            }]