[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2ConnectionDecoder.java, +            try {, +                // This call will create a stream for streamDependency if necessary., +                // For this reason it must be done before notifying the listener., +                stream.setPriority(streamDependency, weight, exclusive);, +            } catch (ClosedStreamCreationException ignored) {, +                // It is possible that either the stream for this frame or the parent stream is closed., +                // In this case we should ignore the exception and allow the frame to be sent., +            }, +, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2ConnectionDecoder.java, +            try {, +                // This call will create a stream for streamDependency if necessary., +                // For this reason it must be done before notifying the listener., +                stream.setPriority(streamDependency, weight, exclusive);, +            } catch (ClosedStreamCreationException ignored) {, +                // It is possible that either the stream for this frame or the parent stream is closed., +                // In this case we should ignore the exception and allow the frame to be sent., +            }, +, +++ b/codec-http2/src/test/java/io/netty/handler/codec/http2/DefaultHttp2ConnectionDecoderTest.java, +    private static final int STREAM_DEPENDENCY_ID = 3;, +    public void headersDependencyNotCreatedShouldCreateAndSucceed() throws Exception {, +        final short weight = 1;, +        decode().onHeadersRead(ctx, STREAM_ID, EmptyHttp2Headers.INSTANCE, STREAM_DEPENDENCY_ID,, +                weight, true, 0, true);, +        verify(listener).onHeadersRead(eq(ctx), eq(STREAM_ID), eq(EmptyHttp2Headers.INSTANCE), eq(STREAM_DEPENDENCY_ID),, +                eq(weight), eq(true), eq(0), eq(true));, +        verify(stream).setPriority(eq(STREAM_DEPENDENCY_ID), eq(weight), eq(true));, +        verify(lifecycleManager).closeRemoteSide(eq(stream), any(ChannelFuture.class));, +    }, +, +    @Test, +    public void headersDependencyPreviouslyCreatedStreamShouldSucceed() throws Exception {, +        final short weight = 1;, +        doAnswer(new Answer<Http2Stream>() {, +            @Override, +            public Http2Stream answer(InvocationOnMock in) throws Throwable {, +                throw new ClosedStreamCreationException(Http2Error.INTERNAL_ERROR);, +            }, +        }).when(stream).setPriority(eq(STREAM_DEPENDENCY_ID), eq(weight), eq(true));, +        decode().onHeadersRead(ctx, STREAM_ID, EmptyHttp2Headers.INSTANCE, STREAM_DEPENDENCY_ID,, +                weight, true, 0, true);, +        verify(listener).onHeadersRead(eq(ctx), eq(STREAM_ID), eq(EmptyHttp2Headers.INSTANCE), eq(STREAM_DEPENDENCY_ID),, +                eq(weight), eq(true), eq(0), eq(true));, +        verify(stream).setPriority(eq(STREAM_DEPENDENCY_ID), eq(weight), eq(true));, +        verify(lifecycleManager).closeRemoteSide(eq(stream), any(ChannelFuture.class));, +    }, +, +    @Test(expected = RuntimeException.class), +    public void headersDependencyInvalidStreamShouldFail() throws Exception {, +        final short weight = 1;, +        doAnswer(new Answer<Http2Stream>() {, +            @Override, +            public Http2Stream answer(InvocationOnMock in) throws Throwable {, +                throw new RuntimeException("Fake Exception");, +            }, +        }).when(stream).setPriority(eq(STREAM_DEPENDENCY_ID), eq(weight), eq(true));, +        decode().onHeadersRead(ctx, STREAM_ID, EmptyHttp2Headers.INSTANCE, STREAM_DEPENDENCY_ID,, +                weight, true, 0, true);, +        verify(listener, never()).onHeadersRead(any(ChannelHandlerContext.class), anyInt(), any(Http2Headers.class),, +                anyInt(), anyShort(), anyBoolean(), anyInt(), anyBoolean());, +        verify(stream).setPriority(eq(STREAM_DEPENDENCY_ID), eq(weight), eq(true));, +        verify(lifecycleManager, never()).closeRemoteSide(eq(stream), any(ChannelFuture.class));, +    }, +, +    @Test, +        decode().onPriorityRead(ctx, STREAM_ID, STREAM_DEPENDENCY_ID, (short) 255, true);, +        verify(stream).setPriority(eq(STREAM_DEPENDENCY_ID), eq((short) 255), eq(true));, +        verify(listener).onPriorityRead(eq(ctx), eq(STREAM_ID), eq(STREAM_DEPENDENCY_ID), eq((short) 255), eq(true));, +        when(connection.stream(STREAM_DEPENDENCY_ID)).thenReturn(stream);, +        when(connection.requireStream(STREAM_DEPENDENCY_ID)).thenReturn(stream);, +        decode().onPriorityRead(ctx, STREAM_ID, STREAM_DEPENDENCY_ID, (short) 255, true);, +        verify(listener).onPriorityRead(eq(ctx), eq(STREAM_ID), eq(STREAM_DEPENDENCY_ID), eq((short) 255), eq(true));, +        }).when(stream).setPriority(eq(STREAM_DEPENDENCY_ID), eq((short) 255), eq(true));, +        decode().onPriorityRead(ctx, STREAM_ID, STREAM_DEPENDENCY_ID, (short) 255, true);, +        verify(stream).setPriority(eq(STREAM_DEPENDENCY_ID), eq((short) 255), eq(true));, +        verify(listener).onPriorityRead(eq(ctx), eq(STREAM_ID), eq(STREAM_DEPENDENCY_ID), eq((short) 255), eq(true));]