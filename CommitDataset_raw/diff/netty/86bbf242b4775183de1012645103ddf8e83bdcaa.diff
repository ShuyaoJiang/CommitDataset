[+++ b/handler/src/test/java/io/netty/handler/ssl/SniHandlerTest.java, +import java.util.ArrayList;, +import java.util.List;, +import org.junit.runner.RunWith;, +import org.junit.runners.Parameterized;, +@RunWith(Parameterized.class), +    private static void assumeApnSupported(SslProvider provider) {, +        switch (provider) {, +            case OPENSSL:, +            case OPENSSL_REFCNT:, +                assumeTrue(OpenSsl.isAlpnSupported());, +                break;, +            case JDK:, +                assumeTrue(JdkAlpnSslEngine.isAvailable());, +                break;, +            default:, +                throw new Error();, +        }, +    private static SslContext makeSslContext(SslProvider provider, boolean apn) throws Exception {, +        if (apn) {, +            assumeApnSupported(provider);, +        }, +, +        SslContextBuilder sslCtxBuilder = SslContextBuilder.forServer(crtFile, keyFile, "12345"), +                .sslProvider(provider);, +        if (apn) {, +            sslCtxBuilder.applicationProtocolConfig(newApnConfig());, +        }, +        return sslCtxBuilder.build();, +    private static SslContext makeSslClientContext(SslProvider provider, boolean apn) throws Exception {, +        if (apn) {, +            assumeApnSupported(provider);, +        }, +, +        SslContextBuilder sslCtxBuilder = SslContextBuilder.forClient().trustManager(crtFile).sslProvider(provider);, +        if (apn) {, +            sslCtxBuilder.applicationProtocolConfig(newApnConfig());, +        }, +        return sslCtxBuilder.build();, +    }, +, +    @Parameterized.Parameters(name = "{index}: sslProvider={0}"), +    public static Iterable<? extends Object> data() {, +        List<SslProvider> params = new ArrayList<SslProvider>(3);, +        if (OpenSsl.isAvailable()) {, +            params.add(SslProvider.OPENSSL);, +            params.add(SslProvider.OPENSSL_REFCNT);, +        }, +        params.add(SslProvider.JDK);, +        return params;, +    }, +, +    private final SslProvider provider;, +, +    public SniHandlerTest(SslProvider provider) {, +        this.provider = provider;, +        SslContext nettyContext = makeSslContext(provider, false);, +        SslContext leanContext = makeSslContext(provider, false);, +        SslContext leanContext2 = makeSslContext(provider, false);, +        try {, +                    // a hostname conflict with previous one, since we are using order-sensitive config,, +                    // the engine won't be used with the handler., +            // Just call finish and not assert the return value. This is because OpenSSL correct produces an alert, +            // while the JDK SSLEngineImpl does not atm., +            // See https://github.com/netty/netty/issues/5874, +            ch.finish();, +, +        } finally {, +            releaseAll(leanContext, leanContext2, nettyContext);, +        }, +        SslContext nettyContext = makeSslContext(provider, false);, +        SslContext leanContext = makeSslContext(provider, false);, +        SslContext leanContext2 = makeSslContext(provider, false);, +        try {, +                    // a hostname conflict with previous one, since we are using order-sensitive config,, +                    // the engine won't be used with the handler., +        } finally {, +            releaseAll(leanContext, leanContext2, nettyContext);, +        }, +        SslContext nettyContext = makeSslContext(provider, true);, +        SslContext sniContext = makeSslContext(provider, true);, +        final SslContext clientContext = makeSslClientContext(provider, true);, +        try {, +                            protected void configurePipeline(ChannelHandlerContext ctx, String protocol) {, +                            protected void configurePipeline(ChannelHandlerContext ctx, String protocol) {, +        } finally {, +            releaseAll(clientContext, nettyContext, sniContext);, +        }, +        switch (provider) {, +            case OPENSSL:, +            case OPENSSL_REFCNT:, +                SslContext sslContext = null;, +                            .sslProvider(provider), +                    sc = sb.group(group).channel(LocalServerChannel.class), +                            .childHandler(new ChannelInitializer<Channel>() {, +                    sslContext = SslContextBuilder.forClient().sslProvider(provider), +                            .trustManager(InsecureTrustManagerFactory.INSTANCE).build();, +                    if (sslContext != null) {, +                        ReferenceCountUtil.release(sslContext);, +                    }]