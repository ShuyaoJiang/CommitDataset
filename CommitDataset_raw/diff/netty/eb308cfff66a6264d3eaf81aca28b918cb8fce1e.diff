[+++ b/common/src/main/java/io/netty/util/concurrent/DefaultEventExecutor.java, +import java.util.concurrent.Executor;, +    DefaultEventExecutor(DefaultEventExecutorGroup parent, Executor executor) {, +        super(parent, executor, true);, +++ b/common/src/main/java/io/netty/util/concurrent/DefaultEventExecutor.java, +import java.util.concurrent.Executor;, +    DefaultEventExecutor(DefaultEventExecutorGroup parent, Executor executor) {, +        super(parent, executor, true);, +++ b/common/src/main/java/io/netty/util/concurrent/DefaultEventExecutorGroup.java, +import java.util.concurrent.Executor;, +    protected EventExecutor newChild(Executor executor, Object... args) throws Exception {, +        return new DefaultEventExecutor(this, executor);, +++ b/common/src/main/java/io/netty/util/concurrent/DefaultEventExecutor.java, +import java.util.concurrent.Executor;, +    DefaultEventExecutor(DefaultEventExecutorGroup parent, Executor executor) {, +        super(parent, executor, true);, +++ b/common/src/main/java/io/netty/util/concurrent/DefaultEventExecutorGroup.java, +import java.util.concurrent.Executor;, +    protected EventExecutor newChild(Executor executor, Object... args) throws Exception {, +        return new DefaultEventExecutor(this, executor);, +++ b/common/src/main/java/io/netty/util/concurrent/MultithreadEventExecutorGroup.java, +import java.util.concurrent.Executor;, +     * @param args              arguments which will passed to each {@link #newChild(Executor, Object...)} call, +        this(nThreads, threadFactory == null ? null : new ThreadPerTaskExecutor(threadFactory), args);, +    }, +, +    /**, +     * Create a new instance., +     *, +     * @param nThreads          the number of threads that will be used by this instance., +     * @param executor          the Executor to use, or {@code null} if the default should be used., +     * @param args              arguments which will passed to each {@link #newChild(Executor, Object...)} call, +     */, +    protected MultithreadEventExecutorGroup(int nThreads, Executor executor, Object... args) {, +        if (executor == null) {, +            executor = new ThreadPerTaskExecutor(newDefaultThreadFactory());, +                children[i] = newChild(executor, args);, +    protected abstract EventExecutor newChild(Executor executor, Object... args) throws Exception;, +++ b/common/src/main/java/io/netty/util/concurrent/DefaultEventExecutor.java, +import java.util.concurrent.Executor;, +    DefaultEventExecutor(DefaultEventExecutorGroup parent, Executor executor) {, +        super(parent, executor, true);, +++ b/common/src/main/java/io/netty/util/concurrent/DefaultEventExecutorGroup.java, +import java.util.concurrent.Executor;, +    protected EventExecutor newChild(Executor executor, Object... args) throws Exception {, +        return new DefaultEventExecutor(this, executor);, +++ b/common/src/main/java/io/netty/util/concurrent/MultithreadEventExecutorGroup.java, +import java.util.concurrent.Executor;, +     * @param args              arguments which will passed to each {@link #newChild(Executor, Object...)} call, +        this(nThreads, threadFactory == null ? null : new ThreadPerTaskExecutor(threadFactory), args);, +    }, +, +    /**, +     * Create a new instance., +     *, +     * @param nThreads          the number of threads that will be used by this instance., +     * @param executor          the Executor to use, or {@code null} if the default should be used., +     * @param args              arguments which will passed to each {@link #newChild(Executor, Object...)} call, +     */, +    protected MultithreadEventExecutorGroup(int nThreads, Executor executor, Object... args) {, +        if (executor == null) {, +            executor = new ThreadPerTaskExecutor(newDefaultThreadFactory());, +                children[i] = newChild(executor, args);, +    protected abstract EventExecutor newChild(Executor executor, Object... args) throws Exception;, +++ b/common/src/main/java/io/netty/util/concurrent/SingleThreadEventExecutor.java, +import java.util.concurrent.Executor;, +    private volatile Thread thread;, +    private final Executor executor;, +    private volatile boolean interrupted;, +        this(parent, new ThreadPerTaskExecutor(threadFactory), addTaskWakesUp);, +    }, +    /**, +     * Create a new instance, +     *, +     * @param parent            the {@link EventExecutorGroup} which is the parent of this instance and belongs to it, +     * @param executor          the {@link Executor} which will be used for executing, +     * @param addTaskWakesUp    {@code true} if and only if invocation of {@link #addTask(Runnable)} will wake up the, +     *                          executor thread, +     */, +    protected SingleThreadEventExecutor(, +            EventExecutorGroup parent, Executor executor, boolean addTaskWakesUp) {, +, +        if (executor == null) {, +            throw new NullPointerException("executor");, +        this.executor = executor;, +        Thread currentThread = thread;, +        if (currentThread == null) {, +            interrupted = true;, +        } else {, +            currentThread.interrupt();, +        }, +                        doStartThread();, +                    doStartThread();, +                doStartThread();, +    private void doStartThread() {, +        assert thread == null;, +        executor.execute(new Runnable() {, +            @Override, +            public void run() {, +                thread = Thread.currentThread();]