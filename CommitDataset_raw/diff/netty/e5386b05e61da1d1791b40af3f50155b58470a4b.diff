[+++ b/buffer/src/main/java/io/netty/buffer/ByteBufUtil.java, +import static io.netty.util.internal.StringUtil.NEWLINE;, +    private static final int THREAD_LOCAL_BUFFER_SIZE;, +        return HexUtil.hexDump(buffer, fromIndex, length);, +        return HexUtil.hexDump(array, fromIndex, length);, +        return HexUtil.prettyHexDump(buffer, offset, length);, +        HexUtil.appendPrettyHexDump(dump, buf, offset, length);, +    }, +, +    /* Separate class so that the expensive static initialization is only done when needed */, +    private static final class HexUtil {, +, +        private static final char[] BYTE2CHAR = new char[256];, +        private static final char[] HEXDUMP_TABLE = new char[256 * 4];, +        private static final String[] HEXPADDING = new String[16];, +        private static final String[] HEXDUMP_ROWPREFIXES = new String[65536 >>> 4];, +        private static final String[] BYTE2HEX = new String[256];, +        private static final String[] BYTEPADDING = new String[16];, +, +        static {, +            final char[] DIGITS = "0123456789abcdef".toCharArray();, +            for (int i = 0; i < 256; i ++) {, +                HEXDUMP_TABLE[ i << 1     ] = DIGITS[i >>> 4 & 0x0F];, +                HEXDUMP_TABLE[(i << 1) + 1] = DIGITS[i       & 0x0F];, +            }, +, +            int i;, +, +            // Generate the lookup table for hex dump paddings, +            for (i = 0; i < HEXPADDING.length; i ++) {, +                int padding = HEXPADDING.length - i;, +                StringBuilder buf = new StringBuilder(padding * 3);, +                for (int j = 0; j < padding; j ++) {, +                    buf.append("   ");, +                }, +                HEXPADDING[i] = buf.toString();, +            }, +, +            // Generate the lookup table for the start-offset header in each row (up to 64KiB)., +            for (i = 0; i < HEXDUMP_ROWPREFIXES.length; i ++) {, +                StringBuilder buf = new StringBuilder(12);, +                buf.append(NEWLINE);, +                buf.append(Long.toHexString(i << 4 & 0xFFFFFFFFL | 0x100000000L));, +                buf.setCharAt(buf.length() - 9, '|');, +                buf.append('|');, +                HEXDUMP_ROWPREFIXES[i] = buf.toString();, +            }, +, +            // Generate the lookup table for byte-to-hex-dump conversion, +            for (i = 0; i < BYTE2HEX.length; i ++) {, +                BYTE2HEX[i] = ' ' + StringUtil.byteToHexStringPadded(i);, +            }, +, +            // Generate the lookup table for byte dump paddings, +            for (i = 0; i < BYTEPADDING.length; i ++) {, +                int padding = BYTEPADDING.length - i;, +                StringBuilder buf = new StringBuilder(padding);, +                for (int j = 0; j < padding; j ++) {, +                    buf.append(' ');, +                }, +                BYTEPADDING[i] = buf.toString();, +            }, +, +            // Generate the lookup table for byte-to-char conversion, +            for (i = 0; i < BYTE2CHAR.length; i ++) {, +                if (i <= 0x1f || i >= 0x7f) {, +                    BYTE2CHAR[i] = '.';, +                } else {, +                    BYTE2CHAR[i] = (char) i;, +                }, +            }, +        }, +, +        private static String hexDump(ByteBuf buffer, int fromIndex, int length) {, +            if (length < 0) {, +              throw new IllegalArgumentException("length: " + length);, +            }, +            if (length == 0) {, +              return "";, +            }, +, +            int endIndex = fromIndex + length;, +            char[] buf = new char[length << 1];, +, +            int srcIdx = fromIndex;, +            int dstIdx = 0;, +            for (; srcIdx < endIndex; srcIdx ++, dstIdx += 2) {, +              System.arraycopy(, +                  HEXDUMP_TABLE, buffer.getUnsignedByte(srcIdx) << 1,, +                  buf, dstIdx, 2);, +            }, +, +            return new String(buf);, +        }, +, +        private static String hexDump(byte[] array, int fromIndex, int length) {, +            if (length < 0) {, +              throw new IllegalArgumentException("length: " + length);, +            }, +            if (length == 0) {]