[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2ConnectionEncoder.java, +import io.netty.channel.CoalescingBufferQueue;, +, +        private final CoalescingBufferQueue queue;, +            queue = new CoalescingBufferQueue(ctx.channel());, +            queue.add(buf, promise);, +            return queue.readableBytes() + padding;, +            queue.releaseAndFailAll(cause);, +            if (!endOfStream && (queue.readableBytes() == 0 || allowedBytes == 0)) {, +                // Nothing to write and we don't have to force a write because of EOS., +                int allowedFrameSize = Math.min(maxFrameSize, allowedBytes);, +                int writeableData = Math.min(queue.readableBytes(), allowedFrameSize);, +                ChannelPromise writePromise = ctx.newPromise();, +                writePromise.addListener(this);, +                ByteBuf toWrite = queue.remove(writeableData, writePromise);, +, +                allowedBytes -= writeableData + writeablePadding;, +                        endOfStream && size() == 0, writePromise);, +            } while (size() > 0 && allowedBytes > 0);, +            FlowControlledData nextData = (FlowControlledData) next;, +            nextData.queue.copyTo(queue);, +            padding = Math.max(padding, nextData.padding);, +            promise.addListener(this);, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2ConnectionEncoder.java, +import io.netty.channel.CoalescingBufferQueue;, +, +        private final CoalescingBufferQueue queue;, +            queue = new CoalescingBufferQueue(ctx.channel());, +            queue.add(buf, promise);, +            return queue.readableBytes() + padding;, +            queue.releaseAndFailAll(cause);, +            if (!endOfStream && (queue.readableBytes() == 0 || allowedBytes == 0)) {, +                // Nothing to write and we don't have to force a write because of EOS., +                int allowedFrameSize = Math.min(maxFrameSize, allowedBytes);, +                int writeableData = Math.min(queue.readableBytes(), allowedFrameSize);, +                ChannelPromise writePromise = ctx.newPromise();, +                writePromise.addListener(this);, +                ByteBuf toWrite = queue.remove(writeableData, writePromise);, +, +                allowedBytes -= writeableData + writeablePadding;, +                        endOfStream && size() == 0, writePromise);, +            } while (size() > 0 && allowedBytes > 0);, +            FlowControlledData nextData = (FlowControlledData) next;, +            nextData.queue.copyTo(queue);, +            padding = Math.max(padding, nextData.padding);, +            promise.addListener(this);, +++ b/codec-http2/src/test/java/io/netty/handler/codec/http2/DefaultHttp2ConnectionEncoderTest.java, +import io.netty.buffer.PooledByteBufAllocator;, +        when(channel.alloc()).thenReturn(PooledByteBufAllocator.DEFAULT);, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2ConnectionEncoder.java, +import io.netty.channel.CoalescingBufferQueue;, +, +        private final CoalescingBufferQueue queue;, +            queue = new CoalescingBufferQueue(ctx.channel());, +            queue.add(buf, promise);, +            return queue.readableBytes() + padding;, +            queue.releaseAndFailAll(cause);, +            if (!endOfStream && (queue.readableBytes() == 0 || allowedBytes == 0)) {, +                // Nothing to write and we don't have to force a write because of EOS., +                int allowedFrameSize = Math.min(maxFrameSize, allowedBytes);, +                int writeableData = Math.min(queue.readableBytes(), allowedFrameSize);, +                ChannelPromise writePromise = ctx.newPromise();, +                writePromise.addListener(this);, +                ByteBuf toWrite = queue.remove(writeableData, writePromise);, +, +                allowedBytes -= writeableData + writeablePadding;, +                        endOfStream && size() == 0, writePromise);, +            } while (size() > 0 && allowedBytes > 0);, +            FlowControlledData nextData = (FlowControlledData) next;, +            nextData.queue.copyTo(queue);, +            padding = Math.max(padding, nextData.padding);, +            promise.addListener(this);, +++ b/codec-http2/src/test/java/io/netty/handler/codec/http2/DefaultHttp2ConnectionEncoderTest.java, +import io.netty.buffer.PooledByteBufAllocator;, +        when(channel.alloc()).thenReturn(PooledByteBufAllocator.DEFAULT);, +++ b/codec-http2/src/test/java/io/netty/handler/codec/http2/StreamBufferingEncoderTest.java, +        when(channel.alloc()).thenReturn(UnpooledByteBufAllocator.DEFAULT);]