[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectDecoder.java, +import io.netty.channel.socket.ChannelInputShutdownEvent;, +                /**, +                 * <a href="https://tools.ietf.org/html/rfc7230#section-3.3.3">RFC 7230, 3.3.3</a> states that if a, +                 * request does not have either a transfer-encoding or a content-length header then the message body, +                 * length is 0. However for a response the body length is the number of octets received prior to the, +                 * server closing the connection. So we treat this as variable length chunked encoding., +                 */, +    @Override, +    public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception {, +        if (evt instanceof ChannelInputShutdownEvent) {, +            // The decodeLast method is invoked when a channelInactive event is encountered., +            // This method is responsible for ending requests in some situations and must be called, +            // when the input has been shutdown., +            super.channelInactive(ctx);, +        }, +        super.userEventTriggered(ctx, evt);, +    }, +, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectDecoder.java, +import io.netty.channel.socket.ChannelInputShutdownEvent;, +                /**, +                 * <a href="https://tools.ietf.org/html/rfc7230#section-3.3.3">RFC 7230, 3.3.3</a> states that if a, +                 * request does not have either a transfer-encoding or a content-length header then the message body, +                 * length is 0. However for a response the body length is the number of octets received prior to the, +                 * server closing the connection. So we treat this as variable length chunked encoding., +                 */, +    @Override, +    public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception {, +        if (evt instanceof ChannelInputShutdownEvent) {, +            // The decodeLast method is invoked when a channelInactive event is encountered., +            // This method is responsible for ending requests in some situations and must be called, +            // when the input has been shutdown., +            super.channelInactive(ctx);, +        }, +        super.userEventTriggered(ctx, evt);, +    }, +, +++ b/codec-http/src/test/java/io/netty/handler/codec/http/HttpClientCodecTest.java, +import io.netty.bootstrap.Bootstrap;, +import io.netty.bootstrap.ServerBootstrap;, +import io.netty.channel.Channel;, +import io.netty.channel.ChannelFuture;, +import io.netty.channel.ChannelFutureListener;, +import io.netty.channel.ChannelHandlerContext;, +import io.netty.channel.ChannelInitializer;, +import io.netty.channel.ChannelOption;, +import io.netty.channel.SimpleChannelInboundHandler;, +import io.netty.channel.nio.NioEventLoopGroup;, +import io.netty.channel.socket.SocketChannel;, +import io.netty.channel.socket.nio.NioServerSocketChannel;, +import io.netty.channel.socket.nio.NioSocketChannel;, +import io.netty.util.NetUtil;, +import java.net.InetSocketAddress;, +import java.util.concurrent.CountDownLatch;, +, +import static io.netty.util.ReferenceCountUtil.release;, +import static io.netty.util.ReferenceCountUtil.releaseLater;, +import static java.util.concurrent.TimeUnit.SECONDS;, +import static org.hamcrest.CoreMatchers.instanceOf;, +import static org.junit.Assert.assertNotNull;, +import static org.junit.Assert.assertNull;, +import static org.junit.Assert.assertThat;, +import static org.junit.Assert.assertTrue;, +import static org.junit.Assert.fail;, +, +    @Test, +    public void testServerCloseSocketInputProvidesData() throws InterruptedException {, +        ServerBootstrap sb = new ServerBootstrap();, +        Bootstrap cb = new Bootstrap();, +        final CountDownLatch serverChannelLatch = new CountDownLatch(1);, +        final CountDownLatch responseRecievedLatch = new CountDownLatch(1);, +        try {, +            sb.group(new NioEventLoopGroup(2));, +            sb.channel(NioServerSocketChannel.class);, +            sb.childHandler(new ChannelInitializer<Channel>() {, +                @Override, +                protected void initChannel(Channel ch) throws Exception {, +                    // Don't use the HttpServerCodec, because we don't want to have content-length or anything added., +                    ch.pipeline().addLast(new HttpRequestDecoder(4096, 8192, 8192, true));, +                    ch.pipeline().addLast(new HttpObjectAggregator(4096));, +                    ch.pipeline().addLast(new SimpleChannelInboundHandler<FullHttpRequest>() {, +                        @Override, +                        protected void channelRead0(ChannelHandlerContext ctx, FullHttpRequest msg) {, +                            // This is just a simple demo...don't block in IO, +                            assertTrue(ctx.channel() instanceof SocketChannel);, +                            final SocketChannel sChannel = (SocketChannel) ctx.channel();, +                            /**, +                             * The point of this test is to not add any content-length or content-encoding headers, +                             * and the client should still handle this., +                             * See <a href="https://tools.ietf.org/html/rfc7230#section-3.3.3">RFC 7230, 3.3.3</a>., +                             */, +                            sChannel.writeAndFlush(Unpooled.wrappedBuffer(("HTTP/1.0 200 OK\r\n" +, +                            "Date: Fri, 31 Dec 1999 23:59:59 GMT\r\n" +, +                            "Content-Type: text/html\r\n\r\n").getBytes(CharsetUtil.ISO_8859_1))), +                                    .addListener(new ChannelFutureListener() {, +                                @Override, +                                public void operationComplete(ChannelFuture future) throws Exception {, +                                    assertTrue(future.isSuccess());, +                                    sChannel.writeAndFlush(Unpooled.wrappedBuffer(]