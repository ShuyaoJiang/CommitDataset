[+++ b/buffer/src/main/java/io/netty/buffer/CompositeChannelBuffer.java, +import io.netty.util.internal.DetectionUtil;, +, +        if (DetectionUtil.javaVersion() >= 7) {, +            return (int) out.write(toByteBuffers(index, length));, +        }, +++ b/buffer/src/main/java/io/netty/buffer/CompositeChannelBuffer.java, +import io.netty.util.internal.DetectionUtil;, +, +        if (DetectionUtil.javaVersion() >= 7) {, +            return (int) out.write(toByteBuffers(index, length));, +        }, +++ b/transport/src/main/java/io/netty/channel/socket/nio/SendBufferPool.java, +import java.nio.channels.GatheringByteChannel;, +import io.netty.buffer.CompositeChannelBuffer;, +import io.netty.util.internal.DetectionUtil;, +        , +        if (src instanceof CompositeChannelBuffer && DetectionUtil.javaVersion() >= 7) {, +            return new GatheringSendBuffer(src.toByteBuffers());, +        }, +        , +    class GatheringSendBuffer implements SendBuffer {, +, +        private final ByteBuffer[] buffers;, +        private final int last;, +        private long written;, +        private final int total;, +, +        GatheringSendBuffer(ByteBuffer[] buffers) {, +            this.buffers = buffers;, +            this.last = buffers.length - 1;, +            int total = 0;, +            for (ByteBuffer buf: buffers) {, +                total += buf.remaining();, +            }, +            this.total = total;, +        }, +        , +        @Override, +        public boolean finished() {, +            return !buffers[last].hasRemaining();, +        }, +, +        @Override, +        public long writtenBytes() {, +            return written;, +        }, +, +        @Override, +        public long totalBytes() {, +            return total;, +        }, +, +        @Override, +        public long transferTo(WritableByteChannel ch) throws IOException {, +            if (ch instanceof GatheringByteChannel) {, +                 long w = ((GatheringByteChannel) ch).write(buffers);, +                 written += w;, +                 return w;, +            } else {, +                int send = 0;, +                for (ByteBuffer buf: buffers) {, +                    if (buf.hasRemaining()) {, +                        int w = ch.write(buf);, +                        if (w == 0) {, +                            break;, +                        } else {, +                            send += w;, +                        }, +                    }, +                }, +                written += send;, +                return send;, +            }, +        }, +, +        @Override, +        public long transferTo(DatagramChannel ch, SocketAddress raddr) throws IOException {, +            int send = 0;, +            for (ByteBuffer buf: buffers) {, +                if (buf.hasRemaining()) {, +                    int w = ch.send(buf, raddr);, +                    if (w == 0) {, +                        break;, +                    } else {, +                        send += w;, +                    }, +                }, +            }, +            written += send;, +, +            return send;, +        }, +, +        @Override, +        public void release() {, +            // nothing todo, +        }, +        , +    }]