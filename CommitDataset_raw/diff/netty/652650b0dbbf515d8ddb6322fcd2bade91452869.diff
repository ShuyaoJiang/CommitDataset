[+++ b/transport/src/main/java/io/netty/channel/AbstractChannelHandlerContext.java, +            final AbstractWriteTask task;, +            if (!safeExecute(executor, task, promise, m)) {, +                // We failed to submit the AbstractWriteTask. We need to cancel it so we decrement the pending bytes, +                // and put it back in the Recycler for re-use later., +                //, +                // See https://github.com/netty/netty/issues/8343., +                task.cancel();, +            }, +    private static boolean safeExecute(EventExecutor executor, Runnable runnable, ChannelPromise promise, Object msg) {, +            return true;, +            return false;, +                decrementPendingOutboundBytes();, +                write(ctx, msg, promise);, +            } finally {, +                recycle();, +            }, +        }, +, +        void cancel() {, +            try {, +                decrementPendingOutboundBytes();, +            } finally {, +                recycle();, +            }, +        }, +, +        private void decrementPendingOutboundBytes() {, +        }, +, +        private void recycle() {, +        static WriteTask newInstance(, +        static WriteAndFlushTask newInstance(, +++ b/transport/src/main/java/io/netty/channel/AbstractChannelHandlerContext.java, +            final AbstractWriteTask task;, +            if (!safeExecute(executor, task, promise, m)) {, +                // We failed to submit the AbstractWriteTask. We need to cancel it so we decrement the pending bytes, +                // and put it back in the Recycler for re-use later., +                //, +                // See https://github.com/netty/netty/issues/8343., +                task.cancel();, +            }, +    private static boolean safeExecute(EventExecutor executor, Runnable runnable, ChannelPromise promise, Object msg) {, +            return true;, +            return false;, +                decrementPendingOutboundBytes();, +                write(ctx, msg, promise);, +            } finally {, +                recycle();, +            }, +        }, +, +        void cancel() {, +            try {, +                decrementPendingOutboundBytes();, +            } finally {, +                recycle();, +            }, +        }, +, +        private void decrementPendingOutboundBytes() {, +        }, +, +        private void recycle() {, +        static WriteTask newInstance(, +        static WriteAndFlushTask newInstance(, +++ b/transport/src/test/java/io/netty/channel/ChannelOutboundBufferTest.java, +import io.netty.util.concurrent.DefaultThreadFactory;, +import io.netty.util.concurrent.RejectedExecutionHandlers;, +import io.netty.util.concurrent.SingleThreadEventExecutor;, +import java.util.Queue;, +import java.util.concurrent.CountDownLatch;, +import java.util.concurrent.RejectedExecutionException;, +    @Test(timeout = 5000), +    public void testWriteTaskRejected() throws Exception {, +        final SingleThreadEventExecutor executor = new SingleThreadEventExecutor(, +                null, new DefaultThreadFactory("executorPool"),, +                true, 1, RejectedExecutionHandlers.reject()) {, +            @Override, +            protected void run() {, +                do {, +                    Runnable task = takeTask();, +                    if (task != null) {, +                        task.run();, +                        updateLastExecutionTime();, +                    }, +                } while (!confirmShutdown());, +            }, +, +            @Override, +            protected Queue<Runnable> newTaskQueue(int maxPendingTasks) {, +                return super.newTaskQueue(1);, +            }, +        };, +        final CountDownLatch handlerAddedLatch = new CountDownLatch(1);, +        EmbeddedChannel ch = new EmbeddedChannel();, +        ch.pipeline().addLast(executor, new ChannelOutboundHandlerAdapter() {, +            @Override, +            public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception {, +                promise.setFailure(new AssertionError("Should not be called"));]