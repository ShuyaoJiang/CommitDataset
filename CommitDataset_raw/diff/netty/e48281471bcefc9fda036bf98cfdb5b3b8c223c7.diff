[+++ b/example/src/main/java/io/netty/example/discard/DiscardClient.java, +import io.netty.channel.ChannelBootstrap;, +import io.netty.channel.ChannelInitializer;, +import io.netty.channel.socket.SocketChannel;, +import io.netty.channel.socket.nio.NioEventLoop;, +import io.netty.channel.socket.nio.NioSocketChannel;, +    public void run() throws Exception {, +        ChannelBootstrap b = new ChannelBootstrap();, +        try {, +            b.eventLoop(new NioEventLoop()), +             .channel(new NioSocketChannel()), +             .remoteAddress(host, port), +             .initializer(new ChannelInitializer<SocketChannel>() {, +                @Override, +                public void initChannel(SocketChannel ch) throws Exception {, +                    ch.pipeline().addLast(new DiscardClientHandler(firstMessageSize));, +            // Make the connection attempt., +            ChannelFuture f = b.connect().sync();, +            // Wait until the connection is closed., +            f.channel().closeFuture().sync();, +        } finally {, +            b.shutdown();, +        }, +++ b/example/src/main/java/io/netty/example/discard/DiscardClient.java, +import io.netty.channel.ChannelBootstrap;, +import io.netty.channel.ChannelInitializer;, +import io.netty.channel.socket.SocketChannel;, +import io.netty.channel.socket.nio.NioEventLoop;, +import io.netty.channel.socket.nio.NioSocketChannel;, +    public void run() throws Exception {, +        ChannelBootstrap b = new ChannelBootstrap();, +        try {, +            b.eventLoop(new NioEventLoop()), +             .channel(new NioSocketChannel()), +             .remoteAddress(host, port), +             .initializer(new ChannelInitializer<SocketChannel>() {, +                @Override, +                public void initChannel(SocketChannel ch) throws Exception {, +                    ch.pipeline().addLast(new DiscardClientHandler(firstMessageSize));, +            // Make the connection attempt., +            ChannelFuture f = b.connect().sync();, +            // Wait until the connection is closed., +            f.channel().closeFuture().sync();, +        } finally {, +            b.shutdown();, +        }, +++ b/example/src/main/java/io/netty/example/discard/DiscardClientHandler.java, +import io.netty.buffer.ChannelBuffer;, +import io.netty.channel.ChannelFuture;, +import io.netty.channel.ChannelFutureListener;, +import io.netty.channel.ChannelInboundHandlerContext;, +import io.netty.channel.ChannelInboundStreamHandlerAdapter;, +, +public class DiscardClientHandler extends ChannelInboundStreamHandlerAdapter {, +    private ChannelInboundHandlerContext<Byte> ctx;, +    private ChannelBuffer out;, +    public void channelActive(ChannelInboundHandlerContext<Byte> ctx), +            throws Exception {, +        this.ctx = ctx;, +        out = ctx.out().byteBuffer();, +        generateTraffic();, +    public void inboundBufferUpdated(ChannelInboundHandlerContext<Byte> ctx), +            throws Exception {, +    public void exceptionCaught(ChannelInboundHandlerContext<Byte> ctx,, +            Throwable cause) throws Exception {, +                cause);, +        ctx.close();, +    long counter;, +, +    private void generateTraffic() {, +        // Fill the outbound buffer up to 64KiB, +        while (out.readableBytes() < 65536) {, +            out.writeBytes(content);, +        // Flush the outbound buffer to the socket., +        // Once flushed, generate the same amount of traffic again., +        ctx.flush().addListener(GENERATE_TRAFFIC);, +, +    private final ChannelFutureListener GENERATE_TRAFFIC = new ChannelFutureListener() {, +        @Override, +        public void operationComplete(ChannelFuture future) throws Exception {, +            if (future.isSuccess()) {, +                out.clear();, +                generateTraffic();, +            }, +        }, +    };, +++ b/example/src/main/java/io/netty/example/discard/DiscardClient.java, +import io.netty.channel.ChannelBootstrap;, +import io.netty.channel.ChannelInitializer;, +import io.netty.channel.socket.SocketChannel;, +import io.netty.channel.socket.nio.NioEventLoop;, +import io.netty.channel.socket.nio.NioSocketChannel;, +    public void run() throws Exception {, +        ChannelBootstrap b = new ChannelBootstrap();, +        try {, +            b.eventLoop(new NioEventLoop()), +             .channel(new NioSocketChannel()), +             .remoteAddress(host, port), +             .initializer(new ChannelInitializer<SocketChannel>() {, +                @Override]