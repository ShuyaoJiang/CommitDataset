[+++ b/transport/src/main/java/io/netty/channel/socket/nio/NioEventLoop.java, +import io.netty.channel.EventLoopException;, +public final class NioEventLoop extends SingleThreadEventLoop {, +    /**, +     * Registers an arbitrary {@link SelectableChannel}, not necessarily created by Netty, to the {@link Selector}, +     * of this event loop.  Once the specified {@link SelectableChannel} is registered, the specified {@code task} will, +     * be executed by this event loop when the {@link SelectableChannel} is ready., +     */, +    public void register(final SelectableChannel ch, final int interestOps, final NioTask<?> task) {, +        if (ch == null) {, +            throw new NullPointerException("ch");, +        }, +        if (interestOps == 0) {, +            throw new IllegalArgumentException("interestOps must be non-zero.");, +        }, +        if ((interestOps & ~ch.validOps()) != 0) {, +            throw new IllegalArgumentException(, +                    "invalid interestOps: " + interestOps + "(validOps: " + ch.validOps() + ")");, +        }, +        if (task == null) {, +            throw new NullPointerException("task");, +        }, +, +        if (isShutdown()) {, +            throw new IllegalStateException("event loop shut down");, +        }, +, +        try {, +            ch.register(selector, interestOps, task);, +        } catch (Exception e) {, +            throw new EventLoopException("failed to register a channel", e);, +        }, +    }, +, +        final Selector newSelector = openSelector();, +        final Selector oldSelector = this.selector;, +        // Register all channels to the new Selector., +        boolean success = false;, +            for (SelectionKey key: oldSelector.keys()) {, +                key.channel().register(newSelector, key.interestOps(), key.attachment());, +            }, +            success = true;, +        } catch (Exception e) {, +            logger.warn("Failed to re-register a Channel to the new Selector.", e);, +        } finally {, +            if (!success) {, +                try {, +                    newSelector.close();, +                } catch (Exception e) {, +                    logger.warn("Failed to close the new Selector.", e);, +        }, +, +        if (!success) {, +            // Keep using the old Selector on failure., +            return oldSelector;, +        }, +, +        // Registration to the new Selector is done. Close the old Selector to cancel all old keys., +        } catch (Exception e) {, +            logger.warn("Failed to close the old selector.", e);, +, +        logger.info("Selector migration complete.");, +        return this.selector = newSelector;, +                final Object a = k.attachment();, +                if (a instanceof AbstractNioChannel) {, +                    processSelectedKey(k, (AbstractNioChannel) a);, +                } else {, +                    processSelectedKey(k, (NioTask<SelectableChannel>) a);, +    private static void processSelectedKey(SelectionKey k, AbstractNioChannel ch) {, +        final NioUnsafe unsafe = ch.unsafe();, +        try {, +            int readyOps = k.readyOps();, +            if ((readyOps & (SelectionKey.OP_READ | SelectionKey.OP_ACCEPT)) != 0 || readyOps == 0) {, +                unsafe.read();, +                if (!ch.isOpen()) {, +                    // Connection already closed - no need to handle write., +                    return;, +                }, +            }, +            if ((readyOps & SelectionKey.OP_WRITE) != 0) {, +                unsafe.flushNow();, +            }, +            if ((readyOps & SelectionKey.OP_CONNECT) != 0) {, +                unsafe.finishConnect();, +            }, +        } catch (CancelledKeyException ignored) {, +            unsafe.close(unsafe.voidFuture());, +        }, +    }, +, +    private static void processSelectedKey(SelectionKey k, NioTask<SelectableChannel> task) {, +        boolean success = false;, +        try {, +            task.channelReady(k.channel(), k);, +            success = true;, +        } catch (Exception e) {, +            logger.warn("Unexpected exception while running NioTask.channelReady() - cancelling the key", e);, +        } finally {, +            if (!success) {, +                k.cancel();]