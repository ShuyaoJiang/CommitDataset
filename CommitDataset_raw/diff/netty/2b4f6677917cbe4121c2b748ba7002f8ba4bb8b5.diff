[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/DefaultHttpDataFactory.java, +import io.netty.handler.codec.http.DefaultHttpRequest;, +import java.util.Collections;, +import java.util.IdentityHashMap;, + * Default factory giving {@link Attribute} and {@link FileUpload} according to constructor., + * <p>According to the constructor, {@link Attribute} and {@link FileUpload} can be:</p>, + * <ul>, + * <li>MemoryAttribute, DiskAttribute or MixedAttribute</li>, + * <li>MemoryFileUpload, DiskFileUpload or MixedFileUpload</li>, + * </ul>, +     * Keep all {@link HttpData}s until cleaning methods are called., +     * We need to use {@link IdentityHashMap} because different requests may be equal., +     * See {@link DefaultHttpRequest#hashCode} and {@link DefaultHttpRequest#equals}., +     * Similarly, when removing data items, we need to check their identities because, +     * different data items may be equal., +    private final Map<HttpRequest, List<HttpData>> requestFileDeleteMap =, +            Collections.synchronizedMap(new IdentityHashMap<HttpRequest, List<HttpData>>());, +     * @return the associated list of {@link HttpData} for the request, +            List<HttpData> list = getList(request);, +            list.add(attribute);, +            List<HttpData> list = getList(request);, +            list.add(attribute);, +            List<HttpData> list = getList(request);, +            list.add(attribute);, +            List<HttpData> list = getList(request);, +            list.add(attribute);, +            List<HttpData> list = getList(request);, +            list.add(attribute);, +            List<HttpData> list = getList(request);, +            list.add(attribute);, +            List<HttpData> list = getList(request);, +            list.add(fileUpload);, +            List<HttpData> list = getList(request);, +            list.add(fileUpload);, +        if (!(data instanceof HttpData)) {, +            return;, +        }, +, +        // Do not use getList because it adds empty list to requestFileDeleteMap, +        // if request is not found, +        List<HttpData> list = requestFileDeleteMap.get(request);, +        if (list == null) {, +            return;, +        }, +, +        // Can't simply call list.remove(data), because different data items may be equal., +        // Need to check identity., +        Iterator<HttpData> i = list.iterator();, +        while (i.hasNext()) {, +            HttpData n = i.next();, +            if (n == data) {, +                i.remove();, +, +                // Remove empty list to avoid memory leak, +                if (list.isEmpty()) {, +                    requestFileDeleteMap.remove(request);, +                }, +, +                return;, +            }, +        List<HttpData> list = requestFileDeleteMap.remove(request);, +        if (list != null) {, +            for (HttpData data : list) {, +                data.release();, +            // Calling i.remove() here will cause "java.lang.IllegalStateException: Entry was removed", +            // at e.getValue() below, +, +            List<HttpData> list = e.getValue();, +            for (HttpData data : list) {, +                data.release();, +, +            i.remove();, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/DefaultHttpDataFactory.java, +import io.netty.handler.codec.http.DefaultHttpRequest;, +import java.util.Collections;, +import java.util.IdentityHashMap;, + * Default factory giving {@link Attribute} and {@link FileUpload} according to constructor., + * <p>According to the constructor, {@link Attribute} and {@link FileUpload} can be:</p>, + * <ul>, + * <li>MemoryAttribute, DiskAttribute or MixedAttribute</li>, + * <li>MemoryFileUpload, DiskFileUpload or MixedFileUpload</li>, + * </ul>, +     * Keep all {@link HttpData}s until cleaning methods are called., +     * We need to use {@link IdentityHashMap} because different requests may be equal., +     * See {@link DefaultHttpRequest#hashCode} and {@link DefaultHttpRequest#equals}., +     * Similarly, when removing data items, we need to check their identities because, +     * different data items may be equal., +    private final Map<HttpRequest, List<HttpData>> requestFileDeleteMap =, +            Collections.synchronizedMap(new IdentityHashMap<HttpRequest, List<HttpData>>());, +     * @return the associated list of {@link HttpData} for the request, +            List<HttpData> list = getList(request);, +            list.add(attribute);, +            List<HttpData> list = getList(request);, +            list.add(attribute);, +            List<HttpData> list = getList(request);, +            list.add(attribute);, +            List<HttpData> list = getList(request);, +            list.add(attribute);, +            List<HttpData> list = getList(request);, +            list.add(attribute);]