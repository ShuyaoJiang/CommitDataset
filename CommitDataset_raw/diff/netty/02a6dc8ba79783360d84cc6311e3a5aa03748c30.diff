[+++ b/common/src/main/java/io/netty/util/collection/IntObjectHashMap.java, +/*, + * Copyright 2014 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License, version 2.0 (the, + * "License"); you may not use this file except in compliance with the License. You may obtain a, + * copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software distributed under the License, + * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express, + * or implied. See the License for the specific language governing permissions and limitations under, + * the License., + */, +, +package io.netty.util.collection;, +, +import java.lang.reflect.Array;, +import java.util.Arrays;, +import java.util.Iterator;, +import java.util.NoSuchElementException;, +, +/**, + * A hash map implementation of {@link IntObjectMap} that uses open addressing for keys. To minimize, + * the memory footprint, this class uses open addressing rather than chaining. Collisions are, + * resolved using double hashing., + *, + * @param <V> The value type stored in the map., + */, +public class IntObjectHashMap<V> implements IntObjectMap<V>, Iterable<IntObjectMap.Entry<V>> {, +, +    /** State indicating that a slot is available.*/, +    private static final byte AVAILABLE = 0;, +, +    /** State indicating that a slot is occupied. */, +    private static final byte OCCUPIED = 1;, +, +    /** State indicating that a slot was removed. */, +    private static final byte REMOVED = 2;, +, +    /** Default initial capacity. Used if not specified in the constructor */, +    private static final int DEFAULT_CAPACITY = 11;, +, +    /** Default load factor. Used if not specified in the constructor */, +    private static final float DEFAULT_LOAD_FACTOR = 0.5f;, +, +    /** The maximum number of elements allowed without allocating more space. */, +    private int maxSize;, +, +    /** The load factor for the map. Used to calculate {@link maxSize}. */, +    private final float loadFactor;, +, +    private byte[] states;, +    private int[] keys;, +    private V[] values;, +    private int size;, +    private int available;, +, +    public IntObjectHashMap() {, +        this(DEFAULT_CAPACITY, DEFAULT_LOAD_FACTOR);, +    }, +, +    public IntObjectHashMap(int initialCapacity) {, +        this(initialCapacity, DEFAULT_LOAD_FACTOR);, +    }, +, +    public IntObjectHashMap(int initialCapacity, float loadFactor) {, +        if (initialCapacity < 1) {, +            throw new IllegalArgumentException("initialCapacity must be >= 1");, +        }, +        if (loadFactor <= 0.0f) {, +            throw new IllegalArgumentException("loadFactor must be > 0");, +        }, +, +        this.loadFactor = loadFactor;, +, +        // Allocate the arrays., +        states = new byte[initialCapacity];, +        keys = new int[initialCapacity];, +        @SuppressWarnings("unchecked"), +        V[] temp = (V[]) new Object[initialCapacity];, +        values = temp;, +, +        // Initialize the maximum size value., +        maxSize = calcMaxSize(initialCapacity);, +, +        // Initialize the available element count, +        available = initialCapacity - size;, +    }, +, +    @Override, +    public V get(int key) {, +        int index = indexOf(key);, +        return index < 0 ? null : values[index];, +    }, +, +    @Override, +    public V put(int key, V value) {, +        int hash = hash(key);]