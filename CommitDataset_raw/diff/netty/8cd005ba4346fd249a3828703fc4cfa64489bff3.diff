[+++ b/buffer/src/main/java/io/netty/buffer/PoolChunk.java, +import java.nio.ByteBuffer;, +import java.util.ArrayDeque;, +import java.util.Deque;, +, +    // Use as cache for ByteBuffer created from the memory. These are just duplicates and so are only a container, +    // around the memory itself. These are often needed for operations within the Pooled*DirectByteBuf and so, +    // may produce extra GC, which can be greatly reduced by caching the duplicates., +    //, +    // This may be null if the PoolChunk is unpooled as pooling the ByteBuffer instances does not make any sense here., +    private final Deque<ByteBuffer> cachedNioBuffers;, +, +        cachedNioBuffers = new ArrayDeque<ByteBuffer>();, +        cachedNioBuffers = null;, +    }, +, +    ByteBuffer pollCachedNioBuffer() {, +        // We use LIFO to increase the chance that its still "hot" and so in the CPU / L* cache., +        return cachedNioBuffers != null ? cachedNioBuffers.pollLast() : null;, +    }, +, +    void offerCachedNioBuffer(ByteBuffer nioBuffer) {, +        // Only cache if we did not reach the limit yet and if its not unpooled., +        // If we do just drop it on the floor and let the GC collect it., +        if (cachedNioBuffers != null &&, +                cachedNioBuffers.size() <= PooledByteBufAllocator.DEFAULT_MAX_CACHED_BYTEBUFFERS_PER_CHUNK) {, +            cachedNioBuffers.offer(nioBuffer);, +        }, +++ b/buffer/src/main/java/io/netty/buffer/PoolChunk.java, +import java.nio.ByteBuffer;, +import java.util.ArrayDeque;, +import java.util.Deque;, +, +    // Use as cache for ByteBuffer created from the memory. These are just duplicates and so are only a container, +    // around the memory itself. These are often needed for operations within the Pooled*DirectByteBuf and so, +    // may produce extra GC, which can be greatly reduced by caching the duplicates., +    //, +    // This may be null if the PoolChunk is unpooled as pooling the ByteBuffer instances does not make any sense here., +    private final Deque<ByteBuffer> cachedNioBuffers;, +, +        cachedNioBuffers = new ArrayDeque<ByteBuffer>();, +        cachedNioBuffers = null;, +    }, +, +    ByteBuffer pollCachedNioBuffer() {, +        // We use LIFO to increase the chance that its still "hot" and so in the CPU / L* cache., +        return cachedNioBuffers != null ? cachedNioBuffers.pollLast() : null;, +    }, +, +    void offerCachedNioBuffer(ByteBuffer nioBuffer) {, +        // Only cache if we did not reach the limit yet and if its not unpooled., +        // If we do just drop it on the floor and let the GC collect it., +        if (cachedNioBuffers != null &&, +                cachedNioBuffers.size() <= PooledByteBufAllocator.DEFAULT_MAX_CACHED_BYTEBUFFERS_PER_CHUNK) {, +            cachedNioBuffers.offer(nioBuffer);, +        }, +++ b/buffer/src/main/java/io/netty/buffer/PooledByteBuf.java, +        tmpNioBuf = chunk.pollCachedNioBuffer();, +            if (tmpNioBuf != null) {, +                // Try to put back into the cache for later usage., +                chunk.offerCachedNioBuffer(tmpNioBuf);, +            }, +++ b/buffer/src/main/java/io/netty/buffer/PoolChunk.java, +import java.nio.ByteBuffer;, +import java.util.ArrayDeque;, +import java.util.Deque;, +, +    // Use as cache for ByteBuffer created from the memory. These are just duplicates and so are only a container, +    // around the memory itself. These are often needed for operations within the Pooled*DirectByteBuf and so, +    // may produce extra GC, which can be greatly reduced by caching the duplicates., +    //, +    // This may be null if the PoolChunk is unpooled as pooling the ByteBuffer instances does not make any sense here., +    private final Deque<ByteBuffer> cachedNioBuffers;, +, +        cachedNioBuffers = new ArrayDeque<ByteBuffer>();, +        cachedNioBuffers = null;, +    }, +, +    ByteBuffer pollCachedNioBuffer() {, +        // We use LIFO to increase the chance that its still "hot" and so in the CPU / L* cache., +        return cachedNioBuffers != null ? cachedNioBuffers.pollLast() : null;, +    }, +, +    void offerCachedNioBuffer(ByteBuffer nioBuffer) {, +        // Only cache if we did not reach the limit yet and if its not unpooled., +        // If we do just drop it on the floor and let the GC collect it., +        if (cachedNioBuffers != null &&, +                cachedNioBuffers.size() <= PooledByteBufAllocator.DEFAULT_MAX_CACHED_BYTEBUFFERS_PER_CHUNK) {, +            cachedNioBuffers.offer(nioBuffer);, +        }, +++ b/buffer/src/main/java/io/netty/buffer/PooledByteBuf.java, +        tmpNioBuf = chunk.pollCachedNioBuffer();, +            if (tmpNioBuf != null) {, +                // Try to put back into the cache for later usage., +                chunk.offerCachedNioBuffer(tmpNioBuf);, +            }, +++ b/buffer/src/main/java/io/netty/buffer/PooledByteBufAllocator.java, +    static final int DEFAULT_MAX_CACHED_BYTEBUFFERS_PER_CHUNK;, +        DEFAULT_MAX_CACHED_BYTEBUFFERS_PER_CHUNK = SystemPropertyUtil.getInt(, +                "io.netty.allocator.maxCachedByteBuffersPerChunk", 1024);]