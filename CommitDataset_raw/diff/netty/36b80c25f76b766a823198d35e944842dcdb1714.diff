[+++ b/common/src/main/java/io/netty/util/concurrent/SingleThreadEventExecutor.java, +     * Returns {@code true} if a scheduled task is ready for processing by {@link #runAllTasks()} or, +     * {@link #runAllTasks(long)}., +     */, +    protected boolean hasScheduledTasks() {, +        assert inEventLoop();, +        ScheduledFutureTask<?> delayedTask = delayedTaskQueue.peek();, +        return delayedTask != null && delayedTask.deadlineNanos() <= ScheduledFutureTask.nanoTime();, +    }, +, +    /**, +++ b/common/src/main/java/io/netty/util/concurrent/SingleThreadEventExecutor.java, +     * Returns {@code true} if a scheduled task is ready for processing by {@link #runAllTasks()} or, +     * {@link #runAllTasks(long)}., +     */, +    protected boolean hasScheduledTasks() {, +        assert inEventLoop();, +        ScheduledFutureTask<?> delayedTask = delayedTaskQueue.peek();, +        return delayedTask != null && delayedTask.deadlineNanos() <= ScheduledFutureTask.nanoTime();, +    }, +, +    /**, +++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollEventLoop.java, +    private int epollWait(boolean oldWakenUp) {, +            if (selectedKeys != 0 || oldWakenUp || wakenUp == 1 || hasTasks() || hasScheduledTasks()) {, +                // - Selected something,, +                // - waken up by user, or, +                // - the task queue has a pending task., +                // - a scheduled task is ready for processing, +            boolean oldWakenUp = WAKEN_UP_UPDATER.getAndSet(this, 0) == 1;, +                    ready = epollWait(oldWakenUp);, +++ b/common/src/main/java/io/netty/util/concurrent/SingleThreadEventExecutor.java, +     * Returns {@code true} if a scheduled task is ready for processing by {@link #runAllTasks()} or, +     * {@link #runAllTasks(long)}., +     */, +    protected boolean hasScheduledTasks() {, +        assert inEventLoop();, +        ScheduledFutureTask<?> delayedTask = delayedTaskQueue.peek();, +        return delayedTask != null && delayedTask.deadlineNanos() <= ScheduledFutureTask.nanoTime();, +    }, +, +    /**, +++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollEventLoop.java, +    private int epollWait(boolean oldWakenUp) {, +            if (selectedKeys != 0 || oldWakenUp || wakenUp == 1 || hasTasks() || hasScheduledTasks()) {, +                // - Selected something,, +                // - waken up by user, or, +                // - the task queue has a pending task., +                // - a scheduled task is ready for processing, +            boolean oldWakenUp = WAKEN_UP_UPDATER.getAndSet(this, 0) == 1;, +                    ready = epollWait(oldWakenUp);, +++ b/transport/src/main/java/io/netty/channel/nio/NioEventLoop.java, +import java.util.concurrent.TimeUnit;, +            boolean oldWakenUp = wakenUp.getAndSet(false);, +                    select(oldWakenUp);, +        final AbstractNioChannel.NioUnsafe unsafe = ch.unsafe();, +    private void select(boolean oldWakenUp) throws IOException {, +                if (selectedKeys != 0 || oldWakenUp || wakenUp.get() || hasTasks() || hasScheduledTasks()) {, +                    // - Selected something,, +                    // - waken up by user, or, +                    // - the task queue has a pending task., +                    // - a scheduled task is ready for processing, +, +                long time = System.nanoTime();, +                if ((time - TimeUnit.MILLISECONDS.toNanos(timeoutMillis)) >= currentTimeNanos) {, +                    // timeoutMillis elapsed without anything selected., +                    selectCnt = 1;, +                } else if (SELECTOR_AUTO_REBUILD_THRESHOLD > 0 &&, +                currentTimeNanos = time;]