[+++ b/common/src/main/java/io/netty/util/internal/logging/InternalLoggerFactory.java, +import java.util.concurrent.atomic.AtomicReference;, +, + * Creates {@link InternalLogger}s. This factory allows you to choose what logging framework Netty should use. The, + * default factory is {@link Slf4JLoggerFactory}. If SLF4J is not available, {@link Log4JLoggerFactory} is used. If, + * Log4J is not available, {@link JdkLoggerFactory} is used. You can change it to your preferred logging framework, + * before other Netty classes are loaded via {@link #setDefaultFactory(InternalLoggerFactory)}. If you want to change, + * the logger factory, {@link #setDefaultFactory(InternalLoggerFactory)} must be invoked before any other Netty classes, + * are loaded. Note that {@link #setDefaultFactory(InternalLoggerFactory)}} can not be invoked more than once., +    private static final InternalLoggerFactoryHolder HOLDER = new InternalLoggerFactoryHolder();, +, +    /**, +     * This class holds a reference to the {@link InternalLoggerFactory}. The raison d'être for this class is primarily, +     * to aid in testing., +     */, +    static final class InternalLoggerFactoryHolder {, +        private final AtomicReference<InternalLoggerFactory> reference;, +, +        InternalLoggerFactoryHolder() {, +            this(null);, +        }, +, +        InternalLoggerFactoryHolder(final InternalLoggerFactory holder) {, +            this.reference = new AtomicReference<InternalLoggerFactory>(holder);, +        }, +, +        InternalLoggerFactory getFactory() {, +            if (reference.get() == null) {, +                reference.compareAndSet(null, newDefaultFactory(InternalLoggerFactory.class.getName()));, +            }, +            return reference.get();, +        }, +, +        void setFactory(final InternalLoggerFactory factory) {, +            if (factory == null) {, +                throw new NullPointerException("factory");, +            }, +            if (!reference.compareAndSet(null, factory)) {, +                throw new IllegalStateException(, +                        "factory is already set to [" + reference.get() + "], rejecting [" + factory + "]");, +            }, +        }, +, +        InternalLogger getInstance(final Class<?> clazz) {, +            return getInstance(clazz.getName());, +        }, +, +        InternalLogger getInstance(final String name) {, +            return newInstance(name);, +        }, +, +        InternalLogger newInstance(String name) {, +            return getFactory().newInstance(name);, +        }, +    }, +     * Get the default factory that was either initialized automatically based on logging implementations on the, +     * classpath, or set explicitly via {@link #setDefaultFactory(InternalLoggerFactory)}., +        return HOLDER.getFactory();, +     * Set the default factory. This method must be invoked before the default factory is initialized via, +     * {@link #getDefaultFactory()}, and can not be invoked multiple times., +     *, +     * @param defaultFactory a non-null implementation of {@link InternalLoggerFactory}, +        HOLDER.setFactory(defaultFactory);, +        return HOLDER.getInstance(clazz);, +        return HOLDER.getInstance(name);, +++ b/common/src/main/java/io/netty/util/internal/logging/InternalLoggerFactory.java, +import java.util.concurrent.atomic.AtomicReference;, +, + * Creates {@link InternalLogger}s. This factory allows you to choose what logging framework Netty should use. The, + * default factory is {@link Slf4JLoggerFactory}. If SLF4J is not available, {@link Log4JLoggerFactory} is used. If, + * Log4J is not available, {@link JdkLoggerFactory} is used. You can change it to your preferred logging framework, + * before other Netty classes are loaded via {@link #setDefaultFactory(InternalLoggerFactory)}. If you want to change, + * the logger factory, {@link #setDefaultFactory(InternalLoggerFactory)} must be invoked before any other Netty classes, + * are loaded. Note that {@link #setDefaultFactory(InternalLoggerFactory)}} can not be invoked more than once., +    private static final InternalLoggerFactoryHolder HOLDER = new InternalLoggerFactoryHolder();, +, +    /**, +     * This class holds a reference to the {@link InternalLoggerFactory}. The raison d'être for this class is primarily, +     * to aid in testing., +     */, +    static final class InternalLoggerFactoryHolder {, +        private final AtomicReference<InternalLoggerFactory> reference;, +, +        InternalLoggerFactoryHolder() {, +            this(null);, +        }, +, +        InternalLoggerFactoryHolder(final InternalLoggerFactory holder) {, +            this.reference = new AtomicReference<InternalLoggerFactory>(holder);, +        }, +, +        InternalLoggerFactory getFactory() {, +            if (reference.get() == null) {, +                reference.compareAndSet(null, newDefaultFactory(InternalLoggerFactory.class.getName()));, +            }, +            return reference.get();, +        }, +, +        void setFactory(final InternalLoggerFactory factory) {, +            if (factory == null) {]