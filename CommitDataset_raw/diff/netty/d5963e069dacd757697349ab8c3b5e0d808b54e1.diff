[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2RemoteFlowController.java, +    public void sendFlowControlled(ChannelHandlerContext ctx, Http2Stream stream, FlowControlled frame) {, +        checkNotNull(frame, "frame");, +            state.enqueueFrame(frame);, +            frame.error(t);, +            frame.error(t);, +    private final class FlowState {, +        private final Deque<FlowControlled> pendingWriteQueue;, +            pendingWriteQueue = new ArrayDeque<FlowControlled>(2);, +         * Adds the {@code frame} to the pending queue and increments the pending, +         * byte count., +        void enqueueFrame(FlowControlled frame) {, +            incrementPendingBytes(frame.size());, +        FlowControlled peek() {, +                FlowControlled frame = pendingWriteQueue.poll();, +                writeError(frame, streamError(stream.id(), INTERNAL_ERROR,, +                bytesAttempted += write(peek(), maxBytes);, +         * Writes the frame and decrements the stream and connection window sizes. If the frame is in the pending, +         * queue, the written bytes are removed from this branch of the priority tree., +         * <p>, +         * Note: this does not flush the {@link ChannelHandlerContext}., +         * </p>, +         */, +        int write(FlowControlled frame, int allowedBytes) {, +            int before = frame.size();, +            int writtenBytes = 0;, +            try {, +                assert !writing;, +, +                // Write the portion of the frame., +                writing = true;, +                needFlush |= frame.write(Math.max(0, allowedBytes));, +                if (!cancelled && frame.size() == 0) {, +                    // This frame has been fully written, remove this frame, +                    // and notify it. Since we remove this frame, +                    // first, we're guaranteed that its error method will not, +                    // be called when we call cancel., +                    pendingWriteQueue.remove();, +                    frame.writeComplete();, +                }, +            } catch (Throwable e) {, +                // Mark the state as cancelled, we'll clear the pending queue, +                // via cancel() below., +                cancelled = true;, +            } finally {, +                writing = false;, +                // Make sure we always decrement the flow control windows, +                // by the bytes written., +                writtenBytes = before - frame.size();, +                decrementFlowControlWindow(writtenBytes);, +                decrementPendingBytes(writtenBytes);, +                // If a cancellation occurred while writing, call cancel again to, +                // clear and error all of the pending writes., +                if (cancelled) {, +                    cancel();, +                }, +            }, +            return writtenBytes;, +        }, +, +        /**, +         * fit into the stream window, then {@link #incrementStreamableBytesForTree} is called to recursively update, +         * this branch of the priority tree., +        void incrementPendingBytes(int numBytes) {, +         * If this frame is in the pending queue, decrements the number of pending bytes for the stream., +        void decrementPendingBytes(int bytes) {, +            incrementPendingBytes(-bytes);, +                int negativeBytes = -bytes;, +                connectionState().incrementStreamWindow(negativeBytes);, +                incrementStreamWindow(negativeBytes);, +            } catch (Http2Exception e) {, +                // Should never get here since we're decrementing., +                throw new IllegalStateException("Invalid window state when writing frame: " + e.getMessage(), e);, +         * Discards this {@link FlowControlled}, writing an error. If this frame is in the pending queue,, +         * the unwritten bytes are removed from this branch of the priority tree., +        void writeError(FlowControlled frame, Http2Exception cause) {, +            decrementPendingBytes(frame.size());, +            frame.error(cause);]