[+++ b/handler/src/main/java/io/netty/handler/stream/ChunkedWriteHandler.java, +import java.io.IOException;, +import java.nio.channels.Channels;, +import java.nio.channels.ClosedChannelException;, +import java.util.Queue;, +import java.util.concurrent.atomic.AtomicBoolean;, +, +    private volatile ChannelHandlerContext ctx;, +    private final AtomicBoolean flush = new AtomicBoolean(false);, +    private void flush(ChannelHandlerContext ctx, boolean fireNow) throws Exception {, +        boolean acquired = false;, +        final Channel channel = ctx.getChannel();, +, +        // use CAS to see if the have flush already running, if so we don't need to take futher actions, +        if (acquired = flush.compareAndSet(false, true)) {, +            try {, +, +                            final ChunkedInput chunks = (ChunkedInput) m;, +, +                                    // Register a listener which will close the input once the write is complete. This is needed because the Chunk may have, +                                    // some resource bound that can not be closed before its not written, +                                    //, +                                    // See https://github.com/netty/netty/issues/303, +                                    writeFuture.addListener(new ChannelFutureListener() {, +, +                                        @Override, +                                        public void operationComplete(ChannelFuture future) throws Exception {, +                                            closeInput(chunks);, +                                        }, +                                    });, +                                        public void operationComplete(ChannelFuture future) throws Exception {, +                                                currentEvent.getFuture().setFailure(future.getCause());, +            } finally {, +                // mark the flush as done, +                flush.set(false);, +            }, +, +        }, +, +        if (acquired && !channel.isConnected() || channel.isWritable() && !queue.isEmpty()) {, +            flush(ctx, fireNow);, +        }]