[+++ b/src/main/java/org/jboss/netty/util/LinkedTransferQueue.java, +, +public class LinkedTransferQueue<E> extends AbstractQueue<E> implements BlockingQueue<E> {, +    private static final int NOWAIT  = 0;, +    private static final int TIMEOUT = 1;, +    private static final int WAIT    = 2;, +    private static final int NCPUS = Runtime.getRuntime().availableProcessors();, +    private static final int maxTimedSpins = NCPUS < 2? 0 : 32;, +    private static final int maxUntimedSpins = maxTimedSpins * 16;, +    private static final long spinForTimeoutThreshold = 1000L;, +    private static final class QNode extends AtomicReference<Object> {, +, +        private static final AtomicReferenceFieldUpdater<QNode, QNode>, +    private static final class PaddedAtomicReference<T> extends AtomicReference<T> {, +        private static final long serialVersionUID = 4684288940772921317L;, +, +        // enough padding for 64bytes with 4byte refs, +        Object p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, pa, pb, pc, pd, pe;, +        PaddedAtomicReference(T r) { super(r); }, +    }, +    private final PaddedAtomicReference<QNode> head;, +    private final PaddedAtomicReference<QNode> tail;, +    private final PaddedAtomicReference<QNode> cleanMe;, +        head = new PaddedAtomicReference<QNode>(dummy);, +        tail = new PaddedAtomicReference<QNode>(dummy);, +        cleanMe = new PaddedAtomicReference<QNode>(null);, +    @SuppressWarnings("unchecked"), +    E cast(Object e) {, +    private class Itr implements Iterator<E> {, +        private QNode nextNode;    // Next node to return next, +        private QNode currentNode; // last returned node, for remove(), +        private QNode prevNode;    // predecessor of last returned node, +        private E nextItem;        // Cache of next item, once commited to in next, +        private E advance() {]