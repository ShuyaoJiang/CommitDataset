[+++ b/transport/src/main/java/io/netty/channel/ChannelHandlerInvoker.java, +++ b/transport/src/main/java/io/netty/channel/ChannelHandlerInvoker.java, +++ b/transport/src/main/java/io/netty/channel/ChannelHandlerInvokerUtil.java, +++ b/transport/src/main/java/io/netty/channel/ChannelHandlerInvoker.java, +++ b/transport/src/main/java/io/netty/channel/ChannelHandlerInvokerUtil.java, +++ b/transport/src/main/java/io/netty/channel/DefaultChannelHandlerContext.java, +        ChannelHandlerInvoker invoker = next.invoker();, +        invoker.invokeWrite(next, msg, promise);, +        invoker.invokeFlush(next);, +++ b/transport/src/main/java/io/netty/channel/ChannelHandlerInvoker.java, +++ b/transport/src/main/java/io/netty/channel/ChannelHandlerInvokerUtil.java, +++ b/transport/src/main/java/io/netty/channel/DefaultChannelHandlerContext.java, +        ChannelHandlerInvoker invoker = next.invoker();, +        invoker.invokeWrite(next, msg, promise);, +        invoker.invokeFlush(next);, +++ b/transport/src/main/java/io/netty/channel/DefaultChannelHandlerInvoker.java, +            safeExecuteOutbound(WriteTask.newInstance(ctx, msg, size, promise), promise, msg);, +    static final class WriteTask extends OneTimeTask implements SingleThreadEventLoop.NonWakeupRunnable {, +        private static WriteTask newInstance(, +                ChannelHandlerContext ctx, Object msg, int size, ChannelPromise promise) {, +            task.ctx = ctx;, +            task.msg = msg;, +            task.promise = promise;, +            task.size = size;, +        private final Recycler.Handle<WriteTask> handle;, +, +            this.handle = handle;, +        public void run() {, +            try {, +                if (size > 0) {, +                    ChannelOutboundBuffer buffer = ctx.channel().unsafe().outboundBuffer();, +                    // Check for null as it may be set to null if the channel is closed already, +                    if (buffer != null) {, +                        buffer.decrementPendingOutboundBytes(size);, +                    }, +                }, +                invokeWriteNow(ctx, msg, promise);, +            } finally {, +                // Set to null so the GC can collect them directly, +                ctx = null;, +                msg = null;, +                promise = null;, +, +++ b/transport/src/main/java/io/netty/channel/ChannelHandlerInvoker.java, +++ b/transport/src/main/java/io/netty/channel/ChannelHandlerInvokerUtil.java, +++ b/transport/src/main/java/io/netty/channel/DefaultChannelHandlerContext.java, +        ChannelHandlerInvoker invoker = next.invoker();, +        invoker.invokeWrite(next, msg, promise);, +        invoker.invokeFlush(next);, +++ b/transport/src/main/java/io/netty/channel/DefaultChannelHandlerInvoker.java, +            safeExecuteOutbound(WriteTask.newInstance(ctx, msg, size, promise), promise, msg);, +    static final class WriteTask extends OneTimeTask implements SingleThreadEventLoop.NonWakeupRunnable {, +        private static WriteTask newInstance(, +                ChannelHandlerContext ctx, Object msg, int size, ChannelPromise promise) {, +            task.ctx = ctx;, +            task.msg = msg;, +            task.promise = promise;, +            task.size = size;, +        private final Recycler.Handle<WriteTask> handle;, +, +            this.handle = handle;, +        public void run() {, +            try {, +                if (size > 0) {, +                    ChannelOutboundBuffer buffer = ctx.channel().unsafe().outboundBuffer();, +                    // Check for null as it may be set to null if the channel is closed already, +                    if (buffer != null) {, +                        buffer.decrementPendingOutboundBytes(size);, +                    }, +                }, +                invokeWriteNow(ctx, msg, promise);, +            } finally {, +                // Set to null so the GC can collect them directly, +                ctx = null;, +                msg = null;, +                promise = null;, +, +++ b/transport/src/main/java/io/netty/channel/embedded/EmbeddedEventLoop.java]