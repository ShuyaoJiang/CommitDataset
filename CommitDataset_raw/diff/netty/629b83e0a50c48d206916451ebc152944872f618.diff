[+++ b/buffer/src/main/java/io/netty/buffer/ByteBufUtil.java, +     * Decode a 2-digit hex byte from within a string., +     */, +    public static byte decodeHexByte(CharSequence s, int pos) {, +        return HexUtil.decodeHexByte(s, pos);, +    }, +, +    /**, +     * Decodes part of a string generated by {@link #hexDump(byte[])}, +     */, +    public static byte[] decodeHexDump(CharSequence hexDump, int fromIndex, int length) {, +        return HexUtil.decodeHexDump(hexDump, fromIndex, length);, +    }, +, +    /**, +        /**, +         * Helper to decode half of a hexadecimal number from a string., +         * @param c The ASCII character of the hexadecimal number to decode., +         * Must be in the range {@code [0-9a-fA-F]}., +         * @return The hexadecimal value represented in the ASCII character, +         * given, or {@code -1} if the character is invalid., +         */, +        private static int decodeHexNibble(final char c) {, +            // Character.digit() is not used here, as it addresses a larger, +            // set of characters (both ASCII and full-width latin letters)., +            if ('0' <= c && c <= '9') {, +                return c - '0';, +            }, +            if ('a' <= c && c <= 'f') {, +                return c - 'a' + 0xA;, +            }, +            if ('A' <= c && c <= 'F') {, +                return c - 'A' + 0xA;, +            }, +            return -1;, +        }, +, +        private static byte decodeHexByte(CharSequence s, int pos) {, +            int hi = decodeHexNibble(s.charAt(pos));, +            int lo = decodeHexNibble(s.charAt(pos + 1));, +            if (hi == -1 || lo == -1) {, +                throw new IllegalArgumentException(String.format(, +                        "invalid hex byte '%s' at index %d of '%s'", s.subSequence(pos, pos + 2), pos, s));, +            }, +            return (byte) ((hi << 4) + lo);, +        }, +, +            if (length < 0 || (length & 1) != 0) {, +            for (int i = 0; i < length; i += 2) {, +                bytes[i >>> 1] = decodeHexByte(hexDump, fromIndex + i);, +++ b/buffer/src/main/java/io/netty/buffer/ByteBufUtil.java, +     * Decode a 2-digit hex byte from within a string., +     */, +    public static byte decodeHexByte(CharSequence s, int pos) {, +        return HexUtil.decodeHexByte(s, pos);, +    }, +, +    /**, +     * Decodes part of a string generated by {@link #hexDump(byte[])}, +     */, +    public static byte[] decodeHexDump(CharSequence hexDump, int fromIndex, int length) {, +        return HexUtil.decodeHexDump(hexDump, fromIndex, length);, +    }, +, +    /**, +        /**, +         * Helper to decode half of a hexadecimal number from a string., +         * @param c The ASCII character of the hexadecimal number to decode., +         * Must be in the range {@code [0-9a-fA-F]}., +         * @return The hexadecimal value represented in the ASCII character, +         * given, or {@code -1} if the character is invalid., +         */, +        private static int decodeHexNibble(final char c) {, +            // Character.digit() is not used here, as it addresses a larger, +            // set of characters (both ASCII and full-width latin letters)., +            if ('0' <= c && c <= '9') {, +                return c - '0';, +            }, +            if ('a' <= c && c <= 'f') {, +                return c - 'a' + 0xA;, +            }, +            if ('A' <= c && c <= 'F') {, +                return c - 'A' + 0xA;, +            }, +            return -1;, +        }, +, +        private static byte decodeHexByte(CharSequence s, int pos) {, +            int hi = decodeHexNibble(s.charAt(pos));, +            int lo = decodeHexNibble(s.charAt(pos + 1));, +            if (hi == -1 || lo == -1) {, +                throw new IllegalArgumentException(String.format(, +                        "invalid hex byte '%s' at index %d of '%s'", s.subSequence(pos, pos + 2), pos, s));, +            }, +            return (byte) ((hi << 4) + lo);, +        }, +, +            if (length < 0 || (length & 1) != 0) {, +            for (int i = 0; i < length; i += 2) {, +                bytes[i >>> 1] = decodeHexByte(hexDump, fromIndex + i);]