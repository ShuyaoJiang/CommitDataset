[+++ b/buffer/src/main/java/io/netty/buffer/AdvancedLeakAwareCompositeByteBuf.java, +    public ByteBuf asReadOnly() {, +        recordLeakNonRefCountingOperation(leak);, +        return new AdvancedLeakAwareByteBuf(super.asReadOnly(), leak);, +    }, +, +    @Override, +    public boolean isReadOnly() {, +        recordLeakNonRefCountingOperation(leak);, +        return super.isReadOnly();, +    }, +, +    @Override, +++ b/buffer/src/main/java/io/netty/buffer/AdvancedLeakAwareCompositeByteBuf.java, +    public ByteBuf asReadOnly() {, +        recordLeakNonRefCountingOperation(leak);, +        return new AdvancedLeakAwareByteBuf(super.asReadOnly(), leak);, +    }, +, +    @Override, +    public boolean isReadOnly() {, +        recordLeakNonRefCountingOperation(leak);, +        return super.isReadOnly();, +    }, +, +    @Override, +++ b/buffer/src/main/java/io/netty/buffer/SimpleLeakAwareByteBuf.java, +, +    @Override, +    public ByteBuf asReadOnly() {, +        return new SimpleLeakAwareByteBuf(super.asReadOnly(), leak);, +    }, +++ b/buffer/src/main/java/io/netty/buffer/AdvancedLeakAwareCompositeByteBuf.java, +    public ByteBuf asReadOnly() {, +        recordLeakNonRefCountingOperation(leak);, +        return new AdvancedLeakAwareByteBuf(super.asReadOnly(), leak);, +    }, +, +    @Override, +    public boolean isReadOnly() {, +        recordLeakNonRefCountingOperation(leak);, +        return super.isReadOnly();, +    }, +, +    @Override, +++ b/buffer/src/main/java/io/netty/buffer/SimpleLeakAwareByteBuf.java, +, +    @Override, +    public ByteBuf asReadOnly() {, +        return new SimpleLeakAwareByteBuf(super.asReadOnly(), leak);, +    }, +++ b/buffer/src/main/java/io/netty/buffer/SimpleLeakAwareCompositeByteBuf.java, +, +    @Override, +    public ByteBuf asReadOnly() {, +        return new SimpleLeakAwareByteBuf(super.asReadOnly(), leak);, +    }, +++ b/buffer/src/main/java/io/netty/buffer/AdvancedLeakAwareCompositeByteBuf.java, +    public ByteBuf asReadOnly() {, +        recordLeakNonRefCountingOperation(leak);, +        return new AdvancedLeakAwareByteBuf(super.asReadOnly(), leak);, +    }, +, +    @Override, +    public boolean isReadOnly() {, +        recordLeakNonRefCountingOperation(leak);, +        return super.isReadOnly();, +    }, +, +    @Override, +++ b/buffer/src/main/java/io/netty/buffer/SimpleLeakAwareByteBuf.java, +, +    @Override, +    public ByteBuf asReadOnly() {, +        return new SimpleLeakAwareByteBuf(super.asReadOnly(), leak);, +    }, +++ b/buffer/src/main/java/io/netty/buffer/SimpleLeakAwareCompositeByteBuf.java, +, +    @Override, +    public ByteBuf asReadOnly() {, +        return new SimpleLeakAwareByteBuf(super.asReadOnly(), leak);, +    }, +++ b/buffer/src/main/java/io/netty/buffer/WrappedCompositeByteBuf.java, +import java.nio.channels.FileChannel;, +    public int getBytes(int index, FileChannel out, long position, int length) throws IOException {, +        return wrapped.getBytes(index, out, position, length);, +    }, +, +    @Override, +    public int setBytes(int index, FileChannel in, long position, int length) throws IOException {, +        return wrapped.setBytes(index, in, position, length);, +    }, +, +    @Override, +    public boolean isReadOnly() {, +        return wrapped.isReadOnly();, +    }, +, +    @Override, +    public ByteBuf asReadOnly() {]