[+++ b/buffer/src/main/java/io/netty/buffer/AbstractDerivedByteBuf.java, +        return release0(decrement);, +++ b/buffer/src/main/java/io/netty/buffer/AbstractDerivedByteBuf.java, +        return release0(decrement);, +++ b/buffer/src/main/java/io/netty/buffer/AbstractPooledDerivedByteBuf.java, +            return new PooledNonRetainedDuplicateByteBuf(referenceCountDelegate, unwrap()), +                    .setIndex(idx(readerIndex()), idx(writerIndex()));, +            return PooledDuplicatedByteBuf.newInstance(unwrap(), this, idx(readerIndex()), idx(writerIndex()));, +++ b/buffer/src/main/java/io/netty/buffer/AbstractDerivedByteBuf.java, +        return release0(decrement);, +++ b/buffer/src/main/java/io/netty/buffer/AbstractPooledDerivedByteBuf.java, +            return new PooledNonRetainedDuplicateByteBuf(referenceCountDelegate, unwrap()), +                    .setIndex(idx(readerIndex()), idx(writerIndex()));, +            return PooledDuplicatedByteBuf.newInstance(unwrap(), this, idx(readerIndex()), idx(writerIndex()));, +++ b/buffer/src/main/java/io/netty/buffer/AbstractUnpooledSlicedByteBuf.java, +        return unwrap().duplicate().setIndex(idx(readerIndex()), idx(writerIndex()));, +++ b/buffer/src/main/java/io/netty/buffer/AbstractDerivedByteBuf.java, +        return release0(decrement);, +++ b/buffer/src/main/java/io/netty/buffer/AbstractPooledDerivedByteBuf.java, +            return new PooledNonRetainedDuplicateByteBuf(referenceCountDelegate, unwrap()), +                    .setIndex(idx(readerIndex()), idx(writerIndex()));, +            return PooledDuplicatedByteBuf.newInstance(unwrap(), this, idx(readerIndex()), idx(writerIndex()));, +++ b/buffer/src/main/java/io/netty/buffer/AbstractUnpooledSlicedByteBuf.java, +        return unwrap().duplicate().setIndex(idx(readerIndex()), idx(writerIndex()));, +++ b/buffer/src/main/java/io/netty/buffer/ByteBuf.java, +     * @return A buffer whose readable content is equivalent to the buffer returned by {@link #slice()}., +     * However this buffer will share the capacity of the underlying buffer, and therefore allows access to all of the, +     * underlying content if necessary., +++ b/buffer/src/main/java/io/netty/buffer/AbstractDerivedByteBuf.java, +        return release0(decrement);, +++ b/buffer/src/main/java/io/netty/buffer/AbstractPooledDerivedByteBuf.java, +            return new PooledNonRetainedDuplicateByteBuf(referenceCountDelegate, unwrap()), +                    .setIndex(idx(readerIndex()), idx(writerIndex()));, +            return PooledDuplicatedByteBuf.newInstance(unwrap(), this, idx(readerIndex()), idx(writerIndex()));, +++ b/buffer/src/main/java/io/netty/buffer/AbstractUnpooledSlicedByteBuf.java, +        return unwrap().duplicate().setIndex(idx(readerIndex()), idx(writerIndex()));, +++ b/buffer/src/main/java/io/netty/buffer/ByteBuf.java, +     * @return A buffer whose readable content is equivalent to the buffer returned by {@link #slice()}., +     * However this buffer will share the capacity of the underlying buffer, and therefore allows access to all of the, +     * underlying content if necessary., +++ b/buffer/src/main/java/io/netty/buffer/PooledDuplicatedByteBuf.java, +        return duplicate0().setIndex(readerIndex(), writerIndex());, +++ b/buffer/src/main/java/io/netty/buffer/AbstractDerivedByteBuf.java, +        return release0(decrement);, +++ b/buffer/src/main/java/io/netty/buffer/AbstractPooledDerivedByteBuf.java, +            return new PooledNonRetainedDuplicateByteBuf(referenceCountDelegate, unwrap()), +                    .setIndex(idx(readerIndex()), idx(writerIndex()));, +            return PooledDuplicatedByteBuf.newInstance(unwrap(), this, idx(readerIndex()), idx(writerIndex()));, +++ b/buffer/src/main/java/io/netty/buffer/AbstractUnpooledSlicedByteBuf.java, +        return unwrap().duplicate().setIndex(idx(readerIndex()), idx(writerIndex()));, +++ b/buffer/src/main/java/io/netty/buffer/ByteBuf.java, +     * @return A buffer whose readable content is equivalent to the buffer returned by {@link #slice()}., +     * However this buffer will share the capacity of the underlying buffer, and therefore allows access to all of the, +     * underlying content if necessary., +++ b/buffer/src/main/java/io/netty/buffer/PooledDuplicatedByteBuf.java, +        return duplicate0().setIndex(readerIndex(), writerIndex());, +++ b/buffer/src/main/java/io/netty/buffer/PooledSlicedByteBuf.java, +        return duplicate0().setIndex(idx(readerIndex()), idx(writerIndex()));, +        return PooledDuplicatedByteBuf.newInstance(unwrap(), this, idx(readerIndex()), idx(writerIndex()));, +++ b/buffer/src/main/java/io/netty/buffer/AbstractDerivedByteBuf.java, +        return release0(decrement);, +++ b/buffer/src/main/java/io/netty/buffer/AbstractPooledDerivedByteBuf.java, +            return new PooledNonRetainedDuplicateByteBuf(referenceCountDelegate, unwrap()), +                    .setIndex(idx(readerIndex()), idx(writerIndex()));, +            return PooledDuplicatedByteBuf.newInstance(unwrap(), this, idx(readerIndex()), idx(writerIndex()));, +++ b/buffer/src/main/java/io/netty/buffer/AbstractUnpooledSlicedByteBuf.java, +        return unwrap().duplicate().setIndex(idx(readerIndex()), idx(writerIndex()));, +++ b/buffer/src/main/java/io/netty/buffer/ByteBuf.java, +     * @return A buffer whose readable content is equivalent to the buffer returned by {@link #slice()}., +     * However this buffer will share the capacity of the underlying buffer, and therefore allows access to all of the, +     * underlying content if necessary., +++ b/buffer/src/main/java/io/netty/buffer/PooledDuplicatedByteBuf.java, +        return duplicate0().setIndex(readerIndex(), writerIndex());, +++ b/buffer/src/main/java/io/netty/buffer/PooledSlicedByteBuf.java, +        return duplicate0().setIndex(idx(readerIndex()), idx(writerIndex()));, +        return PooledDuplicatedByteBuf.newInstance(unwrap(), this, idx(readerIndex()), idx(writerIndex()));, +++ b/buffer/src/test/java/io/netty/buffer/AbstractByteBufTest.java, +        assertEquals(buffer.readableBytes(), duplicate.readableBytes());, +        assertEquals(0, buffer.compareTo(duplicate));, +        assertEquals(buffer.getByte(readerIndex), duplicate.getByte(duplicate.readerIndex()));, +        duplicate.setByte(duplicate.readerIndex(), (byte) (duplicate.getByte(duplicate.readerIndex()) + 1));, +        assertEquals(buffer.getByte(readerIndex), duplicate.getByte(duplicate.readerIndex()));, +        assertEquals(0, slice2.compareTo(slice2.duplicate()));, +        assertEquals(0, slice2.compareTo(slice2.slice()));, +, +        ByteBuf tmpBuf = slice2.retainedDuplicate();, +        assertEquals(0, slice2.compareTo(tmpBuf));, +        tmpBuf.release();, +        tmpBuf = slice2.retainedSlice();, +        assertEquals(0, slice2.compareTo(tmpBuf));, +        tmpBuf.release();, +        assertEquals(0, dup2.compareTo(dup2.duplicate()));, +        assertEquals(0, dup2.compareTo(dup2.slice()));, +, +        ByteBuf tmpBuf = dup2.retainedDuplicate();, +        assertEquals(0, dup2.compareTo(tmpBuf));, +        tmpBuf.release();, +        tmpBuf = dup2.retainedSlice();, +        assertEquals(0, dup2.compareTo(tmpBuf));, +        tmpBuf.release();]