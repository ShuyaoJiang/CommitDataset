[+++ b/src/main/java/org/jboss/netty/handler/codec/replay/ReplayingDecoder.java, +import org.jboss.netty.handler.codec.frame.FrameDecoder;, + * A specialized variation of {@link FrameDecoder} which enables implementation, + * of a non-blocking decoder in the blocking I/O paradigm., + * <p>, + * The biggest difference between {@link ReplayingDecoder} and, + * {@link FrameDecoder} is that {@link ReplayingDecoder} allows you to, + * implement the {@code decode()} and {@code decodeLast()} methods just like, + * all required bytes were received already, rather than checking the, + * availability of the required bytes.  For example, the following, + * {@link FrameDecoder} implementation:, + * <pre>, + * public class IntegerHeaderFrameDecoder extends FrameDecoder {, + *, + *   protected Object decode(ChannelHandlerContext ctx,, + *                           Channel channel,, + *                           ChannelBuffer buf) throws Exception {, + *, + *     if (buf.readableBytes() &lt; 4) {, + *        return <strong>null</strong>;, + *     }, + *, + *     buf.markReaderIndex();, + *     int length = buf.readInt();, + *, + *     if (buf.readableBytes() &lt; length) {, + *        buf.resetReaderIndex();, + *        return <strong>null</strong>;, + *     }, + *, + *     return buf.readBytes(length);, + *   }, + * }, + * </pre>, + * is simplified like the following with {@link ReplayingDecoder}:, + * <pre>, + * public class IntegerHeaderFrameDecoder, + *      extends ReplayingDecoder&lt;VoidEnum&gt; {, + *, + *   protected Object decode(ChannelHandlerContext ctx,, + *                           Channel channel,, + *                           ChannelBuffer buf,, + *                           VoidEnum state) throws Exception {, + *, + *     return buf.readBytes(buf.readInt());, + *   }, + * }, + * </pre>, + *, + * <h3>Limitations</h3>, + * <p>, + * At the cost of the simplicity, {@link ReplayingDecoder} enforces you a few, + * limitations:, + * <ul>, + * <li>Some buffer operations are prohibited.</li>, + * <li>Performance can be worse if the network is slow and the message, + *     format is complicated unlike the example above.</li>, + * </ul>, + *, + * <h3>Improving the performance</h3>, + * <p>, + * Fortunately, the performance of a {@link ReplayingDecoder} implementation, + * can be improved significantly by using the {@code checkpoint()} method., + *, + * <h4>Calling {@code checkpoint(T)} with an {@link Enum}</h4>, + * <p>, + * The easiest way is to create an {@link Enum} type which represents the, + * current state of the decoder and to call {@code checkpoint(T)} method, + * whenever the state changes.  You can have as many states as you want, + * depending on the complexity of the message:, + *, + * <pre>, + * public enum MyDecoderState {, + *   READ_LENGTH,, + *   READ_CONTENT;, + * }, + *, + * public class IntegerHeaderFrameDecoder, + *      extends ReplayingDecoder&lt;<strong>MyDecoderState</strong>&gt; {, + *, + *   private int length;, + *, + *   public IntegerHeaderFrameDecoder() {, + *     // Set the initial state., + *     <strong>super(MyDecoderState.READ_LENGTH);</strong>, + *   }, + *, + *   protected Object decode(ChannelHandlerContext ctx,, + *                           Channel channel,, + *                           ChannelBuffer buf,, + *                           MyDecoderState state) throws Exception {, + *     switch (state) {, + *     case READ_LENGTH:, + *       length = buf.readInt();, + *       <strong>checkpoint(MyDecoderState.READ_CONTENT);</strong>, + *     case READ_CONTENT:, + *       ChannelBuffer frame = buf.readBytes(length);, + *       <strong>checkpoint(MyDecoderState.READ_LENGTH);</strong>, + *       return frame;, + *     default:]