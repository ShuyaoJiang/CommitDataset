[+++ b/common/src/main/java/io/netty/util/internal/MacAddressUtil.java, +import io.netty.util.NetUtil;, +import io.netty.util.internal.logging.InternalLogger;, +import io.netty.util.internal.logging.InternalLoggerFactory;, +, +import static io.netty.util.internal.EmptyArrays.EMPTY_BYTES;, +    private static final int EUI64_MAC_ADDRESS_LENGTH = 8;, +    private static final int EUI48_MAC_ADDRESS_LENGTH = 6;, +, +        byte[] bestMacAddr = EMPTY_BYTES;, +        if (bestMacAddr == EMPTY_BYTES) {, +            case EUI48_MAC_ADDRESS_LENGTH: // EUI-48 - convert to EUI-64, +                byte[] newAddr = new byte[EUI64_MAC_ADDRESS_LENGTH];, +                bestMacAddr = Arrays.copyOf(bestMacAddr, EUI64_MAC_ADDRESS_LENGTH);, +     * Returns the result of {@link #bestAvailableMac()} if non-{@code null} otherwise returns a random EUI-64 MAC, +     * address., +     */, +    public static byte[] defaultMachineId() {, +        byte[] bestMacAddr = MacAddressUtil.bestAvailableMac();, +        if (bestMacAddr == null) {, +            bestMacAddr = new byte[EUI64_MAC_ADDRESS_LENGTH];, +            ThreadLocalRandom.current().nextBytes(bestMacAddr);, +            logger.warn(, +                    "Failed to find a usable hardware address from the network interfaces; using random bytes: {}",, +                    MacAddressUtil.formatAddress(bestMacAddr));, +        }, +        return bestMacAddr;, +    }, +, +    /**, +     * Parse a EUI-48, MAC-48, or EUI-64 MAC address from a {@link String} and return it as a {@code byte[]}., +     * @param value The string representation of the MAC address., +     * @return The byte representation of the MAC address., +     */, +    public static byte[] parseMAC(String value) {, +        final byte[] machineId;, +        final char separator;, +        switch (value.length()) {, +            case 17:, +                separator = value.charAt(2);, +                validateMacSeparator(separator);, +                machineId = new byte[EUI48_MAC_ADDRESS_LENGTH];, +                break;, +            case 23:, +                separator = value.charAt(2);, +                validateMacSeparator(separator);, +                machineId = new byte[EUI64_MAC_ADDRESS_LENGTH];, +                break;, +            default:, +                throw new IllegalArgumentException("value is not supported [MAC-48, EUI-48, EUI-64]");, +        }, +, +        final int end = machineId.length - 1;, +        int j = 0;, +        for (int i = 0; i < end; ++i, j += 3) {, +            final int sIndex = j + 2;, +            machineId[i] = (byte) Integer.parseInt(value.substring(j, sIndex), 16);, +            if (value.charAt(sIndex) != separator) {, +                throw new IllegalArgumentException("expected separator '" + separator + " but got '" +, +                        value.charAt(sIndex) + "' at index: " + sIndex);, +            }, +        }, +, +        machineId[end] = (byte) Integer.parseInt(value.substring(j, value.length()), 16);, +, +        return machineId;, +    }, +, +    private static void validateMacSeparator(char separator) {, +        if (separator != ':' && separator != '-') {, +            throw new IllegalArgumentException("unsupported seperator: " + separator + " (expected: [:-])");, +        }, +    }, +, +    /**, +        if (candidate == null || candidate.length < EUI48_MAC_ADDRESS_LENGTH) {, +        if (current.length == 0 || (current[0] & 2) == 0) {, +        } else if ((candidate[0] & 2) == 0) {, +        }, +++ b/common/src/main/java/io/netty/util/internal/MacAddressUtil.java, +import io.netty.util.NetUtil;, +import io.netty.util.internal.logging.InternalLogger;, +import io.netty.util.internal.logging.InternalLoggerFactory;, +, +import static io.netty.util.internal.EmptyArrays.EMPTY_BYTES;, +    private static final int EUI64_MAC_ADDRESS_LENGTH = 8;, +    private static final int EUI48_MAC_ADDRESS_LENGTH = 6;, +, +        byte[] bestMacAddr = EMPTY_BYTES;, +        if (bestMacAddr == EMPTY_BYTES) {, +            case EUI48_MAC_ADDRESS_LENGTH: // EUI-48 - convert to EUI-64, +                byte[] newAddr = new byte[EUI64_MAC_ADDRESS_LENGTH];, +                bestMacAddr = Arrays.copyOf(bestMacAddr, EUI64_MAC_ADDRESS_LENGTH);, +     * Returns the result of {@link #bestAvailableMac()} if non-{@code null} otherwise returns a random EUI-64 MAC, +     * address., +     */, +    public static byte[] defaultMachineId() {, +        byte[] bestMacAddr = MacAddressUtil.bestAvailableMac();, +        if (bestMacAddr == null) {, +            bestMacAddr = new byte[EUI64_MAC_ADDRESS_LENGTH];]