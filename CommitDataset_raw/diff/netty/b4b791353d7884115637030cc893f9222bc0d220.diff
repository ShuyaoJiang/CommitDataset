[+++ b/common/src/main/java/io/netty/util/AsciiString.java, +import static io.netty.util.internal.ObjectUtil.checkNotNull;, + * {@link ByteBuffer}. It is often used in conjunction with {@link Headers} that require a {@link CharSequence}., +    /**, +     * {@inheritDoc}, +     * <p>, +     * Provides a case-insensitive hash code for Ascii like byte strings., +     */, +        if (hash == 0) {, +            hash = PlatformDependent.hashCodeAscii(value, offset, length);, +        return length() == other.length() &&, +               hashCode() == other.hashCode() &&, +               PlatformDependent.equals(array(), arrayOffset(), other.array(), other.arrayOffset(), length());, +            return AsciiString.hashCode(o);, +, +     * {@link CharSequence}s into the same headers., +        return PlatformDependent.hashCodeAscii(value);, +++ b/common/src/main/java/io/netty/util/AsciiString.java, +import static io.netty.util.internal.ObjectUtil.checkNotNull;, + * {@link ByteBuffer}. It is often used in conjunction with {@link Headers} that require a {@link CharSequence}., +    /**, +     * {@inheritDoc}, +     * <p>, +     * Provides a case-insensitive hash code for Ascii like byte strings., +     */, +        if (hash == 0) {, +            hash = PlatformDependent.hashCodeAscii(value, offset, length);, +        return length() == other.length() &&, +               hashCode() == other.hashCode() &&, +               PlatformDependent.equals(array(), arrayOffset(), other.array(), other.arrayOffset(), length());, +            return AsciiString.hashCode(o);, +, +     * {@link CharSequence}s into the same headers., +        return PlatformDependent.hashCodeAscii(value);, +++ b/common/src/main/java/io/netty/util/internal/PlatformDependent.java, +import static io.netty.util.internal.PlatformDependent0.HASH_CODE_ASCII_SEED;, +import static io.netty.util.internal.PlatformDependent0.hashCodeAsciiCompute;, +import static io.netty.util.internal.PlatformDependent0.hashCodeAsciiSanitize;, +import static io.netty.util.internal.PlatformDependent0.hashCodeAsciiSanitizeAsByte;, +, +    private static long getLongSafe(byte[] bytes, int offset) {, +        if (BIG_ENDIAN_NATIVE_ORDER) {, +            return (long) bytes[offset] << 56 |, +                    ((long) bytes[offset + 1] & 0xff) << 48 |, +                    ((long) bytes[offset + 2] & 0xff) << 40 |, +                    ((long) bytes[offset + 3] & 0xff) << 32 |, +                    ((long) bytes[offset + 4] & 0xff) << 24 |, +                    ((long) bytes[offset + 5] & 0xff) << 16 |, +                    ((long) bytes[offset + 6] & 0xff) <<  8 |, +                    (long) bytes[offset + 7] & 0xff;, +        }, +        return (long) bytes[offset] & 0xff |, +                ((long) bytes[offset + 1] & 0xff) << 8 |, +                ((long) bytes[offset + 2] & 0xff) << 16 |, +                ((long) bytes[offset + 3] & 0xff) << 24 |, +                ((long) bytes[offset + 4] & 0xff) << 32 |, +                ((long) bytes[offset + 5] & 0xff) << 40 |, +                ((long) bytes[offset + 6] & 0xff) << 48 |, +                ((long) bytes[offset + 7] & 0xff) << 56;, +    }, +, +    private static long getLongFromBytesSafe(CharSequence bytes, int offset) {, +        if (BIG_ENDIAN_NATIVE_ORDER) {, +            return (long) bytes.charAt(offset) << 56 |, +                    ((long) bytes.charAt(offset + 1) & 0xff) << 48 |, +                    ((long) bytes.charAt(offset + 2) & 0xff) << 40 |, +                    ((long) bytes.charAt(offset + 3) & 0xff) << 32 |, +                    ((long) bytes.charAt(offset + 4) & 0xff) << 24 |, +                    ((long) bytes.charAt(offset + 5) & 0xff) << 16 |, +                    ((long) bytes.charAt(offset + 6) & 0xff) <<  8 |, +                    (long) bytes.charAt(offset + 7) & 0xff;, +        }, +        return (long) bytes.charAt(offset) & 0xff |, +                ((long) bytes.charAt(offset + 1) & 0xff) << 8 |, +                ((long) bytes.charAt(offset + 2) & 0xff) << 16 |, +                ((long) bytes.charAt(offset + 3) & 0xff) << 24 |, +                ((long) bytes.charAt(offset + 4) & 0xff) << 32 |, +                ((long) bytes.charAt(offset + 5) & 0xff) << 40 |, +                ((long) bytes.charAt(offset + 6) & 0xff) << 48 |, +                ((long) bytes.charAt(offset + 7) & 0xff) << 56;, +    }, +, +    private static int getIntSafe(byte[] bytes, int offset) {, +        if (BIG_ENDIAN_NATIVE_ORDER) {, +            return bytes[offset] << 24 |, +                    (bytes[offset + 1] & 0xff) << 16 |, +                    (bytes[offset + 2] & 0xff) << 8 |, +                    bytes[offset + 3] & 0xff;, +        }, +        return bytes[offset] & 0xff |, +                (bytes[offset + 1] & 0xff) << 8 |, +                (bytes[offset + 2] & 0xff) << 16 |, +                bytes[offset + 3] << 24;, +    }, +, +    private static int getIntFromBytesSafe(CharSequence bytes, int offset) {, +        if (BIG_ENDIAN_NATIVE_ORDER) {, +            return bytes.charAt(offset) << 24 |, +                    (bytes.charAt(offset + 1) & 0xff) << 16 |, +                    (bytes.charAt(offset + 2) & 0xff) << 8 |]