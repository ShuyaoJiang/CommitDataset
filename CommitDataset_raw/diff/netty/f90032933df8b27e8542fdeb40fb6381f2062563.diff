[+++ b/handler/src/main/java/io/netty/handler/timeout/WriteTimeoutHandler.java, + * Raises a {@link WriteTimeoutException} when a write operation cannot finish in a certain period of time., + * // The connection is closed when a write operation cannot finish in 30 seconds., +    /**, +     * A doubly-linked list to track all WriteTimeoutTasks, +     */, +    private WriteTimeoutTask lastTask;, +, +    public void handlerRemoved(ChannelHandlerContext ctx) throws Exception {, +        WriteTimeoutTask task = lastTask;, +        lastTask = null;, +        while (task != null) {, +            task.scheduledFuture.cancel(false);, +            WriteTimeoutTask prev = task.prev;, +            task.prev = null;, +            task.next = null;, +            task = prev;, +    private void scheduleTimeout(final ChannelHandlerContext ctx, final ChannelPromise promise) {, +        // Schedule a timeout., +        final WriteTimeoutTask task = new WriteTimeoutTask(ctx, promise);, +        task.scheduledFuture = ctx.executor().schedule(task, timeoutNanos, TimeUnit.NANOSECONDS);, +, +        if (!task.scheduledFuture.isDone()) {, +            addWriteTimeoutTask(task);, +, +            // Cancel the scheduled timeout if the flush promise is complete., +            promise.addListener(task);, +    }, +, +    private void addWriteTimeoutTask(WriteTimeoutTask task) {, +        if (lastTask == null) {, +            lastTask = task;, +        } else {, +            lastTask.next = task;, +            task.prev = lastTask;, +            lastTask = task;, +        }, +    }, +, +    private void removeWriteTimeoutTask(WriteTimeoutTask task) {, +        if (task == lastTask) {, +            // task is the tail of list, +            assert task.next == null;, +            lastTask = lastTask.prev;, +            if (lastTask != null) {, +                lastTask.next = null;, +            }, +        } else if (task.prev == null && task.next == null) {, +            // Since task is not lastTask, then it has been removed or not been added., +            return;, +        } else if (task.prev == null) {, +            // task is the head of list and the list has at least 2 nodes, +            task.next.prev = null;, +        } else {, +            task.prev.next = task.next;, +            task.next.prev = task.prev;, +        }, +        task.prev = null;, +        task.next = null;, +, +    private final class WriteTimeoutTask extends OneTimeTask implements ChannelFutureListener {, +, +        private final ChannelHandlerContext ctx;, +        private final ChannelPromise promise;, +, +        // WriteTimeoutTask is also a node of a doubly-linked list, +        WriteTimeoutTask prev;, +        WriteTimeoutTask next;, +, +        ScheduledFuture<?> scheduledFuture;, +, +        WriteTimeoutTask(ChannelHandlerContext ctx, ChannelPromise promise) {, +            this.ctx = ctx;, +            this.promise = promise;, +        }, +, +        @Override, +        public void run() {, +            // Was not written yet so issue a write timeout, +            // The promise itself will be failed with a ClosedChannelException once the close() was issued, +            // See https://github.com/netty/netty/issues/2159, +            if (!promise.isDone()) {, +                try {, +                    writeTimedOut(ctx);, +                } catch (Throwable t) {, +                    ctx.fireExceptionCaught(t);, +                }, +            }, +            removeWriteTimeoutTask(this);, +        }, +, +        @Override, +        public void operationComplete(ChannelFuture future) throws Exception {, +            // scheduledFuture has already be set when reaching here, +            scheduledFuture.cancel(false);, +            removeWriteTimeoutTask(this);, +        }, +    }]