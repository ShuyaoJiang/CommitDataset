[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectDecoder.java, +    private static final String EMPTY_VALUE = "";, +    private final HeaderParser headerParser;, +    private final LineParser lineParser;, +    // These will be updated by splitHeader(...), +    private CharSequence name;, +    private CharSequence value;, +, +        AppendableCharSequence seq = new AppendableCharSequence(128);, +        lineParser = new LineParser(seq, maxInitialLineLength);, +        headerParser = new HeaderParser(seq, maxHeaderSize);, +            // fall-through, +            // fall-through, +            switch (nextState) {, +                case SKIP_CONTROL_CHARS:, +                    // fast-path, +                    // No content is expected., +                    out.add(message);, +                    out.add(LastHttpContent.EMPTY_LAST_CONTENT);, +                    resetNow();, +                    return;, +                case READ_CHUNK_SIZE:, +                default:, +                    assert nextState == State.READ_FIXED_LENGTH_CONTENT ||, +                            nextState == State.READ_VARIABLE_LENGTH_CONTENT;, +            }, +                ByteBuf content = buffer.readSlice(toRead).retain();, +            ByteBuf content = buffer.readSlice(toRead).retain();, +            checkpoint(State.READ_CHUNKED_CONTENT);, +            // fall-through, +            toRead = Math.min(toRead, actualReadableBytes());, +            if (toRead == 0) {, +                return;, +            }, +            HttpContent chunk = new DefaultHttpContent(buffer.readSlice(toRead).retain());, +            if (chunkSize != 0) {, +            checkpoint(State.READ_CHUNK_DELIMITER);, +            // fall-through, +            boolean chunked = HttpHeaders.isTransferEncodingChunked(message);, +             if (state() == State.READ_VARIABLE_LENGTH_CONTENT && !in.isReadable() && !chunked) {, +                // End of connection., +                out.add(LastHttpContent.EMPTY_LAST_CONTENT);, +                reset();, +                return;, +            }, +            if (isDecodingRequest() || chunked) {, +        name = null;, +        value = null;, +        lineParser.reset();, +        headerParser.reset();, +                    value = value.toString() + ' ' + line.toString().trim();, +                    splitHeader(line);, +        }, +        // reset name and value fields, +        name = null;, +        value = null;, +        CharSequence lastHeader = null;, +                    splitHeader(line);, +                    CharSequence headerName = name;, +                    if (!AsciiString.equalsIgnoreCase(headerName, HttpHeaders.Names.CONTENT_LENGTH) &&, +                            !AsciiString.equalsIgnoreCase(headerName, HttpHeaders.Names.TRANSFER_ENCODING) &&, +                            !AsciiString.equalsIgnoreCase(headerName, HttpHeaders.Names.TRAILER)) {, +                        trailer.trailingHeaders().add(headerName, value);, +                    // reset name and value fields, +                    name = null;, +                    value = null;, +    private void splitHeader(AppendableCharSequence sb) {, +        name = sb.substring(nameStart, nameEnd);, +            value = EMPTY_VALUE;, +        } else {, +            value = sb.substring(valueStart, valueEnd);, +        }, +    private class HeaderParser implements ByteBufProcessor {, +        private final int maxLength;, +        private int size;, +        HeaderParser(AppendableCharSequence seq, int maxLength) {, +            this.maxLength = maxLength;, +, +            // Call checkpoint to make sure the readerIndex is updated correctly, +            checkpoint();, +        public void reset() {, +            size = 0;, +        }, +, +            if (size >= maxLength) {, +                throw newException(maxLength);, +, +        protected TooLongFrameException newException(int maxLength) {, +            return new TooLongFrameException(, +                    "HTTP header is larger than  " + maxLength +, +                            " bytes.");, +        }, +    }, +, +    private final class LineParser extends HeaderParser {, +, +        LineParser(AppendableCharSequence seq, int maxLength) {, +            super(seq, maxLength);, +        }, +]