[+++ b/handler/src/main/java/io/netty/handler/queue/BlockingReadHandler.java, +import io.netty.buffer.ChannelBuffer;, +import io.netty.channel.BlockingOperationException;, +import io.netty.channel.Channel;, +import io.netty.channel.ChannelBufferHolder;, +import io.netty.channel.ChannelBufferHolders;, +import io.netty.channel.ChannelHandlerContext;, +import io.netty.channel.ChannelInboundHandlerAdapter;, +import io.netty.channel.ChannelInboundHandlerContext;, +import io.netty.channel.ChannelPipeline;, +import io.netty.util.internal.QueueFactory;, +, +public class BlockingReadHandler<E> extends ChannelInboundHandlerAdapter<Object> {, +    private static final Object INACTIVE = new Object();, +, +    private volatile ChannelHandlerContext ctx;, +    private final BlockingQueue<Object> queue;, +        this(QueueFactory.createQueue());, +    public BlockingReadHandler(BlockingQueue<Object> queue) {, +    @Override, +    public ChannelBufferHolder<Object> newInboundBuffer(, +            ChannelInboundHandlerContext<Object> ctx) throws Exception {, +        this.ctx = ctx;, +        return ChannelBufferHolders.catchAllBuffer();, +        return filter(readEvent());, +        return filter(readEvent(timeout, unit));, +    }, +, +    @SuppressWarnings("unchecked"), +    private E filter(Object e) throws IOException {, +        if (e == null || e == INACTIVE) {, +        if (e instanceof Throwable) {, +            throw (IOException) new IOException().initCause((Throwable) e);, +        return (E) e;, +    }, +, +    private Object readEvent() throws InterruptedException {, +, +        return queue.take();, +    private Object readEvent(long timeout, TimeUnit unit) throws InterruptedException, BlockingReadTimeoutException {, +        Object o = queue.poll(timeout, unit);, +        if (o == null) {, +            return o;, +        if (ctx.eventLoop().inEventLoop()) {, +            throw new BlockingOperationException();, +    public void channelInactive(ChannelInboundHandlerContext<Object> ctx) throws Exception {, +        addEvent(INACTIVE);, +    public void exceptionCaught(ChannelInboundHandlerContext<Object> ctx,, +            Throwable cause) throws Exception {, +        addEvent(cause);, +    public void afterRemove(ChannelHandlerContext ctx) throws Exception {, +        addEvent(INACTIVE);, +    }, +, +    private void addEvent(Object e) {, +        if (!closed) {, +            if (e == INACTIVE) {, +            queue.add(e);, +        }]