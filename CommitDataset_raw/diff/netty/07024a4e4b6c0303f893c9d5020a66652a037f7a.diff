[+++ b/common/src/main/java/io/netty/util/collection/IntObjectHashMap.java, + * A hash map implementation of {@link IntObjectMap} that uses open addressing for keys., + * To minimize the memory footprint, this class uses open addressing rather than chaining., + * Collisions are resolved using linear probing. Deletions implement compaction, so cost of, + * remove can approach O(N) for full maps, which makes a small loadFactor recommended., +    /**, +     * Placeholder for null values, so we can use the actual null to mean available., +     * (Better than using a placeholder for available: less references for GC processing.), +     */, +    private static final Object NULL_VALUE = new Object();, +, +        if (loadFactor <= 0.0f || loadFactor > 1.0f) {, +            // Cannot exceed 1 because we can never store more than capacity elements;, +            // using a bigger loadFactor would trigger rehashing before the desired load is reached., +            throw new IllegalArgumentException("loadFactor must be > 0 and <= 1");, +        int capacity = adjustCapacity(initialCapacity);, +        keys = new int[capacity];, +        @SuppressWarnings({ "unchecked", }), +        V[] temp = (V[]) new Object[capacity];, +        maxSize = calcMaxSize(capacity);, +    }, +    private static <T> T toExternal(T value) {, +        return value == NULL_VALUE ? null : value;, +    }, +, +    @SuppressWarnings("unchecked"), +    private static <T> T toInternal(T value) {, +        return value == null ? (T) NULL_VALUE : value;, +        return index == -1 ? null : toExternal(values[index]);, +        int startIndex = hashIndex(key);, +        int index = startIndex;, +        for (;;) {, +            if (values[index] == null) {, +                // Found empty slot, use it., +                keys[index] = key;, +                values[index] = toInternal(value);, +                growSize();, +            } else if (keys[index] == key) {, +                // Found existing entry with this key, just replace the value., +                values[index] = toInternal(value);, +                return toExternal(previousValue);, +            // Conflict, keep probing ..., +            if ((index = probeNext(index)) == startIndex) {, +                // Can only happen if the map was full at MAX_ARRAY_SIZE and couldn't grow., +                throw new IllegalStateException("Unable to insert");, +        }, +    private int probeNext(int index) {, +        return index == values.length - 1 ? 0 : index + 1;, +            for (int i = 0; i < source.values.length; ++i) {, +                V sourceValue = source.values[i];, +                if (sourceValue != null) {, +                    put(source.keys[i], sourceValue);, +                }, +        if (index == -1) {, +        return toExternal(prev);, +        Arrays.fill(keys, 0);, +        V v = toInternal(value);, +        for (int i = 0; i < values.length; ++i) {, +            // The map supports null values; this will be matched as NULL_VALUE.equals(NULL_VALUE)., +            if (values[i] != null && values[i].equals(v)) {, +        int targetIx = 0;, +        for (int i = 0; i < values.length; ++i) {, +            if (values[i] != null) {, +                outKeys[targetIx++] = keys[i];, +            }, +        }, +        int targetIx = 0;, +        for (int i = 0; i < values.length; ++i) {, +            if (values[i] != null) {, +                outValues[targetIx++] = values[i];, +            }, +        }, +    @Override, +    public int hashCode() {, +        // Hashcode is based on all non-zero, valid keys. We have to scan the whole keys, +        // array, which may have different lengths for two maps of same size(), so the, +        // capacity cannot be used as input for hashing but the size can., +        int hash = size;, +        for (int i = 0; i < keys.length; ++i) {, +            // 0 can be a valid key or unused slot, but won't impact the hashcode in either case., +            // This way we can use a cheap loop without conditionals, or hard-to-unroll operations,, +            // or the devastatingly bad memory locality of visiting value objects., +            // Also, it's important to use a hash function that does not depend on the ordering, +            // of terms, only their values; since the map is an unordered collection and, +            // entries can end up in different positions in different maps that have the same, +            // elements, but with different history of puts/removes, due to conflicts., +            hash = hash ^ keys[i];, +        return hash;, +    }, +, +    @Override, +    public boolean equals(Object obj) {, +        if (this == obj) {, +            return true;, +        } else if (!(obj instanceof IntObjectMap)) {, +            return false;, +        }, +        @SuppressWarnings("rawtypes"), +        IntObjectMap other = (IntObjectMap) obj;, +        if (size != other.size()) {]