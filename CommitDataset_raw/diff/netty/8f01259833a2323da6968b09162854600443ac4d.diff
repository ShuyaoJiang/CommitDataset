[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/HpackDecoder.java, +import static io.netty.handler.codec.http2.Http2Exception.streamError;, +        Http2HeadersSink sink = new Http2HeadersSink(streamId, headers, maxHeaderListSize, validateHeaders);, +        decode(in, sink);, +        // Now that we've read all of our headers we can perform the validation steps. We must, +        // delay throwing until this point to prevent dynamic table corruption., +        sink.finish();, +    private void decode(ByteBuf in, Sink sink) throws Http2Exception {, +     * @deprecated use {@link #setMaxHeaderListSize(long)}; {@code maxHeaderListSizeGoAway} is, +    private static HeaderType validate(int streamId, CharSequence name,, +                                       HeaderType previousHeaderType) throws Http2Exception {, +                throw streamError(streamId, PROTOCOL_ERROR,, +                        "Pseudo-header field '%s' found after regular header.", name);, +                throw streamError(streamId, PROTOCOL_ERROR, "Invalid HTTP/2 pseudo-header '%s' encountered.", name);, +                throw streamError(streamId, PROTOCOL_ERROR, "Mix of request and response pseudo-headers.");, +    private void insertHeader(Sink sink, CharSequence name, CharSequence value, IndexType indexType) {, +        void finish() throws Http2Exception;, +        private final int streamId;, +        private final boolean validate;, +        private HeaderType previousType;, +        private Http2Exception validationException;, +        public Http2HeadersSink(int streamId, Http2Headers headers, long maxHeaderListSize, boolean validate) {, +            this.streamId = streamId;, +            this.validate = validate;, +        }, +, +        @Override, +        public void finish() throws Http2Exception {, +            if (exceededMaxLength) {, +                headerListSizeExceeded(streamId, maxHeaderListSize, true);, +            } else if (validationException != null) {, +                throw validationException;, +            }, +            exceededMaxLength |= headersLength > maxHeaderListSize;, +, +            if (exceededMaxLength || validationException != null) {, +                // We don't store the header since we've already failed validation requirements., +                return;, +, +            if (validate) {, +                try {, +                    previousType = HpackDecoder.validate(streamId, name, previousType);, +                } catch (Http2Exception ex) {, +                    validationException = ex;, +                    return;, +            headers.add(name, value);, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/HpackDecoder.java, +import static io.netty.handler.codec.http2.Http2Exception.streamError;, +        Http2HeadersSink sink = new Http2HeadersSink(streamId, headers, maxHeaderListSize, validateHeaders);, +        decode(in, sink);, +        // Now that we've read all of our headers we can perform the validation steps. We must, +        // delay throwing until this point to prevent dynamic table corruption., +        sink.finish();, +    private void decode(ByteBuf in, Sink sink) throws Http2Exception {, +     * @deprecated use {@link #setMaxHeaderListSize(long)}; {@code maxHeaderListSizeGoAway} is, +    private static HeaderType validate(int streamId, CharSequence name,, +                                       HeaderType previousHeaderType) throws Http2Exception {, +                throw streamError(streamId, PROTOCOL_ERROR,, +                        "Pseudo-header field '%s' found after regular header.", name);, +                throw streamError(streamId, PROTOCOL_ERROR, "Invalid HTTP/2 pseudo-header '%s' encountered.", name);, +                throw streamError(streamId, PROTOCOL_ERROR, "Mix of request and response pseudo-headers.");, +    private void insertHeader(Sink sink, CharSequence name, CharSequence value, IndexType indexType) {, +        void finish() throws Http2Exception;, +        private final int streamId;, +        private final boolean validate;, +        private HeaderType previousType;, +        private Http2Exception validationException;, +        public Http2HeadersSink(int streamId, Http2Headers headers, long maxHeaderListSize, boolean validate) {, +            this.streamId = streamId;, +            this.validate = validate;, +        }, +, +        @Override, +        public void finish() throws Http2Exception {, +            if (exceededMaxLength) {, +                headerListSizeExceeded(streamId, maxHeaderListSize, true);, +            } else if (validationException != null) {, +                throw validationException;, +            }, +            exceededMaxLength |= headersLength > maxHeaderListSize;, +, +            if (exceededMaxLength || validationException != null) {, +                // We don't store the header since we've already failed validation requirements., +                return;, +, +            if (validate) {, +                try {, +                    previousType = HpackDecoder.validate(streamId, name, previousType);, +                } catch (Http2Exception ex) {, +                    validationException = ex;, +                    return;, +            headers.add(name, value);, +++ b/codec-http2/src/test/java/io/netty/handler/codec/http2/HpackDecoderTest.java, +            expectedException.expect(Http2Exception.StreamException.class);, +            expectedException.expect(Http2Exception.StreamException.class);, +            expectedException.expect(Http2Exception.StreamException.class);, +            expectedException.expect(Http2Exception.StreamException.class);, +, +    @Test, +    public void failedValidationDoesntCorruptHpack() throws Exception {]