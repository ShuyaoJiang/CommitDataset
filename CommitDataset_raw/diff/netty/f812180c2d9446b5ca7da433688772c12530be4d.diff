[+++ b/buffer/src/main/java/io/netty/buffer/ByteBufUtil.java, +        checkNotNull(dst, "dst").setBytes(dstIdx, src.array(), srcIdx + src.arrayOffset(), length);, +        checkNotNull(dst, "dst").writeBytes(src.array(), srcIdx + src.arrayOffset(), length);, +++ b/buffer/src/main/java/io/netty/buffer/ByteBufUtil.java, +        checkNotNull(dst, "dst").setBytes(dstIdx, src.array(), srcIdx + src.arrayOffset(), length);, +        checkNotNull(dst, "dst").writeBytes(src.array(), srcIdx + src.arrayOffset(), length);, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2HeadersEncoder.java, +        encoder.encodeHeader(stream,, +                key.isEntireArrayUsed() ? key.array() : new ByteString(key, true).array(),, +                value.isEntireArrayUsed() ? value.array() : new ByteString(value, true).array(),, +                sensitivityDetector.isSensitive(key, value));, +++ b/buffer/src/main/java/io/netty/buffer/ByteBufUtil.java, +        checkNotNull(dst, "dst").setBytes(dstIdx, src.array(), srcIdx + src.arrayOffset(), length);, +        checkNotNull(dst, "dst").writeBytes(src.array(), srcIdx + src.arrayOffset(), length);, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2HeadersEncoder.java, +        encoder.encodeHeader(stream,, +                key.isEntireArrayUsed() ? key.array() : new ByteString(key, true).array(),, +                value.isEntireArrayUsed() ? value.array() : new ByteString(value, true).array(),, +                sensitivityDetector.isSensitive(key, value));, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/HttpUtil.java, +                    output.add(new AsciiString(translatedName, false), new AsciiString(value, false));, +++ b/buffer/src/main/java/io/netty/buffer/ByteBufUtil.java, +        checkNotNull(dst, "dst").setBytes(dstIdx, src.array(), srcIdx + src.arrayOffset(), length);, +        checkNotNull(dst, "dst").writeBytes(src.array(), srcIdx + src.arrayOffset(), length);, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2HeadersEncoder.java, +        encoder.encodeHeader(stream,, +                key.isEntireArrayUsed() ? key.array() : new ByteString(key, true).array(),, +                value.isEntireArrayUsed() ? value.array() : new ByteString(value, true).array(),, +                sensitivityDetector.isSensitive(key, value));, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/HttpUtil.java, +                    output.add(new AsciiString(translatedName, false), new AsciiString(value, false));, +++ b/common/src/main/java/io/netty/util/AsciiString.java, +                final int a1Len = minLength + a1.arrayOffset();, +                for (int i = a1.arrayOffset(), j = a2.arrayOffset(); i < a1Len; i++, j++) {, +                    byte v1 = a1.value[i];, +                    byte v2 = a2.value[j];, +                for (int i = a1.arrayOffset(), j = 0; j < minLength; i++, j++) {, +                    int c1 = toLowerCase(a1.value[i]);, +                    int c2 = toLowerCase(o2.charAt(j));, +                for (int i = 0, j = a2.arrayOffset(); i < minLength; i++, j++) {, +                    int c2 = toLowerCase(a2.value[j]);, +                final int a1Len = minLength + a1.arrayOffset();, +                for (int i = a1.arrayOffset(), j = a2.arrayOffset(); i < a1Len; i++, j++) {, +                    byte v1 = a1.value[i];, +                    byte v2 = a2.value[j];, +                for (int i = a1.arrayOffset(), j = 0; j < minLength; i++, j++) {, +                    int c1 = a1.value[i];, +                    int c2 = o2.charAt(j);, +                for (int i = 0, j = a2.arrayOffset(); i < minLength; i++, j++) {, +                    int c2 = a2.value[j];, +     * Factory which uses the {@link #AsciiString(byte[], int, int, boolean)} constructor., +     */, +    private static final ByteStringFactory DEFAULT_FACTORY = new ByteStringFactory() {, +        @Override, +        public ByteString newInstance(byte[] value, int start, int length, boolean copy) {, +            return new AsciiString(value, start, length, copy);, +        }, +    };, +, +    /**, +            try {, +                ByteProcessor processor = new ByteProcessor() {, +                    private int hash;, +                    @Override, +                    public boolean process(byte value) throws Exception {, +                        hash = hash * HASH_CODE_PRIME ^ toLowerCase(value) & HASH_CODE_PRIME;, +                        return true;, +                    }, +, +                    @Override, +                    public int hashCode() {, +                        return hash;, +                    }, +                };, +                ((AsciiString) value).forEachByte(processor);, +                return processor.hashCode();, +            } catch (Exception e) {, +                PlatformDependent.throwException(e);, +            }, +            hash = hash * HASH_CODE_PRIME ^ toLowerCase(value.charAt(i)) & HASH_CODE_PRIME;, +    public AsciiString(ByteString value, boolean copy) {, +        super(value, copy);, +    public AsciiString(ByteBuffer value) {, +        super(value);, +        for (int i = 0, j = start; i < length; i++, j++) {, +            this.value[i] = c2b(value.charAt(j));, +    @Override, +    public void arrayChanged() {, +        string = null;, +        super.arrayChanged();, +    }, +, +    @Override, +        for (int i = 0, j = arrayOffset(); i < minLength; i++, j++) {, +            result = b2c(value[j]) - string.charAt(i);, +            byte[] newValue = new byte[thisLen + thatLen];, +            System.arraycopy(value, arrayOffset(), newValue, 0, thisLen);, +            System.arraycopy(that.value, that.arrayOffset(), newValue, thisLen, thatLen);, +        byte[] newValue = new byte[thisLen + thatLen];, +        System.arraycopy(value, arrayOffset(), newValue, 0, thisLen);]