[+++ b/src/main/java/org/jboss/netty/handler/execution/MemoryAwareThreadPoolExecutor.java, +        allowCoreThreadTimeOut(true);, +                    Thread.currentThread().interrupt();, +++ b/src/main/java/org/jboss/netty/handler/execution/MemoryAwareThreadPoolExecutor.java, +        allowCoreThreadTimeOut(true);, +                    Thread.currentThread().interrupt();, +++ b/src/main/java/org/jboss/netty/handler/execution/OrderedMemoryAwareThreadPoolExecutor.java, +import java.util.LinkedList;, +        private final LinkedList<Runnable> tasks = new LinkedList<Runnable>();, +            boolean needsExecution;, +            synchronized (tasks) {, +                needsExecution = tasks.isEmpty();, +            }, +            if (needsExecution) {, +                final Runnable task;, +                synchronized (tasks) {, +                    task = tasks.getFirst();, +                    synchronized (tasks) {, +                        tasks.removeFirst();, +                        if (tasks.isEmpty()) {, +                            break;, +                        }, +                    }, +++ b/src/main/java/org/jboss/netty/handler/execution/MemoryAwareThreadPoolExecutor.java, +        allowCoreThreadTimeOut(true);, +                    Thread.currentThread().interrupt();, +++ b/src/main/java/org/jboss/netty/handler/execution/OrderedMemoryAwareThreadPoolExecutor.java, +import java.util.LinkedList;, +        private final LinkedList<Runnable> tasks = new LinkedList<Runnable>();, +            boolean needsExecution;, +            synchronized (tasks) {, +                needsExecution = tasks.isEmpty();, +            }, +            if (needsExecution) {, +                final Runnable task;, +                synchronized (tasks) {, +                    task = tasks.getFirst();, +                    synchronized (tasks) {, +                        tasks.removeFirst();, +                        if (tasks.isEmpty()) {, +                            break;, +                        }, +                    }, +++ b/src/main/java/org/jboss/netty/handler/ssl/SslHandler.java, + * <h3>Handshake</h3>, + * <p>, + * If {@link #isIssueHandshake()} is {@code false}, + * (default) you will need to take care of calling {@link #handshake()} by your own. In most situations were {@link SslHandler} is used in 'client mode', + * you want to issue a handshake once the connection was established. if {@link #setIssueHandshake(boolean)} is set to <code>true</code> you don't need to , + * worry about this as the {@link SslHandler} will take care of it., + * <p>, + * , +    private volatile boolean issueHandshake = false;, +    , +    private static final ChannelFutureListener HANDSHAKE_LISTENER = new ChannelFutureListener() {, +, +        @Override, +        public void operationComplete(ChannelFuture future) throws Exception {, +            if (!future.isSuccess()) {, +                Channels.fireExceptionCaught(future.getChannel(), future.getCause());, +            }, +        }, +        , +    };, +    , +    /**, +     * Enables or disables the automatic handshake once the {@link Channel} is connected. The value will only have affect if its set before the , +     * {@link Channel} is connected., +     * , +     */, +    public void setIssueHandshake(boolean issueHandshake) {, +        this.issueHandshake = issueHandshake;, +    }, +    , +    /**, +     * Returns <code>true</code> if the automatic handshake is enabled, +     */, +    public boolean isIssueHandshake() {, +        return issueHandshake;, +    }, +    , +    , +, +    /**, +     * Calls {@link #handshake()} once the {@link Channel} is connected, +     */, +    @Override, +    public void channelConnected(ChannelHandlerContext ctx, ChannelStateEvent e) throws Exception {, +        if (issueHandshake) {, +            // issue and handshake and add a listener to it which will fire an exception event if an exception was thrown, +            // while doing the handshake, +            handshake().addListener(HANDSHAKE_LISTENER);, +        }, +        super.channelConnected(ctx, e);     , +    } ]