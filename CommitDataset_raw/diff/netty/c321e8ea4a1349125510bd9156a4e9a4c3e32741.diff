[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2Connection.java, +                throw streamError(streamId, REFUSED_STREAM,, +                      "Cannot create stream %d since this endpoint has received a GOAWAY frame with last stream id %d.",, +                      streamId, localEndpoint.lastStreamKnownByPeer());, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2Connection.java, +                throw streamError(streamId, REFUSED_STREAM,, +                      "Cannot create stream %d since this endpoint has received a GOAWAY frame with last stream id %d.",, +                      streamId, localEndpoint.lastStreamKnownByPeer());, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2ConnectionHandler.java, +            if (!outbound || connection().local().mayHaveCreatedStream(streamId)) {, +            }, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2Connection.java, +                throw streamError(streamId, REFUSED_STREAM,, +                      "Cannot create stream %d since this endpoint has received a GOAWAY frame with last stream id %d.",, +                      streamId, localEndpoint.lastStreamKnownByPeer());, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2ConnectionHandler.java, +            if (!outbound || connection().local().mayHaveCreatedStream(streamId)) {, +            }, +++ b/codec-http2/src/test/java/io/netty/handler/codec/http2/Http2ConnectionRoundtripTest.java, +import static io.netty.buffer.Unpooled.EMPTY_BUFFER;, +import static io.netty.handler.codec.http2.Http2Error.NO_ERROR;, +import static java.lang.Integer.MAX_VALUE;, +        setClientGracefulShutdownTime(0);, +        setClientGracefulShutdownTime(0);, +        setClientGracefulShutdownTime(0);, +                http2Client.encoder().writeHeaders(ctx(), MAX_VALUE + 1, headers, 0, (short) 16, false, 0,, +    public void createStreamAfterReceiveGoAwayShouldNotSendGoAway() throws Exception {, +        bootstrapEnv(1, 1, 2, 1, 1);, +, +        // We want both sides to do graceful shutdown during the test., +        setClientGracefulShutdownTime(10000);, +        setServerGracefulShutdownTime(10000);, +, +        final CountDownLatch clientGoAwayLatch = new CountDownLatch(1);, +        doAnswer(new Answer<Void>() {, +            @Override, +            public Void answer(InvocationOnMock invocationOnMock) throws Throwable {, +                clientGoAwayLatch.countDown();, +                return null;, +            }, +        }).when(clientListener).onGoAwayRead(any(ChannelHandlerContext.class), anyInt(), anyLong(), any(ByteBuf.class));, +, +        // Create a single stream by sending a HEADERS frame to the server., +        final Http2Headers headers = dummyHeaders();, +        runInChannel(clientChannel, new Http2Runnable() {, +            @Override, +            public void run() throws Http2Exception {, +                http2Client.encoder().writeHeaders(ctx(), 3, headers, 0, (short) 16, false, 0,, +                        false, newPromise());, +                http2Client.flush(ctx());, +            }, +        });, +, +        assertTrue(serverSettingsAckLatch.await(DEFAULT_AWAIT_TIMEOUT_SECONDS, SECONDS));, +, +        // Server has received the headers, so the stream is open, +        assertTrue(requestLatch.await(DEFAULT_AWAIT_TIMEOUT_SECONDS, SECONDS));, +, +        runInChannel(serverChannel, new Http2Runnable() {, +            @Override, +            public void run() throws Http2Exception {, +                http2Server.encoder().writeGoAway(serverCtx(), 3, NO_ERROR.code(), EMPTY_BUFFER, serverNewPromise());, +                http2Server.flush(serverCtx());, +            }, +        });, +, +        // wait for the client to receive the GO_AWAY., +        assertTrue(clientGoAwayLatch.await(DEFAULT_AWAIT_TIMEOUT_SECONDS, SECONDS));, +        verify(clientListener).onGoAwayRead(any(ChannelHandlerContext.class), eq(3), eq(NO_ERROR.code()),, +                any(ByteBuf.class));, +, +        final AtomicReference<ChannelFuture> clientWriteAfterGoAwayFutureRef = new AtomicReference<ChannelFuture>();, +        final CountDownLatch clientWriteAfterGoAwayLatch = new CountDownLatch(1);, +        runInChannel(clientChannel, new Http2Runnable() {, +            @Override, +            public void run() throws Http2Exception {, +                ChannelFuture f = http2Client.encoder().writeHeaders(ctx(), 5, headers, 0, (short) 16, false, 0,, +                        true, newPromise());, +                clientWriteAfterGoAwayFutureRef.set(f);, +                http2Client.flush(ctx());, +                f.addListener(new ChannelFutureListener() {, +                    @Override, +                    public void operationComplete(ChannelFuture future) throws Exception {, +                        clientWriteAfterGoAwayLatch.countDown();, +                    }, +                });, +            }, +        });, +, +        // Wait for the client's write operation to complete., +        assertTrue(clientWriteAfterGoAwayLatch.await(DEFAULT_AWAIT_TIMEOUT_SECONDS, SECONDS));, +, +        ChannelFuture clientWriteAfterGoAwayFuture = clientWriteAfterGoAwayFutureRef.get();, +        assertNotNull(clientWriteAfterGoAwayFuture);, +        Throwable clientCause = clientWriteAfterGoAwayFuture.cause();, +        assertThat(clientCause, is(instanceOf(Http2Exception.StreamException.class)));, +        assertEquals(Http2Error.REFUSED_STREAM.code(), ((Http2Exception.StreamException) clientCause).error().code());, +, +        // Wait for the server to receive a GO_AWAY, but this is expected to timeout!, +        assertFalse(goAwayLatch.await(1, SECONDS));]