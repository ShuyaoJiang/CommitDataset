[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/cookie/ClientCookieEncoder.java, +import static io.netty.handler.codec.http.cookie.CookieUtil.add;, +import static io.netty.handler.codec.http.cookie.CookieUtil.addQuoted;, +import static io.netty.handler.codec.http.cookie.CookieUtil.stringBuilder;, +import static io.netty.handler.codec.http.cookie.CookieUtil.stripTrailingSeparator;, +import static io.netty.handler.codec.http.cookie.CookieUtil.stripTrailingSeparatorOrNull;, +import java.util.ArrayList;, +import java.util.Arrays;, +import java.util.Collection;, +import java.util.Comparator;, +import java.util.Iterator;, +import java.util.List;, +, + * A <a href="http://tools.ietf.org/html/rfc6265">RFC6265</a> compliant cookie encoder to be used client side, so, + * only name=value pairs are sent., +     * Strict encoder that validates that name and value chars are in the valid scope and (for methods that accept, +     * multiple cookies) sorts cookies into order of decreasing path length, as specified in RFC6265., +     * Lax instance that doesn't validate name and value, and (for methods that accept multiple cookies) keeps, +     * cookies in the order in which they were given., +     * @param name, +     *            the cookie name, +     * @param value, +     *            the cookie value, +     * @param specified, +     *            the cookie, +     * Sort cookies into decreasing order of path length, breaking ties by sorting into increasing chronological, +     * order of creation time, as recommended by RFC 6265., +     */, +    private static final Comparator<Cookie> COOKIE_COMPARATOR = new Comparator<Cookie>() {, +        @Override, +        public int compare(Cookie c1, Cookie c2) {, +            String path1 = c1.path();, +            String path2 = c2.path();, +            // Cookies with unspecified path default to the path of the request. We don't, +            // know the request path here, but we assume that the length of an unspecified, +            // path is longer than any specified path (i.e. pathless cookies come first),, +            // because setting cookies with a path longer than the request path is of, +            // limited use., +            int len1 = path1 == null ? Integer.MAX_VALUE : path1.length();, +            int len2 = path2 == null ? Integer.MAX_VALUE : path2.length();, +            int diff = len2 - len1;, +            if (diff != 0) {, +                return diff;, +            }, +            // Rely on Java's sort stability to retain creation order in cases where, +            // cookies have same path length., +            return -1;, +        }, +    };, +, +    /**, +     * @param cookies, +     *            some cookies, +        if (strict) {, +            if (cookies.length == 1) {, +                encode(buf, cookies[0]);, +            } else {, +                Cookie[] cookiesSorted = Arrays.copyOf(cookies, cookies.length);, +                Arrays.sort(cookiesSorted, COOKIE_COMPARATOR);, +                for (Cookie c : cookiesSorted) {, +                    encode(buf, c);, +                }, +            }, +        } else {, +                encode(buf, c);, +            }, +        }, +        return stripTrailingSeparatorOrNull(buf);, +    /**, +     * Encodes the specified cookies into a single Cookie header value., +     *, +     * @param cookies, +     *            some cookies, +     * @return a Rfc6265 style Cookie header value, null if no cookies are passed., +     */, +    public String encode(Collection<? extends Cookie> cookies) {, +        if (checkNotNull(cookies, "cookies").isEmpty()) {, +            return null;, +        }, +, +        StringBuilder buf = stringBuilder();, +        if (strict) {, +            if (cookies.size() == 1) {, +                encode(buf, cookies.iterator().next());, +            } else {, +                Cookie[] cookiesSorted = cookies.toArray(new Cookie[cookies.size()]);, +                Arrays.sort(cookiesSorted, COOKIE_COMPARATOR);, +                for (Cookie c : cookiesSorted) {, +            }, +        } else {, +            for (Cookie c : cookies) {, +                encode(buf, c);, +            }, +        }, +        if (strict) {, +            Cookie firstCookie = cookiesIt.next();, +            if (!cookiesIt.hasNext()) {, +                encode(buf, firstCookie);, +            } else {, +                List<Cookie> cookiesList = new ArrayList<Cookie>();]