[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectAggregator.java, +import static io.netty.handler.codec.http.HttpHeaderNames.CONNECTION;, +    private static final FullHttpResponse TOO_LARGE_CLOSE = new DefaultFullHttpResponse(, +            HttpVersion.HTTP_1_1, HttpResponseStatus.REQUEST_ENTITY_TOO_LARGE, Unpooled.EMPTY_BUFFER);, +, +        TOO_LARGE_CLOSE.headers().set(CONTENT_LENGTH, 0);, +        TOO_LARGE_CLOSE.headers().set(CONNECTION, HttpHeaderValues.CLOSE);, +, +            // If the client started to send data already, close because it's impossible to recover., +            // If keep-alive is off and 'Expect: 100-continue' is missing, no need to leave the connection open., +            if (oversized instanceof FullHttpMessage ||, +                !HttpUtil.is100ContinueExpected(oversized) && !HttpUtil.isKeepAlive(oversized)) {, +                ChannelFuture future = ctx.writeAndFlush(TOO_LARGE_CLOSE.retainedDuplicate());, +                future.addListener(new ChannelFutureListener() {, +                    @Override, +                    public void operationComplete(ChannelFuture future) throws Exception {, +                        if (!future.isSuccess()) {, +                            logger.debug("Failed to send a 413 Request Entity Too Large.", future.cause());, +                        }, +                        ctx.close();, +                    }, +                });, +            } else {, +                ctx.writeAndFlush(TOO_LARGE.retainedDuplicate()).addListener(new ChannelFutureListener() {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectAggregator.java, +import static io.netty.handler.codec.http.HttpHeaderNames.CONNECTION;, +    private static final FullHttpResponse TOO_LARGE_CLOSE = new DefaultFullHttpResponse(, +            HttpVersion.HTTP_1_1, HttpResponseStatus.REQUEST_ENTITY_TOO_LARGE, Unpooled.EMPTY_BUFFER);, +, +        TOO_LARGE_CLOSE.headers().set(CONTENT_LENGTH, 0);, +        TOO_LARGE_CLOSE.headers().set(CONNECTION, HttpHeaderValues.CLOSE);, +, +            // If the client started to send data already, close because it's impossible to recover., +            // If keep-alive is off and 'Expect: 100-continue' is missing, no need to leave the connection open., +            if (oversized instanceof FullHttpMessage ||, +                !HttpUtil.is100ContinueExpected(oversized) && !HttpUtil.isKeepAlive(oversized)) {, +                ChannelFuture future = ctx.writeAndFlush(TOO_LARGE_CLOSE.retainedDuplicate());, +                future.addListener(new ChannelFutureListener() {, +                    @Override, +                    public void operationComplete(ChannelFuture future) throws Exception {, +                        if (!future.isSuccess()) {, +                            logger.debug("Failed to send a 413 Request Entity Too Large.", future.cause());, +                        }, +                        ctx.close();, +                    }, +                });, +            } else {, +                ctx.writeAndFlush(TOO_LARGE.retainedDuplicate()).addListener(new ChannelFutureListener() {, +++ b/codec-http/src/test/java/io/netty/handler/codec/http/HttpObjectAggregatorTest.java, +        if (serverShouldCloseConnection(message, response)) {, +    private static boolean serverShouldCloseConnection(HttpRequest message, HttpResponse response) {, +        // If the response wasn't keep-alive, the server should close the connection., +        if (!HttpUtil.isKeepAlive(response)) {, +            return true;, +        }]