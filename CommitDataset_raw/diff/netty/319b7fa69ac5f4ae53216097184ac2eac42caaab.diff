[+++ b/codec/src/main/java/io/netty/handler/codec/compression/Snappy.java, +        for (int i = 0;; i ++) {, +            int b = length >>> i * 7;, +            if ((b & 0xFFFFFF80) != 0) {, +                out.writeByte(b & 0x7f | 0x80);, +                out.writeByte(b);, +                break;, +        while (in.isReadable()) {, +            int current = in.readUnsignedByte();, +            length |= (current & 0x7f) << byteIndex++ * 7;, +            if ((current & 0x80) == 0) {, +                   | in.readUnsignedByte() << 8;, +                   | in.readUnsignedByte() << 8, +                   | in.readUnsignedByte() << 16;, +                   | in.readUnsignedByte() << 8, +                   | in.readUnsignedByte() << 16, +                   | in.readUnsignedByte() << 24;, +++ b/codec/src/main/java/io/netty/handler/codec/compression/Snappy.java, +        for (int i = 0;; i ++) {, +            int b = length >>> i * 7;, +            if ((b & 0xFFFFFF80) != 0) {, +                out.writeByte(b & 0x7f | 0x80);, +                out.writeByte(b);, +                break;, +        while (in.isReadable()) {, +            int current = in.readUnsignedByte();, +            length |= (current & 0x7f) << byteIndex++ * 7;, +            if ((current & 0x80) == 0) {, +                   | in.readUnsignedByte() << 8;, +                   | in.readUnsignedByte() << 8, +                   | in.readUnsignedByte() << 16;, +                   | in.readUnsignedByte() << 8, +                   | in.readUnsignedByte() << 16, +                   | in.readUnsignedByte() << 24;, +++ b/codec/src/main/java/io/netty/handler/codec/compression/SnappyFramedDecoder.java, +            int idx = in.readerIndex();, +            final int inSize = in.writerIndex() - idx;, +            if (inSize < 4) {, +                // and the length of the chunk (3 bytes) in order to proceed, +            final int chunkTypeVal = in.getUnsignedByte(idx);, +            final ChunkType chunkType = mapChunkType((byte) chunkTypeVal);, +            final int chunkLength = in.getUnsignedByte(idx + 1), +                                  | in.getUnsignedByte(idx + 2) << 8, +                                  | in.getUnsignedByte(idx + 3) << 16;, +                    if (inSize < 4 + SNAPPY.length) {, +                        break;, +                    }, +, +                    in.skipBytes(4).readBytes(identifier);, +, +                    if (inSize < 4 + chunkLength) {, +                        // TODO: Don't keep skippable bytes, +                        return;, +                    }, +, +                    in.skipBytes(4 + chunkLength);, +                case RESERVED_UNSKIPPABLE:, +                    // The spec mandates that reserved unskippable chunks must immediately, +                    // return an error, as we must assume that we cannot decode the stream, +                    // correctly, +                    throw new CompressionException(, +                            "Found reserved unskippable chunk type: 0x" + Integer.toHexString(chunkTypeVal));, +                    if (chunkLength > 65536 + 4) {, +                        throw new CompressionException("Received UNCOMPRESSED_DATA larger than 65540 bytes");, +                    }, +, +                    if (inSize < 4 + chunkLength) {, +                        return;, +                    }, +, +                    in.skipBytes(4);, +                    if (validateChecksums) {, +                        int checksum = in.readUnsignedByte(), +                        ByteBuf data = in.readSlice(chunkLength - 4);, +                        in.skipBytes(4);, +                        in.readBytes(out, chunkLength - 4);, +, +                    if (inSize < 4 + chunkLength) {, +                        return;, +                    }, +, +                    in.skipBytes(4);, +                    int checksum = in.readUnsignedByte(), +++ b/codec/src/main/java/io/netty/handler/codec/compression/Snappy.java, +        for (int i = 0;; i ++) {, +            int b = length >>> i * 7;, +            if ((b & 0xFFFFFF80) != 0) {, +                out.writeByte(b & 0x7f | 0x80);, +                out.writeByte(b);, +                break;, +        while (in.isReadable()) {, +            int current = in.readUnsignedByte();, +            length |= (current & 0x7f) << byteIndex++ * 7;, +            if ((current & 0x80) == 0) {, +                   | in.readUnsignedByte() << 8;, +                   | in.readUnsignedByte() << 8, +                   | in.readUnsignedByte() << 16;, +                   | in.readUnsignedByte() << 8, +                   | in.readUnsignedByte() << 16, +                   | in.readUnsignedByte() << 24;]