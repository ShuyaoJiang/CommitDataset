[+++ b/src/main/java/org/jboss/netty/channel/socket/nio/NioServerSocketPipelineSink.java, +++ b/src/main/java/org/jboss/netty/channel/socket/nio/NioServerSocketPipelineSink.java, +++ b/src/main/java/org/jboss/netty/channel/socket/nio/NioWorker.java, +    private volatile Thread thread;, +    private volatile Selector selector;, +    private final AtomicBoolean wakenUp = new AtomicBoolean();, +    private final ReadWriteLock selectorGuard = new ReentrantReadWriteLock();, +    private final ReadWriteLock shutdownLock = new ReentrantReadWriteLock();, +    //private final FastQueue<Runnable> taskQueue = new FastQueue<Runnable>();, +    //private final ConcurrentFastQueue<Runnable> taskQueue = new ConcurrentFastQueue<Runnable>();, +    private final FastQueue<Runnable> registerTaskQueue = new FastQueue<Runnable>();, +    private final ConcurrentLinkedQueue<Runnable> writeTaskQueue = new ConcurrentLinkedQueue<Runnable>();, +        Runnable registerTask = new RegisterTask(selector, channel, future, server);, +        if (firstChannel) {, +            registerTask.run();, +            shutdownLock.readLock().lock();, +                registerTaskQueue.offer(registerTask);, +            } finally {, +                shutdownLock.readLock().unlock();, +            }, +            if (CONSTRAINT_LEVEL != 0) {, +            }, +                processRegisterTaskQueue();, +                processWriteTaskQueue();, +                        shutdownLock.writeLock().lock();, +                            if (registerTaskQueue.isEmpty() && selector.keys().isEmpty()) {, +                            shutdownLock.writeLock().unlock();, +    private void processRegisterTaskQueue() {, +            final Runnable task = registerTaskQueue.poll();, +            if (task == null) {, +                break;, +            }, +, +            task.run();, +        }, +    }, +, +    private void processWriteTaskQueue() {, +        for (;;) {, +            final Runnable task = writeTaskQueue.poll();, +                        worker.writeTaskQueue.offer(channel.writeTask);, +            FastQueue<MessageEvent> writeBuffer = channel.writeBuffer;, +                    evt = writeBuffer.poll();, +            FastQueue<MessageEvent> writeBuffer = channel.writeBuffer;, +                    evt = writeBuffer.poll();, +            FastQueue<MessageEvent> writeBuffer = channel.writeBuffer;, +                evt = writeBuffer.poll();, +, +    private class RegisterTask implements Runnable {, +        private final Selector selector;, +        private final NioSocketChannel channel;, +        private final ChannelFuture future;, +        private final boolean server;, +, +        RegisterTask(, +                Selector selector,, +                NioSocketChannel channel, ChannelFuture future, boolean server) {, +, +            this.selector = selector;, +            this.channel = channel;, +            this.future = future;, +            this.server = server;, +        }, +, +        public void run() {, +            try {, +                channel.socket.register(selector, SelectionKey.OP_READ, channel);, +                if (future != null) {, +                    future.setSuccess();, +                }, +            } catch (ClosedChannelException e) {, +                future.setFailure(e);, +                throw new ChannelException(, +                        "Failed to register a socket to the selector.", e);, +            }, +, +            if (server) {, +                fireChannelOpen(channel);, +                fireChannelBound(channel, channel.getLocalAddress());, +            } else if (!((NioClientSocketChannel) channel).boundManually) {, +                fireChannelBound(channel, channel.getLocalAddress());, +            }, +            fireChannelConnected(channel, channel.getRemoteAddress());, +        }, +    }, +++ b/src/main/java/org/jboss/netty/channel/socket/nio/NioServerSocketPipelineSink.java, +++ b/src/main/java/org/jboss/netty/channel/socket/nio/NioWorker.java, +    private volatile Thread thread;, +    private volatile Selector selector;, +    private final AtomicBoolean wakenUp = new AtomicBoolean();, +    private final ReadWriteLock selectorGuard = new ReentrantReadWriteLock();, +    private final ReadWriteLock shutdownLock = new ReentrantReadWriteLock();, +    //private final FastQueue<Runnable> taskQueue = new FastQueue<Runnable>();, +    //private final ConcurrentFastQueue<Runnable> taskQueue = new ConcurrentFastQueue<Runnable>();, +    private final FastQueue<Runnable> registerTaskQueue = new FastQueue<Runnable>();, +    private final ConcurrentLinkedQueue<Runnable> writeTaskQueue = new ConcurrentLinkedQueue<Runnable>();, +        Runnable registerTask = new RegisterTask(selector, channel, future, server);, +        if (firstChannel) {, +            registerTask.run();, +            shutdownLock.readLock().lock();]