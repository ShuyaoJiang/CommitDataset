[+++ b/handler/src/main/java/io/netty/handler/stream/ChunkedWriteHandler.java, +import java.io.IOException;, +import io.netty.channel.LifeCycleAwareChannelHandler;, +public class ChunkedWriteHandler implements ChannelUpstreamHandler, ChannelDownstreamHandler, LifeCycleAwareChannelHandler {, +    , +, +    public void beforeAdd(ChannelHandlerContext ctx) throws Exception {, +        // nothing to do, +        , +    }, +, +    public void afterAdd(ChannelHandlerContext ctx) throws Exception {, +        // nothing to do, +        , +    }, +, +    public void beforeRemove(ChannelHandlerContext ctx) throws Exception {, +        // try to flush again a last time., +        //, +        // See #304, +        flush(ctx, false);, +    }, +, +    // This method should not need any synchronization as the ChunkedWriteHandler will not receive any new events, +    public void afterRemove(ChannelHandlerContext ctx) throws Exception {, +        // Fail all MessageEvent's that are left. This is needed because otherwise we would never notify the, +        // ChannelFuture and the registered FutureListener. See #304, +        //, +        Throwable cause = null;, +        boolean fireExceptionCaught = false;, +, +        for (;;) {, +            MessageEvent currentEvent = this.currentEvent;, +, +            if (this.currentEvent == null) {, +                currentEvent = queue.poll();, +            } else {, +                this.currentEvent = null;, +            }, +, +            if (currentEvent == null) {, +                break;, +            }, +, +            Object m = currentEvent.getMessage();, +            if (m instanceof ChunkedInput) {, +                closeInput((ChunkedInput) m);, +            }, +, +            // Create exception, +            if (cause == null) {, +                cause = new IOException("Unable to flush event, discarding");, +            }, +            currentEvent.getFuture().setFailure(cause);, +            fireExceptionCaught = true;, +, +            currentEvent = null;, +        }, +, +        if (fireExceptionCaught) {, +            Channels.fireExceptionCaughtLater(ctx.getChannel(), cause);, +        }, +    }]