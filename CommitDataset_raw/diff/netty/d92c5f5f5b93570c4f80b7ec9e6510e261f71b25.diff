[+++ b/buffer/src/test/java/io/netty/buffer/AbstractPooledByteBufTest.java, +, +        // Testing if the writerIndex and readerIndex are correct when allocate and also after we reset the mark., +        assertEquals(0, buffer.writerIndex());, +        assertEquals(0, buffer.readerIndex());, +        buffer.resetReaderIndex();, +        buffer.resetWriterIndex();, +++ b/buffer/src/test/java/io/netty/buffer/AbstractPooledByteBufTest.java, +, +        // Testing if the writerIndex and readerIndex are correct when allocate and also after we reset the mark., +        assertEquals(0, buffer.writerIndex());, +        assertEquals(0, buffer.readerIndex());, +        buffer.resetReaderIndex();, +        buffer.resetWriterIndex();, +++ b/common/src/main/java/io/netty/util/Recycler.java, +import static io.netty.util.internal.MathUtil.findNextPositivePowerOfTwo;, +    private static final int RATIO;, +        LINK_CAPACITY = findNextPositivePowerOfTwo(, +        // By default we allow one push to a Recycler for each 8th try on handles that were never recycled before., +        // This should help to slowly increase the capacity of the recycler while not be too sensitive to allocation, +        // bursts., +        RATIO = min(findNextPositivePowerOfTwo(, +                max(SystemPropertyUtil.getInt("io.netty.recycler.ratio", 8), 2)), 0x40000000);, +, +                logger.debug("-Dio.netty.recycler.ratio: disabled");, +                logger.debug("-Dio.netty.recycler.ratio: {}", RATIO);, +    private final int ratioMask;, +            return new Stack<T>(Recycler.this, Thread.currentThread(), maxCapacity, maxSharedCapacityFactor, ratioMask);, +        this(maxCapacity, maxSharedCapacityFactor, RATIO);, +    }, +, +    protected Recycler(int maxCapacity, int maxSharedCapacityFactor, int ratio) {, +        if (ratio > 0x40000000) {, +            throw new IllegalArgumentException(ratio + ": " + ratio + " (expected: < 0x40000000)");, +        }, +        ratioMask = findNextPositivePowerOfTwo(ratio) - 1;, +        boolean hasBeenRecycled;, +, +, +                    srcElems[i] = null;, +, +                    if (dst.dropHandle(element)) {, +                        // Drop the object., +                        continue;, +                    }, +                if (dst.size == newDstSize) {, +                    return false;, +                }, +                dst.size = newDstSize;, +        private final int ratioMask;, +        private int handleRecycleCount = -1; // Start with -1 so the first one will be recycled., +        Stack(Recycler<T> parent, Thread thread, int maxCapacity, int maxSharedCapacityFactor, int ratioMask) {, +            this.ratioMask = ratioMask;, +            if (size >= maxCapacity || dropHandle(item)) {, +                // Hit the maximum capacity or should drop - drop the possibly youngest object., +        boolean dropHandle(DefaultHandle<?> handle) {, +            if (!handle.hasBeenRecycled) {, +                if ((++handleRecycleCount & ratioMask) != 0) {, +                    // Drop the object., +                    return true;, +                }, +                handle.hasBeenRecycled = true;, +            }, +            return false;, +        }, +, +++ b/buffer/src/test/java/io/netty/buffer/AbstractPooledByteBufTest.java, +, +        // Testing if the writerIndex and readerIndex are correct when allocate and also after we reset the mark., +        assertEquals(0, buffer.writerIndex());, +        assertEquals(0, buffer.readerIndex());, +        buffer.resetReaderIndex();, +        buffer.resetWriterIndex();, +++ b/common/src/main/java/io/netty/util/Recycler.java, +import static io.netty.util.internal.MathUtil.findNextPositivePowerOfTwo;, +    private static final int RATIO;, +        LINK_CAPACITY = findNextPositivePowerOfTwo(, +        // By default we allow one push to a Recycler for each 8th try on handles that were never recycled before., +        // This should help to slowly increase the capacity of the recycler while not be too sensitive to allocation, +        // bursts., +        RATIO = min(findNextPositivePowerOfTwo(, +                max(SystemPropertyUtil.getInt("io.netty.recycler.ratio", 8), 2)), 0x40000000);, +, +                logger.debug("-Dio.netty.recycler.ratio: disabled");, +                logger.debug("-Dio.netty.recycler.ratio: {}", RATIO);, +    private final int ratioMask;, +            return new Stack<T>(Recycler.this, Thread.currentThread(), maxCapacity, maxSharedCapacityFactor, ratioMask);, +        this(maxCapacity, maxSharedCapacityFactor, RATIO);, +    }, +, +    protected Recycler(int maxCapacity, int maxSharedCapacityFactor, int ratio) {, +        if (ratio > 0x40000000) {, +            throw new IllegalArgumentException(ratio + ": " + ratio + " (expected: < 0x40000000)");, +        }, +        ratioMask = findNextPositivePowerOfTwo(ratio) - 1;, +        boolean hasBeenRecycled;, +, +, +                    srcElems[i] = null;, +]