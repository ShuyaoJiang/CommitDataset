[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2Connection.java, +import io.netty.util.internal.SystemPropertyUtil;, +     * The initial size of the children map is chosen to be conservative on initial memory allocations under, +     * the assumption that most streams will have a small number of children. This choice may be, +     * sub-optimal if when children are present there are many children (i.e. a web page which has many, +     * dependencies to load)., +     */, +    private static final int INITIAL_CHILDREN_MAP_SIZE =, +            Math.max(1, SystemPropertyUtil.getInt("io.netty.http2.childrenMapSize", 4));, +, +    /**, +            assert amt > 0 && Integer.MAX_VALUE - amt >= prioritizableForTree;, +            assert amt > 0 && prioritizableForTree >= amt;, +                initChildren();, +        private void initChildren() {, +            children = new IntObjectHashMap<DefaultStream>(INITIAL_CHILDREN_MAP_SIZE);, +        }, +, +        /**, +         * Remove all children with the exception of {@code streamToRetain}., +         * This method is intended to be used to support an exclusive priority dependency operation., +         * @return The map of children prior to this operation, excluding {@code streamToRetain} if present., +         */, +        private IntObjectMap<DefaultStream> retain(DefaultStream streamToRetain) {, +            streamToRetain = children.remove(streamToRetain.id());, +            IntObjectMap<DefaultStream> prevChildren = children;, +            // This map should be re-initialized in anticipation for the 1 exclusive child which will be added., +            // It will either be added directly in this method, or after this method is called...but it will be added., +            initChildren();, +            if (streamToRetain == null) {, +            } else {, +                totalChildWeights = streamToRetain.weight();, +                // prioritizableForTree does not change because it is assumed all children node will still be, +                // descendants through an exclusive priority tree operation., +                children.put(streamToRetain.id(), streamToRetain);, +            }, +, +            if (oldParent != this) {, +                // We need the removal operation to happen first so the prioritizableForTree for the old parent to root, +                // path is updated with the correct child.prioritizableForTree() value. Note that the removal operation, +                // may not be successful and may return null. This is because when an exclusive dependency is processed, +                // the children are removed in a previous recursive call but the child's parent link is updated here., +                if (oldParent != null && oldParent.children.remove(child.id()) != null) {, +                    oldParent.totalChildWeights -= child.weight();, +                    if (!child.isDescendantOf(oldParent)) {, +                        oldParent.decrementPrioritizableForTree(child.prioritizableForTree());, +                        if (oldParent.prioritizableForTree() == 0) {, +                            // There are a few risks with immediately removing nodes from the priority tree:, +                            // 1. We are removing nodes while we are potentially shifting the tree. There are no, +                            // concrete cases known but is risky because it could invalidate the data structure., +                            // 2. We are notifying listeners of the removal while the tree is in flux. Currently the, +                            // codec listeners make no assumptions about priority tree structure when being notified., +                            removeStream(oldParent);, +                        }, +                final Http2Stream oldChild = children.put(child.id(), child);, +                assert oldChild == null : "A stream with the same stream ID was already in the child map.";, +            if (exclusive && !children.isEmpty()) {, +                // If it was requested that this child be the exclusive dependency of this node,, +                // move any previous children to the child node, becoming grand children of this node., +                for (DefaultStream grandchild : retain(child).values()) {, +                    child.takeChild(grandchild, false, events);, +                    // There are a few risks with immediately removing nodes from the priority tree:, +                    // 1. We are removing nodes while we are potentially shifting the tree. There are no, +                    // concrete cases known but is risky because it could invalidate the data structure., +                    // 2. We are notifying listeners of the removal while the tree is in flux. Currently the, +                    // codec listeners make no assumptions about priority tree structure when being notified., +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2Connection.java, +import io.netty.util.internal.SystemPropertyUtil;, +     * The initial size of the children map is chosen to be conservative on initial memory allocations under, +     * the assumption that most streams will have a small number of children. This choice may be, +     * sub-optimal if when children are present there are many children (i.e. a web page which has many, +     * dependencies to load)., +     */, +    private static final int INITIAL_CHILDREN_MAP_SIZE =, +            Math.max(1, SystemPropertyUtil.getInt("io.netty.http2.childrenMapSize", 4));, +, +    /**, +            assert amt > 0 && Integer.MAX_VALUE - amt >= prioritizableForTree;, +            assert amt > 0 && prioritizableForTree >= amt;, +                initChildren();, +        private void initChildren() {, +            children = new IntObjectHashMap<DefaultStream>(INITIAL_CHILDREN_MAP_SIZE);, +        }, +, +        /**, +         * Remove all children with the exception of {@code streamToRetain}., +         * This method is intended to be used to support an exclusive priority dependency operation., +         * @return The map of children prior to this operation, excluding {@code streamToRetain} if present., +         */, +        private IntObjectMap<DefaultStream> retain(DefaultStream streamToRetain) {, +            streamToRetain = children.remove(streamToRetain.id());, +            IntObjectMap<DefaultStream> prevChildren = children;, +            // This map should be re-initialized in anticipation for the 1 exclusive child which will be added., +            // It will either be added directly in this method, or after this method is called...but it will be added., +            initChildren();, +            if (streamToRetain == null) {, +            } else {, +                totalChildWeights = streamToRetain.weight();, +                // prioritizableForTree does not change because it is assumed all children node will still be, +                // descendants through an exclusive priority tree operation.]