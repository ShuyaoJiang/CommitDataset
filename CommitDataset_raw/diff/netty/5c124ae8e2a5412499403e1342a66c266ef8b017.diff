[+++ b/handler/src/test/java/io/netty/handler/ssl/OpenSslEngineTest.java, +import io.netty.handler.ssl.ApplicationProtocolConfig.Protocol;, +import io.netty.handler.ssl.ApplicationProtocolConfig.SelectedListenerFailureBehavior;, +import io.netty.handler.ssl.ApplicationProtocolConfig.SelectorFailureBehavior;, +import java.nio.ByteBuffer;, +++ b/handler/src/test/java/io/netty/handler/ssl/OpenSslEngineTest.java, +import io.netty.handler.ssl.ApplicationProtocolConfig.Protocol;, +import io.netty.handler.ssl.ApplicationProtocolConfig.SelectedListenerFailureBehavior;, +import io.netty.handler.ssl.ApplicationProtocolConfig.SelectorFailureBehavior;, +import java.nio.ByteBuffer;, +++ b/handler/src/test/java/io/netty/handler/ssl/SSLEngineTest.java, +import io.netty.channel.socket.SocketChannel;, +import io.netty.util.ReferenceCountUtil;, +import java.util.concurrent.ExecutionException;, +import javax.net.ssl.SSLEngine;, +import javax.net.ssl.SSLEngineResult;, +import javax.net.ssl.SSLException;, +import javax.net.ssl.SSLHandshakeException;, +import javax.net.ssl.SSLSession;, +, +import static org.junit.Assert.assertArrayEquals;, +import static org.junit.Assert.assertEquals;, +import static org.junit.Assert.assertFalse;, +import static org.junit.Assert.assertNotEquals;, +import static org.junit.Assert.assertNotNull;, +import static org.junit.Assert.assertTrue;, +        if (clientChannel != null) {, +            clientChannel.close();, +            clientChannel = null;, +        }, +        if (serverConnectedChannel != null) {, +            serverConnectedChannel.close();, +            serverConnectedChannel = null;, +        }, +        }, +        Future<?> serverGroupShutdownFuture = null;, +        Future<?> serverChildGroupShutdownFuture = null;, +        Future<?> clientGroupShutdownFuture = null;, +        if (sb != null) {, +            serverGroupShutdownFuture = sb.config().group().shutdownGracefully(0, 0, TimeUnit.MILLISECONDS);, +            serverChildGroupShutdownFuture = sb.config().childGroup().shutdownGracefully(0, 0, TimeUnit.MILLISECONDS);, +        }, +        if (cb != null) {, +            clientGroupShutdownFuture = cb.config().group().shutdownGracefully(0, 0, TimeUnit.MILLISECONDS);, +        }, +        if (serverGroupShutdownFuture != null) {, +            serverGroupShutdownFuture.sync();, +            serverChildGroupShutdownFuture.sync();, +        }, +        if (clientGroupShutdownFuture != null) {, +            clientGroupShutdownFuture.sync();, +        }, +    @Test(timeout = 3000), +    public void clientInitiatedRenegotiationWithFatalAlertDoesNotInfiniteLoopServer(), +            throws CertificateException, SSLException, InterruptedException, ExecutionException {, +        final SelfSignedCertificate ssc = new SelfSignedCertificate();, +        serverSslCtx = SslContextBuilder.forServer(ssc.certificate(), ssc.privateKey()), +                .sslProvider(sslProvider()).build();, +        sb = new ServerBootstrap(), +                .group(new NioEventLoopGroup(1)), +                .channel(NioServerSocketChannel.class), +                .childHandler(new ChannelInitializer<SocketChannel>() {, +                    @Override, +                    public void initChannel(SocketChannel ch) {, +                        ChannelPipeline p = ch.pipeline();, +                        p.addLast(serverSslCtx.newHandler(ch.alloc()));, +                        p.addLast(new ChannelInboundHandlerAdapter() {, +                            @Override, +                            public void userEventTriggered(ChannelHandlerContext ctx, Object evt) {, +                                if (evt instanceof SslHandshakeCompletionEvent &&, +                                        ((SslHandshakeCompletionEvent) evt).isSuccess()) {, +                                    // This data will be sent to the client before any of the re-negotiation data can be, +                                    // sent. The client will read this, detect that it is not the response to, +                                    // renegotiation which was expected, and respond with a fatal alert., +                                    ctx.writeAndFlush(ctx.alloc().buffer(1).writeByte(100));, +                                }, +                                ctx.fireUserEventTriggered(evt);, +                            }, +, +                            @Override, +                            public void channelRead(final ChannelHandlerContext ctx, Object msg) {, +                                ReferenceCountUtil.release(msg);, +                                // The server then attempts to trigger a flush operation once the application data is, +                                // received from the client. The flush will encrypt all data and should not result in, +                                // deadlock., +                                ctx.channel().eventLoop().schedule(new Runnable() {, +                                    @Override, +                                    public void run() {, +                                        ctx.writeAndFlush(ctx.alloc().buffer(1).writeByte(101));, +                                    }, +                                }, 500, TimeUnit.MILLISECONDS);, +                            }, +, +                            @Override, +                            public void channelInactive(ChannelHandlerContext ctx) {, +                                serverLatch.countDown();, +                            }, +                        });, +                        serverConnectedChannel = ch;, +                    }]