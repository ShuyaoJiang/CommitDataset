[+++ b/transport/src/main/java/io/netty/channel/embedded/EmbeddedChannel.java, +import io.netty.channel.ChannelInitializer;, +    public EmbeddedChannel(final ChannelHandler... handlers) {, +        int nHandlers = 0;, +            nHandlers ++;, +        if (nHandlers == 0) {, +            throw new IllegalArgumentException("handlers is empty.");, +        }, +, +        ChannelPipeline p = pipeline();, +        p.addLast(new ChannelInitializer<Channel>() {, +            @Override, +            protected void initChannel(Channel ch) throws Exception {, +                ChannelPipeline pipeline = ch.pipeline();, +                for (ChannelHandler h: handlers) {, +                    if (h == null) {, +                        break;, +                    }, +                    pipeline.addLast(h);, +                }, +            }, +        });, +, +        ChannelFuture future = loop.register(this);, +        assert future.isDone();, +++ b/transport/src/main/java/io/netty/channel/embedded/EmbeddedChannel.java, +import io.netty.channel.ChannelInitializer;, +    public EmbeddedChannel(final ChannelHandler... handlers) {, +        int nHandlers = 0;, +            nHandlers ++;, +        if (nHandlers == 0) {, +            throw new IllegalArgumentException("handlers is empty.");, +        }, +, +        ChannelPipeline p = pipeline();, +        p.addLast(new ChannelInitializer<Channel>() {, +            @Override, +            protected void initChannel(Channel ch) throws Exception {, +                ChannelPipeline pipeline = ch.pipeline();, +                for (ChannelHandler h: handlers) {, +                    if (h == null) {, +                        break;, +                    }, +                    pipeline.addLast(h);, +                }, +            }, +        });, +, +        ChannelFuture future = loop.register(this);, +        assert future.isDone();, +++ b/transport/src/test/java/io/netty/channel/embedded/EmbeddedChannelTest.java, +import io.netty.channel.ChannelHandlerAdapter;, +import java.util.concurrent.atomic.AtomicReference;, +, +    @Test(timeout = 3000), +    public void testHandlerAddedExecutedInEventLoop() throws Throwable {, +        final CountDownLatch latch = new CountDownLatch(1);, +        final AtomicReference<Throwable> error = new AtomicReference<Throwable>();, +        final ChannelHandler handler = new ChannelHandlerAdapter() {, +            @Override, +            public void handlerAdded(ChannelHandlerContext ctx) throws Exception {, +                try {, +                    Assert.assertTrue(ctx.executor().inEventLoop());, +                } catch (Throwable cause) {, +                    error.set(cause);, +                } finally {, +                    latch.countDown();, +                }, +            }, +        };, +        EmbeddedChannel channel = new EmbeddedChannel(handler);, +        Assert.assertFalse(channel.finish());, +        latch.await();, +        Throwable cause = error.get();, +        if (cause != null) {, +            throw cause;, +        }, +    }]