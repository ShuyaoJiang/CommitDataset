[+++ b/common/src/main/java/io/netty/util/concurrent/DefaultPromise.java, +import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;, +import static io.netty.util.internal.ObjectUtil.checkNotNull;, +    private static final AtomicReferenceFieldUpdater<DefaultPromise, Object> RESULT_UPDATER;, +        AtomicReferenceFieldUpdater<DefaultPromise, Object> updater =, +                PlatformDependent.newAtomicReferenceFieldUpdater(DefaultPromise.class, "result");, +        RESULT_UPDATER = updater == null ? AtomicReferenceFieldUpdater.newUpdater(DefaultPromise.class,, +                                                                                  Object.class, "result") : updater;, +    private final EventExecutor executor;, +     *, +     * Threading - synchronized(this). We must support adding listeners when there is no EventExecutor., +    /**, +     * Threading - synchronized(this). We are required to hold the monitor to use Java's underlying wait()/notifyAll()., +     */, +    private short waiters;, +     * Threading - EventExecutor. Only accessed inside the EventExecutor thread while notifying listeners., +    private boolean notifyingListeners;, +        this.executor = checkNotNull(executor, "executor");, +        if (RESULT_UPDATER.compareAndSet(this, null, UNCANCELLABLE)) {, +            return true;, +        }, +        return !isDone0(result) || !isCancelled0(result);, +    public boolean isSuccess() {, +        Object result = this.result;, +        return result != null && result != UNCANCELLABLE && !(result instanceof CauseHolder);, +    }, +, +    @Override, +    public boolean isCancellable() {, +        return result == null;, +    }, +, +    @Override, +    public Throwable cause() {, +        Object result = this.result;, +        return (result instanceof CauseHolder) ? ((CauseHolder) result).cause : null;, +    }, +, +    @Override, +    public Promise<V> addListener(GenericFutureListener<? extends Future<? super V>> listener) {, +        checkNotNull(listener, "listener");, +, +        synchronized (this) {, +            addListener0(listener);, +        }, +, +        if (isDone()) {, +            notifyListeners();, +        }, +, +        return this;, +    }, +, +    @Override, +    public Promise<V> addListeners(GenericFutureListener<? extends Future<? super V>>... listeners) {, +        checkNotNull(listeners, "listeners");, +, +        synchronized (this) {, +            for (GenericFutureListener<? extends Future<? super V>> listener : listeners) {, +                if (listener == null) {, +                    break;, +                }, +                addListener0(listener);, +            }, +        }, +, +        if (isDone()) {, +            notifyListeners();, +        }, +, +        return this;, +    }, +, +    @Override, +    public Promise<V> removeListener(final GenericFutureListener<? extends Future<? super V>> listener) {, +        checkNotNull(listener, "listener");, +, +        synchronized (this) {, +            removeListener0(listener);, +        }, +, +        return this;, +    }, +, +    @Override, +    public Promise<V> removeListeners(final GenericFutureListener<? extends Future<? super V>>... listeners) {, +        checkNotNull(listeners, "listeners");, +, +        synchronized (this) {, +            for (GenericFutureListener<? extends Future<? super V>> listener : listeners) {, +                if (listener == null) {, +                    break;, +                }, +                removeListener0(listener);, +            }, +        }, +, +        return this;, +    }, +]