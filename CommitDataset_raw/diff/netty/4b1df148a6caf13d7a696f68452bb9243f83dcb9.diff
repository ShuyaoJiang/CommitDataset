[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentEncoder.java, +import io.netty.handler.codec.http.HttpHeaders.Names;, +import io.netty.handler.codec.http.HttpHeaders.Values;, +import java.util.Collections;, +                if (encoded[0] instanceof HttpMessage && encoded[encoded.length - 1] instanceof LastHttpContent) {, +                    // Set 'Content-Length' if the length of the content is known., +                    long contentLength = 0;, +                    for (int i = 1; i < encoded.length; i ++) {, +                        contentLength += ((ByteBufHolder) encoded[i]).data().readableBytes();, +                    }, +                    headers.set(Names.CONTENT_LENGTH, contentLength);, +                    headers.remove(Names.TRANSFER_ENCODING);, +                } else {, +                    headers.remove(Names.CONTENT_LENGTH);, +                    headers.set(Names.TRANSFER_ENCODING, Values.CHUNKED);, +                }, +                Collections.addAll(out, encoded);, +                Collections.addAll(out, encodeContent(null, c));, +    private HttpObject[] encodeContent(HttpMessage msg, HttpContent c) {, +                if (msg == null) {, +                    return new HttpObject[] { msg,  new DefaultHttpContent(newContent),, +                if (msg == null) {, +                    return new HttpObject[] { msg, new DefaultLastHttpContent(newContent) };, +        if (msg == null) {, +            return new HttpObject[] { msg, new DefaultHttpContent(newContent) };, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentEncoder.java, +import io.netty.handler.codec.http.HttpHeaders.Names;, +import io.netty.handler.codec.http.HttpHeaders.Values;, +import java.util.Collections;, +                if (encoded[0] instanceof HttpMessage && encoded[encoded.length - 1] instanceof LastHttpContent) {, +                    // Set 'Content-Length' if the length of the content is known., +                    long contentLength = 0;, +                    for (int i = 1; i < encoded.length; i ++) {, +                        contentLength += ((ByteBufHolder) encoded[i]).data().readableBytes();, +                    }, +                    headers.set(Names.CONTENT_LENGTH, contentLength);, +                    headers.remove(Names.TRANSFER_ENCODING);, +                } else {, +                    headers.remove(Names.CONTENT_LENGTH);, +                    headers.set(Names.TRANSFER_ENCODING, Values.CHUNKED);, +                }, +                Collections.addAll(out, encoded);, +                Collections.addAll(out, encodeContent(null, c));, +    private HttpObject[] encodeContent(HttpMessage msg, HttpContent c) {, +                if (msg == null) {, +                    return new HttpObject[] { msg,  new DefaultHttpContent(newContent),, +                if (msg == null) {, +                    return new HttpObject[] { msg, new DefaultLastHttpContent(newContent) };, +        if (msg == null) {, +            return new HttpObject[] { msg, new DefaultHttpContent(newContent) };, +++ b/codec-http/src/test/java/io/netty/handler/codec/http/HttpContentEncoderTest.java, +/*, + * Copyright 2013 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + *   http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the, + * License for the specific language governing permissions and limitations, + * under the License., + */, +, +package io.netty.handler.codec.http;, +, +import io.netty.buffer.ByteBuf;, +import io.netty.buffer.Unpooled;, +import io.netty.channel.ChannelHandlerContext;, +import io.netty.channel.embedded.EmbeddedByteChannel;, +import io.netty.channel.embedded.EmbeddedMessageChannel;, +import io.netty.handler.codec.ByteToByteEncoder;, +import io.netty.handler.codec.http.HttpHeaders.Names;, +import io.netty.util.CharsetUtil;, +import org.junit.Test;, +, +import static org.hamcrest.CoreMatchers.*;, +import static org.junit.Assert.*;, +, +public class HttpContentEncoderTest {, +, +    @Test, +    public void testSplitContent() throws Exception {, +        EmbeddedMessageChannel ch = new EmbeddedMessageChannel(, +                new HttpContentEncoder() {, +                    @Override, +                    protected Result beginEncode(HttpMessage header, HttpContent msg, String acceptEncoding) {, +                        return new Result("test", new EmbeddedByteChannel(new ByteToByteEncoder() {, +                            @Override, +                            protected void encode(ChannelHandlerContext ctx, ByteBuf in, ByteBuf out) {, +                                out.writeBytes(String.valueOf(in.readableBytes()).getBytes(CharsetUtil.US_ASCII));, +                                in.skipBytes(in.readableBytes());, +                            }, +                        }));, +                    }, +                });, +]