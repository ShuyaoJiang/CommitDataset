[+++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/AbstractEpollChannel.java, +        final AbstractEpollUnsafe unsafe = (AbstractEpollUnsafe) unsafe();, +            // Run epollInReady later because this is consistent with declaring interest with the polling mechanism., +            // We also set maybeMoreDataToRead to false to prevent executing multiple of these runnables., +            unsafe.maybeMoreDataToRead = false;, +            unsafe.executeEpollInReadyRunnable();, +        } else {, +            setFlag(readFlag);, +                        if (!unsafe.readPending && !config().isAutoRead()) {, +        boolean readPending;, +        boolean maybeMoreDataToRead;, +        private Runnable epollInReadyRunnable;, +            maybeMoreDataToRead = allocHandle.maybeMoreDataToRead();, +            } else if (readPending && maybeMoreDataToRead && !fd().isInputShutdown()) {, +                // trigger a read again as there may be something left to read and because of epoll ET we, +                // will not get notified again until we read everything from the socket, +                //, +                // It is possible the last fireChannelRead call could cause the user to call read() again, or if, +                // autoRead is true the call to channelReadComplete would also call read, but maybeMoreDataToRead is set, +                // to false before every read operation to prevent re-entry into epollInReady() we will not read from, +                // the underlying OS again unless the user happens to call read again., +                executeEpollInReadyRunnable();, +        final void executeEpollInReadyRunnable() {, +            if (epollInReadyRunnable == null) {, +                epollInReadyRunnable = new Runnable() {, +                };, +            eventLoop().execute(epollInReadyRunnable);, +++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/AbstractEpollChannel.java, +        final AbstractEpollUnsafe unsafe = (AbstractEpollUnsafe) unsafe();, +            // Run epollInReady later because this is consistent with declaring interest with the polling mechanism., +            // We also set maybeMoreDataToRead to false to prevent executing multiple of these runnables., +            unsafe.maybeMoreDataToRead = false;, +            unsafe.executeEpollInReadyRunnable();, +        } else {, +            setFlag(readFlag);, +                        if (!unsafe.readPending && !config().isAutoRead()) {, +        boolean readPending;, +        boolean maybeMoreDataToRead;, +        private Runnable epollInReadyRunnable;, +            maybeMoreDataToRead = allocHandle.maybeMoreDataToRead();, +            } else if (readPending && maybeMoreDataToRead && !fd().isInputShutdown()) {, +                // trigger a read again as there may be something left to read and because of epoll ET we, +                // will not get notified again until we read everything from the socket, +                //, +                // It is possible the last fireChannelRead call could cause the user to call read() again, or if, +                // autoRead is true the call to channelReadComplete would also call read, but maybeMoreDataToRead is set, +                // to false before every read operation to prevent re-entry into epollInReady() we will not read from, +                // the underlying OS again unless the user happens to call read again., +                executeEpollInReadyRunnable();, +        final void executeEpollInReadyRunnable() {, +            if (epollInReadyRunnable == null) {, +                epollInReadyRunnable = new Runnable() {, +                };, +            eventLoop().execute(epollInReadyRunnable);, +++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/AbstractEpollServerChannel.java, +            if (!readPending && !config.isAutoRead() || fd().isInputShutdown()) {, +            final EpollRecvByteAllocatorHandle allocHandle = recvBufAllocHandle();, +            allocHandle.edgeTriggered(isFlagSet(Native.EPOLLET));, +                        allocHandle.lastBytesRead(fd().accept(acceptedAddress));, +++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/AbstractEpollChannel.java, +        final AbstractEpollUnsafe unsafe = (AbstractEpollUnsafe) unsafe();, +            // Run epollInReady later because this is consistent with declaring interest with the polling mechanism., +            // We also set maybeMoreDataToRead to false to prevent executing multiple of these runnables., +            unsafe.maybeMoreDataToRead = false;, +            unsafe.executeEpollInReadyRunnable();, +        } else {, +            setFlag(readFlag);, +                        if (!unsafe.readPending && !config().isAutoRead()) {, +        boolean readPending;, +        boolean maybeMoreDataToRead;, +        private Runnable epollInReadyRunnable;, +            maybeMoreDataToRead = allocHandle.maybeMoreDataToRead();, +            } else if (readPending && maybeMoreDataToRead && !fd().isInputShutdown()) {, +                // trigger a read again as there may be something left to read and because of epoll ET we, +                // will not get notified again until we read everything from the socket, +                //, +                // It is possible the last fireChannelRead call could cause the user to call read() again, or if, +                // autoRead is true the call to channelReadComplete would also call read, but maybeMoreDataToRead is set, +                // to false before every read operation to prevent re-entry into epollInReady() we will not read from, +                // the underlying OS again unless the user happens to call read again., +                executeEpollInReadyRunnable();, +        final void executeEpollInReadyRunnable() {, +            if (epollInReadyRunnable == null) {, +                epollInReadyRunnable = new Runnable() {, +                };, +            eventLoop().execute(epollInReadyRunnable);, +++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/AbstractEpollServerChannel.java, +            if (!readPending && !config.isAutoRead() || fd().isInputShutdown()) {, +            final EpollRecvByteAllocatorHandle allocHandle = recvBufAllocHandle();, +            allocHandle.edgeTriggered(isFlagSet(Native.EPOLLET));, +                        allocHandle.lastBytesRead(fd().accept(acceptedAddress));, +++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/AbstractEpollStreamChannel.java, +            if (!readPending && !config.isAutoRead() || fd().isInputShutdown()) {, +            final EpollRecvByteAllocatorHandle allocHandle = recvBufAllocHandle();, +            allocHandle.edgeTriggered(isFlagSet(Native.EPOLLET));, +, +                    allocHandle.lastBytesRead(doReadBytes(byteBuf));, +++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/AbstractEpollChannel.java, +        final AbstractEpollUnsafe unsafe = (AbstractEpollUnsafe) unsafe();, +            // Run epollInReady later because this is consistent with declaring interest with the polling mechanism.]