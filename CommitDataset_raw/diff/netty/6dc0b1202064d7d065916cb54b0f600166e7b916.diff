[+++ b/src/main/java/org/jboss/netty/handler/stream/ChunkedWriteHandler.java, +import org.jboss.netty.buffer.ChannelBuffers;, +            flush(ctx);, +            switch (cse.getState()) {, +            case INTEREST_OPS:, +                flush(ctx);, +                break;, +            case OPEN:, +                if (!Boolean.TRUE.equals(cse.getValue())) {, +                    // Fail all pending writes, +                    discard(ctx);, +                }, +                break;, +    private synchronized void discard(ChannelHandlerContext ctx) {, +        for (;;) {, +            if (currentEvent == null) {, +                currentEvent = queue.poll();, +            }, +, +            if (currentEvent == null) {, +                break;, +            }, +, +            MessageEvent currentEvent = this.currentEvent;, +            this.currentEvent = null;, +, +            Object m = currentEvent.getMessage();, +            if (m instanceof ChunkedInput) {, +                ChunkedInput chunks = (ChunkedInput) m;, +                try {, +                    chunks.close();, +                } catch (Throwable t2) {, +                    logger.warn("Failed to close a chunked input.", t2);, +                }, +, +                // Trigger a ClosedChannelException, +                Channels.write(, +                        ctx, currentEvent.getFuture(), ChannelBuffers.EMPTY_BUFFER,, +                        currentEvent.getRemoteAddress());, +            } else {, +                // Trigger a ClosedChannelException, +                ctx.sendDownstream(currentEvent);, +            }, +            currentEvent = null;, +        }, +    }, +, +    private synchronized void flush(ChannelHandlerContext ctx) throws Exception {, +        final Channel channel = ctx.getChannel();, +        if (!channel.isConnected()) {, +            discard(ctx);, +        }, +, +        while (channel.isWritable()) {, +                    if (chunk == null) {, +                        chunk = ChannelBuffers.EMPTY_BUFFER;, +                        last = true;, +                    } else {, +                    }, +                    MessageEvent currentEvent = this.currentEvent;, +                    this.currentEvent = null;, +, +                    t.printStackTrace();, +        }]