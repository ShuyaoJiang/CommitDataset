[+++ b/transport/src/main/java/io/netty/channel/local/LocalChannel.java, +import io.netty.channel.ChannelPipeline;, +        final ChannelPipeline peerPipeline = peer.pipeline();, +        final EventLoop peerLoop = peer.eventLoop();, +        if (peerLoop == eventLoop()) {, +            buf.drainTo(peerPipeline.inboundMessageBuffer());, +            peerPipeline.fireInboundBufferUpdated();, +        } else {, +            final Object msgs[] = buf.toArray();, +            buf.clear();, +            peerLoop.execute(new Runnable() {, +                    MessageBuf<Object> buf = peerPipeline.inboundMessageBuffer();, +                    for (Object m: msgs) {, +                        buf.add(m);, +                    }, +                    peerPipeline.fireInboundBufferUpdated();, +    }, +++ b/transport/src/main/java/io/netty/channel/local/LocalChannel.java, +import io.netty.channel.ChannelPipeline;, +        final ChannelPipeline peerPipeline = peer.pipeline();, +        final EventLoop peerLoop = peer.eventLoop();, +        if (peerLoop == eventLoop()) {, +            buf.drainTo(peerPipeline.inboundMessageBuffer());, +            peerPipeline.fireInboundBufferUpdated();, +        } else {, +            final Object msgs[] = buf.toArray();, +            buf.clear();, +            peerLoop.execute(new Runnable() {, +                    MessageBuf<Object> buf = peerPipeline.inboundMessageBuffer();, +                    for (Object m: msgs) {, +                        buf.add(m);, +                    }, +                    peerPipeline.fireInboundBufferUpdated();, +    }, +++ b/transport/src/test/java/io/netty/channel/local/LocalTransportThreadModelTest2.java, +/*, + * Copyright 2012 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + *   http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the, + * License for the specific language governing permissions and limitations, + * under the License., + */, +package io.netty.channel.local;, +, +import static org.junit.Assert.*;, +import io.netty.bootstrap.Bootstrap;, +import io.netty.bootstrap.ServerBootstrap;, +import io.netty.buffer.MessageBuf;, +import io.netty.channel.Channel;, +import io.netty.channel.ChannelFuture;, +import io.netty.channel.ChannelHandler.Sharable;, +import io.netty.channel.ChannelHandlerContext;, +import io.netty.channel.ChannelInboundMessageHandlerAdapter;, +, +import java.util.Iterator;, +import java.util.concurrent.atomic.AtomicInteger;, +, +import org.junit.Test;, +, +public class LocalTransportThreadModelTest2 {, +, +    private static final String LOCAL_CHANNEL = LocalTransportThreadModelTest2.class.getName();, +, +    static final int messageCountPerRun = 4;, +, +    @Test(timeout = 15000), +    public void testSocketReuse() throws InterruptedException {, +        ServerBootstrap serverBootstrap = new ServerBootstrap();, +        LocalHander serverHandler = new LocalHander("SERVER");, +        serverBootstrap, +                .group(new LocalEventLoopGroup(), new LocalEventLoopGroup()), +                .channel(LocalServerChannel.class), +                .localAddress(new LocalAddress(LOCAL_CHANNEL)), +                .childHandler(serverHandler);, +, +        Bootstrap clientBootstrap = new Bootstrap();, +        LocalHander clientHandler = new LocalHander("CLIENT");, +        clientBootstrap, +                .group(new LocalEventLoopGroup()), +                .channel(LocalChannel.class), +                .remoteAddress(new LocalAddress(LOCAL_CHANNEL)).handler(clientHandler);, +, +        serverBootstrap.bind().sync();, +, +        int count = 100;, +        for (int i = 1; i < count + 1; i ++) {, +            Channel ch = clientBootstrap.connect().sync().channel();, +, +            // SPIN until we get what we are looking for., +            int target = i * messageCountPerRun;, +            while (serverHandler.count.get() != target || clientHandler.count.get() != target) {, +                Thread.sleep(50);]