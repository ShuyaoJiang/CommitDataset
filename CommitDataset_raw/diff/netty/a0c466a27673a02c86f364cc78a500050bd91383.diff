[+++ b/NOTICE.txt, +This product contains a modified portion of 'jfastlz', a Java port of FastLZ compression, +and decompression library written by William Kinney. It can be obtained at:, +, +  * LICENSE:, +    * license/LICENSE.jfastlz.txt (MIT License), +  * HOMEPAGE:, +    * https://code.google.com/p/jfastlz/, +, +++ b/NOTICE.txt, +This product contains a modified portion of 'jfastlz', a Java port of FastLZ compression, +and decompression library written by William Kinney. It can be obtained at:, +, +  * LICENSE:, +    * license/LICENSE.jfastlz.txt (MIT License), +  * HOMEPAGE:, +    * https://code.google.com/p/jfastlz/, +, +++ b/codec/src/main/java/io/netty/handler/codec/compression/FastLz.java, +/*, + * Copyright 2014 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + *   http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the, + * License for the specific language governing permissions and limitations, + * under the License., + */, +package io.netty.handler.codec.compression;, +, +/**, + * Core of FastLZ compression algorithm., + *, + * This class provides methods for compression and decompression of buffers and saves, + * constants which use by {@link FastLzFramedEncoder} and {@link FastLzFramedDecoder}., + *, + * This is refactored code of <a href="https://code.google.com/p/jfastlz/">jfastlz</a>, + * library written by William Kinney., + */, +final class FastLz {, +, +    private static final int MAX_DISTANCE = 8191;, +    private static final int MAX_FARDISTANCE = 65535 + MAX_DISTANCE - 1;, +, +    private static final int HASH_LOG = 13;, +    private static final int HASH_SIZE = 1 << HASH_LOG; // 8192, +    private static final int HASH_MASK = HASH_SIZE - 1;, +, +    private static final int MAX_COPY = 32;, +    private static final int MAX_LEN = 256 + 8;, +, +    private static final int MIN_RECOMENDED_LENGTH_FOR_LEVEL_2 = 1024 * 64;, +, +    static final int MAGIC_NUMBER = 'F' << 16 | 'L' << 8 | 'Z';, +, +    static final byte BLOCK_TYPE_NON_COMPRESSED = 0x00;, +    static final byte     BLOCK_TYPE_COMPRESSED = 0x01;, +    static final byte    BLOCK_WITHOUT_CHECKSUM = 0x00;, +    static final byte       BLOCK_WITH_CHECKSUM = 0x10;, +, +    static final int OPTIONS_OFFSET = 3;, +    static final int CHECKSUM_OFFSET = 4;, +, +    static final int MAX_CHUNK_LENGTH = 0xFFFF;, +, +    /**, +     * Do not call {@link #compress(byte[], int, int, byte[], int, int)} for input buffers, +     * which length less than this value., +     */, +    static final int MIN_LENGTH_TO_COMPRESSION = 32;, +, +    /**, +     * In this case {@link #compress(byte[], int, int, byte[], int, int)} will choose level, +     * automatically depending on the length of the input buffer. If length less than, +     * {@link #MIN_RECOMENDED_LENGTH_FOR_LEVEL_2} {@link #LEVEL_1} will be choosen,, +     * otherwise {@link #LEVEL_2}., +     */, +    static final int LEVEL_AUTO = 0;, +, +    /**, +     * Level 1 is the fastest compression and generally useful for short data., +     */, +    static final int LEVEL_1 = 1;, +, +    /**, +     * Level 2 is slightly slower but it gives better compression ratio., +     */, +    static final int LEVEL_2 = 2;, +, +    /**, +     * The output buffer must be at least 6% larger than the input buffer and can not be smaller than 66 bytes., +     * @param inputLength length of input buffer, +     * @return Maximum output buffer length, +     */]