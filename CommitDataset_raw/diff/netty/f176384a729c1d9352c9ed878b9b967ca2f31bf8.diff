[+++ b/transport/src/main/java/io/netty/channel/AbstractChannel.java, +            new ExtendedClosedChannelException(null), AbstractUnsafe.class, "ensureOpen(...)");, +            new ExtendedClosedChannelException(null), AbstractUnsafe.class, "write(...)");, +    private static final ClosedChannelException FLUSH0_CLOSED_CHANNEL_EXCEPTION = ThrowableUtil.unknownStackTrace(, +            new ExtendedClosedChannelException(null), AbstractUnsafe.class, "flush0()");, +    private Throwable initialCloseCause;, +                safeSetFailure(promise, newWriteException(initialCloseCause));, +                        outboundBuffer.failFlushed(newFlush0Exception(initialCloseCause), false);, +                    initialCloseCause = t;, +                    close(voidPromise(), t, newFlush0Exception(t), false);, +                        initialCloseCause = t;, +                        close(voidPromise(), t2, newFlush0Exception(t), false);, +        private ClosedChannelException newWriteException(Throwable cause) {, +            if (cause == null) {, +                return WRITE_CLOSED_CHANNEL_EXCEPTION;, +            }, +            return ThrowableUtil.unknownStackTrace(, +                    new ExtendedClosedChannelException(cause), AbstractUnsafe.class, "write(...)");, +        }, +, +        private ClosedChannelException newFlush0Exception(Throwable cause) {, +            if (cause == null) {, +                return FLUSH0_CLOSED_CHANNEL_EXCEPTION;, +            }, +            return ThrowableUtil.unknownStackTrace(, +                    new ExtendedClosedChannelException(cause), AbstractUnsafe.class, "flush0()");, +        }, +, +        private ClosedChannelException newEnsureOpenException(Throwable cause) {, +            if (cause == null) {, +                return ENSURE_OPEN_CLOSED_CHANNEL_EXCEPTION;, +            }, +            return ThrowableUtil.unknownStackTrace(, +                    new ExtendedClosedChannelException(cause), AbstractUnsafe.class, "ensureOpen(...)");, +        }, +, +            safeSetFailure(promise, newEnsureOpenException(initialCloseCause));, +++ b/transport/src/main/java/io/netty/channel/AbstractChannel.java, +            new ExtendedClosedChannelException(null), AbstractUnsafe.class, "ensureOpen(...)");, +            new ExtendedClosedChannelException(null), AbstractUnsafe.class, "write(...)");, +    private static final ClosedChannelException FLUSH0_CLOSED_CHANNEL_EXCEPTION = ThrowableUtil.unknownStackTrace(, +            new ExtendedClosedChannelException(null), AbstractUnsafe.class, "flush0()");, +    private Throwable initialCloseCause;, +                safeSetFailure(promise, newWriteException(initialCloseCause));, +                        outboundBuffer.failFlushed(newFlush0Exception(initialCloseCause), false);, +                    initialCloseCause = t;, +                    close(voidPromise(), t, newFlush0Exception(t), false);, +                        initialCloseCause = t;, +                        close(voidPromise(), t2, newFlush0Exception(t), false);, +        private ClosedChannelException newWriteException(Throwable cause) {, +            if (cause == null) {, +                return WRITE_CLOSED_CHANNEL_EXCEPTION;, +            }, +            return ThrowableUtil.unknownStackTrace(, +                    new ExtendedClosedChannelException(cause), AbstractUnsafe.class, "write(...)");, +        }, +, +        private ClosedChannelException newFlush0Exception(Throwable cause) {, +            if (cause == null) {, +                return FLUSH0_CLOSED_CHANNEL_EXCEPTION;, +            }, +            return ThrowableUtil.unknownStackTrace(, +                    new ExtendedClosedChannelException(cause), AbstractUnsafe.class, "flush0()");, +        }, +, +        private ClosedChannelException newEnsureOpenException(Throwable cause) {, +            if (cause == null) {, +                return ENSURE_OPEN_CLOSED_CHANNEL_EXCEPTION;, +            }, +            return ThrowableUtil.unknownStackTrace(, +                    new ExtendedClosedChannelException(cause), AbstractUnsafe.class, "ensureOpen(...)");, +        }, +, +            safeSetFailure(promise, newEnsureOpenException(initialCloseCause));, +++ b/transport/src/main/java/io/netty/channel/ExtendedClosedChannelException.java, +/*, + * Copyright 2019 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + *   http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the, + * License for the specific language governing permissions and limitations, + * under the License., + */, +package io.netty.channel;, +, +import java.nio.channels.ClosedChannelException;, +, +final class ExtendedClosedChannelException extends ClosedChannelException {, +, +    ExtendedClosedChannelException(Throwable cause) {, +        if (cause != null) {, +            initCause(cause);, +        }]