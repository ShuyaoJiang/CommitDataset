[+++ b/handler/src/main/java/io/netty/handler/ssl/SslHandler.java, +            "^.*(?:Socket|Datagram|Sctp)Channel.*$");, +    private final CloseNotifyListener closeNotifyWriteListener = new CloseNotifyListener();, +                future.addListener(closeNotifyWriteListener);, +                try {, +                    flush(ctx, future);, +                } catch (Exception e) {, +                    if (!future.tryFailure(e)) {, +                        logger.warn("flush() raised a masked exception.", e);, +                    }, +                }, +            // 'broken pipe' error after sending close_notify., +                        "Swallowing a harmless 'connection reset by peer / broken pipe' error that occurred " +, +                        "while writing close_notify in response to the peer's close_notify", cause);, +        } else {, +            ctx.fireExceptionCaught(cause);, +        if (!(t instanceof SSLException) && t instanceof IOException && sslCloseFuture.isDone()) {, +, +, +        final boolean disconnected = cause == null || cause instanceof ClosedChannelException;, +            if (!disconnected) {, +                logger.warn("SSLEngine.closeInbound() raised an exception after a handshake failure.", e);, +            } else if (!closeNotifyWriteListener.done) {, +                logger.warn("SSLEngine.closeInbound() raised an exception due to closed connection.", e);, +            } else {, +                // cause == null && sentCloseNotify, +                // closeInbound() will raise an exception with bogus truncation attack warning., +        if (!handshakePromises.isEmpty()) {, +        }, +        ChannelPromise closeNotifyFuture = ctx.newPromise().addListener(closeNotifyWriteListener);, +    private static final class CloseNotifyListener implements ChannelFutureListener {, +        volatile boolean done;, +, +        @Override, +        public void operationComplete(ChannelFuture future) throws Exception {, +            if (future.isSuccess()) {, +                if (done) {, +                    throw new IllegalStateException("notified twice");, +                }, +                done = true;, +            }, +        }, +    }, +]