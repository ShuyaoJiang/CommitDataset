[+++ b/src/main/java/org/jboss/netty/handler/queue/BlockingReadHandler.java, +/*, + * Copyright 2009 Red Hat, Inc., + *, + * Red Hat licenses this file to you under the Apache License, version 2.0, + * (the "License"); you may not use this file except in compliance with the, + * License.  You may obtain a copy of the License at:, + *, + *    http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the, + * License for the specific language governing permissions and limitations, + * under the License., + */, +package org.jboss.netty.handler.queue;, +, +import java.util.concurrent.BlockingQueue;, +import java.util.concurrent.TimeUnit;, +, +import org.jboss.netty.channel.Channel;, +import org.jboss.netty.channel.ChannelHandlerContext;, +import org.jboss.netty.channel.ChannelPipeline;, +import org.jboss.netty.channel.ChannelPipelineCoverage;, +import org.jboss.netty.channel.LifeCycleAwareChannelHandler;, +import org.jboss.netty.channel.MessageEvent;, +import org.jboss.netty.channel.SimpleChannelUpstreamHandler;, +import org.jboss.netty.util.internal.IoWorkerRunnable;, +import org.jboss.netty.util.internal.LinkedTransferQueue;, +, +/**, + * Emulates blocking read operation.  This handler stores all received messages, + * into a {@link BlockingQueue} and returns the received messages when, + * {@link #read()} or {@link #read(long, TimeUnit)} method is called., + * <p>, + * Please note that this handler is only useful for the cases where there are, + * very small number of connections, such as testing and simple client-side, + * application development., + * <p>, + * Also, any handler placed after this handler will never receive a, + * {@code messageReceived} event, hence it should be placed in the last place, + * in a pipeline., + * <p>, + * Here is an example that demonstrates the usage:, + * <pre>, + * BlockingReadHandler&lt;ChannelBuffer&gt; reader =, + *         new BlockingReadHandler&lt;ChannelBuffer&gt;();, + * ChannelPipeline p = ...;, + * p.addLast("reader", reader);, + *, + * ..., + *, + * // Read a message from a channel in a blocking manner., + * try {, + *     ChannelBuffer buf = reader.read(60, TimeUnit.SECONDS);, + *     if (buf == null) {, + *         // Connection closed., + *     } else {, + *         // Handle the received message here., + *     }, + * } catch (BlockingReadTimeoutException e) {, + *     // Read timed out., + * }, + * </pre>, + *, + * @param <E> the type of the received messages, + *, + * @author The Netty Project (netty-dev@lists.jboss.org), + * @author Trustin Lee (trustin@gmail.com), + * @version $Rev$, $Date$, + */, +@ChannelPipelineCoverage("one"), +public class BlockingReadHandler<E> extends SimpleChannelUpstreamHandler, +                            implements LifeCycleAwareChannelHandler {, +, +    private final BlockingQueue<E> queue;, +    private volatile Channel channel;, +, +    /**, +     * Creates a new instance with the default unbounded {@link BlockingQueue}, +     * implementation., +     */, +    public BlockingReadHandler() {, +        this(new LinkedTransferQueue<E>());, +    }, +, +    /**, +     * Creates a new instance with the specified {@link BlockingQueue}., +     */, +    public BlockingReadHandler(BlockingQueue<E> queue) {, +        if (queue == null) {, +            throw new NullPointerException("queue");, +        }, +        this.queue = queue;, +    }, +, +    /**, +     * Returns the queue which stores the received messages.  The default, +     * implementation returns the queue which was specified in the constructor.]