[+++ b/testsuite/src/main/java/io/netty/testsuite/transport/socket/SocketHalfClosedTest.java, +import io.netty.channel.SimpleChannelInboundHandler;, +import io.netty.channel.socket.ChannelOutputShutdownEvent;, +import java.util.concurrent.atomic.AtomicReference;, +import static org.junit.Assert.assertNull;, +    private static void testAllDataReadAfterHalfClosure(final boolean autoRead,, +    public void testAutoCloseFalseDoesShutdownOutput() throws Throwable {, +        run();, +    }, +, +    public void testAutoCloseFalseDoesShutdownOutput(ServerBootstrap sb, Bootstrap cb) throws Throwable {, +        testAutoCloseFalseDoesShutdownOutput(false, false, sb, cb);, +        testAutoCloseFalseDoesShutdownOutput(false, true, sb, cb);, +        testAutoCloseFalseDoesShutdownOutput(true, false, sb, cb);, +        testAutoCloseFalseDoesShutdownOutput(true, true, sb, cb);, +    }, +, +    private static void testAutoCloseFalseDoesShutdownOutput(boolean allowHalfClosed,, +                                                             final boolean clientIsLeader,, +                                                             ServerBootstrap sb,, +                                                             Bootstrap cb) throws InterruptedException {, +        final int expectedBytes = 100;, +        final CountDownLatch serverReadExpectedLatch = new CountDownLatch(1);, +        final CountDownLatch doneLatch = new CountDownLatch(1);, +        final AtomicReference<Throwable> causeRef = new AtomicReference<Throwable>();, +        Channel serverChannel = null;, +        Channel clientChannel = null;, +        try {, +            cb.option(ChannelOption.ALLOW_HALF_CLOSURE, allowHalfClosed), +                    .option(ChannelOption.AUTO_CLOSE, false), +                    .option(ChannelOption.SO_LINGER, 0);, +            sb.childOption(ChannelOption.ALLOW_HALF_CLOSURE, allowHalfClosed), +                    .childOption(ChannelOption.AUTO_CLOSE, false), +                    .childOption(ChannelOption.SO_LINGER, 0);, +, +            final SimpleChannelInboundHandler<ByteBuf> leaderHandler = new AutoCloseFalseLeader(expectedBytes,, +                    serverReadExpectedLatch, doneLatch, causeRef);, +            final SimpleChannelInboundHandler<ByteBuf> followerHandler = new AutoCloseFalseFollower(expectedBytes,, +                    serverReadExpectedLatch, doneLatch, causeRef);, +            sb.childHandler(new ChannelInitializer<Channel>() {, +                @Override, +                protected void initChannel(Channel ch) throws Exception {, +                    ch.pipeline().addLast(clientIsLeader ? followerHandler :leaderHandler);, +                }, +            });, +, +            cb.handler(new ChannelInitializer<Channel>() {, +                @Override, +                protected void initChannel(Channel ch) throws Exception {, +                    ch.pipeline().addLast(clientIsLeader ? leaderHandler : followerHandler);, +                }, +            });, +, +            serverChannel = sb.bind().sync().channel();, +            clientChannel = cb.connect(serverChannel.localAddress()).sync().channel();, +, +            doneLatch.await();, +            assertNull(causeRef.get());, +        } finally {, +            if (clientChannel != null) {, +                clientChannel.close().sync();, +            }, +            if (serverChannel != null) {, +                serverChannel.close().sync();, +            }, +        }, +    }, +, +    private static final class AutoCloseFalseFollower extends SimpleChannelInboundHandler<ByteBuf> {, +        private final int expectedBytes;, +        private final CountDownLatch followerCloseLatch;, +        private final CountDownLatch doneLatch;, +        private final AtomicReference<Throwable> causeRef;, +        private int bytesRead;, +, +        AutoCloseFalseFollower(int expectedBytes, CountDownLatch followerCloseLatch, CountDownLatch doneLatch,, +                               AtomicReference<Throwable> causeRef) {, +            this.expectedBytes = expectedBytes;, +            this.followerCloseLatch = followerCloseLatch;, +            this.doneLatch = doneLatch;, +            this.causeRef = causeRef;, +        }, +, +        @Override, +        public void channelInactive(ChannelHandlerContext ctx) {, +            checkPrematureClose();, +        }, +, +        @Override, +        public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {, +            ctx.close();, +            checkPrematureClose();, +        }, +, +        @Override, +        protected void channelRead0(ChannelHandlerContext ctx, ByteBuf msg) throws Exception {, +            bytesRead += msg.readableBytes();, +            if (bytesRead >= expectedBytes) {, +                // We write a reply and immediately close our end of the socket., +                ByteBuf buf = ctx.alloc().buffer(expectedBytes);]