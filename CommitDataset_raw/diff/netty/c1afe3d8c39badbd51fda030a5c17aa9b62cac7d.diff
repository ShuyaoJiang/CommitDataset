[+++ b/transport/src/test/java/io/netty/channel/local/LocalTransportThreadModelTest.java, +import java.util.concurrent.BlockingQueue;, +    @Test(timeout = 50000), +        final int COUNT = 1048576 * 4;, +            Queue<Object> buf = ch.pipeline().inboundMessageBuffer();, +            // Thread-safe bridge must be returned., +            Assert.assertTrue(buf instanceof BlockingQueue);, +                buf.add(Integer.valueOf(i ++));, +, +        while (h1.inCnt < COUNT || h2.inCnt < COUNT || h3.inCnt < COUNT) {, +            if (h1.exception.get() != null) {, +                throw h1.exception.get();, +            }, +            if (h2.exception.get() != null) {, +                throw h2.exception.get();, +            }, +            if (h3.exception.get() != null) {, +                throw h3.exception.get();, +            }, +, +            Thread.sleep(10);, +        }, +, +        for (int i = 0; i < COUNT;) {, +            Queue<Object> buf = ch.pipeline().outboundMessageBuffer();, +            for (int j = 0; i < COUNT && j < COUNT / 8; j ++) {, +                buf.add(Integer.valueOf(i ++));, +                if (h1.exception.get() != null) {, +                    throw h1.exception.get();, +                }, +                if (h2.exception.get() != null) {, +                    throw h2.exception.get();, +                }, +                if (h3.exception.get() != null) {, +                    throw h3.exception.get();, +                }, +            }, +            ch.pipeline().flush();, +        }, +, +        while (h1.outCnt < COUNT || h2.outCnt < COUNT || h3.outCnt < COUNT) {, +            if (h1.exception.get() != null) {, +                throw h1.exception.get();, +            }, +            if (h2.exception.get() != null) {, +                throw h2.exception.get();, +            }, +            if (h3.exception.get() != null) {, +                throw h3.exception.get();, +            }, +, +            Thread.sleep(10);, +        }, +, +    private static class MessageForwarder extends ChannelHandlerAdapter<Object, Object> {, +        private volatile int inCnt;, +        private volatile int outCnt;, +        private volatile Thread t;, +        public ChannelBufferHolder<Object> newInboundBuffer(, +                ChannelInboundHandlerContext<Object> ctx) throws Exception {, +            return ChannelBufferHolders.messageBuffer();, +        }, +, +        @Override, +        public ChannelBufferHolder<Object> newOutboundBuffer(, +                ChannelOutboundHandlerContext<Object> ctx) throws Exception {, +            return ChannelBufferHolders.messageBuffer();, +        }, +, +        @Override, +        public void inboundBufferUpdated(, +                ChannelInboundHandlerContext<Object> ctx) throws Exception {, +            Thread t = this.t;, +            if (t == null) {, +                this.t = Thread.currentThread();, +            } else {, +                Assert.assertSame(t, Thread.currentThread());, +            }, +, +            Queue<Object> in = ctx.inbound().messageBuffer();, +            Queue<Object> out = ctx.nextInboundMessageBuffer();, +, +            // Ensure the bridge buffer is returned., +            Assert.assertTrue(out instanceof BlockingQueue);, +, +            for (;;) {, +                Object msg = in.poll();, +                if (msg == null) {, +                    break;, +                }, +, +                int expected = inCnt ++;, +                Assert.assertEquals(expected, msg);, +                out.add(msg);, +            }, +            ctx.fireInboundBufferUpdated();, +        }, +, +        @Override, +        public void flush(ChannelOutboundHandlerContext<Object> ctx,]