[+++ b/common/src/main/java/io/netty/util/internal/NativeLibraryLoader.java, +            if (shouldShadedLibraryIdBePatched(packagePrefix)) {, +                patchShadedLibraryId(in, out, originalName, name);, +            } else {, +, +    // Package-private for testing., +    static boolean patchShadedLibraryId(InputStream in, OutputStream out, String originalName, String name), +            throws IOException {, +        byte[] buffer = new byte[8192];, +        int length;, +        // We read the whole native lib into memory to make it easier to monkey-patch the id., +        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(in.available());, +, +        while ((length = in.read(buffer)) > 0) {, +            byteArrayOutputStream.write(buffer, 0, length);, +        }, +        byteArrayOutputStream.flush();, +        byte[] bytes = byteArrayOutputStream.toByteArray();, +        byteArrayOutputStream.close();, +, +        final boolean patched;, +        // Try to patch the library id., +        if (!patchShadedLibraryId(bytes, originalName, name)) {, +            // We did not find the Id, check if we used a originalName that has the os and arch as suffix., +            // If this is the case we should also try to patch with the os and arch suffix removed., +            String os = PlatformDependent.normalizedOs();, +            String arch = PlatformDependent.normalizedArch();, +            String osArch = "_" + os + "_" + arch;, +            if (originalName.endsWith(osArch)) {, +                patched = patchShadedLibraryId(bytes,, +                        originalName.substring(0, originalName.length() - osArch.length()), name);, +            } else {, +                patched = false;, +            }, +        } else {, +            patched = true;, +        }, +        out.write(bytes, 0, bytes.length);, +        return patched;, +    }, +, +    private static boolean shouldShadedLibraryIdBePatched(String packagePrefix) {, +        return TRY_TO_PATCH_SHADED_ID && PlatformDependent.isOsx() && !packagePrefix.isEmpty();, +    }, +, +    private static boolean patchShadedLibraryId(byte[] bytes, String originalName, String name) {, +            return false;, +            return true;, +++ b/common/src/main/java/io/netty/util/internal/NativeLibraryLoader.java, +            if (shouldShadedLibraryIdBePatched(packagePrefix)) {, +                patchShadedLibraryId(in, out, originalName, name);, +            } else {, +, +    // Package-private for testing., +    static boolean patchShadedLibraryId(InputStream in, OutputStream out, String originalName, String name), +            throws IOException {, +        byte[] buffer = new byte[8192];, +        int length;, +        // We read the whole native lib into memory to make it easier to monkey-patch the id., +        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(in.available());, +, +        while ((length = in.read(buffer)) > 0) {, +            byteArrayOutputStream.write(buffer, 0, length);, +        }, +        byteArrayOutputStream.flush();, +        byte[] bytes = byteArrayOutputStream.toByteArray();, +        byteArrayOutputStream.close();, +, +        final boolean patched;, +        // Try to patch the library id., +        if (!patchShadedLibraryId(bytes, originalName, name)) {, +            // We did not find the Id, check if we used a originalName that has the os and arch as suffix., +            // If this is the case we should also try to patch with the os and arch suffix removed., +            String os = PlatformDependent.normalizedOs();, +            String arch = PlatformDependent.normalizedArch();, +            String osArch = "_" + os + "_" + arch;, +            if (originalName.endsWith(osArch)) {, +                patched = patchShadedLibraryId(bytes,, +                        originalName.substring(0, originalName.length() - osArch.length()), name);, +            } else {, +                patched = false;, +            }, +        } else {, +            patched = true;, +        }, +        out.write(bytes, 0, bytes.length);, +        return patched;, +    }, +, +    private static boolean shouldShadedLibraryIdBePatched(String packagePrefix) {, +        return TRY_TO_PATCH_SHADED_ID && PlatformDependent.isOsx() && !packagePrefix.isEmpty();, +    }, +, +    private static boolean patchShadedLibraryId(byte[] bytes, String originalName, String name) {, +            return false;, +            return true;, +++ b/common/src/test/java/io/netty/util/internal/NativeLibraryLoaderTest.java, +import io.netty.util.CharsetUtil;, +import java.io.ByteArrayInputStream;, +import java.io.ByteArrayOutputStream;]