[+++ b/transport/src/main/java/io/netty/channel/socket/aio/AioEventLoop.java, +import java.util.ArrayDeque;, +import java.util.Deque;, +import java.util.concurrent.ConcurrentHashMap;, +import java.util.concurrent.ConcurrentMap;, +    private static final ConcurrentMap<Class<?>, Field[]> fieldCache = new ConcurrentHashMap<Class<?>, Field[]>();, +    private static final Field[] FAILURE = new Field[0];, +, +        Class<?> commandType = command.getClass();, +        Field[] fields = fieldCache.get(commandType);, +        if (fields == null) {, +            try {, +                fields = findFieldSequence(command, new ArrayDeque<Field>(2));, +            } catch (Throwable t) {, +                // Failed to get the field list, +            }, +, +            if (fields == null) {, +                fields = FAILURE;, +            }, +, +            fieldCache.put(commandType, fields); // No need to use putIfAbsent(), +        }, +, +        if (fields == FAILURE) {, +            return null;, +        }, +, +        final int lastIndex = fields.length - 1;, +        for (int i = 0; i < lastIndex; i ++) {, +            command = (Runnable) fields[i].get(command);, +        }, +, +        return (AbstractAioChannel) fields[lastIndex].get(command);, +    }, +, +    private static Field[] findFieldSequence(Runnable command, Deque<Field> fields) throws Exception {, +                fields.addLast(f);, +                try {, +                    Field[] ret = findFieldSequence((Runnable) f.get(command), fields);, +                    if (ret != null) {, +                        return ret;, +                    }, +                } finally {, +                    fields.removeLast();, +                fields.addLast(f);, +                try {, +                        return fields.toArray(new Field[fields.size()]);, +                    }, +                } finally {, +                    fields.removeLast();]