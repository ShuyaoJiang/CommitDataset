[+++ b/src/main/java/org/jboss/netty/handler/codec/base64/Base64.java, +/*, + * JBoss, Home of Professional Open Source, + *, + * Copyright 2008, Red Hat Middleware LLC, and individual contributors, + * by the @author tags. See the COPYRIGHT.txt in the distribution for a, + * full listing of individual contributors., + *, + * This is free software; you can redistribute it and/or modify it, + * under the terms of the GNU Lesser General Public License as, + * published by the Free Software Foundation; either version 2.1 of, + * the License, or (at your option) any later version., + *, + * This software is distributed in the hope that it will be useful,, + * but WITHOUT ANY WARRANTY; without even the implied warranty of, + * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU, + * Lesser General Public License for more details., + *, + * You should have received a copy of the GNU Lesser General Public, + * License along with this software; if not, write to the Free, + * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA, + * 02110-1301 USA, or see the FSF site: http://www.fsf.org., + */, +/*, + * Written by Robert Harder and released to the public domain, as explained at, + * http://creativecommons.org/licenses/publicdomain, + */, +package org.jboss.netty.handler.codec.base64;, +, +import org.jboss.netty.buffer.ChannelBuffer;, +import org.jboss.netty.buffer.ChannelBuffers;, +, +/**, + * Utility class for {@link ChannelBuffer} that encodes and decodes to and from, + * <a href="http://en.wikipedia.org/wiki/Base64">Base64</a> notation., + * <p>, + * The encoding and decoding algorithm in this class has been derived from, + * <a href="http://iharder.sourceforge.net/current/java/base64/">Robert Harder's Public Domain Base64 Encoder/Decoder</a>., + *, + * @author The Netty Project (netty-dev@lists.jboss.org), + * @author Robert Harder (rob@iharder.net), + * @author Trustin Lee (tlee@redhat.com), + */, +public class Base64 {, +, +    /** Maximum line length (76) of Base64 output. */, +    private final static int MAX_LINE_LENGTH = 76;, +, +    /** The equals sign (=) as a byte. */, +    private final static byte EQUALS_SIGN = (byte) '=';, +, +    /** The new line character (\n) as a byte. */, +    private final static byte NEW_LINE = (byte) '\n';, +, +    private final static byte WHITE_SPACE_ENC = -5; // Indicates white space in encoding, +, +    private final static byte EQUALS_SIGN_ENC = -1; // Indicates equals sign in encoding, +, +    private final static byte[] getAlphabet(Base64Dialect dialect) {, +        if (dialect == null) {, +            throw new NullPointerException("dialect");, +        }, +        return dialect.alphabet;, +    }, +, +    private final static byte[] getDecodabet(Base64Dialect dialect) {, +        if (dialect == null) {, +            throw new NullPointerException("dialect");, +        }, +        return dialect.decodabet;, +    }, +, +    public static ChannelBuffer encode(ChannelBuffer src) {, +        return encode(src, true);, +    }, +, +    public static ChannelBuffer encode(ChannelBuffer src, boolean breakLines) {, +        return encode(src, breakLines, Base64Dialect.STANDARD);, +    }, +, +    public static ChannelBuffer encode(, +            ChannelBuffer src, boolean breakLines, Base64Dialect dialect) {, +        ChannelBuffer dest = encode(, +                src, src.readerIndex(), src.readableBytes(), breakLines, dialect);, +        src.readerIndex(src.writerIndex());, +        return dest;, +    }, +, +    public static ChannelBuffer encode(ChannelBuffer src, int off, int len) {, +        return encode(src, off, len, true);, +    }, +, +    public static ChannelBuffer encode(, +            ChannelBuffer src, int off, int len, boolean breakLines) {, +        return encode(src, off, len, breakLines, Base64Dialect.STANDARD);, +    }, +, +    public static ChannelBuffer encode(, +            ChannelBuffer src, int off, int len,, +            boolean breakLines, Base64Dialect dialect) {]