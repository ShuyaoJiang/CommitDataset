[+++ b/src/main/java/org/jboss/netty/buffer/CompositeChannelBuffer.java, +    private ChannelBuffer[] slices;, +    private int[] indices;, +        // Get the list of the component, while guessing the byte order., +        final List<ChannelBuffer> bufferList = new ArrayList<ChannelBuffer>(buffers.length);, +            if (buffer.readableBytes() > 0) {, +                expectedEndianness = buffer.order();, +                if (buffer instanceof CompositeChannelBuffer) {, +                    // Expand nested composition., +                    CompositeChannelBuffer child = (CompositeChannelBuffer) buffer;, +                    bufferList.addAll(, +                            child.getBufferList(child.readerIndex(), child.readableBytes()));, +                } else {, +                    // An ordinary buffer (non-composite), +                    bufferList.add(buffer.slice());, +                }, +            } else if (buffer.capacity() != 0) {, +            throw new IllegalArgumentException(, +                    "buffers have only empty buffers.");, +        setFromList(bufferList);, +    }, +, +   /**, +    * Returns the list of valid buffers from index and length, slicing contents, +    */, +   private List<ChannelBuffer> getBufferList(int index, int length) {, +       int localReaderIndex = index;, +       int localWriterIndex = this.writerIndex();, +       int sliceId = sliceId(localReaderIndex);, +       // some slices from sliceId must be kept, +       int maxlength = localWriterIndex - localReaderIndex;, +       if (maxlength < length) {, +           // check then if maxlength is compatible with the capacity, +           maxlength = capacity() - localReaderIndex;, +           if (maxlength < length) {, +               // too big, +               throw new IllegalArgumentException(, +                       "Length is bigger than available.");, +           }, +           // use capacity (discardReadBytes method), +       }, +, +       List<ChannelBuffer> bufferList = new ArrayList<ChannelBuffer>(slices.length);, +       // first one is not complete, +       // each slice will be duplicated before assign to the list (maintain original indexes), +       ChannelBuffer buf = slices[sliceId].duplicate();, +       buf.readerIndex(localReaderIndex - indices[sliceId]);, +       buf.writerIndex(slices[sliceId].writerIndex());, +       // as writerIndex can be less than capacity, check too for the end, +       int newlength = length;, +       while (newlength > 0) {, +           int leftInBuffer = buf.capacity() - buf.readerIndex();, +           if (newlength <= leftInBuffer) {, +               // final buffer, +               buf.writerIndex(buf.readerIndex() + newlength);, +               bufferList.add(buf);, +               newlength = 0;, +               break;, +           } else {, +               // not final buffer, +               bufferList.add(buf);, +               newlength -= leftInBuffer;, +               sliceId ++;, +               buf = slices[sliceId].duplicate();, +               buf.readerIndex(0);, +               buf.writerIndex(slices[sliceId].writerIndex());, +               // length is > 0, +           }, +       }, +       return bufferList;, +   }, +, +   /**, +    * Setup this ChannelBuffer from the list and the Endianness, +    * @param listBuf, +    * @param expectedEndianness, +    */, +   private void setFromList(List<ChannelBuffer> listBuf) {, +, +       // Reset the cached slice position., +       lastSliceId = 0;, +, +       int number = listBuf.size();, +       if (number == 0) {, +           slices = new ChannelBuffer[1];, +           // to prevent remove too early, +           slices[0] = ChannelBuffers.EMPTY_BUFFER.slice();, +           indices = new int[2];, +           indices[1] = indices[0] + slices[0].capacity();, +           readerIndex(0);, +           writerIndex(capacity());, +           return;, +       }, +       slices = new ChannelBuffer[number];, +       int i = 0;, +       for (ChannelBuffer buffer: listBuf) {, +           if (buffer.order() != order()) {, +           slices[i] = buffer;, +           i ++;, +       indices = new int[number + 1];]