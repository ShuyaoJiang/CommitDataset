[+++ b/transport/src/main/java/io/netty/channel/ChannelHandlerInvokerUtil.java, +import io.netty.util.internal.StringUtil;, +, +    public static boolean validatePromise(, +            ChannelHandlerContext ctx, ChannelPromise promise, boolean allowVoidPromise) {, +        if (ctx == null) {, +            throw new NullPointerException("ctx");, +        }, +, +        if (promise == null) {, +            throw new NullPointerException("promise");, +        }, +, +        if (promise.isDone()) {, +            if (promise.isCancelled()) {, +                return false;, +            }, +            throw new IllegalArgumentException("promise already done: " + promise);, +        }, +, +        if (promise.channel() != ctx.channel()) {, +            throw new IllegalArgumentException(String.format(, +                    "promise.channel does not match: %s (expected: %s)", promise.channel(), ctx.channel()));, +        }, +, +        if (promise.getClass() == DefaultChannelPromise.class) {, +            return true;, +        }, +, +        if (!allowVoidPromise && promise instanceof VoidChannelPromise) {, +            throw new IllegalArgumentException(, +                    StringUtil.simpleClassName(VoidChannelPromise.class) + " not allowed for this operation");, +        }, +, +        if (promise instanceof AbstractChannel.CloseFuture) {, +            throw new IllegalArgumentException(, +                    StringUtil.simpleClassName(AbstractChannel.CloseFuture.class) + " not allowed in a pipeline");, +        }, +        return true;, +    }, +, +++ b/transport/src/main/java/io/netty/channel/ChannelHandlerInvokerUtil.java, +import io.netty.util.internal.StringUtil;, +, +    public static boolean validatePromise(, +            ChannelHandlerContext ctx, ChannelPromise promise, boolean allowVoidPromise) {, +        if (ctx == null) {, +            throw new NullPointerException("ctx");, +        }, +, +        if (promise == null) {, +            throw new NullPointerException("promise");, +        }, +, +        if (promise.isDone()) {, +            if (promise.isCancelled()) {, +                return false;, +            }, +            throw new IllegalArgumentException("promise already done: " + promise);, +        }, +, +        if (promise.channel() != ctx.channel()) {, +            throw new IllegalArgumentException(String.format(, +                    "promise.channel does not match: %s (expected: %s)", promise.channel(), ctx.channel()));, +        }, +, +        if (promise.getClass() == DefaultChannelPromise.class) {, +            return true;, +        }, +, +        if (!allowVoidPromise && promise instanceof VoidChannelPromise) {, +            throw new IllegalArgumentException(, +                    StringUtil.simpleClassName(VoidChannelPromise.class) + " not allowed for this operation");, +        }, +, +        if (promise instanceof AbstractChannel.CloseFuture) {, +            throw new IllegalArgumentException(, +                    StringUtil.simpleClassName(AbstractChannel.CloseFuture.class) + " not allowed in a pipeline");, +        }, +        return true;, +    }, +, +++ b/transport/src/main/java/io/netty/channel/DefaultChannelHandlerInvoker.java]