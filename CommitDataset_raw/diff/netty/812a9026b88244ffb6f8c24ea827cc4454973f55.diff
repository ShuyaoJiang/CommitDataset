[+++ b/transport/src/main/java/io/netty/channel/socket/nio/AbstractNioChannel.java, +/*, + * Copyright 2011 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the, + * License for the specific language governing permissions and limitations, + * under the License., + */, +package io.netty.channel.socket.nio;, +, +import static io.netty.channel.Channels.fireChannelInterestChanged;, +import io.netty.buffer.ChannelBuffer;, +import io.netty.channel.AbstractChannel;, +import io.netty.channel.Channel;, +import io.netty.channel.ChannelFactory;, +import io.netty.channel.ChannelFuture;, +import io.netty.channel.ChannelPipeline;, +import io.netty.channel.ChannelSink;, +import io.netty.channel.MessageEvent;, +import io.netty.channel.socket.nio.SocketSendBufferPool.SendBuffer;, +import io.netty.util.internal.QueueFactory;, +import io.netty.util.internal.ThreadLocalBoolean;, +, +import java.net.InetSocketAddress;, +import java.net.SocketAddress;, +import java.nio.channels.SelectableChannel;, +import java.nio.channels.WritableByteChannel;, +import java.util.Collection;, +import java.util.Iterator;, +import java.util.Queue;, +import java.util.concurrent.BlockingQueue;, +import java.util.concurrent.TimeUnit;, +import java.util.concurrent.atomic.AtomicBoolean;, +import java.util.concurrent.atomic.AtomicInteger;, +, +abstract class AbstractNioChannel<C extends SelectableChannel & WritableByteChannel> extends AbstractChannel {, +, +    /**, +     * The {@link AbstractNioWorker}., +     */, +    final AbstractNioWorker worker;, +, +    /**, +     * Monitor object to synchronize access to InterestedOps., +     */, +    final Object interestOpsLock = new Object();, +, +    /**, +     * Monitor object for synchronizing access to the {@link WriteRequestQueue}., +     */, +    final Object writeLock = new Object();, +, +    /**, +     * WriteTask that performs write operations., +     */, +    final Runnable writeTask = new WriteTask();, +, +    /**, +     * Indicates if there is a {@link WriteTask} in the task queue., +     */, +    final AtomicBoolean writeTaskInTaskQueue = new AtomicBoolean();, +, +    /**, +     * Queue of write {@link MessageEvent}s., +     */, +    final Queue<MessageEvent> writeBufferQueue = new WriteRequestQueue();, +, +    /**, +     * Keeps track of the number of bytes that the {@link WriteRequestQueue} currently, +     * contains., +     */, +    final AtomicInteger writeBufferSize = new AtomicInteger();, +, +    /**, +     * Keeps track of the highWaterMark., +     */, +    final AtomicInteger highWaterMarkCounter = new AtomicInteger();, +, +    /**, +     * The current write {@link MessageEvent}, +     */, +    MessageEvent currentWriteEvent;, +    SendBuffer currentWriteBuffer;, +, +    /**, +     * Boolean that indicates that write operation is in progress., +     */, +    boolean inWriteNowLoop;, +    boolean writeSuspended;, +    , +, +    private volatile InetSocketAddress localAddress;]