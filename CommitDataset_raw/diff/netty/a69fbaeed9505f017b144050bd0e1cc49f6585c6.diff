[+++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/AbstractEpollStreamChannel.java, +    protected void shutdownOutput0(final ChannelPromise promise) {, +        } catch (Throwable cause) {, +            promise.setFailure(cause);, +++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/AbstractEpollStreamChannel.java, +    protected void shutdownOutput0(final ChannelPromise promise) {, +        } catch (Throwable cause) {, +            promise.setFailure(cause);, +++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollSocketChannel.java, +import io.netty.channel.EventLoop;, +import io.netty.util.concurrent.GlobalEventExecutor;, +import io.netty.util.internal.OneTimeTask;, +import java.util.concurrent.Executor;, +        Executor closeExecutor = ((EpollSocketChannelUnsafe) unsafe()).closeExecutor();, +        if (closeExecutor != null) {, +            closeExecutor.execute(new OneTimeTask() {, +                @Override, +                public void run() {, +                    shutdownOutput0(promise);, +                }, +            });, +        } else {, +            EventLoop loop = eventLoop();, +            if (loop.inEventLoop()) {, +                shutdownOutput0(promise);, +            } else {, +                loop.execute(new OneTimeTask() {, +                    @Override, +                    public void run() {, +                        shutdownOutput0(promise);, +                    }, +                });, +            }, +        }, +        return promise;, +    protected AbstractEpollUnsafe newUnsafe() {, +        return new EpollSocketChannelUnsafe();, +    }, +, +    @Override, +, +    private final class EpollSocketChannelUnsafe extends EpollStreamUnsafe {, +        @Override, +        protected Executor closeExecutor() {, +            if (config().getSoLinger() > 0) {, +                return GlobalEventExecutor.INSTANCE;, +            }, +            return null;, +        }, +    }, +++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/AbstractEpollStreamChannel.java, +    protected void shutdownOutput0(final ChannelPromise promise) {, +        } catch (Throwable cause) {, +            promise.setFailure(cause);, +++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollSocketChannel.java, +import io.netty.channel.EventLoop;, +import io.netty.util.concurrent.GlobalEventExecutor;, +import io.netty.util.internal.OneTimeTask;, +import java.util.concurrent.Executor;, +        Executor closeExecutor = ((EpollSocketChannelUnsafe) unsafe()).closeExecutor();, +        if (closeExecutor != null) {, +            closeExecutor.execute(new OneTimeTask() {, +                @Override, +                public void run() {, +                    shutdownOutput0(promise);, +                }, +            });, +        } else {, +            EventLoop loop = eventLoop();, +            if (loop.inEventLoop()) {, +                shutdownOutput0(promise);, +            } else {, +                loop.execute(new OneTimeTask() {, +                    @Override, +                    public void run() {, +                        shutdownOutput0(promise);, +                    }, +                });, +            }, +        }, +        return promise;, +    protected AbstractEpollUnsafe newUnsafe() {, +        return new EpollSocketChannelUnsafe();, +    }, +, +    @Override, +, +    private final class EpollSocketChannelUnsafe extends EpollStreamUnsafe {, +        @Override, +        protected Executor closeExecutor() {, +            if (config().getSoLinger() > 0) {, +                return GlobalEventExecutor.INSTANCE;, +            }, +            return null;, +        }, +    }, +++ b/transport/src/main/java/io/netty/channel/AbstractChannel.java, +import java.util.concurrent.Executor;, +            if (outboundBuffer == null) {, +                // This means close() was called before so we just register a listener and return]