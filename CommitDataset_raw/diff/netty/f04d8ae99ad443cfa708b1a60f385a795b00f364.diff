[+++ b/src/main/java/org/jboss/netty/handler/codec/embedder/AbstractCodecEmbedder.java, +import java.util.LinkedList;, +import java.util.Queue;, +, +import org.jboss.netty.channel.ChannelEvent;, +import org.jboss.netty.channel.ChannelPipeline;, +import org.jboss.netty.channel.ChannelPipelineException;, +import org.jboss.netty.channel.ChannelSink;, +import org.jboss.netty.channel.Channels;, +import org.jboss.netty.channel.ExceptionEvent;, +import org.jboss.netty.channel.MessageEvent;, +    private static final String NAME = "__embedded__";, +, +    private final Channel channel;, +    private final ChannelPipeline pipeline;, +    final Queue<Object> productQueue = new LinkedList<Object>();, +        pipeline = Channels.pipeline();, +        pipeline.addLast(NAME, handler);, +        channel = new EmbeddedChannel(pipeline, new EmbeddedChannelSink());, +        fireChannelOpen(channel);, +        fireChannelBound(channel, channel.getLocalAddress());, +        fireChannelConnected(channel, channel.getRemoteAddress());, +        fireChannelDisconnected(channel);, +        fireChannelUnbound(channel);, +        fireChannelClosed(channel);, +        return !productQueue.isEmpty();, +    }, +, +    protected final Channel getChannel() {, +        return channel;, +    }, +, +    protected final boolean isEmpty() {, +        return productQueue.isEmpty();, +    public final T poll() {, +        return (T) productQueue.poll();, +    public final T peek() {, +        return (T) productQueue.peek();, +    }, +, +    private final class EmbeddedChannelSink implements ChannelSink {, +        EmbeddedChannelSink() {, +            super();, +        }, +, +        public void eventSunk(ChannelPipeline pipeline, ChannelEvent e) {, +            if (e instanceof MessageEvent) {, +                productQueue.offer(((MessageEvent) e).getMessage());, +            } else if (e instanceof ExceptionEvent) {, +                throw new CodecEmbedderException(((ExceptionEvent) e).getCause());, +            }, +, +            // Swallow otherwise., +        }, +, +        public void exceptionCaught(, +                ChannelPipeline pipeline, ChannelEvent e,, +                ChannelPipelineException cause) throws Exception {, +            Throwable actualCause = cause.getCause();, +            if (actualCause == null) {, +                actualCause = cause;, +            }, +, +            throw new CodecEmbedderException(actualCause);, +        }, +++ b/src/main/java/org/jboss/netty/handler/codec/embedder/AbstractCodecEmbedder.java, +import java.util.LinkedList;, +import java.util.Queue;, +, +import org.jboss.netty.channel.ChannelEvent;, +import org.jboss.netty.channel.ChannelPipeline;, +import org.jboss.netty.channel.ChannelPipelineException;, +import org.jboss.netty.channel.ChannelSink;, +import org.jboss.netty.channel.Channels;, +import org.jboss.netty.channel.ExceptionEvent;, +import org.jboss.netty.channel.MessageEvent;, +    private static final String NAME = "__embedded__";, +, +    private final Channel channel;, +    private final ChannelPipeline pipeline;, +    final Queue<Object> productQueue = new LinkedList<Object>();, +        pipeline = Channels.pipeline();, +        pipeline.addLast(NAME, handler);, +        channel = new EmbeddedChannel(pipeline, new EmbeddedChannelSink());, +        fireChannelOpen(channel);, +        fireChannelBound(channel, channel.getLocalAddress());, +        fireChannelConnected(channel, channel.getRemoteAddress());, +        fireChannelDisconnected(channel);, +        fireChannelUnbound(channel);, +        fireChannelClosed(channel);, +        return !productQueue.isEmpty();, +    }, +, +    protected final Channel getChannel() {, +        return channel;, +    }, +, +    protected final boolean isEmpty() {, +        return productQueue.isEmpty();, +    public final T poll() {]