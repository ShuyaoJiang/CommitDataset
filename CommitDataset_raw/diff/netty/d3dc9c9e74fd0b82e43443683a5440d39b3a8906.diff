[+++ b/common/src/main/java/io/netty/util/Recycler.java, +    private static final int MAX_DELAYED_QUEUES_PER_THREAD;, +        MAX_DELAYED_QUEUES_PER_THREAD = max(0,, +                SystemPropertyUtil.getInt("io.netty.recycler.maxDelayedQueuesPerThread",, +                        // We use the same value as default EventLoop number, +                        Runtime.getRuntime().availableProcessors() * 2));, +, +    private final int maxDelayedQueuesPerThread;, +            return new Stack<T>(Recycler.this, Thread.currentThread(), maxCapacity, maxSharedCapacityFactor,, +                    ratioMask, maxDelayedQueuesPerThread);, +        this(maxCapacity, maxSharedCapacityFactor, RATIO, MAX_DELAYED_QUEUES_PER_THREAD);, +    protected Recycler(int maxCapacity, int maxSharedCapacityFactor, int ratio, int maxDelayedQueuesPerThread) {, +            this.maxDelayedQueuesPerThread = 0;, +            this.maxDelayedQueuesPerThread = max(0, maxDelayedQueuesPerThread);, +        static final WeakOrderQueue DUMMY = new WeakOrderQueue();, +, +        private WeakOrderQueue() {, +            owner = null;, +            availableSharedCapacity = null;, +        }, +, +        final AtomicInteger availableSharedCapacity;, +        final int maxDelayedQueues;, +, +        private DefaultHandle<?>[] elements;, +        private volatile WeakOrderQueue head;, +        Stack(Recycler<T> parent, Thread thread, int maxCapacity, int maxSharedCapacityFactor,, +              int ratioMask, int maxDelayedQueues) {, +            this.maxDelayedQueues = maxDelayedQueues;, +            Thread currentThread = Thread.currentThread();, +            if (thread == currentThread) {, +                // The current Thread is the thread that belongs to the Stack, we can try to push the object now., +                pushNow(item);, +            } else {, +                // The current Thread is not the one that belongs to the Stack, we need to signal that the push, +                // happens later., +                pushLater(item, currentThread);, +            }, +        }, +, +        private void pushNow(DefaultHandle<?> item) {, +        private void pushLater(DefaultHandle<?> item, Thread thread) {, +            // we don't want to have a ref to the queue as the value in our weak map, +            // so we null it out; to ensure there are no races with restoring it later, +            // we impose a memory ordering here (no-op on x86), +            Map<Stack<?>, WeakOrderQueue> delayedRecycled = DELAYED_RECYCLED.get();, +            WeakOrderQueue queue = delayedRecycled.get(this);, +            if (queue == null) {, +                if (delayedRecycled.size() >= maxDelayedQueues) {, +                    // Add a dummy queue so we know we should drop the object, +                    delayedRecycled.put(this, WeakOrderQueue.DUMMY);, +                    return;, +                }, +                // Check if we already reached the maximum number of delayed queues and if we can allocate at all., +                if ((queue = WeakOrderQueue.allocate(this, thread)) == null) {, +                    // drop object, +                    return;, +                }, +                delayedRecycled.put(this, queue);, +            } else if (queue == WeakOrderQueue.DUMMY) {, +                // drop object, +                return;, +            }, +, +            queue.add(item);, +        }, +, +++ b/common/src/main/java/io/netty/util/Recycler.java, +    private static final int MAX_DELAYED_QUEUES_PER_THREAD;, +        MAX_DELAYED_QUEUES_PER_THREAD = max(0,, +                SystemPropertyUtil.getInt("io.netty.recycler.maxDelayedQueuesPerThread",, +                        // We use the same value as default EventLoop number, +                        Runtime.getRuntime().availableProcessors() * 2));, +, +    private final int maxDelayedQueuesPerThread;, +            return new Stack<T>(Recycler.this, Thread.currentThread(), maxCapacity, maxSharedCapacityFactor,, +                    ratioMask, maxDelayedQueuesPerThread);, +        this(maxCapacity, maxSharedCapacityFactor, RATIO, MAX_DELAYED_QUEUES_PER_THREAD);, +    protected Recycler(int maxCapacity, int maxSharedCapacityFactor, int ratio, int maxDelayedQueuesPerThread) {, +            this.maxDelayedQueuesPerThread = 0;, +            this.maxDelayedQueuesPerThread = max(0, maxDelayedQueuesPerThread);, +        static final WeakOrderQueue DUMMY = new WeakOrderQueue();, +, +        private WeakOrderQueue() {, +            owner = null;, +            availableSharedCapacity = null;, +        }, +, +        final AtomicInteger availableSharedCapacity;, +        final int maxDelayedQueues;, +, +        private DefaultHandle<?>[] elements;, +        private volatile WeakOrderQueue head;, +        Stack(Recycler<T> parent, Thread thread, int maxCapacity, int maxSharedCapacityFactor,, +              int ratioMask, int maxDelayedQueues) {, +            this.maxDelayedQueues = maxDelayedQueues;, +            Thread currentThread = Thread.currentThread();, +            if (thread == currentThread) {, +                // The current Thread is the thread that belongs to the Stack, we can try to push the object now., +                pushNow(item);]