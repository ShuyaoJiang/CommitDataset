[+++ b/codec/src/main/java/io/netty/handler/codec/ByteToMessageDecoder.java, +import io.netty.buffer.ByteBufAllocator;, +import io.netty.buffer.CompositeByteBuf;, + * Some methods such as {@link ByteBuf#readBytes(int)} will cause a memory leak if the returned buffer, + * is not released or added to the <tt>out</tt> {@link List}. Use derived buffers like {@link ByteBuf#readSlice(int)}, +    /**, +     * Cumulate {@link ByteBuf}s by merge them into one {@link ByteBuf}'s, using memory copies., +     */, +    public static final Cumulator MERGE_CUMULATOR = new Cumulator() {, +        @Override, +        public ByteBuf cumulate(ByteBufAllocator alloc, ByteBuf cumulation, ByteBuf in) {, +            ByteBuf buffer;, +            if (cumulation.writerIndex() > cumulation.maxCapacity() - in.readableBytes(), +                    || cumulation.refCnt() > 1) {, +                // Expand cumulation (by replace it) when either there is not more room in the buffer, +                // or if the refCnt is greater then 1 which may happen when the user use slice().retain() or, +                // duplicate().retain()., +                //, +                // See:, +                // - https://github.com/netty/netty/issues/2327, +                // - https://github.com/netty/netty/issues/1764, +                buffer = expandCumulation(alloc, cumulation, in.readableBytes());, +            } else {, +                buffer = cumulation;, +            }, +            buffer.writeBytes(in);, +            in.release();, +            return buffer;, +        }, +    };, +, +    /**, +     * Cumulate {@link ByteBuf}s by add them to a {@link CompositeByteBuf} and so do no memory copy whenever possible., +     * Be aware that {@link CompositeByteBuf} use a more complex indexing implementation so depending on your use-case, +     * and the decoder implemention this may be slower then just use the {@link #MERGE_CUMULATOR}., +     */, +    public static final Cumulator COMPOSITE_CUMULATOR = new Cumulator() {, +        @Override, +        public ByteBuf cumulate(ByteBufAllocator alloc, ByteBuf cumulation, ByteBuf in) {, +            ByteBuf buffer;, +            if (cumulation.refCnt() > 1) {, +                // Expand cumulation (by replace it) when the refCnt is greater then 1 which may happen when the user, +                // use slice().retain() or duplicate().retain()., +                //, +                // See:, +                // - https://github.com/netty/netty/issues/2327, +                // - https://github.com/netty/netty/issues/1764, +                buffer = expandCumulation(alloc, cumulation, in.readableBytes());, +                buffer.writeBytes(in);, +                in.release();, +            } else {, +                CompositeByteBuf composite;, +                if (cumulation instanceof CompositeByteBuf) {, +                    composite = (CompositeByteBuf) cumulation;, +                } else {, +                    int readable = cumulation.readableBytes();, +                    composite = alloc.compositeBuffer();, +                    composite.addComponent(cumulation).writerIndex(readable);, +                }, +                composite.addComponent(in).writerIndex(composite.writerIndex() + in.readableBytes());, +                buffer = composite;, +            }, +            return buffer;, +        }, +    };, +, +    private Cumulator cumulator = MERGE_CUMULATOR;, +     * Set the {@link Cumulator} to use for cumulate the received {@link ByteBuf}s., +     */, +    public void setCumulator(Cumulator cumulator) {, +        if (cumulator == null) {, +            throw new NullPointerException("cumulator");, +        }, +        this.cumulator = cumulator;, +    }, +, +    /**, +                    cumulation = cumulator.cumulate(ctx.alloc(), cumulation, data);, +, +    static ByteBuf expandCumulation(ByteBufAllocator alloc, ByteBuf cumulation, int readable) {, +        ByteBuf oldCumulation = cumulation;, +        cumulation = alloc.buffer(oldCumulation.readableBytes() + readable);, +        cumulation.writeBytes(oldCumulation);, +        oldCumulation.release();, +        return cumulation;, +    }, +, +    /**, +     * Cumulate {@link ByteBuf}s., +     */, +    public interface Cumulator {, +        /**, +         * Cumulate the given {@link ByteBuf}s and return the {@link ByteBuf} that holds the cumulated bytes., +         * The implementation is responsible to correctly handle the life-cycle of the given {@link ByteBuf}s and so, +         * call {@link ByteBuf#release()} if a {@link ByteBuf} is fully consumed., +         */, +        ByteBuf cumulate(ByteBufAllocator alloc, ByteBuf cumulation, ByteBuf in);, +    }, +++ b/codec/src/main/java/io/netty/handler/codec/ByteToMessageDecoder.java, +import io.netty.buffer.ByteBufAllocator;]