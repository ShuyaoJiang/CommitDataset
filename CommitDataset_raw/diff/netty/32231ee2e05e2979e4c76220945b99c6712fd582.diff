[+++ b/transport-native-epoll/src/main/c/io_netty_channel_epoll_Native.c, +JNIEXPORT jint JNICALL Java_io_netty_channel_epoll_Native_errnoENOTCONN(JNIEnv* env, jclass clazz) {, +    return ENOTCONN;, +}, +, +++ b/transport-native-epoll/src/main/c/io_netty_channel_epoll_Native.c, +JNIEXPORT jint JNICALL Java_io_netty_channel_epoll_Native_errnoENOTCONN(JNIEnv* env, jclass clazz) {, +    return ENOTCONN;, +}, +, +++ b/transport-native-epoll/src/main/c/io_netty_channel_epoll_Native.h, +jint Java_io_netty_channel_epoll_Native_errnoENOTCONN(JNIEnv* env, jclass clazz);, +++ b/transport-native-epoll/src/main/c/io_netty_channel_epoll_Native.c, +JNIEXPORT jint JNICALL Java_io_netty_channel_epoll_Native_errnoENOTCONN(JNIEnv* env, jclass clazz) {, +    return ENOTCONN;, +}, +, +++ b/transport-native-epoll/src/main/c/io_netty_channel_epoll_Native.h, +jint Java_io_netty_channel_epoll_Native_errnoENOTCONN(JNIEnv* env, jclass clazz);, +++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/AbstractEpollChannel.java, +            // This must happen before we attempt to read. This will ensure reading continues until an error occurs., +            recvBufAllocHandle().receivedRdHup();, +, +, +++ b/transport-native-epoll/src/main/c/io_netty_channel_epoll_Native.c, +JNIEXPORT jint JNICALL Java_io_netty_channel_epoll_Native_errnoENOTCONN(JNIEnv* env, jclass clazz) {, +    return ENOTCONN;, +}, +, +++ b/transport-native-epoll/src/main/c/io_netty_channel_epoll_Native.h, +jint Java_io_netty_channel_epoll_Native_errnoENOTCONN(JNIEnv* env, jclass clazz);, +++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/AbstractEpollChannel.java, +            // This must happen before we attempt to read. This will ensure reading continues until an error occurs., +            recvBufAllocHandle().receivedRdHup();, +, +, +++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollEventLoop.java, +                    if ((ev & (Native.EPOLLERR | Native.EPOLLOUT)) != 0 && ch.isOpen()) {, +                    // Check EPOLLIN before EPOLLRDHUP to ensure all data is read before shutting down the input., +                    // See https://github.com/netty/netty/issues/4317., +                    //, +                    // If EPOLLIN or EPOLLERR was received and the channel is still open call epollInReady(). This will, +                    // try to read from the underlying file descriptor and so notify the user about the error., +                    if ((ev & (Native.EPOLLERR | Native.EPOLLIN)) != 0 && ch.isOpen()) {, +                        // The Channel is still open and there is something to read. Do it now., +                        unsafe.epollInReady();, +                    }, +, +++ b/transport-native-epoll/src/main/c/io_netty_channel_epoll_Native.c, +JNIEXPORT jint JNICALL Java_io_netty_channel_epoll_Native_errnoENOTCONN(JNIEnv* env, jclass clazz) {, +    return ENOTCONN;, +}, +, +++ b/transport-native-epoll/src/main/c/io_netty_channel_epoll_Native.h, +jint Java_io_netty_channel_epoll_Native_errnoENOTCONN(JNIEnv* env, jclass clazz);, +++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/AbstractEpollChannel.java, +            // This must happen before we attempt to read. This will ensure reading continues until an error occurs., +            recvBufAllocHandle().receivedRdHup();, +, +, +++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollEventLoop.java, +                    if ((ev & (Native.EPOLLERR | Native.EPOLLOUT)) != 0 && ch.isOpen()) {, +                    // Check EPOLLIN before EPOLLRDHUP to ensure all data is read before shutting down the input., +                    // See https://github.com/netty/netty/issues/4317., +                    //, +                    // If EPOLLIN or EPOLLERR was received and the channel is still open call epollInReady(). This will, +                    // try to read from the underlying file descriptor and so notify the user about the error., +                    if ((ev & (Native.EPOLLERR | Native.EPOLLIN)) != 0 && ch.isOpen()) {, +                        // The Channel is still open and there is something to read. Do it now., +                        unsafe.epollInReady();, +                    }, +, +++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollRecvByteAllocatorHandle.java, +    private boolean receivedRdHup;, +, +    public final void receivedRdHup() {, +        receivedRdHup = true;, +    }, +, +    public final boolean isRdHup() {, +        return receivedRdHup;, +    }, +++ b/transport-native-epoll/src/main/c/io_netty_channel_epoll_Native.c, +JNIEXPORT jint JNICALL Java_io_netty_channel_epoll_Native_errnoENOTCONN(JNIEnv* env, jclass clazz) {, +    return ENOTCONN;, +}, +, +++ b/transport-native-epoll/src/main/c/io_netty_channel_epoll_Native.h, +jint Java_io_netty_channel_epoll_Native_errnoENOTCONN(JNIEnv* env, jclass clazz);, +++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/AbstractEpollChannel.java, +            // This must happen before we attempt to read. This will ensure reading continues until an error occurs., +            recvBufAllocHandle().receivedRdHup();, +, +, +++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollEventLoop.java, +                    if ((ev & (Native.EPOLLERR | Native.EPOLLOUT)) != 0 && ch.isOpen()) {, +                    // Check EPOLLIN before EPOLLRDHUP to ensure all data is read before shutting down the input., +                    // See https://github.com/netty/netty/issues/4317., +                    //, +                    // If EPOLLIN or EPOLLERR was received and the channel is still open call epollInReady(). This will]