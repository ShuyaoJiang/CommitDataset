[+++ b/src/main/java/org/jboss/netty/handler/codec/frame/DelimiterBasedFrameDecoder.java, +    private final boolean stripDelimiter;, +    private volatile boolean discardingTooLongFrame;, +    private volatile long tooLongFrameLength;, +        this(maxFrameLength, true, delimiter);, +    }, +, +    /**, +     * Creates a new instance., +     *, +     * @param maxFrameLength  the maximum length of the decoded frame., +     *                        A {@link TooLongFrameException} is thrown if, +     *                        the length of the frame exceeds this value., +     * @param stripDelimiter  whether the decoded frame should strip out the, +     *                        delimiter or not, +     * @param delimiter  the delimiter, +     */, +    public DelimiterBasedFrameDecoder(, +            int maxFrameLength, boolean stripDelimiter, ChannelBuffer delimiter) {, +        this.stripDelimiter = stripDelimiter;, +        this(maxFrameLength, true, delimiters);, +    }, +, +    /**, +     * Creates a new instance., +     *, +     * @param maxFrameLength  the maximum length of the decoded frame., +     *                        A {@link TooLongFrameException} is thrown if, +     *                        the length of the frame exceeds this value., +     * @param stripDelimiter  whether the decoded frame should strip out the, +     *                        delimiter or not, +     * @param delimiters  the delimiters, +     */, +    public DelimiterBasedFrameDecoder(, +            int maxFrameLength, boolean stripDelimiter, ChannelBuffer... delimiters) {, +        this.stripDelimiter = stripDelimiter;, +        int minFrameLength = Integer.MAX_VALUE;, +            int frameLength = indexOf(buffer, delim);, +            if (frameLength >= 0 && frameLength < minFrameLength) {, +                minFrameLength = frameLength;, +            int minDelimLength = minDelim.capacity();, +            ChannelBuffer frame;, +, +            if (discardingTooLongFrame) {, +                // We've just finished discarding a very large frame., +                // Throw an exception and go back to the initial state., +                long tooLongFrameLength = this.tooLongFrameLength;, +                this.tooLongFrameLength = 0L;, +                discardingTooLongFrame = false;, +                buffer.skipBytes(minFrameLength + minDelimLength);, +                fail(tooLongFrameLength + minFrameLength + minDelimLength);, +            if (minFrameLength > maxFrameLength) {, +                // Discard read frame., +                buffer.skipBytes(minFrameLength + minDelimLength);, +                fail(minFrameLength);, +, +            if (stripDelimiter) {, +                frame = buffer.readBytes(minFrameLength);, +                buffer.skipBytes(minDelimLength);, +            } else {, +                frame = buffer.readBytes(minFrameLength + minDelimLength);, +            }, +, +            return frame;, +        } else {, +            if (buffer.readableBytes() > maxFrameLength) {, +                // Discard the content of the buffer until a delimiter is found., +                tooLongFrameLength = buffer.readableBytes();, +                buffer.skipBytes(buffer.readableBytes());, +                discardingTooLongFrame = true;, +            }, +, +    }, +    private void fail(long frameLength) throws TooLongFrameException {, +    /**, +     * Returns the number of bytes between the readerIndex of the haystack and, +     * the first needle found in the haystack.  -1 is returned if no needle is, +     * found in the haystack., +     */]