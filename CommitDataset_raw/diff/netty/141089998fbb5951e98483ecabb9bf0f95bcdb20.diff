[+++ b/handler/src/main/java/io/netty/handler/ssl/ReferenceCountedOpenSslEngine.java, +                // we will only produce a single TLS packet, and we don't aggregate src buffers,, +                // so we always fix the number of buffers to 1 when checking if the dst buffer is large enough., +                if (dst.remaining() < calculateOutNetBufSize(srcsLen, 1)) {, +++ b/handler/src/main/java/io/netty/handler/ssl/ReferenceCountedOpenSslEngine.java, +                // we will only produce a single TLS packet, and we don't aggregate src buffers,, +                // so we always fix the number of buffers to 1 when checking if the dst buffer is large enough., +                if (dst.remaining() < calculateOutNetBufSize(srcsLen, 1)) {, +++ b/handler/src/main/java/io/netty/handler/ssl/SslHandler.java, +            int calculateWrapBufferCapacity(SslHandler handler, int pendingBytes, int numComponents) {, +            int calculateWrapBufferCapacity(SslHandler handler, int pendingBytes, int numComponents) {, +            int calculateWrapBufferCapacity(SslHandler handler, int pendingBytes, int numComponents) {, +        abstract int calculateWrapBufferCapacity(SslHandler handler, int pendingBytes, int numComponents);, +        return allocate(ctx, engineType.calculateWrapBufferCapacity(this, pendingBytes, numComponents));, +++ b/handler/src/main/java/io/netty/handler/ssl/ReferenceCountedOpenSslEngine.java, +                // we will only produce a single TLS packet, and we don't aggregate src buffers,, +                // so we always fix the number of buffers to 1 when checking if the dst buffer is large enough., +                if (dst.remaining() < calculateOutNetBufSize(srcsLen, 1)) {, +++ b/handler/src/main/java/io/netty/handler/ssl/SslHandler.java, +            int calculateWrapBufferCapacity(SslHandler handler, int pendingBytes, int numComponents) {, +            int calculateWrapBufferCapacity(SslHandler handler, int pendingBytes, int numComponents) {, +            int calculateWrapBufferCapacity(SslHandler handler, int pendingBytes, int numComponents) {, +        abstract int calculateWrapBufferCapacity(SslHandler handler, int pendingBytes, int numComponents);, +        return allocate(ctx, engineType.calculateWrapBufferCapacity(this, pendingBytes, numComponents));, +++ b/handler/src/test/java/io/netty/handler/ssl/SslHandlerTest.java, +import io.netty.buffer.ByteBufAllocator;, +import io.netty.buffer.Unpooled;, +import io.netty.channel.ChannelHandlerContext;, +import io.netty.channel.ChannelInboundHandlerAdapter;, +import io.netty.channel.ChannelOutboundHandlerAdapter;, +import io.netty.channel.embedded.EmbeddedChannel;, +import io.netty.handler.codec.DecoderException;, +import io.netty.handler.codec.UnsupportedMessageTypeException;, +import io.netty.handler.ssl.util.SelfSignedCertificate;, +import io.netty.util.ReferenceCountUtil;, +import io.netty.util.ReferenceCounted;, +import javax.net.ssl.ManagerFactoryParameters;, +import javax.net.ssl.SSLContext;, +import javax.net.ssl.SSLEngine;, +import javax.net.ssl.SSLException;, +import javax.net.ssl.SSLProtocolException;, +import javax.net.ssl.TrustManager;, +import javax.net.ssl.X509TrustManager;, +, +import static org.hamcrest.CoreMatchers.instanceOf;, +import static org.hamcrest.CoreMatchers.is;, +import static org.hamcrest.CoreMatchers.nullValue;, +import static org.junit.Assert.assertEquals;, +import static org.junit.Assert.assertFalse;, +import static org.junit.Assert.assertThat;, +import static org.junit.Assert.assertTrue;, +import static org.junit.Assert.fail;, +import static org.junit.Assume.assumeTrue;, +    @Test(timeout = 300000), +                        compositeBufSizeEstimationGuaranteesSynchronousWrite(serverProvider, clientProvider,, +                                true, true);, +                        compositeBufSizeEstimationGuaranteesSynchronousWrite(serverProvider, clientProvider,, +                                true, false);, +                        compositeBufSizeEstimationGuaranteesSynchronousWrite(serverProvider, clientProvider,, +                                false, true);, +                        compositeBufSizeEstimationGuaranteesSynchronousWrite(serverProvider, clientProvider,, +                                false, false);, +            SslProvider serverProvider, SslProvider clientProvider,, +            final boolean letHandlerCreateServerEngine, final boolean letHandlerCreateClientEngine), +            // The goal is to provide the SSLEngine with many ByteBuf components to ensure that the overhead for wrap, +            // is correctly accounted for on each component., +            final int numComponents = 150;, +            // This is the TLS packet size. The goal is to divide the maximum amount of application data that can fit, +            // into a single TLS packet into many components to ensure the overhead is correctly taken into account., +            final int desiredBytes = 16384;, +            final int singleComponentSize = desiredBytes / numComponents;, +            final int expectedBytes = numComponents * singleComponentSize;, +                            if (letHandlerCreateServerEngine) {, +                            } else {, +                                ch.pipeline().addLast(new SslHandler(sslServerCtx.newEngine(ch.alloc())));, +                            }, +                                            CompositeByteBuf content = ctx.alloc().compositeDirectBuffer(numComponents);, +                                            for (int i = 0; i < numComponents; ++i) {, +                                                ByteBuf buf = ctx.alloc().directBuffer(singleComponentSize);, +                                                buf.writerIndex(buf.writerIndex() + singleComponentSize);, +                                                content.addComponent(true, buf);, +                                            ctx.writeAndFlush(content);, +                            if (letHandlerCreateClientEngine) {, +                            } else {, +                                ch.pipeline().addLast(new SslHandler(sslClientCtx.newEngine(ch.alloc())));, +                            }]