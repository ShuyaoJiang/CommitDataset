[+++ b/buffer/src/main/java/io/netty/buffer/SlicedByteBuf.java, +import static io.netty.util.internal.MathUtil.isOutOfBounds;, +, +        if (isOutOfBounds(index, length, buffer.capacity())) {, +++ b/buffer/src/main/java/io/netty/buffer/SlicedByteBuf.java, +import static io.netty.util.internal.MathUtil.isOutOfBounds;, +, +        if (isOutOfBounds(index, length, buffer.capacity())) {, +++ b/buffer/src/main/java/io/netty/buffer/SwappedByteBuf.java, +        return buf.retainedSlice().order(order);, +        return buf.retainedSlice(index, length).order(order);, +++ b/buffer/src/main/java/io/netty/buffer/SlicedByteBuf.java, +import static io.netty.util.internal.MathUtil.isOutOfBounds;, +, +        if (isOutOfBounds(index, length, buffer.capacity())) {, +++ b/buffer/src/main/java/io/netty/buffer/SwappedByteBuf.java, +        return buf.retainedSlice().order(order);, +        return buf.retainedSlice(index, length).order(order);, +++ b/buffer/src/test/java/io/netty/buffer/AbstractByteBufTest.java, +    public void testRetainedSliceIndex() throws Exception {, +        assertEqualsAndRelease(buffer, 0, buffer.retainedSlice(0, buffer.capacity()).readerIndex());, +        assertEqualsAndRelease(buffer, 0, buffer.retainedSlice(0, buffer.capacity() - 1).readerIndex());, +        assertEqualsAndRelease(buffer, 0, buffer.retainedSlice(1, buffer.capacity() - 1).readerIndex());, +        assertEqualsAndRelease(buffer, 0, buffer.retainedSlice(1, buffer.capacity() - 2).readerIndex());, +, +        assertEqualsAndRelease(buffer, buffer.capacity(), buffer.retainedSlice(0, buffer.capacity()).writerIndex());, +        assertEqualsAndRelease(buffer,, +                buffer.capacity() - 1, buffer.retainedSlice(0, buffer.capacity() - 1).writerIndex());, +        assertEqualsAndRelease(buffer,, +                buffer.capacity() - 1, buffer.retainedSlice(1, buffer.capacity() - 1).writerIndex());, +        assertEqualsAndRelease(buffer,, +                buffer.capacity() - 2, buffer.retainedSlice(1, buffer.capacity() - 2).writerIndex());, +    }, +, +    @Test, +        assertTrueAndRelease(buffer, buffer.retainedSlice(0, 31).compareTo(wrappedBuffer(value)) < 0);, +        assertTrueAndRelease(buffer,, +                buffer.retainedSlice(0, 31).compareTo(wrappedBuffer(value).order(LITTLE_ENDIAN)) < 0);, +    @Test(expected = IndexOutOfBoundsException.class), +    public void testRetainedSliceIndexOutOfBounds() {, +        testSliceOutOfBounds(true, true, true);, +    }, +, +    @Test(expected = IndexOutOfBoundsException.class), +    public void testRetainedSliceLengthOutOfBounds() {, +        testSliceOutOfBounds(true, true, false);, +    }, +, +    @Test(expected = IndexOutOfBoundsException.class), +    public void testMixedSliceAIndexOutOfBounds() {, +        testSliceOutOfBounds(true, false, true);, +    }, +, +    @Test(expected = IndexOutOfBoundsException.class), +    public void testMixedSliceALengthOutOfBounds() {, +        testSliceOutOfBounds(true, false, false);, +    }, +, +    @Test(expected = IndexOutOfBoundsException.class), +    public void testMixedSliceBIndexOutOfBounds() {, +        testSliceOutOfBounds(false, true, true);, +    }, +, +    @Test(expected = IndexOutOfBoundsException.class), +    public void testMixedSliceBLengthOutOfBounds() {, +        testSliceOutOfBounds(false, true, false);, +    }, +, +    @Test(expected = IndexOutOfBoundsException.class), +    public void testSliceIndexOutOfBounds() {, +        testSliceOutOfBounds(false, false, true);, +    }, +, +    @Test(expected = IndexOutOfBoundsException.class), +    public void testSliceLengthOutOfBounds() {, +        testSliceOutOfBounds(false, false, false);, +    }, +, +    @Test, +    public void testRetainedSliceContents() {, +        testSliceContents(true);, +    }, +, +    @Test, +    public void testSliceContents() {, +        testSliceContents(false);, +    }, +, +    @Test, +    public void testRetainedDuplicateContents() {, +        testDuplicateContents(true);, +    }, +, +    @Test, +    public void testDuplicateContents() {, +        testDuplicateContents(false);, +    }, +, +    private void testSliceOutOfBounds(boolean initRetainedSlice, boolean finalRetainedSlice, boolean indexOutOfBounds) {, +        ByteBuf buf = releaseLater(newBuffer(8));]