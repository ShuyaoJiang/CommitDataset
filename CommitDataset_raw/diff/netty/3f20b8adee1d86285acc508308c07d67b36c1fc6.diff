[+++ b/common/src/main/java/io/netty/util/HashedWheelTimer.java, +import java.util.concurrent.RejectedExecutionException;, +import java.util.concurrent.atomic.AtomicLong;, +    private final AtomicLong pendingTimeouts = new AtomicLong(0);, +    private final long maxPendingTimeouts;, +     * @param leakDetection        {@code true} if leak detection should be enabled always,, +     *                             if false it will only be enabled if the worker thread is not, +     *                             a daemon thread., +        this(threadFactory, tickDuration, unit, ticksPerWheel, leakDetection, -1);, +    }, +, +    /**, +     * Creates a new timer., +     *, +     * @param threadFactory        a {@link ThreadFactory} that creates a, +     *                             background {@link Thread} which is dedicated to, +     *                             {@link TimerTask} execution., +     * @param tickDuration         the duration between tick, +     * @param unit                 the time unit of the {@code tickDuration}, +     * @param ticksPerWheel        the size of the wheel, +     * @param leakDetection        {@code true} if leak detection should be enabled always,, +     *                             if false it will only be enabled if the worker thread is not, +     *                             a daemon thread., +     * @param  maxPendingTimeouts  The maximum number of pending timeouts after which call to, +     *                             {@code newTimeout} will result in, +     *                             {@link java.util.concurrent.RejectedExecutionException}, +     *                             being thrown. No maximum pending timeouts limit is assumed if, +     *                             this value is 0 or negative., +     * @throws NullPointerException     if either of {@code threadFactory} and {@code unit} is {@code null}, +     * @throws IllegalArgumentException if either of {@code tickDuration} and {@code ticksPerWheel} is &lt;= 0, +     */, +    public HashedWheelTimer(, +            ThreadFactory threadFactory,, +            long tickDuration, TimeUnit unit, int ticksPerWheel, boolean leakDetection,, +            long maxPendingTimeouts) {, +, +        this.maxPendingTimeouts = maxPendingTimeouts;, +        if (shouldLimitTimeouts()) {, +            long pendingTimeoutsCount = pendingTimeouts.incrementAndGet();, +            if (pendingTimeoutsCount > maxPendingTimeouts) {, +                pendingTimeouts.decrementAndGet();, +                throw new RejectedExecutionException("Number of pending timeouts (", +                    + pendingTimeoutsCount + ") is greater than or equal to maximum allowed pending ", +                    + "timeouts (" + maxPendingTimeouts + ")");, +            }, +        }, +, +    private boolean shouldLimitTimeouts() {, +        return maxPendingTimeouts > 0;, +    }, +, +            } else if (timer.shouldLimitTimeouts()) {, +                timer.pendingTimeouts.decrementAndGet();, +            if (timeout.timer.shouldLimitTimeouts()) {, +                timeout.timer.pendingTimeouts.decrementAndGet();, +            }, +++ b/common/src/main/java/io/netty/util/HashedWheelTimer.java, +import java.util.concurrent.RejectedExecutionException;, +import java.util.concurrent.atomic.AtomicLong;, +    private final AtomicLong pendingTimeouts = new AtomicLong(0);, +    private final long maxPendingTimeouts;, +     * @param leakDetection        {@code true} if leak detection should be enabled always,, +     *                             if false it will only be enabled if the worker thread is not, +     *                             a daemon thread., +        this(threadFactory, tickDuration, unit, ticksPerWheel, leakDetection, -1);, +    }, +, +    /**, +     * Creates a new timer., +     *, +     * @param threadFactory        a {@link ThreadFactory} that creates a, +     *                             background {@link Thread} which is dedicated to, +     *                             {@link TimerTask} execution., +     * @param tickDuration         the duration between tick, +     * @param unit                 the time unit of the {@code tickDuration}, +     * @param ticksPerWheel        the size of the wheel, +     * @param leakDetection        {@code true} if leak detection should be enabled always,, +     *                             if false it will only be enabled if the worker thread is not, +     *                             a daemon thread., +     * @param  maxPendingTimeouts  The maximum number of pending timeouts after which call to, +     *                             {@code newTimeout} will result in, +     *                             {@link java.util.concurrent.RejectedExecutionException}, +     *                             being thrown. No maximum pending timeouts limit is assumed if, +     *                             this value is 0 or negative., +     * @throws NullPointerException     if either of {@code threadFactory} and {@code unit} is {@code null}, +     * @throws IllegalArgumentException if either of {@code tickDuration} and {@code ticksPerWheel} is &lt;= 0, +     */, +    public HashedWheelTimer(, +            ThreadFactory threadFactory,, +            long tickDuration, TimeUnit unit, int ticksPerWheel, boolean leakDetection,, +            long maxPendingTimeouts) {, +, +        this.maxPendingTimeouts = maxPendingTimeouts;, +        if (shouldLimitTimeouts()) {, +            long pendingTimeoutsCount = pendingTimeouts.incrementAndGet();, +            if (pendingTimeoutsCount > maxPendingTimeouts) {, +                pendingTimeouts.decrementAndGet();, +                throw new RejectedExecutionException("Number of pending timeouts (", +                    + pendingTimeoutsCount + ") is greater than or equal to maximum allowed pending ", +                    + "timeouts (" + maxPendingTimeouts + ")");]