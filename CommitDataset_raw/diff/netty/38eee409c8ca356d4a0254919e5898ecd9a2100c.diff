[+++ b/common/src/main/java/io/netty/util/internal/CleanerJava6.java, +import java.security.AccessController;, +import java.security.PrivilegedAction;, +    private static final Field CLEANER_FIELD;, +        long fieldOffset;, +        Method clean;, +        Field cleanerField;, +        final ByteBuffer direct = ByteBuffer.allocateDirect(1);, +        try {, +            Object mayBeCleanerField = AccessController.doPrivileged(new PrivilegedAction<Object>() {, +                @Override, +                public Object run() {, +                        if (!PlatformDependent.hasUnsafe()) {, +                            // We need to make it accessible if we do not use Unsafe as we will access it via, +                            // reflection., +                            cleanerField.setAccessible(true);, +                        }, +                        return cleanerField;, +                    } catch (Throwable cause) {, +                        return cause;, +                    }, +                }, +            });, +            if (mayBeCleanerField instanceof Throwable) {, +                throw (Throwable) mayBeCleanerField;, +            }, +, +            cleanerField = (Field) mayBeCleanerField;, +, +            final Object cleaner;, +, +            // If we have sun.misc.Unsafe we will use it as its faster then using reflection,, +            // otherwise let us try reflection as last resort., +            if (PlatformDependent.hasUnsafe()) {, +                cleaner = PlatformDependent0.getObject(direct, fieldOffset);, +            } else {, +                fieldOffset = -1;, +                cleaner = cleanerField.get(direct);, +            }, +            cleanerField = null;, +, +        CLEANER_FIELD = cleanerField;, +        return CLEANER_FIELD_OFFSET != -1 || CLEANER_FIELD != null;, +        if (System.getSecurityManager() == null) {, +                freeDirectBuffer0(buffer);, +        } else {, +            freeDirectBufferPrivileged(buffer);, +        }, +    }, +, +    private static void freeDirectBufferPrivileged(final ByteBuffer buffer) {, +        Throwable cause = AccessController.doPrivileged(new PrivilegedAction<Throwable>() {, +            @Override, +            public Throwable run() {, +                try {, +                    freeDirectBuffer0(buffer);, +                    return null;, +                } catch (Throwable cause) {, +                    return cause;, +                }, +            }, +        });, +        if (cause != null) {, +            PlatformDependent0.throwException(cause);, +        }, +    }, +, +    private static void freeDirectBuffer0(ByteBuffer buffer) throws Exception {, +        final Object cleaner;, +        // If CLEANER_FIELD_OFFSET == -1 we need to use reflection to access the cleaner, otherwise we can use, +        // sun.misc.Unsafe., +        if (CLEANER_FIELD_OFFSET == -1) {, +            cleaner = CLEANER_FIELD.get(buffer);, +        } else {, +            cleaner = PlatformDependent0.getObject(buffer, CLEANER_FIELD_OFFSET);, +        }, +        if (cleaner != null) {, +            CLEAN_METHOD.invoke(cleaner);, +        }, +++ b/common/src/main/java/io/netty/util/internal/CleanerJava6.java, +import java.security.AccessController;, +import java.security.PrivilegedAction;, +    private static final Field CLEANER_FIELD;, +        long fieldOffset;, +        Method clean;, +        Field cleanerField;, +        final ByteBuffer direct = ByteBuffer.allocateDirect(1);, +        try {, +            Object mayBeCleanerField = AccessController.doPrivileged(new PrivilegedAction<Object>() {, +                @Override, +                public Object run() {, +                        if (!PlatformDependent.hasUnsafe()) {, +                            // We need to make it accessible if we do not use Unsafe as we will access it via, +                            // reflection., +                            cleanerField.setAccessible(true);, +                        }, +                        return cleanerField;, +                    } catch (Throwable cause) {, +                        return cause;, +                    }]