[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2RemoteFlowController.java, +, +, +    private final StreamByteDistributor.Writer writer = new StreamByteDistributor.Writer() {, +        public void write(Http2Stream stream, int numBytes) {, +            int written = state(stream).writeAllocatedBytes(numBytes);, +    private final StreamByteDistributor streamByteDistributor;, +    private final AbstractState connectionState;, +        this(connection, new PriorityStreamByteDistributor(connection));, +    }, +, +    public DefaultHttp2RemoteFlowController(Http2Connection connection,, +                                            StreamByteDistributor streamByteDistributor) {, +        this.streamByteDistributor = checkNotNull(streamByteDistributor, "streamWriteDistributor");, +        connectionState = new DefaultState(connection.connectionStream(), initialWindowSize);, +        connection.connectionStream().setProperty(stateKey, connectionState);, +            connectionState.incrementStreamWindow(delta);, +        return connectionState.windowSize();, +        return min(connectionState.windowSize(), useableBytes);, +     *, +     * @return The amount of bytes that can be supported by underlying {@link, +     * io.netty.channel.Channel} without queuing "too-much"., +    private int writableBytes() {, +        return Math.min(connectionWindowSize(), maxUsableChannelBytes());, +        int bytesToWrite = writableBytes();, +        boolean haveUnwrittenBytes;, +, +        // Using a do-while loop so that we always write at least once, regardless if we have, +        // bytesToWrite or not. This ensures that zero-length frames will always be written., +            // Distribute the connection window across the streams and write the data., +            haveUnwrittenBytes = streamByteDistributor.distribute(bytesToWrite, writer);, +        } while (haveUnwrittenBytes && (bytesToWrite = writableBytes()) > 0 && ctx.channel().isWritable());, +        int writeAllocatedBytes(int allocated) {, +            try {, +                return writeBytes(allocated);, +            } finally {, +                streamByteDistributor.updateStreamableBytes(this);, +            streamByteDistributor.updateStreamableBytes(this);, +        public int streamableBytes() {, +            return max(0, min(pendingBytes, window));, +        public boolean hasFrame() {, +            streamByteDistributor.updateStreamableBytes(this);, +         * Increments the number of pending bytes for this node and updates the {@link StreamByteDistributor}., +            streamByteDistributor.updateStreamableBytes(this);, +                connectionState.incrementStreamWindow(negativeBytes);, +        public int streamableBytes() {, +        int writeAllocatedBytes(int allocated) {, +        public boolean hasFrame() {, +    private abstract class AbstractState implements StreamByteDistributor.StreamState {, +        @Override, +        public final Http2Stream stream() {, +        abstract int writeAllocatedBytes(int allocated);, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2RemoteFlowController.java, +, +, +    private final StreamByteDistributor.Writer writer = new StreamByteDistributor.Writer() {, +        public void write(Http2Stream stream, int numBytes) {, +            int written = state(stream).writeAllocatedBytes(numBytes);, +    private final StreamByteDistributor streamByteDistributor;, +    private final AbstractState connectionState;, +        this(connection, new PriorityStreamByteDistributor(connection));, +    }, +, +    public DefaultHttp2RemoteFlowController(Http2Connection connection,, +                                            StreamByteDistributor streamByteDistributor) {, +        this.streamByteDistributor = checkNotNull(streamByteDistributor, "streamWriteDistributor");, +        connectionState = new DefaultState(connection.connectionStream(), initialWindowSize);, +        connection.connectionStream().setProperty(stateKey, connectionState);, +            connectionState.incrementStreamWindow(delta);, +        return connectionState.windowSize();, +        return min(connectionState.windowSize(), useableBytes);, +     *, +     * @return The amount of bytes that can be supported by underlying {@link, +     * io.netty.channel.Channel} without queuing "too-much"., +    private int writableBytes() {, +        return Math.min(connectionWindowSize(), maxUsableChannelBytes());, +        int bytesToWrite = writableBytes();, +        boolean haveUnwrittenBytes;, +, +        // Using a do-while loop so that we always write at least once, regardless if we have, +        // bytesToWrite or not. This ensures that zero-length frames will always be written., +            // Distribute the connection window across the streams and write the data., +            haveUnwrittenBytes = streamByteDistributor.distribute(bytesToWrite, writer);, +        } while (haveUnwrittenBytes && (bytesToWrite = writableBytes()) > 0 && ctx.channel().isWritable());, +        int writeAllocatedBytes(int allocated) {, +            try {, +                return writeBytes(allocated);, +            } finally {, +                streamByteDistributor.updateStreamableBytes(this);, +            streamByteDistributor.updateStreamableBytes(this);, +        public int streamableBytes() {, +            return max(0, min(pendingBytes, window));, +        public boolean hasFrame() {, +            streamByteDistributor.updateStreamableBytes(this);, +         * Increments the number of pending bytes for this node and updates the {@link StreamByteDistributor}., +            streamByteDistributor.updateStreamableBytes(this);, +                connectionState.incrementStreamWindow(negativeBytes);, +        public int streamableBytes() {, +        int writeAllocatedBytes(int allocated) {, +        public boolean hasFrame() {]