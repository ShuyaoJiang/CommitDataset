[+++ b/handler/src/main/java/io/netty/handler/ssl/ReferenceCountedOpenSslEngine.java, +    private int writePlaintextData(final ByteBuffer src, int len) {, +, +            loop: for (int i = offset; i < endOffset; ++i) {, +                    int result = writePlaintextData(, +                            src, Math.min(src.remaining(), MAX_PLAINTEXT_LENGTH - bytesConsumed));, +, +                        if (bytesConsumed == MAX_PLAINTEXT_LENGTH) {, +                            // If we consumed the maximum amount of bytes for the plaintext length break out of the, +                            // loop and start to fill the dst buffer., +                            break loop;, +                        }, +++ b/handler/src/main/java/io/netty/handler/ssl/ReferenceCountedOpenSslEngine.java, +    private int writePlaintextData(final ByteBuffer src, int len) {, +, +            loop: for (int i = offset; i < endOffset; ++i) {, +                    int result = writePlaintextData(, +                            src, Math.min(src.remaining(), MAX_PLAINTEXT_LENGTH - bytesConsumed));, +, +                        if (bytesConsumed == MAX_PLAINTEXT_LENGTH) {, +                            // If we consumed the maximum amount of bytes for the plaintext length break out of the, +                            // loop and start to fill the dst buffer., +                            break loop;, +                        }, +++ b/handler/src/test/java/io/netty/handler/ssl/SSLEngineTest.java, +        boolean clientHandshakeFinished = false;, +        boolean serverHandshakeFinished = false;, +, +            int cTOsPos = cTOs.position();, +            int sTOcPos = sTOc.position();, +, +, +            // Verify that the consumed and produced number match what is in the buffers now., +            assertEquals(empty.remaining(), clientResult.bytesConsumed());, +            assertEquals(empty.remaining(), serverResult.bytesConsumed());, +            assertEquals(cTOs.position() - cTOsPos,  clientResult.bytesProduced());, +            assertEquals(sTOc.position() - sTOcPos, serverResult.bytesProduced());, +, +, +            // Verify that we only had one SSLEngineResult.HandshakeStatus.FINISHED, +            if (isHandshakeFinished(clientResult)) {, +                assertFalse(clientHandshakeFinished);, +                clientHandshakeFinished = true;, +            }, +            if (isHandshakeFinished(serverResult)) {, +                assertFalse(serverHandshakeFinished);, +                serverHandshakeFinished = true;, +            }, +, +            cTOsPos = cTOs.position();, +            sTOcPos = sTOc.position();, +, +            int clientAppReadBufferPos = clientAppReadBuffer.position();, +            int serverAppReadBufferPos = serverAppReadBuffer.position();, +, +, +            // Verify that the consumed and produced number match what is in the buffers now., +            assertEquals(sTOc.position() - sTOcPos, clientResult.bytesConsumed());, +            assertEquals(cTOs.position() - cTOsPos, serverResult.bytesConsumed());, +            assertEquals(clientAppReadBuffer.position() - clientAppReadBufferPos, clientResult.bytesProduced());, +            assertEquals(serverAppReadBuffer.position() - serverAppReadBufferPos, serverResult.bytesProduced());, +, +, +            // Verify that we only had one SSLEngineResult.HandshakeStatus.FINISHED, +            if (isHandshakeFinished(clientResult)) {, +                assertFalse(clientHandshakeFinished);, +                clientHandshakeFinished = true;, +            }, +            if (isHandshakeFinished(serverResult)) {, +                assertFalse(serverHandshakeFinished);, +                serverHandshakeFinished = true;, +            }, +        } while (!clientHandshakeFinished || !serverHandshakeFinished);, +    private static boolean isHandshakeFinished(SSLEngineResult result) {, +        return result.getHandshakeStatus() == SSLEngineResult.HandshakeStatus.FINISHED;, +, +    @Test, +    public void testPacketBufferSizeLimit() throws Exception {, +        SelfSignedCertificate cert = new SelfSignedCertificate();, +, +        clientSslCtx = SslContextBuilder, +                .forClient(), +                .trustManager(cert.cert()), +                .sslProvider(sslClientProvider()), +                .build();, +        SSLEngine client = clientSslCtx.newEngine(UnpooledByteBufAllocator.DEFAULT);, +, +        serverSslCtx = SslContextBuilder, +                .forServer(cert.certificate(), cert.privateKey()), +                .sslProvider(sslServerProvider()), +                .build();, +        SSLEngine server = serverSslCtx.newEngine(UnpooledByteBufAllocator.DEFAULT);, +, +        try {, +            // Allocate an buffer that is bigger then the max plain record size., +            ByteBuffer plainServerOut = ByteBuffer.allocate(server.getSession().getApplicationBufferSize() * 2);, +, +            handshake(client, server);, +, +            // Fill the whole buffer and flip it.]