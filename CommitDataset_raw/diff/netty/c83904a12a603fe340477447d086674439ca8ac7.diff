[+++ b/buffer/src/main/java/io/netty/buffer/PooledByteBufAllocator.java, +import io.netty.util.concurrent.EventExecutor;, +import io.netty.util.internal.ThreadExecutorMap;, +import java.util.concurrent.TimeUnit;, +    private static final long DEFAULT_CACHE_TRIM_INTERVAL_MILLIS;, +    private final Runnable trimTask = new Runnable() {, +        @Override, +        public void run() {, +            PooledByteBufAllocator.this.trimCurrentThreadCache();, +        }, +    };, +, +        DEFAULT_CACHE_TRIM_INTERVAL_MILLIS = SystemPropertyUtil.getLong(, +                "io.netty.allocation.cacheTrimIntervalMillis", 0);, +, +            logger.debug("-Dio.netty.allocator.cacheTrimIntervalMillis: {}", DEFAULT_CACHE_TRIM_INTERVAL_MILLIS);, +            final Thread current = Thread.currentThread();, +                final PoolThreadCache cache = new PoolThreadCache(, +, +                if (DEFAULT_CACHE_TRIM_INTERVAL_MILLIS > 0) {, +                    final EventExecutor executor = ThreadExecutorMap.currentExecutor();, +                    if (executor != null) {, +                        executor.scheduleAtFixedRate(trimTask, DEFAULT_CACHE_TRIM_INTERVAL_MILLIS,, +                                DEFAULT_CACHE_TRIM_INTERVAL_MILLIS, TimeUnit.MILLISECONDS);, +                    }, +                }, +                return cache;, +     * Trim thread local cache for the current {@link Thread}, which will give back any cached memory that was not, +     * allocated frequently since the last trim operation., +     *, +     * Returns {@code true} if a cache for the current {@link Thread} exists and so was trimmed, false otherwise., +     */, +    public boolean trimCurrentThreadCache() {, +        PoolThreadCache cache = threadCache.getIfExists();, +        if (cache != null) {, +            cache.trim();, +            return true;, +        }, +        return false;, +    }, +, +    /**, +++ b/buffer/src/main/java/io/netty/buffer/PooledByteBufAllocator.java, +import io.netty.util.concurrent.EventExecutor;, +import io.netty.util.internal.ThreadExecutorMap;, +import java.util.concurrent.TimeUnit;, +    private static final long DEFAULT_CACHE_TRIM_INTERVAL_MILLIS;, +    private final Runnable trimTask = new Runnable() {, +        @Override, +        public void run() {, +            PooledByteBufAllocator.this.trimCurrentThreadCache();, +        }, +    };, +, +        DEFAULT_CACHE_TRIM_INTERVAL_MILLIS = SystemPropertyUtil.getLong(, +                "io.netty.allocation.cacheTrimIntervalMillis", 0);, +, +            logger.debug("-Dio.netty.allocator.cacheTrimIntervalMillis: {}", DEFAULT_CACHE_TRIM_INTERVAL_MILLIS);, +            final Thread current = Thread.currentThread();, +                final PoolThreadCache cache = new PoolThreadCache(, +, +                if (DEFAULT_CACHE_TRIM_INTERVAL_MILLIS > 0) {, +                    final EventExecutor executor = ThreadExecutorMap.currentExecutor();, +                    if (executor != null) {, +                        executor.scheduleAtFixedRate(trimTask, DEFAULT_CACHE_TRIM_INTERVAL_MILLIS,, +                                DEFAULT_CACHE_TRIM_INTERVAL_MILLIS, TimeUnit.MILLISECONDS);, +                    }, +                }, +                return cache;, +     * Trim thread local cache for the current {@link Thread}, which will give back any cached memory that was not, +     * allocated frequently since the last trim operation., +     *, +     * Returns {@code true} if a cache for the current {@link Thread} exists and so was trimmed, false otherwise., +     */, +    public boolean trimCurrentThreadCache() {, +        PoolThreadCache cache = threadCache.getIfExists();, +        if (cache != null) {, +            cache.trim();, +            return true;, +        }, +        return false;, +    }, +, +    /**, +++ b/buffer/src/test/java/io/netty/buffer/PooledByteBufAllocatorTest.java, +    public void testTrim() {, +        PooledByteBufAllocator allocator = newAllocator(true);, +, +        // Should return false as we never allocated from this thread yet., +        assertFalse(allocator.trimCurrentThreadCache());, +, +        ByteBuf directBuffer = allocator.directBuffer();, +, +        assertTrue(directBuffer.release());, +, +        // Should return true now a cache exists for the calling thread., +        assertTrue(allocator.trimCurrentThreadCache());, +    }, +, +    @Test]