[+++ b/transport/src/main/java/io/netty/channel/ChannelInitializer.java, +import java.util.Collections;, +import java.util.Set;, +import java.util.concurrent.ConcurrentHashMap;, +    // We use a Set as a ChannelInitializer is usually shared between all Channels in a Bootstrap /, +    private final Set<ChannelHandlerContext> initMap = Collections.newSetFromMap(, +            new ConcurrentHashMap<ChannelHandlerContext, Boolean>());, +    @Override, +    public void handlerRemoved(ChannelHandlerContext ctx) throws Exception {, +        initMap.remove(ctx);, +    }, +, +        if (initMap.add(ctx)) { // Guard against re-entrance., +    private void remove(final ChannelHandlerContext ctx) {, +            // The removal may happen in an async fashion if the EventExecutor we use does something funky., +            if (ctx.isRemoved()) {, +            } else {, +                // Ensure we always remove from the Map in all cases to not produce a memory leak., +                ctx.channel().closeFuture().addListener(new ChannelFutureListener() {, +                    @Override, +                    public void operationComplete(ChannelFuture future) {, +                        initMap.remove(ctx);, +                    }, +                });, +            }, +++ b/transport/src/main/java/io/netty/channel/ChannelInitializer.java, +import java.util.Collections;, +import java.util.Set;, +import java.util.concurrent.ConcurrentHashMap;, +    // We use a Set as a ChannelInitializer is usually shared between all Channels in a Bootstrap /, +    private final Set<ChannelHandlerContext> initMap = Collections.newSetFromMap(, +            new ConcurrentHashMap<ChannelHandlerContext, Boolean>());, +    @Override, +    public void handlerRemoved(ChannelHandlerContext ctx) throws Exception {, +        initMap.remove(ctx);, +    }, +, +        if (initMap.add(ctx)) { // Guard against re-entrance., +    private void remove(final ChannelHandlerContext ctx) {, +            // The removal may happen in an async fashion if the EventExecutor we use does something funky., +            if (ctx.isRemoved()) {, +            } else {, +                // Ensure we always remove from the Map in all cases to not produce a memory leak., +                ctx.channel().closeFuture().addListener(new ChannelFutureListener() {, +                    @Override, +                    public void operationComplete(ChannelFuture future) {, +                        initMap.remove(ctx);, +                    }, +                });, +            }, +++ b/transport/src/test/java/io/netty/channel/ChannelInitializerTest.java, +import io.netty.util.concurrent.EventExecutor;, +import io.netty.util.concurrent.Future;, +import java.util.concurrent.Executors;, +import java.util.concurrent.ScheduledExecutorService;, +import static org.junit.Assert.assertNotNull;, +    @SuppressWarnings("deprecation"), +    @Test(timeout = 10000), +    public void testChannelInitializerEventExecutor() throws Throwable {, +        final AtomicInteger invokeCount = new AtomicInteger();, +        final AtomicInteger completeCount = new AtomicInteger();, +        final AtomicReference<Throwable> errorRef = new AtomicReference<Throwable>();, +        LocalAddress addr = new LocalAddress("test");, +, +        final EventExecutor executor = new DefaultEventLoop() {, +            private final ScheduledExecutorService execService = Executors.newSingleThreadScheduledExecutor();, +, +            @Override, +            public void shutdown() {, +                execService.shutdown();, +            }, +, +            @Override, +            public boolean inEventLoop(Thread thread) {, +                // Always return false which will ensure we always call execute(...), +                return false;, +            }, +, +            @Override, +            public boolean isShuttingDown() {, +                return false;, +            }, +, +            @Override, +            public Future<?> shutdownGracefully(long quietPeriod, long timeout, TimeUnit unit) {, +                throw new IllegalStateException();, +            }, +, +            @Override, +            public Future<?> terminationFuture() {, +                throw new IllegalStateException();, +            }, +, +            @Override, +            public boolean isShutdown() {, +                return execService.isShutdown();, +            }, +, +            @Override, +            public boolean isTerminated() {]