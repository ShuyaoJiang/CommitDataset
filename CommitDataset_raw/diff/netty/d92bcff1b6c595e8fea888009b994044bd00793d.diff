[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentEncoder.java, +                        // Set the content length to 0., +                        res.headers().remove(Names.TRANSFER_ENCODING);, +                        res.headers().set(Names.CONTENT_LENGTH, "0");, +                final Result result = beginEncode(res, acceptEncoding);, +                        // As an unchunked response, +                        res.headers().remove(Names.TRANSFER_ENCODING);, +                        res.headers().set(Names.CONTENT_LENGTH, ((ByteBufHolder) res).data().readableBytes());, +                        // As a chunked response, +                        res.headers().remove(Names.CONTENT_LENGTH);, +                        res.headers().set(Names.TRANSFER_ENCODING, Values.CHUNKED);, +, +                if (newContent.isReadable()) {, +                    return new HttpContent[] {, +                            new DefaultHttpContent(newContent), new DefaultLastHttpContent(lastProduct)};, +                } else {, +                    return new HttpContent[] { new DefaultLastHttpContent(lastProduct) };, +                }, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentEncoder.java, +                        // Set the content length to 0., +                        res.headers().remove(Names.TRANSFER_ENCODING);, +                        res.headers().set(Names.CONTENT_LENGTH, "0");, +                final Result result = beginEncode(res, acceptEncoding);, +                        // As an unchunked response, +                        res.headers().remove(Names.TRANSFER_ENCODING);, +                        res.headers().set(Names.CONTENT_LENGTH, ((ByteBufHolder) res).data().readableBytes());, +                        // As a chunked response, +                        res.headers().remove(Names.CONTENT_LENGTH);, +                        res.headers().set(Names.TRANSFER_ENCODING, Values.CHUNKED);, +, +                if (newContent.isReadable()) {, +                    return new HttpContent[] {, +                            new DefaultHttpContent(newContent), new DefaultLastHttpContent(lastProduct)};, +                } else {, +                    return new HttpContent[] { new DefaultLastHttpContent(lastProduct) };, +                }, +++ b/codec-http/src/test/java/io/netty/handler/codec/http/HttpContentCompressorTest.java, +import io.netty.channel.embedded.EmbeddedMessageChannel;, +import io.netty.handler.codec.http.HttpHeaders.Names;, +import static org.hamcrest.CoreMatchers.*;, +import static org.junit.Assert.*;, +, +                    fail();, +            assertEquals(contentEncoding, targetEncoding);, +, +    @Test, +    public void testEmptyContentCompression() throws Exception {, +        EmbeddedMessageChannel ch = new EmbeddedMessageChannel(new HttpContentCompressor());, +        FullHttpRequest req = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.GET, "/");, +        req.headers().set(Names.ACCEPT_ENCODING, "deflate");, +        ch.writeInbound(req);, +, +        ch.writeOutbound(new DefaultHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.OK));, +, +        HttpResponse res = (HttpResponse) ch.readOutbound();, +        assertThat(res, is(not(instanceOf(FullHttpResponse.class))));, +        assertThat(res.headers().get(Names.TRANSFER_ENCODING), is("chunked"));, +        assertThat(res.headers().get(Names.CONTENT_LENGTH), is(nullValue()));, +        assertThat(res.headers().get(Names.CONTENT_ENCODING), is("deflate"));, +, +        ch.writeOutbound(LastHttpContent.EMPTY_LAST_CONTENT);, +, +        HttpContent chunk;, +        chunk = (HttpContent) ch.readOutbound();, +        assertThat(chunk, is(instanceOf(LastHttpContent.class)));, +        assertThat(chunk.data().isReadable(), is(true));, +, +        assertThat(ch.readOutbound(), is(nullValue()));, +    }, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentEncoder.java, +                        // Set the content length to 0., +                        res.headers().remove(Names.TRANSFER_ENCODING);, +                        res.headers().set(Names.CONTENT_LENGTH, "0");, +                final Result result = beginEncode(res, acceptEncoding);, +                        // As an unchunked response, +                        res.headers().remove(Names.TRANSFER_ENCODING);, +                        res.headers().set(Names.CONTENT_LENGTH, ((ByteBufHolder) res).data().readableBytes());, +                        // As a chunked response, +                        res.headers().remove(Names.CONTENT_LENGTH);, +                        res.headers().set(Names.TRANSFER_ENCODING, Values.CHUNKED);, +, +                if (newContent.isReadable()) {, +                    return new HttpContent[] {, +                            new DefaultHttpContent(newContent), new DefaultLastHttpContent(lastProduct)};, +                } else {, +                    return new HttpContent[] { new DefaultLastHttpContent(lastProduct) };, +                }, +++ b/codec-http/src/test/java/io/netty/handler/codec/http/HttpContentCompressorTest.java, +import io.netty.channel.embedded.EmbeddedMessageChannel;, +import io.netty.handler.codec.http.HttpHeaders.Names;, +import static org.hamcrest.CoreMatchers.*;, +import static org.junit.Assert.*;, +, +                    fail();, +            assertEquals(contentEncoding, targetEncoding);, +, +    @Test, +    public void testEmptyContentCompression() throws Exception {, +        EmbeddedMessageChannel ch = new EmbeddedMessageChannel(new HttpContentCompressor());, +        FullHttpRequest req = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.GET, "/");]