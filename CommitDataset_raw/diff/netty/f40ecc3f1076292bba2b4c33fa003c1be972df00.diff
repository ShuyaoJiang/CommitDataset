[+++ b/codec/src/main/java/io/netty/handler/codec/compression/Snappy.java, +            length = in.readUnsignedShortLE();, +        int offset = in.readUnsignedShortLE();, +     * the permissible bounds of an offset (0 < offset < Integer.MAX_VALUE), and does not, +        if (offset == 0) {, +            throw new DecompressionException("Offset is less than minimum permissible value");, +        if (offset < 0) {, +            // Due to arithmetic overflow, +            throw new DecompressionException("Offset is greater than maximum value supported by this implementation");, +++ b/codec/src/main/java/io/netty/handler/codec/compression/Snappy.java, +            length = in.readUnsignedShortLE();, +        int offset = in.readUnsignedShortLE();, +     * the permissible bounds of an offset (0 < offset < Integer.MAX_VALUE), and does not, +        if (offset == 0) {, +            throw new DecompressionException("Offset is less than minimum permissible value");, +        if (offset < 0) {, +            // Due to arithmetic overflow, +            throw new DecompressionException("Offset is greater than maximum value supported by this implementation");, +++ b/codec/src/test/java/io/netty/handler/codec/compression/SnappyTest.java, +, +    @Test, +    public void testLarge2ByteLiteralLengthAndCopyOffset() {, +        ByteBuf compressed = Unpooled.buffer();, +        ByteBuf actualDecompressed = Unpooled.buffer();, +        ByteBuf expectedDecompressed = Unpooled.buffer().writeByte(0x01).writeZero(0x8000).writeByte(0x01);, +        try {, +            // Generate a Snappy-encoded buffer that can only be decompressed correctly if, +            // the decoder treats 2-byte literal lengths and 2-byte copy offsets as unsigned values., +, +            // Write preamble, uncompressed content length (0x8002) encoded as varint., +            compressed.writeByte(0x82).writeByte(0x80).writeByte(0x02);, +, +            // Write a literal consisting of 0x01 followed by 0x8000 zeroes., +            // The total length of this literal is 0x8001, which gets encoded as 0x8000 (length - 1)., +            // This length was selected because the encoded form is one larger than the maximum value, +            // representable using a signed 16-bit integer, and we want to assert the decoder is reading, +            // the length as an unsigned value., +            compressed.writeByte(61 << 2); // tag for LITERAL with a 2-byte length, +            compressed.writeShortLE(0x8000); // length - 1, +            compressed.writeByte(0x01).writeZero(0x8000); // literal content, +, +            // Similarly, for a 2-byte copy operation we want to ensure the offset is treated as unsigned., +            // Copy the initial 0x01 which was written 0x8001 bytes back in the stream., +            compressed.writeByte(0x02); // tag for COPY with 2-byte offset, length = 1, +            compressed.writeShortLE(0x8001); // offset, +, +            snappy.decode(compressed, actualDecompressed);, +            assertEquals(expectedDecompressed, actualDecompressed);, +        } finally {, +            compressed.release();, +            actualDecompressed.release();, +            expectedDecompressed.release();, +        }, +    }]