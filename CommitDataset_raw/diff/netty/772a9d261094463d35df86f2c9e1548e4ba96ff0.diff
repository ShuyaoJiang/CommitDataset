[+++ b/transport/src/main/java/io/netty/channel/DefaultChannelHandlerInvoker.java, +        if (!validatePromise(ctx, promise, false)) {, +            // promise cancelled, +            return;, +        }, +        if (!validatePromise(ctx, promise, false)) {, +            // promise cancelled, +            return;, +        }, +        if (!validatePromise(ctx, promise, false)) {, +            // promise cancelled, +            return;, +        }, +        if (!validatePromise(ctx, promise, false)) {, +            // promise cancelled, +            return;, +        }, +        if (!validatePromise(ctx, promise, false)) {, +            // promise cancelled, +            return;, +        }, +        if (!validatePromise(ctx, promise, true)) {, +            // promise cancelled, +            ReferenceCountUtil.release(msg);, +            return;, +        }, +, +        if (!validatePromise(ctx, promise, true)) {, +            // promise cancelled, +            ReferenceCountUtil.release(msg);, +            return;, +        }, +    private static boolean validatePromise(, +            ChannelHandlerContext ctx, ChannelPromise promise, boolean allowVoidPromise) {, +            if (promise.isCancelled()) {, +                return false;, +            }, +            return true;, +        return true;, +++ b/transport/src/main/java/io/netty/channel/DefaultChannelHandlerInvoker.java, +        if (!validatePromise(ctx, promise, false)) {, +            // promise cancelled, +            return;, +        }, +        if (!validatePromise(ctx, promise, false)) {, +            // promise cancelled, +            return;, +        }, +        if (!validatePromise(ctx, promise, false)) {, +            // promise cancelled, +            return;, +        }, +        if (!validatePromise(ctx, promise, false)) {, +            // promise cancelled, +            return;, +        }, +        if (!validatePromise(ctx, promise, false)) {, +            // promise cancelled, +            return;, +        }, +        if (!validatePromise(ctx, promise, true)) {, +            // promise cancelled, +            ReferenceCountUtil.release(msg);, +            return;, +        }, +, +        if (!validatePromise(ctx, promise, true)) {, +            // promise cancelled, +            ReferenceCountUtil.release(msg);, +            return;, +        }, +    private static boolean validatePromise(, +            ChannelHandlerContext ctx, ChannelPromise promise, boolean allowVoidPromise) {, +            if (promise.isCancelled()) {, +                return false;, +            }, +            return true;, +        return true;, +++ b/transport/src/test/java/io/netty/channel/DefaultChannelPipelineTest.java, +import io.netty.buffer.ByteBuf;, +import io.netty.buffer.Unpooled;, +    // Tests for https://github.com/netty/netty/issues/2349, +    @Test, +    public void testCancelBind() throws Exception {, +        ChannelPipeline pipeline = new LocalChannel().pipeline();, +        group.register(pipeline.channel());, +, +        ChannelPromise promise = pipeline.channel().newPromise();, +        assertTrue(promise.cancel(false));, +        ChannelFuture future = pipeline.bind(new LocalAddress("test"), promise);, +        assertTrue(future.isCancelled());, +    }, +, +    @Test, +    public void testCancelConnect() throws Exception {, +        ChannelPipeline pipeline = new LocalChannel().pipeline();, +        group.register(pipeline.channel());, +, +        ChannelPromise promise = pipeline.channel().newPromise();, +        assertTrue(promise.cancel(false));]