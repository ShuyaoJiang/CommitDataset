[+++ b/src/main/java/org/jboss/netty/handler/queue/BufferedWriteHandler.java, +import java.util.ArrayList;, +import java.util.List;, +import org.jboss.netty.buffer.ChannelBuffers;, +import org.jboss.netty.channel.ChannelConfig;, +import org.jboss.netty.channel.ChannelFuture;, +import org.jboss.netty.channel.ChannelFutureListener;, +import org.jboss.netty.channel.Channels;, +import org.jboss.netty.channel.SimpleChannelHandler;, +import org.jboss.netty.channel.socket.nio.NioSocketChannelConfig;, + * queue otherwise.  It means you have to call {@link #flush()} before the size, + * of the queue increases too much.  You can implement your own auto-flush, + * strategy by extending this handler:, + *     {@literal @Override}, + * <h3>Consolidate on flush</h3>, + *, + * If there are two or more write requests in the queue and all their message, + * type is {@link ChannelBuffer}, they can be merged into a single write request, + * to save the number of system calls., + * <pre>, + * BEFORE consolidation:            AFTER consolidation:, + * +-------+-------+-------+        +-------------+, + * | Req C | Req B | Req A |------\\| Request ABC |, + * | "789" | "456" | "123" |------//| "123456789" |, + * +-------+-------+-------+        +-------------+, + * </pre>, + * This feature is disabled by default.  You can override the default when you, + * create this handler or call {@link #flush(boolean)}.  If you specified, + * {@code true} when you call the constructor, calling {@link #flush()} will, + * always consolidate the queue.  Otherwise, you have to call, + * {@link #flush(boolean)} with {@code true} to enable this feature for each, + * flush., + * The disadvantage of consolidation is that the {@link ChannelFuture} and its, + * {@link ChannelFutureListener}s associated with the original write requests, + * might be notified later than when they are actually written out.  They will, + * always be notified when the consolidated write request is fully written., + * <p>, + * The following example implements the consolidation strategy that reduces, + * the number of write requests based on the writability of a channel:, + * <pre>, + * public class ConsolidatingAutoFlusher extends {@link BufferedWriteHandler} {, + *, + *     public ConsolidatingAutoFlusher() {, + *         // Enable consolidation by default., + *         super(true);, + *     }, + *, + *     {@literal @Override}, + *     public void channelOpen({@link ChannelHandlerContext} ctx, {@link ChannelStateEvent} e) throws Exception {, + *         {@link ChannelConfig} cfg = e.getChannel().getConfig();, + *         if (cfg instanceof {@link NioSocketChannelConfig}) {, + *             // Lower the watermark to increase the chance of consolidation., + *             cfg.setWriteBufferLowWaterMark(0);, + *         }, + *         super.channelOpen(e);, + *     }, + *, + *     {@literal @Override}, + *     public void writeRequested({@link ChannelHandlerContext} ctx, {@link MessageEvent} e) throws Exception {, + *         super.writeRequested(ctx, et);, + *         if (e.getChannel().isWritable()) {, + *             flush();, + *         }, + *     }, + *, + *     {@literal @Override}, + *     public void channelInterestChanged({@link ChannelHandlerContext} ctx, {@link ChannelStateEvent} e) throws Exception {, + *         if (e.getChannel().isWritable()) {, + *             flush();, + *         }, + *     }, + * }, + * </pre>, + *, + * <h3>Prioritized Writes</h3>, + *, + * For example, you could call {@link #flush()} periodically, using, + * {@link HashedWheelTimer} every second., +public class BufferedWriteHandler extends SimpleChannelHandler {, +    private final boolean consolidateOnFlush;, +     * implementation and without buffer consolidation., +        this(false);, +    }, +, +    /**, +     * Creates a new instance with the specified thread-safe unbounded, +     * {@link Queue} and without buffer consolidation.  Please note that, +     * specifying a bounded {@link Queue} or a thread-unsafe {@link Queue} will, +     * result in an unspecified behavior., +     */, +    public BufferedWriteHandler(Queue<MessageEvent> queue) {, +        this(queue, false);, +    }, +, +    /**, +     * Creates a new instance with the default unbounded {@link BlockingQueue}, +     * implementation., +     *, +     * @param consolidateOnFlush, +     *        {@code true} if and only if the buffered write requests are merged]