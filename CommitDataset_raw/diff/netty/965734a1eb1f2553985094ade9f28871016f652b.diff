[+++ b/buffer/src/main/java/io/netty/buffer/ByteBufUtil.java, +import java.io.IOException;, +import java.io.OutputStream;, +    static final int WRITE_CHUNK_SIZE = 8192;, +    /**, +     * Read bytes from the given {@link ByteBuffer} into the given {@link OutputStream} using the {@code position} and, +     * {@code length}. The position and limit of the given {@link ByteBuffer} may be adjusted., +     */, +    static void readBytes(ByteBufAllocator allocator, ByteBuffer buffer, int position, int length, OutputStream out), +            throws IOException {, +        if (buffer.hasArray()) {, +            out.write(buffer.array(), position + buffer.arrayOffset(), length);, +        } else {, +            int chunkLen = Math.min(length, WRITE_CHUNK_SIZE);, +            buffer.clear().position(position);, +, +            if (allocator.isDirectBufferPooled()) {, +                // if direct buffers are pooled chances are good that heap buffers are pooled as well., +                ByteBuf tmpBuf = allocator.heapBuffer(chunkLen);, +                try {, +                    byte[] tmp = tmpBuf.array();, +                    int offset = tmpBuf.arrayOffset();, +                    getBytes(buffer, tmp, offset, chunkLen, out, length);, +                } finally {, +                    tmpBuf.release();, +                }, +            } else {, +                getBytes(buffer, new byte[chunkLen], 0, chunkLen, out, length);, +            }, +        }, +    }, +, +    private static void getBytes(ByteBuffer inBuffer, byte[] in, int inOffset, int inLen, OutputStream out, int outLen), +            throws IOException {, +        do {, +            int len = Math.min(inLen, outLen);, +            inBuffer.get(in, inOffset, len);, +            out.write(in, inOffset, len);, +            outLen -= len;, +        } while (outLen > 0);, +    }, +, +++ b/buffer/src/main/java/io/netty/buffer/ByteBufUtil.java, +import java.io.IOException;, +import java.io.OutputStream;, +    static final int WRITE_CHUNK_SIZE = 8192;, +    /**, +     * Read bytes from the given {@link ByteBuffer} into the given {@link OutputStream} using the {@code position} and, +     * {@code length}. The position and limit of the given {@link ByteBuffer} may be adjusted., +     */, +    static void readBytes(ByteBufAllocator allocator, ByteBuffer buffer, int position, int length, OutputStream out), +            throws IOException {, +        if (buffer.hasArray()) {, +            out.write(buffer.array(), position + buffer.arrayOffset(), length);, +        } else {, +            int chunkLen = Math.min(length, WRITE_CHUNK_SIZE);, +            buffer.clear().position(position);, +, +            if (allocator.isDirectBufferPooled()) {, +                // if direct buffers are pooled chances are good that heap buffers are pooled as well., +                ByteBuf tmpBuf = allocator.heapBuffer(chunkLen);, +                try {, +                    byte[] tmp = tmpBuf.array();, +                    int offset = tmpBuf.arrayOffset();, +                    getBytes(buffer, tmp, offset, chunkLen, out, length);, +                } finally {, +                    tmpBuf.release();, +                }, +            } else {, +                getBytes(buffer, new byte[chunkLen], 0, chunkLen, out, length);, +            }, +        }, +    }, +, +    private static void getBytes(ByteBuffer inBuffer, byte[] in, int inOffset, int inLen, OutputStream out, int outLen), +            throws IOException {, +        do {, +            int len = Math.min(inLen, outLen);, +            inBuffer.get(in, inOffset, len);, +            out.write(in, inOffset, len);, +            outLen -= len;, +        } while (outLen > 0);, +    }, +, +++ b/buffer/src/main/java/io/netty/buffer/PooledDirectByteBuf.java, +        ByteBufUtil.readBytes(alloc(), internal ? internalNioBuffer() : memory.duplicate(), idx(index), length, out);, +++ b/buffer/src/main/java/io/netty/buffer/ByteBufUtil.java, +import java.io.IOException;, +import java.io.OutputStream;, +    static final int WRITE_CHUNK_SIZE = 8192;, +    /**, +     * Read bytes from the given {@link ByteBuffer} into the given {@link OutputStream} using the {@code position} and, +     * {@code length}. The position and limit of the given {@link ByteBuffer} may be adjusted., +     */, +    static void readBytes(ByteBufAllocator allocator, ByteBuffer buffer, int position, int length, OutputStream out), +            throws IOException {, +        if (buffer.hasArray()) {, +            out.write(buffer.array(), position + buffer.arrayOffset(), length);, +        } else {, +            int chunkLen = Math.min(length, WRITE_CHUNK_SIZE);]