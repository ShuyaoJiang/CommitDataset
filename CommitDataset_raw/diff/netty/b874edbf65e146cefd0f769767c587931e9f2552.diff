[+++ b/resolver-dns/src/main/java/io/netty/resolver/dns/DefaultDnsCache.java, +                e.getValue().clearAndCancel();, +        return entries != null && entries.clearAndCancel();, +        scheduleCacheExpiration(e, ttl, loop);, +    private void scheduleCacheExpiration(final DefaultDnsCacheEntry e,, +                        // We always remove all entries for a hostname once one entry expire. This is not the, +                        // most efficient to do but this way we can guarantee that if a DnsResolver, +                        // be configured to prefer one ip family over the other we will not return unexpected, +                        // results to the enduser if one of the A or AAAA records has different TTL settings., +                        //, +                        // As a TTL is just a hint of the maximum time a cache is allowed to cache stuff it's, +                        // completely fine to remove the entry even if the TTL is not reached yet., +                        //, +                        // See https://github.com/netty/netty/issues/7329, +                        Entries entries = resolveCache.remove(e.hostname);, +                        if (entries != null) {, +                            entries.clearAndCancel();, +        boolean clearAndCancel() {, +++ b/resolver-dns/src/main/java/io/netty/resolver/dns/DefaultDnsCache.java, +                e.getValue().clearAndCancel();, +        return entries != null && entries.clearAndCancel();, +        scheduleCacheExpiration(e, ttl, loop);, +    private void scheduleCacheExpiration(final DefaultDnsCacheEntry e,, +                        // We always remove all entries for a hostname once one entry expire. This is not the, +                        // most efficient to do but this way we can guarantee that if a DnsResolver, +                        // be configured to prefer one ip family over the other we will not return unexpected, +                        // results to the enduser if one of the A or AAAA records has different TTL settings., +                        //, +                        // As a TTL is just a hint of the maximum time a cache is allowed to cache stuff it's, +                        // completely fine to remove the entry even if the TTL is not reached yet., +                        //, +                        // See https://github.com/netty/netty/issues/7329, +                        Entries entries = resolveCache.remove(e.hostname);, +                        if (entries != null) {, +                            entries.clearAndCancel();, +        boolean clearAndCancel() {, +++ b/resolver-dns/src/test/java/io/netty/resolver/dns/DefaultDnsCacheTest.java, +/*, + * Copyright 2018 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + *   http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the, + * License for the specific language governing permissions and limitations, + * under the License., + */, +package io.netty.resolver.dns;, +, +import io.netty.channel.DefaultEventLoopGroup;, +import io.netty.channel.EventLoop;, +import io.netty.channel.EventLoopGroup;, +import io.netty.util.NetUtil;, +import org.junit.Assert;, +import org.junit.Test;, +, +import java.util.concurrent.Callable;, +import java.util.concurrent.TimeUnit;, +, +public class DefaultDnsCacheTest {, +, +    @Test, +    public void testExpire() throws Throwable {, +        EventLoopGroup group = new DefaultEventLoopGroup(1);, +, +        try {, +            EventLoop loop = group.next();, +            final DefaultDnsCache cache = new DefaultDnsCache();, +            cache.cache("netty.io", null, NetUtil.LOCALHOST, 1, loop);, +            cache.cache("netty.io", null, NetUtil.LOCALHOST6, 10000, loop);, +, +            Throwable error = loop.schedule(new Callable<Throwable>() {, +                @Override, +                public Throwable call() throws Exception {, +                    try {, +                        Assert.assertNull(cache.get("netty.io", null));, +                        return null;, +                    } catch (Throwable cause) {, +                        return cause;, +                    }, +                }, +            }, 1, TimeUnit.SECONDS).get();, +            if (error != null) {, +                throw error;, +            }, +        } finally {, +            group.shutdownGracefully();, +        }, +    }, +}]