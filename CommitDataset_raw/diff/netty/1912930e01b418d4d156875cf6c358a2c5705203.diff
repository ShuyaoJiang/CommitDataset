[+++ b/src/main/java/org/jboss/netty/channel/socket/nio/NioSocketChannel.java, +import static org.jboss.netty.channel.Channels.*;, +, +    final AtomicBoolean writeTaskInTaskQueue = new AtomicBoolean();, +    final Queue<MessageEvent> writeBuffer = new WriteBuffer();, +    final AtomicInteger writeBufferSize = new AtomicInteger();, +    final AtomicInteger highWaterMarkCounter = new AtomicInteger();, +        int writeBufferSize = this.writeBufferSize.get();, +        if (writeBufferSize != 0) {, +            if (highWaterMarkCounter.get() > 0) {, +                int lowWaterMark = getConfig().getWriteBufferLowWaterMark();, +                if (writeBufferSize >= lowWaterMark) {, +            } else {, +                int highWaterMark = getConfig().getWriteBufferHighWaterMark();, +                if (writeBufferSize >= highWaterMark) {, +                    interestOps |= Channel.OP_WRITE;, +                } else {, +                    interestOps &= ~Channel.OP_WRITE;, +                }, +            }, +        } else {, +            interestOps &= ~Channel.OP_WRITE;, +        }, +, +, +        private final ThreadLocal<Boolean> notifying = new ThreadLocal<Boolean>() {, +            @Override, +            protected Boolean initialValue() {, +                return Boolean.FALSE;, +            }, +        };, +, +, +            int messageSize = ((ChannelBuffer) e.getMessage()).readableBytes();, +            int newWriteBufferSize = writeBufferSize.addAndGet(messageSize);, +            int highWaterMark = getConfig().getWriteBufferHighWaterMark();, +, +            if (newWriteBufferSize >= highWaterMark) {, +                if (newWriteBufferSize - messageSize < highWaterMark) {, +                    highWaterMarkCounter.incrementAndGet();, +                    if (!notifying.get()) {, +                        notifying.set(Boolean.TRUE);, +                        fireChannelInterestChanged(, +                                NioSocketChannel.this, getRawInterestOps() | OP_WRITE);, +                        notifying.set(Boolean.FALSE);, +                    }, +                }, +            }, +                int messageSize = ((ChannelBuffer) e.getMessage()).readableBytes();, +                int newWriteBufferSize = writeBufferSize.addAndGet(-messageSize);, +                int lowWaterMark = getConfig().getWriteBufferLowWaterMark();, +, +                if (newWriteBufferSize == 0 || newWriteBufferSize < lowWaterMark) {, +                    if (newWriteBufferSize + messageSize >= lowWaterMark) {, +                        highWaterMarkCounter.decrementAndGet();, +                        if (!notifying.get()) {, +                            notifying.set(Boolean.TRUE);, +                            fireChannelInterestChanged(, +                                    NioSocketChannel.this, getRawInterestOps() & ~OP_WRITE);, +                            notifying.set(Boolean.FALSE);, +                        }, +                    }, +++ b/src/main/java/org/jboss/netty/channel/socket/nio/NioSocketChannel.java, +import static org.jboss.netty.channel.Channels.*;, +, +    final AtomicBoolean writeTaskInTaskQueue = new AtomicBoolean();, +    final Queue<MessageEvent> writeBuffer = new WriteBuffer();, +    final AtomicInteger writeBufferSize = new AtomicInteger();, +    final AtomicInteger highWaterMarkCounter = new AtomicInteger();, +        int writeBufferSize = this.writeBufferSize.get();, +        if (writeBufferSize != 0) {, +            if (highWaterMarkCounter.get() > 0) {, +                int lowWaterMark = getConfig().getWriteBufferLowWaterMark();, +                if (writeBufferSize >= lowWaterMark) {, +            } else {, +                int highWaterMark = getConfig().getWriteBufferHighWaterMark();, +                if (writeBufferSize >= highWaterMark) {, +                    interestOps |= Channel.OP_WRITE;, +                } else {, +                    interestOps &= ~Channel.OP_WRITE;, +                }, +            }, +        } else {, +            interestOps &= ~Channel.OP_WRITE;, +        }, +, +, +        private final ThreadLocal<Boolean> notifying = new ThreadLocal<Boolean>() {, +            @Override, +            protected Boolean initialValue() {, +                return Boolean.FALSE;, +            }, +        };, +, +, +            int messageSize = ((ChannelBuffer) e.getMessage()).readableBytes();, +            int newWriteBufferSize = writeBufferSize.addAndGet(messageSize);, +            int highWaterMark = getConfig().getWriteBufferHighWaterMark();, +, +            if (newWriteBufferSize >= highWaterMark) {]