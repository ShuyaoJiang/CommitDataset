[+++ b/src/main/java/org/jboss/netty/handler/queue/BlockingReadHandler.java, +import org.jboss.netty.channel.ChannelStateEvent;, + * {@link #read()}, {@link #read(long, TimeUnit)}, {@link #readEvent()}, or, + * {@link #readEvent(long, TimeUnit)} method is called., + * Also, any handler placed after this handler will never receive, + * {@code messageReceived}, {@code exceptionCaught}, and {@code channelClosed}, + * events, hence it should be placed in the last place in a pipeline., +public class BlockingReadHandler<E> extends SimpleChannelUpstreamHandler {, +    private volatile boolean closed;, +        return closed;, +        ChannelEvent e = getQueue().take();, +        if (e instanceof ChannelStateEvent) {, +            // channelClosed has been triggered., +            assert closed;, +            return null;, +        } else {, +            return e;, +        }, +        } else if (e instanceof ChannelStateEvent) {, +            // channelClosed has been triggered., +            assert closed;, +            return null;, +                    "read*(...) in I/O thread causes a dead lock or " +, +                    "call read*() from a different thread.");, +    @Override, +    public void channelClosed(ChannelHandlerContext ctx, ChannelStateEvent e), +            throws Exception {, +        closed = true;, +        getQueue().put(e);, +    }]