[+++ b/buffer/src/main/java/io/netty/buffer/AdvancedLeakAwareByteBuf.java, +import java.nio.ByteOrder;, +    public boolean release() {, +        boolean deallocated =  super.release();, +        if (deallocated) {, +            leak.close();, +        } else {, +            leak.record();, +        }, +        return deallocated;, +    }, +, +    @Override, +    public boolean release(int decrement) {, +        boolean deallocated = super.release(decrement);, +        if (deallocated) {, +            leak.close();, +        } else {, +            leak.record();, +        }, +        return deallocated;, +    }, +, +    @Override, +    public ByteBuf order(ByteOrder endianness) {, +        leak.record();, +        if (order() == endianness) {, +            return this;, +        } else {, +            return new AdvancedLeakAwareByteBuf(super.order(endianness), leak);, +        }, +    }, +, +    @Override, +    public ByteBuf slice() {, +        leak.record();, +        return new AdvancedLeakAwareByteBuf(super.slice(), leak);, +    }, +, +    @Override, +    public ByteBuf slice(int index, int length) {, +        leak.record();, +        return new AdvancedLeakAwareByteBuf(super.slice(index, length), leak);, +    }, +, +    @Override, +    public ByteBuf duplicate() {, +        leak.record();, +        return new AdvancedLeakAwareByteBuf(super.duplicate(), leak);, +    }, +, +    @Override, +    public ByteBuf readSlice(int length) {, +        leak.record();, +        return new AdvancedLeakAwareByteBuf(super.readSlice(length), leak);, +    }, +, +    @Override, +    public ByteBuf capacity(int newCapacity) {, +        return super.capacity(newCapacity);, +++ b/buffer/src/main/java/io/netty/buffer/AdvancedLeakAwareByteBuf.java, +import java.nio.ByteOrder;, +    public boolean release() {, +        boolean deallocated =  super.release();, +        if (deallocated) {, +            leak.close();, +        } else {, +            leak.record();, +        }, +        return deallocated;, +    }, +, +    @Override, +    public boolean release(int decrement) {, +        boolean deallocated = super.release(decrement);, +        if (deallocated) {, +            leak.close();, +        } else {, +            leak.record();, +        }, +        return deallocated;, +    }, +, +    @Override, +    public ByteBuf order(ByteOrder endianness) {, +        leak.record();, +        if (order() == endianness) {, +            return this;, +        } else {, +            return new AdvancedLeakAwareByteBuf(super.order(endianness), leak);, +        }, +    }, +, +    @Override, +    public ByteBuf slice() {, +        leak.record();, +        return new AdvancedLeakAwareByteBuf(super.slice(), leak);, +    }, +, +    @Override]