[+++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslEngine.java, +    public SSLEngineResult wrap(, +        synchronized (this) {, +            // Check to make sure the engine has not been closed, +            if (isDestroyed()) {, +                return CLOSED_NOT_HANDSHAKING;, +            }, +, +                                // If there is no pending data to read from BIO we should go back to event loop and try, +                                // to read more data [1]. It is also possible that event loop will detect the socket, +                                // has been closed. [1] https://www.openssl.org/docs/manmaster/ssl/SSL_write.html, +                                        new SSLEngineResult(getEngineStatus(),, +                                                NEED_UNWRAP, bytesConsumed, bytesProduced);, +                                // SSL_ERROR_WANT_WRITE typically means that the underlying transport is not writable, +                                // and we should set the "want write" flag on the selector and try again when the, +                                // underlying transport is writable [1]. However we are not directly writing to the, +                                // underlying transport and instead writing to a BIO buffer. The OpenSsl documentation, +                                // says we should do the following [1]:, +                                // "When using a buffering BIO, like a BIO pair, data must be written into or retrieved, +                                // out of the BIO before being able to continue.", +                                // So we attempt to drain the BIO buffer below, but if there is no data this condition, +                                // is undefined and we assume their is a fatal error with the openssl engine and close., +            // We need to check if pendingWrittenBytesInBIO was checked yet, as we may not checked if the srcs was, +            // empty, or only contained empty buffers., +    }, +    public SSLEngineResult unwrap(, +        final int srcsEndOffset = srcsOffset + srcsLength;, +        long len = 0;, +        for (int i = srcsOffset; i < srcsEndOffset; i++) {, +            ByteBuffer src = srcs[i];, +            if (src == null) {, +                throw new IllegalArgumentException("srcs[" + i + "] is null");, +            }, +            len += src.remaining();, +        }, +, +        synchronized (this) {, +            // Check to make sure the engine has not been closed, +            if (isDestroyed()) {, +                return CLOSED_NOT_HANDSHAKING;, +            }, +, +            // protect against protocol overflow attack vector, +            if (len > MAX_ENCRYPTED_PACKET_LENGTH) {, +                isInboundDone = true;, +                isOutboundDone = true;, +                engineClosed = true;, +                shutdown();, +                throw ENCRYPTED_PACKET_OVERSIZED;, +            }, +, +                        // We ignore BIO_* errors here as we use in memory BIO anyway and will do another SSL_* call, +                        // later on in which we will produce an exception in case of an error, +                    // TODO: We may want to consider if we move this check and only do it in a less often called place, +                    // at the price of not being 100% accurate, like for example when calling SSL.getError(...)., +    }]