[+++ b/handler/src/main/java/io/netty/handler/ssl/SslHandler.java, +    private final ChannelFlushPromiseNotifier flushFutureNotifier = new ChannelFlushPromiseNotifier(true);, +            flushFutureNotifier.add(promise, in.readableBytes());, +                flushFutureNotifier.add(promise, in.readableBytes());, +++ b/handler/src/main/java/io/netty/handler/ssl/SslHandler.java, +    private final ChannelFlushPromiseNotifier flushFutureNotifier = new ChannelFlushPromiseNotifier(true);, +            flushFutureNotifier.add(promise, in.readableBytes());, +                flushFutureNotifier.add(promise, in.readableBytes());, +++ b/transport/src/main/java/io/netty/channel/AbstractChannel.java, +                flushFutureNotifier.add(promise, outboundBufSize());, +++ b/handler/src/main/java/io/netty/handler/ssl/SslHandler.java, +    private final ChannelFlushPromiseNotifier flushFutureNotifier = new ChannelFlushPromiseNotifier(true);, +            flushFutureNotifier.add(promise, in.readableBytes());, +                flushFutureNotifier.add(promise, in.readableBytes());, +++ b/transport/src/main/java/io/netty/channel/AbstractChannel.java, +                flushFutureNotifier.add(promise, outboundBufSize());, +++ b/transport/src/main/java/io/netty/channel/ChannelFlushPromiseNotifier.java, +    private final boolean tryNotify;, +, +    /**, +     * Create a new instance, +     *, +     * @param tryNotify if {@code true} the {@link ChannelPromise}s will get notified with, +     *                  {@link ChannelPromise#trySuccess()} and {@link ChannelPromise#tryFailure(Throwable)}., +     *                  Otherwise {@link ChannelPromise#setSuccess()} and {@link ChannelPromise#setFailure(Throwable)}, +     *                  is used, +     */, +    public ChannelFlushPromiseNotifier(boolean tryNotify) {, +        this.tryNotify = tryNotify;, +    }, +, +    /**, +     * Create a new instance which will use {@link ChannelPromise#setSuccess()} and, +     * {@link ChannelPromise#setFailure(Throwable)} to notify the {@link ChannelPromise}s., +     */, +    public ChannelFlushPromiseNotifier() {, +        this(false);, +    }, +    public ChannelFlushPromiseNotifier add(ChannelPromise promise, int pendingDataSize) {, +        if (promise == null) {, +            throw new NullPointerException("promise");, +        if (promise instanceof FlushCheckpoint) {, +            FlushCheckpoint cp = (FlushCheckpoint) promise;, +            flushCheckpoints.add(new DefaultFlushCheckpoint(checkpoint, promise));, +     * Notify all {@link ChannelFuture}s that were registered with {@link #add(ChannelPromise, int)} and, +     * Notify all {@link ChannelFuture}s that were registered with {@link #add(ChannelPromise, int)} and, +            if (tryNotify) {, +                cp.future().tryFailure(cause);, +            } else {, +        }, +     * Notify all {@link ChannelFuture}s that were registered with {@link #add(ChannelPromise, int)} and, +            if (tryNotify) {, +                cp.future().tryFailure(cause2);, +            } else {, +        }, +                if (tryNotify) {, +                    cp.future().trySuccess();, +                } else {, +                }, +            } else {, +                if (tryNotify) {, +                    cp.future().tryFailure(cause);, +        }]