[+++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, +        return ByteBufUtil.decodeString(nioBuffer, charset);, +        return ByteBufUtil.indexOf(this, fromIndex, toIndex, value);, +        return ByteBufUtil.indexOf(this, fromIndex, toIndex, indexFinder);, +        return ByteBufUtil.hashCode(this);, +            return ByteBufUtil.equals(this, (ByteBuf) o);, +        return ByteBufUtil.compare(this, that);, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, +        return ByteBufUtil.decodeString(nioBuffer, charset);, +        return ByteBufUtil.indexOf(this, fromIndex, toIndex, value);, +        return ByteBufUtil.indexOf(this, fromIndex, toIndex, indexFinder);, +        return ByteBufUtil.hashCode(this);, +            return ByteBufUtil.equals(this, (ByteBuf) o);, +        return ByteBufUtil.compare(this, that);, +++ b/buffer/src/main/java/io/netty/buffer/ByteBufUtil.java, +/*, + * Copyright 2012 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + *   http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the, + * License for the specific language governing permissions and limitations, + * under the License., + */, +package io.netty.buffer;, +, +import io.netty.util.CharsetUtil;, +, +import java.nio.ByteBuffer;, +import java.nio.ByteOrder;, +import java.nio.CharBuffer;, +import java.nio.charset.CharacterCodingException;, +import java.nio.charset.Charset;, +import java.nio.charset.CharsetDecoder;, +import java.nio.charset.CharsetEncoder;, +import java.nio.charset.CoderResult;, +, +public final class ByteBufUtil {, +, +    private static final char[] HEXDUMP_TABLE = new char[256 * 4];, +, +    static {, +        final char[] DIGITS = "0123456789abcdef".toCharArray();, +        for (int i = 0; i < 256; i ++) {, +            HEXDUMP_TABLE[(i << 1) + 0] = DIGITS[i >>> 4 & 0x0F];, +            HEXDUMP_TABLE[(i << 1) + 1] = DIGITS[i >>> 0 & 0x0F];, +        }, +    }, +, +    /**, +     * Returns a <a href="http://en.wikipedia.org/wiki/Hex_dump">hex dump</a>, +     * of the specified buffer's readable bytes., +     */, +    public static String hexDump(ByteBuf buffer) {, +        return hexDump(buffer, buffer.readerIndex(), buffer.readableBytes());, +    }, +, +    /**, +     * Returns a <a href="http://en.wikipedia.org/wiki/Hex_dump">hex dump</a>, +     * of the specified buffer's sub-region., +     */, +    public static String hexDump(ByteBuf buffer, int fromIndex, int length) {, +        if (length < 0) {, +            throw new IllegalArgumentException("length: " + length);, +        }, +        if (length == 0) {, +            return "";, +        }, +, +        int endIndex = fromIndex + length;, +        char[] buf = new char[length << 1];, +, +        int srcIdx = fromIndex;, +        int dstIdx = 0;, +        for (; srcIdx < endIndex; srcIdx ++, dstIdx += 2) {, +            System.arraycopy(, +                    HEXDUMP_TABLE, buffer.getUnsignedByte(srcIdx) << 1,, +                    buf, dstIdx, 2);, +        }, +, +        return new String(buf);, +    }, +, +    /**, +     * Calculates the hash code of the specified buffer.  This method is, +     * useful when implementing a new buffer type., +     */, +    public static int hashCode(ByteBuf buffer) {, +        final int aLen = buffer.readableBytes();, +        final int intCount = aLen >>> 2;, +        final int byteCount = aLen & 3;, +, +        int hashCode = 1;, +        int arrayIndex = buffer.readerIndex();]