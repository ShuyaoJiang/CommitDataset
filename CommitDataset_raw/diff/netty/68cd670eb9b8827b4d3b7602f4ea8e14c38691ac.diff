[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2MultiplexCodec.java, +    private volatile Runnable flushTask;, +    // Override this to signal it will never throw an exception., +    @Override, +    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {, +        ctx.fireExceptionCaught(cause);, +    }, +, +    // Override this to signal it will never throw an exception., +    @Override, +    public void flush(ChannelHandlerContext ctx) {, +        ctx.flush();, +    }, +, +    void flushFromStreamChannel() {, +        EventExecutor executor = ctx.executor();, +        if (executor.inEventLoop()) {, +            flush(ctx);, +        } else {, +            Runnable task = flushTask;, +            if (task == null) {, +                task = flushTask = new Runnable() {, +                    @Override, +                    public void run() {, +                        flush(ctx);, +                    }, +                };, +            }, +            executor.execute(task);, +        }, +    }, +, +    void writeFromStreamChannel(final Object msg, final boolean flush) {, +        final ChannelPromise promise = ctx.newPromise();, +        EventExecutor executor = ctx.executor();, +        if (executor.inEventLoop()) {, +            writeFromStreamChannel0(msg, flush, promise);, +        } else {, +            try {, +                executor.execute(new OneTimeTask() {, +                    @Override, +                    public void run() {, +                        writeFromStreamChannel0(msg, flush, promise);, +                    }, +                });, +            } catch (Throwable cause) {, +                promise.setFailure(cause);, +            }, +        }, +    }, +, +    private void writeFromStreamChannel0(Object msg, boolean flush, ChannelPromise promise) {, +        try {, +            write(ctx, msg, promise);, +        } catch (Throwable cause) {, +            promise.tryFailure(cause);, +        }, +        if (flush) {, +            flush(ctx);, +        }, +    }, +, +    public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) {, +            ctx.write(msg, promise);, +            final StreamInfo streamInfo = stream.getProperty(streamInfoKey);, +            } catch (final Throwable t) {, +                EventExecutor executor = ctx.executor();, +                if (executor.inEventLoop()) {, +                    exceptionCaught(ctx, t);, +                } else {, +                    executor.execute(new OneTimeTask() {, +                        @Override, +                        public void run() {, +                            exceptionCaught(ctx, t);, +                        }, +                    });, +                }, +                StreamInfo streamInfo = stream.getProperty(streamInfoKey);, +            StreamInfo streamInfo = stream.getProperty(streamInfoKey);, +            StreamInfo streamInfo = stream.getProperty(streamInfoKey);, +            StreamInfo streamInfo = stream.getProperty(streamInfoKey);, +         * {@code true} if stream is in {@link Http2MultiplexCodec#streamsToFireChildReadComplete}., +                writeFromStreamChannel(resetFrame, true);, +, +            writeFromStreamChannel(msg, false);, +            flushFromStreamChannel();, +                exceptionCaught(ctx, t);, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2MultiplexCodec.java, +    private volatile Runnable flushTask;, +    // Override this to signal it will never throw an exception., +    @Override, +    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {, +        ctx.fireExceptionCaught(cause);, +    }, +, +    // Override this to signal it will never throw an exception., +    @Override, +    public void flush(ChannelHandlerContext ctx) {, +        ctx.flush();, +    }]