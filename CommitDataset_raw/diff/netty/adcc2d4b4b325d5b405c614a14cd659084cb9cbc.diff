[+++ b/codec/src/main/java/io/netty/handler/codec/ByteToMessageCodec.java, +        if (isSharable()) {, +++ b/codec/src/main/java/io/netty/handler/codec/ByteToMessageCodec.java, +        if (isSharable()) {, +++ b/codec/src/main/java/io/netty/handler/codec/ByteToMessageDecoder.java, +        if (isSharable()) {, +++ b/codec/src/main/java/io/netty/handler/codec/ByteToMessageCodec.java, +        if (isSharable()) {, +++ b/codec/src/main/java/io/netty/handler/codec/ByteToMessageDecoder.java, +        if (isSharable()) {, +++ b/transport/src/main/java/io/netty/channel/ChannelHandlerAdapter.java, +import java.util.Map;, +import java.util.WeakHashMap;, +, +    /**, +     * Cache the result of {@link Sharable} annotation detection to workaround a condition. We use a, +     * {@link ThreadLocal} and {@link WeakHashMap} to eliminate the volatile write/reads. Using different, +     * {@link WeakHashMap} instances per {@link Thread} is good enough for us and the number of, +     * {@link Thread}s are quite limited anyway., +     *, +     * See <a href="See https://github.com/netty/netty/issues/2289">#2289</a>., +     */, +    private static final ThreadLocal<Map<Class<?>, Boolean>> SHARABLE_CACHE =, +            new ThreadLocal<Map<Class<?>, Boolean>>() {, +                @Override, +                protected Map<Class<?>, Boolean> initialValue() {, +                    // Start with small capacity to keep memory overhead as low as possible., +                    return new WeakHashMap<Class<?>, Boolean>(4);, +                }, +            };, +, +        Class<?> clazz = getClass();, +        Map<Class<?>, Boolean> cache = SHARABLE_CACHE.get();, +        Boolean sharable = cache.get(clazz);, +        if (sharable == null) {, +            sharable = clazz.isAnnotationPresent(Sharable.class);, +            cache.put(clazz, sharable);, +        }, +        return sharable;]