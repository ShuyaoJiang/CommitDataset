[+++ b/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverContext.java, +        while (!cnames.isEmpty()) { // Do not attempt to call Map.remove() when the Map is empty, +                                    // because it can be Collections.emptyMap(), +                                    // whose remove() throws a UnsupportedOperationException., +            final String next = cnames.remove(resolved);, +++ b/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverContext.java, +        while (!cnames.isEmpty()) { // Do not attempt to call Map.remove() when the Map is empty, +                                    // because it can be Collections.emptyMap(), +                                    // whose remove() throws a UnsupportedOperationException., +            final String next = cnames.remove(resolved);, +++ b/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java, +    private static DnsNameResolverBuilder newResolver() {, +    private static DnsNameResolverBuilder newResolver(InternetProtocolFamily... resolvedAddressTypes) {, +    private static Map<String, InetAddress> testResolve0(DnsNameResolver resolver, Set<String> excludedDomains), +    private static UnknownHostException resolveNonExistentDomain(DnsNameResolver resolver) {, +    private static void resolve(DnsNameResolver resolver, Map<String, Future<InetAddress>> futures, String hostname) {, +                            // In case of RecordType.AAAA we need to encode the RecordType by ourselves., +                return ipPart() + "." + ipPart() + '.' + ipPart() + '.' + ipPart();, +            private static int ipPart() {, +                        int priority = 0;, +                            rm.put(DnsAttribute.MX_PREFERENCE, String.valueOf(++priority));]