[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2MultiplexCodec.java, +import io.netty.channel.RecvByteBufAllocator.Handle;, +        public void operationComplete(ChannelFuture future) {, +            curr.next = curr.previous = null;, +            ((Http2MultiplexCodecStream) streamFrame.stream()).channel.fireChildRead(streamFrame);, +    private boolean isChildChannelInReadPendingQueue(DefaultHttp2StreamChannel childChannel) {, +        return childChannel.previous != null || childChannel.next != null || head == childChannel;, +    }, +, +    final void tryAddChildChannelToReadPendingQueue(DefaultHttp2StreamChannel childChannel) {, +        if (!isChildChannelInReadPendingQueue(childChannel)) {, +            childChannel.previous = tail;, +, +    private void tryRemoveChildChannelFromReadPendingQueue(DefaultHttp2StreamChannel childChannel) {, +        if (isChildChannelInReadPendingQueue(childChannel)) {, +            removeChildChannelFromReadPendingQueue(childChannel);, +        }, +    }, +, +    private void removeChildChannelFromReadPendingQueue(DefaultHttp2StreamChannel childChannel) {, +        DefaultHttp2StreamChannel previous = childChannel.previous;, +        if (childChannel.next != null) {, +            childChannel.next.previous = previous;, +        } else {, +            tail = tail.previous; // If there is no next, this childChannel is the tail, so move the tail back., +        }, +        if (previous != null) {, +            previous.next = childChannel.next;, +        } else {, +            head = head.next; // If there is no previous, this childChannel is the head, so move the tail forward., +        }, +        childChannel.next = childChannel.previous = null;, +        try {, +        } finally {, +            parentReadInProgress = false;, +            tail = head = null;, +            // We always flush as this is what Http2ConnectionHandler does for now., +            flush0(ctx);, +        }, +            childChannel.next = childChannel.previous = null;, +            childChannel.fireChildReadComplete();, +        /**, +         * This variable represents if a read is in progress for the current channel. Note that depending upon the, +         * {@link RecvByteBufAllocator} behavior a read may extend beyond the {@link Http2ChannelUnsafe#beginRead()}, +         * method scope. The {@link Http2ChannelUnsafe#beginRead()} loop may drain all pending data, and then if the, +         * parent channel is reading this channel may still accept frames., +         */, +        // Currently the child channel and parent channel are always on the same EventLoop thread. This allows us to, +        // extend the read loop of a child channel if the child channel drains its queued data during read, and the, +        // parent channel is still in its read loop. The next/previous links build a doubly linked list that the parent, +        // channel will iterate in its channelReadComplete to end the read cycle for each child channel in the list., +        DefaultHttp2StreamChannel previous;, +            unsafe.readEOS();, +            // Attempt to drain any queued data from the queue and deliver it to the application before closing this, +            // channel., +            unsafe.doBeginRead();, +        void fireChildRead(Http2Frame frame) {, +            } else if (readInProgress) {, +                // If readInProgress there cannot be anything in the queue, otherwise we would have drained it from the, +                // queue and processed it during the read cycle., +                assert inboundBuffer == null || inboundBuffer.isEmpty();, +                final Handle allocHandle = unsafe.recvBufAllocHandle();, +                // We currently don't need to check for readEOS because the parent channel and child channel are limited, +                // to the same EventLoop thread. There are a limited number of frame types that may come after EOS is, +                // read (unknown, reset) and the trade off is less conditionals for the hot path (headers/data) at the, +                // cost of additional readComplete notifications on the rare path., +                if (allocHandle.continueReading()) {, +                    tryAddChildChannelToReadPendingQueue(this);, +                } else {, +                    tryRemoveChildChannelFromReadPendingQueue(this);, +                    unsafe.notifyReadComplete(allocHandle);, +                }, +            assert readInProgress;, +            unsafe.notifyReadComplete(unsafe.recvBufAllocHandle());, +            private Handle recvHandle;, +            private boolean readEOS;, +            public Handle recvBufAllocHandle() {, +                    recvHandle = config().getRecvByteBufAllocator().newHandle();, +                    recvHandle.reset(config());, +                            public void operationComplete(ChannelFuture future) {, +                tryRemoveChildChannelFromReadPendingQueue(DefaultHttp2StreamChannel.this);, +                if (parent().isActive() && !readEOS && connection().streamMayHaveExisted(stream().id())) {, +                doBeginRead();, +            }, +            void doBeginRead() {, +                Object message;, +                if (inboundBuffer == null || (message = inboundBuffer.poll()) == null) {, +                    if (readEOS) {, +                } else {, +                    final Handle allocHandle = recvBufAllocHandle();, +                    allocHandle.reset(config());, +                    boolean continueReading = false;, +                        doRead0((Http2Frame) message, allocHandle);, +                    } while ((readEOS || (continueReading = allocHandle.continueReading())) &&, +                             (message = inboundBuffer.poll()) != null);, +                    if (continueReading && parentReadInProgress && !readEOS) {, +                        // Currently the parent and child channel are on the same EventLoop thread. If the parent is, +                        // currently reading it is possile that more frames will be delivered to this child channel. In, +                        // the case that this child channel still wants to read we delay the channelReadComplete on this, +                        // child channel until the parent is done reading.]