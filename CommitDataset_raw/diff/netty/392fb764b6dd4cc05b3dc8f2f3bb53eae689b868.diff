[+++ b/handler/src/main/java/io/netty/handler/ssl/SslHandler.java, +                        logger.warn("{} flush() raised a masked exception.", ctx.channel(), e);, +            setHandshakeFailure(ctx, e);, +            setHandshakeFailure(ctx, e);, +        setHandshakeFailure(ctx, CHANNEL_CLOSED);, +                        "{} Swallowing a harmless 'connection reset by peer / broken pipe' error that occurred " +, +                        "while writing close_notify in response to the peer's close_notify", ctx.channel(), cause);, +, +            // If SSLEngine expects a heap buffer for unwrapping, do the conversion., +            if (in.isDirect() && wantsInboundHeapBuffer) {, +                ByteBuf copy = ctx.alloc().heapBuffer(totalLength);, +                try {, +                    copy.writeBytes(in, startOffset, totalLength);, +                    unwrap(ctx, copy, 0, totalLength);, +                } finally {, +                    copy.release();, +                }, +            } else {, +        }, +            setHandshakeFailure(ctx, e);, +    private void unwrap(, +            ChannelHandlerContext ctx, ByteBuf packet, int offset, int length) throws SSLException {, +        ByteBuf decodeOut = allocate(ctx, length);, +                final SSLEngineResult result = unwrap(engine, packet, offset, length, decodeOut);, +                offset += consumed;, +                length -= consumed;, +                        throw new IllegalStateException("unknown handshake status: " + handshakeStatus);, +            setHandshakeFailure(ctx, e);, +            logger.debug("{} HANDSHAKEN: {}", ctx.channel(), engine.getSession().getCipherSuite());, +    private void setHandshakeFailure(ChannelHandlerContext ctx, Throwable cause) {, +                logger.debug("{} SSLEngine.closeInbound() raised an exception.", ctx.channel(), e);, +                    logger.warn("{} Last write attempt timed out; force-closing the connection.", ctx.channel());]