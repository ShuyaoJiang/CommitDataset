[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2ConnectionEncoder.java, +import io.netty.buffer.CompositeByteBuf;, +import io.netty.buffer.SlicedByteBuf;, +        flowController().addFlowControlled(ctx, stream,, +            flowController().addFlowControlled(ctx, stream,, +        private FlowControlledData(ChannelHandlerContext ctx, Http2Stream stream, ByteBuf buf, int padding,, +            this.data = buf;, +                    if (size == bytesWritten && !promise.isVoid()) {, +                    if (toWrite instanceof SlicedByteBuf && data instanceof CompositeByteBuf) {, +                        // If we're writing a subset of a composite buffer then we want to release, +                        // any underlying buffers that have been consumed. CompositeByteBuf only releases, +                        // underlying buffers on write if all of its data has been consumed and its refCnt becomes, +                        // 0., +                        final CompositeByteBuf toFree = (CompositeByteBuf) data;, +                        writePromise.addListener(new ChannelFutureListener() {, +                            @Override, +                            public void operationComplete(ChannelFuture future) throws Exception {, +                                toFree.discardReadComponents();, +                            }, +                        });, +                    }, +, +        @Override, +        public boolean merge(Http2RemoteFlowController.FlowControlled next) {, +            if (FlowControlledData.class != next.getClass()) {, +                return false;, +            }, +            final FlowControlledData nextData = (FlowControlledData) next;, +            // Given that we're merging data into a frame it doesn't really make sense to accumulate padding., +            padding = Math.max(nextData.padding, padding);, +            endOfStream = nextData.endOfStream;, +            final CompositeByteBuf compositeByteBuf;, +            if (data instanceof CompositeByteBuf) {, +                compositeByteBuf = (CompositeByteBuf) data;, +            } else {, +                compositeByteBuf = ctx.alloc().compositeBuffer(Integer.MAX_VALUE);, +                compositeByteBuf.addComponent(data);, +                compositeByteBuf.writerIndex(data.readableBytes());, +                data = compositeByteBuf;, +            }, +            compositeByteBuf.addComponent(nextData.data);, +            compositeByteBuf.writerIndex(compositeByteBuf.writerIndex() + nextData.data.readableBytes());, +            size = data.readableBytes() + padding;, +            if (!nextData.promise.isVoid()) {, +                // Replace current promise if void otherwise chain them., +                if (promise.isVoid()) {, +                    promise = nextData.promise;, +                } else {, +                    promise.addListener(new ChannelFutureListener() {, +                        @Override, +                        public void operationComplete(ChannelFuture future) throws Exception {, +                            if (future.isSuccess()) {, +                                nextData.promise.trySuccess();, +                            } else {, +                                nextData.promise.tryFailure(future.cause());, +                            }, +                        }, +                    });, +                }, +            }, +            return true;, +        }, +            if (promise.isVoid()) {, +                promise = ctx.newPromise();, +                promise.addListener(this);, +            }, +, +        @Override, +        public boolean merge(Http2RemoteFlowController.FlowControlled next) {, +            return false;, +        }, +        protected ChannelPromise promise;, +        protected boolean endOfStream;, +            if (!promise.isVoid()) {, +        }, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2ConnectionEncoder.java, +import io.netty.buffer.CompositeByteBuf;, +import io.netty.buffer.SlicedByteBuf;, +        flowController().addFlowControlled(ctx, stream,, +            flowController().addFlowControlled(ctx, stream,, +        private FlowControlledData(ChannelHandlerContext ctx, Http2Stream stream, ByteBuf buf, int padding,, +            this.data = buf;, +                    if (size == bytesWritten && !promise.isVoid()) {, +                    if (toWrite instanceof SlicedByteBuf && data instanceof CompositeByteBuf) {, +                        // If we're writing a subset of a composite buffer then we want to release, +                        // any underlying buffers that have been consumed. CompositeByteBuf only releases, +                        // underlying buffers on write if all of its data has been consumed and its refCnt becomes, +                        // 0., +                        final CompositeByteBuf toFree = (CompositeByteBuf) data;, +                        writePromise.addListener(new ChannelFutureListener() {, +                            @Override, +                            public void operationComplete(ChannelFuture future) throws Exception {, +                                toFree.discardReadComponents();, +                            }, +                        });, +                    }, +, +        @Override, +        public boolean merge(Http2RemoteFlowController.FlowControlled next) {, +            if (FlowControlledData.class != next.getClass()) {]