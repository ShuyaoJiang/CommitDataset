[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectDecoder.java, +import io.netty.handler.codec.ByteToMessageDecoder;, +public abstract class HttpObjectDecoder extends ByteToMessageDecoder {, +    private LastHttpContent trailer;, +, +    private enum State {, +    private State currentState = State.SKIP_CONTROL_CHARS;, +, +        switch (currentState) {, +            if (!skipControlCharacters(buffer)) {, +                return;, +            currentState = State.READ_INITIAL;, +            AppendableCharSequence line = lineParser.parse(buffer);, +            if (line == null) {, +                return;, +            }, +            String[] initialLine = splitInitialLine(line);, +                currentState = State.SKIP_CONTROL_CHARS;, +            currentState = State.READ_HEADER;, +            if (nextState == null) {, +                return;, +            }, +            currentState = nextState;, +            int toRead = Math.min(buffer.readableBytes(), maxChunkSize);, +            int readLimit = buffer.readableBytes();, +            if (line == null) {, +                return;, +            }, +                currentState = State.READ_CHUNK_FOOTER;, +            currentState = State.READ_CHUNKED_CONTENT;, +            toRead = Math.min(toRead, buffer.readableBytes());, +            currentState = State.READ_CHUNK_DELIMITER;, +            final int wIdx = buffer.writerIndex();, +            int rIdx = buffer.readerIndex();, +            while (wIdx > rIdx) {, +                byte next = buffer.getByte(rIdx++);, +                if (next == HttpConstants.LF) {, +                    currentState = State.READ_CHUNK_SIZE;, +                    break;, +                }, +            }, +            buffer.readerIndex(rIdx);, +            if (trailer == null) {, +                return;, +            }, +            buffer.skipBytes(buffer.readableBytes());, +            int readableBytes = buffer.readableBytes();, +                out.add(buffer.readBytes(readableBytes));, +            if (currentState == State.READ_VARIABLE_LENGTH_CONTENT && !in.isReadable() && !chunked) {, +        trailer = null;, +                currentState = State.UPGRADED;, +        currentState = State.SKIP_CONTROL_CHARS;, +        currentState = State.BAD_MESSAGE;, +        currentState = State.BAD_MESSAGE;, +        trailer = null;, +    private static boolean skipControlCharacters(ByteBuf buffer) {, +        boolean skiped = false;, +        final int wIdx = buffer.writerIndex();, +        int rIdx = buffer.readerIndex();, +        while (wIdx > rIdx) {, +            int c = buffer.getUnsignedByte(rIdx++);, +            if (!Character.isISOControl(c) && !Character.isWhitespace(c)) {, +                rIdx--;, +                skiped = true;, +        buffer.readerIndex(rIdx);, +        return skiped;, +        if (line == null) {, +            return null;, +        }, +                if (line == null) {, +                    return null;, +                }, +        if (line == null) {, +            return null;, +        }, +            LastHttpContent trailer = this.trailer;, +            if (trailer == null) {, +                trailer = this.trailer = new DefaultLastHttpContent(Unpooled.EMPTY_BUFFER, validateHeaders);, +            }, +                if (line == null) {, +                    return null;, +                }, +            this.trailer = null;, +    private static class HeaderParser implements ByteBufProcessor {, +            if (i == -1) {, +                return null;, +            }, +    private static final class LineParser extends HeaderParser {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectDecoder.java, +import io.netty.handler.codec.ByteToMessageDecoder;, +public abstract class HttpObjectDecoder extends ByteToMessageDecoder {, +    private LastHttpContent trailer;, +, +    private enum State {, +    private State currentState = State.SKIP_CONTROL_CHARS;, +, +        switch (currentState) {, +            if (!skipControlCharacters(buffer)) {, +                return;, +            currentState = State.READ_INITIAL;]