[+++ b/testsuite/src/test/java/io/netty/testsuite/transport/socket/SocketBufReleaseTest.java, +import io.netty.buffer.MessageBuf;, +import io.netty.util.concurrent.DefaultEventExecutorGroup;, +import io.netty.util.concurrent.DefaultPromise;, +import io.netty.util.concurrent.DefaultThreadFactory;, +import io.netty.util.concurrent.EventExecutor;, +import io.netty.util.concurrent.Promise;, +import static org.junit.Assert.*;, +    private static final EventExecutor executor =, +            new DefaultEventExecutorGroup(1, new DefaultThreadFactory(SocketBufReleaseTest.class, true)).next();, +, +        // Ensure the server socket accepted the client connection *and* initialized pipeline successfully., +        serverHandler.channelFuture.sync();, +, +        // and then close all sockets., +, +        private final Promise<Channel> channelFuture = new DefaultPromise<Channel>(executor);, +, +        @Override, +        public void handlerAdded(ChannelHandlerContext ctx) throws Exception {, +            channelFuture.setSuccess(ctx.channel());, +        }, +, +        @Override, +        public MessageBuf<Object> newInboundBuffer(ChannelHandlerContext ctx) throws Exception {, +            return super.newInboundBuffer(ctx);, +        }, +, +        @Override, +        public void freeInboundBuffer(ChannelHandlerContext ctx) throws Exception {, +            super.freeInboundBuffer(ctx);, +        }, +, +++ b/testsuite/src/test/java/io/netty/testsuite/transport/socket/SocketBufReleaseTest.java, +import io.netty.buffer.MessageBuf;, +import io.netty.util.concurrent.DefaultEventExecutorGroup;, +import io.netty.util.concurrent.DefaultPromise;, +import io.netty.util.concurrent.DefaultThreadFactory;, +import io.netty.util.concurrent.EventExecutor;, +import io.netty.util.concurrent.Promise;, +import static org.junit.Assert.*;, +    private static final EventExecutor executor =, +            new DefaultEventExecutorGroup(1, new DefaultThreadFactory(SocketBufReleaseTest.class, true)).next();, +, +        // Ensure the server socket accepted the client connection *and* initialized pipeline successfully., +        serverHandler.channelFuture.sync();, +, +        // and then close all sockets., +, +        private final Promise<Channel> channelFuture = new DefaultPromise<Channel>(executor);, +, +        @Override, +        public void handlerAdded(ChannelHandlerContext ctx) throws Exception {, +            channelFuture.setSuccess(ctx.channel());, +        }, +, +        @Override, +        public MessageBuf<Object> newInboundBuffer(ChannelHandlerContext ctx) throws Exception {, +            return super.newInboundBuffer(ctx);, +        }, +, +        @Override, +        public void freeInboundBuffer(ChannelHandlerContext ctx) throws Exception {, +            super.freeInboundBuffer(ctx);, +        }, +, +++ b/transport/src/main/java/io/netty/channel/socket/aio/AioServerSocketChannel.java, +import io.netty.buffer.MessageBuf;, +import io.netty.channel.ChannelPipeline;, +, +            ChannelPipeline pipeline = channel.pipeline();, +            MessageBuf<Object> buffer = pipeline.inboundMessageBuffer();, +, +            if (buffer.refCnt() == 0) {, +                try {, +                    ch.close();, +                } catch (IOException e) {, +                    logger.warn(, +                            "Failed to close a socket which was accepted while its server socket is being closed",, +                            e);, +                }, +                return;, +            }, +, +            buffer.add(new AioSocketChannel(channel, null, ch));, +            pipeline.fireInboundBufferUpdated();, +            pipeline.fireChannelReadSuspended();]