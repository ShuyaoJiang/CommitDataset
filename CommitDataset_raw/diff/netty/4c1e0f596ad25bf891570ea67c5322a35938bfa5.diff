[+++ b/codec/src/main/java/io/netty/handler/codec/CodecOutputList.java, +import io.netty.util.concurrent.FastThreadLocal;, +import io.netty.util.internal.MathUtil;, +    private static final CodecOutputListRecycler NOOP_RECYCLER = new CodecOutputListRecycler() {, +        public void recycle(CodecOutputList object) {, +            // drop on the floor and let the GC handle it., +    private static final FastThreadLocal<CodecOutputLists> CODEC_OUTPUT_LISTS_POOL =, +            new FastThreadLocal<CodecOutputLists>() {, +                @Override, +                protected CodecOutputLists initialValue() throws Exception {, +                    // 16 CodecOutputList per Thread are cached., +                    return new CodecOutputLists(16);, +                }, +            };, +, +    private interface CodecOutputListRecycler {, +        void recycle(CodecOutputList codecOutputList);, +    private static final class CodecOutputLists implements CodecOutputListRecycler {, +        private final CodecOutputList[] elements;, +        private final int mask;, +, +        private int currentIdx;, +        private int count;, +, +        CodecOutputLists(int numElements) {, +            elements = new CodecOutputList[MathUtil.safeFindNextPositivePowerOfTwo(numElements)];, +            for (int i = 0; i < elements.length; ++i) {, +                // Size of 16 should be good enough for the majority of all users as an initial capacity., +                elements[i] = new CodecOutputList(this, 16);, +            }, +            count = elements.length;, +            currentIdx = elements.length;, +            mask = elements.length - 1;, +        }, +, +        public CodecOutputList getOrCreate() {, +            if (count == 0) {, +                // Return a new CodecOutputList which will not be cached. We use a size of 4 to keep the overhead, +                // low., +                return new CodecOutputList(NOOP_RECYCLER, 4);, +            }, +            --count;, +, +            int idx = (currentIdx - 1) & mask;, +            CodecOutputList list = elements[idx];, +            currentIdx = idx;, +            return list;, +        }, +, +        @Override, +        public void recycle(CodecOutputList codecOutputList) {, +            int idx = currentIdx;, +            elements[idx] = codecOutputList;, +            currentIdx = (idx + 1) & mask;, +            ++count;, +            assert count <= elements.length;, +        }, +    }, +, +    static CodecOutputList newInstance() {, +        return CODEC_OUTPUT_LISTS_POOL.get().getOrCreate();, +    }, +, +    private final CodecOutputListRecycler recycler;, +    private Object[] array;, +    private CodecOutputList(CodecOutputListRecycler recycler, int size) {, +        this.recycler = recycler;, +        array = new Object[size];, +        size = 0;, +, +        recycler.recycle(this);, +++ b/codec/src/main/java/io/netty/handler/codec/CodecOutputList.java, +import io.netty.util.concurrent.FastThreadLocal;, +import io.netty.util.internal.MathUtil;, +    private static final CodecOutputListRecycler NOOP_RECYCLER = new CodecOutputListRecycler() {, +        public void recycle(CodecOutputList object) {, +            // drop on the floor and let the GC handle it., +    private static final FastThreadLocal<CodecOutputLists> CODEC_OUTPUT_LISTS_POOL =, +            new FastThreadLocal<CodecOutputLists>() {, +                @Override, +                protected CodecOutputLists initialValue() throws Exception {, +                    // 16 CodecOutputList per Thread are cached., +                    return new CodecOutputLists(16);, +                }, +            };, +, +    private interface CodecOutputListRecycler {, +        void recycle(CodecOutputList codecOutputList);, +    private static final class CodecOutputLists implements CodecOutputListRecycler {, +        private final CodecOutputList[] elements;, +        private final int mask;, +, +        private int currentIdx;, +        private int count;, +, +        CodecOutputLists(int numElements) {, +            elements = new CodecOutputList[MathUtil.safeFindNextPositivePowerOfTwo(numElements)];, +            for (int i = 0; i < elements.length; ++i) {, +                // Size of 16 should be good enough for the majority of all users as an initial capacity., +                elements[i] = new CodecOutputList(this, 16);]