[+++ b/codec/src/main/java/io/netty/handler/codec/json/JsonObjectDecoder.java, +/*, + * Copyright 2014 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + *   http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the, + * License for the specific language governing permissions and limitations, + * under the License., + */, +, +package io.netty.handler.codec.json;, +, +import io.netty.buffer.ByteBuf;, +import io.netty.buffer.ByteBufUtil;, +import io.netty.channel.ChannelHandlerContext;, +import io.netty.handler.codec.ByteToMessageDecoder;, +import io.netty.channel.ChannelHandler;, +import io.netty.handler.codec.CorruptedFrameException;, +import io.netty.handler.codec.TooLongFrameException;, +import io.netty.channel.ChannelPipeline;, +, +import java.util.List;, +, +/**, + * Splits a byte stream of JSON objects and arrays into individual objects/arrays and passes them up the, + * {@link ChannelPipeline}., + *, + * This class does not do any real parsing or validation. A sequence of bytes is considered a JSON object/array, + * if it contains a matching number of opening and closing braces/brackets. It's up to a subsequent, + * {@link ChannelHandler} to parse the JSON text into a more usable form i.e. a POJO., + */, +public class JsonObjectDecoder extends ByteToMessageDecoder {, +, +    private int openBraces;, +    private int idx;, +, +    private boolean isDecoding;, +    private boolean isArrayStreamDecoding;, +    private boolean insideString;, +, +    private final int maxObjectLength;, +    private final boolean streamArrayElements;, +, +    public JsonObjectDecoder() {, +        // 1 MB, +        this(1024 * 1024);, +    }, +, +    public JsonObjectDecoder(int maxObjectLength) {, +        this(maxObjectLength, false);, +    }, +, +    public JsonObjectDecoder(boolean streamArrayElements) {, +        this(1024 * 1024, streamArrayElements);, +    }, +, +    /**, +     * @param maxObjectLength   maximum number of bytes a JSON object/array may use (including braces and all)., +     *                             Objects exceeding this length are dropped and an {@link TooLongFrameException}, +     *                             is thrown., +     * @param streamArrayElements   if set to true and the "top level" JSON object is an array, each of its entries, +     *                                  is passed through the pipeline individually and immediately after it was fully, +     *                                  received, allowing for arrays with "infinitely" many elements., +     *, +     */, +    public JsonObjectDecoder(int maxObjectLength, boolean streamArrayElements) {, +        if (maxObjectLength < 1) {, +            throw new IllegalArgumentException("maxObjectLength must be a positive int");, +        }, +        this.maxObjectLength = maxObjectLength;, +        this.streamArrayElements = streamArrayElements;, +    }, +, +    @Override, +    protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) throws Exception {, +        // index of next byte to process., +        int idx = this.idx;, +        int wrtIdx = in.writerIndex();, +, +        if (wrtIdx > maxObjectLength) {, +            // buffer size exceeded maxObjectLength; discarding the complete buffer., +            ctx.fireExceptionCaught(, +                    new TooLongFrameException(, +                            "object length exceeds " + maxObjectLength + ": " + wrtIdx + " bytes discarded"), +            );, +, +            in.skipBytes(in.readableBytes());, +            reset();, +            return;, +        }, +, +        for (/* use current idx */; idx < wrtIdx; idx++) {, +            byte c = in.getByte(idx);]