[+++ b/transport-rxtx/src/main/java/io/netty/channel/rxtx/DefaultRxtxChannelConfig.java, +    private volatile int waitTime;, +        return getOptions(super.getOptions(), BAUD_RATE, DTR, RTS, STOP_BITS, DATA_BITS, PARITY_BIT, WAIT_TIME);, +        if (option == WAIT_TIME) {, +            return (T) Integer.valueOf(getWaitTimeMillis());, +        }, +        } else if (option == WAIT_TIME) {, +            setWaitTimeMillis((Integer) value);, +    public int getWaitTimeMillis() {, +        return waitTime;, +    }, +, +    @Override, +    public RxtxChannelConfig setWaitTimeMillis(final int waitTimeMillis) {, +        if (waitTimeMillis < 0) {, +            throw new IllegalArgumentException("Wait time must be >= 0");, +        }, +        waitTime = waitTimeMillis;, +        return this;, +    }, +, +    @Override, +++ b/transport-rxtx/src/main/java/io/netty/channel/rxtx/DefaultRxtxChannelConfig.java, +    private volatile int waitTime;, +        return getOptions(super.getOptions(), BAUD_RATE, DTR, RTS, STOP_BITS, DATA_BITS, PARITY_BIT, WAIT_TIME);, +        if (option == WAIT_TIME) {, +            return (T) Integer.valueOf(getWaitTimeMillis());, +        }, +        } else if (option == WAIT_TIME) {, +            setWaitTimeMillis((Integer) value);, +    public int getWaitTimeMillis() {, +        return waitTime;, +    }, +, +    @Override, +    public RxtxChannelConfig setWaitTimeMillis(final int waitTimeMillis) {, +        if (waitTimeMillis < 0) {, +            throw new IllegalArgumentException("Wait time must be >= 0");, +        }, +        waitTime = waitTimeMillis;, +        return this;, +    }, +, +    @Override, +++ b/transport-rxtx/src/main/java/io/netty/channel/rxtx/RxtxChannel.java, +import static io.netty.channel.rxtx.RxtxChannelOption.*;, +, +import io.netty.channel.ChannelPromise;, +import java.util.concurrent.TimeUnit;, +import gnu.io.CommPort;, +import gnu.io.CommPortIdentifier;, +import gnu.io.SerialPort;, +    protected AbstractUnsafe newUnsafe() {, +        return new RxtxUnsafe();, +    }, +, +    @Override, +    }, +, +    protected void doInit() throws Exception {, +, +    private final class RxtxUnsafe extends AbstractUnsafe {, +        @Override, +        public void connect(, +                final SocketAddress remoteAddress,, +                final SocketAddress localAddress, final ChannelPromise promise) {, +            if (eventLoop().inEventLoop()) {, +                if (!ensureOpen(promise)) {, +                    return;, +                }, +, +                try {, +                    final boolean wasActive = isActive();, +                    doConnect(remoteAddress, localAddress);, +, +                    int waitTime = config().getOption(WAIT_TIME);, +                    if (waitTime > 0) {, +                        eventLoop().schedule(new Runnable() {, +                            @Override, +                            public void run() {, +                                try {, +                                    doInit();, +                                    promise.setSuccess();, +                                    if (!wasActive && isActive()) {, +                                        pipeline().fireChannelActive();, +                                    }, +                                } catch (Throwable t) {, +                                    promise.setFailure(t);, +                                    closeIfClosed();, +                                }, +                            }, +                       }, waitTime, TimeUnit.MILLISECONDS);, +                    } else {, +                        doInit();, +                        promise.setSuccess();, +                        if (!wasActive && isActive()) {, +                            pipeline().fireChannelActive();, +                        }, +                    }, +                } catch (Throwable t) {]