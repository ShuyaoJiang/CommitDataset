[+++ b/resolver-dns/src/main/java/io/netty/resolver/dns/DefaultDnsCache.java, +import io.netty.util.internal.StringUtil;, +        Entries entries = resolveCache.remove(appendDot(hostname));, +        Entries entries = resolveCache.get(appendDot(hostname));, +        cache0(appendDot(hostname), e,, +                Math.max(minTtl, Math.min(MAX_SUPPORTED_TTL_SECS, (int) Math.min(maxTtl, originalTtl))), loop);, +        cache0(appendDot(hostname), e, Math.min(MAX_SUPPORTED_TTL_SECS, negativeTtl), loop);, +    private void cache0(String hostname, DefaultDnsCacheEntry e, int ttl, EventLoop loop) {, +        Entries entries = resolveCache.get(hostname);, +            Entries oldEntries = resolveCache.putIfAbsent(hostname, entries);, +        scheduleCacheExpiration(hostname, e, ttl, loop);, +    private void scheduleCacheExpiration(final String hostname, final DefaultDnsCacheEntry e,, +                        Entries entries = resolveCache.remove(hostname);, +, +    private static String appendDot(String hostname) {, +        return StringUtil.endsWith(hostname, '.') ? hostname : hostname + '.';, +    }, +++ b/resolver-dns/src/main/java/io/netty/resolver/dns/DefaultDnsCache.java, +import io.netty.util.internal.StringUtil;, +        Entries entries = resolveCache.remove(appendDot(hostname));, +        Entries entries = resolveCache.get(appendDot(hostname));, +        cache0(appendDot(hostname), e,, +                Math.max(minTtl, Math.min(MAX_SUPPORTED_TTL_SECS, (int) Math.min(maxTtl, originalTtl))), loop);, +        cache0(appendDot(hostname), e, Math.min(MAX_SUPPORTED_TTL_SECS, negativeTtl), loop);, +    private void cache0(String hostname, DefaultDnsCacheEntry e, int ttl, EventLoop loop) {, +        Entries entries = resolveCache.get(hostname);, +            Entries oldEntries = resolveCache.putIfAbsent(hostname, entries);, +        scheduleCacheExpiration(hostname, e, ttl, loop);, +    private void scheduleCacheExpiration(final String hostname, final DefaultDnsCacheEntry e,, +                        Entries entries = resolveCache.remove(hostname);, +, +    private static String appendDot(String hostname) {, +        return StringUtil.endsWith(hostname, '.') ? hostname : hostname + '.';, +    }, +++ b/resolver-dns/src/main/java/io/netty/resolver/dns/DnsAddressResolveContext.java, +import io.netty.util.concurrent.Promise;, +, +    @Override, +    void doSearchDomainQuery(String hostname, Promise<List<InetAddress>> nextPromise) {, +        // Query the cache for the hostname first and only do a query if we could not find it in the cache., +        if (!parent.doResolveAllCached(hostname, additionals, nextPromise, resolveCache)) {, +            super.doSearchDomainQuery(hostname, nextPromise);, +        }, +    }, +++ b/resolver-dns/src/main/java/io/netty/resolver/dns/DefaultDnsCache.java, +import io.netty.util.internal.StringUtil;, +        Entries entries = resolveCache.remove(appendDot(hostname));, +        Entries entries = resolveCache.get(appendDot(hostname));, +        cache0(appendDot(hostname), e,, +                Math.max(minTtl, Math.min(MAX_SUPPORTED_TTL_SECS, (int) Math.min(maxTtl, originalTtl))), loop);, +        cache0(appendDot(hostname), e, Math.min(MAX_SUPPORTED_TTL_SECS, negativeTtl), loop);, +    private void cache0(String hostname, DefaultDnsCacheEntry e, int ttl, EventLoop loop) {, +        Entries entries = resolveCache.get(hostname);, +            Entries oldEntries = resolveCache.putIfAbsent(hostname, entries);, +        scheduleCacheExpiration(hostname, e, ttl, loop);, +    private void scheduleCacheExpiration(final String hostname, final DefaultDnsCacheEntry e,, +                        Entries entries = resolveCache.remove(hostname);, +, +    private static String appendDot(String hostname) {, +        return StringUtil.endsWith(hostname, '.') ? hostname : hostname + '.';, +    }, +++ b/resolver-dns/src/main/java/io/netty/resolver/dns/DnsAddressResolveContext.java, +import io.netty.util.concurrent.Promise;, +, +    @Override, +    void doSearchDomainQuery(String hostname, Promise<List<InetAddress>> nextPromise) {, +        // Query the cache for the hostname first and only do a query if we could not find it in the cache., +        if (!parent.doResolveAllCached(hostname, additionals, nextPromise, resolveCache)) {, +            super.doSearchDomainQuery(hostname, nextPromise);, +        }, +    }, +++ b/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java, +    boolean doResolveAllCached(String hostname,, +++ b/resolver-dns/src/main/java/io/netty/resolver/dns/DefaultDnsCache.java, +import io.netty.util.internal.StringUtil;, +        Entries entries = resolveCache.remove(appendDot(hostname));, +        Entries entries = resolveCache.get(appendDot(hostname));, +        cache0(appendDot(hostname), e,, +                Math.max(minTtl, Math.min(MAX_SUPPORTED_TTL_SECS, (int) Math.min(maxTtl, originalTtl))), loop);, +        cache0(appendDot(hostname), e, Math.min(MAX_SUPPORTED_TTL_SECS, negativeTtl), loop);, +    private void cache0(String hostname, DefaultDnsCacheEntry e, int ttl, EventLoop loop) {, +        Entries entries = resolveCache.get(hostname);, +            Entries oldEntries = resolveCache.putIfAbsent(hostname, entries);, +        scheduleCacheExpiration(hostname, e, ttl, loop);, +    private void scheduleCacheExpiration(final String hostname, final DefaultDnsCacheEntry e,, +                        Entries entries = resolveCache.remove(hostname);, +, +    private static String appendDot(String hostname) {, +        return StringUtil.endsWith(hostname, '.') ? hostname : hostname + '.';, +    }, +++ b/resolver-dns/src/main/java/io/netty/resolver/dns/DnsAddressResolveContext.java, +import io.netty.util.concurrent.Promise;, +, +    @Override, +    void doSearchDomainQuery(String hostname, Promise<List<InetAddress>> nextPromise) {, +        // Query the cache for the hostname first and only do a query if we could not find it in the cache., +        if (!parent.doResolveAllCached(hostname, additionals, nextPromise, resolveCache)) {, +            super.doSearchDomainQuery(hostname, nextPromise);, +        }, +    }]