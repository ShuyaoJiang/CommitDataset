[+++ b/transport/src/main/java/io/netty/channel/PendingWriteQueue.java, +        // It is possible for writes to be triggered from removeAndFailAll(). To preserve ordering,, +        // we should add them to the queue and let removeAndFailAll() fail them later., +        // It is possible for some of the failed promises to trigger more writes. The new writes, +        // will "revive" the queue, so we need to clean them up until the queue is empty., +        for (PendingWrite write = head; write != null; write = head) {, +        }, +++ b/transport/src/main/java/io/netty/channel/PendingWriteQueue.java, +        // It is possible for writes to be triggered from removeAndFailAll(). To preserve ordering,, +        // we should add them to the queue and let removeAndFailAll() fail them later., +        // It is possible for some of the failed promises to trigger more writes. The new writes, +        // will "revive" the queue, so we need to clean them up until the queue is empty., +        for (PendingWrite write = head; write != null; write = head) {, +        }, +++ b/transport/src/test/java/io/netty/channel/PendingWriteQueueTest.java, +import java.util.ArrayList;, +import java.util.Collections;, +import java.util.List;, +    public void testRemoveAndFailAllReentrantFailAll() {, +        assertTrue(promise.isDone());, +        assertTrue(promise2.isDone());, +    public void testRemoveAndFailAllReentrantWrite() {, +        final List<Integer> failOrder = Collections.synchronizedList(new ArrayList<Integer>());, +        EmbeddedChannel channel = new EmbeddedChannel();, +        final PendingWriteQueue queue = new PendingWriteQueue(channel.pipeline().firstContext());, +, +        ChannelPromise promise = channel.newPromise();, +        final ChannelPromise promise3 = channel.newPromise();, +        promise3.addListener(new ChannelFutureListener() {, +            @Override, +            public void operationComplete(ChannelFuture future) throws Exception {, +                failOrder.add(3);, +            }, +        });, +        promise.addListener(new ChannelFutureListener() {, +            @Override, +            public void operationComplete(ChannelFuture future) throws Exception {, +                failOrder.add(1);, +                queue.add(3L, promise3);, +            }, +        });, +        queue.add(1L, promise);, +, +        ChannelPromise promise2 = channel.newPromise();, +        promise2.addListener(new ChannelFutureListener() {, +            @Override, +            public void operationComplete(ChannelFuture future) throws Exception {, +                failOrder.add(2);, +            }, +        });, +        queue.add(2L, promise2);, +        queue.removeAndFailAll(new Exception());, +        assertTrue(promise.isDone());, +        assertFalse(promise.isSuccess());, +        assertTrue(promise2.isDone());, +        assertFalse(promise2.isSuccess());, +        assertTrue(promise3.isDone());, +        assertFalse(promise3.isSuccess());, +        assertFalse(channel.finish());, +        assertEquals(1, (int) failOrder.get(0));, +        assertEquals(2, (int) failOrder.get(1));, +        assertEquals(3, (int) failOrder.get(2));, +    }, +, +    @Test]