[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2Connection.java, +     *, +     * Visible only for testing!, +    static final int INITIAL_CHILDREN_MAP_SIZE =, +        private IntObjectMap<DefaultStream> removeAllChildrenExcept(DefaultStream streamToRetain) {, +        final void takeChild(Iterator<PrimitiveEntry<DefaultStream>> childItr, DefaultStream child, boolean exclusive,, +                             List<ParentChangedEvent> events) {, +                // If the childItr is not null we are iterating over the oldParent.children collection and should, +                // use the iterator to remove from the collection to avoid concurrent modification. Otherwise it is, +                // assumed we are not iterating over this collection and it is safe to call remove directly., +                if (childItr != null) {, +                    childItr.remove();, +                } else if (oldParent != null) {, +                Iterator<PrimitiveEntry<DefaultStream>> itr = removeAllChildrenExcept(child).entries().iterator();, +                while (itr.hasNext()) {, +                    child.takeChild(itr, itr.next().value(), false, events);, +        final void takeChild(DefaultStream child, boolean exclusive, List<ParentChangedEvent> events) {, +            takeChild(null, child, exclusive, events);, +        }, +, +                Iterator<PrimitiveEntry<DefaultStream>> itr = child.children.entries().iterator();, +                while (itr.hasNext()) {, +                    takeChild(itr, itr.next().value(), false, events);, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2Connection.java, +     *, +     * Visible only for testing!, +    static final int INITIAL_CHILDREN_MAP_SIZE =, +        private IntObjectMap<DefaultStream> removeAllChildrenExcept(DefaultStream streamToRetain) {, +        final void takeChild(Iterator<PrimitiveEntry<DefaultStream>> childItr, DefaultStream child, boolean exclusive,, +                             List<ParentChangedEvent> events) {, +                // If the childItr is not null we are iterating over the oldParent.children collection and should, +                // use the iterator to remove from the collection to avoid concurrent modification. Otherwise it is, +                // assumed we are not iterating over this collection and it is safe to call remove directly., +                if (childItr != null) {, +                    childItr.remove();, +                } else if (oldParent != null) {, +                Iterator<PrimitiveEntry<DefaultStream>> itr = removeAllChildrenExcept(child).entries().iterator();, +                while (itr.hasNext()) {, +                    child.takeChild(itr, itr.next().value(), false, events);, +        final void takeChild(DefaultStream child, boolean exclusive, List<ParentChangedEvent> events) {, +            takeChild(null, child, exclusive, events);, +        }, +, +                Iterator<PrimitiveEntry<DefaultStream>> itr = child.children.entries().iterator();, +                while (itr.hasNext()) {, +                    takeChild(itr, itr.next().value(), false, events);, +++ b/codec-http2/src/test/java/io/netty/handler/codec/http2/DefaultHttp2ConnectionTest.java, +import static io.netty.handler.codec.http2.DefaultHttp2Connection.INITIAL_CHILDREN_MAP_SIZE;, +    public void closingStreamWithChildrenDoesNotCauseConcurrentModification() throws Http2Exception {, +        // We create enough streams to wrap around the child array. We carefully craft the stream ids so that they hash, +        // codes overlap with respect to the child collection. If the implementation is not careful this may lead to a, +        // concurrent modification excpetion while promoting all children to the connection stream., +        final Http2Stream streamA = client.local().createStream(1, false);, +        final int numStreams = INITIAL_CHILDREN_MAP_SIZE - 1;, +        for (int i = 0, streamId = 3; i < numStreams; ++i, streamId += INITIAL_CHILDREN_MAP_SIZE) {, +            final Http2Stream stream = client.local().createStream(streamId, false);, +            stream.setPriority(streamA.id(), Http2CodecUtil.DEFAULT_PRIORITY_WEIGHT, false);, +        }, +        assertEquals(INITIAL_CHILDREN_MAP_SIZE, client.numActiveStreams());, +        streamA.close();, +        assertEquals(numStreams, client.numActiveStreams());, +    }, +, +    @Test, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2Connection.java, +     *, +     * Visible only for testing!, +    static final int INITIAL_CHILDREN_MAP_SIZE =, +        private IntObjectMap<DefaultStream> removeAllChildrenExcept(DefaultStream streamToRetain) {, +        final void takeChild(Iterator<PrimitiveEntry<DefaultStream>> childItr, DefaultStream child, boolean exclusive,, +                             List<ParentChangedEvent> events) {, +                // If the childItr is not null we are iterating over the oldParent.children collection and should, +                // use the iterator to remove from the collection to avoid concurrent modification. Otherwise it is, +                // assumed we are not iterating over this collection and it is safe to call remove directly., +                if (childItr != null) {, +                    childItr.remove();, +                } else if (oldParent != null) {, +                Iterator<PrimitiveEntry<DefaultStream>> itr = removeAllChildrenExcept(child).entries().iterator();, +                while (itr.hasNext()) {, +                    child.takeChild(itr, itr.next().value(), false, events);, +        final void takeChild(DefaultStream child, boolean exclusive, List<ParentChangedEvent> events) {, +            takeChild(null, child, exclusive, events);, +        }, +, +                Iterator<PrimitiveEntry<DefaultStream>> itr = child.children.entries().iterator();, +                while (itr.hasNext()) {, +                    takeChild(itr, itr.next().value(), false, events);, +++ b/codec-http2/src/test/java/io/netty/handler/codec/http2/DefaultHttp2ConnectionTest.java, +import static io.netty.handler.codec.http2.DefaultHttp2Connection.INITIAL_CHILDREN_MAP_SIZE;, +    public void closingStreamWithChildrenDoesNotCauseConcurrentModification() throws Http2Exception {, +        // We create enough streams to wrap around the child array. We carefully craft the stream ids so that they hash, +        // codes overlap with respect to the child collection. If the implementation is not careful this may lead to a, +        // concurrent modification excpetion while promoting all children to the connection stream., +        final Http2Stream streamA = client.local().createStream(1, false);, +        final int numStreams = INITIAL_CHILDREN_MAP_SIZE - 1;, +        for (int i = 0, streamId = 3; i < numStreams; ++i, streamId += INITIAL_CHILDREN_MAP_SIZE) {, +            final Http2Stream stream = client.local().createStream(streamId, false);, +            stream.setPriority(streamA.id(), Http2CodecUtil.DEFAULT_PRIORITY_WEIGHT, false);, +        }, +        assertEquals(INITIAL_CHILDREN_MAP_SIZE, client.numActiveStreams());]