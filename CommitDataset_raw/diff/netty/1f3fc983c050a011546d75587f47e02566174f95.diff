[+++ b/common/src/main/java/io/netty/util/concurrent/DefaultPromise.java, +import io.netty.util.internal.OneTimeTask;, +import static java.util.concurrent.TimeUnit.MILLISECONDS;, +            execute(executor, new OneTimeTask() {, +            execute(executor, new OneTimeTask() {, +            // Execute immediately if late listeners is empty. This allows subsequent late listeners, +            // that are added after completion to be notified immediately and preserver order., +            if (listeners == null && (lateListeners == null || lateListeners.isEmpty())) {, +        execute(eventExecutor, new OneTimeTask() {, +                execute(executor, new OneTimeTask() {, +                execute(executor, new OneTimeTask() {, +++ b/common/src/main/java/io/netty/util/concurrent/DefaultPromise.java, +import io.netty.util.internal.OneTimeTask;, +import static java.util.concurrent.TimeUnit.MILLISECONDS;, +            execute(executor, new OneTimeTask() {, +            execute(executor, new OneTimeTask() {, +            // Execute immediately if late listeners is empty. This allows subsequent late listeners, +            // that are added after completion to be notified immediately and preserver order., +            if (listeners == null && (lateListeners == null || lateListeners.isEmpty())) {, +        execute(eventExecutor, new OneTimeTask() {, +                execute(executor, new OneTimeTask() {, +                execute(executor, new OneTimeTask() {, +++ b/common/src/test/java/io/netty/util/concurrent/DefaultPromiseTest.java, +import java.util.concurrent.atomic.AtomicInteger;, +import static org.hamcrest.CoreMatchers.is;, +import static org.junit.Assert.assertEquals;, +import static org.junit.Assert.assertSame;, +import static org.junit.Assert.assertThat;, +import static org.junit.Assert.assertTrue;, +        try {, +                        future.addListener(listener4);, +                assertSame("Fail 1 during run " + i + " / " + runs, listener1, listeners.take());, +                assertSame("Fail 2 during run " + i + " / " + runs, listener2, listeners.take());, +                assertSame("Fail 3 during run " + i + " / " + runs, listener3, listeners.take());, +                assertSame("Fail 4 during run " + i + " / " + runs, listener4, listeners.take());, +        } finally {, +            executor.shutdownGracefully(0, 0, TimeUnit.SECONDS).sync();, +        }, +        testPromiseListenerAddWhenComplete(fakeException());, +    @Test(timeout = 2000), +    public void testLateListenerIsOrderedCorrectlySuccess() throws InterruptedException {, +        final EventExecutor executor = new TestEventExecutor();, +        try {, +            testLateListenerIsOrderedCorrectly(null);, +        } finally {, +            executor.shutdownGracefully(0, 0, TimeUnit.SECONDS).sync();, +        }, +    }, +, +    @Test(timeout = 2000), +    public void testLateListenerIsOrderedCorrectlyFailure() throws InterruptedException {, +        final EventExecutor executor = new TestEventExecutor();, +        try {, +            testLateListenerIsOrderedCorrectly(fakeException());, +        } finally {, +            executor.shutdownGracefully(0, 0, TimeUnit.SECONDS).sync();, +        }, +    }, +, +    /**, +     * This test is mean to simulate the following sequence of events, which all take place on the I/O thread:, +     * <ol>, +     * <li>A write is done</li>, +     * <li>The write operation completes, and the promise state is changed to done</li>, +     * <li>A listener is added to the return from the write. The {@link FutureListener#operationComplete()} updates, +     * state which must be invoked before the response to the previous write is read.</li>, +     * <li>The write operation</li>, +     * </ol>, +     */, +    private static void testLateListenerIsOrderedCorrectly(Throwable cause) throws InterruptedException {, +        final EventExecutor executor = new TestEventExecutor();, +        try {, +            final AtomicInteger state = new AtomicInteger();, +            final CountDownLatch latch1 = new CountDownLatch(1);, +            final CountDownLatch latch2 = new CountDownLatch(2);, +            final Promise<Void> promise = new DefaultPromise<Void>(executor);, +, +            // Add a listener before completion so "lateListener" is used next time we add a listener., +            promise.addListener(new FutureListener<Void>() {, +                @Override, +                public void operationComplete(Future<Void> future) throws Exception {, +                    assertTrue(state.compareAndSet(0, 1));, +                }, +            });, +, +            // Simulate write operation completing, which will execute listeners in another thread., +            if (cause == null) {, +                promise.setSuccess(null);, +            } else {, +                promise.setFailure(cause);, +            }, +, +            // Add a "late listener", +            promise.addListener(new FutureListener<Void>() {, +                @Override, +                public void operationComplete(Future<Void> future) throws Exception {, +                    assertTrue(state.compareAndSet(1, 2));, +                    latch1.countDown();, +                }, +            });]