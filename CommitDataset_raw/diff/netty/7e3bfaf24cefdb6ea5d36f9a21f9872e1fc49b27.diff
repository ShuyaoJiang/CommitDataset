[+++ b/handler/src/main/java/io/netty/handler/ssl/SslHandler.java, +    private final ChannelFlushFutureNotifier flushFutureNotifier = new ChannelFlushFutureNotifier() {, +        @Override, +        public synchronized void increaseWriteCounter(long delta) {, +            super.increaseWriteCounter(delta);, +        }, +, +        @Override, +        public synchronized void notifyFlushFutures() {, +            super.notifyFlushFutures();, +        }, +, +        @Override, +        public synchronized void notifyFlushFutures(Throwable cause) {, +            super.notifyFlushFutures(cause);, +        }, +    };, +        int bytesProduced = 0;, +                bytesProduced += result.bytesProduced();, +            flushFutureNotifier.increaseWriteCounter(bytesProduced);, +            ctx.flush(ctx.newFuture().addListener(flushFutureNotifier));, +                throw e;, +            if (cause == null) {, +                cause = new ClosedChannelException();, +            }, +, +        // Force-close the connection if close_notify is not fully sent in time., +        final ScheduledFuture<?> timeoutFuture = ctx.executor().schedule(new Runnable() {, +            @Override, +            public void run() {, +                logger.warn(ctx.channel() + "close_notify write attempt timed out. Force-closing the connection.");, +                ctx.close(future);, +            }, +        }, 3, TimeUnit.SECONDS); // FIXME: Magic value, +, +        // Close the connection if close_notify is sent in time., +        closeNotifyFuture.addListener(new ChannelFutureListener() {, +            @Override, +            public void operationComplete(ChannelFuture f), +                    throws Exception {, +                if (timeoutFuture.cancel(false)) {, +                    ctx.close(future);, +                }, +            }, +        });, +, +, +, +++ b/handler/src/main/java/io/netty/handler/ssl/SslHandler.java, +    private final ChannelFlushFutureNotifier flushFutureNotifier = new ChannelFlushFutureNotifier() {, +        @Override, +        public synchronized void increaseWriteCounter(long delta) {, +            super.increaseWriteCounter(delta);, +        }, +, +        @Override, +        public synchronized void notifyFlushFutures() {, +            super.notifyFlushFutures();, +        }, +, +        @Override, +        public synchronized void notifyFlushFutures(Throwable cause) {, +            super.notifyFlushFutures(cause);, +        }, +    };, +        int bytesProduced = 0;, +                bytesProduced += result.bytesProduced();, +            flushFutureNotifier.increaseWriteCounter(bytesProduced);, +            ctx.flush(ctx.newFuture().addListener(flushFutureNotifier));, +                throw e;, +            if (cause == null) {, +                cause = new ClosedChannelException();, +            }, +, +        // Force-close the connection if close_notify is not fully sent in time., +        final ScheduledFuture<?> timeoutFuture = ctx.executor().schedule(new Runnable() {, +            @Override, +            public void run() {, +                logger.warn(ctx.channel() + "close_notify write attempt timed out. Force-closing the connection.");, +                ctx.close(future);, +            }, +        }, 3, TimeUnit.SECONDS); // FIXME: Magic value, +, +        // Close the connection if close_notify is sent in time., +        closeNotifyFuture.addListener(new ChannelFutureListener() {, +            @Override, +            public void operationComplete(ChannelFuture f), +                    throws Exception {, +                if (timeoutFuture.cancel(false)) {, +                    ctx.close(future);, +                }, +            }, +        });, +, +, +, +++ b/transport/src/main/java/io/netty/channel/AbstractChannel.java, +import java.util.Random;, +    private static final Random random = new Random();, +]