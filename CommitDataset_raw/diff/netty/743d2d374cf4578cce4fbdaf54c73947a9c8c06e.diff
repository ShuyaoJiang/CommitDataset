[+++ b/microbench/src/main/java/io/netty/microbench/channel/EmbeddedChannelHandlerContext.java, +/*, + * Copyright 2017 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License, version 2.0 (the, + * "License"); you may not use this file except in compliance with the License. You may obtain a, + * copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software distributed under the License, + * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express, + * or implied. See the License for the specific language governing permissions and limitations under, + * the License., + */, +package io.netty.microbench.channel;, +, +import io.netty.buffer.ByteBufAllocator;, +import io.netty.channel.Channel;, +import io.netty.channel.ChannelFuture;, +import io.netty.channel.ChannelHandler;, +import io.netty.channel.ChannelHandlerContext;, +import io.netty.channel.ChannelPipeline;, +import io.netty.channel.ChannelProgressivePromise;, +import io.netty.channel.ChannelPromise;, +import io.netty.channel.EventLoop;, +import io.netty.channel.embedded.EmbeddedChannel;, +import io.netty.util.Attribute;, +import io.netty.util.AttributeKey;, +import io.netty.util.ReferenceCountUtil;, +import io.netty.util.concurrent.EventExecutor;, +, +import java.net.SocketAddress;, +, +import static io.netty.util.internal.ObjectUtil.checkNotNull;, +, +public abstract class EmbeddedChannelHandlerContext implements ChannelHandlerContext {, +    private static final String HANDLER_NAME = "microbench-delegator-ctx";, +    private final EventLoop eventLoop;, +    private final Channel channel;, +    private final ByteBufAllocator alloc;, +    private final ChannelHandler handler;, +    private SocketAddress localAddress;, +, +    protected EmbeddedChannelHandlerContext(ByteBufAllocator alloc, ChannelHandler handler, EmbeddedChannel channel) {, +        this.alloc = checkNotNull(alloc, "alloc");, +        this.channel = checkNotNull(channel, "channel");, +        this.handler = checkNotNull(handler, "handler");, +        eventLoop = checkNotNull(channel.eventLoop(), "eventLoop");, +    }, +, +    protected abstract void handleException(Throwable t);, +, +    @Override, +    public final <T> Attribute<T> attr(AttributeKey<T> key) {, +        return null;, +    }, +, +    @Override, +    public final <T> boolean hasAttr(AttributeKey<T> key) {, +        return false;, +    }, +, +    @Override, +    public final Channel channel() {, +        return channel;, +    }, +, +    @Override, +    public final EventExecutor executor() {, +        return eventLoop;, +    }, +, +    @Override, +    public final String name() {, +        return HANDLER_NAME;, +    }, +, +    @Override, +    public final ChannelHandler handler() {, +        return handler;, +    }, +, +    @Override, +    public final boolean isRemoved() {, +        return false;, +    }, +, +    @Override, +    public final ChannelHandlerContext fireChannelRegistered() {, +        return this;, +    }, +, +    @Override, +    public final ChannelHandlerContext fireChannelUnregistered() {, +        return this;, +    }, +, +    @Override, +    public final ChannelHandlerContext fireChannelActive() {]