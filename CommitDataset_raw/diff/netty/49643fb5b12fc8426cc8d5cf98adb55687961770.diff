[+++ b/transport-native-epoll/src/main/c/io_netty_channel_epoll_Native.c, +JNIEXPORT jint JNICALL Java_io_netty_channel_epoll_Native_epollerr(JNIEnv* env, jclass clazz) {, +    return EPOLLERR;, +}, +, +++ b/transport-native-epoll/src/main/c/io_netty_channel_epoll_Native.c, +JNIEXPORT jint JNICALL Java_io_netty_channel_epoll_Native_epollerr(JNIEnv* env, jclass clazz) {, +    return EPOLLERR;, +}, +, +++ b/transport-native-epoll/src/main/c/io_netty_channel_epoll_Native.h, +jint Java_io_netty_channel_epoll_Native_epollerr(JNIEnv* env, jclass clazz);, +++ b/transport-native-epoll/src/main/c/io_netty_channel_epoll_Native.c, +JNIEXPORT jint JNICALL Java_io_netty_channel_epoll_Native_epollerr(JNIEnv* env, jclass clazz) {, +    return EPOLLERR;, +}, +, +++ b/transport-native-epoll/src/main/c/io_netty_channel_epoll_Native.h, +jint Java_io_netty_channel_epoll_Native_epollerr(JNIEnv* env, jclass clazz);, +++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollEventLoop.java, +                    // Check if an error was the cause of the wakeup., +                    boolean err = (ev & Native.EPOLLERR) != 0;, +, +                    //, +                    // It is possible for an EPOLLOUT or EPOLLERR to be generated when a connection is refused., +                    // In either case epollOutReady() will do the correct thing (finish connecting, or fail, +                    // the connection)., +                    // See https://github.com/netty/netty/issues/3848, +                    if (err || ((ev & Native.EPOLLOUT) != 0) && ch.isOpen()) {, +, +                    // If EPOLLOUT or EPOLLING was received and the channel is still open call epollInReady()., +                    // This will try to read from the underlying filedescriptor and so notify the user about the, +                    // error., +                    if ((err || (ev & Native.EPOLLIN) != 0) && ch.isOpen()) {, +++ b/transport-native-epoll/src/main/c/io_netty_channel_epoll_Native.c, +JNIEXPORT jint JNICALL Java_io_netty_channel_epoll_Native_epollerr(JNIEnv* env, jclass clazz) {, +    return EPOLLERR;, +}, +, +++ b/transport-native-epoll/src/main/c/io_netty_channel_epoll_Native.h, +jint Java_io_netty_channel_epoll_Native_epollerr(JNIEnv* env, jclass clazz);, +++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollEventLoop.java, +                    // Check if an error was the cause of the wakeup., +                    boolean err = (ev & Native.EPOLLERR) != 0;, +, +                    //, +                    // It is possible for an EPOLLOUT or EPOLLERR to be generated when a connection is refused., +                    // In either case epollOutReady() will do the correct thing (finish connecting, or fail, +                    // the connection)., +                    // See https://github.com/netty/netty/issues/3848, +                    if (err || ((ev & Native.EPOLLOUT) != 0) && ch.isOpen()) {, +, +                    // If EPOLLOUT or EPOLLING was received and the channel is still open call epollInReady()., +                    // This will try to read from the underlying filedescriptor and so notify the user about the, +                    // error., +                    if ((err || (ev & Native.EPOLLIN) != 0) && ch.isOpen()) {, +++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/Native.java, +    public static final int EPOLLERR = epollerr();, +    private static native int epollerr();]