[+++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyCodecUtil.java, + * Copyright 2013 The Netty Project, +    static final int SPDY_DATA_FRAME          = 0;, +    static final int SPDY_PUSH_PROMISE_FRAME  = 5;, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyCodecUtil.java, + * Copyright 2013 The Netty Project, +    static final int SPDY_DATA_FRAME          = 0;, +    static final int SPDY_PUSH_PROMISE_FRAME  = 5;, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyFrameDecoder.java, +    private static final SpdyProtocolException INVALID_FRAME =, +            new SpdyProtocolException("Received invalid frame");, +, +    private final SpdyHeaderBlockDecoder headerBlockDecoder;, +    private int streamId;, +        this(version, maxChunkSize, SpdyHeaderBlockDecoder.newInstance(version, maxHeaderSize));, +    }, +, +    protected SpdyFrameDecoder(, +            int version, int maxChunkSize, SpdyHeaderBlockDecoder headerBlockDecoder) {, +        this.headerBlockDecoder = headerBlockDecoder;, +            headerBlockDecoder.end();, +                    fireInvalidFrameException(ctx);, +                    SpdyDataFrame spdyDataFrame = new DefaultSpdyDataFrame(streamId);, +                fireInvalidFrameException(ctx);, +                    fireInvalidFrameException(ctx);, +                    fireInvalidFrameException(ctx);, +                fireInvalidFrameException(ctx);, +                headerBlockDecoder.decode(buffer.readSlice(compressedBytes), spdyHeadersFrame);, +                    headerBlockDecoder.reset();, +                headerBlockDecoder.reset();, +            if (streamId == 0) {, +            SpdyDataFrame spdyDataFrame = new DefaultSpdyDataFrame(streamId, data);, +            streamId = 0;, +        } else {, +            // Decode data frame common header, +            version = spdyVersion; // Default to expected version, +, +            type = SPDY_DATA_FRAME;, +, +            streamId = getUnsignedInt(buffer, frameOffset);, +        }, +        if (version != spdyVersion || !isValidFrameHeader()) {, +        if (willGenerateFrame()) {, +            case SPDY_DATA_FRAME:, +                nextState = State.READ_DATA_FRAME;, +                break;, +, +        int streamId;, +            streamId = getUnsignedInt(buffer, buffer.readerIndex());, +            return new DefaultSpdyRstStreamFrame(streamId, statusCode);, +            streamId = getUnsignedInt(buffer, buffer.readerIndex());, +            return new DefaultSpdyWindowUpdateFrame(streamId, deltaWindowSize);, +        int streamId;, +            streamId = getUnsignedInt(buffer, offset);, +                    new DefaultSpdySynStreamFrame(streamId, associatedToStreamId, priority);, +            streamId = getUnsignedInt(buffer, buffer.readerIndex());, +            SpdySynReplyFrame spdySynReplyFrame = new DefaultSpdySynReplyFrame(streamId);, +            streamId = getUnsignedInt(buffer, buffer.readerIndex());, +            SpdyHeadersFrame spdyHeadersFrame = new DefaultSpdyHeadersFrame(streamId);, +    private boolean isValidFrameHeader() {, +        case SPDY_DATA_FRAME:, +            return streamId != 0;, +, +    private boolean willGenerateFrame() {, +        case SPDY_DATA_FRAME:, +    private static void fireInvalidFrameException(ChannelHandlerContext ctx) {, +        ctx.fireExceptionCaught(INVALID_FRAME);, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyCodecUtil.java, + * Copyright 2013 The Netty Project, +    static final int SPDY_DATA_FRAME          = 0;, +    static final int SPDY_PUSH_PROMISE_FRAME  = 5;, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyFrameDecoder.java, +    private static final SpdyProtocolException INVALID_FRAME =, +            new SpdyProtocolException("Received invalid frame");, +, +    private final SpdyHeaderBlockDecoder headerBlockDecoder;, +    private int streamId;, +        this(version, maxChunkSize, SpdyHeaderBlockDecoder.newInstance(version, maxHeaderSize));, +    }, +, +    protected SpdyFrameDecoder(, +            int version, int maxChunkSize, SpdyHeaderBlockDecoder headerBlockDecoder) {, +        this.headerBlockDecoder = headerBlockDecoder;, +            headerBlockDecoder.end();, +                    fireInvalidFrameException(ctx);, +                    SpdyDataFrame spdyDataFrame = new DefaultSpdyDataFrame(streamId);, +                fireInvalidFrameException(ctx);, +                    fireInvalidFrameException(ctx);, +                    fireInvalidFrameException(ctx);, +                fireInvalidFrameException(ctx);, +                headerBlockDecoder.decode(buffer.readSlice(compressedBytes), spdyHeadersFrame);, +                    headerBlockDecoder.reset();, +                headerBlockDecoder.reset();, +            if (streamId == 0) {, +            SpdyDataFrame spdyDataFrame = new DefaultSpdyDataFrame(streamId, data);, +            streamId = 0;, +        } else {, +            // Decode data frame common header, +            version = spdyVersion; // Default to expected version, +]