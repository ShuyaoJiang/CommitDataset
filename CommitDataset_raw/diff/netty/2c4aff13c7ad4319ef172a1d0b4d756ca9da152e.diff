[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectAggregator.java, +            // Release the message in case it is a full one., +, +            if (msg instanceof HttpRequest) {, +                // If an oversized request was handled properly and the connection is still alive, +                // (i.e. rejected 100-continue). the decoder should prepare to handle a new message., +                HttpObjectDecoder decoder = ctx.pipeline().get(HttpObjectDecoder.class);, +                if (decoder != null) {, +                    decoder.reset();, +                }, +            }, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectAggregator.java, +            // Release the message in case it is a full one., +, +            if (msg instanceof HttpRequest) {, +                // If an oversized request was handled properly and the connection is still alive, +                // (i.e. rejected 100-continue). the decoder should prepare to handle a new message., +                HttpObjectDecoder decoder = ctx.pipeline().get(HttpObjectDecoder.class);, +                if (decoder != null) {, +                    decoder.reset();, +                }, +            }, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectDecoder.java, +    private volatile boolean resetRequested;, +        if (resetRequested) {, +            resetNow();, +        }, +, +                resetNow();, +                resetNow();, +                    resetNow();, +                resetNow();, +                resetNow();, +            resetNow();, +            resetNow();, +    /**, +     * Resets the state of the decoder so that it is ready to decode a new message., +     * This method is useful for handling a rejected request with {@code Expect: 100-continue} header., +     */, +    public void reset() {, +        resetRequested = true;, +    }, +, +    private void resetNow() {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectAggregator.java, +            // Release the message in case it is a full one., +, +            if (msg instanceof HttpRequest) {, +                // If an oversized request was handled properly and the connection is still alive, +                // (i.e. rejected 100-continue). the decoder should prepare to handle a new message., +                HttpObjectDecoder decoder = ctx.pipeline().get(HttpObjectDecoder.class);, +                if (decoder != null) {, +                    decoder.reset();, +                }, +            }, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectDecoder.java, +    private volatile boolean resetRequested;, +        if (resetRequested) {, +            resetNow();, +        }, +, +                resetNow();, +                resetNow();, +                    resetNow();, +                resetNow();, +                resetNow();, +            resetNow();, +            resetNow();, +    /**, +     * Resets the state of the decoder so that it is ready to decode a new message., +     * This method is useful for handling a rejected request with {@code Expect: 100-continue} header., +     */, +    public void reset() {, +        resetRequested = true;, +    }, +, +    private void resetNow() {, +++ b/codec-http/src/test/java/io/netty/handler/codec/http/HttpObjectAggregatorTest.java, +        HttpRequest message = new DefaultHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.PUT, "http://localhost");, +        HttpRequest message = new DefaultHttpRequest(HttpVersion.HTTP_1_0, HttpMethod.PUT, "http://localhost");, +        HttpRequest message = new DefaultHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.PUT, "http://localhost");, +    public void testOversizedRequestWith100Continue() {, +        HttpRequest message = new DefaultHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.PUT, "http://localhost");, +        HttpRequest message2 = new DefaultHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.PUT, "http://localhost");, +    @Test, +    public void testOversizedRequestWith100ContinueAndDecoder() {, +        EmbeddedChannel embedder = new EmbeddedChannel(new HttpRequestDecoder(), new HttpObjectAggregator(4));, +        embedder.writeInbound(Unpooled.copiedBuffer(, +                "PUT /upload HTTP/1.1\r\n" +, +                        "Expect: 100-continue\r\n" +, +                        "Content-Length: 100\r\n\r\n", CharsetUtil.US_ASCII));, +, +        assertNull(embedder.readInbound());, +, +        FullHttpResponse response = embedder.readOutbound();, +        assertEquals(HttpResponseStatus.REQUEST_ENTITY_TOO_LARGE, response.getStatus());, +        assertEquals("0", response.headers().get(Names.CONTENT_LENGTH));, +, +        // Keep-alive is on by default in HTTP/1.1, so the connection should be still alive., +        assertTrue(embedder.isOpen());]