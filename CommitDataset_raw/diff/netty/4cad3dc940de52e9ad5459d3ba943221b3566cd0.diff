[+++ b/src/docbook/module/start.xml, +      Dealing with a Stream-based Transport, +        One Small Caveat of Socket Buffer, +        In a stream-based transport such as TCP/IP, received data is stored, +        into a socket receive buffer.  Unfortunately, the buffer of a, +        stream-based transport is not a queue of packets but a queue of bytes., +        It means, even if you sent two messages as two independent packets, an, +        operating system will not treat them as two messages but as just a, +        bunch of bytes.  Therefore, there is no guarantee that what you read, +        is exactly what your remote peer wrote.  For example, let us assume, +        that the TCP/IP stack of an operating system has received three packets:, +        Because of this general property of a stream-based protocol, there's, +        high chance of reading them in the following fragmented form in your, +        application:, +        Therefore, a receiving part, regardless it is server-side or, +        client-side, should defrag the received data into one or more meaningful, +        application logic.  In case of the example above, the received data, +        should be framed like the following:, +        Now let us get back to the TIME client example.  We have the same, +        problem here.  A 32-bit integer is a very small amount of data, and it, +        is not likely to be fragmented often.  However, the problem is that it, +        It means one same <classname>TimeClientHandler</classname> instance is, +        going to handle multiple &Channel;s and consequently the data will be, +        corrupted.  To create a new <classname>TimeClientHandler</classname>, +        instance per &Channel;, we have to implement a &ChannelPipelineFactory;:, +        However, as your application gets more and more complex, you will, +        almost always end up with writing a &ChannelPipelineFactory;, which, +        yields much more flexibility to the pipeline configuration., +              <classname>TimeDecoder</classname> which deals with the, +              fragmentation issue, and, +        Fortunately, Netty provides an extensible class which helps you write, +        the first one out of the box:, +        &Channels;.write(ctx, e.getFuture(), buf);<co id="example.time6.co3"/>, +          <literal>"all"</literal> because this encoder is stateless., +          Actually, most encoders are stateless., +write(ctx, e.getFuture(), buf);, +fireChannelDisconnected(ctx);</programlisting>, +      Shutting Down Your Application, +    </title>, +    <para>, +      If you ran the <classname>TimeClient</classname>, you must have noticed, +      that the application doesn't exit but just keep running doing nothing., +      Looking from the full stack trace, you will also find a couple I/O threads, +      are running.  To shut down the I/O threads and let the application exit, +      gracefully, you need to release the resources allocated by &ChannelFactory;., +    </para>, +    <para>, +      The shutdown process of a typical network application is composed of the, +      following three steps:, +      <orderedlist>, +        <listitem>, +          <para>, +            Close all server sockets if there are any,, +          </para>, +        </listitem>, +        <listitem>, +          <para>, +            Close all non-server sockets (i.e. client sockets and accepted, +            sockets) if there are any, and, +          </para>, +        </listitem>, +        <listitem>, +          <para>, +            Release all resources used by &ChannelFactory;., +          </para>, +        </listitem>, +      </orderedlist>, +    </para>, +    <para>, +      To apply the three steps above to the <classname>TimeClient</classname>,, +      <methodname>TimeClient.main()</methodname> could shut itself down, +      gracefully by closing the only one client connection and releasing all, +      resources used by &ChannelFactory;:, +    </para>, +    <programlisting>package org.jboss.netty.example.time;, +, +public class TimeClient {, +    public static void main(String[] args) throws Exception {, +        ..., +        &ChannelFactory; factory = ...;, +        &ClientBootstrap; bootstrap = ...;, +        ..., +        &ChannelFuture; future<co id="example.time7.co1"/> = bootstrap.connect(...);, +        future.awaitUninterruptible();<co id="example.time7.co2"/>, +        if (!future.isSuccess()) {, +            future.getCause().printStackTrace();<co id="example.time7.co3"/>, +        }, +        future.getChannel().getCloseFuture().awaitUninterruptibly();<co id="example.time7.co4"/>, +        factory.releaseExternalResources();<co id="example.time7.co5"/>, +    }, +}</programlisting>, +    <calloutlist>, +      <callout arearefs="example.time7.co1">, +        <para>, +          The <methodname>connect</methodname> method of &ClientBootstrap;, +          returns a &ChannelFuture; which notifies when a connection attempt, +          succeeds or fails.  It also has a reference to the &Channel; which, +          is associated with the connection attempt., +        </para>, +      </callout>]