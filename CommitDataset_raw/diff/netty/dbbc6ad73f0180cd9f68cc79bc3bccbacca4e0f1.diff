[+++ b/transport/src/main/java/io/netty/channel/DefaultEventExecutor.java, +            if (isShutdown() && confirmShutdown()) {, +++ b/transport/src/main/java/io/netty/channel/DefaultEventExecutor.java, +            if (isShutdown() && confirmShutdown()) {, +++ b/transport/src/main/java/io/netty/channel/MultithreadEventExecutorGroup.java, +        if (isShutdown()) {, +            return;, +        }, +, +++ b/transport/src/main/java/io/netty/channel/DefaultEventExecutor.java, +            if (isShutdown() && confirmShutdown()) {, +++ b/transport/src/main/java/io/netty/channel/MultithreadEventExecutorGroup.java, +        if (isShutdown()) {, +            return;, +        }, +, +++ b/transport/src/main/java/io/netty/channel/SingleThreadEventExecutor.java, +    /**, +     * Wait at least 2 seconds after shutdown() until there are no pending tasks anymore., +     * @see #confirmShutdown(), +     */, +    private static final long SHUTDOWN_DELAY_NANOS = TimeUnit.SECONDS.toNanos(2);, +, +    private static final int ST_NOT_STARTED = 1;, +    private static final int ST_STARTED = 2;, +    private static final int ST_SHUTDOWN = 3;, +    private static final int ST_TERMINATED = 4;, +, +    private static final Runnable WAKEUP_TASK = new Runnable() {, +        @Override, +        public void run() {, +            // Do nothing., +        }, +    };, +, +    private volatile int state = ST_NOT_STARTED;, +    private long lastAccessTimeNanos;, +                boolean success = false;, +                    success = true;, +                    // Check if confirmShutdown() was called at the end of the loop., +                    if (success && lastAccessTimeNanos == 0) {, +                        logger.error(, +                                "Buggy " + EventExecutor.class.getSimpleName() + " implementation; " +, +                                SingleThreadEventExecutor.class.getSimpleName() + ".confirmShutdown() must be called " +, +                                "before run() implementation terminates.");, +                    }, +, +                        for (;;) {, +                            if (confirmShutdown()) {, +                                break;, +                            }, +                        }, +                            state = ST_TERMINATED;, +        if (isTerminated()) {, +            if (task == WAKEUP_TASK) {, +                continue;, +            }, +, +    protected void wakeup(boolean inEventLoop) {, +        if (!inEventLoop || state == ST_SHUTDOWN) {, +            addTask(WAKEUP_TASK);, +        }, +    }, +        if (isShutdown()) {, +            return;, +        }, +, +        boolean wakeup = true;, +, +                assert state == ST_STARTED;, +                state = ST_SHUTDOWN;, +                case ST_NOT_STARTED:, +                    state = ST_SHUTDOWN;, +                    thread.start();, +                case ST_STARTED:, +                    state = ST_SHUTDOWN;, +                default:, +                    wakeup = false;, +        return state >= ST_SHUTDOWN;, +        return state == ST_TERMINATED;, +    }, +, +    protected boolean confirmShutdown() {, +        if (!isShutdown()) {, +            throw new IllegalStateException("must be invoked after shutdown()");, +        }, +        if (!inEventLoop()) {, +            throw new IllegalStateException("must be invoked from an event loop");, +        }, +, +        if (runAllTasks() || runShutdownHooks()) {, +            // There were tasks in the queue. Wait a little bit more until no tasks are queued for SHUTDOWN_DELAY_NANOS., +            lastAccessTimeNanos = 0;, +            wakeup(true);, +            return false;, +        }, +, +        if (lastAccessTimeNanos == 0 || System.nanoTime() - lastAccessTimeNanos < SHUTDOWN_DELAY_NANOS) {, +            if (lastAccessTimeNanos == 0) {, +                lastAccessTimeNanos = System.nanoTime();]