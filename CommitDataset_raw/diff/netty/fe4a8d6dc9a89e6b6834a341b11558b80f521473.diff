[+++ b/transport/src/main/java/io/netty/channel/socket/aio/AioChannelFinder.java, +package io.netty.channel.socket.aio;, +, +interface AioChannelFinder {, +    AbstractAioChannel findChannel(Runnable command) throws Exception;, +}, +++ b/transport/src/main/java/io/netty/channel/socket/aio/AioChannelFinder.java, +package io.netty.channel.socket.aio;, +, +interface AioChannelFinder {, +    AbstractAioChannel findChannel(Runnable command) throws Exception;, +}, +++ b/transport/src/main/java/io/netty/channel/socket/aio/AioEventLoopGroup.java, +import io.netty.channel.ChannelTaskScheduler;, +    private static final AioChannelFinder CHANNEL_FINDER;, +        AioChannelFinder finder;, +                finder = new UnsafeAioChannelFinder();, +                finder = new DefaultAioChannelFinder();, +            LOGGER.debug(String.format(, +                    "Unable to instance the optimal %s implementation - falling back to %s.",, +                    AioChannelFinder.class.getSimpleName(), DefaultAioChannelFinder.class.getSimpleName()), t);, +            finder = new DefaultAioChannelFinder();, +++ b/transport/src/main/java/io/netty/channel/socket/aio/AioChannelFinder.java, +package io.netty.channel.socket.aio;, +, +interface AioChannelFinder {, +    AbstractAioChannel findChannel(Runnable command) throws Exception;, +}, +++ b/transport/src/main/java/io/netty/channel/socket/aio/AioEventLoopGroup.java, +import io.netty.channel.ChannelTaskScheduler;, +    private static final AioChannelFinder CHANNEL_FINDER;, +        AioChannelFinder finder;, +                finder = new UnsafeAioChannelFinder();, +                finder = new DefaultAioChannelFinder();, +            LOGGER.debug(String.format(, +                    "Unable to instance the optimal %s implementation - falling back to %s.",, +                    AioChannelFinder.class.getSimpleName(), DefaultAioChannelFinder.class.getSimpleName()), t);, +            finder = new DefaultAioChannelFinder();, +++ b/transport/src/main/java/io/netty/channel/socket/aio/DefaultAioChannelFinder.java, +package io.netty.channel.socket.aio;, +, +import java.lang.reflect.Field;, +import java.util.ArrayDeque;, +import java.util.Deque;, +import java.util.concurrent.ConcurrentHashMap;, +import java.util.concurrent.ConcurrentMap;, +, +class DefaultAioChannelFinder implements AioChannelFinder {, +    private static final ConcurrentMap<Class<?>, Field[]> fieldCache = new ConcurrentHashMap<Class<?>, Field[]>();, +    private static final Field[] FAILURE = new Field[0];, +, +    @Override, +    public AbstractAioChannel findChannel(Runnable command) throws Exception {, +        Class<?> commandType = command.getClass();, +        Field[] fields = fieldCache.get(commandType);, +        if (fields == null) {, +            try {, +                fields = findFieldSequence(command, new ArrayDeque<Field>(2));, +            } catch (Throwable t) {, +                // Failed to get the field list, +            }, +, +            if (fields == null) {, +                fields = FAILURE;, +            }, +, +            fieldCache.put(commandType, fields); // No need to use putIfAbsent(), +        }, +, +        if (fields == FAILURE) {, +            return null;, +        }, +, +        final int lastIndex = fields.length - 1;, +        for (int i = 0; i < lastIndex; i ++) {, +            command = (Runnable) get(fields[i], command);, +        }, +, +        return (AbstractAioChannel) get(fields[lastIndex], command);, +    }, +, +    private Field[] findFieldSequence(Runnable command, Deque<Field> fields) throws Exception {, +        Class<?> commandType = command.getClass();, +        for (Field f: commandType.getDeclaredFields()) {, +            if (f.getType() == Runnable.class) {, +                f.setAccessible(true);, +                fields.addLast(f);, +                try {, +                    Field[] ret = findFieldSequence((Runnable) get(f, command), fields);, +                    if (ret != null) {, +                        return ret;, +                    }, +                } finally {, +                    fields.removeLast();, +                }, +            }, +, +            if (f.getType() == Object.class) {, +                f.setAccessible(true);, +                fields.addLast(f);]