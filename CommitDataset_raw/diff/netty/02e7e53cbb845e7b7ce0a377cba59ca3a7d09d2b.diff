[+++ b/handler/src/main/java/io/netty/handler/ssl/SslHandler.java, +import io.netty.channel.PendingWriteQueue;, +    private PendingWriteQueue pendingUnencryptedWrites;, +, +        if (!pendingUnencryptedWrites.isEmpty()) {, +            // Check if queue is not empty first because create a new ChannelException is expensive, +            pendingUnencryptedWrites.removeAndFailAll(new ChannelException("Pending write on removal of SslHandler"));, +        pendingUnencryptedWrites.add(msg, promise);, +            pendingUnencryptedWrites.removeAndWriteAll();, +            pendingUnencryptedWrites.add(Unpooled.EMPTY_BUFFER, ctx.voidPromise());, +                Object msg = pendingUnencryptedWrites.current();, +                if (msg == null) {, +                if (!(msg instanceof ByteBuf)) {, +                    pendingUnencryptedWrites.removeAndWrite();, +                ByteBuf buf = (ByteBuf) msg;, +                    promise = pendingUnencryptedWrites.remove();, +                    pendingUnencryptedWrites.removeAndFailAll(SSLENGINE_CLOSED);, +        pendingUnencryptedWrites.removeAndFailAll(cause);, +        pendingUnencryptedWrites = new PendingWriteQueue(ctx);, +++ b/handler/src/main/java/io/netty/handler/ssl/SslHandler.java, +import io.netty.channel.PendingWriteQueue;, +    private PendingWriteQueue pendingUnencryptedWrites;, +, +        if (!pendingUnencryptedWrites.isEmpty()) {, +            // Check if queue is not empty first because create a new ChannelException is expensive, +            pendingUnencryptedWrites.removeAndFailAll(new ChannelException("Pending write on removal of SslHandler"));, +        pendingUnencryptedWrites.add(msg, promise);, +            pendingUnencryptedWrites.removeAndWriteAll();, +            pendingUnencryptedWrites.add(Unpooled.EMPTY_BUFFER, ctx.voidPromise());, +                Object msg = pendingUnencryptedWrites.current();, +                if (msg == null) {, +                if (!(msg instanceof ByteBuf)) {, +                    pendingUnencryptedWrites.removeAndWrite();, +                ByteBuf buf = (ByteBuf) msg;, +                    promise = pendingUnencryptedWrites.remove();, +                    pendingUnencryptedWrites.removeAndFailAll(SSLENGINE_CLOSED);, +        pendingUnencryptedWrites.removeAndFailAll(cause);, +        pendingUnencryptedWrites = new PendingWriteQueue(ctx);, +++ b/transport/src/main/java/io/netty/channel/ChannelOutboundBuffer.java, +    void incrementPendingOutboundBytes(long size) {, +    void decrementPendingOutboundBytes(long size) {, +++ b/handler/src/main/java/io/netty/handler/ssl/SslHandler.java, +import io.netty.channel.PendingWriteQueue;, +    private PendingWriteQueue pendingUnencryptedWrites;, +, +        if (!pendingUnencryptedWrites.isEmpty()) {, +            // Check if queue is not empty first because create a new ChannelException is expensive, +            pendingUnencryptedWrites.removeAndFailAll(new ChannelException("Pending write on removal of SslHandler"));, +        pendingUnencryptedWrites.add(msg, promise);, +            pendingUnencryptedWrites.removeAndWriteAll();, +            pendingUnencryptedWrites.add(Unpooled.EMPTY_BUFFER, ctx.voidPromise());, +                Object msg = pendingUnencryptedWrites.current();, +                if (msg == null) {, +                if (!(msg instanceof ByteBuf)) {, +                    pendingUnencryptedWrites.removeAndWrite();, +                ByteBuf buf = (ByteBuf) msg;, +                    promise = pendingUnencryptedWrites.remove();, +                    pendingUnencryptedWrites.removeAndFailAll(SSLENGINE_CLOSED);, +        pendingUnencryptedWrites.removeAndFailAll(cause);, +        pendingUnencryptedWrites = new PendingWriteQueue(ctx);, +++ b/transport/src/main/java/io/netty/channel/ChannelOutboundBuffer.java, +    void incrementPendingOutboundBytes(long size) {, +    void decrementPendingOutboundBytes(long size) {, +++ b/transport/src/main/java/io/netty/channel/PendingWriteQueue.java, +/*, + * Copyright 2014 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + *   http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the, + * License for the specific language governing permissions and limitations, + * under the License., + */, +package io.netty.channel;, +, +import io.netty.util.Recycler;, +import io.netty.util.ReferenceCountUtil;, +import io.netty.util.internal.logging.InternalLogger;, +import io.netty.util.internal.logging.InternalLoggerFactory;, +, +/**, + * A queue of write operations which are pending for later execution. It also updates the, + * {@linkplain Channel#isWritable() writability} of the associated {@link Channel}, so that, + * the pending write operations are also considered to determine the writability., + */, +public final class PendingWriteQueue {, +    private static final InternalLogger logger = InternalLoggerFactory.getInstance(PendingWriteQueue.class);, +, +    private final ChannelHandlerContext ctx;, +    private final ChannelOutboundBuffer buffer;, +    private final MessageSizeEstimator.Handle estimatorHandle;, +, +    // head and tail pointers for the linked-list structure. If empty head and tail are null., +    private PendingWrite head;]