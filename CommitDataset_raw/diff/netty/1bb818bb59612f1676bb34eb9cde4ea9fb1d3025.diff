[+++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslEngine.java, +import io.netty.buffer.Unpooled;, +    private static final long EMPTY_ADDR = Buffer.address(Unpooled.EMPTY_BUFFER.nioBuffer());, +, +     * Write encrypted data to the OpenSSL network BIO., +        return -1;, +            final ByteBuffer[] srcs, int srcsOffset, final int srcsLength,, +            final ByteBuffer[] dsts, final int dstsOffset, final int dstsLength) throws SSLException {, +        if (srcs == null) {, +            throw new NullPointerException("srcs");, +        }, +        if (srcsOffset >= srcs.length, +                || srcsOffset + srcsLength > srcs.length) {, +            throw new IndexOutOfBoundsException(, +                    "offset: " + srcsOffset + ", length: " + srcsLength +, +                    " (expected: offset <= offset + length <= srcs.length (" + srcs.length + "))");, +        if (dstsOffset >= dsts.length || dstsOffset + dstsLength > dsts.length) {, +                    "offset: " + dstsOffset + ", length: " + dstsLength +, +        final int endOffset = dstsOffset + dstsLength;, +        for (int i = dstsOffset; i < endOffset; i ++) {, +        final int srcsEndOffset = srcsOffset + srcsLength;, +        int len = 0;, +        for (int i = srcsOffset; i < srcsEndOffset; i++) {, +            ByteBuffer src = srcs[i];, +            if (src == null) {, +                throw new NullPointerException("srcs[" + i + ']');, +            }, +            len += src.remaining();, +        }, +, +        if (len > MAX_ENCRYPTED_PACKET_LENGTH) {, +        int bytesConsumed = -1;, +        int lastPrimingReadResult = 0;, +            while (srcsOffset < srcsEndOffset) {, +                ByteBuffer src = srcs[srcsOffset];, +                int remaining = src.remaining();, +                int written = writeEncryptedData(src);, +                if (written >= 0) {, +                    if (bytesConsumed == -1) {, +                        bytesConsumed = written;, +                    } else {, +                        bytesConsumed += written;, +                    }, +                    if (written == remaining) {, +                        srcsOffset ++;, +                    } else if (written == 0) {, +                        break;, +                    }, +                } else {, +                    break;, +                }, +            }, +        if (bytesConsumed >= 0) {, +            lastPrimingReadResult = SSL.readFromSSL(ssl, EMPTY_ADDR, 0); // priming read, +        } else {, +            // Reset to 0 as -1 is used to signal that nothing was written and no priming read needs to be done, +            bytesConsumed = 0;, +        }, +        int idx = dstsOffset;, +    public SSLEngineResult unwrap(final ByteBuffer[] srcs, final ByteBuffer[] dsts) throws SSLException {, +        return unwrap(srcs, 0, srcs.length, dsts, 0, dsts.length);, +    }, +, +    @Override, +    public SSLEngineResult unwrap(, +            final ByteBuffer src, final ByteBuffer[] dsts, final int offset, final int length) throws SSLException {, +        return unwrap(new ByteBuffer[] { src }, 0, 1, dsts, offset, length);, +    }, +, +++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslEngine.java, +import io.netty.buffer.Unpooled;, +    private static final long EMPTY_ADDR = Buffer.address(Unpooled.EMPTY_BUFFER.nioBuffer());, +, +     * Write encrypted data to the OpenSSL network BIO., +        return -1;, +            final ByteBuffer[] srcs, int srcsOffset, final int srcsLength,, +            final ByteBuffer[] dsts, final int dstsOffset, final int dstsLength) throws SSLException {, +        if (srcs == null) {, +            throw new NullPointerException("srcs");, +        }, +        if (srcsOffset >= srcs.length, +                || srcsOffset + srcsLength > srcs.length) {, +            throw new IndexOutOfBoundsException(, +                    "offset: " + srcsOffset + ", length: " + srcsLength +, +                    " (expected: offset <= offset + length <= srcs.length (" + srcs.length + "))");, +        if (dstsOffset >= dsts.length || dstsOffset + dstsLength > dsts.length) {, +                    "offset: " + dstsOffset + ", length: " + dstsLength +, +        final int endOffset = dstsOffset + dstsLength;, +        for (int i = dstsOffset; i < endOffset; i ++) {, +        final int srcsEndOffset = srcsOffset + srcsLength;, +        int len = 0;, +        for (int i = srcsOffset; i < srcsEndOffset; i++) {, +            ByteBuffer src = srcs[i];, +            if (src == null) {, +                throw new NullPointerException("srcs[" + i + ']');, +            }, +            len += src.remaining();, +        }, +, +        if (len > MAX_ENCRYPTED_PACKET_LENGTH) {]