[+++ b/handler/src/main/java/io/netty/handler/traffic/AbstractTrafficShapingHandler.java, +import io.netty.util.internal.logging.InternalLogger;, +import io.netty.util.internal.logging.InternalLoggerFactory;, +    private static final InternalLogger logger =, +            InternalLoggerFactory.getInstance(AbstractTrafficShapingHandler.class);, +    * Default max delay in case of traffic shaping, +    * (during which no communication will occur)., +    * Shall be less than TIMEOUT. Here half of "standard" 30s, +    */, +    public static final long DEFAULT_MAX_TIME = 15000;, +, +    /**, +    static final long MINIMAL_WAIT = 10;, +    * Max delay in wait, +    */, +    protected long maxTime = DEFAULT_MAX_TIME; // default 15 s, +, +    /**, +     * @param maxTime, +     *          The maximum delay to wait in case of traffic excess, +                                            long checkInterval, long maxTime) {, +        this.maxTime = maxTime;, +    }, +, +   /**, +    * @param writeLimit, +    *           0 or a limit in bytes/s, +    * @param readLimit, +    *           0 or a limit in bytes/s, +    * @param checkInterval, +    *           The delay between two computations of performances for, +    *           channels or 0 if no stats are to be computed, +    */, +    protected AbstractTrafficShapingHandler(long writeLimit, long readLimit,, +            long checkInterval) {, +        this(writeLimit, readLimit, checkInterval, DEFAULT_MAX_TIME);, +        this(writeLimit, readLimit, DEFAULT_CHECK_INTERVAL, DEFAULT_MAX_TIME);, +        this(0, 0, DEFAULT_CHECK_INTERVAL, DEFAULT_MAX_TIME);, +        this(0, 0, checkInterval, DEFAULT_MAX_TIME);, +     * @return the writeLimit, +     */, +    public long getWriteLimit() {, +        return writeLimit;, +    }, +, +    /**, +     * @param writeLimit the writeLimit to set, +     */, +    public void setWriteLimit(long writeLimit) {, +        this.writeLimit = writeLimit;, +        if (trafficCounter != null) {, +            trafficCounter.resetAccounting(System.currentTimeMillis() + 1);, +        }, +    }, +, +    /**, +     * @return the readLimit, +     */, +    public long getReadLimit() {, +        return readLimit;, +    }, +, +    /**, +     * @param readLimit the readLimit to set, +     */, +    public void setReadLimit(long readLimit) {, +        this.readLimit = readLimit;, +        if (trafficCounter != null) {, +            trafficCounter.resetAccounting(System.currentTimeMillis() + 1);, +        }, +    }, +, +    /**, +     * @return the checkInterval, +     */, +    public long getCheckInterval() {, +        return checkInterval;, +    }, +, +    /**, +     * @param checkInterval the checkInterval to set, +     */, +    public void setCheckInterval(long checkInterval) {, +        this.checkInterval = checkInterval;, +        if (trafficCounter != null) {, +            trafficCounter.configure(checkInterval);, +        }, +    }, +, +    /**, +     *, +     * @param maxTime, +     *            Max delay in wait, shall be less than TIME OUT in related protocol, +     */, +    public void setMaxTimeWait(long maxTime) {, +        this.maxTime = maxTime;, +    }, +, +    /**, +     * @return the max delay in wait]