[+++ b/handler/src/main/java/io/netty/handler/ssl/ReferenceCountedOpenSslEngine.java, +    private static final int OPENSSL_OP_NO_PROTOCOL_INDEX_SSLV2 = 0;, +    private static final int OPENSSL_OP_NO_PROTOCOL_INDEX_SSLV3 = 1;, +    private static final int OPENSSL_OP_NO_PROTOCOL_INDEX_TLSv1 = 2;, +    private static final int OPENSSL_OP_NO_PROTOCOL_INDEX_TLSv1_1 = 3;, +    private static final int OPENSSL_OP_NO_PROTOCOL_INDEX_TLSv1_2 = 4;, +    private static final int[] OPENSSL_OP_NO_PROTOCOLS = new int[] {, +            SSL.SSL_OP_NO_SSLv2,, +            SSL.SSL_OP_NO_SSLv3,, +            SSL.SSL_OP_NO_TLSv1,, +            SSL.SSL_OP_NO_TLSv1_1,, +            SSL.SSL_OP_NO_TLSv1_2, +    };, +    /**, +     * {@inheritDoc}, +     * TLS doesn't support a way to advertise non-contiguous versions from the client's perspective, and the client, +     * just advertises the max supported version. The TLS protocol also doesn't support all different combinations of, +     * discrete protocols, and instead assumes contiguous ranges. OpenSSL has some unexpected behavior, +     * (e.g. handshake failures) if non-contiguous protocols are used even where there is a compatible set of protocols, +     * and ciphers. For these reasons this method will determine the minimum protocol and the maximum protocol and, +     * enabled a contiguous range from [min protocol, max protocol] in OpenSSL., +     */, +        int minProtocolIndex = OPENSSL_OP_NO_PROTOCOLS.length;, +        int maxProtocolIndex = 0;, +                if (minProtocolIndex > OPENSSL_OP_NO_PROTOCOL_INDEX_SSLV2) {, +                    minProtocolIndex = OPENSSL_OP_NO_PROTOCOL_INDEX_SSLV2;, +                }, +                if (maxProtocolIndex < OPENSSL_OP_NO_PROTOCOL_INDEX_SSLV2) {, +                    maxProtocolIndex = OPENSSL_OP_NO_PROTOCOL_INDEX_SSLV2;, +                }, +                if (minProtocolIndex > OPENSSL_OP_NO_PROTOCOL_INDEX_SSLV3) {, +                    minProtocolIndex = OPENSSL_OP_NO_PROTOCOL_INDEX_SSLV3;, +                }, +                if (maxProtocolIndex < OPENSSL_OP_NO_PROTOCOL_INDEX_SSLV3) {, +                    maxProtocolIndex = OPENSSL_OP_NO_PROTOCOL_INDEX_SSLV3;, +                }, +                if (minProtocolIndex > OPENSSL_OP_NO_PROTOCOL_INDEX_TLSv1) {, +                    minProtocolIndex = OPENSSL_OP_NO_PROTOCOL_INDEX_TLSv1;, +                }, +                if (maxProtocolIndex < OPENSSL_OP_NO_PROTOCOL_INDEX_TLSv1) {, +                    maxProtocolIndex = OPENSSL_OP_NO_PROTOCOL_INDEX_TLSv1;, +                }, +                if (minProtocolIndex > OPENSSL_OP_NO_PROTOCOL_INDEX_TLSv1_1) {, +                    minProtocolIndex = OPENSSL_OP_NO_PROTOCOL_INDEX_TLSv1_1;, +                }, +                if (maxProtocolIndex < OPENSSL_OP_NO_PROTOCOL_INDEX_TLSv1_1) {, +                    maxProtocolIndex = OPENSSL_OP_NO_PROTOCOL_INDEX_TLSv1_1;, +                }, +                if (minProtocolIndex > OPENSSL_OP_NO_PROTOCOL_INDEX_TLSv1_2) {, +                    minProtocolIndex = OPENSSL_OP_NO_PROTOCOL_INDEX_TLSv1_2;, +                }, +                if (maxProtocolIndex < OPENSSL_OP_NO_PROTOCOL_INDEX_TLSv1_2) {, +                    maxProtocolIndex = OPENSSL_OP_NO_PROTOCOL_INDEX_TLSv1_2;, +                }, +                for (int i = 0; i < minProtocolIndex; ++i) {, +                    opts |= OPENSSL_OP_NO_PROTOCOLS[i];, +                assert maxProtocolIndex != MAX_VALUE;, +                for (int i = maxProtocolIndex + 1; i < OPENSSL_OP_NO_PROTOCOLS.length; ++i) {, +                    opts |= OPENSSL_OP_NO_PROTOCOLS[i];, +++ b/handler/src/main/java/io/netty/handler/ssl/ReferenceCountedOpenSslEngine.java, +    private static final int OPENSSL_OP_NO_PROTOCOL_INDEX_SSLV2 = 0;, +    private static final int OPENSSL_OP_NO_PROTOCOL_INDEX_SSLV3 = 1;, +    private static final int OPENSSL_OP_NO_PROTOCOL_INDEX_TLSv1 = 2;, +    private static final int OPENSSL_OP_NO_PROTOCOL_INDEX_TLSv1_1 = 3;, +    private static final int OPENSSL_OP_NO_PROTOCOL_INDEX_TLSv1_2 = 4;, +    private static final int[] OPENSSL_OP_NO_PROTOCOLS = new int[] {, +            SSL.SSL_OP_NO_SSLv2,, +            SSL.SSL_OP_NO_SSLv3,, +            SSL.SSL_OP_NO_TLSv1,, +            SSL.SSL_OP_NO_TLSv1_1,, +            SSL.SSL_OP_NO_TLSv1_2, +    };, +    /**, +     * {@inheritDoc}, +     * TLS doesn't support a way to advertise non-contiguous versions from the client's perspective, and the client, +     * just advertises the max supported version. The TLS protocol also doesn't support all different combinations of, +     * discrete protocols, and instead assumes contiguous ranges. OpenSSL has some unexpected behavior, +     * (e.g. handshake failures) if non-contiguous protocols are used even where there is a compatible set of protocols, +     * and ciphers. For these reasons this method will determine the minimum protocol and the maximum protocol and, +     * enabled a contiguous range from [min protocol, max protocol] in OpenSSL., +     */, +        int minProtocolIndex = OPENSSL_OP_NO_PROTOCOLS.length;, +        int maxProtocolIndex = 0;, +                if (minProtocolIndex > OPENSSL_OP_NO_PROTOCOL_INDEX_SSLV2) {, +                    minProtocolIndex = OPENSSL_OP_NO_PROTOCOL_INDEX_SSLV2;, +                }, +                if (maxProtocolIndex < OPENSSL_OP_NO_PROTOCOL_INDEX_SSLV2) {, +                    maxProtocolIndex = OPENSSL_OP_NO_PROTOCOL_INDEX_SSLV2;, +                }, +                if (minProtocolIndex > OPENSSL_OP_NO_PROTOCOL_INDEX_SSLV3) {, +                    minProtocolIndex = OPENSSL_OP_NO_PROTOCOL_INDEX_SSLV3;, +                }, +                if (maxProtocolIndex < OPENSSL_OP_NO_PROTOCOL_INDEX_SSLV3) {, +                    maxProtocolIndex = OPENSSL_OP_NO_PROTOCOL_INDEX_SSLV3;, +                }, +                if (minProtocolIndex > OPENSSL_OP_NO_PROTOCOL_INDEX_TLSv1) {, +                    minProtocolIndex = OPENSSL_OP_NO_PROTOCOL_INDEX_TLSv1;, +                }, +                if (maxProtocolIndex < OPENSSL_OP_NO_PROTOCOL_INDEX_TLSv1) {, +                    maxProtocolIndex = OPENSSL_OP_NO_PROTOCOL_INDEX_TLSv1;]