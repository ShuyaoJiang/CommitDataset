[+++ b/common/src/main/java/io/netty/util/ThreadDeathWatcher.java, +import java.util.concurrent.TimeUnit;, +    private static volatile Thread watcherThread;, +            ThreadDeathWatcher.watcherThread = watcherThread;, +    /**, +     * Waits until the thread of this watcher has no threads to watch and terminates itself., +     * Because a new watcher thread will be started again on {@link #watch(Thread, Runnable)},, +     * this operation is only useful when you want to ensure that the watcher thread is terminated, +     * <strong>after</strong> your application is shut down and there's no chance of calling, +     * {@link #watch(Thread, Runnable)} afterwards., +     *, +     * @return {@code true} if and only if the watcher thread has been terminated, +     */, +    public boolean awaitInactivity(long timeout, TimeUnit unit) throws InterruptedException {, +        if (unit == null) {, +            throw new NullPointerException("unit");, +        }, +, +        Thread watcherThread = ThreadDeathWatcher.watcherThread;, +        if (watcherThread != null) {, +            watcherThread.join(unit.toMillis(timeout));, +        }, +        return !watcherThread.isAlive();, +    }, +, +++ b/common/src/main/java/io/netty/util/ThreadDeathWatcher.java, +import java.util.concurrent.TimeUnit;, +    private static volatile Thread watcherThread;, +            ThreadDeathWatcher.watcherThread = watcherThread;, +    /**, +     * Waits until the thread of this watcher has no threads to watch and terminates itself., +     * Because a new watcher thread will be started again on {@link #watch(Thread, Runnable)},, +     * this operation is only useful when you want to ensure that the watcher thread is terminated, +     * <strong>after</strong> your application is shut down and there's no chance of calling, +     * {@link #watch(Thread, Runnable)} afterwards., +     *, +     * @return {@code true} if and only if the watcher thread has been terminated, +     */, +    public boolean awaitInactivity(long timeout, TimeUnit unit) throws InterruptedException {, +        if (unit == null) {, +            throw new NullPointerException("unit");, +        }, +, +        Thread watcherThread = ThreadDeathWatcher.watcherThread;, +        if (watcherThread != null) {, +            watcherThread.join(unit.toMillis(timeout));, +        }, +        return !watcherThread.isAlive();, +    }, +, +++ b/common/src/main/java/io/netty/util/concurrent/GlobalEventExecutor.java, +import java.util.concurrent.atomic.AtomicBoolean;, +    final BlockingQueue<Runnable> taskQueue = new LinkedBlockingQueue<Runnable>();, +    private final AtomicBoolean started = new AtomicBoolean();, +        BlockingQueue<Runnable> taskQueue = this.taskQueue;, +    /**, +     * Waits until the worker thread of this executor has no tasks left in its task queue and terminates itself., +     * Because a new worker thread will be started again when a new task is submitted, this operation is only useful, +     * when you want to ensure that the worker thread is terminated <strong>after</strong> your application is shut, +     * down and there's no chance of submitting a new task afterwards., +     *, +     * @return {@code true} if and only if the worker thread has been terminated, +     */, +    public boolean awaitInactivity(long timeout, TimeUnit unit) throws InterruptedException {, +        if (unit == null) {, +            throw new NullPointerException("unit");, +        }, +, +        Thread thread = this.thread;, +        if (thread != null) {, +            thread.join(unit.toMillis(timeout));, +        }, +        return !thread.isAlive();, +    }, +, +        if (started.compareAndSet(false, true)) {, +            Thread t = threadFactory.newThread(taskRunner);, +            t.start();, +            thread = t;, +                    // Mark the current thread as stopped., +                    // The following CAS must always success and must be uncontended,, +                    // because only one thread should be running at the same time., +                    boolean stopped = started.compareAndSet(true, false);, +                    assert stopped;, +, +                    // Check if there are pending entries added by execute() or schedule*() while we do CAS above., +                    if (taskQueue.isEmpty() && delayedTaskQueue.size() == 1) {, +                        // A) No new task was added and thus there's nothing to handle, +                        //    -> safe to terminate because there's nothing left to do, +                        // B) A new thread started and handled all the new tasks., +                        //    -> safe to terminate the new thread will take care the rest, +, +                    // There are pending tasks added again., +                    if (!started.compareAndSet(false, true)) {, +                        // startThread() started a new thread and set 'started' to true., +                        // -> terminate this thread so that the new thread reads from taskQueue exclusively., +                        break;, +, +                    // New tasks were added, but this worker was faster to set 'started' to true., +                    // i.e. a new worker thread was not started by startThread().]