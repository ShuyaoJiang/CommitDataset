[+++ /dev/null, +++ /dev/null, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2StreamFrameToHttpObjectCodec.java, +/*, + * Copyright 2016 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + *   http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the, + * License for the specific language governing permissions and limitations, + * under the License., + */, +, +package io.netty.handler.codec.http2;, +, +import io.netty.buffer.ByteBufAllocator;, +import io.netty.buffer.Unpooled;, +import io.netty.channel.Channel;, +import io.netty.channel.ChannelHandler;, +import io.netty.channel.ChannelHandlerContext;, +import io.netty.handler.codec.MessageToMessageCodec;, +import io.netty.handler.codec.http.DefaultHttpContent;, +import io.netty.handler.codec.http.DefaultLastHttpContent;, +import io.netty.handler.codec.http.FullHttpMessage;, +import io.netty.handler.codec.http.HttpContent;, +import io.netty.handler.codec.http.HttpHeaderNames;, +import io.netty.handler.codec.http.HttpHeaderValues;, +import io.netty.handler.codec.http.HttpMessage;, +import io.netty.handler.codec.http.HttpObject;, +import io.netty.handler.codec.http.HttpRequest;, +import io.netty.handler.codec.http.HttpScheme;, +import io.netty.handler.codec.http.HttpUtil;, +import io.netty.handler.codec.http.HttpVersion;, +import io.netty.handler.codec.http.LastHttpContent;, +import io.netty.handler.ssl.SslHandler;, +import io.netty.util.ReferenceCountUtil;, +import io.netty.util.internal.UnstableApi;, +, +import java.util.List;, +, +/**, + * This handler converts from {@link Http2StreamFrame} to {@link HttpObject},, + * and back. It can be used as an adapter in conjunction with {@link, + * Http2MultiplexCodec} to make http/2 connections backward-compatible with, + * {@link ChannelHandler}s expecting {@link HttpObject}, + *, + * For simplicity, it converts to chunked encoding unless the entire stream, + * is a single header., + */, +@UnstableApi, +public class Http2StreamFrameToHttpObjectCodec extends MessageToMessageCodec<Http2StreamFrame, HttpObject> {, +    private final boolean isServer;, +    private final boolean validateHeaders;, +, +    private HttpScheme scheme;, +, +    public Http2StreamFrameToHttpObjectCodec(final boolean isServer,, +                                             final boolean validateHeaders) {, +        this.isServer = isServer;, +        this.validateHeaders = validateHeaders;, +        scheme = HttpScheme.HTTP;, +    }, +, +    public Http2StreamFrameToHttpObjectCodec(final boolean isServer) {, +        this(isServer, true);, +    }, +, +    @Override, +    public boolean acceptInboundMessage(Object msg) throws Exception {, +        return (msg instanceof Http2HeadersFrame) || (msg instanceof Http2DataFrame);, +    }, +, +    @Override, +    protected void decode(ChannelHandlerContext ctx, Http2StreamFrame frame, List<Object> out) throws Exception {, +        if (frame instanceof Http2HeadersFrame) {, +            int id = 0; // not really the id, +            Http2HeadersFrame headersFrame = (Http2HeadersFrame) frame;, +            Http2Headers headers = headersFrame.headers();, +, +            if (headersFrame.isEndStream()) {, +                if (headers.method() == null && headers.status() == null) {, +                    LastHttpContent last = new DefaultLastHttpContent(Unpooled.EMPTY_BUFFER, validateHeaders);, +                    HttpConversionUtil.addHttp2ToHttpHeaders(id, headers, last.trailingHeaders(),, +                                                             HttpVersion.HTTP_1_1, true, true);, +                    out.add(last);, +                } else {, +                    FullHttpMessage full = newFullMessage(id, headers, ctx.alloc());, +                    out.add(full);, +                }, +            } else {, +                HttpMessage req = newMessage(id, headers);, +                if (!HttpUtil.isContentLengthSet(req)) {, +                    req.headers().add(HttpHeaderNames.TRANSFER_ENCODING, HttpHeaderValues.CHUNKED);, +                }]