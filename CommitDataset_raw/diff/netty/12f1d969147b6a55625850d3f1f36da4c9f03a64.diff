[+++ b/buffer/src/main/java/io/netty/buffer/AbstractMessageBuf.java, +import io.netty.util.internal.PlatformDependent;, +, +import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;, +    @SuppressWarnings("rawtypes"), +    private static final AtomicIntegerFieldUpdater<AbstractMessageBuf> refCntUpdater =, +            AtomicIntegerFieldUpdater.newUpdater(AbstractMessageBuf.class, "refCnt");, +, +    private static final long REFCNT_FIELD_OFFSET;, +, +    static {, +        long refCntFieldOffset = -1;, +        try {, +            if (PlatformDependent.hasUnsafe()) {, +                refCntFieldOffset = PlatformDependent.objectFieldOffset(AbstractMessageBuf.class.getDeclaredField("refCnt"));, +            }, +        } catch (Throwable ignored) { }, +, +        REFCNT_FIELD_OFFSET = refCntFieldOffset;, +    }, +, +, +    @SuppressWarnings("FieldMayBeFinal"), +    private volatile int refCnt = 1;, +        if (REFCNT_FIELD_OFFSET >= 0) {, +            // Try to do non-volatile read for performance., +            return PlatformDependent.getInt(this, REFCNT_FIELD_OFFSET);, +        } else {, +    }, +    public MessageBuf<T> retain() {, +        for (;;) {, +            if (refCnt == 0) {, +            if (refCntUpdater.compareAndSet(this, refCnt, refCnt + 1)) {, +                break;, +            }, +        }, +    public MessageBuf<T> retain(int increment) {, +        for (;;) {, +            if (refCnt == 0) {, +            if (refCntUpdater.compareAndSet(this, refCnt, refCnt + increment)) {, +                break;, +            }, +        }, +        for (;;) {, +            if (refCnt == 0) {, +            if (refCntUpdater.compareAndSet(this, refCnt, refCnt - 1)) {, +                if (refCnt == 1) {, +        }, +    }, +        for (;;) {, +            if (refCntUpdater.compareAndSet(this, refCnt, refCnt - decrement)) {, +                if (refCnt == decrement) {, +        }, +    }, +++ b/buffer/src/main/java/io/netty/buffer/AbstractMessageBuf.java, +import io.netty.util.internal.PlatformDependent;, +, +import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;, +    @SuppressWarnings("rawtypes"), +    private static final AtomicIntegerFieldUpdater<AbstractMessageBuf> refCntUpdater =, +            AtomicIntegerFieldUpdater.newUpdater(AbstractMessageBuf.class, "refCnt");, +, +    private static final long REFCNT_FIELD_OFFSET;, +, +    static {, +        long refCntFieldOffset = -1;, +        try {, +            if (PlatformDependent.hasUnsafe()) {, +                refCntFieldOffset = PlatformDependent.objectFieldOffset(AbstractMessageBuf.class.getDeclaredField("refCnt"));, +            }, +        } catch (Throwable ignored) { }, +, +        REFCNT_FIELD_OFFSET = refCntFieldOffset;, +    }, +, +, +    @SuppressWarnings("FieldMayBeFinal"), +    private volatile int refCnt = 1;, +        if (REFCNT_FIELD_OFFSET >= 0) {, +            // Try to do non-volatile read for performance., +            return PlatformDependent.getInt(this, REFCNT_FIELD_OFFSET);, +        } else {, +    }, +    public MessageBuf<T> retain() {, +        for (;;) {, +            if (refCnt == 0) {, +            if (refCntUpdater.compareAndSet(this, refCnt, refCnt + 1)) {, +                break;, +            }, +        }, +    public MessageBuf<T> retain(int increment) {, +        for (;;) {, +            if (refCnt == 0) {, +            if (refCntUpdater.compareAndSet(this, refCnt, refCnt + increment)) {, +                break;, +            }, +        }, +        for (;;) {, +            if (refCnt == 0) {, +            if (refCntUpdater.compareAndSet(this, refCnt, refCnt - 1)) {]