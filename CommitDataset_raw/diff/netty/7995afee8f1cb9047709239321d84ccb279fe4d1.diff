[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpClientCodec.java, +            if (statusCode == 100 || statusCode == 101) {, +                // 100-continue and 101 switching protocols response should be excluded from paired comparison., +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpClientCodec.java, +            if (statusCode == 100 || statusCode == 101) {, +                // 100-continue and 101 switching protocols response should be excluded from paired comparison., +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectDecoder.java, +     * Returns true if the server switched to a different protocol than HTTP/1.0 or HTTP/1.1, e.g. HTTP/2 or Websocket., +     * Returns false if the upgrade happened in a different layer, e.g. upgrade from HTTP/1.1 to HTTP/1.1 over TLS., +     */, +    protected boolean isSwitchingToNonHttp1Protocol(HttpResponse msg) {, +        if (msg.status().code() != HttpResponseStatus.SWITCHING_PROTOCOLS.code()) {, +            return false;, +        }, +        String newProtocol = msg.headers().get(HttpHeaderNames.UPGRADE);, +        return newProtocol == null ||, +                !newProtocol.contains(HttpVersion.HTTP_1_0.text()) &&, +                !newProtocol.contains(HttpVersion.HTTP_1_1.text());, +    }, +, +    /**, +            if (res != null && isSwitchingToNonHttp1Protocol(res)) {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpClientCodec.java, +            if (statusCode == 100 || statusCode == 101) {, +                // 100-continue and 101 switching protocols response should be excluded from paired comparison., +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectDecoder.java, +     * Returns true if the server switched to a different protocol than HTTP/1.0 or HTTP/1.1, e.g. HTTP/2 or Websocket., +     * Returns false if the upgrade happened in a different layer, e.g. upgrade from HTTP/1.1 to HTTP/1.1 over TLS., +     */, +    protected boolean isSwitchingToNonHttp1Protocol(HttpResponse msg) {, +        if (msg.status().code() != HttpResponseStatus.SWITCHING_PROTOCOLS.code()) {, +            return false;, +        }, +        String newProtocol = msg.headers().get(HttpHeaderNames.UPGRADE);, +        return newProtocol == null ||, +                !newProtocol.contains(HttpVersion.HTTP_1_0.text()) &&, +                !newProtocol.contains(HttpVersion.HTTP_1_1.text());, +    }, +, +    /**, +            if (res != null && isSwitchingToNonHttp1Protocol(res)) {, +++ b/codec-http/src/test/java/io/netty/handler/codec/http/HttpClientCodecTest.java, +, +    @Test, +    public void testDecodesFinalResponseAfterSwitchingProtocols() {, +        String SWITCHING_PROTOCOLS_RESPONSE = "HTTP/1.1 101 Switching Protocols\r\n" +, +                "Connection: Upgrade\r\n" +, +                "Upgrade: TLS/1.2, HTTP/1.1\r\n\r\n";, +, +        HttpClientCodec codec = new HttpClientCodec(4096, 8192, 8192, true);, +        EmbeddedChannel ch = new EmbeddedChannel(codec, new HttpObjectAggregator(1024));, +, +        HttpRequest request = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.GET, "http://localhost/");, +        request.headers().set(HttpHeaderNames.CONNECTION, HttpHeaderValues.UPGRADE);, +        request.headers().set(HttpHeaderNames.UPGRADE, "TLS/1.2");, +        assertTrue("Channel outbound write failed.", ch.writeOutbound(request));, +, +        assertTrue("Channel inbound write failed.",, +                ch.writeInbound(Unpooled.copiedBuffer(SWITCHING_PROTOCOLS_RESPONSE, CharsetUtil.ISO_8859_1)));, +        Object switchingProtocolsResponse = ch.readInbound();, +        assertNotNull("No response received", switchingProtocolsResponse);, +        assertThat("Response was not decoded", switchingProtocolsResponse, instanceOf(FullHttpResponse.class));, +        ((FullHttpResponse) switchingProtocolsResponse).release();, +, +        assertTrue("Channel inbound write failed",, +                ch.writeInbound(Unpooled.copiedBuffer(RESPONSE, CharsetUtil.ISO_8859_1)));, +        Object finalResponse = ch.readInbound();, +        assertNotNull("No response received", finalResponse);, +        assertThat("Response was not decoded", finalResponse, instanceOf(FullHttpResponse.class));, +        ((FullHttpResponse) finalResponse).release();, +        assertTrue("Channel finish failed", ch.finishAndReleaseAll());, +    }]