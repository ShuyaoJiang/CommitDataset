[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2ConnectionDecoder.java, +                    lifecycleManager.closeStreamRemote(stream, ctx.newSucceededFuture());, +                lifecycleManager.closeStreamRemote(stream, ctx.newSucceededFuture());, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2ConnectionDecoder.java, +                    lifecycleManager.closeStreamRemote(stream, ctx.newSucceededFuture());, +                lifecycleManager.closeStreamRemote(stream, ctx.newSucceededFuture());, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2ConnectionEncoder.java, +        return lifecycleManager.resetStream(ctx, streamId, errorCode, promise);, +        return lifecycleManager.goAway(ctx, lastStreamId, errorCode, debugData, promise);, +                lifecycleManager.closeStreamLocal(stream, promise);, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2ConnectionDecoder.java, +                    lifecycleManager.closeStreamRemote(stream, ctx.newSucceededFuture());, +                lifecycleManager.closeStreamRemote(stream, ctx.newSucceededFuture());, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2ConnectionEncoder.java, +        return lifecycleManager.resetStream(ctx, streamId, errorCode, promise);, +        return lifecycleManager.goAway(ctx, lastStreamId, errorCode, debugData, promise);, +                lifecycleManager.closeStreamLocal(stream, promise);, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2ConnectionHandler.java, +        ChannelFuture future = goAway(ctx, null);, +    public void closeStreamLocal(Http2Stream stream, ChannelFuture future) {, +    public void closeStreamRemote(Http2Stream stream, ChannelFuture future) {, +        goAway(ctx, http2Ex).addListener(new ClosingChannelFutureListener(ctx, ctx.newPromise()));, +        resetStream(ctx, http2Ex.streamId(), http2Ex.error().code(), ctx.newPromise());, +    public ChannelFuture resetStream(final ChannelHandlerContext ctx, int streamId, long errorCode,, +    public ChannelFuture goAway(ChannelHandlerContext ctx, int lastStreamId, long errorCode,, +            ByteBuf debugData, ChannelPromise promise) {, +     * Close the remote endpoint with with a {@code GO_AWAY} frame., +    private ChannelFuture goAway(ChannelHandlerContext ctx, Http2Exception cause) {, +        return goAway(ctx, lastKnownStream, errorCode, debugData, ctx.newPromise());, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2ConnectionDecoder.java, +                    lifecycleManager.closeStreamRemote(stream, ctx.newSucceededFuture());, +                lifecycleManager.closeStreamRemote(stream, ctx.newSucceededFuture());, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2ConnectionEncoder.java, +        return lifecycleManager.resetStream(ctx, streamId, errorCode, promise);, +        return lifecycleManager.goAway(ctx, lastStreamId, errorCode, debugData, promise);, +                lifecycleManager.closeStreamLocal(stream, promise);, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2ConnectionHandler.java, +        ChannelFuture future = goAway(ctx, null);, +    public void closeStreamLocal(Http2Stream stream, ChannelFuture future) {, +    public void closeStreamRemote(Http2Stream stream, ChannelFuture future) {, +        goAway(ctx, http2Ex).addListener(new ClosingChannelFutureListener(ctx, ctx.newPromise()));, +        resetStream(ctx, http2Ex.streamId(), http2Ex.error().code(), ctx.newPromise());, +    public ChannelFuture resetStream(final ChannelHandlerContext ctx, int streamId, long errorCode,, +    public ChannelFuture goAway(ChannelHandlerContext ctx, int lastStreamId, long errorCode,, +            ByteBuf debugData, ChannelPromise promise) {, +     * Close the remote endpoint with with a {@code GO_AWAY} frame., +    private ChannelFuture goAway(ChannelHandlerContext ctx, Http2Exception cause) {, +        return goAway(ctx, lastKnownStream, errorCode, debugData, ctx.newPromise());, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2LifecycleManager.java, +     * Closes the local side of the {@code stream}. Depending on the {@code stream} state this may result in, +     * {@code stream} being closed. See {@link closeStream(Http2Stream, ChannelFuture)}., +     * @param future See {@link closeStream(Http2Stream, ChannelFuture)}., +    void closeStreamLocal(Http2Stream stream, ChannelFuture future);, +     * Closes the remote side of the {@code stream}. Depending on the {@code stream} state this may result in, +     * {@code stream} being closed. See {@link closeStream(Http2Stream, ChannelFuture)}., +     * @param future See {@link closeStream(Http2Stream, ChannelFuture)}., +    void closeStreamRemote(Http2Stream stream, ChannelFuture future);, +     * Closes and deactivates the given {@code stream}. A listener is also attached to {@code future} and upon, +     * completion the underlying channel will be closed if {@link Http2Connection#numActiveStreams()} is 0., +     * @param stream the stream to be closed and deactivated., +     * @param future when completed if {@link Http2Connection#numActiveStreams()} is 0 then the underlying channel, +     * will be closed., +     * Ensure the stream identified by {@code streamId} is reset. If our local state does not indicate the stream has, +     * been reset yet then a {@code RST_STREAM} will be sent to the peer. If our local state indicates the stream, +     * has already been reset then the return status will indicate success without sending anything to the peer., +     * @param ctx The context used for communication and buffer allocation if necessary., +     * @param streamId The identifier of the stream to reset., +     * @param errorCode Justification as to why this stream is being reset. See {@link Http2Error}., +     * @param promise Used to indicate the return status of this operation., +     * @return Will be considered successful when the connection and stream state has been updated, and a, +     * {@code RST_STREAM} frame has been sent to the peer. If the stream state has already been updated and a, +     * {@code RST_STREAM} frame has been sent then the return status may indicate success immediately., +    ChannelFuture resetStream(ChannelHandlerContext ctx, int streamId, long errorCode,, +     * Close the connection and prevent the peer from creating streams. After this call the peer, +     * is not allowed to create any new streams and the local endpoint will be limited to creating streams with, +     * {@code stream identifier <= lastStreamId}. This may result in sending a {@code GO_AWAY} frame (assuming we, +     * have not already sent one with {@code Last-Stream-ID <= lastStreamId}), or may just return success if a, +     * {@code GO_AWAY} has previously been sent., +     * @param ctx The context used for communication and buffer allocation if necessary., +     * @param lastStreamId The last stream that the local endpoint is claiming it will accept., +     * @param errorCode The rational as to why the connection is being closed. See {@link Http2Error}., +     * @param debugData For diagnostic purposes (carries no semantic value)., +     * @param promise Used to indicate the return status of this operation., +     * @return Will be considered successful when the connection and stream state has been updated, and a, +     * {@code GO_AWAY} frame has been sent to the peer. If the stream state has already been updated and a, +     * {@code GO_AWAY} frame has been sent then the return status may indicate success immediately., +    ChannelFuture goAway(ChannelHandlerContext ctx, int lastStreamId, long errorCode,, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2ConnectionDecoder.java, +                    lifecycleManager.closeStreamRemote(stream, ctx.newSucceededFuture());, +                lifecycleManager.closeStreamRemote(stream, ctx.newSucceededFuture());, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2ConnectionEncoder.java, +        return lifecycleManager.resetStream(ctx, streamId, errorCode, promise);, +        return lifecycleManager.goAway(ctx, lastStreamId, errorCode, debugData, promise);, +                lifecycleManager.closeStreamLocal(stream, promise);, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2ConnectionHandler.java, +        ChannelFuture future = goAway(ctx, null);, +    public void closeStreamLocal(Http2Stream stream, ChannelFuture future) {, +    public void closeStreamRemote(Http2Stream stream, ChannelFuture future) {, +        goAway(ctx, http2Ex).addListener(new ClosingChannelFutureListener(ctx, ctx.newPromise()));, +        resetStream(ctx, http2Ex.streamId(), http2Ex.error().code(), ctx.newPromise());]