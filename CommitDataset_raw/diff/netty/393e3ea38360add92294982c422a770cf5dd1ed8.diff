[+++ b/handler/src/main/java/io/netty/handler/ssl/JdkSslContext.java, +++ b/handler/src/main/java/io/netty/handler/ssl/JdkSslContext.java, +++ b/handler/src/main/java/io/netty/handler/ssl/JdkSslServerContext.java, +, +++ b/handler/src/main/java/io/netty/handler/ssl/JdkSslContext.java, +++ b/handler/src/main/java/io/netty/handler/ssl/JdkSslServerContext.java, +, +++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslClientContext.java, +import io.netty.buffer.ByteBuf;, +import io.netty.buffer.ByteBufInputStream;, +import io.netty.util.internal.logging.InternalLogger;, +import io.netty.util.internal.logging.InternalLoggerFactory;, +import org.apache.tomcat.jni.CertificateVerifier;, +import javax.security.auth.x500.X500Principal;, +import java.io.IOException;, +import java.security.KeyStoreException;, +import java.security.NoSuchAlgorithmException;, +import java.security.cert.CertificateException;, +import java.security.cert.X509Certificate;, +    private static final InternalLogger logger = InternalLoggerFactory.getInstance(OpenSslClientContext.class);, +                    // Set up trust manager factory to use our key store., +                    if (trustManagerFactory == null) {, +                        trustManagerFactory = TrustManagerFactory.getInstance(, +                                TrustManagerFactory.getDefaultAlgorithm());, +                    }, +                    final X509TrustManager manager = chooseTrustManager(trustManagerFactory.getTrustManagers());, +, +                    SSLContext.setCertVerifyCallback(ctx, new CertificateVerifier() {, +                        @Override, +                        public boolean verify(long ssl, byte[][] chain, String auth) {, +                            X509Certificate[] peerCerts = certificates(chain);, +                            try {, +                                manager.checkServerTrusted(peerCerts, auth);, +                                return true;, +                                logger.debug("verification of certificate failed", e);, +                            return false;, +                    });, +                } catch (Exception e) {, +                    throw new SSLException("unable to setup trustmanager", e);, +    private static void initTrustManagerFactory(File certChainFile, TrustManagerFactory trustManagerFactory), +            throws KeyStoreException, CertificateException, NoSuchAlgorithmException, IOException {, +        KeyStore ks = KeyStore.getInstance("JKS");, +        ks.load(null, null);, +        if (certChainFile != null) {, +            ByteBuf[] certs = PemReader.readCertificates(certChainFile);, +            try {, +                for (ByteBuf buf: certs) {, +                    X509Certificate cert = (X509Certificate) X509_CERT_FACTORY.generateCertificate(, +                            new ByteBufInputStream(buf));, +                    X500Principal principal = cert.getSubjectX500Principal();, +                    ks.setCertificateEntry(principal.getName("RFC2253"), cert);, +                }, +            } finally {, +                for (ByteBuf buf: certs) {, +                    buf.release();, +                }, +            }, +        }, +        trustManagerFactory.init(ks);, +    }, +, +            return new OpenSslEngine(ctx, alloc, null, isClient());, +            return new OpenSslEngine(ctx, alloc, protos.get(protos.size() - 1), isClient());, +++ b/handler/src/main/java/io/netty/handler/ssl/JdkSslContext.java, +++ b/handler/src/main/java/io/netty/handler/ssl/JdkSslServerContext.java, +, +++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslClientContext.java, +import io.netty.buffer.ByteBuf;, +import io.netty.buffer.ByteBufInputStream;, +import io.netty.util.internal.logging.InternalLogger;, +import io.netty.util.internal.logging.InternalLoggerFactory;, +import org.apache.tomcat.jni.CertificateVerifier;, +import javax.security.auth.x500.X500Principal;, +import java.io.IOException;, +import java.security.KeyStoreException;, +import java.security.NoSuchAlgorithmException;, +import java.security.cert.CertificateException;, +import java.security.cert.X509Certificate;, +    private static final InternalLogger logger = InternalLoggerFactory.getInstance(OpenSslClientContext.class);, +                    // Set up trust manager factory to use our key store., +                    if (trustManagerFactory == null) {, +                        trustManagerFactory = TrustManagerFactory.getInstance(, +                                TrustManagerFactory.getDefaultAlgorithm());, +                    }, +                    final X509TrustManager manager = chooseTrustManager(trustManagerFactory.getTrustManagers());, +, +                    SSLContext.setCertVerifyCallback(ctx, new CertificateVerifier() {, +                        @Override, +                        public boolean verify(long ssl, byte[][] chain, String auth) {, +                            X509Certificate[] peerCerts = certificates(chain);, +                            try {, +                                manager.checkServerTrusted(peerCerts, auth);, +                                return true;, +                                logger.debug("verification of certificate failed", e);, +                            return false;, +                    });, +                } catch (Exception e) {, +                    throw new SSLException("unable to setup trustmanager", e);, +    private static void initTrustManagerFactory(File certChainFile, TrustManagerFactory trustManagerFactory), +            throws KeyStoreException, CertificateException, NoSuchAlgorithmException, IOException {]