[+++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslEngine.java, +import javax.net.ssl.SSLEngineResult.HandshakeStatus;, +    private enum HandshakeState {, +         * Not started yet., +        NOT_STARTED,, +        /**, +         * Started via unwrap/wrap., +         */, +        STARTED_IMPLICITLY,, +        /**, +         * Started via {@link #beginHandshake()}., +         */, +        STARTED_EXPLICITLY,, +, +        /**, +         * Handshake is finished., +         */, +        FINISHED, +    }, +, +    private HandshakeState handshakeState = HandshakeState.NOT_STARTED;, +        if (handshakeState != HandshakeState.NOT_STARTED) {, +, +        // On shutdown clear all errors, +        SSL.clearError();, +        return sslWrote;, +        final int netWrote;, +            netWrote = SSL.writeToBIO(networkBIO, addr, len);, +                netWrote = SSL.writeToBIO(networkBIO, addr, len);, +        return netWrote;, +        final int sslRead;, +            sslRead = SSL.readFromSSL(ssl, addr, len);, +                sslRead = SSL.readFromSSL(ssl, addr, len);, +        return sslRead;, +        final int bioRead;, +, +            bioRead = SSL.readFromBIO(networkBIO, addr, pending);, +                bioRead = SSL.readFromBIO(networkBIO, addr, pending);, +        return bioRead;, +    }, +, +    private SSLEngineResult readPendingBytesFromBIO(ByteBuffer dst, int bytesConsumed, int bytesProduced), +            throws SSLException {, +        // Check to see if the engine wrote data into the network BIO, +        int pendingNet = SSL.pendingWrittenBytesInBIO(networkBIO);, +        if (pendingNet > 0) {, +, +            // Do we have enough room in dst to write encrypted data?, +            int capacity = dst.remaining();, +            if (capacity < pendingNet) {, +                return new SSLEngineResult(BUFFER_OVERFLOW, mayFinishHandshake(getHandshakeStatus(pendingNet)),, +                                           bytesConsumed, bytesProduced);, +            }, +, +            // Write the pending data from the network BIO into the dst buffer, +            int produced = readEncryptedData(dst, pendingNet);, +, +            if (produced <= 0) {, +                // We ignore BIO_* errors here as we use in memory BIO anyway and will do another SSL_* call later, +                // on in which we will produce an exception in case of an error, +                SSL.clearError();, +            } else {, +                bytesProduced += produced;, +                pendingNet -= produced;, +            }, +            // If isOuboundDone is set, then the data from the network BIO, +            // was the close_notify message -- we are not required to wait, +            // for the receipt the peer's close_notify message -- shutdown., +            if (isOutboundDone) {, +                shutdown();, +            }, +, +            return new SSLEngineResult(getEngineStatus(), mayFinishHandshake(getHandshakeStatus(pendingNet)),, +                                       bytesConsumed, bytesProduced);, +        }, +        return null;, +        if (handshakeState != HandshakeState.FINISHED) {, +            if (handshakeState != HandshakeState.STARTED_EXPLICITLY) {, +                // Update accepted so we know we triggered the handshake via wrap, +                handshakeState = HandshakeState.STARTED_IMPLICITLY;, +            HandshakeStatus status = handshake();, +            if (status == NEED_UNWRAP) {, +, +                int result = writePlaintextData(src);, +                if (result > 0) {, +                    bytesConsumed += result;, +                } else {, +                    int sslError = SSL.getError(ssl, result);, +                    switch (sslError) {, +                    case SSL.SSL_ERROR_ZERO_RETURN:, +                        // This means the connection was shutdown correctly, close inbound and outbound, +                        if (!receivedShutdown) {, +                            closeAll();, +                        // fall-trough!, +                    case SSL.SSL_ERROR_WANT_READ:, +                    case SSL.SSL_ERROR_WANT_WRITE:, +                        // Break here as this means we need check if there is something pending in the BIO, +                        break;, +                    default:, +                        // Everything else is considered as error]