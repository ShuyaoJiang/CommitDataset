[+++ b/src/docbook/module/start.xml, +      this chapter are only two; the latest version of Netty and JDK 1.5 or, +      <ulink url="&Downloads;">the project download page</ulink>.  To download, +      the right version of JDK, please refer to your preferred JDK vendor's web, +      To implement the DISCARD protocol, you only need to log the received data., +      Let us start straight from the handler implementation, which handles I/O, +      events generated by Netty., +          <classname>DiscardServerHandler</classname> does not manage any, +          stateful information, and therefore it is annotated with the value, +          handler methods that you can override.  For now, it is just enough, +          from a client.  In this example, we ignore the received data by doing, +          nothing to implement the DISCARD protocol., +      So far so good.  We have implemented the first half of the DISCARD server., +      which starts the server with the <classname>DiscardServerHandler</classname>., +          that it does not create I/O threads by itself.  It is supposed to, +          set up the server using a &Channel; directly.  However, please note, +          that this is a tedious process and you do not need to do that in most, +          cases., +          of the options of the &ServerSocketChannel;.  You could do the, +          following to set the options of the &ServerSocketChannel;:, +          of all NICs (network interface cards) in the machine.  You can now, +          call the <methodname>bind</methodname> method as many times as, +          you want (with different bind addresses.) , +      Now that we have written our first server, we need to test if it really, +      works.  The easiest way to test it is to use the <command>telnet</command>, +      However, can we say that the server is working fine?  We cannot really, +      know that because it is a discard server.  You will not get any response, +      at all.  To prove it is really working, let us modify the server to print, +      what it has received., +      will be invoked.  Let us put some code into the, +          <classname>ByteBuffer</classname>, but it is easier to use and more, +      however, is usually supposed to respond to a request.  Let us learn how to, +      printing the received data out to the console.  Therefore, it is enough, +      again to modify the <methodname>messageReceived</methodname> method:, +      as soon as a connection is established, we cannot use the, +      The following is the implementation:, +          be invoked when a connection is established.  Let us write the 32-bit, +          lot of useful methods related to the &ChannelBuffer;.  For more, +          information, please refer to the API reference., +          On the other hand, it is a good idea to use static imports for, +          message in NIO?  &ChannelBuffer; does not have such a method because, +          a &ChannelBuffer; while the reader index does not change.  The reader, +          In contrast, NIO buffer does not provide a clean way to figure out, +          be sent.  Such an error does not happen in Netty because we have, +          I/O operation which has not yet occurred.  It means, any requested, +          operation has been done.  Please note that, <methodname>close</methodname>, +          This is as simple as adding a &ChannelFutureListener; to the returned, +      because a human cannot translate a 32-bit binary data into a date on a, +      calendar.  In this section, we discuss how to make sure the server works, +      correctly and learn how to write a client with Netty., +          A client-side &SocketChannel; does not have a parent., +      As you can see, it is not really different from the server side startup., +      What about the &ChannelHandler; implementation?  It should receive a, +      32-bit integer from the server, translate it into a human readable format,, +      print the translated time, and close the connection:, +      It looks very simple and does not look any different from the server side, +      <exceptionname>IndexOutOfBoundsException</exceptionname>.  We discuss why, +      this happens in the next section., +        let us assume you have received three packets:, +        because of the packet fragmentation, a server can receive them as, +        follows:, +        Therefore, a receiving part, regardless it is server-side or client-side,, +        Now let us get back to the TIME client example.  We have the same problem, +        fragmentation will increase as the traffic increases., +        wait until all 4 bytes are received into the internal buffer.  The, +        following is the modified <classname>TimeClientHandler</classname>, +        implementation that fixes the problem:, +            the content of the <varname>buf</varname> will be corrupted. , +        There's another place that needs a fix.  Do you remember that we, +        multiple &Channel;s and consequently the data will be corrupted.  To, +        Now let us replace the following lines of <classname>TimeClient</classname>:, +        client, the modified handler does not look that clean.  Imagine a more, +        As you may have noticed, you can add more than one &ChannelHandler; to, +        a &ChannelPipeline;, and therefore, you can split one monolithic, +        &ChannelHandler; into multiple modular ones to reduce the complexity of, +        your application.  For example, you could split, +        <classname>TimeClientHandler</classname> into two handlers:, +            enough data yet.  &FrameDecoder; will call again when there is a, +            sufficient amount of data., +        If you are an adventurous person, you might want to try the, +        you to implement most protocols very easily and helps you avoid from, +        Please refer to the following packages for more detailed examples:, +      All the examples we have reviewed so far used a &ChannelBuffer; as a, +      primary data structure of a protocol message.  In this section, we will, +      improve the TIME protocol client and server example to use a , +      32-bit integer and it is not a major issue to use &ChannelBuffer; directly., +      First, let us define a new type called <classname>UnixTime</classname>., +      does not use &ChannelBuffer; anymore:, +      the server side.  Let us update the, +          On the other hand, it is a good idea to use static imports for, +      into the &ChannelPipeline; on the server side, and it is left as a, +      In this chapter, we had a quick tour of Netty with a demonstration on how, +      to write a network application on top of Netty.  More questions you may, +      have will be covered in the upcoming chapters and the revised version of, +      this chapter.  Please also note that <ulink url="&Community;">the Netty, +      project community</ulink> is always here to help you.]