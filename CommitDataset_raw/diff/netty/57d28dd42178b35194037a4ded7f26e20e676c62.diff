[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/HttpToHttp2ConnectionHandler.java, +import io.netty.buffer.ByteBuf;, +import io.netty.handler.codec.http.HttpContent;, +import io.netty.handler.codec.http.HttpMessage;, +import io.netty.handler.codec.http.LastHttpContent;, +import io.netty.util.ReferenceCountUtil;, +, +    private int currentStreamId;, +, +     * Handles conversion of {@link HttpMessage} and {@link HttpContent} to HTTP/2 frames., +, +        if (!(msg instanceof HttpMessage || msg instanceof HttpContent)) {, +            ctx.write(msg, promise);, +            return;, +        }, +, +        boolean release = true;, +        SimpleChannelPromiseAggregator promiseAggregator =, +                new SimpleChannelPromiseAggregator(promise, ctx.channel(), ctx.executor());, +            Http2ConnectionEncoder encoder = encoder();, +            boolean endStream = false;, +            if (msg instanceof HttpMessage) {, +                final HttpMessage httpMsg = (HttpMessage) msg;, +, +                currentStreamId = getStreamId(httpMsg.headers());, +                endStream = msg instanceof FullHttpMessage && !((FullHttpMessage) msg).content().isReadable();, +                encoder.writeHeaders(ctx, currentStreamId, http2Headers, 0, endStream, promiseAggregator.newPromise());, +            }, +            if (!endStream && msg instanceof HttpContent) {, +                boolean isLastContent = false;, +                Http2Headers trailers = EmptyHttp2Headers.INSTANCE;, +                if (msg instanceof LastHttpContent) {, +                    isLastContent = true;, +, +                    // Convert any trailing headers., +                    final LastHttpContent lastContent = (LastHttpContent) msg;, +                    trailers = HttpUtil.toHttp2Headers(lastContent.trailingHeaders());, +                }, +, +                // Write the data, +                final ByteBuf content = ((HttpContent) msg).content();, +                endStream = isLastContent && trailers.isEmpty();, +                release = false;, +                encoder.writeData(ctx, currentStreamId, content, 0, endStream, promiseAggregator.newPromise());, +, +                if (!trailers.isEmpty()) {, +                    // Write trailing headers., +                    encoder.writeHeaders(ctx, currentStreamId, trailers, 0, true, promiseAggregator.newPromise());, +                }, +            }, +, +            if (release) {, +                ReferenceCountUtil.release(msg);, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/HttpToHttp2ConnectionHandler.java, +import io.netty.buffer.ByteBuf;, +import io.netty.handler.codec.http.HttpContent;, +import io.netty.handler.codec.http.HttpMessage;, +import io.netty.handler.codec.http.LastHttpContent;, +import io.netty.util.ReferenceCountUtil;, +, +    private int currentStreamId;, +, +     * Handles conversion of {@link HttpMessage} and {@link HttpContent} to HTTP/2 frames., +, +        if (!(msg instanceof HttpMessage || msg instanceof HttpContent)) {, +            ctx.write(msg, promise);, +            return;, +        }, +, +        boolean release = true;, +        SimpleChannelPromiseAggregator promiseAggregator =, +                new SimpleChannelPromiseAggregator(promise, ctx.channel(), ctx.executor());, +            Http2ConnectionEncoder encoder = encoder();, +            boolean endStream = false;, +            if (msg instanceof HttpMessage) {, +                final HttpMessage httpMsg = (HttpMessage) msg;, +, +                currentStreamId = getStreamId(httpMsg.headers());, +                endStream = msg instanceof FullHttpMessage && !((FullHttpMessage) msg).content().isReadable();, +                encoder.writeHeaders(ctx, currentStreamId, http2Headers, 0, endStream, promiseAggregator.newPromise());, +            }, +            if (!endStream && msg instanceof HttpContent) {, +                boolean isLastContent = false;, +                Http2Headers trailers = EmptyHttp2Headers.INSTANCE;, +                if (msg instanceof LastHttpContent) {, +                    isLastContent = true;, +, +                    // Convert any trailing headers., +                    final LastHttpContent lastContent = (LastHttpContent) msg;, +                    trailers = HttpUtil.toHttp2Headers(lastContent.trailingHeaders());, +                }, +, +                // Write the data, +                final ByteBuf content = ((HttpContent) msg).content();, +                endStream = isLastContent && trailers.isEmpty();, +                release = false;, +                encoder.writeData(ctx, currentStreamId, content, 0, endStream, promiseAggregator.newPromise());, +, +                if (!trailers.isEmpty()) {, +                    // Write trailing headers.]