[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2ConnectionHandler.java, +import static io.netty.buffer.ByteBufUtil.hexDump;, +import static io.netty.handler.codec.http2.Http2FrameTypes.SETTINGS;, +import static java.lang.Math.min;, +                if (readClientPrefaceString(in) && verifyFirstFrameIsSettings(in)) {, +                    byteDecoder = new FrameDecoder();, +                    byteDecoder.decode(ctx, in, out);, +            int bytesRead = min(in.readableBytes(), prefaceRemaining);, +                String receivedBytes = hexDump(in, in.readerIndex(),, +                        min(in.readableBytes(), clientPrefaceString.readableBytes()));, +                throw connectionError(PROTOCOL_ERROR, "HTTP/2 client preface string missing or corrupt. " +, +                        "Hex dump for received bytes: %s", receivedBytes);, +         * Peeks at that the next frame in the buffer and verifies that it is a {@code SETTINGS} frame., +         *, +         * @param in the inbound buffer., +         * @return {@code} true if the next frame is a {@code SETTINGS} frame, {@code false} if more, +         * data is required before we can determine the next frame type., +         * @throws Http2Exception thrown if the next frame is NOT a {@code SETTINGS} frame., +         */, +        private boolean verifyFirstFrameIsSettings(ByteBuf in) throws Http2Exception {, +            if (in.readableBytes() < 4) {, +                // Need more data before we can see the frame type for the first frame., +                return false;, +            }, +, +            byte frameType = in.getByte(in.readerIndex() + 3);, +            if (frameType != SETTINGS) {, +                throw connectionError(PROTOCOL_ERROR, "First received frame was not SETTINGS. " +, +                        "Hex dump for first 4 bytes: %s", hexDump(in, in.readerIndex(), 4));, +            }, +            return true;, +        }, +, +        /**, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2ConnectionHandler.java, +import static io.netty.buffer.ByteBufUtil.hexDump;, +import static io.netty.handler.codec.http2.Http2FrameTypes.SETTINGS;, +import static java.lang.Math.min;, +                if (readClientPrefaceString(in) && verifyFirstFrameIsSettings(in)) {, +                    byteDecoder = new FrameDecoder();, +                    byteDecoder.decode(ctx, in, out);, +            int bytesRead = min(in.readableBytes(), prefaceRemaining);, +                String receivedBytes = hexDump(in, in.readerIndex(),, +                        min(in.readableBytes(), clientPrefaceString.readableBytes()));, +                throw connectionError(PROTOCOL_ERROR, "HTTP/2 client preface string missing or corrupt. " +, +                        "Hex dump for received bytes: %s", receivedBytes);, +         * Peeks at that the next frame in the buffer and verifies that it is a {@code SETTINGS} frame., +         *, +         * @param in the inbound buffer., +         * @return {@code} true if the next frame is a {@code SETTINGS} frame, {@code false} if more, +         * data is required before we can determine the next frame type., +         * @throws Http2Exception thrown if the next frame is NOT a {@code SETTINGS} frame., +         */, +        private boolean verifyFirstFrameIsSettings(ByteBuf in) throws Http2Exception {, +            if (in.readableBytes() < 4) {, +                // Need more data before we can see the frame type for the first frame., +                return false;, +            }, +, +            byte frameType = in.getByte(in.readerIndex() + 3);, +            if (frameType != SETTINGS) {, +                throw connectionError(PROTOCOL_ERROR, "First received frame was not SETTINGS. " +, +                        "Hex dump for first 4 bytes: %s", hexDump(in, in.readerIndex(), 4));, +            }, +            return true;, +        }, +, +        /**, +++ b/codec-http2/src/test/java/io/netty/handler/codec/http2/Http2ConnectionHandlerTest.java, +import static org.mockito.Mockito.atLeastOnce;, +, +import java.util.List;, +, +    public void serverReceivingClientPrefaceStringFollowedByNonSettingsShouldHandleException(), +            throws Exception {, +, +        // Create a connection preface followed by a bunch of zeros (i.e. not a settings frame)., +        ByteBuf buf = Unpooled.buffer().writeBytes(connectionPrefaceBuf()).writeZero(10);, +        handler.channelRead(ctx, buf);, +        ArgumentCaptor<ByteBuf> captor = ArgumentCaptor.forClass(ByteBuf.class);, +        verify(frameWriter, atLeastOnce()).writeGoAway(eq(ctx), eq(0), eq(PROTOCOL_ERROR.code()),, +                captor.capture(), eq(promise));, +        assertEquals(0, captor.getValue().refCnt());, +    public void serverReceivingValidClientPrefaceStringShouldContinueReadingFrames() throws Exception {, +        ByteBuf prefacePlusSome = addSettingsHeader(Unpooled.buffer().writeBytes(connectionPrefaceBuf()));, +        handler.channelRead(ctx, prefacePlusSome);, +        verify(decoder, atLeastOnce()).decodeFrame(any(ChannelHandlerContext.class),, +        handler.channelRead(ctx, preface);, +        ByteBuf prefacePlusSome = addSettingsHeader(Unpooled.buffer().writeBytes(connectionPrefaceBuf()));, +        verify(decoder, atLeastOnce()).decodeFrame(eq(ctx), any(ByteBuf.class), Matchers.<List<Object>>any());, +            .writeRstStream(any(ChannelHandlerContext.class), anyInt(), anyLong(),, +                    any(ChannelPromise.class));, +        verify(frameWriter).writeRstStream(eq(ctx), eq(STREAM_ID), anyLong(),, +                any(ChannelPromise.class));, +        verify(frameWriter).writeGoAway(eq(ctx), eq(STREAM_ID), eq(errorCode), eq(data),, +                eq(promise));, +        verify(frameWriter).writeGoAway(eq(ctx), eq(STREAM_ID + 2), eq(errorCode), eq(data),, +                eq(promise));, +, +    private ByteBuf addSettingsHeader(ByteBuf buf) {]