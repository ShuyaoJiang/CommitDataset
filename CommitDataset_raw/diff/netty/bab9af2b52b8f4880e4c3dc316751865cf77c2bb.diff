[+++ b/src/main/java/org/jboss/netty/handler/queue/BlockingReadHandler.java, +import java.io.IOException;, +import org.jboss.netty.channel.ChannelEvent;, +import org.jboss.netty.channel.ExceptionEvent;, + * {@code messageReceived} event and an {@code exceptionCaught} event, hence it, + * should be placed in the last place in a pipeline., + * } catch (IOException e) {, + *     // Other read errors, +    private final BlockingQueue<ChannelEvent> queue;, +        this(new LinkedTransferQueue<ChannelEvent>());, +    public BlockingReadHandler(BlockingQueue<ChannelEvent> queue) {, +    protected BlockingQueue<ChannelEvent> getQueue() {, +     * @throws IOException, +     *         if failed to receive a new message, +    public E read() throws IOException, InterruptedException {, +        ChannelEvent e = readEvent();, +        if (e == null) {, +        if (e instanceof MessageEvent) {, +            return getMessage((MessageEvent) e);, +        } else if (e instanceof ExceptionEvent) {, +            throw (IOException) new IOException().initCause(((ExceptionEvent) e).getCause());, +        } else {, +            throw new IllegalStateException();, +        }, +     * @throws IOException, +     *         if failed to receive a new message, +    public E read(long timeout, TimeUnit unit) throws IOException, InterruptedException {, +        ChannelEvent e = readEvent(timeout, unit);, +        if (e == null) {, +            return null;, +        }, +, +        if (e instanceof MessageEvent) {, +            return getMessage((MessageEvent) e);, +        } else if (e instanceof ExceptionEvent) {, +            throw (IOException) new IOException().initCause(((ExceptionEvent) e).getCause());, +        } else {, +            throw new IllegalStateException();, +        }, +    }, +, +    /**, +     * Waits until a new {@link ChannelEvent} is received or the associated, +     * {@link Channel} is closed., +     *, +     * @return a {@link MessageEvent} or an {@link ExceptionEvent}., +     *         {@code null} if the associated {@link Channel} has been closed, +     * @throws InterruptedException, +     *         if the operation has been interrupted, +     */, +    public ChannelEvent readEvent() throws InterruptedException {, +        return getQueue().take();, +    }, +, +    /**, +     * Waits until a new {@link ChannelEvent} is received or the associated, +     * {@link Channel} is closed., +     *, +     * @param timeout, +     *        the amount time to wait until a new {@link ChannelEvent} is, +     *        received.  If no message is received within the timeout,, +     *        {@link BlockingReadTimeoutException} is thrown., +     * @param unit, +     *        the unit of {@code timeout}, +     *, +     * @return a {@link MessageEvent} or an {@link ExceptionEvent}., +     *         {@code null} if the associated {@link Channel} has been closed, +     * @throws BlockingReadTimeoutException, +     *         if no event was received within the specified timeout, +     * @throws InterruptedException, +     *         if the operation has been interrupted, +     */, +    public ChannelEvent readEvent(long timeout, TimeUnit unit) throws InterruptedException, BlockingReadTimeoutException {, +        detectDeadLock();, +        if (isClosed()) {, +            if (getQueue().isEmpty()) {, +                return null;, +            }, +        }, +, +        ChannelEvent e = getQueue().poll(timeout, unit);, +        if (e == null) {, +            return e;, +        getQueue().put(e);, +    @Override, +    public void exceptionCaught(ChannelHandlerContext ctx, ExceptionEvent e), +            throws Exception {, +        getQueue().put(e);, +    }, +, +]