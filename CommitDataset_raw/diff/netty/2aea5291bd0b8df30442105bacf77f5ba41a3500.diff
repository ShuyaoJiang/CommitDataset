[+++ b/handler/src/main/java/io/netty/handler/ssl/SslHandler.java, +import io.netty.channel.ChannelInboundHandlerContext;, +    , +    // TODO: Fix STARTTLS, +    private boolean firstMessageSend;, +                return handshakeFuture;, +                if (ctx.executor().inEventLoop()) {, +                        wrapNonAppData(ctx, channel);, +                        , +                        exception = e;, +                    }, +                    , +                } else {, +                    ctx.executor().execute(new Runnable() {, +                        , +                        @Override, +                        public void run() {, +                            Throwable exception = null;, +                            synchronized (handshakeLock) {, +                                try {, +                                    , +                                    engine.beginHandshake();, +                                    runDelegatedTasks();, +                                    wrapNonAppData(ctx, ctx.channel());, +                                    , +                                } catch (Exception e) {, +                            if (exception != null) { // Failed to initiate handshake., +                                handshakeFuture.setFailure(exception);, +                                ctx.fireExceptionCaught(exception);, +                            }                 , +                        }, +                    });, +        }, +, +        if (exception != null) { // Failed to initiate handshake., +            handshakeFuture.setFailure(exception);, +            ctx.fireExceptionCaught(exception);, +            ctx.fireExceptionCaught(e);, +            return channel.newFailedFuture(e);, +    public void disconnect(final ChannelOutboundHandlerContext<Byte> ctx,, +            final ChannelFuture future) throws Exception {, +        closeOutboundAndChannel(ctx, future, true);, +    public void close(final ChannelOutboundHandlerContext<Byte> ctx,, +            final ChannelFuture future) throws Exception {, +        closeOutboundAndChannel(ctx, future, false);, +        ByteBuffer outNetBuf = bufferPool.acquireBuffer();, +        boolean success = true;, +        boolean needsUnwrap = false;, +        try {, +            ByteBuffer outAppBuf = in.nioBuffer();, +, +            while(in.readable()) {, +                , +                int read;, +                int remaining = outAppBuf.remaining();, +                SSLEngineResult result = null;, +, +                synchronized (handshakeLock) {, +                    result = engine.wrap(outAppBuf, outNetBuf);, +                }, +                read = remaining - outAppBuf.remaining();, +                in.readerIndex(in.readerIndex() + read);, +                    , +                , +, +                if (result.bytesProduced() > 0) {, +                    outNetBuf.flip();, +                    out.writeBytes(outNetBuf);, +                    outNetBuf.clear();, +                    , +, +                } else if (result.getStatus() == Status.CLOSED) {, +                    // SSLEngine has been closed already., +                    // Any further write attempts should be denied., +                    success = false;, +                    break;, +                    final HandshakeStatus handshakeStatus = result.getHandshakeStatus();, +                    handleRenegotiation(handshakeStatus);, +                    switch (handshakeStatus) {, +                    case NEED_WRAP:, +                        if (outAppBuf.hasRemaining()) {, +                            break;, +                        } else {, +                            break;, +                    case NEED_UNWRAP:, +                        needsUnwrap = true;, +                    case NEED_TASK:, +                        runDelegatedTasks();, +                        break;, +                    case FINISHED:, +                    case NOT_HANDSHAKING:, +                        if (handshakeStatus == HandshakeStatus.FINISHED) {, +                            setHandshakeSuccess(ctx.channel());, +                        }, +                        if (result.getStatus() == Status.CLOSED) {, +                            success = false;, +                        }, +                        break;, +                    default:, +                        throw new IllegalStateException("Unknown handshake status: " + handshakeStatus);]