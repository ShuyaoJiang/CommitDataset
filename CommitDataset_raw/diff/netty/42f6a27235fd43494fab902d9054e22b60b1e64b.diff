[+++ b/pom.xml, +            <ignore>java.net.StandardSocketOptions</ignore>, +            <ignore>java.net.SocketOption</ignore>, +++ b/pom.xml, +            <ignore>java.net.StandardSocketOptions</ignore>, +            <ignore>java.net.SocketOption</ignore>, +++ b/transport/src/main/java/io/netty/channel/socket/aio/AioServerSocketChannel.java, +            config.active(channel);, +++ b/pom.xml, +            <ignore>java.net.StandardSocketOptions</ignore>, +            <ignore>java.net.SocketOption</ignore>, +++ b/transport/src/main/java/io/netty/channel/socket/aio/AioServerSocketChannel.java, +            config.active(channel);, +++ b/transport/src/main/java/io/netty/channel/socket/aio/AioServerSocketChannelConfig.java, +import java.net.SocketOption;, +import java.util.concurrent.ConcurrentHashMap;, +import java.util.concurrent.atomic.AtomicReference;, +    private final AtomicReference<AsynchronousServerSocketChannel> channel, +            = new AtomicReference<AsynchronousServerSocketChannel>();, +    private Map<SocketOption<?>, Object> options = new ConcurrentHashMap<SocketOption<?>, Object>();, +    private static final int DEFAULT_SND_BUF_SIZE = 32 * 1024;, +    private static final boolean DEFAULT_SO_REUSEADDR = false;, +    AioServerSocketChannelConfig(AsynchronousServerSocketChannel channel) {, +        this.channel.set(channel);, +    }, +, +        return (Boolean) getOption(StandardSocketOptions.SO_REUSEADDR, DEFAULT_SO_REUSEADDR);, +        setOption(StandardSocketOptions.SO_REUSEADDR, reuseAddress);, +        return (Integer) getOption(StandardSocketOptions.SO_RCVBUF, DEFAULT_SND_BUF_SIZE);, +        setOption(StandardSocketOptions.SO_RCVBUF, receiveBufferSize);, +, +    private Object getOption(SocketOption option, Object defaultValue) {, +        if (channel.get() == null) {, +            Object value = options.get(option);, +            if (value == null) {, +                return defaultValue;, +            } else {, +                return value;, +            }, +        }, +, +        try {, +            return channel.get().getOption(option);, +        } catch (IOException e) {, +            throw new ChannelException(e);, +        }, +    }, +, +    private void setOption(SocketOption option, Object defaultValue) {, +        if (channel.get() == null) {, +            options.put(option, defaultValue);, +            return;, +        }, +        try {, +            channel.get().setOption(option, defaultValue);, +        } catch (IOException e) {, +            throw new ChannelException(e);, +        }, +    }, +, +    void active(AsynchronousServerSocketChannel channel) {, +        if (channel == null) {, +            throw new NullPointerException("channel");, +        }, +        if (this.channel.compareAndSet(null, channel)) {, +            propagateOptions();, +        }, +    }, +, +    private void propagateOptions() {, +        for (SocketOption option: options.keySet()) {, +            Object value = options.remove(option);, +            if (value != null) {, +                try {, +                    channel.get().setOption(option, value);, +                } catch (IOException e) {, +                    throw new ChannelException(e);, +                }, +            }, +        }, +        // not needed anymore, +        options = null;, +    }, +++ b/pom.xml, +            <ignore>java.net.StandardSocketOptions</ignore>, +            <ignore>java.net.SocketOption</ignore>, +++ b/transport/src/main/java/io/netty/channel/socket/aio/AioServerSocketChannel.java, +            config.active(channel);, +++ b/transport/src/main/java/io/netty/channel/socket/aio/AioServerSocketChannelConfig.java, +import java.net.SocketOption;, +import java.util.concurrent.ConcurrentHashMap;, +import java.util.concurrent.atomic.AtomicReference;, +    private final AtomicReference<AsynchronousServerSocketChannel> channel, +            = new AtomicReference<AsynchronousServerSocketChannel>();, +    private Map<SocketOption<?>, Object> options = new ConcurrentHashMap<SocketOption<?>, Object>();, +    private static final int DEFAULT_SND_BUF_SIZE = 32 * 1024;, +    private static final boolean DEFAULT_SO_REUSEADDR = false;, +    AioServerSocketChannelConfig(AsynchronousServerSocketChannel channel) {, +        this.channel.set(channel);, +    }]