[+++ b/testsuite/src/test/java/io/netty/testsuite/transport/socket/SocketGatheringWriteTest.java, +        testGatheringWrite0(sb, cb, data, false, true);, +        testGatheringWrite0(sb, cb, data, false, false);, +        testGatheringWrite0(sb, cb, data, true, false);, +        testGatheringWrite0(sb, cb, data, true, true);, +    }, +, +    // Test for https://github.com/netty/netty/issues/2647, +    @Test(timeout = 30000), +    public void testGatheringWriteBig() throws Throwable {, +        run();, +    }, +, +    public void testGatheringWriteBig(ServerBootstrap sb, Bootstrap cb) throws Throwable {, +        byte[] bigData = new byte[1024 * 1024 * 50];, +        random.nextBytes(bigData);, +        testGatheringWrite0(sb, cb, bigData, false, true);, +            ServerBootstrap sb, Bootstrap cb, byte[] data, boolean composite, boolean autoRead) throws Throwable {, +            int length = Math.min(random.nextInt(1024 * 8), data.length - i);, +++ b/testsuite/src/test/java/io/netty/testsuite/transport/socket/SocketGatheringWriteTest.java, +        testGatheringWrite0(sb, cb, data, false, true);, +        testGatheringWrite0(sb, cb, data, false, false);, +        testGatheringWrite0(sb, cb, data, true, false);, +        testGatheringWrite0(sb, cb, data, true, true);, +    }, +, +    // Test for https://github.com/netty/netty/issues/2647, +    @Test(timeout = 30000), +    public void testGatheringWriteBig() throws Throwable {, +        run();, +    }, +, +    public void testGatheringWriteBig(ServerBootstrap sb, Bootstrap cb) throws Throwable {, +        byte[] bigData = new byte[1024 * 1024 * 50];, +        random.nextBytes(bigData);, +        testGatheringWrite0(sb, cb, bigData, false, true);, +            ServerBootstrap sb, Bootstrap cb, byte[] data, boolean composite, boolean autoRead) throws Throwable {, +            int length = Math.min(random.nextInt(1024 * 8), data.length - i);, +++ b/transport-native-epoll/src/main/c/io_netty_channel_epoll_Native.c, +    // Calculate maximal size of iov, +    //, +    // See https://github.com/netty/netty/issues/2647, +    int iovLen = IOV_MAX < length ? IOV_MAX : length;, +    struct iovec iov[iovLen];, +    jlong w = 0;, +    while (length > 0) {, +        int loop = IOV_MAX < length ? IOV_MAX : length;, +        int num = offset + loop;, +        for (i = offset; i < num; i++) {, +        jlong res = writev0(env, clazz, fd, iov, loop);, +            return res < 0 ? res : w;, +        w += res;, +        offset += loop;, +        length -= loop;, +, +        for (a = 0; a < loop; a++) {, +            if (len > written) {, +, +                // incomplete write which means the channel is not writable anymore. Return now!, +                return w;, +            } else {, +                incrementPosition(env, bufObj, len);, +                // Explicit delete local reference as otherwise the local references will only be released once the native method returns., +                // Also there may be a lot of these and JNI specification only specify that 16 must be able to be created., +                //, +                // See https://github.com/netty/netty/issues/2623, +                 (*env)->DeleteLocalRef(env, bufObj);, +                written -= len;, +, +        }, +    }, +    return w;, +    // Calculate maximal size of iov, +    //, +    // See https://github.com/netty/netty/issues/2647, +    int iovLen = IOV_MAX < length ? IOV_MAX : length;, +    struct iovec iov[iovLen];, +    jlong w = 0;, +    while (length > 0) {, +        int loop = IOV_MAX < length ? IOV_MAX : length;, +        int num = offset + loop;, +        for (i = offset; i < num; i++) {, +        jlong res = writev0(env, clazz, fd, iov, loop);, +            return res < 0 ? res : w;, +, +        w += res;, +        offset += loop;, +        length -= loop;, +, +        // update the position of the written buffers, +        int written = res;, +        int a;, +        for (a = 0; a < loop; a++) {, +            int len = iov[a].iov_len;, +            if (len > written) {, +                // incomplete write which means the channel is not writable anymore. Return now!, +                return w;, +            }, +            written -= len;, +        }]