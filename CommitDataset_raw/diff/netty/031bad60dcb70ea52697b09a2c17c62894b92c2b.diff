[+++ b/common/src/main/java/io/netty/util/internal/ObjectCleaner.java, +import io.netty.util.internal.logging.InternalLogger;, +import io.netty.util.internal.logging.InternalLoggerFactory;, +                    final AutomaticCleanerReference reference;, +                        reference = (AutomaticCleanerReference) REFERENCE_QUEUE.remove(REFERENCE_QUEUE_POLL_TIMEOUT_MS);, +                        continue;, +                    }, +                    if (reference != null) {, +                        try {, +                            reference.cleanup();, +                        } catch (Throwable ignored) {, +                            // ignore exceptions, and don't log in case the logger throws an exception, blocks, or has, +                            // other unexpected side effects., +                        }, +                        LIVE_SET.remove(reference);, +++ b/common/src/main/java/io/netty/util/internal/ObjectCleaner.java, +import io.netty.util.internal.logging.InternalLogger;, +import io.netty.util.internal.logging.InternalLoggerFactory;, +                    final AutomaticCleanerReference reference;, +                        reference = (AutomaticCleanerReference) REFERENCE_QUEUE.remove(REFERENCE_QUEUE_POLL_TIMEOUT_MS);, +                        continue;, +                    }, +                    if (reference != null) {, +                        try {, +                            reference.cleanup();, +                        } catch (Throwable ignored) {, +                            // ignore exceptions, and don't log in case the logger throws an exception, blocks, or has, +                            // other unexpected side effects., +                        }, +                        LIVE_SET.remove(reference);, +++ b/common/src/test/java/io/netty/util/internal/ObjectCleanerTest.java, +import java.util.concurrent.atomic.AtomicInteger;, +, +import static org.junit.Assert.assertEquals;, +    private Object temporaryObject;, +, +    @Test(timeout = 5000), +    public void testCleanupContinuesDespiteThrowing() throws InterruptedException {, +        final AtomicInteger freeCalledCount = new AtomicInteger();, +        final CountDownLatch latch = new CountDownLatch(1);, +        temporaryThread = new Thread(new Runnable() {, +            @Override, +            public void run() {, +                try {, +                    latch.await();, +                } catch (InterruptedException ignore) {, +                    // just ignore, +                }, +            }, +        });, +        temporaryThread.start();, +        temporaryObject = new Object();, +        ObjectCleaner.register(temporaryThread, new Runnable() {, +            @Override, +            public void run() {, +                freeCalledCount.incrementAndGet();, +                throw new RuntimeException("expected");, +            }, +        });, +        ObjectCleaner.register(temporaryObject, new Runnable() {, +            @Override, +            public void run() {, +                freeCalledCount.incrementAndGet();, +                throw new RuntimeException("expected");, +            }, +        });, +, +        latch.countDown();, +        temporaryThread.join();, +        assertEquals(0, freeCalledCount.get());, +, +        // Null out the temporary object to ensure it is enqueued for GC., +        temporaryThread = null;, +        temporaryObject = null;, +, +        while (freeCalledCount.get() != 2) {, +            System.gc();, +            System.runFinalization();, +            Thread.sleep(100);, +        }, +    }]