[+++ b/handler/src/main/java/io/netty/handler/ssl/JdkSslContext.java, +                // GCM (Galois/Counter Mode) requires JDK 8., +                "TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256",, +                // AES256 requires JCE unlimited strength jurisdiction policy files., +                // GCM (Galois/Counter Mode) requires JDK 8., +                "TLS_RSA_WITH_AES_128_GCM_SHA256",, +                // AES256 requires JCE unlimited strength jurisdiction policy files., +++ b/handler/src/main/java/io/netty/handler/ssl/JdkSslContext.java, +                // GCM (Galois/Counter Mode) requires JDK 8., +                "TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256",, +                // AES256 requires JCE unlimited strength jurisdiction policy files., +                // GCM (Galois/Counter Mode) requires JDK 8., +                "TLS_RSA_WITH_AES_128_GCM_SHA256",, +                // AES256 requires JCE unlimited strength jurisdiction policy files., +++ b/handler/src/main/java/io/netty/handler/ssl/SslHandler.java, +, +    // BEGIN Platform-dependent flags, +, +    /**, +     * {@code trus} if and only if {@link SSLEngine} expects a direct buffer., +     */, +    private final boolean wantsDirectBuffer;, +    private final boolean wantsLargeOutboundNetworkBuffer;, +    /**, +     * {@code true} if and only if {@link SSLEngine#unwrap(ByteBuffer, ByteBuffer)} expects a heap buffer rather than, +     * a direct buffer.  For an unknown reason, JDK8 SSLEngine causes JVM to crash when its cipher suite uses Galois, +     * Counter Mode (GCM)., +     */, +    private boolean wantsInboundHeapBuffer;, +, +    // END Platform-dependent flags, +, +        wantsDirectBuffer = engine instanceof OpenSslEngine;, +        wantsLargeOutboundNetworkBuffer = !(engine instanceof OpenSslEngine);, +        if (!in0.isDirect()) {, +            ByteBuffer newIn0 = ByteBuffer.allocateDirect(in0.remaining());, +            newIn0.put(in0).flip();, +            in0 = newIn0;, +        }, +, +        // If SSLEngine expects a heap buffer for unwrapping, do the conversion., +        final ByteBuffer oldPacket;, +        final ByteBuf newPacket;, +        final int oldPos = packet.position();, +        if (wantsInboundHeapBuffer && packet.isDirect()) {, +            newPacket = ctx.alloc().heapBuffer(packet.limit() - oldPos);, +            newPacket.writeBytes(packet);, +            oldPacket = packet;, +            packet = newPacket.nioBuffer();, +        } else {, +            oldPacket = null;, +            newPacket = null;, +        }, +, +            // If we converted packet into a heap buffer at the beginning of this method,, +            // we should synchronize the position of the original buffer., +            if (newPacket != null) {, +                oldPacket.position(oldPos + packet.position());, +                newPacket.release();, +            }, +, +        // Work around the JVM crash which occurs when a cipher suite with GCM enabled., +        final String cipherSuite = String.valueOf(engine.getSession().getCipherSuite());, +        if (!wantsDirectBuffer && (cipherSuite.contains("_GCM_") || cipherSuite.contains("-GCM-"))) {, +            wantsInboundHeapBuffer = true;, +        }, +, +, +    private ByteBuf allocate(ChannelHandlerContext ctx, int capacity) {, +        if (wantsDirectBuffer) {, +        if (wantsLargeOutboundNetworkBuffer) {]