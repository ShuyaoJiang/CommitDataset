[+++ b/common/src/main/java/io/netty/util/internal/chmv8/ConcurrentHashMapV8.java, +import java.io.ObjectStreamField;, +import java.lang.reflect.ParameterizedType;, +import java.lang.reflect.Type;, +import java.util.ConcurrentModificationException;, +import java.util.HashMap;, +import java.util.Hashtable;, +import java.util.concurrent.locks.LockSupport;, +import java.util.concurrent.locks.ReentrantLock;, + * ConcurrentModificationException}.  However, iterators are designed, + * hash table. To ameliorate impact, when keys are {@link Comparable},, + * this class may use comparison order among keys to help break ties., + * <p>A {@link Set} projection of a ConcurrentHashMapV8 may be created, + * <em>optional</em> methods of the {@link Map} and {@link Iterator}, + * <p>Like {@link Hashtable} but unlike {@link HashMap}, this class, + * <p>ConcurrentHashMapV8s support a set of sequential and parallel bulk, + * operations that are designed, + * to be safely, and often sensibly, applied even with maps that are, + * being concurrently updated by other threads; for example, when, + * computing a snapshot summary of the values in a shared registry., + * There are three kinds of operation, each with four forms, accepting, + * functions with Keys, Values, Entries, and (Key, Value) arguments, + * and/or return values. Because the elements of a ConcurrentHashMapV8, + * are not ordered in any particular way, and may be processed in, + * different orders in different parallel executions, the correctness, + * of supplied functions should not depend on any ordering, or on any, + * other objects or values that may transiently change while, + * computation is in progress; and except for forEach actions, should, + * ideally be side-effect-free. Bulk operations on {@link java.util.Map.Entry}, + * objects do not support method {@code setValue}., + * </ul>, + *, + * <p>These bulk operations accept a {@code parallelismThreshold}, + * argument. Methods proceed sequentially if the current map size is, + * estimated to be less than the given threshold. Using a value of, + * {@code Long.MAX_VALUE} suppresses all parallelism.  Using a value, + * of {@code 1} results in maximal parallelism by partitioning into, + * enough subtasks to fully utilize the {@link, + * ForkJoinPool#commonPool()} that is used for all parallel, + * computations. Normally, you would initially choose one of these, + * extreme values, and then measure performance of using in-between, + * values that trade off overhead versus throughput., +public class ConcurrentHashMapV8<K,V>, +     * An object for traversing and partitioning elements of a source., +     * This interface provides a subset of the functionality of JDK8, +     * java.util.Spliterator., +    public static interface ConcurrentHashMapSpliterator<T> {, +         * If possible, returns a new spliterator covering, +         * approximately one half of the elements, which will not be, +         * covered by this spliterator. Returns null if cannot be, +         * split., +        ConcurrentHashMapSpliterator<T> trySplit();, +        /**, +         * Returns an estimate of the number of elements covered by, +         * this Spliterator., +         */, +        long estimateSize();, +, +        /** Applies the action to each untraversed element */, +        void forEachRemaining(Action<? super T> action);, +        /** If an element remains, applies the action and returns true. */, +        boolean tryAdvance(Action<? super T> action);, +    // Sams, +    /** Interface describing a void action of one argument */, +    public interface Action<A> { void apply(A a); }, +    /** Interface describing a void action of two arguments */, +    public interface BiAction<A,B> { void apply(A a, B b); }, +    /** Interface describing a function of one argument */, +    public interface Fun<A,T> { T apply(A a); }, +    /** Interface describing a function of two arguments */, +    public interface BiFun<A,B,T> { T apply(A a, B b); }, +    /** Interface describing a function mapping its argument to a double */, +    public interface ObjectToDouble<A> { double apply(A a); }, +    /** Interface describing a function mapping its argument to a long */, +    public interface ObjectToLong<A> { long apply(A a); }, +    /** Interface describing a function mapping its argument to an int */, +    public interface ObjectToInt<A> {int apply(A a); }, +    /** Interface describing a function mapping two arguments to a double */, +    public interface ObjectByObjectToDouble<A,B> { double apply(A a, B b); }, +    /** Interface describing a function mapping two arguments to a long */, +    public interface ObjectByObjectToLong<A,B> { long apply(A a, B b); }, +    /** Interface describing a function mapping two arguments to an int */, +    public interface ObjectByObjectToInt<A,B> {int apply(A a, B b); }, +    /** Interface describing a function mapping two doubles to a double */, +    public interface DoubleByDoubleToDouble { double apply(double a, double b); }, +    /** Interface describing a function mapping two longs to a long */, +    public interface LongByLongToLong { long apply(long a, long b); }, +    /** Interface describing a function mapping two ints to an int */, +    public interface IntByIntToInt { int apply(int a, int b); }, +, +     * This map usually acts as a binned (bucketed) hash table.  Each, +     * key-value mapping is held in a Node.  Most nodes are instances, +     * of the basic Node class with hash, key, value, and next, +     * fields. However, various subclasses exist: TreeNodes are, +     * arranged in balanced trees, not lists.  TreeBins hold the roots, +     * of sets of TreeNodes. ForwardingNodes are placed at the heads, +     * of bins during resizing. ReservationNodes are used as, +     * placeholders while establishing values in computeIfAbsent and, +     * related methods.  The types TreeBin, ForwardingNode, and, +     * ReservationNode do not hold normal user keys, values, or]