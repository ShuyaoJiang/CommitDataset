[+++ b/transport/src/main/java/io/netty/channel/local/LocalChannel.java, +    private volatile boolean registerInProgress;, +            // Store the peer in a local variable as it may be set to null if doClose() is called., +            // Because of this we also set registerInProgress to true as we check for this in doClose() and make sure, +            // we delay the fireChannelInactive() to be fired after the fireChannelActive() and so keep the correct, +            // order of events., +            //, +            // See https://github.com/netty/netty/issues/2144, +            final LocalChannel peer = this.peer;, +            registerInProgress = true;, +                    registerInProgress = false;, +, +            // Also check if the registration was not done yet. In this case we submit the close to the EventLoop, +            // to make sure it is run after the registration completes., +            //, +            // See https://github.com/netty/netty/issues/2144, +            if (eventLoop.inEventLoop() && !registerInProgress) {, +++ b/transport/src/main/java/io/netty/channel/local/LocalChannel.java, +    private volatile boolean registerInProgress;, +            // Store the peer in a local variable as it may be set to null if doClose() is called., +            // Because of this we also set registerInProgress to true as we check for this in doClose() and make sure, +            // we delay the fireChannelInactive() to be fired after the fireChannelActive() and so keep the correct, +            // order of events., +            //, +            // See https://github.com/netty/netty/issues/2144, +            final LocalChannel peer = this.peer;, +            registerInProgress = true;, +                    registerInProgress = false;, +, +            // Also check if the registration was not done yet. In this case we submit the close to the EventLoop, +            // to make sure it is run after the registration completes., +            //, +            // See https://github.com/netty/netty/issues/2144, +            if (eventLoop.inEventLoop() && !registerInProgress) {, +++ b/transport/src/test/java/io/netty/channel/local/LocalChannelTest.java, +import io.netty.channel.ChannelFuture;, +import io.netty.channel.EventLoop;, +import io.netty.channel.SingleThreadEventLoop;, +import java.util.concurrent.Executor;, +import java.util.concurrent.TimeUnit;, +    @Test, +    public void localChannelRaceCondition() throws Exception {, +        final LocalAddress address = new LocalAddress("test");, +        final CountDownLatch closeLatch = new CountDownLatch(1);, +        final EventLoopGroup serverGroup = new DefaultEventLoopGroup(1);, +        final EventLoopGroup clientGroup = new DefaultEventLoopGroup(1) {, +            @Override, +            protected EventLoop newChild(Executor threadFactory, Object... args), +                    throws Exception {, +                return new SingleThreadEventLoop(this, threadFactory, true) {, +                    @Override, +                    protected void run() {, +                        for (;;) {, +                            Runnable task = takeTask();, +                            if (task != null) {, +                                /* Only slow down the anonymous class in LocalChannel#doRegister() */, +                                if (task.getClass().getEnclosingClass() == LocalChannel.class) {, +                                    try {, +                                        closeLatch.await();, +                                    } catch (InterruptedException e) {, +                                        throw new Error(e);, +                                    }, +                                }, +                                task.run();, +                                updateLastExecutionTime();, +                            }, +, +                            if (confirmShutdown()) {, +                                break;, +                            }, +                        }, +                    }, +                };, +            }, +        };, +        try {, +            ServerBootstrap sb = new ServerBootstrap();, +            sb.group(serverGroup)., +                    channel(LocalServerChannel.class)., +                    childHandler(new ChannelInitializer<Channel>() {, +                        @Override, +                        protected void initChannel(Channel ch) throws Exception {, +                            ch.close();, +                            closeLatch.countDown();, +                        }, +                    })., +                    bind(address)., +                    sync();, +            Bootstrap bootstrap = new Bootstrap();, +            bootstrap.group(clientGroup)., +                    channel(LocalChannel.class)., +                    handler(new ChannelInitializer<Channel>() {, +                        @Override, +                        protected void initChannel(Channel ch) throws Exception {, +                            /* Do nothing */, +                        }, +                    });, +            ChannelFuture future = bootstrap.connect(address);, +            assertTrue("Connection should finish, not time out", future.await(200));, +        } finally {]