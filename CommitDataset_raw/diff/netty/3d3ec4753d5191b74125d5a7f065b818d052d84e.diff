[+++ b/transport/src/main/java/io/netty/bootstrap/AbstractBootstrap.java, +import io.netty.util.concurrent.EventExecutor;, +            promise = new PendingRegistrationPromise(channel);, +, +    private static final class PendingRegistrationPromise extends DefaultChannelPromise {, +        private PendingRegistrationPromise(Channel channel) {, +            super(channel);, +        }, +, +        @Override, +        protected EventExecutor executor() {, +            if (isSuccess()) {, +                // If the registration was a success we can just call super.executor() which will return, +                // channel.eventLoop()., +                return super.executor();, +            }, +            // The registration failed so we can only use the GlobalEventExecutor as last resort to notify., +            return GlobalEventExecutor.INSTANCE;, +        }, +    }, +++ b/transport/src/main/java/io/netty/bootstrap/AbstractBootstrap.java, +import io.netty.util.concurrent.EventExecutor;, +            promise = new PendingRegistrationPromise(channel);, +, +    private static final class PendingRegistrationPromise extends DefaultChannelPromise {, +        private PendingRegistrationPromise(Channel channel) {, +            super(channel);, +        }, +, +        @Override, +        protected EventExecutor executor() {, +            if (isSuccess()) {, +                // If the registration was a success we can just call super.executor() which will return, +                // channel.eventLoop()., +                return super.executor();, +            }, +            // The registration failed so we can only use the GlobalEventExecutor as last resort to notify., +            return GlobalEventExecutor.INSTANCE;, +        }, +    }, +++ b/transport/src/test/java/io/netty/bootstrap/BootstrapTest.java, +import io.netty.channel.Channel;, +import io.netty.channel.ChannelFuture;, +import io.netty.channel.ChannelFutureListener;, +import io.netty.channel.ChannelPromise;, +import io.netty.channel.local.LocalEventLoopGroup;, +import io.netty.channel.local.LocalServerChannel;, +import org.junit.Assert;, +import java.util.concurrent.BlockingQueue;, +import java.util.concurrent.LinkedBlockingQueue;, +    @Test, +    public void testLateRegisterSuccess() throws Exception {, +        TestEventLoopGroup group = new TestEventLoopGroup();, +        try {, +            ServerBootstrap bootstrap = new ServerBootstrap();, +            bootstrap.group(group);, +            bootstrap.channel(LocalServerChannel.class);, +            bootstrap.childHandler(new DummyHandler());, +            bootstrap.localAddress(new LocalAddress("1"));, +            ChannelFuture future = bootstrap.bind();, +            Assert.assertFalse(future.isDone());, +            group.promise.setSuccess();, +            final BlockingQueue<Boolean> queue = new LinkedBlockingQueue<Boolean>();, +            future.addListener(new ChannelFutureListener() {, +                @Override, +                public void operationComplete(ChannelFuture future) throws Exception {, +                    queue.add(future.channel().eventLoop().inEventLoop(Thread.currentThread()));, +                }, +            });, +            Assert.assertTrue(queue.take());, +        } finally {, +            group.shutdownGracefully();, +            group.terminationFuture().sync();, +        }, +    }, +, +    private static final class TestEventLoopGroup extends DefaultEventLoopGroup {, +        ChannelPromise promise;, +        TestEventLoopGroup() {, +            super(1);, +        }, +, +        @Override, +        public ChannelFuture register(Channel channel) {, +            super.register(channel).syncUninterruptibly();, +            promise = channel.newPromise();, +            return promise;, +        }, +, +        @Override, +        public ChannelFuture register(Channel channel, ChannelPromise promise) {, +            throw new UnsupportedOperationException();, +        }, +    }, +]