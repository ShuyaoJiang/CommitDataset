[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2Connection.java, +import io.netty.channel.ChannelPromise;, +import io.netty.util.collection.IntObjectMap.PrimitiveEntry;, +import io.netty.util.concurrent.Future;, +import io.netty.util.concurrent.FutureListener;, +import io.netty.util.concurrent.Promise;, +, +import static io.netty.handler.codec.http2.Http2CodecUtil.CONNECTION_STREAM_ID;, +import static io.netty.handler.codec.http2.Http2CodecUtil.DEFAULT_PRIORITY_WEIGHT;, +import static io.netty.handler.codec.http2.Http2CodecUtil.MAX_WEIGHT;, +import static io.netty.handler.codec.http2.Http2CodecUtil.MIN_WEIGHT;, +import static io.netty.handler.codec.http2.Http2Error.INTERNAL_ERROR;, +import static io.netty.handler.codec.http2.Http2Error.PROTOCOL_ERROR;, +import static io.netty.handler.codec.http2.Http2Error.REFUSED_STREAM;, +import static io.netty.handler.codec.http2.Http2Exception.closedStreamError;, +import static io.netty.handler.codec.http2.Http2Exception.connectionError;, +import static io.netty.handler.codec.http2.Http2Exception.streamError;, +import static io.netty.handler.codec.http2.Http2Stream.State.CLOSED;, +import static io.netty.handler.codec.http2.Http2Stream.State.HALF_CLOSED_LOCAL;, +import static io.netty.handler.codec.http2.Http2Stream.State.HALF_CLOSED_REMOTE;, +import static io.netty.handler.codec.http2.Http2Stream.State.IDLE;, +import static io.netty.handler.codec.http2.Http2Stream.State.OPEN;, +import static io.netty.handler.codec.http2.Http2Stream.State.RESERVED_LOCAL;, +import static io.netty.handler.codec.http2.Http2Stream.State.RESERVED_REMOTE;, +import static io.netty.util.internal.ObjectUtil.checkNotNull;, +    Promise<Void> closePromise;, +    /**, +     * Determine if {@link #close(Promise)} has been called and no more streams are allowed to be created., +     */, +    final boolean isClosed() {, +        return closePromise != null;, +    }, +, +    @Override, +    public Future<Void> close(final Promise<Void> promise) {, +        checkNotNull(promise, "promise");, +        // Since we allow this method to be called multiple times, we must make sure that all the promises are notified, +        // when all streams are removed and the close operation completes., +        if (closePromise != null) {, +            if (closePromise == promise) {, +                // Do nothing, +            } else if ((promise instanceof ChannelPromise) && ((ChannelPromise) closePromise).isVoid()) {, +                closePromise = promise;, +            } else {, +                closePromise.addListener(new FutureListener<Void>() {, +                    @Override, +                    public void operationComplete(Future<Void> future) throws Exception {, +                        if (future.isSuccess()) {, +                            promise.trySuccess(null);, +                        } else if (future.isCancelled()) {, +                            promise.cancel(false);, +                        } else {, +                            promise.tryFailure(future.cause());, +                        }, +                    }, +                });, +            }, +        } else {, +            closePromise = promise;, +        }, +        if (isStreamMapEmpty()) {, +            promise.trySuccess(null);, +            return promise;, +        }, +        Iterator<PrimitiveEntry<Http2Stream>> itr = streamMap.entries().iterator();, +        // We must take care while iterating the streamMap as to not modify while iterating in case there are other code, +        // paths iterating over the active streams., +        if (activeStreams.allowModifications()) {, +            while (itr.hasNext()) {, +                Http2Stream stream = itr.next().value();, +                if (stream.id() != CONNECTION_STREAM_ID) {, +                    // If modifications of the activeStream map is allowed, then a stream close operation will also, +                    // modify the streamMap. We must prevent concurrent modifications to the streamMap, so use the, +                    // iterator to remove the current stream., +                    itr.remove();, +                    stream.close();, +                }, +            }, +        } else {, +            while (itr.hasNext()) {, +                Http2Stream stream = itr.next().value();, +                if (stream.id() != CONNECTION_STREAM_ID) {, +                    // We are not allowed to make modifications, so the close calls will be executed after this, +                    // iteration completes., +                    stream.close();, +                }, +            }, +        }, +        return closePromise;, +    }, +, +     * Determine if {@link #streamMap} only contains the connection stream., +     */, +    private boolean isStreamMapEmpty() {, +        return streamMap.size() == 1;, +    }, +, +    /**, +, +            if (closePromise != null && isStreamMapEmpty()) {]