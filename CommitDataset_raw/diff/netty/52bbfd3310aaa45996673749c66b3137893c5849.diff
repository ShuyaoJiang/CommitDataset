[+++ b/transport-native-epoll/pom.xml, +  <properties>, +    <jni.compiler.args.ldflags>LDFLAGS=-Wl,--no-as-needed -lrt</jni.compiler.args.ldflags>, +  </properties>, +, +                <arg>${jni.compiler.args.ldflags}</arg>, +                <arg>${jni.compiler.args.cflags}</arg>, +              <name>jni.compiler.args.cflags</name>, +              <name>jni.compiler.args.cflags</name>, +              <value>${jni.compiler.args.cflags}</value>, +++ b/transport-native-epoll/pom.xml, +  <properties>, +    <jni.compiler.args.ldflags>LDFLAGS=-Wl,--no-as-needed -lrt</jni.compiler.args.ldflags>, +  </properties>, +, +                <arg>${jni.compiler.args.ldflags}</arg>, +                <arg>${jni.compiler.args.cflags}</arg>, +              <name>jni.compiler.args.cflags</name>, +              <name>jni.compiler.args.cflags</name>, +              <value>${jni.compiler.args.cflags}</value>, +++ b/transport-native-epoll/src/main/c/netty_epoll_native.c, +#include <time.h>, +clockid_t epollWaitClock = 0; // initialized in initializeEpollWaitClock, +, +static jboolean initializeEpollWaitClock() {, +  struct timespec ts;, +  // First try to get a monotonic clock, as we effectively measure execution time and don't want the underlying clock, +  // moving unexpectedly/abruptly., +  #ifdef CLOCK_MONOTONIC_COARSE, +  epollWaitClock = CLOCK_MONOTONIC_COARSE;, +  if (clock_gettime(epollWaitClock, &ts) != EINVAL) {, +    return JNI_TRUE;, +  }, +  #endif, +  #ifdef CLOCK_MONOTONIC_RAW, +  epollWaitClock = CLOCK_MONOTONIC_RAW;, +  if (clock_gettime(epollWaitClock, &ts) != EINVAL) {, +    return JNI_TRUE;, +  }, +  #endif, +  #ifdef CLOCK_MONOTONIC, +  epollWaitClock = CLOCK_MONOTONIC;, +  if (clock_gettime(epollWaitClock, &ts) != EINVAL) {, +    return JNI_TRUE;, +  }, +  #endif, +, +  // Fallback to realtime ... in this case we are subject to clock movements on the system., +  #ifdef CLOCK_REALTIME_COARSE, +  epollWaitClock = CLOCK_REALTIME_COARSE;, +  if (clock_gettime(epollWaitClock, &ts) != EINVAL) {, +    return JNI_TRUE;, +  }, +  #endif, +  #ifdef CLOCK_REALTIME, +  epollWaitClock = CLOCK_REALTIME;, +  if (clock_gettime(epollWaitClock, &ts) != EINVAL) {, +    return JNI_TRUE;, +  }, +  #endif, +  fprintf(stderr, "FATAL: could not find a clock for clock_gettime!\n");, +  return JNI_FALSE;, +}, +, +    struct timespec ts;, +    jlong timeBeforeWait, timeNow;, +    int timeDiff, result, err;, +    clock_gettime(epollWaitClock, &ts);, +    timeBeforeWait = ts.tv_sec * 1000 + ts.tv_nsec / 1000000;, +    for (;;) {, +      result = epoll_wait(efd, ev, len, timeout);, +      if (result >= 0) {, +        return result;, +      }, +      if ((err = errno) == EINTR) {, +        if (timeout > 0) {, +          clock_gettime(epollWaitClock, &ts);, +          timeNow = ts.tv_sec * 1000 + ts.tv_nsec / 1000000;, +          timeDiff = timeNow - timeBeforeWait;, +          timeout -= timeDiff;, +          if (timeDiff < 0 || timeout <= 0) {, +            return 0;, +          }, +          timeBeforeWait = timeNow;, +        } else if (timeout == 0) {, +          return 0;, +        }, +      } else {, +    }, +    if (!initializeEpollWaitClock()) {, +      return JNI_ERR;, +    }, +]