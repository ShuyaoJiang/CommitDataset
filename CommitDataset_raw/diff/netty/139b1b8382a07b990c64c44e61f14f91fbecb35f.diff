[+++ b/transport/src/main/java/io/netty/channel/ChannelInboundMessageHandlerAdapter.java, +            }, +    protected boolean beginMessageReceived(, +            @SuppressWarnings("UnusedParameters") ChannelHandlerContext ctx) throws Exception {, +     * Is called when {@link #messageReceived(ChannelHandlerContext, Object)} returns., +    protected void endMessageReceived(, +            @SuppressWarnings("UnusedParameters") ChannelHandlerContext ctx) throws Exception {, +++ b/transport/src/main/java/io/netty/channel/ChannelInboundMessageHandlerAdapter.java, +            }, +    protected boolean beginMessageReceived(, +            @SuppressWarnings("UnusedParameters") ChannelHandlerContext ctx) throws Exception {, +     * Is called when {@link #messageReceived(ChannelHandlerContext, Object)} returns., +    protected void endMessageReceived(, +            @SuppressWarnings("UnusedParameters") ChannelHandlerContext ctx) throws Exception {, +++ b/transport/src/main/java/io/netty/channel/ChannelOutboundMessageHandlerAdapter.java, +import io.netty.logging.InternalLoggerFactory;, +    private boolean closeOnFailedFlush = true;, +    protected final boolean isCloseOnFailedFlush() {, +        return closeOnFailedFlush;, +    }, +, +    protected final void setCloseOnFailedFlush(boolean closeOnFailedFlush) {, +        this.closeOnFailedFlush = closeOnFailedFlush;, +    }, +, +, +        final int inSize = in.size();, +        int processed = 0;, +, +            beginFlush(ctx);, +                    processed ++;, +                    processed ++;, +            }, +            fail(ctx, promise, new PartialFlushException(, +                    processed + " out of " + inSize + " message(s) flushed; " + in.size() + " left", t));, +        }, +, +        try {, +            endFlush(ctx);, +        } catch (Throwable t) {, +            if (promise.isDone()) {, +                InternalLoggerFactory.getInstance(getClass()).warn(, +                        "endFlush() raised a masked exception due to failed flush().", t);, +            } else {, +                fail(ctx, promise, t);, +            }, +            return;, +        }, +, +        ctx.flush(promise);, +    }, +, +    private void fail(ChannelHandlerContext ctx, ChannelPromise promise, Throwable cause) {, +        promise.setFailure(cause);, +        if (isCloseOnFailedFlush()) {, +            ctx.close();, +, +    /**, +     * Will get notified once {@link #flush(ChannelHandlerContext, ChannelPromise)} was called., +     *, +     * @param ctx           the {@link ChannelHandlerContext} which this {@link ChannelHandler} belongs to, +     */, +    protected void beginFlush(@SuppressWarnings("UnusedParameters") ChannelHandlerContext ctx) throws Exception { }, +     * Is called when {@link #flush(ChannelHandlerContext, ChannelPromise)} returns., +     *, +     * Super-classes may-override this for special handling., +     *, +     * @param ctx           the {@link ChannelHandlerContext} which this {@link ChannelHandler} belongs to, +     */, +    protected void endFlush(@SuppressWarnings("UnusedParameters") ChannelHandlerContext ctx) throws Exception { }, +, +    /**]