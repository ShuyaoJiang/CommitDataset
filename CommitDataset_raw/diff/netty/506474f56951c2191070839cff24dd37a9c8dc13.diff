[+++ b/transport/src/main/java/io/netty/channel/DefaultChannelHandlerContext.java, +import java.nio.channels.ClosedChannelException;, +    private boolean needsLazyBufInit;, +    private AtomicReference<MessageBridge> outMsgBridge;, +    private AtomicReference<ByteBridge> outByteBridge;, +    // Lazily instantiated tasks used to trigger events to a handler with different executor., +    private Runnable invokeChannelRegisteredTask;, +    private Runnable invokeChannelUnregisteredTask;, +    private Runnable invokeChannelActiveTask;, +    private Runnable invokeChannelInactiveTask;, +    private Runnable invokeInboundBufferUpdatedTask;, +    private Runnable fireInboundBufferUpdated0Task;, +    private Runnable invokeInboundBufferSuspendedTask;, +    private Runnable invokeFreeInboundBuffer0Task;, +    private Runnable invokeFreeOutboundBuffer0Task;, +    private Runnable invokeRead0Task;, +    DefaultChannelHandlerContext(, +            DefaultChannelPipeline pipeline, EventExecutorGroup group,, +            String name, ChannelHandler handler) {, +        this(pipeline, group, name, handler, false);, +            String name, ChannelHandler handler, boolean needsLazyBufInit) {, +        if (handler instanceof ChannelInboundHandler) {, +        if (handler instanceof ChannelOutboundHandler) {, +            if (needsLazyBufInit) {, +                // Special case: it means this context is for HeadHandler., +        this.needsLazyBufInit = needsLazyBufInit;, +        if (needsLazyBufInit) {, +                needsLazyBufInit = false;, +            buf = ((ChannelOutboundHandler) handler()).newOutboundBuffer(this);, +    private void fillBridge() {, +    private void flushBridge() {, +        return channel().config().getAllocator();, +            return channel().eventLoop();, +            if (handler() instanceof ChannelInboundHandler) {, +            if (handler() instanceof ChannelInboundHandler) {, +            if (handler() instanceof ChannelOutboundHandler) {, +            if (handler() instanceof ChannelOutboundHandler) {, +            if (ctx.hasInboundByteBuffer()) {, +            if (ctx.hasInboundMessageBuffer()) {, +            if (ctx.hasOutboundByteBuffer()) {, +, +            if (ctx.hasOutboundMessageBuffer()) {, +, +            if (ctx.hasInboundByteBuffer()) {, +                if (ctx.executor().inEventLoop()) {, +                    return ctx.inboundByteBuffer();, +            if (ctx.hasInboundMessageBuffer()) {, +                if (ctx.executor().inEventLoop()) {, +                    return ctx.inboundMessageBuffer();, +        DefaultChannelHandlerContext ctx = prev;, +        final DefaultChannelHandlerContext initialCtx = ctx;, +        for (;;) {, +            if (ctx.hasOutboundByteBuffer()) {, +                if (ctx.executor().inEventLoop()) {, +                    return ctx.outboundByteBuffer();, +                } else {, +                    ByteBridge bridge = ctx.outByteBridge.get();, +                    if (bridge == null) {, +                        bridge = new ByteBridge(ctx);, +                        if (!ctx.outByteBridge.compareAndSet(null, bridge)) {, +                            bridge = ctx.outByteBridge.get();, +                        }, +                    }, +                    return bridge.byteBuf;, +                }, +            }, +            ctx = ctx.prev;, +, +            if (ctx == null) {, +                if (initialCtx != null && initialCtx.next != null) {, +                    throw new NoSuchBufferException(String.format(, +                            "the handler '%s' could not find a %s whose outbound buffer is %s.",, +                            initialCtx.next.name(), ChannelOutboundHandler.class.getSimpleName(),, +                            ByteBuf.class.getSimpleName()));, +                } else {, +                    throw new NoSuchBufferException(String.format(, +                            "the pipeline does not contain a %s whose outbound buffer is %s.",, +                            ChannelOutboundHandler.class.getSimpleName(),, +                            ByteBuf.class.getSimpleName()));, +                }, +            }, +        }, +        DefaultChannelHandlerContext ctx = prev;, +        final DefaultChannelHandlerContext initialCtx = ctx;, +        for (;;) {, +            if (ctx.hasOutboundMessageBuffer()) {, +                if (ctx.executor().inEventLoop()) {, +                    return ctx.outboundMessageBuffer();, +                } else {, +                    MessageBridge bridge = ctx.outMsgBridge.get();, +                    if (bridge == null) {, +                        bridge = new MessageBridge();, +                        if (!ctx.outMsgBridge.compareAndSet(null, bridge)) {, +                            bridge = ctx.outMsgBridge.get();, +                        }, +                    }, +                    return bridge.msgBuf;, +                }, +            }, +            ctx = ctx.prev;]