[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectDecoder.java, +                sb.subStringUnsafe(aStart, aEnd),, +                sb.subStringUnsafe(bStart, bEnd),, +                cStart < cEnd? sb.subStringUnsafe(cStart, cEnd) : "" };, +        name = sb.subStringUnsafe(nameStart, nameEnd);, +            value = sb.subStringUnsafe(valueStart, valueEnd);, +    private static int findNonWhitespace(AppendableCharSequence sb, int offset) {, +        for (int result = offset; result < sb.length(); ++result) {, +            if (!Character.isWhitespace(sb.charAtUnsafe(result))) {, +        }, +        return sb.length();, +    }, +    private static int findWhitespace(AppendableCharSequence sb, int offset) {, +        for (int result = offset; result < sb.length(); ++result) {, +            if (Character.isWhitespace(sb.charAtUnsafe(result))) {, +        }, +        return sb.length();, +    }, +    private static int findEndOfString(AppendableCharSequence sb) {, +        for (int result = sb.length() - 1; result > 0; --result) {, +            if (!Character.isWhitespace(sb.charAtUnsafe(result))) {, +                return result + 1;, +        return 0;, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectDecoder.java, +                sb.subStringUnsafe(aStart, aEnd),, +                sb.subStringUnsafe(bStart, bEnd),, +                cStart < cEnd? sb.subStringUnsafe(cStart, cEnd) : "" };, +        name = sb.subStringUnsafe(nameStart, nameEnd);, +            value = sb.subStringUnsafe(valueStart, valueEnd);, +    private static int findNonWhitespace(AppendableCharSequence sb, int offset) {, +        for (int result = offset; result < sb.length(); ++result) {, +            if (!Character.isWhitespace(sb.charAtUnsafe(result))) {, +        }, +        return sb.length();, +    }, +    private static int findWhitespace(AppendableCharSequence sb, int offset) {, +        for (int result = offset; result < sb.length(); ++result) {, +            if (Character.isWhitespace(sb.charAtUnsafe(result))) {, +        }, +        return sb.length();, +    }, +    private static int findEndOfString(AppendableCharSequence sb) {, +        for (int result = sb.length() - 1; result > 0; --result) {, +            if (!Character.isWhitespace(sb.charAtUnsafe(result))) {, +                return result + 1;, +        return 0;, +++ b/common/src/main/java/io/netty/util/internal/AppendableCharSequence.java, +        if (chars.length < 1) {, +            throw new IllegalArgumentException("length: " + chars.length + " (length: >= 1)");, +        }, +    /**, +     * Access a value in this {@link CharSequence}., +     * This method is considered unsafe as index values are assumed to be legitimate., +     * Only underlying array bounds checking is done., +     * @param index The index to access the underlying array at., +     * @return The value at {@code index}., +     */, +    public char charAtUnsafe(int index) {, +        return chars[index];, +    }, +, +        try {, +        } catch (IndexOutOfBoundsException e) {, +            expand();, +            chars[pos - 1] = c;, +        }, +    /**, +     * Create a new {@link String} from the given start to end., +     * This method is considered unsafe as index values are assumed to be legitimate., +     * Only underlying array bounds checking is done., +     */, +    public String subStringUnsafe(int start, int end) {, +        return new String(chars, start, end - start);, +    }, +, +    private void expand() {, +        char[] old = chars;, +        // double it, +        int len = old.length << 1;, +        if (len < 0) {, +            throw new IllegalStateException();, +        }, +        chars = new char[len];, +        System.arraycopy(old, 0, chars, 0, old.length);, +    }, +, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectDecoder.java, +                sb.subStringUnsafe(aStart, aEnd),, +                sb.subStringUnsafe(bStart, bEnd),, +                cStart < cEnd? sb.subStringUnsafe(cStart, cEnd) : "" };, +        name = sb.subStringUnsafe(nameStart, nameEnd);, +            value = sb.subStringUnsafe(valueStart, valueEnd);, +    private static int findNonWhitespace(AppendableCharSequence sb, int offset) {, +        for (int result = offset; result < sb.length(); ++result) {, +            if (!Character.isWhitespace(sb.charAtUnsafe(result))) {, +        }, +        return sb.length();, +    }, +    private static int findWhitespace(AppendableCharSequence sb, int offset) {, +        for (int result = offset; result < sb.length(); ++result) {]