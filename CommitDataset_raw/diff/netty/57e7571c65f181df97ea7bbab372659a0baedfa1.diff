[+++ b/transport/src/main/java/io/netty/channel/AbstractChannel.java, +                                    buffer.failFlushed(CLOSED_CHANNEL_EXCEPTION, false);, +                    buffer.failFlushed(CLOSED_CHANNEL_EXCEPTION, false);, +                        outboundBuffer.failFlushed(NOT_YET_CONNECTED_EXCEPTION, true);, +                        // Do not trigger channelWritabilityChanged because the channel is closed already., +                        outboundBuffer.failFlushed(CLOSED_CHANNEL_EXCEPTION, false);, +                boolean close = t instanceof IOException && config().isAutoClose();, +                // We do not want to trigger channelWritabilityChanged event if the channel is going to be closed., +                outboundBuffer.failFlushed(t, !close);, +                if (close) {, +++ b/transport/src/main/java/io/netty/channel/AbstractChannel.java, +                                    buffer.failFlushed(CLOSED_CHANNEL_EXCEPTION, false);, +                    buffer.failFlushed(CLOSED_CHANNEL_EXCEPTION, false);, +                        outboundBuffer.failFlushed(NOT_YET_CONNECTED_EXCEPTION, true);, +                        // Do not trigger channelWritabilityChanged because the channel is closed already., +                        outboundBuffer.failFlushed(CLOSED_CHANNEL_EXCEPTION, false);, +                boolean close = t instanceof IOException && config().isAutoClose();, +                // We do not want to trigger channelWritabilityChanged event if the channel is going to be closed., +                outboundBuffer.failFlushed(t, !close);, +                if (close) {, +++ b/transport/src/main/java/io/netty/channel/ChannelOutboundBuffer.java, +                    decrementPendingOutboundBytes(pending, false, true);, +        decrementPendingOutboundBytes(size, true, true);, +    private void decrementPendingOutboundBytes(long size, boolean invokeLater, boolean notifyWritability) {, +        if (notifyWritability && newWriteBufferSize == 0, +            || newWriteBufferSize <= channel.config().getWriteBufferLowWaterMark()) {, +            decrementPendingOutboundBytes(size, false, true);, +        return remove0(cause, true);, +    }, +, +    private boolean remove0(Throwable cause, boolean notifyWritability) {, +            decrementPendingOutboundBytes(size, false, notifyWritability);, +    void failFlushed(Throwable cause, boolean notify) {, +                if (!remove0(cause, notify)) {]