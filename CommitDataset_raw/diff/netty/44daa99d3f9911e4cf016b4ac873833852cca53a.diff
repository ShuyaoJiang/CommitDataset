[+++ b/transport/src/main/java/io/netty/channel/socket/aio/AioSocketChannel.java, +    private static void expandReadBuffer(ByteBuf byteBuf) {, +        final int writerIndex = byteBuf.writerIndex();, +        if (capacity != writerIndex) {, +            return;, +        }, +, +        final int maxCapacity = byteBuf.maxCapacity();, +            return;, +            // Expand to maximum capacity., +        } else {, +        }, +++ b/transport/src/main/java/io/netty/channel/socket/aio/AioSocketChannel.java, +    private static void expandReadBuffer(ByteBuf byteBuf) {, +        final int writerIndex = byteBuf.writerIndex();, +        if (capacity != writerIndex) {, +            return;, +        }, +, +        final int maxCapacity = byteBuf.maxCapacity();, +            return;, +            // Expand to maximum capacity., +        } else {, +        }, +++ b/transport/src/main/java/io/netty/channel/socket/nio/AbstractNioByteChannel.java, +                loop: for (;;) {, +, +                    switch (expandReadBuffer(byteBuf)) {, +                    case 0:, +                        // Read all - stop reading., +                        break loop;, +                    case 1:, +                        // Keep reading until everything is read., +                    case 2:, +                        // Let the inbound handler drain the buffer and continue reading., +                        if (read) {, +                            read = false;, +                            pipeline.fireInboundBufferUpdated();, +                            if (!byteBuf.writable()) {, +                                throw new IllegalStateException(, +                                        "an inbound handler whose buffer is full must consume at " +, +                                        "least one byte.");, +                            }, +                        }, +    // 0 - not expanded because the buffer is writable, +    // 1 - expanded because the buffer was not writable, +    // 2 - could not expand because the buffer was at its maximum although the buffer is not writable., +    private static int expandReadBuffer(ByteBuf byteBuf) {, +        final int writerIndex = byteBuf.writerIndex();, +        if (capacity != writerIndex) {, +            return 0;, +        }, +, +        final int maxCapacity = byteBuf.maxCapacity();, +            return 2;, +            // Expand to maximum capacity., +        } else {, +        }, +, +        return 1;, +++ b/transport/src/main/java/io/netty/channel/socket/aio/AioSocketChannel.java, +    private static void expandReadBuffer(ByteBuf byteBuf) {, +        final int writerIndex = byteBuf.writerIndex();, +        if (capacity != writerIndex) {, +            return;, +        }, +, +        final int maxCapacity = byteBuf.maxCapacity();, +            return;, +            // Expand to maximum capacity., +        } else {, +        }, +++ b/transport/src/main/java/io/netty/channel/socket/nio/AbstractNioByteChannel.java, +                loop: for (;;) {, +, +                    switch (expandReadBuffer(byteBuf)) {, +                    case 0:, +                        // Read all - stop reading., +                        break loop;, +                    case 1:, +                        // Keep reading until everything is read., +                    case 2:, +                        // Let the inbound handler drain the buffer and continue reading., +                        if (read) {, +                            read = false;, +                            pipeline.fireInboundBufferUpdated();, +                            if (!byteBuf.writable()) {, +                                throw new IllegalStateException(, +                                        "an inbound handler whose buffer is full must consume at " +, +                                        "least one byte.");, +                            }, +                        }, +    // 0 - not expanded because the buffer is writable, +    // 1 - expanded because the buffer was not writable, +    // 2 - could not expand because the buffer was at its maximum although the buffer is not writable., +    private static int expandReadBuffer(ByteBuf byteBuf) {, +        final int writerIndex = byteBuf.writerIndex();, +        if (capacity != writerIndex) {, +            return 0;, +        }]