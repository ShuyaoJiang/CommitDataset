[+++ b/transport/src/main/java/io/netty/channel/AbstractChannel.java, +    public long bytesBeforeUnwritable() {, +        ChannelOutboundBuffer buf = unsafe.outboundBuffer();, +        // isWritable() is currently assuming if there is no outboundBuffer then the channel is not writable., +        // We should be consistent with that here., +        return buf != null ? buf.bytesBeforeUnwritable() : 0;, +    }, +, +    @Override, +    public long bytesBeforeWritable() {, +        ChannelOutboundBuffer buf = unsafe.outboundBuffer();, +        // isWritable() is currently assuming if there is no outboundBuffer then the channel is not writable., +        // We should be consistent with that here., +        return buf != null ? buf.bytesBeforeWritable() : Long.MAX_VALUE;, +    }, +, +    @Override, +++ b/transport/src/main/java/io/netty/channel/AbstractChannel.java, +    public long bytesBeforeUnwritable() {, +        ChannelOutboundBuffer buf = unsafe.outboundBuffer();, +        // isWritable() is currently assuming if there is no outboundBuffer then the channel is not writable., +        // We should be consistent with that here., +        return buf != null ? buf.bytesBeforeUnwritable() : 0;, +    }, +, +    @Override, +    public long bytesBeforeWritable() {, +        ChannelOutboundBuffer buf = unsafe.outboundBuffer();, +        // isWritable() is currently assuming if there is no outboundBuffer then the channel is not writable., +        // We should be consistent with that here., +        return buf != null ? buf.bytesBeforeWritable() : Long.MAX_VALUE;, +    }, +, +    @Override, +++ b/transport/src/main/java/io/netty/channel/Channel.java, +     * Get how many bytes can be written until {@link #isWritable()} returns {@code false}., +     * This quantity will always be non-negative. If {@link #isWritable()} is {@code false} then 0., +     */, +    long bytesBeforeUnwritable();, +, +    /**, +     * Get how many bytes must be drained from underlying buffers until {@link #isWritable()} returns {@code true}., +     * This quantity will always be non-negative. If {@link #isWritable()} is {@code true} then 0., +     */, +    long bytesBeforeWritable();, +, +    /**, +++ b/transport/src/main/java/io/netty/channel/AbstractChannel.java, +    public long bytesBeforeUnwritable() {, +        ChannelOutboundBuffer buf = unsafe.outboundBuffer();, +        // isWritable() is currently assuming if there is no outboundBuffer then the channel is not writable., +        // We should be consistent with that here., +        return buf != null ? buf.bytesBeforeUnwritable() : 0;, +    }, +, +    @Override, +    public long bytesBeforeWritable() {, +        ChannelOutboundBuffer buf = unsafe.outboundBuffer();, +        // isWritable() is currently assuming if there is no outboundBuffer then the channel is not writable., +        // We should be consistent with that here., +        return buf != null ? buf.bytesBeforeWritable() : Long.MAX_VALUE;, +    }, +, +    @Override, +++ b/transport/src/main/java/io/netty/channel/Channel.java, +     * Get how many bytes can be written until {@link #isWritable()} returns {@code false}., +     * This quantity will always be non-negative. If {@link #isWritable()} is {@code false} then 0., +     */, +    long bytesBeforeUnwritable();, +, +    /**, +     * Get how many bytes must be drained from underlying buffers until {@link #isWritable()} returns {@code true}., +     * This quantity will always be non-negative. If {@link #isWritable()} is {@code true} then 0., +     */, +    long bytesBeforeWritable();, +, +    /**, +++ b/transport/src/main/java/io/netty/channel/ChannelOutboundBuffer.java, +    public long bytesBeforeUnwritable() {]