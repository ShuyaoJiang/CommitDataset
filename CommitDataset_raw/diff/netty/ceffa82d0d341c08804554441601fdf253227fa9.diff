[+++ b/buffer/src/main/java/io/netty/buffer/PooledByteBufAllocator.java, +import io.netty.util.concurrent.GlobalEventExecutor;, +import io.netty.util.concurrent.ScheduledFuture;, +import java.util.IdentityHashMap;, +import java.util.Iterator;, +import java.util.Map;, +import java.util.concurrent.TimeUnit;, +    private static final long DEFAULT_CACHE_CLEANUP_INTERVAL;, +        // the default interval at which we check for caches that are assigned to Threads that are not alive anymore, +        DEFAULT_CACHE_CLEANUP_INTERVAL = SystemPropertyUtil.getLong(, +                "io.netty.allocator.cacheCleanupInterval", 5000);, +            logger.debug("-Dio.netty.allocator.cacheCleanupInterval: {} ms",, +                    DEFAULT_CACHE_CLEANUP_INTERVAL);, +    final PoolThreadLocalCache threadCache;, +        this(preferDirect, nHeapArena, nDirectArena, pageSize, maxOrder, tinyCacheSize, smallCacheSize,, +                normalCacheSize, DEFAULT_CACHE_CLEANUP_INTERVAL);, +    }, +, +    public PooledByteBufAllocator(boolean preferDirect, int nHeapArena, int nDirectArena, int pageSize, int maxOrder,, +                                  int tinyCacheSize, int smallCacheSize, int normalCacheSize,, +                                  long cacheThreadAliveCheckInterval) {, +        threadCache = new PoolThreadLocalCache(cacheThreadAliveCheckInterval);, +    @Deprecated, +    @Deprecated, +        private final Map<Thread, PoolThreadCache> caches = new IdentityHashMap<Thread, PoolThreadCache>();, +        private final ReleaseCacheTask task = new ReleaseCacheTask();, +        private final long cacheThreadAliveCheckInterval;, +, +        PoolThreadLocalCache(long cacheThreadAliveCheckInterval) {, +            this.cacheThreadAliveCheckInterval = cacheThreadAliveCheckInterval;, +        }, +        @Override, +        public void set(PoolThreadCache value) {, +            Thread current = Thread.currentThread();, +            synchronized (caches) {, +                caches.put(current, value);, +                if (task.releaseTaskFuture == null) {, +                    task.releaseTaskFuture = GlobalEventExecutor.INSTANCE.scheduleWithFixedDelay(task,, +                            cacheThreadAliveCheckInterval, cacheThreadAliveCheckInterval, TimeUnit.MILLISECONDS);, +                }, +            }, +            super.set(value);, +        }, +, +        @Override, +        public void remove() {, +            super.remove();, +            PoolThreadCache cache;, +            Thread current = Thread.currentThread();, +            synchronized (caches) {, +                cache = caches.remove(current);, +            }, +            if (cache != null) {, +                cache.free();, +            }, +        }, +, +        @Deprecated, +        @Deprecated, +, +        private final class ReleaseCacheTask implements Runnable {, +            private ScheduledFuture<?> releaseTaskFuture;, +, +            @Override, +            public void run() {, +                synchronized (caches) {, +                    for (Iterator<Map.Entry<Thread, PoolThreadCache>> i = caches.entrySet().iterator();, +                         i.hasNext();) {, +                        Map.Entry<Thread, PoolThreadCache> cache = i.next();, +                        if (cache.getKey().isAlive()) {, +                            // Thread is still alive..., +                            continue;, +                        }, +                        cache.getValue().free();, +                        i.remove();, +                    }, +                    if (caches.isEmpty()) {, +                        // Nothing in the caches anymore so no need to continue to check if something needs to be, +                        // released periodically. The task will be rescheduled if there is any need later., +                        if (releaseTaskFuture != null) {, +                            releaseTaskFuture.cancel(true);, +                            releaseTaskFuture = null;, +                        }, +                    }, +                }, +            }, +        }]