[+++ b/buffer/src/main/java/io/netty/buffer/PoolArena.java, +        private static final boolean HAS_UNSAFE = PlatformDependent.hasUnsafe();, +            if (HAS_UNSAFE) {, +            if (HAS_UNSAFE) {, +++ b/buffer/src/main/java/io/netty/buffer/PoolArena.java, +        private static final boolean HAS_UNSAFE = PlatformDependent.hasUnsafe();, +            if (HAS_UNSAFE) {, +            if (HAS_UNSAFE) {, +++ b/buffer/src/main/java/io/netty/buffer/UnpooledByteBufAllocator.java, +        if (PlatformDependent.hasUnsafe()) {, +++ b/buffer/src/main/java/io/netty/buffer/PoolArena.java, +        private static final boolean HAS_UNSAFE = PlatformDependent.hasUnsafe();, +            if (HAS_UNSAFE) {, +            if (HAS_UNSAFE) {, +++ b/buffer/src/main/java/io/netty/buffer/UnpooledByteBufAllocator.java, +        if (PlatformDependent.hasUnsafe()) {, +++ b/common/src/main/java/io/netty/util/internal/PlatformDependent.java, +     * Return {@code true} if {@code sun.misc.Unsafe} was found on the classpath and can be used for acclerated, +     * direct memory access., +    /**, +     * Try to allocate a new direct {@link ByteBuffer} using the best available allocator., +     */, +    public static ByteBuffer newDirectBuffer(int capacity) {, +        return PlatformDependent0.newDirectBuffer(capacity);, +        if (buffer.isDirect()) {, +    public static long directBufferAddress(ByteBuffer buffer) {, +        return PlatformDependent0.directBufferAddress(buffer);, +    }, +, +            Class.forName("android.app.Application", false, ClassLoader.getSystemClassLoader());, +        try {, +        } catch (Throwable t) {, +++ b/buffer/src/main/java/io/netty/buffer/PoolArena.java, +        private static final boolean HAS_UNSAFE = PlatformDependent.hasUnsafe();, +            if (HAS_UNSAFE) {, +            if (HAS_UNSAFE) {, +++ b/buffer/src/main/java/io/netty/buffer/UnpooledByteBufAllocator.java, +        if (PlatformDependent.hasUnsafe()) {, +++ b/common/src/main/java/io/netty/util/internal/PlatformDependent.java, +     * Return {@code true} if {@code sun.misc.Unsafe} was found on the classpath and can be used for acclerated, +     * direct memory access., +    /**, +     * Try to allocate a new direct {@link ByteBuffer} using the best available allocator., +     */, +    public static ByteBuffer newDirectBuffer(int capacity) {, +        return PlatformDependent0.newDirectBuffer(capacity);, +        if (buffer.isDirect()) {, +    public static long directBufferAddress(ByteBuffer buffer) {, +        return PlatformDependent0.directBufferAddress(buffer);, +    }, +, +            Class.forName("android.app.Application", false, ClassLoader.getSystemClassLoader());, +        try {, +        } catch (Throwable t) {, +++ b/common/src/main/java/io/netty/util/internal/PlatformDependent0.java, +, +, +        Field addressField;, +        try {, +            addressField = Buffer.class.getDeclaredField("address");, +            addressField.setAccessible(true);, +            if (addressField.getLong(ByteBuffer.allocate(1)) != 0) {, +                addressField = null;, +            } else {, +                direct = ByteBuffer.allocateDirect(1);, +                if (addressField.getLong(direct) == 0) {, +                    addressField = null;, +                }, +                Cleaner cleaner = (Cleaner) cleanerField.get(direct);, +                cleaner.clean();, +            }, +        } catch (Throwable t) {, +            addressField = null;, +        }, +, +        Unsafe unsafe;, +        if (addressField != null && cleanerField != null) {, +            try {, +                Field unsafeField = Unsafe.class.getDeclaredField("theUnsafe");, +                unsafeField.setAccessible(true);, +                unsafe = (Unsafe) unsafeField.get(null);, +, +                // Ensure the unsafe supports all necessary methods to work around the mistake in the latest OpenJDK., +                // https://github.com/netty/netty/issues/1061, +                // http://www.mail-archive.com/jdk6-dev@openjdk.java.net/msg00698.html, +                unsafe.getClass().getDeclaredMethod(, +                        "copyMemory", new Class[] { Object.class, long.class, Object.class, long.class, long.class });, +            } catch (Throwable cause) {, +                unsafe = null;, +            }, +        } else {, +            // If we cannot access the address of a direct buffer, there's no point of using unsafe., +            // Let's just pretend unsafe is unavailable for overall simplicity., +            unsafe = null;, +        }, +        UNSAFE = unsafe;, +, +        if (unsafe == null) {, +            CLEANER_FIELD_OFFSET = -1;, +            ADDRESS_FIELD_OFFSET = -1;]