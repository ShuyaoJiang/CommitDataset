[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectAggregator.java, +import io.netty.handler.codec.TooLongFrameException;, +import io.netty.util.internal.logging.InternalLogger;, +import io.netty.util.internal.logging.InternalLoggerFactory;, +, +    /**, +     * @deprecated Will be removed in the next minor version bump., +     */, +    @Deprecated, +    public static final int DEFAULT_MAX_COMPOSITEBUFFER_COMPONENTS = 1024; // TODO: Make it private in the next bump., +, +    private static final InternalLogger logger = InternalLoggerFactory.getInstance(HttpObjectAggregator.class);, +, +    static {, +        TOO_LARGE.headers().set(Names.CONTENT_LENGTH, 0);, +    }, +, +    private boolean handlingOversizedMessage;, +     *        {@link #handleOversizedMessage(ChannelHandlerContext, HttpMessage)}, +     * The default value of this property is {@value #DEFAULT_MAX_COMPOSITEBUFFER_COMPONENTS}., +     * The default value of this property is {@value #DEFAULT_MAX_COMPOSITEBUFFER_COMPONENTS}, +            handlingOversizedMessage = false;, +                    invokeHandleOversizedMessage(ctx, m);, +            if (is100ContinueExpected(m)) {, +            if (handlingOversizedMessage) {, +                invokeHandleOversizedMessage(ctx, currentMessage);, +    private void invokeHandleOversizedMessage(ChannelHandlerContext ctx, HttpMessage msg) throws Exception {, +        handlingOversizedMessage = true;, +        try {, +            handleOversizedMessage(ctx, msg);, +        } finally {, +            ReferenceCountUtil.release(msg);, +        }, +     * The default behavior is:, +     * <ul>, +     * <li>Oversized request: Send a {@link HttpResponseStatus#REQUEST_ENTITY_TOO_LARGE} and close the connection, +     *     if keep-alive is not enabled.</li>, + *     <li>Oversized response: Close the connection and raise {@link TooLongFrameException}.</li>, +     * </ul>, +     * Sub-classes may override this method to change the default behavior.  The specified {@code msg} is released, +     * once this method returns., +    @SuppressWarnings("UnusedParameters"), +    protected void handleOversizedMessage(final ChannelHandlerContext ctx, HttpMessage msg) throws Exception {, +        if (msg instanceof HttpRequest) {, +                        logger.debug("Failed to send a 413 Request Entity Too Large.", future.cause());, +                        ctx.close();, +            // If the client started to send data already, close because it's impossible to recover., +            // If 'Expect: 100-continue' is missing, close becuase it's impossible to recover., +            // If keep-alive is off, no need to leave the connection open., +            if (msg instanceof FullHttpMessage || !is100ContinueExpected(msg) || !isKeepAlive(msg)) {, +        } else if (msg instanceof HttpResponse) {, +            ctx.close();, +            throw new TooLongFrameException("Response entity too large: " + msg);, +        } else {, +            throw new IllegalStateException();, +        }, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectAggregator.java, +import io.netty.handler.codec.TooLongFrameException;, +import io.netty.util.internal.logging.InternalLogger;, +import io.netty.util.internal.logging.InternalLoggerFactory;, +, +    /**, +     * @deprecated Will be removed in the next minor version bump., +     */, +    @Deprecated, +    public static final int DEFAULT_MAX_COMPOSITEBUFFER_COMPONENTS = 1024; // TODO: Make it private in the next bump., +, +    private static final InternalLogger logger = InternalLoggerFactory.getInstance(HttpObjectAggregator.class);, +, +    static {, +        TOO_LARGE.headers().set(Names.CONTENT_LENGTH, 0);, +    }, +, +    private boolean handlingOversizedMessage;, +     *        {@link #handleOversizedMessage(ChannelHandlerContext, HttpMessage)}, +     * The default value of this property is {@value #DEFAULT_MAX_COMPOSITEBUFFER_COMPONENTS}., +     * The default value of this property is {@value #DEFAULT_MAX_COMPOSITEBUFFER_COMPONENTS}, +            handlingOversizedMessage = false;, +                    invokeHandleOversizedMessage(ctx, m);, +            if (is100ContinueExpected(m)) {, +            if (handlingOversizedMessage) {, +                invokeHandleOversizedMessage(ctx, currentMessage);, +    private void invokeHandleOversizedMessage(ChannelHandlerContext ctx, HttpMessage msg) throws Exception {, +        handlingOversizedMessage = true;, +        try {, +            handleOversizedMessage(ctx, msg);, +        } finally {, +            ReferenceCountUtil.release(msg);, +        }, +     * The default behavior is:, +     * <ul>, +     * <li>Oversized request: Send a {@link HttpResponseStatus#REQUEST_ENTITY_TOO_LARGE} and close the connection, +     *     if keep-alive is not enabled.</li>, + *     <li>Oversized response: Close the connection and raise {@link TooLongFrameException}.</li>, +     * </ul>, +     * Sub-classes may override this method to change the default behavior.  The specified {@code msg} is released, +     * once this method returns., +    @SuppressWarnings("UnusedParameters"), +    protected void handleOversizedMessage(final ChannelHandlerContext ctx, HttpMessage msg) throws Exception {, +        if (msg instanceof HttpRequest) {]