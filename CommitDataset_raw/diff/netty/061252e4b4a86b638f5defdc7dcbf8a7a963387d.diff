[+++ b/common/src/main/java/io/netty/util/UniqueName.java, +++ b/common/src/main/java/io/netty/util/UniqueName.java, +++ b/pom.xml, +            <ignore>java.nio.channels.InterruptedByTimeoutException</ignore>, +++ b/common/src/main/java/io/netty/util/UniqueName.java, +++ b/pom.xml, +            <ignore>java.nio.channels.InterruptedByTimeoutException</ignore>, +++ b/transport/src/main/java/io/netty/channel/ChannelOption.java, +    public static final ChannelOption<Long> AIO_READ_TIMEOUT =, +            new ChannelOption<Long>("AIO_READ_TIMEOUT");, +    public static final ChannelOption<Long> AIO_WRITE_TIMEOUT =, +            new ChannelOption<Long>("AIO_WRITE_TIMEOUT");, +, +++ b/common/src/main/java/io/netty/util/UniqueName.java, +++ b/pom.xml, +            <ignore>java.nio.channels.InterruptedByTimeoutException</ignore>, +++ b/transport/src/main/java/io/netty/channel/ChannelOption.java, +    public static final ChannelOption<Long> AIO_READ_TIMEOUT =, +            new ChannelOption<Long>("AIO_READ_TIMEOUT");, +    public static final ChannelOption<Long> AIO_WRITE_TIMEOUT =, +            new ChannelOption<Long>("AIO_WRITE_TIMEOUT");, +, +++ b/transport/src/main/java/io/netty/channel/socket/aio/AioSocketChannel.java, +import java.nio.channels.InterruptedByTimeoutException;, +import java.util.concurrent.TimeUnit;, +                javaChannel().write(buffers, 0, buffers.length, config.getReadTimeout(),, +                        TimeUnit.MILLISECONDS, AioSocketChannel.this, GATHERING_WRITE_HANDLER);, +                javaChannel().write(buf.nioBuffer(), config.getReadTimeout(), TimeUnit.MILLISECONDS,, +                        this, WRITE_HANDLER);, +            javaChannel().read(buffers, 0, buffers.length, config.getWriteTimeout(),, +                    TimeUnit.MILLISECONDS, AioSocketChannel.this, SCATTERING_READ_HANDLER);, +            javaChannel().read(buffer, config.getWriteTimeout(), TimeUnit.MILLISECONDS,, +                    AioSocketChannel.this, READ_HANDLER);, +            // Check if the exception was raised because of an InterruptedByTimeoutException which means that the, +            // write timeout was hit. In that case we should close the channel as it may be unusable anyway., +            //, +            // See http://openjdk.java.net/projects/nio/javadoc/java/nio/channels/AsynchronousSocketChannel.html, +            if (cause instanceof InterruptedByTimeoutException) {, +                channel.unsafe().close(channel.unsafe().voidFuture());, +                return;, +            }, +, +            // Check if the exception was raised because of an InterruptedByTimeoutException which means that the, +            // write timeout was hit. In that case we should close the channel as it may be unusable anyway., +            //, +            // See http://openjdk.java.net/projects/nio/javadoc/java/nio/channels/AsynchronousSocketChannel.html, +            if (t instanceof IOException || t instanceof InterruptedByTimeoutException) {, +++ b/common/src/main/java/io/netty/util/UniqueName.java, +++ b/pom.xml, +            <ignore>java.nio.channels.InterruptedByTimeoutException</ignore>, +++ b/transport/src/main/java/io/netty/channel/ChannelOption.java, +    public static final ChannelOption<Long> AIO_READ_TIMEOUT =, +            new ChannelOption<Long>("AIO_READ_TIMEOUT");, +    public static final ChannelOption<Long> AIO_WRITE_TIMEOUT =, +            new ChannelOption<Long>("AIO_WRITE_TIMEOUT");, +, +++ b/transport/src/main/java/io/netty/channel/socket/aio/AioSocketChannel.java, +import java.nio.channels.InterruptedByTimeoutException;, +import java.util.concurrent.TimeUnit;, +                javaChannel().write(buffers, 0, buffers.length, config.getReadTimeout(),, +                        TimeUnit.MILLISECONDS, AioSocketChannel.this, GATHERING_WRITE_HANDLER);, +                javaChannel().write(buf.nioBuffer(), config.getReadTimeout(), TimeUnit.MILLISECONDS,, +                        this, WRITE_HANDLER);, +            javaChannel().read(buffers, 0, buffers.length, config.getWriteTimeout(),, +                    TimeUnit.MILLISECONDS, AioSocketChannel.this, SCATTERING_READ_HANDLER);, +            javaChannel().read(buffer, config.getWriteTimeout(), TimeUnit.MILLISECONDS,, +                    AioSocketChannel.this, READ_HANDLER);, +            // Check if the exception was raised because of an InterruptedByTimeoutException which means that the, +            // write timeout was hit. In that case we should close the channel as it may be unusable anyway., +            //, +            // See http://openjdk.java.net/projects/nio/javadoc/java/nio/channels/AsynchronousSocketChannel.html, +            if (cause instanceof InterruptedByTimeoutException) {, +                channel.unsafe().close(channel.unsafe().voidFuture());, +                return;, +            }, +, +            // Check if the exception was raised because of an InterruptedByTimeoutException which means that the, +            // write timeout was hit. In that case we should close the channel as it may be unusable anyway., +            //, +            // See http://openjdk.java.net/projects/nio/javadoc/java/nio/channels/AsynchronousSocketChannel.html, +            if (t instanceof IOException || t instanceof InterruptedByTimeoutException) {, +++ b/transport/src/main/java/io/netty/channel/socket/aio/AioSocketChannelConfig.java, +import java.nio.channels.InterruptedByTimeoutException;, +    private volatile long readTimeoutInMillis;, +    private volatile long writeTimeoutInMillis;, +                SO_RCVBUF, SO_SNDBUF, TCP_NODELAY, SO_KEEPALIVE, SO_REUSEADDR, SO_LINGER, IP_TOS,, +                AIO_READ_TIMEOUT, AIO_WRITE_TIMEOUT);, +        if (option == AIO_READ_TIMEOUT) {, +            return (T) Long.valueOf(getReadTimeout());, +        }, +        if (option == AIO_WRITE_TIMEOUT) {, +            return (T) Long.valueOf(getWriteTimeout());, +        }, +        } else if (option == AIO_READ_TIMEOUT) {, +            setReadTimeout((Long) value);, +        } else if (option == AIO_WRITE_TIMEOUT) {, +            setWriteTimeout((Long) value);, +, +    /**, +     * Return the read timeout in milliseconds after which a {@link InterruptedByTimeoutException} will get thrown.]