[+++ b/src/main/java/org/jboss/netty/util/HashedWheelTimer.java, +        if (Thread.currentThread() == workerThread) {, +            throw new IllegalStateException(, +                    HashedWheelTimer.class.getSimpleName() +, +                    ".stop() cannot be called from " +, +                    TimerTask.class.getSimpleName());, +        }, +, +        delay = unit.toMillis(delay);, +        HashedWheelTimeout timeout = new HashedWheelTimeout(task, currentTime + delay);, +        scheduleTimeout(timeout, delay);, +        return timeout;, +    }, +, +    void scheduleTimeout(HashedWheelTimeout timeout, long delay) {, +        // delay must be equal to or greater than tickDuration so that the, +        // worker thread never misses the timeout., +        if (delay < tickDuration) {, +            delay = tickDuration;, +        }, +, +        // Prepare the required parameters to schedule the timeout object., +            int stopIndex = (int) (wheelCursor + relativeIndex & mask);, +            timeout.stopIndex = stopIndex;, +            timeout.remainingRounds = remainingRounds;, +            wheel[stopIndex].add(timeout);, +                final long deadline = waitForNextTick();, +                if (deadline > 0) {, +                    fetchExpiredTimeouts(expiredTimeouts, deadline);, +        }, +                List<HashedWheelTimeout> expiredTimeouts, long deadline) {, +                int newWheelCursor = wheelCursor = wheelCursor + 1 & mask;, +                ReusableIterator<HashedWheelTimeout> i = iterators[newWheelCursor];, +                fetchExpiredTimeouts(expiredTimeouts, i, deadline);, +                ReusableIterator<HashedWheelTimeout> i, long deadline) {, +            List<HashedWheelTimeout> slipped = null;, +                    if (timeout.deadline <= deadline) {, +                        // Handle the case where the timeout is put into a wrong, +                        // place, usually one tick earlier.  For now, just add, +                        // it to a temporary list - we will reschedule it in a, +                        // separate loop., +                        if (slipped == null) {, +                            slipped = new ArrayList<HashedWheelTimer.HashedWheelTimeout>();, +                        }, +                        slipped.add(timeout);, +, +            // Reschedule the slipped timeouts., +            if (slipped != null) {, +                for (HashedWheelTimeout timeout: slipped) {, +                    scheduleTimeout(timeout, timeout.deadline - deadline);, +                }, +            }, +        private long waitForNextTick() {, +            long deadline = startTime + tickDuration * tick;, +, +                        return -1;, +            // Increase the tick., +            return deadline;, +        volatile int stopIndex;, +        HashedWheelTimeout(TimerTask task, long deadline) {]