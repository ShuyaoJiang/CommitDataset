[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpClientCodec.java, +import io.netty.channel.Channel;, +import io.netty.handler.codec.PrematureChannelClosureException;, +import java.util.concurrent.atomic.AtomicLong;, + *, + * If the {@link Channel} is closed and there are missing responses,, + * a {@link PrematureChannelClosureException} is thrown., + *, +    private final AtomicLong requestResponseCounter = new AtomicLong();, +    private final boolean failOnMissingResponse;, +, +        this(4096, 8192, 8192, false);, +        this(maxInitialLineLength, maxHeaderSize, maxChunkSize, false);, +    }, +, +    public HttpClientCodec(, +            int maxInitialLineLength, int maxHeaderSize, int maxChunkSize,, +            boolean failOnMissingResponse) {, +, +        this.failOnMissingResponse = failOnMissingResponse;, +, +, +            if (failOnMissingResponse) {, +                // check if the request is chunked if so do not increment, +                if (msg instanceof HttpRequest && !((HttpRequest) msg).isChunked()) {, +                    requestResponseCounter.incrementAndGet();, +                } else if (msg instanceof HttpChunk && ((HttpChunk) msg).isLast()) {, +                    // increment as its the last chunk, +                    requestResponseCounter.incrementAndGet();, +                }, +            }, +                Object msg = super.decode(ctx, buffer);, +                if (failOnMissingResponse) {, +                    decrement(msg);, +                }, +                return msg;, +            }, +        }, +, +        private void decrement(Object msg) {, +            if (msg == null) {, +                return;, +            }, +, +            // check if its a HttpMessage and its not chunked, +            if (msg instanceof HttpMessage && !((HttpMessage) msg).isChunked()) {, +                requestResponseCounter.decrementAndGet();, +            } else if (msg instanceof HttpChunk && ((HttpChunk) msg).isLast()) {, +                requestResponseCounter.decrementAndGet();, +            } else if (msg instanceof Object[]) {, +                // we just decrement it here as we only use this if the end of the chunk is reached, +                // It would be more safe to check all the objects in the array but would also be slower, +                requestResponseCounter.decrementAndGet();, +, +        @Override, +        public void channelInactive(ChannelInboundHandlerContext<Byte> ctx), +                throws Exception {, +            super.channelInactive(ctx);, +, +            if (failOnMissingResponse) {, +                long missingResponses = requestResponseCounter.get();, +                if (missingResponses > 0) {, +                    ctx.fireExceptionCaught(new PrematureChannelClosureException(, +                            "channel gone inactive with " + missingResponses +, +                            " missing response(s)"));, +                }, +            }, +        }]