[+++ b/codec/src/main/java/io/netty/handler/codec/compression/LzfDecoder.java, +     * Current state of decompression., +    private enum State {, +        INIT_BLOCK,, +        INIT_ORIGINAL_LENGTH,, +        DECOMPRESS_DATA,, +        CORRUPTED, +    }, +, +    private State currentState = State.INIT_BLOCK;, +     * Magic number of LZF chunk., +    private static final short MAGIC_NUMBER = BYTE_Z << 8 | BYTE_V;, +    private ChunkDecoder decoder;, +    private BufferRecycler recycler;, +     * Length of current received chunk of data., +    private int chunkLength;, +, +    /**, +     * Original length of current received chunk of data., +     * It is equal to {@link #chunkLength} for non compressed chunks., +     */, +    private int originalLength;, +, +    /**, +     * Indicates is this chunk compressed or not., +     */, +    private boolean isCompressed;, +            try {, +                switch (currentState) {, +                    case INIT_BLOCK:, +                        final int magic = in.readUnsignedShort();, +                        if (magic != MAGIC_NUMBER) {, +                            throw new DecompressionException("unexpected block identifier");, +                        final int type = in.readByte();, +                            case BLOCK_TYPE_NON_COMPRESSED:, +                                isCompressed = false;, +                                currentState = State.DECOMPRESS_DATA;, +                                break;, +                            case BLOCK_TYPE_COMPRESSED:, +                                isCompressed = true;, +                                currentState = State.INIT_ORIGINAL_LENGTH;, +                                break;, +                            default:, +                                throw new DecompressionException(String.format(, +                                        "unknown type of chunk: %d (expected: %d or %d)",, +                                        type, BLOCK_TYPE_NON_COMPRESSED, BLOCK_TYPE_COMPRESSED));, +                        }, +                        chunkLength = in.readUnsignedShort();, +, +                        if (type != BLOCK_TYPE_COMPRESSED) {, +                    case INIT_ORIGINAL_LENGTH:, +                        if (in.readableBytes() < 2) {, +                            return;, +                        }, +                        originalLength = in.readUnsignedShort();, +, +                        currentState = State.DECOMPRESS_DATA;, +                    case DECOMPRESS_DATA:, +                        final int chunkLength = this.chunkLength;, +                        if (in.readableBytes() < chunkLength) {, +                            return;, +                        }, +                        final int originalLength = this.originalLength;, +, +                        if (isCompressed) {, +                            final int idx = in.readerIndex();, +                                inPos = in.arrayOffset() + idx;, +                                in.getBytes(idx, inputArray, 0, chunkLength);, +                                in.skipBytes(chunkLength);, +                        } else {, +                            out.add(in.readSlice(chunkLength).retain());, +, +                        currentState = State.INIT_BLOCK;, +                        break;, +                    case CORRUPTED:, +                        in.skipBytes(in.readableBytes());, +                        return;, +                        throw new IllegalStateException();, +                currentState = State.CORRUPTED;, +                decoder = null;, +                recycler = null;, +++ b/codec/src/main/java/io/netty/handler/codec/compression/LzfDecoder.java, +     * Current state of decompression., +    private enum State {, +        INIT_BLOCK,, +        INIT_ORIGINAL_LENGTH,, +        DECOMPRESS_DATA,, +        CORRUPTED, +    }, +, +    private State currentState = State.INIT_BLOCK;, +     * Magic number of LZF chunk., +    private static final short MAGIC_NUMBER = BYTE_Z << 8 | BYTE_V;, +    private ChunkDecoder decoder;, +    private BufferRecycler recycler;, +     * Length of current received chunk of data., +    private int chunkLength;, +, +    /**, +     * Original length of current received chunk of data.]