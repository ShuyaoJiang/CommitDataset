[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentEncoder.java, +    private static final CharSequence ZERO_LENGTH_HEAD = "HEAD";, +    private static final CharSequence ZERO_LENGTH_CONNECT = "CONNECT";, +, +    private final Queue<CharSequence> acceptEncodingQueue = new ArrayDeque<CharSequence>();, +    private CharSequence acceptEncoding;, +        CharSequence acceptedEncoding = msg.headers().get(HttpHeaderNames.ACCEPT_ENCODING);, +, +        HttpMethod meth = msg.method();, +        if (meth == HttpMethod.HEAD) {, +            acceptedEncoding = ZERO_LENGTH_HEAD;, +        } else if (meth == HttpMethod.CONNECT) {, +            acceptedEncoding = ZERO_LENGTH_CONNECT;, +        }, +, +                // Get the list of encodings accepted by the peer., +                acceptEncoding = acceptEncodingQueue.poll();, +                if (acceptEncoding == null) {, +                    throw new IllegalStateException("cannot send more responses than requests");, +                }, +, +                 *, +                 * 9.4 HEAD, +                 * The HEAD method is identical to GET except that the server MUST NOT return a message-body, +                 * in the response., +                 *, +                 * This code is now inline with HttpClientDecoder.Decoder, +                if (isPassthru(res, acceptEncoding)) {, +                final Result result = beginEncode(res, acceptEncoding.toString());, +    private static boolean isPassthru(HttpResponse res, CharSequence httpMethod) {, +        boolean expectEmptyBody = httpMethod == ZERO_LENGTH_HEAD || (httpMethod == ZERO_LENGTH_CONNECT && code == 200);, +        return code < 200 || code == 204 || code == 304 || expectEmptyBody;, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentEncoder.java, +    private static final CharSequence ZERO_LENGTH_HEAD = "HEAD";, +    private static final CharSequence ZERO_LENGTH_CONNECT = "CONNECT";, +, +    private final Queue<CharSequence> acceptEncodingQueue = new ArrayDeque<CharSequence>();, +    private CharSequence acceptEncoding;, +        CharSequence acceptedEncoding = msg.headers().get(HttpHeaderNames.ACCEPT_ENCODING);, +, +        HttpMethod meth = msg.method();, +        if (meth == HttpMethod.HEAD) {, +            acceptedEncoding = ZERO_LENGTH_HEAD;, +        } else if (meth == HttpMethod.CONNECT) {, +            acceptedEncoding = ZERO_LENGTH_CONNECT;, +        }, +, +                // Get the list of encodings accepted by the peer., +                acceptEncoding = acceptEncodingQueue.poll();, +                if (acceptEncoding == null) {, +                    throw new IllegalStateException("cannot send more responses than requests");, +                }, +, +                 *, +                 * 9.4 HEAD, +                 * The HEAD method is identical to GET except that the server MUST NOT return a message-body, +                 * in the response., +                 *, +                 * This code is now inline with HttpClientDecoder.Decoder, +                if (isPassthru(res, acceptEncoding)) {, +                final Result result = beginEncode(res, acceptEncoding.toString());, +    private static boolean isPassthru(HttpResponse res, CharSequence httpMethod) {, +        boolean expectEmptyBody = httpMethod == ZERO_LENGTH_HEAD || (httpMethod == ZERO_LENGTH_CONNECT && code == 200);, +        return code < 200 || code == 204 || code == 304 || expectEmptyBody;, +++ b/codec-http/src/test/java/io/netty/handler/codec/http/HttpContentEncoderTest.java, +    @Test, +    public void testEmptyHeadResponse() throws Exception {, +        EmbeddedChannel ch = new EmbeddedChannel(new TestEncoder());, +        HttpRequest req = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.HEAD, "/");, +        ch.writeInbound(req);, +, +        HttpResponse res = new DefaultHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.OK);, +        res.headers().set(HttpHeaderNames.TRANSFER_ENCODING, HttpHeaderValues.CHUNKED);, +        ch.writeOutbound(res);, +        ch.writeOutbound(LastHttpContent.EMPTY_LAST_CONTENT);, +, +        assertEmptyResponse(ch);, +    }, +, +    @Test, +    public void testHttp304Response() throws Exception {, +        EmbeddedChannel ch = new EmbeddedChannel(new TestEncoder());, +        HttpRequest req = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.GET, "/");, +        req.headers().set(HttpHeaderNames.ACCEPT_ENCODING, HttpHeaderValues.GZIP);, +        ch.writeInbound(req);, +, +        HttpResponse res = new DefaultHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.NOT_MODIFIED);, +        res.headers().set(HttpHeaderNames.TRANSFER_ENCODING, HttpHeaderValues.CHUNKED);, +        ch.writeOutbound(res);, +        ch.writeOutbound(LastHttpContent.EMPTY_LAST_CONTENT);, +, +        assertEmptyResponse(ch);, +    }, +, +    @Test, +    public void testConnect200Response() throws Exception {, +        EmbeddedChannel ch = new EmbeddedChannel(new TestEncoder());, +        HttpRequest req = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.CONNECT, "google.com:80");, +        ch.writeInbound(req);, +]