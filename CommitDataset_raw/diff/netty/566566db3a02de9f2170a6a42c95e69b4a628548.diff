[+++ b/resolver-dns/src/main/java/io/netty/resolver/dns/DefaultDnsCache.java, +import io.netty.util.concurrent.ScheduledFuture;, +    private final ConcurrentMap<String, List<DefaultDnsCacheEntry>> resolveCache =, +                                                            PlatformDependent.newConcurrentHashMap();, +        for (Iterator<Map.Entry<String, List<DefaultDnsCacheEntry>>> i = resolveCache.entrySet().iterator();, +             i.hasNext();) {, +            final Map.Entry<String, List<DefaultDnsCacheEntry>> e = i.next();, +        for (Iterator<Map.Entry<String, List<DefaultDnsCacheEntry>>> i = resolveCache.entrySet().iterator();, +             i.hasNext();) {, +            final Map.Entry<String, List<DefaultDnsCacheEntry>> e = i.next();, +    public List<? extends DnsCacheEntry> get(String hostname, DnsRecord[] additionals) {, +    private List<DefaultDnsCacheEntry> cachedEntries(String hostname) {, +        List<DefaultDnsCacheEntry> oldEntries = resolveCache.get(hostname);, +        final List<DefaultDnsCacheEntry> entries;, +            List<DefaultDnsCacheEntry> newEntries = new ArrayList<DefaultDnsCacheEntry>(8);, +    public DnsCacheEntry cache(String hostname, DnsRecord[] additionals,, +        final DefaultDnsCacheEntry e = new DefaultDnsCacheEntry(hostname, address);, +            return e;, +        final List<DefaultDnsCacheEntry> entries = cachedEntries(hostname);, +                final DefaultDnsCacheEntry firstEntry = entries.get(0);, +        return e;, +    public DnsCacheEntry cache(String hostname, DnsRecord[] additionals, Throwable cause, EventLoop loop) {, +        final DefaultDnsCacheEntry e = new DefaultDnsCacheEntry(hostname, cause);, +            return e;, +        final List<DefaultDnsCacheEntry> entries = cachedEntries(hostname);, +        return e;, +    private static void cancelExpiration(List<DefaultDnsCacheEntry> entries) {, +    private void scheduleCacheExpiration(final List<DefaultDnsCacheEntry> entries,, +                                         final DefaultDnsCacheEntry e,, +, +    private static final class DefaultDnsCacheEntry implements DnsCacheEntry {, +        private final String hostname;, +        private final InetAddress address;, +        private final Throwable cause;, +        private volatile ScheduledFuture<?> expirationFuture;, +, +        DefaultDnsCacheEntry(String hostname, InetAddress address) {, +            this.hostname = checkNotNull(hostname, "hostname");, +            this.address = checkNotNull(address, "address");, +            cause = null;, +        }, +, +        DefaultDnsCacheEntry(String hostname, Throwable cause) {, +            this.hostname = checkNotNull(hostname, "hostname");, +            this.cause = checkNotNull(cause, "cause");, +            address = null;, +        }, +, +        @Override, +        public InetAddress address() {, +            return address;, +        }, +, +        @Override, +        public Throwable cause() {, +            return cause;, +        }, +, +        String hostname() {, +            return hostname;, +        }, +, +        void scheduleExpiration(EventLoop loop, Runnable task, long delay, TimeUnit unit) {, +            assert expirationFuture == null : "expiration task scheduled already";, +            expirationFuture = loop.schedule(task, delay, unit);, +        }, +, +        void cancelExpiration() {, +            ScheduledFuture<?> expirationFuture = this.expirationFuture;, +            if (expirationFuture != null) {, +                expirationFuture.cancel(false);, +            }, +        }, +, +        @Override, +        public String toString() {, +            if (cause != null) {, +                return hostname + '/' + cause;, +            } else {, +                return address.toString();, +            }, +        }, +    }, +++ b/resolver-dns/src/main/java/io/netty/resolver/dns/DefaultDnsCache.java, +import io.netty.util.concurrent.ScheduledFuture;, +    private final ConcurrentMap<String, List<DefaultDnsCacheEntry>> resolveCache =, +                                                            PlatformDependent.newConcurrentHashMap();, +        for (Iterator<Map.Entry<String, List<DefaultDnsCacheEntry>>> i = resolveCache.entrySet().iterator();, +             i.hasNext();) {, +            final Map.Entry<String, List<DefaultDnsCacheEntry>> e = i.next();, +        for (Iterator<Map.Entry<String, List<DefaultDnsCacheEntry>>> i = resolveCache.entrySet().iterator();, +             i.hasNext();) {, +            final Map.Entry<String, List<DefaultDnsCacheEntry>> e = i.next();, +    public List<? extends DnsCacheEntry> get(String hostname, DnsRecord[] additionals) {, +    private List<DefaultDnsCacheEntry> cachedEntries(String hostname) {, +        List<DefaultDnsCacheEntry> oldEntries = resolveCache.get(hostname);, +        final List<DefaultDnsCacheEntry> entries;, +            List<DefaultDnsCacheEntry> newEntries = new ArrayList<DefaultDnsCacheEntry>(8);, +    public DnsCacheEntry cache(String hostname, DnsRecord[] additionals,, +        final DefaultDnsCacheEntry e = new DefaultDnsCacheEntry(hostname, address);]