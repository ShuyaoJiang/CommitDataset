[+++ b/transport/src/main/java/io/netty/channel/AbstractChannel.java, +    protected int calculateMessageSize(Object message) {, +++ b/transport/src/main/java/io/netty/channel/AbstractChannel.java, +    protected int calculateMessageSize(Object message) {, +++ b/transport/src/main/java/io/netty/channel/ChannelOutboundBuffer.java, +import io.netty.buffer.ByteBufHolder;, +    private int[] flushedPendingSizes;, +    private int[] unflushedPendingSizes;, +    private long totalPendingSize;, +        flushedPendingSizes = new int[initialCapacity];, +        unflushedPendingSizes = new int[initialCapacity];, +        if (totalPendingSize != 0) {, +        final int size = channel.calculateMessageSize(msg);, +        unflushedPendingSizes[unflushedCount] = size;, +        unflushedTotals[unflushedCount] = total(msg);, +    private static long total(Object msg) {, +        if (msg instanceof ByteBuf) {, +            return ((ByteBuf) msg).readableBytes();, +        }, +        if (msg instanceof FileRegion) {, +            return ((FileRegion) msg).count();, +        }, +        if (msg instanceof ByteBufHolder) {, +            return ((ByteBufHolder) msg).content().readableBytes();, +        }, +        return -1;, +    }, +, +        int[] a3 = new int[newCapacity];, +        System.arraycopy(unflushedPendingSizes, 0, a3, 0, unflushedCount);, +        unflushedPendingSizes = a3;, +, +        long[] a4 = new long[newCapacity];, +        System.arraycopy(unflushedTotals, 0, a4, 0, unflushedCount);, +        unflushedTotals = a4;, +        int[] unflushedPendingSizes = this.unflushedPendingSizes;, +        int[] flushedPendingSizes = this.flushedPendingSizes;, +            flushedPendingSizes[tail] = unflushedPendingSizes[i];, +                flushedPendingSizes = this.flushedPendingSizes;, +        int[] a3 = new int[newCapacity];, +        System.arraycopy(flushedPendingSizes, p, a3, 0, r);, +        System.arraycopy(flushedPendingSizes, 0, a3, r, p);, +        flushedPendingSizes = a3;, +        System.arraycopy(flushedProgresses, p, a4, 0, r);, +        System.arraycopy(flushedProgresses, 0, a4, r, p);, +        flushedProgresses = a4;, +, +        long[] a5 = new long[newCapacity];, +        System.arraycopy(flushedTotals, p, a5, 0, r);, +        System.arraycopy(flushedTotals, 0, a5, r, p);, +        flushedTotals = a5;, +    private void incrementPendingOutboundBytes(int size) {, +        long newWriteBufferSize = totalPendingSize += size;, +    private void decrementPendingOutboundBytes(int size) {, +        long newWriteBufferSize = totalPendingSize -= size;, +        decrementPendingOutboundBytes(flushedPendingSizes[head]);, +        flushedPendingSizes[head] = 0;, +        decrementPendingOutboundBytes(flushedPendingSizes[head]);, +        flushedPendingSizes[head] = 0;, +        return WRITABLE_UPDATER.get(this) != 0;, +        int[] unflushedPendingSizes = this.unflushedPendingSizes;, +                decrementPendingOutboundBytes(unflushedPendingSizes[i]);, +                unflushedPendingSizes[i] = 0;]