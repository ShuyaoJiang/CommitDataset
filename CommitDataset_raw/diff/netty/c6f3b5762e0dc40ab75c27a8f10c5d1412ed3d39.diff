[+++ b/common/src/main/java/io/netty/util/Signal.java, +    private final UniqueName uname;, +        uname = new UniqueName(map, name);, +++ b/common/src/main/java/io/netty/util/Signal.java, +    private final UniqueName uname;, +        uname = new UniqueName(map, name);, +++ b/common/src/main/java/io/netty/util/UniqueKey.java, +    public UniqueKey(ConcurrentMap<String, Boolean> map, String name, Class<T> valueType) {, +++ b/common/src/main/java/io/netty/util/Signal.java, +    private final UniqueName uname;, +        uname = new UniqueName(map, name);, +++ b/common/src/main/java/io/netty/util/UniqueKey.java, +    public UniqueKey(ConcurrentMap<String, Boolean> map, String name, Class<T> valueType) {, +++ b/common/src/main/java/io/netty/util/UniqueName.java, +    public UniqueName(ConcurrentMap<String, Boolean> map, String name, Object... args) {, +++ b/common/src/main/java/io/netty/util/Signal.java, +    private final UniqueName uname;, +        uname = new UniqueName(map, name);, +++ b/common/src/main/java/io/netty/util/UniqueKey.java, +    public UniqueKey(ConcurrentMap<String, Boolean> map, String name, Class<T> valueType) {, +++ b/common/src/main/java/io/netty/util/UniqueName.java, +    public UniqueName(ConcurrentMap<String, Boolean> map, String name, Object... args) {, +++ b/transport/src/main/java/io/netty/channel/AbstractChannel.java, +import java.util.Queue;, +                ChannelBufferHolder<Object> out = out();, +                if (out.hasByteBuffer()) {, +                    flushByteBuf(out.byteBuffer());, +                } else {, +                    flushMessageBuf(out.messageBuffer());, +        private void flushByteBuf(ChannelBuffer buf) throws Exception {, +            for (int i = config().getWriteSpinCount() - 1; i >= 0; i --) {, +                int localFlushedAmount = doFlush(i == 0);, +                if (localFlushedAmount > 0) {, +                    flushedAmount += localFlushedAmount;, +                    notifyFlushFutures();, +                    break;, +                }, +                if (!buf.readable()) {, +                    // Reset reader/writerIndex to 0 if the buffer is empty., +                    buf.clear();, +                    break;, +                }, +            }, +        }, +, +        private void flushMessageBuf(Queue<Object> buf) throws Exception {, +            final int writeSpinCount = config().getWriteSpinCount() - 1;, +            while (!buf.isEmpty()) {, +                boolean wrote = false;, +                for (int i = writeSpinCount; i >= 0; i --) {, +                    int localFlushedAmount = doFlush(i == 0);, +                    if (localFlushedAmount > 0) {, +                        flushedAmount += localFlushedAmount;, +                        wrote = true;, +                        notifyFlushFutures();, +                        break;, +                    }, +                }, +, +                if (!wrote) {, +                    break;, +                }, +            }, +        }, +, +++ b/common/src/main/java/io/netty/util/Signal.java, +    private final UniqueName uname;, +        uname = new UniqueName(map, name);, +++ b/common/src/main/java/io/netty/util/UniqueKey.java, +    public UniqueKey(ConcurrentMap<String, Boolean> map, String name, Class<T> valueType) {, +++ b/common/src/main/java/io/netty/util/UniqueName.java, +    public UniqueName(ConcurrentMap<String, Boolean> map, String name, Object... args) {, +++ b/transport/src/main/java/io/netty/channel/AbstractChannel.java, +import java.util.Queue;, +                ChannelBufferHolder<Object> out = out();, +                if (out.hasByteBuffer()) {, +                    flushByteBuf(out.byteBuffer());, +                } else {, +                    flushMessageBuf(out.messageBuffer());, +        private void flushByteBuf(ChannelBuffer buf) throws Exception {, +            for (int i = config().getWriteSpinCount() - 1; i >= 0; i --) {, +                int localFlushedAmount = doFlush(i == 0);, +                if (localFlushedAmount > 0) {, +                    flushedAmount += localFlushedAmount;, +                    notifyFlushFutures();, +                    break;, +                }, +                if (!buf.readable()) {, +                    // Reset reader/writerIndex to 0 if the buffer is empty., +                    buf.clear();, +                    break;, +                }, +            }, +        }, +, +        private void flushMessageBuf(Queue<Object> buf) throws Exception {, +            final int writeSpinCount = config().getWriteSpinCount() - 1;, +            while (!buf.isEmpty()) {, +                boolean wrote = false;, +                for (int i = writeSpinCount; i >= 0; i --) {]