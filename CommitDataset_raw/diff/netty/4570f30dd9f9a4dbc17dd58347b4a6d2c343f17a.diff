[+++ b/buffer/src/main/java/io/netty/buffer/ByteBufUtil.java, +import io.netty.util.internal.StringUtil;, +    private static final String NEWLINE = StringUtil.NEWLINE;, +    private static final String[] BYTE2HEX = new String[256];, +    private static final String[] HEXPADDING = new String[16];, +    private static final String[] BYTEPADDING = new String[16];, +    private static final char[] BYTE2CHAR = new char[256];, +    private static final String[] HEXDUMP_ROWPREFIXES = new String[65536 >>> 4];, +        int i;, +, +        // Generate the lookup table for byte-to-hex-dump conversion, +        for (i = 0; i < BYTE2HEX.length; i ++) {, +            BYTE2HEX[i] = ' ' + StringUtil.byteToHexStringPadded(i);, +        }, +, +        // Generate the lookup table for hex dump paddings, +        for (i = 0; i < HEXPADDING.length; i ++) {, +            int padding = HEXPADDING.length - i;, +            StringBuilder buf = new StringBuilder(padding * 3);, +            for (int j = 0; j < padding; j ++) {, +                buf.append("   ");, +            }, +            HEXPADDING[i] = buf.toString();, +        }, +, +        // Generate the lookup table for byte dump paddings, +        for (i = 0; i < BYTEPADDING.length; i ++) {, +            int padding = BYTEPADDING.length - i;, +            StringBuilder buf = new StringBuilder(padding);, +            for (int j = 0; j < padding; j ++) {, +                buf.append(' ');, +            }, +            BYTEPADDING[i] = buf.toString();, +        }, +, +        // Generate the lookup table for byte-to-char conversion, +        for (i = 0; i < BYTE2CHAR.length; i ++) {, +            if (i <= 0x1f || i >= 0x7f) {, +                BYTE2CHAR[i] = '.';, +            } else {, +                BYTE2CHAR[i] = (char) i;, +            }, +        }, +, +        // Generate the lookup table for the start-offset header in each row (up to 64KiB)., +        for (i = 0; i < HEXDUMP_ROWPREFIXES.length; i ++) {, +            StringBuilder buf = new StringBuilder(12);, +            buf.append(NEWLINE);, +            buf.append(Long.toHexString(i << 4 & 0xFFFFFFFFL | 0x100000000L));, +            buf.setCharAt(buf.length() - 9, '|');, +            buf.append('|');, +            HEXDUMP_ROWPREFIXES[i] = buf.toString();, +        }, +, +    /**, +     * Returns a multi-line hexadecimal dump of the specified {@link ByteBuf} that is easy to read by humans., +     */, +    public static String prettyHexDump(ByteBuf buffer) {, +        return prettyHexDump(buffer, buffer.readerIndex(), buffer.readableBytes());, +    }, +, +    /**, +     * Returns a multi-line hexadecimal dump of the specified {@link ByteBuf} that is easy to read by humans,, +     * starting at the given {@code offset} using the given {@code length}., +     */, +    public static String prettyHexDump(ByteBuf buffer, int offset, int length) {, +        if (length == 0) {, +            return StringUtil.EMPTY_STRING;, +        } else {, +            int rows = length / 16 + (length % 15 == 0? 0 : 1) + 4;, +            StringBuilder buf = new StringBuilder(rows * 80);, +            appendPrettyHexDump(buf, buffer, offset, length);, +            return buf.toString();, +        }, +    }, +, +    /**, +     * Appends the prettified multi-line hexadecimal dump of the specified {@link ByteBuf} to the specified, +     * {@link StringBuilder} that is easy to read by humans., +     */, +    public static void appendPrettyHexDump(StringBuilder dump, ByteBuf buf) {, +        appendPrettyHexDump(dump, buf, buf.readerIndex(), buf.readableBytes());, +    }, +, +    /**, +     * Appends the prettified multi-line hexadecimal dump of the specified {@link ByteBuf} to the specified, +     * {@link StringBuilder} that is easy to read by humans, starting at the given {@code offset} using, +     * the given {@code length}., +     */, +    public static void appendPrettyHexDump(StringBuilder dump, ByteBuf buf, int offset, int length) {, +        if (offset < 0 || length  > checkNotNull(buf, "buf").capacity() - offset) {, +            throw new IndexOutOfBoundsException(, +                    "expected: " + "0 <= offset(" + offset + ") <= offset + length(" + length, +                                                + ") <= " + "buf.capacity(" + buf.capacity() + ')');, +        }, +        if (length == 0) {, +            return;, +        }, +        dump.append(, +                          "         +-------------------------------------------------+" +]