[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2RemoteFlowController.java, +        private long pendingBytes;, +            return windowSize() > pendingBytes() && !cancelled;, +        public long pendingBytes() {, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2RemoteFlowController.java, +        private long pendingBytes;, +            return windowSize() > pendingBytes() && !cancelled;, +        public long pendingBytes() {, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2CodecUtil.java, +        return max(0, (int) min(state.pendingBytes(), state.windowSize()));, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2RemoteFlowController.java, +        private long pendingBytes;, +            return windowSize() > pendingBytes() && !cancelled;, +        public long pendingBytes() {, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2CodecUtil.java, +        return max(0, (int) min(state.pendingBytes(), state.windowSize()));, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/StreamByteDistributor.java, +        long pendingBytes();, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2RemoteFlowController.java, +        private long pendingBytes;, +            return windowSize() > pendingBytes() && !cancelled;, +        public long pendingBytes() {, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2CodecUtil.java, +        return max(0, (int) min(state.pendingBytes(), state.windowSize()));, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/StreamByteDistributor.java, +        long pendingBytes();, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/UniformStreamByteDistributor.java, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2RemoteFlowController.java, +        private long pendingBytes;, +            return windowSize() > pendingBytes() && !cancelled;, +        public long pendingBytes() {, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2CodecUtil.java, +        return max(0, (int) min(state.pendingBytes(), state.windowSize()));, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/StreamByteDistributor.java, +        long pendingBytes();, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/UniformStreamByteDistributor.java, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/WeightedFairQueueByteDistributor.java, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2RemoteFlowController.java, +        private long pendingBytes;, +            return windowSize() > pendingBytes() && !cancelled;, +        public long pendingBytes() {, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2CodecUtil.java, +        return max(0, (int) min(state.pendingBytes(), state.windowSize()));, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/StreamByteDistributor.java, +        long pendingBytes();, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/UniformStreamByteDistributor.java, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/WeightedFairQueueByteDistributor.java, +++ b/codec-http2/src/test/java/io/netty/handler/codec/http2/AbstractWeightedFairQueueByteDistributorDependencyTest.java, +import io.netty.handler.codec.http2.Http2TestUtil.TestStreamByteDistributorStreamState;, +import io.netty.util.collection.IntObjectHashMap;, +import io.netty.util.collection.IntObjectMap;, +    private IntObjectMap<TestStreamByteDistributorStreamState> stateMap =, +            new IntObjectHashMap<TestStreamByteDistributorStreamState>();, +                TestStreamByteDistributorStreamState state = stateMap.get(stream.id());, +                state.pendingBytes -= numBytes;, +                state.hasFrame = state.pendingBytes > 0;, +                state.isWriteAllowed = state.hasFrame;, +                if (closeIfNoFrame && !state.hasFrame) {, +                    stream.close();, +                }, +                distributor.updateStreamableBytes(state);, +    void initState(final int streamId, final long streamableBytes, final boolean hasFrame) {, +        initState(streamId, streamableBytes, hasFrame, hasFrame);, +    void initState(final int streamId, final long pendingBytes, final boolean hasFrame,, +                              final boolean isWriteAllowed) {, +        TestStreamByteDistributorStreamState state = new TestStreamByteDistributorStreamState(stream, pendingBytes,, +                hasFrame, isWriteAllowed);, +        stateMap.put(streamId, state);, +        distributor.updateStreamableBytes(state);, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2RemoteFlowController.java, +        private long pendingBytes;, +            return windowSize() > pendingBytes() && !cancelled;, +        public long pendingBytes() {, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2CodecUtil.java, +        return max(0, (int) min(state.pendingBytes(), state.windowSize()));, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/StreamByteDistributor.java, +        long pendingBytes();, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/UniformStreamByteDistributor.java, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/WeightedFairQueueByteDistributor.java, +++ b/codec-http2/src/test/java/io/netty/handler/codec/http2/AbstractWeightedFairQueueByteDistributorDependencyTest.java, +import io.netty.handler.codec.http2.Http2TestUtil.TestStreamByteDistributorStreamState;, +import io.netty.util.collection.IntObjectHashMap;, +import io.netty.util.collection.IntObjectMap;, +    private IntObjectMap<TestStreamByteDistributorStreamState> stateMap =, +            new IntObjectHashMap<TestStreamByteDistributorStreamState>();, +                TestStreamByteDistributorStreamState state = stateMap.get(stream.id());, +                state.pendingBytes -= numBytes;, +                state.hasFrame = state.pendingBytes > 0;, +                state.isWriteAllowed = state.hasFrame;, +                if (closeIfNoFrame && !state.hasFrame) {, +                    stream.close();, +                }, +                distributor.updateStreamableBytes(state);, +    void initState(final int streamId, final long streamableBytes, final boolean hasFrame) {, +        initState(streamId, streamableBytes, hasFrame, hasFrame);, +    void initState(final int streamId, final long pendingBytes, final boolean hasFrame,, +                              final boolean isWriteAllowed) {, +        TestStreamByteDistributorStreamState state = new TestStreamByteDistributorStreamState(stream, pendingBytes,, +                hasFrame, isWriteAllowed);, +        stateMap.put(streamId, state);]