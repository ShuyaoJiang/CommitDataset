[+++ b/transport/src/main/java/io/netty/bootstrap/AbstractBootstrap.java, +import io.netty.channel.ChannelFutureListener;, +import io.netty.channel.ChannelPromise;, +    private ChannelFuture doBind(final SocketAddress localAddress) {, +        final ChannelFuture regPromise = initAndRegister();, +        final Channel channel = regPromise.channel();, +        final ChannelPromise promise = channel.newPromise();, +        if (regPromise.isDone()) {, +            doBind0(regPromise, channel, localAddress, promise);, +        } else {, +            regPromise.addListener(new ChannelFutureListener() {, +                @Override, +                public void operationComplete(ChannelFuture future) throws Exception {, +                    doBind0(future, channel, localAddress, promise);, +                }, +            });, +        }, +, +        return promise;, +    }, +, +    final ChannelFuture initAndRegister() {, +        final Channel channel = channelFactory().newChannel();, +        try {, +            init(channel);, +        } catch (Throwable t) {, +            channel.unsafe().closeForcibly();, +            return channel.newFailedFuture(t);, +        }, +, +        ChannelPromise regPromise = channel.newPromise();, +        group().register(channel, regPromise);, +        if (regPromise.cause() != null) {, +            if (channel.isRegistered()) {, +                channel.close();, +            } else {, +                channel.unsafe().closeForcibly();, +            }, +        }, +, +        // If we are here and the promise is not failed, it's one of the following cases:, +        // 1) If we attempted registration from the event loop, the registration has been completed at this point., +        //    i.e. It's safe to attempt bind() or connect() now beause the channel has been registered., +        // 2) If we attempted registration from the other thread, the registration request has been successfully, +        //    added to the event loop's task queue for later execution., +        //    i.e. It's safe to attempt bind() or connect() now:, +        //         because bind() or connect() will be executed *after* the scheduled registration task is executed, +        //         because register(), bind(), and connect() are all bound to the same thread., +, +        return regPromise;, +    }, +, +    abstract void init(Channel channel) throws Exception;, +, +    private static void doBind0(, +            final ChannelFuture regFuture, final Channel channel,, +            final SocketAddress localAddress, final ChannelPromise promise) {, +, +        // This method is invoked before channelRegistered() is triggered.  Give user handlers a chance to set up, +        // the pipeline in its channelRegistered() implementation., +, +        channel.eventLoop().execute(new Runnable() {, +            @Override, +            public void run() {, +                if (regFuture.isSuccess()) {, +                    channel.bind(localAddress, promise).addListener(ChannelFutureListener.CLOSE_ON_FAILURE);, +                } else {, +                    promise.setFailure(regFuture.cause());, +                }, +            }, +        });, +    }, +++ b/transport/src/main/java/io/netty/bootstrap/AbstractBootstrap.java, +import io.netty.channel.ChannelFutureListener;, +import io.netty.channel.ChannelPromise;, +    private ChannelFuture doBind(final SocketAddress localAddress) {, +        final ChannelFuture regPromise = initAndRegister();, +        final Channel channel = regPromise.channel();, +        final ChannelPromise promise = channel.newPromise();, +        if (regPromise.isDone()) {, +            doBind0(regPromise, channel, localAddress, promise);, +        } else {, +            regPromise.addListener(new ChannelFutureListener() {, +                @Override, +                public void operationComplete(ChannelFuture future) throws Exception {, +                    doBind0(future, channel, localAddress, promise);, +                }, +            });, +        }, +, +        return promise;, +    }, +, +    final ChannelFuture initAndRegister() {, +        final Channel channel = channelFactory().newChannel();, +        try {, +            init(channel);, +        } catch (Throwable t) {, +            channel.unsafe().closeForcibly();, +            return channel.newFailedFuture(t);]