[+++ b/codec/src/main/java/io/netty/handler/codec/ByteToMessageDecoder.java, +            try {, +            } finally {, +                // We must release in in all cases as otherwise it may produce a leak if writeBytes(...) throw, +                // for whatever release (for example because of OutOfMemoryError), +                in.release();, +            }, +            try {, +                    // Expand cumulation (by replace it) when the refCnt is greater then 1 which may happen when the, +                    // user use slice().retain() or duplicate().retain()., +                    in = null;, +            } finally {, +                if (in != null) {, +                    // We must release if the ownership was not transfered as otherwise it may produce a leak if, +                    // writeBytes(...) throw for whatever release (for example because of OutOfMemoryError)., +                    in.release();, +                }, +            }, +++ b/codec/src/main/java/io/netty/handler/codec/ByteToMessageDecoder.java, +            try {, +            } finally {, +                // We must release in in all cases as otherwise it may produce a leak if writeBytes(...) throw, +                // for whatever release (for example because of OutOfMemoryError), +                in.release();, +            }, +            try {, +                    // Expand cumulation (by replace it) when the refCnt is greater then 1 which may happen when the, +                    // user use slice().retain() or duplicate().retain()., +                    in = null;, +            } finally {, +                if (in != null) {, +                    // We must release if the ownership was not transfered as otherwise it may produce a leak if, +                    // writeBytes(...) throw for whatever release (for example because of OutOfMemoryError)., +                    in.release();, +                }, +            }, +++ b/codec/src/test/java/io/netty/handler/codec/ByteToMessageDecoderTest.java, +import io.netty.buffer.CompositeByteBuf;, +import io.netty.buffer.UnpooledByteBufAllocator;, +import io.netty.buffer.UnpooledHeapByteBuf;, +import static org.junit.Assert.*;, +, +    @Test, +    public void releaseWhenMergeCumulateThrows() {, +        final Error error = new Error();, +, +        ByteBuf cumulation = new UnpooledHeapByteBuf(UnpooledByteBufAllocator.DEFAULT, 0, 64) {, +            @Override, +            public ByteBuf writeBytes(ByteBuf src) {, +                throw error;, +            }, +        };, +        ByteBuf in = Unpooled.buffer().writeZero(12);, +        try {, +            ByteToMessageDecoder.MERGE_CUMULATOR.cumulate(UnpooledByteBufAllocator.DEFAULT, cumulation, in);, +            fail();, +        } catch (Error expected) {, +            assertSame(error, expected);, +            assertEquals(0, in.refCnt());, +        }, +    }, +, +    @Test, +    public void releaseWhenCompositeCumulateThrows() {, +        final Error error = new Error();, +, +        ByteBuf cumulation = new CompositeByteBuf(UnpooledByteBufAllocator.DEFAULT, false, 64) {, +            @Override, +            public CompositeByteBuf addComponent(boolean increaseWriterIndex, ByteBuf buffer) {, +                throw error;, +            }, +        };, +        ByteBuf in = Unpooled.buffer().writeZero(12);, +        try {, +            ByteToMessageDecoder.COMPOSITE_CUMULATOR.cumulate(UnpooledByteBufAllocator.DEFAULT, cumulation, in);, +            fail();, +        } catch (Error expected) {, +            assertSame(error, expected);, +            assertEquals(0, in.refCnt());, +        }, +    }]