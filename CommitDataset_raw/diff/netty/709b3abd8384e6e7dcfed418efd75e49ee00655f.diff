[+++ b/transport/src/main/java/io/netty/channel/socket/aio/DefaultAioChannelFinder.java, +import java.util.HashMap;, +import java.util.Map;, +    private static volatile Map<Class<?>, Field> fieldCache = new HashMap<Class<?>, Field>();, +        Field f;, +        for (;;) {, +            f = findField(command);, +            if (f == null) {, +            Object next = f.get(command);, +            if (next instanceof AbstractAioChannel) {, +                return (AbstractAioChannel) next;, +            }, +            command = (Runnable) next;, +        }, +    private static Field findField(Object command) throws Exception {, +        Map<Class<?>, Field> fieldCache = DefaultAioChannelFinder.fieldCache;, +        Field res = fieldCache.get(commandType);, +        if (res != null) {, +            return res;, +        }, +, +                put(fieldCache, commandType, f);, +                return f;, +                Object candidate = f.get(command);, +                    put(fieldCache, commandType, f);, +                    return f;, +    private static void put(Map<Class<?>, Field> oldCache, Class<?> key, Field value) {, +        Map<Class<?>, Field> newCache = new HashMap<Class<?>, Field>(oldCache.size());, +        newCache.putAll(oldCache);, +        newCache.put(key, value);, +        fieldCache = newCache;, +++ b/transport/src/main/java/io/netty/channel/socket/aio/DefaultAioChannelFinder.java, +import java.util.HashMap;, +import java.util.Map;, +    private static volatile Map<Class<?>, Field> fieldCache = new HashMap<Class<?>, Field>();, +        Field f;, +        for (;;) {, +            f = findField(command);, +            if (f == null) {, +            Object next = f.get(command);, +            if (next instanceof AbstractAioChannel) {, +                return (AbstractAioChannel) next;, +            }, +            command = (Runnable) next;, +        }, +    private static Field findField(Object command) throws Exception {, +        Map<Class<?>, Field> fieldCache = DefaultAioChannelFinder.fieldCache;, +        Field res = fieldCache.get(commandType);, +        if (res != null) {, +            return res;, +        }, +, +                put(fieldCache, commandType, f);, +                return f;, +                Object candidate = f.get(command);, +                    put(fieldCache, commandType, f);, +                    return f;, +    private static void put(Map<Class<?>, Field> oldCache, Class<?> key, Field value) {, +        Map<Class<?>, Field> newCache = new HashMap<Class<?>, Field>(oldCache.size());, +        newCache.putAll(oldCache);, +        newCache.put(key, value);, +        fieldCache = newCache;, +++ b/transport/src/main/java/io/netty/channel/socket/aio/UnsafeAioChannelFinder.java, +import java.util.HashMap;, +import java.util.Map;, +class UnsafeAioChannelFinder implements AioChannelFinder {, +    private static volatile Map<Class<?>, Long> offsetCache = new HashMap<Class<?>, Long>();, +, +    public AbstractAioChannel findChannel(Runnable command) throws Exception {, +        Long offset;, +        for (;;) {, +            offset = findField(command);, +            if (offset == null) {, +                return null;, +            }, +            Object next = UNSAFE.getObject(command, offset);, +            if (next instanceof AbstractAioChannel) {, +                return (AbstractAioChannel) next;, +            }, +            command = (Runnable) next;, +        }, +    }, +, +    private static Long findField(Object command) throws Exception {, +        Map<Class<?>, Long> offsetCache = UnsafeAioChannelFinder.offsetCache;, +        Class<?> commandType = command.getClass();, +        Long res = offsetCache.get(commandType);, +        if (res != null) {, +            return res;, +        }, +, +        for (Field f: commandType.getDeclaredFields()) {, +            if (f.getType() == Runnable.class) {, +                res = UNSAFE.objectFieldOffset(f);, +                put(offsetCache, commandType, res);, +                return res;, +            }, +, +            if (f.getType() == Object.class) {, +                f.setAccessible(true);]