[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpServerUpgradeHandler.java, +import java.util.ArrayList;, +import static io.netty.util.internal.ObjectUtil.checkNotNull;, +     * Creates a new {@link UpgradeCodec} for the requested protocol name., +     */, +    public interface UpgradeCodecFactory {, +        /**, +         * Invoked by {@link HttpServerUpgradeHandler} for all the requested protocol names in the order of, +         * the client preference. The first non-{@code null} {@link UpgradeCodec} returned by this method, +         * will be selected., +         *, +         * @return a new {@link UpgradeCodec}, or {@code null} if the specified protocol name is not supported, +         */, +        UpgradeCodec newUpgradeCodec(String protocol);, +    }, +, +    /**, +    private static final String UPGRADE_STRING = HttpHeaderNames.UPGRADE.toString();, +, +    private final UpgradeCodecFactory upgradeCodecFactory;, +     * <p>, +     * The handler instantiated by this constructor will reject an upgrade request with non-empty content., +     * It should not be a concern because an upgrade request is most likely a GET request., +     * If you have a client that sends a non-GET upgrade request, please consider using, +     * {@link #HttpServerUpgradeHandler(SourceCodec, UpgradeCodecFactory, int)} to specify the maximum, +     * length of the content of an upgrade request., +     * </p>, +     * @param sourceCodec the codec that is being used initially, +     * @param upgradeCodecFactory the factory that creates a new upgrade codec, +     *                            for one of the requested upgrade protocols, +    public HttpServerUpgradeHandler(SourceCodec sourceCodec, UpgradeCodecFactory upgradeCodecFactory) {, +        this(sourceCodec, upgradeCodecFactory, 0);, +    }, +, +    /**, +     * Constructs the upgrader with the supported codecs., +     *, +     * @param sourceCodec the codec that is being used initially, +     * @param upgradeCodecFactory the factory that creates a new upgrade codec, +     *                            for one of the requested upgrade protocols, +     * @param maxContentLength the maximum length of the content of an upgrade request, +     */, +    public HttpServerUpgradeHandler(, +            SourceCodec sourceCodec, UpgradeCodecFactory upgradeCodecFactory, int maxContentLength) {, +, +        this.sourceCodec = checkNotNull(sourceCodec, "sourceCodec");, +        this.upgradeCodecFactory = checkNotNull(upgradeCodecFactory, "upgradeCodecFactory");, +        final ArrayList<String> requestedProtocols = splitHeader(request.headers().get(HttpHeaderNames.UPGRADE));, +        final int numRequestedProtocols = requestedProtocols.size();, +        UpgradeCodec upgradeCodec = null;, +        String upgradeProtocol = null;, +        for (int i = 0; i < numRequestedProtocols; i ++) {, +            final String p = requestedProtocols.get(i);, +            final UpgradeCodec c = upgradeCodecFactory.newUpgradeCodec(p);, +            if (c != null) {, +                upgradeProtocol = p;, +                upgradeCodec = c;, +                break;, +            }, +        }, +, +        List<String> values = splitHeader(connectionHeader);, +        if (!values.contains(UPGRADE_STRING) || !values.containsAll(requiredHeaders)) {, +        final UpgradeEvent event = new UpgradeEvent(upgradeProtocol, request);, +        final FullHttpResponse upgradeResponse = createUpgradeResponse(upgradeProtocol);, +, +        final UpgradeCodec finalUpgradeCodec = upgradeCodec;, +                        finalUpgradeCodec.upgradeTo(ctx, request, upgradeResponse);, +    private static FullHttpResponse createUpgradeResponse(String upgradeProtocol) {, +        res.headers().add(HttpHeaderNames.UPGRADE, upgradeProtocol);, +    private static ArrayList<String> splitHeader(CharSequence header) {, +        final StringBuilder builder = new StringBuilder(header.length());, +        final ArrayList<String> protocols = new ArrayList<String>(4);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpServerUpgradeHandler.java, +import java.util.ArrayList;, +import static io.netty.util.internal.ObjectUtil.checkNotNull;, +     * Creates a new {@link UpgradeCodec} for the requested protocol name., +     */, +    public interface UpgradeCodecFactory {, +        /**, +         * Invoked by {@link HttpServerUpgradeHandler} for all the requested protocol names in the order of, +         * the client preference. The first non-{@code null} {@link UpgradeCodec} returned by this method, +         * will be selected., +         *, +         * @return a new {@link UpgradeCodec}, or {@code null} if the specified protocol name is not supported, +         */, +        UpgradeCodec newUpgradeCodec(String protocol);, +    }, +, +    /**, +    private static final String UPGRADE_STRING = HttpHeaderNames.UPGRADE.toString();, +, +    private final UpgradeCodecFactory upgradeCodecFactory;, +     * <p>, +     * The handler instantiated by this constructor will reject an upgrade request with non-empty content., +     * It should not be a concern because an upgrade request is most likely a GET request., +     * If you have a client that sends a non-GET upgrade request, please consider using, +     * {@link #HttpServerUpgradeHandler(SourceCodec, UpgradeCodecFactory, int)} to specify the maximum, +     * length of the content of an upgrade request., +     * </p>]