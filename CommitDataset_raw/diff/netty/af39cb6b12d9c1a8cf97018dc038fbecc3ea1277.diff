[+++ b/transport/src/main/java/io/netty/channel/AbstractChannelHandlerContext.java, +import io.netty.util.internal.OneTimeTask;, +    private boolean handlerRemoved;, +, +    /**, +     * This is set to {@code true} once the {@link ChannelHandler#handlerAdded(ChannelHandlerContext) method was called., +     * We need to keep track of this This will set to true once the, +     * {@link ChannelHandler#handlerAdded(ChannelHandlerContext)} method was called. We need to keep track of this, +     * to ensure we will never call another {@link ChannelHandler} method before handlerAdded(...) was called, +     * to guard againstordering issues. {@link ChannelHandler#handlerAdded(ChannelHandlerContext)} MUST be the first, +     * method that is called for handler when it becomes a part of the {@link ChannelPipeline} in all cases. Not doing, +     * so may lead to unexpected side-effects as {@link ChannelHandler} implementationsmay need to do initialization, +     * steps before a  {@link ChannelHandler} can be used., +     *, +     * See <a href="https://github.com/netty/netty/issues/4705">#4705</a>, +     *, +     * No need to mark volatile as this will be made visible as next/prev is volatile., +     */, +    private boolean handlerAdded;, +        next.invokeChannelRegistered();, +        next.invokeChannelUnregistered();, +        next.invokeChannelActive();, +        next.invokeChannelInactive();, +        next.invokeExceptionCaught(cause);, +        next.invokeUserEventTriggered(event);, +        next.invokeChannelRead(pipeline.touch(msg, next));, +        next.invokeChannelReadComplete();, +        next.invokeChannelWritabilityChanged();, +        next.invokeBind(localAddress, promise);, +        next.invokeConnect(remoteAddress, localAddress, promise);, +        next.invokeDisconnect(promise);, +        next.invokeClose(promise);, +        next.invokeDeregister(promise);, +        next.invokeRead();, +        next.invokeWrite(pipeline.touch(msg, next), promise);, +        next.invokeFlush();, +        next.invokeWriteAndFlush(pipeline.touch(msg, next), promise);, +        handlerRemoved = true;, +        return handlerRemoved;, +    }, +, +    final void invokeChannelRegistered() {, +        final ChannelHandlerInvoker invoker = invoker();, +        if (handlerAdded) {, +            invoker.invokeChannelRegistered(this);, +        } else {, +            invoker.executor().execute(new OneTimeTask() {, +                @Override, +                public void run() {, +                    assert handlerAdded;, +                    invoker.invokeChannelRegistered(AbstractChannelHandlerContext.this);, +                }, +            });, +        }, +    }, +, +    final void invokeChannelUnregistered() {, +        final ChannelHandlerInvoker invoker = invoker();, +        if (handlerAdded) {, +            invoker.invokeChannelUnregistered(this);, +        } else {, +            invoker.executor().execute(new OneTimeTask() {, +                @Override, +                public void run() {, +                    assert handlerAdded;, +                    invoker.invokeChannelUnregistered(AbstractChannelHandlerContext.this);, +                }, +            });, +        }, +    }, +, +    final void invokeChannelActive() {, +        final ChannelHandlerInvoker invoker = invoker();, +        if (handlerAdded) {, +            invoker.invokeChannelActive(this);, +        } else {, +            invoker.executor().execute(new OneTimeTask() {, +                @Override, +                public void run() {, +                    assert handlerAdded;, +                    invoker.invokeChannelActive(AbstractChannelHandlerContext.this);, +                }, +            });, +        }, +    }, +, +    final void invokeChannelInactive() {, +        final ChannelHandlerInvoker invoker = invoker();, +        if (handlerAdded) {, +            invoker.invokeChannelInactive(this);, +        } else {, +            invoker.executor().execute(new OneTimeTask() {, +                @Override, +                public void run() {, +                    assert handlerAdded;, +                    invoker.invokeChannelInactive(AbstractChannelHandlerContext.this);, +                }, +            });, +        }, +    }]