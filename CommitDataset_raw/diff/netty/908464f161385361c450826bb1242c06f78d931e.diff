[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2ConnectionEncoder.java, +            final boolean exclusive, final int padding, final boolean endOfStream, ChannelPromise promise) {, +                    final ChannelFutureListener closeStreamLocalListener = new ChannelFutureListener() {, +                            lifecycleManager.closeStreamLocal(finalStream, future);, +                    };, +                    promise = promise.unvoid().addListener(closeStreamLocalListener);, +                return frameWriter.writeHeaders(ctx, streamId, headers, streamDependency, weight,, +                                                exclusive, padding, endOfStream, promise);, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2ConnectionEncoder.java, +            final boolean exclusive, final int padding, final boolean endOfStream, ChannelPromise promise) {, +                    final ChannelFutureListener closeStreamLocalListener = new ChannelFutureListener() {, +                            lifecycleManager.closeStreamLocal(finalStream, future);, +                    };, +                    promise = promise.unvoid().addListener(closeStreamLocalListener);, +                return frameWriter.writeHeaders(ctx, streamId, headers, streamDependency, weight,, +                                                exclusive, padding, endOfStream, promise);, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2ConnectionHandler.java, +        promise = promise.unvoid();, +                                     ChannelPromise promise) {, +        promise = promise.unvoid();, +            promise = promise.unvoid();, +            if (connection().goAwaySent()) {, +                // Protect against re-entrancy. Could happen if writing the frame fails, and error handling, +                // treating this is a connection handler and doing a graceful shutdown..., +                if (lastStreamId == connection().remote().lastStreamKnownByPeer()) {, +                    return promise;, +                }, +                if (lastStreamId > connection.remote().lastStreamKnownByPeer()) {, +            }, +, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2ConnectionEncoder.java, +            final boolean exclusive, final int padding, final boolean endOfStream, ChannelPromise promise) {, +                    final ChannelFutureListener closeStreamLocalListener = new ChannelFutureListener() {, +                            lifecycleManager.closeStreamLocal(finalStream, future);, +                    };, +                    promise = promise.unvoid().addListener(closeStreamLocalListener);, +                return frameWriter.writeHeaders(ctx, streamId, headers, streamDependency, weight,, +                                                exclusive, padding, endOfStream, promise);, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2ConnectionHandler.java, +        promise = promise.unvoid();, +                                     ChannelPromise promise) {, +        promise = promise.unvoid();, +            promise = promise.unvoid();, +            if (connection().goAwaySent()) {, +                // Protect against re-entrancy. Could happen if writing the frame fails, and error handling, +                // treating this is a connection handler and doing a graceful shutdown..., +                if (lastStreamId == connection().remote().lastStreamKnownByPeer()) {, +                    return promise;, +                }, +                if (lastStreamId > connection.remote().lastStreamKnownByPeer()) {, +            }, +, +++ b/codec-http2/src/test/java/io/netty/handler/codec/http2/DefaultHttp2ConnectionEncoderTest.java, +import static io.netty.handler.codec.http2.Http2TestUtil.newVoidPromise;, +import io.netty.channel.ChannelPipeline;, +    private ChannelPipeline pipeline;, +, +    @Mock, +        when(channel.pipeline()).thenReturn(pipeline);, +        ChannelPromise promise1 = newVoidPromise(channel);, +        ChannelPromise promise2 = newVoidPromise(channel);, +    @Test, +    public void writeHeadersUsingVoidPromise() throws Exception {, +        final Throwable cause = new RuntimeException("fake exception");, +        when(writer.writeHeaders(eq(ctx), eq(STREAM_ID), any(Http2Headers.class), anyInt(), anyShort(), anyBoolean(),, +                                 anyInt(), anyBoolean(), any(ChannelPromise.class))), +                .then(new Answer<ChannelFuture>() {, +                    @Override, +                    public ChannelFuture answer(InvocationOnMock invocationOnMock) throws Throwable {, +                        ChannelPromise promise = invocationOnMock.getArgumentAt(8, ChannelPromise.class);, +                        assertFalse(promise.isVoid());, +                        return promise.setFailure(cause);, +                    }, +                });, +        createStream(STREAM_ID, false);, +        // END_STREAM flag, so that a listener is added to the future., +        encoder.writeHeaders(ctx, STREAM_ID, EmptyHttp2Headers.INSTANCE, 0, true, newVoidPromise(channel));, +, +        verify(writer).writeHeaders(eq(ctx), eq(STREAM_ID), any(Http2Headers.class), anyInt(), anyShort(), anyBoolean(),, +                                    anyInt(), anyBoolean(), any(ChannelPromise.class));, +        // When using a void promise, the error should be propagated via the channel pipeline., +        verify(pipeline).fireExceptionCaught(cause);, +    }, +, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2ConnectionEncoder.java, +            final boolean exclusive, final int padding, final boolean endOfStream, ChannelPromise promise) {, +                    final ChannelFutureListener closeStreamLocalListener = new ChannelFutureListener() {, +                            lifecycleManager.closeStreamLocal(finalStream, future);, +                    };, +                    promise = promise.unvoid().addListener(closeStreamLocalListener);, +                return frameWriter.writeHeaders(ctx, streamId, headers, streamDependency, weight,, +                                                exclusive, padding, endOfStream, promise);, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2ConnectionHandler.java, +        promise = promise.unvoid();, +                                     ChannelPromise promise) {, +        promise = promise.unvoid();, +            promise = promise.unvoid();, +            if (connection().goAwaySent()) {, +                // Protect against re-entrancy. Could happen if writing the frame fails, and error handling, +                // treating this is a connection handler and doing a graceful shutdown...]