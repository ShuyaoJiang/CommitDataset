[+++ b/pom.xml, +++ b/pom.xml, +++ b/src/main/java/org/jboss/netty/channel/socket/sctp/DefaultNioSctpChannelConfig.java, +/*, + * Copyright 2011 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the, + * License for the specific language governing permissions and limitations, + * under the License., + */, +package org.jboss.netty.channel.socket.sctp;, +, +import com.sun.nio.sctp.SctpChannel;, +import java.util.Map;, +, +import org.jboss.netty.channel.AdaptiveReceiveBufferSizePredictorFactory;, +import org.jboss.netty.channel.ChannelException;, +import org.jboss.netty.channel.ReceiveBufferSizePredictor;, +import org.jboss.netty.channel.ReceiveBufferSizePredictorFactory;, +import org.jboss.netty.logging.InternalLogger;, +import org.jboss.netty.logging.InternalLoggerFactory;, +import org.jboss.netty.util.internal.ConversionUtil;, +, +/**, + * The default {@link org.jboss.netty.channel.socket.nio.NioSocketChannelConfig} implementation for SCTP., + *, + * @author <a href="http://www.jboss.org/netty/">The Netty Project</a>, + * @author <a href="http://gleamynode.net/">Trustin Lee</a>, + * @author <a href="http://github.com/jestan">Jestan Nirojan</a>, + */, +class DefaultNioSctpChannelConfig extends DefaultSctpChannelConfig implements NioSctpChannelConfig {, +, +    private static final InternalLogger logger =, +            InternalLoggerFactory.getInstance(DefaultNioSctpChannelConfig.class);, +, +    private static final ReceiveBufferSizePredictorFactory DEFAULT_PREDICTOR_FACTORY =, +            new AdaptiveReceiveBufferSizePredictorFactory();, +, +    private volatile int writeBufferHighWaterMark = 64 * 1024;, +    private volatile int writeBufferLowWaterMark = 32 * 1024;, +    private volatile ReceiveBufferSizePredictor predictor;, +    private volatile ReceiveBufferSizePredictorFactory predictorFactory = DEFAULT_PREDICTOR_FACTORY;, +    private volatile int writeSpinCount = 16;, +, +    DefaultNioSctpChannelConfig(SctpChannel channel) {, +       super(channel);, +    }, +, +    @Override, +    public void setOptions(Map<String, Object> options) {, +        super.setOptions(options);, +        if (getWriteBufferHighWaterMark() < getWriteBufferLowWaterMark()) {, +            // Recover the integrity of the configuration with a sensible value., +            setWriteBufferLowWaterMark0(getWriteBufferHighWaterMark() >>> 1);, +            // Notify the user about misconfiguration., +            logger.warn(, +                    "writeBufferLowWaterMark cannot be greater than " +, +                            "writeBufferHighWaterMark; setting to the half of the " +, +                            "writeBufferHighWaterMark.");, +        }, +    }, +, +    @Override, +    public boolean setOption(String key, Object value) {, +        if (super.setOption(key, value)) {, +            return true;, +        }, +, +        if (key.equals("writeBufferHighWaterMark")) {, +            setWriteBufferHighWaterMark0(ConversionUtil.toInt(value));, +        } else if (key.equals("writeBufferLowWaterMark")) {, +            setWriteBufferLowWaterMark0(ConversionUtil.toInt(value));, +        } else if (key.equals("writeSpinCount")) {, +            setWriteSpinCount(ConversionUtil.toInt(value));, +        } else if (key.equals("receiveBufferSizePredictorFactory")) {, +            setReceiveBufferSizePredictorFactory((ReceiveBufferSizePredictorFactory) value);, +        } else if (key.equals("receiveBufferSizePredictor")) {, +            setReceiveBufferSizePredictor((ReceiveBufferSizePredictor) value);, +        } else {, +            return false;, +        }, +        return true;, +    }, +, +    @Override, +    public int getWriteBufferHighWaterMark() {, +        return writeBufferHighWaterMark;, +    }, +, +    @Override, +    public void setWriteBufferHighWaterMark(int writeBufferHighWaterMark) {, +        if (writeBufferHighWaterMark < getWriteBufferLowWaterMark()) {]