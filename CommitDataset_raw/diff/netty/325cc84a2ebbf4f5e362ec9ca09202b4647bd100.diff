[+++ b/handler/src/main/java/io/netty/handler/ssl/ReferenceCountedOpenSslEngine.java, +import java.security.AlgorithmConstraints;, +import java.util.Collection;, +import javax.net.ssl.SNIMatcher;, +            if (sslParameters.getAlgorithmConstraints() != null) {, +                throw new IllegalArgumentException("AlgorithmConstraints are not supported.");, +            if (version >= 8) {, +                Collection<SNIMatcher> matchers = sslParameters.getSNIMatchers();, +                if (matchers != null && !matchers.isEmpty()) {, +                    throw new IllegalArgumentException("SNIMatchers are not supported.");, +                }, +, +                if (!isDestroyed()) {, +, +            final String endPointIdentificationAlgorithm = sslParameters.getEndpointIdentificationAlgorithm();, +            final boolean endPointVerificationEnabled = endPointIdentificationAlgorithm != null &&, +                    !endPointIdentificationAlgorithm.isEmpty();, +            SSL.setHostNameValidation(ssl, DEFAULT_HOSTNAME_VALIDATION_FLAGS,, +                    endPointVerificationEnabled ? getPeerHost() : null);, +            // If the user asks for hostname verification we must ensure we verify the peer., +            // If the user disables hostname verification we leave it up to the user to change the mode manually., +            if (clientMode && endPointVerificationEnabled) {, +                SSL.setVerify(ssl, SSL.SSL_CVERIFY_REQUIRED, -1);, +            }, +, +            this.endPointIdentificationAlgorithm = endPointIdentificationAlgorithm;, +            algorithmConstraints = sslParameters.getAlgorithmConstraints();, +        }, +        super.setSSLParameters(sslParameters);, +++ b/handler/src/main/java/io/netty/handler/ssl/ReferenceCountedOpenSslEngine.java, +import java.security.AlgorithmConstraints;, +import java.util.Collection;, +import javax.net.ssl.SNIMatcher;, +            if (sslParameters.getAlgorithmConstraints() != null) {, +                throw new IllegalArgumentException("AlgorithmConstraints are not supported.");, +            if (version >= 8) {, +                Collection<SNIMatcher> matchers = sslParameters.getSNIMatchers();, +                if (matchers != null && !matchers.isEmpty()) {, +                    throw new IllegalArgumentException("SNIMatchers are not supported.");, +                }, +, +                if (!isDestroyed()) {, +, +            final String endPointIdentificationAlgorithm = sslParameters.getEndpointIdentificationAlgorithm();, +            final boolean endPointVerificationEnabled = endPointIdentificationAlgorithm != null &&, +                    !endPointIdentificationAlgorithm.isEmpty();, +            SSL.setHostNameValidation(ssl, DEFAULT_HOSTNAME_VALIDATION_FLAGS,, +                    endPointVerificationEnabled ? getPeerHost() : null);, +            // If the user asks for hostname verification we must ensure we verify the peer., +            // If the user disables hostname verification we leave it up to the user to change the mode manually., +            if (clientMode && endPointVerificationEnabled) {, +                SSL.setVerify(ssl, SSL.SSL_CVERIFY_REQUIRED, -1);, +            }, +, +            this.endPointIdentificationAlgorithm = endPointIdentificationAlgorithm;, +            algorithmConstraints = sslParameters.getAlgorithmConstraints();, +        }, +        super.setSSLParameters(sslParameters);, +++ b/handler/src/test/java/io/netty/handler/ssl/OpenSslEngineTest.java, +import java.security.AlgorithmConstraints;, +import java.security.AlgorithmParameters;, +import java.security.CryptoPrimitive;, +import java.security.Key;, +import java.util.Collections;, +import java.util.Set;, +import javax.net.ssl.SNIMatcher;, +import javax.net.ssl.SNIServerName;, +import javax.net.ssl.SSLParameters;, +    @Test(expected = IllegalArgumentException.class), +    public void testSNIMatchersThrows() throws Exception {, +        assumeTrue(PlatformDependent.javaVersion() >= 8);, +        SelfSignedCertificate ssc = new SelfSignedCertificate();, +        serverSslCtx = SslContextBuilder.forServer(ssc.certificate(), ssc.privateKey()), +                .sslProvider(sslServerProvider()), +                .build();, +, +        SSLEngine engine = serverSslCtx.newEngine(UnpooledByteBufAllocator.DEFAULT);, +        try {, +            SSLParameters parameters = new SSLParameters();, +            SNIMatcher matcher = new SNIMatcher(0) {, +                @Override, +                public boolean matches(SNIServerName sniServerName) {, +                    return false;, +                }, +            };, +            parameters.setSNIMatchers(Collections.singleton(matcher));, +            engine.setSSLParameters(parameters);, +        } finally {, +            cleanupServerSslEngine(engine);, +            ssc.delete();, +        }, +    }, +, +    @Test(expected = IllegalArgumentException.class), +    public void testAlgorithmConstraintsThrows() throws Exception {, +        SelfSignedCertificate ssc = new SelfSignedCertificate();, +        serverSslCtx = SslContextBuilder.forServer(ssc.certificate(), ssc.privateKey()), +                .sslProvider(sslServerProvider()), +                .build();, +]