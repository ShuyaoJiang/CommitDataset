[+++ b/transport-native-epoll/src/main/c/netty_epoll_native.c, +static inline void cpu_relax() {, +#if defined(__x86_64__), +    asm volatile("pause\n": : :"memory");, +#endif, +}, +, +static jint netty_epoll_native_epollBusyWait0(JNIEnv* env, jclass clazz, jint efd, jlong address, jint len) {, +    struct epoll_event *ev = (struct epoll_event*) (intptr_t) address;, +    int result, err;, +, +    // Zeros = poll (aka return immediately)., +    do {, +        result = epoll_wait(efd, ev, len, 0);, +        if (result == 0) {, +            // Since we're always polling epoll_wait with no timeout,, +            // signal CPU that we're in a busy loop, +            cpu_relax();, +        }, +, +        if (result >= 0) {, +            return result;, +        }, +    } while((err = errno) == EINTR);, +, +    return -err;, +}, +, +  { "epollBusyWait0", "(IJI)I", (void *) netty_epoll_native_epollBusyWait0 },, +++ b/transport-native-epoll/src/main/c/netty_epoll_native.c, +static inline void cpu_relax() {, +#if defined(__x86_64__), +    asm volatile("pause\n": : :"memory");, +#endif, +}, +, +static jint netty_epoll_native_epollBusyWait0(JNIEnv* env, jclass clazz, jint efd, jlong address, jint len) {, +    struct epoll_event *ev = (struct epoll_event*) (intptr_t) address;, +    int result, err;, +, +    // Zeros = poll (aka return immediately)., +    do {, +        result = epoll_wait(efd, ev, len, 0);, +        if (result == 0) {, +            // Since we're always polling epoll_wait with no timeout,, +            // signal CPU that we're in a busy loop, +            cpu_relax();, +        }, +, +        if (result >= 0) {, +            return result;, +        }, +    } while((err = errno) == EINTR);, +, +    return -err;, +}, +, +  { "epollBusyWait0", "(IJI)I", (void *) netty_epoll_native_epollBusyWait0 },, +++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollEventLoop.java, +    private int epollBusyWait() throws IOException {, +        return Native.epollBusyWait(epollFd, events);, +    }, +, +, +                    case SelectStrategy.BUSY_WAIT:, +                        strategy = epollBusyWait();, +                        break;, +, +++ b/transport-native-epoll/src/main/c/netty_epoll_native.c, +static inline void cpu_relax() {, +#if defined(__x86_64__), +    asm volatile("pause\n": : :"memory");, +#endif, +}, +, +static jint netty_epoll_native_epollBusyWait0(JNIEnv* env, jclass clazz, jint efd, jlong address, jint len) {, +    struct epoll_event *ev = (struct epoll_event*) (intptr_t) address;, +    int result, err;, +, +    // Zeros = poll (aka return immediately)., +    do {, +        result = epoll_wait(efd, ev, len, 0);, +        if (result == 0) {, +            // Since we're always polling epoll_wait with no timeout,, +            // signal CPU that we're in a busy loop, +            cpu_relax();, +        }, +, +        if (result >= 0) {, +            return result;, +        }, +    } while((err = errno) == EINTR);, +, +    return -err;, +}, +, +  { "epollBusyWait0", "(IJI)I", (void *) netty_epoll_native_epollBusyWait0 },, +++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollEventLoop.java, +    private int epollBusyWait() throws IOException {, +        return Native.epollBusyWait(epollFd, events);]