[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectAggregator.java, +            // If keep-alive is off and 'Expect: 100-continue' is missing, no need to leave the connection open., +                    (!HttpHeaders.is100ContinueExpected(oversized) && !HttpHeaders.isKeepAlive(oversized))) {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectAggregator.java, +            // If keep-alive is off and 'Expect: 100-continue' is missing, no need to leave the connection open., +                    (!HttpHeaders.is100ContinueExpected(oversized) && !HttpHeaders.isKeepAlive(oversized))) {, +++ b/codec-http/src/test/java/io/netty/handler/codec/http/HttpObjectAggregatorTest.java, +    @Test, +    public void testRequestAfterOversized100ContinueAndDecoder() {, +        EmbeddedChannel embedder = new EmbeddedChannel(new HttpRequestDecoder(), new HttpObjectAggregator(15));, +, +        // Write first request with Expect: 100-continue, +        HttpRequest message = new DefaultHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.PUT, "http://localhost");, +        HttpHeaders.set100ContinueExpected(message);, +        HttpHeaders.setContentLength(message, 16);, +, +        HttpContent chunk1 = releaseLater(new DefaultHttpContent(Unpooled.copiedBuffer("some", CharsetUtil.US_ASCII)));, +        HttpContent chunk2 = releaseLater(new DefaultHttpContent(Unpooled.copiedBuffer("test", CharsetUtil.US_ASCII)));, +        HttpContent chunk3 = LastHttpContent.EMPTY_LAST_CONTENT;, +, +        // Send a request with 100-continue + large Content-Length header value., +        assertFalse(embedder.writeInbound(message));, +, +        // The agregator should respond with '413 Request Entity Too Large.', +        FullHttpResponse response = embedder.readOutbound();, +        assertEquals(HttpResponseStatus.REQUEST_ENTITY_TOO_LARGE, response.status());, +        assertEquals("0", response.headers().get(Names.CONTENT_LENGTH));, +, +        // An ill-behaving client could continue to send data without a respect, and such data should be discarded., +        assertFalse(embedder.writeInbound(chunk1));, +, +        // The aggregator should not close the connection because keep-alive is on., +        assertTrue(embedder.isOpen());, +, +        // Now send a valid request., +        HttpRequest message2 = new DefaultHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.PUT, "http://localhost");, +, +        assertFalse(embedder.writeInbound(message2));, +        assertFalse(embedder.writeInbound(chunk2));, +        assertTrue(embedder.writeInbound(chunk3));, +, +        FullHttpRequest fullMsg = embedder.readInbound();, +        assertNotNull(fullMsg);, +, +        assertEquals(, +                chunk2.content().readableBytes() + chunk3.content().readableBytes(),, +                HttpHeaders.getContentLength(fullMsg));, +, +        assertEquals(HttpHeaders.getContentLength(fullMsg), fullMsg.content().readableBytes());, +, +        fullMsg.release();, +        assertFalse(embedder.finish());, +    }, +, +, +        if (serverShouldCloseConnection(message)) {, +        } else {, +            assertTrue(embedder.isOpen());, +        }, +    }, +, +    private static boolean serverShouldCloseConnection(HttpRequest message) {, +        // The connection should only be kept open if Expect: 100-continue is set,, +        // or if keep-alive is on., +        if (HttpHeaders.is100ContinueExpected(message)) {, +            return false;, +        }, +        if (HttpHeaders.isKeepAlive(message)) {, +            return false;, +        }, +        return true;]