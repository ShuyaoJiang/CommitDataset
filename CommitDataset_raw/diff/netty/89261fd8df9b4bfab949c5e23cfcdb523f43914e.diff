[+++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollSocketChannel.java, +    private Runnable flushTask;, +    private int doWriteBytes(ByteBuf buf) throws Exception {, +                ByteBuffer nioBuf = buf.internalNioBuffer(readerIndex, buf.readableBytes());, +        boolean done = false;, +        boolean setEpollOut = false;, +        long writtenBytes = 0;, +        for (int i = config().getWriteSpinCount() - 1; i >= 0; i --) {, +            if (localWrittenBytes == 0) {, +                setEpollOut = true;, +                break;, +            }, +            expectedWrittenBytes -= localWrittenBytes;, +            writtenBytes += localWrittenBytes;, +            if (expectedWrittenBytes == 0) {, +                done = true;, +                break;, +            }, +        }, +        if (done) {, +            // Release all buffers, +            for (int i = msgCount; i > 0; i --) {, +                in.remove();, +            }, +            // Finish the write loop if no new messages were flushed by in.remove()., +            if (in.isEmpty()) {, +                clearEpollOut();, +            }, +        } else {, +            // Did not write all buffers completely., +            // Release the fully written buffers and update the indexes of the partially written buffer., +                if (readableBytes < writtenBytes) {, +                    writtenBytes -= readableBytes;, +                } else if (readableBytes > writtenBytes) {, +                    buf.readerIndex(readerIndex + (int) writtenBytes);, +                    in.progress(writtenBytes);, +            incompleteWrite(setEpollOut);, +, +    private void incompleteWrite(boolean setEpollOut) {, +        // Did not write completely., +        if (setEpollOut) {, +            setEpollOut();, +        } else {, +            // Schedule flush again later so other tasks can be picked up in the meantime, +            Runnable flushTask = this.flushTask;, +            if (flushTask == null) {, +                flushTask = this.flushTask = new Runnable() {, +                    @Override, +                    public void run() {, +                        flush();, +                    }, +                };, +            }, +            eventLoop().execute(flushTask);, +        }, +                boolean setEpollOut = false;, +                boolean done = false;, +                long flushedAmount = 0;, +                int writeSpinCount = config().getWriteSpinCount();, +                for (int i = writeSpinCount - 1; i >= 0; i --) {, +                    int localFlushedAmount = doWriteBytes(buf);, +                    if (localFlushedAmount == 0) {, +                        setEpollOut = true;, +, +                    flushedAmount += localFlushedAmount;, +                        done = true;, +                        break;, +                    }, +                in.progress(flushedAmount);, +, +                if (done) {, +                    in.remove();, +                } else {, +                    incompleteWrite(setEpollOut);, +                    break;, +                }]