[+++ b/src/main/java/org/jboss/netty/channel/ChannelFuture.java, + * In spite of the disadvantages mentioned above, there are certainly the cases, + * {@link IllegalStateException} will be raised to prevent a dead lock., +++ b/src/main/java/org/jboss/netty/channel/ChannelFuture.java, + * In spite of the disadvantages mentioned above, there are certainly the cases, + * {@link IllegalStateException} will be raised to prevent a dead lock., +++ b/src/main/java/org/jboss/netty/channel/ChannelFutureListener.java, + * <h3>Return the control to the caller quickly</h3>, + *, + * {@link #operationComplete(ChannelFuture)} is directly called by an I/O, + * thread.  Therefore, performing a time consuming task or a blocking operation, + * in the handler method can cause an unexpected pause during I/O., + *, +++ b/src/main/java/org/jboss/netty/channel/ChannelFuture.java, + * In spite of the disadvantages mentioned above, there are certainly the cases, + * {@link IllegalStateException} will be raised to prevent a dead lock., +++ b/src/main/java/org/jboss/netty/channel/ChannelFutureListener.java, + * <h3>Return the control to the caller quickly</h3>, + *, + * {@link #operationComplete(ChannelFuture)} is directly called by an I/O, + * thread.  Therefore, performing a time consuming task or a blocking operation, + * in the handler method can cause an unexpected pause during I/O., + *, +++ b/src/main/java/org/jboss/netty/channel/ChannelHandler.java, + * {@link ChannelHandler} itself does not provide any method.  To handle a, + * {@link ChannelEvent} you need to implement its sub-interfaces.  There are, + * two sub-interfaces which handles a received event, one for upstream events, + * and the other for downstream events:, + * each sub-interface on how an event is interpreted when it goes upstream and, + * or the previous handler or modify the behavior of the pipeline by adding or, + * Please refer to the {@link ChannelEvent} and {@link ChannelPipeline}, + * documentation to find out what a upstream event and a downstream event are,, + * what fundamental differences they have, and how they flow in a pipeline., + * @apiviz.exclude ^org\.jboss\.netty\.handler\..*$, +++ b/src/main/java/org/jboss/netty/channel/ChannelFuture.java, + * In spite of the disadvantages mentioned above, there are certainly the cases, + * {@link IllegalStateException} will be raised to prevent a dead lock., +++ b/src/main/java/org/jboss/netty/channel/ChannelFutureListener.java, + * <h3>Return the control to the caller quickly</h3>, + *, + * {@link #operationComplete(ChannelFuture)} is directly called by an I/O, + * thread.  Therefore, performing a time consuming task or a blocking operation, + * in the handler method can cause an unexpected pause during I/O., + *, +++ b/src/main/java/org/jboss/netty/channel/ChannelHandler.java, + * {@link ChannelHandler} itself does not provide any method.  To handle a, + * {@link ChannelEvent} you need to implement its sub-interfaces.  There are, + * two sub-interfaces which handles a received event, one for upstream events, + * and the other for downstream events:, + * each sub-interface on how an event is interpreted when it goes upstream and, + * or the previous handler or modify the behavior of the pipeline by adding or, + * Please refer to the {@link ChannelEvent} and {@link ChannelPipeline}, + * documentation to find out what a upstream event and a downstream event are,, + * what fundamental differences they have, and how they flow in a pipeline., + * @apiviz.exclude ^org\.jboss\.netty\.handler\..*$, +++ b/src/main/java/org/jboss/netty/channel/ChannelHandlerContext.java, + * {@link ChannelHandler} in a {@link ChannelPipeline}., + * +---------+ 1 .. 1 +----------+ 1    n +---------+ n    m +---------+, + * | Channel |--------| Pipeline |--------| Context |--------| Handler |, + * +---------+        +----------+        +---------+        +---------+, + *  n = the number of the handler entries in a pipeline, + * </pre>, + *, + * Please note that a {@link ChannelHandler} instance can be added to more than, + * one {@link ChannelPipeline}.  It means a single {@link ChannelHandler}, + * instance can have more than one {@link ChannelHandlerContext} and therefore, + * can be invoked with different {@link ChannelHandlerContext}s if it is added, + * to one or more {@link ChannelPipeline}s more than once.  For example, the, + * following handler will have as many independent attachments as how many, + * times it is added to pipelines, regardless if it is added to the same, + * pipeline multiple times or added to different pipelines multiple times:, + * <pre>, + * public class FibonacciHandler extends SimpleUpstreamChannelHandler {, + *   public void messageReceived(ChannelHandlerContext ctx, MessageEvent evt) {, + *     Integer a = (Integer) ctx.getAttachment();, + *     Integer b = (Integer) evt.getMessage();, + *, + *     if (a == null) {, + *       a = 0;, + *     }, + *, + *     ctx.setAttachment(Integer.valueOf(a + b));, + *   }, + * }, +++ b/src/main/java/org/jboss/netty/channel/ChannelFuture.java, + * In spite of the disadvantages mentioned above, there are certainly the cases, + * {@link IllegalStateException} will be raised to prevent a dead lock., +++ b/src/main/java/org/jboss/netty/channel/ChannelFutureListener.java, + * <h3>Return the control to the caller quickly</h3>, + *, + * {@link #operationComplete(ChannelFuture)} is directly called by an I/O, + * thread.  Therefore, performing a time consuming task or a blocking operation, + * in the handler method can cause an unexpected pause during I/O., + *, +++ b/src/main/java/org/jboss/netty/channel/ChannelHandler.java, + * {@link ChannelHandler} itself does not provide any method.  To handle a, + * {@link ChannelEvent} you need to implement its sub-interfaces.  There are, + * two sub-interfaces which handles a received event, one for upstream events, + * and the other for downstream events:, + * each sub-interface on how an event is interpreted when it goes upstream and]