[+++ b/buffer/src/main/java/io/netty/buffer/PoolArena.java, +                    s.chunk.initBufWithSubpage(buf, null, handle, reqCapacity);, +        boolean success = c.allocate(buf, reqCapacity, normCapacity);, +        assert success;, +    void free(PoolChunk<T> chunk, ByteBuffer nioBuffer, long handle, int normCapacity, PoolThreadCache cache) {, +            if (cache != null && cache.add(this, chunk, nioBuffer, handle, normCapacity, sizeClass)) {, +            freeChunk(chunk, handle, sizeClass, nioBuffer);, +    void freeChunk(PoolChunk<T> chunk, long handle, SizeClass sizeClass, ByteBuffer nioBuffer) {, +            destroyChunk = !chunk.parent.free(chunk, handle, nioBuffer);, +        ByteBuffer oldNioBuffer = buf.tmpNioBuf;, +            free(oldChunk, oldNioBuffer, oldHandle, oldMaxLength, buf.cache);, +++ b/buffer/src/main/java/io/netty/buffer/PoolArena.java, +                    s.chunk.initBufWithSubpage(buf, null, handle, reqCapacity);, +        boolean success = c.allocate(buf, reqCapacity, normCapacity);, +        assert success;, +    void free(PoolChunk<T> chunk, ByteBuffer nioBuffer, long handle, int normCapacity, PoolThreadCache cache) {, +            if (cache != null && cache.add(this, chunk, nioBuffer, handle, normCapacity, sizeClass)) {, +            freeChunk(chunk, handle, sizeClass, nioBuffer);, +    void freeChunk(PoolChunk<T> chunk, long handle, SizeClass sizeClass, ByteBuffer nioBuffer) {, +            destroyChunk = !chunk.parent.free(chunk, handle, nioBuffer);, +        ByteBuffer oldNioBuffer = buf.tmpNioBuf;, +            free(oldChunk, oldNioBuffer, oldHandle, oldMaxLength, buf.cache);, +++ b/buffer/src/main/java/io/netty/buffer/PoolChunk.java, +import java.nio.ByteBuffer;, +import java.util.ArrayDeque;, +import java.util.Deque;, +, +    // Use as cache for ByteBuffer created from the memory. These are just duplicates and so are only a container, +    // around the memory itself. These are often needed for operations within the Pooled*ByteBuf and so, +    // may produce extra GC, which can be greatly reduced by caching the duplicates., +    //, +    // This may be null if the PoolChunk is unpooled as pooling the ByteBuffer instances does not make any sense here., +    private final Deque<ByteBuffer> cachedNioBuffers;, +, +        cachedNioBuffers = new ArrayDeque<ByteBuffer>(8);, +        cachedNioBuffers = null;, +    boolean allocate(PooledByteBuf<T> buf, int reqCapacity, int normCapacity) {, +        final long handle;, +            handle =  allocateRun(normCapacity);, +            handle = allocateSubpage(normCapacity);, +, +        if (handle < 0) {, +            return false;, +        }, +        ByteBuffer nioBuffer = cachedNioBuffers != null ? cachedNioBuffers.pollLast() : null;, +        initBuf(buf, nioBuffer, handle, reqCapacity);, +        return true;, +        synchronized (head) {, +    void free(long handle, ByteBuffer nioBuffer) {, +, +        if (nioBuffer != null && cachedNioBuffers != null &&, +                cachedNioBuffers.size() < PooledByteBufAllocator.DEFAULT_MAX_CACHED_BYTEBUFFERS_PER_CHUNK) {, +            cachedNioBuffers.offer(nioBuffer);, +        }, +    void initBuf(PooledByteBuf<T> buf, ByteBuffer nioBuffer, long handle, int reqCapacity) {, +            buf.init(this, nioBuffer, handle, runOffset(memoryMapIdx) + offset,, +                    reqCapacity, runLength(memoryMapIdx), arena.parent.threadCache());, +            initBufWithSubpage(buf, nioBuffer, handle, bitmapIdx, reqCapacity);, +    void initBufWithSubpage(PooledByteBuf<T> buf, ByteBuffer nioBuffer, long handle, int reqCapacity) {, +        initBufWithSubpage(buf, nioBuffer, handle, bitmapIdx(handle), reqCapacity);, +    private void initBufWithSubpage(PooledByteBuf<T> buf, ByteBuffer nioBuffer,, +                                    long handle, int bitmapIdx, int reqCapacity) {, +            this, nioBuffer, handle,, +++ b/buffer/src/main/java/io/netty/buffer/PoolArena.java, +                    s.chunk.initBufWithSubpage(buf, null, handle, reqCapacity);, +        boolean success = c.allocate(buf, reqCapacity, normCapacity);, +        assert success;, +    void free(PoolChunk<T> chunk, ByteBuffer nioBuffer, long handle, int normCapacity, PoolThreadCache cache) {, +            if (cache != null && cache.add(this, chunk, nioBuffer, handle, normCapacity, sizeClass)) {, +            freeChunk(chunk, handle, sizeClass, nioBuffer);, +    void freeChunk(PoolChunk<T> chunk, long handle, SizeClass sizeClass, ByteBuffer nioBuffer) {, +            destroyChunk = !chunk.parent.free(chunk, handle, nioBuffer);, +        ByteBuffer oldNioBuffer = buf.tmpNioBuf;, +            free(oldChunk, oldNioBuffer, oldHandle, oldMaxLength, buf.cache);, +++ b/buffer/src/main/java/io/netty/buffer/PoolChunk.java, +import java.nio.ByteBuffer;, +import java.util.ArrayDeque;, +import java.util.Deque;, +, +    // Use as cache for ByteBuffer created from the memory. These are just duplicates and so are only a container, +    // around the memory itself. These are often needed for operations within the Pooled*ByteBuf and so, +    // may produce extra GC, which can be greatly reduced by caching the duplicates., +    //, +    // This may be null if the PoolChunk is unpooled as pooling the ByteBuffer instances does not make any sense here., +    private final Deque<ByteBuffer> cachedNioBuffers;, +, +        cachedNioBuffers = new ArrayDeque<ByteBuffer>(8);, +        cachedNioBuffers = null;, +    boolean allocate(PooledByteBuf<T> buf, int reqCapacity, int normCapacity) {, +        final long handle;, +            handle =  allocateRun(normCapacity);, +            handle = allocateSubpage(normCapacity);, +, +        if (handle < 0) {, +            return false;, +        }, +        ByteBuffer nioBuffer = cachedNioBuffers != null ? cachedNioBuffers.pollLast() : null;, +        initBuf(buf, nioBuffer, handle, reqCapacity);, +        return true;, +        synchronized (head) {]