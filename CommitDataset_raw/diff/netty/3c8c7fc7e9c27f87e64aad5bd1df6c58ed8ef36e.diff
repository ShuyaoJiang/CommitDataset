[+++ b/common/src/main/java/io/netty/util/ResourceLeakDetector.java, +import java.util.HashSet;, +import java.util.Set;, +    private static final String PROP_MAX_SAMPLED_RECORDS = "io.netty.leakDetection.maxSampledRecords";, +, +    private static final int MAX_SAMPLED_RECORDS;, +        long maxRecordsSampled = SystemPropertyUtil.getLong(PROP_MAX_SAMPLED_RECORDS, MAX_RECORDS * 10L);, +        MAX_SAMPLED_RECORDS = Math.max((int) Math.min(Integer.MAX_VALUE, maxRecordsSampled), MAX_RECORDS);, +            logger.debug("-D{}: {}", PROP_MAX_SAMPLED_RECORDS, MAX_SAMPLED_RECORDS);, +                reportLeak();, +            }, +        reportLeak();, +    private void clearRefQueue() {, +    }, +, +    private void reportLeak() {, +        if (!logger.isErrorEnabled()) {, +            clearRefQueue();, +        private final Record head;, +        // This will be updated once a new Record will be created and added, +        private Record tail;, +, +        private final int trackedHash;, +        private int numRecords;, +        private int droppedRecords;, +            head = tail = getLevel().ordinal() >= Level.ADVANCED.ordinal() ? new Record() : null;, +            record0(null);, +            record0(hint);, +        private void record0(Object hint) {, +            if (head != null && MAX_RECORDS > 0) {, +                synchronized (head) {, +                    if (tail == null) {, +                        // already closed, +                        return;, +, +                    Record record = hint == null ? new Record() : new Record(hint);, +                    tail.next = record;, +                    tail = record;, +, +                    // Enforce a limit so our linked-list not grows too large and cause a GC storm later on when we, +                    // unlink it. The reason why we choose a different limit to MAX_RECORDS is that we will not handle, +                    // duplications here as its very expensive. We will filter these out when we actually, +                    // detected a leak., +                    if (numRecords == MAX_SAMPLED_RECORDS) {, +                        head.next = head.next.next;, +                        droppedRecords++;, +                    } else {, +                        numRecords++;, +            if (allLeaks.remove(this, LeakEntry.INSTANCE)) {, +                // Call clear so the reference is not even enqueued., +                clear();, +, +                if (head != null) {, +                    synchronized (head) {, +                        // Allow to GC all the records., +                        head.next = null;, +                        numRecords = 0;, +                        tail = null;, +                    }, +                }, +                return true;, +            }, +            return false;, +            if (head == null) {, +            final String creationRecord;, +            final String[] array;, +            int idx = 0;, +            String last = null;, +            final int dropped;, +, +            synchronized (head) {, +                if (tail == null) {, +                    // Already closed, +                    return EMPTY_STRING;, +                dropped = droppedRecords;, +                creationRecord = head.toString();, +                array = new String[numRecords];, +                Record record = head.next;, +                while (record != null) {, +                    String recordStr = record.toString();, +                    if (last == null || !last.equals(recordStr)) {, +                        array[idx ++] = recordStr;, +                        last = recordStr;, +                    }, +                    record = record.next;, +                }, +            int removed = idx > MAX_RECORDS ? idx - MAX_RECORDS : 0;, +, +            if (removed > 0) {, +                   .append(removed), +            if (dropped > 0) {, +                buf.append(dropped), +                   .append(" leak records were not sampled because the leak record sample count is limited to "), +                   .append(MAX_SAMPLED_RECORDS), +                   .append(". Use system property "), +                   .append(PROP_MAX_SAMPLED_RECORDS), +                   .append(" to increase the limit."), +            }, +            int records = idx - removed;, +            buf.append("Recent access records: ").append(records).append(NEWLINE);]