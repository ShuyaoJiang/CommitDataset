[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2CodecUtil.java, +     * The assumed minimum value for {@code SETTINGS_MAX_CONCURRENT_STREAMS} as, +     * recommended by the HTTP/2 spec., +     */, +    public static final int SMALLEST_MAX_CONCURRENT_STREAMS = 100;, +, +    /**, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2CodecUtil.java, +     * The assumed minimum value for {@code SETTINGS_MAX_CONCURRENT_STREAMS} as, +     * recommended by the HTTP/2 spec., +     */, +    public static final int SMALLEST_MAX_CONCURRENT_STREAMS = 100;, +, +    /**, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/StreamBufferingEncoder.java, +/*, + * Copyright 2015 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License, version 2.0 (the, + * "License"); you may not use this file except in compliance with the License. You may obtain a, + * copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software distributed under the License, + * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express, + * or implied. See the License for the specific language governing permissions and limitations under, + * the License., + */, +, +package io.netty.handler.codec.http2;, +, +import static io.netty.handler.codec.http2.Http2CodecUtil.SMALLEST_MAX_CONCURRENT_STREAMS;, +import static io.netty.handler.codec.http2.Http2Error.PROTOCOL_ERROR;, +import static io.netty.handler.codec.http2.Http2Exception.connectionError;, +, +import io.netty.buffer.ByteBuf;, +import io.netty.channel.ChannelFuture;, +import io.netty.channel.ChannelHandlerContext;, +import io.netty.channel.ChannelPromise;, +import io.netty.util.ReferenceCountUtil;, +, +import java.util.ArrayDeque;, +import java.util.Iterator;, +import java.util.Map;, +import java.util.Queue;, +import java.util.TreeMap;, +, +/**, + * Implementation of a {@link Http2ConnectionEncoder} that dispatches all method call to another, + * {@link Http2ConnectionEncoder}, until {@code SETTINGS_MAX_CONCURRENT_STREAMS} is reached., + * <p/>, + * <p>When this limit is hit, instead of rejecting any new streams this implementation buffers newly, + * created streams and their corresponding frames. Once an active stream gets closed or the maximum, + * number of concurrent streams is increased, this encoder will automatically try to empty its, + * buffer and create as many new streams as possible., + * <p/>, + * <p>, + * If a {@code GOAWAY} frame is received from the remote endpoint, all buffered writes for streams, + * with an ID less than the specified {@code lastStreamId} will immediately fail with a, + * {@link StreamBufferingEncoder.GoAwayException}., + * <p/>, + * <p>This implementation makes the buffering mostly transparent and is expected to be used as a, + * drop-in decorator of {@link DefaultHttp2ConnectionEncoder}., + * </p>, + */, +public class StreamBufferingEncoder extends DecoratingHttp2ConnectionEncoder {, +, +    /**, +     * Thrown by {@link StreamBufferingEncoder} if buffered streams are terminated due to, +     * receipt of a {@code GOAWAY}., +     */, +    public static final class GoAwayException extends Http2Exception {, +        private static final long serialVersionUID = 1326785622777291198L;, +        private final int lastStreamId;, +        private final long errorCode;, +        private final ByteBuf debugData;, +, +        public GoAwayException(int lastStreamId, long errorCode, ByteBuf debugData) {, +            super(Http2Error.STREAM_CLOSED);, +            this.lastStreamId = lastStreamId;, +            this.errorCode = errorCode;, +            this.debugData = debugData;, +        }, +, +        public int lastStreamId() {, +            return lastStreamId;, +        }, +, +        public long errorCode() {, +            return errorCode;, +        }, +, +        public ByteBuf debugData() {, +            return debugData;, +        }, +    }, +, +    /**, +     * Buffer for any streams and corresponding frames that could not be created due to the maximum]