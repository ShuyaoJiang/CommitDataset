[+++ b/buffer/src/main/java/io/netty/buffer/PoolThreadCache.java, +import io.netty.util.ThreadDeathWatcher;, +import io.netty.util.internal.logging.InternalLogger;, +import io.netty.util.internal.logging.InternalLoggerFactory;, +, +, +    private static final InternalLogger logger = InternalLoggerFactory.getInstance(PoolThreadCache.class);, +, +    private final Thread thread = Thread.currentThread();, +    private final Runnable freeTask = new Runnable() {, +        @Override, +        public void run() {, +            free0();, +        }, +    };, +, +, +        // The thread-local cache will keep a list of pooled buffers which must be returned to, +        // the pool when the thread is not alive anymore., +        ThreadDeathWatcher.watch(thread, freeTask);, +    void free() {, +        ThreadDeathWatcher.unwatch(thread, freeTask);, +        free0();, +    }, +, +    private void free0() {, +        int numFreed = free(tinySubPageDirectCaches) +, +, +        if (numFreed > 0 && logger.isDebugEnabled()) {, +            logger.debug("Freed {} thread-local buffer(s) from thread: {}", numFreed, thread.getName());, +        }, +++ b/buffer/src/main/java/io/netty/buffer/PoolThreadCache.java, +import io.netty.util.ThreadDeathWatcher;, +import io.netty.util.internal.logging.InternalLogger;, +import io.netty.util.internal.logging.InternalLoggerFactory;, +, +, +    private static final InternalLogger logger = InternalLoggerFactory.getInstance(PoolThreadCache.class);, +, +    private final Thread thread = Thread.currentThread();, +    private final Runnable freeTask = new Runnable() {, +        @Override, +        public void run() {, +            free0();, +        }, +    };, +, +, +        // The thread-local cache will keep a list of pooled buffers which must be returned to, +        // the pool when the thread is not alive anymore., +        ThreadDeathWatcher.watch(thread, freeTask);, +    void free() {, +        ThreadDeathWatcher.unwatch(thread, freeTask);, +        free0();, +    }, +, +    private void free0() {, +        int numFreed = free(tinySubPageDirectCaches) +, +, +        if (numFreed > 0 && logger.isDebugEnabled()) {, +            logger.debug("Freed {} thread-local buffer(s) from thread: {}", numFreed, thread.getName());, +        }, +++ b/buffer/src/main/java/io/netty/buffer/PooledByteBufAllocator.java, +import io.netty.util.concurrent.FastThreadLocal;, +        return threadCache.isSet();, +        threadCache.remove();, +            return new PoolThreadCache(, +        }, +        protected void onRemoval(PoolThreadCache value) {, +            value.free();, +++ b/buffer/src/main/java/io/netty/buffer/PoolThreadCache.java, +import io.netty.util.ThreadDeathWatcher;, +import io.netty.util.internal.logging.InternalLogger;, +import io.netty.util.internal.logging.InternalLoggerFactory;, +, +, +    private static final InternalLogger logger = InternalLoggerFactory.getInstance(PoolThreadCache.class);, +, +    private final Thread thread = Thread.currentThread();, +    private final Runnable freeTask = new Runnable() {, +        @Override, +        public void run() {, +            free0();, +        }, +    };, +, +, +        // The thread-local cache will keep a list of pooled buffers which must be returned to, +        // the pool when the thread is not alive anymore., +        ThreadDeathWatcher.watch(thread, freeTask);, +    void free() {, +        ThreadDeathWatcher.unwatch(thread, freeTask);, +        free0();, +    }, +, +    private void free0() {, +        int numFreed = free(tinySubPageDirectCaches) +, +, +        if (numFreed > 0 && logger.isDebugEnabled()) {, +            logger.debug("Freed {} thread-local buffer(s) from thread: {}", numFreed, thread.getName());]