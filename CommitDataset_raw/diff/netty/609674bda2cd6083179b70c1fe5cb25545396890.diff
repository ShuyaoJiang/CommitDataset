[+++ b/codec/src/main/java/io/netty/handler/codec/embedder/AbstractCodecEmbedder.java, +import io.netty.buffer.ChannelBuffer;, +import io.netty.channel.ChannelFuture;, +import io.netty.channel.ChannelHandlerContext;, +import io.netty.channel.ChannelOutboundHandlerAdapter;, +import io.netty.channel.ChannelOutboundHandlerContext;, +        if (handlers == null) {, +            throw new NullPointerException("handlers");, +        }, +, +        int inboundType = 0; // 0 - unknown, 1 - stream, 2 - message, +        int outboundType = 0;, +        int nHandlers = 0;, +        ChannelPipeline p = channel.pipeline();, +        for (ChannelHandler h: handlers) {, +            if (h == null) {, +                break;, +            }, +            nHandlers ++;, +, +            p.addLast(h);, +            ChannelHandlerContext ctx = p.context(h);, +            if (inboundType == 0) {, +                if (ctx.canHandleInbound()) {, +                    ChannelInboundHandlerContext<?> inCtx = (ChannelInboundHandlerContext<?>) ctx;, +                    if (inCtx.inbound().hasByteBuffer()) {, +                        inboundType = 1;, +                    } else {, +                        inboundType = 2;, +                    }, +                }, +            }, +            if (ctx.canHandleOutbound()) {, +                ChannelOutboundHandlerContext<?> outCtx = (ChannelOutboundHandlerContext<?>) ctx;, +                if (outCtx.outbound().hasByteBuffer()) {, +                    outboundType = 1;, +                } else {, +                    outboundType = 2;, +                }, +            }, +        }, +, +        if (nHandlers == 0) {, +            throw new IllegalArgumentException("handlers is empty.");, +        }, +, +        if (inboundType == 0 && outboundType == 0) {, +            throw new IllegalArgumentException("handlers does not provide any buffers.");, +        }, +, +        p.addFirst(StreamToChannelBufferEncoder.INSTANCE);, +, +        if (inboundType == 1) {, +            p.addFirst(ChannelBufferToStreamDecoder.INSTANCE);, +        }, +, +        if (outboundType == 1) {, +            p.addLast(ChannelBufferToStreamEncoder.INSTANCE);, +        }, +, +        p.addLast(new LastHandler());, +, +, +    @ChannelHandler.Sharable, +    private static final class StreamToChannelBufferEncoder extends ChannelOutboundHandlerAdapter<Byte> {, +, +        static final StreamToChannelBufferEncoder INSTANCE = new StreamToChannelBufferEncoder();, +, +        @Override, +        public ChannelBufferHolder<Byte> newOutboundBuffer(, +                ChannelOutboundHandlerContext<Byte> ctx) throws Exception {, +            return ChannelBufferHolders.byteBuffer();, +        }, +, +        @Override, +        public void flush(ChannelOutboundHandlerContext<Byte> ctx, ChannelFuture future) throws Exception {, +            ChannelBuffer in = ctx.outbound().byteBuffer();, +            if (in.readable()) {, +                ctx.nextOutboundMessageBuffer().add(in.readBytes(in.readableBytes()));, +            }, +            ctx.flush(future);, +        }, +    }, +, +    @ChannelHandler.Sharable, +    private static final class ChannelBufferToStreamDecoder extends ChannelInboundHandlerAdapter<Object> {, +, +        static final ChannelBufferToStreamDecoder INSTANCE = new ChannelBufferToStreamDecoder();, +, +        @Override, +        public ChannelBufferHolder<Object> newInboundBuffer(, +                ChannelInboundHandlerContext<Object> ctx) throws Exception {, +            return ChannelBufferHolders.messageBuffer();, +        }, +, +        @Override, +        public void inboundBufferUpdated(ChannelInboundHandlerContext<Object> ctx) throws Exception {, +            Queue<Object> in = ctx.inbound().messageBuffer();, +            for (;;) {, +                Object msg = in.poll();]