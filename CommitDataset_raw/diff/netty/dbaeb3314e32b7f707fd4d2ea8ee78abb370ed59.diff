[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2ConnectionEncoder.java, +import static java.lang.Math.min;, +, +            connection.local().maxActiveStreams((int) min(maxConcurrentStreams, Integer.MAX_VALUE));, +            outboundHeaderTable.maxHeaderTableSize((int) min(headerTableSize, Integer.MAX_VALUE));, +            int queuedData = queue.readableBytes();, +            if (!endOfStream && (queuedData == 0 || allowedBytes == 0)) {, +, +            // Determine how much data to write., +            int writeableData = min(queuedData, allowedBytes);, +            ChannelPromise writePromise = ctx.newPromise().addListener(this);, +            // Determine how much padding to write., +            int writeablePadding = min(allowedBytes - writeableData, padding);, +, +            // Write the frame(s)., +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2ConnectionEncoder.java, +import static java.lang.Math.min;, +, +            connection.local().maxActiveStreams((int) min(maxConcurrentStreams, Integer.MAX_VALUE));, +            outboundHeaderTable.maxHeaderTableSize((int) min(headerTableSize, Integer.MAX_VALUE));, +            int queuedData = queue.readableBytes();, +            if (!endOfStream && (queuedData == 0 || allowedBytes == 0)) {, +, +            // Determine how much data to write., +            int writeableData = min(queuedData, allowedBytes);, +            ChannelPromise writePromise = ctx.newPromise().addListener(this);, +            // Determine how much padding to write., +            int writeablePadding = min(allowedBytes - writeableData, padding);, +, +            // Write the frame(s)., +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2FrameReader.java, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2ConnectionEncoder.java, +import static java.lang.Math.min;, +, +            connection.local().maxActiveStreams((int) min(maxConcurrentStreams, Integer.MAX_VALUE));, +            outboundHeaderTable.maxHeaderTableSize((int) min(headerTableSize, Integer.MAX_VALUE));, +            int queuedData = queue.readableBytes();, +            if (!endOfStream && (queuedData == 0 || allowedBytes == 0)) {, +, +            // Determine how much data to write., +            int writeableData = min(queuedData, allowedBytes);, +            ChannelPromise writePromise = ctx.newPromise().addListener(this);, +            // Determine how much padding to write., +            int writeablePadding = min(allowedBytes - writeableData, padding);, +, +            // Write the frame(s)., +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2FrameReader.java, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2FrameWriter.java, +import static java.lang.Math.max;, +import static java.lang.Math.min;, +, +import io.netty.buffer.ByteBuf;, +import io.netty.channel.ChannelFuture;, +import io.netty.channel.ChannelHandlerContext;, +import io.netty.channel.ChannelPromise;, +import io.netty.handler.codec.http2.Http2CodecUtil.SimpleChannelPromiseAggregator;, +import io.netty.handler.codec.http2.Http2FrameWriter.Configuration;, +        final SimpleChannelPromiseAggregator promiseAggregator =, +        final DataFrameHeader header = new DataFrameHeader(ctx, streamId);, +        boolean needToReleaseHeaders = true;, +        boolean needToReleaseData = true;, +            boolean lastFrame;, +            int remainingData = data.readableBytes();, +            do {, +                // Determine how much data and padding to write in this frame. Put all padding at the end., +                int frameDataBytes = min(remainingData, maxFrameSize);, +                int framePaddingBytes = min(padding, max(0, (maxFrameSize - 1) - frameDataBytes));, +                // Decrement the remaining counters., +                padding -= framePaddingBytes;, +                remainingData -= frameDataBytes;, +                // Determine whether or not this is the last frame to be sent., +                lastFrame = remainingData == 0 && padding == 0;, +                // Only the last frame is not retained. Until then, the outer finally must release., +                ByteBuf frameHeader = header.slice(frameDataBytes, framePaddingBytes, lastFrame && endStream);, +                needToReleaseHeaders = !lastFrame;, +                ctx.write(lastFrame ? frameHeader : frameHeader.retain(), promiseAggregator.newPromise());, +                // Write the frame data., +                ByteBuf frameData = data.readSlice(frameDataBytes);, +                // Only the last frame is not retained. Until then, the outer finally must release., +                needToReleaseData = !lastFrame;, +                ctx.write(lastFrame ? frameData : frameData.retain(), promiseAggregator.newPromise());, +, +                // Write the frame padding., +                if (framePaddingBytes > 0) {, +                    ctx.write(ZERO_BUFFER.slice(0, framePaddingBytes), promiseAggregator.newPromise());, +            } while (!lastFrame);, +, +            if (needToReleaseHeaders) {, +                header.release();, +            }, +            if (needToReleaseData) {, +                    headerBlock.readSlice(min(headerBlock.readableBytes(), maxFragmentLength)).retain();, +                ctx.write(ZERO_BUFFER.slice(0, padding), promiseAggregator.newPromise());, +                    headerBlock.readSlice(min(headerBlock.readableBytes(), maxFragmentLength)).retain();, +                ctx.write(ZERO_BUFFER.slice(0, padding), promiseAggregator.newPromise());, +            int fragmentReadableBytes = min(headerBlock.readableBytes(), maxFragmentLength);, +                fragmentReadableBytes = min(headerBlock.readableBytes(), maxFragmentLength);, +                if (padding > 0) {, +                    ctx.write(ZERO_BUFFER.slice(0, padding), promiseAggregator.newPromise());, +]