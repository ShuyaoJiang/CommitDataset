[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/AbstractHttp2ConnectionHandlerBuilder.java, +import static io.netty.handler.codec.http2.Http2CodecUtil.DEFAULT_MAX_RESERVED_STREAMS;, +import static io.netty.util.internal.ObjectUtil.checkPositiveOrZero;, +    private Integer maxReservedStreams;, +     * Get the maximum number of streams which can be in the reserved state at any given time., +     * <p>, +     * By default this value will be ignored on the server for local endpoint. This is because the RFC provides, +     * no way to explicitly communicate a limit to how many states can be in the reserved state, and instead relies, +     * on the peer to send RST_STREAM frames when they will be rejected., +     */, +    protected int maxReservedStreams() {, +        return maxReservedStreams != null ? maxReservedStreams : DEFAULT_MAX_RESERVED_STREAMS;, +    }, +, +    /**, +     * Set the maximum number of streams which can be in the reserved state at any given time., +     */, +    protected B maxReservedStreams(int maxReservedStreams) {, +        enforceConstraint("server", "connection", connection);, +        enforceConstraint("server", "codec", decoder);, +        enforceConstraint("server", "codec", encoder);, +, +        this.maxReservedStreams = checkPositiveOrZero(maxReservedStreams, "maxReservedStreams");, +        return self();, +    }, +, +    /**, +        enforceConstraint("connection", "maxReservedStreams", maxReservedStreams);, +        enforceConstraint("codec", "maxReservedStreams", maxReservedStreams);, +            connection = new DefaultHttp2Connection(isServer(), maxReservedStreams());, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/AbstractHttp2ConnectionHandlerBuilder.java, +import static io.netty.handler.codec.http2.Http2CodecUtil.DEFAULT_MAX_RESERVED_STREAMS;, +import static io.netty.util.internal.ObjectUtil.checkPositiveOrZero;, +    private Integer maxReservedStreams;, +     * Get the maximum number of streams which can be in the reserved state at any given time., +     * <p>, +     * By default this value will be ignored on the server for local endpoint. This is because the RFC provides, +     * no way to explicitly communicate a limit to how many states can be in the reserved state, and instead relies, +     * on the peer to send RST_STREAM frames when they will be rejected., +     */, +    protected int maxReservedStreams() {, +        return maxReservedStreams != null ? maxReservedStreams : DEFAULT_MAX_RESERVED_STREAMS;, +    }, +, +    /**, +     * Set the maximum number of streams which can be in the reserved state at any given time., +     */, +    protected B maxReservedStreams(int maxReservedStreams) {, +        enforceConstraint("server", "connection", connection);, +        enforceConstraint("server", "codec", decoder);, +        enforceConstraint("server", "codec", encoder);, +, +        this.maxReservedStreams = checkPositiveOrZero(maxReservedStreams, "maxReservedStreams");, +        return self();, +    }, +, +    /**, +        enforceConstraint("connection", "maxReservedStreams", maxReservedStreams);, +        enforceConstraint("codec", "maxReservedStreams", maxReservedStreams);, +            connection = new DefaultHttp2Connection(isServer(), maxReservedStreams());, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2Connection.java, +import static io.netty.handler.codec.http2.Http2CodecUtil.DEFAULT_MAX_RESERVED_STREAMS;, +import static io.netty.util.internal.ObjectUtil.checkPositiveOrZero;, +import static java.lang.Integer.MAX_VALUE;, +     * <p>, +     * Initial size of 4 because the default configuration currently has 3 listeners, +     * (local/remote flow controller and {@link StreamByteDistributor}) and we leave room for 1 extra., +     * We could be more aggressive but the ArrayList resize will double the size if we are too small., +     * @param server whether or not this end-point is the server-side of the HTTP/2 connection., +        this(server, DEFAULT_MAX_RESERVED_STREAMS);, +    }, +, +    /**, +     * Creates a new connection with the given settings., +     * @param server whether or not this end-point is the server-side of the HTTP/2 connection., +     * @param maxReservedStreams The maximum amount of streams which can exist in the reserved state for each endpoint., +     */, +    public DefaultHttp2Connection(boolean server, int maxReservedStreams) {, +        // Reserved streams are excluded from the SETTINGS_MAX_CONCURRENT_STREAMS limit according to [1] and the RFC, +        // doesn't define a way to communicate the limit on reserved streams. We rely upon the peer to send RST_STREAM, +        // in response to any locally enforced limits being exceeded [2]., +        // [1] https://tools.ietf.org/html/rfc7540#section-5.1.2, +        // [2] https://tools.ietf.org/html/rfc7540#section-8.2.2, +        localEndpoint = new DefaultEndpoint<Http2LocalFlowController>(server, server ? MAX_VALUE : maxReservedStreams);, +        remoteEndpoint = new DefaultEndpoint<Http2RemoteFlowController>(!server, maxReservedStreams);, +        final boolean removed;, +            removed = streamMap.remove(stream.id()) != null;, +            removed = true;, +        if (removed) {, +        private int maxActiveStreams;, +        private final int maxReservedStreams;, +        DefaultEndpoint(boolean server, int maxReservedStreams) {, +            maxActiveStreams = MAX_VALUE;, +            this.maxReservedStreams = checkPositiveOrZero(maxReservedStreams, "maxReservedStreams");, +            updateMaxStreams();, +        @Override, +        public DefaultStream createStream(int streamId, boolean halfClosed) throws Http2Exception {, +            State state = activeState(streamId, IDLE, isLocal(), halfClosed);, +, +                throw connectionError(PROTOCOL_ERROR, "Server push not allowed to opposite endpoint");]