[+++ b/buffer/src/main/java/io/netty/buffer/CompositeByteBuf.java, +        removeComp(cIndex);, +            // Release the slice if present since it may have a different, +            // refcount to the unwrapped buf if it is a PooledSlicedByteBuf, +            ByteBuf buffer = slice;, +            if (buffer != null) {, +                buffer.release();, +            } else {, +                buf.release();, +            }, +            // null out in either case since it could be racy, +++ b/buffer/src/main/java/io/netty/buffer/CompositeByteBuf.java, +        removeComp(cIndex);, +            // Release the slice if present since it may have a different, +            // refcount to the unwrapped buf if it is a PooledSlicedByteBuf, +            ByteBuf buffer = slice;, +            if (buffer != null) {, +                buffer.release();, +            } else {, +                buf.release();, +            }, +            // null out in either case since it could be racy, +++ b/buffer/src/test/java/io/netty/buffer/AbstractCompositeByteBufTest.java, +    public void testReleasesItsComponents2() {, +        // It is important to use a pooled allocator here to ensure, +        // the slices returned by readRetainedSlice are of type, +        // PooledSlicedByteBuf, which maintains an independent refcount, +        // (so that we can be sure to cover this case), +        ByteBuf buffer = PooledByteBufAllocator.DEFAULT.buffer(); // 1, +, +        buffer.writeBytes(new byte[] {1, 2, 3, 4, 5, 6, 7, 8, 9, 10});, +, +        // use readRetainedSlice this time - produces different kind of slices, +        ByteBuf s1 = buffer.readRetainedSlice(2); // 2, +        ByteBuf s2 = s1.readRetainedSlice(2); // 3, +        ByteBuf s3 = s2.readRetainedSlice(2); // 4, +        ByteBuf s4 = s3.readRetainedSlice(2); // 5, +, +        ByteBuf composite = Unpooled.compositeBuffer(), +            .addComponent(s1), +            .addComponents(s2, s3, s4), +            .order(ByteOrder.LITTLE_ENDIAN);, +, +        assertEquals(1, composite.refCnt());, +        assertEquals(2, buffer.refCnt());, +, +        // releasing composite should release the 4 components, +        composite.release();, +        assertEquals(0, composite.refCnt());, +        assertEquals(1, buffer.refCnt());, +, +        // last remaining ref to buffer, +        buffer.release();, +        assertEquals(0, buffer.refCnt());, +    }, +, +    @Test]