[+++ b/transport-native-epoll/src/main/c/netty_epoll_native.c, +#include <sys/timerfd.h>, +        netty_unix_errors_throwChannelExceptionErrorNo(env, "eventfd() failed: ", errno);, +static jint netty_epoll_native_timerFd(JNIEnv* env, jclass clazz) {, +    jint timerFD = timerfd_create(CLOCK_MONOTONIC, TFD_CLOEXEC | TFD_NONBLOCK);, +, +    if (timerFD < 0) {, +        netty_unix_errors_throwChannelExceptionErrorNo(env, "timerfd_create() failed: ", errno);, +    }, +    return timerFD;, +}, +, +        netty_unix_errors_throwChannelExceptionErrorNo(env, "eventfd_write() failed: ", errno);, +static void netty_epoll_native_timerFdRead(JNIEnv* env, jclass clazz, jint fd) {, +    uint64_t timerFireCount;, +, +    if (read(fd, &timerFireCount, sizeof(uint64_t)) < 0) {, +        // it is expected that this is only called where there is known to be activity, so this is an error., +        netty_unix_errors_throwChannelExceptionErrorNo(env, "read() failed: ", errno);, +    }, +}, +, +static jint netty_epoll_native_epollWait0(JNIEnv* env, jclass clazz, jint efd, jlong address, jint len, jint timerFd, jint tvSec, jint tvNsec) {, +    int result, err;, +    if (tvSec == 0 && tvNsec == 0) {, +        // Zeros = poll (aka return immediately)., +        do {, +            result = epoll_wait(efd, ev, len, 0);, +        } while((err = errno) == EINTR);, +        struct itimerspec ts;, +        memset(&ts.it_interval, 0, sizeof(struct timespec));, +        ts.it_value.tv_sec = tvSec;, +        ts.it_value.tv_nsec = tvNsec;, +        if (timerfd_settime(timerFd, 0, &ts, NULL) < 0) {, +            netty_unix_errors_throwChannelExceptionErrorNo(env, "timerfd_settime() failed: ", errno);, +            return -1;, +        }, +        do {, +            result = epoll_wait(efd, ev, len, -1);, +            if (result > 0) {, +                // Detect timeout, and preserve the epoll_wait API., +                if (result == 1 && ev[0].data.fd == timerFd) {, +                    // We assume that timerFD is in ET mode. So we must consume this event to ensure we are notified, +                    // of future timer events because ET mode only notifies a single time until the event is consumed., +                    uint64_t timerFireCount;, +                    // We don't care what the result is. We just want to consume the wakeup event and reset ET., +                    result = read(timerFd, &timerFireCount, sizeof(uint64_t));, +                    return 0;, +                }, +                return result;, +            }, +        } while((err = errno) == EINTR);, +    }, +    netty_unix_errors_throwRuntimeExceptionErrorNo(env, "uname() failed: ", errno);, +  { "timerFd", "()I", (void *) netty_epoll_native_timerFd },, +  { "timerFdRead", "(I)V", (void *) netty_epoll_native_timerFdRead },, +  { "epollWait0", "(IJIIII)I", (void *) netty_epoll_native_epollWait0 },, +++ b/transport-native-epoll/src/main/c/netty_epoll_native.c, +#include <sys/timerfd.h>, +        netty_unix_errors_throwChannelExceptionErrorNo(env, "eventfd() failed: ", errno);, +static jint netty_epoll_native_timerFd(JNIEnv* env, jclass clazz) {, +    jint timerFD = timerfd_create(CLOCK_MONOTONIC, TFD_CLOEXEC | TFD_NONBLOCK);, +, +    if (timerFD < 0) {, +        netty_unix_errors_throwChannelExceptionErrorNo(env, "timerfd_create() failed: ", errno);, +    }, +    return timerFD;, +}, +, +        netty_unix_errors_throwChannelExceptionErrorNo(env, "eventfd_write() failed: ", errno);, +static void netty_epoll_native_timerFdRead(JNIEnv* env, jclass clazz, jint fd) {, +    uint64_t timerFireCount;, +, +    if (read(fd, &timerFireCount, sizeof(uint64_t)) < 0) {, +        // it is expected that this is only called where there is known to be activity, so this is an error., +        netty_unix_errors_throwChannelExceptionErrorNo(env, "read() failed: ", errno);, +    }, +}, +, +static jint netty_epoll_native_epollWait0(JNIEnv* env, jclass clazz, jint efd, jlong address, jint len, jint timerFd, jint tvSec, jint tvNsec) {, +    int result, err;, +    if (tvSec == 0 && tvNsec == 0) {, +        // Zeros = poll (aka return immediately)., +        do {, +            result = epoll_wait(efd, ev, len, 0);, +        } while((err = errno) == EINTR);, +        struct itimerspec ts;, +        memset(&ts.it_interval, 0, sizeof(struct timespec));, +        ts.it_value.tv_sec = tvSec;, +        ts.it_value.tv_nsec = tvNsec;, +        if (timerfd_settime(timerFd, 0, &ts, NULL) < 0) {, +            netty_unix_errors_throwChannelExceptionErrorNo(env, "timerfd_settime() failed: ", errno);, +            return -1;, +        }, +        do {, +            result = epoll_wait(efd, ev, len, -1);, +            if (result > 0) {, +                // Detect timeout, and preserve the epoll_wait API., +                if (result == 1 && ev[0].data.fd == timerFd) {, +                    // We assume that timerFD is in ET mode. So we must consume this event to ensure we are notified]