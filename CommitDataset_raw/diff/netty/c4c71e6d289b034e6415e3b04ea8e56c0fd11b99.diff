[+++ b/codec-socks/src/main/java/io/netty/handler/codec/socks/SocksCommonUtils.java, +import io.netty.util.internal.StringUtil;, +, +    /**, +    /**, +     * Converts numeric IPv6 to standard (non-compressed) format., +    private static void ipv6toStr(StringBuilder sb, byte[] src, int fromHextet, int toHextet) {, +        int i;, +        toHextet --;, +        for (i = fromHextet; i < toHextet; i++) {, +            appendHextet(sb, src, i);, +, +        appendHextet(sb, src, i);, +, +    private static void appendHextet(StringBuilder sb, byte[] src, int i) {, +        StringUtil.toHexString(sb, src, i << 1, 2);, +++ b/codec-socks/src/main/java/io/netty/handler/codec/socks/SocksCommonUtils.java, +import io.netty.util.internal.StringUtil;, +, +    /**, +    /**, +     * Converts numeric IPv6 to standard (non-compressed) format., +    private static void ipv6toStr(StringBuilder sb, byte[] src, int fromHextet, int toHextet) {, +        int i;, +        toHextet --;, +        for (i = fromHextet; i < toHextet; i++) {, +            appendHextet(sb, src, i);, +, +        appendHextet(sb, src, i);, +, +    private static void appendHextet(StringBuilder sb, byte[] src, int i) {, +        StringUtil.toHexString(sb, src, i << 1, 2);, +++ b/codec-socks/src/test/java/io/netty/handler/codec/socks/SocksCmdResponseDecoderTest.java, +            testSocksCmdResponseDecoderWithDifferentParams(cmdStatus, SocksAddressType.IPv6,, +                    "1111:111:11:1:0:0:0:1", 80);, +++ b/codec-socks/src/main/java/io/netty/handler/codec/socks/SocksCommonUtils.java, +import io.netty.util.internal.StringUtil;, +, +    /**, +    /**, +     * Converts numeric IPv6 to standard (non-compressed) format., +    private static void ipv6toStr(StringBuilder sb, byte[] src, int fromHextet, int toHextet) {, +        int i;, +        toHextet --;, +        for (i = fromHextet; i < toHextet; i++) {, +            appendHextet(sb, src, i);, +, +        appendHextet(sb, src, i);, +, +    private static void appendHextet(StringBuilder sb, byte[] src, int i) {, +        StringUtil.toHexString(sb, src, i << 1, 2);, +++ b/codec-socks/src/test/java/io/netty/handler/codec/socks/SocksCmdResponseDecoderTest.java, +            testSocksCmdResponseDecoderWithDifferentParams(cmdStatus, SocksAddressType.IPv6,, +                    "1111:111:11:1:0:0:0:1", 80);, +++ b/common/src/main/java/io/netty/util/internal/StringUtil.java, +import java.io.IOException;, +    private static final String[] BYTE2HEX_PAD = new String[256];, +    private static final String[] BYTE2HEX_NOPAD = new String[256];, +    private static final String EMPTY_STRING = "";, +, +        // Determine the newline character of the current platform., +        // Generate the lookup table that converts a byte into a 2-digit hexadecimal integer., +        int i;, +        for (i = 0; i < 10; i ++) {, +            StringBuilder buf = new StringBuilder(2);, +            buf.append('0');, +            buf.append(i);, +            BYTE2HEX_PAD[i] = buf.toString();, +            BYTE2HEX_NOPAD[i] = String.valueOf(i);, +        }, +        for (; i < 16; i ++) {, +            StringBuilder buf = new StringBuilder(2);, +            char c = (char) ('a' + i - 10);, +            buf.append('0');, +            buf.append(c);, +            BYTE2HEX_PAD[i] = buf.toString();, +            BYTE2HEX_NOPAD[i] = String.valueOf(c);, +        }, +        for (; i < BYTE2HEX_PAD.length; i ++) {, +            StringBuilder buf = new StringBuilder(2);, +            buf.append(Integer.toHexString(i));, +            String str = buf.toString();, +            BYTE2HEX_PAD[i] = str;, +            BYTE2HEX_NOPAD[i] = str;, +        }, +    }, +     * Converts the specified byte value into a 2-digit hexadecimal integer., +     */, +    public static String byteToHexStringPadded(int value) {, +        return BYTE2HEX_PAD[value & 0xff];, +    }, +, +    /**, +     * Converts the specified byte value into a 2-digit hexadecimal integer and appends it to the specified buffer., +     */, +    public static <T extends Appendable> T byteToHexStringPadded(T buf, int value) {, +        try {, +            buf.append(byteToHexStringPadded(value));, +        } catch (IOException e) {, +            PlatformDependent.throwException(e);]