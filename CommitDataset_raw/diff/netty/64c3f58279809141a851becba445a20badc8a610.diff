[+++ b/common/src/main/java/io/netty/util/concurrent/SingleThreadEventExecutor.java, +        if (!addTaskWakesUp && wakesUpForTask(task)) {, +    @SuppressWarnings("unused"), +    protected boolean wakesUpForTask(Runnable task) {, +        return true;, +    }, +, +++ b/common/src/main/java/io/netty/util/concurrent/SingleThreadEventExecutor.java, +        if (!addTaskWakesUp && wakesUpForTask(task)) {, +    @SuppressWarnings("unused"), +    protected boolean wakesUpForTask(Runnable task) {, +        return true;, +    }, +, +++ b/transport/src/main/java/io/netty/channel/DefaultChannelHandlerContext.java, +            Runnable task;, +            if (flush) {, +                task = WriteAndFlushTask.newInstance(next, msg, size, promise);, +            }  else {, +                task = WriteTask.newInstance(next, msg, size, promise);, +            }, +            safeExecute(executor, task, promise, msg);, +    abstract static class AbstractWriteTask implements Runnable {, +        private final Recycler.Handle handle;, +, +, +        private AbstractWriteTask(Recycler.Handle handle) {, +            this.handle = handle;, +        }, +, +        protected static void init(AbstractWriteTask task, DefaultChannelHandlerContext ctx,, +                                   Object msg, int size, ChannelPromise promise) {, +            task.ctx = ctx;, +            task.msg = msg;, +            task.promise = promise;, +            task.size = size;, +        }, +, +        @Override, +        public final void run() {, +            try {, +                if (size > 0) {, +                    ChannelOutboundBuffer buffer = ctx.channel.unsafe().outboundBuffer();, +                    // Check for null as it may be set to null if the channel is closed already, +                    if (buffer != null) {, +                        buffer.decrementPendingOutboundBytes(size);, +                    }, +                }, +                write(ctx, msg, promise);, +            } finally {, +                // Set to null so the GC can collect them directly, +                ctx = null;, +                msg = null;, +                promise = null;, +                recycle(handle);, +            }, +        }, +, +        protected void write(DefaultChannelHandlerContext ctx, Object msg, ChannelPromise promise) {, +            ctx.invokeWrite(msg, promise);, +        }, +, +        protected abstract void recycle(Recycler.Handle handle);, +    }, +, +    static final class WriteTask extends AbstractWriteTask implements SingleThreadEventLoop.NonWakeupRunnable {, +                DefaultChannelHandlerContext ctx, Object msg, int size, ChannelPromise promise) {, +            init(task, ctx, msg, size, promise);, +            super(handle);, +        protected void recycle(Recycler.Handle handle) {, +, +    static final class WriteAndFlushTask extends AbstractWriteTask {, +, +        private static final Recycler<WriteAndFlushTask> RECYCLER = new Recycler<WriteAndFlushTask>() {, +            @Override, +            protected WriteAndFlushTask newObject(Handle handle) {, +                return new WriteAndFlushTask(handle);, +            }, +        };, +, +        private static WriteAndFlushTask newInstance(, +                DefaultChannelHandlerContext ctx, Object msg, int size, ChannelPromise promise) {, +            WriteAndFlushTask task = RECYCLER.get();, +            init(task, ctx, msg, size, promise);, +            return task;, +        }, +, +        private WriteAndFlushTask(Recycler.Handle handle) {, +            super(handle);, +        }, +, +        @Override, +        public void write(DefaultChannelHandlerContext ctx, Object msg, ChannelPromise promise) {, +            super.write(ctx, msg, promise);, +            ctx.invokeFlush();, +        }, +, +        @Override, +        protected void recycle(Recycler.Handle handle) {, +            RECYCLER.recycle(this, handle);]