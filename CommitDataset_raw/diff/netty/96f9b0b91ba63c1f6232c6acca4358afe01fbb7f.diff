[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2RemoteFlowController.java, +            final int initialAllocated = allocated;, +            int writtenBytes;, +            // In case an exception is thrown we want to remember it and pass it to cancel(Throwable)., +            Throwable cause = null;, +            FlowControlled frame;, +                assert !writing;, +                writing = true;, +, +                // Write the remainder of frames that we are allowed to, +                boolean writeOccurred = false;, +                while (!cancelled && (frame = peek()) != null) {, +                    int maxBytes = min(allocated, writableWindow());, +                    if (maxBytes <= 0 && frame.size() > 0) {, +                        // The frame still has data, but the amount of allocated bytes has been exhausted., +                        // Don't write needless empty frames., +                        break;, +                    writeOccurred = true;, +                    int initialFrameSize = frame.size();, +                    try {, +                        frame.write(ctx, max(0, maxBytes));, +                        if (frame.size() == 0) {, +                            // This frame has been fully written, remove this frame and notify it., +                            // Since we remove this frame first, we're guaranteed that its error, +                            // method will not be called when we call cancel., +                            pendingWriteQueue.remove();, +                            frame.writeComplete();, +                        }, +                    } finally {, +                        // Decrement allocated by how much was actually written., +                        allocated -= initialFrameSize - frame.size();, +                    }, +                }, +, +                if (!writeOccurred) {, +                    // Either there was no frame, or the amount of allocated bytes has been exhausted., +                    return -1;, +                }, +, +            } catch (Throwable t) {, +                // Mark the state as cancelled, we'll clear the pending queue via cancel() below., +                cancelled = true;, +                cause = t;, +            } finally {, +                writing = false;, +                // Make sure we always decrement the flow control windows, +                // by the bytes written., +                writtenBytes = initialAllocated - allocated;, +, +                decrementPendingBytes(writtenBytes, false);, +                decrementFlowControlWindow(writtenBytes);, +, +                // If a cancellation occurred while writing, call cancel again to, +                // clear and error all of the pending writes., +                if (cancelled) {, +                    cancel(cause);, +                }, +            }, +            return writtenBytes;, +            // This must be called after adding to the queue in order so that hasFrame() is, +            // updated before updating the stream state., +            incrementPendingBytes(frame.size(), true);, +         * Increments the number of pending bytes for this node and optionally updates the, +         * {@link StreamByteDistributor}., +        private void incrementPendingBytes(int numBytes, boolean updateStreamableBytes) {, +            if (updateStreamableBytes) {, +                streamByteDistributor.updateStreamableBytes(this);, +            }, +        private void decrementPendingBytes(int bytes, boolean updateStreamableBytes) {, +            incrementPendingBytes(-bytes, updateStreamableBytes);, +            decrementPendingBytes(frame.size(), true);, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2RemoteFlowController.java, +            final int initialAllocated = allocated;, +            int writtenBytes;, +            // In case an exception is thrown we want to remember it and pass it to cancel(Throwable)., +            Throwable cause = null;, +            FlowControlled frame;, +                assert !writing;, +                writing = true;, +, +                // Write the remainder of frames that we are allowed to, +                boolean writeOccurred = false;, +                while (!cancelled && (frame = peek()) != null) {, +                    int maxBytes = min(allocated, writableWindow());, +                    if (maxBytes <= 0 && frame.size() > 0) {, +                        // The frame still has data, but the amount of allocated bytes has been exhausted., +                        // Don't write needless empty frames., +                        break;, +                    writeOccurred = true;, +                    int initialFrameSize = frame.size();, +                    try {, +                        frame.write(ctx, max(0, maxBytes));, +                        if (frame.size() == 0) {, +                            // This frame has been fully written, remove this frame and notify it., +                            // Since we remove this frame first, we're guaranteed that its error, +                            // method will not be called when we call cancel., +                            pendingWriteQueue.remove();, +                            frame.writeComplete();, +                        }, +                    } finally {]