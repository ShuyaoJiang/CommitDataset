[+++ b/codec/src/main/java/io/netty/handler/codec/ByteToByteEncoder.java, +, +        ctx.flush(future);, +++ b/codec/src/main/java/io/netty/handler/codec/ByteToByteEncoder.java, +, +        ctx.flush(future);, +++ b/codec/src/main/java/io/netty/handler/codec/MessageToByteEncoder.java, +++ b/codec/src/main/java/io/netty/handler/codec/ByteToByteEncoder.java, +, +        ctx.flush(future);, +++ b/codec/src/main/java/io/netty/handler/codec/MessageToByteEncoder.java, +++ b/codec/src/main/java/io/netty/handler/codec/MessageToMessageEncoder.java, +                CodecUtil.unfoldAndAdd(ctx, omsg, false);, +++ b/codec/src/main/java/io/netty/handler/codec/ByteToByteEncoder.java, +, +        ctx.flush(future);, +++ b/codec/src/main/java/io/netty/handler/codec/MessageToByteEncoder.java, +++ b/codec/src/main/java/io/netty/handler/codec/MessageToMessageEncoder.java, +                CodecUtil.unfoldAndAdd(ctx, omsg, false);, +++ b/handler/src/main/java/io/netty/handler/stream/ChunkedNioFile.java, +            int localReadBytes = buffer.writeBytes(in, chunkSize - readBytes);, +++ b/codec/src/main/java/io/netty/handler/codec/ByteToByteEncoder.java, +, +        ctx.flush(future);, +++ b/codec/src/main/java/io/netty/handler/codec/MessageToByteEncoder.java, +++ b/codec/src/main/java/io/netty/handler/codec/MessageToMessageEncoder.java, +                CodecUtil.unfoldAndAdd(ctx, omsg, false);, +++ b/handler/src/main/java/io/netty/handler/stream/ChunkedNioFile.java, +            int localReadBytes = buffer.writeBytes(in, chunkSize - readBytes);, +++ b/handler/src/main/java/io/netty/handler/stream/ChunkedWriteHandler.java, +    private final int maxPendingWrites;, +    public ChunkedWriteHandler() {, +        this(4);, +    }, +, +    public ChunkedWriteHandler(int maxPendingWrites) {, +        if (maxPendingWrites <= 0) {, +            throw new IllegalArgumentException(, +                    "maxPendingWrites: " + maxPendingWrites + " (expected: > 0)");, +        }, +        this.maxPendingWrites = maxPendingWrites;, +    }, +, +        this.ctx = ctx;, +        return pendingWrites.get() < maxPendingWrites;, +    private void discard(final ChannelHandlerContext ctx, Throwable cause) {, +        boolean success = true;, +                ChunkedInput<?> in = (ChunkedInput<?>) currentEvent;, +                try {, +                    if (!in.isEndOfInput()) {, +                        success = false;, +                    }, +                } catch (Exception e) {, +                    success = false;, +                    logger.warn(ChunkedInput.class.getSimpleName() + ".isEndOfInput() failed", e);, +                }, +                closeInput(in);, +                ChannelFuture f = (ChannelFuture) currentEvent;, +                if (!success) {, +                    if (cause == null) {, +                        cause = new ClosedChannelException();, +                    }, +                    f.setFailure(cause);, +                } else {, +                    f.setSuccess();, +                }, +            discard(ctx, null);]