[+++ b/handler/src/main/java/io/netty/handler/stream/ChunkedWriteHandler.java, +++ b/handler/src/main/java/io/netty/handler/stream/ChunkedWriteHandler.java, +++ b/transport/src/main/java/io/netty/channel/DefaultChannelHandlerContext.java, +    private short callDepth;, +    private short flags;, +, +            if (!isOutboundFreed()) {, +            }, +, +            if (!isInboundFreed()) {, +            }, +, +, +            freeAllIfRemoved();, +    private boolean isInboundFreed() {, +        return (flags & FLAG_FREED_INBOUND) != 0;, +    }, +, +    private boolean isOutboundFreed() {, +        return (flags & FLAG_FREED_OUTBOUND) != 0;, +    }, +, +    private void freeAllIfRemoved() {, +        if (callDepth != 0) {, +            // Free only when the current context's handler is not being called., +            return;, +        }, +, +        final int flags = this.flags;, +                safeFree(inByteBuf);, +                safeFree(inMsgBuf);, +                safeFree(outByteBuf);, +                safeFree(outMsgBuf);, +                this.flags = (short) (flags | FLAG_FREED | FLAG_FREED_INBOUND | FLAG_FREED_OUTBOUND);, +    void freeInbound() {, +        EventExecutor executor = executor();, +        if (executor.inEventLoop()) {, +            freeInbound0();, +        } else {, +            executor.execute(new Runnable() {, +                @Override, +                public void run() {, +                    freeInbound0();, +            });, +    private void freeInbound0() {, +        try {, +            safeFree(inByteBuf);, +            safeFree(inMsgBuf);, +        } finally {, +            flags |= FLAG_FREED_INBOUND;, +            freeNextInboundBridgeFeeder();, +        }, +, +        if (next != null) {, +            DefaultChannelHandlerContext nextCtx = findContextInbound();, +            nextCtx.freeInbound();, +        } else {, +            // Freed all inbound buffers. Remove all handlers from the pipeline one by one from tail (exclusive), +            // to head (inclusive) to trigger handlerRemoved(). If the removed handler has an outbound buffer, free it,, +            // too.  Note that the tail handler is excluded because it's neither an outbound buffer and it doesn't, +            // do anything in handlerRemoved()., +            pipeline.tail.prev.freeOutboundAndRemove();, +        }, +    }, +, +    /** Invocation initiated by {@link #freeInbound0()} after freeing all inbound buffers. */, +    private void freeOutboundAndRemove() {, +        EventExecutor executor = executor();, +        if (executor.inEventLoop()) {, +            freeOutboundAndRemove0();, +        } else {, +            executor.execute(new Runnable() {, +                @Override, +                public void run() {, +                    freeOutboundAndRemove0();, +                }, +            });, +        }, +    }, +, +    private void freeOutboundAndRemove0() {, +        if (handler instanceof ChannelOperationHandler) {, +            // Outbound handler - free the buffers / bridge feeders, +            try {, +                safeFree(outByteBuf);, +                safeFree(outMsgBuf);, +            } finally {, +                // We also OR FLAG_FREED because at this point we are sure both inbound and outbound were freed., +                flags |= FLAG_FREED | FLAG_FREED_OUTBOUND;, +                freeNextOutboundBridgeFeeder();, +            }, +        }, +, +        DefaultChannelHandlerContext prev = this.prev;, +        if (prev != null) {, +            synchronized (pipeline) {, +                pipeline.remove0(this, false);, +            }, +            prev.freeOutboundAndRemove();, +        }]