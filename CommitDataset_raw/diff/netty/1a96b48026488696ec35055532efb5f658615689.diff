[+++ b/src/main/java/org/jboss/netty/channel/socket/servlet/ServletClientSocketChannel.java, +import org.jboss.netty.buffer.ChannelBuffers;, +import org.jboss.netty.channel.ChannelHandlerContext;, +import static org.jboss.netty.channel.Channels.fireChannelOpen;, +import static org.jboss.netty.channel.Channels.pipeline;, +import org.jboss.netty.channel.DefaultChannelPipeline;, +import org.jboss.netty.channel.MessageEvent;, +import org.jboss.netty.channel.SimpleChannelHandler;, +import org.jboss.netty.channel.ExceptionEvent;, +import org.jboss.netty.channel.ChannelStateEvent;, +import org.jboss.netty.channel.ChannelPipelineCoverage;, +import org.jboss.netty.channel.socket.ClientSocketChannelFactory;, +import org.jboss.netty.channel.socket.SocketChannel;, +import static org.jboss.netty.channel.socket.servlet.ServletClientSocketPipelineSink.LINE_TERMINATOR;, +import org.jboss.netty.handler.codec.frame.DelimiterBasedFrameDecoder;, +import org.jboss.netty.handler.codec.frame.Delimiters;, +import org.jboss.netty.util.LinkedTransferQueue;, +, +import java.io.IOException;, +import java.net.InetSocketAddress;, +import java.net.SocketAddress;, +import java.net.URL;, +import java.util.concurrent.locks.ReentrantLock;, +import java.util.concurrent.locks.Lock;, +    private final Lock reconnectLock = new ReentrantLock();, +, +    private volatile boolean awaitingInitialResponse = true;, +    LinkedTransferQueue<byte[]> messages = new LinkedTransferQueue<byte[]>();, +, +    private ClientSocketChannelFactory clientSocketChannelFactory;, +, +    private SocketChannel channel;, +, +    private DelimiterBasedFrameDecoder handler = new DelimiterBasedFrameDecoder(8092, ChannelBuffers.wrappedBuffer(new byte[] { '\r', '\n' }));, +, +    private ServletClientSocketChannel.ServletChannelHandler servletHandler = new ServletChannelHandler();, +, +            ChannelSink sink, URL url, ClientSocketChannelFactory clientSocketChannelFactory) {, +        this.clientSocketChannelFactory = clientSocketChannelFactory;, +, +        DefaultChannelPipeline channelPipeline = new DefaultChannelPipeline();, +        channelPipeline.addLast("DelimiterBasedFrameDecoder", handler);, +        channelPipeline.addLast("servletHandler", servletHandler);, +        channel = clientSocketChannelFactory.newChannel(channelPipeline);, +, +        return channel.getConfig();, +        return channel.getLocalAddress();, +        return channel.getRemoteAddress();, +        return channel.isOpen();, +        return channel.isConnected();, +            DefaultChannelPipeline channelPipeline = new DefaultChannelPipeline();, +            channelPipeline.addLast("DelimiterBasedFrameDecoder", handler);, +            channelPipeline.addLast("servletHandler", servletHandler);, +            channel = clientSocketChannelFactory.newChannel(channelPipeline);, +        channel.connect(remoteAddress);, +        channel.write(ChannelBuffers.wrappedBuffer(msg.getBytes("ASCII7")));, +        // try {, +            a.writeBytes(LINE_TERMINATOR.getBytes());, +            channel.write(ChannelBuffers.wrappedBuffer(hex.getBytes()));, +            channel.write(a).awaitUninterruptibly();, +            //channel.write(ChannelBuffers.wrappedBuffer(LINE_TERMINATOR.getBytes()));, +        byte[] buf = null;, +            buf = messages.take();, +        catch (InterruptedException e) {, +            e.printStackTrace();, +        }, +        return buf;, +    }, +, +    private void reConnect() throws Exception{, +                throw new IllegalStateException("channel closed");, +            if (reconnectLock.tryLock()) {, +                    awaitingInitialResponse = true;, +, +                    connectAndSendHeaders(true, channel.getRemoteAddress());, +                    reconnectLock.unlock();, +                    reconnectLock.lock();, +                    reconnectLock.unlock();, +        channel.close();, +        channel.bind(localAddress);, +    }, +, +    @ChannelPipelineCoverage("one"), +    class ServletChannelHandler extends SimpleChannelHandler {, +        int nextChunkSize = -1;, +, +, +        public void messageReceived(ChannelHandlerContext ctx, MessageEvent e) throws Exception {, +            ChannelBuffer buf = (ChannelBuffer) e.getMessage();, +            byte[] bytes = new byte[buf.readableBytes()];, +            buf.getBytes(0, bytes);, +            if (awaitingInitialResponse) {, +                String line = new String(bytes);, +                if (line.contains("Set-Cookie")) {, +                    int start = line.indexOf("JSESSIONID=") + 11;, +                    int end = line.indexOf(";", start);, +                    sessionId = line.substring(start, end);, +                }, +                else if (line.equals("")) {, +                    awaitingInitialResponse = false;]