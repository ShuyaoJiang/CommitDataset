[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2RemoteFlowController.java, +import static io.netty.handler.codec.http2.Http2Error.STREAM_CLOSED;, +                state(stream).cancel(STREAM_CLOSED, null);, +                if (HALF_CLOSED_LOCAL == stream.state()) {, +                    state(stream).cancel(STREAM_CLOSED, null);, +                    cancel(INTERNAL_ERROR, cause);, +         * @param error the {@link Http2Error} to use., +        void cancel(Http2Error error, Throwable cause) {, +                final Http2Exception exception = streamError(stream.id(), error, cause,, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2RemoteFlowController.java, +import static io.netty.handler.codec.http2.Http2Error.STREAM_CLOSED;, +                state(stream).cancel(STREAM_CLOSED, null);, +                if (HALF_CLOSED_LOCAL == stream.state()) {, +                    state(stream).cancel(STREAM_CLOSED, null);, +                    cancel(INTERNAL_ERROR, cause);, +         * @param error the {@link Http2Error} to use., +        void cancel(Http2Error error, Throwable cause) {, +                final Http2Exception exception = streamError(stream.id(), error, cause,, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2MultiplexCodec.java, +        private boolean outboundClosed;, +                outboundClosed = true;, +                if (!isActive() ||, +                        // Once the outbound side was closed we should not allow header / data frames, +                        outboundClosed && (msg instanceof Http2HeadersFrame || msg instanceof Http2DataFrame)) {, +                    promise.setFailure(wrapStreamClosedError(cause));, +                    // If the first write fails there is not much we can do, just close, +                    Throwable error = wrapStreamClosedError(cause);, +                    promise.setFailure(error);, +, +                    if (error instanceof ClosedChannelException) {, +                        if (config.isAutoClose()) {, +                            // Close channel if needed., +                            closeForcibly();, +                        } else {, +                            outboundClosed = true;, +                }, +            }, +, +            private Throwable wrapStreamClosedError(Throwable cause) {, +                // If the error was caused by STREAM_CLOSED we should use a ClosedChannelException to better, +                // mimic other transports and make it easier to reason about what exceptions to expect., +                if (cause instanceof Http2Exception && ((Http2Exception) cause).error() == Http2Error.STREAM_CLOSED) {, +                    return new ClosedChannelException().initCause(cause);, +                }, +                return cause;, +            }, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2RemoteFlowController.java, +import static io.netty.handler.codec.http2.Http2Error.STREAM_CLOSED;, +                state(stream).cancel(STREAM_CLOSED, null);, +                if (HALF_CLOSED_LOCAL == stream.state()) {, +                    state(stream).cancel(STREAM_CLOSED, null);, +                    cancel(INTERNAL_ERROR, cause);, +         * @param error the {@link Http2Error} to use., +        void cancel(Http2Error error, Throwable cause) {, +                final Http2Exception exception = streamError(stream.id(), error, cause,, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2MultiplexCodec.java, +        private boolean outboundClosed;, +                outboundClosed = true;, +                if (!isActive() ||, +                        // Once the outbound side was closed we should not allow header / data frames, +                        outboundClosed && (msg instanceof Http2HeadersFrame || msg instanceof Http2DataFrame)) {, +                    promise.setFailure(wrapStreamClosedError(cause));, +                    // If the first write fails there is not much we can do, just close, +                    Throwable error = wrapStreamClosedError(cause);, +                    promise.setFailure(error);, +, +                    if (error instanceof ClosedChannelException) {, +                        if (config.isAutoClose()) {, +                            // Close channel if needed., +                            closeForcibly();, +                        } else {, +                            outboundClosed = true;, +                }, +            }, +, +            private Throwable wrapStreamClosedError(Throwable cause) {, +                // If the error was caused by STREAM_CLOSED we should use a ClosedChannelException to better, +                // mimic other transports and make it easier to reason about what exceptions to expect., +                if (cause instanceof Http2Exception && ((Http2Exception) cause).error() == Http2Error.STREAM_CLOSED) {, +                    return new ClosedChannelException().initCause(cause);, +                }, +                return cause;, +            }, +++ b/codec-http2/src/test/java/io/netty/handler/codec/http2/DefaultHttp2RemoteFlowControllerTest.java, +        data.assertError(Http2Error.STREAM_CLOSED);, +        moreData.assertError(Http2Error.STREAM_CLOSED);, +        public void assertError(Http2Error error) {, +            if (error != null) {, +                assertSame(error, ((Http2Exception) t).error());, +            }, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2RemoteFlowController.java, +import static io.netty.handler.codec.http2.Http2Error.STREAM_CLOSED;, +                state(stream).cancel(STREAM_CLOSED, null);, +                if (HALF_CLOSED_LOCAL == stream.state()) {, +                    state(stream).cancel(STREAM_CLOSED, null);, +                    cancel(INTERNAL_ERROR, cause);, +         * @param error the {@link Http2Error} to use., +        void cancel(Http2Error error, Throwable cause) {, +                final Http2Exception exception = streamError(stream.id(), error, cause,, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2MultiplexCodec.java]