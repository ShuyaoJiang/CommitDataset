[+++ b/buffer/src/main/java/io/netty/buffer/PooledByteBufAllocator.java, +        final ByteBuf buf;, +            buf = PlatformDependent.hasUnsafe() ?, +                    new UnpooledUnsafeHeapByteBuf(this, initialCapacity, maxCapacity) :, +                    new UnpooledHeapByteBuf(this, initialCapacity, maxCapacity);, +        final ByteBuf buf;, +            buf = PlatformDependent.hasUnsafe() ?, +                    UnsafeByteBufUtil.newUnsafeDirectByteBuf(this, initialCapacity, maxCapacity) :, +                    new UnpooledDirectByteBuf(this, initialCapacity, maxCapacity);, +++ b/buffer/src/main/java/io/netty/buffer/PooledByteBufAllocator.java, +        final ByteBuf buf;, +            buf = PlatformDependent.hasUnsafe() ?, +                    new UnpooledUnsafeHeapByteBuf(this, initialCapacity, maxCapacity) :, +                    new UnpooledHeapByteBuf(this, initialCapacity, maxCapacity);, +        final ByteBuf buf;, +            buf = PlatformDependent.hasUnsafe() ?, +                    UnsafeByteBufUtil.newUnsafeDirectByteBuf(this, initialCapacity, maxCapacity) :, +                    new UnpooledDirectByteBuf(this, initialCapacity, maxCapacity);, +++ b/buffer/src/test/java/io/netty/buffer/AbstractByteBufAllocatorTest.java, +import static org.junit.Assert.assertTrue;, +    protected abstract AbstractByteBufAllocator newUnpooledAllocator();, +, +, +    @Test, +    public void testUnsafeHeapBufferAndUnsafeDirectBuffer() {, +        AbstractByteBufAllocator allocator = newUnpooledAllocator();, +        ByteBuf directBuffer = allocator.directBuffer();, +        assertInstanceOf(directBuffer,, +                PlatformDependent.hasUnsafe() ? UnpooledUnsafeDirectByteBuf.class : UnpooledDirectByteBuf.class);, +        directBuffer.release();, +, +        ByteBuf heapBuffer = allocator.heapBuffer();, +        assertInstanceOf(heapBuffer,, +                PlatformDependent.hasUnsafe() ? UnpooledUnsafeHeapByteBuf.class : UnpooledHeapByteBuf.class);, +        heapBuffer.release();, +    }, +, +    protected static void assertInstanceOf(ByteBuf buffer, Class<? extends ByteBuf> clazz) {, +        // Unwrap if needed, +        assertTrue(clazz.isInstance(buffer instanceof SimpleLeakAwareByteBuf ? buffer.unwrap() : buffer));, +    }, +++ b/buffer/src/main/java/io/netty/buffer/PooledByteBufAllocator.java, +        final ByteBuf buf;, +            buf = PlatformDependent.hasUnsafe() ?, +                    new UnpooledUnsafeHeapByteBuf(this, initialCapacity, maxCapacity) :, +                    new UnpooledHeapByteBuf(this, initialCapacity, maxCapacity);, +        final ByteBuf buf;, +            buf = PlatformDependent.hasUnsafe() ?, +                    UnsafeByteBufUtil.newUnsafeDirectByteBuf(this, initialCapacity, maxCapacity) :, +                    new UnpooledDirectByteBuf(this, initialCapacity, maxCapacity);, +++ b/buffer/src/test/java/io/netty/buffer/AbstractByteBufAllocatorTest.java, +import static org.junit.Assert.assertTrue;, +    protected abstract AbstractByteBufAllocator newUnpooledAllocator();, +, +, +    @Test, +    public void testUnsafeHeapBufferAndUnsafeDirectBuffer() {, +        AbstractByteBufAllocator allocator = newUnpooledAllocator();, +        ByteBuf directBuffer = allocator.directBuffer();, +        assertInstanceOf(directBuffer,, +                PlatformDependent.hasUnsafe() ? UnpooledUnsafeDirectByteBuf.class : UnpooledDirectByteBuf.class);, +        directBuffer.release();, +, +        ByteBuf heapBuffer = allocator.heapBuffer();, +        assertInstanceOf(heapBuffer,, +                PlatformDependent.hasUnsafe() ? UnpooledUnsafeHeapByteBuf.class : UnpooledHeapByteBuf.class);, +        heapBuffer.release();, +    }, +, +    protected static void assertInstanceOf(ByteBuf buffer, Class<? extends ByteBuf> clazz) {, +        // Unwrap if needed, +        assertTrue(clazz.isInstance(buffer instanceof SimpleLeakAwareByteBuf ? buffer.unwrap() : buffer));, +    }, +++ b/buffer/src/test/java/io/netty/buffer/PooledByteBufAllocatorTest.java, +import io.netty.util.internal.PlatformDependent;, +    @Override, +    protected AbstractByteBufAllocator newUnpooledAllocator() {, +        return new PooledByteBufAllocator(0, 0, 8192, 1);, +    }, +, +    @Test, +    public void testPooledUnsafeHeapBufferAndUnsafeDirectBuffer() {, +        AbstractByteBufAllocator allocator = newAllocator(true);, +        ByteBuf directBuffer = allocator.directBuffer();, +        assertInstanceOf(directBuffer,, +                PlatformDependent.hasUnsafe() ? PooledUnsafeDirectByteBuf.class : PooledDirectByteBuf.class);, +        directBuffer.release();, +, +        ByteBuf heapBuffer = allocator.heapBuffer();, +        assertInstanceOf(heapBuffer,, +                PlatformDependent.hasUnsafe() ? PooledUnsafeHeapByteBuf.class : PooledHeapByteBuf.class);, +        heapBuffer.release();, +    }, +, +++ b/buffer/src/main/java/io/netty/buffer/PooledByteBufAllocator.java, +        final ByteBuf buf;, +            buf = PlatformDependent.hasUnsafe() ?, +                    new UnpooledUnsafeHeapByteBuf(this, initialCapacity, maxCapacity) :, +                    new UnpooledHeapByteBuf(this, initialCapacity, maxCapacity);, +        final ByteBuf buf;]