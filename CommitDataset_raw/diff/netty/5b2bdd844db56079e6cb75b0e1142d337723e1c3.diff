[+++ b/common/src/main/java/io/netty/util/HashedWheelTimer.java, +    private final Queue<Runnable> cancelledTimeouts = PlatformDependent.newMpscQueue();, +                    processCancelledTasks();, +                if (!timeout.isCancelled()) {, +            processCancelledTasks();, +        }, +, +        private void processCancelledTasks() {, +            for (;;) {, +                Runnable task = cancelledTimeouts.poll();, +                if (task == null) {, +                    // all processed, +                    break;, +                }, +                try {, +                    task.run();, +                } catch (Throwable t) {, +                    if (logger.isWarnEnabled()) {, +                        logger.warn("An exception was thrown while process a cancellation task", t);, +                    }, +                }, +            }, +        }, +, +            // If a task should be canceled we create a new Runnable for this to another queue which will, +            // be processed on each tick. So this means that we will have a GC latency of max. 1 tick duration, +            // which is good enough. This way we can make again use of our MpscLinkedQueue and so minimize the, +            // locking / overhead as much as possible., +            //, +            // It is important that we not just add the HashedWheelTimeout itself again as it extends, +            // MpscLinkedQueueNode and so may still be used as tombstone., +            timer.cancelledTimeouts.add(new Runnable() {, +                @Override, +                public void run() {, +                    HashedWheelBucket bucket = HashedWheelTimeout.this.bucket;, +                        bucket.remove(HashedWheelTimeout.this);, +            });]