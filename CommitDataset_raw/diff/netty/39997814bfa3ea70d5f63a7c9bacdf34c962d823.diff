[+++ b/handler/src/main/java/io/netty/handler/ssl/SslHandler.java, +            // Only continue to loop if the handler was not removed in the meantime., +            // See https://github.com/netty/netty/issues/5860, +            while (!ctx.isRemoved()) {, +            // Only continue to loop if the handler was not removed in the meantime., +            // See https://github.com/netty/netty/issues/5860, +            while (!ctx.isRemoved()) {, +, +            // First fail the handshake promise as we may need to have access to the SSLEngine which may, +            // be released because the user will remove the SslHandler in an exceptionCaught(...) implementation., +, +            ctx.fireExceptionCaught(e);, +            // Only continue to loop if the handler was not removed in the meantime., +            // See https://github.com/netty/netty/issues/5860, +            while (!ctx.isRemoved()) {, +                    int bufferSize = engine.getSession().getApplicationBufferSize() - readableBytes;, +                    decodeOut = allocate(ctx, bufferSize);, +++ b/handler/src/main/java/io/netty/handler/ssl/SslHandler.java, +            // Only continue to loop if the handler was not removed in the meantime., +            // See https://github.com/netty/netty/issues/5860, +            while (!ctx.isRemoved()) {, +            // Only continue to loop if the handler was not removed in the meantime., +            // See https://github.com/netty/netty/issues/5860, +            while (!ctx.isRemoved()) {, +, +            // First fail the handshake promise as we may need to have access to the SSLEngine which may, +            // be released because the user will remove the SslHandler in an exceptionCaught(...) implementation., +, +            ctx.fireExceptionCaught(e);, +            // Only continue to loop if the handler was not removed in the meantime., +            // See https://github.com/netty/netty/issues/5860, +            while (!ctx.isRemoved()) {, +                    int bufferSize = engine.getSession().getApplicationBufferSize() - readableBytes;, +                    decodeOut = allocate(ctx, bufferSize);, +++ b/handler/src/test/java/io/netty/handler/ssl/SslHandlerTest.java, +import io.netty.bootstrap.Bootstrap;, +import io.netty.bootstrap.ServerBootstrap;, +import io.netty.channel.Channel;, +import io.netty.channel.ChannelHandler;, +import io.netty.channel.ChannelInitializer;, +import io.netty.channel.nio.NioEventLoopGroup;, +import io.netty.channel.socket.nio.NioServerSocketChannel;, +import io.netty.channel.socket.nio.NioSocketChannel;, +import io.netty.handler.codec.CodecException;, +import io.netty.handler.ssl.util.InsecureTrustManagerFactory;, +import io.netty.util.IllegalReferenceCountException;, +import io.netty.util.concurrent.Future;, +import io.netty.util.concurrent.FutureListener;, +import io.netty.util.concurrent.Promise;, +import java.net.InetSocketAddress;, +, +, +    @Test(timeout = 5000), +    public void testRemoval() throws Exception {, +        NioEventLoopGroup group = new NioEventLoopGroup();, +        Channel sc = null;, +        Channel cc = null;, +        try {, +            final Promise<Void> clientPromise = group.next().newPromise();, +            Bootstrap bootstrap = new Bootstrap(), +                    .group(group), +                    .channel(NioSocketChannel.class), +                    .handler(newHandler(SslContextBuilder.forClient().trustManager(, +                            InsecureTrustManagerFactory.INSTANCE).build(), clientPromise));, +, +            SelfSignedCertificate ssc = new SelfSignedCertificate();, +            final Promise<Void> serverPromise = group.next().newPromise();, +            ServerBootstrap serverBootstrap = new ServerBootstrap(), +                    .group(group, group), +                    .channel(NioServerSocketChannel.class), +                    .childHandler(newHandler(SslContextBuilder.forServer(ssc.certificate(), ssc.privateKey()).build(),, +                            serverPromise));, +            sc = serverBootstrap.bind(new InetSocketAddress(0)).syncUninterruptibly().channel();, +            cc = bootstrap.connect(sc.localAddress()).syncUninterruptibly().channel();, +, +            serverPromise.syncUninterruptibly();, +            clientPromise.syncUninterruptibly();, +        } finally {, +            if (cc != null) {, +                cc.close().syncUninterruptibly();, +            }, +            if (sc != null) {, +                sc.close().syncUninterruptibly();, +            }, +            group.shutdownGracefully();, +        }, +    }, +, +    private static ChannelHandler newHandler(final SslContext sslCtx, final Promise<Void> promise) {, +        return new ChannelInitializer() {, +            @Override, +            protected void initChannel(final Channel ch) {, +                final SslHandler sslHandler = sslCtx.newHandler(ch.alloc());, +                sslHandler.setHandshakeTimeoutMillis(1000);, +                ch.pipeline().addFirst(sslHandler);, +                sslHandler.handshakeFuture().addListener(new FutureListener<Channel>() {, +                    @Override, +                    public void operationComplete(final Future<Channel> future) {, +                        ch.pipeline().remove(sslHandler);, +]