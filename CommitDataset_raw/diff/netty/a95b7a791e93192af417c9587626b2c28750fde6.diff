[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2ConnectionEncoder.java, +                // The behavior here should mirror that in FlowControlledHeaders, +, +                promise = promise.unvoid();, +                if (endOfStream) {, +                    // Must handle calling onError before calling closeStreamLocal, otherwise the error handler will, +                    // incorrectly think the stream no longer exists and so may not send RST_STREAM or perform similar, +                    // appropriate action., +                    lifecycleManager.closeStreamLocal(stream, future);, +                }, +, +            promise = promise.unvoid();, +            super(stream, padding, endOfStream, promise.unvoid());, +            // The code is currently requiring adding this listener before writing, in order to call onError() before, +            // closeStreamLocal()., +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2ConnectionEncoder.java, +                // The behavior here should mirror that in FlowControlledHeaders, +, +                promise = promise.unvoid();, +                if (endOfStream) {, +                    // Must handle calling onError before calling closeStreamLocal, otherwise the error handler will, +                    // incorrectly think the stream no longer exists and so may not send RST_STREAM or perform similar, +                    // appropriate action., +                    lifecycleManager.closeStreamLocal(stream, future);, +                }, +, +            promise = promise.unvoid();, +            super(stream, padding, endOfStream, promise.unvoid());, +            // The code is currently requiring adding this listener before writing, in order to call onError() before, +            // closeStreamLocal()., +++ b/codec-http2/src/test/java/io/netty/handler/codec/http2/DefaultHttp2ConnectionEncoderTest.java, +import org.mockito.InOrder;, +import static org.mockito.Mockito.inOrder;, +    public void headersWriteShouldHalfCloseAfterOnError() throws Exception {, +        final ChannelPromise promise = newPromise();, +        final Throwable ex = new RuntimeException();, +        // Fake an encoding error, like HPACK's HeaderListSizeException, +        when(writer.writeHeaders(eq(ctx), eq(STREAM_ID), eq(EmptyHttp2Headers.INSTANCE), eq(0),, +                eq(DEFAULT_PRIORITY_WEIGHT), eq(false), eq(0), eq(true), eq(promise))), +            .thenAnswer(new Answer<ChannelFuture>() {, +                @Override, +                public ChannelFuture answer(InvocationOnMock invocation) {, +                    promise.setFailure(ex);, +                    return promise;, +                }, +            });, +, +        writeAllFlowControlledFrames();, +        createStream(STREAM_ID, false);, +        encoder.writeHeaders(ctx, STREAM_ID, EmptyHttp2Headers.INSTANCE, 0, true, promise);, +, +        assertTrue(promise.isDone());, +        assertFalse(promise.isSuccess());, +        InOrder inOrder = inOrder(lifecycleManager);, +        inOrder.verify(lifecycleManager).onError(eq(ctx), eq(true), eq(ex));, +        inOrder.verify(lifecycleManager).closeStreamLocal(eq(stream(STREAM_ID)), eq(promise));, +    }, +, +    @Test]