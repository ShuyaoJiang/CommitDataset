[+++ b/handler/src/main/java/io/netty/handler/flow/FlowControlHandler.java, +/*, + * Copyright 2016 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License, version, + * 2.0 (the "License"); you may not use this file except in compliance with the, + * License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the, + * License for the specific language governing permissions and limitations under, + * the License., + */, +package io.netty.handler.flow;, +, +import java.util.ArrayDeque;, +import java.util.Queue;, +, +import io.netty.channel.Channel;, +import io.netty.channel.ChannelConfig;, +import io.netty.channel.ChannelDuplexHandler;, +import io.netty.channel.ChannelHandler;, +import io.netty.channel.ChannelHandlerContext;, +import io.netty.channel.ChannelInboundHandlerAdapter;, +import io.netty.channel.ChannelPipeline;, +import io.netty.handler.codec.ByteToMessageDecoder;, +import io.netty.handler.codec.MessageToByteEncoder;, +import io.netty.util.Recycler;, +import io.netty.util.Recycler.Handle;, +import io.netty.util.ReferenceCountUtil;, +import io.netty.util.internal.logging.InternalLogger;, +import io.netty.util.internal.logging.InternalLoggerFactory;, +, +/**, + * The {@link FlowControlHandler} ensures that only one message per {@code read()} is sent downstream., + *, + * Classes such as {@link ByteToMessageDecoder} or {@link MessageToByteEncoder} are free to emit as, + * many events as they like for any given input. A channel's auto reading configuration doesn't usually, + * apply in these scenarios. This is causing problems in downstream {@link ChannelHandler}s that would, + * like to hold subsequent events while they're processing one event. It's a common problem with the, + * {@code HttpObjectDecoder} that will very often fire a {@code HttpRequest} that is immediately followed, + * by a {@code LastHttpContent} event., + *, + * <pre>, + * {@link ChannelPipeline} pipeline = ...;, + *, + * pipeline.addLast(new HttpServerCodec());, + * pipeline.addLast(new {@link FlowControlHandler}());, + *, + * pipeline.addLast(new MyExampleHandler());, + *, + * class MyExampleHandler extends {@link ChannelInboundHandlerAdapter} {, + *   @Override, + *   public void channelRead({@link ChannelHandlerContext} ctx, Object msg) {, + *     if (msg instanceof HttpRequest) {, + *       ctx.channel().config().setAutoRead(false);, + *, + *       // The FlowControlHandler will hold any subsequent events that, + *       // were emitted by HttpObjectDecoder until auto reading is turned, + *       // back on or Channel#read() is being called., + *     }, + *   }, + * }, + * </pre>, + *, + * @see ChannelConfig#setAutoRead(boolean), + */, +public class FlowControlHandler extends ChannelDuplexHandler {, +    private static final InternalLogger logger = InternalLoggerFactory.getInstance(FlowControlHandler.class);, +, +    private final boolean releaseMessages;, +, +    private RecyclableArrayDeque queue;, +, +    private ChannelConfig config;, +, +    private boolean shouldConsume;, +, +    public FlowControlHandler() {, +        this(true);, +    }, +, +    public FlowControlHandler(boolean releaseMessages) {, +        this.releaseMessages = releaseMessages;, +    }, +, +    /**, +     * Returns a copy of the underlying {@link Queue}. This method exists for, +     * testing, debugging and inspection purposes and it is not Thread safe!, +     */, +    Queue<Object> queue() {, +        RecyclableArrayDeque queue = this.queue;, +, +        if (queue == null) {, +            return new ArrayDeque<Object>(0);, +        }, +]