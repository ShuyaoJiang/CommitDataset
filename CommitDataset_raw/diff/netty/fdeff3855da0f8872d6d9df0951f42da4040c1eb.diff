[+++ b/buffer/src/main/java/io/netty/buffer/PoolArena.java, +    PooledByteBuf<T> allocate(PoolThreadCache cache, int minCapacity, int maxCapacity) {, +        allocate(cache, buf, minCapacity);, +    private void allocate(PoolThreadCache cache, PooledByteBuf<T> buf, int minCapacity) {, +        final int capacity = normalizeCapacity(minCapacity);, +        if ((capacity & subpageOverflowMask) == 0) { // capacity < pageSize, +            if ((capacity & 0xFFFFFE00) == 0) { // < 512, +                tableIdx = capacity >>> 4;, +                int i = capacity >>> 10;, +                    if (!s.doNotDestroy || s.elemSize != capacity) {, +                        s.chunk.initBufWithSubpage(buf, handle);, +        allocateNormal(buf, capacity);, +    private synchronized void allocateNormal(PooledByteBuf<T> buf, int capacity) {, +        if (q050.allocate(buf, capacity) || q025.allocate(buf, capacity) ||, +            q000.allocate(buf, capacity) || qInit.allocate(buf, capacity) ||, +            q075.allocate(buf, capacity)) {, +        long handle = c.allocate(capacity);, +        c.initBuf(buf, handle);, +    private int normalizeCapacity(int capacity) {, +        if (capacity < 0 || capacity > chunkSize) {, +            throw new IllegalArgumentException("capacity: " + capacity + " (expected: 0-" + chunkSize + ')');, +        if ((capacity & 0xFFFFFE00) != 0) { // >= 512, +            while (normalizedCapacity < capacity) {, +        if ((capacity & 15) == 0) {, +            return capacity;, +        return (capacity & ~15) + 16;, +++ b/buffer/src/main/java/io/netty/buffer/PoolArena.java, +    PooledByteBuf<T> allocate(PoolThreadCache cache, int minCapacity, int maxCapacity) {, +        allocate(cache, buf, minCapacity);, +    private void allocate(PoolThreadCache cache, PooledByteBuf<T> buf, int minCapacity) {, +        final int capacity = normalizeCapacity(minCapacity);, +        if ((capacity & subpageOverflowMask) == 0) { // capacity < pageSize, +            if ((capacity & 0xFFFFFE00) == 0) { // < 512, +                tableIdx = capacity >>> 4;, +                int i = capacity >>> 10;, +                    if (!s.doNotDestroy || s.elemSize != capacity) {, +                        s.chunk.initBufWithSubpage(buf, handle);, +        allocateNormal(buf, capacity);, +    private synchronized void allocateNormal(PooledByteBuf<T> buf, int capacity) {, +        if (q050.allocate(buf, capacity) || q025.allocate(buf, capacity) ||, +            q000.allocate(buf, capacity) || qInit.allocate(buf, capacity) ||, +            q075.allocate(buf, capacity)) {, +        long handle = c.allocate(capacity);, +        c.initBuf(buf, handle);, +    private int normalizeCapacity(int capacity) {, +        if (capacity < 0 || capacity > chunkSize) {, +            throw new IllegalArgumentException("capacity: " + capacity + " (expected: 0-" + chunkSize + ')');, +        if ((capacity & 0xFFFFFE00) != 0) { // >= 512, +            while (normalizedCapacity < capacity) {, +        if ((capacity & 15) == 0) {, +            return capacity;, +        return (capacity & ~15) + 16;, +++ b/buffer/src/main/java/io/netty/buffer/PoolChunk.java, +    long allocate(int capacity) {, +        if ((capacity & subpageOverflowMask) != 0) { // >= pageSize, +            return allocateRun(capacity, 1, firstVal);, +            return allocateSubpage(capacity, 1, firstVal);, +    private long allocateRun(int capacity, int curIdx, int val) {, +                long res = allocateRun(capacity, nextIdx, memoryMap[nextIdx]);, +            return allocateRunSimple(capacity, curIdx, val);, +    private long allocateRunSimple(int capacity, int curIdx, int val) {, +        if (capacity > runLength) {, +            if (capacity == runLength) {, +    private long allocateSubpage(int capacity, int curIdx, int val) {, +            long res = branchSubpage(capacity, nextIdx);, +            return branchSubpage(capacity, nextIdx ^ 1);, +            return allocateSubpageSimple(capacity, curIdx, val);, +            if (capacity != elemSize) {, +    private long allocateSubpageSimple(int capacity, int curIdx, int val) {, +                    subpage = new PoolSubpage<T>(this, curIdx, runOffset(val), pageSize, capacity);, +                    subpage.init(capacity);, +    private long branchSubpage(int capacity, int nextIdx) {, +            return allocateSubpage(capacity, nextIdx, nextVal);, +    void initBuf(PooledByteBuf<T> buf, long handle) {, +            buf.init(this, handle, memory, runOffset(val), runLength(val));, +            initBufWithSubpage(buf, handle, bitmapIdx);, +    void initBufWithSubpage(PooledByteBuf<T> buf, long handle) {, +        initBufWithSubpage(buf, handle, (int) (handle >>> 32));, +    private void initBufWithSubpage(PooledByteBuf<T> buf, long handle, int bitmapIdx) {, +                runOffset(val) + (bitmapIdx & 0x3FFFFFFF) * subpage.elemSize, subpage.elemSize);, +++ b/buffer/src/main/java/io/netty/buffer/PoolArena.java, +    PooledByteBuf<T> allocate(PoolThreadCache cache, int minCapacity, int maxCapacity) {, +        allocate(cache, buf, minCapacity);, +    private void allocate(PoolThreadCache cache, PooledByteBuf<T> buf, int minCapacity) {, +        final int capacity = normalizeCapacity(minCapacity);, +        if ((capacity & subpageOverflowMask) == 0) { // capacity < pageSize, +            if ((capacity & 0xFFFFFE00) == 0) { // < 512, +                tableIdx = capacity >>> 4;, +                int i = capacity >>> 10;, +                    if (!s.doNotDestroy || s.elemSize != capacity) {, +                        s.chunk.initBufWithSubpage(buf, handle);, +        allocateNormal(buf, capacity);, +    private synchronized void allocateNormal(PooledByteBuf<T> buf, int capacity) {, +        if (q050.allocate(buf, capacity) || q025.allocate(buf, capacity) ||, +            q000.allocate(buf, capacity) || qInit.allocate(buf, capacity) ||, +            q075.allocate(buf, capacity)) {, +        long handle = c.allocate(capacity);, +        c.initBuf(buf, handle);, +    private int normalizeCapacity(int capacity) {, +        if (capacity < 0 || capacity > chunkSize) {]