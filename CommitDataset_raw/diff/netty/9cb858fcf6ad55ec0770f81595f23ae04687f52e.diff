[+++ b/common/src/main/java/io/netty/util/NetUtil.java, +     * Creates an byte[] based on an ipAddressString. No error handling is performed here., +            return getIPv6ByName(ipAddressString, true);, +                    } else if (numberOfPeriods == 1) {, +                        // Verify this address is of the correct structure to contain an IPv4 address., +                        // It must be IPv4-Mapped or IPv4-Compatible, +                        // (see https://tools.ietf.org/html/rfc4291#section-2.5.5)., +                        int j = i - word.length() - 2; // index of character before the previous ':'., +                        final int beginColonIndex = ipAddress.lastIndexOf(':', j);, +                        if (beginColonIndex == -1) {, +                            return false;, +                        }, +                        char tmpChar = ipAddress.charAt(j);, +                        if (isValidIPv4MappedChar(tmpChar)) {, +                            if (j - beginColonIndex != 4 ||, +                                !isValidIPv4MappedChar(ipAddress.charAt(j - 1)) ||, +                                !isValidIPv4MappedChar(ipAddress.charAt(j - 2)) ||, +                                !isValidIPv4MappedChar(ipAddress.charAt(j - 3))) {, +                                return false;, +                            }, +                            j -= 5;, +                        } else if (tmpChar == '0' || tmpChar == ':') {, +                            --j;, +                        } else {, +                            return false;, +                        }, +                        for (; j >= startOffset; --j) {, +                            tmpChar = ipAddress.charAt(j);, +                            if (tmpChar != '0' && tmpChar != ':') {, +                                return false;, +                            }, +                        }, +            if (numberOfPeriods != 3 || !(isValidIp4Word(word.toString()) && (numberOfColons < 7 || doubleColon))) {, +    private static boolean isValidIPv4MappedChar(char c) {, +        return c == 'f' || c == 'F';, +    }, +, +    private static boolean isValidIPv4MappedSeparators(byte b0, byte b1, boolean mustBeZero) {, +        // We allow IPv4 Mapped (https://tools.ietf.org/html/rfc4291#section-2.5.5.1), +        // and IPv4 compatible (https://tools.ietf.org/html/rfc4291#section-2.5.5.1)., +        // The IPv4 compatible is deprecated, but it allows parsing of plain IPv4 addressed into IPv6-Mapped addresses., +        return b0 == b1 && (b0 == 0 || !mustBeZero && b1 == -1);, +    }, +, +    private static boolean isValidIPv4Mapped(byte[] bytes, int currentIndex, int compressBegin, int compressLength) {, +        return currentIndex <= 12 && currentIndex >= 2 &&, +                isValidIPv4MappedSeparators(bytes[currentIndex - 1], bytes[currentIndex - 2],, +                (compressBegin + compressLength) >= 14) && PlatformDependent.isZero(bytes, 0, currentIndex - 3);, +    }, +, +     * <li>{@code false} Consider IPv4 mapped addresses as invalid.</li>, +        byte[] bytes = getIPv6ByName(ip, ipv4Mapped);, +        if (bytes == null) {, +            return null;, +        }, +        try {, +            return Inet6Address.getByAddress(null, bytes, -1);, +        } catch (UnknownHostException e) {, +            throw new RuntimeException(e); // Should never happen, +        }, +    }, +, +    /**, +     * Returns the byte array representation of a {@link CharSequence} IP address., +     * <p>, +     * The {@code ipv4Mapped} parameter specifies how IPv4 addresses should be treated., +     * "IPv4 mapped" format as, +     * defined in <a href="http://tools.ietf.org/html/rfc4291#section-2.5.5">rfc 4291 section 2</a> is supported., +     * @param ip {@link CharSequence} IP address to be converted to a {@link Inet6Address}, +     * @param ipv4Mapped, +     * <ul>, +     * <li>{@code true} To allow IPv4 mapped inputs to be translated into {@link Inet6Address}</li>, +     * <li>{@code false} Consider IPv4 mapped addresses as invalid.</li>, +     * </ul>, +     * @return byte array representation of the {@code ip} or {@code null} if not a valid IP address., +     */, +    private static byte[] getIPv6ByName(CharSequence ip, boolean ipv4Mapped) {, +        int ipv6Separators = 0;, +        int ipv4Separators = 0;, +                ++ipv6Separators;, +                        ipv4Separators > 0 || ipv6Separators > IPV6_MAX_SEPARATORS ||, +                    ++ipv6Separators;, +                    needsShift = ipv6Separators == 2 && value == 0;, +                ++ipv4Separators;, +                tmp = i - begin; // tmp is the length of the current segment., +                if (tmp > IPV4_MAX_CHAR_BETWEEN_SEPARATOR, +                        || begin < 0, +                        || ipv4Separators > IPV4_SEPARATORS, +                        || (ipv6Separators > 0 && (currentIndex + compressLength < 12)), +                        || ipv4Separators == 1 &&, +                            // We also parse pure IPv4 addresses as IPv4-Mapped for ease of use., +                            ((!ipv4Mapped || currentIndex != 0 && !isValidIPv4Mapped(bytes, currentIndex,, +                                                                                     compressBegin, compressLength)) ||, +                                (tmp == 3 && (!isValidNumericChar(ip.charAt(i - 1)) ||, +                                              !isValidNumericChar(ip.charAt(i - 2)) ||, +                                              !isValidNumericChar(ip.charAt(i - 3))) ||, +                                 tmp == 2 && (!isValidNumericChar(ip.charAt(i - 1)) ||, +                                              !isValidNumericChar(ip.charAt(i - 2))) ||, +                                 tmp == 1 && !isValidNumericChar(ip.charAt(i - 1))))) {, +                value <<= (IPV4_MAX_CHAR_BETWEEN_SEPARATOR - tmp) << 2;]