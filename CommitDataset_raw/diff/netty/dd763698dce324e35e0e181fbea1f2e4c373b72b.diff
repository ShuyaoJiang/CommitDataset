[+++ b/transport/src/main/java/io/netty/channel/group/ChannelGroup.java, +     * @return itself, +     */, +    ChannelGroup write(Object message);, +, +    /**, +     * Flush all {@link Channel}s in this, +     * group.  Please note that this operation is asynchronous as, +     * {@link Channel#flush()} is., +     *, +    ChannelGroupFuture flush();, +, +    /**, +     * Shortcut for calling {@link #write(Object)} and {@link #flush()}., +     */, +    ChannelGroupFuture flushAndWrite(Object message);, +++ b/transport/src/main/java/io/netty/channel/group/ChannelGroup.java, +     * @return itself, +     */, +    ChannelGroup write(Object message);, +, +    /**, +     * Flush all {@link Channel}s in this, +     * group.  Please note that this operation is asynchronous as, +     * {@link Channel#flush()} is., +     *, +    ChannelGroupFuture flush();, +, +    /**, +     * Shortcut for calling {@link #write(Object)} and {@link #flush()}., +     */, +    ChannelGroupFuture flushAndWrite(Object message);, +++ b/transport/src/main/java/io/netty/channel/group/DefaultChannelGroup.java, +    public ChannelGroup write(Object message) {, +            c.write(safeDuplicate(message));, +        return this;, +    }, +, +    @Override, +    public ChannelGroupFuture flush() {, +        Map<Channel, ChannelFuture> futures = new LinkedHashMap<Channel, ChannelFuture>(size());, +        for (Channel c: nonServerChannels) {, +            futures.put(c, c.flush());, +        }, +, +        return new DefaultChannelGroupFuture(this, futures, executor);, +    }, +, +    @Override, +    public ChannelGroupFuture flushAndWrite(Object message) {, +        Map<Channel, ChannelFuture> futures = new LinkedHashMap<Channel, ChannelFuture>(size());, +, +        for (Channel c: nonServerChannels) {, +            futures.put(c, c.writeAndFlush(safeDuplicate(message)));, +        }, +, +        ReferenceCountUtil.release(message);, +]