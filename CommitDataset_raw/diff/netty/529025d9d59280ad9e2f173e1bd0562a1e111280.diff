[+++ b/transport/src/main/java/io/netty/channel/pool/FixedChannelPool.java, +        this(bootstrap, handler, healthCheck, action, acquireTimeoutMillis, maxConnections, maxPendingAcquires,, +                releaseHealthCheck, true);, +    }, +, +    /**, +     * Creates a new instance., +     *, +     * @param bootstrap             the {@link Bootstrap} that is used for connections, +     * @param handler               the {@link ChannelPoolHandler} that will be notified for the different pool actions, +     * @param healthCheck           the {@link ChannelHealthChecker} that will be used to check if a {@link Channel} is, +     *                              still healthy when obtain from the {@link ChannelPool}, +     * @param action                the {@link AcquireTimeoutAction} to use or {@code null} if non should be used., +     *                              In this case {@param acquireTimeoutMillis} must be {@code -1}., +     * @param acquireTimeoutMillis  the time (in milliseconds) after which an pending acquire must complete or, +     *                              the {@link AcquireTimeoutAction} takes place., +     * @param maxConnections        the number of maximal active connections, once this is reached new tries to, +     *                              acquire a {@link Channel} will be delayed until a connection is returned to the, +     *                              pool again., +     * @param maxPendingAcquires    the maximum number of pending acquires. Once this is exceed acquire tries will, +     *                              be failed., +     * @param releaseHealthCheck    will check channel health before offering back if this parameter set to, +     *                              {@code true}., +     * @param lastRecentUsed        {@code true} {@link Channel} selection will be LIFO, if {@code false} FIFO., +     */, +    public FixedChannelPool(Bootstrap bootstrap,, +                            ChannelPoolHandler handler,, +                            ChannelHealthChecker healthCheck, AcquireTimeoutAction action,, +                            final long acquireTimeoutMillis,, +                            int maxConnections, int maxPendingAcquires,, +                            boolean releaseHealthCheck, boolean lastRecentUsed) {, +        super(bootstrap, handler, healthCheck, releaseHealthCheck, lastRecentUsed);, +++ b/transport/src/main/java/io/netty/channel/pool/FixedChannelPool.java, +        this(bootstrap, handler, healthCheck, action, acquireTimeoutMillis, maxConnections, maxPendingAcquires,, +                releaseHealthCheck, true);, +    }, +, +    /**, +     * Creates a new instance., +     *, +     * @param bootstrap             the {@link Bootstrap} that is used for connections, +     * @param handler               the {@link ChannelPoolHandler} that will be notified for the different pool actions, +     * @param healthCheck           the {@link ChannelHealthChecker} that will be used to check if a {@link Channel} is, +     *                              still healthy when obtain from the {@link ChannelPool}, +     * @param action                the {@link AcquireTimeoutAction} to use or {@code null} if non should be used., +     *                              In this case {@param acquireTimeoutMillis} must be {@code -1}., +     * @param acquireTimeoutMillis  the time (in milliseconds) after which an pending acquire must complete or, +     *                              the {@link AcquireTimeoutAction} takes place., +     * @param maxConnections        the number of maximal active connections, once this is reached new tries to, +     *                              acquire a {@link Channel} will be delayed until a connection is returned to the, +     *                              pool again., +     * @param maxPendingAcquires    the maximum number of pending acquires. Once this is exceed acquire tries will, +     *                              be failed., +     * @param releaseHealthCheck    will check channel health before offering back if this parameter set to, +     *                              {@code true}., +     * @param lastRecentUsed        {@code true} {@link Channel} selection will be LIFO, if {@code false} FIFO., +     */, +    public FixedChannelPool(Bootstrap bootstrap,, +                            ChannelPoolHandler handler,, +                            ChannelHealthChecker healthCheck, AcquireTimeoutAction action,, +                            final long acquireTimeoutMillis,, +                            int maxConnections, int maxPendingAcquires,, +                            boolean releaseHealthCheck, boolean lastRecentUsed) {, +        super(bootstrap, handler, healthCheck, releaseHealthCheck, lastRecentUsed);, +++ b/transport/src/main/java/io/netty/channel/pool/SimpleChannelPool.java, +    private final boolean lastRecentUsed;, +        this(bootstrap, handler, healthCheck, releaseHealthCheck, true);, +    }, +, +    /**, +     * Creates a new instance., +     *, +     * @param bootstrap          the {@link Bootstrap} that is used for connections, +     * @param handler            the {@link ChannelPoolHandler} that will be notified for the different pool actions, +     * @param healthCheck        the {@link ChannelHealthChecker} that will be used to check if a {@link Channel} is, +     *                           still healthy when obtain from the {@link ChannelPool}, +     * @param releaseHealthCheck will check channel health before offering back if this parameter set to {@code true};, +     *                           otherwise, channel health is only checked at acquisition time, +     * @param lastRecentUsed    {@code true} {@link Channel} selection will be LIFO, if {@code false} FIFO., +     */, +    public SimpleChannelPool(Bootstrap bootstrap, final ChannelPoolHandler handler, ChannelHealthChecker healthCheck,, +                             boolean releaseHealthCheck, boolean lastRecentUsed) {, +        this.lastRecentUsed = lastRecentUsed;, +        return lastRecentUsed ? deque.pollLast() : deque.pollFirst();]