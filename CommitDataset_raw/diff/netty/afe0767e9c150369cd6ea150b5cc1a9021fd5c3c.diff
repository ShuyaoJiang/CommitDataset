[+++ b/common/src/main/java/io/netty/util/internal/logging/LocationAwareSlf4JLogger.java, +/*, + * Copyright 2017 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + *   http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the, + * License for the specific language governing permissions and limitations, + * under the License., + */, +package io.netty.util.internal.logging;, +, +import org.slf4j.spi.LocationAwareLogger;, +, +import static org.slf4j.spi.LocationAwareLogger.*;, +, +/**, + * <a href="http://www.slf4j.org/">SLF4J</a> logger which is location aware and so will log the correct origin of the, + * logging event by filter out the wrapper itself., + */, +final class LocationAwareSlf4JLogger extends AbstractInternalLogger {, +, +    // IMPORTANT: All our log methods first check if the log level is enabled before call the wrapped, +    // LocationAwareLogger.log(...) method. This is done to reduce GC creation that is caused by varargs., +, +    private static final String FQCN = LocationAwareSlf4JLogger.class.getName();, +    private static final long serialVersionUID = -8292030083201538180L;, +, +    private final transient LocationAwareLogger logger;, +, +    LocationAwareSlf4JLogger(LocationAwareLogger logger) {, +        super(logger.getName());, +        this.logger = logger;, +    }, +, +    private void log(final int level, final String message, final Object... params) {, +        logger.log(null, FQCN, level, message, params, null);, +    }, +, +    private void log(final int level, final String message, Throwable throwable, final Object... params) {, +        logger.log(null, FQCN, level, message, params, throwable);, +    }, +, +    @Override, +    public boolean isTraceEnabled() {, +        return logger.isTraceEnabled();, +    }, +, +    @Override, +    public void trace(String msg) {, +        if (isTraceEnabled()) {, +            log(TRACE_INT, msg, null);, +        }, +    }, +, +    @Override, +    public void trace(String format, Object arg) {, +        if (isTraceEnabled()) {, +            log(TRACE_INT, format, arg);, +        }, +    }, +, +    @Override, +    public void trace(String format, Object argA, Object argB) {, +        if (isTraceEnabled()) {, +            log(TRACE_INT, format, argA, argB);, +        }, +    }, +, +    @Override, +    public void trace(String format, Object... argArray) {, +        if (isTraceEnabled()) {, +            log(TRACE_INT, format, argArray);, +        }, +    }, +, +    @Override, +    public void trace(String msg, Throwable t) {, +        if (isTraceEnabled()) {, +            log(TRACE_INT, msg, t);, +        }, +    }, +, +    @Override, +    public boolean isDebugEnabled() {, +        return logger.isDebugEnabled();, +    }, +, +    @Override, +    public void debug(String msg) {, +        if (isDebugEnabled()) {, +            log(DEBUG_INT, msg);, +        }, +    }]