[+++ b/handler/src/main/java/io/netty/handler/logging/LoggingHandler.java, +    private static final String[] HEXDUMP_ROWPREFIXES = new String[65536 >>> 4];, +, +        // Generate the lookup table for the start-offset header in each row (up to 64KiB)., +        for (i = 0; i < HEXDUMP_ROWPREFIXES.length; i ++) {, +            StringBuilder buf = new StringBuilder(12);, +            buf.append(NEWLINE);, +            buf.append(Long.toHexString(i << 4 & 0xFFFFFFFFL | 0x100000000L));, +            buf.setCharAt(buf.length() - 9, '|');, +            buf.append('|');, +            HEXDUMP_ROWPREFIXES[i] = buf.toString();, +        }, +        ctx.fireChannelRegistered();, +        ctx.fireChannelActive();, +        ctx.fireChannelInactive();, +            logger.log(internalLevel, format(ctx, "EXCEPTION", cause), cause);, +        ctx.fireExceptionCaught(cause);, +            logger.log(internalLevel, format(ctx, "USER_EVENT", evt));, +        ctx.fireUserEventTriggered(evt);, +            logger.log(internalLevel, format(ctx, "BIND", localAddress));, +        ctx.bind(localAddress, promise);, +            logger.log(internalLevel, format(ctx, "CONNECT", remoteAddress, localAddress));, +        ctx.connect(remoteAddress, localAddress, promise);, +            logger.log(internalLevel, format(ctx, "DISCONNECT"));, +        ctx.disconnect(promise);, +            logger.log(internalLevel, format(ctx, "CLOSE"));, +        ctx.close(promise);, +            logger.log(internalLevel, format(ctx, "DEREGISTER"));, +        if (logger.isEnabled(internalLevel)) {, +            logger.log(internalLevel, format(ctx, "RECEIVED", msg));, +        }, +        if (logger.isEnabled(internalLevel)) {, +            logger.log(internalLevel, format(ctx, "WRITE", msg));, +        }, +    /**, +     * Formats an event and returns the formatted message., +     *, +     * @param eventName the name of the event, +     */, +    protected String format(ChannelHandlerContext ctx, String eventName) {, +        String chStr = ctx.channel().toString();, +        StringBuilder buf = new StringBuilder(chStr.length() + 1 + eventName.length());, +        buf.append(chStr);, +        buf.append(' ');, +        buf.append(eventName);, +        return buf.toString();, +    /**, +     * Formats an event and returns the formatted message., +     *, +     * @param eventName the name of the event, +     * @param arg       the argument of the event, +     */, +    protected String format(ChannelHandlerContext ctx, String eventName, Object arg) {, +        if (arg instanceof ByteBuf) {, +            return formatByteBuf(ctx, eventName, (ByteBuf) arg);, +        } else if (arg instanceof ByteBufHolder) {, +            return formatByteBufHolder(ctx, eventName, (ByteBufHolder) arg);, +            return formatUserMessage(ctx, eventName, arg);, +     * Formats an event and returns the formatted message., +     *, +     * @param eventName the name of the event, +     * @param firstArg  the first argument of the event, +     * @param secondArg the second argument of the event, +    protected String format(ChannelHandlerContext ctx, String eventName, Object firstArg, Object secondArg) {, +        String chStr = ctx.channel().toString();, +        String arg1Str = String.valueOf(firstArg);, +        if (secondArg == null) {, +            StringBuilder buf = new StringBuilder(chStr.length() + 1 + eventName + 2 + arg1Str.length());, +            buf.append(chStr).append(' ').append(eventName).append(": ").append(arg1Str);, +            return buf.toString();, +        } else {, +            String arg2Str = secondArg.toString();, +            StringBuilder buf = new StringBuilder(, +                    chStr.length() + 1 + eventName + 2 + arg1Str.length() + 2 + arg2Str.length());, +            buf.append(chStr).append(' ').append(eventName).append(": ").append(arg1Str).append(", ").append(arg2Str);, +            return buf.toString();, +        }, +    }, +    /**, +     * Generates the default log message of the specified event whose argument is a {@link ByteBuf}., +     */, +    private static String formatByteBuf(ChannelHandlerContext ctx, String eventName, ByteBuf msg) {, +        String chStr = ctx.channel().toString();, +        int length = msg.readableBytes();, +        if (length == 0) {, +            StringBuilder buf = new StringBuilder(chStr.length() + 1 + eventName.length() + 4);, +            buf.append(chStr).append(' ').append(eventName).append(": 0B");, +            return buf.toString();, +        } else {, +            int rows = length / 16 + (length % 15 == 0? 0 : 1) + 4;, +            StringBuilder buf = new StringBuilder(chStr.length() + 1 + eventName.length() + 2 + 10 + 1 + 2 + rows * 80);, +, +            buf.append(chStr).append(' ').append(eventName).append(": ").append(length).append('B');, +            appendHexDump(buf, msg);, +, +            return buf.toString();, +        }, +    }, +, +    /**]