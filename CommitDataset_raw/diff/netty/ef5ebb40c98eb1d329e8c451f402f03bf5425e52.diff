[+++ b/common/src/main/java/io/netty/util/ResourceLeakDetector.java, +         * properties:, +         *, +         * <ol>, +         * <li>  The current record is always recorded. This is due to the compare and swap dropping the top most, +         *       record, rather than the to-be-pushed record., +         * <li>  The very last access will always be recorded. This comes as a property of 1., +         * <li>  It is possible to retain more records than the target, based upon the probability distribution., +         * <li>  It is easy to keep a precise record of the number of elements in the stack, since each element has to, +         *     know how tall the stack is., +         * </ol>, +         * possible to see what other accesses occur, rather than always dropping them. Second, after, +         * {@link #TARGET_RECORDS} accesses, backoff occurs. This matches typical access patterns,, +                    final int numElements = oldHead.pos + 1;, +                    if (numElements >= TARGET_RECORDS) {, +                        final int backOffFactor = Math.min(numElements - TARGET_RECORDS, 30);, +                        if (dropped = PlatformDependent.threadLocalRandom().nextInt(1 << backOffFactor) != 0) {, +                    } else {, +                        dropped = false;, +                    }, +            Record oldHead = headUpdater.getAndSet(this, null);]