[+++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslEngine.java, +        long capacity = 0;, +        long len = 0;, +        // Number of produced bytes, +        if (capacity > 0) {, +                // TODO: We may want to consider if we move this check and only do it in a less often called place at, +                // the price of not being 100% accurate, like for example when calling SSL.getError(...)., +                    } else {, +                        // We read everything return now., +                        return newResult(bytesConsumed, bytesProduced);, +        } else {, +            // If the capacity of all destination buffers is 0 we need to trigger a SSL_read anyway to ensure, +            // everything is flushed in the BIO pair and so we can detect it in the pendingAppData() call., +            if (SSL.readFromSSL(ssl, EMPTY_ADDR, 0) <= 0) {, +                // We do not check SSL_get_error as we are not interested in any error that is not fatal., +                int err = SSL.getLastErrorNumber();, +                if (OpenSsl.isError(err)) {, +                    shutdownWithError("SSL_read", SSL.getErrorString(err));, +                }, +            }, +        }, +        if (pendingAppData() > 0) {, +            // We filled all buffers but there is still some data pending in the BIO buffer, return BUFFER_OVERFLOW., +            return new SSLEngineResult(, +                    BUFFER_OVERFLOW, mayFinishHandshake(getHandshakeStatus()), bytesConsumed, bytesProduced);, +        // Check to see if we received a close_notify message from the peer., +    private int pendingAppData() {, +        // There won't be any application data until we're done handshaking., +        // We first check handshakeFinished to eliminate the overhead of extra JNI call if possible., +        return handshakeState == HandshakeState.FINISHED ? SSL.pendingReadableBytesInSSL(ssl) : 0;, +    }, +]