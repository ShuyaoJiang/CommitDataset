[+++ b/transport/src/main/java/io/netty/channel/SingleThreadEventExecutor.java, +    protected static void reject() {, +++ b/transport/src/main/java/io/netty/channel/SingleThreadEventExecutor.java, +    protected static void reject() {, +++ b/transport/src/main/java/io/netty/channel/aio/AioCompletionHandler.java, +            } else {, +                // schedule it with a special runnable to make sure we keep the right, +                // order and exist the recursive call to prevent stackoverflow, +                loop.execute(new AioEventLoop.RecursionBreakingRunnable() {, +                    @Override, +                    public void run() {, +                        completed0(result, channel);, +                    }, +                });, +            } else {, +                // schedule it with a special runnable to make sure we keep the right, +                // order and exist the recursive call to prevent stackoverflow, +                loop.execute(new AioEventLoop.RecursionBreakingRunnable() {, +                    @Override, +                    public void run() {, +                        failed0(exc, channel);, +                    }, +                });, +++ b/transport/src/main/java/io/netty/channel/SingleThreadEventExecutor.java, +    protected static void reject() {, +++ b/transport/src/main/java/io/netty/channel/aio/AioCompletionHandler.java, +            } else {, +                // schedule it with a special runnable to make sure we keep the right, +                // order and exist the recursive call to prevent stackoverflow, +                loop.execute(new AioEventLoop.RecursionBreakingRunnable() {, +                    @Override, +                    public void run() {, +                        completed0(result, channel);, +                    }, +                });, +            } else {, +                // schedule it with a special runnable to make sure we keep the right, +                // order and exist the recursive call to prevent stackoverflow, +                loop.execute(new AioEventLoop.RecursionBreakingRunnable() {, +                    @Override, +                    public void run() {, +                        failed0(exc, channel);, +                    }, +                });, +++ b/transport/src/main/java/io/netty/channel/aio/AioEventLoop.java, +import java.util.Queue;, +import java.util.concurrent.LinkedBlockingDeque;, +    private LinkedBlockingDeque<Runnable> taskQueue;, +, +    @Override, +    protected Queue<Runnable> newTaskQueue() {, +        // use a Deque as we need to be able to also add tasks on the first position., +        taskQueue = new LinkedBlockingDeque<Runnable>();, +        return taskQueue;, +    }, +, +    @Override, +    protected void addTask(Runnable task) {, +        if (task instanceof RecursionBreakingRunnable) {, +            if (task == null) {, +                throw new NullPointerException("task");, +            }, +            if (isTerminated()) {, +                reject();, +            }, +            // put the task at the first postion of the queue as we just schedule it to, +            // break the recursive operation, +            taskQueue.addFirst(task);, +        } else {, +            super.addTask(task);, +        }, +    }, +, +    /**, +     * Special Runnable which is used by {@link AioCompletionHandler} to break a recursive call and so prevent, +     * from StackOverFlowError. When a task is executed that implement it needs to put on the first position of, +     * the queue to guaranteer execution order and break the recursive call., +     */, +    interface RecursionBreakingRunnable extends Runnable {, +        // Marker interface, +    }]