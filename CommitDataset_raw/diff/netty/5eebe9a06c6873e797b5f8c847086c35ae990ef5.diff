[+++ b/resolver/src/main/java/io/netty/resolver/RoundRobinInetAddressResolver.java, +import java.util.ArrayList;, +import java.util.Collections;, +import java.util.concurrent.atomic.AtomicInteger;, +    private final AtomicInteger index = new AtomicInteger();, +        nameResolver.resolveAll(inetHost).addListener(new FutureListener<List<InetAddress>>() {, +                    if (numAddresses > 0) {, +                        // if there are multiple addresses: we shall pick one by one, +                        // to support the round robin distribution, +                        promise.setSuccess(inetAddresses.get(index.getAndIncrement() % numAddresses));, +                        promise.setFailure(new UnknownHostException(inetHost));, +    protected void doResolveAll(String inetHost, final Promise<List<InetAddress>> promise) throws Exception {, +        nameResolver.resolveAll(inetHost).addListener(new FutureListener<List<InetAddress>>() {, +            @Override, +            public void operationComplete(Future<List<InetAddress>> future) throws Exception {, +                if (future.isSuccess()) {, +                    List<InetAddress> inetAddresses = future.getNow();, +                    if (!inetAddresses.isEmpty()) {, +                        // create a copy to make sure that it's modifiable random access collection, +                        List<InetAddress> result = new ArrayList<InetAddress>(inetAddresses);, +                        // rotate by different distance each time to force round robin distribution, +                        Collections.rotate(result, index.getAndIncrement());, +                        promise.setSuccess(result);, +                    } else {, +                        promise.setSuccess(inetAddresses);, +                    }, +                } else {, +                    promise.setFailure(future.cause());, +                }, +            }, +        });]