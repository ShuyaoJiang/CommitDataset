[+++ b/transport/src/main/java/io/netty/channel/AbstractChannel.java, +            close(promise, CLOSED_CHANNEL_EXCEPTION, false);, +        }, +, +        private void close(final ChannelPromise promise, final Throwable cause, final boolean notify) {, +            final ChannelOutboundBuffer outboundBuffer = this.outboundBuffer;, +            this.outboundBuffer = null; // Disallow adding any messages and flushes to outboundBuffer., +                                    outboundBuffer.failFlushed(cause, notify);, +                                    outboundBuffer.close(CLOSED_CHANNEL_EXCEPTION);, +                    outboundBuffer.failFlushed(cause, notify);, +                    outboundBuffer.close(CLOSED_CHANNEL_EXCEPTION);, +                if (t instanceof IOException && config().isAutoClose()) {, +                    /**, +                     * Just call {@link #close(ChannelPromise, Throwable, boolean)} here which will take care of, +                     * failing all flushed messages and also ensure the actual close of the underlying transport, +                     * will happen before the promises are notified., +                     *, +                     * This is needed as otherwise {@link #isActive()} , {@link #isOpen()} and {@link #isWritable()}, +                     * may still return {@code true} even if the channel should be closed as result of the exception., +                     */, +                    close(voidPromise(), t, false);, +                } else {, +                    outboundBuffer.failFlushed(t, true);]