[+++ b/src/main/java/org/jboss/netty/handler/stream/ChunkedFile.java, + * Copyright 2009 Red Hat, Inc., +import static org.jboss.netty.buffer.ChannelBuffers.*;, +import java.io.File;, +import java.io.IOException;, +import java.io.RandomAccessFile;, + * @version $Rev$, $Date$, +public class ChunkedFile implements ChunkedInput {, +, +    private final RandomAccessFile file;, +    private final long startOffset;, +    private final long endOffset;, +    private final int chunkSize;, +    private volatile long offset;, +     * Creates a new instance that fetches data from the specified file., +    public ChunkedFile(File file) throws IOException {, +        this(file, ChunkedStream.DEFAULT_CHUNK_SIZE);, +    }, +, +    /**, +     * Creates a new instance that fetches data from the specified file., +     *, +     * @param chunkSize the number of bytes to fetch on each, +     *                  {@link #nextChunk()} call, +     */, +    public ChunkedFile(File file, int chunkSize) throws IOException {, +        this(new RandomAccessFile(file, "r"), chunkSize);, +    }, +, +    /**, +     * Creates a new instance that fetches data from the specified file., +     */, +    public ChunkedFile(RandomAccessFile file) throws IOException {, +        this(file, ChunkedStream.DEFAULT_CHUNK_SIZE);, +    }, +, +    /**, +     * Creates a new instance that fetches data from the specified file., +     *, +     * @param chunkSize the number of bytes to fetch on each, +     *                  {@link #nextChunk()} call, +     */, +    public ChunkedFile(RandomAccessFile file, int chunkSize) throws IOException {, +        this(file, 0, file.length(), chunkSize);, +    }, +, +    /**, +     * Creates a new instance that fetches data from the specified file., +     *, +     * @param offset the offset of the file where the transfer begins, +     * @param length the number of bytes to transfer, +     * @param chunkSize the number of bytes to fetch on each, +     *                  {@link #nextChunk()} call, +     */, +    public ChunkedFile(RandomAccessFile file, long offset, long length, int chunkSize) throws IOException {, +        if (file == null) {, +            throw new NullPointerException("file");, +        }, +        if (offset < 0) {, +            throw new IllegalArgumentException(, +                    "offset: " + offset + " (expected: 0 or greater)");, +        }, +        if (length < 0) {, +            throw new IllegalArgumentException(, +                    "length: " + length + " (expected: 0 or greater)");, +        }, +        if (chunkSize <= 0) {, +            throw new IllegalArgumentException(, +                    "chunkSize: " + chunkSize +, +                    " (expected: a positive integer)");, +        }, +, +        this.file = file;, +        this.offset = startOffset = offset;, +        endOffset = offset + length;, +        this.chunkSize = chunkSize;, +, +        file.seek(offset);, +    }, +    public long getStartOffset() {, +        return startOffset;, +    }, +    public long getEndOffset() {, +        return endOffset;, +    }, +    public long getCurrentOffset() {, +        return offset;, +    }, +, +    public boolean hasNextChunk() throws Exception {, +        return offset < endOffset && file.getChannel().isOpen();, +    }, +, +    public boolean isEndOfInput() throws Exception {, +        return hasNextChunk();, +    }, +, +    public void close() throws Exception {, +        file.close();, +    }]