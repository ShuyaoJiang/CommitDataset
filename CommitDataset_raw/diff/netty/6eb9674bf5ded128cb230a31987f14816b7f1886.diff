[+++ b/common/src/main/java/io/netty/util/Recycler.java, +import io.netty.util.internal.ObjectCleaner;, +        static final class Link extends AtomicInteger {, +            Link next;, +        }, +, +        // This act as a place holder for the head Link but also will be used by the ObjectCleaner, +        // to return space that was before reserved. Its important this does not hold any reference to, +        // either Stack or WeakOrderQueue., +        static final class Head implements Runnable {, +            private final AtomicInteger availableSharedCapacity;, +, +            Link link;, +, +            Head(AtomicInteger availableSharedCapacity) {, +                this.availableSharedCapacity = availableSharedCapacity;, +            }, +, +            @Override, +            public void run() {, +                Link head = link;, +                while (head != null) {, +                    reclaimSpace(LINK_CAPACITY);, +                    head = link.next;, +                }, +            }, +, +            void reclaimSpace(int space) {, +                assert space >= 0;, +                availableSharedCapacity.addAndGet(space);, +            }, +, +            boolean reserveSpace(int space) {, +                return reserveSpace(availableSharedCapacity, space);, +            }, +, +            static boolean reserveSpace(AtomicInteger availableSharedCapacity, int space) {, +                assert space >= 0;, +                for (;;) {, +                    int available = availableSharedCapacity.get();, +                    if (available < space) {, +                        return false;, +                    }, +                    if (availableSharedCapacity.compareAndSet(available, available - space)) {, +                        return true;, +                    }, +                }, +            }, +        private final Head head;, +        private Link tail;, +            head = new Head(null);, +            tail = new Link();, +            head = new Head(stack.availableSharedCapacity);, +            head.link = tail;, +            owner = new WeakReference<Thread>(thread);, +            final WeakOrderQueue queue = new WeakOrderQueue(stack, thread);, +, +            // We need to reclaim all space that was reserved by this WeakOrderQueue so we not run out of space in, +            // the stack. This is needed as we not have a good life-time control over the queue as it is used in a, +            // WeakHashMap which will drop it at any time., +            final Head head = queue.head;, +            ObjectCleaner.register(queue, head);, +, +            return Head.reserveSpace(stack.availableSharedCapacity, LINK_CAPACITY), +                if (!head.reserveSpace(LINK_CAPACITY)) {, +            Link head = this.head.link;, +                this.head.link = head = head.next;, +                    this.head.reclaimSpace(LINK_CAPACITY);, +                    this.head.link = head.next;]