[+++ b/transport/src/main/java/io/netty/channel/AbstractChannel.java, +        /** true if the channel has never been registered, false otherwise */, +        private boolean neverRegistered = true;, +                boolean firstRegistration = neverRegistered;, +                neverRegistered = false;, +                // Only fire a channelActive if the channel has never been registered. This prevents firing, +                // multiple channel actives if the channel is deregistered and re-registered., +                if (firstRegistration && isActive()) {, +++ b/transport/src/main/java/io/netty/channel/AbstractChannel.java, +        /** true if the channel has never been registered, false otherwise */, +        private boolean neverRegistered = true;, +                boolean firstRegistration = neverRegistered;, +                neverRegistered = false;, +                // Only fire a channelActive if the channel has never been registered. This prevents firing, +                // multiple channel actives if the channel is deregistered and re-registered., +                if (firstRegistration && isActive()) {, +++ b/transport/src/test/java/io/netty/channel/AbstractChannelTest.java, +/*, + * Copyright 2014 The Netty Project, +, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, +, + * http://www.apache.org/licenses/LICENSE-2.0, +, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the, + * License for the specific language governing permissions and limitations, + * under the License., + */, +package io.netty.channel;, +, +import static org.easymock.EasyMock.anyObject;, +import static org.easymock.EasyMock.capture;, +import static org.easymock.EasyMock.createMock;, +import static org.easymock.EasyMock.createNiceMock;, +import static org.easymock.EasyMock.expect;, +import static org.easymock.EasyMock.expectLastCall;, +import static org.easymock.EasyMock.replay;, +import static org.easymock.EasyMock.verify;, +, +import java.net.SocketAddress;, +, +import org.easymock.Capture;, +import org.junit.Test;, +, +public class AbstractChannelTest {, +, +    @Test, +    public void ensureInitialRegistrationFiresActive() throws Throwable {, +        EventLoop eventLoop = createNiceMock(EventLoop.class);, +        // This allows us to have a single-threaded test, +        expect(eventLoop.inEventLoop()).andReturn(true).anyTimes();, +, +        TestChannel channel = new TestChannel();, +        ChannelInboundHandler handler = createMock(ChannelInboundHandler.class);, +        handler.handlerAdded(anyObject(ChannelHandlerContext.class)); expectLastCall();, +        Capture<Throwable> throwable = catchHandlerExceptions(handler);, +        handler.channelRegistered(anyObject(ChannelHandlerContext.class));, +        expectLastCall().once();, +        handler.channelActive(anyObject(ChannelHandlerContext.class));, +        expectLastCall().once();, +        replay(handler, eventLoop);, +        channel.pipeline().addLast(handler);, +, +        registerChannel(eventLoop, channel);, +, +        checkForHandlerException(throwable);, +        verify(handler);, +    }, +, +    @Test, +    public void ensureSubsequentRegistrationDoesNotFireActive() throws Throwable {, +            EventLoop eventLoop = createNiceMock(EventLoop.class);, +            // This allows us to have a single-threaded test, +            expect(eventLoop.inEventLoop()).andReturn(true).anyTimes();, +, +            TestChannel channel = new TestChannel();, +            ChannelInboundHandler handler = createMock(ChannelInboundHandler.class);, +            handler.handlerAdded(anyObject(ChannelHandlerContext.class)); expectLastCall();, +            Capture<Throwable> throwable = catchHandlerExceptions(handler);, +            handler.channelRegistered(anyObject(ChannelHandlerContext.class));, +            expectLastCall().times(2); // Should register twice, +            handler.channelActive(anyObject(ChannelHandlerContext.class));, +            expectLastCall().once(); // Should only fire active once, +            replay(handler, eventLoop);, +            channel.pipeline().addLast(handler);, +, +            registerChannel(eventLoop, channel);, +            channel.unsafe().deregister(new DefaultChannelPromise(channel));, +            registerChannel(eventLoop, channel);, +, +            checkForHandlerException(throwable);, +            verify(handler);, +        }, +, +    private void registerChannel(EventLoop eventLoop, Channel channel) throws Exception {, +        DefaultChannelPromise future = new DefaultChannelPromise(channel);]