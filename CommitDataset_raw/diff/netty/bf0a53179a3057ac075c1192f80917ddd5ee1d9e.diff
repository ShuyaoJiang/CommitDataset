[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FrameCodec.java, +    final boolean isWritable(DefaultHttp2FrameStream stream) {, +        Http2Stream s = stream.stream;, +        return s != null && connection().remote().flowController().isWritable(s);, +    }, +, +        volatile Http2Stream stream;, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FrameCodec.java, +    final boolean isWritable(DefaultHttp2FrameStream stream) {, +        Http2Stream s = stream.stream;, +        return s != null && connection().remote().flowController().isWritable(s);, +    }, +, +        volatile Http2Stream stream;, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2MultiplexCodec.java, +        Http2MultiplexCodecStream s = (Http2MultiplexCodecStream) stream;, +, +                if (s.channel != null) {, +                ChannelFuture future = ctx.channel().eventLoop().register(new DefaultHttp2StreamChannel(s, false));, +                DefaultHttp2StreamChannel channel = s.channel;, +    private boolean initialWritability(DefaultHttp2FrameStream stream) {, +        // If the stream id is not valid yet we will just mark the channel as writable as we will be notified, +        // about non-writability state as soon as the first Http2HeaderFrame is written (if needed)., +        // This should be good enough and simplify things a lot., +        return !isStreamIdValid(stream.id()) || isWritable(stream);, +    }, +, +        private final DefaultHttp2FrameStream stream;, +        // We start with the writability of the channel when creating the StreamChannel., +        DefaultHttp2StreamChannel(DefaultHttp2FrameStream stream, boolean outbound) {, +            writable = initialWritability(stream);, +            return writable;, +                    // As we just finished our first write which made the stream-id valid we need to re-evaluate, +                    // the writability of the channel., +                    writabilityChanged(Http2MultiplexCodec.this.isWritable(stream));, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FrameCodec.java, +    final boolean isWritable(DefaultHttp2FrameStream stream) {, +        Http2Stream s = stream.stream;, +        return s != null && connection().remote().flowController().isWritable(s);, +    }, +, +        volatile Http2Stream stream;, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2MultiplexCodec.java, +        Http2MultiplexCodecStream s = (Http2MultiplexCodecStream) stream;, +, +                if (s.channel != null) {, +                ChannelFuture future = ctx.channel().eventLoop().register(new DefaultHttp2StreamChannel(s, false));, +                DefaultHttp2StreamChannel channel = s.channel;, +    private boolean initialWritability(DefaultHttp2FrameStream stream) {, +        // If the stream id is not valid yet we will just mark the channel as writable as we will be notified, +        // about non-writability state as soon as the first Http2HeaderFrame is written (if needed)., +        // This should be good enough and simplify things a lot., +        return !isStreamIdValid(stream.id()) || isWritable(stream);, +    }, +, +        private final DefaultHttp2FrameStream stream;, +        // We start with the writability of the channel when creating the StreamChannel., +        DefaultHttp2StreamChannel(DefaultHttp2FrameStream stream, boolean outbound) {, +            writable = initialWritability(stream);, +            return writable;, +                    // As we just finished our first write which made the stream-id valid we need to re-evaluate, +                    // the writability of the channel., +                    writabilityChanged(Http2MultiplexCodec.this.isWritable(stream));, +++ b/codec-http2/src/test/java/io/netty/handler/codec/http2/Http2MultiplexCodecBuilderTest.java, +import io.netty.channel.ChannelInboundHandlerAdapter;, +                        ch.pipeline().addLast(new Http2MultiplexCodecBuilder(true, new ChannelInitializer<Channel>() {, +, +                            @Override, +                            protected void initChannel(Channel ch) throws Exception {, +                                ch.pipeline().addLast(new ChannelInboundHandlerAdapter() {, +                                    private boolean writable;, +, +                                    @Override, +                                    public void channelActive(ChannelHandlerContext ctx) throws Exception {, +                                        writable |= ctx.channel().isWritable();, +                                        super.channelActive(ctx);, +                                    }, +, +                                    @Override, +                                    public void channelWritabilityChanged(ChannelHandlerContext ctx) throws Exception {, +                                        writable |= ctx.channel().isWritable();, +                                        super.channelWritabilityChanged(ctx);, +                                    }, +, +                                    @Override, +                                    public void channelInactive(ChannelHandlerContext ctx) throws Exception {, +                                        assertTrue(writable);, +                                        super.channelInactive(ctx);, +                                    }, +                                });, +                                ch.pipeline().addLast(serverLastInboundHandler);, +                            }, +                        }).build());, +    public void multipleOutboundStreams() throws Exception {, +, +        serverLastInboundHandler.checkException();, +    public void createOutboundStream() throws Exception {, +, +        serverLastInboundHandler.checkException();, +]