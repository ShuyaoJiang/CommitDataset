[+++ b/handler/src/main/java/io/netty/handler/stream/ChunkedWriteHandler.java, +, +            if (currentWrite.promise.isDone()) {, +                // This might happen e.g. in the case when a write operation, +                // failed, but there're still unconsumed chunks left., +                // Most chunked input sources would stop generating chunks, +                // and report end of input, but this doesn't work with any, +                // source wrapped in HttpChunkedInput., +                // Note, that we're not trying to release the message/chunks, +                // as this had to be done already by someone who resolved the, +                // promise (using ChunkedInput.close method)., +                // See https://github.com/netty/netty/issues/8700., +                this.currentWrite = null;, +                continue;, +            }, +, +                            if (!future.isSuccess()) {, +                                closeInput(chunks);, +                                currentWrite.fail(future.cause());, +                            } else {, +                            }, +++ b/handler/src/main/java/io/netty/handler/stream/ChunkedWriteHandler.java, +, +            if (currentWrite.promise.isDone()) {, +                // This might happen e.g. in the case when a write operation, +                // failed, but there're still unconsumed chunks left., +                // Most chunked input sources would stop generating chunks, +                // and report end of input, but this doesn't work with any, +                // source wrapped in HttpChunkedInput., +                // Note, that we're not trying to release the message/chunks, +                // as this had to be done already by someone who resolved the, +                // promise (using ChunkedInput.close method)., +                // See https://github.com/netty/netty/issues/8700., +                this.currentWrite = null;, +                continue;, +            }, +, +                            if (!future.isSuccess()) {, +                                closeInput(chunks);, +                                currentWrite.fail(future.cause());, +                            } else {, +                            }, +++ b/handler/src/test/java/io/netty/handler/stream/ChunkedWriteHandlerTest.java, +import io.netty.channel.ChannelPromise;, +import io.netty.channel.ChannelOutboundHandlerAdapter;, +import io.netty.util.ReferenceCountUtil;, +import java.util.concurrent.atomic.AtomicInteger;, +import static org.junit.Assert.*;, +        assertTrue(ch.finish());, +    @Test, +    public void testWriteFailureChunkedStream() throws IOException {, +        checkFirstFailed(new ChunkedStream(new ByteArrayInputStream(BYTES)));, +    }, +, +    @Test, +    public void testWriteFailureChunkedNioStream() throws IOException {, +        checkFirstFailed(new ChunkedNioStream(Channels.newChannel(new ByteArrayInputStream(BYTES))));, +    }, +, +    @Test, +    public void testWriteFailureChunkedFile() throws IOException {, +        checkFirstFailed(new ChunkedFile(TMP));, +    }, +, +    @Test, +    public void testWriteFailureChunkedNioFile() throws IOException {, +        checkFirstFailed(new ChunkedNioFile(TMP));, +    }, +, +    @Test, +    public void testWriteFailureUnchunkedData() throws IOException {, +        checkFirstFailed(Unpooled.wrappedBuffer(BYTES));, +    }, +, +    @Test, +    public void testSkipAfterFailedChunkedStream() throws IOException {, +        checkSkipFailed(new ChunkedStream(new ByteArrayInputStream(BYTES)),, +                        new ChunkedStream(new ByteArrayInputStream(BYTES)));, +    }, +, +    @Test, +    public void testSkipAfterFailedChunkedNioStream() throws IOException {, +        checkSkipFailed(new ChunkedNioStream(Channels.newChannel(new ByteArrayInputStream(BYTES))),, +                        new ChunkedNioStream(Channels.newChannel(new ByteArrayInputStream(BYTES))));, +    }, +, +    @Test, +    public void testSkipAfterFailedChunkedFile() throws IOException {, +        checkSkipFailed(new ChunkedFile(TMP), new ChunkedFile(TMP));, +    }, +, +    @Test, +    public void testSkipAfterFailedChunkedNioFile() throws IOException {, +        checkSkipFailed(new ChunkedNioFile(TMP), new ChunkedFile(TMP));, +    }, +, +    // See https://github.com/netty/netty/issues/8700., +    @Test, +    public void testFailureWhenLastChunkFailed() throws IOException {, +        ChannelOutboundHandlerAdapter failLast = new ChannelOutboundHandlerAdapter() {]