[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FrameCodec.java, +import io.netty.util.collection.IntObjectHashMap;, +import io.netty.util.collection.IntObjectMap;, +    private final IntObjectMap<DefaultHttp2FrameStream> frameStreamToInitializeMap =, +            new IntObjectHashMap<DefaultHttp2FrameStream>(8);, +            // Use a Map to store all pending streams as we may have multiple. This is needed as if we would store the, +            // stream in a field directly we may override the stored field before onStreamAdded(...) was called, +            // and so not correctly set the property for the buffered stream., +            //, +            // See https://github.com/netty/netty/issues/8692, +            Object old = frameStreamToInitializeMap.put(streamId, stream);, +            // We should not re-use ids., +            assert old == null;, +, +            // TODO(buchgr): Once Http2FrameStream and Http2Stream are merged this is no longer necessary., +        Http2FrameStream stream2 = newStream().setStreamAndProperty(streamKey, stream);, +            DefaultHttp2FrameStream frameStream = frameStreamToInitializeMap.remove(stream.id());, +, +             if (frameStream != null) {, +                 frameStream.setStreamAndProperty(streamKey, stream);, +            Http2FrameStream stream2 = stream.getProperty(streamKey);, +            Http2FrameStream stream2 = stream.getProperty(streamKey);, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FrameCodec.java, +import io.netty.util.collection.IntObjectHashMap;, +import io.netty.util.collection.IntObjectMap;, +    private final IntObjectMap<DefaultHttp2FrameStream> frameStreamToInitializeMap =, +            new IntObjectHashMap<DefaultHttp2FrameStream>(8);, +            // Use a Map to store all pending streams as we may have multiple. This is needed as if we would store the, +            // stream in a field directly we may override the stored field before onStreamAdded(...) was called, +            // and so not correctly set the property for the buffered stream., +            //, +            // See https://github.com/netty/netty/issues/8692, +            Object old = frameStreamToInitializeMap.put(streamId, stream);, +            // We should not re-use ids., +            assert old == null;, +, +            // TODO(buchgr): Once Http2FrameStream and Http2Stream are merged this is no longer necessary., +        Http2FrameStream stream2 = newStream().setStreamAndProperty(streamKey, stream);, +            DefaultHttp2FrameStream frameStream = frameStreamToInitializeMap.remove(stream.id());, +, +             if (frameStream != null) {, +                 frameStream.setStreamAndProperty(streamKey, stream);, +            Http2FrameStream stream2 = stream.getProperty(streamKey);, +            Http2FrameStream stream2 = stream.getProperty(streamKey);, +++ b/codec-http2/src/test/java/io/netty/handler/codec/http2/Http2FrameCodecTest.java, +    public void multipleNewOutboundStreamsShouldBeBuffered() throws Exception {, +        // We use a limit of 1 and then increase it step by step., +        setUp(Http2FrameCodecBuilder.forServer().encoderEnforceMaxConcurrentStreams(true),, +                new Http2Settings().maxConcurrentStreams(1));, +, +        Http2FrameStream stream1 = frameCodec.newStream();, +        Http2FrameStream stream2 = frameCodec.newStream();, +        Http2FrameStream stream3 = frameCodec.newStream();, +, +        ChannelPromise promise1 = channel.newPromise();, +        ChannelPromise promise2 = channel.newPromise();, +        ChannelPromise promise3 = channel.newPromise();, +, +        channel.writeAndFlush(new DefaultHttp2HeadersFrame(new DefaultHttp2Headers()).stream(stream1), promise1);, +        channel.writeAndFlush(new DefaultHttp2HeadersFrame(new DefaultHttp2Headers()).stream(stream2), promise2);, +        channel.writeAndFlush(new DefaultHttp2HeadersFrame(new DefaultHttp2Headers()).stream(stream3), promise3);, +, +        assertTrue(isStreamIdValid(stream1.id()));, +        channel.runPendingTasks();, +        assertTrue(isStreamIdValid(stream2.id()));, +, +        assertTrue(promise1.syncUninterruptibly().isSuccess());, +        assertFalse(promise2.isDone());, +        assertFalse(promise3.isDone());, +, +        // Increase concurrent streams limit to 2, +        frameInboundWriter.writeInboundSettings(new Http2Settings().maxConcurrentStreams(2));, +        channel.flush();, +, +        // As we increased the limit to 2 we should have also succeed the second frame., +        assertTrue(promise2.syncUninterruptibly().isSuccess());, +        assertFalse(promise3.isDone());, +, +        frameInboundWriter.writeInboundSettings(new Http2Settings().maxConcurrentStreams(3));, +        channel.flush();, +, +        // With the max streams of 3 all streams should be succeed now., +        assertTrue(promise3.syncUninterruptibly().isSuccess());, +, +        assertFalse(channel.finishAndReleaseAll());, +    }, +, +    @Test]