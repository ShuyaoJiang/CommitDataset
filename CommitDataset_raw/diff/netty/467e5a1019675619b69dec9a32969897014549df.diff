[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2ConnectionDecoder.java, +                            logger.info("%s ignoring PRIORITY frame for stream %d. Stream doesn't exist but may " +, +                        logger.info("%s ignoring PRIORITY frame for stream %d. Stream created after GOAWAY sent. " +, +                throw connectionError(PROTOCOL_ERROR, "Stream %d does not exist", streamId);, +                        logger.info("%s ignoring %s frame for stream %d. Stream sent after GOAWAY sent",, +                throw streamError(streamId, STREAM_CLOSED, "Received %s frame for an unknown stream %d",, +                                  frameName, streamId);, +                    logger.info("%s ignoring %s frame for stream %d. %s", ctx.channel(), frameName,, +                throw connectionError(PROTOCOL_ERROR, "Stream %d does not exist", streamId);, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2ConnectionDecoder.java, +                            logger.info("%s ignoring PRIORITY frame for stream %d. Stream doesn't exist but may " +, +                        logger.info("%s ignoring PRIORITY frame for stream %d. Stream created after GOAWAY sent. " +, +                throw connectionError(PROTOCOL_ERROR, "Stream %d does not exist", streamId);, +                        logger.info("%s ignoring %s frame for stream %d. Stream sent after GOAWAY sent",, +                throw streamError(streamId, STREAM_CLOSED, "Received %s frame for an unknown stream %d",, +                                  frameName, streamId);, +                    logger.info("%s ignoring %s frame for stream %d. %s", ctx.channel(), frameName,, +                throw connectionError(PROTOCOL_ERROR, "Stream %d does not exist", streamId);, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2FrameReader.java, +import io.netty.util.internal.PlatformDependent;, +    /**, +     * {@code true} = reading headers, {@code false} = reading payload., +     */, +    private boolean readingHeaders = true;, +    /**, +     * Once set to {@code true} the value will never change. This is set to {@code true} if an unrecoverable error which, +     * renders the connection unusable., +     */, +    private boolean readError;, +        if (readError) {, +            input.skipBytes(input.readableBytes());, +            return;, +        }, +            do {, +                if (readingHeaders) {, +                    if (readingHeaders) {, +                }, +                if (!readingHeaders) {, +            } while (input.isReadable());, +            readError = !Http2Exception.isStreamError(e);, +            readError = true;, +        } catch (Throwable cause) {, +            readError = true;, +            PlatformDependent.throwException(cause);, +        // We have consumed the data, next time we read we will be expecting to read the frame payload., +        readingHeaders = false;, +, +        // We have consumed the data, next time we read we will be expecting to read a frame header., +        readingHeaders = true;, +, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2ConnectionDecoder.java, +                            logger.info("%s ignoring PRIORITY frame for stream %d. Stream doesn't exist but may " +, +                        logger.info("%s ignoring PRIORITY frame for stream %d. Stream created after GOAWAY sent. " +, +                throw connectionError(PROTOCOL_ERROR, "Stream %d does not exist", streamId);, +                        logger.info("%s ignoring %s frame for stream %d. Stream sent after GOAWAY sent",, +                throw streamError(streamId, STREAM_CLOSED, "Received %s frame for an unknown stream %d",, +                                  frameName, streamId);, +                    logger.info("%s ignoring %s frame for stream %d. %s", ctx.channel(), frameName,, +                throw connectionError(PROTOCOL_ERROR, "Stream %d does not exist", streamId);, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2FrameReader.java, +import io.netty.util.internal.PlatformDependent;, +    /**, +     * {@code true} = reading headers, {@code false} = reading payload., +     */, +    private boolean readingHeaders = true;, +    /**, +     * Once set to {@code true} the value will never change. This is set to {@code true} if an unrecoverable error which, +     * renders the connection unusable., +     */, +    private boolean readError;, +        if (readError) {, +            input.skipBytes(input.readableBytes());, +            return;, +        }, +            do {, +                if (readingHeaders) {, +                    if (readingHeaders) {, +                }, +                if (!readingHeaders) {, +            } while (input.isReadable());, +            readError = !Http2Exception.isStreamError(e);, +            readError = true;, +        } catch (Throwable cause) {, +            readError = true;, +            PlatformDependent.throwException(cause);, +        // We have consumed the data, next time we read we will be expecting to read the frame payload., +        readingHeaders = false;, +, +        // We have consumed the data, next time we read we will be expecting to read a frame header., +        readingHeaders = true;, +, +++ b/codec-http2/src/test/java/io/netty/handler/codec/http2/Http2ConnectionRoundtripTest.java, +import java.util.concurrent.TimeUnit;, +import java.util.concurrent.atomic.AtomicReference;, +import static org.mockito.Matchers.anyShort;, +    private Http2ConnectionHandler http2Server;, +    public void inflightFrameAfterStreamResetShouldNotMakeConnectionUnsuable() throws Exception {, +        bootstrapEnv(1, 1, 2, 1);, +        final CountDownLatch latch = new CountDownLatch(1);, +        doAnswer(new Answer<Void>() {]