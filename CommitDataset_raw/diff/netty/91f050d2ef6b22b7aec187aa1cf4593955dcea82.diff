[+++ b/handler/src/main/java/io/netty/handler/ssl/ReferenceCountedOpenSslEngine.java, +    static final int MAX_PLAINTEXT_LENGTH = 16 * 1024; // 2^14, +    /**, +     * This is the maximum overhead when encrypting plaintext as defined by, +     * <a href="https://www.ietf.org/rfc/rfc5246.txt">rfc5264</a>,, +     * <a href="https://www.ietf.org/rfc/rfc5289.txt">rfc5289</a> and openssl implementation itself., +     *, +     * Please note that we use a padding of 16 here as openssl uses PKC#5 which uses 16 bytes while the spec itself, +     * allow up to 255 bytes. 16 bytes is the max for PKC#5 (which handles it the same way as PKC#7) as we use a block, +     * size of 16. See <a href="https://tools.ietf.org/html/rfc5652#section-6.3">rfc5652#section-6.3</a>., +     *, +     * 16 (IV) + 48 (MAC) + 1 (Padding_length field) + 15 (Padding) + 1 (ContentType) + 2 (ProtocolVersion) + 2 (Length), +     *, +     * TODO: We may need to review this calculation once TLS 1.3 becomes available., +     */, +    static final int MAX_ENCRYPTION_OVERHEAD_LENGTH = 15 + 48 + 1 + 16 + 1 + 2 + 2;, +    static final int MAX_ENCRYPTED_PACKET_LENGTH = MAX_PLAINTEXT_LENGTH + MAX_ENCRYPTION_OVERHEAD_LENGTH;, +++ b/handler/src/main/java/io/netty/handler/ssl/ReferenceCountedOpenSslEngine.java, +    static final int MAX_PLAINTEXT_LENGTH = 16 * 1024; // 2^14, +    /**, +     * This is the maximum overhead when encrypting plaintext as defined by, +     * <a href="https://www.ietf.org/rfc/rfc5246.txt">rfc5264</a>,, +     * <a href="https://www.ietf.org/rfc/rfc5289.txt">rfc5289</a> and openssl implementation itself., +     *, +     * Please note that we use a padding of 16 here as openssl uses PKC#5 which uses 16 bytes while the spec itself, +     * allow up to 255 bytes. 16 bytes is the max for PKC#5 (which handles it the same way as PKC#7) as we use a block, +     * size of 16. See <a href="https://tools.ietf.org/html/rfc5652#section-6.3">rfc5652#section-6.3</a>., +     *, +     * 16 (IV) + 48 (MAC) + 1 (Padding_length field) + 15 (Padding) + 1 (ContentType) + 2 (ProtocolVersion) + 2 (Length), +     *, +     * TODO: We may need to review this calculation once TLS 1.3 becomes available., +     */, +    static final int MAX_ENCRYPTION_OVERHEAD_LENGTH = 15 + 48 + 1 + 16 + 1 + 2 + 2;, +    static final int MAX_ENCRYPTED_PACKET_LENGTH = MAX_PLAINTEXT_LENGTH + MAX_ENCRYPTION_OVERHEAD_LENGTH;, +++ b/handler/src/main/java/io/netty/handler/ssl/SslHandler.java, +                    // As this is called for the handshake we have no real idea how big the buffer needs to be., +                    // That said 2048 should give us enough room to include everything like ALPN / NPN data., +                    // If this is not enough we will increase the buffer in wrap(...)., +                    out = allocateOutNetBuf(ctx, 2048);, +++ b/handler/src/main/java/io/netty/handler/ssl/ReferenceCountedOpenSslEngine.java, +    static final int MAX_PLAINTEXT_LENGTH = 16 * 1024; // 2^14, +    /**, +     * This is the maximum overhead when encrypting plaintext as defined by, +     * <a href="https://www.ietf.org/rfc/rfc5246.txt">rfc5264</a>,, +     * <a href="https://www.ietf.org/rfc/rfc5289.txt">rfc5289</a> and openssl implementation itself., +     *, +     * Please note that we use a padding of 16 here as openssl uses PKC#5 which uses 16 bytes while the spec itself, +     * allow up to 255 bytes. 16 bytes is the max for PKC#5 (which handles it the same way as PKC#7) as we use a block, +     * size of 16. See <a href="https://tools.ietf.org/html/rfc5652#section-6.3">rfc5652#section-6.3</a>., +     *, +     * 16 (IV) + 48 (MAC) + 1 (Padding_length field) + 15 (Padding) + 1 (ContentType) + 2 (ProtocolVersion) + 2 (Length), +     *, +     * TODO: We may need to review this calculation once TLS 1.3 becomes available., +     */, +    static final int MAX_ENCRYPTION_OVERHEAD_LENGTH = 15 + 48 + 1 + 16 + 1 + 2 + 2;, +    static final int MAX_ENCRYPTED_PACKET_LENGTH = MAX_PLAINTEXT_LENGTH + MAX_ENCRYPTION_OVERHEAD_LENGTH;, +++ b/handler/src/main/java/io/netty/handler/ssl/SslHandler.java, +                    // As this is called for the handshake we have no real idea how big the buffer needs to be., +                    // That said 2048 should give us enough room to include everything like ALPN / NPN data., +                    // If this is not enough we will increase the buffer in wrap(...)., +                    out = allocateOutNetBuf(ctx, 2048);, +++ b/handler/src/test/java/io/netty/handler/ssl/OpenSslEngineTest.java, +import java.util.Arrays;, +import java.util.HashSet;, +import java.util.Set;, +import javax.net.ssl.SSLException;, +import static org.junit.Assert.assertFalse;, +    private static final Set<String> TLS_V1_1_CIPHERS = new HashSet<String>(Arrays.asList(, +            "ECDHE-RSA-AES256-SHA",, +            "DHE-RSA-AES256-SHA",, +            "DHE-RSA-CAMELLIA256-SHA",, +            "AECDH-AES256-SHA",, +            "ADH-AES256-SHA",, +            "ADH-CAMELLIA256-SHA",, +            "AES256-SHA",, +            "CAMELLIA256-SHA",, +            "ECDHE-RSA-AES128-SHA",, +            "DHE-RSA-AES128-SHA",, +            "DHE-RSA-SEED-SHA",, +            "DHE-RSA-CAMELLIA128-SHA",, +            "AECDH-AES128-SHA",, +            "ADH-AES128-SHA",, +            "ADH-SEED-SHA",, +            "ADH-CAMELLIA128-SHA",, +            "AES128-SHA",, +            "SEED-SHA",, +            "CAMELLIA128-SHA",, +            "IDEA-CBC-SHA",, +            "ECDHE-RSA-RC4-SHA",, +            "AECDH-RC4-SHA",, +            "ADH-RC4-MD5",, +            "RC4-SHA",, +            "RC4-MD5",, +            "ECDHE-RSA-DES-CBC3-SHA",, +            "EDH-RSA-DES-CBC3-SHA",, +            "AECDH-DES-CBC3-SHA",, +            "ADH-DES-CBC3-SHA",, +            "DES-CBC3-SHA", +    ));, +]