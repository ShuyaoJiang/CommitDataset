[+++ b/src/main/java/org/jboss/netty/channel/socket/http/AcceptedServerChannelPipelineFactory.java, +class AcceptedServerChannelPipelineFactory implements ChannelPipelineFactory {, +    public AcceptedServerChannelPipelineFactory(, +            ServerMessageSwitch messageSwitch) {, +    public ChannelPipeline getPipeline() throws Exception {, +        pipeline.addLast("httpChunkAggregator", new HttpChunkAggregator(, +                HttpTunnelMessageUtils.MAX_BODY_SIZE));, +        pipeline.addLast("messageSwitchClient",, +                new AcceptedServerChannelRequestDispatch(messageSwitch));, +++ b/src/main/java/org/jboss/netty/channel/socket/http/AcceptedServerChannelPipelineFactory.java, +class AcceptedServerChannelPipelineFactory implements ChannelPipelineFactory {, +    public AcceptedServerChannelPipelineFactory(, +            ServerMessageSwitch messageSwitch) {, +    public ChannelPipeline getPipeline() throws Exception {, +        pipeline.addLast("httpChunkAggregator", new HttpChunkAggregator(, +                HttpTunnelMessageUtils.MAX_BODY_SIZE));, +        pipeline.addLast("messageSwitchClient",, +                new AcceptedServerChannelRequestDispatch(messageSwitch));, +++ b/src/main/java/org/jboss/netty/channel/socket/http/AcceptedServerChannelRequestDispatch.java, +class AcceptedServerChannelRequestDispatch extends SimpleChannelUpstreamHandler {, +    public AcceptedServerChannelRequestDispatch(, +            ServerMessageSwitchUpstreamInterface messageSwitch) {, +    public void messageReceived(ChannelHandlerContext ctx, MessageEvent e), +            throws Exception {, +        if (HttpTunnelMessageUtils.isOpenTunnelRequest(request)) {, +        } else if (HttpTunnelMessageUtils.isSendDataRequest(request)) {, +        } else if (HttpTunnelMessageUtils.isReceiveDataRequest(request)) {, +        } else if (HttpTunnelMessageUtils.isCloseTunnelRequest(request)) {, +        } else {, +            respondWithRejection(ctx, request,, +                    "invalid request to netty HTTP tunnel gateway");, +    private void handleOpenTunnel(ChannelHandlerContext ctx) {, +        String tunnelId =, +                messageSwitch.createTunnel((InetSocketAddress) ctx.getChannel(), +                        .getRemoteAddress());, +        if (LOG.isDebugEnabled()) {, +            LOG.debug("open tunnel request received from " +, +                    ctx.getChannel().getRemoteAddress() + " - allocated ID " +, +                    tunnelId);, +        respondWith(ctx,, +                HttpTunnelMessageUtils.createTunnelOpenResponse(tunnelId));, +    private void handleCloseTunnel(ChannelHandlerContext ctx,, +            HttpRequest request) {, +        if (tunnelId == null) {, +        if (LOG.isDebugEnabled()) {, +        respondWith(ctx, HttpTunnelMessageUtils.createTunnelCloseResponse()), +                .addListener(ChannelFutureListener.CLOSE);, +    private void handleSendData(ChannelHandlerContext ctx, HttpRequest request) {, +        if (tunnelId == null) {, +        if (LOG.isDebugEnabled()) {, +        if (HttpHeaders.getContentLength(request) == 0 ||, +                request.getContent() == null ||, +                request.getContent().readableBytes() == 0) {, +            respondWithRejection(ctx, request,, +                    "Send data requests must contain data");, +    private void handleReceiveData(ChannelHandlerContext ctx,, +            HttpRequest request) {, +        if (tunnelId == null) {, +        if (LOG.isDebugEnabled()) {, +    private String checkTunnelId(HttpRequest request, ChannelHandlerContext ctx) {, +        if (tunnelId == null) {, +            respondWithRejection(ctx, request,, +                    "no tunnel id specified in request");, +        } else if (!messageSwitch.isOpenTunnel(tunnelId)) {, +            respondWithRejection(ctx, request,, +                    "specified tunnel is either closed or does not exist");, +    private ChannelFuture respondWith(ChannelHandlerContext ctx,, +            HttpResponse response) {, +    private void respondWithRejection(ChannelHandlerContext ctx,, +            HttpRequest rejectedRequest, String errorMessage) {, +        if (LOG.isWarnEnabled()) {, +            String tunnelId =, +                    HttpTunnelMessageUtils.extractTunnelId(rejectedRequest);, +            if (tunnelId == null) {, +            LOG.warn("Rejecting request from " + remoteAddress +, +                    " representing tunnel " + tunnelId + ": " + errorMessage);, +        HttpResponse rejection =, +                HttpTunnelMessageUtils.createRejection(rejectedRequest,, +                        errorMessage);, +++ b/src/main/java/org/jboss/netty/channel/socket/http/AcceptedServerChannelPipelineFactory.java, +class AcceptedServerChannelPipelineFactory implements ChannelPipelineFactory {, +    public AcceptedServerChannelPipelineFactory(, +            ServerMessageSwitch messageSwitch) {, +    public ChannelPipeline getPipeline() throws Exception {, +        pipeline.addLast("httpChunkAggregator", new HttpChunkAggregator(, +                HttpTunnelMessageUtils.MAX_BODY_SIZE));, +        pipeline.addLast("messageSwitchClient",, +                new AcceptedServerChannelRequestDispatch(messageSwitch));, +++ b/src/main/java/org/jboss/netty/channel/socket/http/AcceptedServerChannelRequestDispatch.java, +class AcceptedServerChannelRequestDispatch extends SimpleChannelUpstreamHandler {, +    public AcceptedServerChannelRequestDispatch(, +            ServerMessageSwitchUpstreamInterface messageSwitch) {, +    public void messageReceived(ChannelHandlerContext ctx, MessageEvent e), +            throws Exception {, +        if (HttpTunnelMessageUtils.isOpenTunnelRequest(request)) {, +        } else if (HttpTunnelMessageUtils.isSendDataRequest(request)) {, +        } else if (HttpTunnelMessageUtils.isReceiveDataRequest(request)) {, +        } else if (HttpTunnelMessageUtils.isCloseTunnelRequest(request)) {, +        } else {, +            respondWithRejection(ctx, request,]