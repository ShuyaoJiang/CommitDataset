[+++ b/transport/src/main/java/io/netty/channel/local/LocalChannel.java, +    final Queue<Object> inboundBuffer = PlatformDependent.newSpscQueue();, +        State oldState = state;, +        try {, +            if (oldState != State.CLOSED) {, +                // to make sure its run after the registration completes, +                // (see https://github.com/netty/netty/issues/2144)., +                            // inboundBuffers is a SPSC so we may leak if the event loop is shutdown prematurely or, +                            // rejects the close Runnable but give a best effort., +        } finally {, +            // Release all buffers if the Channel was already registered in the past and if it was not closed before., +            if (oldState != null && oldState != State.CLOSED) {, +                // We need to release all the buffers that may be put into our inbound queue since we closed the Channel, +                // to ensure we not leak any memory. This is fine as it basically gives the same guarantees as TCP which, +                // means even if the promise was notified before its not really guaranteed that the "remote peer" will, +                // see the buffer at all., +                releaseInboundBuffers();, +            }, +        }, +++ b/transport/src/main/java/io/netty/channel/local/LocalChannel.java, +    final Queue<Object> inboundBuffer = PlatformDependent.newSpscQueue();, +        State oldState = state;, +        try {, +            if (oldState != State.CLOSED) {, +                // to make sure its run after the registration completes, +                // (see https://github.com/netty/netty/issues/2144)., +                            // inboundBuffers is a SPSC so we may leak if the event loop is shutdown prematurely or, +                            // rejects the close Runnable but give a best effort., +        } finally {, +            // Release all buffers if the Channel was already registered in the past and if it was not closed before., +            if (oldState != null && oldState != State.CLOSED) {, +                // We need to release all the buffers that may be put into our inbound queue since we closed the Channel, +                // to ensure we not leak any memory. This is fine as it basically gives the same guarantees as TCP which, +                // means even if the promise was notified before its not really guaranteed that the "remote peer" will, +                // see the buffer at all., +                releaseInboundBuffers();, +            }, +        }, +++ b/transport/src/test/java/io/netty/channel/local/LocalChannelTest.java, +, +    @Test, +    public void testNotLeakBuffersWhenCloseByRemotePeer() throws Exception {, +        Bootstrap cb = new Bootstrap();, +        ServerBootstrap sb = new ServerBootstrap();, +, +        cb.group(sharedGroup), +                .channel(LocalChannel.class), +                .handler(new SimpleChannelInboundHandler<ByteBuf>() {, +                    @Override, +                    public void channelActive(final ChannelHandlerContext ctx) throws Exception {, +                        ctx.writeAndFlush(ctx.alloc().buffer().writeZero(100));, +                    }, +, +                    @Override, +                    public void channelRead0(ChannelHandlerContext ctx, ByteBuf buffer) throws Exception {, +                        // Just drop the buffer, +                    }, +                });, +, +        sb.group(sharedGroup), +                .channel(LocalServerChannel.class), +                .childHandler(new ChannelInitializer<LocalChannel>() {, +                    @Override, +                    public void initChannel(LocalChannel ch) throws Exception {, +                        ch.pipeline().addLast(new SimpleChannelInboundHandler<ByteBuf>() {, +, +                            @Override, +                            public void channelRead0(ChannelHandlerContext ctx, ByteBuf buffer) throws Exception {, +                                while (buffer.isReadable()) {, +                                    // Fill the ChannelOutboundBuffer with multiple buffers, +                                    ctx.write(buffer.readRetainedSlice(1));, +                                }, +                                // Flush and so transfer the written buffers to the inboundBuffer of the remote peer., +                                // After this point the remote peer is responsible to release all the buffers., +                                ctx.flush();, +                                // This close call will trigger the remote peer close as well., +                                ctx.close();, +                            }, +                        });, +                    }, +                });, +, +        Channel sc = null;, +        LocalChannel cc = null;, +        try {, +            // Start server, +            sc = sb.bind(TEST_ADDRESS).sync().channel();, +, +            // Connect to the server, +            cc = (LocalChannel) cb.connect(sc.localAddress()).sync().channel();, +, +            // Close the channel, +            closeChannel(cc);, +            assertTrue(cc.inboundBuffer.isEmpty());, +            closeChannel(sc);, +        } finally {, +            closeChannel(cc);, +            closeChannel(sc);, +        }, +    }]