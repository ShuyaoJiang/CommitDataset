[+++ b/buffer/src/main/java/io/netty/buffer/PooledUnsafeDirectByteBuf.java, +        return new UnsafeDirectSwappedByteBuf(this);, +++ b/buffer/src/main/java/io/netty/buffer/PooledUnsafeDirectByteBuf.java, +        return new UnsafeDirectSwappedByteBuf(this);, +++ b/buffer/src/main/java/io/netty/buffer/UnpooledUnsafeDirectByteBuf.java, +        return new UnsafeDirectSwappedByteBuf(this);, +++ b/buffer/src/main/java/io/netty/buffer/PooledUnsafeDirectByteBuf.java, +        return new UnsafeDirectSwappedByteBuf(this);, +++ b/buffer/src/main/java/io/netty/buffer/UnpooledUnsafeDirectByteBuf.java, +        return new UnsafeDirectSwappedByteBuf(this);, +++ b/buffer/src/main/java/io/netty/buffer/UnsafeDirectSwappedByteBuf.java, +    UnsafeDirectSwappedByteBuf(AbstractByteBuf buf) {, +        // We need to call wrapped.memoryAddress() everytime and NOT cache it as it may change if the buffer expand., +        // See:, +        // - https://github.com/netty/netty/issues/2587, +        // - https://github.com/netty/netty/issues/2580, +        return wrapped.memoryAddress() + index;, +++ b/buffer/src/main/java/io/netty/buffer/PooledUnsafeDirectByteBuf.java, +        return new UnsafeDirectSwappedByteBuf(this);, +++ b/buffer/src/main/java/io/netty/buffer/UnpooledUnsafeDirectByteBuf.java, +        return new UnsafeDirectSwappedByteBuf(this);, +++ b/buffer/src/main/java/io/netty/buffer/UnsafeDirectSwappedByteBuf.java, +    UnsafeDirectSwappedByteBuf(AbstractByteBuf buf) {, +        // We need to call wrapped.memoryAddress() everytime and NOT cache it as it may change if the buffer expand., +        // See:, +        // - https://github.com/netty/netty/issues/2587, +        // - https://github.com/netty/netty/issues/2580, +        return wrapped.memoryAddress() + index;, +++ b/buffer/src/test/java/io/netty/buffer/AbstractByteBufTest.java, +    // See:, +    // - https://github.com/netty/netty/issues/2587, +    // - https://github.com/netty/netty/issues/2580, +    @Test, +    public void testLittleEndianWithExpand() {, +        ByteBuf buffer = releaseLater(newBuffer(0)).order(LITTLE_ENDIAN);, +        System.out.println(buffer.getClass());, +        buffer.writeInt(0x12345678);, +        System.out.println(ByteBufUtil.hexDump(buffer));, +        assertEquals("78563412", ByteBufUtil.hexDump(buffer));, +    }, +, +++ b/buffer/src/main/java/io/netty/buffer/PooledUnsafeDirectByteBuf.java, +        return new UnsafeDirectSwappedByteBuf(this);, +++ b/buffer/src/main/java/io/netty/buffer/UnpooledUnsafeDirectByteBuf.java, +        return new UnsafeDirectSwappedByteBuf(this);, +++ b/buffer/src/main/java/io/netty/buffer/UnsafeDirectSwappedByteBuf.java, +    UnsafeDirectSwappedByteBuf(AbstractByteBuf buf) {, +        // We need to call wrapped.memoryAddress() everytime and NOT cache it as it may change if the buffer expand., +        // See:, +        // - https://github.com/netty/netty/issues/2587, +        // - https://github.com/netty/netty/issues/2580, +        return wrapped.memoryAddress() + index;, +++ b/buffer/src/test/java/io/netty/buffer/AbstractByteBufTest.java, +    // See:, +    // - https://github.com/netty/netty/issues/2587, +    // - https://github.com/netty/netty/issues/2580, +    @Test, +    public void testLittleEndianWithExpand() {, +        ByteBuf buffer = releaseLater(newBuffer(0)).order(LITTLE_ENDIAN);, +        System.out.println(buffer.getClass());, +        buffer.writeInt(0x12345678);, +        System.out.println(ByteBufUtil.hexDump(buffer));, +        assertEquals("78563412", ByteBufUtil.hexDump(buffer));, +    }, +, +++ b/buffer/src/test/java/io/netty/buffer/SlicedByteBufTest.java, +import static io.netty.buffer.Unpooled.LITTLE_ENDIAN;, +import static io.netty.util.ReferenceCountUtil.releaseLater;, +, +    @Test, +    @Override, +    public void testLittleEndianWithExpand() {, +       // ignore for SlicedByteBuf, +    }]