[+++ b/src/main/java/org/jboss/netty/handler/codec/http/HttpRequestDecoder.java, +                HttpVersion.valueOf(split[2]), HttpMethod.valueOf(split[0]), split[1]);, +++ b/src/main/java/org/jboss/netty/handler/codec/http/HttpRequestDecoder.java, +                HttpVersion.valueOf(split[2]), HttpMethod.valueOf(split[0]), split[1]);, +++ b/src/main/java/org/jboss/netty/handler/codec/http/HttpRequestEncoder.java, +        buf.writeBytes(request.getProtocolVersion().toString().getBytes());, +++ b/src/main/java/org/jboss/netty/handler/codec/http/HttpRequestDecoder.java, +                HttpVersion.valueOf(split[2]), HttpMethod.valueOf(split[0]), split[1]);, +++ b/src/main/java/org/jboss/netty/handler/codec/http/HttpRequestEncoder.java, +        buf.writeBytes(request.getProtocolVersion().toString().getBytes());, +++ b/src/main/java/org/jboss/netty/handler/codec/http/HttpResponseDecoder.java, +        message = new DefaultHttpResponse(HttpVersion.valueOf(split[0]), new HttpResponseStatus(Integer.valueOf(split[1]), split[2]));, +++ b/src/main/java/org/jboss/netty/handler/codec/http/HttpRequestDecoder.java, +                HttpVersion.valueOf(split[2]), HttpMethod.valueOf(split[0]), split[1]);, +++ b/src/main/java/org/jboss/netty/handler/codec/http/HttpRequestEncoder.java, +        buf.writeBytes(request.getProtocolVersion().toString().getBytes());, +++ b/src/main/java/org/jboss/netty/handler/codec/http/HttpResponseDecoder.java, +        message = new DefaultHttpResponse(HttpVersion.valueOf(split[0]), new HttpResponseStatus(Integer.valueOf(split[1]), split[2]));, +++ b/src/main/java/org/jboss/netty/handler/codec/http/HttpResponseEncoder.java, +        buf.writeBytes(response.getProtocolVersion().toString().getBytes());, +++ b/src/main/java/org/jboss/netty/handler/codec/http/HttpRequestDecoder.java, +                HttpVersion.valueOf(split[2]), HttpMethod.valueOf(split[0]), split[1]);, +++ b/src/main/java/org/jboss/netty/handler/codec/http/HttpRequestEncoder.java, +        buf.writeBytes(request.getProtocolVersion().toString().getBytes());, +++ b/src/main/java/org/jboss/netty/handler/codec/http/HttpResponseDecoder.java, +        message = new DefaultHttpResponse(HttpVersion.valueOf(split[0]), new HttpResponseStatus(Integer.valueOf(split[1]), split[2]));, +++ b/src/main/java/org/jboss/netty/handler/codec/http/HttpResponseEncoder.java, +        buf.writeBytes(response.getProtocolVersion().toString().getBytes());, +++ b/src/main/java/org/jboss/netty/handler/codec/http/HttpVersion.java, +public class HttpVersion implements Comparable<HttpVersion> {, +    public static final HttpVersion HTTP_1_0 = new HttpVersion("HTTP", 1, 0);, +    public static final HttpVersion HTTP_1_1 = new HttpVersion("HTTP", 1, 1);, +    private static final java.util.regex.Pattern VERSION_PATTERN =, +            java.util.regex.Pattern.compile("(\\S+)/(\\d+)\\.(\\d+)");, +    public static HttpVersion valueOf(String value) {, +        value = value.toUpperCase();, +        if (value.equals("HTTP/1.1")) {, +        if (value.equals("HTTP/1.0")) {, +            return HTTP_1_0;, +        return new HttpVersion(value);, +    }, +, +    private final String protocolName;, +    private final int majorVersion;, +    private final int minorVersion;, +    private final String string;, +, +    public HttpVersion(String value) {, +        if (value == null) {, +            throw new NullPointerException("value");, +        }, +, +        java.util.regex.Matcher m = VERSION_PATTERN.matcher(value);, +        if (!m.matches()) {, +            throw new IllegalArgumentException("invalid version format: " + value);, +        }, +, +        this.protocolName = m.group(1);, +        this.majorVersion = Integer.parseInt(m.group(2));, +        this.minorVersion = Integer.parseInt(m.group(3));, +        this.string = protocolName + '/' + majorVersion + '.' + minorVersion;, +    }, +, +    public HttpVersion(, +            String protocolName, int majorVersion, int minorVersion) {, +        if (protocolName == null) {, +            throw new NullPointerException("protocolName");, +        }, +, +        protocolName = protocolName.trim().toUpperCase();, +        if (protocolName.length() == 0) {, +            throw new IllegalArgumentException("empty protocolName");, +        }, +, +        for (int i = 0; i < protocolName.length(); i ++) {, +            if (Character.isWhitespace(protocolName.charAt(i))) {, +                throw new IllegalArgumentException("whitespace in protocolName");, +            }, +        }, +, +        if (majorVersion < 0) {, +            throw new IllegalArgumentException("negative majorVersion");, +        }, +        if (minorVersion < 0) {, +            throw new IllegalArgumentException("negative minorVersion");, +        }, +, +        this.protocolName = protocolName;, +        this.majorVersion = majorVersion;, +        this.minorVersion = minorVersion;, +        this.string = protocolName + '/' + majorVersion + '.' + minorVersion;, +    }, +, +    public String getProtocolName() {, +        return protocolName;, +    }, +, +    public int getMajorVersion() {, +        return majorVersion;, +    }]