[+++ b/transport/src/main/java/io/netty/channel/AbstractChannel.java, +import java.util.ArrayDeque;, +import java.util.Deque;, +    private final Deque<FlushCheckpoint> flushCheckpoints = new ArrayDeque<FlushCheckpoint>();, +                if (buf.hasMessageBuffer()) {, +                    Queue<Object> msgBuf = buf.messageBuffer();, +                        int localReadAmount = doRead(msgBuf);, +                } else {, +                    ChannelBuffer byteBuf = buf.byteBuffer();, +                    for (;;) {, +                        int localReadAmount = doRead(byteBuf);, +                        if (localReadAmount > 0) {, +                            read = true;, +                        } else if (localReadAmount < 0) {, +                            closed = true;, +                            break;, +                        }, +                        if (!expandReadBuffer(byteBuf)) {, +                            break;, +                        }, +                    }, +                }, +                    long checkpoint = flushedAmount + out().size();, +                    if (future instanceof FlushCheckpoint) {, +                        FlushCheckpoint cp = (FlushCheckpoint) future;, +                        cp.flushCheckpoint(checkpoint);, +                        flushCheckpoints.add(cp);, +                        flushCheckpoints.add(new DefaultFlushCheckpoint(checkpoint, future));, +            if (flushCheckpoints.isEmpty()) {, +            for (;;) {, +                FlushCheckpoint cp = flushCheckpoints.poll();, +                if (cp == null) {, +                if (cp.flushCheckpoint() > flushedAmount) {, +                    break;, +                }, +                cp.future().setSuccess();, +            }, +            if (flushCheckpoints.isEmpty()) {, +                for (FlushCheckpoint cp: flushCheckpoints) {, +                    cp.flushCheckpoint(cp.flushCheckpoint() - flushedAmount);, +                }, +            for (;;) {, +                FlushCheckpoint cp = flushCheckpoints.poll();, +                if (cp == null) {, +                    break;, +                cp.future().setFailure(cause);, +            }, +    static abstract class FlushCheckpoint {, +        abstract long flushCheckpoint();, +        abstract void flushCheckpoint(long checkpoint);, +        abstract ChannelFuture future();, +    }, +    private static class DefaultFlushCheckpoint extends FlushCheckpoint {, +        private long checkpoint;, +        private final ChannelFuture future;, +, +        DefaultFlushCheckpoint(long checkpoint, ChannelFuture future) {, +            this.checkpoint = checkpoint;, +        }, +, +        @Override, +        long flushCheckpoint() {, +            return checkpoint;, +        }, +, +        @Override, +        void flushCheckpoint(long checkpoint) {, +            this.checkpoint = checkpoint;, +        }, +, +        @Override, +        ChannelFuture future() {, +            return future;, +    protected abstract int doRead(Queue<Object> buf) throws Exception;, +    protected abstract int doRead(ChannelBuffer buf) throws Exception;, +    private static boolean expandReadBuffer(ChannelBuffer byteBuf) {, +++ b/transport/src/main/java/io/netty/channel/AbstractChannel.java, +import java.util.ArrayDeque;, +import java.util.Deque;, +    private final Deque<FlushCheckpoint> flushCheckpoints = new ArrayDeque<FlushCheckpoint>();, +                if (buf.hasMessageBuffer()) {, +                    Queue<Object> msgBuf = buf.messageBuffer();, +                        int localReadAmount = doRead(msgBuf);, +                } else {, +                    ChannelBuffer byteBuf = buf.byteBuffer();, +                    for (;;) {, +                        int localReadAmount = doRead(byteBuf);, +                        if (localReadAmount > 0) {, +                            read = true;, +                        } else if (localReadAmount < 0) {, +                            closed = true;, +                            break;, +                        }, +                        if (!expandReadBuffer(byteBuf)) {, +                            break;, +                        }, +                    }, +                }, +                    long checkpoint = flushedAmount + out().size();, +                    if (future instanceof FlushCheckpoint) {]