[+++ b/handler/src/main/java/io/netty/handler/ssl/SslHandler.java, +    private volatile long closeNotifyFlushTimeoutMillis = 3000;, +    private volatile long closeNotifyReadTimeoutMillis;, +    /**, +     * @deprecated use {@link #getCloseNotifyFlushTimeoutMillis()}, +     */, +    @Deprecated, +        return getCloseNotifyFlushTimeoutMillis();, +    /**, +     * @deprecated use {@link #setCloseNotifyFlushTimeout(long, TimeUnit)}, +     */, +    @Deprecated, +        setCloseNotifyFlushTimeout(closeNotifyTimeout, unit);, +    /**, +     * @deprecated use {@link #setCloseNotifyFlushTimeoutMillis(long)}, +     */, +    @Deprecated, +    public void setCloseNotifyTimeoutMillis(long closeNotifyFlushTimeoutMillis) {, +        setCloseNotifyFlushTimeoutMillis(closeNotifyFlushTimeoutMillis);, +    /**, +     * Gets the timeout for flushing the close_notify that was triggered by closing the, +     * {@link Channel}. If the close_notify was not flushed in the given timeout the {@link Channel} will be closed, +     * forcibily., +     */, +    public final long getCloseNotifyFlushTimeoutMillis() {, +        return closeNotifyFlushTimeoutMillis;, +    }, +, +    /**, +     * Sets the timeout for flushing the close_notify that was triggered by closing the, +     * {@link Channel}. If the close_notify was not flushed in the given timeout the {@link Channel} will be closed, +     * forcibily., +     */, +    public final void setCloseNotifyFlushTimeout(long closeNotifyFlushTimeoutMillis, TimeUnit unit) {, +        setCloseNotifyFlushTimeoutMillis(unit.toMillis(closeNotifyFlushTimeoutMillis));, +    }, +, +    /**, +     * See {@link #setCloseNotifyFlushTimeout(long, TimeUnit)}., +     */, +    public final void setCloseNotifyFlushTimeoutMillis(long closeNotifyFlushTimeoutMillis) {, +        if (closeNotifyFlushTimeoutMillis < 0) {, +                    "closeNotifyFlushTimeoutMillis: " + closeNotifyFlushTimeoutMillis + " (expected: >= 0)");, +        this.closeNotifyFlushTimeoutMillis = closeNotifyFlushTimeoutMillis;, +    }, +, +    /**, +     * Gets the timeout (in ms) for receiving the response for the close_notify that was triggered by closing the, +     * {@link Channel}. This timeout starts after the close_notify message was successfully written to the, +     * remote peer. Use {@code 0} to directly close the {@link Channel} and not wait for the response., +     */, +    public final long getCloseNotifyReadTimeoutMillis() {, +        return closeNotifyReadTimeoutMillis;, +    }, +, +    /**, +     * Sets the timeout  for receiving the response for the close_notify that was triggered by closing the, +     * {@link Channel}. This timeout starts after the close_notify message was successfully written to the, +     * remote peer. Use {@code 0} to directly close the {@link Channel} and not wait for the response., +     */, +    public final void setCloseNotifyReadTimeout(long closeNotifyReadTimeoutMillis, TimeUnit unit) {, +        setCloseNotifyReadTimeoutMillis(unit.toMillis(closeNotifyReadTimeoutMillis));, +    }, +, +    /**, +     * See {@link #setCloseNotifyReadTimeout(long, TimeUnit)}., +     */, +    public final void setCloseNotifyReadTimeoutMillis(long closeNotifyReadTimeoutMillis) {, +        if (closeNotifyReadTimeoutMillis < 0) {, +            throw new IllegalArgumentException(, +                    "closeNotifyReadTimeoutMillis: " + closeNotifyReadTimeoutMillis + " (expected: >= 0)");, +        }, +        this.closeNotifyReadTimeoutMillis = closeNotifyReadTimeoutMillis;, +, +            final ChannelHandlerContext ctx, final ChannelFuture flushFuture,, +            long closeNotifyTimeout = closeNotifyFlushTimeoutMillis;, +            if (closeNotifyTimeout > 0) {, +                        // May be done in the meantime as cancel(...) is only best effort., +                        if (!flushFuture.isDone()) {, +                            logger.warn("{} Last write attempt timed out; force-closing the connection.",, +                                    ctx.channel());, +                    }, +                }, closeNotifyTimeout, TimeUnit.MILLISECONDS);, +                final long closeNotifyReadTimeout = closeNotifyReadTimeoutMillis;, +                if (closeNotifyReadTimeout <= 0) {, +                } else {, +                    final ScheduledFuture<?> closeNotifyReadTimeoutFuture;, +, +                    if (!sslClosePromise.isDone()) {, +                        closeNotifyReadTimeoutFuture = ctx.executor().schedule(new Runnable() {, +                            @Override, +                            public void run() {, +                                if (!sslClosePromise.isDone()) {, +                                    logger.debug(, +                                            "{} did not receive close_notify in {}ms; force-closing the connection.",, +                                            ctx.channel(), closeNotifyReadTimeout);, +, +                                    // Do the close now..., +                                    addCloseListener(ctx.close(ctx.newPromise()), promise);, +                                }]