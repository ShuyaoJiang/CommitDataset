[+++ b/src/main/java/org/jboss/netty/example/http/websocket/WebSocketServerHandler.java, +import java.security.MessageDigest;, +, +    private void handleHttpRequest(ChannelHandlerContext ctx, HttpRequest req) throws Exception {, +, +            // Fill in the headers and contents depending on handshake method., +            if (req.containsHeader(SEC_WEBSOCKET_KEY1) &&, +                req.containsHeader(SEC_WEBSOCKET_KEY2)) {, +                // New handshake method with a challenge:, +                res.addHeader(SEC_WEBSOCKET_ORIGIN, req.getHeader(ORIGIN));, +                res.addHeader(SEC_WEBSOCKET_LOCATION, getWebSocketLocation(req));, +                String protocol = req.getHeader(SEC_WEBSOCKET_PROTOCOL);, +                if (protocol != null) {, +                    res.addHeader(SEC_WEBSOCKET_PROTOCOL, protocol);, +                }, +, +                // Calculate the answer of the challenge., +                String key1 = req.getHeader(SEC_WEBSOCKET_KEY1);, +                String key2 = req.getHeader(SEC_WEBSOCKET_KEY2);, +                int a = (int) (Long.parseLong(key1.replaceAll("[^0-9]", "")) / key1.replaceAll("[^ ]", "").length());, +                int b = (int) (Long.parseLong(key2.replaceAll("[^0-9]", "")) / key2.replaceAll("[^ ]", "").length());, +                long c = req.getContent().readLong();, +                ChannelBuffer input = ChannelBuffers.buffer(16);, +                input.writeInt(a);, +                input.writeInt(b);, +                input.writeLong(c);, +                ChannelBuffer output = ChannelBuffers.wrappedBuffer(, +                        MessageDigest.getInstance("MD5").digest(input.array()),, +                        new byte[] { '\r', '\n' });, +                res.setContent(output);, +            } else {, +                // Old handshake method with no challenge:, +            }, +++ b/src/main/java/org/jboss/netty/example/http/websocket/WebSocketServerHandler.java, +import java.security.MessageDigest;, +, +    private void handleHttpRequest(ChannelHandlerContext ctx, HttpRequest req) throws Exception {, +, +            // Fill in the headers and contents depending on handshake method., +            if (req.containsHeader(SEC_WEBSOCKET_KEY1) &&, +                req.containsHeader(SEC_WEBSOCKET_KEY2)) {, +                // New handshake method with a challenge:, +                res.addHeader(SEC_WEBSOCKET_ORIGIN, req.getHeader(ORIGIN));, +                res.addHeader(SEC_WEBSOCKET_LOCATION, getWebSocketLocation(req));, +                String protocol = req.getHeader(SEC_WEBSOCKET_PROTOCOL);, +                if (protocol != null) {, +                    res.addHeader(SEC_WEBSOCKET_PROTOCOL, protocol);, +                }, +, +                // Calculate the answer of the challenge., +                String key1 = req.getHeader(SEC_WEBSOCKET_KEY1);, +                String key2 = req.getHeader(SEC_WEBSOCKET_KEY2);, +                int a = (int) (Long.parseLong(key1.replaceAll("[^0-9]", "")) / key1.replaceAll("[^ ]", "").length());, +                int b = (int) (Long.parseLong(key2.replaceAll("[^0-9]", "")) / key2.replaceAll("[^ ]", "").length());, +                long c = req.getContent().readLong();, +                ChannelBuffer input = ChannelBuffers.buffer(16);, +                input.writeInt(a);, +                input.writeInt(b);, +                input.writeLong(c);, +                ChannelBuffer output = ChannelBuffers.wrappedBuffer(, +                        MessageDigest.getInstance("MD5").digest(input.array()),, +                        new byte[] { '\r', '\n' });, +                res.setContent(output);, +            } else {, +                // Old handshake method with no challenge:, +            }, +++ b/src/main/java/org/jboss/netty/handler/codec/http/HttpHeaders.java, +         * {@code "Sec-WebSocket-Key1"}, +         */, +        public static final String SEC_WEBSOCKET_KEY1 = "Sec-WebSocket-Key1";, +        /**, +         * {@code "Sec-WebSocket-Key2"}, +         */, +        public static final String SEC_WEBSOCKET_KEY2 = "Sec-WebSocket-Key2";, +        /**, +         * {@code "Sec-WebSocket-Location"}, +         */, +        public static final String SEC_WEBSOCKET_LOCATION = "Sec-WebSocket-Location";, +        /**, +         * {@code "Sec-WebSocket-Origin"}, +         */, +        public static final String SEC_WEBSOCKET_ORIGIN = "Sec-WebSocket-Origin";, +        /**, +         * {@code "Sec-WebSocket-Protocol"}, +         */, +        public static final String SEC_WEBSOCKET_PROTOCOL = "Sec-WebSocket-Protocol";, +        /**, +, +        // WebSockset messages have constant content-lengths., +        if (message instanceof HttpRequest) {, +            HttpRequest req = (HttpRequest) message;, +            if (HttpMethod.GET.equals(req.getMethod()) &&, +                req.containsHeader(Names.SEC_WEBSOCKET_KEY1) &&, +                req.containsHeader(Names.SEC_WEBSOCKET_KEY2)) {, +                return 10;, +            }, +        } else if (message instanceof HttpResponse) {, +            HttpResponse res = (HttpResponse) message;, +            if (res.getStatus().getCode() == 101 &&, +                res.containsHeader(Names.SEC_WEBSOCKET_ORIGIN) &&]