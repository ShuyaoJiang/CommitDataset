[+++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslContext.java, +        ByteBufAllocator allocator = ByteBufAllocator.DEFAULT;, +        PemEncoded pem = PemPrivateKey.toPEM(allocator, true, key);, +        try {, +            return toBIO(allocator, pem.retain());, +        } finally {, +            pem.release();, +        }, +, +        if (certChain.length == 0) {, +            throw new IllegalArgumentException("certChain can't be empty");, +        }, +, +        ByteBufAllocator allocator = ByteBufAllocator.DEFAULT;, +        PemEncoded pem = PemX509Certificate.toPEM(allocator, true, certChain);, +            return toBIO(allocator, pem.retain());, +            pem.release();, +    }, +, +    private static long toBIO(ByteBufAllocator allocator, PemEncoded pem) throws Exception {, +        try {, +            // We can turn direct buffers straight into BIOs. No need to, +            // make a yet another copy., +            ByteBuf content = pem.content();, +, +            if (content.isDirect()) {, +                return newBIO(content.retainedSlice());, +            }, +, +            ByteBuf buffer = allocator.directBuffer(content.readableBytes());, +            try {, +                buffer.writeBytes(content);, +                return newBIO(buffer.retainedSlice());, +                try {, +                    // If the contents of the ByteBuf is sensitive (e.g. a PrivateKey) we, +                    // need to zero out the bytes of the copy before we're releasing it., +                    if (pem.isSensitive()) {, +                        SslUtils.zeroout(buffer);, +        } finally {, +            pem.release();, +        }, +    }, +        try {, +        } finally {, +            buffer.release();, +        }, +++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslContext.java, +        ByteBufAllocator allocator = ByteBufAllocator.DEFAULT;, +        PemEncoded pem = PemPrivateKey.toPEM(allocator, true, key);, +        try {, +            return toBIO(allocator, pem.retain());, +        } finally {, +            pem.release();, +        }, +, +        if (certChain.length == 0) {, +            throw new IllegalArgumentException("certChain can't be empty");, +        }, +, +        ByteBufAllocator allocator = ByteBufAllocator.DEFAULT;, +        PemEncoded pem = PemX509Certificate.toPEM(allocator, true, certChain);, +            return toBIO(allocator, pem.retain());, +            pem.release();, +    }, +, +    private static long toBIO(ByteBufAllocator allocator, PemEncoded pem) throws Exception {, +        try {, +            // We can turn direct buffers straight into BIOs. No need to, +            // make a yet another copy., +            ByteBuf content = pem.content();, +, +            if (content.isDirect()) {, +                return newBIO(content.retainedSlice());, +            }, +, +            ByteBuf buffer = allocator.directBuffer(content.readableBytes());, +            try {, +                buffer.writeBytes(content);, +                return newBIO(buffer.retainedSlice());, +                try {, +                    // If the contents of the ByteBuf is sensitive (e.g. a PrivateKey) we, +                    // need to zero out the bytes of the copy before we're releasing it., +                    if (pem.isSensitive()) {, +                        SslUtils.zeroout(buffer);, +        } finally {, +            pem.release();, +        }, +    }, +        try {, +        } finally {, +            buffer.release();, +        }, +++ b/handler/src/main/java/io/netty/handler/ssl/PemEncoded.java, +/*, + * Copyright 2016 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *]