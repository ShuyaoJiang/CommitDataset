[+++ b/buffer/src/main/java/io/netty/buffer/ByteBufUtil.java, +    private static final FastThreadLocal<byte[]> BYTE_ARRAYS = new FastThreadLocal<byte[]>() {, +        protected byte[] initialValue() throws Exception {, +            return PlatformDependent.allocateUninitializedArray(1024);, +    @SuppressWarnings("deprecation"), +        final byte[] array;, +        final int offset;, +        if (src.hasArray()) {, +            array = src.array();, +            offset = src.arrayOffset() + readerIndex;, +        } else {, +            if (len <= 1024) {, +                array = BYTE_ARRAYS.get();, +            } else {, +                array = PlatformDependent.allocateUninitializedArray(len);, +            offset = 0;, +            src.getBytes(readerIndex, array, 0, len);, +        if (CharsetUtil.US_ASCII.equals(charset)) {, +            // Fast-path for US-ASCII which is used frequently., +            return new String(array, 0, offset, len);, +        return new String(array, offset, len, charset);, +++ b/buffer/src/main/java/io/netty/buffer/ByteBufUtil.java, +    private static final FastThreadLocal<byte[]> BYTE_ARRAYS = new FastThreadLocal<byte[]>() {, +        protected byte[] initialValue() throws Exception {, +            return PlatformDependent.allocateUninitializedArray(1024);, +    @SuppressWarnings("deprecation"), +        final byte[] array;, +        final int offset;, +        if (src.hasArray()) {, +            array = src.array();, +            offset = src.arrayOffset() + readerIndex;, +        } else {, +            if (len <= 1024) {, +                array = BYTE_ARRAYS.get();, +            } else {, +                array = PlatformDependent.allocateUninitializedArray(len);, +            offset = 0;, +            src.getBytes(readerIndex, array, 0, len);, +        if (CharsetUtil.US_ASCII.equals(charset)) {, +            // Fast-path for US-ASCII which is used frequently., +            return new String(array, 0, offset, len);, +        return new String(array, offset, len, charset);, +++ b/microbench/src/main/java/io/netty/buffer/ByteBufUtilDecodeStringBenchmark.java, +/*, + * Copyright 2018 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + *   http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the, + * License for the specific language governing permissions and limitations, + * under the License., + */, +package io.netty.buffer;, +, +import io.netty.microbench.util.AbstractMicrobenchmark;, +import org.openjdk.jmh.annotations.Benchmark;, +import org.openjdk.jmh.annotations.Measurement;, +import org.openjdk.jmh.annotations.Param;, +import org.openjdk.jmh.annotations.Setup;, +import org.openjdk.jmh.annotations.TearDown;, +import org.openjdk.jmh.annotations.Warmup;, +, +import java.nio.charset.Charset;, +import java.util.Arrays;, +import java.util.concurrent.TimeUnit;, +, +@Warmup(iterations = 5, time = 1, timeUnit = TimeUnit.SECONDS), +@Measurement(iterations = 10, time = 1, timeUnit = TimeUnit.SECONDS), +public class ByteBufUtilDecodeStringBenchmark extends AbstractMicrobenchmark {, +, +    public enum ByteBufType {, +        DIRECT {, +            @Override, +            ByteBuf newBuffer(byte[] bytes, int length) {, +                ByteBuf buffer = Unpooled.directBuffer(length);, +                buffer.writeBytes(bytes, 0, length);, +                return buffer;, +            }, +        },, +        HEAP_OFFSET {, +            @Override, +            ByteBuf newBuffer(byte[] bytes, int length) {, +                return Unpooled.wrappedBuffer(bytes, 1, length);, +            }, +        },, +        HEAP {, +            @Override, +            ByteBuf newBuffer(byte[] bytes, int length) {, +                return Unpooled.wrappedBuffer(bytes, 0, length);, +            }, +        },, +        COMPOSITE {, +            @Override, +            ByteBuf newBuffer(byte[] bytes, int length) {]