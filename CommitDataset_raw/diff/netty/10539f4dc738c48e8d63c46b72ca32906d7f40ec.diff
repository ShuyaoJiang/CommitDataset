[+++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, +    static final boolean checkAccessible; // accessed from CompositeByteBuf, +        if (endianness == null) {, +            throw new NullPointerException("endianness");, +        }, +    int forEachByteAsc0(int start, int end, ByteProcessor processor) throws Exception {, +    int forEachByteDesc0(int rStart, final int rEnd, ByteProcessor processor) throws Exception {, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, +    static final boolean checkAccessible; // accessed from CompositeByteBuf, +        if (endianness == null) {, +            throw new NullPointerException("endianness");, +        }, +    int forEachByteAsc0(int start, int end, ByteProcessor processor) throws Exception {, +    int forEachByteDesc0(int rStart, final int rEnd, ByteProcessor processor) throws Exception {, +++ b/buffer/src/main/java/io/netty/buffer/CompositeByteBuf.java, +import io.netty.util.ByteProcessor;, +import io.netty.util.IllegalReferenceCountException;, +import io.netty.util.ReferenceCountUtil;, +import io.netty.util.internal.RecyclableArrayList;, +import java.util.Arrays;, +    private int componentCount;, +    private Component[] components; // resized when needed, +, +        components = newCompArray(initSize, maxNumComponents);, +        this(alloc, direct, maxNumComponents, buffers, 0);, +            ByteBuf[] buffers, int offset) {, +        this(alloc, direct, maxNumComponents, buffers.length - offset);, +        addComponents0(false, 0, buffers, offset);, +        setIndex0(0, capacity());, +    private static Component[] newCompArray(int initComponents, int maxNumComponents) {, +        return new Component[Math.max(initComponents, capacityGuess)];, +        addComponent0(increaseWriterIndex, componentCount, buffer);, +        checkNotNull(buffers, "buffers");, +        addComponents0(increaseWriterIndex, componentCount, buffers, 0);, +        addComponents0(increaseWriterIndex, componentCount, buffers);, +            Component c = newComponent(buffer, 0);, +            int readableBytes = c.length();, +, +            addComp(cIndex, c);, +            if (readableBytes > 0 && cIndex < componentCount - 1) {, +            } else if (cIndex > 0) {, +                c.reposition(components[cIndex - 1].endOffset);, +    // unwrap if already sliced, +    @SuppressWarnings("deprecation"), +    private Component newComponent(ByteBuf buf, int offset) {, +        if (checkAccessible && buf.refCnt() == 0) {, +            throw new IllegalReferenceCountException(0);, +        }, +        int srcIndex = buf.readerIndex(), len = buf.readableBytes();, +        ByteBuf slice = null;, +        if (buf instanceof AbstractUnpooledSlicedByteBuf) {, +            srcIndex += ((AbstractUnpooledSlicedByteBuf) buf).idx(0);, +            slice = buf;, +            buf = buf.unwrap();, +        } else if (buf instanceof PooledSlicedByteBuf) {, +            srcIndex += ((PooledSlicedByteBuf) buf).adjustment;, +            slice = buf;, +            buf = buf.unwrap();, +        }, +        return new Component(buf.order(ByteOrder.BIG_ENDIAN), srcIndex, offset, len, slice);, +    }, +, +        checkNotNull(buffers, "buffers");, +        addComponents0(false, cIndex, buffers, 0);, +    private int addComponents0(boolean increaseWriterIndex, final int cIndex, ByteBuf[] buffers, int arrOffset) {, +        final int len = buffers.length, count = len - arrOffset;, +        int ci = Integer.MAX_VALUE;, +            shiftComps(cIndex, count); // will increase componentCount, +            ci = cIndex; // only set this after we've shifted so that finally block logic is always correct, +            int nextOffset = cIndex > 0 ? components[cIndex - 1].endOffset : 0;, +            for (ByteBuf b; arrOffset < len && (b = buffers[arrOffset]) != null; arrOffset++, ci++) {, +                Component c = newComponent(b, nextOffset);, +                components[ci] = c;, +                nextOffset = c.endOffset;, +            return ci;, +            // ci is now the index following the last successfully added component, +            if (ci < componentCount) {, +                if (ci < cIndex + count) {, +                    // we bailed early, +                    removeCompRange(ci, cIndex + count);, +                    for (; arrOffset < len; ++arrOffset) {, +                        ReferenceCountUtil.safeRelease(buffers[arrOffset]);, +                updateComponentOffsets(ci); // only need to do this here for components after the added ones, +            }, +            if (increaseWriterIndex && ci > cIndex && ci <= componentCount) {, +                writerIndex(writerIndex() + components[ci - 1].endOffset - components[cIndex].offset);, +                int size = componentCount;, +    // TODO optimize further, similar to ByteBuf[] version, +    // (difference here is that we don't know *always* know precise size increase in advance,, +    // but we do in the most common case that the Iterable is a Collection), +        Iterator<ByteBuf> it = buffers.iterator();, +            checkComponentIndex(cIndex);, +, +            // No need for consolidation, +            while (it.hasNext()) {, +                ByteBuf b = it.next();, +                if (b == null) {, +                    break;, +                cIndex = addComponent0(increaseIndex, cIndex, b) + 1;, +                cIndex = Math.min(cIndex, componentCount);]