[+++ b/transport/src/main/java/io/netty/channel/AbstractServerChannel.java, +    protected abstract class DefaultServerUnsafe extends AbstractUnsafe {, +++ b/transport/src/main/java/io/netty/channel/AbstractServerChannel.java, +    protected abstract class DefaultServerUnsafe extends AbstractUnsafe {, +++ b/transport/src/main/java/io/netty/channel/Channel.java, +        void suspendRead();, +        void resumeRead();, +++ b/transport/src/main/java/io/netty/channel/AbstractServerChannel.java, +    protected abstract class DefaultServerUnsafe extends AbstractUnsafe {, +++ b/transport/src/main/java/io/netty/channel/Channel.java, +        void suspendRead();, +        void resumeRead();, +++ b/transport/src/main/java/io/netty/channel/ChannelHandlerContext.java, +, +    boolean isReadable();, +    void readable(boolean readable);, +++ b/transport/src/main/java/io/netty/channel/AbstractServerChannel.java, +    protected abstract class DefaultServerUnsafe extends AbstractUnsafe {, +++ b/transport/src/main/java/io/netty/channel/Channel.java, +        void suspendRead();, +        void resumeRead();, +++ b/transport/src/main/java/io/netty/channel/ChannelHandlerContext.java, +, +    boolean isReadable();, +    void readable(boolean readable);, +++ b/transport/src/main/java/io/netty/channel/ChannelStateHandler.java, +, +++ b/transport/src/main/java/io/netty/channel/AbstractServerChannel.java, +    protected abstract class DefaultServerUnsafe extends AbstractUnsafe {, +++ b/transport/src/main/java/io/netty/channel/Channel.java, +        void suspendRead();, +        void resumeRead();, +++ b/transport/src/main/java/io/netty/channel/ChannelHandlerContext.java, +, +    boolean isReadable();, +    void readable(boolean readable);, +++ b/transport/src/main/java/io/netty/channel/ChannelStateHandler.java, +, +++ b/transport/src/main/java/io/netty/channel/DefaultChannelHandlerContext.java, +import java.util.concurrent.atomic.AtomicBoolean;, +    final AtomicBoolean suspendRead = new AtomicBoolean(false);, +, +, +    @Override, +    public boolean isReadable() {, +        return !suspendRead.get();, +    }, +, +    @Override, +    public void readable(boolean readable) {, +        this.pipeline.readable(this, readable);, +    }, +++ b/transport/src/main/java/io/netty/channel/AbstractServerChannel.java, +    protected abstract class DefaultServerUnsafe extends AbstractUnsafe {, +++ b/transport/src/main/java/io/netty/channel/Channel.java, +        void suspendRead();, +        void resumeRead();, +++ b/transport/src/main/java/io/netty/channel/ChannelHandlerContext.java, +, +    boolean isReadable();, +    void readable(boolean readable);, +++ b/transport/src/main/java/io/netty/channel/ChannelStateHandler.java, +, +++ b/transport/src/main/java/io/netty/channel/DefaultChannelHandlerContext.java, +import java.util.concurrent.atomic.AtomicBoolean;, +    final AtomicBoolean suspendRead = new AtomicBoolean(false);, +, +, +    @Override, +    public boolean isReadable() {, +        return !suspendRead.get();, +    }, +, +    @Override, +    public void readable(boolean readable) {, +        this.pipeline.readable(this, readable);, +    }, +++ b/transport/src/main/java/io/netty/channel/DefaultChannelPipeline.java, +import java.util.concurrent.atomic.AtomicInteger;, +    private final AtomicInteger suspendRead = new AtomicInteger();, +, +        // make sure we clear the readable flag, +        ctx.readable(true);, +, +        // clear readable suspend if necessary, +        oldTail.readable(true);, +, +, +, +, +            // clear readable suspend if necessary, +            ctx.readable(true);, +, +    void readable(DefaultChannelHandlerContext ctx, boolean readable) {, +        if (ctx.suspendRead.compareAndSet(!readable, readable)) {, +            if (!readable) {, +                if (suspendRead.incrementAndGet() == 1) {, +                    unsafe.suspendRead();, +                }, +            } else {]