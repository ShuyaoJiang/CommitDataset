[+++ b/common/src/main/java/io/netty/util/concurrent/SingleThreadEventExecutor.java, +            if (isShutdown()) {, +                boolean reject = false;, +                try {, +                    if (removeTask(task)) {, +                        reject = true;, +                    }, +                } catch (UnsupportedOperationException e) {, +                    // The task queue does not support removal so the best thing we can do is to just move on and, +                    // hope we will be able to pick-up the task before its completely terminated., +                    // In worst case we will log on termination., +                }, +                if (reject) {, +        }, +++ b/common/src/main/java/io/netty/util/concurrent/SingleThreadEventExecutor.java, +            if (isShutdown()) {, +                boolean reject = false;, +                try {, +                    if (removeTask(task)) {, +                        reject = true;, +                    }, +                } catch (UnsupportedOperationException e) {, +                    // The task queue does not support removal so the best thing we can do is to just move on and, +                    // hope we will be able to pick-up the task before its completely terminated., +                    // In worst case we will log on termination., +                }, +                if (reject) {, +        }, +++ b/transport/src/test/java/io/netty/channel/nio/NioEventLoopTest.java, +import org.hamcrest.core.IsInstanceOf;, +import java.util.concurrent.RejectedExecutionException;, +import java.util.concurrent.atomic.AtomicReference;, +, +    @SuppressWarnings("deprecation"), +    @Test, +    public void testTaskRemovalOnShutdownThrowsNoUnsupportedOperationException() throws Exception {, +        final AtomicReference<Throwable> error = new AtomicReference<Throwable>();, +        final Runnable task = new Runnable() {, +            @Override, +            public void run() {, +                // NOOP, +            }, +        };, +        // Just run often enough to trigger it normally., +        for (int i = 0; i < 1000; i++) {, +            NioEventLoopGroup group = new NioEventLoopGroup(1);, +            final NioEventLoop loop = (NioEventLoop) group.next();, +, +            Thread t = new Thread(new Runnable() {, +                @Override, +                public void run() {, +                    try {, +                        for (;;) {, +                            loop.execute(task);, +                        }, +                    } catch (Throwable cause) {, +                        error.set(cause);, +                    }, +                }, +            });, +            t.start();, +            group.shutdownNow();, +            t.join();, +            group.terminationFuture().syncUninterruptibly();, +            assertThat(error.get(), IsInstanceOf.instanceOf(RejectedExecutionException.class));, +            error.set(null);, +        }, +    }, +]