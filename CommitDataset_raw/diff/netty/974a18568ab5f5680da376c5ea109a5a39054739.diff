[+++ b/src/main/java/org/jboss/netty/util/internal/LinkedTransferQueue.java, +import java.util.ConcurrentModificationException;, +    private static final class Node<E> extends AtomicReference<Object> {, +        transient volatile Node<E> next;, +        Node(E item, boolean isData) {, +        @SuppressWarnings("unchecked"), +        private static final AtomicReferenceFieldUpdater<Node, Node> nextUpdater;, +            @SuppressWarnings("unchecked"), +            AtomicReferenceFieldUpdater<Node, Node> tmp = null;, +                        Node.class, Node.class, "next");, +                @SuppressWarnings("unchecked"), +                Node testNode = new Node(null, false);, +        final boolean casNext(Node<E> cmp, Node<E> val) {, +        private synchronized final boolean alternativeCasNext(Node<E> cmp, Node<E> val) {, +            next = this; // allows to run on java5, +    private final PaddedAtomicReference<Node<E>> head;, +    private final PaddedAtomicReference<Node<E>> tail;, +    private final PaddedAtomicReference<Node<E>> cleanMe;, +    private boolean advanceHead(Node<E> h, Node<E> nh) {, +    private E xfer(E e, int mode, long nanos) {, +        Node<E> s = null;, +        final PaddedAtomicReference<Node<E>> head = this.head;, +        final PaddedAtomicReference<Node<E>> tail = this.tail;, +            Node<E> t = tail.get();, +            Node<E> h = head.get();, +            if (t == h || t.isData == isData) {, +                    s = new Node<E>(e, isData);, +                Node<E> last = t.next;, +            } else {, +                Node<E> first = h.next;, +                        return isData? e : cast(x);, +    private E fulfill(E e) {, +        final PaddedAtomicReference<Node<E>> head = this.head;, +        final PaddedAtomicReference<Node<E>> tail = this.tail;, +            Node<E> t = tail.get();, +            Node<E> h = head.get();, +            if (t == h || t.isData == isData) {, +                Node<E> last = t.next;, +            } else {, +                Node<E> first = h.next;, +                        return isData? e : cast(x);, +     * @return matched item, or null if cancelled, +    private E awaitFulfill(Node<E> pred, Node<E> s, E e,, +                    return cast(x);, +                Node<E> h = head.get(); // only spin if at head, +                spins = h.next != s ? 0 :, +                    mode == TIMEOUT ? maxTimedSpins :, +                        maxUntimedSpins;, +    private Node<E> getValidatedTail() {, +            Node<E> h = head.get();, +            Node<E> first = h.next;, +            if (first != null && first.get() == first) { // help advance, +            Node<E> t = tail.get();, +            Node<E> last = t.next;, +    void clean(Node<E> pred, Node<E> s) {, +            Node<E> oldpred = reclean();  // First, help get rid of cleanMe, +            Node<E> t = getValidatedTail();, +                Node<E> sn = s.next;      // s.next == s means s already off list, +    private Node<E> reclean() {, +        Node<E> pred;, +            Node<E> t = getValidatedTail();, +            Node<E> s = pred.next;, +                Node<E> sn;, +        Node<E> dummy = new Node<E>(null, false);, +        head = new PaddedAtomicReference<Node<E>>(dummy);, +        tail = new PaddedAtomicReference<Node<E>>(dummy);, +        cleanMe = new PaddedAtomicReference<Node<E>>(null);, +    /**, +     * Inserts the specified element at the tail of this queue., +     * As the queue is unbounded, this method will never block., +     *, +     * @throws NullPointerException if the specified element is null, +     */, +        offer(e);, +    /**, +     * Inserts the specified element at the tail of this queue, +     * As the queue is unbounded, this method will never block or, +     * return {@code false}., +     *, +     * @return {@code true} (as specified by {@link BlockingQueue#offer(Object,long,TimeUnit) BlockingQueue.offer}), +     * @throws NullPointerException if the specified element is null, +     */, +        return offer(e);, +    /**, +     * Inserts the specified element at the tail of this queue., +     * As the queue is unbounded, this method will never return {@code false}., +     *, +     * @return {@code true} (as specified by {@link BlockingQueue#offer(Object) BlockingQueue.offer}), +     * @throws NullPointerException if the specified element is null, +     */, +    /**, +     * Inserts the specified element at the tail of this queue., +     * As the queue is unbounded, this method will never throw, +     * {@link IllegalStateException} or return {@code false}., +     *, +     * @return {@code true} (as specified by {@link Collection#add}), +     * @throws NullPointerException if the specified element is null, +     */, +        return offer(e);, +    }]