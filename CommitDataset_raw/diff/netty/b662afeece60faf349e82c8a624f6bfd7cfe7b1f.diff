[+++ b/buffer/src/test/java/io/netty/buffer/UnpooledTest.java, +            ByteBuf buffer = wrappedBuffer(e.getKey());, +                    ByteBufUtil.hashCode(buffer));, +            buffer.release();, +        a.release();, +        b.release();, +        a.release();, +        b.release();, +        a.release();, +        b.release();, +        a.release();, +        b.release();, +        a.release();, +        b.release();, +        a.release();, +        b.release();, +        a.release();, +        b.release();, +        a.release();, +        b.release();, +        a.release();, +        b.release();, +        for (ByteBuf buffer: expected) {, +            buffer.release();, +        }, +        assertSameAndRelease(EMPTY_BUFFER, wrappedBuffer(EMPTY_BYTES));, +        assertSameAndRelease(EMPTY_BUFFER, wrappedBuffer(new byte[8], 0, 0));, +        assertSameAndRelease(EMPTY_BUFFER, wrappedBuffer(new byte[8], 8, 0));, +        assertSameAndRelease(EMPTY_BUFFER, wrappedBuffer(ByteBuffer.allocateDirect(0)));, +        assertSameAndRelease(EMPTY_BUFFER, wrappedBuffer(EMPTY_BUFFER));, +        assertSameAndRelease(EMPTY_BUFFER, wrappedBuffer(EMPTY_BYTES_2D));, +        assertSameAndRelease(EMPTY_BUFFER, wrappedBuffer(new byte[][] { EMPTY_BYTES }));, +        assertSameAndRelease(EMPTY_BUFFER, wrappedBuffer(EMPTY_BYTE_BUFFERS));, +        assertSameAndRelease(EMPTY_BUFFER, wrappedBuffer(new ByteBuffer[] { ByteBuffer.allocate(0) }));, +        assertSameAndRelease(EMPTY_BUFFER, wrappedBuffer(ByteBuffer.allocate(0), ByteBuffer.allocate(0)));, +        assertSameAndRelease(EMPTY_BUFFER, wrappedBuffer(EMPTY_BYTE_BUFS));, +        assertSameAndRelease(EMPTY_BUFFER, wrappedBuffer(new ByteBuf[] { buffer(0) }));, +        assertSameAndRelease(EMPTY_BUFFER, wrappedBuffer(buffer(0), buffer(0)));, +        assertSameAndRelease(EMPTY_BUFFER, copiedBuffer(EMPTY_BYTES));, +        assertSameAndRelease(EMPTY_BUFFER, copiedBuffer(new byte[8], 0, 0));, +        assertSameAndRelease(EMPTY_BUFFER, copiedBuffer(new byte[8], 8, 0));, +        assertSameAndRelease(EMPTY_BUFFER, copiedBuffer(ByteBuffer.allocateDirect(0)));, +        assertSameAndRelease(EMPTY_BUFFER, copiedBuffer(EMPTY_BUFFER));, +        assertSameAndRelease(EMPTY_BUFFER, copiedBuffer(new byte[][] { EMPTY_BYTES }));, +        assertSameAndRelease(EMPTY_BUFFER, copiedBuffer(EMPTY_BYTE_BUFFERS));, +        assertSameAndRelease(EMPTY_BUFFER, copiedBuffer(new ByteBuffer[] { ByteBuffer.allocate(0) }));, +        assertSameAndRelease(EMPTY_BUFFER, copiedBuffer(ByteBuffer.allocate(0), ByteBuffer.allocate(0)));, +        assertSameAndRelease(EMPTY_BUFFER, copiedBuffer(EMPTY_BYTE_BUFS));, +        assertSameAndRelease(EMPTY_BUFFER, copiedBuffer(new ByteBuf[] { buffer(0) }));, +        assertSameAndRelease(EMPTY_BUFFER, copiedBuffer(buffer(0), buffer(0)));, +        ByteBuf expected = wrappedBuffer(new byte[]{(byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF});, +        ByteBuf actual = wrappedBuffer(new byte[]{(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00});, +        assertTrue(ByteBufUtil.compare(expected, actual) > 0);, +        expected.release();, +        actual.release();, +        expected = wrappedBuffer(new byte[]{(byte) 0xFF});, +        actual = wrappedBuffer(new byte[]{(byte) 0x00});, +        assertTrue(ByteBufUtil.compare(expected, actual) > 0);, +        expected.release();, +        actual.release();, +        ByteBuf buffer = wrappedBuffer(ByteBuffer.allocateDirect(16));, +        assertEquals(16, buffer.capacity());, +        buffer.release();, +        assertEqualsAndRelease(, +        assertEqualsAndRelease(, +                wrappedBuffer(new byte[] { 1 }, new byte[] { 2 }, new byte[] { 3 }));, +        assertEqualsAndRelease(wrappedBuffer(new byte[] { 1, 2, 3 }),, +                wrappedBuffer(new ByteBuf[] { wrappedBuffer(new byte[] { 1, 2, 3 }) }));, +        assertEqualsAndRelease(, +                wrappedBuffer(wrappedBuffer(new byte[] { 1 }),, +                        wrappedBuffer(new byte[] { 2 }), wrappedBuffer(new byte[] { 3 })));, +        assertEqualsAndRelease(wrappedBuffer(new byte[] { 1, 2, 3 }),, +                wrappedBuffer(new ByteBuffer[] { ByteBuffer.wrap(new byte[] { 1, 2, 3 }) }));, +        assertEqualsAndRelease(wrappedBuffer(new byte[] { 1, 2, 3 }),, +                wrappedBuffer(ByteBuffer.wrap(new byte[] { 1 }),, +                ByteBuffer.wrap(new byte[] { 2 }), ByteBuffer.wrap(new byte[] { 3 })));, +        ByteBuf copied = copiedBuffer(ByteBuffer.allocateDirect(16));, +        assertEquals(16, copied.capacity());, +        copied.release();, +        assertEqualsAndRelease(wrappedBuffer(new byte[] { 1, 2, 3 }),, +        assertEqualsAndRelease(wrappedBuffer(new byte[] { 1, 2, 3 }),, +                copiedBuffer(new byte[] { 1 }, new byte[] { 2 }, new byte[] { 3 }));, +        assertEqualsAndRelease(wrappedBuffer(new byte[] { 1, 2, 3 }),, +                copiedBuffer(new ByteBuf[] { wrappedBuffer(new byte[] { 1, 2, 3 })}));, +        assertEqualsAndRelease(wrappedBuffer(new byte[] { 1, 2, 3 }),, +                copiedBuffer(wrappedBuffer(new byte[] { 1 }),, +                        wrappedBuffer(new byte[] { 2 }), wrappedBuffer(new byte[] { 3 })));, +        assertEqualsAndRelease(wrappedBuffer(new byte[] { 1, 2, 3 }),, +                copiedBuffer(new ByteBuffer[] { ByteBuffer.wrap(new byte[] { 1, 2, 3 }) }));, +        assertEqualsAndRelease(wrappedBuffer(new byte[] { 1, 2, 3 }),, +                copiedBuffer(ByteBuffer.wrap(new byte[] { 1 }),, +                        ByteBuffer.wrap(new byte[] { 2 }), ByteBuffer.wrap(new byte[] { 3 })));, +    }, +, +    private static void assertEqualsAndRelease(ByteBuf expected, ByteBuf actual) {, +        assertEquals(expected, actual);, +        expected.release();, +        actual.release();, +    }, +]