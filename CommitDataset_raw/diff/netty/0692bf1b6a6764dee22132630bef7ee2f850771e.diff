[+++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBufAllocator.java, +            throw new IllegalArgumentException("initialCapacity: " + initialCapacity + " (expected: 0+)");, +            throw new IllegalArgumentException("minNewCapacity: " + minNewCapacity + " (expected: 0+)");, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBufAllocator.java, +            throw new IllegalArgumentException("initialCapacity: " + initialCapacity + " (expected: 0+)");, +            throw new IllegalArgumentException("minNewCapacity: " + minNewCapacity + " (expected: 0+)");, +++ b/buffer/src/main/java/io/netty/buffer/DefaultByteBufHolder.java, +     * Return {@link ByteBuf#toString()} without checking the reference count first. This is useful to implement, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBufAllocator.java, +            throw new IllegalArgumentException("initialCapacity: " + initialCapacity + " (expected: 0+)");, +            throw new IllegalArgumentException("minNewCapacity: " + minNewCapacity + " (expected: 0+)");, +++ b/buffer/src/main/java/io/netty/buffer/DefaultByteBufHolder.java, +     * Return {@link ByteBuf#toString()} without checking the reference count first. This is useful to implement, +++ b/buffer/src/main/java/io/netty/buffer/PoolArena.java, +    // Method must be called inside synchronized(this) { ... } block, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBufAllocator.java, +            throw new IllegalArgumentException("initialCapacity: " + initialCapacity + " (expected: 0+)");, +            throw new IllegalArgumentException("minNewCapacity: " + minNewCapacity + " (expected: 0+)");, +++ b/buffer/src/main/java/io/netty/buffer/DefaultByteBufHolder.java, +     * Return {@link ByteBuf#toString()} without checking the reference count first. This is useful to implement, +++ b/buffer/src/main/java/io/netty/buffer/PoolArena.java, +    // Method must be called inside synchronized(this) { ... } block, +++ b/buffer/src/main/java/io/netty/buffer/PoolChunkListMetric.java, +     * Return the minimum usage of the chunk list before which chunks are promoted to the previous list., +     * Return the maximum usage of the chunk list after which chunks are promoted to the next list., +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBufAllocator.java, +            throw new IllegalArgumentException("initialCapacity: " + initialCapacity + " (expected: 0+)");, +            throw new IllegalArgumentException("minNewCapacity: " + minNewCapacity + " (expected: 0+)");, +++ b/buffer/src/main/java/io/netty/buffer/DefaultByteBufHolder.java, +     * Return {@link ByteBuf#toString()} without checking the reference count first. This is useful to implement, +++ b/buffer/src/main/java/io/netty/buffer/PoolArena.java, +    // Method must be called inside synchronized(this) { ... } block, +++ b/buffer/src/main/java/io/netty/buffer/PoolChunkListMetric.java, +     * Return the minimum usage of the chunk list before which chunks are promoted to the previous list., +     * Return the maximum usage of the chunk list after which chunks are promoted to the next list., +++ b/buffer/src/main/java/io/netty/buffer/PooledByteBufAllocator.java, +     * Default number of heap arenas - System Property: io.netty.allocator.numHeapArenas - default 2 * cores, +     * Default number of direct arenas - System Property: io.netty.allocator.numDirectArenas - default 2 * cores, +     * Return {@code true} if direct memory cache alignment is supported, {@code false} otherwise., +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBufAllocator.java, +            throw new IllegalArgumentException("initialCapacity: " + initialCapacity + " (expected: 0+)");, +            throw new IllegalArgumentException("minNewCapacity: " + minNewCapacity + " (expected: 0+)");, +++ b/buffer/src/main/java/io/netty/buffer/DefaultByteBufHolder.java, +     * Return {@link ByteBuf#toString()} without checking the reference count first. This is useful to implement, +++ b/buffer/src/main/java/io/netty/buffer/PoolArena.java, +    // Method must be called inside synchronized(this) { ... } block, +++ b/buffer/src/main/java/io/netty/buffer/PoolChunkListMetric.java, +     * Return the minimum usage of the chunk list before which chunks are promoted to the previous list., +     * Return the maximum usage of the chunk list after which chunks are promoted to the next list., +++ b/buffer/src/main/java/io/netty/buffer/PooledByteBufAllocator.java, +     * Default number of heap arenas - System Property: io.netty.allocator.numHeapArenas - default 2 * cores, +     * Default number of direct arenas - System Property: io.netty.allocator.numDirectArenas - default 2 * cores, +     * Return {@code true} if direct memory cache alignment is supported, {@code false} otherwise., +++ b/buffer/src/main/java/io/netty/buffer/PooledHeapByteBuf.java, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBufAllocator.java, +            throw new IllegalArgumentException("initialCapacity: " + initialCapacity + " (expected: 0+)");, +            throw new IllegalArgumentException("minNewCapacity: " + minNewCapacity + " (expected: 0+)");, +++ b/buffer/src/main/java/io/netty/buffer/DefaultByteBufHolder.java, +     * Return {@link ByteBuf#toString()} without checking the reference count first. This is useful to implement, +++ b/buffer/src/main/java/io/netty/buffer/PoolArena.java, +    // Method must be called inside synchronized(this) { ... } block, +++ b/buffer/src/main/java/io/netty/buffer/PoolChunkListMetric.java, +     * Return the minimum usage of the chunk list before which chunks are promoted to the previous list., +     * Return the maximum usage of the chunk list after which chunks are promoted to the next list., +++ b/buffer/src/main/java/io/netty/buffer/PooledByteBufAllocator.java, +     * Default number of heap arenas - System Property: io.netty.allocator.numHeapArenas - default 2 * cores, +     * Default number of direct arenas - System Property: io.netty.allocator.numDirectArenas - default 2 * cores, +     * Return {@code true} if direct memory cache alignment is supported, {@code false} otherwise., +++ b/buffer/src/main/java/io/netty/buffer/PooledHeapByteBuf.java, +++ b/buffer/src/main/java/io/netty/buffer/Unpooled.java, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBufAllocator.java, +            throw new IllegalArgumentException("initialCapacity: " + initialCapacity + " (expected: 0+)");, +            throw new IllegalArgumentException("minNewCapacity: " + minNewCapacity + " (expected: 0+)");, +++ b/buffer/src/main/java/io/netty/buffer/DefaultByteBufHolder.java, +     * Return {@link ByteBuf#toString()} without checking the reference count first. This is useful to implement, +++ b/buffer/src/main/java/io/netty/buffer/PoolArena.java, +    // Method must be called inside synchronized(this) { ... } block, +++ b/buffer/src/main/java/io/netty/buffer/PoolChunkListMetric.java, +     * Return the minimum usage of the chunk list before which chunks are promoted to the previous list., +     * Return the maximum usage of the chunk list after which chunks are promoted to the next list., +++ b/buffer/src/main/java/io/netty/buffer/PooledByteBufAllocator.java, +     * Default number of heap arenas - System Property: io.netty.allocator.numHeapArenas - default 2 * cores, +     * Default number of direct arenas - System Property: io.netty.allocator.numDirectArenas - default 2 * cores, +     * Return {@code true} if direct memory cache alignment is supported, {@code false} otherwise., +++ b/buffer/src/main/java/io/netty/buffer/PooledHeapByteBuf.java, +++ b/buffer/src/main/java/io/netty/buffer/Unpooled.java, +++ b/buffer/src/test/java/io/netty/buffer/AbstractByteBufTest.java, +    public void testRetainedSliceUnreleasable1() {, +        testRetainedSliceUnreleasable(true, true);, +    public void testRetainedSliceUnreleasable2() {, +        testRetainedSliceUnreleasable(true, false);, +    public void testRetainedSliceUnreleasable3() {, +        testRetainedSliceUnreleasable(false, true);, +    public void testRetainedSliceUnreleasable4() {, +        testRetainedSliceUnreleasable(false, false);, +    public void testReadRetainedSliceUnreleasable1() {, +        testReadRetainedSliceUnreleasable(true, true);, +    public void testReadRetainedSliceUnreleasable2() {, +        testReadRetainedSliceUnreleasable(true, false);, +    public void testReadRetainedSliceUnreleasable3() {]