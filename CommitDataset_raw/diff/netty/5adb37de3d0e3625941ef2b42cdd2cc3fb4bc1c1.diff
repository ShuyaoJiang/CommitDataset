[+++ b/handler/src/main/java/io/netty/handler/traffic/AbstractTrafficShapingHandler.java, +/*, + * Copyright 2011 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the, + * License for the specific language governing permissions and limitations, + * under the License., + */, +package io.netty.handler.traffic;, +, +import io.netty.buffer.Buf;, +import io.netty.buffer.ByteBuf;, +import io.netty.channel.ChannelFuture;, +import io.netty.channel.ChannelHandlerAdapter;, +import io.netty.channel.ChannelHandlerContext;, +import io.netty.channel.ChannelInboundByteHandler;, +import io.netty.channel.ChannelOutboundByteHandler;, +import io.netty.util.Attribute;, +import io.netty.util.AttributeKey;, +, +import java.util.concurrent.TimeUnit;, +, +/**, + * AbstractTrafficShapingHandler allows to limit the global bandwidth, + * (see {@link GlobalTrafficShapingHandler}) or per session, + * bandwidth (see {@link ChannelTrafficShapingHandler}), as traffic shaping., + * It allows you to implement an almost real time monitoring of the bandwidth using, + * the monitors from {@link TrafficCounter} that will call back every checkInterval, + * the method doAccounting of this handler.<br>, + * <br>, + *, + * If you want for any particular reasons to stop the monitoring (accounting) or to change, + * the read/write limit or the check interval, several methods allow that for you:<br>, + * <ul>, + * <li><tt>configure</tt> allows you to change read or write limits, or the checkInterval</li>, + * <li><tt>getTrafficCounter</tt> allows you to have access to the TrafficCounter and so to stop, + * or start the monitoring, to change the checkInterval directly, or to have access to its values.</li>, + * </ul>, + */, +public abstract class AbstractTrafficShapingHandler extends ChannelHandlerAdapter, +        implements ChannelInboundByteHandler, ChannelOutboundByteHandler {, +, +    /**, +     * Default delay between two checks: 1s, +     */, +    public static final long DEFAULT_CHECK_INTERVAL = 1000;, +, +    /**, +     * Default minimal time to wait, +     */, +    private static final long MINIMAL_WAIT = 10;, +, +    /**, +     * Traffic Counter, +     */, +    protected TrafficCounter trafficCounter;, +, +    /**, +     * Limit in B/s to apply to write, +     */, +    private long writeLimit;, +, +    /**, +     * Limit in B/s to apply to read, +     */, +    private long readLimit;, +, +    /**, +     * Delay between two performance snapshots, +     */, +    protected long checkInterval = DEFAULT_CHECK_INTERVAL; // default 1 s, +, +    private static final AttributeKey<Runnable> REOPEN_TASK = new AttributeKey<Runnable>("reopenTask");, +    private static final AttributeKey<Runnable> BUFFER_UPDATE_TASK = new AttributeKey<Runnable>("bufferUpdateTask");, +, +    /**, +     *, +     * @param newTrafficCounter the TrafficCounter to set, +     */, +    void setTrafficCounter(TrafficCounter newTrafficCounter) {, +        trafficCounter = newTrafficCounter;, +    }, +, +    /**, +     * @param writeLimit, +     *          0 or a limit in bytes/s, +     * @param readLimit, +     *          0 or a limit in bytes/s, +     * @param checkInterval, +     *          The delay between two computations of performances for, +     *            channels or 0 if no stats are to be computed, +     */]