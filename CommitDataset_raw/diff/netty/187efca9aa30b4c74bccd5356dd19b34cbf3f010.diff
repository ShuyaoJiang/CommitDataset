[+++ b/transport/src/main/java/io/netty/channel/DefaultChannelPipeline.java, +        destroyUp(head.next, false);, +    private void destroyUp(AbstractChannelHandlerContext ctx, boolean inEventLoop) {, +                destroyDown(currentThread, tail.prev, inEventLoop);, +            if (!inEventLoop && !executor.inEventLoop(currentThread)) {, +                        destroyUp(finalCtx, true);, +            inEventLoop = false;, +    private void destroyDown(Thread currentThread, AbstractChannelHandlerContext ctx, boolean inEventLoop) {, +            if (inEventLoop || executor.inEventLoop(currentThread)) {, +                        destroyDown(Thread.currentThread(), finalCtx, true);, +            inEventLoop = false;, +++ b/transport/src/main/java/io/netty/channel/DefaultChannelPipeline.java, +        destroyUp(head.next, false);, +    private void destroyUp(AbstractChannelHandlerContext ctx, boolean inEventLoop) {, +                destroyDown(currentThread, tail.prev, inEventLoop);, +            if (!inEventLoop && !executor.inEventLoop(currentThread)) {, +                        destroyUp(finalCtx, true);, +            inEventLoop = false;, +    private void destroyDown(Thread currentThread, AbstractChannelHandlerContext ctx, boolean inEventLoop) {, +            if (inEventLoop || executor.inEventLoop(currentThread)) {, +                        destroyDown(Thread.currentThread(), finalCtx, true);, +            inEventLoop = false;, +++ b/transport/src/test/java/io/netty/channel/DefaultChannelPipelineTest.java, +import io.netty.util.concurrent.AbstractEventExecutor;, +import io.netty.util.concurrent.EventExecutorGroup;, +import io.netty.util.concurrent.Future;, +import java.util.concurrent.ExecutorService;, +import java.util.concurrent.Executors;, +    @Test, +    public void testChannelUnregistrationWithCustomExecutor() throws Exception {, +        final CountDownLatch channelLatch = new CountDownLatch(1);, +        final CountDownLatch handlerLatch = new CountDownLatch(1);, +        ChannelPipeline pipeline = new LocalChannel().pipeline();, +        pipeline.addLast(new ChannelInitializer<Channel>() {, +            @Override, +            protected void initChannel(Channel ch) throws Exception {, +                ch.pipeline().addLast(new WrapperExecutor(),, +                        new ChannelInboundHandlerAdapter() {, +, +                            @Override, +                            public void channelUnregistered(ChannelHandlerContext ctx) throws Exception {, +                                channelLatch.countDown();, +                            }, +, +                            @Override, +                            public void handlerRemoved(ChannelHandlerContext ctx) throws Exception {, +                                handlerLatch.countDown();, +                            }, +                        });, +            }, +        });, +        Channel channel = pipeline.channel();, +        group.register(channel);, +        channel.close();, +        channel.deregister();, +        assertTrue(channelLatch.await(2, TimeUnit.SECONDS));, +        assertTrue(handlerLatch.await(2, TimeUnit.SECONDS));, +    }, +, +, +    private static final class WrapperExecutor extends AbstractEventExecutor {, +, +        private final ExecutorService wrapped = Executors.newSingleThreadExecutor();, +, +        @Override, +        public boolean isShuttingDown() {, +            return wrapped.isShutdown();, +        }, +, +        @Override, +        public Future<?> shutdownGracefully(long l, long l2, TimeUnit timeUnit) {, +            throw new IllegalStateException();, +        }, +, +        @Override, +        public Future<?> terminationFuture() {, +            throw new IllegalStateException();, +        }, +, +        @Override, +        public void shutdown() {, +            wrapped.shutdown();, +        }, +, +        @Override, +        public List<Runnable> shutdownNow() {, +            return wrapped.shutdownNow();, +        }, +, +        @Override, +        public boolean isShutdown() {, +            return wrapped.isShutdown();, +        }, +, +        @Override, +        public boolean isTerminated() {, +            return wrapped.isTerminated();, +        }, +, +        @Override]