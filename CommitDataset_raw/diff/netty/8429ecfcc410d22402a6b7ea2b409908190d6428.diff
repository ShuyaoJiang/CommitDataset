[+++ b/buffer/src/main/java/io/netty/buffer/PoolArena.java, +    static final int numTinySubpagePools = 512 >>> 4;, +, +    final int pageSize;, +    final int pageShifts;, +    final int chunkSize;, +    final int subpageOverflowMask;, +    final int numSmallSubpagePools;, +        tinySubpagePools = newSubpagePoolArray(numTinySubpagePools);, +        numSmallSubpagePools = pageShifts - 9;, +        smallSubpagePools = newSubpagePoolArray(numSmallSubpagePools);, +    abstract boolean isDirect();, +, +    static int tinyIdx(int normCapacity) {, +        return normCapacity >>> 4;, +    }, +, +    static int smallIdx(int normCapacity) {, +        int tableIdx = 0;, +        return tableIdx;, +    }, +, +    // capacity < pageSize, +    boolean isTinyOrSmall(int normCapacity) {, +        return (normCapacity & subpageOverflowMask) == 0;, +    }, +, +    // normCapacity < 512, +    static boolean isTiny(int normCapacity) {, +        return (normCapacity & 0xFFFFFE00) == 0;, +    }, +, +    private void allocate(PoolThreadCache cache, PooledByteBuf<T> buf, final int reqCapacity) {, +        final int normCapacity = normalizeCapacity(reqCapacity);, +        if (isTinyOrSmall(normCapacity)) { // capacity < pageSize, +            int tableIdx;, +            PoolSubpage<T>[] table;, +            if (isTiny(normCapacity)) { // < 512, +                if (cache.allocateTiny(this, buf, reqCapacity, normCapacity)) {, +                    // was able to allocate out of the cache so move on, +                    return;, +                }, +                tableIdx = tinyIdx(normCapacity);, +                table = tinySubpagePools;, +            } else {, +                if (cache.allocateSmall(this, buf, reqCapacity, normCapacity)) {, +                    // was able to allocate out of the cache so move on, +                    return;, +                }, +                tableIdx = smallIdx(normCapacity);, +        } else if (normCapacity <= chunkSize) {, +            if (cache.allocateNormal(this, buf, reqCapacity, normCapacity)) {, +                // was able to allocate out of the cache so move on, +                return;, +            }, +        } else {, +            // Huge allocations are never served via the cache so just call allocateHuge, +    void free(PoolChunk<T> chunk, long handle, int normCapacity) {, +            PoolThreadCache cache = parent.threadCache.get();, +            if (cache.add(this, chunk, handle, normCapacity)) {, +                // cached so not free it., +                return;, +            }, +        if (isTiny(elemSize)) { // < 512, +    int normalizeCapacity(int reqCapacity) {, +        if (!isTiny(reqCapacity)) { // >= 512, +        int oldMaxLength = buf.maxLength;, +            free(oldChunk, oldHandle, oldMaxLength);, +        boolean isDirect() {, +            return false;, +        }, +, +        @Override, +        boolean isDirect() {, +            return true;, +        }, +, +        @Override, +++ b/buffer/src/main/java/io/netty/buffer/PoolArena.java, +    static final int numTinySubpagePools = 512 >>> 4;, +, +    final int pageSize;, +    final int pageShifts;, +    final int chunkSize;, +    final int subpageOverflowMask;, +    final int numSmallSubpagePools;, +        tinySubpagePools = newSubpagePoolArray(numTinySubpagePools);, +        numSmallSubpagePools = pageShifts - 9;, +        smallSubpagePools = newSubpagePoolArray(numSmallSubpagePools);, +    abstract boolean isDirect();, +, +    static int tinyIdx(int normCapacity) {, +        return normCapacity >>> 4;, +    }, +, +    static int smallIdx(int normCapacity) {, +        int tableIdx = 0;, +        return tableIdx;, +    }, +]