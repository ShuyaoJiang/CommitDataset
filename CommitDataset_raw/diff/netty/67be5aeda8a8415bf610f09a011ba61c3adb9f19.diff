[+++ b/transport/src/main/java/io/netty/channel/socket/aio/AbstractAsyncChannel.java, +/*, + * Copyright 2012 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + *   http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the, + * License for the specific language governing permissions and limitations, + * under the License., + */, +package io.netty.channel.socket.aio;, +, +import io.netty.channel.AbstractChannel;, +import io.netty.channel.Channel;, +import io.netty.channel.ChannelFuture;, +import io.netty.channel.EventLoop;, +, +import java.net.ConnectException;, +import java.net.InetSocketAddress;, +import java.net.SocketAddress;, +import java.nio.channels.AsynchronousChannel;, +import java.util.concurrent.ScheduledFuture;, +import java.util.concurrent.TimeUnit;, +, +public abstract class AbstractAsyncChannel extends AbstractChannel {, +, +    protected volatile AsynchronousChannel ch;, +, +    /**, +     * The future of the current connection attempt.  If not null, subsequent, +     * connection attempts will fail., +     */, +    protected ChannelFuture connectFuture;, +    protected ScheduledFuture<?> connectTimeoutFuture;, +    private ConnectException connectTimeoutException;, +, +    protected AbstractAsyncChannel(Channel parent, Integer id) {, +        super(parent, id);, +    }, +, +, +    @Override, +    public InetSocketAddress localAddress() {, +        if (ch == null) {, +            return null;, +        }, +        return (InetSocketAddress) super.localAddress();, +    }, +, +    @Override, +    public InetSocketAddress remoteAddress() {, +        if (ch == null) {, +            return null;, +        }, +        return (InetSocketAddress) super.remoteAddress();, +    }, +, +    protected AsynchronousChannel javaChannel() {, +        return ch;, +    }, +, +, +    @Override, +    public boolean isOpen() {, +        return ch == null || ch.isOpen();, +    }, +, +    @Override, +    protected void doDeregister() throws Exception {, +        // NOOP, +    }, +, +    @Override, +    protected AsyncUnsafe newUnsafe() {, +        return new AsyncUnsafe();, +    }, +, +    @Override, +    protected boolean isCompatible(EventLoop loop) {, +        return loop instanceof AsyncChildEventLoop;, +    }, +, +    protected class AsyncUnsafe extends AbstractUnsafe {, +, +        @Override, +        public void connect(final SocketAddress remoteAddress,, +                final SocketAddress localAddress, final ChannelFuture future) {, +            if (eventLoop().inEventLoop()) {, +                if (!ensureOpen(future)) {, +                    return;, +                }, +, +                try {, +                    if (connectFuture != null) {]