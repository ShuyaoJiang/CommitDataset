[+++ b/handler/src/main/java/io/netty/handler/ssl/SslHandler.java, +import java.util.Arrays;, +                            throw new IllegalStateException(, +                                    "Unknown handshake status: " + result.getHandshakeStatus());, +                            unwrapNonApp(ctx);, +                            unwrapNonApp(ctx);, +, +        // Keeps the list of the length of every SSL record in the input buffer., +        int[] recordLengths = null;, +        int nRecords = 0;, +, +                recordLengths = new int[4];, +                recordLengths[0] = packetLength;, +                nRecords = 1;, +, +            // We have a whole packet., +            // Remember the length of the current packet., +            if (recordLengths == null) {, +                recordLengths = new int[4];, +            }, +            if (nRecords == recordLengths.length) {, +                recordLengths = Arrays.copyOf(recordLengths, recordLengths.length << 1);, +            }, +            recordLengths[nRecords ++] = packetLength;, +, +            // Increment the offset to handle the next packet., +        final int totalLength = offset - startOffset;, +        if (totalLength > 0) {, +            in.skipBytes(totalLength);, +            ByteBuffer buffer = in.nioBuffer(startOffset, totalLength);, +            unwrapMultiple(ctx, buffer, totalLength, recordLengths, nRecords, out);, +    /**, +     * Calls {@link SSLEngine#unwrap(ByteBuffer, ByteBuffer)} with an empty buffer to handle handshakes, etc., +     */, +    private void unwrapNonApp(ChannelHandlerContext ctx) throws SSLException {, +            unwrapSingle(ctx, Unpooled.EMPTY_BUFFER.nioBuffer(), 0);, +            ByteBuf decodeOut = this.decodeOut;, +            if (decodeOut != null && decodeOut.isReadable()) {, +                this.decodeOut = null;, +                ctx.fireChannelRead(decodeOut);, +            }, +    /**, +     * Unwraps multiple inbound SSL records., +     */, +    private void unwrapMultiple(, +            ChannelHandlerContext ctx, ByteBuffer packet, int totalLength,, +            int[] recordLengths, int nRecords, List<Object> out) throws SSLException {, +, +        for (int i = 0; i < nRecords; i ++) {, +            packet.limit(packet.position() + recordLengths[i]);, +            try {, +                unwrapSingle(ctx, packet, totalLength);, +                assert !packet.hasRemaining();, +            } finally {, +                ByteBuf decodeOut = this.decodeOut;, +                if (decodeOut != null && decodeOut.isReadable()) {, +                    this.decodeOut = null;, +                    out.add(decodeOut);, +                }, +            }, +        }, +    }, +, +    /**, +     * Unwraps a single SSL record., +     */, +    private void unwrapSingle(, +            ChannelHandlerContext ctx, ByteBuffer packet, int initialOutAppBufCapacity) throws SSLException {, +, +                    decodeOut = ctx.alloc().buffer(initialOutAppBufCapacity);]