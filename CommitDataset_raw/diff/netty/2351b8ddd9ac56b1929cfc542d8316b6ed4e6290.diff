[+++ b/buffer/src/main/java/io/netty/buffer/FixedCompositeByteBuf.java, +/*, + * Copyright 2013 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + *   http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the, + * License for the specific language governing permissions and limitations, + * under the License., + */, +package io.netty.buffer;, +, +import io.netty.util.internal.EmptyArrays;, +import io.netty.util.internal.RecyclableArrayList;, +, +import java.io.IOException;, +import java.io.InputStream;, +import java.io.OutputStream;, +import java.nio.ByteBuffer;, +import java.nio.ByteOrder;, +import java.nio.ReadOnlyBufferException;, +import java.nio.channels.GatheringByteChannel;, +import java.nio.channels.ScatteringByteChannel;, +import java.util.Collections;, +, +/**, + * {@link ByteBuf} implementation which allows to wrap an array of {@link ByteBuf} in a read-only mode., + * This is useful to write an array of {@link ByteBuf}s., + */, +final class FixedCompositeByteBuf extends AbstractReferenceCountedByteBuf {, +    private static final ByteBuf[] EMPTY = { Unpooled.EMPTY_BUFFER };, +    private final int nioBufferCount;, +    private final int capacity;, +    private final ByteBufAllocator allocator;, +    private final ByteOrder order;, +    private final Object[] buffers;, +    private final boolean direct;, +, +    public FixedCompositeByteBuf(ByteBufAllocator allocator, ByteBuf... buffers) {, +        super(Integer.MAX_VALUE);, +        if (buffers.length == 0) {, +            this.buffers = EMPTY;, +            order = ByteOrder.BIG_ENDIAN;, +            nioBufferCount = 1;, +            capacity = 0;, +            direct = buffers[0].isDirect();, +        } else {, +            ByteBuf b = buffers[0];, +            this.buffers = new Object[buffers.length];, +            this.buffers[0] = b;, +            boolean direct = true;, +            int nioBufferCount = b.nioBufferCount();, +            int capacity = b.readableBytes();, +            order = b.order();, +            for (int i = 1; i < buffers.length; i++) {, +                b = buffers[i];, +                if (buffers[i].order() != order) {, +                    throw new IllegalArgumentException("All ByteBufs need to have same ByteOrder");, +                }, +                nioBufferCount += b.nioBufferCount();, +                capacity += b.readableBytes();, +                if (!b.isDirect()) {, +                    direct = false;, +                }, +                this.buffers[i] = b;, +            }, +            this.nioBufferCount = nioBufferCount;, +            this.capacity = capacity;, +            this.direct = direct;, +        }, +        setIndex(0, capacity());, +        this.allocator = allocator;, +    }, +, +    @Override, +    public boolean isWritable() {, +        return false;, +    }, +, +    @Override, +    public boolean isWritable(int size) {, +        return false;, +    }, +, +    @Override, +    public ByteBuf discardReadBytes() {, +        throw new ReadOnlyBufferException();, +    }, +, +    @Override, +    public ByteBuf setBytes(int index, ByteBuf src, int srcIndex, int length) {, +        throw new ReadOnlyBufferException();, +    }, +]