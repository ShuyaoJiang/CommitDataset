[+++ b/handler/src/main/java/io/netty/handler/ssl/ReferenceCountedOpenSslEngine.java, +import static javax.net.ssl.SSLEngineResult.Status.BUFFER_UNDERFLOW;, +    private int writeEncryptedData(final ByteBuffer src, int len) {, +                int newLimit = pos + len;, +                if (newLimit != src.remaining()) {, +                    buf.setBytes(0, (ByteBuffer) src.duplicate().position(pos).limit(newLimit));, +                } else {, +                }, +            if (dst.remaining() < MAX_ENCRYPTED_PACKET_LENGTH) {, +                // Can not hold the maximum packet so we need to tell the caller to use a bigger destination, +                // buffer., +                return new SSLEngineResult(BUFFER_OVERFLOW, getHandshakeStatus(), 0, 0);, +            }, +            if (len < SslUtils.SSL_RECORD_HEADER_LENGTH) {, +                return new SSLEngineResult(BUFFER_UNDERFLOW, getHandshakeStatus(), 0, 0);, +            }, +, +            int packetLength = SslUtils.getEncryptedPacketLength(srcs, srcsOffset);, +            if (packetLength - SslUtils.SSL_RECORD_HEADER_LENGTH > capacity) {, +                // No enough space in the destination buffer so signal the caller, +                // that the buffer needs to be increased., +                return new SSLEngineResult(BUFFER_OVERFLOW, getHandshakeStatus(), 0, 0);, +            }, +, +            if (len < packetLength) {, +                // We either have no enough data to read the packet length at all or not enough for reading, +                // the whole packet., +                return new SSLEngineResult(BUFFER_UNDERFLOW, getHandshakeStatus(), 0, 0);, +            }, +, +, +                // Write encrypted data to network BIO, +                int packetLengthRemaining = packetLength;, +, +                    // Write more encrypted data into the BIO. Ensure we only read one packet at a time as, +                    // stated in the SSLEngine javadocs., +                    int written = writeEncryptedData(src, Math.min(packetLengthRemaining, src.remaining()));, +                        packetLengthRemaining -= written;, +                        if (packetLengthRemaining == 0) {, +                            // A whole packet has been consumed., +                            break;, +                        }, +                bytesConsumed = packetLength - packetLengthRemaining;, +++ b/handler/src/main/java/io/netty/handler/ssl/ReferenceCountedOpenSslEngine.java, +import static javax.net.ssl.SSLEngineResult.Status.BUFFER_UNDERFLOW;, +    private int writeEncryptedData(final ByteBuffer src, int len) {, +                int newLimit = pos + len;, +                if (newLimit != src.remaining()) {, +                    buf.setBytes(0, (ByteBuffer) src.duplicate().position(pos).limit(newLimit));, +                } else {, +                }, +            if (dst.remaining() < MAX_ENCRYPTED_PACKET_LENGTH) {, +                // Can not hold the maximum packet so we need to tell the caller to use a bigger destination, +                // buffer., +                return new SSLEngineResult(BUFFER_OVERFLOW, getHandshakeStatus(), 0, 0);, +            }, +            if (len < SslUtils.SSL_RECORD_HEADER_LENGTH) {, +                return new SSLEngineResult(BUFFER_UNDERFLOW, getHandshakeStatus(), 0, 0);, +            }, +, +            int packetLength = SslUtils.getEncryptedPacketLength(srcs, srcsOffset);, +            if (packetLength - SslUtils.SSL_RECORD_HEADER_LENGTH > capacity) {, +                // No enough space in the destination buffer so signal the caller, +                // that the buffer needs to be increased., +                return new SSLEngineResult(BUFFER_OVERFLOW, getHandshakeStatus(), 0, 0);, +            }, +, +            if (len < packetLength) {, +                // We either have no enough data to read the packet length at all or not enough for reading, +                // the whole packet., +                return new SSLEngineResult(BUFFER_UNDERFLOW, getHandshakeStatus(), 0, 0);, +            }, +, +, +                // Write encrypted data to network BIO, +                int packetLengthRemaining = packetLength;, +, +                    // Write more encrypted data into the BIO. Ensure we only read one packet at a time as, +                    // stated in the SSLEngine javadocs., +                    int written = writeEncryptedData(src, Math.min(packetLengthRemaining, src.remaining()));, +                        packetLengthRemaining -= written;, +                        if (packetLengthRemaining == 0) {, +                            // A whole packet has been consumed., +                            break;, +                        }, +                bytesConsumed = packetLength - packetLengthRemaining;, +++ b/handler/src/main/java/io/netty/handler/ssl/SslHandler.java, +                    out = allocateOutNetBuf(ctx);, +                    out = allocateOutNetBuf(ctx);, +    private ByteBuf allocateOutNetBuf(ChannelHandlerContext ctx) {, +++ b/handler/src/main/java/io/netty/handler/ssl/ReferenceCountedOpenSslEngine.java, +import static javax.net.ssl.SSLEngineResult.Status.BUFFER_UNDERFLOW;, +    private int writeEncryptedData(final ByteBuffer src, int len) {, +                int newLimit = pos + len;, +                if (newLimit != src.remaining()) {, +                    buf.setBytes(0, (ByteBuffer) src.duplicate().position(pos).limit(newLimit));, +                } else {, +                }, +            if (dst.remaining() < MAX_ENCRYPTED_PACKET_LENGTH) {, +                // Can not hold the maximum packet so we need to tell the caller to use a bigger destination]