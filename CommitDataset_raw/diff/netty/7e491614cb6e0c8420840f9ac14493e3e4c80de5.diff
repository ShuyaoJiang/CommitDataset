[+++ b/src/main/java/org/jboss/netty/channel/socket/nio/DefaultReceiveBufferSizePredictor.java, + * <p>, + * It doubles the expected number of readable bytes if the previous read, + * filled the allocated buffer.  It halves the expected number of readable, + * bytes if the read operation was not able to fill a quarter of the allocated, + * buffer two times consecutively.  Otherwise, it keeps returning the previous, + * prediction., +    /**, +     * Creates a new predictor with the default parameters.  With the default, +     * parameters, the expected buffer size starts from {@code 1024}, doesn't, +     * go down below {@code 256}, and doesn't go up above {@code 1048576}., +     */, +    /**, +     * Creates a new predictor with the specified parameters., +     *, +     * @param minimum  the inclusive lower bound of the expected buffer size, +     * @param initial  the initial buffer size when no feed back was received, +     * @param maximum  the inclusive upper bound of the expected buffer size, +     */, +        } else if (previousReceiveBufferSize >= nextReceiveBufferSize) {, +++ b/src/main/java/org/jboss/netty/channel/socket/nio/DefaultReceiveBufferSizePredictor.java, + * <p>, + * It doubles the expected number of readable bytes if the previous read, + * filled the allocated buffer.  It halves the expected number of readable, + * bytes if the read operation was not able to fill a quarter of the allocated, + * buffer two times consecutively.  Otherwise, it keeps returning the previous, + * prediction., +    /**, +     * Creates a new predictor with the default parameters.  With the default, +     * parameters, the expected buffer size starts from {@code 1024}, doesn't, +     * go down below {@code 256}, and doesn't go up above {@code 1048576}., +     */, +    /**, +     * Creates a new predictor with the specified parameters., +     *, +     * @param minimum  the inclusive lower bound of the expected buffer size, +     * @param initial  the initial buffer size when no feed back was received, +     * @param maximum  the inclusive upper bound of the expected buffer size, +     */, +        } else if (previousReceiveBufferSize >= nextReceiveBufferSize) {, +++ b/src/main/java/org/jboss/netty/channel/socket/nio/NioClientSocketChannelFactory.java, +import java.nio.channels.Selector;, +import java.util.concurrent.ExecutorService;, +import java.util.concurrent.Executors;, +import java.util.concurrent.RejectedExecutionException;, +import java.util.concurrent.TimeUnit;, +import org.jboss.netty.channel.Channel;, + * A {@link ClientSocketChannelFactory} which creates a client-side NIO-based, + * {@link SocketChannel}.  It utilizes the non-blocking I/O mode which was, + * introduced with NIO to serve many number of concurrent connections, + * efficiently., + *, + * <h3>How threads work</h3>, + * <p>, + * There are two types of threads in a {@link NioClientSocketChannelFactory};, + * one is boss thread and the other is worker thread., + *, + * <h4>Boss thread</h4>, + * <p>, + * One {@link NioClientSocketChannelFactory} has one boss thread.  It makes, + * a connection attempt on request.  Once a connection attempt succeeds,, + * the boss thread passes the connected {@link Channel} to one of the worker, + * threads that the {@link NioClientSocketChannelFactory} manages., + *, + * <h4>Worker threads</h4>, + * <p>, + * One {@link NioClientSocketChannelFactory} can have one or more worker, + * threads.  A worker thread performs non-blocking read and write for one or, + * more {@link Channel}s on request., + *, + * <h3>Life cycle of threads and graceful shutdown</h3>, + * <p>, + * All threads are acquired from the {@link Executor}s which were specified, + * when a {@link NioClientSocketChannelFactory} is created.  A boss thread is, + * acquired from the {@code bossExecutor}, and worker threads are acquired from, + * the {@code workerExecutor}.  Therefore, you should make sure the specified, + * {@link Executor}s are able to lend the sufficient number of threads., + * It is the best bet to specify {@linkplain Executors#newCachedThreadPool() a cached thread pool}., + * <p>, + * Both boss and worker threads are acquired lazily, and then released when, + * there's nothing left to process.  All the related resources such as, + * {@link Selector} are also released when the boss and worker threads are, + * released.  Therefore, to shut down a service gracefully, you should do the, + * following:, + *, + * <ol>, + * <li>close all channels created by the factory,</li>, + * <li>call {@link ExecutorService#shutdown()} for all executors which were, + *     specified to create the factory, and</li>, + * <li>call {@link ExecutorService#awaitTermination(long, TimeUnit)}, + *     until it returns {@code true}.</li>, + * </ol>, + *, + * Please make sure not to shut down the executor until all channels are, + * closed.  Otherwise, you will end up with a {@link RejectedExecutionException}, + * and the related resources might not be released properly., +    /**, +     * Creates a new instance.  Calling this constructor is same with calling, +     * {@link #NioClientSocketChannelFactory(Executor, Executor, int)} with, +     * the number of available processors in the machine.  The number of]