[+++ b/src/main/java/org/jboss/netty/util/LinkedTransferQueue.java, + * An unbounded <tt>TransferQueue</tt> based on linked nodes., + * {@code LinkedTransferQueue}, + * <a href="package-summary.html#MemoryVisibility"><i>happen-before</i></a>, + * actions subsequent to the access or removal of that element from, + * the {@code LinkedTransferQueue} in another thread., +     * The main extension is to provide different Wait modes for the, +     * main "xfer" method that puts or takes items.  These don't, +     * impact the basic dual-queue logic, but instead control whether, +     * or how threads block upon insertion of request or data nodes, +     * into the dual queue. It also uses slightly different, +     * conventions for tracking whether nodes are off-list or, +     * cancelled., +     * faster since they don't need to check times on each spin., +     * Node class for LinkedTransferQueue. Opportunistically, +     * subclasses from AtomicReference to represent item. Uses Object,, +     * not E, to allow setting item to "this" after use, to avoid, +     * garbage retention. Similarly, setting the next field to this is, +     * used as sentinel that node is off list., +        volatile Thread waiter;       // to control park/unpark, +     * poll() and tryTransfer()). See the similar code in, +     * SynchronousQueue for detailed explanation., +        final PaddedAtomicReference<QNode> head = this.head;, +        final PaddedAtomicReference<QNode> tail = this.tail;, +        final PaddedAtomicReference<QNode> head = this.head;, +        final PaddedAtomicReference<QNode> tail = this.tail;, +                if (x == s) {              // was cancelled, +                    clean(pred, s);, +                    return null;, +                else if (x != null) {, +                    s.set(s);             // avoid garbage retention, +                    return x;, +                } else {, +                    return e;, +            }, +     * Returns validated tail for use in cleaning methods, +    private QNode getValidatedTail() {, +        for (;;) {, +            QNode h = head.get();, +            QNode first = h.next;, +            if (first != null && first.next == first) { // help advance, +                advanceHead(h, first);, +                continue;, +            }, +            QNode t = tail.get();, +            QNode last = t.next;, +            if (t == tail.get()) {, +                if (last != null) {, +                    tail.compareAndSet(t, last); // help advance, +                } else {, +                    return t;, +                }, +            }, +        }, +    }, +, +    /**, +     * Gets rid of cancelled node s with original predecessor pred., +     * @param pred predecessor of cancelled node, +     * @param s the cancelled node, +     */, +    void clean(QNode pred, QNode s) {, +        /*, +         * At any given time, exactly one node on list cannot be, +         * deleted -- the last inserted node. To accommodate this, if, +         * we cannot delete s, we save its predecessor as "cleanMe",, +         * processing the previously saved version first. At least one, +         * of node s or the node previously saved can always be, +         * processed, so this always terminates., +         */, +        while (pred.next == s) {, +            QNode oldpred = reclean();  // First, help get rid of cleanMe, +            QNode t = getValidatedTail();, +                QNode sn = s.next;      // s.next == s means s already off list, +                    break;, +                }, +            }, +            else if (oldpred == pred || // Already saved, +                     oldpred == null && cleanMe.compareAndSet(null, pred)) {, +                break;                  // Postpone cleaning, +            }, +    /**, +     * Tries to unsplice the cancelled node held in cleanMe that was, +     * previously uncleanable because it was at tail., +     * @return current cleanMe node (or null), +     */, +    private QNode reclean() {, +        /*, +         * cleanMe is, or at one time was, predecessor of cancelled, +         * node s that was the tail so could not be unspliced.  If s, +         * is no longer the tail, try to unsplice if necessary and, +         * make cleanMe slot available.  This differs from similar, +         * code in clean() because we must check that pred still, +         * points to a cancelled node that must be unspliced -- if, +         * not, we can (must) clear cleanMe without unsplicing., +         * This can loop only due to contention on casNext or, +         * clearing cleanMe., +         */, +        QNode pred;, +        while ((pred = cleanMe.get()) != null) {]