[+++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollSocketChannel.java, +        Executor closeExecutor = ((EpollSocketChannelUnsafe) unsafe()).prepareToClose();, +        protected Executor prepareToClose() {, +                    // We need to cancel this key of the channel so we may not end up in a eventloop spin, +                    // because we try to read or write until the actual close happens which may be later due, +                    // SO_LINGER handling., +                    // See https://github.com/netty/netty/issues/4449, +                    ((EpollEventLoop) eventLoop()).remove(EpollSocketChannel.this);, +++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollSocketChannel.java, +        Executor closeExecutor = ((EpollSocketChannelUnsafe) unsafe()).prepareToClose();, +        protected Executor prepareToClose() {, +                    // We need to cancel this key of the channel so we may not end up in a eventloop spin, +                    // because we try to read or write until the actual close happens which may be later due, +                    // SO_LINGER handling., +                    // See https://github.com/netty/netty/issues/4449, +                    ((EpollEventLoop) eventLoop()).remove(EpollSocketChannel.this);, +++ b/transport/src/main/java/io/netty/channel/AbstractChannel.java, +            Executor closeExecutor = prepareToClose();, +         * Prepares to close the {@link Channel}. If this method returns an {@link Executor}, the, +         * caller must call the {@link Executor#execute(Runnable)} method with a task that calls, +         * {@link #doClose()} on the returned {@link Executor}. If this method returns {@code null},, +         * {@link #doClose()} must be called from the caller thread. (i.e. {@link EventLoop}), +        protected Executor prepareToClose() {, +++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollSocketChannel.java, +        Executor closeExecutor = ((EpollSocketChannelUnsafe) unsafe()).prepareToClose();, +        protected Executor prepareToClose() {, +                    // We need to cancel this key of the channel so we may not end up in a eventloop spin, +                    // because we try to read or write until the actual close happens which may be later due, +                    // SO_LINGER handling., +                    // See https://github.com/netty/netty/issues/4449, +                    ((EpollEventLoop) eventLoop()).remove(EpollSocketChannel.this);, +++ b/transport/src/main/java/io/netty/channel/AbstractChannel.java, +            Executor closeExecutor = prepareToClose();, +         * Prepares to close the {@link Channel}. If this method returns an {@link Executor}, the, +         * caller must call the {@link Executor#execute(Runnable)} method with a task that calls, +         * {@link #doClose()} on the returned {@link Executor}. If this method returns {@code null},, +         * {@link #doClose()} must be called from the caller thread. (i.e. {@link EventLoop}), +        protected Executor prepareToClose() {, +++ b/transport/src/main/java/io/netty/channel/socket/nio/NioSocketChannel.java, +        Executor closeExecutor = ((NioSocketChannelUnsafe) unsafe()).prepareToClose();, +        protected Executor prepareToClose() {, +                    // We need to cancel this key of the channel so we may not end up in a eventloop spin, +                    // because we try to read or write until the actual close happens which may be later due, +                    // SO_LINGER handling., +                    // See https://github.com/netty/netty/issues/4449, +                    doDeregister();]