[+++ b/src/main/java/org/jboss/netty/channel/group/ChannelGroup.java, +import org.jboss.netty.buffer.ChannelBuffer;, +import org.jboss.netty.channel.ServerChannel;, + * A thread-safe {@link Set} that contains open {@link Channel}s and provides, + * various bulk operations on them.  Using {@link ChannelGroup}, you can, + * categorize {@link Channel}s into a meaningful group (e.g. on a per-service, + * or per-state basis.)  A closed {@link Channel} is automatically removed from, + * the collection, so that you don't need to worry about the life cycle of the, + * added {@link Channel}.  A {@link Channel} can belong to more than one, + * {@link ChannelGroup}., + *, + * <h3>Simplify shutdown process with {@link ChannelGroup}</h3>, + * <p>, + * If both {@link ServerChannel}s and non-{@link ServerChannel}s exists in the, + * same {@link ChannelGroup}, any requested I/O operations on the group are, + * performed for the {@link ServerChannel}s first and then for the others., + * <p>, + * This rule is very useful when you shut down a server in one shot:, + *, + * <pre>, + * ChannelGroup allChannels = new DefaultChannelGroup();, + *, + * public static void main(String[] args) throws Exception {, + *     ServerBootstrap b = new ServerBootstrap(..);, + *     ..., + *, + *     // Start the server, + *     b.getPipeline().addLast("handler", new MyHandler());, + *     Channel serverChannel = b.bind(..);, + *, + *     ... Wait until the shutdown signal reception ..., + *, + *     // Close the serverChannel and then all accepted connections., + *     allChannels.close().awaitUninterruptibly();, + *     b.releaseExternalResources();, + * }, + *, + * public class MyHandler extends SimpleChannelUpstreamHandler {, + *     public void channelOpen(ChannelHandlerContext ctx, ChannelStateEvent e) {, + *         // Add all open channels to the global group so that they are, + *         // closed on shutdown., + *         allChannels.add(e.getChannel());, + *     }, + * }, + * </pre>, + *, +, +    /**, +     * Returns the name of this group.  A group name is purely for helping, +     * you to distinguish one group from others., +     */, +, +    /**, +     * Returns the {@link Channel} whose ID matches the specified integer., +     *, +     * @return the matching {@link Channel} if found. {@code null} otherwise., +     */, +, +    /**, +     * Calls {@link Channel#setInterestOps(int)} for all {@link Channel}s in, +     * this group with the specified {@code interestOps}. Please note that, +     * this operation is asynchronous as {@link Channel#setInterestOps(int)} is., +     *, +     * @return the {@link ChannelGroupFuture} instance that notifies when, +     *         the operation is done for all channels, +     */, +, +    /**, +     * Calls {@link Channel#setReadable(boolean)} for all {@link Channel}s in, +     * this group with the specified boolean flag. Please note that this, +     * operation is asynchronous as {@link Channel#setReadable(boolean)} is., +     *, +     * @return the {@link ChannelGroupFuture} instance that notifies when, +     *         the operation is done for all channels, +     */, +, +    /**, +     * Writes the specified {@code message} to all {@link Channel}s in this, +     * group. If the specified {@code message} is an instance of, +     * {@link ChannelBuffer}, it is automatically, +     * {@linkplain ChannelBuffer#duplicate() duplicated} to avoid a race, +     * condition. Please note that this operation is asynchronous as, +     * {@link Channel#write(Object)} is., +     *, +     * @return the {@link ChannelGroupFuture} instance that notifies when, +     *         the operation is done for all channels, +     */, +, +    /**, +     * Writes the specified {@code message} with the specified, +     * {@code remoteAddress} to all {@link Channel}s in this group.  If the, +     * specified {@code message} is an instance of {@link ChannelBuffer}, it is, +     * automatically {@linkplain ChannelBuffer#duplicate() duplicated} to avoid, +     * a race condition. Please note that this operation is asynchronous as, +     * {@link Channel#write(Object, SocketAddress)} is., +     *, +     * @return the {@link ChannelGroupFuture} instance that notifies when, +     *         the operation is done for all channels, +     */, +]