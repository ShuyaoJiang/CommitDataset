[+++ b/NOTICE.txt, +This product contains a modified portion of Nitsan Wakart's 'JCTools', Java Concurrency Tools for the JVM,, + which can be obtained at:, +, +  * LICENSE:, +    * license/LICENSE.jctools.txt (ASL2 License), +  * HOMEPAGE:, +    * https://github.com/JCTools/JCTools, +, +++ b/NOTICE.txt, +This product contains a modified portion of Nitsan Wakart's 'JCTools', Java Concurrency Tools for the JVM,, + which can be obtained at:, +, +  * LICENSE:, +    * license/LICENSE.jctools.txt (ASL2 License), +  * HOMEPAGE:, +    * https://github.com/JCTools/JCTools, +, +++ b/buffer/src/main/java/io/netty/buffer/PoolArena.java, +    void free(PoolChunk<T> chunk, long handle, int normCapacity, PoolThreadCache cache) {, +            if (cache != null && cache.add(this, chunk, handle, normCapacity, sizeClass)) {, +, +            free(oldChunk, oldHandle, oldMaxLength, buf.cache);, +++ b/NOTICE.txt, +This product contains a modified portion of Nitsan Wakart's 'JCTools', Java Concurrency Tools for the JVM,, + which can be obtained at:, +, +  * LICENSE:, +    * license/LICENSE.jctools.txt (ASL2 License), +  * HOMEPAGE:, +    * https://github.com/JCTools/JCTools, +, +++ b/buffer/src/main/java/io/netty/buffer/PoolArena.java, +    void free(PoolChunk<T> chunk, long handle, int normCapacity, PoolThreadCache cache) {, +            if (cache != null && cache.add(this, chunk, handle, normCapacity, sizeClass)) {, +, +            free(oldChunk, oldHandle, oldMaxLength, buf.cache);, +++ b/buffer/src/main/java/io/netty/buffer/PoolChunk.java, +            buf.init(this, handle, runOffset(memoryMapIdx), reqCapacity, runLength(memoryMapIdx),, +                     arena.parent.threadCache());, +            runOffset(memoryMapIdx) + (bitmapIdx & 0x3FFFFFFF) * subpage.elemSize, reqCapacity, subpage.elemSize,, +            arena.parent.threadCache());, +++ b/NOTICE.txt, +This product contains a modified portion of Nitsan Wakart's 'JCTools', Java Concurrency Tools for the JVM,, + which can be obtained at:, +, +  * LICENSE:, +    * license/LICENSE.jctools.txt (ASL2 License), +  * HOMEPAGE:, +    * https://github.com/JCTools/JCTools, +, +++ b/buffer/src/main/java/io/netty/buffer/PoolArena.java, +    void free(PoolChunk<T> chunk, long handle, int normCapacity, PoolThreadCache cache) {, +            if (cache != null && cache.add(this, chunk, handle, normCapacity, sizeClass)) {, +, +            free(oldChunk, oldHandle, oldMaxLength, buf.cache);, +++ b/buffer/src/main/java/io/netty/buffer/PoolChunk.java, +            buf.init(this, handle, runOffset(memoryMapIdx), reqCapacity, runLength(memoryMapIdx),, +                     arena.parent.threadCache());, +            runOffset(memoryMapIdx) + (bitmapIdx & 0x3FFFFFFF) * subpage.elemSize, reqCapacity, subpage.elemSize,, +            arena.parent.threadCache());, +++ b/buffer/src/main/java/io/netty/buffer/PoolThreadCache.java, +import io.netty.util.Recycler;, +import io.netty.util.Recycler.Handle;, +import io.netty.util.internal.PlatformDependent;, +import java.util.Queue;, +    private static <T> MemoryRegionCache<T>[] createSubPageCaches(, +            MemoryRegionCache<T>[] cache = new MemoryRegionCache[numCaches];, +    private static <T> MemoryRegionCache<T>[] createNormalCaches(, +            MemoryRegionCache<T>[] cache = new MemoryRegionCache[arraySize];, +        private final int size;, +        private final Queue<Entry<T>> queue;, +        private int allocations;, +            this.size = powerOfTwo(size);, +            queue = PlatformDependent.newFixedMpscQueue(this.size);, +        @SuppressWarnings("unchecked"), +        public final boolean add(PoolChunk<T> chunk, long handle) {, +            return queue.offer(newEntry(chunk, handle));, +        public final boolean allocate(PooledByteBuf<T> buf, int reqCapacity) {, +            Entry<T> entry = queue.poll();, +            if (entry == null) {, +, +            // allocations is not thread-safe which is fine as this is only called from the same thread all time., +            ++ allocations;, +        public final int free() {, +            return free(Integer.MAX_VALUE);, +        }, +, +        private int free(int max) {, +            for (; numFreed < max; numFreed++) {, +                Entry<T> entry = queue.poll();, +                if (entry != null) {, +                    freeEntry(entry);, +            return numFreed;, +        public final void trim() {, +            int free = size - allocations;, +            allocations = 0;, +            // We not even allocated all the number that are, +            if (free > 0) {, +                free(free);]