[+++ b/codec/src/main/java/io/netty/handler/codec/compression/Bzip2BitReader.java, + * arbitrary length (up to 32 bits), and bit aligned 32-bit integers. A single byte, +     * Maximum count of possible readable bytes to check., +     */, +    private static final int MAX_COUNT_OF_READABLE_BYTES = Integer.MAX_VALUE >>> 3;, +, +    /**, +     * The {@link ByteBuf} from which to read data., +     */, +    private ByteBuf in;, +, +    /**, +    private long bitBuffer;, +     * Set the {@link ByteBuf} from which to read data., +     */, +    void setByteBuf(ByteBuf in) {, +        this.in = in;, +    }, +, +    /**, +     * Reads up to 32 bits from the {@link ByteBuf}., +     * @param count The number of bits to read (maximum {@code 32} as a size of {@code int}), +    int readBits(final int count) {, +        if (count < 0 || count > 32) {, +            throw new IllegalArgumentException("count: " + count + " (expected: 0-32 )");, +        long bitBuffer = this.bitBuffer;, +            long readData;, +            int offset;, +            switch (in.readableBytes()) {, +                case 1: {, +                    readData = in.readUnsignedByte();, +                    offset = 8;, +                    break;, +                }, +                case 2: {, +                    readData = in.readUnsignedShort();, +                    offset = 16;, +                    break;, +                }, +                case 3: {, +                    readData = in.readUnsignedMedium();, +                    offset = 24;, +                    break;, +                }, +                default: {, +                    readData = in.readUnsignedInt();, +                    offset = 32;, +                    break;, +                }, +            }, +            bitBuffer = bitBuffer << offset | readData;, +            bitCount += offset;, +        return (int) (bitBuffer >>> bitCount & (count != 32 ? (1 << count) - 1 : 0xFFFFFFFFL));, +    boolean readBoolean() {, +        return readBits(1) != 0;, +    int readInt() {, +        return readBits(32);, +    }, +, +    /**, +     * Refill the {@link ByteBuf} by one byte., +     */, +    void refill() {, +        int readData = in.readUnsignedByte();, +        bitBuffer = bitBuffer << 8 | readData;, +        bitCount += 8;, +    boolean isReadable() {, +, +    /**, +     * Checks that the specified number of bits available for reading., +     * @param count The number of bits to check, +     * @return {@code true} if {@code count} bits are available for reading, otherwise {@code false}, +     */, +    boolean hasReadableBits(int count) {, +        if (count < 0) {, +            throw new IllegalArgumentException("count: " + count + " (expected value greater than 0)");, +        }, +        return bitCount >= count || (in.readableBytes() << 3 & Integer.MAX_VALUE) >= count - bitCount;, +    }, +, +    /**, +     * Checks that the specified number of bytes available for reading., +     * @param count The number of bytes to check, +     * @return {@code true} if {@code count} bytes are available for reading, otherwise {@code false}, +     */, +    boolean hasReadableBytes(int count) {, +        if (count < 0 || count > MAX_COUNT_OF_READABLE_BYTES) {, +            throw new IllegalArgumentException("count: " + count, +                    + " (expected: 0-" + MAX_COUNT_OF_READABLE_BYTES + ')');, +        }, +        return hasReadableBits(count << 3);, +    }, +++ b/codec/src/main/java/io/netty/handler/codec/compression/Bzip2BitReader.java, + * arbitrary length (up to 32 bits), and bit aligned 32-bit integers. A single byte, +     * Maximum count of possible readable bytes to check., +     */, +    private static final int MAX_COUNT_OF_READABLE_BYTES = Integer.MAX_VALUE >>> 3;, +, +    /**, +     * The {@link ByteBuf} from which to read data.]