[+++ b/buffer/src/main/java/io/netty/buffer/ByteBufUtil.java, +     * identical to each other for {@code length} bytes starting at {@code aStartIndex}, +     * index for the {@code a} buffer and {@code bStartIndex} index for the {@code b} buffer., +     * A more compact way to express this is:, +     * <p>, +     * {@code a[aStartIndex : aStartIndex + length] == b[bStartIndex : bStartIndex + length]}, +     */, +    public static boolean equals(ByteBuf a, int aStartIndex, ByteBuf b, int bStartIndex, int length) {, +        if (aStartIndex < 0 || bStartIndex < 0 || length < 0) {, +            throw new IllegalArgumentException("All indexes and lengths must be non-negative");, +        }, +        if (a.writerIndex() - length < aStartIndex || b.writerIndex() - length < bStartIndex) {, +            return false;, +        }, +, +        final int longCount = length >>> 3;, +        final int byteCount = length & 7;, +, +        if (a.order() == b.order()) {, +            for (int i = longCount; i > 0; i --) {, +                if (a.getLong(aStartIndex) != b.getLong(bStartIndex)) {, +                    return false;, +                }, +                aStartIndex += 8;, +                bStartIndex += 8;, +            }, +        } else {, +            for (int i = longCount; i > 0; i --) {, +                if (a.getLong(aStartIndex) != swapLong(b.getLong(bStartIndex))) {, +                    return false;, +                }, +                aStartIndex += 8;, +                bStartIndex += 8;, +            }, +        }, +, +        for (int i = byteCount; i > 0; i --) {, +            if (a.getByte(aStartIndex) != b.getByte(bStartIndex)) {, +                return false;, +            }, +            aStartIndex ++;, +            bStartIndex ++;, +        }, +, +        return true;, +    }, +, +    /**, +     * Returns {@code true} if and only if the two specified buffers are, +     * identical to each other as described in {@link ByteBuf#equals(Object)}., +        return equals(bufferA, bufferA.readerIndex(), bufferB, bufferB.readerIndex(), aLen);, +++ b/buffer/src/main/java/io/netty/buffer/ByteBufUtil.java, +     * identical to each other for {@code length} bytes starting at {@code aStartIndex}, +     * index for the {@code a} buffer and {@code bStartIndex} index for the {@code b} buffer., +     * A more compact way to express this is:, +     * <p>, +     * {@code a[aStartIndex : aStartIndex + length] == b[bStartIndex : bStartIndex + length]}, +     */, +    public static boolean equals(ByteBuf a, int aStartIndex, ByteBuf b, int bStartIndex, int length) {, +        if (aStartIndex < 0 || bStartIndex < 0 || length < 0) {, +            throw new IllegalArgumentException("All indexes and lengths must be non-negative");, +        }, +        if (a.writerIndex() - length < aStartIndex || b.writerIndex() - length < bStartIndex) {, +            return false;, +        }, +, +        final int longCount = length >>> 3;, +        final int byteCount = length & 7;, +, +        if (a.order() == b.order()) {, +            for (int i = longCount; i > 0; i --) {, +                if (a.getLong(aStartIndex) != b.getLong(bStartIndex)) {, +                    return false;, +                }, +                aStartIndex += 8;, +                bStartIndex += 8;, +            }, +        } else {, +            for (int i = longCount; i > 0; i --) {, +                if (a.getLong(aStartIndex) != swapLong(b.getLong(bStartIndex))) {, +                    return false;, +                }, +                aStartIndex += 8;, +                bStartIndex += 8;, +            }, +        }, +, +        for (int i = byteCount; i > 0; i --) {, +            if (a.getByte(aStartIndex) != b.getByte(bStartIndex)) {, +                return false;, +            }, +            aStartIndex ++;, +            bStartIndex ++;, +        }, +, +        return true;, +    }, +, +    /**, +     * Returns {@code true} if and only if the two specified buffers are]