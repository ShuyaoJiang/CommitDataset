[+++ b/handler/src/main/java/io/netty/handler/timeout/IdleStateHandler.java, +    private long lastFlushProgress;, +                lastFlushProgress = buf.currentProgress();, +, +                long flushProgress = buf.currentProgress();, +                if (flushProgress != lastFlushProgress) {, +                    lastFlushProgress = flushProgress;, +, +                    if (!first) {, +                        return true;, +                    }, +                }, +++ b/handler/src/main/java/io/netty/handler/timeout/IdleStateHandler.java, +    private long lastFlushProgress;, +                lastFlushProgress = buf.currentProgress();, +, +                long flushProgress = buf.currentProgress();, +                if (flushProgress != lastFlushProgress) {, +                    lastFlushProgress = flushProgress;, +, +                    if (!first) {, +                        return true;, +                    }, +                }, +++ b/handler/src/test/java/io/netty/handler/timeout/IdleStateHandlerTest.java, +            channel.writeAndFlush(Unpooled.wrappedBuffer(new byte[5 * 1024]));, +            // Consume part of the message every 2 seconds, then be idle for 1 seconds,, +            // then run the task and we should get an IdleStateEvent because the first trigger, +            idleStateHandler.tick(2L, TimeUnit.SECONDS);, +            assertNotNullAndRelease(channel.consumePart(1024));, +            idleStateHandler.tick(2L, TimeUnit.SECONDS);, +            assertNotNullAndRelease(channel.consumePart(1024));, +            idleStateHandler.tickRun(1L, TimeUnit.SECONDS);, +            assertEquals(1, events.size());, +            assertEquals(31L, idleStateHandler.tick(TimeUnit.SECONDS)); // 26s + 2s + 2s + 1s, +            events.clear();, +, +            // Consume part of the message every 2 seconds, then be idle for 1 seconds,, +            // then consume all the rest of the message, then run the task and we shouldn't, +            // get an IdleStateEvent because the data is flowing and we haven't been idle for long enough!, +            idleStateHandler.tick(2L, TimeUnit.SECONDS);, +            assertNotNullAndRelease(channel.consumePart(1024));, +            idleStateHandler.tick(2L, TimeUnit.SECONDS);, +            assertNotNullAndRelease(channel.consumePart(1024));, +            idleStateHandler.tickRun(1L, TimeUnit.SECONDS);, +            assertEquals(0, events.size());, +            assertEquals(36L, idleStateHandler.tick(TimeUnit.SECONDS)); // 31s + 2s + 2s + 1s, +            idleStateHandler.tick(2L, TimeUnit.SECONDS);, +            assertNotNullAndRelease(channel.consumePart(1024));, +, +            assertEquals(43L, idleStateHandler.tick(TimeUnit.SECONDS)); // 36s + 2s + 3s + 2s, +        private Object consume() {, +, +        /**, +         * Consume the part of a message., +         *, +         * @param byteCount count of byte to be consumed, +         * @return the message currently being consumed, +         */, +        private Object consumePart(int byteCount) {, +            ChannelOutboundBuffer buf = unsafe().outboundBuffer();, +            if (buf != null) {, +                Object msg = buf.current();, +                if (msg != null) {, +                    ReferenceCountUtil.retain(msg);, +                    buf.removeBytes(byteCount);, +                    return msg;, +                }, +            }, +            return null;, +        }, +++ b/handler/src/main/java/io/netty/handler/timeout/IdleStateHandler.java, +    private long lastFlushProgress;, +                lastFlushProgress = buf.currentProgress();, +, +                long flushProgress = buf.currentProgress();, +                if (flushProgress != lastFlushProgress) {, +                    lastFlushProgress = flushProgress;, +, +                    if (!first) {, +                        return true;, +                    }, +                }, +++ b/handler/src/test/java/io/netty/handler/timeout/IdleStateHandlerTest.java, +            channel.writeAndFlush(Unpooled.wrappedBuffer(new byte[5 * 1024]));, +            // Consume part of the message every 2 seconds, then be idle for 1 seconds,, +            // then run the task and we should get an IdleStateEvent because the first trigger, +            idleStateHandler.tick(2L, TimeUnit.SECONDS);, +            assertNotNullAndRelease(channel.consumePart(1024));, +            idleStateHandler.tick(2L, TimeUnit.SECONDS);, +            assertNotNullAndRelease(channel.consumePart(1024));, +            idleStateHandler.tickRun(1L, TimeUnit.SECONDS);, +            assertEquals(1, events.size());, +            assertEquals(31L, idleStateHandler.tick(TimeUnit.SECONDS)); // 26s + 2s + 2s + 1s, +            events.clear();, +, +            // Consume part of the message every 2 seconds, then be idle for 1 seconds,, +            // then consume all the rest of the message, then run the task and we shouldn't, +            // get an IdleStateEvent because the data is flowing and we haven't been idle for long enough!, +            idleStateHandler.tick(2L, TimeUnit.SECONDS);]