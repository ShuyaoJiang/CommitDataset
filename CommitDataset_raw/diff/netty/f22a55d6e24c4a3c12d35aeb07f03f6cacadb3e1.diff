[+++ b/src/main/java/org/jboss/netty/example/uptime/UptimeClient.java, +import org.jboss.netty.channel.ChannelHandler;, +, +            private final ChannelHandler timeoutHandler =, +                new ReadTimeoutHandler(timer, READ_TIMEOUT);, +            private final ChannelHandler uptimeHandler =, +                new UptimeClientHandler(bootstrap, timer);, +, +                        timeoutHandler, uptimeHandler);, +++ b/src/main/java/org/jboss/netty/example/uptime/UptimeClient.java, +import org.jboss.netty.channel.ChannelHandler;, +, +            private final ChannelHandler timeoutHandler =, +                new ReadTimeoutHandler(timer, READ_TIMEOUT);, +            private final ChannelHandler uptimeHandler =, +                new UptimeClientHandler(bootstrap, timer);, +, +                        timeoutHandler, uptimeHandler);, +++ b/src/main/java/org/jboss/netty/example/uptime/UptimeClientHandler.java, +    private long startTime = -1;, +++ b/src/main/java/org/jboss/netty/example/uptime/UptimeClient.java, +import org.jboss.netty.channel.ChannelHandler;, +, +            private final ChannelHandler timeoutHandler =, +                new ReadTimeoutHandler(timer, READ_TIMEOUT);, +            private final ChannelHandler uptimeHandler =, +                new UptimeClientHandler(bootstrap, timer);, +, +                        timeoutHandler, uptimeHandler);, +++ b/src/main/java/org/jboss/netty/example/uptime/UptimeClientHandler.java, +    private long startTime = -1;, +++ b/src/main/java/org/jboss/netty/handler/timeout/ReadTimeoutHandler.java, +import org.jboss.netty.channel.ChannelHandler;, +import org.jboss.netty.channel.ChannelHandler.Sharable;, + *     private final {@link ChannelHandler} timeoutHandler;, + *         this.timeoutHandler = <b>new {@link ReadTimeoutHandler}(timer, 30), // timer must be shared.</b>, + *             timeoutHandler,, +@Sharable, +        destroy(ctx);, +        destroy(ctx);, +        updateLastReadTime(ctx);, +        updateLastReadTime(ctx);, +            State state = (State) ctx.getAttachment();, +            state.timeout = timer.newTimeout(new ReadTimeoutTask(ctx), timeoutMillis, TimeUnit.MILLISECONDS);, +    private void updateLastReadTime(ChannelHandlerContext ctx) {, +        State state = (State) ctx.getAttachment();, +        if (state == null) {, +            // lastReadTime will be set by the constructor, so we do not do it, +            // again here., +            ctx.setAttachment(state = new State());, +        } else {, +            state.lastReadTime = System.currentTimeMillis();, +        }, +    private void destroy(ChannelHandlerContext ctx) {, +        State state = (State) ctx.getAttachment();, +        if (state.timeout != null) {, +            state.timeout.cancel();, +            state.timeout = null;, +            State state = (State) ctx.getAttachment();, +            long nextDelay = timeoutMillis - (currentTime - state.lastReadTime);, +                state.timeout =, +                    // FIXME This should be called from an I/O thread., +                    //       To be fixed in Netty 4., +                state.timeout =, +, +    private static final class State {, +        volatile Timeout timeout;, +        volatile long lastReadTime = System.currentTimeMillis();, +, +        State() {, +            super();, +        }, +    }]