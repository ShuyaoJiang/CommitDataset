[+++ b/src/main/java/org/jboss/netty/channel/socket/nio/DefaultReceiveBufferSizePredictor.java, +import java.util.ArrayList;, +import java.util.List;, +, + * It gradually increases the expected number of readable bytes if the, + * previous read filled the allocated buffer.  It gradually decreases the, + * expected number of readable bytes if the read operation was not able to, + * fill a certain amount of the allocated buffer two times consecutively., + * Otherwise, it keeps returning the previous prediction., +, +    private static final int INDEX_INCREMENT = 4;, +    private static final int INDEX_DECREMENT = 1;, +, +    private static final int[] SIZE_TABLE;, +, +    static {, +        List<Integer> sizeTable = new ArrayList<Integer>();, +        for (int i = 1; i <= 8; i ++) {, +            sizeTable.add(i);, +        }, +, +        for (int i = 4; i < 32; i ++) {, +            long v = 1L << i;, +            long inc = v >>> 4;, +            v -= inc << 3;, +, +            for (int j = 0; j < 8; j ++) {, +                v += inc;, +                if (v > Integer.MAX_VALUE) {, +                    sizeTable.add(Integer.MAX_VALUE);, +                } else {, +                    sizeTable.add((int) v);, +                }, +            }, +        }, +, +        SIZE_TABLE = new int[sizeTable.size()];, +        for (int i = 0; i < SIZE_TABLE.length; i ++) {, +            SIZE_TABLE[i] = sizeTable.get(i);, +        }, +    }, +, +    private static int getSizeTableIndex(final int size) {, +        if (size <= 16) {, +            return size - 1;, +        }, +, +        int bits = 0;, +        int v = size;, +        do {, +            v >>>= 1;, +            bits ++;, +        } while (v != 0);, +, +        final int baseIdx = bits << 3;, +        final int startIdx = baseIdx - 18;, +        final int endIdx = baseIdx - 25;, +, +        for (int i = startIdx; i >= endIdx; i --) {, +            if (size >= SIZE_TABLE[i]) {, +                return i;, +            }, +        }, +, +        throw new Error("shouldn't reach here; please file a bug report.");, +    }, +, +    private static final int DEFAULT_MINIMUM = 64;, +    private final int minIndex;, +    private final int maxIndex;, +    private int index;, +    private int nextReceiveBufferSize;, +    private boolean decreaseNow;, +     * go down below {@code 64}, and doesn't go up above {@code 65536}., +, +        int minIndex = getSizeTableIndex(minimum);, +        if (SIZE_TABLE[minIndex] < minimum) {, +            this.minIndex = minIndex + 1;, +        } else {, +            this.minIndex = minIndex;, +        }, +, +        int maxIndex = getSizeTableIndex(maximum);, +        if (SIZE_TABLE[maxIndex] > maximum) {, +            this.maxIndex = maxIndex - 1;, +        } else {, +            this.maxIndex = maxIndex;, +        }, +, +        index = getSizeTableIndex(initial);, +        nextReceiveBufferSize = SIZE_TABLE[index];, +        if (previousReceiveBufferSize <= SIZE_TABLE[Math.max(0, index - 2)]) {, +            if (decreaseNow) {, +                index = Math.max(index - INDEX_DECREMENT, minIndex);, +                nextReceiveBufferSize = SIZE_TABLE[index];, +                decreaseNow = false;, +                decreaseNow = true;, +            index = Math.min(index + INDEX_INCREMENT, maxIndex);, +            nextReceiveBufferSize = SIZE_TABLE[index];, +            decreaseNow = false;]