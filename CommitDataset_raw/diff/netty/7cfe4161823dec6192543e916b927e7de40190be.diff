[+++ b/common/src/main/java/io/netty/util/internal/PlatformDependent.java, +import org.jctools.queues.MpscUnboundedArrayQueue;, +import org.jctools.queues.atomic.MpscGrowableAtomicArrayQueue;, +import org.jctools.queues.atomic.MpscUnboundedAtomicArrayQueue;, +import static java.lang.Math.max;, +import static java.lang.Math.min;, +            final int capacity = max(min(maxCapacity, MAX_ALLOWED_MPSC_CAPACITY), MIN_MAX_MPSC_CAPACITY);, +            return USE_MPSC_CHUNKED_ARRAY_QUEUE ? new MpscChunkedArrayQueue<T>(MPSC_CHUNK_SIZE, capacity), +                                                : new MpscGrowableAtomicArrayQueue<T>(MPSC_CHUNK_SIZE, capacity);, +, +        static <T> Queue<T> newMpscQueue() {, +            return USE_MPSC_CHUNKED_ARRAY_QUEUE ? new MpscUnboundedArrayQueue<T>(MPSC_CHUNK_SIZE), +                                                : new MpscUnboundedAtomicArrayQueue<T>(MPSC_CHUNK_SIZE);, +     * @return A MPSC queue which may be unbounded., +        return Mpsc.newMpscQueue();, +++ b/common/src/main/java/io/netty/util/internal/PlatformDependent.java, +import org.jctools.queues.MpscUnboundedArrayQueue;, +import org.jctools.queues.atomic.MpscGrowableAtomicArrayQueue;, +import org.jctools.queues.atomic.MpscUnboundedAtomicArrayQueue;, +import static java.lang.Math.max;, +import static java.lang.Math.min;, +            final int capacity = max(min(maxCapacity, MAX_ALLOWED_MPSC_CAPACITY), MIN_MAX_MPSC_CAPACITY);, +            return USE_MPSC_CHUNKED_ARRAY_QUEUE ? new MpscChunkedArrayQueue<T>(MPSC_CHUNK_SIZE, capacity), +                                                : new MpscGrowableAtomicArrayQueue<T>(MPSC_CHUNK_SIZE, capacity);, +, +        static <T> Queue<T> newMpscQueue() {, +            return USE_MPSC_CHUNKED_ARRAY_QUEUE ? new MpscUnboundedArrayQueue<T>(MPSC_CHUNK_SIZE), +                                                : new MpscUnboundedAtomicArrayQueue<T>(MPSC_CHUNK_SIZE);, +     * @return A MPSC queue which may be unbounded., +        return Mpsc.newMpscQueue();, +++ b/pom.xml, +        <version>2.0.2</version>, +++ b/common/src/main/java/io/netty/util/internal/PlatformDependent.java, +import org.jctools.queues.MpscUnboundedArrayQueue;, +import org.jctools.queues.atomic.MpscGrowableAtomicArrayQueue;, +import org.jctools.queues.atomic.MpscUnboundedAtomicArrayQueue;, +import static java.lang.Math.max;, +import static java.lang.Math.min;, +            final int capacity = max(min(maxCapacity, MAX_ALLOWED_MPSC_CAPACITY), MIN_MAX_MPSC_CAPACITY);, +            return USE_MPSC_CHUNKED_ARRAY_QUEUE ? new MpscChunkedArrayQueue<T>(MPSC_CHUNK_SIZE, capacity), +                                                : new MpscGrowableAtomicArrayQueue<T>(MPSC_CHUNK_SIZE, capacity);, +, +        static <T> Queue<T> newMpscQueue() {, +            return USE_MPSC_CHUNKED_ARRAY_QUEUE ? new MpscUnboundedArrayQueue<T>(MPSC_CHUNK_SIZE), +                                                : new MpscUnboundedAtomicArrayQueue<T>(MPSC_CHUNK_SIZE);, +     * @return A MPSC queue which may be unbounded., +        return Mpsc.newMpscQueue();, +++ b/pom.xml, +        <version>2.0.2</version>, +++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollEventLoop.java, +        return maxPendingTasks == Integer.MAX_VALUE ? PlatformDependent.<Runnable>newMpscQueue(), +                                                    : PlatformDependent.<Runnable>newMpscQueue(maxPendingTasks);, +++ b/common/src/main/java/io/netty/util/internal/PlatformDependent.java, +import org.jctools.queues.MpscUnboundedArrayQueue;, +import org.jctools.queues.atomic.MpscGrowableAtomicArrayQueue;, +import org.jctools.queues.atomic.MpscUnboundedAtomicArrayQueue;, +import static java.lang.Math.max;, +import static java.lang.Math.min;, +            final int capacity = max(min(maxCapacity, MAX_ALLOWED_MPSC_CAPACITY), MIN_MAX_MPSC_CAPACITY);, +            return USE_MPSC_CHUNKED_ARRAY_QUEUE ? new MpscChunkedArrayQueue<T>(MPSC_CHUNK_SIZE, capacity), +                                                : new MpscGrowableAtomicArrayQueue<T>(MPSC_CHUNK_SIZE, capacity);, +, +        static <T> Queue<T> newMpscQueue() {, +            return USE_MPSC_CHUNKED_ARRAY_QUEUE ? new MpscUnboundedArrayQueue<T>(MPSC_CHUNK_SIZE), +                                                : new MpscUnboundedAtomicArrayQueue<T>(MPSC_CHUNK_SIZE);, +     * @return A MPSC queue which may be unbounded., +        return Mpsc.newMpscQueue();, +++ b/pom.xml, +        <version>2.0.2</version>, +++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollEventLoop.java, +        return maxPendingTasks == Integer.MAX_VALUE ? PlatformDependent.<Runnable>newMpscQueue(), +                                                    : PlatformDependent.<Runnable>newMpscQueue(maxPendingTasks);, +++ b/transport-native-kqueue/src/main/java/io/netty/channel/kqueue/KQueueEventLoop.java, +        return maxPendingTasks == Integer.MAX_VALUE ? PlatformDependent.<Runnable>newMpscQueue(), +                                                    : PlatformDependent.<Runnable>newMpscQueue(maxPendingTasks);, +++ b/common/src/main/java/io/netty/util/internal/PlatformDependent.java, +import org.jctools.queues.MpscUnboundedArrayQueue;, +import org.jctools.queues.atomic.MpscGrowableAtomicArrayQueue;, +import org.jctools.queues.atomic.MpscUnboundedAtomicArrayQueue;, +import static java.lang.Math.max;, +import static java.lang.Math.min;, +            final int capacity = max(min(maxCapacity, MAX_ALLOWED_MPSC_CAPACITY), MIN_MAX_MPSC_CAPACITY);, +            return USE_MPSC_CHUNKED_ARRAY_QUEUE ? new MpscChunkedArrayQueue<T>(MPSC_CHUNK_SIZE, capacity), +                                                : new MpscGrowableAtomicArrayQueue<T>(MPSC_CHUNK_SIZE, capacity);, +, +        static <T> Queue<T> newMpscQueue() {, +            return USE_MPSC_CHUNKED_ARRAY_QUEUE ? new MpscUnboundedArrayQueue<T>(MPSC_CHUNK_SIZE), +                                                : new MpscUnboundedAtomicArrayQueue<T>(MPSC_CHUNK_SIZE);, +     * @return A MPSC queue which may be unbounded., +        return Mpsc.newMpscQueue();, +++ b/pom.xml, +        <version>2.0.2</version>, +++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollEventLoop.java, +        return maxPendingTasks == Integer.MAX_VALUE ? PlatformDependent.<Runnable>newMpscQueue(), +                                                    : PlatformDependent.<Runnable>newMpscQueue(maxPendingTasks);, +++ b/transport-native-kqueue/src/main/java/io/netty/channel/kqueue/KQueueEventLoop.java, +        return maxPendingTasks == Integer.MAX_VALUE ? PlatformDependent.<Runnable>newMpscQueue(), +                                                    : PlatformDependent.<Runnable>newMpscQueue(maxPendingTasks);, +++ b/transport/src/main/java/io/netty/channel/nio/NioEventLoop.java, +        return maxPendingTasks == Integer.MAX_VALUE ? PlatformDependent.<Runnable>newMpscQueue()]