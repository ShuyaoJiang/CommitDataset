[+++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHttpDecoder.java, +import io.netty.buffer.ByteBufAllocator;, +import io.netty.util.ReferenceCountUtil;, +    @Override, +    public void channelInactive(ChannelHandlerContext ctx) throws Exception {, +        // Release any outstanding messages from the map, +        for (Map.Entry<Integer, FullHttpMessage> entry : messageMap.entrySet()) {, +            ReferenceCountUtil.safeRelease(entry.getValue());, +        }, +        messageMap.clear();, +        super.channelInactive(ctx);, +    }, +, +                    FullHttpRequest httpRequestWithEntity = createHttpRequest(spdySynStreamFrame, ctx.alloc());, +                } catch (Throwable ignored) {, +                    FullHttpRequest httpRequestWithEntity = createHttpRequest(spdySynStreamFrame, ctx.alloc());, +                } catch (Throwable t) {, +                FullHttpResponse httpResponseWithEntity =, +                   createHttpResponse(spdySynReplyFrame, ctx.alloc(), validateHeaders);, +            } catch (Throwable t) {, +                        fullHttpMessage = createHttpResponse(spdyHeadersFrame, ctx.alloc(), validateHeaders);, +                    } catch (Throwable t) {, +    private static FullHttpRequest createHttpRequest(SpdyHeadersFrame requestFrame, ByteBufAllocator alloc), +        boolean release = true;, +        ByteBuf buffer = alloc.buffer();, +        try {, +            FullHttpRequest req = new DefaultFullHttpRequest(httpVersion, method, url, buffer);, +            release = false;, +        } finally {, +            if (release) {, +                buffer.release();, +            }, +        }, +    private static FullHttpResponse createHttpResponse(SpdyHeadersFrame responseFrame, ByteBufAllocator alloc,, +        boolean release = true;, +        ByteBuf buffer = alloc.buffer();, +        try {, +            FullHttpResponse res = new DefaultFullHttpResponse(version, status, buffer, validateHeaders);, +            release = false;, +        } finally {, +            if (release) {, +                buffer.release();, +            }, +        }, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHttpDecoder.java, +import io.netty.buffer.ByteBufAllocator;, +import io.netty.util.ReferenceCountUtil;, +    @Override, +    public void channelInactive(ChannelHandlerContext ctx) throws Exception {, +        // Release any outstanding messages from the map, +        for (Map.Entry<Integer, FullHttpMessage> entry : messageMap.entrySet()) {, +            ReferenceCountUtil.safeRelease(entry.getValue());, +        }, +        messageMap.clear();, +        super.channelInactive(ctx);, +    }, +, +                    FullHttpRequest httpRequestWithEntity = createHttpRequest(spdySynStreamFrame, ctx.alloc());, +                } catch (Throwable ignored) {, +                    FullHttpRequest httpRequestWithEntity = createHttpRequest(spdySynStreamFrame, ctx.alloc());, +                } catch (Throwable t) {, +                FullHttpResponse httpResponseWithEntity =, +                   createHttpResponse(spdySynReplyFrame, ctx.alloc(), validateHeaders);, +            } catch (Throwable t) {, +                        fullHttpMessage = createHttpResponse(spdyHeadersFrame, ctx.alloc(), validateHeaders);, +                    } catch (Throwable t) {, +    private static FullHttpRequest createHttpRequest(SpdyHeadersFrame requestFrame, ByteBufAllocator alloc), +        boolean release = true;, +        ByteBuf buffer = alloc.buffer();, +        try {, +            FullHttpRequest req = new DefaultFullHttpRequest(httpVersion, method, url, buffer);, +            release = false;, +        } finally {, +            if (release) {, +                buffer.release();, +            }, +        }, +    private static FullHttpResponse createHttpResponse(SpdyHeadersFrame responseFrame, ByteBufAllocator alloc,, +        boolean release = true;, +        ByteBuf buffer = alloc.buffer();, +        try {, +            FullHttpResponse res = new DefaultFullHttpResponse(version, status, buffer, validateHeaders);, +            release = false;, +        } finally {, +            if (release) {, +                buffer.release();, +            }, +        }, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/HttpConversionUtil.java, +import io.netty.buffer.ByteBufAllocator;, +     * @param alloc The {@link ByteBufAllocator} to use to generate the content of the message, +    public static FullHttpResponse toHttpResponse(int streamId, Http2Headers http2Headers, ByteBufAllocator alloc,, +                                                  boolean validateHttpHeaders), +        FullHttpResponse msg = new DefaultFullHttpResponse(HttpVersion.HTTP_1_1, status, alloc.buffer(),, +                                                           validateHttpHeaders);, +     * @param alloc The {@link ByteBufAllocator} to use to generate the content of the message, +    public static FullHttpRequest toHttpRequest(int streamId, Http2Headers http2Headers, ByteBufAllocator alloc,, +                                                boolean validateHttpHeaders), +                        .toString()), path.toString(), alloc.buffer(), validateHttpHeaders);, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHttpDecoder.java]