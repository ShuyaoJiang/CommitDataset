[+++ b/transport/src/main/java/io/netty/channel/AbstractChannel.java, +                        invokeLater(new Runnable() {, +                            @Override, +                            public void run() {, +                        });, +                    }, +                        invokeLater(new Runnable() {, +                            @Override, +                            public void run() {, +                        });, +                    }, +                        invokeLater(new Runnable() {, +                            @Override, +                            public void run() {, +                            }, +                        });, +                } catch (final Exception e) {, +                    invokeLater(new Runnable() {, +                        @Override, +                        public void run() {, +                            pipeline.fireExceptionCaught(e);, +                        }, +                    });, +                    // Flush immediately only when there's no pending flush., +                    // If there's a pending flush operation, event loop will call flushNow() later,, +                    // and thus there's no need to call it now., +, +        private void invokeLater(Runnable task) {, +            // This method is used by outbound operation implementations to trigger an inbound event later., +            // They do not trigger an inbound event immediately because an outbound operation might have been, +            // triggered by another inbound event handler method.  If fired immediately, the call stack, +            // will look like this for example:, +            //, +            //   handlerA.inboundBufferUpdated() - (1) an inbound handler method closes a connection., +            //   -> handlerA.ctx.close(), +            //      -> channel.unsafe.close(), +            //         -> handlerA.channelInactive() - (2) another inbound handler method called while in (1) yet, +            //, +            // which means the execution of two inbound handler methods of the same handler overlap undesirably., +            eventLoop().execute(task);, +        }, +++ b/transport/src/main/java/io/netty/channel/AbstractChannel.java, +                        invokeLater(new Runnable() {, +                            @Override, +                            public void run() {, +                        });, +                    }, +                        invokeLater(new Runnable() {, +                            @Override, +                            public void run() {, +                        });, +                    }, +                        invokeLater(new Runnable() {, +                            @Override, +                            public void run() {, +                            }, +                        });, +                } catch (final Exception e) {, +                    invokeLater(new Runnable() {, +                        @Override, +                        public void run() {, +                            pipeline.fireExceptionCaught(e);, +                        }, +                    });, +                    // Flush immediately only when there's no pending flush., +                    // If there's a pending flush operation, event loop will call flushNow() later,, +                    // and thus there's no need to call it now., +, +        private void invokeLater(Runnable task) {, +            // This method is used by outbound operation implementations to trigger an inbound event later., +            // They do not trigger an inbound event immediately because an outbound operation might have been, +            // triggered by another inbound event handler method.  If fired immediately, the call stack, +            // will look like this for example:, +            //, +            //   handlerA.inboundBufferUpdated() - (1) an inbound handler method closes a connection., +            //   -> handlerA.ctx.close(), +            //      -> channel.unsafe.close(), +            //         -> handlerA.channelInactive() - (2) another inbound handler method called while in (1) yet, +            //, +            // which means the execution of two inbound handler methods of the same handler overlap undesirably., +            eventLoop().execute(task);, +        }, +++ b/transport/src/main/java/io/netty/channel/DefaultChannelHandlerContext.java, +import io.netty.util.concurrent.Future;, +import io.netty.util.internal.PlatformDependent;, +import java.util.concurrent.ExecutionException;, +        EventExecutor executor = executor();, +        if (executor.inEventLoop()) {, +        } else {, +            Future<?> f = executor.submit(new Runnable() {, +                @Override, +                public void run() {, +                    initHeadHandler();, +                }, +            });, +, +            boolean interrupted = false;, +            try {, +                while (!f.isDone()) {, +                    try {]