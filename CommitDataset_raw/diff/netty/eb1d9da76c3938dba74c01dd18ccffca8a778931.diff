[+++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslContext.java, +                // We need to enable SSL_MODE_ACCEPT_MOVING_WRITE_BUFFER as the memory address may change between, +                // calling OpenSSLEngine.wrap(...)., +                // See https://github.com/netty/netty-tcnative/issues/100, +                SSLContext.setMode(ctx, SSLContext.getMode(ctx) | SSL.SSL_MODE_ACCEPT_MOVING_WRITE_BUFFER);, +, +++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslContext.java, +                // We need to enable SSL_MODE_ACCEPT_MOVING_WRITE_BUFFER as the memory address may change between, +                // calling OpenSSLEngine.wrap(...)., +                // See https://github.com/netty/netty-tcnative/issues/100, +                SSLContext.setMode(ctx, SSLContext.getMode(ctx) | SSL.SSL_MODE_ACCEPT_MOVING_WRITE_BUFFER);, +, +++ b/handler/src/test/java/io/netty/handler/ssl/OpenSslEngineTest.java, +import io.netty.buffer.UnpooledByteBufAllocator;, +import io.netty.handler.ssl.util.InsecureTrustManagerFactory;, +import io.netty.handler.ssl.util.SelfSignedCertificate;, +import io.netty.util.internal.ThreadLocalRandom;, +import javax.net.ssl.SSLEngine;, +import javax.net.ssl.SSLEngineResult;, +import java.nio.ByteBuffer;, +, +import static org.junit.Assert.assertSame;, +    @Test, +    public void testWrapHeapBuffersNoWritePendingError() throws Exception {, +        assumeTrue(OpenSsl.isAvailable());, +        final SslContext clientContext = SslContextBuilder.forClient(), +                .trustManager(InsecureTrustManagerFactory.INSTANCE), +                .sslProvider(sslProvider()), +                .build();, +        SelfSignedCertificate ssc = new SelfSignedCertificate();, +        SslContext serverContext = SslContextBuilder.forServer(ssc.certificate(), ssc.privateKey()), +                .sslProvider(sslProvider()), +                .build();, +        SSLEngine clientEngine = clientContext.newEngine(UnpooledByteBufAllocator.DEFAULT);, +        SSLEngine serverEngine = serverContext.newEngine(UnpooledByteBufAllocator.DEFAULT);, +        handshake(clientEngine, serverEngine);, +, +        ByteBuffer src = ByteBuffer.allocate(1024 * 10);, +        ThreadLocalRandom.current().nextBytes(src.array());, +        ByteBuffer dst = ByteBuffer.allocate(1);, +        // Try to wrap multiple times so we are more likely to hit the issue., +        for (int i = 0; i < 100; i++) {, +            src.position(0);, +            dst.position(0);, +            assertSame(SSLEngineResult.Status.BUFFER_OVERFLOW, clientEngine.wrap(src, dst).getStatus());, +        }, +    }, +, +++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslContext.java, +                // We need to enable SSL_MODE_ACCEPT_MOVING_WRITE_BUFFER as the memory address may change between, +                // calling OpenSSLEngine.wrap(...)., +                // See https://github.com/netty/netty-tcnative/issues/100, +                SSLContext.setMode(ctx, SSLContext.getMode(ctx) | SSL.SSL_MODE_ACCEPT_MOVING_WRITE_BUFFER);, +, +++ b/handler/src/test/java/io/netty/handler/ssl/OpenSslEngineTest.java, +import io.netty.buffer.UnpooledByteBufAllocator;, +import io.netty.handler.ssl.util.InsecureTrustManagerFactory;, +import io.netty.handler.ssl.util.SelfSignedCertificate;, +import io.netty.util.internal.ThreadLocalRandom;, +import javax.net.ssl.SSLEngine;, +import javax.net.ssl.SSLEngineResult;, +import java.nio.ByteBuffer;, +, +import static org.junit.Assert.assertSame;, +    @Test, +    public void testWrapHeapBuffersNoWritePendingError() throws Exception {, +        assumeTrue(OpenSsl.isAvailable());, +        final SslContext clientContext = SslContextBuilder.forClient(), +                .trustManager(InsecureTrustManagerFactory.INSTANCE), +                .sslProvider(sslProvider()), +                .build();, +        SelfSignedCertificate ssc = new SelfSignedCertificate();, +        SslContext serverContext = SslContextBuilder.forServer(ssc.certificate(), ssc.privateKey()), +                .sslProvider(sslProvider()), +                .build();, +        SSLEngine clientEngine = clientContext.newEngine(UnpooledByteBufAllocator.DEFAULT);, +        SSLEngine serverEngine = serverContext.newEngine(UnpooledByteBufAllocator.DEFAULT);, +        handshake(clientEngine, serverEngine);, +, +        ByteBuffer src = ByteBuffer.allocate(1024 * 10);, +        ThreadLocalRandom.current().nextBytes(src.array());, +        ByteBuffer dst = ByteBuffer.allocate(1);, +        // Try to wrap multiple times so we are more likely to hit the issue., +        for (int i = 0; i < 100; i++) {, +            src.position(0);, +            dst.position(0);, +            assertSame(SSLEngineResult.Status.BUFFER_OVERFLOW, clientEngine.wrap(src, dst).getStatus());, +        }, +    }, +, +++ b/handler/src/test/java/io/netty/handler/ssl/SSLEngineTest.java, +    protected static void handshake(SSLEngine clientEngine, SSLEngine serverEngine) throws SSLException {]