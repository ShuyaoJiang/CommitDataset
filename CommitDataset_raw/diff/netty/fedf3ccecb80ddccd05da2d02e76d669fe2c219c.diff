[+++ b/buffer/src/main/java/io/netty/buffer/AbstractReferenceCountedByteBuf.java, +    // even => "real" refcount is (refCnt >>> 1); odd => "real" refcount is 0, +    @SuppressWarnings("unused"), +    private volatile int refCnt = 2;, +    private static int realRefCnt(int rawCnt) {, +        return (rawCnt & 1) != 0 ? 0 : rawCnt >>> 1;, +    }, +, +    private int nonVolatileRawCnt() {, +        // TODO: Once we compile against later versions of Java we can replace the Unsafe usage here by varhandles., +        return REFCNT_FIELD_OFFSET != -1 ? PlatformDependent.getInt(this, REFCNT_FIELD_OFFSET), +                : refCntUpdater.get(this);, +    }, +, +        return realRefCnt(nonVolatileRawCnt());, +        return realRefCnt(refCntUpdater.get(this));, +    protected final void setRefCnt(int newRefCnt) {, +        refCntUpdater.set(this, newRefCnt << 1); // overflow OK here, +        // all changes to the raw count are 2x the "real" change, +        int adjustedIncrement = increment << 1; // overflow OK here, +        int oldRef = refCntUpdater.getAndAdd(this, adjustedIncrement);, +        if ((oldRef & 1) != 0) {, +            throw new IllegalReferenceCountException(0, increment);, +        }, +        // don't pass 0!, +        if ((oldRef <= 0 && oldRef + adjustedIncrement >= 0), +                || (oldRef >= 0 && oldRef + adjustedIncrement < oldRef)) {, +            // overflow case, +            refCntUpdater.getAndAdd(this, -adjustedIncrement);, +            throw new IllegalReferenceCountException(realRefCnt(oldRef), increment);, +        int rawCnt = nonVolatileRawCnt(), realCnt = toLiveRealCnt(rawCnt, decrement);, +        if (decrement == realCnt) {, +            if (refCntUpdater.compareAndSet(this, rawCnt, 1)) {, +            return retryRelease0(decrement);, +        return releaseNonFinal0(decrement, rawCnt, realCnt);, +    }, +, +    private boolean releaseNonFinal0(int decrement, int rawCnt, int realCnt) {, +        if (decrement < realCnt, +                // all changes to the raw count are 2x the "real" change, +                && refCntUpdater.compareAndSet(this, rawCnt, rawCnt - (decrement << 1))) {, +        return retryRelease0(decrement);, +    }, +, +    private boolean retryRelease0(int decrement) {, +        for (;;) {, +            int rawCnt = refCntUpdater.get(this), realCnt = toLiveRealCnt(rawCnt, decrement);, +            if (decrement == realCnt) {, +                if (refCntUpdater.compareAndSet(this, rawCnt, 1)) {, +                    deallocate();, +                    return true;, +                }, +            } else if (decrement < realCnt) {, +                // all changes to the raw count are 2x the "real" change, +                if (refCntUpdater.compareAndSet(this, rawCnt, rawCnt - (decrement << 1))) {, +                    return false;, +                }, +            } else {, +                throw new IllegalReferenceCountException(realCnt, -decrement);, +            }, +            Thread.yield(); // this benefits throughput under high contention, +        }, +    }, +, +    /**, +     * Like {@link #realRefCnt(int)} but throws if refCnt == 0, +     */, +    private static int toLiveRealCnt(int rawCnt, int decrement) {, +        if ((rawCnt & 1) == 0) {, +            return rawCnt >>> 1;, +        }, +        // odd rawCnt => already deallocated, +        throw new IllegalReferenceCountException(0, -decrement);, +    }, +, +++ b/buffer/src/main/java/io/netty/buffer/AbstractReferenceCountedByteBuf.java, +    // even => "real" refcount is (refCnt >>> 1); odd => "real" refcount is 0, +    @SuppressWarnings("unused"), +    private volatile int refCnt = 2;, +    private static int realRefCnt(int rawCnt) {, +        return (rawCnt & 1) != 0 ? 0 : rawCnt >>> 1;, +    }, +, +    private int nonVolatileRawCnt() {, +        // TODO: Once we compile against later versions of Java we can replace the Unsafe usage here by varhandles., +        return REFCNT_FIELD_OFFSET != -1 ? PlatformDependent.getInt(this, REFCNT_FIELD_OFFSET), +                : refCntUpdater.get(this);, +    }, +, +        return realRefCnt(nonVolatileRawCnt());, +        return realRefCnt(refCntUpdater.get(this));, +    protected final void setRefCnt(int newRefCnt) {, +        refCntUpdater.set(this, newRefCnt << 1); // overflow OK here, +        // all changes to the raw count are 2x the "real" change, +        int adjustedIncrement = increment << 1; // overflow OK here, +        int oldRef = refCntUpdater.getAndAdd(this, adjustedIncrement);, +        if ((oldRef & 1) != 0) {, +            throw new IllegalReferenceCountException(0, increment);, +        }, +        // don't pass 0!]