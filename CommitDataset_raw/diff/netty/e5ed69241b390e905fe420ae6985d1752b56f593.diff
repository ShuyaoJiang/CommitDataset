[+++ b/buffer/src/main/java/io/netty/buffer/PoolChunk.java, +        switch (val & 3) {, +            case ST_UNUSED:, +                return allocateRunSimple(normCapacity, curIdx, val);, +            case ST_BRANCH:, +                final int nextIdxLeft = curIdx << 1;, +                final int nextValLeft = memoryMap[nextIdxLeft];, +                final boolean recurseLeft;, +                switch (nextValLeft & 3) {, +                    case ST_UNUSED:, +                        return allocateRunSimple(normCapacity, nextIdxLeft, nextValLeft);, +                    case ST_BRANCH:, +                        recurseLeft = true;, +                        break;, +                    default:, +                        recurseLeft = false;, +                }, +, +                final int nextIdxRight = nextIdxLeft ^ 1;, +                final int nextValRight = memoryMap[nextIdxRight];, +                final boolean recurseRight;, +                switch (nextValRight & 3) {, +                    case ST_UNUSED:, +                        return allocateRunSimple(normCapacity, nextIdxRight, nextValRight);, +                    case ST_BRANCH:, +                        recurseRight = true;, +                        break;, +                    default:, +                        recurseRight = false;, +                }, +, +                if (recurseLeft) {, +                    long res = branchRun(normCapacity, nextIdxLeft);, +                    if (res > 0) {, +                        return res;, +                    }, +                }, +, +                if (recurseRight) {, +                    return branchRun(normCapacity, nextIdxRight);, +                }, +        }, +, +    private long branchRun(int normCapacity, int nextIdx) {, +        int nextNextIdx = nextIdx << 1;, +        int nextNextVal = memoryMap[nextNextIdx];, +        long res = allocateRun(normCapacity, nextNextIdx, nextNextVal);, +        nextNextIdx ^= 1;, +        nextNextVal = memoryMap[nextNextIdx];, +        return allocateRun(normCapacity, nextNextIdx, nextNextVal);, +++ b/buffer/src/main/java/io/netty/buffer/PoolChunk.java, +        switch (val & 3) {, +            case ST_UNUSED:, +                return allocateRunSimple(normCapacity, curIdx, val);, +            case ST_BRANCH:, +                final int nextIdxLeft = curIdx << 1;, +                final int nextValLeft = memoryMap[nextIdxLeft];, +                final boolean recurseLeft;, +                switch (nextValLeft & 3) {, +                    case ST_UNUSED:, +                        return allocateRunSimple(normCapacity, nextIdxLeft, nextValLeft);, +                    case ST_BRANCH:, +                        recurseLeft = true;, +                        break;, +                    default:, +                        recurseLeft = false;, +                }, +, +                final int nextIdxRight = nextIdxLeft ^ 1;, +                final int nextValRight = memoryMap[nextIdxRight];, +                final boolean recurseRight;, +                switch (nextValRight & 3) {, +                    case ST_UNUSED:, +                        return allocateRunSimple(normCapacity, nextIdxRight, nextValRight);, +                    case ST_BRANCH:, +                        recurseRight = true;, +                        break;, +                    default:, +                        recurseRight = false;, +                }, +, +                if (recurseLeft) {, +                    long res = branchRun(normCapacity, nextIdxLeft);, +                    if (res > 0) {, +                        return res;, +                    }, +                }, +, +                if (recurseRight) {, +                    return branchRun(normCapacity, nextIdxRight);, +                }, +        }, +, +    private long branchRun(int normCapacity, int nextIdx) {, +        int nextNextIdx = nextIdx << 1;, +        int nextNextVal = memoryMap[nextNextIdx];, +        long res = allocateRun(normCapacity, nextNextIdx, nextNextVal);, +        nextNextIdx ^= 1;, +        nextNextVal = memoryMap[nextNextIdx];, +        return allocateRun(normCapacity, nextNextIdx, nextNextVal);]