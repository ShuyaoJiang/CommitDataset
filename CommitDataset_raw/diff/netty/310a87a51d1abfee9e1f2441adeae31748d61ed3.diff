[+++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdySessionHandler.java, +        sendGoAwayFrame(ctx, future);, +    private void sendGoAwayFrame(ChannelHandlerContext ctx, ChannelFuture future) {, +            ctx.close(future);, +            f.addListener(new ClosingChannelFutureListener(ctx, future));, +            closeSessionFuture.addListener(new ClosingChannelFutureListener(ctx, future));, +        // FIXME: Close the connection forcibly after timeout., +        private final ChannelFuture future;, +        ClosingChannelFutureListener(ChannelHandlerContext ctx, ChannelFuture future) {, +            this.future = future;, +            System.err.println("ASDF");, +            ctx.close(future);, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdySessionHandler.java, +        sendGoAwayFrame(ctx, future);, +    private void sendGoAwayFrame(ChannelHandlerContext ctx, ChannelFuture future) {, +            ctx.close(future);, +            f.addListener(new ClosingChannelFutureListener(ctx, future));, +            closeSessionFuture.addListener(new ClosingChannelFutureListener(ctx, future));, +        // FIXME: Close the connection forcibly after timeout., +        private final ChannelFuture future;, +        ClosingChannelFutureListener(ChannelHandlerContext ctx, ChannelFuture future) {, +            this.future = future;, +            System.err.println("ASDF");, +            ctx.close(future);, +++ b/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdySessionHandlerTest.java, +        // Check if session handler sends a GOAWAY frame when closing, +        sessionHandler.writeInbound(closeMessage);, +        assertNull(sessionHandler.readOutbound());, +        localStreamID += 2;, +, +        // Check if session handler returns REFUSED_STREAM if it receives, +        // SYN_STREAM frames after sending a GOAWAY frame, +        spdySynStreamFrame.setStreamId(localStreamID);, +        sessionHandler.writeInbound(spdySynStreamFrame);, +        assertRstStream(sessionHandler.readOutbound(), localStreamID, SpdyStreamStatus.REFUSED_STREAM);, +        assertNull(sessionHandler.readOutbound());, +, +        // Check if session handler ignores Data frames after sending, +        // a GOAWAY frame, +        spdyDataFrame.setStreamId(localStreamID);, +        sessionHandler.writeInbound(spdyDataFrame);, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdySessionHandler.java, +        sendGoAwayFrame(ctx, future);, +    private void sendGoAwayFrame(ChannelHandlerContext ctx, ChannelFuture future) {, +            ctx.close(future);, +            f.addListener(new ClosingChannelFutureListener(ctx, future));, +            closeSessionFuture.addListener(new ClosingChannelFutureListener(ctx, future));, +        // FIXME: Close the connection forcibly after timeout., +        private final ChannelFuture future;, +        ClosingChannelFutureListener(ChannelHandlerContext ctx, ChannelFuture future) {, +            this.future = future;, +            System.err.println("ASDF");, +            ctx.close(future);, +++ b/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdySessionHandlerTest.java, +        // Check if session handler sends a GOAWAY frame when closing, +        sessionHandler.writeInbound(closeMessage);, +        assertNull(sessionHandler.readOutbound());, +        localStreamID += 2;, +, +        // Check if session handler returns REFUSED_STREAM if it receives, +        // SYN_STREAM frames after sending a GOAWAY frame, +        spdySynStreamFrame.setStreamId(localStreamID);, +        sessionHandler.writeInbound(spdySynStreamFrame);, +        assertRstStream(sessionHandler.readOutbound(), localStreamID, SpdyStreamStatus.REFUSED_STREAM);, +        assertNull(sessionHandler.readOutbound());, +, +        // Check if session handler ignores Data frames after sending, +        // a GOAWAY frame, +        spdyDataFrame.setStreamId(localStreamID);, +        sessionHandler.writeInbound(spdyDataFrame);, +++ b/transport/src/main/java/io/netty/channel/DefaultChannelPipeline.java, +import java.nio.channels.ClosedChannelException;, +        if (!channel.isRegistered() && !channel.isActive()) {, +            future.setFailure(new ClosedChannelException());, +            return;, +        }, +, +        if (!channel.isRegistered() && !channel.isActive()) {, +            future.setFailure(new ClosedChannelException());, +            return;, +        }, +, +            ctx.outboundMessageBuffer().add(message);, +            ctx.outboundByteBuffer().writeBytes(buf, buf.readerIndex(), buf.readableBytes());]