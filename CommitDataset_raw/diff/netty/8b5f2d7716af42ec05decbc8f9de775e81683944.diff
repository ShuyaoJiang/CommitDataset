[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2FrameWriter.java, +import static io.netty.handler.codec.http2.Http2CodecUtil.CONTINUATION_FRAME_HEADER_LENGTH;, +import static io.netty.handler.codec.http2.Http2CodecUtil.DATA_FRAME_HEADER_LENGTH;, +import static io.netty.handler.codec.http2.Http2CodecUtil.GO_AWAY_FRAME_HEADER_LENGTH;, +import static io.netty.handler.codec.http2.Http2CodecUtil.HEADERS_FRAME_HEADER_LENGTH;, +import static io.netty.handler.codec.http2.Http2CodecUtil.PRIORITY_FRAME_LENGTH;, +import static io.netty.handler.codec.http2.Http2CodecUtil.PUSH_PROMISE_FRAME_HEADER_LENGTH;, +import static io.netty.handler.codec.http2.Http2CodecUtil.RST_STREAM_FRAME_LENGTH;, +import static io.netty.handler.codec.http2.Http2CodecUtil.WINDOW_UPDATE_FRAME_LENGTH;, +import static io.netty.handler.codec.http2.Http2CodecUtil.writeFrameHeaderInternal;, +import static io.netty.handler.codec.http2.Http2Exception.connectionError;, +import io.netty.buffer.Unpooled;, +import io.netty.handler.codec.http2.Http2CodecUtil.SimpleChannelPromiseAggregator;, +    /**, +     * This buffer is allocated to the maximum padding size needed, and filled with padding., +     * When padding is needed it can be taken as a slice of this buffer. Users should call {@link ByteBuf#retain()}, +     * before using their slice., +     */, +    private static final ByteBuf ZERO_BUFFER = Unpooled.buffer(MAX_UNSIGNED_BYTE).writeZero(MAX_UNSIGNED_BYTE);, +        boolean releaseData = true;, +        ByteBuf buf = null;, +        SimpleChannelPromiseAggregator promiseAggregator =, +                new SimpleChannelPromiseAggregator(promise, ctx.channel(), ctx.executor());, +            buf = ctx.alloc().buffer(DATA_FRAME_HEADER_LENGTH);, +            writeFrameHeaderInternal(buf, payloadLength, DATA, flags, streamId);, +            writePaddingLength(buf, padding);, +            ctx.write(buf, promiseAggregator.newPromise());, +            releaseData = false;, +            ctx.write(data, promiseAggregator.newPromise());, +            if (padding > 0) { // Write the required padding., +                ctx.write(ZERO_BUFFER.slice(0, padding).retain(), promiseAggregator.newPromise());, +            }, +            return promiseAggregator.doneAllocatingPromises();, +        } catch (Throwable t) {, +            if (releaseData) {, +            return promiseAggregator.setFailure(t);, +        }, +        return writeHeadersInternal(ctx, streamId, headers, padding, endStream,, +                false, 0, (short) 0, false, promise);, +        return writeHeadersInternal(ctx, streamId, headers, padding, endStream,, +                true, streamDependency, weight, exclusive, promise);, +            ByteBuf buf = ctx.alloc().buffer(PRIORITY_FRAME_LENGTH);, +            writeFrameHeaderInternal(buf, PRIORITY_ENTRY_LENGTH, PRIORITY, new Http2Flags(), streamId);, +            writeUnsignedInt(word1, buf);, +            buf.writeByte(weight - 1);, +            return ctx.write(buf, promise);, +        } catch (Throwable t) {, +            return promise.setFailure(t);, +            ByteBuf buf = ctx.alloc().buffer(RST_STREAM_FRAME_LENGTH);, +            writeFrameHeaderInternal(buf, INT_FIELD_LENGTH, RST_STREAM, new Http2Flags(), streamId);, +            writeUnsignedInt(errorCode, buf);, +            return ctx.write(buf, promise);, +        } catch (Throwable t) {, +            return promise.setFailure(t);, +            ByteBuf buf = ctx.alloc().buffer(FRAME_HEADER_LENGTH + settings.size() * SETTING_ENTRY_LENGTH);, +            writeFrameHeaderInternal(buf, payloadLength, SETTINGS, new Http2Flags(), 0);, +                writeUnsignedShort(entry.key(), buf);, +                writeUnsignedInt(entry.value(), buf);, +            return ctx.write(buf, promise);, +        } catch (Throwable t) {, +            return promise.setFailure(t);, +            ByteBuf buf = ctx.alloc().buffer(FRAME_HEADER_LENGTH);, +            writeFrameHeaderInternal(buf, 0, SETTINGS, new Http2Flags().ack(true), 0);, +            return ctx.write(buf, promise);, +        } catch (Throwable t) {, +            return promise.setFailure(t);, +        boolean releaseData = true;, +        SimpleChannelPromiseAggregator promiseAggregator =, +                new SimpleChannelPromiseAggregator(promise, ctx.channel(), ctx.executor());, +            ByteBuf buf = ctx.alloc().buffer(FRAME_HEADER_LENGTH);, +            writeFrameHeaderInternal(buf, data.readableBytes(), PING, flags, 0);, +            ctx.write(buf, promiseAggregator.newPromise());, +            releaseData = false;, +            ctx.write(data, promiseAggregator.newPromise());, +, +            return promiseAggregator.doneAllocatingPromises();, +        } catch (Throwable t) {, +            if (releaseData) {, +            return promiseAggregator.setFailure(t);, +        }, +        SimpleChannelPromiseAggregator promiseAggregator =, +                new SimpleChannelPromiseAggregator(promise, ctx.channel(), ctx.executor());, +            // INT_FIELD_LENGTH is for the length of the promisedStreamId, +            int nonFragmentLength = INT_FIELD_LENGTH + padding + flags.getPaddingPresenceFieldLength();, +                    headerBlock.readSlice(Math.min(headerBlock.readableBytes(), maxFragmentLength)).retain();, +            flags.endOfHeaders(!headerBlock.isReadable());, +            ByteBuf buf = ctx.alloc().buffer(PUSH_PROMISE_FRAME_HEADER_LENGTH);, +            writeFrameHeaderInternal(buf, payloadLength, PUSH_PROMISE, flags, streamId);, +            writePaddingLength(buf, padding);, +            buf.writeInt(promisedStreamId);, +            ctx.write(buf, promiseAggregator.newPromise());, +            ctx.write(fragment, promiseAggregator.newPromise());, +            if (padding > 0) { // Write out the padding, if any., +                ctx.write(ZERO_BUFFER.slice(0, padding).retain(), promiseAggregator.newPromise());, +            if (!flags.endOfHeaders()) {, +                writeContinuationFrames(ctx, streamId, headerBlock, padding, promiseAggregator);, +            }, +, +            return promiseAggregator.doneAllocatingPromises();, +        } catch (Throwable t) {]