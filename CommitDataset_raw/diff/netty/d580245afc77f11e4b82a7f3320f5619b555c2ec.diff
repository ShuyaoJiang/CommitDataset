[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2Connection.java, +, +            activeStreams.incrementPendingIterations();, +            try {, +                        // modify the streamMap. Pass the iterator in so that remove will be called to prevent, +                        // concurrent modification exceptions., +            } finally {, +                activeStreams.decrementPendingIterations();, +            }, +            } catch (Throwable cause) {, +                logger.error("Caught Throwable from listener onGoAwayReceived.", cause);, +            } catch (Throwable cause) {, +                logger.error("Caught Throwable from listener onGoAwaySent.", cause);, +     * Remove a stream from the {@link #streamMap}., +     * @param stream the stream to remove., +     * @param itr an iterator that may be pointing to the stream during iteration and {@link Iterator#remove()} will be, +     * used if non-{@code null}., +                } catch (Throwable cause) {, +                    logger.error("Caught Throwable from listener onStreamRemoved.", cause);, +            } catch (Throwable cause) {, +                logger.error("Caught Throwable from listener onStreamHalfClosed.", cause);, +            } catch (Throwable cause) {, +                logger.error("Caught Throwable from listener onStreamClosed.", cause);, +                    } catch (Throwable cause) {, +                        logger.error("Caught Throwable from listener onWeightChanged.", cause);, +            if (streamToRetain != null) {, +                // Note that the removal operation may not be successful and may return null. This is because when an, +                // exclusive dependency is processed the children are removed in a previous recursive call but the, +                // child's parent link is updated here., +                if (oldParent != null) {, +                    oldParent.children.remove(child.id());, +            if (children.remove(child.id()) != null) {, +            } catch (Throwable cause) {, +                logger.error("Caught Throwable from listener onPriorityTreeParentChanged.", cause);, +            } catch (Throwable cause) {, +                logger.error("Caught Throwable from listener onPriorityTreeParentChanging.", cause);, +                } catch (Throwable cause) {, +                    logger.error("Caught Throwable from listener onStreamAdded.", cause);, +            if (allowModifications() || itr != null) {, +            incrementPendingIterations();, +                decrementPendingIterations();, +                    } catch (Throwable cause) {, +                        logger.error("Caught Throwable from listener onStreamActive.", cause);, +, +        void incrementPendingIterations() {, +            ++pendingIterations;, +        }, +, +        void decrementPendingIterations() {, +            --pendingIterations;, +            if (allowModifications()) {, +                for (;;) {, +                    Event event = pendingEvents.poll();, +                    if (event == null) {, +                        break;, +                    }, +                    try {, +                        event.process();, +                    } catch (Throwable cause) {, +                        logger.error("Caught Throwable while processing pending ActiveStreams$Event.", cause);, +                    }, +                }, +            }, +        }, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2Connection.java, +, +            activeStreams.incrementPendingIterations();, +            try {, +                        // modify the streamMap. Pass the iterator in so that remove will be called to prevent, +                        // concurrent modification exceptions., +            } finally {, +                activeStreams.decrementPendingIterations();, +            }, +            } catch (Throwable cause) {, +                logger.error("Caught Throwable from listener onGoAwayReceived.", cause);, +            } catch (Throwable cause) {, +                logger.error("Caught Throwable from listener onGoAwaySent.", cause);, +     * Remove a stream from the {@link #streamMap}., +     * @param stream the stream to remove., +     * @param itr an iterator that may be pointing to the stream during iteration and {@link Iterator#remove()} will be, +     * used if non-{@code null}., +                } catch (Throwable cause) {, +                    logger.error("Caught Throwable from listener onStreamRemoved.", cause);, +            } catch (Throwable cause) {, +                logger.error("Caught Throwable from listener onStreamHalfClosed.", cause);, +            } catch (Throwable cause) {, +                logger.error("Caught Throwable from listener onStreamClosed.", cause);, +                    } catch (Throwable cause) {, +                        logger.error("Caught Throwable from listener onWeightChanged.", cause);, +            if (streamToRetain != null) {, +                // Note that the removal operation may not be successful and may return null. This is because when an, +                // exclusive dependency is processed the children are removed in a previous recursive call but the, +                // child's parent link is updated here., +                if (oldParent != null) {, +                    oldParent.children.remove(child.id());, +            if (children.remove(child.id()) != null) {, +            } catch (Throwable cause) {, +                logger.error("Caught Throwable from listener onPriorityTreeParentChanged.", cause);, +            } catch (Throwable cause) {, +                logger.error("Caught Throwable from listener onPriorityTreeParentChanging.", cause);]