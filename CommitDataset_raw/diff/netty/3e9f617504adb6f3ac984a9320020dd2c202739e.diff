[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/HttpPostMultipartRequestDecoder.java, +                } catch (NumberFormatException ignored) {, +            if (!loadDataMultipart(undecodedChunk, multipartDataBoundary, currentAttribute)) {, +                // Delimiter is not found. Need more chunks., +        if (!loadDataMultipart(undecodedChunk, delimiter, currentFileUpload)) {, +            // Delimiter is not found. Need more chunks., +     * Load the field value or file data from a Multipart request, +     * @return {@code true} if the last chunk is loaded (boundary delimiter found), {@code false} if need more chunks, +    private static boolean loadDataMultipartStandard(ByteBuf undecodedChunk, String delimiter, HttpData httpData) {, +        final int startReaderIndex = undecodedChunk.readerIndex();, +        final int delimeterLength = delimiter.length();, +        int lastPosition = startReaderIndex;, +        byte prevByte = HttpConstants.LF;, +        boolean delimiterFound = false;, +            final byte nextByte = undecodedChunk.readByte();, +            if (prevByte == HttpConstants.LF && nextByte == delimiter.codePointAt(index)) {, +                if (delimeterLength == index) {, +                    delimiterFound = true;, +                continue;, +                lastPosition -= (prevByte == HttpConstants.CR)? 2 : 1;, +            prevByte = nextByte;, +        if (prevByte == HttpConstants.CR) {, +            lastPosition--;, +        ByteBuf content = undecodedChunk.copy(startReaderIndex, lastPosition - startReaderIndex);, +            httpData.addContent(content, delimiterFound);, +        return delimiterFound;, +     * @return {@code true} if the last chunk is loaded (boundary delimiter found), {@code false} if need more chunks, +    private static boolean loadDataMultipart(ByteBuf undecodedChunk, String delimiter, HttpData httpData) {, +            return loadDataMultipartStandard(undecodedChunk, delimiter, httpData);, +        final SeekAheadOptimize sao = new SeekAheadOptimize(undecodedChunk);, +        final int startReaderIndex = undecodedChunk.readerIndex();, +        final int delimeterLength = delimiter.length();, +        int lastRealPos = sao.pos;, +        byte prevByte = HttpConstants.LF;, +        boolean delimiterFound = false;, +            final byte nextByte = sao.bytes[sao.pos++];, +            if (prevByte == HttpConstants.LF && nextByte == delimiter.codePointAt(index)) {, +                if (delimeterLength == index) {, +                    delimiterFound = true;, +                continue;, +            }, +            lastRealPos = sao.pos;, +                lastRealPos -= (prevByte == HttpConstants.CR)? 2 : 1;, +            prevByte = nextByte;, +        if (prevByte == HttpConstants.CR) {, +            lastRealPos--;, +        final int lastPosition = sao.getReadPosition(lastRealPos);, +        final ByteBuf content = undecodedChunk.copy(startReaderIndex, lastPosition - startReaderIndex);, +            httpData.addContent(content, delimiterFound);, +        return delimiterFound;, +        int size = field.length();, +        StringBuilder sb = new StringBuilder(size);, +        for (int i = 0; i < size; i++) {, +            switch (nextChar) {, +            case HttpConstants.COLON:, +            case HttpConstants.COMMA:, +            case HttpConstants.EQUALS:, +            case HttpConstants.SEMICOLON:, +            case HttpConstants.HT:, +                break;, +            case HttpConstants.DOUBLE_QUOTE:, +                break;, +            default:, +                break;]