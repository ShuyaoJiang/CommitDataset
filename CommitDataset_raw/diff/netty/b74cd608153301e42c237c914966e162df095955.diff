[+++ b/src/main/java/org/jboss/netty/channel/socket/nio/DirectBufferPool.java, +    private final ThreadLocal<SoftReference<ByteBuffer>[]> pool = , +    	new ThreadLocal<SoftReference<ByteBuffer>[]>() {, +			@Override, +			protected SoftReference<ByteBuffer>[] initialValue() {, +				return new SoftReference[POOL_SIZE];, +			}, +    		, +    	};, +, +    	final SoftReference<ByteBuffer>[] pool = this.pool.get();, +    	final SoftReference<ByteBuffer>[] pool = this.pool.get();, +++ b/src/main/java/org/jboss/netty/channel/socket/nio/DirectBufferPool.java, +    private final ThreadLocal<SoftReference<ByteBuffer>[]> pool = , +    	new ThreadLocal<SoftReference<ByteBuffer>[]>() {, +			@Override, +			protected SoftReference<ByteBuffer>[] initialValue() {, +				return new SoftReference[POOL_SIZE];, +			}, +    		, +    	};, +, +    	final SoftReference<ByteBuffer>[] pool = this.pool.get();, +    	final SoftReference<ByteBuffer>[] pool = this.pool.get();, +++ b/src/main/java/org/jboss/netty/channel/socket/nio/NioClientSocketPipelineSink.java, +            channel.worker.write(channel);, +++ b/src/main/java/org/jboss/netty/channel/socket/nio/DirectBufferPool.java, +    private final ThreadLocal<SoftReference<ByteBuffer>[]> pool = , +    	new ThreadLocal<SoftReference<ByteBuffer>[]>() {, +			@Override, +			protected SoftReference<ByteBuffer>[] initialValue() {, +				return new SoftReference[POOL_SIZE];, +			}, +    		, +    	};, +, +    	final SoftReference<ByteBuffer>[] pool = this.pool.get();, +    	final SoftReference<ByteBuffer>[] pool = this.pool.get();, +++ b/src/main/java/org/jboss/netty/channel/socket/nio/NioClientSocketPipelineSink.java, +            channel.worker.write(channel);, +++ b/src/main/java/org/jboss/netty/channel/socket/nio/NioServerSocketPipelineSink.java, +            channel.worker.write(channel);, +++ b/src/main/java/org/jboss/netty/channel/socket/nio/DirectBufferPool.java, +    private final ThreadLocal<SoftReference<ByteBuffer>[]> pool = , +    	new ThreadLocal<SoftReference<ByteBuffer>[]>() {, +			@Override, +			protected SoftReference<ByteBuffer>[] initialValue() {, +				return new SoftReference[POOL_SIZE];, +			}, +    		, +    	};, +, +    	final SoftReference<ByteBuffer>[] pool = this.pool.get();, +    	final SoftReference<ByteBuffer>[] pool = this.pool.get();, +++ b/src/main/java/org/jboss/netty/channel/socket/nio/NioClientSocketPipelineSink.java, +            channel.worker.write(channel);, +++ b/src/main/java/org/jboss/netty/channel/socket/nio/NioServerSocketPipelineSink.java, +            channel.worker.write(channel);, +++ b/src/main/java/org/jboss/netty/channel/socket/nio/NioSocketChannel.java, +import static org.jboss.netty.channel.Channels.fireChannelInterestChanged;, +import java.util.concurrent.locks.Lock;, +import java.util.concurrent.locks.ReentrantLock;, +    final Lock writeLock = new ReentrantLock();, +            worker.write(NioSocketChannel.this);, +++ b/src/main/java/org/jboss/netty/channel/socket/nio/DirectBufferPool.java, +    private final ThreadLocal<SoftReference<ByteBuffer>[]> pool = , +    	new ThreadLocal<SoftReference<ByteBuffer>[]>() {, +			@Override, +			protected SoftReference<ByteBuffer>[] initialValue() {, +				return new SoftReference[POOL_SIZE];, +			}, +    		, +    	};, +, +    	final SoftReference<ByteBuffer>[] pool = this.pool.get();, +    	final SoftReference<ByteBuffer>[] pool = this.pool.get();, +++ b/src/main/java/org/jboss/netty/channel/socket/nio/NioClientSocketPipelineSink.java, +            channel.worker.write(channel);, +++ b/src/main/java/org/jboss/netty/channel/socket/nio/NioServerSocketPipelineSink.java, +            channel.worker.write(channel);, +++ b/src/main/java/org/jboss/netty/channel/socket/nio/NioSocketChannel.java, +import static org.jboss.netty.channel.Channels.fireChannelInterestChanged;, +import java.util.concurrent.locks.Lock;, +import java.util.concurrent.locks.ReentrantLock;, +    final Lock writeLock = new ReentrantLock();, +            worker.write(NioSocketChannel.this);, +++ b/src/main/java/org/jboss/netty/channel/socket/nio/NioWorker.java, +        write(ch);, +    void write(final NioSocketChannel channel) {, +        if (!channel.writeLock.tryLock()) {, +            rescheduleWrite(channel);, +        final Queue<MessageEvent> writeBuffer = channel.writeBuffer;, +        final int writeSpinCount = channel.getConfig().getWriteSpinCount();, +        try {, +        } finally {, +            channel.writeLock.unlock();, +            if (addOpWrite) {, +                    int interestOps = channel.getRawInterestOps();, +                        setInterestOps0(channel, interestOps);, +            } else if (removeOpWrite) {]