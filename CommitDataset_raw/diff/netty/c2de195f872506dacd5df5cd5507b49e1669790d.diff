[+++ b/common/src/main/java/io/netty/util/ByteString.java, +, +import io.netty.util.internal.PlatformDependent;, +        ByteString other = (ByteString) obj;, +        return hashCode() == other.hashCode() &&, +               PlatformDependent.equals(array(), 0, array().length, other.array(), 0, other.array().length);, +++ b/common/src/main/java/io/netty/util/ByteString.java, +, +import io.netty.util.internal.PlatformDependent;, +        ByteString other = (ByteString) obj;, +        return hashCode() == other.hashCode() &&, +               PlatformDependent.equals(array(), 0, array().length, other.array(), 0, other.array().length);, +++ b/common/src/main/java/io/netty/util/internal/PlatformDependent.java, +    private static final long ARRAY_BASE_OFFSET = PlatformDependent0.arrayBaseOffset();, +     * Compare two {@code byte} arrays for equality. For performance reasons no bounds checking on the, +     * parameters is performed., +     *, +     * @param bytes1 the first byte array., +     * @param startPos1 the position (inclusive) to start comparing in {@code bytes1}., +     * @param endPos1 the position (exclusive) to stop comparing in {@code bytes1}., +     * @param bytes2 the second byte array., +     * @param startPos2 the position (inclusive) to start comparing in {@code bytes2}., +     * @param endPos2 the position (exclusive) to stop comparing in {@code bytes2}., +     */, +    public static boolean equals(byte[] bytes1, int startPos1, int endPos1, byte[] bytes2, int startPos2, int endPos2) {, +        if (!hasUnsafe() || !PlatformDependent0.unalignedAccess()) {, +            return safeEquals(bytes1, startPos1, endPos1, bytes2, startPos2, endPos2);, +        }, +        return PlatformDependent0.equals(bytes1, startPos1, endPos1, bytes2, startPos2, endPos2);, +    }, +, +    /**, +    private static boolean safeEquals(byte[] bytes1, int startPos1, int endPos1,, +                                      byte[] bytes2, int startPos2, int endPos2) {, +        final int len1 = endPos1 - startPos1;, +        final int len2 = endPos2 - startPos2;, +        if (len1 != len2) {, +            return false;, +        }, +        for (int i = 0; i < len1; i++) {, +            if (bytes1[startPos1 + i] != bytes2[startPos2 + i]) {, +                return false;, +            }, +        }, +        return true;, +    }, +, +++ b/common/src/main/java/io/netty/util/ByteString.java, +, +import io.netty.util.internal.PlatformDependent;, +        ByteString other = (ByteString) obj;, +        return hashCode() == other.hashCode() &&, +               PlatformDependent.equals(array(), 0, array().length, other.array(), 0, other.array().length);, +++ b/common/src/main/java/io/netty/util/internal/PlatformDependent.java, +    private static final long ARRAY_BASE_OFFSET = PlatformDependent0.arrayBaseOffset();, +     * Compare two {@code byte} arrays for equality. For performance reasons no bounds checking on the, +     * parameters is performed., +     *, +     * @param bytes1 the first byte array., +     * @param startPos1 the position (inclusive) to start comparing in {@code bytes1}., +     * @param endPos1 the position (exclusive) to stop comparing in {@code bytes1}., +     * @param bytes2 the second byte array., +     * @param startPos2 the position (inclusive) to start comparing in {@code bytes2}., +     * @param endPos2 the position (exclusive) to stop comparing in {@code bytes2}., +     */, +    public static boolean equals(byte[] bytes1, int startPos1, int endPos1, byte[] bytes2, int startPos2, int endPos2) {, +        if (!hasUnsafe() || !PlatformDependent0.unalignedAccess()) {, +            return safeEquals(bytes1, startPos1, endPos1, bytes2, startPos2, endPos2);, +        }, +        return PlatformDependent0.equals(bytes1, startPos1, endPos1, bytes2, startPos2, endPos2);, +    }, +, +    /**, +    private static boolean safeEquals(byte[] bytes1, int startPos1, int endPos1,, +                                      byte[] bytes2, int startPos2, int endPos2) {, +        final int len1 = endPos1 - startPos1;, +        final int len2 = endPos2 - startPos2;, +        if (len1 != len2) {, +            return false;, +        }, +        for (int i = 0; i < len1; i++) {, +            if (bytes1[startPos1 + i] != bytes2[startPos2 + i]) {, +                return false;, +            }, +        }, +        return true;, +    }, +, +++ b/common/src/main/java/io/netty/util/internal/PlatformDependent0.java, +    private static final long ARRAY_BASE_OFFSET;, +            ARRAY_BASE_OFFSET = -1;, +            ARRAY_BASE_OFFSET = UNSAFE.arrayBaseOffset(byte[].class);, +    static boolean unalignedAccess() {, +        return UNALIGNED;, +    }, +, +        return ARRAY_BASE_OFFSET;, +    static boolean equals(byte[] bytes1, int startPos1, int endPos1, byte[] bytes2, int startPos2, int endPos2) {, +        final int len1 = endPos1 - startPos1;, +        final int len2 = endPos2 - startPos2;]