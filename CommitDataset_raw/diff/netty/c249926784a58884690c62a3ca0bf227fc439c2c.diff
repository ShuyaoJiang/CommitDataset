[+++ b/transport/src/main/java/io/netty/channel/group/ChannelGroup.java, +     * group that are matched by the given {@link ChannelMatcher}. If the specified {@code message} is an instance of, +     * Writes the specified {@code message} to all {@link Channel}s in this, +     * group that are matched by the given {@link ChannelMatcher}. If the specified {@code message} is an instance of, +     * {@link ByteBuf}, it is automatically, +     * {@linkplain ByteBuf#duplicate() duplicated} to avoid a race, +     * condition. The same is true for {@link ByteBufHolder}. Please note that this operation is asynchronous as, +     * {@link Channel#write(Object)} is., +     *, +     * If {@code voidPromise} is {@code true} {@link Channel#voidPromise()} is used for the writes and so the same, +     * restrictions to the returned {@link ChannelGroupFuture} apply as to a void promise., +     *, +     * @return the {@link ChannelGroupFuture} instance that notifies when, +     *         the operation is done for all channels, +     */, +    ChannelGroupFuture write(Object message, ChannelMatcher matcher, boolean voidPromise);, +, +    /**, +     * Flush all {@link Channel}s in this group that are matched by the given {@link ChannelMatcher}., +     * {@link Channel}s that are matched by the {@link ChannelMatcher}., +     * Shortcut for calling {@link #write(Object, ChannelMatcher, boolean)} and {@link #flush()} and only act on, +     * {@link Channel}s that are matched by the {@link ChannelMatcher}., +     */, +    ChannelGroupFuture writeAndFlush(Object message, ChannelMatcher matcher, boolean voidPromise);, +, +    /**, +     * that are matched by the given {@link ChannelMatcher}., +     * Closes all {@link Channel}s in this group that are matched by the given {@link ChannelMatcher}., +     * Deregister all {@link Channel}s in this group from their {@link EventLoop} that are matched by the given, +++ b/transport/src/main/java/io/netty/channel/group/ChannelGroup.java, +     * group that are matched by the given {@link ChannelMatcher}. If the specified {@code message} is an instance of, +     * Writes the specified {@code message} to all {@link Channel}s in this, +     * group that are matched by the given {@link ChannelMatcher}. If the specified {@code message} is an instance of, +     * {@link ByteBuf}, it is automatically, +     * {@linkplain ByteBuf#duplicate() duplicated} to avoid a race, +     * condition. The same is true for {@link ByteBufHolder}. Please note that this operation is asynchronous as, +     * {@link Channel#write(Object)} is., +     *, +     * If {@code voidPromise} is {@code true} {@link Channel#voidPromise()} is used for the writes and so the same, +     * restrictions to the returned {@link ChannelGroupFuture} apply as to a void promise., +     *, +     * @return the {@link ChannelGroupFuture} instance that notifies when, +     *         the operation is done for all channels, +     */, +    ChannelGroupFuture write(Object message, ChannelMatcher matcher, boolean voidPromise);, +, +    /**, +     * Flush all {@link Channel}s in this group that are matched by the given {@link ChannelMatcher}., +     * {@link Channel}s that are matched by the {@link ChannelMatcher}., +     * Shortcut for calling {@link #write(Object, ChannelMatcher, boolean)} and {@link #flush()} and only act on, +     * {@link Channel}s that are matched by the {@link ChannelMatcher}., +     */, +    ChannelGroupFuture writeAndFlush(Object message, ChannelMatcher matcher, boolean voidPromise);, +, +    /**, +     * that are matched by the given {@link ChannelMatcher}., +     * Closes all {@link Channel}s in this group that are matched by the given {@link ChannelMatcher}., +     * Deregister all {@link Channel}s in this group from their {@link EventLoop} that are matched by the given, +++ b/transport/src/main/java/io/netty/channel/group/DefaultChannelGroup.java, +    private final VoidChannelGroupFuture voidFuture = new VoidChannelGroupFuture(this);, +        return write(message, matcher, false);, +    }, +, +    @Override, +    public ChannelGroupFuture write(Object message, ChannelMatcher matcher, boolean voidPromise) {, +        final ChannelGroupFuture future;, +        if (voidPromise) {, +            for (Channel c: nonServerChannels.values()) {, +                if (matcher.matches(c)) {, +                    c.write(safeDuplicate(message), c.voidPromise());, +                }, +            }, +            future = voidFuture;, +        } else {, +            future = new DefaultChannelGroupFuture(this, futures, executor);, +        }, +        return future;, +        return writeAndFlush(message, matcher, false);, +    }, +, +    @Override, +    public ChannelGroupFuture writeAndFlush(Object message, ChannelMatcher matcher, boolean voidPromise) {, +        final ChannelGroupFuture future;, +        if (voidPromise) {, +            for (Channel c: nonServerChannels.values()) {, +                if (matcher.matches(c)) {, +                    c.writeAndFlush(safeDuplicate(message), c.voidPromise());, +                }, +            }, +            future = voidFuture;, +        } else {, +            future = new DefaultChannelGroupFuture(this, futures, executor);, +        }, +        return future;, +++ b/transport/src/main/java/io/netty/channel/group/ChannelGroup.java, +     * group that are matched by the given {@link ChannelMatcher}. If the specified {@code message} is an instance of, +     * Writes the specified {@code message} to all {@link Channel}s in this, +     * group that are matched by the given {@link ChannelMatcher}. If the specified {@code message} is an instance of, +     * {@link ByteBuf}, it is automatically, +     * {@linkplain ByteBuf#duplicate() duplicated} to avoid a race]