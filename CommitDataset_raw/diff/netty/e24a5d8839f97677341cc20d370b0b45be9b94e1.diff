[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/AbstractHttp2StreamChannel.java, +/*, + * Copyright 2016 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License, version 2.0 (the, + * "License"); you may not use this file except in compliance with the License. You may obtain a, + * copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software distributed under the License, + * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express, + * or implied. See the License for the specific language governing permissions and limitations under, + * the License., + */, +, +package io.netty.handler.codec.http2;, +, +import static io.netty.util.internal.ObjectUtil.checkNotNull;, +, +import io.netty.channel.AbstractChannel;, +import io.netty.channel.Channel;, +import io.netty.channel.ChannelConfig;, +import io.netty.channel.ChannelMetadata;, +import io.netty.channel.ChannelOutboundBuffer;, +import io.netty.channel.ChannelPromise;, +import io.netty.channel.DefaultChannelConfig;, +import io.netty.channel.EventLoop;, +import io.netty.channel.RecvByteBufAllocator;, +import io.netty.util.ReferenceCountUtil;, +import io.netty.util.concurrent.EventExecutor;, +import io.netty.util.internal.EmptyArrays;, +import io.netty.util.internal.OneTimeTask;, +, +import java.net.SocketAddress;, +import java.nio.channels.ClosedChannelException;, +import java.util.ArrayDeque;, +import java.util.Queue;, +, +/**, + * Child {@link Channel} of another channel, for use for modeling streams as channels., + */, +abstract class AbstractHttp2StreamChannel extends AbstractChannel {, +    /**, +     * Used by subclasses to queue a close channel within the read queue. When read, it will close, +     * the channel (using Unsafe) instead of notifying handlers of the message with {@code, +     * channelRead()}. Additional inbound messages must not arrive after this one., +     */, +    protected static final Object CLOSE_MESSAGE = new Object();, +    private static final ChannelMetadata METADATA = new ChannelMetadata(false, 16);, +    private static final ClosedChannelException CLOSED_CHANNEL_EXCEPTION = new ClosedChannelException();, +    /**, +     * Number of bytes to consider non-payload messages, to determine when to stop reading. 9 is, +     * arbitrary, but also the minimum size of an HTTP/2 frame. Primarily is non-zero., +     */, +    private static final int ARBITRARY_MESSAGE_SIZE = 9;, +, +    static {, +        CLOSED_CHANNEL_EXCEPTION.setStackTrace(EmptyArrays.EMPTY_STACK_TRACE);, +    }, +, +    private final ChannelConfig config = new DefaultChannelConfig(this);, +    private final Queue<Object> inboundBuffer = new ArrayDeque<Object>(4);, +    private final Runnable fireChildReadCompleteTask = new Runnable() {, +        @Override, +        public void run() {, +            if (readInProgress) {, +                readInProgress = false;, +                unsafe().recvBufAllocHandle().readComplete();, +                pipeline().fireChannelReadComplete();, +            }, +        }, +    };, +, +    private boolean closed;, +    private boolean readInProgress;, +, +    public AbstractHttp2StreamChannel(Channel parent) {, +        super(parent);, +    }, +, +    @Override, +    public ChannelMetadata metadata() {, +        return METADATA;, +    }, +, +    @Override, +    public ChannelConfig config() {, +        return config;, +    }, +, +    @Override, +    public boolean isOpen() {, +        return !closed;, +    }, +, +    @Override, +    public boolean isActive() {, +        return !closed;, +    }]