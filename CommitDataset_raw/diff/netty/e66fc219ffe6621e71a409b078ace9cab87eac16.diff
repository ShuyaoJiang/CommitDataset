[+++ b/common/src/main/java/io/netty/util/HashedWheelTimer.java, +        long relativeIndex = (delay + tickDuration - 1) / tickDuration;, +, +        // if the previous line had an overflow going on, then we’ll just schedule this timeout, +        // one tick early; that shouldn’t matter since we’re talking 270 years here, +        if (relativeIndex < 0) {, +            relativeIndex = delay / tickDuration;, +        } else if (relativeIndex == 0) {, +            relativeIndex = 1;, +        final long remainingRounds = relativeIndex / wheel.length;, +            int stopIndex = (int) ((wheelCursor + relativeIndex) & mask);, +                if (deadline > Long.MIN_VALUE) {, +                    if ((timeout.deadline - deadline) <= 0) {, +        /**, +         * calculate goal nanoTime from startTime and current tick number,, +         * then wait until that goal has been reached., +         * @return Long.MIN_VALUE if received a shutdown request, current time otherwise, +         */, +            final long deadline = startTime + tickDuration * tick;, +                final long currentTime = System.nanoTime();, +                long sleepTimeMs = (deadline - currentTime + 999999) / 1000000;, +, +                if (sleepTimeMs <= 0) {, +                    tick++;, +                    if (currentTime == Long.MIN_VALUE) {, +                        return -Long.MAX_VALUE;, +                    } else {, +                        return currentTime;, +                    }, +                }, +                    sleepTimeMs = (sleepTimeMs / 10) * 10;, +                    Thread.sleep(sleepTimeMs);, +                        return Long.MIN_VALUE;]