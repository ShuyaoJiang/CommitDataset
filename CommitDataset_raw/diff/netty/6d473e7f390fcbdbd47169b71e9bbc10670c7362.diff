[+++ b/common/src/main/java/io/netty/util/concurrent/SingleThreadEventExecutor.java, +import java.lang.Thread.State;, +import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;, +    private static final Runnable NOOP_TASK = new Runnable() {, +        @Override, +        public void run() {, +            // Do nothing., +        }, +    };, +    private static final AtomicReferenceFieldUpdater<SingleThreadEventExecutor, ThreadProperties> PROPERTIES_UPDATER;, +, +        AtomicReferenceFieldUpdater<SingleThreadEventExecutor, ThreadProperties> propertiesUpdater =, +                PlatformDependent.newAtomicReferenceFieldUpdater(SingleThreadEventExecutor.class, "threadProperties");, +        if (propertiesUpdater == null) {, +            propertiesUpdater = AtomicReferenceFieldUpdater.newUpdater(SingleThreadEventExecutor.class,, +                                                                   ThreadProperties.class, "threadProperties");, +        }, +        PROPERTIES_UPDATER = propertiesUpdater;, +    private volatile ThreadProperties threadProperties;, +    /**, +     * Returns the {@link ThreadProperties} of the {@link Thread} that powers the {@link SingleThreadEventExecutor}., +     * If the {@link SingleThreadEventExecutor} is not started yet, this operation will start it and block until the, +     * it is fully started., +     */, +    public final ThreadProperties threadProperties() {, +        ThreadProperties threadProperties = this.threadProperties;, +        if (threadProperties == null) {, +            Thread thread = this.thread;, +            if (thread == null) {, +                assert !inEventLoop();, +                submit(NOOP_TASK).syncUninterruptibly();, +                thread = this.thread;, +                assert thread != null;, +            }, +, +            threadProperties = new DefaultThreadProperties(thread);, +            if (!PROPERTIES_UPDATER.compareAndSet(this, null, threadProperties)) {, +                threadProperties = this.threadProperties;, +            }, +        }, +, +        return threadProperties;, +    }, +, +, +    private static final class DefaultThreadProperties implements ThreadProperties {, +        private final Thread t;, +, +        DefaultThreadProperties(Thread t) {, +            this.t = t;, +        }, +, +        @Override, +        public State state() {, +            return t.getState();, +        }, +, +        @Override, +        public int priority() {, +            return t.getPriority();, +        }, +, +        @Override, +        public boolean isInterrupted() {, +            return t.isInterrupted();, +        }, +, +        @Override, +        public boolean isDaemon() {, +            return t.isDaemon();, +        }, +, +        @Override, +        public String name() {, +            return t.getName();, +        }, +, +        @Override, +        public long id() {, +            return t.getId();, +        }, +, +        @Override, +        public StackTraceElement[] stackTrace() {, +            return t.getStackTrace();, +        }, +, +        @Override, +        public boolean isAlive() {, +            return t.isAlive();, +        }, +    }, +++ b/common/src/main/java/io/netty/util/concurrent/SingleThreadEventExecutor.java, +import java.lang.Thread.State;, +import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;, +    private static final Runnable NOOP_TASK = new Runnable() {, +        @Override, +        public void run() {, +            // Do nothing., +        }]