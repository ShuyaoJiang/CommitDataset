[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2ConnectionHandler.java, +                ChannelFutureListener closeListener = Http2ConnectionHandler.this.closeListener;, +                // This method could be called multiple times, +                // and we don't want to notify the closeListener multiple times, +                Http2ConnectionHandler.this.closeListener = null;, +    public ChannelFuture writeRstStream(final ChannelHandlerContext ctx, int streamId, long errorCode,, +            final ChannelPromise promise) {, +        final Http2Stream stream = connection().stream(streamId);, +        if (stream == null || stream.isResetSent()) {, +            // Don't write a RST_STREAM frame if we are not aware of the stream, or if we have already written one., +            return promise.setSuccess();, +        }, +, +        // Synchronously set the resetSent flag to prevent any subsequent calls, +        // from resulting in multiple reset frames being sent., +, +        future.addListener(new ChannelFutureListener() {, +            @Override, +            public void operationComplete(ChannelFuture future) throws Exception {, +                if (future.isSuccess()) {, +                } else {, +                    // The connection will be closed and so no need to change the resetSent flag to false., +                    onConnectionError(ctx, future.cause(), null);, +            }, +        });, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2ConnectionHandler.java, +                ChannelFutureListener closeListener = Http2ConnectionHandler.this.closeListener;, +                // This method could be called multiple times, +                // and we don't want to notify the closeListener multiple times, +                Http2ConnectionHandler.this.closeListener = null;, +    public ChannelFuture writeRstStream(final ChannelHandlerContext ctx, int streamId, long errorCode,, +            final ChannelPromise promise) {, +        final Http2Stream stream = connection().stream(streamId);, +        if (stream == null || stream.isResetSent()) {, +            // Don't write a RST_STREAM frame if we are not aware of the stream, or if we have already written one., +            return promise.setSuccess();, +        }, +, +        // Synchronously set the resetSent flag to prevent any subsequent calls, +        // from resulting in multiple reset frames being sent., +, +        future.addListener(new ChannelFutureListener() {, +            @Override, +            public void operationComplete(ChannelFuture future) throws Exception {, +                if (future.isSuccess()) {, +                } else {, +                    // The connection will be closed and so no need to change the resetSent flag to false., +                    onConnectionError(ctx, future.cause(), null);, +            }, +        });, +++ b/codec-http2/src/test/java/io/netty/handler/codec/http2/Http2ConnectionHandlerTest.java, +import static io.netty.handler.codec.http2.Http2Error.STREAM_CLOSED;, +import static io.netty.handler.codec.http2.Http2Stream.State.CLOSED;, +import static org.junit.Assert.assertNull;, +import static org.junit.Assert.assertTrue;, +import static org.mockito.Matchers.anyLong;, +import static org.mockito.Mockito.times;, +import io.netty.channel.ChannelFutureListener;, +import io.netty.util.concurrent.GenericFutureListener;, +import java.util.Arrays;, +    private static final int NON_EXISTANT_STREAM_ID = 13;, +    private ChannelPromise promise;, +        when(connection.stream(NON_EXISTANT_STREAM_ID)).thenReturn(null);, +        when(connection.stream(STREAM_ID)).thenReturn(stream);, +, +    @Test, +    public void writeRstOnNonExistantStreamShouldSucceed() throws Exception {, +        handler = newHandler();, +        handler.writeRstStream(ctx, NON_EXISTANT_STREAM_ID, STREAM_CLOSED.code(), promise);, +        verify(frameWriter, never()), +            .writeRstStream(any(ChannelHandlerContext.class), anyInt(), anyLong(), any(ChannelPromise.class));, +        assertTrue(promise.isDone());, +        assertTrue(promise.isSuccess());, +        assertNull(promise.cause());, +    }, +, +    @Test, +    public void writeRstOnClosedStreamShouldSucceed() throws Exception {, +        handler = newHandler();, +        when(frameWriter.writeRstStream(eq(ctx), eq(STREAM_ID),, +                anyLong(), any(ChannelPromise.class))).thenReturn(future);, +        when(stream.state()).thenReturn(CLOSED);, +        // The stream is "closed" but is still known about by the connection (connection().stream(..), +        // will return the stream). We should still write a RST_STREAM frame in this scenario., +        handler.writeRstStream(ctx, STREAM_ID, STREAM_CLOSED.code(), promise);, +        verify(frameWriter).writeRstStream(eq(ctx), eq(STREAM_ID), anyLong(), any(ChannelPromise.class));, +    }, +, +    @SuppressWarnings("unchecked"), +    @Test, +    public void closeListenerShouldBeNotifiedOnlyOneTime() throws Exception {, +        handler = newHandler();, +        when(connection.activeStreams()).thenReturn(Arrays.asList(stream));, +        when(connection.numActiveStreams()).thenReturn(1);, +        when(future.isDone()).thenReturn(true);, +        when(future.isSuccess()).thenReturn(true);, +        doAnswer(new Answer<ChannelFuture>() {, +            @Override, +            public ChannelFuture answer(InvocationOnMock invocation) throws Throwable {, +                Object[] args = invocation.getArguments();]