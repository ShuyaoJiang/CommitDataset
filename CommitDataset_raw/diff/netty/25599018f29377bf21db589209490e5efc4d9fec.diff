[+++ b/transport/src/main/java/io/netty/channel/SingleThreadEventLoop.java, +            if (fetchScheduledTasks()) {, +        }, +        Runnable task = taskQueue.peek();, +        if (task == null) {, +            if (fetchScheduledTasks()) {, +                task = taskQueue.peek();, +            }, +        }, +        return task;, +        boolean empty = taskQueue.isEmpty();, +        if (empty) {, +            if (fetchScheduledTasks()) {, +                empty = taskQueue.isEmpty();, +            }, +        }, +        return !empty;, +    private boolean fetchScheduledTasks() {, +            return false;, +            boolean added = false;, +                        added = true;, +            return added;, +, +        return false;, +++ b/transport/src/main/java/io/netty/channel/SingleThreadEventLoop.java, +            if (fetchScheduledTasks()) {, +        }, +        Runnable task = taskQueue.peek();, +        if (task == null) {, +            if (fetchScheduledTasks()) {, +                task = taskQueue.peek();, +            }, +        }, +        return task;, +        boolean empty = taskQueue.isEmpty();, +        if (empty) {, +            if (fetchScheduledTasks()) {, +                empty = taskQueue.isEmpty();, +            }, +        }, +        return !empty;, +    private boolean fetchScheduledTasks() {, +            return false;, +            boolean added = false;, +                        added = true;, +            return added;, +, +        return false;, +++ b/transport/src/main/java/io/netty/channel/socket/nio/SingleThreadSelectorEventLoop.java, +        Iterator<SelectionKey> i;, +        for (i = selector.selectedKeys().iterator(); i.hasNext();) {, +            i.remove();, +                if ((readyOps & (SelectionKey.OP_READ | SelectionKey.OP_ACCEPT)) != 0 || readyOps == 0) {, +                // Create the iterator again to avoid ConcurrentModificationException, +                i = selector.selectedKeys().iterator();]