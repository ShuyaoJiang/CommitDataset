[+++ b/handler/src/main/java/io/netty/handler/ssl/ReferenceCountedOpenSslContext.java, +    private static final boolean USE_TASKS =, +            SystemPropertyUtil.getBoolean("io.netty.handler.ssl.openssl.useTasks", false);, +, +            SSLContext.setUseTasks(ctx, USE_TASKS);, +++ b/handler/src/main/java/io/netty/handler/ssl/ReferenceCountedOpenSslContext.java, +    private static final boolean USE_TASKS =, +            SystemPropertyUtil.getBoolean("io.netty.handler.ssl.openssl.useTasks", false);, +, +            SSLContext.setUseTasks(ctx, USE_TASKS);, +++ b/handler/src/main/java/io/netty/handler/ssl/ReferenceCountedOpenSslEngine.java, +import static javax.net.ssl.SSLEngineResult.HandshakeStatus.NEED_TASK;, +    private volatile boolean needTask;, +                    if (status == NEED_TASK) {, +                        return newResult(status, 0, bytesProduced);, +                    }, +, +                        } else if (sslError == SSL.SSL_ERROR_WANT_X509_LOOKUP) {, +                            return newResult(NEED_TASK, bytesConsumed, bytesProduced);, +        if (hs == NEED_TASK) {, +            // Set needTask to true so getHandshakeStatus() will return the correct value., +            needTask = true;, +        }, +, +                if (status == NEED_TASK) {, +                    return newResult(status, 0, 0);, +                }, +, +                                } else if (sslError == SSL.SSL_ERROR_WANT_X509_LOOKUP) {, +                                    return newResult(isInboundDone() ? CLOSED : OK,, +                                            NEED_TASK, bytesConsumed, bytesProduced);, +    public final synchronized Runnable getDelegatedTask() {, +        if (isDestroyed()) {, +        final Runnable task = SSL.getTask(ssl);, +        if (task == null) {, +            return null;, +        }, +        return new Runnable() {, +            @Override, +            public void run() {, +                try {, +                    if (isDestroyed()) {, +                        // The engine was destroyed in the meantime, just return., +                        return;, +                    }, +                    task.run();, +                } finally {, +                    // The task was run, reset needTask to false so getHandshakeStatus() returns the correct value., +                    needTask = false;, +                }, +            }, +        };, +    }, +                if (handshake() == NEED_TASK) {, +                    // Set needTask to true so getHandshakeStatus() will return the correct value., +                    needTask = true;, +                }, +            }, +, +            if (sslError == SSL.SSL_ERROR_WANT_X509_LOOKUP) {, +                return NEED_TASK;, +            }, +, +        // We have produced more data as part of the handshake if this is the case the user should call wrap(...), +        if (SSL.bioLengthNonApplication(networkBIO) > 0) {, +            return NEED_WRAP;, +        if (needPendingStatus()) {, +            if (needTask) {, +                // There is a task outstanding, +                return NEED_TASK;, +            }, +            return pendingStatus(SSL.bioLengthNonApplication(networkBIO));, +        }, +        return NOT_HANDSHAKING;, +        if (needPendingStatus()) {, +            if (needTask) {, +                // There is a task outstanding, +                return NEED_TASK;, +            }, +            return pendingStatus(pending);, +        }, +        return NOT_HANDSHAKING;, +++ b/handler/src/main/java/io/netty/handler/ssl/ReferenceCountedOpenSslContext.java, +    private static final boolean USE_TASKS =, +            SystemPropertyUtil.getBoolean("io.netty.handler.ssl.openssl.useTasks", false);, +, +            SSLContext.setUseTasks(ctx, USE_TASKS);, +++ b/handler/src/main/java/io/netty/handler/ssl/ReferenceCountedOpenSslEngine.java, +import static javax.net.ssl.SSLEngineResult.HandshakeStatus.NEED_TASK;, +    private volatile boolean needTask;, +                    if (status == NEED_TASK) {, +                        return newResult(status, 0, bytesProduced);, +                    }, +, +                        } else if (sslError == SSL.SSL_ERROR_WANT_X509_LOOKUP) {, +                            return newResult(NEED_TASK, bytesConsumed, bytesProduced);, +        if (hs == NEED_TASK) {, +            // Set needTask to true so getHandshakeStatus() will return the correct value., +            needTask = true;, +        }]