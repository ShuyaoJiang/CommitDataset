[+++ b/transport/src/main/java/io/netty/channel/ChannelOutboundBuffer.java, +    private volatile Runnable fireChannelWritabilityChangedTask;, +    ChannelOutboundBuffer(AbstractChannel channel) {, +        incrementPendingOutboundBytes(size, false);, +                    decrementPendingOutboundBytes(pending, false, true);, +    void incrementPendingOutboundBytes(long size) {, +        incrementPendingOutboundBytes(size, true);, +    }, +, +    private void incrementPendingOutboundBytes(long size, boolean invokeLater) {, +            setUnwritable(invokeLater);, +    void decrementPendingOutboundBytes(long size) {, +        decrementPendingOutboundBytes(size, true, true);, +    }, +, +    private void decrementPendingOutboundBytes(long size, boolean invokeLater, boolean notifyWritability) {, +        if (notifyWritability && (newWriteBufferSize == 0, +            || newWriteBufferSize <= channel.config().getWriteBufferLowWaterMark())) {, +            setWritable(invokeLater);, +            decrementPendingOutboundBytes(size, false, true);, +            decrementPendingOutboundBytes(size, false, notifyWritability);, +                    fireChannelWritabilityChanged(true);, +                    fireChannelWritabilityChanged(true);, +    private void setWritable(boolean invokeLater) {, +                if (oldValue != 0 && newValue == 0) {, +                    fireChannelWritabilityChanged(invokeLater);, +    private void setUnwritable(boolean invokeLater) {, +                if (oldValue == 0 && newValue != 0) {, +                    fireChannelWritabilityChanged(invokeLater);, +    private void fireChannelWritabilityChanged(boolean invokeLater) {, +        final ChannelPipeline pipeline = channel.pipeline();, +        if (invokeLater) {, +            Runnable task = fireChannelWritabilityChangedTask;, +            if (task == null) {, +                fireChannelWritabilityChangedTask = task = new Runnable() {, +                    @Override, +                    public void run() {, +                        pipeline.fireChannelWritabilityChanged();, +                    }, +                };, +            }, +            channel.eventLoop().execute(task);, +        } else {, +            pipeline.fireChannelWritabilityChanged();, +        }, +++ b/transport/src/main/java/io/netty/channel/ChannelOutboundBuffer.java, +    private volatile Runnable fireChannelWritabilityChangedTask;, +    ChannelOutboundBuffer(AbstractChannel channel) {, +        incrementPendingOutboundBytes(size, false);, +                    decrementPendingOutboundBytes(pending, false, true);, +    void incrementPendingOutboundBytes(long size) {, +        incrementPendingOutboundBytes(size, true);, +    }, +, +    private void incrementPendingOutboundBytes(long size, boolean invokeLater) {, +            setUnwritable(invokeLater);, +    void decrementPendingOutboundBytes(long size) {, +        decrementPendingOutboundBytes(size, true, true);, +    }, +, +    private void decrementPendingOutboundBytes(long size, boolean invokeLater, boolean notifyWritability) {, +        if (notifyWritability && (newWriteBufferSize == 0, +            || newWriteBufferSize <= channel.config().getWriteBufferLowWaterMark())) {, +            setWritable(invokeLater);, +            decrementPendingOutboundBytes(size, false, true);, +            decrementPendingOutboundBytes(size, false, notifyWritability);, +                    fireChannelWritabilityChanged(true);, +                    fireChannelWritabilityChanged(true);, +    private void setWritable(boolean invokeLater) {, +                if (oldValue != 0 && newValue == 0) {, +                    fireChannelWritabilityChanged(invokeLater);, +    private void setUnwritable(boolean invokeLater) {, +                if (oldValue == 0 && newValue != 0) {, +                    fireChannelWritabilityChanged(invokeLater);, +    private void fireChannelWritabilityChanged(boolean invokeLater) {, +        final ChannelPipeline pipeline = channel.pipeline();, +        if (invokeLater) {, +            Runnable task = fireChannelWritabilityChangedTask;, +            if (task == null) {, +                fireChannelWritabilityChangedTask = task = new Runnable() {, +                    @Override, +                    public void run() {, +                        pipeline.fireChannelWritabilityChanged();, +                    }, +                };, +            }, +            channel.eventLoop().execute(task);, +        } else {, +            pipeline.fireChannelWritabilityChanged();, +        }, +++ b/transport/src/main/java/io/netty/channel/DefaultChannelHandlerInvoker.java, +                    buffer.incrementPendingOutboundBytes(task.size);, +                    buffer.decrementPendingOutboundBytes(size);, +++ b/transport/src/main/java/io/netty/channel/ChannelOutboundBuffer.java, +    private volatile Runnable fireChannelWritabilityChangedTask;, +    ChannelOutboundBuffer(AbstractChannel channel) {, +        incrementPendingOutboundBytes(size, false);, +                    decrementPendingOutboundBytes(pending, false, true);, +    void incrementPendingOutboundBytes(long size) {, +        incrementPendingOutboundBytes(size, true);]