[+++ b/buffer/src/main/java/io/netty/buffer/ByteBuf.java, +++ b/buffer/src/main/java/io/netty/buffer/ByteBuf.java, +++ b/buffer/src/main/java/io/netty/buffer/ByteBufUtil.java, +        if (uintCount > 0) {, +            boolean bufferAIsBigEndian = bufferA.order() == ByteOrder.BIG_ENDIAN;, +            final long res;, +            int uintCountIncrement = uintCount << 2;, +, +                res = bufferAIsBigEndian ? compareUintBigEndian(bufferA, bufferB, aIndex, bIndex, uintCountIncrement) :, +                        compareUintLittleEndian(bufferA, bufferB, aIndex, bIndex, uintCountIncrement);, +                res = bufferAIsBigEndian ? compareUintBigEndianA(bufferA, bufferB, aIndex, bIndex, uintCountIncrement) :, +                        compareUintBigEndianB(bufferA, bufferB, aIndex, bIndex, uintCountIncrement);, +            if (res != 0) {, +                // Ensure we not overflow when cast, +                return (int) Math.min(Integer.MAX_VALUE, res);, +            aIndex += uintCountIncrement;, +            bIndex += uintCountIncrement;, +        for (int aEnd = aIndex + byteCount; aIndex < aEnd; ++aIndex, ++bIndex) {, +            int comp = bufferA.getUnsignedByte(aIndex) - bufferB.getUnsignedByte(bIndex);, +            if (comp != 0) {, +                return comp;, +    private static long compareUintBigEndian(, +            ByteBuf bufferA, ByteBuf bufferB, int aIndex, int bIndex, int uintCountIncrement) {, +        for (int aEnd = aIndex + uintCountIncrement; aIndex < aEnd; aIndex += 4, bIndex += 4) {, +            long comp = bufferA.getUnsignedInt(aIndex) - bufferB.getUnsignedInt(bIndex);, +            if (comp != 0) {, +                return comp;, +            }, +        }, +        return 0;, +    }, +, +    private static long compareUintLittleEndian(, +            ByteBuf bufferA, ByteBuf bufferB, int aIndex, int bIndex, int uintCountIncrement) {, +        for (int aEnd = aIndex + uintCountIncrement; aIndex < aEnd; aIndex += 4, bIndex += 4) {, +            long comp = bufferA.getUnsignedIntLE(aIndex) - bufferB.getUnsignedIntLE(bIndex);, +            if (comp != 0) {, +                return comp;, +            }, +        }, +        return 0;, +    }, +, +    private static long compareUintBigEndianA(, +            ByteBuf bufferA, ByteBuf bufferB, int aIndex, int bIndex, int uintCountIncrement) {, +        for (int aEnd = aIndex + uintCountIncrement; aIndex < aEnd; aIndex += 4, bIndex += 4) {, +            long comp =  bufferA.getUnsignedInt(aIndex) - bufferB.getUnsignedIntLE(bIndex);, +            if (comp != 0) {, +                return comp;, +            }, +        }, +        return 0;, +    }, +, +    private static long compareUintBigEndianB(, +            ByteBuf bufferA, ByteBuf bufferB, int aIndex, int bIndex, int uintCountIncrement) {, +        for (int aEnd = aIndex + uintCountIncrement; aIndex < aEnd; aIndex += 4, bIndex += 4) {, +            long comp =  bufferA.getUnsignedIntLE(aIndex) - bufferB.getUnsignedInt(bIndex);, +            if (comp != 0) {, +                return comp;, +            }, +        }, +        return 0;, +    }, +, +++ b/buffer/src/main/java/io/netty/buffer/ByteBuf.java, +++ b/buffer/src/main/java/io/netty/buffer/ByteBufUtil.java, +        if (uintCount > 0) {, +            boolean bufferAIsBigEndian = bufferA.order() == ByteOrder.BIG_ENDIAN;, +            final long res;, +            int uintCountIncrement = uintCount << 2;, +, +                res = bufferAIsBigEndian ? compareUintBigEndian(bufferA, bufferB, aIndex, bIndex, uintCountIncrement) :, +                        compareUintLittleEndian(bufferA, bufferB, aIndex, bIndex, uintCountIncrement);, +                res = bufferAIsBigEndian ? compareUintBigEndianA(bufferA, bufferB, aIndex, bIndex, uintCountIncrement) :, +                        compareUintBigEndianB(bufferA, bufferB, aIndex, bIndex, uintCountIncrement);, +            if (res != 0) {, +                // Ensure we not overflow when cast, +                return (int) Math.min(Integer.MAX_VALUE, res);, +            aIndex += uintCountIncrement;, +            bIndex += uintCountIncrement;, +        for (int aEnd = aIndex + byteCount; aIndex < aEnd; ++aIndex, ++bIndex) {, +            int comp = bufferA.getUnsignedByte(aIndex) - bufferB.getUnsignedByte(bIndex);, +            if (comp != 0) {, +                return comp;, +    private static long compareUintBigEndian(, +            ByteBuf bufferA, ByteBuf bufferB, int aIndex, int bIndex, int uintCountIncrement) {, +        for (int aEnd = aIndex + uintCountIncrement; aIndex < aEnd; aIndex += 4, bIndex += 4) {, +            long comp = bufferA.getUnsignedInt(aIndex) - bufferB.getUnsignedInt(bIndex);, +            if (comp != 0) {, +                return comp;, +            }, +        }, +        return 0;, +    }, +, +    private static long compareUintLittleEndian(, +            ByteBuf bufferA, ByteBuf bufferB, int aIndex, int bIndex, int uintCountIncrement) {, +        for (int aEnd = aIndex + uintCountIncrement; aIndex < aEnd; aIndex += 4, bIndex += 4) {, +            long comp = bufferA.getUnsignedIntLE(aIndex) - bufferB.getUnsignedIntLE(bIndex);]