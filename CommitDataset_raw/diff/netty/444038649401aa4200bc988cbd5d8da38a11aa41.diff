[+++ b/transport/src/main/java/io/netty/channel/AbstractChannel.java, +    private final ChannelPipeline pipeline;, +, +        pipeline = new DefaultChannelPipeline(this);, +        EventLoop eventLoop = this.eventLoop;, +                if (!inFlushNow) { // Avoid re-entrance, +                        if (!isFlushPending()) {, +                        } else {, +                            // Event loop will call flushNow() later by itself., +++ b/transport/src/main/java/io/netty/channel/AbstractChannel.java, +    private final ChannelPipeline pipeline;, +, +        pipeline = new DefaultChannelPipeline(this);, +        EventLoop eventLoop = this.eventLoop;, +                if (!inFlushNow) { // Avoid re-entrance, +                        if (!isFlushPending()) {, +                        } else {, +                            // Event loop will call flushNow() later by itself., +++ b/transport/src/main/java/io/netty/channel/DefaultChannelHandlerContext.java, +    private final Channel channel;, +        channel = pipeline.channel;, +        return channel;, +            return channel.eventLoop();, +        return channel.newFuture();, +        return channel.newSucceededFuture();, +        return channel.newFailedFuture(cause);, +++ b/transport/src/main/java/io/netty/channel/AbstractChannel.java, +    private final ChannelPipeline pipeline;, +, +        pipeline = new DefaultChannelPipeline(this);, +        EventLoop eventLoop = this.eventLoop;, +                if (!inFlushNow) { // Avoid re-entrance, +                        if (!isFlushPending()) {, +                        } else {, +                            // Event loop will call flushNow() later by itself., +++ b/transport/src/main/java/io/netty/channel/DefaultChannelHandlerContext.java, +    private final Channel channel;, +        channel = pipeline.channel;, +        return channel;, +            return channel.eventLoop();, +        return channel.newFuture();, +        return channel.newSucceededFuture();, +        return channel.newFailedFuture(cause);, +++ b/transport/src/main/java/io/netty/channel/DefaultChannelPipeline.java, +    private final Channel.Unsafe unsafe;, +    private final ChannelBufferHolder<Object> directOutbound;, +, +        unsafe = channel.unsafe();, +        directOutbound = unsafe.directOutbound();, +                if (directOutbound.hasByteBuffer()) {, +                    return directOutbound.byteBuffer();, +                if (directOutbound.hasMessageBuffer()) {, +                    return directOutbound.messageBuffer();, +            unsafe.bind(localAddress, future);, +            unsafe.connect(remoteAddress,  localAddress, future);, +            unsafe.disconnect(future);, +            unsafe.close(future);, +            unsafe.deregister(future);, +                flush0(ctx, future);, +            } else {, +                executor.execute(new Runnable() {, +                    @Override, +                    public void run() {, +                        flush(ctx, future);, +                    }, +                });, +            }, +        } else {, +            unsafe.flush(future);, +        }, +, +        return future;, +    }, +, +    private void flush0(final DefaultChannelHandlerContext ctx, ChannelFuture future) {, +            out = directOutbound;, +            if (ctx != null) {, +                flush0(ctx, future);, +            } else {, +                unsafe.flush(future);, +            }, +            return future;]