[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectAggregator.java, +import io.netty.util.ReferenceCountUtil;, +    private static final FullHttpResponse CONTINUE = new DefaultFullHttpResponse(, +            HttpVersion.HTTP_1_1, HttpResponseStatus.CONTINUE, Unpooled.EMPTY_BUFFER);, +    private static final FullHttpResponse TOO_LARGE = new DefaultFullHttpResponse(, +            HttpVersion.HTTP_1_1, HttpResponseStatus.REQUEST_ENTITY_TOO_LARGE, Unpooled.EMPTY_BUFFER);, +    private boolean is100Continue;, +    private boolean isKeepAlive;, +     *        {@link #messageTooLong(io.netty.channel.ChannelHandlerContext, HttpObject)}, +     *        will be called., +            is100Continue = is100ContinueExpected(m);, +            isKeepAlive = isKeepAlive(m);, +, +            // if content length is set, preemptively close if it's too large, +            if (isContentLengthSet(m)) {, +                if (getContentLength(m) > maxContentLength) {, +                    // handle oversized message, +                    handleMessageTooLong(ctx, m);, +                    return;, +                }, +            }, +, +            if (is100Continue) {, +                // handle oversized message, +                handleMessageTooLong(ctx, currentMessage);, +                return;, +    private void handleMessageTooLong(ChannelHandlerContext ctx, HttpObject msg) throws Exception {, +        tooLongFrameFound = true;, +        currentMessage = null;, +        messageTooLong(ctx, msg);, +    }, +, +    /**, +     * Invoked when an incoming request exceeds the maximum content length., +     *, +     * The default behavior returns a {@code 413} HTTP response., +     *, +     * Sub-classes may override this method to change behavior. <em>Note:</em>, +     * you are responsible for releasing {@code msg} if you override the, +     * default behavior., +     *, +     * @param ctx the {@link ChannelHandlerContext}, +     * @param msg the accumulated HTTP message up to this point, +     */, +    protected void messageTooLong(ChannelHandlerContext ctx, HttpObject msg) throws Exception {, +        // release current message to prevent leaks, +        ReferenceCountUtil.release(msg);, +, +        final ChannelHandlerContext context = ctx;, +        // send back a 413 and close the connection, +        ChannelFuture future = ctx.writeAndFlush(TOO_LARGE).addListener(new ChannelFutureListener() {, +            @Override, +            public void operationComplete(ChannelFuture future) throws Exception {, +                if (!future.isSuccess()) {, +                    context.fireExceptionCaught(future.cause());, +                }, +            }, +        });, +, +        if (!is100Continue || !isKeepAlive) {, +            future.addListener(ChannelFutureListener.CLOSE);, +        }, +    }, +, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectAggregator.java, +import io.netty.util.ReferenceCountUtil;, +    private static final FullHttpResponse CONTINUE = new DefaultFullHttpResponse(, +            HttpVersion.HTTP_1_1, HttpResponseStatus.CONTINUE, Unpooled.EMPTY_BUFFER);, +    private static final FullHttpResponse TOO_LARGE = new DefaultFullHttpResponse(, +            HttpVersion.HTTP_1_1, HttpResponseStatus.REQUEST_ENTITY_TOO_LARGE, Unpooled.EMPTY_BUFFER);, +    private boolean is100Continue;, +    private boolean isKeepAlive;, +     *        {@link #messageTooLong(io.netty.channel.ChannelHandlerContext, HttpObject)}, +     *        will be called., +            is100Continue = is100ContinueExpected(m);, +            isKeepAlive = isKeepAlive(m);, +, +            // if content length is set, preemptively close if it's too large, +            if (isContentLengthSet(m)) {, +                if (getContentLength(m) > maxContentLength) {, +                    // handle oversized message, +                    handleMessageTooLong(ctx, m);, +                    return;, +                }, +            }, +, +            if (is100Continue) {, +                // handle oversized message, +                handleMessageTooLong(ctx, currentMessage);, +                return;, +    private void handleMessageTooLong(ChannelHandlerContext ctx, HttpObject msg) throws Exception {, +        tooLongFrameFound = true;, +        currentMessage = null;, +        messageTooLong(ctx, msg);, +    }, +, +    /**, +     * Invoked when an incoming request exceeds the maximum content length., +     *, +     * The default behavior returns a {@code 413} HTTP response.]