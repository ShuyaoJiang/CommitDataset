[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2ConnectionEncoder.java, +import io.netty.buffer.Unpooled;, +import io.netty.util.ReferenceCountUtil;, +            connection.remote().flowController(new DefaultHttp2RemoteFlowController(connection));, +        final Http2Stream stream;, +        flowController().sendFlowControlled(ctx, stream,, +                new FlowControlledData(ctx, stream, data, padding, endOfStream, promise));, +        return promise;, +            Http2Stream stream = connection.stream(streamId);, +                stream = connection.createLocalStream(streamId);, +            } else if (stream.isResetSent()) {, +            } else if (stream.isEndOfStreamSent()) {, +            // Pass headers to the flow-controller so it can maintain their sequence relative to DATA frames., +            flowController().sendFlowControlled(ctx, stream,, +                    new FlowControlledHeaders(ctx, stream, headers, streamDependency, weight,, +                            exclusive, padding, endOfStream, promise));, +            if (endOfStream) {, +                // Flag delivery of EOS synchronously to prevent subsequent frames being enqueued in the flow, +                // controller., +                stream.endOfStreamSent();, +            return promise;, +, +    /**, +     * Wrap a DATA frame so it can be written subject to flow-control. Note that this implementation assumes it, +     * only writes padding once for the entire payload as opposed to writing it once per-frame. This makes the, +     * {@link #size} calculation deterministic thereby greatly simplifying the implementation., +     * <p>, +     * If frame-splitting is required to fit within max-frame-size and flow-control constraints we ensure that, +     * the passed promise is not completed until last frame write., +     * </p>, +     */, +    private final class FlowControlledData extends FlowControlledBase {, +        private ByteBuf data;, +        private int size;, +, +        private FlowControlledData(ChannelHandlerContext ctx, Http2Stream stream, ByteBuf data, int padding,, +                                    boolean endOfStream, ChannelPromise promise) {, +            super(ctx, stream, padding, endOfStream, promise);, +            this.data = data;, +            size = data.readableBytes() + padding;, +        }, +, +        @Override, +        public int size() {, +            return size;, +        }, +, +        @Override, +        public void error(Throwable cause) {, +            ReferenceCountUtil.safeRelease(data);, +            lifecycleManager.onException(ctx, cause);, +            data = null;, +            size = 0;, +            promise.tryFailure(cause);, +        }, +, +        @Override, +        public boolean write(int allowedBytes) {, +            if (data == null) {, +                return false;, +            }, +            if (allowedBytes == 0 && size() != 0) {, +                // No point writing an empty DATA frame, wait for a bigger allowance., +                return false;, +            }, +            int maxFrameSize = frameWriter().configuration().frameSizePolicy().maxFrameSize();, +            try {, +                int bytesWritten = 0;, +                do {, +                    int allowedFrameSize = Math.min(maxFrameSize, allowedBytes - bytesWritten);, +                    ByteBuf toWrite;, +                    // Let data consume the frame before padding., +                    int writeableData = data.readableBytes();, +                    if (writeableData > allowedFrameSize) {, +                        writeableData = allowedFrameSize;, +                        toWrite = data.readSlice(writeableData).retain();, +                    } else {, +                        // We're going to write the full buffer which will cause it to be released, for subsequent, +                        // writes just use empty buffer to avoid over-releasing. Have to use an empty buffer, +                        // as we may continue to write padding in subsequent frames., +                        toWrite = data;, +                        data = Unpooled.EMPTY_BUFFER;, +                    }, +                    int writeablePadding = Math.min(allowedFrameSize - writeableData, padding);, +                    padding -= writeablePadding;, +                    bytesWritten += writeableData + writeablePadding;, +                    ChannelPromise writePromise;, +                    if (size == bytesWritten) {, +                        // Can use the original promise if it's the last write, +                        writePromise = promise;, +                    } else {, +                        // Create a new promise and listen to it for failure, +                        writePromise = ctx.newPromise();, +                        writePromise.addListener(this);, +                    }, +                    frameWriter().writeData(ctx, stream.id(), toWrite, writeablePadding,, +                            size == bytesWritten && endOfStream, writePromise);, +                } while (size != bytesWritten && allowedBytes > bytesWritten);, +                size -= bytesWritten;, +                return true;]