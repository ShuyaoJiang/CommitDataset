[+++ b/common/src/main/java/io/netty/util/concurrent/SingleThreadEventExecutor.java, +    public int pendingTasks() {, +++ b/common/src/main/java/io/netty/util/concurrent/SingleThreadEventExecutor.java, +    public int pendingTasks() {, +++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollEventLoop.java, +import java.util.concurrent.Callable;, +    private final Callable<Integer> pendingTasksCallable = new Callable<Integer>() {, +        @Override, +        public Integer call() throws Exception {, +            return EpollEventLoop.super.pendingTasks();, +        }, +    };, +    @Override, +    public int pendingTasks() {, +        // As we use a MpscQueue we need to ensure pendingTasks() is only executed from within the EventLoop as, +        // otherwise we may see unexpected behavior (as size() is only allowed to be called by a single consumer)., +        // See https://github.com/netty/netty/issues/5297, +        if (inEventLoop()) {, +            return super.pendingTasks();, +        } else {, +            return submit(pendingTasksCallable).syncUninterruptibly().getNow();, +        }, +    }, +++ b/common/src/main/java/io/netty/util/concurrent/SingleThreadEventExecutor.java, +    public int pendingTasks() {, +++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollEventLoop.java, +import java.util.concurrent.Callable;, +    private final Callable<Integer> pendingTasksCallable = new Callable<Integer>() {, +        @Override, +        public Integer call() throws Exception {, +            return EpollEventLoop.super.pendingTasks();, +        }, +    };, +    @Override, +    public int pendingTasks() {, +        // As we use a MpscQueue we need to ensure pendingTasks() is only executed from within the EventLoop as, +        // otherwise we may see unexpected behavior (as size() is only allowed to be called by a single consumer)., +        // See https://github.com/netty/netty/issues/5297, +        if (inEventLoop()) {, +            return super.pendingTasks();, +        } else {, +            return submit(pendingTasksCallable).syncUninterruptibly().getNow();, +        }, +    }, +++ b/transport/src/main/java/io/netty/channel/nio/NioEventLoop.java, +import java.util.concurrent.Callable;, +    private final Callable<Integer> pendingTasksCallable = new Callable<Integer>() {, +        @Override, +        public Integer call() throws Exception {, +            return NioEventLoop.super.pendingTasks();, +        }, +    };, +    @Override, +    public int pendingTasks() {, +        // As we use a MpscQueue we need to ensure pendingTasks() is only executed from within the EventLoop as, +        // otherwise we may see unexpected behavior (as size() is only allowed to be called by a single consumer)., +        // See https://github.com/netty/netty/issues/5297, +        if (inEventLoop()) {, +            return super.pendingTasks();, +        } else {, +            return submit(pendingTasksCallable).syncUninterruptibly().getNow();, +        }, +    }, +]