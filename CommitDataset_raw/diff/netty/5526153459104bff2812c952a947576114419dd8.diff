[+++ b/codec/src/main/java/io/netty/handler/codec/ByteToByteEncoder.java, +import io.netty.channel.PartialFlushException;, +        boolean encoded = false;, +                encoded = true;, +                Throwable cause;, +                    cause = t;, +                    cause = new EncoderException(t);, +                if (encoded) {, +                    cause = new PartialFlushException("Unable to encoded all bytes", cause);, +                }, +                in.discardSomeReadBytes();, +                promise.setFailure(cause);, +                return;, +++ b/codec/src/main/java/io/netty/handler/codec/ByteToByteEncoder.java, +import io.netty.channel.PartialFlushException;, +        boolean encoded = false;, +                encoded = true;, +                Throwable cause;, +                    cause = t;, +                    cause = new EncoderException(t);, +                if (encoded) {, +                    cause = new PartialFlushException("Unable to encoded all bytes", cause);, +                }, +                in.discardSomeReadBytes();, +                promise.setFailure(cause);, +                return;, +++ b/codec/src/main/java/io/netty/handler/codec/MessageToMessageEncoder.java, +import io.netty.channel.PartialFlushException;, +        boolean encoded = false;, +, +                    encoded = true;, +                Throwable cause;, +                    cause = t;, +                    cause = new EncoderException(t);, +                }, +                if (encoded) {, +                    cause = new PartialFlushException("Unable to encoded all messages", cause);, +                }, +                promise.setFailure(cause);, +                return;, +++ b/codec/src/main/java/io/netty/handler/codec/ByteToByteEncoder.java, +import io.netty.channel.PartialFlushException;, +        boolean encoded = false;, +                encoded = true;, +                Throwable cause;, +                    cause = t;, +                    cause = new EncoderException(t);, +                if (encoded) {, +                    cause = new PartialFlushException("Unable to encoded all bytes", cause);, +                }, +                in.discardSomeReadBytes();, +                promise.setFailure(cause);, +                return;, +++ b/codec/src/main/java/io/netty/handler/codec/MessageToMessageEncoder.java, +import io.netty.channel.PartialFlushException;, +        boolean encoded = false;, +, +                    encoded = true;, +                Throwable cause;, +                    cause = t;, +                    cause = new EncoderException(t);, +                }, +                if (encoded) {, +                    cause = new PartialFlushException("Unable to encoded all messages", cause);, +                }, +                promise.setFailure(cause);, +                return;, +++ b/transport/src/main/java/io/netty/channel/ChannelOutboundInvoker.java, +     * <p>, +     * Be aware that the flush could be only partially successful. In such cases the {@link ChannelFuture} will be, +     * failed with an {@link PartialFlushException}. So if you are interested to know if it was partial successful you, +     * need to check if the returned {@link ChannelFuture#cause()} returns an instance of, +     * {@link PartialFlushException}. In such cases you may want to call {@link #flush(ChannelPromise)} or, +     * {@link #flush()} to flush the rest of the data or just close the connection via {@link #close(ChannelPromise)} or, +     * {@link #close()}  if it is not possible to recover., +     * If you want to write a {@link FileRegion} use {@link #sendFile(FileRegion)}., +     * <p>, +     * Be aware that the write could be only partially successful as the message may need to get encoded before write it, +     * to the remote peer. In such cases the {@link ChannelFuture} will be failed with a {@link PartialFlushException}., +     * In such cases you may want to call {@link #flush(ChannelPromise)} or  {@link #flush()} to flush the rest of the, +     * data or just close the connection via {@link #close(ChannelPromise)} or {@link #close()} if it is not possible, +     * to recover., +     * <p>, +     * Be aware that the flush could be only partially successful. In such cases the {@link ChannelFuture} will be, +     * failed with an {@link PartialFlushException}. So if you are interested to know if it was partial successful you, +     * need to check if the returned {@link ChannelFuture#cause()} returns an instance of, +     * {@link PartialFlushException}. In such cases you may want to call {@link #flush(ChannelPromise)} or, +     * {@link #flush()} to flush the rest of the data or just close the connection via {@link #close(ChannelPromise)} or, +     * {@link #close()}  if it is not possible to recover., +     * <p>, +     * Be aware that the write could be only partially successful as the message may need to get encoded before write it, +     * to the remote peer. In such cases the {@link ChannelFuture} will be failed with a {@link PartialFlushException}., +     * In such cases you may want to call {@link #flush(ChannelPromise)} or  {@link #flush()} to flush the rest of the, +     * data or just close the connection via {@link #close(ChannelPromise)} or {@link #close()} if it is not possible, +     * to recover., +++ b/codec/src/main/java/io/netty/handler/codec/ByteToByteEncoder.java, +import io.netty.channel.PartialFlushException;, +        boolean encoded = false;, +                encoded = true;, +                Throwable cause;]