[+++ b/buffer/src/main/java/io/netty/buffer/stream/AbstractStream.java, +/*, + * Copyright 2013 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + *   http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the, + * License for the specific language governing permissions and limitations, + * under the License., + */, +, +package io.netty.buffer.stream;, +, +import io.netty.buffer.Buf;, +import io.netty.util.concurrent.EventExecutor;, +import io.netty.util.internal.PlatformDependent;, +import io.netty.util.internal.logging.InternalLogger;, +import io.netty.util.internal.logging.InternalLoggerFactory;, +, +import java.util.Random;, +, +public abstract class AbstractStream<T extends Buf> implements Stream<T> {, +, +    private static final InternalLogger logger = InternalLoggerFactory.getInstance(AbstractStream.class);, +, +    private static final Random random = new Random();, +, +    private static final ThreadLocal<Boolean> IN_CONSUMER = new ThreadLocal<Boolean>() {, +        @Override, +        protected Boolean initialValue() {, +            return Boolean.FALSE;, +        }, +    };, +, +    /**, +     * Generate a random string that can be used for correlating a group of log messages., +     */, +    private static String nextLogKey() {, +        return Long.toHexString(random.nextInt() & 0xFFFFFFFFL);, +    }, +, +    private final StreamProducerContextImpl producerCtx;, +    private StreamConsumerContextImpl consumerCtx;, +    private Runnable invokeStreamConsumedTask;, +, +    /**  0 - init, 1 - accepted, 2 - discarded, 3 - rejected, 4 - closed */, +    int state;, +    T buffer;, +, +    @SuppressWarnings("unchecked"), +    protected AbstractStream(EventExecutor executor, StreamProducer<? super T> producer) {, +        producerCtx = new StreamProducerContextImpl(executor, producer);, +    }, +, +    T buffer() {, +        T buffer = this.buffer;, +        if (buffer == null) {, +            fail();, +        }, +        return buffer;, +    }, +, +    @Override, +    public void accept(EventExecutor executor, StreamConsumer<? super T> consumer) {, +        if (executor == null) {, +            throw new NullPointerException("executor");, +        }, +        if (consumer == null) {, +            throw new NullPointerException("handler");, +        }, +, +        if (state != 0) {, +            fail();, +        }, +, +        StreamConsumerContextImpl consumerCtx = new StreamConsumerContextImpl(executor, consumer);, +, +        @SuppressWarnings("unchecked"), +        StreamConsumer<T> h = (StreamConsumer<T>) consumer;, +        try {, +            buffer = h.newStreamBuffer(consumerCtx);, +        } catch (Throwable t) {, +            PlatformDependent.throwException(t);, +        }, +, +        this.consumerCtx = consumerCtx;, +        state = 1;, +, +        fireStreamAccepted();, +    }, +, +    private void fireStreamAccepted() {, +        EventExecutor e = producerCtx.executor;, +        if (e.inEventLoop()) {]