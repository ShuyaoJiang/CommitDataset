[+++ b/codec/src/main/java/io/netty/handler/codec/compression/Snappy.java, +import io.netty.buffer.BufUtil;, +import java.util.zip.CRC32;, +, +, +    private enum State {, +     * @return The number of bytes appended to the output buffer, or -1 to indicate "try again later", +            length = BufUtil.swapShort(in.readShort());, +            length = BufUtil.swapMedium(in.readUnsignedMedium());, +            length = BufUtil.swapInt(in.readInt());, +        int offset = BufUtil.swapShort(in.readShort());, +        int offset = BufUtil.swapInt(in.readInt());, +, +    /**, +     * Computes the CRC32 checksum of the supplied data and performs the "mask" operation, +     * on the computed checksum, +     *, +     * @param data The input data to calculate the CRC32 checksum of, +     */, +    public static int calculateChecksum(ByteBuf data) {, +        return calculateChecksum(data, data.readerIndex(), data.readableBytes());, +    }, +, +    /**, +     * Computes the CRC32 checksum of the supplied data and performs the "mask" operation, +     * on the computed checksum, +     *, +     * @param data The input data to calculate the CRC32 checksum of, +     */, +    public static int calculateChecksum(ByteBuf data, int offset, int length) {, +        CRC32 crc32 = new CRC32();, +        try {, +            if (data.hasArray()) {, +                crc32.update(data.array(), data.arrayOffset() + offset, length);, +            } else {, +                byte[] array = new byte[length];, +                data.getBytes(offset, array);, +                crc32.update(array);, +            }, +, +            return maskChecksum((int) crc32.getValue());, +        } finally {, +            crc32.reset();, +        }, +    }, +, +    /**, +     * Computes the CRC32 checksum of the supplied data, performs the "mask" operation, +     * on the computed checksum, and then compares the resulting masked checksum to the, +     * supplied checksum., +     *, +     * @param expectedChecksum The checksum decoded from the stream to compare against, +     * @param data The input data to calculate the CRC32 checksum of, +     * @throws CompressionException If the calculated and supplied checksums do not match, +     */, +    static void validateChecksum(int expectedChecksum, ByteBuf data) {, +        validateChecksum(expectedChecksum, data, data.readerIndex(), data.readableBytes());, +    }, +, +    /**, +     * Computes the CRC32 checksum of the supplied data, performs the "mask" operation, +     * on the computed checksum, and then compares the resulting masked checksum to the, +     * supplied checksum., +     *, +     * @param expectedChecksum The checksum decoded from the stream to compare against, +     * @param data The input data to calculate the CRC32 checksum of, +     * @throws CompressionException If the calculated and supplied checksums do not match, +     */, +    static void validateChecksum(int expectedChecksum, ByteBuf data, int offset, int length) {, +        final int actualChecksum = calculateChecksum(data, offset, length);, +        if (actualChecksum != expectedChecksum) {, +            throw new CompressionException(, +                    "mismatching checksum: " + Integer.toHexString(actualChecksum) +, +                            " (expected: " + Integer.toHexString(expectedChecksum) + ')');, +        }, +    }, +, +    /**, +     * From the spec:, +     *, +     * "Checksums are not stored directly, but masked, as checksumming data and, +     * then its own checksum can be problematic. The masking is the same as used, +     * in Apache Hadoop: Rotate the checksum by 15 bits, then add the constant, +     * 0xa282ead8 (using wraparound as normal for unsigned integers).", +     *, +     * @param checksum The actual checksum of the data, +     * @return The masked checksum, +     */, +    static int maskChecksum(int checksum) {, +        return (checksum >> 15 | checksum << 17) + 0xa282ead8;, +    }, +++ b/codec/src/main/java/io/netty/handler/codec/compression/Snappy.java, +import io.netty.buffer.BufUtil;, +import java.util.zip.CRC32;, +, +, +    private enum State {, +     * @return The number of bytes appended to the output buffer, or -1 to indicate "try again later", +            length = BufUtil.swapShort(in.readShort());, +            length = BufUtil.swapMedium(in.readUnsignedMedium());]