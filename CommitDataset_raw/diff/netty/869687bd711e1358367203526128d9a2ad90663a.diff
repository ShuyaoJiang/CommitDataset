[+++ b/buffer/src/main/java/io/netty/buffer/ByteBufUtil.java, +import io.netty.util.Recycler;, +import io.netty.util.Recycler.Handle;, +    private static final int THREAD_LOCAL_BUFFER_SIZE;, +, +        String allocType = SystemPropertyUtil.get("io.netty.allocator.type", "unpooled").toLowerCase(Locale.US).trim();, +, +        THREAD_LOCAL_BUFFER_SIZE = SystemPropertyUtil.getInt("io.netty.threadLocalDirectBufferSize", 64 * 1024);, +        logger.debug("-Dio.netty.threadLocalDirectBufferSize: {}", THREAD_LOCAL_BUFFER_SIZE);, +    /**, +     * Returns a cached thread-local direct buffer, if available., +     *, +     * @return a cached thread-local direct buffer, if available.  {@code null} otherwise., +     */, +    public static ByteBuf threadLocalDirectBuffer() {, +        if (THREAD_LOCAL_BUFFER_SIZE <= 0) {, +            return null;, +        }, +, +        if (PlatformDependent.hasUnsafe()) {, +            return ThreadLocalUnsafeDirectByteBuf.newInstance();, +        } else {, +            return ThreadLocalDirectByteBuf.newInstance();, +        }, +    }, +, +    static final class ThreadLocalUnsafeDirectByteBuf extends UnpooledUnsafeDirectByteBuf {, +, +        private static final Recycler<ThreadLocalUnsafeDirectByteBuf> RECYCLER =, +                new Recycler<ThreadLocalUnsafeDirectByteBuf>() {, +                    @Override, +                    protected ThreadLocalUnsafeDirectByteBuf newObject(Handle handle) {, +                        return new ThreadLocalUnsafeDirectByteBuf(handle);, +                    }, +                };, +, +        static ThreadLocalUnsafeDirectByteBuf newInstance() {, +            ThreadLocalUnsafeDirectByteBuf buf = RECYCLER.get();, +            buf.setRefCnt(1);, +            return buf;, +        }, +, +        private final Handle handle;, +, +        private ThreadLocalUnsafeDirectByteBuf(Handle handle) {, +            super(UnpooledByteBufAllocator.DEFAULT, 256, Integer.MAX_VALUE);, +            this.handle = handle;, +        }, +, +        @Override, +        protected void deallocate() {, +            if (capacity() > THREAD_LOCAL_BUFFER_SIZE) {, +                super.deallocate();, +            } else {, +                clear();, +                RECYCLER.recycle(this, handle);, +            }, +        }, +    }, +, +    static final class ThreadLocalDirectByteBuf extends UnpooledDirectByteBuf {, +, +        private static final Recycler<ThreadLocalDirectByteBuf> RECYCLER = new Recycler<ThreadLocalDirectByteBuf>() {, +            @Override, +            protected ThreadLocalDirectByteBuf newObject(Handle handle) {, +                return new ThreadLocalDirectByteBuf(handle);, +            }, +        };, +, +        static ThreadLocalDirectByteBuf newInstance() {, +            ThreadLocalDirectByteBuf buf = RECYCLER.get();, +            buf.setRefCnt(1);, +            return buf;, +        }, +, +        private final Handle handle;, +, +        private ThreadLocalDirectByteBuf(Handle handle) {, +            super(UnpooledByteBufAllocator.DEFAULT, 256, Integer.MAX_VALUE);, +            this.handle = handle;, +        }, +, +        @Override, +        protected void deallocate() {, +            if (capacity() > THREAD_LOCAL_BUFFER_SIZE) {, +                super.deallocate();, +            } else {, +                clear();, +                RECYCLER.recycle(this, handle);, +            }, +        }, +    }, +, +++ b/buffer/src/main/java/io/netty/buffer/ByteBufUtil.java, +import io.netty.util.Recycler;, +import io.netty.util.Recycler.Handle;, +    private static final int THREAD_LOCAL_BUFFER_SIZE;, +, +        String allocType = SystemPropertyUtil.get("io.netty.allocator.type", "unpooled").toLowerCase(Locale.US).trim();, +]