[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/internal/hpack/Encoder.java, +import static io.netty.util.internal.MathUtil.findNextPositivePowerOfTwo;, +import static java.lang.Math.max;, +import static java.lang.Math.min;, +    private final HeaderEntry[] headerFields;, +    private final HuffmanEncoder huffmanEncoder = new HuffmanEncoder();, +    private final byte hashMask;, +        this(maxHeaderTableSize, 16);, +    }, +, +    /**, +     * Creates a new encoder., +     */, +    public Encoder(int maxHeaderTableSize, int arraySizeHint) {, +        this(maxHeaderTableSize, true, false, false, arraySizeHint);, +            boolean forceHuffmanOff,, +            int arraySizeHint, +        // Enforce a bound of [2, 128] because hashMask is a byte. The max possible value of hashMask is one less, +        // than the length of this array, and we want the mask to be > 0., +        headerFields = new HeaderEntry[findNextPositivePowerOfTwo(max(2, min(arraySizeHint, 128)))];, +        hashMask = (byte) (headerFields.length - 1);, +        int h = AsciiString.hashCode(name);, +        int h = AsciiString.hashCode(name);, +                return getIndex(e.index);, +        return -1;, +        return index == -1 ? -1 : index - head.before.index + 1;, +        int h = AsciiString.hashCode(name);, +    private int index(int h) {, +        return h & hashMask;, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/internal/hpack/Encoder.java, +import static io.netty.util.internal.MathUtil.findNextPositivePowerOfTwo;, +import static java.lang.Math.max;, +import static java.lang.Math.min;, +    private final HeaderEntry[] headerFields;, +    private final HuffmanEncoder huffmanEncoder = new HuffmanEncoder();, +    private final byte hashMask;, +        this(maxHeaderTableSize, 16);, +    }, +, +    /**, +     * Creates a new encoder., +     */, +    public Encoder(int maxHeaderTableSize, int arraySizeHint) {, +        this(maxHeaderTableSize, true, false, false, arraySizeHint);, +            boolean forceHuffmanOff,, +            int arraySizeHint, +        // Enforce a bound of [2, 128] because hashMask is a byte. The max possible value of hashMask is one less, +        // than the length of this array, and we want the mask to be > 0., +        headerFields = new HeaderEntry[findNextPositivePowerOfTwo(max(2, min(arraySizeHint, 128)))];, +        hashMask = (byte) (headerFields.length - 1);, +        int h = AsciiString.hashCode(name);, +        int h = AsciiString.hashCode(name);, +                return getIndex(e.index);, +        return -1;, +        return index == -1 ? -1 : index - head.before.index + 1;, +        int h = AsciiString.hashCode(name);, +    private int index(int h) {, +        return h & hashMask;, +++ b/codec-http2/src/test/java/io/netty/handler/codec/http2/internal/hpack/TestCase.java, +        return new Encoder(maxHeaderTableSize, useIndexing, forceHuffmanOn, forceHuffmanOff, 16);, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/internal/hpack/Encoder.java, +import static io.netty.util.internal.MathUtil.findNextPositivePowerOfTwo;, +import static java.lang.Math.max;, +import static java.lang.Math.min;, +    private final HeaderEntry[] headerFields;, +    private final HuffmanEncoder huffmanEncoder = new HuffmanEncoder();, +    private final byte hashMask;, +        this(maxHeaderTableSize, 16);, +    }, +, +    /**, +     * Creates a new encoder., +     */, +    public Encoder(int maxHeaderTableSize, int arraySizeHint) {, +        this(maxHeaderTableSize, true, false, false, arraySizeHint);, +            boolean forceHuffmanOff,, +            int arraySizeHint, +        // Enforce a bound of [2, 128] because hashMask is a byte. The max possible value of hashMask is one less, +        // than the length of this array, and we want the mask to be > 0., +        headerFields = new HeaderEntry[findNextPositivePowerOfTwo(max(2, min(arraySizeHint, 128)))];, +        hashMask = (byte) (headerFields.length - 1);, +        int h = AsciiString.hashCode(name);, +        int h = AsciiString.hashCode(name);, +                return getIndex(e.index);, +        return -1;, +        return index == -1 ? -1 : index - head.before.index + 1;, +        int h = AsciiString.hashCode(name);, +    private int index(int h) {, +        return h & hashMask;, +++ b/codec-http2/src/test/java/io/netty/handler/codec/http2/internal/hpack/TestCase.java, +        return new Encoder(maxHeaderTableSize, useIndexing, forceHuffmanOn, forceHuffmanOff, 16);, +++ b/codec/src/main/java/io/netty/handler/codec/DefaultHeaders.java, +        // Enforce a bound of [2, 128] because hashMask is a byte. The max possible value of hashMask is one less, +        // than the length of this array, and we want the mask to be > 0., +        entries = new DefaultHeaders.HeaderEntry[findNextPositivePowerOfTwo(max(2, min(arraySizeHint, 128)))];, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/internal/hpack/Encoder.java, +import static io.netty.util.internal.MathUtil.findNextPositivePowerOfTwo;, +import static java.lang.Math.max;, +import static java.lang.Math.min;, +    private final HeaderEntry[] headerFields;]