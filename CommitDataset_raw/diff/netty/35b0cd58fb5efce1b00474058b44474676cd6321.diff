[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2ConnectionEncoder.java, +                    // and it is not end of stream yet. Just complete their promises by getting the buffer corresponding, +                    // to 0 bytes and writing it to the channel (to preserve notification order)., +                    ctx.write(queue.remove(0, writePromise), writePromise);, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2ConnectionEncoder.java, +                    // and it is not end of stream yet. Just complete their promises by getting the buffer corresponding, +                    // to 0 bytes and writing it to the channel (to preserve notification order)., +                    ctx.write(queue.remove(0, writePromise), writePromise);, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2FrameWriter.java, +            try {, +            } finally {, +                promiseAggregator.doneAllocatingPromises();, +            }, +            return promiseAggregator;, +    public ChannelFuture writePing(ChannelHandlerContext ctx, boolean ack, ByteBuf data, ChannelPromise promise) {, +        final SimpleChannelPromiseAggregator promiseAggregator =, +            int payloadLength = data.readableBytes();, +            // Assume nothing below will throw until buf is written. That way we don't have to take care of ownership, +            // in the catch block., +            writeFrameHeaderInternal(buf, payloadLength, PING, flags, 0);, +        } catch (Throwable t) {, +            try {, +                data.release();, +            } finally {, +                promiseAggregator.setFailure(t);, +                promiseAggregator.doneAllocatingPromises();, +            }, +            return promiseAggregator;, +        }, +        try {, +, +            // Assume nothing below will throw until buf is written. That way we don't have to take care of ownership, +            // in the catch block., +        } catch (Throwable t) {, +            try {, +                debugData.release();, +            } finally {, +                promiseAggregator.setFailure(t);, +                promiseAggregator.doneAllocatingPromises();, +            }, +            return promiseAggregator;, +        }, +        try {, +            // Assume nothing below will throw until buf is written. That way we don't have to take care of ownership, +            // in the catch block., +        } catch (Throwable t) {, +            try {, +                payload.release();, +            } finally {, +                promiseAggregator.setFailure(t);, +                promiseAggregator.doneAllocatingPromises();, +            }, +            return promiseAggregator;, +        }, +        try {, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2ConnectionEncoder.java, +                    // and it is not end of stream yet. Just complete their promises by getting the buffer corresponding, +                    // to 0 bytes and writing it to the channel (to preserve notification order)., +                    ctx.write(queue.remove(0, writePromise), writePromise);, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2FrameWriter.java, +            try {, +            } finally {, +                promiseAggregator.doneAllocatingPromises();, +            }, +            return promiseAggregator;, +    public ChannelFuture writePing(ChannelHandlerContext ctx, boolean ack, ByteBuf data, ChannelPromise promise) {, +        final SimpleChannelPromiseAggregator promiseAggregator =, +            int payloadLength = data.readableBytes();, +            // Assume nothing below will throw until buf is written. That way we don't have to take care of ownership, +            // in the catch block., +            writeFrameHeaderInternal(buf, payloadLength, PING, flags, 0);, +        } catch (Throwable t) {, +            try {, +                data.release();, +            } finally {, +                promiseAggregator.setFailure(t);, +                promiseAggregator.doneAllocatingPromises();, +            }, +            return promiseAggregator;, +        }, +        try {, +, +            // Assume nothing below will throw until buf is written. That way we don't have to take care of ownership, +            // in the catch block., +        } catch (Throwable t) {, +            try {, +                debugData.release();, +            } finally {, +                promiseAggregator.setFailure(t);, +                promiseAggregator.doneAllocatingPromises();, +            }, +            return promiseAggregator;, +        }, +        try {, +            // Assume nothing below will throw until buf is written. That way we don't have to take care of ownership, +            // in the catch block., +        } catch (Throwable t) {, +            try {, +                payload.release();, +            } finally {]