[+++ b/transport/src/main/java/io/netty/channel/embedded/EmbeddedChannel.java, +        checkException();, +        return isNotEmpty(inboundMessages) || isNotEmpty(outboundMessages);, +    }, +    private void finishPendingTasks() {, +        runPendingTasks();, +    }, +    @Override, +    public final ChannelFuture close() {, +        ChannelFuture future = super.close();, +        finishPendingTasks();, +        return future;, +    }, +    @Override, +    public final ChannelFuture disconnect() {, +        ChannelFuture future = super.disconnect();, +        finishPendingTasks();, +        return future;, +    }, +, +    @Override, +    public final ChannelFuture close(ChannelPromise promise) {, +        ChannelFuture future = super.close(promise);, +        finishPendingTasks();, +        return future;, +    }, +, +    @Override, +    public final ChannelFuture disconnect(ChannelPromise promise) {, +        ChannelFuture future = super.disconnect(promise);, +        finishPendingTasks();, +        return future;, +++ b/transport/src/main/java/io/netty/channel/embedded/EmbeddedChannel.java, +        checkException();, +        return isNotEmpty(inboundMessages) || isNotEmpty(outboundMessages);, +    }, +    private void finishPendingTasks() {, +        runPendingTasks();, +    }, +    @Override, +    public final ChannelFuture close() {, +        ChannelFuture future = super.close();, +        finishPendingTasks();, +        return future;, +    }, +    @Override, +    public final ChannelFuture disconnect() {, +        ChannelFuture future = super.disconnect();, +        finishPendingTasks();, +        return future;, +    }, +, +    @Override, +    public final ChannelFuture close(ChannelPromise promise) {, +        ChannelFuture future = super.close(promise);, +        finishPendingTasks();, +        return future;, +    }, +, +    @Override, +    public final ChannelFuture disconnect(ChannelPromise promise) {, +        ChannelFuture future = super.disconnect(promise);, +        finishPendingTasks();, +        return future;, +++ b/transport/src/test/java/io/netty/channel/PendingWriteQueueTest.java, +        ChannelHandlerContext context = channel.pipeline().firstContext();, +        final PendingWriteQueue queue = new PendingWriteQueue(context);, +++ b/transport/src/main/java/io/netty/channel/embedded/EmbeddedChannel.java, +        checkException();, +        return isNotEmpty(inboundMessages) || isNotEmpty(outboundMessages);, +    }, +    private void finishPendingTasks() {, +        runPendingTasks();, +    }, +    @Override, +    public final ChannelFuture close() {, +        ChannelFuture future = super.close();, +        finishPendingTasks();, +        return future;, +    }, +    @Override, +    public final ChannelFuture disconnect() {, +        ChannelFuture future = super.disconnect();, +        finishPendingTasks();, +        return future;, +    }, +, +    @Override, +    public final ChannelFuture close(ChannelPromise promise) {, +        ChannelFuture future = super.close(promise);, +        finishPendingTasks();, +        return future;, +    }, +, +    @Override, +    public final ChannelFuture disconnect(ChannelPromise promise) {, +        ChannelFuture future = super.disconnect(promise);, +        finishPendingTasks();, +        return future;, +++ b/transport/src/test/java/io/netty/channel/PendingWriteQueueTest.java]