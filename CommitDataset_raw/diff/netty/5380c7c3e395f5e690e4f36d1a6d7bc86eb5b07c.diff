[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/AbstractHttp2ConnectionHandlerBuilder.java, +    private long gracefulShutdownTimeoutMillis = Http2CodecUtil.DEFAULT_GRACEFUL_SHUTDOWN_TIMEOUT_MILLIS;, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/AbstractHttp2ConnectionHandlerBuilder.java, +    private long gracefulShutdownTimeoutMillis = Http2CodecUtil.DEFAULT_GRACEFUL_SHUTDOWN_TIMEOUT_MILLIS;, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/AbstractHttp2StreamChannel.java, +import static io.netty.handler.codec.http2.Http2CodecUtil.isStreamIdValid;, +import static java.lang.Math.max;, +import static java.lang.Math.min;, +import io.netty.buffer.Unpooled;, +import io.netty.channel.ChannelFuture;, +import io.netty.channel.ChannelFutureListener;, +import io.netty.channel.MessageSizeEstimator;, +import io.netty.channel.WriteBufferWaterMark;, +import java.util.concurrent.atomic.AtomicLongFieldUpdater;, +, +    @SuppressWarnings("rawtypes"), +    private static final AtomicLongFieldUpdater<AbstractHttp2StreamChannel> OUTBOUND_FLOW_CONTROL_WINDOW_UPDATER;, +, +    /**, +     * Used to add a message to the {@link ChannelOutboundBuffer}, so as to have it re-evaluate its writability state., +     */, +    private static final Object REEVALUATE_WRITABILITY_MESSAGE = new Object();, +    private final Http2StreamChannelConfig config = new Http2StreamChannelConfig(this);, +    private final Http2Stream2 stream;, +    /**, +     * The flow control window of the remote side i.e. the number of bytes this channel is allowed to send to the remote, +     * peer. The window can become negative if a channel handler ignores the channel's writability. We are using a long, +     * so that we realistically don't have to worry about underflow., +     */, +    @SuppressWarnings("UnusedDeclaration"), +    private volatile long outboundFlowControlWindow;, +, +    static {, +        @SuppressWarnings("rawtypes"), +        AtomicLongFieldUpdater<AbstractHttp2StreamChannel> updater = AtomicLongFieldUpdater.newUpdater(, +                AbstractHttp2StreamChannel.class, "outboundFlowControlWindow");, +        if (updater == null) {, +            updater = AtomicLongFieldUpdater.newUpdater(AbstractHttp2StreamChannel.class, "outboundFlowControlWindow");, +        }, +        OUTBOUND_FLOW_CONTROL_WINDOW_UPDATER = updater;, +    }, +, +    protected AbstractHttp2StreamChannel(Channel parent, Http2Stream2 stream) {, +        this.stream = stream;, +    }, +, +    protected Http2Stream2 stream() {, +        return stream;, +    public boolean isWritable() {, +        return isStreamIdValid(stream.id()), +               // So that the channel doesn't become active before the initial flow control window has been set., +               && outboundFlowControlWindow > 0, +               // Could be null if channel closed., +               && unsafe().outboundBuffer() != null, +               && unsafe().outboundBuffer().isWritable();, +    }, +, +    @Override, +        final MessageSizeEstimator.Handle sizeEstimator = config().getMessageSizeEstimator().newHandle();, +            final Object msg = in.current();, +            // TODO(buchgr): Detecting cancellation relies on ChannelOutboundBuffer internals. NOT COOL!, +            if (msg == Unpooled.EMPTY_BUFFER /* The write was cancelled. */, +                || msg == REEVALUATE_WRITABILITY_MESSAGE /* Write to trigger writability after window update. */) {, +                continue;, +            final int bytes = sizeEstimator.size(msg);, +            /**, +             * The flow control window needs to be decrement before stealing the message from the buffer (and thereby, +             * decrementing the number of pending bytes). Else, when calling steal() the number of pending bytes could, +             * be less than the writebuffer watermark (=flow control window) and thus trigger a writability change., +             *, +             * This code must never trigger a writability change. Only reading window updates or channel writes may, +             * change the channel's writability., +             */, +            incrementOutboundFlowControlWindow(-bytes);, +            final ChannelPromise promise = in.steal();, +            if (bytes > 0) {, +                promise.addListener(new ReturnFlowControlWindowOnFailureListener(bytes));, +            // TODO(buchgr): Should we also the change the writability if END_STREAM is set?, +                doWrite(msg, promise);, +                promise.tryFailure(t);, +    protected abstract void doWrite(Object msg, ChannelPromise promise) throws Exception;, +    protected void incrementOutboundFlowControlWindow(int bytes) {, +        if (bytes == 0) {, +            return;, +        OUTBOUND_FLOW_CONTROL_WINDOW_UPDATER.addAndGet(this, bytes);, +    // Visible for testing, +    long getOutboundFlowControlWindow() {, +        return outboundFlowControlWindow;, +            close();, +        if (msg instanceof Http2WindowUpdateFrame) {, +            Http2WindowUpdateFrame windowUpdate = (Http2WindowUpdateFrame) msg;, +            incrementOutboundFlowControlWindow(windowUpdate.windowSizeIncrement());, +            reevaluateWritability();, +            return true;, +        }, +            numBytesToBeConsumed = dataFrameFlowControlBytes((Http2DataFrame) msg);, +    private void reevaluateWritability() {, +        ChannelOutboundBuffer buffer = unsafe().outboundBuffer();, +        // If the buffer is not writable but should be writable, then write and flush a dummy object, +        // to trigger a writability change.]