[+++ b/buffer/src/main/java/io/netty/buffer/PoolArena.java, +    private final PoolSubpage<T>[] tinySubpagePools;, +    private final PoolSubpage<T>[] smallSubpagePools;, +            tinySubpagePools[i] = newSubpagePoolHead(pageSize);, +            smallSubpagePools[i] = newSubpagePoolHead(pageSize);, +    private PoolSubpage<T> newSubpagePoolHead(int pageSize) {, +        PoolSubpage<T> head = new PoolSubpage<T>(pageSize);, +        head.prev = head;, +        head.next = head;, +        return head;, +    }, +, +    private PoolSubpage<T>[] newSubpagePoolArray(int size) {, +        return new PoolSubpage[size];, +            PoolSubpage<T>[] table;, +                final PoolSubpage<T> head = table[tableIdx];, +                final PoolSubpage<T> s = head.next;, +                if (s != head) {, +                    assert s.doNotDestroy && s.elemSize == normCapacity;, +                    assert handle >= 0;, +            q075.allocate(buf, reqCapacity, normCapacity) || q100.allocate(buf, reqCapacity, normCapacity)) {, +    PoolSubpage<T> findSubpagePoolHead(int elemSize) {, +        PoolSubpage<T>[] table;, +        return table[tableIdx];, +            PoolSubpage<T> head = tinySubpagePools[i];, +            if (head.next == head) {, +            PoolSubpage<T> s = head.next;, +            for (;;) {, +                buf.append(s);, +                s = s.next;, +                if (s == head) {, +                    break;, +                }, +            }, +            PoolSubpage<T> head = smallSubpagePools[i];, +            if (head.next == head) {, +            PoolSubpage<T> s = head.next;, +            for (;;) {, +                buf.append(s);, +                s = s.next;, +                if (s == head) {, +                    break;, +                }, +            }, +++ b/buffer/src/main/java/io/netty/buffer/PoolArena.java, +    private final PoolSubpage<T>[] tinySubpagePools;, +    private final PoolSubpage<T>[] smallSubpagePools;, +            tinySubpagePools[i] = newSubpagePoolHead(pageSize);, +            smallSubpagePools[i] = newSubpagePoolHead(pageSize);, +    private PoolSubpage<T> newSubpagePoolHead(int pageSize) {, +        PoolSubpage<T> head = new PoolSubpage<T>(pageSize);, +        head.prev = head;, +        head.next = head;, +        return head;, +    }, +, +    private PoolSubpage<T>[] newSubpagePoolArray(int size) {, +        return new PoolSubpage[size];, +            PoolSubpage<T>[] table;, +                final PoolSubpage<T> head = table[tableIdx];, +                final PoolSubpage<T> s = head.next;, +                if (s != head) {, +                    assert s.doNotDestroy && s.elemSize == normCapacity;, +                    assert handle >= 0;, +            q075.allocate(buf, reqCapacity, normCapacity) || q100.allocate(buf, reqCapacity, normCapacity)) {, +    PoolSubpage<T> findSubpagePoolHead(int elemSize) {, +        PoolSubpage<T>[] table;, +        return table[tableIdx];, +            PoolSubpage<T> head = tinySubpagePools[i];, +            if (head.next == head) {, +            PoolSubpage<T> s = head.next;, +            for (;;) {, +                buf.append(s);, +                s = s.next;, +                if (s == head) {, +                    break;, +                }, +            }, +            PoolSubpage<T> head = smallSubpagePools[i];, +            if (head.next == head) {, +            PoolSubpage<T> s = head.next;, +            for (;;) {, +                buf.append(s);, +                s = s.next;, +                if (s == head) {, +                    break;, +                }, +            }, +++ b/buffer/src/main/java/io/netty/buffer/PoolChunk.java, +++ b/buffer/src/main/java/io/netty/buffer/PoolArena.java, +    private final PoolSubpage<T>[] tinySubpagePools;, +    private final PoolSubpage<T>[] smallSubpagePools;, +            tinySubpagePools[i] = newSubpagePoolHead(pageSize);, +            smallSubpagePools[i] = newSubpagePoolHead(pageSize);, +    private PoolSubpage<T> newSubpagePoolHead(int pageSize) {, +        PoolSubpage<T> head = new PoolSubpage<T>(pageSize);, +        head.prev = head;, +        head.next = head;, +        return head;, +    }]