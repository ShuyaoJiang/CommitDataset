[+++ b/transport/src/main/java/io/netty/channel/AbstractChannel.java, +    private final DefaultChannelPipeline pipeline;, +        pipeline = new DefaultChannelPipeline(this);, +            return pipeline.directOutbound;, +            final ChannelBufferHolder<Object> out = directOutbound();, +++ b/transport/src/main/java/io/netty/channel/AbstractChannel.java, +    private final DefaultChannelPipeline pipeline;, +        pipeline = new DefaultChannelPipeline(this);, +            return pipeline.directOutbound;, +            final ChannelBufferHolder<Object> out = directOutbound();, +++ b/transport/src/main/java/io/netty/channel/DefaultChannelHandlerContext.java, +import java.util.concurrent.BlockingQueue;, +import java.util.concurrent.atomic.AtomicReference;, +    final ChannelBufferHolder<Object> out;, +, +    // When the two handlers run in a different thread and they are next to each other,, +    // each other's buffers can be accessed at the same time resuslting in a race condition., +    // To avoid such situation, we lazily creates an additional thread-safe buffer called, +    // 'bridge' so that the two handlers access each other's buffer only via the bridges., +    // The content written into a bridge is flushed into the actual buffer by flushBridge()., +    final AtomicReference<BlockingQueue<Object>> inMsgBridge;, +    final AtomicReference<BlockingQueue<Object>> outMsgBridge;, +    final AtomicReference<ChannelBuffer> inByteBridge;, +    final AtomicReference<ChannelBuffer> outByteBridge;, +            flushBridge();, +, +            if (!in.isBypass()) {, +                if (in.hasByteBuffer()) {, +                    inByteBridge = new AtomicReference<ChannelBuffer>();, +                    inMsgBridge = null;, +                } else {, +                    inByteBridge = null;, +                    inMsgBridge = new AtomicReference<BlockingQueue<Object>>();, +                }, +            } else {, +                inByteBridge = null;, +                inMsgBridge = null;, +            }, +            inByteBridge = null;, +            inMsgBridge = null;, +, +            if (!out.isBypass()) {, +                if (out.hasByteBuffer()) {, +                    outByteBridge = new AtomicReference<ChannelBuffer>();, +                    outMsgBridge = null;, +                } else {, +                    outByteBridge = null;, +                    outMsgBridge = new AtomicReference<BlockingQueue<Object>>();, +                }, +            } else {, +                outByteBridge = null;, +                outMsgBridge = null;, +            }, +            outByteBridge = null;, +            outMsgBridge = null;, +        }, +    }, +, +    void flushBridge() {, +        if (inMsgBridge != null) {, +            BlockingQueue<Object> bridge = inMsgBridge.get();, +            if (bridge != null) {, +                bridge.drainTo(in.messageBuffer());, +            }, +        }, +        if (outMsgBridge != null) {, +            BlockingQueue<Object> bridge = outMsgBridge.get();, +            if (bridge != null) {, +                bridge.drainTo(out.messageBuffer());, +            }, +        return DefaultChannelPipeline.nextInboundMessageBuffer(executor(), next);, +        return pipeline.nextOutboundMessageBuffer(executor(), prev);, +++ b/transport/src/main/java/io/netty/channel/AbstractChannel.java, +    private final DefaultChannelPipeline pipeline;, +        pipeline = new DefaultChannelPipeline(this);, +            return pipeline.directOutbound;, +            final ChannelBufferHolder<Object> out = directOutbound();, +++ b/transport/src/main/java/io/netty/channel/DefaultChannelHandlerContext.java, +import java.util.concurrent.BlockingQueue;, +import java.util.concurrent.atomic.AtomicReference;, +    final ChannelBufferHolder<Object> out;, +, +    // When the two handlers run in a different thread and they are next to each other,, +    // each other's buffers can be accessed at the same time resuslting in a race condition., +    // To avoid such situation, we lazily creates an additional thread-safe buffer called, +    // 'bridge' so that the two handlers access each other's buffer only via the bridges., +    // The content written into a bridge is flushed into the actual buffer by flushBridge()., +    final AtomicReference<BlockingQueue<Object>> inMsgBridge;, +    final AtomicReference<BlockingQueue<Object>> outMsgBridge;, +    final AtomicReference<ChannelBuffer> inByteBridge;, +    final AtomicReference<ChannelBuffer> outByteBridge;, +            flushBridge();, +, +            if (!in.isBypass()) {, +                if (in.hasByteBuffer()) {, +                    inByteBridge = new AtomicReference<ChannelBuffer>();, +                    inMsgBridge = null;, +                } else {, +                    inByteBridge = null;, +                    inMsgBridge = new AtomicReference<BlockingQueue<Object>>();]