[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2ConnectionEncoder.java, +            int bytesWritten = 0;, +            try {, +                if (allowedBytes == 0 && size != 0) {, +            } finally {, +                size -= bytesWritten;, +            // Ensure error() gets called in case something goes wrong after the frame is passed to Netty., +        public void writeComplete() {, +            if (endOfStream) {, +                lifecycleManager.closeLocalSide(stream, promise);, +            }, +        }, +, +        @Override, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2ConnectionEncoder.java, +            int bytesWritten = 0;, +            try {, +                if (allowedBytes == 0 && size != 0) {, +            } finally {, +                size -= bytesWritten;, +            // Ensure error() gets called in case something goes wrong after the frame is passed to Netty., +        public void writeComplete() {, +            if (endOfStream) {, +                lifecycleManager.closeLocalSide(stream, promise);, +            }, +        }, +, +        @Override, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2RemoteFlowController.java, +import io.netty.handler.codec.http2.Http2Stream.State;, +import java.util.Deque;, +                // Any pending frames can never be written, cancel and, +                state(stream).cancel();, +            }, +, +            @Override, +            public void streamHalfClosed(Http2Stream stream) {, +                if (State.HALF_CLOSED_LOCAL.equals(stream.state())) {, +                    /**, +                     * When this method is called there should not be any, +                     * pending frames left if the API is used correctly. However,, +                     * it is possible that a erroneous application can sneak, +                     * in a frame even after having already written a frame with the, +                     * END_STREAM flag set, as the stream state might not transition, +                     * immediately to HALF_CLOSED_LOCAL / CLOSED due to flow control, +                     * delaying the write., +                     *, +                     * This is to cancel any such illegal writes., +                     */, +                     state(stream).cancel();, +                }, +        FlowState state;, +            state = state(stream);, +        } catch (Throwable t) {, +            payload.error(t);, +            return;, +        }, +        try {, +        } catch (Throwable t) {, +            payload.error(t);, +        private final Deque<Frame> pendingWriteQueue;, +        // Set to true while a frame is being written, false otherwise., +        private boolean writing;, +        // Set to true if cancel() was called., +        private boolean cancelled;, +        void cancel() {, +            cancelled = true;, +            // Ensure that the queue can't be modified while, +            // we are writing., +            if (writing) {, +                return;, +            }, +                int writtenBytes = 0;, +                    if (writing) {, +                        throw new IllegalStateException("write is not re-entrant");, +                    }, +                    // Write the portion of the frame., +                    writing = true;, +                    needFlush |= payload.write(Math.max(0, allowedBytes));, +                    if (!cancelled && payload.size() == 0) {, +                        // This frame has been fully written, remove this frame, +                        // and notify the payload. Since we remove this frame, +                        // first, we're guaranteed that its error method will not, +                        // be called when we call cancel., +                        pendingWriteQueue.remove();, +                        payload.writeComplete();, +                    }, +                } catch (Throwable e) {, +                    // Mark the state as cancelled, we'll clear the pending queue, +                    // via cancel() below., +                    cancelled = true;, +                } finally {, +                    writing = false;, +                    // Make sure we always decrement the flow control windows, +                    // by the bytes written., +                    writtenBytes = before - payload.size();, +                    decrementFlowControlWindow(writtenBytes);, +                    decrementPendingBytes(writtenBytes);, +                    // If a cancellation occurred while writing, call cancel again to, +                    // clear and error all of the pending writes.]