[+++ b/transport/src/main/java/io/netty/channel/AbstractChannel.java, +    private final VoidChannelPromise voidPromise = new VoidChannelPromise(this, true);, +    private final VoidChannelPromise unsafeVoidPromise = new VoidChannelPromise(this, false);, +        @Override, +        public ChannelPromise voidPromise() {, +            return unsafeVoidPromise;, +        }, +, +++ b/transport/src/main/java/io/netty/channel/AbstractChannel.java, +    private final VoidChannelPromise voidPromise = new VoidChannelPromise(this, true);, +    private final VoidChannelPromise unsafeVoidPromise = new VoidChannelPromise(this, false);, +        @Override, +        public ChannelPromise voidPromise() {, +            return unsafeVoidPromise;, +        }, +, +++ b/transport/src/main/java/io/netty/channel/Channel.java, +     *   <li>{@link #voidPromise()}</li>, +, +        /**, +         * Return a special ChannelPromise which can be reused and passed to the operations in {@link Unsafe}., +         * It will never be notified of a success or error and so is only a placeholder for operations, +         * that take a {@link ChannelPromise} as argument but for which you not want to get notified., +         */, +        ChannelPromise voidPromise();, +++ b/transport/src/main/java/io/netty/channel/AbstractChannel.java, +    private final VoidChannelPromise voidPromise = new VoidChannelPromise(this, true);, +    private final VoidChannelPromise unsafeVoidPromise = new VoidChannelPromise(this, false);, +        @Override, +        public ChannelPromise voidPromise() {, +            return unsafeVoidPromise;, +        }, +, +++ b/transport/src/main/java/io/netty/channel/Channel.java, +     *   <li>{@link #voidPromise()}</li>, +, +        /**, +         * Return a special ChannelPromise which can be reused and passed to the operations in {@link Unsafe}., +         * It will never be notified of a success or error and so is only a placeholder for operations, +         * that take a {@link ChannelPromise} as argument but for which you not want to get notified., +         */, +        ChannelPromise voidPromise();, +++ b/transport/src/main/java/io/netty/channel/ThreadPerChannelEventLoop.java, +                    ch.unsafe().close(ch.unsafe().voidPromise());, +++ b/transport/src/main/java/io/netty/channel/AbstractChannel.java, +    private final VoidChannelPromise voidPromise = new VoidChannelPromise(this, true);, +    private final VoidChannelPromise unsafeVoidPromise = new VoidChannelPromise(this, false);, +        @Override, +        public ChannelPromise voidPromise() {, +            return unsafeVoidPromise;, +        }, +, +++ b/transport/src/main/java/io/netty/channel/Channel.java, +     *   <li>{@link #voidPromise()}</li>, +, +        /**, +         * Return a special ChannelPromise which can be reused and passed to the operations in {@link Unsafe}., +         * It will never be notified of a success or error and so is only a placeholder for operations, +         * that take a {@link ChannelPromise} as argument but for which you not want to get notified., +         */, +        ChannelPromise voidPromise();, +++ b/transport/src/main/java/io/netty/channel/ThreadPerChannelEventLoop.java, +                    ch.unsafe().close(ch.unsafe().voidPromise());, +++ b/transport/src/main/java/io/netty/channel/VoidChannelPromise.java, +    private final boolean fireException;, +    public VoidChannelPromise(Channel channel, boolean fireException) {, +        this.fireException = fireException;, +        if (fireException) {, +        }, +        if (fireException) {, +        }, +++ b/transport/src/main/java/io/netty/channel/AbstractChannel.java, +    private final VoidChannelPromise voidPromise = new VoidChannelPromise(this, true);, +    private final VoidChannelPromise unsafeVoidPromise = new VoidChannelPromise(this, false);, +        @Override, +        public ChannelPromise voidPromise() {, +            return unsafeVoidPromise;, +        }, +, +++ b/transport/src/main/java/io/netty/channel/Channel.java, +     *   <li>{@link #voidPromise()}</li>, +, +        /**, +         * Return a special ChannelPromise which can be reused and passed to the operations in {@link Unsafe}., +         * It will never be notified of a success or error and so is only a placeholder for operations, +         * that take a {@link ChannelPromise} as argument but for which you not want to get notified., +         */, +        ChannelPromise voidPromise();, +++ b/transport/src/main/java/io/netty/channel/ThreadPerChannelEventLoop.java, +                    ch.unsafe().close(ch.unsafe().voidPromise());, +++ b/transport/src/main/java/io/netty/channel/VoidChannelPromise.java, +    private final boolean fireException;, +    public VoidChannelPromise(Channel channel, boolean fireException) {, +        this.fireException = fireException;, +        if (fireException) {, +        }, +        if (fireException) {, +        }, +++ b/transport/src/main/java/io/netty/channel/aio/AioEventLoop.java, +            ch.unsafe().close(ch.unsafe().voidPromise());]