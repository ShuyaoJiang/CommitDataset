[+++ b/src/main/java/org/jboss/netty/handler/ssl/SslBufferPool.java, +import javax.net.ssl.SSLEngine;, +, + * A {@link ByteBuffer} pool dedicated for {@link SslHandler} performance, + * improvement., + * <p>, + * In most cases, you won't need to create a new pool instance because, + * {@link SslHandler} has a default pool instance internally., + * <p>, + * The reason why {@link SslHandler} requires a buffer pool is because the, + * current {@link SSLEngine} implementation always requires a 17KiB buffer for, + * the 'wrap' and 'unwrap' operation.  In most cases, the size of the required, + * buffer is much smaller than that, and therefore allocating a 17KiB buffer, + * for every 'wrap' and 'unwrap' operation wastes a lot of memory bandwidth,, + * resulting in the application performance degradation., + *, +    /**, +     * Creates a new buffer pool whose size is {@code 18113536}, which can, +     * hold {@code 1024} buffers., +     */, +    /**, +     * Creates a new buffer pool., +     *, +     * @param maxPoolSize the maximum number of bytes that this pool can hold, +     */, +    public SslBufferPool(int maxPoolSize) {, +        if (maxPoolSize <= 0) {, +            throw new IllegalArgumentException("maxPoolSize: " + maxPoolSize);, +        int maxBufferCount = maxPoolSize / MAX_PACKET_SIZE;, +        if (maxPoolSize % MAX_PACKET_SIZE != 0) {, +        maxPoolSize = maxBufferCount * MAX_PACKET_SIZE;, +    /**, +     * Returns the maximum size of this pool in byte unit.  The returned value, +     * can be somewhat different from what was specified in the constructor., +     */, +    /**, +     * Returns the number of bytes which were allocated but not acquired yet., +     * You can estimate how optimal the specified maximum pool size is from, +     * this value.  If it keeps returning {@code 0}, it means the pool is, +     * getting exhausted.  If it keeps returns a unnecessarily big value, it, +     * means the pool is wasting the heap space., +     */, +++ b/src/main/java/org/jboss/netty/handler/ssl/SslBufferPool.java, +import javax.net.ssl.SSLEngine;, +, + * A {@link ByteBuffer} pool dedicated for {@link SslHandler} performance, + * improvement., + * <p>, + * In most cases, you won't need to create a new pool instance because, + * {@link SslHandler} has a default pool instance internally., + * <p>, + * The reason why {@link SslHandler} requires a buffer pool is because the, + * current {@link SSLEngine} implementation always requires a 17KiB buffer for, + * the 'wrap' and 'unwrap' operation.  In most cases, the size of the required, + * buffer is much smaller than that, and therefore allocating a 17KiB buffer, + * for every 'wrap' and 'unwrap' operation wastes a lot of memory bandwidth,, + * resulting in the application performance degradation., + *, +    /**, +     * Creates a new buffer pool whose size is {@code 18113536}, which can, +     * hold {@code 1024} buffers., +     */, +    /**, +     * Creates a new buffer pool., +     *, +     * @param maxPoolSize the maximum number of bytes that this pool can hold, +     */, +    public SslBufferPool(int maxPoolSize) {, +        if (maxPoolSize <= 0) {, +            throw new IllegalArgumentException("maxPoolSize: " + maxPoolSize);, +        int maxBufferCount = maxPoolSize / MAX_PACKET_SIZE;, +        if (maxPoolSize % MAX_PACKET_SIZE != 0) {, +        maxPoolSize = maxBufferCount * MAX_PACKET_SIZE;, +    /**, +     * Returns the maximum size of this pool in byte unit.  The returned value, +     * can be somewhat different from what was specified in the constructor., +     */, +    /**, +     * Returns the number of bytes which were allocated but not acquired yet., +     * You can estimate how optimal the specified maximum pool size is from, +     * this value.  If it keeps returning {@code 0}, it means the pool is, +     * getting exhausted.  If it keeps returns a unnecessarily big value, it, +     * means the pool is wasting the heap space., +     */, +++ b/src/main/java/org/jboss/netty/handler/ssl/SslHandler.java, +import org.jboss.netty.channel.ChannelPipeline;, + * Adds <a href="http://en.wikipedia.org/wiki/Transport_Layer_Security">SSL, + * &middot; TLS</a> and StartTLS support to a {@link Channel}.  Please refer, + * to the <strong>"SecureChat"</strong> example in the distribution or the web, + * site for the detailed usage., + *, + * <h3>Beginning the handshake</h3>, + * <p>, + * A user should make sure not to write a message while the, + * {@linkplain #handshake(Channel) handshake} is in progress unless it's a, + * renegotiation.  You will be notified by the {@link ChannelFuture} which is, + * returned by the {@link #handshake(Channel)} method when the handshake, + * process succeeds or fails., + *, + * <h3>Renegotiation</h3>]