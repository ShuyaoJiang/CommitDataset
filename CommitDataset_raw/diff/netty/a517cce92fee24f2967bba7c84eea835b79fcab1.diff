[+++ b/resolver-dns/src/main/java/io/netty/resolver/dns/DnsAddressResolverGroup.java, +import io.netty.resolver.InetSocketAddressResolver;, +import io.netty.resolver.NameResolver;, +import io.netty.util.concurrent.Promise;, +import java.net.InetAddress;, +import java.util.List;, +import java.util.concurrent.ConcurrentMap;, +import static io.netty.util.internal.PlatformDependent.newConcurrentHashMap;, +    private final ConcurrentMap<String, Promise<InetAddress>> resolvesInProgress = newConcurrentHashMap();, +    private final ConcurrentMap<String, Promise<List<InetAddress>>> resolveAllsInProgress = newConcurrentHashMap();, +, +        final NameResolver<InetAddress> resolver = new InflightNameResolver<InetAddress>(, +                eventLoop,, +                new DnsNameResolverBuilder(eventLoop), +                        .build(),, +                resolvesInProgress,, +                resolveAllsInProgress);, +, +        return new InetSocketAddressResolver(eventLoop, resolver);, +++ b/resolver-dns/src/main/java/io/netty/resolver/dns/DnsAddressResolverGroup.java, +import io.netty.resolver.InetSocketAddressResolver;, +import io.netty.resolver.NameResolver;, +import io.netty.util.concurrent.Promise;, +import java.net.InetAddress;, +import java.util.List;, +import java.util.concurrent.ConcurrentMap;, +import static io.netty.util.internal.PlatformDependent.newConcurrentHashMap;, +    private final ConcurrentMap<String, Promise<InetAddress>> resolvesInProgress = newConcurrentHashMap();, +    private final ConcurrentMap<String, Promise<List<InetAddress>>> resolveAllsInProgress = newConcurrentHashMap();, +, +        final NameResolver<InetAddress> resolver = new InflightNameResolver<InetAddress>(, +                eventLoop,, +                new DnsNameResolverBuilder(eventLoop), +                        .build(),, +                resolvesInProgress,, +                resolveAllsInProgress);, +, +        return new InetSocketAddressResolver(eventLoop, resolver);, +++ b/resolver-dns/src/main/java/io/netty/resolver/dns/InflightNameResolver.java, +/*, + * Copyright 2016 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + *   http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the, + * License for the specific language governing permissions and limitations, + * under the License., + */, +, +package io.netty.resolver.dns;, +, +import io.netty.resolver.NameResolver;, +import io.netty.util.concurrent.EventExecutor;, +import io.netty.util.concurrent.Future;, +import io.netty.util.concurrent.FutureListener;, +import io.netty.util.concurrent.Promise;, +import io.netty.util.internal.StringUtil;, +, +import java.util.List;, +import java.util.concurrent.ConcurrentMap;, +, +import static io.netty.util.internal.ObjectUtil.checkNotNull;, +, +// FIXME(trustin): Find a better name and move it to the 'resolver' module., +final class InflightNameResolver<T> implements NameResolver<T> {, +, +    private final EventExecutor executor;, +    private final NameResolver<T> delegate;, +    private final ConcurrentMap<String, Promise<T>> resolvesInProgress;, +    private final ConcurrentMap<String, Promise<List<T>>> resolveAllsInProgress;, +, +    InflightNameResolver(EventExecutor executor, NameResolver<T> delegate,, +                         ConcurrentMap<String, Promise<T>> resolvesInProgress,, +                         ConcurrentMap<String, Promise<List<T>>> resolveAllsInProgress) {, +, +        this.executor = checkNotNull(executor, "executor");, +        this.delegate = checkNotNull(delegate, "delegate");, +        this.resolvesInProgress = checkNotNull(resolvesInProgress, "resolvesInProgress");, +        this.resolveAllsInProgress = checkNotNull(resolveAllsInProgress, "resolveAllsInProgress");, +    }, +, +    @Override, +    public Future<T> resolve(String inetHost) {, +        return resolve(inetHost, executor.<T>newPromise());, +    }, +, +    @Override, +    public Future<List<T>> resolveAll(String inetHost) {, +        return resolveAll(inetHost, executor.<List<T>>newPromise());, +    }, +, +    @Override, +    public void close() {, +        delegate.close();]