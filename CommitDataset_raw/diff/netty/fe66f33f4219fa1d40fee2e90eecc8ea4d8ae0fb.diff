[+++ b/transport/src/main/java/io/netty/channel/DefaultChannelHandlerContext.java, +    void forwardBufferContent(final DefaultChannelHandlerContext forwardPrev,, +                              final DefaultChannelHandlerContext forwardNext) {, +        boolean flush = false;, +        boolean inboundBufferUpdated = false;, +            ByteBuf forwardPrevBuf;, +            if (forwardPrev.hasOutboundByteBuffer()) {, +                forwardPrevBuf = forwardPrev.outboundByteBuffer();, +            } else {, +                forwardPrevBuf = forwardPrev.nextOutboundByteBuffer();, +            }, +            forwardPrevBuf.writeBytes(outboundByteBuffer());, +            flush = true;, +            MessageBuf<Object> forwardPrevBuf;, +            if (forwardPrev.hasOutboundMessageBuffer()) {, +                forwardPrevBuf = forwardPrev.outboundMessageBuffer();, +            } else {, +                forwardPrevBuf = forwardPrev.nextOutboundMessageBuffer();, +            }, +            if (outboundMessageBuffer().drainTo(forwardPrevBuf) > 0) {, +                flush = true;, +            ByteBuf forwardNextBuf;, +            if (forwardNext.hasInboundByteBuffer()) {, +                forwardNextBuf = forwardNext.inboundByteBuffer();, +            } else {, +                forwardNextBuf = forwardNext.nextInboundByteBuffer();, +            }, +            forwardNextBuf.writeBytes(inboundByteBuffer());, +            inboundBufferUpdated = true;, +            MessageBuf<Object> forwardNextBuf;, +            if (forwardNext.hasInboundMessageBuffer()) {, +                forwardNextBuf = forwardNext.inboundMessageBuffer();, +            } else {, +                forwardNextBuf = forwardNext.nextInboundMessageBuffer();, +            }, +            if (inboundMessageBuffer().drainTo(forwardNextBuf) > 0) {, +                inboundBufferUpdated = true;, +        if (flush) {, +            EventExecutor executor = executor();, +            Thread currentThread = Thread.currentThread();, +            if (executor.inEventLoop(currentThread)) {, +                invokePrevFlush(newPromise(), currentThread, findContextOutboundInclusive(forwardPrev));, +            } else {, +                executor.execute(new Runnable() {, +                    @Override, +                    public void run() {, +                        invokePrevFlush(newPromise(), Thread.currentThread(),, +                                findContextOutboundInclusive(forwardPrev));, +                    }, +                });, +            }, +        }, +        if (inboundBufferUpdated) {, +            EventExecutor executor = executor();, +            if (executor.inEventLoop()) {, +                fireInboundBufferUpdated0(findContextInboundInclusive(forwardNext));, +            } else {, +                executor.execute(new Runnable() {, +                    @Override, +                    public void run() {, +                        fireInboundBufferUpdated0(findContextInboundInclusive(forwardNext));, +                    }, +                });, +            }, +        }, +    }, +, +    private static DefaultChannelHandlerContext findContextOutboundInclusive(DefaultChannelHandlerContext ctx) {, +        if (ctx.handler() instanceof ChannelOperationHandler) {, +            return ctx;, +        }, +        return ctx.findContextOutbound();, +    }, +, +    private static DefaultChannelHandlerContext findContextInboundInclusive(DefaultChannelHandlerContext ctx) {, +        if (ctx.handler() instanceof ChannelStateHandler) {, +            return ctx;, +        }, +        return ctx.findContextInbound();, +            fireInboundBufferUpdated0(findContextInbound());, +                        fireInboundBufferUpdated0(findContextInbound());, +    private void fireInboundBufferUpdated0(final DefaultChannelHandlerContext next) {, +                                fireInboundBufferUpdated0(next);, +            invokePrevFlush(promise, currentThread, findContextOutbound());, +                    invokePrevFlush(promise, Thread.currentThread(), findContextOutbound());, +    private void invokePrevFlush(ChannelPromise promise, Thread currentThread, DefaultChannelHandlerContext prev) {, +++ b/transport/src/main/java/io/netty/channel/DefaultChannelHandlerContext.java, +    void forwardBufferContent(final DefaultChannelHandlerContext forwardPrev,, +                              final DefaultChannelHandlerContext forwardNext) {, +        boolean flush = false;, +        boolean inboundBufferUpdated = false;, +            ByteBuf forwardPrevBuf;, +            if (forwardPrev.hasOutboundByteBuffer()) {, +                forwardPrevBuf = forwardPrev.outboundByteBuffer();, +            } else {, +                forwardPrevBuf = forwardPrev.nextOutboundByteBuffer();, +            }, +            forwardPrevBuf.writeBytes(outboundByteBuffer());, +            flush = true;, +            MessageBuf<Object> forwardPrevBuf;]