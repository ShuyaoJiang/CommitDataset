[+++ b/common/src/main/java/io/netty/util/ResourceLeakDetector.java, +import io.netty.util.internal.ThreadLocalRandom;, +    /** the collection of active resources */, +    private final ConcurrentMap<DefaultResourceLeak, Boolean> allLeaks = PlatformDependent.newConcurrentHashMap();, +        this.samplingInterval = samplingInterval;, +            if ((ThreadLocalRandom.current().nextInt(0, samplingInterval)) == 0) {, +        if (allLeaks.size() * samplingInterval > maxActive && loggedTooManyActive.compareAndSet(false, true)) {, +                allLeaks.put(this, Boolean.TRUE);, +            // Use the ConcurrentMap remove method, which avoids allocating an iterator., +            return allLeaks.remove(this, Boolean.TRUE);]