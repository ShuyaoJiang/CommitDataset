[+++ b/common/src/main/java/io/netty/util/concurrent/PromiseNotifier.java, +import io.netty.util.internal.logging.InternalLogger;, +import io.netty.util.internal.logging.InternalLoggerFactory;, +, +import static io.netty.util.internal.ObjectUtil.checkNotNull;, +, + * @param <V> the type of value returned by the future, + * @param <F> the type of future, +    private static final InternalLogger logger = InternalLoggerFactory.getInstance(PromiseNotifier.class);, +        checkNotNull(promises, "promises");, +                if (!p.trySuccess(result)) {, +                    logger.warn("Failed to mark a promise as success because it is done already: {}", p);, +                }, +            if (!p.tryFailure(cause)) {, +                logger.warn("Failed to mark a promise as failure because it's done already: {}", p, cause);, +    }, +++ b/common/src/main/java/io/netty/util/concurrent/PromiseNotifier.java, +import io.netty.util.internal.logging.InternalLogger;, +import io.netty.util.internal.logging.InternalLoggerFactory;, +, +import static io.netty.util.internal.ObjectUtil.checkNotNull;, +, + * @param <V> the type of value returned by the future, + * @param <F> the type of future, +    private static final InternalLogger logger = InternalLoggerFactory.getInstance(PromiseNotifier.class);, +        checkNotNull(promises, "promises");, +                if (!p.trySuccess(result)) {, +                    logger.warn("Failed to mark a promise as success because it is done already: {}", p);, +                }, +            if (!p.tryFailure(cause)) {, +                logger.warn("Failed to mark a promise as failure because it's done already: {}", p, cause);, +    }, +++ b/common/src/test/java/io/netty/util/concurrent/PromiseNotifierTest.java, +        expect(p1.trySuccess(null)).andReturn(true);, +        expect(p2.trySuccess(null)).andReturn(true);, +        expect(p1.tryFailure(t)).andReturn(true);, +        expect(p2.tryFailure(t)).andReturn(true);, +++ b/common/src/main/java/io/netty/util/concurrent/PromiseNotifier.java, +import io.netty.util.internal.logging.InternalLogger;, +import io.netty.util.internal.logging.InternalLoggerFactory;, +, +import static io.netty.util.internal.ObjectUtil.checkNotNull;, +, + * @param <V> the type of value returned by the future, + * @param <F> the type of future, +    private static final InternalLogger logger = InternalLoggerFactory.getInstance(PromiseNotifier.class);, +        checkNotNull(promises, "promises");, +                if (!p.trySuccess(result)) {, +                    logger.warn("Failed to mark a promise as success because it is done already: {}", p);, +                }, +            if (!p.tryFailure(cause)) {, +                logger.warn("Failed to mark a promise as failure because it's done already: {}", p, cause);, +    }, +++ b/common/src/test/java/io/netty/util/concurrent/PromiseNotifierTest.java, +        expect(p1.trySuccess(null)).andReturn(true);, +        expect(p2.trySuccess(null)).andReturn(true);, +        expect(p1.tryFailure(t)).andReturn(true);, +        expect(p2.tryFailure(t)).andReturn(true);, +++ b/handler/src/main/java/io/netty/handler/ssl/SslHandler.java, +import io.netty.channel.ChannelPromiseNotifier;, +, +                    // We notify the promise in the TryNotifyListener as there is a "race" where the close(...) call, +                    // by the timeoutFuture and the close call in the flushFuture listener will be called. Because of, +                    // this we need to use trySuccess() and tryFailure(...) as otherwise we can cause an, +                    // IllegalStateException., +                    ctx.close(ctx.newPromise()).addListener(new ChannelPromiseNotifier(promise));, +                //, +                // We notify the promise in the ChannelPromiseNotifier as there is a "race" where the close(...) call, +                // by the timeoutFuture and the close call in the flushFuture listener will be called. Because of, +                // this we need to use trySuccess() and tryFailure(...) as otherwise we can cause an, +                // IllegalStateException., +                ctx.close(ctx.newPromise()).addListener(new ChannelPromiseNotifier(promise));, +++ b/common/src/main/java/io/netty/util/concurrent/PromiseNotifier.java, +import io.netty.util.internal.logging.InternalLogger;, +import io.netty.util.internal.logging.InternalLoggerFactory;, +, +import static io.netty.util.internal.ObjectUtil.checkNotNull;, +, + * @param <V> the type of value returned by the future, + * @param <F> the type of future, +    private static final InternalLogger logger = InternalLoggerFactory.getInstance(PromiseNotifier.class);, +        checkNotNull(promises, "promises");, +                if (!p.trySuccess(result)) {, +                    logger.warn("Failed to mark a promise as success because it is done already: {}", p);, +                }, +            if (!p.tryFailure(cause)) {, +                logger.warn("Failed to mark a promise as failure because it's done already: {}", p, cause);, +    }, +++ b/common/src/test/java/io/netty/util/concurrent/PromiseNotifierTest.java, +        expect(p1.trySuccess(null)).andReturn(true);, +        expect(p2.trySuccess(null)).andReturn(true);, +        expect(p1.tryFailure(t)).andReturn(true);, +        expect(p2.tryFailure(t)).andReturn(true);, +++ b/handler/src/main/java/io/netty/handler/ssl/SslHandler.java, +import io.netty.channel.ChannelPromiseNotifier;, +, +                    // We notify the promise in the TryNotifyListener as there is a "race" where the close(...) call, +                    // by the timeoutFuture and the close call in the flushFuture listener will be called. Because of, +                    // this we need to use trySuccess() and tryFailure(...) as otherwise we can cause an, +                    // IllegalStateException.]