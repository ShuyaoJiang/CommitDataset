[+++ b/transport-native-epoll/src/main/c/io_netty_channel_epoll_Native.c, +, +static inline int addressLength(struct sockaddr_storage addr) {, +    if (addr.ss_family == AF_INET) {, +        return 8;, +    } else {, +        struct sockaddr_in6* s = (struct sockaddr_in6*) &addr;, +        if (s->sin6_addr.s6_addr[0] == 0x00 && s->sin6_addr.s6_addr[1] == 0x00 && s->sin6_addr.s6_addr[2] == 0x00 && s->sin6_addr.s6_addr[3] == 0x00 && s->sin6_addr.s6_addr[4] == 0x00, +                && s->sin6_addr.s6_addr[5] == 0x00 && s->sin6_addr.s6_addr[6] == 0x00 && s->sin6_addr.s6_addr[7] == 0x00 && s->sin6_addr.s6_addr[8] == 0x00 && s->sin6_addr.s6_addr[9] == 0x00, +                 && s->sin6_addr.s6_addr[10] == 0xff && s->sin6_addr.s6_addr[11] == 0xff) {, +            // IPv4-mapped-on-IPv6, +            return 8;, +        } else {, +            return 24;, +        }, +    }, +}, +, +static inline void initInetSocketAddressArray(JNIEnv* env, struct sockaddr_storage addr, jbyteArray bArray, int offset, int len) {, +        (*env)->SetByteArrayRegion(env, bArray, offset, 8, (jbyte*) &a);, +        if (len == 8) {, +            (*env)->SetByteArrayRegion(env, bArray, offset, 4, (jbyte*) &(s->sin6_addr.s6_addr[12]));, +            (*env)->SetByteArrayRegion(env, bArray, offset + 4, 4, (jbyte*) &a);, +            (*env)->SetByteArrayRegion(env, bArray, offset, 16, (jbyte*) &(s->sin6_addr.s6_addr));, +            (*env)->SetByteArrayRegion(env, bArray, offset + 16, 8, (jbyte*) &a);, +        }, +    }, +}, +, +static jbyteArray createInetSocketAddressArray(JNIEnv* env, struct sockaddr_storage addr) {, +    int len = addressLength(addr);, +    jbyteArray bArray = (*env)->NewByteArray(env, len);, +, +    initInetSocketAddressArray(env, addr, bArray, 0, len);, +, +JNIEXPORT jint JNICALL Java_io_netty_channel_epoll_Native_accept0(JNIEnv* env, jclass clazz, jint fd, jbyteArray acceptedAddress) {, +    struct sockaddr_storage addr;, +    socklen_t address_len = sizeof(addr);, +            socketFd = accept4(fd, (struct sockaddr*) &addr, &address_len, SOCK_NONBLOCK | SOCK_CLOEXEC);, +            socketFd = accept(fd, (struct sockaddr*) &addr, &address_len);, +, +    int len = addressLength(addr);, +, +    // Fill in remote address details, +    (*env)->SetByteArrayRegion(env, acceptedAddress, 0, 4, (jbyte*) &len);, +    initInetSocketAddressArray(env, addr, acceptedAddress, 1, len);, +, +++ b/transport-native-epoll/src/main/c/io_netty_channel_epoll_Native.c, +, +static inline int addressLength(struct sockaddr_storage addr) {, +    if (addr.ss_family == AF_INET) {, +        return 8;, +    } else {, +        struct sockaddr_in6* s = (struct sockaddr_in6*) &addr;, +        if (s->sin6_addr.s6_addr[0] == 0x00 && s->sin6_addr.s6_addr[1] == 0x00 && s->sin6_addr.s6_addr[2] == 0x00 && s->sin6_addr.s6_addr[3] == 0x00 && s->sin6_addr.s6_addr[4] == 0x00, +                && s->sin6_addr.s6_addr[5] == 0x00 && s->sin6_addr.s6_addr[6] == 0x00 && s->sin6_addr.s6_addr[7] == 0x00 && s->sin6_addr.s6_addr[8] == 0x00 && s->sin6_addr.s6_addr[9] == 0x00, +                 && s->sin6_addr.s6_addr[10] == 0xff && s->sin6_addr.s6_addr[11] == 0xff) {, +            // IPv4-mapped-on-IPv6, +            return 8;, +        } else {, +            return 24;, +        }, +    }, +}, +, +static inline void initInetSocketAddressArray(JNIEnv* env, struct sockaddr_storage addr, jbyteArray bArray, int offset, int len) {, +        (*env)->SetByteArrayRegion(env, bArray, offset, 8, (jbyte*) &a);, +        if (len == 8) {, +            (*env)->SetByteArrayRegion(env, bArray, offset, 4, (jbyte*) &(s->sin6_addr.s6_addr[12]));, +            (*env)->SetByteArrayRegion(env, bArray, offset + 4, 4, (jbyte*) &a);, +            (*env)->SetByteArrayRegion(env, bArray, offset, 16, (jbyte*) &(s->sin6_addr.s6_addr));, +            (*env)->SetByteArrayRegion(env, bArray, offset + 16, 8, (jbyte*) &a);, +        }, +    }, +}, +, +static jbyteArray createInetSocketAddressArray(JNIEnv* env, struct sockaddr_storage addr) {, +    int len = addressLength(addr);, +    jbyteArray bArray = (*env)->NewByteArray(env, len);, +, +    initInetSocketAddressArray(env, addr, bArray, 0, len);, +, +JNIEXPORT jint JNICALL Java_io_netty_channel_epoll_Native_accept0(JNIEnv* env, jclass clazz, jint fd, jbyteArray acceptedAddress) {, +    struct sockaddr_storage addr;, +    socklen_t address_len = sizeof(addr);, +            socketFd = accept4(fd, (struct sockaddr*) &addr, &address_len, SOCK_NONBLOCK | SOCK_CLOEXEC);, +            socketFd = accept(fd, (struct sockaddr*) &addr, &address_len);, +, +    int len = addressLength(addr);, +, +    // Fill in remote address details, +    (*env)->SetByteArrayRegion(env, acceptedAddress, 0, 4, (jbyte*) &len);, +    initInetSocketAddressArray(env, addr, acceptedAddress, 1, len);, +, +++ b/transport-native-epoll/src/main/c/io_netty_channel_epoll_Native.h, +jint Java_io_netty_channel_epoll_Native_accept0(JNIEnv* env, jclass clazz, jint fd, jbyteArray acceptedAddress);, +++ b/transport-native-epoll/src/main/c/io_netty_channel_epoll_Native.c, +, +static inline int addressLength(struct sockaddr_storage addr) {, +    if (addr.ss_family == AF_INET) {]