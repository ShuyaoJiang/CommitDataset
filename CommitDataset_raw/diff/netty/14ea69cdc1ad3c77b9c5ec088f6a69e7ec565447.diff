[+++ b/codec/src/main/java/io/netty/handler/codec/compression/Lz4FrameEncoder.java, +import static io.netty.handler.codec.compression.Lz4Constants.BLOCK_TYPE_COMPRESSED;, +import static io.netty.handler.codec.compression.Lz4Constants.BLOCK_TYPE_NON_COMPRESSED;, +import static io.netty.handler.codec.compression.Lz4Constants.CHECKSUM_OFFSET;, +import static io.netty.handler.codec.compression.Lz4Constants.COMPRESSED_LENGTH_OFFSET;, +import static io.netty.handler.codec.compression.Lz4Constants.COMPRESSION_LEVEL_BASE;, +import static io.netty.handler.codec.compression.Lz4Constants.DECOMPRESSED_LENGTH_OFFSET;, +import static io.netty.handler.codec.compression.Lz4Constants.DEFAULT_BLOCK_SIZE;, +import static io.netty.handler.codec.compression.Lz4Constants.DEFAULT_SEED;, +import static io.netty.handler.codec.compression.Lz4Constants.HEADER_LENGTH;, +import static io.netty.handler.codec.compression.Lz4Constants.MAGIC_NUMBER;, +import static io.netty.handler.codec.compression.Lz4Constants.MAX_BLOCK_SIZE;, +import static io.netty.handler.codec.compression.Lz4Constants.MIN_BLOCK_SIZE;, +import static io.netty.handler.codec.compression.Lz4Constants.TOKEN_OFFSET;, +import static io.netty.util.internal.ThrowableUtil.unknownStackTrace;, +    private static final EncoderException ENCODE_FINSHED_EXCEPTION = unknownStackTrace(new EncoderException(, +                    new IllegalStateException("encode finished and not enough space to write remaining data")),, +                    Lz4FrameEncoder.class, "encode");, +    private final LZ4Compressor compressor;, +    private final ByteBufChecksum checksum;, +            if (!out.isWritable(in.readableBytes())) {, +                // out should be EMPTY_BUFFER because we should have allocated enough space above in allocateBuffer., +                throw ENCODE_FINSHED_EXCEPTION;, +            }, +        if (buffer != null) {, +            buffer.release();, +            buffer = null;, +        }, +++ b/codec/src/main/java/io/netty/handler/codec/compression/Lz4FrameEncoder.java, +import static io.netty.handler.codec.compression.Lz4Constants.BLOCK_TYPE_COMPRESSED;, +import static io.netty.handler.codec.compression.Lz4Constants.BLOCK_TYPE_NON_COMPRESSED;, +import static io.netty.handler.codec.compression.Lz4Constants.CHECKSUM_OFFSET;, +import static io.netty.handler.codec.compression.Lz4Constants.COMPRESSED_LENGTH_OFFSET;, +import static io.netty.handler.codec.compression.Lz4Constants.COMPRESSION_LEVEL_BASE;, +import static io.netty.handler.codec.compression.Lz4Constants.DECOMPRESSED_LENGTH_OFFSET;, +import static io.netty.handler.codec.compression.Lz4Constants.DEFAULT_BLOCK_SIZE;, +import static io.netty.handler.codec.compression.Lz4Constants.DEFAULT_SEED;, +import static io.netty.handler.codec.compression.Lz4Constants.HEADER_LENGTH;, +import static io.netty.handler.codec.compression.Lz4Constants.MAGIC_NUMBER;, +import static io.netty.handler.codec.compression.Lz4Constants.MAX_BLOCK_SIZE;, +import static io.netty.handler.codec.compression.Lz4Constants.MIN_BLOCK_SIZE;, +import static io.netty.handler.codec.compression.Lz4Constants.TOKEN_OFFSET;, +import static io.netty.util.internal.ThrowableUtil.unknownStackTrace;, +    private static final EncoderException ENCODE_FINSHED_EXCEPTION = unknownStackTrace(new EncoderException(, +                    new IllegalStateException("encode finished and not enough space to write remaining data")),, +                    Lz4FrameEncoder.class, "encode");, +    private final LZ4Compressor compressor;, +    private final ByteBufChecksum checksum;, +            if (!out.isWritable(in.readableBytes())) {, +                // out should be EMPTY_BUFFER because we should have allocated enough space above in allocateBuffer., +                throw ENCODE_FINSHED_EXCEPTION;, +            }, +        if (buffer != null) {, +            buffer.release();, +            buffer = null;, +        }, +++ b/codec/src/test/java/io/netty/handler/codec/compression/Lz4FrameEncoderTest.java, +import io.netty.bootstrap.Bootstrap;, +import io.netty.bootstrap.ServerBootstrap;, +import io.netty.channel.Channel;, +import io.netty.channel.ChannelFuture;, +import io.netty.channel.ChannelFutureListener;, +import io.netty.channel.ChannelInitializer;, +import io.netty.channel.EventLoopGroup;, +import io.netty.channel.nio.NioEventLoopGroup;, +import io.netty.channel.socket.nio.NioServerSocketChannel;, +import io.netty.channel.socket.nio.NioSocketChannel;, +import org.junit.Assert;, +import org.junit.Before;, +import org.junit.Test;, +import java.io.InputStream;, +import java.net.InetSocketAddress;, +import java.util.concurrent.CountDownLatch;, +import java.util.concurrent.atomic.AtomicReference;, +import java.util.zip.Checksum;, +, +import static org.hamcrest.Matchers.instanceOf;, +import static org.hamcrest.Matchers.not;, +import static org.hamcrest.core.Is.is;, +import static org.junit.Assert.assertNotNull;, +import static org.junit.Assert.assertThat;, +, +    @Test(timeout = 3000), +    public void writingAfterClosedChannelDoesNotNPE() throws InterruptedException {, +        EventLoopGroup group = new NioEventLoopGroup(2);, +        Channel serverChannel = null;, +        Channel clientChannel = null;, +        final CountDownLatch latch = new CountDownLatch(1);, +        final AtomicReference<Throwable> writeFailCauseRef = new AtomicReference<Throwable>();, +        try {, +            ServerBootstrap sb = new ServerBootstrap();, +            sb.group(group);, +            sb.channel(NioServerSocketChannel.class);, +            sb.childHandler(new ChannelInitializer<Channel>() {, +                @Override, +                protected void initChannel(Channel ch) throws Exception {, +                }, +            });, +, +            Bootstrap bs = new Bootstrap();]