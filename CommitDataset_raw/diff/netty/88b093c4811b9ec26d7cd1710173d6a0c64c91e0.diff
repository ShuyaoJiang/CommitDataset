[+++ b/buffer/src/main/java/io/netty/buffer/PoolChunkList.java, +            // Move the PoolChunk down the PoolChunkList linked-list., +            return move0(chunk);, +        }, +        return true;, +    }, +, +    private boolean move(PoolChunk<T> chunk) {, +        assert chunk.usage() < maxUsage;, +, +        if (chunk.usage() < minUsage) {, +            // Move the PoolChunk down the PoolChunkList linked-list., +            return move0(chunk);, +        }, +, +        // PoolChunk fits into this PoolChunkList, adding it here., +        add0(chunk);, +        return true;, +    }, +, +    /**, +     * Moves the {@link PoolChunk} down the {@link PoolChunkList} linked-list so it will end up in the right, +     * {@link PoolChunkList} that has the correct minUsage / maxUsage in respect to {@link PoolChunk#usage()}., +     */, +    private boolean move0(PoolChunk<T> chunk) {, +            // There is no previous PoolChunkList so return false which result in having the PoolChunk destroyed and, +            // all memory associated with the PoolChunk will be released., +        return prevList.move(chunk);, +        add0(chunk);, +    }, +    /**, +     * Adds the {@link PoolChunk} to this {@link PoolChunkList}., +     */, +    void add0(PoolChunk<T> chunk) {, +++ b/buffer/src/main/java/io/netty/buffer/PoolChunkList.java, +            // Move the PoolChunk down the PoolChunkList linked-list., +            return move0(chunk);, +        }, +        return true;, +    }, +, +    private boolean move(PoolChunk<T> chunk) {, +        assert chunk.usage() < maxUsage;, +, +        if (chunk.usage() < minUsage) {, +            // Move the PoolChunk down the PoolChunkList linked-list., +            return move0(chunk);, +        }, +, +        // PoolChunk fits into this PoolChunkList, adding it here., +        add0(chunk);, +        return true;, +    }, +, +    /**, +     * Moves the {@link PoolChunk} down the {@link PoolChunkList} linked-list so it will end up in the right, +     * {@link PoolChunkList} that has the correct minUsage / maxUsage in respect to {@link PoolChunk#usage()}., +     */, +    private boolean move0(PoolChunk<T> chunk) {, +            // There is no previous PoolChunkList so return false which result in having the PoolChunk destroyed and, +            // all memory associated with the PoolChunk will be released., +        return prevList.move(chunk);, +        add0(chunk);, +    }, +    /**, +     * Adds the {@link PoolChunk} to this {@link PoolChunkList}., +     */, +    void add0(PoolChunk<T> chunk) {, +++ b/buffer/src/test/java/io/netty/buffer/PooledByteBufAllocatorTest.java, +import static org.junit.Assert.assertFalse;, +    @Test, +    public void testFreePoolChunk() {, +        int chunkSize = 16 * 1024 * 1024;, +        PooledByteBufAllocator allocator = new PooledByteBufAllocator(true, 1, 0, 8192, 11, 0, 0, 0);, +        ByteBuf buffer = allocator.heapBuffer(chunkSize);, +        List<PoolArenaMetric> arenas = allocator.heapArenas();, +        assertEquals(1, arenas.size());, +        List<PoolChunkListMetric> lists = arenas.get(0).chunkLists();, +        assertEquals(6, lists.size());, +, +        assertFalse(lists.get(0).iterator().hasNext());, +        assertFalse(lists.get(1).iterator().hasNext());, +        assertFalse(lists.get(2).iterator().hasNext());, +        assertFalse(lists.get(3).iterator().hasNext());, +        assertFalse(lists.get(4).iterator().hasNext());, +, +        // Must end up in the 6th PoolChunkList, +        assertTrue(lists.get(5).iterator().hasNext());, +        assertTrue(buffer.release());, +, +        // Should be completely removed and so all PoolChunkLists must be empty, +        assertFalse(lists.get(0).iterator().hasNext());, +        assertFalse(lists.get(1).iterator().hasNext());, +        assertFalse(lists.get(2).iterator().hasNext());, +        assertFalse(lists.get(3).iterator().hasNext());, +        assertFalse(lists.get(4).iterator().hasNext());, +        assertFalse(lists.get(5).iterator().hasNext());, +    }, +]