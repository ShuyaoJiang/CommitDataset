[+++ b/handler/src/main/java/io/netty/handler/ssl/ReferenceCountedOpenSslEngine.java, +                // Explicitly use outboundClosed as we want to drain any bytes that are still present., +                    // If the outbound was closed we want to ensure we can produce the alert to the destination buffer., +                    // This is true even if we not using jdkCompatibilityMode., +                    //, +                    // We use a plaintextLength of 2 as we at least want to have an alert fit into it., +                    // https://tools.ietf.org/html/rfc5246#section-7.2, +                    if (!isBytesAvailableEnoughForWrap(dst.remaining(), 2, 1)) {, +                        return new SSLEngineResult(BUFFER_OVERFLOW, getHandshakeStatus(), 0, 0);, +                    }, +, +++ b/handler/src/main/java/io/netty/handler/ssl/ReferenceCountedOpenSslEngine.java, +                // Explicitly use outboundClosed as we want to drain any bytes that are still present., +                    // If the outbound was closed we want to ensure we can produce the alert to the destination buffer., +                    // This is true even if we not using jdkCompatibilityMode., +                    //, +                    // We use a plaintextLength of 2 as we at least want to have an alert fit into it., +                    // https://tools.ietf.org/html/rfc5246#section-7.2, +                    if (!isBytesAvailableEnoughForWrap(dst.remaining(), 2, 1)) {, +                        return new SSLEngineResult(BUFFER_OVERFLOW, getHandshakeStatus(), 0, 0);, +                    }, +, +++ b/handler/src/test/java/io/netty/handler/ssl/OpenSslEngineTest.java, +    @Test, +    public void testCorrectlyCalculateSpaceForAlert() throws Exception {, +        testCorrectlyCalculateSpaceForAlert(true);, +    }, +, +    @Test, +    public void testCorrectlyCalculateSpaceForAlertJDKCompatabilityModeOff() throws Exception {, +        testCorrectlyCalculateSpaceForAlert(false);, +    }, +, +    private void testCorrectlyCalculateSpaceForAlert(boolean jdkCompatabilityMode) throws Exception {, +        SelfSignedCertificate ssc = new SelfSignedCertificate();, +        serverSslCtx = SslContextBuilder.forServer(ssc.certificate(), ssc.privateKey()), +                .sslProvider(sslServerProvider()), +                .build();, +, +        clientSslCtx = SslContextBuilder.forClient(), +                .trustManager(InsecureTrustManagerFactory.INSTANCE), +                .sslProvider(sslClientProvider()), +                .build();, +        SSLEngine clientEngine = null;, +        SSLEngine serverEngine = null;, +        try {, +            if (jdkCompatabilityMode) {, +                clientEngine = wrapEngine(clientSslCtx.newEngine(UnpooledByteBufAllocator.DEFAULT));, +                serverEngine = wrapEngine(serverSslCtx.newEngine(UnpooledByteBufAllocator.DEFAULT));, +            } else {, +                clientEngine = wrapEngine(clientSslCtx.newHandler(UnpooledByteBufAllocator.DEFAULT).engine());, +                serverEngine = wrapEngine(serverSslCtx.newHandler(UnpooledByteBufAllocator.DEFAULT).engine());, +            }, +            handshake(clientEngine, serverEngine);, +, +            // This should produce an alert, +            clientEngine.closeOutbound();, +, +            ByteBuffer empty = allocateBuffer(0);, +            ByteBuffer dst = allocateBuffer(clientEngine.getSession().getPacketBufferSize());, +            // Limit to something that is guaranteed to be too small to hold a SSL Record., +            dst.limit(1);, +, +            // As we called closeOutbound() before this should produce a BUFFER_OVERFLOW., +            SSLEngineResult result = clientEngine.wrap(empty, dst);, +            assertEquals(SSLEngineResult.Status.BUFFER_OVERFLOW, result.getStatus());, +, +            // This must calculate a length that can hold an alert at least (or more)., +            dst.limit(dst.capacity());, +, +            result = clientEngine.wrap(empty, dst);, +            assertEquals(SSLEngineResult.Status.CLOSED, result.getStatus());, +, +            // flip the buffer so we can verify we produced a full length buffer., +            dst.flip();, +, +            int length = SslUtils.getEncryptedPacketLength(new ByteBuffer[] { dst }, 0);, +            assertEquals(length, dst.remaining());, +        } finally {, +            cleanupClientSslEngine(clientEngine);, +            cleanupServerSslEngine(serverEngine);, +            ssc.delete();, +        }, +    }, +]