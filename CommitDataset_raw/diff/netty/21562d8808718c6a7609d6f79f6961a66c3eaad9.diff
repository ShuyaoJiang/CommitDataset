[+++ b/buffer/src/main/java/io/netty/buffer/UnreleasableByteBuf.java, +        // We could call buf.readSlice(..), and then call buf.release(). However this creates a leak in unit tests, +        // because the release method on UnreleasableByteBuf will never allow the leak record to be cleaned up., +        // So we just use readSlice(..) because the end result should be logically equivalent., +        return readSlice(length);, +        // We could call buf.retainedSlice(), and then call buf.release(). However this creates a leak in unit tests, +        // because the release method on UnreleasableByteBuf will never allow the leak record to be cleaned up., +        // So we just use slice() because the end result should be logically equivalent., +        return slice();, +        // We could call buf.retainedSlice(..), and then call buf.release(). However this creates a leak in unit tests, +        // because the release method on UnreleasableByteBuf will never allow the leak record to be cleaned up., +        // So we just use slice(..) because the end result should be logically equivalent., +        return slice(index, length);, +        // We could call buf.retainedDuplicate(), and then call buf.release(). However this creates a leak in unit tests, +        // because the release method on UnreleasableByteBuf will never allow the leak record to be cleaned up., +        // So we just use duplicate() because the end result should be logically equivalent., +        return duplicate();, +++ b/buffer/src/main/java/io/netty/buffer/UnreleasableByteBuf.java, +        // We could call buf.readSlice(..), and then call buf.release(). However this creates a leak in unit tests, +        // because the release method on UnreleasableByteBuf will never allow the leak record to be cleaned up., +        // So we just use readSlice(..) because the end result should be logically equivalent., +        return readSlice(length);, +        // We could call buf.retainedSlice(), and then call buf.release(). However this creates a leak in unit tests, +        // because the release method on UnreleasableByteBuf will never allow the leak record to be cleaned up., +        // So we just use slice() because the end result should be logically equivalent., +        return slice();, +        // We could call buf.retainedSlice(..), and then call buf.release(). However this creates a leak in unit tests, +        // because the release method on UnreleasableByteBuf will never allow the leak record to be cleaned up., +        // So we just use slice(..) because the end result should be logically equivalent., +        return slice(index, length);, +        // We could call buf.retainedDuplicate(), and then call buf.release(). However this creates a leak in unit tests, +        // because the release method on UnreleasableByteBuf will never allow the leak record to be cleaned up., +        // So we just use duplicate() because the end result should be logically equivalent., +        return duplicate();, +++ b/buffer/src/test/java/io/netty/buffer/AbstractByteBufTest.java, +import static io.netty.buffer.Unpooled.unreleasableBuffer;, +    @Test, +    public void testRetainedSliceUnreleasble1() {, +        testRetainedSliceUnreleasble(true, true);, +    }, +, +    @Test, +    public void testRetainedSliceUnreleasble2() {, +        testRetainedSliceUnreleasble(true, false);, +    }, +, +    @Test, +    public void testRetainedSliceUnreleasble3() {, +        testRetainedSliceUnreleasble(false, true);, +    }, +, +    @Test, +    public void testRetainedSliceUnreleasble4() {, +        testRetainedSliceUnreleasble(false, false);, +    }, +, +    @Test, +    public void testReadRetainedSliceUnreleasble1() {, +        testReadRetainedSliceUnreleasble(true, true);, +    }, +, +    @Test, +    public void testReadRetainedSliceUnreleasble2() {, +        testReadRetainedSliceUnreleasble(true, false);, +    }, +, +    @Test, +    public void testReadRetainedSliceUnreleasble3() {, +        testReadRetainedSliceUnreleasble(false, true);, +    }, +, +    @Test, +    public void testReadRetainedSliceUnreleasble4() {, +        testReadRetainedSliceUnreleasble(false, false);, +    }, +, +    @Test, +    public void testRetainedDuplicateUnreleasble1() {, +        testRetainedDuplicateUnreleasble(true, true);, +    }, +, +    @Test, +    public void testRetainedDuplicateUnreleasble2() {, +        testRetainedDuplicateUnreleasble(true, false);, +    }, +, +    @Test, +    public void testRetainedDuplicateUnreleasble3() {, +        testRetainedDuplicateUnreleasble(false, true);, +    }, +, +    @Test, +    public void testRetainedDuplicateUnreleasble4() {, +        testRetainedDuplicateUnreleasble(false, false);, +    }, +, +    private void testRetainedSliceUnreleasble(boolean initRetainedSlice, boolean finalRetainedSlice) {, +        ByteBuf buf = newBuffer(8);, +        ByteBuf buf1 = initRetainedSlice ? buf.retainedSlice() : buf.slice().retain();, +        ByteBuf buf2 = unreleasableBuffer(buf1);]