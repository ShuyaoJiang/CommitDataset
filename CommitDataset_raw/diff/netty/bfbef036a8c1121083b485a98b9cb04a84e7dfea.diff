[+++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/AbstractEpollChannel.java, +import io.netty.channel.ChannelConfig;, +    protected final void doBeginRead() throws Exception {, +        AbstractEpollUnsafe unsafe = (AbstractEpollUnsafe) unsafe();, +        unsafe.readPending = true;, +, +        // If EPOLL ET mode is enabled and auto read was toggled off on the last read loop then we may not be notified, +        // again if we didn't consume all the data. So we force a read operation here if there maybe more data., +        if (unsafe.maybeMoreDataToRead) {, +            unsafe.epollInReady();, +        }, +        protected boolean maybeMoreDataToRead;, +        final void epollInReadAttempted() {, +            readPending = maybeMoreDataToRead = false;, +        }, +, +        final void epollInFinally(ChannelConfig config) {, +            // Check if there is a readPending which was not processed yet., +            // This could be for two reasons:, +            // * The user called Channel.read() or ChannelHandlerContext.read() in channelRead(...) method, +            // * The user called Channel.read() or ChannelHandlerContext.read() in channelReadComplete(...) method, +            //, +            // See https://github.com/netty/netty/issues/2254, +            if (!readPending && !config.isAutoRead()) {, +                clearEpollIn();, +            }, +        }, +, +        EpollRecvByteAllocatorHandle newEpollHandle(RecvByteBufAllocator.Handle handle) {, +            return new EpollRecvByteAllocatorHandle(handle, config());, +        }, +++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/AbstractEpollChannel.java, +import io.netty.channel.ChannelConfig;, +    protected final void doBeginRead() throws Exception {, +        AbstractEpollUnsafe unsafe = (AbstractEpollUnsafe) unsafe();, +        unsafe.readPending = true;, +, +        // If EPOLL ET mode is enabled and auto read was toggled off on the last read loop then we may not be notified, +        // again if we didn't consume all the data. So we force a read operation here if there maybe more data., +        if (unsafe.maybeMoreDataToRead) {, +            unsafe.epollInReady();, +        }, +        protected boolean maybeMoreDataToRead;, +        final void epollInReadAttempted() {, +            readPending = maybeMoreDataToRead = false;, +        }, +, +        final void epollInFinally(ChannelConfig config) {, +            // Check if there is a readPending which was not processed yet., +            // This could be for two reasons:, +            // * The user called Channel.read() or ChannelHandlerContext.read() in channelRead(...) method, +            // * The user called Channel.read() or ChannelHandlerContext.read() in channelReadComplete(...) method, +            //, +            // See https://github.com/netty/netty/issues/2254, +            if (!readPending && !config.isAutoRead()) {, +                clearEpollIn();, +            }, +        }, +, +        EpollRecvByteAllocatorHandle newEpollHandle(RecvByteBufAllocator.Handle handle) {, +            return new EpollRecvByteAllocatorHandle(handle, config());, +        }, +++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/AbstractEpollServerChannel.java, +            final EpollRecvByteAllocatorHandle allocHandle = recvBufAllocHandle();, +            allocHandle.edgeTriggered(isFlagSet(Native.EPOLLET));, +            if (!readPending && !allocHandle.isEdgeTriggered() && !config.isAutoRead()) {, +                        // lastBytesRead represents the fd. We use lastBytesRead because it must be set so that the, +                        // EpollRecvByteAllocatorHandle knows if it should try to read again or not when autoRead is, +                        // enabled., +                        allocHandle.lastBytesRead(fd().accept(acceptedAddress));, +                        epollInReadAttempted();, +                        if (allocHandle.lastBytesRead() == -1) {, +                        pipeline.fireChannelRead(newChildChannel(allocHandle.lastBytesRead(), acceptedAddress, 1, len));, +                maybeMoreDataToRead = allocHandle.maybeMoreDataToRead();, +                    checkResetEpollIn(allocHandle.isEdgeTriggered());, +                epollInFinally(config);, +++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/AbstractEpollChannel.java, +import io.netty.channel.ChannelConfig;, +    protected final void doBeginRead() throws Exception {, +        AbstractEpollUnsafe unsafe = (AbstractEpollUnsafe) unsafe();, +        unsafe.readPending = true;, +, +        // If EPOLL ET mode is enabled and auto read was toggled off on the last read loop then we may not be notified, +        // again if we didn't consume all the data. So we force a read operation here if there maybe more data., +        if (unsafe.maybeMoreDataToRead) {, +            unsafe.epollInReady();, +        }, +        protected boolean maybeMoreDataToRead;, +        final void epollInReadAttempted() {, +            readPending = maybeMoreDataToRead = false;, +        }, +, +        final void epollInFinally(ChannelConfig config) {, +            // Check if there is a readPending which was not processed yet., +            // This could be for two reasons:, +            // * The user called Channel.read() or ChannelHandlerContext.read() in channelRead(...) method, +            // * The user called Channel.read() or ChannelHandlerContext.read() in channelReadComplete(...) method, +            //, +            // See https://github.com/netty/netty/issues/2254, +            if (!readPending && !config.isAutoRead()) {]