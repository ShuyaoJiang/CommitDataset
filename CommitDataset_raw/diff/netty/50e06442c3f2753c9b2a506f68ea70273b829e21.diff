[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/DefaultHttpHeaders.java, +import io.netty.handler.codec.DefaultHeaders.NameConverter;, +import io.netty.handler.codec.DefaultTextHeaders.DefaultTextValueTypeConverter;, +/**, + * Default implementation of {@link HttpHeaders}., + */, +    private static final int HIGHEST_INVALID_NAME_CHAR_MASK = ~63;, +    private static final int HIGHEST_INVALID_VALUE_CHAR_MASK = ~15;, +, +    /**, +     * A look-up table used for checking if a character in a header name is prohibited., +     */, +    private static final byte[] LOOKUP_TABLE = new byte[~HIGHEST_INVALID_NAME_CHAR_MASK + 1];, +, +    static {, +        LOOKUP_TABLE['\t'] = -1;, +        LOOKUP_TABLE['\n'] = -1;, +        LOOKUP_TABLE[0x0b] = -1;, +        LOOKUP_TABLE['\f'] = -1;, +        LOOKUP_TABLE[' '] = -1;, +        LOOKUP_TABLE[','] = -1;, +        LOOKUP_TABLE[':'] = -1;, +        LOOKUP_TABLE[';'] = -1;, +        LOOKUP_TABLE['='] = -1;, +    }, +, +    private static final class HttpHeadersValidationConverter extends DefaultTextValueTypeConverter {, +        private final boolean validate;, +, +        HttpHeadersValidationConverter(boolean validate) {, +            this.validate = validate;, +        }, +, +        @Override, +        public CharSequence convertObject(Object value) {, +            if (value == null) {, +                throw new NullPointerException("value");, +            }, +, +            CharSequence seq;, +            if (value instanceof CharSequence) {, +                seq = (CharSequence) value;, +            } else if (value instanceof Number) {, +                seq = value.toString();, +            } else if (value instanceof Date) {, +                seq = HttpHeaderDateFormat.get().format((Date) value);, +            } else if (value instanceof Calendar) {, +                seq = HttpHeaderDateFormat.get().format(((Calendar) value).getTime());, +            } else {, +                seq = value.toString();, +            }, +, +            if (validate) {, +                if (value instanceof AsciiString) {, +                    validateValue((AsciiString) seq);, +                } else {, +                    validateValue(seq);, +                }, +            }, +, +            return seq;, +        }, +, +        private static void validateValue(AsciiString seq) {, +            int state = 0;, +            // Start looping through each of the character, +            final int start = seq.arrayOffset();, +            final int end = start + seq.length();, +            final byte[] array = seq.array();, +            for (int index = start; index < end; index++) {, +                state = validateValueChar(seq, state, (char) (array[index] & 0xFF));, +            }, +, +            if (state != 0) {, +                throw new IllegalArgumentException("a header value must not end with '\\r' or '\\n':" + seq);, +            }, +        }, +, +        private static void validateValue(CharSequence seq) {, +            int state = 0;, +            // Start looping through each of the character, +            for (int index = 0; index < seq.length(); index++) {, +                state = validateValueChar(seq, state, seq.charAt(index));, +            }, +, +            if (state != 0) {, +                throw new IllegalArgumentException("a header value must not end with '\\r' or '\\n':" + seq);, +            }, +        }, +, +        private static int validateValueChar(CharSequence seq, int state, char character) {, +            /*, +             * State:, +             * 0: Previous character was neither CR nor LF, +             * 1: The previous character was CR, +             * 2: The previous character was LF, +             */, +            if ((character & HIGHEST_INVALID_VALUE_CHAR_MASK) == 0) {, +                // Check the absolutely prohibited characters., +                switch (character) {]