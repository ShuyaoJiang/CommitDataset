[+++ b/handler/src/main/java/io/netty/handler/ssl/ReferenceCountedOpenSslEngine.java, +    private SSLEngineResult drainOutboundBuffer(ByteBuffer dst, SSLEngineResult.HandshakeStatus handshakeStatus), +            throws SSLException {, +        SSLEngineResult pendingNetResult = readPendingBytesFromBIO(dst, 0, 0, handshakeStatus);, +        return pendingNetResult != null ? pendingNetResult : NEED_UNWRAP_CLOSED;, +    }, +, +                // All drained in the outbound buffer, +, +            // Explicit use outboundClosed as we want to drain any bytes that are still present., +            if (outboundClosed) {, +                // There is something left to drain., +                // See https://github.com/netty/netty/issues/6260, +                return drainOutboundBuffer(dst, status);, +            }, +, +                    return drainOutboundBuffer(dst, status);, +++ b/handler/src/main/java/io/netty/handler/ssl/ReferenceCountedOpenSslEngine.java, +    private SSLEngineResult drainOutboundBuffer(ByteBuffer dst, SSLEngineResult.HandshakeStatus handshakeStatus), +            throws SSLException {, +        SSLEngineResult pendingNetResult = readPendingBytesFromBIO(dst, 0, 0, handshakeStatus);, +        return pendingNetResult != null ? pendingNetResult : NEED_UNWRAP_CLOSED;, +    }, +, +                // All drained in the outbound buffer, +, +            // Explicit use outboundClosed as we want to drain any bytes that are still present., +            if (outboundClosed) {, +                // There is something left to drain., +                // See https://github.com/netty/netty/issues/6260, +                return drainOutboundBuffer(dst, status);, +            }, +, +                    return drainOutboundBuffer(dst, status);, +++ b/handler/src/test/java/io/netty/handler/ssl/SSLEngineTest.java, +    public void testWrapAfterCloseOutbound() throws Exception {, +        SelfSignedCertificate cert = new SelfSignedCertificate();, +, +        clientSslCtx = SslContextBuilder, +                .forClient(), +                .trustManager(cert.cert()), +                .sslProvider(sslClientProvider()), +                .build();, +        SSLEngine client = clientSslCtx.newEngine(UnpooledByteBufAllocator.DEFAULT);, +, +        serverSslCtx = SslContextBuilder, +                .forServer(cert.certificate(), cert.privateKey()), +                .sslProvider(sslServerProvider()), +                .build();, +        SSLEngine server = serverSslCtx.newEngine(UnpooledByteBufAllocator.DEFAULT);, +, +        try {, +            ByteBuffer dst = allocateBuffer(server.getSession().getPacketBufferSize());, +            ByteBuffer src = allocateBuffer(1024);, +, +            handshake(client, server);, +, +            // This will produce a close_notify, +            client.closeOutbound();, +            SSLEngineResult result = client.wrap(src, dst);, +            assertEquals(SSLEngineResult.Status.CLOSED, result.getStatus());, +            assertEquals(0, result.bytesConsumed());, +            assertTrue(result.bytesProduced() > 0);, +, +            assertTrue(client.isOutboundDone());, +            assertFalse(client.isInboundDone());, +        } finally {, +            cert.delete();, +            cleanupClientSslEngine(client);, +            cleanupServerSslEngine(server);, +        }, +    }, +, +    @Test]