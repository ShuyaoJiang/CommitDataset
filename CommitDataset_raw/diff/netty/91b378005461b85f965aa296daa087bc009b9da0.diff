[+++ b/transport-native-epoll/src/main/c/io_netty_channel_epoll_Native.c, +jmethodID datagramSocketAddrMethodId = NULL;, +jclass datagramSocketAddressClass = NULL;, +, +jobject createDatagramSocketAddress(JNIEnv * env, struct sockaddr_storage addr, int len) {, +    char ipstr[INET6_ADDRSTRLEN];, +    int port;, +    if (addr.ss_family == AF_INET) {, +        struct sockaddr_in *s = (struct sockaddr_in *)&addr;, +        port = ntohs(s->sin_port);, +        inet_ntop(AF_INET, &s->sin_addr, ipstr, sizeof ipstr);, +    } else {, +        struct sockaddr_in6 *s = (struct sockaddr_in6 *)&addr;, +        port = ntohs(s->sin6_port);, +        inet_ntop(AF_INET6, &s->sin6_addr, ipstr, sizeof ipstr);, +    }, +    jstring ipString = (*env)->NewStringUTF(env, ipstr);, +    jobject socketAddr = (*env)->NewObject(env, datagramSocketAddressClass, datagramSocketAddrMethodId, ipString, port, len);, +    return socketAddr;, +}, +, +, +void init_in_addr(JNIEnv * env, jbyteArray address, struct in_addr * addr) {, +    jbyte* addressBytes = (*env)->GetByteArrayElements(env, address, 0);, +    if (socketType == AF_INET6) {, +        memcpy(addr, addressBytes, 16);, +    } else {, +        memcpy(addr, addressBytes + 12, 4);, +    }, +    (*env)->ReleaseByteArrayElements(env, address, addressBytes, JNI_ABORT);, +}, +        jclass localDatagramSocketAddressClass = (*env)->FindClass(env, "io/netty/channel/epoll/EpollDatagramChannel$DatagramSocketAddress");, +        if (localDatagramSocketAddressClass == NULL) {, +            // pending exception..., +            return JNI_ERR;, +        }, +        datagramSocketAddressClass = (jclass) (*env)->NewGlobalRef(env, localDatagramSocketAddressClass);, +        if (datagramSocketAddressClass == NULL) {, +            // out-of-memory!, +            throwOutOfMemoryError(env, "Error allocating memory");, +            return JNI_ERR;, +        }, +, +        datagramSocketAddrMethodId = (*env)->GetMethodID(env, datagramSocketAddressClass, "<init>", "(Ljava/lang/String;II)V");, +        if (datagramSocketAddrMethodId == NULL) {, +            throwRuntimeException(env, "Unable to obtain constructor of DatagramSocketAddress");, +            return JNI_ERR;, +        }, +, +        if (datagramSocketAddressClass != NULL) {, +            (*env)->DeleteGlobalRef(env, datagramSocketAddressClass);, +        }, +jint sendTo0(JNIEnv * env, jint fd, void* buffer, jint pos, jint limit ,jbyteArray address, jint scopeId, jint port) {, +    struct sockaddr_storage addr;, +    init_sockaddr(env, address, scopeId, port, &addr);, +, +    ssize_t res;, +    int err;, +    do {, +       res = sendto(fd, buffer + pos, (size_t) (limit - pos), 0, (struct sockaddr *)&addr, sizeof(struct sockaddr_storage));, +       // keep on writing if it was interrupted, +    } while(res == -1 && ((err = errno) == EINTR));, +, +    if (res < 0) {, +        // network stack saturated... try again later, +        if (err == EAGAIN || err == EWOULDBLOCK) {, +            return 0;, +        }, +        if (err == EBADF) {, +            throwClosedChannelException(env);, +            return -1;, +        }, +        throwIOException(env, exceptionMessage("Error while sendto(...): ", err));, +        return -1;, +    }, +    return (jint) res;, +}, +, +JNIEXPORT jint JNICALL Java_io_netty_channel_epoll_Native_sendTo(JNIEnv * env, jclass clazz, jint fd, jobject jbuffer, jint pos, jint limit, jbyteArray address, jint scopeId, jint port) {, +    void *buffer = (*env)->GetDirectBufferAddress(env, jbuffer);, +    if (buffer == NULL) {, +        throwRuntimeException(env, "Unable to access address of buffer");, +        return -1;, +    }, +    return sendTo0(env, fd, buffer, pos, limit, address, scopeId, port);, +}, +, +JNIEXPORT jint JNICALL Java_io_netty_channel_epoll_Native_sendToAddress(JNIEnv * env, jclass clazz, jint fd, jlong memoryAddress, jint pos, jint limit ,jbyteArray address, jint scopeId, jint port) {, +    return sendTo0(env, fd, (void*) memoryAddress, pos, limit, address, scopeId, port);, +}, +, +jobject recvFrom0(JNIEnv * env, jint fd, void* buffer, jint pos, jint limit) {, +    struct sockaddr_storage addr;, +    socklen_t addrlen = sizeof(addr);, +    ssize_t res;, +    int err;, +, +    do {, +        res = recvfrom(fd, buffer + pos, (size_t) (limit - pos), 0, (struct sockaddr *)&addr, &addrlen);, +        // Keep on reading if we was interrupted]