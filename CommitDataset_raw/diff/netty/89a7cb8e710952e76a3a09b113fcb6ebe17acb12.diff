[+++ b/transport/src/main/java/io/netty/bootstrap/AbstractBootstrap.java, +import io.netty.channel.DefaultChannelPromise;, +import io.netty.util.concurrent.GlobalEventExecutor;, +        final ChannelFuture regFuture = initAndRegister();, +        final Channel channel = regFuture.channel();, +        if (regFuture.cause() != null) {, +            return regFuture;, +        }, +, +        final ChannelPromise promise;, +        if (regFuture.isDone()) {, +            promise = channel.newPromise();, +            doBind0(regFuture, channel, localAddress, promise);, +            // Registration future is almost always fulfilled already, but just in case it's not., +            promise = new DefaultChannelPromise(channel, GlobalEventExecutor.INSTANCE);, +            regFuture.addListener(new ChannelFutureListener() {, +                    doBind0(regFuture, channel, localAddress, promise);, +        ChannelFuture regFuture = group().register(channel);, +        if (regFuture.cause() != null) {, +        return regFuture;, +++ b/transport/src/main/java/io/netty/bootstrap/AbstractBootstrap.java, +import io.netty.channel.DefaultChannelPromise;, +import io.netty.util.concurrent.GlobalEventExecutor;, +        final ChannelFuture regFuture = initAndRegister();, +        final Channel channel = regFuture.channel();, +        if (regFuture.cause() != null) {, +            return regFuture;, +        }, +, +        final ChannelPromise promise;, +        if (regFuture.isDone()) {, +            promise = channel.newPromise();, +            doBind0(regFuture, channel, localAddress, promise);, +            // Registration future is almost always fulfilled already, but just in case it's not., +            promise = new DefaultChannelPromise(channel, GlobalEventExecutor.INSTANCE);, +            regFuture.addListener(new ChannelFutureListener() {, +                    doBind0(regFuture, channel, localAddress, promise);, +        ChannelFuture regFuture = group().register(channel);, +        if (regFuture.cause() != null) {, +        return regFuture;, +++ b/transport/src/main/java/io/netty/bootstrap/ServerBootstrap.java, +import io.netty.channel.ChannelFuture;, +import io.netty.channel.ChannelFutureListener;, +            final Channel child = (Channel) msg;, +                childGroup.register(child).addListener(new ChannelFutureListener() {, +                    @Override, +                    public void operationComplete(ChannelFuture future) throws Exception {, +                        forceClose(child, future.cause());, +                    }, +                });, +                forceClose(child, t);, +            }, +        }, +, +        private static void forceClose(Channel child, Throwable t) {, +++ b/transport/src/main/java/io/netty/bootstrap/AbstractBootstrap.java, +import io.netty.channel.DefaultChannelPromise;, +import io.netty.util.concurrent.GlobalEventExecutor;, +        final ChannelFuture regFuture = initAndRegister();, +        final Channel channel = regFuture.channel();, +        if (regFuture.cause() != null) {, +            return regFuture;, +        }, +, +        final ChannelPromise promise;, +        if (regFuture.isDone()) {, +            promise = channel.newPromise();, +            doBind0(regFuture, channel, localAddress, promise);, +            // Registration future is almost always fulfilled already, but just in case it's not., +            promise = new DefaultChannelPromise(channel, GlobalEventExecutor.INSTANCE);, +            regFuture.addListener(new ChannelFutureListener() {, +                    doBind0(regFuture, channel, localAddress, promise);, +        ChannelFuture regFuture = group().register(channel);, +        if (regFuture.cause() != null) {, +        return regFuture;, +++ b/transport/src/main/java/io/netty/bootstrap/ServerBootstrap.java, +import io.netty.channel.ChannelFuture;, +import io.netty.channel.ChannelFutureListener;, +            final Channel child = (Channel) msg;, +                childGroup.register(child).addListener(new ChannelFutureListener() {, +                    @Override, +                    public void operationComplete(ChannelFuture future) throws Exception {, +                        forceClose(child, future.cause());, +                    }, +                });, +                forceClose(child, t);, +            }, +        }, +, +        private static void forceClose(Channel child, Throwable t) {, +++ b/transport/src/main/java/io/netty/channel/SingleThreadEventLoop.java, +        return register(channel, new DefaultChannelPromise(channel, this));, +++ b/transport/src/main/java/io/netty/bootstrap/AbstractBootstrap.java, +import io.netty.channel.DefaultChannelPromise;, +import io.netty.util.concurrent.GlobalEventExecutor;, +        final ChannelFuture regFuture = initAndRegister();, +        final Channel channel = regFuture.channel();, +        if (regFuture.cause() != null) {, +            return regFuture;, +        }]