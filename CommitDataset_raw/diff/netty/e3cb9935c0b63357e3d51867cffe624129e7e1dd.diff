[+++ b/transport/src/main/java/io/netty/channel/ChannelOutboundBuffer.java, +import io.netty.util.internal.SystemPropertyUtil;, +    // Assuming a 64-bit JVM:, +    //  - 16 bytes object header, +    //  - 8 reference fields, +    //  - 2 long fields, +    //  - 2 int fields, +    //  - 1 boolean field, +    //  - padding, +    static final int CHANNEL_OUTBOUND_BUFFER_ENTRY_OVERHEAD =, +            SystemPropertyUtil.getInt("io.netty.transport.outboundBufferEntrySizeOverhead", 96);, +        incrementPendingOutboundBytes(entry.pendingSize, false);, +            entry.pendingSize = size + CHANNEL_OUTBOUND_BUFFER_ENTRY_OVERHEAD;, +++ b/transport/src/main/java/io/netty/channel/ChannelOutboundBuffer.java, +import io.netty.util.internal.SystemPropertyUtil;, +    // Assuming a 64-bit JVM:, +    //  - 16 bytes object header, +    //  - 8 reference fields, +    //  - 2 long fields, +    //  - 2 int fields, +    //  - 1 boolean field, +    //  - padding, +    static final int CHANNEL_OUTBOUND_BUFFER_ENTRY_OVERHEAD =, +            SystemPropertyUtil.getInt("io.netty.transport.outboundBufferEntrySizeOverhead", 96);, +        incrementPendingOutboundBytes(entry.pendingSize, false);, +            entry.pendingSize = size + CHANNEL_OUTBOUND_BUFFER_ENTRY_OVERHEAD;, +++ b/transport/src/main/java/io/netty/channel/PendingWriteQueue.java, +import io.netty.util.internal.SystemPropertyUtil;, +    // Assuming a 64-bit JVM:, +    //  - 16 bytes object header, +    //  - 4 reference fields, +    //  - 1 long fields, +    private static final int PENDING_WRITE_OVERHEAD =, +            SystemPropertyUtil.getInt("io.netty.transport.pendingWriteSizeOverhead", 64);, +    private int size(Object msg) {, +        // It is possible for writes to be triggered from removeAndFailAll(). To preserve ordering,, +        // we should add them to the queue and let removeAndFailAll() fail them later., +        int messageSize = estimatorHandle.size(msg);, +        if (messageSize < 0) {, +            // Size may be unknow so just use 0, +            messageSize = 0;, +        }, +        return messageSize + PENDING_WRITE_OVERHEAD;, +    }, +, +        int messageSize = size(msg);, +, +++ b/transport/src/main/java/io/netty/channel/ChannelOutboundBuffer.java, +import io.netty.util.internal.SystemPropertyUtil;, +    // Assuming a 64-bit JVM:, +    //  - 16 bytes object header, +    //  - 8 reference fields, +    //  - 2 long fields, +    //  - 2 int fields, +    //  - 1 boolean field, +    //  - padding, +    static final int CHANNEL_OUTBOUND_BUFFER_ENTRY_OVERHEAD =, +            SystemPropertyUtil.getInt("io.netty.transport.outboundBufferEntrySizeOverhead", 96);, +        incrementPendingOutboundBytes(entry.pendingSize, false);, +            entry.pendingSize = size + CHANNEL_OUTBOUND_BUFFER_ENTRY_OVERHEAD;, +++ b/transport/src/main/java/io/netty/channel/PendingWriteQueue.java, +import io.netty.util.internal.SystemPropertyUtil;, +    // Assuming a 64-bit JVM:, +    //  - 16 bytes object header, +    //  - 4 reference fields, +    //  - 1 long fields, +    private static final int PENDING_WRITE_OVERHEAD =, +            SystemPropertyUtil.getInt("io.netty.transport.pendingWriteSizeOverhead", 64);, +    private int size(Object msg) {, +        // It is possible for writes to be triggered from removeAndFailAll(). To preserve ordering,, +        // we should add them to the queue and let removeAndFailAll() fail them later., +        int messageSize = estimatorHandle.size(msg);, +        if (messageSize < 0) {, +            // Size may be unknow so just use 0, +            messageSize = 0;, +        }, +        return messageSize + PENDING_WRITE_OVERHEAD;, +    }, +, +        int messageSize = size(msg);, +, +++ b/transport/src/test/java/io/netty/channel/ChannelOutboundBufferTest.java, +        ch.config().setWriteBufferLowWaterMark(128 + ChannelOutboundBuffer.CHANNEL_OUTBOUND_BUFFER_ENTRY_OVERHEAD);, +        ch.config().setWriteBufferHighWaterMark(256 + ChannelOutboundBuffer.CHANNEL_OUTBOUND_BUFFER_ENTRY_OVERHEAD);, +        assertThat(ch.unsafe().outboundBuffer().totalPendingWriteBytes(),, +                is(127L + ChannelOutboundBuffer.CHANNEL_OUTBOUND_BUFFER_ENTRY_OVERHEAD));]