[+++ b/buffer/src/main/java/io/netty/buffer/PoolArena.java, +        q100 = new PoolChunkList<T>(null, 100, Integer.MAX_VALUE, chunkSize);, +        q075 = new PoolChunkList<T>(q100, 75, 100, chunkSize);, +        q050 = new PoolChunkList<T>(q075, 50, 100, chunkSize);, +        q025 = new PoolChunkList<T>(q050, 25, 75, chunkSize);, +        q000 = new PoolChunkList<T>(q025, 1, 50, chunkSize);, +        qInit = new PoolChunkList<T>(q000, Integer.MIN_VALUE, 25, chunkSize);, +++ b/buffer/src/main/java/io/netty/buffer/PoolArena.java, +        q100 = new PoolChunkList<T>(null, 100, Integer.MAX_VALUE, chunkSize);, +        q075 = new PoolChunkList<T>(q100, 75, 100, chunkSize);, +        q050 = new PoolChunkList<T>(q075, 50, 100, chunkSize);, +        q025 = new PoolChunkList<T>(q050, 25, 75, chunkSize);, +        q000 = new PoolChunkList<T>(q025, 1, 50, chunkSize);, +        qInit = new PoolChunkList<T>(q000, Integer.MIN_VALUE, 25, chunkSize);, +++ b/buffer/src/main/java/io/netty/buffer/PoolChunkList.java, +    private final int maxCapacity;, +    PoolChunkList(PoolChunkList<T> nextList, int minUsage, int maxUsage, int chunkSize) {, +        assert minUsage <= maxUsage;, +        maxCapacity = calculateMaxCapacity(minUsage, chunkSize);, +    }, +, +    /**, +     * Calculates the maximum capacity of a buffer that will ever be possible to allocate out of the {@link PoolChunk}s, +     * that belong to the {@link PoolChunkList} with the given {@code minUsage} and {@code maxUsage} settings., +     */, +    private static int calculateMaxCapacity(int minUsage, int chunkSize) {, +        minUsage = minUsage0(minUsage);, +, +        if (minUsage == 100) {, +            // If the minUsage is 100 we can not allocate anything out of this list., +            return 0;, +        }, +, +        // Calculate the maximum amount of bytes that can be allocated from a PoolChunk in this PoolChunkList., +        //, +        // As an example:, +        // - If a PoolChunkList has minUsage == 25 we are allowed to allocate at most 75% of the chunkSize because, +        //   this is the maximum amount available in any PoolChunk in this PoolChunkList., +        return  (int) (chunkSize * (100L - minUsage) / 100L);, +        if (head == null || normCapacity > maxCapacity) {, +            // Either this PoolChunkList is empty or the requested capacity is larger then the capacity which can, +            // be handled by the PoolChunks that are contained in this PoolChunkList., +        return minUsage0(minUsage);, +    private static int minUsage0(int value) {, +        return max(1, value);, +    }, +]