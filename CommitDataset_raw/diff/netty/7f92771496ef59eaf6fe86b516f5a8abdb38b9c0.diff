[+++ b/common/src/main/java/io/netty/util/Recycler.java, +    final int threadLocalSize() {, +        return threadLocal.get().size;, +    }, +, +        boolean transfer(Stack<?> dst) {, +            final int srcStart = head.readIndex;, +            int srcEnd = head.get();, +            final int srcSize = srcEnd - srcStart;, +            if (srcSize == 0) {, +            final int dstSize = dst.size;, +            final int expectedCapacity = dstSize + srcSize;, +, +            if (expectedCapacity > dst.elements.length) {, +                final int actualCapacity = dst.increaseCapacity(expectedCapacity);, +                srcEnd = Math.min(srcStart + actualCapacity - dstSize, srcEnd);, +            if (srcStart != srcEnd) {, +                final DefaultHandle[] srcElems = head.elements;, +                final DefaultHandle[] dstElems = dst.elements;, +                int newDstSize = dstSize;, +                for (int i = srcStart; i < srcEnd; i++) {, +                    DefaultHandle element = srcElems[i];, +                    element.stack = dst;, +                    dstElems[newDstSize ++] = element;, +                    srcElems[i] = null;, +                dst.size = newDstSize;, +                if (srcEnd == LINK_CAPACITY && head.next != null) {, +                head.readIndex = srcEnd;, +            } else {, +                // The destination stack is full already., +                return false;, +            }, +            elements = new DefaultHandle[Math.min(INITIAL_CAPACITY, maxCapacity)];, +        }, +, +        int increaseCapacity(int expectedCapacity) {, +            int newCapacity = elements.length;, +            int maxCapacity = this.maxCapacity;, +            do {, +                newCapacity <<= 1;, +            } while (newCapacity < expectedCapacity && newCapacity < maxCapacity);, +, +            newCapacity = Math.min(newCapacity, maxCapacity);, +            if (newCapacity != elements.length) {, +                elements = Arrays.copyOf(elements, newCapacity);, +            }, +, +            return newCapacity;, +            WeakOrderQueue cursor = this.cursor;, +            if (cursor == null) {, +                cursor = head;, +                if (cursor == null) {, +                    return false;, +                }, +            }, +, +            WeakOrderQueue prev = this.prev;, +            do {, +, +                    // If the thread associated with the queue is gone, unlink it, after, +                    // performing a volatile read to confirm there is no data left to collect., +                    // We never unlink the first queue, as we don't want to synchronize on updating the head., +                            if (cursor.transfer(this)) {, +                                success = true;, +                            } else {, +, +, +            } while (cursor != null && !success);, +, +            if (size >= maxCapacity) {, +++ b/common/src/main/java/io/netty/util/Recycler.java, +    final int threadLocalSize() {, +        return threadLocal.get().size;, +    }, +, +        boolean transfer(Stack<?> dst) {, +            final int srcStart = head.readIndex;, +            int srcEnd = head.get();, +            final int srcSize = srcEnd - srcStart;, +            if (srcSize == 0) {, +            final int dstSize = dst.size;, +            final int expectedCapacity = dstSize + srcSize;, +, +            if (expectedCapacity > dst.elements.length) {, +                final int actualCapacity = dst.increaseCapacity(expectedCapacity);, +                srcEnd = Math.min(srcStart + actualCapacity - dstSize, srcEnd);, +            if (srcStart != srcEnd) {, +                final DefaultHandle[] srcElems = head.elements;, +                final DefaultHandle[] dstElems = dst.elements;, +                int newDstSize = dstSize;, +                for (int i = srcStart; i < srcEnd; i++) {, +                    DefaultHandle element = srcElems[i];, +                    element.stack = dst;, +                    dstElems[newDstSize ++] = element;, +                    srcElems[i] = null;, +                dst.size = newDstSize;, +                if (srcEnd == LINK_CAPACITY && head.next != null) {, +                head.readIndex = srcEnd;, +            } else {, +                // The destination stack is full already.]