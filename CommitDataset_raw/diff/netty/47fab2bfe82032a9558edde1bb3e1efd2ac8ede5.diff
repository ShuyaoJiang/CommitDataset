[+++ b/transport-native-epoll/src/main/c/io_netty_channel_epoll_Native.c, +jfieldID readerIndexFieldId = NULL;, +jfieldID writerIndexFieldId = NULL;, +jfieldID memoryAddressFieldId = NULL;, +, +        jclass addressEntryClass = (*env)->FindClass(env, "io/netty/channel/epoll/EpollChannelOutboundBuffer$AddressEntry");, +        if (addressEntryClass == NULL) {, +             // pending exception..., +            return JNI_ERR;, +        }, +        readerIndexFieldId = (*env)->GetFieldID(env, addressEntryClass, "readerIndex", "I");, +        if (readerIndexFieldId == NULL) {, +            // pending exception..., +            return JNI_ERR;, +        }, +        writerIndexFieldId = (*env)->GetFieldID(env, addressEntryClass, "writerIndex", "I");, +        if (writerIndexFieldId == NULL) {, +            // pending exception..., +            return JNI_ERR;, +        }, +        memoryAddressFieldId = (*env)->GetFieldID(env, addressEntryClass, "memoryAddress", "J");, +        if (memoryAddressFieldId == NULL) {, +            // pending exception..., +            return JNI_ERR;, +        }, +jlong writev0(JNIEnv * env, jclass clazz, jint fd, struct iovec iov[], jint length) {, +    ssize_t res;, +    int err;, +    do {, +        res = writev(fd, iov, length);, +        // keep on writing if it was interrupted, +    } while(res == -1 && ((err = errno) == EINTR));, +, +    if (res < 0) {, +        if (err == EAGAIN || err == EWOULDBLOCK) {, +            // network stack is saturated we will try again later, +            return 0;, +        }, +        if (err == EBADF) {, +            throwClosedChannelException(env);, +            return -1;, +        }, +        throwIOException(env, exceptionMessage("Error while writev(...): ", err));, +        return -1;, +    }, +    return (jlong) res;, +}, +, +    jlong res = writev0(env, clazz, fd, iov, length);, +    if (res <= 0) {, +        return res;, +JNIEXPORT jlong JNICALL Java_io_netty_channel_epoll_Native_writevAddresses(JNIEnv * env, jclass clazz, jint fd, jobjectArray addresses, jint offset, jint length) {, +    struct iovec iov[length];, +    int i;, +    int iovidx = 0;, +    for (i = offset; i < length; i++) {, +        jobject addressEntry = (*env)->GetObjectArrayElement(env, addresses, i);, +        jint readerIndex = (*env)->GetIntField(env, addressEntry, readerIndexFieldId);, +        jint writerIndex = (*env)->GetIntField(env, addressEntry, writerIndexFieldId);, +        void* memoryAddress = (void*) (*env)->GetLongField(env, addressEntry, memoryAddressFieldId);, +, +        iov[iovidx].iov_base = memoryAddress + readerIndex;, +        iov[iovidx].iov_len = (size_t) (writerIndex - readerIndex);, +        iovidx++;, +    }, +, +    jlong res = writev0(env, clazz, fd, iov, length);, +    if (res <= 0) {, +        return res;, +    }, +}, +, +++ b/transport-native-epoll/src/main/c/io_netty_channel_epoll_Native.c, +jfieldID readerIndexFieldId = NULL;, +jfieldID writerIndexFieldId = NULL;, +jfieldID memoryAddressFieldId = NULL;, +, +        jclass addressEntryClass = (*env)->FindClass(env, "io/netty/channel/epoll/EpollChannelOutboundBuffer$AddressEntry");, +        if (addressEntryClass == NULL) {, +             // pending exception..., +            return JNI_ERR;, +        }, +        readerIndexFieldId = (*env)->GetFieldID(env, addressEntryClass, "readerIndex", "I");, +        if (readerIndexFieldId == NULL) {, +            // pending exception..., +            return JNI_ERR;, +        }, +        writerIndexFieldId = (*env)->GetFieldID(env, addressEntryClass, "writerIndex", "I");, +        if (writerIndexFieldId == NULL) {, +            // pending exception..., +            return JNI_ERR;, +        }, +        memoryAddressFieldId = (*env)->GetFieldID(env, addressEntryClass, "memoryAddress", "J");, +        if (memoryAddressFieldId == NULL) {, +            // pending exception..., +            return JNI_ERR;, +        }, +jlong writev0(JNIEnv * env, jclass clazz, jint fd, struct iovec iov[], jint length) {, +    ssize_t res;, +    int err;]