[+++ b/buffer/src/test/java/io/netty/buffer/AbstractByteBufTest.java, +/*, + * Copyright 2012 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + *   http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the, + * License for the specific language governing permissions and limitations, + * under the License., + */, +package io.netty.buffer;, +, +import io.netty.util.CharsetUtil;, +import org.junit.After;, +import org.junit.Assume;, +import org.junit.Before;, +import org.junit.Test;, +, +import java.io.ByteArrayInputStream;, +import java.io.ByteArrayOutputStream;, +import java.nio.ByteBuffer;, +import java.util.Arrays;, +import java.util.HashSet;, +import java.util.Random;, +import java.util.Set;, +, +import static io.netty.buffer.Unpooled.*;, +import static org.junit.Assert.*;, +, +/**, + * An abstract test class for channel buffers, + */, +public abstract class AbstractByteBufTest {, +, +    private static final int CAPACITY = 4096; // Must be even, +    private static final int BLOCK_SIZE = 128;, +    private static final byte[] EMPTY_ARRAY = new byte[0];, +, +    private long seed;, +    private Random random;, +    private ByteBuf buffer;, +, +    protected abstract ByteBuf newBuffer(int capacity);, +    protected abstract ByteBuf[] components();, +, +    protected boolean discardReadBytesDoesNotMoveWritableBytes() {, +        return true;, +    }, +, +    @Before, +    public void init() {, +        buffer = newBuffer(CAPACITY);, +        seed = System.currentTimeMillis();, +        random = new Random(seed);, +    }, +, +    @After, +    public void dispose() {, +        if (buffer != null) {, +            try {, +                buffer.free();, +            } catch (Exception e) {, +                // Ignore., +            }, +            buffer = null;, +        }, +    }, +, +    @Test, +    public void initialState() {, +        assertEquals(CAPACITY, buffer.capacity());, +        assertEquals(0, buffer.readerIndex());, +    }, +, +    @Test(expected = IndexOutOfBoundsException.class), +    public void readerIndexBoundaryCheck1() {, +        try {, +            buffer.writerIndex(0);, +        } catch (IndexOutOfBoundsException e) {, +            fail();, +        }, +        buffer.readerIndex(-1);, +    }, +, +    @Test(expected = IndexOutOfBoundsException.class), +    public void readerIndexBoundaryCheck2() {, +        try {, +            buffer.writerIndex(buffer.capacity());, +        } catch (IndexOutOfBoundsException e) {, +            fail();, +        }, +        buffer.readerIndex(buffer.capacity() + 1);, +    }, +]