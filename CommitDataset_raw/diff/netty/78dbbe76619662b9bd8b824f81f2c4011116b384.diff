[+++ b/src/main/java/org/jboss/netty/channel/socket/http/HttpTunnelingClientSocketChannel.java, +import org.jboss.netty.channel.ChannelFutureListener;, +    void connectAndSendHeaders(boolean reconnect, final HttpTunnelAddress remoteAddress, final ChannelFuture future) {, +        final URI url = remoteAddress.getUri();, +        future.addListener(ChannelFutureListener.CLOSE_ON_FAILURE);, +, +        SocketAddress connectAddress = new InetSocketAddress(url.getHost(), url.getPort());, +        channel.connect(connectAddress).addListener(, +                new ChannelFutureListener() {, +                    public void operationComplete(ChannelFuture f) {, +                        if (f.isSuccess()) {, +                            ChannelFuture sslHandshakeFuture = null;, +                                try {, +                                    sslHandshakeFuture = sslHandler.handshake(channel);, +                                } catch (SSLException e) {, +                                    future.setFailure(e);, +                                    fireExceptionCaught(channel, e);, +                                    return;, +                                }, +                            final HttpRequest req = new DefaultHttpRequest(, +                                String cookie = ce.encode();, +                                //System.out.println("COOKIE: " + cookie);, +                                req.setHeader(HttpHeaders.Names.COOKIE, cookie);, +                            if (sslHandshakeFuture == null) {, +                                future.setSuccess();, +                                if (!channel.isBound()) {, +                                    fireChannelBound(HttpTunnelingClientSocketChannel.this, channel.getLocalAddress());, +                                }, +                                fireChannelConnected(HttpTunnelingClientSocketChannel.this, channel.getRemoteAddress());, +                            } else {, +                                sslHandshakeFuture.addListener(new ChannelFutureListener() {, +                                    public void operationComplete(, +                                            ChannelFuture f), +                                            throws Exception {, +                                        if (f.isSuccess()) {, +                                            channel.write(req);, +                                            future.setSuccess();, +                                            if (!isBound()) {, +                                                // FIXME: channelBound is not fired., +                                                fireChannelBound(HttpTunnelingClientSocketChannel.this, channel.getLocalAddress());, +                                            }, +                                            fireChannelConnected(HttpTunnelingClientSocketChannel.this, channel.getRemoteAddress());, +                                        } else {, +                                            future.setFailure(f.getCause());, +                                            fireExceptionCaught(HttpTunnelingClientSocketChannel.this, f.getCause());, +                                        }, +                                    }, +                                });, +                            }, +                        } else {, +                            future.setFailure(f.getCause());, +                            fireExceptionCaught(channel, f.getCause());, +                        }, +                    }, +                });, +    void sendChunk(ChannelBuffer a, final ChannelFuture future) {, +        final int size = a.readableBytes();, +        channel.write(new DefaultHttpChunk(a)).addListener(new ChannelFutureListener() {, +            public void operationComplete(ChannelFuture f), +                    throws Exception {, +                if (f.isSuccess()) {, +                    future.setSuccess();, +                    fireWriteComplete(HttpTunnelingClientSocketChannel.this, size);, +                } else {, +                    future.setFailure(f.getCause());, +                    fireExceptionCaught(HttpTunnelingClientSocketChannel.this, f.getCause());, +            }, +        });, +                //System.out.println("NEW_SESSION_ID: " + newSessionId);, +                , +                // If the session ID has been changed, it means the session has, +                // been timed out and a new session has been created.  If so,, +                // channel must be closed., +                if (sessionId != null && !sessionId.equals(newSessionId)) {, +                    closeSocket();, +                    return;, +                }, +                        fireMessageReceived(HttpTunnelingClientSocketChannel.this, content);, +                    fireMessageReceived(HttpTunnelingClientSocketChannel.this, chunk.getContent());, +++ b/src/main/java/org/jboss/netty/channel/socket/http/HttpTunnelingClientSocketChannel.java, +import org.jboss.netty.channel.ChannelFutureListener;, +    void connectAndSendHeaders(boolean reconnect, final HttpTunnelAddress remoteAddress, final ChannelFuture future) {, +        final URI url = remoteAddress.getUri();, +        future.addListener(ChannelFutureListener.CLOSE_ON_FAILURE);, +, +        SocketAddress connectAddress = new InetSocketAddress(url.getHost(), url.getPort());, +        channel.connect(connectAddress).addListener(, +                new ChannelFutureListener() {, +                    public void operationComplete(ChannelFuture f) {, +                        if (f.isSuccess()) {, +                            ChannelFuture sslHandshakeFuture = null;, +                                try {, +                                    sslHandshakeFuture = sslHandler.handshake(channel);, +                                } catch (SSLException e) {, +                                    future.setFailure(e);, +                                    fireExceptionCaught(channel, e);, +                                    return;, +                                }, +                            final HttpRequest req = new DefaultHttpRequest(, +                                String cookie = ce.encode();]