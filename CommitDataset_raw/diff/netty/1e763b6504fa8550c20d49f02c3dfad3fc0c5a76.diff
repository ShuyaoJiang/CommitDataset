[+++ b/transport/src/main/java/io/netty/channel/local/LocalChannel.java, +import io.netty.util.concurrent.SingleThreadEventExecutor;, +import io.netty.util.internal.EmptyArrays;, +    private static final ClosedChannelException CLOSED_CHANNEL_EXCEPTION = new ClosedChannelException();, +    // To further optimize this we could write our own SPSC queue., +        CLOSED_CHANNEL_EXCEPTION.setStackTrace(EmptyArrays.EMPTY_STACK_TRACE);, +, +            // State change must happen before finishPeerRead to ensure writes are released either in doWrite or, +            // channelRead., +, +            ChannelPromise promise = connectPromise;, +            if (promise != null) {, +                // Use tryFailure() instead of setFailure() to avoid the race against cancel()., +                promise.tryFailure(CLOSED_CHANNEL_EXCEPTION);, +                connectPromise = null;, +            }, +, +            // To preserve ordering of events we must process any pending reads, +            if (writeInProgress && peer != null) {, +                finishPeerRead(peer);, +            }, +                try {, +                } catch (RuntimeException e) {, +                    // The peer close may attempt to drain this.inboundBuffers. If that fails make sure it is drained., +                    releaseInboundBuffers();, +                    throw e;, +                }, +            try {, +            } catch (RuntimeException e) {, +                releaseInboundBuffers();, +                throw e;, +            }, +            throw CLOSED_CHANNEL_EXCEPTION;, +                    // It is possible the peer could have closed while we are writing, and in this case we should, +                    // simulate real socket behavior and ensure the write operation is failed., +                    if (peer.state == State.CONNECTED) {, +                    } else {, +                        in.remove(CLOSED_CHANNEL_EXCEPTION);, +                    }, +        try {, +        } catch (RuntimeException e) {, +            peer.releaseInboundBuffers();, +            throw e;, +        }, +    }, +, +    private void releaseInboundBuffers() {, +        for (;;) {, +            Object o = inboundBuffer.poll();, +            if (o == null) {, +                break;, +            }, +            ReferenceCountUtil.release(o);, +        }, +++ b/transport/src/main/java/io/netty/channel/local/LocalChannel.java, +import io.netty.util.concurrent.SingleThreadEventExecutor;, +import io.netty.util.internal.EmptyArrays;, +    private static final ClosedChannelException CLOSED_CHANNEL_EXCEPTION = new ClosedChannelException();, +    // To further optimize this we could write our own SPSC queue., +        CLOSED_CHANNEL_EXCEPTION.setStackTrace(EmptyArrays.EMPTY_STACK_TRACE);, +, +            // State change must happen before finishPeerRead to ensure writes are released either in doWrite or, +            // channelRead., +, +            ChannelPromise promise = connectPromise;, +            if (promise != null) {, +                // Use tryFailure() instead of setFailure() to avoid the race against cancel()., +                promise.tryFailure(CLOSED_CHANNEL_EXCEPTION);, +                connectPromise = null;, +            }, +, +            // To preserve ordering of events we must process any pending reads, +            if (writeInProgress && peer != null) {, +                finishPeerRead(peer);, +            }, +                try {, +                } catch (RuntimeException e) {, +                    // The peer close may attempt to drain this.inboundBuffers. If that fails make sure it is drained., +                    releaseInboundBuffers();, +                    throw e;, +                }, +            try {, +            } catch (RuntimeException e) {, +                releaseInboundBuffers();, +                throw e;, +            }, +            throw CLOSED_CHANNEL_EXCEPTION;, +                    // It is possible the peer could have closed while we are writing, and in this case we should, +                    // simulate real socket behavior and ensure the write operation is failed., +                    if (peer.state == State.CONNECTED) {, +                    } else {, +                        in.remove(CLOSED_CHANNEL_EXCEPTION);, +                    }, +        try {, +        } catch (RuntimeException e) {, +            peer.releaseInboundBuffers();, +            throw e;, +        }, +    }, +]