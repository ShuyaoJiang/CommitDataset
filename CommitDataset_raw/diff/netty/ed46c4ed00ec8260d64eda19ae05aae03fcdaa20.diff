[+++ b/buffer/src/main/java/io/netty/buffer/UnsafeByteBufUtil.java, +        final int length = src.remaining();, +            buf.checkIndex(index, length);, +            PlatformDependent.copyMemory(srcAddress + src.position(), addr, length);, +            buf.checkIndex(index, length);, +            if (length < 8) {, +                setSingleBytes(buf, addr, index, src, length);, +            } else {, +                //no need to checkIndex: internalNioBuffer is already taking care of it, +                assert buf.nioBufferCount() == 1;, +                final ByteBuffer internalBuffer = buf.internalNioBuffer(index, length);, +                internalBuffer.put(src);, +    private static void setSingleBytes(final AbstractByteBuf buf, final long addr, final int index,, +                                       final ByteBuffer src, final int length) {, +        buf.checkIndex(index, length);, +        final int srcPosition = src.position();, +        final int srcLimit = src.limit();, +        long dstAddr = addr;, +        for (int srcIndex = srcPosition; srcIndex < srcLimit; srcIndex++) {, +            final byte value = src.get(srcIndex);, +            PlatformDependent.putByte(dstAddr, value);, +            dstAddr++;, +        }, +        src.position(srcLimit);, +    }, +, +++ b/buffer/src/main/java/io/netty/buffer/UnsafeByteBufUtil.java, +        final int length = src.remaining();, +            buf.checkIndex(index, length);, +            PlatformDependent.copyMemory(srcAddress + src.position(), addr, length);, +            buf.checkIndex(index, length);, +            if (length < 8) {, +                setSingleBytes(buf, addr, index, src, length);, +            } else {, +                //no need to checkIndex: internalNioBuffer is already taking care of it, +                assert buf.nioBufferCount() == 1;, +                final ByteBuffer internalBuffer = buf.internalNioBuffer(index, length);, +                internalBuffer.put(src);, +    private static void setSingleBytes(final AbstractByteBuf buf, final long addr, final int index,, +                                       final ByteBuffer src, final int length) {, +        buf.checkIndex(index, length);, +        final int srcPosition = src.position();, +        final int srcLimit = src.limit();, +        long dstAddr = addr;, +        for (int srcIndex = srcPosition; srcIndex < srcLimit; srcIndex++) {, +            final byte value = src.get(srcIndex);, +            PlatformDependent.putByte(dstAddr, value);, +            dstAddr++;, +        }, +        src.position(srcLimit);, +    }, +, +++ b/microbench/src/main/java/io/netty/microbench/buffer/ByteBufCopyBenchmark.java, +/*, + * Copyright 2018 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + *   http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the, + * License for the specific language governing permissions and limitations, + * under the License., + */, +package io.netty.microbench.buffer;, +, +import io.netty.buffer.ByteBuf;, +import io.netty.buffer.PooledByteBufAllocator;, +import io.netty.buffer.Unpooled;, +import io.netty.microbench.util.AbstractMicrobenchmark;, +import org.openjdk.jmh.annotations.Benchmark;, +import org.openjdk.jmh.annotations.Param;, +import org.openjdk.jmh.annotations.Setup;, +import org.openjdk.jmh.annotations.TearDown;, +, +import java.nio.ByteBuffer;, +import java.nio.ByteOrder;, +, +public class ByteBufCopyBenchmark extends AbstractMicrobenchmark {, +    static {, +        System.setProperty("io.netty.buffer.bytebuf.checkAccessible", "false");, +    }, +, +    @Param({"7", "36", "128", "512" }), +    private int size;, +    @Param({"true", "false" }), +    private boolean directByteBuff;, +    @Param({"true", "false" }), +    private boolean directByteBuffer;, +    @Param({"false", "true" }), +    private boolean readonlyByteBuffer;, +    @Param({"true", "false" }), +    private boolean pooledByteBuf;, +    @Param({"true", "false" }), +    private boolean alignedCopyByteBuffer;, +    @Param({"true", "false" })]