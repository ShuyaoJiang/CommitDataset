[+++ b/transport/src/main/java/io/netty/channel/ChannelMetadata.java, +++ b/transport/src/main/java/io/netty/channel/ChannelMetadata.java, +++ b/transport/src/main/java/io/netty/channel/embedded/EmbeddedChannel.java, +import io.netty.util.internal.ObjectUtil;, +    private static final ChannelMetadata METADATA_NO_DISCONNECT = new ChannelMetadata(false);, +    private static final ChannelMetadata METADATA_DISCONNECT = new ChannelMetadata(true);, +    private final ChannelMetadata metadata;, +    private final ChannelConfig config;, +    public EmbeddedChannel(ChannelHandler... handlers) {, +     * Create a new instance with the pipeline initialized with the specified handlers., +     *, +     * @param hasDisconnect {@code false} if this {@link Channel} will delegate {@link #disconnect()}, +     *                      to {@link #close()}, {@link false} otherwise., +     * @param handlers the {@link ChannelHandler}s which will be add in the {@link ChannelPipeline}, +     */, +    public EmbeddedChannel(boolean hasDisconnect, ChannelHandler... handlers) {, +        this(EmbeddedChannelId.INSTANCE, hasDisconnect, handlers);, +    }, +, +    /**, +        this(channelId, false, handlers);, +    }, +, +    /**, +     * Create a new instance with the channel ID set to the given ID and the pipeline, +     * initialized with the specified handlers., +     *, +     * @param channelId the {@link ChannelId} that will be used to identify this channel, +     * @param hasDisconnect {@code false} if this {@link Channel} will delegate {@link #disconnect()}, +     *                      to {@link #close()}, {@link false} otherwise., +     * @param handlers the {@link ChannelHandler}s which will be add in the {@link ChannelPipeline}, +     */, +    public EmbeddedChannel(ChannelId channelId, boolean hasDisconnect, final ChannelHandler... handlers) {, +        ObjectUtil.checkNotNull(handlers, "handlers");, +        metadata = hasDisconnect ? METADATA_DISCONNECT : METADATA_NO_DISCONNECT;, +        config = new DefaultChannelConfig(this);, +        return metadata;, +    private void finishPendingTasks(boolean cancel) {, +        if (cancel) {, +    }, +        return close(newPromise());, +        return disconnect(newPromise());, +        finishPendingTasks(true);, +        finishPendingTasks(!metadata.hasDisconnect());, +        if (!metadata.hasDisconnect()) {, +    }, +++ b/transport/src/main/java/io/netty/channel/ChannelMetadata.java, +++ b/transport/src/main/java/io/netty/channel/embedded/EmbeddedChannel.java, +import io.netty.util.internal.ObjectUtil;, +    private static final ChannelMetadata METADATA_NO_DISCONNECT = new ChannelMetadata(false);, +    private static final ChannelMetadata METADATA_DISCONNECT = new ChannelMetadata(true);, +    private final ChannelMetadata metadata;, +    private final ChannelConfig config;, +    public EmbeddedChannel(ChannelHandler... handlers) {, +     * Create a new instance with the pipeline initialized with the specified handlers., +     *, +     * @param hasDisconnect {@code false} if this {@link Channel} will delegate {@link #disconnect()}, +     *                      to {@link #close()}, {@link false} otherwise., +     * @param handlers the {@link ChannelHandler}s which will be add in the {@link ChannelPipeline}, +     */, +    public EmbeddedChannel(boolean hasDisconnect, ChannelHandler... handlers) {, +        this(EmbeddedChannelId.INSTANCE, hasDisconnect, handlers);, +    }, +, +    /**, +        this(channelId, false, handlers);, +    }, +, +    /**, +     * Create a new instance with the channel ID set to the given ID and the pipeline, +     * initialized with the specified handlers., +     *, +     * @param channelId the {@link ChannelId} that will be used to identify this channel, +     * @param hasDisconnect {@code false} if this {@link Channel} will delegate {@link #disconnect()}, +     *                      to {@link #close()}, {@link false} otherwise., +     * @param handlers the {@link ChannelHandler}s which will be add in the {@link ChannelPipeline}, +     */, +    public EmbeddedChannel(ChannelId channelId, boolean hasDisconnect, final ChannelHandler... handlers) {, +        ObjectUtil.checkNotNull(handlers, "handlers");, +        metadata = hasDisconnect ? METADATA_DISCONNECT : METADATA_NO_DISCONNECT;, +        config = new DefaultChannelConfig(this);, +        return metadata;, +    private void finishPendingTasks(boolean cancel) {, +        if (cancel) {, +    }, +        return close(newPromise());, +        return disconnect(newPromise());, +        finishPendingTasks(true);, +        finishPendingTasks(!metadata.hasDisconnect());, +        if (!metadata.hasDisconnect()) {, +    }, +++ b/transport/src/test/java/io/netty/channel/embedded/EmbeddedChannelTest.java, +import io.netty.channel.ChannelOutboundHandlerAdapter;, +import io.netty.channel.ChannelPromise;, +import java.util.ArrayDeque;, +import java.util.Queue;, +import static org.junit.Assert.*;, +, +        assertSame(handler, pipeline.firstContext().handler());, +        assertTrue(channel.writeInbound(3));]