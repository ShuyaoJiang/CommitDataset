[+++ b/transport/src/main/java/io/netty/channel/ChannelOutboundBuffer.java, +import io.netty.buffer.UnpooledByteBufAllocator;, +import io.netty.buffer.UnpooledDirectByteBuf;, +import io.netty.util.internal.SystemPropertyUtil;, +    private static final int threadLocalDirectBufferSize;, +, +    static {, +        threadLocalDirectBufferSize = SystemPropertyUtil.getInt("io.netty.threadLocalDirectBufferSize", 64 * 1024);, +        logger.debug("-Dio.netty.threadLocalDirectBufferSize: {}", threadLocalDirectBufferSize);, +    }, +, +        return current(true);, +    }, +, +    public Object current(boolean preferDirect) {, +            // TODO: Think of a smart way to handle ByteBufHolder messages, +            Object msg = entry.msg;, +            if (threadLocalDirectBufferSize <= 0 || !preferDirect) {, +                return msg;, +            }, +            if (msg instanceof ByteBuf) {, +                ByteBuf buf = (ByteBuf) msg;, +                if (buf.isDirect()) {, +                    return buf;, +                } else {, +                    int readableBytes = buf.readableBytes();, +                    if (readableBytes == 0) {, +                        return buf;, +                    }, +, +                    // Non-direct buffers are copied into JDK's own internal direct buffer on every I/O., +                    // We can do a better job by using our pooled allocator. If the current allocator does not, +                    // pool a direct buffer, we use a ThreadLocal based pool., +                    ByteBufAllocator alloc = channel.alloc();, +                    ByteBuf directBuf;, +                    if (alloc.isDirectBufferPooled()) {, +                        directBuf = alloc.directBuffer(readableBytes);, +                    } else {, +                        directBuf = ThreadLocalPooledByteBuf.newInstance();, +                    }, +                    directBuf.writeBytes(buf, buf.readerIndex(), readableBytes);, +                    current(directBuf);, +                    return directBuf;, +                }, +            }, +            return msg;, +, +                        if (buf.isDirect() || threadLocalDirectBufferSize <= 0) {, +        ByteBuf directBuf;, +        if (alloc.isDirectBufferPooled()) {, +            directBuf = alloc.directBuffer(readableBytes);, +        } else {, +            directBuf = ThreadLocalPooledByteBuf.newInstance();, +        }, +, +    static final class ThreadLocalPooledByteBuf extends UnpooledDirectByteBuf {, +        private final Recycler.Handle<ThreadLocalPooledByteBuf> handle;, +, +        private static final Recycler<ThreadLocalPooledByteBuf> RECYCLER = new Recycler<ThreadLocalPooledByteBuf>() {, +            @Override, +            protected ThreadLocalPooledByteBuf newObject(Handle<ThreadLocalPooledByteBuf> handle) {, +                return new ThreadLocalPooledByteBuf(handle);, +            }, +        };, +, +        private ThreadLocalPooledByteBuf(Recycler.Handle<ThreadLocalPooledByteBuf> handle) {, +            super(UnpooledByteBufAllocator.DEFAULT, 256, Integer.MAX_VALUE);, +            this.handle = handle;, +        }, +, +        static ThreadLocalPooledByteBuf newInstance() {, +            ThreadLocalPooledByteBuf buf = RECYCLER.get();, +            buf.setRefCnt(1);, +            return buf;, +        }, +, +        @Override, +        protected void deallocate() {, +            if (capacity() > threadLocalDirectBufferSize) {, +                super.deallocate();, +            } else {, +                clear();, +                RECYCLER.recycle(this, handle);, +            }, +        }, +    }]