[+++ b/handler/src/main/java/io/netty/handler/ssl/SslHandler.java, +            forceFlush(ctx);, +, +        try {, +            wrapAndFlush(ctx);, +        } catch (Throwable cause) {, +            setHandshakeFailure(ctx, cause);, +            PlatformDependent.throwException(cause);, +        }, +    }, +, +    private void wrapAndFlush(ChannelHandlerContext ctx) throws SSLException {, +            forceFlush(ctx);, +    // This method will not call setHandshakeFailure(...) !, +    // This method will not call setHandshakeFailure(...) !, +            try {, +            } catch (Throwable cause) {, +                try {, +                    // We need to flush one time as there may be an alert that we should send to the remote peer because, +                    // of the SSLException reported here., +                    wrapAndFlush(ctx);, +                } catch (SSLException ex) {, +                    logger.debug("SSLException during trying to call SSLEngine.wrap(...)" +, +                            " because of an previous SSLException, ignoring...", ex);, +                } finally {, +                    setHandshakeFailure(ctx, cause);, +                }, +                PlatformDependent.throwException(cause);, +            }, +            forceFlush(ctx);, +        try {, +        } finally {, +            // Ensure we remove and fail all pending writes in all cases and so release memory quickly., +    }, +        } catch (Throwable e) {, +            setHandshakeFailure(ctx, e);, +        } finally {, +           forceFlush(ctx);, +    private void forceFlush(ChannelHandlerContext ctx) {, +        needsFlush = false;, +        ctx.flush();, +    }, +, +++ b/handler/src/main/java/io/netty/handler/ssl/SslHandler.java, +            forceFlush(ctx);, +, +        try {, +            wrapAndFlush(ctx);, +        } catch (Throwable cause) {, +            setHandshakeFailure(ctx, cause);, +            PlatformDependent.throwException(cause);, +        }, +    }, +, +    private void wrapAndFlush(ChannelHandlerContext ctx) throws SSLException {, +            forceFlush(ctx);, +    // This method will not call setHandshakeFailure(...) !, +    // This method will not call setHandshakeFailure(...) !, +            try {, +            } catch (Throwable cause) {, +                try {, +                    // We need to flush one time as there may be an alert that we should send to the remote peer because, +                    // of the SSLException reported here., +                    wrapAndFlush(ctx);, +                } catch (SSLException ex) {, +                    logger.debug("SSLException during trying to call SSLEngine.wrap(...)" +, +                            " because of an previous SSLException, ignoring...", ex);, +                } finally {, +                    setHandshakeFailure(ctx, cause);, +                }, +                PlatformDependent.throwException(cause);, +            }, +            forceFlush(ctx);, +        try {, +        } finally {, +            // Ensure we remove and fail all pending writes in all cases and so release memory quickly., +    }, +        } catch (Throwable e) {, +            setHandshakeFailure(ctx, e);, +        } finally {, +           forceFlush(ctx);, +    private void forceFlush(ChannelHandlerContext ctx) {, +        needsFlush = false;, +        ctx.flush();, +    }, +, +++ b/handler/src/test/java/io/netty/handler/ssl/SniHandlerTest.java, +            // This should produce an alert, +            assertTrue(ch.finish());, +++ b/handler/src/main/java/io/netty/handler/ssl/SslHandler.java, +            forceFlush(ctx);, +, +        try {, +            wrapAndFlush(ctx);, +        } catch (Throwable cause) {, +            setHandshakeFailure(ctx, cause);, +            PlatformDependent.throwException(cause);, +        }, +    }, +]