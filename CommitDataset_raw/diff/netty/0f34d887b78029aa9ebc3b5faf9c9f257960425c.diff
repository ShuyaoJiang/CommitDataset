[+++ b/transport/src/main/java/io/netty/channel/local/LocalChannel.java, +        // We should only set readInProgress to false if there is any data that was read as otherwise we may miss to, +        // forward data later on., +        if (peer.readInProgress && !peer.inboundBuffer.isEmpty()) {, +++ b/transport/src/main/java/io/netty/channel/local/LocalChannel.java, +        // We should only set readInProgress to false if there is any data that was read as otherwise we may miss to, +        // forward data later on., +        if (peer.readInProgress && !peer.inboundBuffer.isEmpty()) {, +++ b/transport/src/test/java/io/netty/channel/local/LocalChannelTest.java, +import io.netty.channel.ChannelOption;, +, +    private static void writeAndFlushReadOnSuccess(final ChannelHandlerContext ctx, Object msg) {, +        ctx.writeAndFlush(msg).addListener(new ChannelFutureListener() {, +            @Override, +            public void operationComplete(ChannelFuture future) {, +                if (future.isSuccess()) {, +                    ctx.read();, +                }, +            }, +        });, +    }, +, +    @Test(timeout = 5000), +    public void testAutoReadDisabledSharedGroup() throws Exception {, +        testAutoReadDisabled(sharedGroup, sharedGroup);, +    }, +, +    @Test(timeout = 5000), +    public void testAutoReadDisabledDifferentGroup() throws Exception {, +        testAutoReadDisabled(group1, group2);, +    }, +, +    private static void testAutoReadDisabled(EventLoopGroup serverGroup, EventLoopGroup clientGroup) throws Exception {, +        final CountDownLatch latch = new CountDownLatch(100);, +        Bootstrap cb = new Bootstrap();, +        ServerBootstrap sb = new ServerBootstrap();, +, +        cb.group(serverGroup), +                .channel(LocalChannel.class), +                .option(ChannelOption.AUTO_READ, false), +                .handler(new ChannelInboundHandlerAdapter() {, +, +                    @Override, +                    public void channelActive(final ChannelHandlerContext ctx) throws Exception {, +                        writeAndFlushReadOnSuccess(ctx, "test");, +                    }, +, +                    @Override, +                    public void channelRead(final ChannelHandlerContext ctx, Object msg) throws Exception {, +                        writeAndFlushReadOnSuccess(ctx, msg);, +                    }, +                });, +, +        sb.group(clientGroup), +                .channel(LocalServerChannel.class), +                .childOption(ChannelOption.AUTO_READ, false), +                .childHandler(new ChannelInboundHandlerAdapter() {, +                    @Override, +                    public void channelActive(final ChannelHandlerContext ctx) throws Exception {, +                        ctx.read();, +                    }, +, +                    @Override, +                    public void channelRead(final ChannelHandlerContext ctx, Object msg) throws Exception {, +                        latch.countDown();, +                        if (latch.getCount() > 0) {, +                            writeAndFlushReadOnSuccess(ctx, msg);, +                        }, +                    }, +                });, +, +        Channel sc = null;, +        Channel cc = null;, +        try {, +            // Start server, +            sc = sb.bind(TEST_ADDRESS).sync().channel();, +            cc = cb.connect(TEST_ADDRESS).sync().channel();, +, +            latch.await();, +        } finally {, +            closeChannel(cc);, +            closeChannel(sc);, +        }, +    }]