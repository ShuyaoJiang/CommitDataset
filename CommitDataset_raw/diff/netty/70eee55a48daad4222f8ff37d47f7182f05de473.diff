[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentCompressor.java, +    protected Result beginEncode(HttpResponse headers, String acceptEncoding) throws Exception {, +        String contentEncoding = headers.headers().get(HttpHeaders.Names.CONTENT_ENCODING);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentCompressor.java, +    protected Result beginEncode(HttpResponse headers, String acceptEncoding) throws Exception {, +        String contentEncoding = headers.headers().get(HttpHeaders.Names.CONTENT_ENCODING);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentEncoder.java, + * {@link EmbeddedByteChannel}, which is created by {@link #beginEncode(HttpResponse, String)}., + * {@link #beginEncode(HttpResponse, String)}., + * {@link #beginEncode(HttpResponse, String)} should return {@code null} so that, + * and implement {@link #beginEncode(HttpResponse, String)} properly to make, +public abstract class HttpContentEncoder extends MessageToMessageCodec<HttpRequest, HttpObject> {, +, +    private enum State {, +        PASS_THROUGH,, +        AWAIT_HEADERS,, +        AWAIT_CONTENT, +    }, +    private String acceptEncoding;, +    private State state = State.AWAIT_HEADERS;, +    public boolean acceptOutboundMessage(Object msg) throws Exception {, +        return msg instanceof HttpContent || msg instanceof HttpResponse;, +    }, +, +    @Override, +    protected void decode(ChannelHandlerContext ctx, HttpRequest msg, MessageBuf<Object> out), +    protected void encode(ChannelHandlerContext ctx, HttpObject msg, MessageBuf<Object> out) throws Exception {, +        final boolean isFull = msg instanceof HttpResponse && msg instanceof LastHttpContent;, +        switch (state) {, +            case AWAIT_HEADERS: {, +                ensureHeaders(msg);, +                assert encoder == null;, +                final HttpResponse res = (HttpResponse) msg;, +, +                if (res.getStatus().code() == 100) {, +                    if (isFull) {, +                        out.add(BufUtil.retain(res));, +                    } else {, +                        out.add(res);, +                        // Pass through all following contents., +                        state = State.PASS_THROUGH;, +                    break;, +                // Get the list of encodings accepted by the peer., +                acceptEncoding = acceptEncodingQueue.poll();, +                if (isFull) {, +                    // Pass through the full response with empty content and continue waiting for the the next resp., +                    if (!((ByteBufHolder) res).data().isReadable()) {, +                        out.add(BufUtil.retain(res));, +                        break;, +                    }, +                // Prepare to encode the content., +                Result result = beginEncode(res, acceptEncoding);, +                // If unable to encode, pass through., +                    if (isFull) {, +                        out.add(BufUtil.retain(res));, +                        out.add(res);, +                        state = State.PASS_THROUGH;, +                    break;, +                res.headers().set(Names.CONTENT_ENCODING, result.targetContentEncoding());, +                // Make the response chunked to simplify content transformation., +                res.headers().remove(Names.CONTENT_LENGTH);, +                res.headers().set(Names.TRANSFER_ENCODING, Values.CHUNKED);, +                // Output the rewritten response., +                if (isFull) {, +                    // Convert full message into unfull one., +                    HttpResponse newRes = new DefaultHttpResponse(res.getProtocolVersion(), res.getStatus());, +                    newRes.headers().set(res.headers());, +                    out.add(newRes);, +                    // Fall through to encode the content of the full response., +                    out.add(res);, +                    state = State.AWAIT_CONTENT;, +                    break;, +            }, +            case AWAIT_CONTENT: {, +                ensureContent(msg);, +                HttpContent[] encoded = encodeContent((HttpContent) msg);, +                if (encoded[encoded.length - 1] instanceof LastHttpContent) {, +                    state = State.AWAIT_HEADERS;, +                break;, +            case PASS_THROUGH: {, +                ensureContent(msg);, +                out.add(BufUtil.retain(msg));, +                // Passed through all following contents of the current response., +                if (msg instanceof LastHttpContent) {, +                    state = State.AWAIT_HEADERS;, +                break;, +            }, +    private static void ensureHeaders(HttpObject msg) {, +        if (!(msg instanceof HttpResponse)) {, +            throw new IllegalStateException(, +                    "unexpected message type: " +, +                    msg.getClass().getName() + " (expected: " + HttpResponse.class.getSimpleName() + ')');, +        }, +    }, +, +    private static void ensureContent(HttpObject msg) {, +        if (!(msg instanceof HttpContent)) {, +            throw new IllegalStateException(, +                    "unexpected message type: " +, +                    msg.getClass().getName() + " (expected: " + HttpContent.class.getSimpleName() + ')');]