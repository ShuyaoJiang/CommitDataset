[+++ b/src/main/java/org/jboss/netty/buffer/AbstractChannelBuffer.java, +        if (length > dst.writableBytes()) {, +            throw new IndexOutOfBoundsException();, +        }, +        if (length > src.readableBytes()) {, +            throw new IndexOutOfBoundsException();, +        }, +++ b/src/main/java/org/jboss/netty/buffer/AbstractChannelBuffer.java, +        if (length > dst.writableBytes()) {, +            throw new IndexOutOfBoundsException();, +        }, +        if (length > src.readableBytes()) {, +            throw new IndexOutOfBoundsException();, +        }, +++ b/src/main/java/org/jboss/netty/buffer/ChannelBuffer.java, + * <h4>Readable bytes (the actual content)</h4>, + * This segment is where the actual data is stored.  Any operation whose name, + * starts with {@code read} or {@code skip} will get or skip the data at the, + * current {@link #readerIndex() readerIndex} and increase it by the number of, + * read bytes.  If the argument of the read operation is also a, + * {@link ChannelBuffer} and no start index is specified, the specified, + * buffer's {@link #readerIndex() readerIndex} is increased together., + * other internal data representation, just like a NIO buffer does., + * <h4>NIO Buffers</h4>, + * <h4>Strings</h4>, + * <h4>I/O Streams</h4>, +     *         if the specified {@code readerIndex} is, +     *            less than {@code 0} or, +     *         if the specified {@code writerIndex} is, +     *            less than {@code this.readerIndex} or, +     *            greater than {@code this.capacity}, +     * indexes meet basic constraints, regardless what the current index, +     * values of the buffer are:, +     * Returns the number of readable bytes which is equal to, +     * Returns the number of writable bytes which is equal to, +     * from that of NIO buffer, which sets the {@code limit} to]