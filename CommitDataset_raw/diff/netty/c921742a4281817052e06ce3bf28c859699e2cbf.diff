[+++ b/handler/src/main/java/io/netty/handler/ssl/AbstractSniHandler.java, +                                SslUtils.notifyHandshakeFailure(ctx, e, true);, +++ b/handler/src/main/java/io/netty/handler/ssl/AbstractSniHandler.java, +                                SslUtils.notifyHandshakeFailure(ctx, e, true);, +++ b/handler/src/main/java/io/netty/handler/ssl/SslHandler.java, +    private boolean handshakeStarted;, +     * {@link #setHandshakeFailure(ChannelHandlerContext, Throwable, boolean, boolean)} or, +        setHandshakeFailure(ctx, CHANNEL_CLOSED, !outboundClosed, handshakeStarted);, +        setHandshakeFailure(ctx, cause, true, true);, +    private void setHandshakeFailure(ChannelHandlerContext ctx, Throwable cause, boolean closeInbound, boolean notify) {, +            notifyHandshakeFailure(cause, notify);, +    private void notifyHandshakeFailure(Throwable cause, boolean notify) {, +            SslUtils.notifyHandshakeFailure(ctx, cause, notify);, +            startHandshakeProcessing();, +        }, +    }, +, +    private void startHandshakeProcessing() {, +        handshakeStarted = true;, +                    notifyHandshakeFailure(HANDSHAKE_TIMED_OUT, true);, +            startHandshakeProcessing();, +++ b/handler/src/main/java/io/netty/handler/ssl/AbstractSniHandler.java, +                                SslUtils.notifyHandshakeFailure(ctx, e, true);, +++ b/handler/src/main/java/io/netty/handler/ssl/SslHandler.java, +    private boolean handshakeStarted;, +     * {@link #setHandshakeFailure(ChannelHandlerContext, Throwable, boolean, boolean)} or, +        setHandshakeFailure(ctx, CHANNEL_CLOSED, !outboundClosed, handshakeStarted);, +        setHandshakeFailure(ctx, cause, true, true);, +    private void setHandshakeFailure(ChannelHandlerContext ctx, Throwable cause, boolean closeInbound, boolean notify) {, +            notifyHandshakeFailure(cause, notify);, +    private void notifyHandshakeFailure(Throwable cause, boolean notify) {, +            SslUtils.notifyHandshakeFailure(ctx, cause, notify);, +            startHandshakeProcessing();, +        }, +    }, +, +    private void startHandshakeProcessing() {, +        handshakeStarted = true;, +                    notifyHandshakeFailure(HANDSHAKE_TIMED_OUT, true);, +            startHandshakeProcessing();, +++ b/handler/src/main/java/io/netty/handler/ssl/SslUtils.java, +    static void notifyHandshakeFailure(ChannelHandlerContext ctx, Throwable cause, boolean notify) {, +        if (notify) {, +        }, +++ b/handler/src/main/java/io/netty/handler/ssl/AbstractSniHandler.java, +                                SslUtils.notifyHandshakeFailure(ctx, e, true);, +++ b/handler/src/main/java/io/netty/handler/ssl/SslHandler.java, +    private boolean handshakeStarted;, +     * {@link #setHandshakeFailure(ChannelHandlerContext, Throwable, boolean, boolean)} or, +        setHandshakeFailure(ctx, CHANNEL_CLOSED, !outboundClosed, handshakeStarted);, +        setHandshakeFailure(ctx, cause, true, true);, +    private void setHandshakeFailure(ChannelHandlerContext ctx, Throwable cause, boolean closeInbound, boolean notify) {, +            notifyHandshakeFailure(cause, notify);, +    private void notifyHandshakeFailure(Throwable cause, boolean notify) {, +            SslUtils.notifyHandshakeFailure(ctx, cause, notify);, +            startHandshakeProcessing();, +        }, +    }, +, +    private void startHandshakeProcessing() {, +        handshakeStarted = true;, +                    notifyHandshakeFailure(HANDSHAKE_TIMED_OUT, true);, +            startHandshakeProcessing();, +++ b/handler/src/main/java/io/netty/handler/ssl/SslUtils.java, +    static void notifyHandshakeFailure(ChannelHandlerContext ctx, Throwable cause, boolean notify) {, +        if (notify) {, +        }, +++ b/handler/src/test/java/io/netty/handler/ssl/SslHandlerTest.java, +import io.netty.channel.DefaultChannelId;, +import java.util.concurrent.atomic.AtomicBoolean;, +    @Test, +    public void testNoSslHandshakeEventWhenNoHandshake() throws Exception {, +        final AtomicBoolean inActive = new AtomicBoolean(false);, +, +        SSLEngine engine = SSLContext.getDefault().createSSLEngine();, +        EmbeddedChannel ch = new EmbeddedChannel(, +                DefaultChannelId.newInstance(), false, false, new ChannelInboundHandlerAdapter() {, +            @Override, +            public void channelActive(ChannelHandlerContext ctx) throws Exception {, +                // Not forward the event to the SslHandler but just close the Channel., +                ctx.close();, +            }, +        }, new SslHandler(engine) {, +            @Override, +            public void handlerAdded(ChannelHandlerContext ctx) throws Exception {, +                // We want to override what Channel.isActive() will return as otherwise it will, +                // return true and so trigger an handshake., +                inActive.set(true);, +                super.handlerAdded(ctx);, +                inActive.set(false);, +            }, +        }, new ChannelInboundHandlerAdapter() {, +            @Override, +            public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception {, +                if (evt instanceof SslHandshakeCompletionEvent) {, +                    throw (Exception) ((SslHandshakeCompletionEvent) evt).cause();, +                }, +            }, +        }) {, +            @Override]