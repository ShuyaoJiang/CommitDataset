[+++ b/testsuite/src/main/java/io/netty/testsuite/transport/socket/SocketShutdownOutputBySelfTest.java, +import io.netty.channel.ChannelFuture;, +import io.netty.channel.ChannelOption;, +import io.netty.channel.WriteBufferWaterMark;, +import io.netty.channel.socket.oio.OioSocketChannel;, +import java.util.concurrent.BlockingDeque;, +import java.util.concurrent.LinkedBlockingDeque;, +import java.util.concurrent.TimeUnit;, +import static org.junit.Assert.assertNull;, +import static org.junit.Assume.assumeFalse;, +    @Test(timeout = 30000), +    public void testWriteAfterShutdownOutputNoWritabilityChange() throws Throwable {, +        run();, +    }, +, +    public void testWriteAfterShutdownOutputNoWritabilityChange(Bootstrap cb) throws Throwable {, +        final TestHandler h = new TestHandler();, +        ServerSocket ss = new ServerSocket();, +        Socket s = null;, +        SocketChannel ch = null;, +        try {, +            ss.bind(newSocketAddress());, +            cb.option(ChannelOption.WRITE_BUFFER_WATER_MARK, new WriteBufferWaterMark(2, 4));, +            ch = (SocketChannel) cb.handler(h).connect(ss.getLocalSocketAddress()).sync().channel();, +            assumeFalse(ch instanceof OioSocketChannel);, +            assertTrue(ch.isActive());, +            assertFalse(ch.isOutputShutdown());, +, +            s = ss.accept();, +, +            byte[] expectedBytes = new byte[]{ 1, 2, 3, 4, 5, 6 };, +            ChannelFuture writeFuture = ch.write(Unpooled.wrappedBuffer(expectedBytes));, +            h.assertWritability(false);, +            ch.flush();, +            writeFuture.sync();, +            h.assertWritability(true);, +            for (int i = 0; i < expectedBytes.length; ++i) {, +                assertEquals(expectedBytes[i], s.getInputStream().read());, +            }, +, +            assertTrue(h.ch.isOpen());, +            assertTrue(h.ch.isActive());, +            assertFalse(h.ch.isInputShutdown());, +            assertFalse(h.ch.isOutputShutdown());, +, +            // Make the connection half-closed and ensure read() returns -1., +            ch.shutdownOutput().sync();, +            assertEquals(-1, s.getInputStream().read());, +, +            assertTrue(h.ch.isOpen());, +            assertTrue(h.ch.isActive());, +            assertFalse(h.ch.isInputShutdown());, +            assertTrue(h.ch.isOutputShutdown());, +, +            try {, +                // If half-closed, the local endpoint shouldn't be able to write, +                ch.writeAndFlush(Unpooled.wrappedBuffer(new byte[]{ 2 })).sync();, +                fail();, +            } catch (Throwable cause) {, +                checkThrowable(cause);, +            }, +            assertNull(h.writabilityQueue.poll());, +        } finally {, +            if (s != null) {, +                s.close();, +            }, +            if (ch != null) {, +                ch.close();, +            }, +            ss.close();, +        }, +    }, +, +, +    private static final class TestHandler extends SimpleChannelInboundHandler<ByteBuf> {, +        final BlockingDeque<Boolean> writabilityQueue = new LinkedBlockingDeque<Boolean>();, +, +        @Override, +        public void channelWritabilityChanged(ChannelHandlerContext ctx) throws Exception {, +            writabilityQueue.add(ctx.channel().isWritable());, +        }, +, +        private void drainWritabilityQueue() throws InterruptedException {, +            while ((writabilityQueue.poll(100, TimeUnit.MILLISECONDS)) != null) {, +                // Just drain the queue., +            }, +        }, +, +        void assertWritability(boolean isWritable) throws InterruptedException {, +            try {, +                Boolean writability = writabilityQueue.takeLast();, +                assertEquals(isWritable, writability);, +                // TODO(scott): why do we get multiple writability changes here ... race condition?, +                drainWritabilityQueue();, +            } catch (Throwable c) {, +                c.printStackTrace();, +            }, +        }, +++ b/testsuite/src/main/java/io/netty/testsuite/transport/socket/SocketShutdownOutputBySelfTest.java, +import io.netty.channel.ChannelFuture;]