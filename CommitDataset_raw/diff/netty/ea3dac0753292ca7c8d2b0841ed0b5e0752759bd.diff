[+++ b/buffer/src/main/java/io/netty/buffer/PoolChunk.java, +    private static final int ST_ALLOCATED_SUBPAGE = 3;, +                // Try the right node first because it is more likely to be ST_UNUSED., +                // It is because allocateRunSimple() always chooses the left node., +, +                final int nextValLeft = memoryMap[nextIdxLeft];, +                final boolean recurseLeft;, +, +                switch (nextValLeft & 3) {, +                    case ST_UNUSED:, +                        return allocateRunSimple(normCapacity, nextIdxLeft, nextValLeft);, +                    case ST_BRANCH:, +                        recurseLeft = true;, +                        break;, +                    default:, +                        recurseLeft = false;, +                }, +, +                if (recurseRight) {, +                    long res = branchRun(normCapacity, nextIdxRight);, +                if (recurseLeft) {, +                    return branchRun(normCapacity, nextIdxLeft);, +            int nextIdx = curIdx << 1;, +        switch (val & 3) {, +            case ST_UNUSED:, +                return allocateSubpageSimple(normCapacity, curIdx, val);, +            case ST_BRANCH:, +                // Try the right node first because it is more likely to be ST_UNUSED., +                // It is because allocateSubpageSimple() always chooses the left node., +                final int nextIdxLeft = curIdx << 1;, +                final int nextIdxRight = nextIdxLeft ^ 1;, +, +                long res = branchSubpage(normCapacity, nextIdxRight);, +                return branchSubpage(normCapacity, nextIdxLeft);, +            case ST_ALLOCATED_SUBPAGE:, +            int nextIdx = curIdx << 1;]