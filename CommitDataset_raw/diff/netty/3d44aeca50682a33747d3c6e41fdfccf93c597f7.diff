[+++ b/transport/src/main/java/io/netty/channel/socket/nio/NioEventLoop.java, +import java.nio.channels.*;, +    protected Selector selector;, +, +    protected final SelectorProvider provider;, +        provider = selectorProvider;, +        selector = openSelector();, +    private Selector openSelector() {, +    // Create a new selector and "transfer" all channels from the old, +    // selector to the new one, +    private Selector recreateSelector() {, +        Selector newSelector = openSelector();, +        Selector selector = this.selector;, +        this.selector = newSelector;, +, +        // loop over all the keys that are registered with the old Selector, +        // and register them with the new one, +        for (SelectionKey key: selector.keys()) {, +            SelectableChannel ch = key.channel();, +            int ops = key.interestOps();, +            Object att = key.attachment();, +            // cancel the old key, +            cancel(key);, +, +            try {, +                // register the channel with the new selector now, +                ch.register(newSelector, ops, att);, +            } catch (ClosedChannelException e) {, +                // close channel, +                AbstractNioChannel channel = (AbstractNioChannel) att;, +                channel.unsafe().close(channel.unsafe().voidFuture());, +            }, +        }, +        try {, +            // time to close the old selector as everything else is registered to the new one, +            selector.close();, +        } catch (Throwable t) {, +            logger.warn("Failed to close a selector.", t);, +        }, +        logger.warn("Recreated Selector because of possible jdk epoll(..) bug");, +        return newSelector;, +    }, +        int selectReturnsImmediately = 0;, +, +        // use 80% of the timeout for measure, +        long minSelectTimeout = SelectorUtil.SELECT_TIMEOUT_NANOS / 100 * 80;, +, +                long beforeSelect = System.nanoTime();, +                int selected = SelectorUtil.select(selector);, +                if (selected == 0) {, +                    long timeBlocked = System.nanoTime()  - beforeSelect;, +                    if (timeBlocked < minSelectTimeout) {, +                        // returned before the minSelectTimeout elapsed with nothing select., +                        // this may be the cause of the jdk epoll(..) bug, so increment the counter, +                        // which we use later to see if its really the jdk bug., +                        selectReturnsImmediately ++;, +                    } else {, +                        selectReturnsImmediately = 0;, +                    }, +                    if (selectReturnsImmediately == 10) {, +                        // The selector returned immediately for 10 times in a row,, +                        // so recreate one selector as it seems like we hit the, +                        // famous epoll(..) jdk bug., +                        selector = recreateSelector();, +                        selectReturnsImmediately = 0;, +, +                        // try to select again, +                        continue;, +                    }, +                } else {, +                    // reset counter, +                    selectReturnsImmediately = 0;, +                }, +++ b/transport/src/main/java/io/netty/channel/socket/nio/NioEventLoop.java, +import java.nio.channels.*;, +    protected Selector selector;, +, +    protected final SelectorProvider provider;, +        provider = selectorProvider;, +        selector = openSelector();, +    private Selector openSelector() {, +    // Create a new selector and "transfer" all channels from the old, +    // selector to the new one, +    private Selector recreateSelector() {, +        Selector newSelector = openSelector();, +        Selector selector = this.selector;, +        this.selector = newSelector;, +, +        // loop over all the keys that are registered with the old Selector, +        // and register them with the new one, +        for (SelectionKey key: selector.keys()) {, +            SelectableChannel ch = key.channel();, +            int ops = key.interestOps();, +            Object att = key.attachment();, +            // cancel the old key, +            cancel(key);, +, +            try {, +                // register the channel with the new selector now, +                ch.register(newSelector, ops, att);]