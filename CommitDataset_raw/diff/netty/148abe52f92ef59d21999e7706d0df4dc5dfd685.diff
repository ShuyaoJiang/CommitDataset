[+++ b/transport/src/main/java/io/netty/channel/DefaultChannelPipeline.java, +import java.util.WeakHashMap;, +    @SuppressWarnings("unchecked"), +    private static final WeakHashMap<Class<?>, String>[] nameCaches =, +            new WeakHashMap[Runtime.getRuntime().availableProcessors()];, +, +    static {, +        for (int i = 0; i < nameCaches.length; i ++) {, +            nameCaches[i] = new WeakHashMap<Class<?>, String>();, +        }, +    }, +, +, +    private String generateName(ChannelHandler handler) {, +        WeakHashMap<Class<?>, String> cache = nameCaches[(int) (Thread.currentThread().getId() % nameCaches.length)];, +        Class<?> handlerType = handler.getClass();, +        String name;, +        synchronized (cache) {, +            name = cache.get(handlerType);, +            if (name == null) {, +                Package pkg = handlerType.getPackage();, +                if (pkg != null) {, +                    name = handlerType.getName().substring(pkg.getName().length() + 1);, +                } else {, +                    name = handlerType.getName();, +                }, +                name += "#0";, +                cache.put(handlerType, name);, +            }, +        }, +, +        synchronized (this) {, +            // It's not very likely for a user to put more than one handler of the same type, but make sure to avoid, +            // any name conflicts.  Note that we don't cache the names generated here., +            if (name2ctx.containsKey(name)) {, +                String baseName = name.substring(0, name.length() - 1); // Strip the trailing '0'., +                for (int i = 1;; i ++) {, +                    String newName = baseName + i;, +                    if (!name2ctx.containsKey(newName)) {, +                        name = newName;, +                        break;, +                    }, +                }, +            }, +        }, +, +        return name;, +    @Override, +    public Iterator<Map.Entry<String, ChannelHandler>> iterator() {, +        return toMap().entrySet().iterator();, +    }, +]