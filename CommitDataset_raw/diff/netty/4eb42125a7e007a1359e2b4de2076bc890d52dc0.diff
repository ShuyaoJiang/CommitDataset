[+++ b/transport/src/main/java/io/netty/channel/DefaultChannelPipeline.java, +import java.util.concurrent.Future;, +    , +    public ChannelPipeline addFirst(EventExecutor executor, final String name, final ChannelHandler handler) {, +        try {, +            Future<?> future;, +, +            synchronized (this) {, +                final DefaultChannelHandlerContext newCtx = new DefaultChannelHandlerContext(this, executor, head, nextCtx, name, handler);, +                    return this;, +                }, +                future = newCtx.executor().submit(new Runnable() {, +                        synchronized (DefaultChannelPipeline.this) {, +                        , +                    }, +                });, +            }, +            // Call Future.get() outside of the synchronized block to prevent dead-lock, +            future.get();, +            return this;, +, +, +    public ChannelPipeline addLast(EventExecutor executor, final String name, final ChannelHandler handler) {, +        try {, +            Future<?> future;, +            synchronized (this) {, +                checkDuplicateName(name);, +, +                final DefaultChannelHandlerContext oldTail = tail;, +                final DefaultChannelHandlerContext newTail = new DefaultChannelHandlerContext(this, executor, oldTail, null, name, handler);, +                    return this;, +                    future = newTail.executor().submit(new Runnable() {, +                            synchronized (DefaultChannelPipeline.this) {, +                        }, +                    });, +                }, +            }, +            // Call Future.get() outside of synchronized block to prevent dead-lock, +            future.get();, +        , +    public ChannelPipeline addBefore(EventExecutor executor, String baseName, final String name, final ChannelHandler handler) {, +        try {, +            Future<?> future;, +            , +            synchronized (this) {, +                final DefaultChannelHandlerContext newCtx = new DefaultChannelHandlerContext(this, executor, ctx.prev, ctx, name, handler);, +                    return this;, +                    future = newCtx.executor().submit(new Runnable() {, +                                synchronized (DefaultChannelPipeline.this) {, +, +                            }, +                        });, +                    , +                }, +            }, +            , +            // Call Future.get() outside of the synchronized to prevent dead-lock, +            future.get();, +            , +, +        , +    public ChannelPipeline addAfter(EventExecutor executor, String baseName, final String name, final ChannelHandler handler) {, +        , +        try {, +            Future<?> future;, +            , +            synchronized (this) {, +                    return addLast(name, handler);, +                }, +                final DefaultChannelHandlerContext newCtx = new DefaultChannelHandlerContext(this, executor, ctx, ctx.next, name, handler);, +                    return this;, +                    future = newCtx.executor().submit(new Runnable() {, +                            synchronized (DefaultChannelPipeline.this) {, +                        }, +                    });, +                }, +            }, +            future.get();, +            return this;, +, +        , +    public void remove(ChannelHandler handler) {, +    public ChannelHandler remove(String name) {, +    public <T extends ChannelHandler> T remove(Class<T> handlerType) {, +        try {, +            DefaultChannelHandlerContext context;, +            Future<?> future;, +            synchronized (this) {, +                    if (head == tail) {, +                        throw new NoSuchElementException();, +                    }, +, +                    final DefaultChannelHandlerContext oldTail = tail;, +                    if (!oldTail.channel().isRegistered() || oldTail.executor().inEventLoop()) {, +                        removeLast0(oldTail);, +                        return oldTail;, +                    } else {, +                        future = oldTail.executor().submit(new Runnable() {, +                            @Override, +                            public void run() {]