[+++ b/src/main/java/org/jboss/netty/example/discard/DiscardClientHandler.java, +    private long transferredBytes = 0;, +        return transferredBytes;, +        transferredBytes =+e.getWrittenAmount();, +++ b/src/main/java/org/jboss/netty/example/discard/DiscardClientHandler.java, +    private long transferredBytes = 0;, +        return transferredBytes;, +        transferredBytes =+e.getWrittenAmount();, +++ b/src/main/java/org/jboss/netty/example/discard/DiscardServerHandler.java, +    private long transferredBytes = 0;, +        return transferredBytes;, +        transferredBytes += (((ChannelBuffer) e.getMessage()).readableBytes());, +++ b/src/main/java/org/jboss/netty/example/discard/DiscardClientHandler.java, +    private long transferredBytes = 0;, +        return transferredBytes;, +        transferredBytes =+e.getWrittenAmount();, +++ b/src/main/java/org/jboss/netty/example/discard/DiscardServerHandler.java, +    private long transferredBytes = 0;, +        return transferredBytes;, +        transferredBytes += (((ChannelBuffer) e.getMessage()).readableBytes());, +++ b/src/main/java/org/jboss/netty/handler/execution/OrderedMemoryAwareThreadPoolExecutor.java, +import java.util.Queue;, +import java.util.concurrent.atomic.AtomicBoolean;, +import org.jboss.netty.util.internal.LinkedTransferQueue;, +        private final Queue<Runnable> tasks = new LinkedTransferQueue<Runnable>();, +        private final AtomicBoolean isRunning = new AtomicBoolean(false);, +            // TODO: What todo if the add return false ?, +, +            if (isRunning.get() == false) {, +            // check if its already running by using CAS. If so just return here. So in the worst case the thread, +            // is executed and do nothing, +            if (isRunning.compareAndSet(false, true)) {, +                try {, +                        final Runnable task = tasks.poll();, +                        // if the task is null we should exit the loop, +                        if (task == null) {, +                            break;, +                        }, +                    }, +                    // set it back to not running, +                    isRunning.set(false);, +++ b/src/main/java/org/jboss/netty/example/discard/DiscardClientHandler.java, +    private long transferredBytes = 0;, +        return transferredBytes;, +        transferredBytes =+e.getWrittenAmount();, +++ b/src/main/java/org/jboss/netty/example/discard/DiscardServerHandler.java, +    private long transferredBytes = 0;, +        return transferredBytes;, +        transferredBytes += (((ChannelBuffer) e.getMessage()).readableBytes());, +++ b/src/main/java/org/jboss/netty/handler/execution/OrderedMemoryAwareThreadPoolExecutor.java, +import java.util.Queue;, +import java.util.concurrent.atomic.AtomicBoolean;, +import org.jboss.netty.util.internal.LinkedTransferQueue;, +        private final Queue<Runnable> tasks = new LinkedTransferQueue<Runnable>();, +        private final AtomicBoolean isRunning = new AtomicBoolean(false);, +            // TODO: What todo if the add return false ?, +, +            if (isRunning.get() == false) {, +            // check if its already running by using CAS. If so just return here. So in the worst case the thread, +            // is executed and do nothing, +            if (isRunning.compareAndSet(false, true)) {, +                try {, +                        final Runnable task = tasks.poll();, +                        // if the task is null we should exit the loop, +                        if (task == null) {, +                            break;, +                        }, +                    }, +                    // set it back to not running, +                    isRunning.set(false);, +++ b/src/main/java/org/jboss/netty/handler/region/FileRegionEncoder.java, + * Copyright 2011 Red Hat, Inc., + * the to be written {@link ChannelBuffer} in any case. This could be for example {@link ChannelDownstreamHandler}'s which needs to encrypt or compress messages., + * , + * Users of this {@link FileRegionEncoder} should add / remove this {@link ChannelDownstreamHandler} on the fly to get the best performance out of their system., + * , +@ChannelHandler.Sharable, +]