[+++ b/handler/src/main/java/io/netty/handler/ssl/SslHandler.java, +    private final ChannelFlushFutureNotifier flushFutureNotifier = new ChannelFlushFutureNotifier();, +                    ctx.close();, +        if (ctx.executor() == ctx.channel().eventLoop()) {, +        } else {, +            synchronized (flushFutureNotifier) {, +                flushFutureNotifier.addFlushFuture(future, in.readableBytes());, +            }, +        }, +        int bytesConsumed = 0;, +                bytesConsumed += result.bytesConsumed();, +                        flush0(ctx, bytesConsumed, e);, +                        bytesConsumed = 0;, +            flush0(ctx, bytesConsumed);, +    private void flush0(final ChannelHandlerContext ctx, final int bytesConsumed) {, +        ctx.flush(ctx.newFuture().addListener(new ChannelFutureListener() {, +            @Override, +            public void operationComplete(ChannelFuture future) throws Exception {, +                if (ctx.executor() == ctx.channel().eventLoop()) {, +                    notifyFlushFutures(bytesConsumed, future);, +                } else {, +                    synchronized (flushFutureNotifier) {, +                        notifyFlushFutures(bytesConsumed, future);, +                    }, +                }, +            }, +, +            private void notifyFlushFutures(final int bytesConsumed, ChannelFuture future) {, +                if (future.isSuccess()) {, +                    flushFutureNotifier.increaseWriteCounter(bytesConsumed);, +                    flushFutureNotifier.notifyFlushFutures();, +                } else {, +                    flushFutureNotifier.notifyFlushFutures(future.cause());, +                }, +            }, +        }));, +    }, +, +    private void flush0(final ChannelHandlerContext ctx, final int bytesConsumed, final Throwable cause) {, +        ChannelFuture flushFuture = ctx.flush(ctx.newFuture().addListener(new ChannelFutureListener() {, +            @Override, +            public void operationComplete(ChannelFuture future) throws Exception {, +                if (ctx.executor() == ctx.channel().eventLoop()) {, +                    notifyFlushFutures(ctx, bytesConsumed, cause, future);, +                } else {, +                    synchronized (flushFutureNotifier) {, +                        notifyFlushFutures(ctx, bytesConsumed, cause, future);, +                    }, +                }, +            }, +, +            private void notifyFlushFutures(final ChannelHandlerContext ctx,, +                    final int bytesConsumed, final Throwable cause, ChannelFuture future) {, +                flushFutureNotifier.increaseWriteCounter(bytesConsumed);, +                if (future.isSuccess()) {, +                    flushFutureNotifier.notifyFlushFutures(cause);, +                } else {, +                    flushFutureNotifier.notifyFlushFutures(cause, future.cause());, +                }, +            }, +        }));, +, +        safeClose(ctx, flushFuture, ctx.newFuture());, +    }, +, +                ctx.fireExceptionCaught(e);, +                setHandshakeFailure(e);, +                return;, +        if (cause == null) {, +            cause = new ClosedChannelException();, +        }, +, +, +        flush0(ctx, 0, cause);, +        safeClose(ctx, closeNotifyFuture, future);, +                        ctx.close();, +    private static void safeClose(, +            final ChannelHandlerContext ctx, ChannelFuture flushFuture,, +            final ChannelFuture closeFuture) {, +        if (!ctx.channel().isActive()) {, +            ctx.close(closeFuture);, +            return;, +        }, +, +        // Force-close the connection if close_notify is not fully sent in time., +        final ScheduledFuture<?> timeoutFuture = ctx.executor().schedule(new Runnable() {, +            @Override, +            public void run() {, +                logger.warn(, +                        ctx.channel() + " last lssssswrite attempt timed out." +, +                                        " Force-closing the connection.");, +                ctx.close(closeFuture);, +            }, +        }, 3, TimeUnit.SECONDS); // FIXME: Magic value, +, +        // Close the connection if close_notify is sent in time., +        flushFuture.addListener(new ChannelFutureListener() {, +            @Override, +            public void operationComplete(ChannelFuture f), +                    throws Exception {]