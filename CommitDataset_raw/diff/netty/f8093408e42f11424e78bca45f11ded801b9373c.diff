[+++ b/buffer/src/main/java/io/netty/buffer/CompositeByteBuf.java, +    /**, +     * Returns the {@link ByteBuf} portion of this {@link CompositeByteBuf} that, +     * contains the specified {@code index}. This is an expert method!, +     *, +     * <p>, +     * Please note that since a {@link CompositeByteBuf} is made up of, +     * multiple {@link ByteBuf}s, this does <em>not</em> return the full buffer., +     * Instead, it only returns a portion of the composite buffer where the, +     * index is located, +     * </p>, +     *, +     * @param index The {@code index} to search for and include in the returned {@link ByteBuf}, +     * @return The {@link ByteBuf} that contains the specified {@code index}, +     * @throws IndexOutOfBoundsException when the specified {@code index} is, +     * less than zero, or larger than {@code capacity()}, +     */, +    public ByteBuf getBufferFor(int index) throws IndexOutOfBoundsException {, +        if (index < 0 || index >= capacity()) {, +            throw new IndexOutOfBoundsException("Invalid index: " + index, +                    + " - Bytes needed: " + index + ", maximum is ", +                    + capacity());, +        }, +, +        //Return the component byte buffer, +        return components[componentId(index)];, +, +    }, +, +++ b/buffer/src/main/java/io/netty/buffer/CompositeByteBuf.java, +    /**, +     * Returns the {@link ByteBuf} portion of this {@link CompositeByteBuf} that, +     * contains the specified {@code index}. This is an expert method!, +     *, +     * <p>, +     * Please note that since a {@link CompositeByteBuf} is made up of, +     * multiple {@link ByteBuf}s, this does <em>not</em> return the full buffer., +     * Instead, it only returns a portion of the composite buffer where the, +     * index is located, +     * </p>, +     *, +     * @param index The {@code index} to search for and include in the returned {@link ByteBuf}, +     * @return The {@link ByteBuf} that contains the specified {@code index}, +     * @throws IndexOutOfBoundsException when the specified {@code index} is, +     * less than zero, or larger than {@code capacity()}, +     */, +    public ByteBuf getBufferFor(int index) throws IndexOutOfBoundsException {, +        if (index < 0 || index >= capacity()) {, +            throw new IndexOutOfBoundsException("Invalid index: " + index, +                    + " - Bytes needed: " + index + ", maximum is ", +                    + capacity());, +        }, +, +        //Return the component byte buffer, +        return components[componentId(index)];, +, +    }, +, +++ b/buffer/src/test/java/io/netty/buffer/AbstractCompositeChannelBufferTest.java, +import java.io.IOException;, +    /**, +     * Tests the "getBufferFor" method, +     */, +    @Test, +    public void testGetBufferFor() throws IOException {, +        CompositeByteBuf buf = (CompositeByteBuf) Unpooled.wrappedBuffer(new byte[] { 1, 2, 3, 4, 5 }, new byte[] {4, 5, 6, 7, 8, 9, 26});, +    , +        //Ensure that a random place will be fine, +        assertEquals(buf.getBufferFor(2).capacity(), 5);, +        , +        //Loop through each byte, +        , +        byte index = 0;, +        , +        while (index < buf.capacity()) {, +            ByteBuf _buf = buf.getBufferFor(index++);, +            assertNotNull(_buf);, +            assertTrue(_buf.capacity() > 0);, +            assertNotNull(_buf.getByte(0));, +            assertNotNull(_buf.getByte(_buf.readableBytes() - 1));, +        }, +    }, +]