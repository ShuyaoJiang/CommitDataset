[+++ b/testsuite/src/main/java/io/netty/testsuite/transport/socket/CompositeBufferGatheringWriteTest.java, +import io.netty.channel.ChannelConfig;, +import io.netty.channel.ChannelOption;, +import io.netty.channel.socket.nio.NioSocketChannel;, +import java.util.Random;, +    @Test(timeout = 10000), +    public void testCompositeBufferPartialWriteDoesNotCorruptData() throws Throwable {, +        run();, +    }, +, +    protected void compositeBufferPartialWriteDoesNotCorruptDataInitServerConfig(ChannelConfig config,, +                                                                                 int soSndBuf) {, +    }, +, +    public void testCompositeBufferPartialWriteDoesNotCorruptData(ServerBootstrap sb, Bootstrap cb) throws Throwable {, +        // The scenario is the following:, +        // Limit SO_SNDBUF so that a single buffer can be written, and part of a CompositeByteBuf at the same time., +        // We then write the single buffer, the CompositeByteBuf, and another single buffer and verify the data is not, +        // corrupted when we read it on the other side., +        Channel serverChannel = null;, +        Channel clientChannel = null;, +        try {, +            Random r = new Random();, +            final int soSndBuf = 1024;, +            ByteBufAllocator alloc = ByteBufAllocator.DEFAULT;, +            final ByteBuf expectedContent = alloc.buffer(soSndBuf * 2);, +            expectedContent.writeBytes(newRandomBytes(expectedContent.writableBytes(), r));, +            final CountDownLatch latch = new CountDownLatch(1);, +            final AtomicReference<Object> clientReceived = new AtomicReference<Object>();, +            sb.childOption(ChannelOption.SO_SNDBUF, soSndBuf), +              .childHandler(new ChannelInitializer<Channel>() {, +                @Override, +                protected void initChannel(Channel ch) throws Exception {, +                    ch.pipeline().addLast(new ChannelInboundHandlerAdapter() {, +                        @Override, +                        public void channelActive(ChannelHandlerContext ctx) throws Exception {, +                            compositeBufferPartialWriteDoesNotCorruptDataInitServerConfig(ctx.channel().config(),, +                                    soSndBuf);, +                            // First single write, +                            int offset = soSndBuf - 100;, +                            ctx.write(expectedContent.retainedSlice(expectedContent.readerIndex(), offset));, +, +                            // Build and write CompositeByteBuf, +                            CompositeByteBuf compositeByteBuf = ctx.alloc().compositeBuffer();, +                            compositeByteBuf.addComponent(true,, +                                    expectedContent.retainedSlice(expectedContent.readerIndex() + offset, 50));, +                            offset += 50;, +                            compositeByteBuf.addComponent(true,, +                                    expectedContent.retainedSlice(expectedContent.readerIndex() + offset, 200));, +                            offset += 200;, +                            ctx.write(compositeByteBuf);, +, +                            // Write a single buffer that is smaller than the second component of the CompositeByteBuf, +                            // above but small enough to fit in the remaining space allowed by the soSndBuf amount., +                            ctx.write(expectedContent.retainedSlice(expectedContent.readerIndex() + offset, 50));, +                            offset += 50;, +, +                            // Write the remainder of the content, +                            ctx.writeAndFlush(expectedContent.retainedSlice(expectedContent.readerIndex() + offset,, +                                    expectedContent.readableBytes() - expectedContent.readerIndex() - offset)), +                                    .addListener(ChannelFutureListener.CLOSE);, +                        }, +, +                        @Override, +                        public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {, +                            // IOException is fine as it will also close the channel and may just be a connection reset., +                            if (!(cause instanceof IOException)) {, +                                clientReceived.set(cause);, +                                latch.countDown();, +                            }, +                        }, +                    });, +                }, +            });, +            cb.handler(new ChannelInitializer<Channel>() {, +                @Override, +                protected void initChannel(Channel ch) throws Exception {, +                    ch.pipeline().addLast(new ChannelInboundHandlerAdapter() {, +                        private ByteBuf aggregator;, +                        @Override, +                        public void handlerAdded(ChannelHandlerContext ctx) {, +                            aggregator = ctx.alloc().buffer(expectedContent.readableBytes());, +                        }, +, +                        @Override, +                        public void channelRead(ChannelHandlerContext ctx, Object msg) {, +                            try {, +                                if (msg instanceof ByteBuf) {, +                                    aggregator.writeBytes((ByteBuf) msg);, +                                }, +                            } finally {, +                                ReferenceCountUtil.release(msg);, +                            }, +                        }, +, +                        @Override, +                        public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {, +                            // IOException is fine as it will also close the channel and may just be a connection reset., +                            if (!(cause instanceof IOException)) {, +                                clientReceived.set(cause);]