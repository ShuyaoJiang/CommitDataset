[+++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, +/*, + * Copyright 2012 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + *   http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the, + * License for the specific language governing permissions and limitations, + * under the License., + */, +package io.netty.buffer;, +, +import java.io.IOException;, +import java.io.InputStream;, +import java.io.OutputStream;, +import java.nio.ByteBuffer;, +import java.nio.channels.GatheringByteChannel;, +import java.nio.channels.ScatteringByteChannel;, +import java.nio.charset.Charset;, +, +, +/**, + * A skeletal implementation of a buffer., + */, +public abstract class AbstractByteBuf implements ByteBuf {, +, +    private int readerIndex;, +    private int writerIndex;, +    private int markedReaderIndex;, +    private int markedWriterIndex;, +, +    @Override, +    public int readerIndex() {, +        return readerIndex;, +    }, +, +    @Override, +    public void readerIndex(int readerIndex) {, +        if (readerIndex < 0 || readerIndex > writerIndex) {, +            throw new IndexOutOfBoundsException("Invalid readerIndex: ", +                    + readerIndex + " - Maximum is " + writerIndex);, +        }, +        this.readerIndex = readerIndex;, +    }, +, +    @Override, +    public int writerIndex() {, +        return writerIndex;, +    }, +, +    @Override, +    public void writerIndex(int writerIndex) {, +        if (writerIndex < readerIndex || writerIndex > capacity()) {, +            throw new IndexOutOfBoundsException("Invalid writerIndex: ", +                    + writerIndex + " - Maximum is " + readerIndex + " or " + capacity());, +        }, +        this.writerIndex = writerIndex;, +    }, +, +    @Override, +    public void setIndex(int readerIndex, int writerIndex) {, +        if (readerIndex < 0 || readerIndex > writerIndex || writerIndex > capacity()) {, +            throw new IndexOutOfBoundsException("Invalid indexes: readerIndex is ", +                    + readerIndex + ", writerIndex is ", +                    + writerIndex + ", capacity is " + capacity());, +        }, +        this.readerIndex = readerIndex;, +        this.writerIndex = writerIndex;, +    }, +, +    @Override, +    public void clear() {, +        readerIndex = writerIndex = 0;, +    }, +, +    @Override, +    public boolean readable() {, +        return writerIndex > readerIndex;, +    }, +, +    @Override, +    public boolean writable() {, +        return writableBytes() > 0;, +    }, +, +    @Override, +    public int readableBytes() {, +        return writerIndex - readerIndex;, +    }, +, +    @Override, +    public int writableBytes() {, +        return capacity() - writerIndex;, +    }]