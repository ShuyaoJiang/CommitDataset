[+++ b/buffer/src/main/java/io/netty/buffer/PoolArena.java, +    PooledByteBuf<T> allocate(PoolThreadCache cache, int reqCapacity, int maxCapacity) {, +        allocate(cache, buf, reqCapacity);, +    private void allocate(PoolThreadCache cache, PooledByteBuf<T> buf, final int reqCapacity) {, +        final int normCapacity = normalizeCapacity(reqCapacity);, +        if ((normCapacity & subpageOverflowMask) == 0) { // capacity < pageSize, +            if ((normCapacity & 0xFFFFFE00) == 0) { // < 512, +                tableIdx = normCapacity >>> 4;, +                int i = normCapacity >>> 10;, +                    if (!s.doNotDestroy || s.elemSize != normCapacity) {, +                        s.chunk.initBufWithSubpage(buf, handle, reqCapacity);, +        allocateNormal(buf, reqCapacity, normCapacity);, +    private synchronized void allocateNormal(PooledByteBuf<T> buf, int reqCapacity, int normCapacity) {, +        if (q050.allocate(buf, reqCapacity, normCapacity) || q025.allocate(buf, reqCapacity, normCapacity) ||, +            q000.allocate(buf, reqCapacity, normCapacity) || qInit.allocate(buf, reqCapacity, normCapacity) ||, +            q075.allocate(buf, reqCapacity, normCapacity)) {, +        long handle = c.allocate(normCapacity);, +        c.initBuf(buf, handle, reqCapacity);, +    private int normalizeCapacity(int reqCapacity) {, +        if (reqCapacity < 0 || reqCapacity > chunkSize) {, +            throw new IllegalArgumentException("capacity: " + reqCapacity + " (expected: 0-" + chunkSize + ')');, +        if ((reqCapacity & 0xFFFFFE00) != 0) { // >= 512, +            while (normalizedCapacity < reqCapacity) {, +        if ((reqCapacity & 15) == 0) {, +            return reqCapacity;, +        return (reqCapacity & ~15) + 16;, +++ b/buffer/src/main/java/io/netty/buffer/PoolArena.java, +    PooledByteBuf<T> allocate(PoolThreadCache cache, int reqCapacity, int maxCapacity) {, +        allocate(cache, buf, reqCapacity);, +    private void allocate(PoolThreadCache cache, PooledByteBuf<T> buf, final int reqCapacity) {, +        final int normCapacity = normalizeCapacity(reqCapacity);, +        if ((normCapacity & subpageOverflowMask) == 0) { // capacity < pageSize, +            if ((normCapacity & 0xFFFFFE00) == 0) { // < 512, +                tableIdx = normCapacity >>> 4;, +                int i = normCapacity >>> 10;, +                    if (!s.doNotDestroy || s.elemSize != normCapacity) {, +                        s.chunk.initBufWithSubpage(buf, handle, reqCapacity);, +        allocateNormal(buf, reqCapacity, normCapacity);, +    private synchronized void allocateNormal(PooledByteBuf<T> buf, int reqCapacity, int normCapacity) {, +        if (q050.allocate(buf, reqCapacity, normCapacity) || q025.allocate(buf, reqCapacity, normCapacity) ||, +            q000.allocate(buf, reqCapacity, normCapacity) || qInit.allocate(buf, reqCapacity, normCapacity) ||, +            q075.allocate(buf, reqCapacity, normCapacity)) {, +        long handle = c.allocate(normCapacity);, +        c.initBuf(buf, handle, reqCapacity);, +    private int normalizeCapacity(int reqCapacity) {, +        if (reqCapacity < 0 || reqCapacity > chunkSize) {, +            throw new IllegalArgumentException("capacity: " + reqCapacity + " (expected: 0-" + chunkSize + ')');, +        if ((reqCapacity & 0xFFFFFE00) != 0) { // >= 512, +            while (normalizedCapacity < reqCapacity) {, +        if ((reqCapacity & 15) == 0) {, +            return reqCapacity;, +        return (reqCapacity & ~15) + 16;, +++ b/buffer/src/main/java/io/netty/buffer/PoolChunk.java, +    long allocate(int normCapacity) {, +        if ((normCapacity & subpageOverflowMask) != 0) { // >= pageSize, +            return allocateRun(normCapacity, 1, firstVal);, +            return allocateSubpage(normCapacity, 1, firstVal);, +    private long allocateRun(int normCapacity, int curIdx, int val) {, +                long res = allocateRun(normCapacity, nextIdx, memoryMap[nextIdx]);, +            return allocateRunSimple(normCapacity, curIdx, val);, +    private long allocateRunSimple(int normCapacity, int curIdx, int val) {, +        if (normCapacity > runLength) {, +            if (normCapacity == runLength) {, +    private long allocateSubpage(int normCapacity, int curIdx, int val) {, +            long res = branchSubpage(normCapacity, nextIdx);, +            return branchSubpage(normCapacity, nextIdx ^ 1);, +            return allocateSubpageSimple(normCapacity, curIdx, val);, +            if (normCapacity != elemSize) {, +    private long allocateSubpageSimple(int normCapacity, int curIdx, int val) {, +                    subpage = new PoolSubpage<T>(this, curIdx, runOffset(val), pageSize, normCapacity);, +                    subpage.init(normCapacity);, +    private long branchSubpage(int normCapacity, int nextIdx) {, +            return allocateSubpage(normCapacity, nextIdx, nextVal);, +    void initBuf(PooledByteBuf<T> buf, long handle, int reqCapacity) {, +            buf.init(this, handle, memory, runOffset(val), reqCapacity, runLength(val));, +            initBufWithSubpage(buf, handle, bitmapIdx, reqCapacity);, +    void initBufWithSubpage(PooledByteBuf<T> buf, long handle, int reqCapacity) {, +        initBufWithSubpage(buf, handle, (int) (handle >>> 32), reqCapacity);, +    private void initBufWithSubpage(PooledByteBuf<T> buf, long handle, int bitmapIdx, int reqCapacity) {, +        assert reqCapacity <= subpage.elemSize;, +                runOffset(val) + (bitmapIdx & 0x3FFFFFFF) * subpage.elemSize, reqCapacity, subpage.elemSize);, +++ b/buffer/src/main/java/io/netty/buffer/PoolArena.java, +    PooledByteBuf<T> allocate(PoolThreadCache cache, int reqCapacity, int maxCapacity) {, +        allocate(cache, buf, reqCapacity);, +    private void allocate(PoolThreadCache cache, PooledByteBuf<T> buf, final int reqCapacity) {, +        final int normCapacity = normalizeCapacity(reqCapacity);, +        if ((normCapacity & subpageOverflowMask) == 0) { // capacity < pageSize, +            if ((normCapacity & 0xFFFFFE00) == 0) { // < 512, +                tableIdx = normCapacity >>> 4;, +                int i = normCapacity >>> 10;, +                    if (!s.doNotDestroy || s.elemSize != normCapacity) {, +                        s.chunk.initBufWithSubpage(buf, handle, reqCapacity);, +        allocateNormal(buf, reqCapacity, normCapacity);, +    private synchronized void allocateNormal(PooledByteBuf<T> buf, int reqCapacity, int normCapacity) {, +        if (q050.allocate(buf, reqCapacity, normCapacity) || q025.allocate(buf, reqCapacity, normCapacity) ||, +            q000.allocate(buf, reqCapacity, normCapacity) || qInit.allocate(buf, reqCapacity, normCapacity) ||, +            q075.allocate(buf, reqCapacity, normCapacity)) {, +        long handle = c.allocate(normCapacity);, +        c.initBuf(buf, handle, reqCapacity);, +    private int normalizeCapacity(int reqCapacity) {]