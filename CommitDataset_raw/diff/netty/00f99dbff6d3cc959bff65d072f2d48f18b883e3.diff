[+++ b/codec/src/main/java/io/netty/handler/codec/compression/JdkZlibDecoder.java, +            while (!inflater.needsInput()) {, +                if (length == 0) {, +                    // completely filled the buffer allocate a new one and start to fill it, +                    out.add(decompressed);, +                    decompressed = ctx.alloc().heapBuffer(maxOutputLength);, +                    outArray = decompressed.array();, +                    continue;, +                }, +                int outputLength = inflater.inflate(outArray, outIndex, length);, +++ b/codec/src/main/java/io/netty/handler/codec/compression/JdkZlibDecoder.java, +            while (!inflater.needsInput()) {, +                if (length == 0) {, +                    // completely filled the buffer allocate a new one and start to fill it, +                    out.add(decompressed);, +                    decompressed = ctx.alloc().heapBuffer(maxOutputLength);, +                    outArray = decompressed.array();, +                    continue;, +                }, +                int outputLength = inflater.inflate(outArray, outIndex, length);, +++ b/codec/src/test/java/io/netty/handler/codec/compression/ZlibTest.java, +import static org.junit.Assert.*;, +    private static final byte[] BYTES_SMALL = new byte[128];, +    private static final byte[] BYTES_LARGE = new byte[1024 * 1024];, +    static {, +        for (int i = 0; i < BYTES_SMALL.length; i++) {, +            BYTES_SMALL[i] = (byte) i;, +        }, +        for (int i = 0; i < BYTES_LARGE.length; i++) {, +            BYTES_LARGE[i] = (byte) i;, +        }, +    }, +, +    private void testCompress0(ZlibWrapper encoderWrapper, ZlibWrapper decoderWrapper, byte[] bytes) throws Exception {, +        ByteBuf data = Unpooled.wrappedBuffer(bytes);, +        byte[] decompressed = new byte[bytes.length];, +        int offset = 0;, +        for (;;) {, +            if (buf == null) {, +                break;, +            }, +            int length = buf.readableBytes();, +            buf.readBytes(decompressed, offset, length);, +            offset += length;, +            buf.release();, +            if (offset == decompressed.length) {, +                break;, +            }, +        }, +        assertArrayEquals(bytes, decompressed);, +    }, +, +    private void testCompressSmall(ZlibWrapper encoderWrapper, ZlibWrapper decoderWrapper) throws Exception {, +        testCompress0(encoderWrapper, decoderWrapper, BYTES_SMALL);, +    }, +, +    private void testCompressLarge(ZlibWrapper encoderWrapper, ZlibWrapper decoderWrapper) throws Exception {, +        testCompress0(encoderWrapper, decoderWrapper, BYTES_LARGE);, +        testCompressSmall(ZlibWrapper.ZLIB, ZlibWrapper.ZLIB);, +        testCompressLarge(ZlibWrapper.ZLIB, ZlibWrapper.ZLIB);, +        testCompressSmall(ZlibWrapper.NONE, ZlibWrapper.NONE);, +        testCompressLarge(ZlibWrapper.NONE, ZlibWrapper.NONE);, +        testCompressSmall(ZlibWrapper.GZIP, ZlibWrapper.GZIP);, +        testCompressLarge(ZlibWrapper.GZIP, ZlibWrapper.GZIP);, +        testCompressSmall(ZlibWrapper.NONE, ZlibWrapper.ZLIB_OR_NONE);, +        testCompressLarge(ZlibWrapper.NONE, ZlibWrapper.ZLIB_OR_NONE);, +        testCompressSmall(ZlibWrapper.ZLIB, ZlibWrapper.ZLIB_OR_NONE);, +        testCompressLarge(ZlibWrapper.GZIP, ZlibWrapper.ZLIB_OR_NONE);, +        testCompressSmall(ZlibWrapper.GZIP, ZlibWrapper.ZLIB_OR_NONE);, +        testCompressLarge(ZlibWrapper.GZIP, ZlibWrapper.ZLIB_OR_NONE);]