[+++ b/common/src/main/java/io/netty/util/HashedWheelTimer.java, +import io.netty.util.internal.MpscLinkedQueue;, +import java.util.Queue;, +import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;, +    private static final AtomicIntegerFieldUpdater<HashedWheelTimer> WORKER_STATE_UPDATER;, +    static {, +        AtomicIntegerFieldUpdater<HashedWheelTimer> workerStateUpdater =, +                PlatformDependent.newAtomicIntegerFieldUpdater(HashedWheelTimer.class, "workerState");, +        if (workerStateUpdater == null) {, +            workerStateUpdater = AtomicIntegerFieldUpdater.newUpdater(HashedWheelTimer.class, "workerState");, +        }, +        WORKER_STATE_UPDATER = workerStateUpdater;, +    }, +, +    private final Thread workerThread;, +    @SuppressWarnings({ "unused", "FieldMayBeFinal", "RedundantFieldInitialization" }), +    private volatile int workerState = WORKER_STATE_INIT; // 0 - init, 1 - started, 2 - shut down, +    private final long tickDuration;, +    private final HashedWheelBucket[] wheel;, +    private final int mask;, +    private final CountDownLatch startTimeInitialized = new CountDownLatch(1);, +    private final Queue<HashedWheelTimeout> timeouts = PlatformDependent.newMpscQueue();, +    private volatile long startTime;, +, +    private static HashedWheelBucket[] createWheel(int ticksPerWheel) {, +        HashedWheelBucket[] wheel = new HashedWheelBucket[ticksPerWheel];, +            wheel[i] = new HashedWheelBucket();, +        switch (WORKER_STATE_UPDATER.get(this)) {, +                if (WORKER_STATE_UPDATER.compareAndSet(this, WORKER_STATE_INIT, WORKER_STATE_STARTED)) {, +        if (!WORKER_STATE_UPDATER.compareAndSet(this, WORKER_STATE_STARTED, WORKER_STATE_SHUTDOWN)) {, +            WORKER_STATE_UPDATER.set(this, WORKER_STATE_SHUTDOWN);, +        return worker.unprocessedTimeouts();, +        start();, +        // Add the timeout to the timeout queue which will be processed on the next tick., +        // During processing all the queued HashedWheelTimeouts will be added to the correct HashedWheelBucket., +        HashedWheelTimeout timeout = new HashedWheelTimeout(this, task, deadline);, +        timeouts.add(timeout);, +        private final Set<Timeout> unprocessedTimeouts = new HashSet<Timeout>();, +        private long tick;, +                    transferTimeoutsToBuckets();, +                    HashedWheelBucket bucket =, +                            wheel[(int) (tick & mask)];, +                    bucket.expireTimeouts(deadline);, +                }, +            } while (WORKER_STATE_UPDATER.get(HashedWheelTimer.this) == WORKER_STATE_STARTED);, +, +            // Fill the unprocessedTimeouts so we can return them from stop() method., +            for (HashedWheelBucket bucket: wheel) {, +                bucket.clearTimeouts(unprocessedTimeouts);, +            }, +            for (;;) {, +                HashedWheelTimeout timeout = timeouts.poll();, +                if (timeout == null) {, +                    break;, +                }, +                unprocessedTimeouts.add(timeout);, +        private void transferTimeoutsToBuckets() {, +            // transfer only max. 100000 timeouts per tick to prevent a thread to stale the workerThread when it just, +            // adds new timeouts in a loop., +            for (int i = 0; i < 100000; i++) {, +                HashedWheelTimeout timeout = timeouts.poll();, +                if (timeout == null) {, +                    // all processed, +                    break;, +                }, +                long calculated = timeout.deadline / tickDuration;, +                long remainingRounds = (calculated - tick) / wheel.length;, +                timeout.remainingRounds = remainingRounds;, +                final long ticks = Math.max(calculated, tick); // Ensure we don't schedule for past., +                int stopIndex = (int) (ticks & mask);, +                HashedWheelBucket bucket = wheel[stopIndex];, +                bucket.addTimeout(timeout);, +                    if (WORKER_STATE_UPDATER.get(HashedWheelTimer.this) == WORKER_STATE_SHUTDOWN) {, +, +        public Set<Timeout> unprocessedTimeouts() {, +            return Collections.unmodifiableSet(unprocessedTimeouts);, +        }, +    private static final class HashedWheelTimeout extends MpscLinkedQueue.Node<Timeout>, +            implements Timeout {, +        private static final AtomicIntegerFieldUpdater<HashedWheelTimeout> STATE_UPDATER;, +        static {, +            AtomicIntegerFieldUpdater<HashedWheelTimeout> updater =, +                    PlatformDependent.newAtomicIntegerFieldUpdater(HashedWheelTimeout.class, "state");, +            if (updater == null) {, +                updater = AtomicIntegerFieldUpdater.newUpdater(HashedWheelTimeout.class, "state");, +            }, +            STATE_UPDATER = updater;, +        }, +, +        private final HashedWheelTimer timer;, +        private final long deadline;, +        @SuppressWarnings({"unused", "FieldMayBeFinal", "RedundantFieldInitialization" }), +        private volatile int state = ST_INIT;, +, +        // remainingRounds will be calculated and set by Worker.transferTimeoutsToBuckets() before the, +        // HashedWheelTimeout will be added to the correct HashedWheelBucket., +        long remainingRounds;, +, +        // This will be used to chain timeouts in HashedWheelTimerBucket via a double-linked-list., +        // As only the workerThread will act on it there is no need for synchronization / volatile.]