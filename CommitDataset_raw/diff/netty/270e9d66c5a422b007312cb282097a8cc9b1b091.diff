[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/QueryStringDecoder.java, +import java.nio.ByteBuffer;, +import java.nio.CharBuffer;, +import java.nio.charset.CharacterCodingException;, +import java.nio.charset.CharsetDecoder;, +import java.nio.charset.CoderResult;, +import static io.netty.util.internal.ObjectUtil.*;, +import static io.netty.util.internal.StringUtil.*;, +    private int pathEndIdx;, +        this.uri = checkNotNull(uri, "uri");, +        this.charset = checkNotNull(charset, "charset");, +        this.maxParams = checkPositive(maxParams, "maxParams");, +        // `-1` means that path end index will be initialized lazily, +        pathEndIdx = hasPath ? -1 : 0;, +        if (rawPath == null) {, +        String rawQuery = uri.getRawQuery();, +        this.uri = rawQuery == null? rawPath : rawPath + '?' + rawQuery;, +        this.charset = checkNotNull(charset, "charset");, +        this.maxParams = checkPositive(maxParams, "maxParams");, +        pathEndIdx = rawPath.length();, +    }, +    @Override, +    public String toString() {, +        return uri();, +            path = decodeComponent(uri, 0, pathEndIdx(), charset, true);, +            params = decodeParams(uri, pathEndIdx(), charset, maxParams);, +    private int pathEndIdx() {, +        if (pathEndIdx == -1) {, +            pathEndIdx = findPathEndIndex(uri);, +        return pathEndIdx;, +    private static Map<String, List<String>> decodeParams(String s, int from, Charset charset, int paramsLimit) {, +        int len = s.length();, +        if (from >= len) {, +            return Collections.emptyMap();, +        if (s.charAt(from) == '?') {, +            from++;, +        Map<String, List<String>> params = new LinkedHashMap<String, List<String>>();, +        int nameStart = from;, +        int valueStart = -1;, +        int i;, +        loop:, +        for (i = from; i < len; i++) {, +            switch (s.charAt(i)) {, +            case '=':, +                if (nameStart == i) {, +                    nameStart = i + 1;, +                } else if (valueStart < nameStart) {, +                    valueStart = i + 1;, +                }, +                break;, +            case '&':, +            case ';':, +                if (addParam(s, nameStart, valueStart, i, params, charset)) {, +                    paramsLimit--;, +                    if (paramsLimit == 0) {, +                        return params;, +                    }, +                }, +                nameStart = i + 1;, +                break;, +            case '#':, +                break loop;, +            default:, +                // continue, +            }, +        }, +        addParam(s, nameStart, valueStart, i, params, charset);, +        return params;, +    private static boolean addParam(String s, int nameStart, int valueStart, int valueEnd,, +                                    Map<String, List<String>> params, Charset charset) {, +        if (nameStart >= valueEnd) {, +        if (valueStart <= nameStart) {, +            valueStart = valueEnd + 1;, +        }, +        String name = decodeComponent(s, nameStart, valueStart - 1, charset, false);, +        String value = decodeComponent(s, valueStart, valueEnd, charset, false);, +     *   {@link URLDecoder#decode(String, String)}, +        return decodeComponent(s, 0, s.length(), charset, false);, +, +    private static String decodeComponent(String s, int from, int toExcluded, Charset charset, boolean isPath) {, +        int len = toExcluded - from;, +        if (len <= 0) {, +            return EMPTY_STRING;, +        int firstEscaped = -1;, +        for (int i = from; i < toExcluded; i++) {, +            if (c == '%' || c == '+' && !isPath) {, +                firstEscaped = i;, +        if (firstEscaped == -1) {, +            return s.substring(from, toExcluded);, +        }, +, +        CharsetDecoder decoder = CharsetUtil.decoder(charset);, +, +        // Each encoded byte takes 3 characters (e.g. "%20"), +        int decodedCapacity = (toExcluded - firstEscaped) / 3;, +        ByteBuffer byteBuf = ByteBuffer.allocate(decodedCapacity);, +        CharBuffer charBuf = CharBuffer.allocate(decodedCapacity);, +, +        StringBuilder strBuf = new StringBuilder(len);, +        strBuf.append(s, from, firstEscaped);]