[+++ b/common/src/main/java/io/netty/util/HashedWheelTimer.java, +import java.util.concurrent.CountDownLatch;, +    final CountDownLatch startTimeInitialized = new CountDownLatch(1);, +    volatile long startTime;, +    volatile long tick;, +, +        // Wait until the startTime is initialized by the worker., +        while (startTime == 0) {, +            try {, +                startTimeInitialized.await();, +            } catch (InterruptedException ignore) {, +                // Ignore - it will be ready very soon., +            }, +        }, +        start();, +        long deadline = System.nanoTime() + unit.toNanos(delay) - startTime;, +        HashedWheelTimeout timeout;, +            timeout = new HashedWheelTimeout(task, deadline);, +            wheel[timeout.stopIndex].add(timeout);, +, +        return timeout;, +            // Initialize the startTime., +            if (startTime == 0) {, +                // We use 0 as an indicator for the uninitialized value here, so make sure it's not 0 when initialized., +                startTime = 1;, +            }, +            // Notify the other threads waiting for the initialization at start()., +            startTimeInitialized.countDown();, +, +            List<HashedWheelTimeout> expiredTimeouts = new ArrayList<HashedWheelTimeout>();, +, +            do {, +            } while (workerState.get() == WORKER_STATE_STARTED);, +                fetchExpiredTimeouts(expiredTimeouts, wheel[(int) (tick & mask)].iterator(), deadline);, +                // Note that the tick is updated only while the writer lock is held,, +                // so that newTimeout() and consequently new HashedWheelTimeout() never see an old value, +                // while the reader lock is held., +                tick ++;, +                        // The timeout was placed into a wrong slot. This should never happen., +                        throw new Error(String.format(, +                                "timeout.deadline (%d) > deadline (%d)", timeout.deadline, deadline));, +            long deadline = tickDuration * (tick + 1);, +                final long currentTime = System.nanoTime() - startTime;, +        final int stopIndex;, +, +            final long ticks = Math.max(deadline / tickDuration, tick); // Ensure we don't schedule for past., +            stopIndex = (int) (ticks & mask);, +            remainingRounds = ticks / wheel.length;, +            long remaining = deadline - currentTime + startTime;, +                buf.append(" ns later");, +                buf.append(" ns ago");, +                buf.append("now");, +            buf.append(", task: ");, +            buf.append(task());, +]