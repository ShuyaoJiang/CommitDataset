[+++ b/handler/src/main/java/io/netty/handler/ssl/ReferenceCountedOpenSslEngine.java, +                    if (handshakeException != null) {, +                        //, +                        // unwrap(...) will then ensure we propagate the handshake error back to the user., +                        return newResult(NEED_UNWRAP, 0, bytesProduced);, +                        } else if (sslError == SSL.SSL_ERROR_WANT_X509_LOOKUP ||, +                                sslError == SSL.SSL_ERROR_WANT_CERTIFICATE_VERIFY) {, +                                } else if (sslError == SSL.SSL_ERROR_WANT_X509_LOOKUP, +                                        || sslError == SSL.SSL_ERROR_WANT_CERTIFICATE_VERIFY) {, +                try {, +    private SSLEngineResult.HandshakeStatus handshakeException() throws SSLException {, +, +        SSLHandshakeException exception = handshakeException;, +    private SSLEngineResult.HandshakeStatus handshake() throws SSLException {, +        if (needTask) {, +            return NEED_TASK;, +        }, +        if (handshakeState == HandshakeState.FINISHED) {, +            return FINISHED;, +        }, +, +        checkEngineClosed(HANDSHAKE_ENGINE_CLOSED);, +, +        if (handshakeException != null) {, +            // If we there was an handshake exception we need to call SSL.doHandshake(...) again as it may produce, +            // some alert or advance the internal state machine. Also clear the error queue as this call may put, +            // something on the queue., +            SSL.doHandshake(ssl);, +            SSL.clearError();, +            return handshakeException();, +        }, +, +            if (sslError == SSL.SSL_ERROR_WANT_X509_LOOKUP || sslError == SSL.SSL_ERROR_WANT_CERTIFICATE_VERIFY) {, +            // Check if we have a pending exception that was created during the handshake and if so throw it after, +            // shutdown the connection., +            if (handshakeException != null) {, +                return handshakeException();, +            }, +, +++ b/handler/src/main/java/io/netty/handler/ssl/ReferenceCountedOpenSslEngine.java, +                    if (handshakeException != null) {, +                        //, +                        // unwrap(...) will then ensure we propagate the handshake error back to the user., +                        return newResult(NEED_UNWRAP, 0, bytesProduced);, +                        } else if (sslError == SSL.SSL_ERROR_WANT_X509_LOOKUP ||, +                                sslError == SSL.SSL_ERROR_WANT_CERTIFICATE_VERIFY) {, +                                } else if (sslError == SSL.SSL_ERROR_WANT_X509_LOOKUP, +                                        || sslError == SSL.SSL_ERROR_WANT_CERTIFICATE_VERIFY) {, +                try {, +    private SSLEngineResult.HandshakeStatus handshakeException() throws SSLException {, +, +        SSLHandshakeException exception = handshakeException;, +    private SSLEngineResult.HandshakeStatus handshake() throws SSLException {, +        if (needTask) {, +            return NEED_TASK;, +        }, +        if (handshakeState == HandshakeState.FINISHED) {, +            return FINISHED;, +        }, +, +        checkEngineClosed(HANDSHAKE_ENGINE_CLOSED);, +, +        if (handshakeException != null) {, +            // If we there was an handshake exception we need to call SSL.doHandshake(...) again as it may produce, +            // some alert or advance the internal state machine. Also clear the error queue as this call may put, +            // something on the queue., +            SSL.doHandshake(ssl);, +            SSL.clearError();, +            return handshakeException();, +        }, +, +            if (sslError == SSL.SSL_ERROR_WANT_X509_LOOKUP || sslError == SSL.SSL_ERROR_WANT_CERTIFICATE_VERIFY) {, +            // Check if we have a pending exception that was created during the handshake and if so throw it after, +            // shutdown the connection., +            if (handshakeException != null) {, +                return handshakeException();, +            }, +, +++ b/handler/src/main/java/io/netty/handler/ssl/SslHandler.java, +                // Check if did not produce any bytes and if so break out of the loop, but only if we did not process, +                // a task as last action. It's fine to not produce any data as part of executing a task., +]