[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/HttpConversionUtil.java, +import io.netty.handler.codec.UnsupportedValueConverter;, +import java.util.List;, +import java.util.Set;, +import static io.netty.util.ByteProcessor.FIND_COMMA;, +    private static CharSequenceMap<AsciiString> toLowercaseMap(List<String> values) {, +        UnsupportedValueConverter<AsciiString> valueConverter = UnsupportedValueConverter.<AsciiString>instance();, +        CharSequenceMap<AsciiString> result =, +            new CharSequenceMap<AsciiString>(true, valueConverter, values.size());, +, +        // we iterate because the underlying list is probably a linked list, +        for (CharSequence value : values) {, +            AsciiString lowerCased = AsciiString.of(value).toLowerCase();, +            try {, +                int index = lowerCased.forEachByte(FIND_COMMA);, +                if (index != -1) {, +                    int start = 0;, +                    do {, +                        result.add(lowerCased.subSequence(start, index, false).trim(), EMPTY_STRING);, +                        start = index + 1;, +                    } while (start < lowerCased.length() &&, +                             (index = lowerCased.forEachByte(start, value.length() - start, FIND_COMMA)) != -1);, +                    result.add(lowerCased.subSequence(start, lowerCased.length(), false).trim(), EMPTY_STRING);, +                } else {, +                    result.add(lowerCased.trim(), EMPTY_STRING);, +                }, +            } catch (Exception e) {, +                // This is not expect to happen because FIND_COMMA never throws but must be caught, +                // because of the ByteProcessor interface., +                throw new IllegalStateException(e);, +            }, +        }, +        return result;, +    }, +, +            new CharSequenceMap<AsciiString>();, +        CharSequenceMap<AsciiString> connectionBlacklist =, +            toLowercaseMap(inHeaders.getAll(HttpHeaderNames.CONNECTION));, +            if (!HTTP_TO_HTTP2_HEADER_BLACKLIST.contains(aName) &&, +                !connectionBlacklist.contains(aName)) {, +                if (aName.contentEqualsIgnoreCase(HttpHeaderNames.TE)) {, +                    if (AsciiString.containsIgnoreCase(entry.getValue(), HttpHeaderValues.TRAILERS)) {, +                        out.add(HttpHeaderNames.TE, HttpHeaderValues.TRAILERS);, +                } else if (aName.contentEqualsIgnoreCase(HttpHeaderNames.COOKIE)) {, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/HttpConversionUtil.java, +import io.netty.handler.codec.UnsupportedValueConverter;, +import java.util.List;, +import java.util.Set;, +import static io.netty.util.ByteProcessor.FIND_COMMA;, +    private static CharSequenceMap<AsciiString> toLowercaseMap(List<String> values) {, +        UnsupportedValueConverter<AsciiString> valueConverter = UnsupportedValueConverter.<AsciiString>instance();, +        CharSequenceMap<AsciiString> result =, +            new CharSequenceMap<AsciiString>(true, valueConverter, values.size());, +, +        // we iterate because the underlying list is probably a linked list, +        for (CharSequence value : values) {, +            AsciiString lowerCased = AsciiString.of(value).toLowerCase();, +            try {, +                int index = lowerCased.forEachByte(FIND_COMMA);, +                if (index != -1) {, +                    int start = 0;, +                    do {, +                        result.add(lowerCased.subSequence(start, index, false).trim(), EMPTY_STRING);, +                        start = index + 1;, +                    } while (start < lowerCased.length() &&, +                             (index = lowerCased.forEachByte(start, value.length() - start, FIND_COMMA)) != -1);, +                    result.add(lowerCased.subSequence(start, lowerCased.length(), false).trim(), EMPTY_STRING);, +                } else {, +                    result.add(lowerCased.trim(), EMPTY_STRING);, +                }, +            } catch (Exception e) {, +                // This is not expect to happen because FIND_COMMA never throws but must be caught, +                // because of the ByteProcessor interface., +                throw new IllegalStateException(e);, +            }, +        }, +        return result;, +    }, +, +            new CharSequenceMap<AsciiString>();, +        CharSequenceMap<AsciiString> connectionBlacklist =, +            toLowercaseMap(inHeaders.getAll(HttpHeaderNames.CONNECTION));, +            if (!HTTP_TO_HTTP2_HEADER_BLACKLIST.contains(aName) &&, +                !connectionBlacklist.contains(aName)) {, +                if (aName.contentEqualsIgnoreCase(HttpHeaderNames.TE)) {, +                    if (AsciiString.containsIgnoreCase(entry.getValue(), HttpHeaderValues.TRAILERS)) {, +                        out.add(HttpHeaderNames.TE, HttpHeaderValues.TRAILERS);, +                } else if (aName.contentEqualsIgnoreCase(HttpHeaderNames.COOKIE)) {, +++ b/codec-http2/src/test/java/io/netty/handler/codec/http2/HttpConversionUtilTest.java, +import io.netty.handler.codec.http.DefaultHttpHeaders;, +import io.netty.handler.codec.http.HttpHeaders;, +import io.netty.handler.codec.http.HttpHeaderNames;, +import io.netty.handler.codec.http.HttpHeaderValues;, +, +    @Test, +    public void stripTEHeaders() {, +        HttpHeaders inHeaders = new DefaultHttpHeaders();, +        inHeaders.add(HttpHeaderNames.TE, HttpHeaderValues.GZIP);, +        Http2Headers out = new DefaultHttp2Headers();, +        HttpConversionUtil.toHttp2Headers(inHeaders, out);]