[+++ b/handler/src/main/java/io/netty/handler/ssl/SslHandler.java, +    private final int maxPacketBufferSize;, +    /**, +     * Set by wrap*() methods when something is produced., +     * {@link #channelReadComplete(ChannelHandlerContext)} will check this flag, clear it, and call ctx.flush()., +     */, +    private boolean needsFlush;, +, +        maxPacketBufferSize = engine.getSession().getPacketBufferSize();, +    @Deprecated, +        wrap(ctx, false);, +        ctx.flush();, +    private void wrap(ChannelHandlerContext ctx, boolean inUnwrap) throws SSLException {, +                    out = ctx.alloc().buffer(maxPacketBufferSize);, +, +                            finishWrap(ctx, out, promise, inUnwrap);, +                            out = null;, +            finishWrap(ctx, out, promise, inUnwrap);, +, +    private void finishWrap(ChannelHandlerContext ctx, ByteBuf out, ChannelPromise promise, boolean inUnwrap) {, +            if (out.isReadable()) {, +                if (promise != null) {, +                    ctx.write(out, promise);, +                } else {, +                    ctx.write(out);, +                }, +                if (inUnwrap) {, +                    needsFlush = true;, +                }, +            } else {, +        } else if (promise != null) {, +            ctx.write(Unpooled.EMPTY_BUFFER, promise);, +            if (inUnwrap) {, +                needsFlush = true;, +            }, +    private void wrapNonAppData(ChannelHandlerContext ctx, boolean inUnwrap) throws SSLException {, +                    out = ctx.alloc().buffer(maxPacketBufferSize);, +                    ctx.write(out);, +                    if (inUnwrap) {, +                        needsFlush = true;, +                    }, +    private SSLEngineResult wrap(SSLEngine engine, ByteBuf in, ByteBuf out) throws SSLException {, +, +            switch (result.getStatus()) {, +                case BUFFER_OVERFLOW:, +                    out.ensureWritable(maxPacketBufferSize);, +                    break;, +                default:, +        return getEncryptedPacketLength(buffer, buffer.readerIndex()) != -1;, +    private static int getEncryptedPacketLength(ByteBuf buffer, int offset) {, +        switch (buffer.getUnsignedByte(offset)) {, +            int majorVersion = buffer.getUnsignedByte(offset + 1);, +                packetLength = buffer.getUnsignedShort(offset + 3) + 5;, +            int headerLength = (buffer.getUnsignedByte(offset) & 0x80) != 0 ? 2 : 3;, +            int majorVersion = buffer.getUnsignedByte(offset + headerLength + 1);, +                    packetLength = (buffer.getShort(offset) & 0x7FFF) + 2;, +                    packetLength = (buffer.getShort(offset) & 0x3FFF) + 3;, +        final int startOffset = in.readerIndex();, +        final int endOffset = in.writerIndex();, +        int offset = startOffset;, +        // If we calculated the length of the current SSL record before, use that information., +        if (packetLength > 0) {, +            if (endOffset - startOffset < packetLength) {, +            } else {, +                offset += packetLength;, +                packetLength = 0;, +            }, +        boolean nonSslRecord = false;, +, +        for (;;) {, +            final int readableBytes = endOffset - offset;, +            if (readableBytes < 5) {, +                break;, +            }, +, +            final int packetLength = getEncryptedPacketLength(in, offset);, +                nonSslRecord = true;, +                break;, +            if (packetLength > readableBytes) {, +                this.packetLength = packetLength;, +                break;, +            offset += packetLength;, +        }, +, +        final int length = offset - startOffset;, +        if (length > 0) {, +            // The buffer contains one or more full SSL records., +            in.skipBytes(length);, +            ByteBuffer buffer = in.nioBuffer(startOffset, length);, +        if (nonSslRecord) {, +            // Not an SSL/TLS packet, +            NotSslRecordException e = new NotSslRecordException(, +                    "not an SSL/TLS record: " + ByteBufUtil.hexDump(in));, +            in.skipBytes(in.readableBytes());, +            ctx.fireExceptionCaught(e);, +            setHandshakeFailure(e);, +        }, +    }, +, +    @Override]