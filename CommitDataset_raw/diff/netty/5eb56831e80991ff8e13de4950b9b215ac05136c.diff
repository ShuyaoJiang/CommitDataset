[+++ b/src/main/java/org/jboss/netty/buffer/ChannelBuffers.java, +import java.util.ArrayList;, +import java.util.List;, +            // Get the list of the component, while guessing the byte order., +            final List<ChannelBuffer> components = new ArrayList<ChannelBuffer>(arrays.length);, +            for (byte[] a: arrays) {, +                if (a == null) {, +                    break;, +                if (a.length > 0) {, +                    components.add(wrappedBuffer(endianness, a));, +                }, +            }, +            return compositeBuffer(endianness, components);, +    private static ChannelBuffer compositeBuffer(, +            ByteOrder endianness, List<ChannelBuffer> components) {, +        switch (components.size()) {, +        case 0:, +            return EMPTY_BUFFER;, +        case 1:, +            return components.get(0);, +        default:, +            return new CompositeChannelBuffer(endianness, components);, +        }, +    }, +, +            ByteOrder order = null;, +            final List<ChannelBuffer> components = new ArrayList<ChannelBuffer>(buffers.length);, +            for (ChannelBuffer c: buffers) {, +                if (c == null) {, +                    break;, +                }, +                if (c.readable()) {, +                    if (order != null) {, +                        if (!order.equals(c.order())) {, +                            throw new IllegalArgumentException(, +                                    "inconsistent byte order");, +                        }, +                    } else {, +                        order = c.order();, +                    }, +                    if (c instanceof CompositeChannelBuffer) {, +                        // Expand nested composition., +                        components.addAll(, +                                ((CompositeChannelBuffer) c).decompose(, +                                        c.readerIndex(), c.readableBytes()));, +                    } else {, +                        // An ordinary buffer (non-composite), +                        components.add(c.slice());, +            return compositeBuffer(order, components);, +        }, +            ByteOrder order = null;, +            final List<ChannelBuffer> components = new ArrayList<ChannelBuffer>(buffers.length);, +            for (ByteBuffer b: buffers) {, +                if (b == null) {, +                    break;, +                if (b.hasRemaining()) {, +                    if (order != null) {, +                        if (!order.equals(b.order())) {, +                            throw new IllegalArgumentException(, +                                    "inconsistent byte order");, +                        }, +                    } else {, +                        order = b.order();, +                    }, +                    components.add(wrappedBuffer(b));, +                }, +            }, +            return compositeBuffer(order, components);, +++ b/src/main/java/org/jboss/netty/buffer/ChannelBuffers.java, +import java.util.ArrayList;, +import java.util.List;, +            // Get the list of the component, while guessing the byte order., +            final List<ChannelBuffer> components = new ArrayList<ChannelBuffer>(arrays.length);, +            for (byte[] a: arrays) {, +                if (a == null) {, +                    break;, +                if (a.length > 0) {, +                    components.add(wrappedBuffer(endianness, a));, +                }, +            }, +            return compositeBuffer(endianness, components);, +    private static ChannelBuffer compositeBuffer(, +            ByteOrder endianness, List<ChannelBuffer> components) {, +        switch (components.size()) {, +        case 0:, +            return EMPTY_BUFFER;, +        case 1:, +            return components.get(0);, +        default:, +            return new CompositeChannelBuffer(endianness, components);, +        }, +    }, +, +            ByteOrder order = null;, +            final List<ChannelBuffer> components = new ArrayList<ChannelBuffer>(buffers.length);, +            for (ChannelBuffer c: buffers) {, +                if (c == null) {, +                    break;, +                }, +                if (c.readable()) {]