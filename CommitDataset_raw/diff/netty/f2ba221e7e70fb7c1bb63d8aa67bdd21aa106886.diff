[+++ b/testsuite/src/main/java/io/netty/testsuite/transport/AbstractTestsuiteTest.java, +                    Method m = getClass().getMethod(, +++ b/testsuite/src/main/java/io/netty/testsuite/transport/AbstractTestsuiteTest.java, +                    Method m = getClass().getMethod(, +++ b/testsuite/src/main/java/io/netty/testsuite/transport/socket/SocketConnectionAttemptTest.java, +import io.netty.channel.Channel;, +import io.netty.channel.ChannelHandler;, +import io.netty.testsuite.util.TestUtils;, +import io.netty.util.NetUtil;, +import io.netty.util.concurrent.GlobalEventExecutor;, +import io.netty.util.concurrent.Promise;, +    @Test(timeout = 30000), +    public void testConnectRefused() throws Throwable {, +        run();, +    }, +, +    public void testConnectRefused(Bootstrap cb) throws Throwable {, +        testConnectRefused0(cb, false);, +    }, +, +    @Test(timeout = 30000), +    public void testConnectRefusedHalfClosure() throws Throwable {, +        run();, +    }, +, +    public void testConnectRefusedHalfClosure(Bootstrap cb) throws Throwable {, +        testConnectRefused0(cb, true);, +    }, +, +    private static void testConnectRefused0(Bootstrap cb, boolean halfClosure) throws Throwable {, +        final Promise<Error> errorPromise = GlobalEventExecutor.INSTANCE.newPromise();, +        ChannelHandler handler = new ChannelInboundHandlerAdapter() {, +            @Override, +            public void channelActive(ChannelHandlerContext ctx) throws Exception {, +                Channel channel = ctx.channel();, +                errorPromise.setFailure(new AssertionError("should have never been called"));, +            }, +        };, +, +        cb.handler(handler);, +        cb.option(ChannelOption.ALLOW_HALF_CLOSURE, halfClosure);, +        ChannelFuture future = cb.connect(NetUtil.LOCALHOST, TestUtils.getFreePort()).awaitUninterruptibly();, +        assertTrue(future.cause() instanceof ConnectException);, +        assertNull(errorPromise.cause());, +    }, +, +++ b/testsuite/src/main/java/io/netty/testsuite/transport/AbstractTestsuiteTest.java, +                    Method m = getClass().getMethod(, +++ b/testsuite/src/main/java/io/netty/testsuite/transport/socket/SocketConnectionAttemptTest.java, +import io.netty.channel.Channel;, +import io.netty.channel.ChannelHandler;, +import io.netty.testsuite.util.TestUtils;, +import io.netty.util.NetUtil;, +import io.netty.util.concurrent.GlobalEventExecutor;, +import io.netty.util.concurrent.Promise;, +    @Test(timeout = 30000), +    public void testConnectRefused() throws Throwable {, +        run();, +    }, +, +    public void testConnectRefused(Bootstrap cb) throws Throwable {, +        testConnectRefused0(cb, false);, +    }, +, +    @Test(timeout = 30000), +    public void testConnectRefusedHalfClosure() throws Throwable {, +        run();, +    }, +, +    public void testConnectRefusedHalfClosure(Bootstrap cb) throws Throwable {, +        testConnectRefused0(cb, true);, +    }, +, +    private static void testConnectRefused0(Bootstrap cb, boolean halfClosure) throws Throwable {, +        final Promise<Error> errorPromise = GlobalEventExecutor.INSTANCE.newPromise();, +        ChannelHandler handler = new ChannelInboundHandlerAdapter() {, +            @Override, +            public void channelActive(ChannelHandlerContext ctx) throws Exception {, +                Channel channel = ctx.channel();, +                errorPromise.setFailure(new AssertionError("should have never been called"));, +            }, +        };, +, +        cb.handler(handler);, +        cb.option(ChannelOption.ALLOW_HALF_CLOSURE, halfClosure);, +        ChannelFuture future = cb.connect(NetUtil.LOCALHOST, TestUtils.getFreePort()).awaitUninterruptibly();, +        assertTrue(future.cause() instanceof ConnectException);, +        assertNull(errorPromise.cause());, +    }, +, +++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollEventLoop.java, +                    // Don't change the ordering of processing EPOLLOUT | EPOLLRDHUP / EPOLLIN if you're not 100%, +                    // sure about it!, +                    // Re-ordering can easily introduce bugs and bad side-effects, as we found out painfully in the, +                    // past., +                    // First check for EPOLLOUT as we may need to fail the connect ChannelPromise before try, +                    // to read from the file descriptor., +                    // See https://github.com/netty/netty/issues/3785, +                    if ((ev & Native.EPOLLOUT) != 0 && ch.isOpen()) {, +                        // Force flush of data as the epoll is writable again]