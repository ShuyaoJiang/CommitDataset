[+++ b/common/src/main/java/io/netty/util/internal/MacAddressUtil.java, +/*, + * Copyright 2016 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + *   http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the, + * License for the specific language governing permissions and limitations, + * under the License., + */, +, +package io.netty.util.internal;, +, +import java.net.InetAddress;, +import java.net.NetworkInterface;, +import java.net.SocketException;, +import java.util.Arrays;, +import java.util.Enumeration;, +import java.util.LinkedHashMap;, +import java.util.Map;, +import java.util.Map.Entry;, +, +import io.netty.util.NetUtil;, +import io.netty.util.internal.logging.InternalLogger;, +import io.netty.util.internal.logging.InternalLoggerFactory;, +, +public final class MacAddressUtil {, +, +    /**, +     * Length of a valid MAC address., +     */, +    public static final int MAC_ADDRESS_LENGTH = 8;, +, +    private static final byte[] NOT_FOUND = { -1 };, +, +    private static final InternalLogger logger = InternalLoggerFactory.getInstance(MacAddressUtil.class);, +, +    /**, +     * Obtains the best MAC address found on local network interfaces., +     * Generally speaking, an active network interface used on public, +     * networks is better than a local network interface., +     *, +     * @return byte array containing a MAC. null if no MAC can be found., +     */, +    public static byte[] bestAvailableMac() {, +        // Find the best MAC address available., +        byte[] bestMacAddr = NOT_FOUND;, +        InetAddress bestInetAddr = NetUtil.LOCALHOST4;, +, +        // Retrieve the list of available network interfaces., +        Map<NetworkInterface, InetAddress> ifaces = new LinkedHashMap<NetworkInterface, InetAddress>();, +        try {, +            for (Enumeration<NetworkInterface> i = NetworkInterface.getNetworkInterfaces(); i.hasMoreElements();) {, +                NetworkInterface iface = i.nextElement();, +                // Use the interface with proper INET addresses only., +                Enumeration<InetAddress> addrs = iface.getInetAddresses();, +                if (addrs.hasMoreElements()) {, +                    InetAddress a = addrs.nextElement();, +                    if (!a.isLoopbackAddress()) {, +                        ifaces.put(iface, a);, +                    }, +                }, +            }, +        } catch (SocketException e) {, +            logger.warn("Failed to retrieve the list of available network interfaces", e);, +        }, +, +        for (Entry<NetworkInterface, InetAddress> entry: ifaces.entrySet()) {, +            NetworkInterface iface = entry.getKey();, +            InetAddress inetAddr = entry.getValue();, +            if (iface.isVirtual()) {, +                continue;, +            }, +, +            byte[] macAddr;, +            try {, +                macAddr = iface.getHardwareAddress();, +            } catch (SocketException e) {, +                logger.debug("Failed to get the hardware address of a network interface: {}", iface, e);, +                continue;, +            }, +, +            boolean replace = false;, +            int res = compareAddresses(bestMacAddr, macAddr);, +            if (res < 0) {, +                // Found a better MAC address., +                replace = true;, +            } else if (res == 0) {, +                // Two MAC addresses are of pretty much same quality., +                res = compareAddresses(bestInetAddr, inetAddr);, +                if (res < 0) {, +                    // Found a MAC address with better INET address., +                    replace = true;, +                } else if (res == 0) {]