[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/UniformStreamByteDistributor.java, +/*, + * Copyright 2015 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License, version 2.0 (the, + * "License"); you may not use this file except in compliance with the License. You may obtain a, + * copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software distributed under the License, + * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express, + * or implied. See the License for the specific language governing permissions and limitations under, + * the License., + */, +package io.netty.handler.codec.http2;, +, +import static io.netty.handler.codec.http2.Http2Error.INTERNAL_ERROR;, +import static io.netty.handler.codec.http2.Http2Exception.connectionError;, +import static io.netty.util.internal.ObjectUtil.checkNotNull;, +import static java.lang.Math.max;, +import static java.lang.Math.min;, +, +import java.util.ArrayDeque;, +import java.util.Deque;, +, +/**, + * A {@link StreamByteDistributor} that ignores stream priority and uniformly allocates bytes to all, + * streams. This class uses a minimum chunk size that will be allocated to each stream. While, + * fewer streams may be written to in each call to {@link #distribute(int, Writer)}, doing this, + * should improve the goodput on each written stream., + */, +public final class UniformStreamByteDistributor implements StreamByteDistributor {, +    static final int DEFAULT_MIN_ALLOCATION_CHUNK = 1024;, +, +    private final Http2Connection.PropertyKey stateKey;, +    private final Deque<State> queue = new ArrayDeque<State>(4);, +    private Deque<State> emptyFrameQueue;, +, +    /**, +     * The minimum number of bytes that we will attempt to allocate to a stream. This is to, +     * help improve goodput on a per-stream basis., +     */, +    private int minAllocationChunk = DEFAULT_MIN_ALLOCATION_CHUNK;, +    private long totalStreamableBytes;, +, +    public UniformStreamByteDistributor(Http2Connection connection) {, +        checkNotNull(connection, "connection");, +, +        // Add a state for the connection., +        stateKey = connection.newKey();, +        Http2Stream connectionStream = connection.connectionStream();, +        connectionStream.setProperty(stateKey, new State(connectionStream));, +, +        // Register for notification of new streams., +        connection.addListener(new Http2ConnectionAdapter() {, +            @Override, +            public void onStreamAdded(Http2Stream stream) {, +                stream.setProperty(stateKey, new State(stream));, +            }, +, +            @Override, +            public void onStreamClosed(Http2Stream stream) {, +                state(stream).close();, +            }, +        });, +    }, +, +    /**, +     * Sets the minimum allocation chunk that will be allocated to each stream. Defaults to 1KiB., +     *, +     * @param minAllocationChunk the minimum number of bytes that will be allocated to each stream., +     * Must be > 0., +     */, +    public void minAllocationChunk(int minAllocationChunk) {, +        if (minAllocationChunk <= 0) {, +            throw new IllegalArgumentException("minAllocationChunk must be > 0");, +        }, +        this.minAllocationChunk = minAllocationChunk;, +    }, +, +    @Override, +    public void updateStreamableBytes(StreamState streamState) {, +        State state = state(streamState.stream());, +        state.updateStreamableBytes(streamState.streamableBytes(), streamState.hasFrame());, +    }, +, +    @Override, +    public boolean distribute(int maxBytes, Writer writer) throws Http2Exception {, +        checkNotNull(writer, "writer");, +, +        // First, write out any empty frames., +        if (emptyFrameQueue != null) {, +            while (!emptyFrameQueue.isEmpty()) {, +                State state = emptyFrameQueue.remove();, +                state.enqueued = false;, +                if (state.streamableBytes > 0) {, +                    // Bytes have been added since it was queued. Add it to the regular queue., +                    state.addToQueue();, +                } else {]