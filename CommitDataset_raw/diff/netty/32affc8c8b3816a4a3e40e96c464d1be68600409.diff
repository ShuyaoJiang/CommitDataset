[+++ b/common/src/main/java/io/netty/util/Attribute.java, + * An attribute which allows to store a value reference. It may be updated atomically and so is thread-safe., +, +    /**, +     * Returns the key of this attribute., +     */, +    AttributeKey<T> key();, +, +     * Removes this attribute from the {@link AttributeMap} and returns the old value..  Subsequent {@link #get()}, +     * calls will return @{code null}., +     */, +    T getAndRemove();, +, +    /**, +     * Removes this attribute from the {@link AttributeMap}.  Subsequent {@link #get()} calls will return @{code null}., +++ b/common/src/main/java/io/netty/util/Attribute.java, + * An attribute which allows to store a value reference. It may be updated atomically and so is thread-safe., +, +    /**, +     * Returns the key of this attribute., +     */, +    AttributeKey<T> key();, +, +     * Removes this attribute from the {@link AttributeMap} and returns the old value..  Subsequent {@link #get()}, +     * calls will return @{code null}., +     */, +    T getAndRemove();, +, +    /**, +     * Removes this attribute from the {@link AttributeMap}.  Subsequent {@link #get()} calls will return @{code null}., +++ b/common/src/main/java/io/netty/util/DefaultAttributeMap.java, +import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;, +    @SuppressWarnings("rawtypes"), +    private static final AtomicReferenceFieldUpdater<DefaultAttributeMap, Map> updater =, +            AtomicReferenceFieldUpdater.newUpdater(DefaultAttributeMap.class, Map.class, "map");, +, +    // Initialize lazily to reduce memory consumption; updated by AtomicReferenceFieldUpdater above., +    @SuppressWarnings("UnusedDeclaration"), +    private volatile Map<AttributeKey<?>, Attribute<?>> map;, +    public <T> Attribute<T> attr(AttributeKey<T> key) {, +            map = new IdentityHashMap<AttributeKey<?>, Attribute<?>>(2);, +            if (!updater.compareAndSet(this, null, map)) {, +                map = this.map;, +            }, +        synchronized (map) {, +                attr = new DefaultAttribute<T>(map, key);, +    }, +    private static final class DefaultAttribute<T> extends AtomicReference<T> implements Attribute<T> {, +        private final Map<AttributeKey<?>, Attribute<?>> map;, +        private final AttributeKey<T> key;, +, +        DefaultAttribute(Map<AttributeKey<?>, Attribute<?>> map, AttributeKey<T> key) {, +            this.map = map;, +            this.key = key;, +        }, +, +        @Override, +        public AttributeKey<T> key() {, +            return key;, +        }, +, +        public T getAndRemove() {, +            T oldValue = getAndSet(null);, +            remove0();, +            return oldValue;, +        }, +, +        @Override, +            set(null);, +            remove0();, +        }, +, +        private void remove0() {, +            synchronized (map) {, +                map.remove(key);]