[+++ b/common/src/main/java/io/netty/util/Recycler.java, +                queue = WeakOrderQueue.allocate(stack, thread);, +                if (queue == null) {, +                    // drop object, +                    return;, +                }, +                delayedRecycled.put(stack, queue);, +        private WeakOrderQueue(Stack<?> stack, Thread thread) {, +        /**, +         * Allocate a new {@link WeakOrderQueue} or return {@code null} if not possible., +         */, +        static WeakOrderQueue allocate(Stack<?> stack, Thread thread) {, +            // We allocated a Link so reserve the space, +            return reserveSpace(stack.availableSharedCapacity, LINK_CAPACITY), +                    ? new WeakOrderQueue(stack, thread) : null;, +        }, +, +        private static boolean reserveSpace(AtomicInteger availableSharedCapacity, int space) {, +                if (!reserveSpace(availableSharedCapacity, LINK_CAPACITY)) {, +, +        @Override, +        protected void finalize() throws Throwable {, +            try {, +                super.finalize();, +            } finally {, +                // We need to reclaim all space that was reserved by this WeakOrderQueue so we not run out of space in, +                // the stack. This is needed as we not have a good life-time control over the queue as it is used in a, +                // WeakHashMap which will drop it at any time., +                Link link = head;, +                while (link != null) {, +                    reclaimSpace(LINK_CAPACITY);, +                    link = link.next;, +                }, +            }, +        }]