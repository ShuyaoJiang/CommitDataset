[+++ b/common/src/main/java/io/netty/util/concurrent/DefaultPromise.java, +import io.netty.util.internal.StringUtil;, +            throw new InterruptedException(toString());, +            throw new InterruptedException(toString());, +            throw new BlockingOperationException(toString());, +        throw new IllegalStateException("complete already: " + this);, +        throw new IllegalStateException("complete already: " + this, cause);, +            return false;, +                return false;, +            throw new IllegalStateException("too many waiters: " + this);, +, +    @Override, +    public String toString() {, +        return toStringBuilder().toString();, +    }, +, +    protected StringBuilder toStringBuilder() {, +        StringBuilder buf = new StringBuilder(64);, +        buf.append(StringUtil.simpleClassName(this));, +        buf.append('@');, +        buf.append(Integer.toHexString(hashCode()));, +, +        Object result = this.result;, +        if (result == SUCCESS) {, +            buf.append("(success)");, +        } else if (result == UNCANCELLABLE) {, +            buf.append("(uncancellable)");, +        } else if (result instanceof CauseHolder) {, +            buf.append("(failure(");, +            buf.append(((CauseHolder) result).cause);, +            buf.append(')');, +        } else {, +            buf.append("(incomplete)");, +        }, +        return buf;, +    }, +++ b/common/src/main/java/io/netty/util/concurrent/DefaultPromise.java, +import io.netty.util.internal.StringUtil;, +            throw new InterruptedException(toString());, +            throw new InterruptedException(toString());, +            throw new BlockingOperationException(toString());, +        throw new IllegalStateException("complete already: " + this);, +        throw new IllegalStateException("complete already: " + this, cause);, +            return false;, +                return false;, +            throw new IllegalStateException("too many waiters: " + this);, +, +    @Override, +    public String toString() {, +        return toStringBuilder().toString();, +    }, +, +    protected StringBuilder toStringBuilder() {, +        StringBuilder buf = new StringBuilder(64);, +        buf.append(StringUtil.simpleClassName(this));, +        buf.append('@');, +        buf.append(Integer.toHexString(hashCode()));, +, +        Object result = this.result;, +        if (result == SUCCESS) {, +            buf.append("(success)");, +        } else if (result == UNCANCELLABLE) {, +            buf.append("(uncancellable)");, +        } else if (result instanceof CauseHolder) {, +            buf.append("(failure(");, +            buf.append(((CauseHolder) result).cause);, +            buf.append(')');, +        } else {, +            buf.append("(incomplete)");, +        }, +        return buf;, +    }, +++ b/common/src/main/java/io/netty/util/concurrent/PromiseTask.java, +import java.util.logging.Level;, +import java.util.logging.Logger;, +    static <T> Callable<T> toCallable(Runnable runnable, T result) {, +        return new RunnableAdapter<T>(runnable, result);, +    }, +, +    private static final class RunnableAdapter<T> implements Callable<T> {, +        final Runnable task;, +        final T result;, +, +        RunnableAdapter(Runnable task, T result) {, +            this.task = task;, +            this.result = result;, +        }, +, +        @Override, +        public T call() {, +            task.run();, +            return result;, +        }, +, +        @Override, +        public String toString() {, +            return "Callable(task: " + task + ", result: " + result + ')';, +        }, +    }, +]