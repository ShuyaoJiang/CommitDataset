[+++ b/buffer/src/main/java/io/netty/buffer/PoolThreadCache.java, +    int free() {, +        return free(tinySubPageDirectCaches) +, +                free(smallSubPageDirectCaches) +, +                free(normalDirectCaches) +, +                free(tinySubPageHeapCaches) +, +                free(smallSubPageHeapCaches) +, +    private static int free(MemoryRegionCache<?>[] caches) {, +            return 0;, +        int numFreed = 0;, +        for (int i = 0; i < caches.length; i++) {, +            numFreed += free(caches[i]);, +        return numFreed;, +    }, +, +    private static int free(MemoryRegionCache<?> cache) {, +        if (cache == null) {, +            return 0;, +        }, +        return cache.free();, +        public int free() {, +            int numFreed = 0;, +                if (freeEntry(entries[i])) {, +                    numFreed++;, +                } else {, +                    return numFreed;, +            return index + 1 & entries.length - 1;, +++ b/buffer/src/main/java/io/netty/buffer/PoolThreadCache.java, +    int free() {, +        return free(tinySubPageDirectCaches) +, +                free(smallSubPageDirectCaches) +, +                free(normalDirectCaches) +, +                free(tinySubPageHeapCaches) +, +                free(smallSubPageHeapCaches) +, +    private static int free(MemoryRegionCache<?>[] caches) {, +            return 0;, +        int numFreed = 0;, +        for (int i = 0; i < caches.length; i++) {, +            numFreed += free(caches[i]);, +        return numFreed;, +    }, +, +    private static int free(MemoryRegionCache<?> cache) {, +        if (cache == null) {, +            return 0;, +        }, +        return cache.free();, +        public int free() {, +            int numFreed = 0;, +                if (freeEntry(entries[i])) {, +                    numFreed++;, +                } else {, +                    return numFreed;, +            return index + 1 & entries.length - 1;, +++ b/buffer/src/main/java/io/netty/buffer/PooledByteBufAllocator.java, +import io.netty.util.ThreadDeathWatcher;, +            logger.debug("-Dio.netty.allocator.cacheTrimInterval: {}", DEFAULT_CACHE_TRIM_INTERVAL);, +        threadCache = new PoolThreadLocalCache();, +    @Deprecated, +    @SuppressWarnings("UnusedParameters"), +    public PooledByteBufAllocator(boolean preferDirect, int nHeapArena, int nDirectArena, int pageSize, int maxOrder,, +                                  int tinyCacheSize, int smallCacheSize, int normalCacheSize,, +                                  long cacheThreadAliveCheckInterval) {, +        this(preferDirect, nHeapArena, nDirectArena, pageSize, maxOrder,, +                tinyCacheSize, smallCacheSize, normalCacheSize);, +    }, +, +        private boolean initialized;, +        protected PoolThreadCache initialValue() {, +, +            final PoolThreadCache cache = new PoolThreadCache(, +, +            // The thread-local cache will keep a list of pooled buffers which must be returned to, +            // the pool when the thread is not alive anymore., +            final Thread thread = Thread.currentThread();, +            ThreadDeathWatcher.watch(thread, new Runnable() {, +                @Override, +                public void run() {, +                    int numFreed = cache.free();, +                    if (logger.isDebugEnabled()) {, +                        logger.debug("Freed {} thread-local buffer(s) from thread: {}", numFreed, thread.getName());, +                }, +            });, +, +            initialized = true;, +            return initialized;, +            if (exists()) {, +                PoolThreadCache cache = get();, +++ b/buffer/src/main/java/io/netty/buffer/PoolThreadCache.java, +    int free() {, +        return free(tinySubPageDirectCaches) +, +                free(smallSubPageDirectCaches) +, +                free(normalDirectCaches) +, +                free(tinySubPageHeapCaches) +, +                free(smallSubPageHeapCaches) +, +    private static int free(MemoryRegionCache<?>[] caches) {, +            return 0;, +        int numFreed = 0;, +        for (int i = 0; i < caches.length; i++) {, +            numFreed += free(caches[i]);]