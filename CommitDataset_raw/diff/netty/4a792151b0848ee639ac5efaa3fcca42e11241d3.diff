[+++ b/transport/src/main/java/io/netty/channel/DefaultChannelHandlerContext.java, +    private volatile Queue<Object> inBridge;, +    private volatile Queue<Object> outBridge;, +    private volatile NextBridgeFeeder nextInBridgeFeeder;, +    private volatile NextBridgeFeeder nextOutBridgeFeeder;, +    @SuppressWarnings("rawtypes"), +    private static final AtomicReferenceFieldUpdater<DefaultChannelHandlerContext, Queue> IN_BRIDGE_UPDATER =, +            AtomicReferenceFieldUpdater.newUpdater(DefaultChannelHandlerContext.class, Queue.class, "inBridge");, +    @SuppressWarnings("rawtypes"), +    private static final AtomicReferenceFieldUpdater<DefaultChannelHandlerContext, Queue> OUT_BRIDGE_UPDATER =, +            AtomicReferenceFieldUpdater.newUpdater(DefaultChannelHandlerContext.class, Queue.class, "outBridge");, +    private static final AtomicReferenceFieldUpdater<DefaultChannelHandlerContext, NextBridgeFeeder>, +            NEXT_IN_BRIDGE_FEEDER = AtomicReferenceFieldUpdater.newUpdater(, +                    DefaultChannelHandlerContext.class, NextBridgeFeeder.class, "nextInBridgeFeeder");, +    private static final AtomicReferenceFieldUpdater<DefaultChannelHandlerContext, NextBridgeFeeder>, +            NEXT_OUT_BRIDGE_FEEDER = AtomicReferenceFieldUpdater.newUpdater(, +                    DefaultChannelHandlerContext.class, NextBridgeFeeder.class, "nextOutBridgeFeeder");, +        Queue<Object> inBridge = this.inBridge;, +        if (inBridge == null) {, +        return flushBridge(inBridge, inMsgBuf, inByteBuf);, +    }, +        Queue<Object> outBridge = this.outBridge;, +        if (outBridge == null) {, +            return true;, +        return flushBridge(outBridge, outMsgBuf, outByteBuf);, +    }, +, +    private static boolean flushBridge(Queue<Object> bridge, MessageBuf<Object> msgBuf, ByteBuf byteBuf) {, +        if (bridge == null) {, +            return true;, +        }, +, +        boolean nextBufferHadEnoughRoom = true;, +        for (;;) {, +            Object o = bridge.peek();, +            if (o == null) {, +                break;, +            }, +, +            try {, +                if (o instanceof Object[]) {, +                    Object[] data = (Object[]) o;, +                    int i;, +                    for (i = 0; i < data.length; i ++) {, +                        Object m = data[i];, +                        if (m == null) {, +                            break;, +                        }, +, +                        if (msgBuf.offer(m)) {, +                            data[i] = null;, +                        } else {, +                            System.arraycopy(data, i, data, 0, data.length - i);, +                            for (int j = i + 1; j < data.length; j ++) {, +                                data[j] = null;, +                            }, +                            nextBufferHadEnoughRoom = false;, +                            break;, +                        }, +                    }, +                } else if (o instanceof ByteBuf) {, +                    ByteBuf data = (ByteBuf) o;, +                    if (byteBuf.writerIndex() > byteBuf.maxCapacity() - data.readableBytes()) {, +                        // The target buffer is not going to be able to accept all data in the bridge., +                        byteBuf.capacity(byteBuf.maxCapacity());, +                        byteBuf.writeBytes(data, byteBuf.writableBytes());, +                        nextBufferHadEnoughRoom = false;, +                        break;, +                    } else {, +                        try {, +                            byteBuf.writeBytes(data);, +                        } finally {, +                            data.release();, +                        }, +                    }, +                } else {, +                    throw new Error();, +                }, +            } finally {, +                if (nextBufferHadEnoughRoom) {, +                    Object removed = bridge.remove();, +                    assert removed == o;, +                }, +        return nextBufferHadEnoughRoom;, +            try {, +                    }, +                }, +                free();, +    private void free() {, +        freeInbound();, +        freeOutbound();, +    private void freeInbound() {, +        // Release the bridge feeder, +        NextBridgeFeeder feeder;, +        feeder = nextInBridgeFeeder;, +        if (feeder != null) {, +            feeder.release();, +            nextInBridgeFeeder = null;, +        }, +]