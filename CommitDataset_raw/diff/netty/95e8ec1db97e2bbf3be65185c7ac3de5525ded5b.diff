[+++ b/transport/src/main/java/io/netty/channel/SingleThreadEventExecutor.java, +                } catch (Throwable t) {, +                    logger.warn("Unexpected exception from an event executor: ", t);, +                    shutdown();, +                            if (!taskQueue.isEmpty()) {, +                                logger.warn(, +                                        "An event executor terminated with " +, +                                        "non-empty task queue (" + taskQueue.size() + ')');, +                            }, +++ b/transport/src/main/java/io/netty/channel/SingleThreadEventExecutor.java, +                } catch (Throwable t) {, +                    logger.warn("Unexpected exception from an event executor: ", t);, +                    shutdown();, +                            if (!taskQueue.isEmpty()) {, +                                logger.warn(, +                                        "An event executor terminated with " +, +                                        "non-empty task queue (" + taskQueue.size() + ')');, +                            }, +++ b/transport/src/main/java/io/netty/channel/socket/aio/AioSocketChannel.java, +import io.netty.channel.socket.SocketChannelConfig;, +    private boolean asyncWriteInProgress;, +    private boolean inDoFlushByteBuffer;, +    private boolean asyncReadInProgress;, +    private boolean inBeginRead;, +, +        if (inDoFlushByteBuffer || asyncWriteInProgress) {, +        inDoFlushByteBuffer = true;, +        try {, +            if (buf.readable()) {, +                for (;;) {, +                    asyncWriteInProgress = true;, +                        if (buffers.length == 1) {, +                            javaChannel().write(, +                                    buffers[0], config.getWriteTimeout(), TimeUnit.MILLISECONDS, this, WRITE_HANDLER);, +                            javaChannel().write(, +                                    buffers, 0, buffers.length, config.getWriteTimeout(), TimeUnit.MILLISECONDS,, +                                    this, GATHERING_WRITE_HANDLER);, +                        }, +                    } else {, +                        javaChannel().write(, +                                buf.nioBuffer(), config.getWriteTimeout(), TimeUnit.MILLISECONDS, this, WRITE_HANDLER);, +                    }, +, +                    if (asyncWriteInProgress) {, +                        // JDK decided to write data (or notify handler) later., +                        break;, +                    }, +, +                    // JDK performed the write operation immediately and notified the handler., +                    // We know this because we set asyncWriteInProgress to false in the handler., +                    if (!buf.readable()) {, +                        // There's nothing left in the buffer. No need to retry writing., +                        break;, +                    }, +, +                    // There's more to write. Continue the loop., +            }, +        } finally {, +            inDoFlushByteBuffer = false;, +        if (inBeginRead || asyncReadInProgress || inputShutdown || readSuspended.get()) {, +        inBeginRead = true;, +        try {, +            for (;;) {, +                asyncReadInProgress = true;, +, +                if (asyncReadInProgress) {, +                    // JDK decided to read data (or notify handler) later., +                    break;, +                }, +, +                // The read operation has been finished immediately - schedule another read operation., +            }, +        } finally {, +            inBeginRead = false;, +        }, +            channel.asyncWriteInProgress = false;, +            if (channel.inDoFlushByteBuffer) {, +                // JDK performed the write operation immediately and notified this handler immediately., +                // doFlushByteBuffer() will do subsequent write operations if necessary for us., +                return;, +            // Notify flush futures only when the handler is called outside of unsafe().flushNow(), +            // because flushNow() will do that for us., +                channel.unsafe().flushNow();, +            } else {, +                buf.discardReadBytes();, +            channel.asyncWriteInProgress = false;, +            if (!channel.inDoFlushByteBuffer) {, +            }, +            channel.asyncReadInProgress = false;, +, +                    // Schedule another read operation., +            channel.asyncReadInProgress = false;, +                // Schedule another read operation., +    public SocketChannelConfig config() {]