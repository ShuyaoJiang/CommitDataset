[+++ b/handler/src/main/java/io/netty/handler/ssl/ReferenceCountedOpenSslEngine.java, +import static java.lang.Math.max;, +import static java.lang.Math.min;, +    private static final int MAX_ENCRYPTION_OVERHEAD_DIFF = Integer.MAX_VALUE - MAX_ENCRYPTION_OVERHEAD_LENGTH;, +, +            final int len = min(MAX_ENCRYPTED_PACKET_LENGTH, limit - pos);, +            int endOffset = offset + length;, +            int srcsLen = 0;, +, +            for (int i = offset; i < endOffset; ++i) {, +                final ByteBuffer src = srcs[i];, +                if (src == null) {, +                    throw new IllegalArgumentException("srcs[" + i + "] is null");, +                }, +                if (srcsLen == MAX_PLAINTEXT_LENGTH) {, +                    continue;, +                }, +, +                srcsLen += src.remaining();, +                if (srcsLen > MAX_PLAINTEXT_LENGTH || srcsLen < 0) {, +                    // If srcLen > MAX_PLAINTEXT_LENGTH or secLen < 0 just set it to MAX_PLAINTEXT_LENGTH., +                    // This also help us to guard against overflow., +                    // We not break out here as we still need to check for null entries in srcs[]., +                    srcsLen = MAX_PLAINTEXT_LENGTH;, +                }, +            }, +, +            int maxEncryptedLen = calculateOutNetBufSize(srcsLen);, +, +            if (dst.remaining() < maxEncryptedLen) {, +                            src, min(src.remaining(), MAX_PLAINTEXT_LENGTH - bytesConsumed));, +                    int written = writeEncryptedData(src, min(packetLengthRemaining, src.remaining()));, +    static int calculateOutNetBufSize(int pendingBytes) {, +        return min(MAX_ENCRYPTED_PACKET_LENGTH, MAX_ENCRYPTION_OVERHEAD_LENGTH, +                + min(MAX_ENCRYPTION_OVERHEAD_DIFF, pendingBytes));, +    }, +, +++ b/handler/src/main/java/io/netty/handler/ssl/ReferenceCountedOpenSslEngine.java, +import static java.lang.Math.max;, +import static java.lang.Math.min;, +    private static final int MAX_ENCRYPTION_OVERHEAD_DIFF = Integer.MAX_VALUE - MAX_ENCRYPTION_OVERHEAD_LENGTH;, +, +            final int len = min(MAX_ENCRYPTED_PACKET_LENGTH, limit - pos);, +            int endOffset = offset + length;, +            int srcsLen = 0;, +, +            for (int i = offset; i < endOffset; ++i) {, +                final ByteBuffer src = srcs[i];, +                if (src == null) {, +                    throw new IllegalArgumentException("srcs[" + i + "] is null");, +                }, +                if (srcsLen == MAX_PLAINTEXT_LENGTH) {, +                    continue;, +                }, +, +                srcsLen += src.remaining();, +                if (srcsLen > MAX_PLAINTEXT_LENGTH || srcsLen < 0) {, +                    // If srcLen > MAX_PLAINTEXT_LENGTH or secLen < 0 just set it to MAX_PLAINTEXT_LENGTH., +                    // This also help us to guard against overflow., +                    // We not break out here as we still need to check for null entries in srcs[]., +                    srcsLen = MAX_PLAINTEXT_LENGTH;, +                }, +            }, +, +            int maxEncryptedLen = calculateOutNetBufSize(srcsLen);, +, +            if (dst.remaining() < maxEncryptedLen) {, +                            src, min(src.remaining(), MAX_PLAINTEXT_LENGTH - bytesConsumed));, +                    int written = writeEncryptedData(src, min(packetLengthRemaining, src.remaining()));, +    static int calculateOutNetBufSize(int pendingBytes) {, +        return min(MAX_ENCRYPTED_PACKET_LENGTH, MAX_ENCRYPTION_OVERHEAD_LENGTH, +                + min(MAX_ENCRYPTION_OVERHEAD_DIFF, pendingBytes));, +    }, +, +++ b/handler/src/main/java/io/netty/handler/ssl/SslHandler.java, +, +            @Override, +            int calculateOutNetBufSize(SslHandler handler, int pendingBytes) {, +                return ReferenceCountedOpenSslEngine.calculateOutNetBufSize(pendingBytes);, +            }, +, +            @Override, +            int calculateOutNetBufSize(SslHandler handler, int pendingBytes) {, +                return handler.maxPacketBufferSize;, +            }, +        abstract int calculateOutNetBufSize(SslHandler handler, int pendingBytes);, +, +        engineType = SslEngineType.forEngine(engine);, +                    out = allocateOutNetBuf(ctx, buf.readableBytes());, +                    out = allocateOutNetBuf(ctx, 0);, +    private ByteBuf allocateOutNetBuf(ChannelHandlerContext ctx, int pendingBytes) {, +        return allocate(ctx, engineType.calculateOutNetBufSize(this, pendingBytes));, +++ b/handler/src/main/java/io/netty/handler/ssl/ReferenceCountedOpenSslEngine.java, +import static java.lang.Math.max;, +import static java.lang.Math.min;, +    private static final int MAX_ENCRYPTION_OVERHEAD_DIFF = Integer.MAX_VALUE - MAX_ENCRYPTION_OVERHEAD_LENGTH;, +, +            final int len = min(MAX_ENCRYPTED_PACKET_LENGTH, limit - pos);, +            int endOffset = offset + length;, +            int srcsLen = 0;]