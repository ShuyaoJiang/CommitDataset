[+++ b/common/src/main/java/io/netty/util/HashedWheelTimer.java, +    private static final ResourceLeakDetector<HashedWheelTimer> leakDetector = ResourceLeakDetectorFactory.instance(), +            .newResourceLeakDetector(HashedWheelTimer.class, 1, Runtime.getRuntime().availableProcessors() * 4L);, +++ b/common/src/main/java/io/netty/util/HashedWheelTimer.java, +    private static final ResourceLeakDetector<HashedWheelTimer> leakDetector = ResourceLeakDetectorFactory.instance(), +            .newResourceLeakDetector(HashedWheelTimer.class, 1, Runtime.getRuntime().availableProcessors() * 4L);, +++ b/common/src/main/java/io/netty/util/ResourceLeakDetector.java, +    static final int DEFAULT_SAMPLING_INTERVAL = 128;, +    /**, +     * @deprecated use {@link ResourceLeakDetectorFactory#newResourceLeakDetector(Class, int, long)}., +     */, +    @Deprecated, +    /**, +     * @deprecated use {@link ResourceLeakDetectorFactory#newResourceLeakDetector(Class, int, long)}., +     */, +    @Deprecated, +    /**, +     * This should not be used directly by users of {@link ResourceLeakDetector}., +     * Please use {@link ResourceLeakDetectorFactory#newResourceLeakDetector(Class)}, +     * or {@link ResourceLeakDetectorFactory#newResourceLeakDetector(Class, int, long)}, +     */, +    @SuppressWarnings("deprecation"), +    /**, +     * @deprecated use {@link ResourceLeakDetectorFactory#newResourceLeakDetector(Class, int, long)}., +     */, +    @Deprecated, +    public final ResourceLeak open(T obj) {, +++ b/common/src/main/java/io/netty/util/HashedWheelTimer.java, +    private static final ResourceLeakDetector<HashedWheelTimer> leakDetector = ResourceLeakDetectorFactory.instance(), +            .newResourceLeakDetector(HashedWheelTimer.class, 1, Runtime.getRuntime().availableProcessors() * 4L);, +++ b/common/src/main/java/io/netty/util/ResourceLeakDetector.java, +    static final int DEFAULT_SAMPLING_INTERVAL = 128;, +    /**, +     * @deprecated use {@link ResourceLeakDetectorFactory#newResourceLeakDetector(Class, int, long)}., +     */, +    @Deprecated, +    /**, +     * @deprecated use {@link ResourceLeakDetectorFactory#newResourceLeakDetector(Class, int, long)}., +     */, +    @Deprecated, +    /**, +     * This should not be used directly by users of {@link ResourceLeakDetector}., +     * Please use {@link ResourceLeakDetectorFactory#newResourceLeakDetector(Class)}, +     * or {@link ResourceLeakDetectorFactory#newResourceLeakDetector(Class, int, long)}, +     */, +    @SuppressWarnings("deprecation"), +    /**, +     * @deprecated use {@link ResourceLeakDetectorFactory#newResourceLeakDetector(Class, int, long)}., +     */, +    @Deprecated, +    public final ResourceLeak open(T obj) {, +++ b/common/src/main/java/io/netty/util/ResourceLeakDetectorFactory.java, +    public final <T> ResourceLeakDetector<T> newResourceLeakDetector(Class<T> resource) {, +        return newResourceLeakDetector(resource, ResourceLeakDetector.DEFAULT_SAMPLING_INTERVAL, Long.MAX_VALUE);, +    }, +, +    /**, +     * Returns a new instance of a {@link ResourceLeakDetector} with the given resource class., +     *, +     * @param resource - the resource class used to initialize the {@link ResourceLeakDetector}, +     * @param samplingInterval - the interval on which sampling takes place, +     * @param maxActive - the maximum active instances, +     * @param <T> - the type of the resource class, +     * @return - a new instance of {@link ResourceLeakDetector}, +     */, +    public abstract <T> ResourceLeakDetector<T> newResourceLeakDetector(, +            Class<T> resource, int samplingInterval, long maxActive);, +        private final Constructor<?> customClassConstructor;, +        DefaultResourceLeakDetectorFactory() {, +            String customLeakDetector;, +            try {, +                customLeakDetector = AccessController.doPrivileged(new PrivilegedAction<String>() {, +            } catch (Throwable cause) {, +                logger.error("Could not access System property: io.netty.customResourceLeakDetector", cause);, +                customLeakDetector = null;, +            }, +            customClassConstructor = customLeakDetector == null ? null : customClassConstructor(customLeakDetector);, +        private static Constructor<?> customClassConstructor(String customLeakDetector) {, +                    return detectorClass.getConstructor(Class.class, int.class, long.class);, +                logger.error("Could not load custom resource leak detector class provided: {}",, +                        customLeakDetector, t);, +        public <T> ResourceLeakDetector<T> newResourceLeakDetector(, +                Class<T> resource, int samplingInterval, long maxActive) {, +                try {, +                    @SuppressWarnings("unchecked"), +                            (ResourceLeakDetector<T>) customClassConstructor.newInstance(, +                                    resource, samplingInterval, maxActive);, +                    logger.debug("Loaded custom ResourceLeakDetector: {}",, +                            customClassConstructor.getDeclaringClass().getName());, +                    logger.error(, +                            "Could not load custom resource leak detector provided: {} with the given resource: {}",, +                            customClassConstructor.getDeclaringClass().getName(), resource, t);, +                }, +            ResourceLeakDetector<T> resourceLeakDetector = new ResourceLeakDetector<T>(, +                    resource, samplingInterval, maxActive);]