[+++ b/transport/src/main/java/io/netty/channel/nio/AbstractNioMessageChannel.java, +                    closed = closeOnReadError(exception);, +    protected boolean closeOnReadError(Throwable cause) {, +        // ServerChannel should not be closed even on IOException because it can often continue, +        // accepting incoming connections. (e.g. too many open files), +        return cause instanceof IOException &&, +                !(cause instanceof PortUnreachableException) &&, +                this instanceof ServerChannel;, +    }, +, +++ b/transport/src/main/java/io/netty/channel/nio/AbstractNioMessageChannel.java, +                    closed = closeOnReadError(exception);, +    protected boolean closeOnReadError(Throwable cause) {, +        // ServerChannel should not be closed even on IOException because it can often continue, +        // accepting incoming connections. (e.g. too many open files), +        return cause instanceof IOException &&, +                !(cause instanceof PortUnreachableException) &&, +                this instanceof ServerChannel;, +    }, +, +++ b/transport/src/main/java/io/netty/channel/socket/nio/NioDatagramChannel.java, +, +    @Override, +    protected boolean closeOnReadError(Throwable cause) {, +        // We do not want to close on SocketException when using DatagramChannel as we usually can continue receiving., +        // See https://github.com/netty/netty/issues/5893, +        if (cause instanceof SocketException) {, +            return false;, +        }, +        return super.closeOnReadError(cause);, +    }]