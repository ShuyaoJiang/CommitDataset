[+++ b/codec-haproxy/src/main/java/io/netty/handler/codec/haproxy/HAProxyMessage.java, +import java.util.ArrayList;, +import java.util.Collections;, +import java.util.List;, +, +    private final List<HAProxyTLV> tlvs;, +        this(protocolVersion, command, proxiedProtocol,, +             sourceAddress, destinationAddress, sourcePort, destinationPort, Collections.<HAProxyTLV>emptyList());, +    }, +, +    /**, +     * Creates a new instance, +     */, +    private HAProxyMessage(, +            HAProxyProtocolVersion protocolVersion, HAProxyCommand command, HAProxyProxiedProtocol proxiedProtocol,, +            String sourceAddress, String destinationAddress, int sourcePort, int destinationPort,, +            List<HAProxyTLV> tlvs) {, +, +        this.tlvs = Collections.unmodifiableList(tlvs);, +        final List<HAProxyTLV> tlvs = readTlvs(header);, +, +        return new HAProxyMessage(ver, cmd, protAndFam, srcAddress, dstAddress, srcPort, dstPort, tlvs);, +    }, +, +    private static List<HAProxyTLV> readTlvs(final ByteBuf header) {, +        HAProxyTLV haProxyTLV = readNextTLV(header);, +        if (haProxyTLV == null) {, +            return Collections.emptyList();, +        }, +        // In most cases there are less than 4 TLVs available, +        List<HAProxyTLV> haProxyTLVs = new ArrayList<HAProxyTLV>(4);, +, +        do {, +            haProxyTLVs.add(haProxyTLV);, +            if (haProxyTLV instanceof HAProxySSLTLV) {, +                haProxyTLVs.addAll(((HAProxySSLTLV) haProxyTLV).encapsulatedTLVs());, +            }, +        } while ((haProxyTLV = readNextTLV(header)) != null);, +        return haProxyTLVs;, +    }, +, +    private static HAProxyTLV readNextTLV(final ByteBuf header) {, +, +        // We need at least 4 bytes for a TLV, +        if (header.readableBytes() < 4) {, +            return null;, +        }, +, +        final byte typeAsByte = header.readByte();, +        final HAProxyTLV.Type type = HAProxyTLV.Type.typeForByteValue(typeAsByte);, +, +        final int length = header.readUnsignedShort();, +        switch (type) {, +        case PP2_TYPE_SSL:, +            final ByteBuf rawContent = header.retainedSlice(header.readerIndex(), length);, +            final ByteBuf byteBuf = header.readSlice(length);, +            final byte client = byteBuf.readByte();, +            final int verify = byteBuf.readInt();, +, +            if (byteBuf.readableBytes() >= 4) {, +, +                final List<HAProxyTLV> encapsulatedTlvs = new ArrayList<HAProxyTLV>(4);, +                do {, +                    final HAProxyTLV haProxyTLV = readNextTLV(byteBuf);, +                    if (haProxyTLV == null) {, +                        break;, +                    }, +                    encapsulatedTlvs.add(haProxyTLV);, +                } while (byteBuf.readableBytes() >= 4);, +, +                return new HAProxySSLTLV(verify, client, encapsulatedTlvs, rawContent);, +            }, +            return new HAProxySSLTLV(verify, client, Collections.<HAProxyTLV>emptyList(), rawContent);, +        // If we're not dealing with a SSL Type, we can use the same mechanism, +        case PP2_TYPE_ALPN:, +        case PP2_TYPE_AUTHORITY:, +        case PP2_TYPE_SSL_VERSION:, +        case PP2_TYPE_SSL_CN:, +        case PP2_TYPE_NETNS:, +        case OTHER:, +            return new HAProxyTLV(type, typeAsByte, header.readRetainedSlice(length));, +        default:, +            return null;, +        }, +, +    /**, +     * Returns a list of {@link HAProxyTLV} or an empty list if no TLVs are present., +     * <p>, +     * TLVs are only available for the Proxy Protocol V2, +     */, +    public List<HAProxyTLV> tlvs() {, +        return tlvs;, +    }, +++ b/codec-haproxy/src/main/java/io/netty/handler/codec/haproxy/HAProxyMessage.java, +import java.util.ArrayList;, +import java.util.Collections;, +import java.util.List;, +, +    private final List<HAProxyTLV> tlvs;, +        this(protocolVersion, command, proxiedProtocol,]