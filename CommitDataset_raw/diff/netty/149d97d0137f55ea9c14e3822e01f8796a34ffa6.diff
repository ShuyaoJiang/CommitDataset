[+++ b/src/main/java/org/jboss/netty/channel/AbstractChannel.java, +import java.util.concurrent.ConcurrentMap;, +import org.jboss.netty.util.ConcurrentHashMap;, +    static final ConcurrentMap<Integer, Channel> allChannels = new ConcurrentHashMap<Integer, Channel>();, +    private static final IdDeallocator ID_DEALLOCATOR = new IdDeallocator();, +, +    private static Integer allocateId(Channel channel) {, +        Integer id = Integer.valueOf(System.identityHashCode(channel));, +        for (;;) {, +            // Loop until a unique ID is acquired., +            // It should be found in one loop practically., +            if (allChannels.putIfAbsent(id, channel) == null) {, +                // Successfully acquired., +                return id;, +            } else {, +                // Taken by other channel at almost the same moment., +                id = Integer.valueOf(id.intValue() + 1);, +            }, +        }, +    }, +, +    private static final class IdDeallocator implements ChannelFutureListener {, +        IdDeallocator() {, +            super();, +        }, +, +        public void operationComplete(ChannelFuture future) throws Exception {, +            allChannels.remove(future.getChannel().getId());, +        }, +    }, +, +    private final Integer id = allocateId(this);, +        closeFuture.addListener(ID_DEALLOCATOR);, +    public final Integer getId() {, +        buf.append("[id: 0x");, +        buf.append(Integer.toHexString(id.intValue()));, +        buf.append(']');, +++ b/src/main/java/org/jboss/netty/channel/AbstractChannel.java, +import java.util.concurrent.ConcurrentMap;, +import org.jboss.netty.util.ConcurrentHashMap;, +    static final ConcurrentMap<Integer, Channel> allChannels = new ConcurrentHashMap<Integer, Channel>();, +    private static final IdDeallocator ID_DEALLOCATOR = new IdDeallocator();, +, +    private static Integer allocateId(Channel channel) {, +        Integer id = Integer.valueOf(System.identityHashCode(channel));, +        for (;;) {, +            // Loop until a unique ID is acquired., +            // It should be found in one loop practically., +            if (allChannels.putIfAbsent(id, channel) == null) {, +                // Successfully acquired., +                return id;, +            } else {, +                // Taken by other channel at almost the same moment., +                id = Integer.valueOf(id.intValue() + 1);, +            }, +        }, +    }, +, +    private static final class IdDeallocator implements ChannelFutureListener {, +        IdDeallocator() {, +            super();, +        }, +, +        public void operationComplete(ChannelFuture future) throws Exception {, +            allChannels.remove(future.getChannel().getId());, +        }, +    }, +, +    private final Integer id = allocateId(this);, +        closeFuture.addListener(ID_DEALLOCATOR);, +    public final Integer getId() {, +        buf.append("[id: 0x");, +        buf.append(Integer.toHexString(id.intValue()));, +        buf.append(']');, +++ b/src/main/java/org/jboss/netty/channel/Channel.java, +     * Returns the unique integer ID of this channel., +    Integer getId();, +++ b/src/main/java/org/jboss/netty/channel/AbstractChannel.java, +import java.util.concurrent.ConcurrentMap;, +import org.jboss.netty.util.ConcurrentHashMap;, +    static final ConcurrentMap<Integer, Channel> allChannels = new ConcurrentHashMap<Integer, Channel>();, +    private static final IdDeallocator ID_DEALLOCATOR = new IdDeallocator();, +, +    private static Integer allocateId(Channel channel) {, +        Integer id = Integer.valueOf(System.identityHashCode(channel));, +        for (;;) {, +            // Loop until a unique ID is acquired., +            // It should be found in one loop practically., +            if (allChannels.putIfAbsent(id, channel) == null) {, +                // Successfully acquired., +                return id;, +            } else {, +                // Taken by other channel at almost the same moment., +                id = Integer.valueOf(id.intValue() + 1);, +            }, +        }, +    }, +, +    private static final class IdDeallocator implements ChannelFutureListener {, +        IdDeallocator() {]