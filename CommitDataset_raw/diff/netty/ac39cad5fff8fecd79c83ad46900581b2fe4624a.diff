[+++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, +        if (fromIndex < 0 || fromIndex > toIndex || toIndex > capacity()) {, +                    "fromIndex: %d, toIndex: %d (expected: 0 <= fromIndex <= toIndex <= capacity(%d))",, +, +        if (fromIndex == toIndex) {, +            return -1;, +        }, +, +    @Override, +    public int forEachByteDesc(ByteBufProcessor processor) {, +        return forEachByteDesc0(readerIndex, writerIndex, processor);, +    @Override, +    public int forEachByteDesc(int toIndex, int fromIndex, ByteBufProcessor processor) {, +        if (toIndex < 0 || toIndex > fromIndex || fromIndex > capacity()) {, +            throw new IndexOutOfBoundsException(String.format(, +                    "toIndex: %d, fromIndex: %d (expected: 0 <= toIndex <= fromIndex <= capacity(%d))",, +                    toIndex, fromIndex, capacity()));, +        }, +, +        return forEachByteDesc0(toIndex, fromIndex, processor);, +    }, +, +    private int forEachByteDesc0(int toIndex, int fromIndex, ByteBufProcessor processor) {, +        int i = fromIndex - 1;, +            } while (i >= toIndex);, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, +        if (fromIndex < 0 || fromIndex > toIndex || toIndex > capacity()) {, +                    "fromIndex: %d, toIndex: %d (expected: 0 <= fromIndex <= toIndex <= capacity(%d))",, +, +        if (fromIndex == toIndex) {, +            return -1;, +        }, +, +    @Override, +    public int forEachByteDesc(ByteBufProcessor processor) {, +        return forEachByteDesc0(readerIndex, writerIndex, processor);, +    @Override, +    public int forEachByteDesc(int toIndex, int fromIndex, ByteBufProcessor processor) {, +        if (toIndex < 0 || toIndex > fromIndex || fromIndex > capacity()) {, +            throw new IndexOutOfBoundsException(String.format(, +                    "toIndex: %d, fromIndex: %d (expected: 0 <= toIndex <= fromIndex <= capacity(%d))",, +                    toIndex, fromIndex, capacity()));, +        }, +, +        return forEachByteDesc0(toIndex, fromIndex, processor);, +    }, +, +    private int forEachByteDesc0(int toIndex, int fromIndex, ByteBufProcessor processor) {, +        int i = fromIndex - 1;, +            } while (i >= toIndex);, +++ b/buffer/src/main/java/io/netty/buffer/ByteBuf.java, +     * Iterates over the readable bytes of this buffer with the specified {@code processor} in ascending order., +     * Iterates over the specified area of this buffer with the specified {@code processor} in ascending order., +     * Iterates over the readable bytes of this buffer with the specified {@code processor} in descending order., +     *, +     * @return {@code -1} if the processor iterated to or beyond the beginning of the readable bytes., +     *         If the {@code processor} raised {@link ByteBufProcessor#ABORT}, the last-visited index will be returned., +     */, +    int forEachByteDesc(ByteBufProcessor processor);, +, +    /**, +     * Iterates over the specified area of this buffer with the specified {@code processor} in descending order., +     * ({@code [toIndex, fromIndex&#41} i.e. {@code (fromIndex - 1)}, {@code (fromIndex - 2)}, ... {@code toIndex}), +     *, +     * @return {@code -1} if the processor iterated to or beyond the beginning of the specified area., +     *         If the {@code processor} raised {@link ByteBufProcessor#ABORT}, the last-visited index will be returned., +     */, +    int forEachByteDesc(int toIndex, int fromIndex, ByteBufProcessor processor);, +, +    /**, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, +        if (fromIndex < 0 || fromIndex > toIndex || toIndex > capacity()) {, +                    "fromIndex: %d, toIndex: %d (expected: 0 <= fromIndex <= toIndex <= capacity(%d))",, +, +        if (fromIndex == toIndex) {, +            return -1;, +        }, +, +    @Override, +    public int forEachByteDesc(ByteBufProcessor processor) {, +        return forEachByteDesc0(readerIndex, writerIndex, processor);, +    @Override, +    public int forEachByteDesc(int toIndex, int fromIndex, ByteBufProcessor processor) {, +        if (toIndex < 0 || toIndex > fromIndex || fromIndex > capacity()) {, +            throw new IndexOutOfBoundsException(String.format(, +                    "toIndex: %d, fromIndex: %d (expected: 0 <= toIndex <= fromIndex <= capacity(%d))",, +                    toIndex, fromIndex, capacity()));, +        }, +, +        return forEachByteDesc0(toIndex, fromIndex, processor);, +    }, +, +    private int forEachByteDesc0(int toIndex, int fromIndex, ByteBufProcessor processor) {, +        int i = fromIndex - 1;, +            } while (i >= toIndex);, +++ b/buffer/src/main/java/io/netty/buffer/ByteBuf.java, +     * Iterates over the readable bytes of this buffer with the specified {@code processor} in ascending order., +     * Iterates over the specified area of this buffer with the specified {@code processor} in ascending order., +     * Iterates over the readable bytes of this buffer with the specified {@code processor} in descending order., +     *]