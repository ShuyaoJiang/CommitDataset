[+++ b/codec/src/main/java/io/netty/handler/codec/ByteToByteEncoder.java, +import io.netty.channel.IncompleteFlushException;, +                    cause = new IncompleteFlushException("Unable to encoded all bytes", cause);, +++ b/codec/src/main/java/io/netty/handler/codec/ByteToByteEncoder.java, +import io.netty.channel.IncompleteFlushException;, +                    cause = new IncompleteFlushException("Unable to encoded all bytes", cause);, +++ b/transport/src/main/java/io/netty/channel/ChannelHandlerUtil.java, +            if (!handler.beginFlush(ctx)) {, +                throw new IncompleteFlushException(, +                        "beginFlush(..) rejected the flush request by returning false. " +, +                        "none of " + inSize + " message(s) fulshed.");, +            }, +            IncompleteFlushException pfe;, +            if (t instanceof IncompleteFlushException) {, +                pfe = (IncompleteFlushException) t;, +            } else {, +                    pfe = new IncompleteFlushException("aborted: " + msg);, +                    pfe = new IncompleteFlushException(msg, t);, +                }, +         *, +         * @return {@code true} to accept the flush request.  {@code false} to reject the flush request and, +         *         to fail the promise associated with the flush request with {@link IncompleteFlushException}., +        boolean beginFlush(ChannelHandlerContext ctx) throws Exception;, +++ b/codec/src/main/java/io/netty/handler/codec/ByteToByteEncoder.java, +import io.netty.channel.IncompleteFlushException;, +                    cause = new IncompleteFlushException("Unable to encoded all bytes", cause);, +++ b/transport/src/main/java/io/netty/channel/ChannelHandlerUtil.java, +            if (!handler.beginFlush(ctx)) {, +                throw new IncompleteFlushException(, +                        "beginFlush(..) rejected the flush request by returning false. " +, +                        "none of " + inSize + " message(s) fulshed.");, +            }, +            IncompleteFlushException pfe;, +            if (t instanceof IncompleteFlushException) {, +                pfe = (IncompleteFlushException) t;, +            } else {, +                    pfe = new IncompleteFlushException("aborted: " + msg);, +                    pfe = new IncompleteFlushException(msg, t);, +                }, +         *, +         * @return {@code true} to accept the flush request.  {@code false} to reject the flush request and, +         *         to fail the promise associated with the flush request with {@link IncompleteFlushException}., +        boolean beginFlush(ChannelHandlerContext ctx) throws Exception;, +++ b/transport/src/main/java/io/netty/channel/ChannelOutboundInvoker.java, +import io.netty.util.concurrent.EventExecutor;, +, +     * failed with an {@link IncompleteFlushException}. So if you are interested to know if it was partial successful you, +     * {@link IncompleteFlushException}. In such cases you may want to call {@link #flush(ChannelPromise)} or, +     * to the remote peer. In such cases the {@link ChannelFuture} will be failed with a {@link IncompleteFlushException}., +     * failed with an {@link IncompleteFlushException}. So if you are interested to know if it was partial successful you, +     * {@link IncompleteFlushException}. In such cases you may want to call {@link #flush(ChannelPromise)} or, +     * to the remote peer. In such cases the {@link ChannelFuture} will be failed with a {@link IncompleteFlushException}., +++ b/codec/src/main/java/io/netty/handler/codec/ByteToByteEncoder.java, +import io.netty.channel.IncompleteFlushException;, +                    cause = new IncompleteFlushException("Unable to encoded all bytes", cause);, +++ b/transport/src/main/java/io/netty/channel/ChannelHandlerUtil.java, +            if (!handler.beginFlush(ctx)) {, +                throw new IncompleteFlushException(, +                        "beginFlush(..) rejected the flush request by returning false. " +, +                        "none of " + inSize + " message(s) fulshed.");, +            }, +            IncompleteFlushException pfe;, +            if (t instanceof IncompleteFlushException) {, +                pfe = (IncompleteFlushException) t;, +            } else {, +                    pfe = new IncompleteFlushException("aborted: " + msg);, +                    pfe = new IncompleteFlushException(msg, t);, +                }, +         *, +         * @return {@code true} to accept the flush request.  {@code false} to reject the flush request and, +         *         to fail the promise associated with the flush request with {@link IncompleteFlushException}., +        boolean beginFlush(ChannelHandlerContext ctx) throws Exception;, +++ b/transport/src/main/java/io/netty/channel/ChannelOutboundInvoker.java, +import io.netty.util.concurrent.EventExecutor;, +, +     * failed with an {@link IncompleteFlushException}. So if you are interested to know if it was partial successful you, +     * {@link IncompleteFlushException}. In such cases you may want to call {@link #flush(ChannelPromise)} or, +     * to the remote peer. In such cases the {@link ChannelFuture} will be failed with a {@link IncompleteFlushException}., +     * failed with an {@link IncompleteFlushException}. So if you are interested to know if it was partial successful you, +     * {@link IncompleteFlushException}. In such cases you may want to call {@link #flush(ChannelPromise)} or, +     * to the remote peer. In such cases the {@link ChannelFuture} will be failed with a {@link IncompleteFlushException}., +++ b/transport/src/main/java/io/netty/channel/ChannelOutboundMessageHandlerAdapter.java, +    public boolean beginFlush(ChannelHandlerContext ctx) throws Exception {, +        return true;, +    }, +++ b/codec/src/main/java/io/netty/handler/codec/ByteToByteEncoder.java, +import io.netty.channel.IncompleteFlushException;, +                    cause = new IncompleteFlushException("Unable to encoded all bytes", cause);, +++ b/transport/src/main/java/io/netty/channel/ChannelHandlerUtil.java, +            if (!handler.beginFlush(ctx)) {, +                throw new IncompleteFlushException(, +                        "beginFlush(..) rejected the flush request by returning false. " +, +                        "none of " + inSize + " message(s) fulshed.");, +            }, +            IncompleteFlushException pfe;, +            if (t instanceof IncompleteFlushException) {, +                pfe = (IncompleteFlushException) t;, +            } else {, +                    pfe = new IncompleteFlushException("aborted: " + msg);, +                    pfe = new IncompleteFlushException(msg, t);]