[+++ b/resolver-dns/src/main/java/io/netty/resolver/dns/DefaultDnsCache.java, +import java.util.Collections;, +import java.util.concurrent.atomic.AtomicReference;, +    private final ConcurrentMap<String, Entries> resolveCache = PlatformDependent.newConcurrentHashMap();, +, +        while (!resolveCache.isEmpty()) {, +            for (Iterator<Map.Entry<String, Entries>> i = resolveCache.entrySet().iterator(); i.hasNext();) {, +                Map.Entry<String, Entries> e = i.next();, +, +                e.getValue().cancelExpiration();, +            }, +        Entries entries = resolveCache.remove(hostname);, +        return entries != null && entries.cancelExpiration();, +            return Collections.<DnsCacheEntry>emptyList();, +        Entries entries = resolveCache.get(hostname);, +        return entries == null ? null : entries.get();, +        cache0(e, Math.max(minTtl, (int) Math.min(maxTtl, originalTtl)), loop);, +        cache0(e, negativeTtl, loop);, +    private void cache0(DefaultDnsCacheEntry e, int ttl, EventLoop loop) {, +        Entries entries = resolveCache.get(e.hostname());, +        if (entries == null) {, +            entries = new Entries(e);, +            Entries oldEntries = resolveCache.putIfAbsent(e.hostname(), entries);, +            if (oldEntries != null) {, +                entries = oldEntries;, +                entries.add(e);, +        scheduleCacheExpiration(entries, e, ttl, loop);, +    }, +, +    private void scheduleCacheExpiration(final Entries entries,, +                        if (entries.remove(e)) {, +                            resolveCache.remove(e.hostname);, +, +    // Directly extend AtomicReference for intrinsics and also to keep memory overhead low., +    private static final class Entries extends AtomicReference<List<DefaultDnsCacheEntry>> {, +, +        Entries(DefaultDnsCacheEntry entry) {, +            super(Collections.singletonList(entry));, +        }, +, +        void add(DefaultDnsCacheEntry e) {, +            if (e.cause() == null) {, +                for (;;) {, +                    List<DefaultDnsCacheEntry> entries = get();, +                    if (!entries.isEmpty()) {, +                        final DefaultDnsCacheEntry firstEntry = entries.get(0);, +                        if (firstEntry.cause() != null) {, +                            assert entries.size() == 1;, +                            if (compareAndSet(entries, Collections.singletonList(e))) {, +                                firstEntry.cancelExpiration();, +                                return;, +                            } else {, +                                // Need to try again as CAS failed, +                                continue;, +                            }, +                        }, +                        // Create a new List for COW semantics, +                        List<DefaultDnsCacheEntry> newEntries = new ArrayList<DefaultDnsCacheEntry>(entries.size() + 1);, +                        newEntries.addAll(entries);, +                        newEntries.add(e);, +                        if (compareAndSet(entries, newEntries)) {, +                            return;, +                        }, +                    } else if (compareAndSet(entries, Collections.singletonList(e))) {, +                        return;, +                    }, +                }, +            } else {, +                List<DefaultDnsCacheEntry> entries = getAndSet(Collections.singletonList(e));, +                cancelExpiration(entries);, +            }, +        }, +, +        boolean remove(DefaultDnsCacheEntry entry) {, +            for (;;) {, +                List<DefaultDnsCacheEntry> entries = get();, +                int size = entries.size();, +                if (size == 0) {, +                    return false;, +                } else if (size == 1) {, +                    if (entries.get(0).equals(entry)) {, +                        // If the list is empty we just return early and so not allocate a new ArrayList., +                        if (compareAndSet(entries, Collections.<DefaultDnsCacheEntry>emptyList())) {, +                            return true;, +                        }, +                    } else {, +                        return false;, +                    }, +                } else {, +                    // Just size the new ArrayList as before as we may not find the entry we are looking for and not, +                    // want to cause an extra allocation / memory copy in this case., +                    //, +                    // Its very likely we find the entry we are looking for so we directly create a new ArrayList, +                    // and fill it., +                    List<DefaultDnsCacheEntry> newEntries = new ArrayList<DefaultDnsCacheEntry>(size);, +                    for (int i = 0; i < size; i++) {, +                        DefaultDnsCacheEntry e = entries.get(i);, +                        if (!e.equals(entry)) {, +                            newEntries.add(e);, +                        }]