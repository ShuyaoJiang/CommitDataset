[+++ b/transport/src/main/java/io/netty/channel/local/LocalChannel.java, +import io.netty.util.internal.logging.InternalLogger;, +import io.netty.util.internal.logging.InternalLoggerFactory;, +    private static final InternalLogger logger = InternalLoggerFactory.getInstance(LocalChannel.class);, +    private enum State { OPEN, BOUND, CONNECTED, CLOSED }, +, +            // Preserve order of event and force a read operation now before the close operation is processed., +            finishPeerRead(this);, +, +        if (peer != null) {, +            this.peer = null;, +            EventLoop peerEventLoop = peer.eventLoop();, +            final boolean peerIsActive = peer.isActive();, +            if (peerEventLoop.inEventLoop() && !registerInProgress) {, +                peer.tryClose(peerIsActive);, +                    peerEventLoop.execute(new Runnable() {, +                            peer.tryClose(peerIsActive);, +                } catch (Throwable cause) {, +                    logger.warn("Releasing Inbound Queues for channels {}-{} because exception occurred!",, +                            this, peer, cause);, +                    if (peerEventLoop.inEventLoop()) {, +                        peer.releaseInboundBuffers();, +                    } else {, +                        // inboundBuffers is a SPSC so we may leak if the event loop is shutdown prematurely or rejects, +                        // the close Runnable but give a best effort., +                        peer.close();, +                    }, +                    PlatformDependent.throwException(cause);, +    private void tryClose(boolean isActive) {, +        if (isActive) {, +            unsafe().close(unsafe().voidPromise());, +        } else {, +            releaseInboundBuffers();, +            } catch (Throwable cause) {, +                logger.warn("Closing Local channels {}-{} because exception occurred!", this, peer, cause);, +                close();, +                peer.close();, +                PlatformDependent.throwException(cause);, +        } catch (Throwable cause) {, +            logger.warn("Closing Local channels {}-{} because exception occurred!", this, peer, cause);, +            close();, +            peer.close();, +            PlatformDependent.throwException(cause);, +        if (readInProgress) {, +            return;, +        Queue<Object> inboundBuffer = this.inboundBuffer;, +        Object msg;, +        while ((msg = inboundBuffer.poll()) != null) {, +            ReferenceCountUtil.release(msg);]