[+++ b/transport/src/main/java/io/netty/channel/ChannelInitializer.java, +import io.netty.util.internal.PlatformDependent;, +import java.util.concurrent.ConcurrentMap;, +, +    // We use a ConcurrentMap as a ChannelInitializer is usually shared between all Channels in a Bootstrap /, +    // ServerBootstrap. This way we can reduce the memory usage compared to use Attributes., +    private final ConcurrentMap<ChannelHandlerContext, Boolean> initMap = PlatformDependent.newConcurrentHashMap();, +        // Normally this method will never be called as handlerAdded(...) should call initChannel(...) and remove, +        // the handler., +        if (initChannel(ctx)) {, +            // we called initChannel(...) so we need to call now pipeline.fireChannelRegistered() to ensure we not, +            // miss an event., +        } else {, +            // Called initChannel(...) before which is the expected behavior, so just forward the event., +            ctx.fireChannelRegistered();, +        }, +        ctx.close();, +    }, +, +    /**, +     * {@inheritDoc} If override this method ensure you call super!, +     */, +    @Override, +    public void handlerAdded(ChannelHandlerContext ctx) throws Exception {, +        if (ctx.channel().isRegistered()) {, +            // This should always be true with our current DefaultChannelPipeline implementation., +            // The good thing about calling initChannel(...) in handlerAdded(...) is that there will be no ordering, +            // suprises if a ChannelInitializer will add another ChannelInitializer. This is as all handlers, +            // will be added in the expected order., +            initChannel(ctx);, +        }, +    }, +, +    @SuppressWarnings("unchecked"), +    private boolean initChannel(ChannelHandlerContext ctx) throws Exception {, +        if (initMap.putIfAbsent(ctx, Boolean.TRUE) == null) { // Guard against re-entrance., +            try {, +                initChannel((C) ctx.channel());, +            } catch (Throwable cause) {, +                // Explicitly call exceptionCaught(...) as we removed the handler before calling initChannel(...)., +                // We do so to prevent multiple calls to initChannel(...)., +                exceptionCaught(ctx, cause);, +            } finally {, +                remove(ctx);, +            }, +            return true;, +        }, +        return false;, +    }, +, +    private void remove(ChannelHandlerContext ctx) {, +            initMap.remove(ctx);, +++ b/transport/src/main/java/io/netty/channel/ChannelInitializer.java, +import io.netty.util.internal.PlatformDependent;, +import java.util.concurrent.ConcurrentMap;, +, +    // We use a ConcurrentMap as a ChannelInitializer is usually shared between all Channels in a Bootstrap /, +    // ServerBootstrap. This way we can reduce the memory usage compared to use Attributes., +    private final ConcurrentMap<ChannelHandlerContext, Boolean> initMap = PlatformDependent.newConcurrentHashMap();, +        // Normally this method will never be called as handlerAdded(...) should call initChannel(...) and remove, +        // the handler., +        if (initChannel(ctx)) {, +            // we called initChannel(...) so we need to call now pipeline.fireChannelRegistered() to ensure we not, +            // miss an event., +        } else {, +            // Called initChannel(...) before which is the expected behavior, so just forward the event., +            ctx.fireChannelRegistered();, +        }, +        ctx.close();, +    }, +, +    /**, +     * {@inheritDoc} If override this method ensure you call super!, +     */, +    @Override, +    public void handlerAdded(ChannelHandlerContext ctx) throws Exception {, +        if (ctx.channel().isRegistered()) {, +            // This should always be true with our current DefaultChannelPipeline implementation., +            // The good thing about calling initChannel(...) in handlerAdded(...) is that there will be no ordering, +            // suprises if a ChannelInitializer will add another ChannelInitializer. This is as all handlers, +            // will be added in the expected order., +            initChannel(ctx);, +        }, +    }, +, +    @SuppressWarnings("unchecked"), +    private boolean initChannel(ChannelHandlerContext ctx) throws Exception {, +        if (initMap.putIfAbsent(ctx, Boolean.TRUE) == null) { // Guard against re-entrance., +            try {, +                initChannel((C) ctx.channel());, +            } catch (Throwable cause) {, +                // Explicitly call exceptionCaught(...) as we removed the handler before calling initChannel(...)., +                // We do so to prevent multiple calls to initChannel(...)., +                exceptionCaught(ctx, cause);, +            } finally {, +                remove(ctx);, +            }, +            return true;, +        }, +        return false;]