[+++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdySession.java, +import io.netty.channel.ChannelPromise;, +    boolean isActiveStream(int streamId) {, +        return activeStreams.containsKey(streamId);, +        TreeSet<Integer> streamIds = new TreeSet<Integer>(new PriorityComparator());, +        streamIds.addAll(activeStreams.keySet());, +        return streamIds;, +            int streamId, byte priority, boolean remoteSideClosed, boolean localSideClosed,, +            activeStreams.put(streamId, new StreamState(, +                    priority, remoteSideClosed, localSideClosed, sendWindowSize, receiveWindowSize));, +    void removeStream(int streamId, Throwable cause) {, +        StreamState state = activeStreams.remove(streamId);, +            state.clearPendingWrites(cause);, +    boolean isRemoteSideClosed(int streamId) {, +        StreamState state = activeStreams.get(streamId);, +    void closeRemoteSide(int streamId) {, +        StreamState state = activeStreams.get(streamId);, +                activeStreams.remove(streamId);, +    boolean isLocalSideClosed(int streamId) {, +        StreamState state = activeStreams.get(streamId);, +    void closeLocalSide(int streamId) {, +        StreamState state = activeStreams.get(streamId);, +                activeStreams.remove(streamId);, +    boolean hasReceivedReply(int streamId) {, +        StreamState state = activeStreams.get(streamId);, +    void receivedReply(int streamId) {, +        StreamState state = activeStreams.get(streamId);, +    int getSendWindowSize(int streamId) {, +        StreamState state = activeStreams.get(streamId);, +    int updateSendWindowSize(int streamId, int deltaWindowSize) {, +        StreamState state = activeStreams.get(streamId);, +    int updateReceiveWindowSize(int streamId, int deltaWindowSize) {, +        StreamState state = activeStreams.get(streamId);, +    int getReceiveWindowSizeLowerBound(int streamId) {, +        StreamState state = activeStreams.get(streamId);, +    void updateAllSendWindowSizes(int deltaWindowSize) {, +        for (StreamState state: activeStreams.values()) {, +            state.updateSendWindowSize(deltaWindowSize);, +        }, +    }, +, +    boolean putPendingWrite(int streamId, PendingWrite pendingWrite) {, +        StreamState state = activeStreams.get(streamId);, +        return state != null && state.putPendingWrite(pendingWrite);, +    PendingWrite getPendingWrite(int streamId) {, +        StreamState state = activeStreams.get(streamId);, +    PendingWrite removePendingWrite(int streamId) {, +        StreamState state = activeStreams.get(streamId);, +        private final Queue<PendingWrite> pendingWriteQueue = new ConcurrentLinkedQueue<PendingWrite>();, +        boolean putPendingWrite(PendingWrite msg) {, +        PendingWrite getPendingWrite() {, +        PendingWrite removePendingWrite() {, +        void clearPendingWrites(Throwable cause) {, +            for (;;) {, +                PendingWrite pendingWrite = pendingWriteQueue.poll();, +                if (pendingWrite == null) {, +                    break;, +                pendingWrite.fail(cause);, +            }, +, +    public static final class PendingWrite {, +        final SpdyDataFrame spdyDataFrame;, +        final ChannelPromise promise;, +, +        PendingWrite(SpdyDataFrame spdyDataFrame, ChannelPromise promise) {, +            this.spdyDataFrame = spdyDataFrame;, +            this.promise = promise;, +        }, +, +        void fail(Throwable cause) {, +            spdyDataFrame.release();, +            promise.setFailure(cause);, +        }, +    }, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdySession.java, +import io.netty.channel.ChannelPromise;, +    boolean isActiveStream(int streamId) {, +        return activeStreams.containsKey(streamId);, +        TreeSet<Integer> streamIds = new TreeSet<Integer>(new PriorityComparator());, +        streamIds.addAll(activeStreams.keySet());, +        return streamIds;, +            int streamId, byte priority, boolean remoteSideClosed, boolean localSideClosed,, +            activeStreams.put(streamId, new StreamState(, +                    priority, remoteSideClosed, localSideClosed, sendWindowSize, receiveWindowSize));, +    void removeStream(int streamId, Throwable cause) {, +        StreamState state = activeStreams.remove(streamId);, +            state.clearPendingWrites(cause);, +    boolean isRemoteSideClosed(int streamId) {, +        StreamState state = activeStreams.get(streamId);, +    void closeRemoteSide(int streamId) {, +        StreamState state = activeStreams.get(streamId);, +                activeStreams.remove(streamId);, +    boolean isLocalSideClosed(int streamId) {, +        StreamState state = activeStreams.get(streamId);, +    void closeLocalSide(int streamId) {, +        StreamState state = activeStreams.get(streamId);, +                activeStreams.remove(streamId);, +    boolean hasReceivedReply(int streamId) {, +        StreamState state = activeStreams.get(streamId);, +    void receivedReply(int streamId) {]