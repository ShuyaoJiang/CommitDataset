[+++ b/common/src/main/java/io/netty/util/Recycler.java, +import java.lang.ref.WeakReference;, +import java.util.Arrays;, +import java.util.WeakHashMap;, +import java.util.concurrent.atomic.AtomicInteger;, +    private static final AtomicInteger ID_GENERATOR = new AtomicInteger(Integer.MIN_VALUE);, +    private static final int OWN_THREAD_ID = ID_GENERATOR.getAndIncrement();, +    @SuppressWarnings("unchecked"), +        DefaultHandle<T> handle = stack.pop();, +        if (handle == null) {, +            handle = stack.newHandle();, +            handle.value = newObject(handle);, +        return (T) handle.value;, +        DefaultHandle<T> h = (DefaultHandle<T>) handle;, +        if (h.stack.parent != this) {, +        h.recycle(o);, +    static final class DefaultHandle<T> implements Handle<T> {, +        private int lastRecycledId;, +        private int recycleId;, +        private Stack<?> stack;, +        private Object value;, +        DefaultHandle(Stack<?> stack) {, +            this.stack = stack;, +        }, +        @Override, +        public void recycle(Object object) {, +            if (object != value) {, +                throw new IllegalArgumentException("object does not belong to handle");, +            }, +            Thread thread = Thread.currentThread();, +            if (thread == stack.thread) {, +                stack.push(this);, +                return;, +            }, +            // we don't want to have a ref to the queue as the value in our weak map, +            // so we null it out; to ensure there are no races with restoring it later, +            // we impose a memory ordering here (no-op on x86), +            Map<Stack<?>, WeakOrderQueue> delayedRecycled = DELAYED_RECYCLED.get();, +            WeakOrderQueue queue = delayedRecycled.get(stack);, +            if (queue == null) {, +                delayedRecycled.put(stack, queue = new WeakOrderQueue(stack, thread));, +            }, +            queue.add(this);, +        }, +    }, +, +    private static final FastThreadLocal<Map<Stack<?>, WeakOrderQueue>> DELAYED_RECYCLED =, +            new FastThreadLocal<Map<Stack<?>, WeakOrderQueue>>() {, +        @Override, +        protected Map<Stack<?>, WeakOrderQueue> initialValue() {, +            return new WeakHashMap<Stack<?>, WeakOrderQueue>();, +        }, +    };, +, +    // a queue that makes only moderate guarantees about visibility: items are seen in the correct order,, +    // but we aren't absolutely guaranteed to ever see anything at all, thereby keeping the queue cheap to maintain, +    private static final class WeakOrderQueue {, +        private static final int LINK_CAPACITY = 16;, +, +        // Let Link extend AtomicInteger for intrinsics. The Link itself will be used as writerIndex., +        @SuppressWarnings("serial"), +        private static final class Link extends AtomicInteger {, +            private final DefaultHandle<?>[] elements = new DefaultHandle[LINK_CAPACITY];, +, +            private int readIndex;, +            private Link next;, +        }, +, +        // chain of data items, +        private Link head, tail;, +        // pointer to another queue of delayed items for the same stack, +        private WeakOrderQueue next;, +        private final WeakReference<Thread> owner;, +        private final int id = ID_GENERATOR.getAndIncrement();, +, +        public WeakOrderQueue(Stack<?> stack, Thread thread) {, +            head = tail = new Link();, +            owner = new WeakReference<Thread>(thread);, +            synchronized (stack) {, +                next = stack.head;, +                stack.head = this;, +            }, +        }, +, +        void add(DefaultHandle<?> handle) {, +            handle.lastRecycledId = id;, +, +            Link tail = this.tail;, +            int writeIndex;, +            if ((writeIndex = tail.get()) == LINK_CAPACITY) {, +                this.tail = tail = tail.next = new Link();, +                writeIndex = tail.get();, +            }, +            tail.elements[writeIndex] = handle;, +            handle.stack = null;, +            // we lazy set to ensure that setting stack to null appears before we unnull it in the owning thread;, +            // this also means we guarantee visibility of an element in the queue if we see the index updated, +            tail.lazySet(writeIndex + 1);, +        }, +]