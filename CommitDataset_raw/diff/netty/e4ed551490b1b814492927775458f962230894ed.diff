[+++ b/transport/src/main/java/io/netty/channel/embedded/AbstractEmbeddedChannel.java, +import io.netty.channel.Channel;, +/**, + * Base class for {@link Channel} implementations that are used in an embedded fashion., + *, + * @param <O>  the type of data that can be written to this {@link Channel}, + */, +public abstract class AbstractEmbeddedChannel<O> extends AbstractChannel {, +    /**, +     * Create a new instance, +     *, +     * @param lastOutboundBuffer    the last outbound buffer which will hold all the written data, +     * @param handlers              the @link ChannelHandler}s which will be add in the {@link ChannelPipeline}, +     */, +    /**, +     * Return the last inbound {@link MessageBuf} which will hold all the {@link Object}s that where received, +     * by this {@link Channel}, +     */, +    /**, +     * Return the last inbound {@link ByteBuf} which will hold all the bytes that where received, +     * by this {@link Channel}, +     */, +    /**, +     * Return received data from this {@link Channel}, +     */, +    /**, +     * Run all tasks that are pending in the {@link EventLoop} for this {@link Channel}, +     */, +    /**, +     * Check if there was any {@link Throwable} received and if so rethrow it., +     */, +    protected final void ensureOpen() {, +    /**, +     * Read data froum the outbound. This may return {@code null} if nothing is readable., +     */, +    public abstract O readOutbound();, +, +    /**, +     * Return the inbound buffer in which inbound messages are stored., +     */, +    public abstract Buf inboundBuffer();, +, +    /**, +     * Return the last outbound buffer in which all the written outbound messages are stored., +     */, +    public abstract Buf lastOutboundBuffer();, +, +    /**, +     * Mark this {@link Channel} as finished. Any futher try to write data to it will fail., +     *, +     *, +     * @return bufferReadable returns {@code true} if any of the used buffers has something left to read, +     */, +    public boolean finish() {, +        close();, +        runPendingTasks();, +        checkException();, +        return lastInboundByteBuffer().readable() || !lastInboundMessageBuffer().isEmpty() ||, +                hasReadableOutboundBuffer();, +    }, +, +    /**, +     * Write data to the inbound of this {@link Channel}., +     *, +     * @param data              data that should be written, +     * @return bufferReadable   returns {@code true} if the write operation did add something to the the inbound buffer, +     */, +    public boolean writeInbound(O data) {, +        ensureOpen();, +        writeInbound0(data);, +        pipeline().fireInboundBufferUpdated();, +        runPendingTasks();, +        checkException();, +        return lastInboundByteBuffer().readable() || !lastInboundMessageBuffer().isEmpty();, +    }, +, +    /**, +     * Write data to the outbound of this {@link Channel}., +     *, +     * @param data              data that should be written, +     * @return bufferReadable   returns {@code true} if the write operation did add something to the the outbound buffer, +     */, +    public boolean writeOutbound(Object data) {, +        ensureOpen();, +        write(data);, +        runPendingTasks();, +        checkException();, +        return hasReadableOutboundBuffer();, +    }, +, +    /**, +     * Returns {@code true} if the outbound buffer hold some data which can be read, +     */, +    protected abstract boolean hasReadableOutboundBuffer();, +, +    /**, +     * Add the data to the inbound buffer., +     */, +    protected abstract void writeInbound0(O data);, +]