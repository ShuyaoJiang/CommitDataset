[+++ b/handler/src/main/java/io/netty/handler/ssl/SslHandler.java, +import io.netty.util.concurrent.FutureListener;, +import io.netty.util.concurrent.Promise;, +import io.netty.util.internal.OneTimeTask;, +    private Promise<Channel> handshakePromise = new LazyChannelPromise();, +     * Returns a {@link Future} that will get notified once the current TLS handshake completes., +     *, +     * @return the {@link Future} for the iniital TLS handshake if {@link #renegotiate()} was not invoked., +     *         The {@link Future} for the most recent {@linkplain #renegotiate() TLS renegotiation} otherwise., +     * Return the {@link Future} that will get notified if the inbound of the {@link SSLEngine} is closed., +     * This method will return the same {@link Future} all the time., +     * @see SSLEngine, +        handshakePromise.trySuccess(ctx.channel());, +, +            // Begin the initial handshake., +            handshake(null);, +    /**, +     * Performs TLS renegotiation., +     */, +    public Future<Channel> renegotiate() {, +        ChannelHandlerContext ctx = this.ctx;, +        if (ctx == null) {, +            throw new IllegalStateException();, +        return renegotiate(ctx.executor().<Channel>newPromise());, +    }, +, +    /**, +     * Performs TLS renegotiation., +     */, +    public Future<Channel> renegotiate(final Promise<Channel> promise) {, +        if (promise == null) {, +            throw new NullPointerException("promise");, +        }, +, +        ChannelHandlerContext ctx = this.ctx;, +        if (ctx == null) {, +            throw new IllegalStateException();, +        }, +, +        EventExecutor executor = ctx.executor();, +        if (!executor.inEventLoop()) {, +            executor.execute(new OneTimeTask() {, +                public void run() {, +                    handshake(promise);, +                }, +            });, +            return promise;, +        }, +, +        handshake(promise);, +        return promise;, +    }, +, +    /**, +     * Performs TLS (re)negotiation., +     *, +     * @param newHandshakePromise if {@code null}, use the existing {@link #handshakePromise},, +     *                            assuming that the current negotiation has not been finished., +     *                            Currently, {@code null} is expected only for the initial handshake., +     */, +    private void handshake(final Promise<Channel> newHandshakePromise) {, +        final Promise<Channel> p;, +        if (newHandshakePromise != null) {, +            final Promise<Channel> oldHandshakePromise = handshakePromise;, +            if (!oldHandshakePromise.isDone()) {, +                // There's no need to handshake because handshake is in progress already., +                // Merge the new promise into the old one., +                oldHandshakePromise.addListener(new FutureListener<Channel>() {, +                    @Override, +                    public void operationComplete(Future<Channel> future) throws Exception {, +                        if (future.isSuccess()) {, +                            newHandshakePromise.setSuccess(future.getNow());, +                        } else {, +                            newHandshakePromise.setFailure(future.cause());, +                return;, +            }, +, +            handshakePromise = p = newHandshakePromise;, +        } else {, +            // Forced to reuse the old handshake., +            p = handshakePromise;, +            assert !p.isDone();, +        }, +, +        // Begin handshake., +        final ChannelHandlerContext ctx = this.ctx;, +, +        // Set timeout if necessary., +        final long handshakeTimeoutMillis = this.handshakeTimeoutMillis;, +        if (handshakeTimeoutMillis <= 0 || p.isDone()) {, +            return;, +        }, +, +        final ScheduledFuture<?> timeoutFuture = ctx.executor().schedule(new Runnable() {, +            @Override, +            public void run() {, +                if (p.isDone()) {, +                    return;, +                }, +                notifyHandshakeFailure(HANDSHAKE_TIMED_OUT);]