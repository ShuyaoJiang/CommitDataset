[+++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, +import io.netty.util.Signal;, +import io.netty.util.internal.PlatformDependent;, +    public int forEachByte(ByteBufProcessor processor) {, +        int index = readerIndex;, +        int length = writerIndex - index;, +        return forEach0(index, length, processor);, +    }, +, +    @Override, +    public int forEachByte(int index, int length, ByteBufProcessor processor) {, +        checkIndex(index, length);, +        return forEach0(index, length, processor);, +    }, +, +    private int forEach0(int index, int length, ByteBufProcessor processor) {, +        if (processor == null) {, +            throw new NullPointerException("processor");, +        }, +, +        if (length == 0) {, +            return -1;, +        }, +, +        final int end = index + length;, +        int i = index;, +        try {, +            do {, +                i += processor.process(this, i, _getByte(i));, +            } while (i < end);, +        } catch (Signal signal) {, +            signal.expect(ByteBufProcessor.ABORT);, +            return i;, +        } catch (Exception e) {, +            PlatformDependent.throwException(e);, +        }, +, +        return -1;, +    }, +, +    @Override, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, +import io.netty.util.Signal;, +import io.netty.util.internal.PlatformDependent;, +    public int forEachByte(ByteBufProcessor processor) {, +        int index = readerIndex;, +        int length = writerIndex - index;, +        return forEach0(index, length, processor);, +    }, +, +    @Override, +    public int forEachByte(int index, int length, ByteBufProcessor processor) {, +        checkIndex(index, length);, +        return forEach0(index, length, processor);, +    }, +, +    private int forEach0(int index, int length, ByteBufProcessor processor) {, +        if (processor == null) {, +            throw new NullPointerException("processor");, +        }, +, +        if (length == 0) {, +            return -1;, +        }, +, +        final int end = index + length;, +        int i = index;, +        try {, +            do {, +                i += processor.process(this, i, _getByte(i));, +            } while (i < end);, +        } catch (Signal signal) {, +            signal.expect(ByteBufProcessor.ABORT);, +            return i;, +        } catch (Exception e) {, +            PlatformDependent.throwException(e);, +        }, +, +        return -1;, +    }, +, +    @Override, +++ b/buffer/src/main/java/io/netty/buffer/ByteBuf.java, +     * Iterates over the readable bytes of this buffer with the specified {@code processor}., +     *, +     * @return {@code -1} if the processor iterated to or beyond the end of the readable bytes., +     *         If the {@code processor} raised {@link ByteBufProcessor#ABORT}, the last-visited index will be returned., +     */, +    int forEachByte(ByteBufProcessor processor);, +, +    /**, +     * Iterates over the specified area of this buffer with the specified {@code processor}., +     *, +     * @return {@code -1} if the processor iterated to or beyond the end of the specified area., +     *         If the {@code processor} raised {@link ByteBufProcessor#ABORT}, the last-visited index will be returned., +     */, +    int forEachByte(int index, int length, ByteBufProcessor processor);, +, +    /**, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java]