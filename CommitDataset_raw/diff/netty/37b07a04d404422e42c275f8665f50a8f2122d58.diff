[+++ b/buffer/src/main/java/io/netty/buffer/PoolChunk.java, +    private static final int ST_UNUSED = 0;, +    private static final int ST_BRANCH = 1;, +    private static final int ST_ALLOCATED = 2;, +    private static final int ST_ALLOCATED_SUBPAGE = 3;, +    private final int[] memoryMap;, +, +        int chunkSizeInPages = chunkSize >>> pageShifts;, +        memoryMap = new int[maxSubpageAllocs << 1];, +        for (int i = 0; i <= maxOrder; i ++) {, +            int runSizeInPages = chunkSizeInPages >>> i;, +            for (int j = 0; j < chunkSizeInPages; j += runSizeInPages) {, +                //noinspection PointlessBitwiseExpression, +                memoryMap[memoryMapIndex ++] = j << 17 | runSizeInPages << 2 | ST_UNUSED;, +        int firstVal = memoryMap[1];, +            return allocateRun(normCapacity, 1, firstVal);, +            return allocateSubpage(normCapacity, 1, firstVal);, +    private long allocateRun(int normCapacity, int curIdx, int val) {, +        switch (val & 3) {, +            case ST_UNUSED:, +                return allocateRunSimple(normCapacity, curIdx, val);, +            case ST_BRANCH:, +                // Try the right node first because it is more likely to be ST_UNUSED., +                // It is because allocateRunSimple() always chooses the left node., +                final int nextIdxLeft = curIdx << 1;, +                final int nextIdxRight = nextIdxLeft ^ 1;, +                final int nextValRight = memoryMap[nextIdxRight];, +                final boolean recurseRight;, +, +                switch (nextValRight & 3) {, +                    case ST_UNUSED:, +                        return allocateRunSimple(normCapacity, nextIdxRight, nextValRight);, +                    case ST_BRANCH:, +                        recurseRight = true;, +                        break;, +                    default:, +                        recurseRight = false;, +                }, +, +                final int nextValLeft = memoryMap[nextIdxLeft];, +                final boolean recurseLeft;, +, +                switch (nextValLeft & 3) {, +                    case ST_UNUSED:, +                        return allocateRunSimple(normCapacity, nextIdxLeft, nextValLeft);, +                    case ST_BRANCH:, +                        recurseLeft = true;, +                        break;, +                    default:, +                        recurseLeft = false;, +                }, +, +                if (recurseRight) {, +                    long res = branchRun(normCapacity, nextIdxRight);, +                    if (res > 0) {, +                        return res;, +                if (recurseLeft) {, +                    return branchRun(normCapacity, nextIdxLeft);, +, +    private long branchRun(int normCapacity, int nextIdx) {, +        int nextNextIdx = nextIdx << 1;, +        int nextNextVal = memoryMap[nextNextIdx];, +        long res = allocateRun(normCapacity, nextNextIdx, nextNextVal);, +        if (res > 0) {, +            return res;, +        nextNextIdx ^= 1;, +        nextNextVal = memoryMap[nextNextIdx];, +        return allocateRun(normCapacity, nextNextIdx, nextNextVal);, +    private long allocateRunSimple(int normCapacity, int curIdx, int val) {, +        int runLength = runLength(val);, +        if (normCapacity > runLength) {, +            return -1;, +        for (;;) {, +            if (normCapacity == runLength) {, +                // Found the run that fits., +                // Note that capacity has been normalized already, so we don't need to deal with, +                // the values that are not power of 2., +                memoryMap[curIdx] = val & ~3 | ST_ALLOCATED;, +                freeBytes -= runLength;, +                return curIdx;, +            int nextIdx = curIdx << 1;, +            int unusedIdx = nextIdx ^ 1;, +, +            memoryMap[curIdx] = val & ~3 | ST_BRANCH;, +            //noinspection PointlessBitwiseExpression, +            memoryMap[unusedIdx] = memoryMap[unusedIdx] & ~3 | ST_UNUSED;, +, +            runLength >>>= 1;, +            curIdx = nextIdx;, +            val = memoryMap[curIdx];, +        }, +    }, +, +    private long allocateSubpage(int normCapacity, int curIdx, int val) {, +        switch (val & 3) {, +            case ST_UNUSED:, +                return allocateSubpageSimple(normCapacity, curIdx, val);, +            case ST_BRANCH:, +                // Try the right node first because it is more likely to be ST_UNUSED., +                // It is because allocateSubpageSimple() always chooses the left node.]