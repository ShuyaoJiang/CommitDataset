[+++ b/common/src/main/java/io/netty/util/concurrent/DefaultPromise.java, +                    this.listeners = null;, +++ b/common/src/main/java/io/netty/util/concurrent/DefaultPromise.java, +                    this.listeners = null;, +++ b/common/src/test/java/io/netty/util/concurrent/DefaultPromiseTest.java, +import java.util.concurrent.CountDownLatch;, +import java.util.concurrent.TimeUnit;, +        EventExecutor executor = new TestEventExecutor();, +        int runs = 100000;, +, +    @Test, +    public void testListenerNotifyLater() throws Exception {, +        // Testing first execution path in DefaultPromise, +        testListenerNotifyLater(1);, +, +        // Testing second execution path in DefaultPromise, +        testListenerNotifyLater(2);, +    }, +, +    private static void testListenerNotifyLater(final int numListenersBefore) throws Exception {, +        EventExecutor executor = new TestEventExecutor();, +        int expectedCount = numListenersBefore + 2;, +        final CountDownLatch latch = new CountDownLatch(expectedCount);, +        final FutureListener<Void> listener = new FutureListener<Void>() {, +            @Override, +            public void operationComplete(Future<Void> future) throws Exception {, +                latch.countDown();, +            }, +        };, +        final Promise<Void> promise = new DefaultPromise<Void>(executor);, +        executor.execute(new Runnable() {, +            @Override, +            public void run() {, +                for (int i = 0; i < numListenersBefore; i++) {, +                    promise.addListener(listener);, +                }, +                promise.setSuccess(null);, +, +                GlobalEventExecutor.INSTANCE.execute(new Runnable() {, +                    @Override, +                    public void run() {, +                        promise.addListener(listener);, +                    }, +                });, +                promise.addListener(listener);, +            }, +        });, +, +        assertTrue("Should have notifed " + expectedCount + " listeners", latch.await(5, TimeUnit.SECONDS));, +        executor.shutdownGracefully().sync();, +    }, +, +    private static final class TestEventExecutor extends SingleThreadEventExecutor {, +        TestEventExecutor() {, +            super(null, Executors.defaultThreadFactory(), true);, +        }, +, +        @Override, +        protected void run() {, +            for (;;) {, +                Runnable task = takeTask();, +                if (task != null) {, +                    task.run();, +                    updateLastExecutionTime();, +                }, +, +                if (confirmShutdown()) {, +                    break;, +                }, +            }, +        }, +    }]