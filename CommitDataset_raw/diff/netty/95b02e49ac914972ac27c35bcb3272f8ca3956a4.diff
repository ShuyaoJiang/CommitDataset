[+++ b/transport/src/main/java/io/netty/channel/AdaptiveRecvByteBufAllocator.java, +, +    @Override, +    public AdaptiveRecvByteBufAllocator respectMaybeMoreData(boolean respectMaybeMoreData) {, +        super.respectMaybeMoreData(respectMaybeMoreData);, +        return this;, +    }, +++ b/transport/src/main/java/io/netty/channel/AdaptiveRecvByteBufAllocator.java, +, +    @Override, +    public AdaptiveRecvByteBufAllocator respectMaybeMoreData(boolean respectMaybeMoreData) {, +        super.respectMaybeMoreData(respectMaybeMoreData);, +        return this;, +    }, +++ b/transport/src/main/java/io/netty/channel/DefaultMaxMessagesRecvByteBufAllocator.java, +    private volatile boolean respectMaybeMoreData = true;, +     * Determine if future instances of {@link #newHandle()} will stop reading if we think there is no more data., +     * @param respectMaybeMoreData, +     * <ul>, +     *     <li>{@code true} to stop reading if we think there is no more data. This may save a system call to read from, +     *          the socket, but if data has arrived in a racy fashion we may give up our {@link #maxMessagesPerRead()}, +     *          quantum and have to wait for the selector to notify us of more data.</li>, +     *     <li>{@code false} to keep reading (up to {@link #maxMessagesPerRead()}) or until there is no data when we, +     *          attempt to read.</li>, +     * </ul>, +     * @return {@code this}., +     */, +    public DefaultMaxMessagesRecvByteBufAllocator respectMaybeMoreData(boolean respectMaybeMoreData) {, +        this.respectMaybeMoreData = respectMaybeMoreData;, +        return this;, +    }, +, +    /**, +     * Get if future instances of {@link #newHandle()} will stop reading if we think there is no more data., +     * @return, +     * <ul>, +     *     <li>{@code true} to stop reading if we think there is no more data. This may save a system call to read from, +     *          the socket, but if data has arrived in a racy fashion we may give up our {@link #maxMessagesPerRead()}, +     *          quantum and have to wait for the selector to notify us of more data.</li>, +     *     <li>{@code false} to keep reading (up to {@link #maxMessagesPerRead()}) or until there is no data when we, +     *          attempt to read.</li>, +     * </ul>, +     */, +    public final boolean respectMaybeMoreData() {, +        return respectMaybeMoreData;, +    }, +, +    /**, +        private final boolean respectMaybeMoreData = DefaultMaxMessagesRecvByteBufAllocator.this.respectMaybeMoreData;, +                   (!respectMaybeMoreData || maybeMoreDataSupplier.get()) &&, +++ b/transport/src/main/java/io/netty/channel/AdaptiveRecvByteBufAllocator.java, +, +    @Override, +    public AdaptiveRecvByteBufAllocator respectMaybeMoreData(boolean respectMaybeMoreData) {, +        super.respectMaybeMoreData(respectMaybeMoreData);, +        return this;, +    }, +++ b/transport/src/main/java/io/netty/channel/DefaultMaxMessagesRecvByteBufAllocator.java, +    private volatile boolean respectMaybeMoreData = true;, +     * Determine if future instances of {@link #newHandle()} will stop reading if we think there is no more data., +     * @param respectMaybeMoreData, +     * <ul>, +     *     <li>{@code true} to stop reading if we think there is no more data. This may save a system call to read from, +     *          the socket, but if data has arrived in a racy fashion we may give up our {@link #maxMessagesPerRead()}, +     *          quantum and have to wait for the selector to notify us of more data.</li>, +     *     <li>{@code false} to keep reading (up to {@link #maxMessagesPerRead()}) or until there is no data when we, +     *          attempt to read.</li>, +     * </ul>, +     * @return {@code this}., +     */, +    public DefaultMaxMessagesRecvByteBufAllocator respectMaybeMoreData(boolean respectMaybeMoreData) {, +        this.respectMaybeMoreData = respectMaybeMoreData;, +        return this;, +    }, +, +    /**, +     * Get if future instances of {@link #newHandle()} will stop reading if we think there is no more data., +     * @return, +     * <ul>, +     *     <li>{@code true} to stop reading if we think there is no more data. This may save a system call to read from, +     *          the socket, but if data has arrived in a racy fashion we may give up our {@link #maxMessagesPerRead()}, +     *          quantum and have to wait for the selector to notify us of more data.</li>, +     *     <li>{@code false} to keep reading (up to {@link #maxMessagesPerRead()}) or until there is no data when we, +     *          attempt to read.</li>, +     * </ul>, +     */, +    public final boolean respectMaybeMoreData() {, +        return respectMaybeMoreData;, +    }, +, +    /**, +        private final boolean respectMaybeMoreData = DefaultMaxMessagesRecvByteBufAllocator.this.respectMaybeMoreData;, +                   (!respectMaybeMoreData || maybeMoreDataSupplier.get()) &&, +++ b/transport/src/main/java/io/netty/channel/FixedRecvByteBufAllocator.java, +, +    @Override, +    public FixedRecvByteBufAllocator respectMaybeMoreData(boolean respectMaybeMoreData) {, +        super.respectMaybeMoreData(respectMaybeMoreData);, +        return this;, +    }]