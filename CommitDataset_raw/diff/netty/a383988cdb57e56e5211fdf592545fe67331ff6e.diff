[+++ b/transport/src/main/java/io/netty/channel/ChannelOutboundBuffer.java, +    private static final int INITIAL_CAPACITY = 32;, +, +    // A circular buffer used to store messages.  The buffer is arranged such that:  flushed <= unflushed <= tail.  The, +    // flushed messages are stored in the range [flushed, unflushed).  Unflushed messages are stored in the range, +    // [unflushed, tail)., +    private Entry[] buffer;, +    private int flushed;, +    private int unflushed;, +        buffer = new Entry[INITIAL_CAPACITY];, +        for (int i = 0; i < buffer.length; i++) {, +            buffer[i] = new Entry();, +        }, +, +        Entry e = buffer[tail++];, +        e.msg = msg;, +        e.pendingSize = size;, +        e.promise = promise;, +        e.total = total(msg);, +, +        tail &= buffer.length - 1;, +, +        if (tail == flushed) {, +            addCapacity();, +        }, +    private void addCapacity() {, +        int p = flushed;, +        int n = buffer.length;, +        int s = size();, +, +        Entry[] e = new Entry[newCapacity];, +        System.arraycopy(buffer, p, e, 0, r);, +        System.arraycopy(buffer, 0, e, r, p);, +        for (int i = n; i < e.length; i++) {, +            e[i] = new Entry();, +        }, +        buffer = e;, +        flushed = 0;, +        unflushed = s;, +    void addFlush() {, +        this.unflushed = this.tail;, +    }, +, +    private static long total(Object msg) {, +        if (msg instanceof ByteBuf) {, +            return ((ByteBuf) msg).readableBytes();, +        }, +        if (msg instanceof FileRegion) {, +            return ((FileRegion) msg).count();, +        }, +        if (msg instanceof ByteBufHolder) {, +            return ((ByteBufHolder) msg).content().readableBytes();, +        }, +        return -1;, +    }, +, +        if (isEmpty()) {, +            return null;, +        } else {, +            return buffer[flushed].msg;, +        }, +        Entry e = buffer[flushed];, +        ChannelPromise p = e.promise;, +            long progress = e.progress + amount;, +            e.progress = progress;, +            ((ChannelProgressivePromise) p).tryProgress(progress, e.total);, +        if (isEmpty()) {, +            return false;, +        }, +        Entry e = buffer[this.flushed];, +        Object msg = e.msg;, +        ChannelPromise promise = e.promise;, +        int size = e.pendingSize;, +, +        e.clear();, +, +        this.flushed = flushed + 1 & buffer.length - 1;, +, +        if (isEmpty()) {, +            return false;, +        }, +        Entry e = buffer[this.flushed];, +        Object msg = e.msg;, +        ChannelPromise promise = e.promise;, +        int size = e.pendingSize;, +, +        e.clear();, +, +        this.flushed = flushed + 1 & buffer.length - 1;, +, +        final int mask = buffer.length - 1;, +        int i = flushed;, +        while (i != unflushed && (m = buffer[i].msg) != null) {, +                    buffer[i].msg = directBuf;, +        return unflushed - flushed & buffer.length - 1;, +        return unflushed == flushed;, +        if (!isEmpty()) {, +        final int unflushedCount = this.tail - this.unflushed & buffer.length - 1;, +                Entry e = buffer[unflushed + i & buffer.length - 1];, +                safeRelease(e.msg);]