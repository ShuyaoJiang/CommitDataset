[+++ b/handler/src/main/java/io/netty/handler/timeout/IdleStateHandler.java, +        if (ctx.getPipeline().isAttached()) {, +            // channelOpen event has been fired already, which means, +            // this.channelOpen() will not be invoked., +            // We have to initialize here instead., +        } else {, +            // channelOpen event has not been fired yet., +            // this.channelOpen() will be invoked and initialization will occur there., +        }, +    public void channelOpen(ChannelHandlerContext ctx, ChannelStateEvent e), +            throws Exception {, +        // This method will be invoked only if this handler was added, +        // before channelOpen event is fired.  If a user adds this handler, +        // after the channelOpen event, initialize() will be called by beforeAdd()., +        initialize(ctx);, +        ctx.sendUpstream(e);, +    }, +, +    @Override, +++ b/handler/src/main/java/io/netty/handler/timeout/IdleStateHandler.java, +        if (ctx.getPipeline().isAttached()) {, +            // channelOpen event has been fired already, which means, +            // this.channelOpen() will not be invoked., +            // We have to initialize here instead., +        } else {, +            // channelOpen event has not been fired yet., +            // this.channelOpen() will be invoked and initialization will occur there., +        }, +    public void channelOpen(ChannelHandlerContext ctx, ChannelStateEvent e), +            throws Exception {, +        // This method will be invoked only if this handler was added, +        // before channelOpen event is fired.  If a user adds this handler, +        // after the channelOpen event, initialize() will be called by beforeAdd()., +        initialize(ctx);, +        ctx.sendUpstream(e);, +    }, +, +    @Override, +++ b/handler/src/main/java/io/netty/handler/timeout/ReadTimeoutHandler.java, +        State state = state(ctx);, +, +        // Avoid the case where destroy() is called before scheduling timeouts., +        // See: https://github.com/netty/netty/issues/143, +        if (state.destroyed) {, +            return;, +        }, +, +        State state;, +        synchronized (ctx) {, +            state = state(ctx);, +            state.destroyed = true;, +        }, +, +    private State state(ChannelHandlerContext ctx) {, +        State state;, +        synchronized (ctx) {, +            // FIXME: It could have been better if there is setAttachmentIfAbsent()., +            state = (State) ctx.getAttachment();, +            if (state != null) {, +                return state;, +            }, +            state = new State();, +            ctx.setAttachment(state);, +        }, +        return state;, +    }, +, +        volatile boolean destroyed;]