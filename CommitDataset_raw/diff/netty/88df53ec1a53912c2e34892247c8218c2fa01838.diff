[+++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, +    protected final void checkSrcIndex(int index, int length, int srcIndex, int srcCapacity) {, +        checkIndex(index, length);, +        if (srcIndex < 0 || srcIndex > srcCapacity - length) {, +            throw new IndexOutOfBoundsException(String.format(, +                    "srcIndex: %d, length: %d (expected: range(0, %d))", srcIndex, length, srcCapacity));, +        }, +    }, +, +    protected final void checkDstIndex(int index, int length, int dstIndex, int dstCapacity) {, +        checkIndex(index, length);, +        if (dstIndex < 0 || dstIndex > dstCapacity - length) {, +            throw new IndexOutOfBoundsException(String.format(, +                    "dstIndex: %d, length: %d (expected: range(0, %d))", dstIndex, length, dstCapacity));, +        }, +    }, +, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, +    protected final void checkSrcIndex(int index, int length, int srcIndex, int srcCapacity) {, +        checkIndex(index, length);, +        if (srcIndex < 0 || srcIndex > srcCapacity - length) {, +            throw new IndexOutOfBoundsException(String.format(, +                    "srcIndex: %d, length: %d (expected: range(0, %d))", srcIndex, length, srcCapacity));, +        }, +    }, +, +    protected final void checkDstIndex(int index, int length, int dstIndex, int dstCapacity) {, +        checkIndex(index, length);, +        if (dstIndex < 0 || dstIndex > dstCapacity - length) {, +            throw new IndexOutOfBoundsException(String.format(, +                    "dstIndex: %d, length: %d (expected: range(0, %d))", dstIndex, length, dstCapacity));, +        }, +    }, +, +++ b/buffer/src/main/java/io/netty/buffer/ByteBuf.java, +     * Returns {@code true} if and only if this buffer has a reference to the low-level memory address that points, +     * to the backing data., +     */, +    boolean hasMemoryAddress();, +, +    /**, +     * Returns the low-level memory address that point to the first byte of ths backing data., +     *, +     * @throws UnsupportedOperationException, +     *         if this buffer does not support accessing the low-level memory address, +     */, +    long memoryAddress();, +, +    /**, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, +    protected final void checkSrcIndex(int index, int length, int srcIndex, int srcCapacity) {, +        checkIndex(index, length);, +        if (srcIndex < 0 || srcIndex > srcCapacity - length) {, +            throw new IndexOutOfBoundsException(String.format(, +                    "srcIndex: %d, length: %d (expected: range(0, %d))", srcIndex, length, srcCapacity));, +        }, +    }, +, +    protected final void checkDstIndex(int index, int length, int dstIndex, int dstCapacity) {, +        checkIndex(index, length);, +        if (dstIndex < 0 || dstIndex > dstCapacity - length) {, +            throw new IndexOutOfBoundsException(String.format(, +                    "dstIndex: %d, length: %d (expected: range(0, %d))", dstIndex, length, dstCapacity));, +        }, +    }, +, +++ b/buffer/src/main/java/io/netty/buffer/ByteBuf.java, +     * Returns {@code true} if and only if this buffer has a reference to the low-level memory address that points, +     * to the backing data., +     */, +    boolean hasMemoryAddress();, +, +    /**, +     * Returns the low-level memory address that point to the first byte of ths backing data., +     *, +     * @throws UnsupportedOperationException, +     *         if this buffer does not support accessing the low-level memory address, +     */, +    long memoryAddress();, +, +    /**, +++ b/buffer/src/main/java/io/netty/buffer/DefaultCompositeByteBuf.java, +        checkIndex(offset, length);, +    public boolean hasMemoryAddress() {, +        if (components.size() == 1) {, +            return components.get(0).buf.hasMemoryAddress();, +        }, +        return false;, +    }, +, +    @Override, +    public long memoryAddress() {, +        if (components.size() == 1) {, +            return components.get(0).buf.memoryAddress();, +        }, +        throw new UnsupportedOperationException();, +    }, +, +    @Override, +        checkIndex(offset);]