[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpClientCodec.java, +    public void setSingleDecode(boolean singleDecode) {, +        decoder().setSingleDecode(singleDecode);, +    }, +, +    public boolean isSingleDecode() {, +        return decoder().isSingleDecode();, +    }, +, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpClientCodec.java, +    public void setSingleDecode(boolean singleDecode) {, +        decoder().setSingleDecode(singleDecode);, +    }, +, +    public boolean isSingleDecode() {, +        return decoder().isSingleDecode();, +    }, +, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker.java, +import io.netty.channel.ChannelFutureListener;, +import io.netty.channel.ChannelHandlerContext;, +import io.netty.channel.ChannelInboundByteHandler;, +import io.netty.channel.ChannelOutboundMessageHandler;, +import io.netty.channel.ChannelPipeline;, +import io.netty.handler.codec.http.FullHttpRequest;, +import io.netty.handler.codec.http.HttpClientCodec;, +import io.netty.handler.codec.http.HttpRequestEncoder;, +import io.netty.handler.codec.http.HttpResponseDecoder;, +    private void setHandshakeComplete() {, +    private void setActualSubprotocol(String actualSubprotocol) {, +    public final ChannelFuture handshake(Channel channel, final ChannelPromise promise) {, +        FullHttpRequest request =  newHandshakeRequest();, +        HttpResponseDecoder decoder = channel.pipeline().get(HttpResponseDecoder.class);, +        if (decoder == null) {, +            HttpClientCodec codec = channel.pipeline().get(HttpClientCodec.class);, +            if (codec == null) {, +               promise.setFailure(new IllegalStateException("ChannelPipeline does not contain " +, +                       "a HttpResponseDecoder or HttpClientCodec"));, +               return promise;, +            }, +            codec.setSingleDecode(true);, +        } else {, +            decoder.setSingleDecode(true);, +        }, +        channel.write(request).addListener(new ChannelFutureListener() {, +            @Override, +            public void operationComplete(ChannelFuture future) {, +                if (future.isSuccess()) {, +                    ChannelPipeline p = future.channel().pipeline();, +                    ChannelHandlerContext ctx = p.context(HttpRequestEncoder.class);, +                    if (ctx == null) {, +                        ctx = p.context(HttpClientCodec.class);, +                    }, +                    if (ctx == null) {, +                        promise.setFailure(new IllegalStateException("ChannelPipeline does not contain " +, +                                "a HttpRequestEncoder or HttpClientCodec"));, +                        return;, +                    }, +                    p.addAfter(ctx.name(), "ws-encoder", newWebSocketEncoder());, +, +                    promise.setSuccess();, +                } else {, +                    promise.setFailure(future.cause());, +                }, +            }, +        });, +        return promise;, +    }, +, +    /**, +     * Returns a new {@link FullHttpRequest) which will be used for the handshake., +     */, +    protected abstract FullHttpRequest newHandshakeRequest();, +    public final void finishHandshake(Channel channel, FullHttpResponse response) {, +        verify(response);, +        setActualSubprotocol(response.headers().get(HttpHeaders.Names.SEC_WEBSOCKET_PROTOCOL));, +        setHandshakeComplete();, +, +        ChannelPipeline p = channel.pipeline();, +        ChannelHandlerContext ctx = p.context(HttpRequestEncoder.class);, +        if (ctx == null) {, +            ctx = p.context(HttpClientCodec.class);, +            if (ctx == null) {, +                throw new IllegalStateException("ChannelPipeline does not contain " +, +                        "a HttpRequestEncoder or HttpClientCodec");, +            }, +            p.replaceAndForward(ctx.name(), "ws-decoder", newWebsocketDecoder());, +        } else {, +            p.remove(HttpRequestEncoder.class);, +            p.replaceAndForward(ctx.name(),, +                    "ws-decoder", newWebsocketDecoder());, +        }, +    }, +, +    /**, +     * Verfiy the {@link FullHttpResponse} and throws a {@link WebSocketHandshakeException} if something is wrong., +     */, +    protected abstract void verify(FullHttpResponse response);, +, +    /**]