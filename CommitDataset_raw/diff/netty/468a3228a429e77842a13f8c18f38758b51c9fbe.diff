[+++ b/buffer/src/main/java/io/netty/buffer/ChannelBuffer.java, + * <a href="http://en.wikipedia.org/wiki/Zero-based_numbering">zero-based indexing</a>., + * It means the index of the first byte is always {@code 0} and the index of the last byte is, + * always {@link #capacity() capacity - 1}.  For example, to iterate all bytes of a buffer, you, + * can do the following, regardless of its internal implementation:, +++ b/buffer/src/main/java/io/netty/buffer/ChannelBuffer.java, + * <a href="http://en.wikipedia.org/wiki/Zero-based_numbering">zero-based indexing</a>., + * It means the index of the first byte is always {@code 0} and the index of the last byte is, + * always {@link #capacity() capacity - 1}.  For example, to iterate all bytes of a buffer, you, + * can do the following, regardless of its internal implementation:, +++ b/buffer/src/main/java/io/netty/buffer/ChannelBuffers.java, +    public static ChannelBuffer dynamicBuffer(, +            ByteOrder endianness, int estimatedLength, ChannelBufferFactory factory) {, +    private static int firstIndexOf(, +            ChannelBuffer buffer, int fromIndex, int toIndex, ChannelBufferIndexFinder indexFinder) {, +    private static int lastIndexOf(, +            ChannelBuffer buffer, int fromIndex, int toIndex, ChannelBufferIndexFinder indexFinder) {, +++ b/buffer/src/main/java/io/netty/buffer/ChannelBuffer.java, + * <a href="http://en.wikipedia.org/wiki/Zero-based_numbering">zero-based indexing</a>., + * It means the index of the first byte is always {@code 0} and the index of the last byte is, + * always {@link #capacity() capacity - 1}.  For example, to iterate all bytes of a buffer, you, + * can do the following, regardless of its internal implementation:, +++ b/buffer/src/main/java/io/netty/buffer/ChannelBuffers.java, +    public static ChannelBuffer dynamicBuffer(, +            ByteOrder endianness, int estimatedLength, ChannelBufferFactory factory) {, +    private static int firstIndexOf(, +            ChannelBuffer buffer, int fromIndex, int toIndex, ChannelBufferIndexFinder indexFinder) {, +    private static int lastIndexOf(, +            ChannelBuffer buffer, int fromIndex, int toIndex, ChannelBufferIndexFinder indexFinder) {, +++ b/buffer/src/main/java/io/netty/buffer/DirectChannelBufferFactory.java, +    private final int preallocatedBufCapacity;, +    private ChannelBuffer preallocatedBEBuf;, +    private int preallocatedBEBufPos;, +    private ChannelBuffer preallocatedLEBuf;, +    private int preallocatedLEBufPos;, +                    "preallocatedBufCapacity must be greater than 0: " + preallocatedBufferCapacity);, +        preallocatedBufCapacity = preallocatedBufferCapacity;, +        if (capacity >= preallocatedBufCapacity) {, +            if (preallocatedBEBuf == null) {, +                preallocatedBEBuf = ChannelBuffers.directBuffer(ByteOrder.BIG_ENDIAN, preallocatedBufCapacity);, +                slice = preallocatedBEBuf.slice(0, capacity);, +                preallocatedBEBufPos = capacity;, +            } else if (preallocatedBEBuf.capacity() - preallocatedBEBufPos >= capacity) {, +                slice = preallocatedBEBuf.slice(preallocatedBEBufPos, capacity);, +                preallocatedBEBufPos += capacity;, +                preallocatedBEBuf = ChannelBuffers.directBuffer(ByteOrder.BIG_ENDIAN, preallocatedBufCapacity);, +                slice = preallocatedBEBuf.slice(0, capacity);, +                preallocatedBEBufPos = capacity;, +            if (preallocatedLEBuf == null) {, +                preallocatedLEBuf = ChannelBuffers.directBuffer(ByteOrder.LITTLE_ENDIAN, preallocatedBufCapacity);, +                slice = preallocatedLEBuf.slice(0, capacity);, +                preallocatedLEBufPos = capacity;, +            } else if (preallocatedLEBuf.capacity() - preallocatedLEBufPos >= capacity) {, +                slice = preallocatedLEBuf.slice(preallocatedLEBufPos, capacity);, +                preallocatedLEBufPos += capacity;, +                preallocatedLEBuf = ChannelBuffers.directBuffer(ByteOrder.LITTLE_ENDIAN, preallocatedBufCapacity);, +                slice = preallocatedLEBuf.slice(0, capacity);, +                preallocatedLEBufPos = capacity;, +++ b/buffer/src/main/java/io/netty/buffer/ChannelBuffer.java, + * <a href="http://en.wikipedia.org/wiki/Zero-based_numbering">zero-based indexing</a>., + * It means the index of the first byte is always {@code 0} and the index of the last byte is, + * always {@link #capacity() capacity - 1}.  For example, to iterate all bytes of a buffer, you, + * can do the following, regardless of its internal implementation:, +++ b/buffer/src/main/java/io/netty/buffer/ChannelBuffers.java, +    public static ChannelBuffer dynamicBuffer(, +            ByteOrder endianness, int estimatedLength, ChannelBufferFactory factory) {, +    private static int firstIndexOf(, +            ChannelBuffer buffer, int fromIndex, int toIndex, ChannelBufferIndexFinder indexFinder) {, +    private static int lastIndexOf(, +            ChannelBuffer buffer, int fromIndex, int toIndex, ChannelBufferIndexFinder indexFinder) {, +++ b/buffer/src/main/java/io/netty/buffer/DirectChannelBufferFactory.java, +    private final int preallocatedBufCapacity;, +    private ChannelBuffer preallocatedBEBuf;, +    private int preallocatedBEBufPos;, +    private ChannelBuffer preallocatedLEBuf;, +    private int preallocatedLEBufPos;, +                    "preallocatedBufCapacity must be greater than 0: " + preallocatedBufferCapacity);, +        preallocatedBufCapacity = preallocatedBufferCapacity;, +        if (capacity >= preallocatedBufCapacity) {, +            if (preallocatedBEBuf == null) {, +                preallocatedBEBuf = ChannelBuffers.directBuffer(ByteOrder.BIG_ENDIAN, preallocatedBufCapacity);, +                slice = preallocatedBEBuf.slice(0, capacity);, +                preallocatedBEBufPos = capacity;, +            } else if (preallocatedBEBuf.capacity() - preallocatedBEBufPos >= capacity) {, +                slice = preallocatedBEBuf.slice(preallocatedBEBufPos, capacity);, +                preallocatedBEBufPos += capacity;, +                preallocatedBEBuf = ChannelBuffers.directBuffer(ByteOrder.BIG_ENDIAN, preallocatedBufCapacity);, +                slice = preallocatedBEBuf.slice(0, capacity);, +                preallocatedBEBufPos = capacity;, +            if (preallocatedLEBuf == null) {, +                preallocatedLEBuf = ChannelBuffers.directBuffer(ByteOrder.LITTLE_ENDIAN, preallocatedBufCapacity);, +                slice = preallocatedLEBuf.slice(0, capacity);, +                preallocatedLEBufPos = capacity;, +            } else if (preallocatedLEBuf.capacity() - preallocatedLEBufPos >= capacity) {, +                slice = preallocatedLEBuf.slice(preallocatedLEBufPos, capacity);, +                preallocatedLEBufPos += capacity;, +                preallocatedLEBuf = ChannelBuffers.directBuffer(ByteOrder.LITTLE_ENDIAN, preallocatedBufCapacity);, +                slice = preallocatedLEBuf.slice(0, capacity);, +                preallocatedLEBufPos = capacity;, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpHeaders.java]