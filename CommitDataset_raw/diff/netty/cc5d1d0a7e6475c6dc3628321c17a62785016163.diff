[+++ b/handler/src/main/java/io/netty/handler/ssl/ReferenceCountedOpenSslEngine.java, +import javax.net.ssl.SNIHostName;, +    // Mark as volatile as accessed by checkSniHostnameMatch(...), +    private volatile Collection<SNIMatcher> matchers;, +, +, +                sslParameters.setSNIMatchers(matchers);, +                matchers = sslParameters.getSNIMatchers();, +    final boolean checkSniHostnameMatch(String hostname) {, +        Collection<SNIMatcher> matchers = this.matchers;, +        if (matchers != null && !matchers.isEmpty()) {, +            SNIHostName name = new SNIHostName(hostname);, +            for (SNIMatcher matcher: matchers) {, +                // type 0 is for hostname, +                if (matcher.getType() == 0 && matcher.matches(name)) {, +                    return true;, +                }, +            }, +            return false;, +        } else {, +            return true;, +        }, +    }, +, +++ b/handler/src/main/java/io/netty/handler/ssl/ReferenceCountedOpenSslEngine.java, +import javax.net.ssl.SNIHostName;, +    // Mark as volatile as accessed by checkSniHostnameMatch(...), +    private volatile Collection<SNIMatcher> matchers;, +, +, +                sslParameters.setSNIMatchers(matchers);, +                matchers = sslParameters.getSNIMatchers();, +    final boolean checkSniHostnameMatch(String hostname) {, +        Collection<SNIMatcher> matchers = this.matchers;, +        if (matchers != null && !matchers.isEmpty()) {, +            SNIHostName name = new SNIHostName(hostname);, +            for (SNIMatcher matcher: matchers) {, +                // type 0 is for hostname, +                if (matcher.getType() == 0 && matcher.matches(name)) {, +                    return true;, +                }, +            }, +            return false;, +        } else {, +            return true;, +        }, +    }, +, +++ b/handler/src/main/java/io/netty/handler/ssl/ReferenceCountedOpenSslServerContext.java, +import io.netty.internal.tcnative.SniHostNameMatcher;, +import io.netty.util.internal.PlatformDependent;, +import io.netty.util.internal.logging.InternalLogger;, +import io.netty.util.internal.logging.InternalLoggerFactory;, +    private static final InternalLogger logger =, +            InternalLoggerFactory.getInstance(ReferenceCountedOpenSslServerContext.class);, +, +            if (PlatformDependent.javaVersion() >= 8) {, +                // Only do on Java8+ as SNIMatcher is not supported in earlier releases., +                // IMPORTANT: The callbacks set for hostname matching must be static to prevent memory leak as, +                //            otherwise the context can never be collected. This is because the JNI code holds, +                //            a global reference to the matcher., +                SSLContext.setSniHostnameMatcher(ctx, new OpenSslSniHostnameMatcher(engineMap));, +            }, +, +    private static final class OpenSslSniHostnameMatcher implements SniHostNameMatcher {, +        private final OpenSslEngineMap engineMap;, +, +        OpenSslSniHostnameMatcher(OpenSslEngineMap engineMap) {, +            this.engineMap = engineMap;, +        }, +, +        @Override, +        public boolean match(long ssl, String hostname) {, +            ReferenceCountedOpenSslEngine engine = engineMap.get(ssl);, +            if (engine != null) {, +                return engine.checkSniHostnameMatch(hostname);, +            }, +            logger.warn("No ReferenceCountedOpenSslEngine found for SSL pointer " + ssl);, +            return false;, +        }, +    }, +++ b/handler/src/main/java/io/netty/handler/ssl/ReferenceCountedOpenSslEngine.java, +import javax.net.ssl.SNIHostName;, +    // Mark as volatile as accessed by checkSniHostnameMatch(...), +    private volatile Collection<SNIMatcher> matchers;, +, +, +                sslParameters.setSNIMatchers(matchers);, +                matchers = sslParameters.getSNIMatchers();, +    final boolean checkSniHostnameMatch(String hostname) {, +        Collection<SNIMatcher> matchers = this.matchers;, +        if (matchers != null && !matchers.isEmpty()) {, +            SNIHostName name = new SNIHostName(hostname);, +            for (SNIMatcher matcher: matchers) {, +                // type 0 is for hostname, +                if (matcher.getType() == 0 && matcher.matches(name)) {, +                    return true;, +                }, +            }, +            return false;]