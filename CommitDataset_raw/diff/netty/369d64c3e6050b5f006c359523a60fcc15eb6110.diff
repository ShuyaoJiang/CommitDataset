[+++ b/resolver-dns/src/main/java/io/netty/resolver/dns/DnsAddressResolveContext.java, +++ b/resolver-dns/src/main/java/io/netty/resolver/dns/DnsAddressResolveContext.java, +++ b/resolver-dns/src/main/java/io/netty/resolver/dns/DnsRecordResolveContext.java, +++ b/resolver-dns/src/main/java/io/netty/resolver/dns/DnsAddressResolveContext.java, +++ b/resolver-dns/src/main/java/io/netty/resolver/dns/DnsRecordResolveContext.java, +++ b/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java, +                public void operationComplete(Future<List<T>> future) {, +            if (!query(hostname, expectedTypes[i], nameServerAddressStream.duplicate(), promise)) {, +        query(hostname, expectedTypes[end], nameServerAddressStream, promise);, +    private void onResponse(final DnsServerAddressStream nameServerAddrStream, final int nameServerAddrStreamIndex,, +                    onResponseCNAME(question, buildAliasMap(envelope.content()), queryLifecycleObserver, promise);, +        if (cnames.isEmpty()) {, +            queryLifecycleObserver.querySucceed();, +            // We also got a CNAME so we need to ensure we also query it., +            onResponseCNAME(question, cnames,, +                    parent.dnsQueryLifecycleObserverFactory().newDnsQueryLifecycleObserver(question), promise);, +    private void tryToFinishResolve(final DnsServerAddressStream nameServerAddrStream,, +, +            // There are still some queries in process, we will try to notify once the next one finishes until, +            // all are finished., +                query(hostname, DnsRecordType.CNAME, getNameServers(hostname), promise);, +                          Promise<List<T>> promise) {, +        query(dnsServerAddressStream, 0, question, promise, null);, +++ b/resolver-dns/src/main/java/io/netty/resolver/dns/DnsAddressResolveContext.java, +++ b/resolver-dns/src/main/java/io/netty/resolver/dns/DnsRecordResolveContext.java, +++ b/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java, +                public void operationComplete(Future<List<T>> future) {, +            if (!query(hostname, expectedTypes[i], nameServerAddressStream.duplicate(), promise)) {, +        query(hostname, expectedTypes[end], nameServerAddressStream, promise);, +    private void onResponse(final DnsServerAddressStream nameServerAddrStream, final int nameServerAddrStreamIndex,, +                    onResponseCNAME(question, buildAliasMap(envelope.content()), queryLifecycleObserver, promise);, +        if (cnames.isEmpty()) {, +            queryLifecycleObserver.querySucceed();, +            // We also got a CNAME so we need to ensure we also query it., +            onResponseCNAME(question, cnames,, +                    parent.dnsQueryLifecycleObserverFactory().newDnsQueryLifecycleObserver(question), promise);, +    private void tryToFinishResolve(final DnsServerAddressStream nameServerAddrStream,, +, +            // There are still some queries in process, we will try to notify once the next one finishes until, +            // all are finished., +                query(hostname, DnsRecordType.CNAME, getNameServers(hostname), promise);, +                          Promise<List<T>> promise) {, +        query(dnsServerAddressStream, 0, question, promise, null);, +++ b/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java, +import java.util.LinkedHashSet;, +    public void testQueryMx() {, +, +    @Test, +    public void testFollowCNAMEEvenIfARecordIsPresent() throws IOException {, +        TestDnsServer dnsServer2 = new TestDnsServer(new RecordStore() {, +, +            @Override, +            public Set<ResourceRecord> getRecords(QuestionRecord question) {, +                if (question.getDomainName().equals("cname.netty.io")) {, +                    Map<String, Object> map1 = new HashMap<String, Object>();, +                    map1.put(DnsAttribute.IP_ADDRESS.toLowerCase(), "10.0.0.99");, +                    return Collections.<ResourceRecord>singleton(, +                            new TestDnsServer.TestResourceRecord(question.getDomainName(), RecordType.A, map1));, +                } else {, +                    Set<ResourceRecord> records = new LinkedHashSet<ResourceRecord>(2);, +                    Map<String, Object> map = new HashMap<String, Object>();, +                    map.put(DnsAttribute.DOMAIN_NAME.toLowerCase(), "cname.netty.io");, +                    records.add(new TestDnsServer.TestResourceRecord(, +                            question.getDomainName(), RecordType.CNAME, map));, +, +                    Map<String, Object> map1 = new HashMap<String, Object>();, +                    map1.put(DnsAttribute.IP_ADDRESS.toLowerCase(), "10.0.0.2");, +                    records.add(new TestDnsServer.TestResourceRecord(, +                            question.getDomainName(), RecordType.A, map1));, +                    return records;, +                }, +            }, +        });, +        dnsServer2.start();, +        DnsNameResolver resolver = null;, +        try {, +            DnsNameResolverBuilder builder = newResolver(), +                    .recursionDesired(true), +                    .resolvedAddressTypes(ResolvedAddressTypes.IPV4_ONLY), +                    .maxQueriesPerResolve(16), +                    .nameServerProvider(new SingletonDnsServerAddressStreamProvider(dnsServer2.localAddress()));, +, +            resolver = builder.build();, +            List<InetAddress> resolvedAddresses =, +                    resolver.resolveAll("somehost.netty.io").syncUninterruptibly().getNow();, +            assertEquals(2, resolvedAddresses.size());, +            assertTrue(resolvedAddresses.contains(InetAddress.getByAddress(new byte[] { 10, 0, 0, 99 })));, +            assertTrue(resolvedAddresses.contains(InetAddress.getByAddress(new byte[] { 10, 0, 0, 2 })));, +        } finally {, +            dnsServer2.stop();, +            if (resolver != null) {, +                resolver.close();, +            }, +        }, +    }]