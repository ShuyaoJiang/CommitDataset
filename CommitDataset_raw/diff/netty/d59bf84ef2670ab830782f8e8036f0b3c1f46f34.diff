[+++ b/transport/src/main/java/io/netty/channel/AbstractChannel.java, +            deregister(voidPromise(), wasActive && !isActive());, +           deregister(promise, false);, +        }, +, +        private void deregister(final ChannelPromise promise, final boolean fireChannelInactive) {, +            // As a user may call deregister() from within any method while doing processing in the ChannelPipeline,, +            // we need to ensure we do the actual deregister operation later. This is needed as for example,, +            // we may be in the ByteToMessageDecoder.callDecode(...) method and so still try to do processing in, +            // the old EventLoop while the user already registered the Channel to a new EventLoop. Without delay,, +            // the deregister operation this could lead to have a handler invoked by different EventLoop and so, +            // threads., +            //, +            // See:, +            // https://github.com/netty/netty/issues/4435, +            invokeLater(new OneTimeTask() {, +                @Override, +                public void run() {, +                        if (fireChannelInactive) {, +                            pipeline.fireChannelInactive();, +                        // close() calls deregister() again - no need to fire channelUnregistered, so check, +                        // if it was registered., +                        if (registered) {, +                            registered = false;, +                            pipeline.fireChannelUnregistered();, +                        }, +            });]