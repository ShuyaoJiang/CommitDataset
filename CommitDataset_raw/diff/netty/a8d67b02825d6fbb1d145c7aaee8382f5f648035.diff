[+++ b/transport/src/main/java/io/netty/channel/AbstractChannel.java, +                if (!outboundBuffer.isEmpty()) {, +                    // fail all queued messages, +                outboundBuffer.clearUnflushed();, +, +                    MessageList messages = outboundBuffer.currentMessageList;, +                        messages = outboundBuffer.currentMessageList;, +++ b/transport/src/main/java/io/netty/channel/AbstractChannel.java, +                if (!outboundBuffer.isEmpty()) {, +                    // fail all queued messages, +                outboundBuffer.clearUnflushed();, +, +                    MessageList messages = outboundBuffer.currentMessageList;, +                        messages = outboundBuffer.currentMessageList;, +++ b/transport/src/main/java/io/netty/channel/ChannelOutboundBuffer.java, +    MessageList currentMessageList;, +    private MessageList[] messageLists;, +    private MessageList unflushedMessageList;, +    private long unflushedMessageListSize;, +, +, +        messageLists = new MessageList[initialCapacity];, +        messageListSizes = new long[initialCapacity];, +        MessageList unflushedMessageList = this.unflushedMessageList;, +        if (unflushedMessageList == null) {, +            this.unflushedMessageList = unflushedMessageList = MessageList.newInstance();, +        unflushedMessageList.add(msg, promise);, +        unflushedMessageListSize += size;, +        MessageList unflushedMessageList = this.unflushedMessageList;, +        if (unflushedMessageList == null) {, +        int tail = this.tail;, +, +        messageLists[tail] = unflushedMessageList;, +        messageListSizes[tail] = unflushedMessageListSize;, +        this.unflushedMessageList = null;, +        unflushedMessageListSize = 0;, +, +        if ((this.tail = (tail + 1) & (messageLists.length - 1)) == head) {, +        int n = messageLists.length;, +        System.arraycopy(messageLists, p, a1, 0, r);, +        System.arraycopy(messageLists, 0, a1, r, p);, +        messageLists = a1;, +        MessageList e = messageLists[h]; // Element is null if deque empty, +            currentMessageList = null;, +        currentMessageList = messageLists[h];, +        messageLists[h] = null;, +        head = h + 1 & messageLists.length - 1;, +        return tail - head & messageLists.length - 1;, +    void clearUnflushed() {, +        MessageList unflushed = unflushedMessageList;, +        if (unflushed == null) {, +            return;, +        }, +, +        // Release all unflushed messages., +        Object[] messages = unflushed.messages();, +        ChannelPromise[] promises = unflushed.promises();, +        final int size = unflushed.size();, +        Throwable flushAborted = null;, +        try {, +            for (int i = 0; i < size; i++) {, +                ReferenceCountUtil.release(messages[i]);, +                ChannelPromise p = promises[i];, +                if (!(p instanceof VoidChannelPromise)) {, +                    if (flushAborted == null) {, +                        flushAborted = new ChannelException("write() aborted without flush()");, +                    }, +                    if (!p.tryFailure(flushAborted)) {, +                        logger.warn("Promise done already: {} - new exception is:", p, flushAborted);, +                    }, +                }, +            }, +        } finally {, +            unflushed.recycle();, +            decrementPendingOutboundBytes(unflushedMessageListSize);, +            unflushedMessageListSize = 0;, +            if (currentMessageList == null) {, +                if (currentMessageList != null) {, +                    MessageList current = currentMessageList;, +                    Object[] messages = current.messages();, +                    ChannelPromise[] promises = current.promises();, +                    final int size = current.size();]