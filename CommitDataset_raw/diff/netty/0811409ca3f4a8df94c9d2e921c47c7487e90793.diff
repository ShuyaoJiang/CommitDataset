[+++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, +        if (checkAccessible && !isAccessible()) {, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, +        if (checkAccessible && !isAccessible()) {, +++ b/buffer/src/main/java/io/netty/buffer/AbstractDerivedByteBuf.java, +    final boolean isAccessible() {, +        return unwrap().isAccessible();, +    }, +, +    @Override, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, +        if (checkAccessible && !isAccessible()) {, +++ b/buffer/src/main/java/io/netty/buffer/AbstractDerivedByteBuf.java, +    final boolean isAccessible() {, +        return unwrap().isAccessible();, +    }, +, +    @Override, +++ b/buffer/src/main/java/io/netty/buffer/AbstractReferenceCountedByteBuf.java, +    boolean isAccessible() {, +, +        // This is copied explicitly from the nonVolatileRawCnt() method above to reduce call stack depth,, +        // to avoid hitting the default limit for inlining (9), +        final int rawCnt = REFCNT_FIELD_OFFSET != -1 ? PlatformDependent.getInt(this, REFCNT_FIELD_OFFSET), +                : refCntUpdater.get(this);, +, +        // The "real" ref count is > 0 if the rawCnt is even., +        // (x & y) appears to be surprisingly expensive relative to (x == y). Thus the expression below provides, +        // a fast path for most common cases where the ref count is 1, 2, 3 or 4., +        return rawCnt == 2 || rawCnt == 4 || rawCnt == 6 || rawCnt == 8 || (rawCnt & 1) == 0;, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, +        if (checkAccessible && !isAccessible()) {, +++ b/buffer/src/main/java/io/netty/buffer/AbstractDerivedByteBuf.java, +    final boolean isAccessible() {, +        return unwrap().isAccessible();, +    }, +, +    @Override, +++ b/buffer/src/main/java/io/netty/buffer/AbstractReferenceCountedByteBuf.java, +    boolean isAccessible() {, +, +        // This is copied explicitly from the nonVolatileRawCnt() method above to reduce call stack depth,, +        // to avoid hitting the default limit for inlining (9), +        final int rawCnt = REFCNT_FIELD_OFFSET != -1 ? PlatformDependent.getInt(this, REFCNT_FIELD_OFFSET), +                : refCntUpdater.get(this);, +, +        // The "real" ref count is > 0 if the rawCnt is even., +        // (x & y) appears to be surprisingly expensive relative to (x == y). Thus the expression below provides, +        // a fast path for most common cases where the ref count is 1, 2, 3 or 4., +        return rawCnt == 2 || rawCnt == 4 || rawCnt == 6 || rawCnt == 8 || (rawCnt & 1) == 0;, +++ b/buffer/src/main/java/io/netty/buffer/ByteBuf.java, +, +    /**, +     * Used internally by {@link AbstractByteBuf#ensureAccessible()} to try to guard, +     * against using the buffer after it was released (best-effort)., +     */, +    boolean isAccessible() {, +        return refCnt() != 0;, +    }, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, +        if (checkAccessible && !isAccessible()) {, +++ b/buffer/src/main/java/io/netty/buffer/AbstractDerivedByteBuf.java, +    final boolean isAccessible() {, +        return unwrap().isAccessible();, +    }, +, +    @Override, +++ b/buffer/src/main/java/io/netty/buffer/AbstractReferenceCountedByteBuf.java, +    boolean isAccessible() {, +, +        // This is copied explicitly from the nonVolatileRawCnt() method above to reduce call stack depth,, +        // to avoid hitting the default limit for inlining (9), +        final int rawCnt = REFCNT_FIELD_OFFSET != -1 ? PlatformDependent.getInt(this, REFCNT_FIELD_OFFSET), +                : refCntUpdater.get(this);, +, +        // The "real" ref count is > 0 if the rawCnt is even., +        // (x & y) appears to be surprisingly expensive relative to (x == y). Thus the expression below provides, +        // a fast path for most common cases where the ref count is 1, 2, 3 or 4., +        return rawCnt == 2 || rawCnt == 4 || rawCnt == 6 || rawCnt == 8 || (rawCnt & 1) == 0;, +++ b/buffer/src/main/java/io/netty/buffer/ByteBuf.java, +, +    /**, +     * Used internally by {@link AbstractByteBuf#ensureAccessible()} to try to guard, +     * against using the buffer after it was released (best-effort)., +     */, +    boolean isAccessible() {, +        return refCnt() != 0;, +    }, +++ b/buffer/src/main/java/io/netty/buffer/CompositeByteBuf.java, +        if (checkAccessible && !buf.isAccessible()) {, +        checkIndex(index, 2);, +        _setShort(index, value);, +        checkIndex(index, 3);, +        _setMedium(index, value);, +        checkIndex(index, 4);, +        _setInt(index, value);, +        checkIndex(index, 8);, +        _setLong(index, value);, +        super.writeBytes(src, 0, src.length);, +    boolean isAccessible() {]