[+++ b/handler/src/main/java/io/netty/handler/ssl/CipherSuiteConverter.java, +/*, + * Copyright 2014 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + *   http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the, + * License for the specific language governing permissions and limitations, + * under the License., + */, +, +package io.netty.handler.ssl;, +, +import io.netty.util.internal.EmptyArrays;, +import io.netty.util.internal.PlatformDependent;, +import io.netty.util.internal.logging.InternalLogger;, +import io.netty.util.internal.logging.InternalLoggerFactory;, +, +import javax.net.ssl.SSLContext;, +import java.security.NoSuchAlgorithmException;, +import java.util.HashMap;, +import java.util.Map;, +import java.util.concurrent.ConcurrentMap;, +import java.util.regex.Matcher;, +import java.util.regex.Pattern;, +, +/**, + * Converts a Java cipher suite string to an OpenSSL cipher suite string and vice versa., + *, + * @see <a href="http://en.wikipedia.org/wiki/Cipher_suite">Wikipedia page about cipher suite</a>, + */, +final class CipherSuiteConverter {, +, +    private static final InternalLogger logger = InternalLoggerFactory.getInstance(CipherSuiteConverter.class);, +, +    /**, +     * A_B_WITH_C_D, where:, +     *, +     * A - TLS or SSL (protocol), +     * B - handshake algorithm (key exchange and authentication algorithms to be precise), +     * C - bulk cipher, +     * D - HMAC algorithm, +     *, +     * This regular expression assumees that:, +     *, +     * 1) A is always TLS or SSL, and, +     * 2) D is always a single word., +     */, +    private static final Pattern JAVA_CIPHERSUITE_PATTERN =, +            Pattern.compile("^(?:TLS|SSL)_((?:(?!_WITH_).)+)_WITH_(.*)_(.*)$");, +, +    /**, +     * A-B-C, where:, +     *, +     * A - handshake algorithm (key exchange and authentication algorithms to be precise), +     * B - bulk cipher, +     * C - HMAC algorithm, +     *, +     * This regular expression assumes that:, +     *, +     * 1) A has some deterministic pattern as shown below, and, +     * 2) C is always a single word, +     */, +    private static final Pattern OPENSSL_CIPHERSUITE_PATTERN =, +            // Be very careful not to break the indentation while editing., +            Pattern.compile(, +                    "^(?:(" + // BEGIN handshake algorithm, +                        "(?:(?:EXP-)?" +, +                            "(?:" +, +                                "(?:DHE|EDH|ECDH|ECDHE)-(?:DSS|RSA|ECDSA)|" +, +                                "(?:ADH|AECDH|KRB5|PSK)" +, +                            ')' +, +                        ")|" +, +                        "EXP" +, +                    ")-)?" +  // END handshake algorithm, +                    "(.*)-(.*)$");, +, +    private static final Pattern JAVA_AES_CBC_PATTERN = Pattern.compile("^(AES)_([0-9]+)_CBC$");, +    private static final Pattern JAVA_AES_PATTERN = Pattern.compile("^(AES)_([0-9]+)_(.*)$");, +    private static final Pattern OPENSSL_AES_CBC_PATTERN = Pattern.compile("^(AES)([0-9]+)$");, +    private static final Pattern OPENSSL_AES_PATTERN = Pattern.compile("^(AES)([0-9]+)-(.*)$");, +, +    /**, +     * Java-to-OpenSSL cipher suite conversion map, +     * Note that the Java cipher suite has the protocol prefix (TLS_, SSL_), +     */, +    private static final ConcurrentMap<String, String> j2o = PlatformDependent.newConcurrentHashMap();, +, +    /**, +     * OpenSSL-to-Java cipher suite conversion map., +     * Note that one OpenSSL cipher suite can be converted to more than one Java cipher suites because, +     * a Java cipher suite has the protocol name prefix (TLS_, SSL_), +     */, +    private static final ConcurrentMap<String, Map<String, String>> o2j = PlatformDependent.newConcurrentHashMap();]