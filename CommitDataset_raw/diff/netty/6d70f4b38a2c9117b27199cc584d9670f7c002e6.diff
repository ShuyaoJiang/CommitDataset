[+++ b/transport/src/main/java/io/netty/channel/PendingWriteQueue.java, +     * Remove all pending write operation and performs them via, +     * {@link ChannelHandlerContext#write(Object, ChannelPromise)}., +     *, +     * @return  {@link ChannelFuture} if something was written and {@code null}, +     *          if the {@link PendingWriteQueue} is empty., +     */, +    public ChannelFuture removeAndWriteAll() {, +        assert ctx.executor().inEventLoop();, +, +        if (isEmpty()) {, +            return null;, +        }, +, +        ChannelPromise p = ctx.newPromise();, +        PromiseCombiner combiner = new PromiseCombiner();, +        try {, +            // It is possible for some of the written promises to trigger more writes. The new writes, +            // will "revive" the queue, so we need to write them up until the queue is empty., +            for (PendingWrite write = head; write != null; write = head) {, +                head = tail = null;, +                size = 0;, +                bytes = 0;, +, +                while (write != null) {, +                    PendingWrite next = write.next;, +                    Object msg = write.msg;, +                    ChannelPromise promise = write.promise;, +                    recycle(write, false);, +                    combiner.add(promise);, +                    ctx.write(msg, promise);, +                    write = next;, +                }, +            }, +            combiner.finish(p);, +        } catch (Throwable cause) {, +            p.setFailure(cause);, +        }, +        assertEmpty();, +        return p;, +    }, +, +    /**, +++ b/transport/src/main/java/io/netty/channel/PendingWriteQueue.java, +     * Remove all pending write operation and performs them via, +     * {@link ChannelHandlerContext#write(Object, ChannelPromise)}., +     *, +     * @return  {@link ChannelFuture} if something was written and {@code null}, +     *          if the {@link PendingWriteQueue} is empty., +     */, +    public ChannelFuture removeAndWriteAll() {, +        assert ctx.executor().inEventLoop();, +, +        if (isEmpty()) {, +            return null;, +        }, +, +        ChannelPromise p = ctx.newPromise();, +        PromiseCombiner combiner = new PromiseCombiner();, +        try {, +            // It is possible for some of the written promises to trigger more writes. The new writes, +            // will "revive" the queue, so we need to write them up until the queue is empty., +            for (PendingWrite write = head; write != null; write = head) {, +                head = tail = null;, +                size = 0;, +                bytes = 0;, +, +                while (write != null) {, +                    PendingWrite next = write.next;, +                    Object msg = write.msg;, +                    ChannelPromise promise = write.promise;, +                    recycle(write, false);, +                    combiner.add(promise);, +                    ctx.write(msg, promise);, +                    write = next;, +                }, +            }, +            combiner.finish(p);, +        } catch (Throwable cause) {, +            p.setFailure(cause);, +        }, +        assertEmpty();, +        return p;, +    }, +, +    /**, +++ b/transport/src/test/java/io/netty/channel/PendingWriteQueueTest.java, +    public void testRemoveAndWriteAllReentrantWrite() {, +        EmbeddedChannel channel = new EmbeddedChannel(new ChannelOutboundHandlerAdapter() {, +            @Override, +            public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) {, +                // Convert to writeAndFlush(...) so the promise will be notified by the transport., +                ctx.writeAndFlush(msg, promise);, +            }, +        }, new ChannelOutboundHandlerAdapter());, +, +        final PendingWriteQueue queue = new PendingWriteQueue(channel.pipeline().lastContext());, +, +        ChannelPromise promise = channel.newPromise();, +        final ChannelPromise promise3 = channel.newPromise();]