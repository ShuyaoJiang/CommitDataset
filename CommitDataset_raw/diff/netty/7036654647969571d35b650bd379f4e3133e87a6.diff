[+++ b/src/main/java/org/jboss/netty/buffer/ByteBufferBackedChannelBuffer.java, +import java.nio.CharBuffer;, +import java.nio.charset.CharacterCodingException;, +import java.nio.charset.CharsetDecoder;, +import java.nio.charset.CoderResult;, +, +import org.jboss.netty.util.CharsetUtil;, +        if (length == 0) {, +            return "";, +        }, +, +        final CharsetDecoder decoder = CharsetUtil.getDecoder(charset);, +        final ByteBuffer src =, +            ((ByteBuffer) buffer.duplicate().position(, +                    index).limit(index + length)).order(order());, +        final CharBuffer dst = CharBuffer.allocate(, +                (int) ((double) length * decoder.maxCharsPerByte()));, +            CoderResult cr = decoder.decode(src, dst, true);, +            if (!cr.isUnderflow()) {, +                cr.throwException();, +            cr = decoder.flush(dst);, +            if (!cr.isUnderflow()) {, +                cr.throwException();, +        } catch (CharacterCodingException x) {, +            throw new IllegalStateException(x);, +, +        dst.flip();, +        return dst.toString();, +++ b/src/main/java/org/jboss/netty/buffer/ByteBufferBackedChannelBuffer.java, +import java.nio.CharBuffer;, +import java.nio.charset.CharacterCodingException;, +import java.nio.charset.CharsetDecoder;, +import java.nio.charset.CoderResult;, +, +import org.jboss.netty.util.CharsetUtil;, +        if (length == 0) {, +            return "";, +        }, +, +        final CharsetDecoder decoder = CharsetUtil.getDecoder(charset);, +        final ByteBuffer src =, +            ((ByteBuffer) buffer.duplicate().position(, +                    index).limit(index + length)).order(order());, +        final CharBuffer dst = CharBuffer.allocate(, +                (int) ((double) length * decoder.maxCharsPerByte()));, +            CoderResult cr = decoder.decode(src, dst, true);, +            if (!cr.isUnderflow()) {, +                cr.throwException();, +            cr = decoder.flush(dst);, +            if (!cr.isUnderflow()) {, +                cr.throwException();, +        } catch (CharacterCodingException x) {, +            throw new IllegalStateException(x);, +, +        dst.flip();, +        return dst.toString();, +++ b/src/main/java/org/jboss/netty/buffer/ChannelBuffers.java, +import java.nio.CharBuffer;, +import java.nio.charset.CharacterCodingException;, +import java.nio.charset.CharsetEncoder;, +import java.nio.charset.CoderResult;, +import org.jboss.netty.util.CharsetUtil;, +, +     * {@code string} encoded in the specified {@code charset}., +    public static ChannelBuffer copiedBuffer(CharSequence string, Charset charset) {, +        return copiedBuffer(BIG_ENDIAN, string, 0, string.length(), charset);, +     * Creates a new big-endian buffer whose content is a subregion of, +     * the specified {@code string} encoded in the specified {@code charset}., +     * The new buffer's {@code readerIndex} and {@code writerIndex} are, +     * {@code 0} and the length of the encoded string respectively., +     */, +    public static ChannelBuffer copiedBuffer(, +            CharSequence string, int offset, int length, Charset charset) {, +        return copiedBuffer(BIG_ENDIAN, string, offset, length, charset);, +    }, +, +    /**, +     * Creates a new buffer with the specified {@code endianness} whose, +     * content is the specified {@code string} encoded in the specified, +     * {@code charset}.  The new buffer's {@code readerIndex} and, +     * {@code writerIndex} are {@code 0} and the length of the encoded string, +     * respectively., +     */, +    public static ChannelBuffer copiedBuffer(ByteOrder endianness, CharSequence string, Charset charset) {, +        return copiedBuffer(endianness, string, 0, string.length(), charset);, +    }, +, +    /**, +     * Creates a new buffer with the specified {@code endianness} whose, +     * content is a subregion of the specified {@code string} encoded in the, +     * specified {@code charset}.  The new buffer's {@code readerIndex} and, +     * {@code writerIndex} are {@code 0} and the length of the encoded string, +     * respectively., +     */, +    public static ChannelBuffer copiedBuffer(, +            ByteOrder endianness, CharSequence string, int offset, int length, Charset charset) {, +        if (string == null) {, +            throw new NullPointerException("string");, +        }, +        if (length == 0) {]