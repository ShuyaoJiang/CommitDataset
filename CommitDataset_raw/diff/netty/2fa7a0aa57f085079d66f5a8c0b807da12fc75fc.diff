[+++ b/resolver-dns/src/main/java/io/netty/resolver/dns/DefaultDnsCache.java, +import java.util.concurrent.Delayed;, +import java.util.concurrent.ScheduledFuture;, +import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;, +, +    private static final ScheduledFuture<?> CANCELLED = new ScheduledFuture<Object>() {, +, +        @Override, +        public boolean cancel(boolean mayInterruptIfRunning) {, +            return false;, +        }, +, +        @Override, +        public long getDelay(TimeUnit unit) {, +            // We ignore unit and always return the minimum value to ensure the TTL of the cancelled marker is, +            // the smallest., +            return Long.MIN_VALUE;, +        }, +, +        @Override, +        public int compareTo(Delayed o) {, +            throw new UnsupportedOperationException();, +        }, +, +        @Override, +        public boolean isCancelled() {, +            return true;, +        }, +, +        @Override, +        public boolean isDone() {, +            return true;, +        }, +, +        @Override, +        public Object get() {, +            throw new UnsupportedOperationException();, +        }, +, +        @Override, +        public Object get(long timeout, TimeUnit unit) {, +            throw new UnsupportedOperationException();, +        }, +    };, +, +    private static final AtomicReferenceFieldUpdater<DefaultDnsCache.Entries, ScheduledFuture> FUTURE_UPDATER =, +            AtomicReferenceFieldUpdater.newUpdater(, +                    DefaultDnsCache.Entries.class, ScheduledFuture.class, "expirationFuture");, +, +    private final ConcurrentMap<String, Entries> resolveCache = PlatformDependent.newConcurrentHashMap();, +                Math.max(minTtl, (int) Math.min(maxTtl, originalTtl)), loop);, +        cache0(appendDot(hostname), e, negativeTtl, loop);, +            entries = new Entries(hostname);, +        entries.add(e, ttl, loop);, +        String hostname() {, +            return hostname;, +    private final class Entries extends AtomicReference<List<DefaultDnsCacheEntry>> implements Runnable {, +        private final String hostname;, +        // Needs to be package-private to be able to access it via the AtomicReferenceFieldUpdater, +        volatile ScheduledFuture<?> expirationFuture;, +, +        Entries(String hostname) {, +            super(Collections.<DefaultDnsCacheEntry>emptyList());, +            this.hostname = hostname;, +        void add(DefaultDnsCacheEntry e, int ttl, EventLoop loop) {, +, +                                scheduleCacheExpirationIfNeeded(ttl, loop);, +                        int i = 0;, +                        do {, +                        } while (++i < entries.size());, +                        if (compareAndSet(entries, Collections.unmodifiableList(newEntries))) {, +                            scheduleCacheExpirationIfNeeded(ttl, loop);, +                        scheduleCacheExpirationIfNeeded(ttl, loop);, +                set(Collections.singletonList(e));, +                scheduleCacheExpirationIfNeeded(ttl, loop);, +            }, +        }, +, +        private void scheduleCacheExpirationIfNeeded(int ttl, EventLoop loop) {, +            for (;;) {, +                // We currently don't calculate a new TTL when we need to retry the CAS as we don't expect this to, +                // be invoked very concurrently and also we use SECONDS anyway. If this ever becomes a problem, +                // we can reconsider., +                ScheduledFuture<?> oldFuture = FUTURE_UPDATER.get(this);, +                if (oldFuture == null || oldFuture.getDelay(TimeUnit.SECONDS) > ttl) {, +                    ScheduledFuture<?> newFuture = loop.schedule(this, ttl, TimeUnit.SECONDS);, +                    // It is possible that, +                    // 1. task will fire in between this line, or, +                    // 2. multiple timers may be set if there is concurrency, +                    // (1) Shouldn't be a problem because we will fail the CAS and then the next loop will see CANCELLED, +                    //     so the ttl will not be less, and we will bail out of the loop., +                    // (2) This is a trade-off to avoid concurrency resulting in contention on a synchronized block., +                    if (FUTURE_UPDATER.compareAndSet(this, oldFuture, newFuture)) {, +                         if (oldFuture != null) {, +                            oldFuture.cancel(true);, +                         }, +                         break;, +                    } else {, +                        // There was something else scheduled in the meantime... Cancel and try again., +                       newFuture.cancel(true);]