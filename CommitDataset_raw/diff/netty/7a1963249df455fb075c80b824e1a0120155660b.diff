[+++ b/src/main/java/org/jboss/netty/channel/xnio/BaseXnioChannel.java, +import java.util.concurrent.atomic.AtomicInteger;, +import org.jboss.netty.buffer.ChannelBuffer;, +import org.jboss.netty.util.ThreadLocalBoolean;, +    final Queue<MessageEvent> writeBuffer = new WriteBuffer();, +    final AtomicInteger writeBufferSize = new AtomicInteger();, +    final AtomicInteger highWaterMarkCounter = new AtomicInteger();, +    public int getInterestOps() {, +        if (!isOpen()) {, +            return Channel.OP_WRITE;, +        }, +, +        int interestOps = getRawInterestOps();, +        int writeBufferSize = this.writeBufferSize.get();, +        if (writeBufferSize != 0) {, +            if (highWaterMarkCounter.get() > 0) {, +                int lowWaterMark = getConfig().getWriteBufferLowWaterMark();, +                if (writeBufferSize >= lowWaterMark) {, +                    interestOps |= Channel.OP_WRITE;, +                } else {, +                    interestOps &= ~Channel.OP_WRITE;, +                }, +            } else {, +                int highWaterMark = getConfig().getWriteBufferHighWaterMark();, +                if (writeBufferSize >= highWaterMark) {, +                    interestOps |= Channel.OP_WRITE;, +                } else {, +                    interestOps &= ~Channel.OP_WRITE;, +                }, +            }, +        } else {, +            interestOps &= ~Channel.OP_WRITE;, +        }, +, +        return interestOps;, +    }, +, +    int getRawInterestOps() {, +        return super.getInterestOps();, +    }, +, +    void setRawInterestOpsNow(int interestOps) {, +        super.setInterestOpsNow(interestOps);, +    }, +, +    @Override, +, +    private final class WriteBuffer extends LinkedTransferQueue<MessageEvent> {, +, +        private final ThreadLocalBoolean notifying = new ThreadLocalBoolean();, +, +        WriteBuffer() {, +            super();, +        }, +, +        @Override, +        public boolean offer(MessageEvent e) {, +            boolean success = super.offer(e);, +            assert success;, +, +            int messageSize = ((ChannelBuffer) e.getMessage()).readableBytes();, +            int newWriteBufferSize = writeBufferSize.addAndGet(messageSize);, +            int highWaterMark = getConfig().getWriteBufferHighWaterMark();, +, +            if (newWriteBufferSize >= highWaterMark) {, +                if (newWriteBufferSize - messageSize < highWaterMark) {, +                    highWaterMarkCounter.incrementAndGet();, +                    if (!notifying.get()) {, +                        notifying.set(Boolean.TRUE);, +                        fireChannelInterestChanged(BaseXnioChannel.this);, +                        notifying.set(Boolean.FALSE);, +                    }, +                }, +            }, +            return true;, +        }, +, +        @Override, +        public MessageEvent poll() {, +            MessageEvent e = super.poll();, +            if (e != null) {, +                int messageSize = ((ChannelBuffer) e.getMessage()).readableBytes();, +                int newWriteBufferSize = writeBufferSize.addAndGet(-messageSize);, +                int lowWaterMark = getConfig().getWriteBufferLowWaterMark();, +, +                if (newWriteBufferSize == 0 || newWriteBufferSize < lowWaterMark) {, +                    if (newWriteBufferSize + messageSize >= lowWaterMark) {, +                        highWaterMarkCounter.decrementAndGet();, +                        if (!notifying.get()) {, +                            notifying.set(Boolean.TRUE);, +                            fireChannelInterestChanged(BaseXnioChannel.this);, +                            notifying.set(Boolean.FALSE);, +                        }, +                    }, +                }, +            }, +            return e;, +        }, +    }, +++ b/src/main/java/org/jboss/netty/channel/xnio/BaseXnioChannel.java]