[+++ b/common/src/main/java/io/netty/util/concurrent/AbstractEventExecutor.java, +import io.netty.util.internal.logging.InternalLogger;, +import io.netty.util.internal.logging.InternalLoggerFactory;, +, +    private static final InternalLogger logger = InternalLoggerFactory.getInstance(AbstractEventExecutor.class);, +, +    /**, +     * Try to execute the given {@link Runnable} and just log if it throws a {@link Throwable}., +     */, +    protected static void safeExecute(Runnable task) {, +        try {, +            task.run();, +        } catch (Throwable t) {, +            logger.warn("A task raised an exception. Task: {}", task, t);, +        }, +    }, +++ b/common/src/main/java/io/netty/util/concurrent/AbstractEventExecutor.java, +import io.netty.util.internal.logging.InternalLogger;, +import io.netty.util.internal.logging.InternalLoggerFactory;, +, +    private static final InternalLogger logger = InternalLoggerFactory.getInstance(AbstractEventExecutor.class);, +, +    /**, +     * Try to execute the given {@link Runnable} and just log if it throws a {@link Throwable}., +     */, +    protected static void safeExecute(Runnable task) {, +        try {, +            task.run();, +        } catch (Throwable t) {, +            logger.warn("A task raised an exception. Task: {}", task, t);, +        }, +    }, +++ b/common/src/main/java/io/netty/util/concurrent/NonStickyEventExecutorGroup.java, +/*, + * Copyright 2016 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + *   http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the, + * License for the specific language governing permissions and limitations, + * under the License., + */, +package io.netty.util.concurrent;, +, +import io.netty.util.internal.ObjectUtil;, +import io.netty.util.internal.PlatformDependent;, +import io.netty.util.internal.UnstableApi;, +, +import java.util.Collection;, +import java.util.Iterator;, +import java.util.List;, +import java.util.Queue;, +import java.util.concurrent.Callable;, +import java.util.concurrent.ExecutionException;, +import java.util.concurrent.RejectedExecutionException;, +import java.util.concurrent.TimeUnit;, +import java.util.concurrent.TimeoutException;, +import java.util.concurrent.atomic.AtomicInteger;, +, +/**, + * {@link EventExecutorGroup} which will preserve {@link Runnable} execution order but makes no guarantees about what, + * {@link EventExecutor} (and therefore {@link Thread}) will be used to execute the {@link Runnable}s., + *, + * <p>The {@link EventExecutorGroup#next()} for the wrapped {@link EventExecutorGroup} must <strong>NOT</strong> return, + * executors of type {@link OrderedEventExecutor}., + */, +@UnstableApi, +public final class NonStickyEventExecutorGroup implements EventExecutorGroup {, +    private final EventExecutorGroup group;, +    private final int maxTaskExecutePerRun;, +, +    /**, +     * Creates a new instance. Be aware that the given {@link EventExecutorGroup} <strong>MUST NOT</strong> contain, +     * any {@link OrderedEventExecutor}s., +     */, +    public NonStickyEventExecutorGroup(EventExecutorGroup group) {, +        this(group, 1024);, +    }, +, +    /**, +     * Creates a new instance. Be aware that the given {@link EventExecutorGroup} <strong>MUST NOT</strong> contain, +     * any {@link OrderedEventExecutor}s., +     */, +    public NonStickyEventExecutorGroup(EventExecutorGroup group, int maxTaskExecutePerRun) {, +        this.group = verify(group);, +        this.maxTaskExecutePerRun = ObjectUtil.checkPositive(maxTaskExecutePerRun, "maxTaskExecutePerRun");, +    }, +, +    private static EventExecutorGroup verify(EventExecutorGroup group) {, +        Iterator<EventExecutor> executors = ObjectUtil.checkNotNull(group, "group").iterator();, +        while (executors.hasNext()) {, +            EventExecutor executor = executors.next();, +            if (executor instanceof OrderedEventExecutor) {, +                throw new IllegalArgumentException("EventExecutorGroup " + group]