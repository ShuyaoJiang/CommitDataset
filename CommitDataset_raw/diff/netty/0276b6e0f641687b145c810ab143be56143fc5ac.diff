[+++ b/common/src/main/java/io/netty/util/Recycler.java, +, +        // We store the Thread in a WeakReference as otherwise we may be the only ones that still hold a strong, +        // Reference to the Thread itself after it died because DefaultHandle will hold a reference to the Stack., +        //, +        // The biggest issue is if we do not use a WeakReference the Thread may not be able to be collected at all if, +        // the user will store a reference to the DefaultHandle somewhere and never clear this reference (or not clear, +        // it in a timely manner)., +        final WeakReference<Thread> threadRef;, +            threadRef = new WeakReference<Thread>(thread);, +            if (threadRef.get() == currentThread) {, +                // The current Thread is not the one that belongs to the Stack, +                // (or the Thread that belonged to the Stack was collected already), we need to signal that the push, +++ b/common/src/main/java/io/netty/util/Recycler.java, +, +        // We store the Thread in a WeakReference as otherwise we may be the only ones that still hold a strong, +        // Reference to the Thread itself after it died because DefaultHandle will hold a reference to the Stack., +        //, +        // The biggest issue is if we do not use a WeakReference the Thread may not be able to be collected at all if, +        // the user will store a reference to the DefaultHandle somewhere and never clear this reference (or not clear, +        // it in a timely manner)., +        final WeakReference<Thread> threadRef;, +            threadRef = new WeakReference<Thread>(thread);, +            if (threadRef.get() == currentThread) {, +                // The current Thread is not the one that belongs to the Stack, +                // (or the Thread that belonged to the Stack was collected already), we need to signal that the push, +++ b/common/src/test/java/io/netty/util/RecyclerTest.java, +import java.util.concurrent.atomic.AtomicBoolean;, +import java.util.concurrent.atomic.AtomicReference;, +    @Test(timeout = 5000L), +    public void testThreadCanBeCollectedEvenIfHandledObjectIsReferenced() throws Exception {, +        final Recycler<HandledObject> recycler = newRecycler(1024);, +        final AtomicBoolean collected = new AtomicBoolean();, +        final AtomicReference<HandledObject> reference = new AtomicReference<HandledObject>();, +        Thread thread = new Thread(new Runnable() {, +            @Override, +            public void run() {, +                HandledObject object = recycler.get();, +                // Store a reference to the HandledObject to ensure it is not collected when the run method finish., +                reference.set(object);, +            }, +        }) {, +            @Override, +            protected void finalize() throws Throwable {, +                super.finalize();, +                collected.set(true);, +            }, +        };, +        assertFalse(collected.get());, +        thread.start();, +        thread.join();, +, +        // Null out so it can be collected., +        thread = null;, +, +        // Loop until the Thread was collected. If we can not collect it the Test will fail due of a timeout., +        while (!collected.get()) {, +            System.gc();, +            System.runFinalization();, +            Thread.sleep(50);, +        }, +, +        // Now call recycle after the Thread was collected to ensure this still works..., +        reference.getAndSet(null).recycle();, +    }, +]