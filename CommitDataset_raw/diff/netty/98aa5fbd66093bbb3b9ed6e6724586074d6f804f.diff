[+++ b/buffer/src/main/java/io/netty/buffer/CompositeByteBuf.java, +        addComponents(false, 0, buffers);, +        return addComponent(increaseWriterIndex, componentCount, buffer);, +        return addComponents(increaseWriterIndex, componentCount, buffers);, +        // unwrap if already sliced, +    private CompositeByteBuf addComponents0(boolean increaseWriterIndex,, +            final int cIndex, ByteBuf[] buffers, int arrOffset) {, +        // only set ci after we've shifted so that finally block logic is always correct, +            for (ci = cIndex; arrOffset < len; arrOffset++, ci++) {, +                ByteBuf b = buffers[arrOffset];, +                if (b == null) {, +                    break;, +                }, +            return this;, +        return addComponents(false, cIndex, buffers);, +    private CompositeByteBuf addComponents(boolean increaseIndex, int cIndex, Iterable<ByteBuf> buffers) {, +            return addComponent(increaseIndex, cIndex, (ByteBuf) buffers);, +        consolidateIfNeeded();, +        return this;, +        comp.free();, +            c.free();, +                c.free();, +            if (localReadBytes == localLength) {, +                i ++;, +            if (localReadBytes == localLength) {, +                i ++;, +            if (localReadBytes == localLength) {, +                i ++;, +                components[i].free();, +            components[i].free();, +                components[i].free();, +            c.free();, +            c.free();, +            free();, +        void free() {, +            // null out in either case since it could be racy if set lazily (but not, +            // in the case we care about, where it will have been set in the ctor), +            components[i].free();]