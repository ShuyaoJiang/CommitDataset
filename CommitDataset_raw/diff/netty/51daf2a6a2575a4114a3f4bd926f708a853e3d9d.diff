[+++ b/transport/src/main/java/io/netty/channel/ChannelInboundMessageHandlerAdapter.java, +import io.netty.util.internal.Signal;, +    /**, +     * Thrown by {@link #messageReceived(ChannelHandlerContext, Object)} to abort message processing., +     */, +    protected static final Signal ABORT = new Signal(ChannelInboundMessageHandlerAdapter.class.getName() + ".ABORT");, +, +        MessageBuf<Object> in = ctx.inboundMessageBuffer();, +        if (in.isEmpty() || !beginMessageReceived(ctx)) {, +                } catch (Signal abort) {, +                    abort.expect(ABORT);, +                    break;, +++ b/transport/src/main/java/io/netty/channel/ChannelInboundMessageHandlerAdapter.java, +import io.netty.util.internal.Signal;, +    /**, +     * Thrown by {@link #messageReceived(ChannelHandlerContext, Object)} to abort message processing., +     */, +    protected static final Signal ABORT = new Signal(ChannelInboundMessageHandlerAdapter.class.getName() + ".ABORT");, +, +        MessageBuf<Object> in = ctx.inboundMessageBuffer();, +        if (in.isEmpty() || !beginMessageReceived(ctx)) {, +                } catch (Signal abort) {, +                    abort.expect(ABORT);, +                    break;, +++ b/transport/src/main/java/io/netty/channel/ChannelOutboundMessageHandlerAdapter.java, +import io.netty.util.internal.Signal;, +    /**, +     * Thrown by {@link #flush(ChannelHandlerContext, Object)} to abort message processing., +     */, +    protected static final Signal ABORT = new Signal(ChannelOutboundMessageHandlerAdapter.class.getName() + ".ABORT");, +, +        if (inSize == 0) {, +            ctx.flush(promise);, +            return;, +        }, +        int processed = 0;, +            PartialFlushException pfe;, +            String msg = processed + " out of " + inSize + " message(s) flushed";, +            if (t instanceof Signal) {, +                Signal abort = (Signal) t;, +                abort.expect(ABORT);, +                pfe = new PartialFlushException("aborted by " + getClass().getSimpleName() + ": " + msg);, +            } else {, +                pfe = new PartialFlushException(msg, t);, +            }, +            fail(ctx, promise, pfe);, +++ b/transport/src/main/java/io/netty/channel/ChannelInboundMessageHandlerAdapter.java, +import io.netty.util.internal.Signal;, +    /**, +     * Thrown by {@link #messageReceived(ChannelHandlerContext, Object)} to abort message processing., +     */, +    protected static final Signal ABORT = new Signal(ChannelInboundMessageHandlerAdapter.class.getName() + ".ABORT");, +, +        MessageBuf<Object> in = ctx.inboundMessageBuffer();, +        if (in.isEmpty() || !beginMessageReceived(ctx)) {, +                } catch (Signal abort) {, +                    abort.expect(ABORT);, +                    break;, +++ b/transport/src/main/java/io/netty/channel/ChannelOutboundMessageHandlerAdapter.java, +import io.netty.util.internal.Signal;, +    /**, +     * Thrown by {@link #flush(ChannelHandlerContext, Object)} to abort message processing., +     */, +    protected static final Signal ABORT = new Signal(ChannelOutboundMessageHandlerAdapter.class.getName() + ".ABORT");, +, +        if (inSize == 0) {, +            ctx.flush(promise);, +            return;, +        }, +        int processed = 0;, +            PartialFlushException pfe;, +            String msg = processed + " out of " + inSize + " message(s) flushed";, +            if (t instanceof Signal) {, +                Signal abort = (Signal) t;, +                abort.expect(ABORT);, +                pfe = new PartialFlushException("aborted by " + getClass().getSimpleName() + ": " + msg);, +            } else {, +                pfe = new PartialFlushException(msg, t);, +            }, +            fail(ctx, promise, pfe);, +++ b/transport/src/main/java/io/netty/channel/PartialFlushException.java, +    public PartialFlushException(String message) {, +        super(message);, +    }, +, +    public PartialFlushException(String message, Throwable cause) {, +        super(message, cause);]