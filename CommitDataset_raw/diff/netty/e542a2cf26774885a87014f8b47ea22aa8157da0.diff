[+++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, +        if (checkAccessible && internalRefCnt() == 0) {, +    /**, +     * Returns the reference count that is used internally by {@link #ensureAccessible()} to try to guard, +     * against using the buffer after it was released (best-effort)., +     */, +    int internalRefCnt() {, +        return refCnt();, +    }, +, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, +        if (checkAccessible && internalRefCnt() == 0) {, +    /**, +     * Returns the reference count that is used internally by {@link #ensureAccessible()} to try to guard, +     * against using the buffer after it was released (best-effort)., +     */, +    int internalRefCnt() {, +        return refCnt();, +    }, +, +++ b/buffer/src/main/java/io/netty/buffer/AbstractReferenceCountedByteBuf.java, +import io.netty.util.internal.PlatformDependent;, +    private static final long REFCNT_FIELD_OFFSET;, +    static {, +        long refCntFieldOffset = -1;, +        try {, +            if (PlatformDependent.hasUnsafe()) {, +                refCntFieldOffset = PlatformDependent.objectFieldOffset(, +                        AbstractReferenceCountedByteBuf.class.getDeclaredField("refCnt"));, +            }, +        } catch (Throwable ignore) {, +            refCntFieldOffset = -1;, +        }, +, +        REFCNT_FIELD_OFFSET = refCntFieldOffset;, +    }, +, +    int internalRefCnt() {, +        // Try to do non-volatile read for performance as the ensureAccessible() is racy anyway and only provide, +        // a best-effort guard., +        //, +        // TODO: Once we compile against later versions of Java we can replace the Unsafe usage here by varhandles., +        return REFCNT_FIELD_OFFSET != -1 ? PlatformDependent.getInt(this, REFCNT_FIELD_OFFSET) : refCnt();, +    }, +, +    @Override, +        }, +        if (oldRef < decrement || oldRef - decrement > oldRef) {, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, +        if (checkAccessible && internalRefCnt() == 0) {, +    /**, +     * Returns the reference count that is used internally by {@link #ensureAccessible()} to try to guard, +     * against using the buffer after it was released (best-effort)., +     */, +    int internalRefCnt() {, +        return refCnt();, +    }, +, +++ b/buffer/src/main/java/io/netty/buffer/AbstractReferenceCountedByteBuf.java, +import io.netty.util.internal.PlatformDependent;, +    private static final long REFCNT_FIELD_OFFSET;, +    static {, +        long refCntFieldOffset = -1;, +        try {, +            if (PlatformDependent.hasUnsafe()) {, +                refCntFieldOffset = PlatformDependent.objectFieldOffset(, +                        AbstractReferenceCountedByteBuf.class.getDeclaredField("refCnt"));, +            }, +        } catch (Throwable ignore) {, +            refCntFieldOffset = -1;, +        }, +, +        REFCNT_FIELD_OFFSET = refCntFieldOffset;, +    }, +, +    int internalRefCnt() {, +        // Try to do non-volatile read for performance as the ensureAccessible() is racy anyway and only provide, +        // a best-effort guard., +        //, +        // TODO: Once we compile against later versions of Java we can replace the Unsafe usage here by varhandles., +        return REFCNT_FIELD_OFFSET != -1 ? PlatformDependent.getInt(this, REFCNT_FIELD_OFFSET) : refCnt();, +    }, +, +    @Override, +        }, +        if (oldRef < decrement || oldRef - decrement > oldRef) {, +++ b/buffer/src/main/java/io/netty/buffer/WrappedCompositeByteBuf.java, +    int internalRefCnt() {, +        return wrapped.internalRefCnt();, +    }, +, +    @Override, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, +        if (checkAccessible && internalRefCnt() == 0) {, +    /**, +     * Returns the reference count that is used internally by {@link #ensureAccessible()} to try to guard, +     * against using the buffer after it was released (best-effort)., +     */, +    int internalRefCnt() {, +        return refCnt();]