[+++ b/src/main/java/org/jboss/netty/util/LinkedTransferQueue.java, +/*, + * JBoss, Home of Professional Open Source, + *, + * Copyright 2008, Red Hat Middleware LLC, and individual contributors, + * by the @author tags. See the COPYRIGHT.txt in the distribution for a, + * full listing of individual contributors., + *, + * This is free software; you can redistribute it and/or modify it, + * under the terms of the GNU Lesser General Public License as, + * published by the Free Software Foundation; either version 2.1 of, + * the License, or (at your option) any later version., + *, + * This software is distributed in the hope that it will be useful,, + * but WITHOUT ANY WARRANTY; without even the implied warranty of, + * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU, + * Lesser General Public License for more details., + *, + * You should have received a copy of the GNU Lesser General Public, + * License along with this software; if not, write to the Free, + * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA, + * 02110-1301 USA, or see the FSF site: http://www.fsf.org., + */, +, +/*, + * Written by Doug Lea with assistance from members of JCP JSR-166, + * Expert Group and released to the public domain, as explained at, + * http://creativecommons.org/licenses/publicdomain, + */, +, +package org.jboss.netty.util;, +import java.util.AbstractQueue;, +import java.util.Collection;, +import java.util.Iterator;, +import java.util.NoSuchElementException;, +import java.util.concurrent.BlockingQueue;, +import java.util.concurrent.TimeUnit;, +import java.util.concurrent.atomic.AtomicReference;, +import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;, +import java.util.concurrent.locks.LockSupport;, +, +/**, + * An unbounded {@linkplain BlockingQueue} based on linked nodes., + * This queue orders elements FIFO (first-in-first-out) with respect, + * to any given producer.  The <em>head</em> of the queue is that, + * element that has been on the queue the longest time for some, + * producer.  The <em>tail</em> of the queue is that element that has, + * been on the queue the shortest time for some producer., + *, + * <p>Beware that, unlike in most collections, the <tt>size</tt>, + * method is <em>NOT</em> a constant-time operation. Because of the, + * asynchronous nature of these queues, determining the current number, + * of elements requires a traversal of the elements., + *, + * <p>This class and its iterator implement all of the, + * <em>optional</em> methods of the {@link Collection} and {@link, + * Iterator} interfaces., + *, + * <p>Memory consistency effects: As with other concurrent, + * collections, actions in a thread prior to placing an object into a, + * {@code LinkedTransferQueue} <i>happen-before</i> actions subsequent, + * to the access or removal of that element from the, + * {@code LinkedTransferQueue} in another thread., + *, + * @author Doug Lea, + * @author The Netty Project (netty-dev@lists.jboss.org), + * @author Trustin Lee (tlee@redhat.com), + *, + * @param <E> the type of elements held in this collection, + *, + */, +public class LinkedTransferQueue<E> extends AbstractQueue<E>, +    implements BlockingQueue<E>, java.io.Serializable {, +    private static final long serialVersionUID = -3223113410248163686L;, +, +    /*, +     * This is still a work in progress..., +     *, +     * This class extends the approach used in FIFO-mode, +     * SynchronousQueues. See the internal documentation, as well as, +     * the PPoPP 2006 paper "Scalable Synchronous Queues" by Scherer,, +     * Lea & Scott, +     * (http://www.cs.rice.edu/~wns1/papers/2006-PPoPP-SQ.pdf), +     *, +     * The main extension is to provide different Wait modes, +     * for the main "xfer" method that puts or takes items., +     * These don't impact the basic dual-queue logic, but instead, +     * control whether or how threads block upon insertion, +     * of request or data nodes into the dual queue., +     */, +, +    // Wait modes for xfer method, +    static final int NOWAIT  = 0;, +    static final int TIMEOUT = 1;, +    static final int WAIT    = 2;, +, +    /** The number of CPUs, for spin control */, +    static final int NCPUS = Runtime.getRuntime().availableProcessors();, +, +    /**]