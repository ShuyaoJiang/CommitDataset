[+++ b/handler/src/main/java/io/netty/handler/ssl/SslHandler.java, +import io.netty.buffer.ByteBufAllocator;, +                    out = allocate(ctx, maxPacketBufferSize);, +                    out = allocate(ctx, maxPacketBufferSize);, +                            unwrapNonAppData(ctx);, +                            unwrapNonAppData(ctx);, +        int totalLength = 0;, +                totalLength = packetLength;, +        while (totalLength < OpenSslEngine.MAX_ENCRYPTED_PACKET_LENGTH) {, +            int newTotalLength = totalLength + packetLength;, +            if (newTotalLength > OpenSslEngine.MAX_ENCRYPTED_PACKET_LENGTH) {, +                // Don't read too much., +                break;, +            // We have a whole packet., +            totalLength = newTotalLength;, +, +            final ByteBuffer inNetBuf = in.nioBuffer(startOffset, totalLength);, +            unwrap(ctx, inNetBuf, totalLength);, +            assert !inNetBuf.hasRemaining() || engine.isInboundDone();, +    private void unwrapNonAppData(ChannelHandlerContext ctx) throws SSLException {, +        unwrap(ctx, Unpooled.EMPTY_BUFFER.nioBuffer(), 0);, +     * Unwraps inbound SSL records., +    private void unwrap(, +        ByteBuf decodeOut = allocate(ctx, initialOutAppBufCapacity);, +        } finally {, +            if (decodeOut.isReadable()) {, +                ctx.fireChannelRead(decodeOut);, +            } else {, +                decodeOut.release();, +            }, +    /**, +     * Always prefer a direct buffer when it's pooled, so that we reduce the number of memory copies, +     * in {@link OpenSslEngine}., +     */, +    private static ByteBuf allocate(ChannelHandlerContext ctx, int capacity) {, +        ByteBufAllocator alloc = ctx.alloc();, +        if (alloc.isDirectBufferPooled()) {, +            return alloc.directBuffer(capacity);, +        } else {, +            return alloc.buffer(capacity);, +        }, +    }, +]