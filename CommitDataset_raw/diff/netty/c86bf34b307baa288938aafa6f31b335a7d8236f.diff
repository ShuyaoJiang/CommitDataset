[+++ b/src/main/java/org/jboss/netty/handler/traffic/TrafficCounter.java, +public class TrafficCounter {, +     * Long life writing bytes, +     */, +    private final AtomicLong cumulativeWritingBytes = new AtomicLong(0);, +, +    /**, +     * Long life reading bytes, +     */, +    private final AtomicLong cumulativeReadingBytes = new AtomicLong(0);, +, +    /**, +    private long lastWritingThroughput = 0;, +    private long lastReadingThroughput = 0;, +    private long checkInterval = TrafficCounterFactory.DEFAULT_DELAY;, +     * Class to implement monitoring at fix delay, +     *, +     */, +    private class TrafficMonitoring implements Runnable {, +        /**, +         * Delay between two capture, +         */, +        private final long checkInterval1;, +        /**, +         * The associated TrafficCounterFactory, +         */, +        private final TrafficCounterFactory factory1;, +        /**, +         * The associated TrafficCounter, +         */, +        private final TrafficCounter counter;, +        , +        /**, +         * @param checkInterval, +         * @param factory, +         * @param counter, +         */, +        protected TrafficMonitoring(long checkInterval,, +                TrafficCounterFactory factory, TrafficCounter counter) {, +            this.checkInterval1 = checkInterval;, +            this.factory1 = factory;, +            this.counter = counter;, +        }, +, +        /**, +         * Default run, +         */, +        public void run() {, +            try {, +                for (;;) {, +                    if (this.checkInterval1 > 0) {, +                        Thread.sleep(this.checkInterval1);, +                    } else {, +                        // Delay goes to TrafficCounterFactory.NO_STAT, so exit, +                        return;, +                    }, +                    long endTime = System.currentTimeMillis();, +                    this.counter.resetAccounting(endTime);, +                    if (this.factory1 != null) {, +                        this.factory1.accounting(this.counter);, +                    }, +                }, +            } catch (InterruptedException e) {, +                // End of computations, +            }, +        }        , +    }, +    /**, +    public void start() {, +            if (this.checkInterval > 0) {, +                this.monitorFuture = , +                    this.executorService.submit(new TrafficMonitoring(this.checkInterval,, +                        this.factory, this));, +    public void stop() {, +    protected void resetAccounting(long newLastTime) {, +            this.lastReadingThroughput = this.lastReadingBytes / interval * 1000;, +            // nb byte / checkInterval in ms * 1000 (1s), +            this.lastWritingThroughput = this.lastWritingBytes / interval * 1000;, +            // nb byte / checkInterval in ms * 1000 (1s), +     * name, the limits in Byte/s (not Bit/s) and the checkInterval between two, +     * @param checkInterval, +     *            the checkInterval in ms between two computations, +            long writeLimit, long readLimit, long checkInterval) {, +        this.configure(channel, writeLimit, readLimit, checkInterval);, +    protected void setMonitoredChannel(Channel channel) {, +     * Specifies limits in Byte/s (not Bit/s) but do not changed the checkInterval, +    public void configure(Channel channel, long writeLimit,, +     * Specifies limits in Byte/s (not Bit/s) and the specified checkInterval between, +    public void configure(Channel channel, long writeLimit,, +        if (this.checkInterval != delayToSet) {, +            this.checkInterval = delayToSet;, +                this.configure(channel, writeLimit, readLimit);, +            stop();, +            if (this.checkInterval > 0) {, +                start();, +        this.configure(channel, writeLimit, readLimit);, +        protected ReopenRead(ChannelHandlerContext ctx,, +    protected void bytesRecvFlowControl(ChannelHandlerContext ctx, long recv), +        this.cumulativeReadingBytes.addAndGet(recv);, +    protected void bytesWriteFlowControl(long write) throws InterruptedException {]