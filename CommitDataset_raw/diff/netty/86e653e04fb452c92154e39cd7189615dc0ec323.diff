[+++ b/buffer/src/main/java/io/netty/buffer/ByteBufUtil.java, +     * Used to determine if the return value of {@link ByteBuf#ensureWritable(int, boolean)} means that there is, +     * adequate space and a write operation will succeed., +     * @param ensureWritableResult The return value from {@link ByteBuf#ensureWritable(int, boolean)}., +     * @return {@code true} if {@code ensureWritableResult} means that there is adequate space and a write operation, +     * will succeed., +     */, +    public static boolean ensureWritableSuccess(int ensureWritableResult) {, +        return ensureWritableResult == 0 || ensureWritableResult == 2;, +    }, +, +    /**, +++ b/buffer/src/main/java/io/netty/buffer/ByteBufUtil.java, +     * Used to determine if the return value of {@link ByteBuf#ensureWritable(int, boolean)} means that there is, +     * adequate space and a write operation will succeed., +     * @param ensureWritableResult The return value from {@link ByteBuf#ensureWritable(int, boolean)}., +     * @return {@code true} if {@code ensureWritableResult} means that there is adequate space and a write operation, +     * will succeed., +     */, +    public static boolean ensureWritableSuccess(int ensureWritableResult) {, +        return ensureWritableResult == 0 || ensureWritableResult == 2;, +    }, +, +    /**, +++ b/handler/src/main/java/io/netty/handler/ssl/SslHandler.java, +import io.netty.channel.AbstractCoalescingBufferQueue;, +import io.netty.util.internal.UnstableApi;, +import javax.net.ssl.SSLEngine;, +import javax.net.ssl.SSLEngineResult;, +import javax.net.ssl.SSLEngineResult.HandshakeStatus;, +import javax.net.ssl.SSLEngineResult.Status;, +import javax.net.ssl.SSLException;, +import javax.net.ssl.SSLSession;, +, +import static io.netty.buffer.ByteBufUtil.ensureWritableSuccess;, +    /**, +     * <a href="https://tools.ietf.org/html/rfc5246#section-6.2">2^14</a> which is the maximum sized plaintext chunk, +     * allowed by the TLS RFC., +     */, +    private static final int MAX_PLAINTEXT_LENGTH = 16 * 1024;, +, +    private final SslHandlerCoalescingBufferQueue pendingUnencryptedWrites = new SslHandlerCoalescingBufferQueue(16);, +     * Sets the number of bytes to pass to each {@link SSLEngine#wrap(ByteBuffer[], int, int, ByteBuffer)} call., +     * <p>, +     * This value will partition data which is passed to write, +     * {@link #write(ChannelHandlerContext, Object, ChannelPromise)}. The partitioning will work as follows:, +     * <ul>, +     * <li>If {@code wrapDataSize <= 0} then we will write each data chunk as is.</li>, +     * <li>If {@code wrapDataSize > data size} then we will attempt to aggregate multiple data chunks together.</li>, +     * <li>If {@code wrapDataSize > data size}  Else if {@code wrapDataSize <= data size} then we will divide the data, +     * into chunks of {@code wrapDataSize} when writing.</li>, +     * </ul>, +     * <p>, +     * If the {@link SSLEngine} doesn't support a gather wrap operation (e.g. {@link SslProvider#OPENSSL}) then, +     * aggregating data before wrapping can help reduce the ratio between TLS overhead vs data payload which will lead, +     * to better goodput. Writing fixed chunks of data can also help target the underlying transport's (e.g. TCP), +     * frame size. Under lossy/congested network conditions this may help the peer get full TLS packets earlier and, +     * be able to do work sooner, as opposed to waiting for the all the pieces of the TLS packet to arrive., +     * @param wrapDataSize the number of bytes which will be passed to each, +     *      {@link SSLEngine#wrap(ByteBuffer[], int, int, ByteBuffer)} call., +     */, +    @UnstableApi, +    public final void setWrapDataSize(int wrapDataSize) {, +        pendingUnencryptedWrites.wrapDataSize = wrapDataSize;, +    }, +, +    /**, +            pendingUnencryptedWrites.releaseAndFailAll(ctx,, +                    new ChannelException("Pending write on removal of SslHandler"));, +        pendingUnencryptedWrites.add((ByteBuf) msg, promise);, +            pendingUnencryptedWrites.writeAndRemoveAll(ctx);, +            final int wrapDataSize = pendingUnencryptedWrites.wrapDataSize;, +                promise = ctx.newPromise();, +                ByteBuf buf = wrapDataSize > 0 ?, +                        pendingUnencryptedWrites.remove(alloc, wrapDataSize, promise) :, +                        pendingUnencryptedWrites.removeFirst(promise);, +                if (buf == null) {, +                    buf.release();, +                    promise.tryFailure(SSLENGINE_CLOSED);, +                    promise = null;, +                    pendingUnencryptedWrites.releaseAndFailAll(ctx, SSLENGINE_CLOSED);, +                    if (buf.isReadable()) {, +                        pendingUnencryptedWrites.addFirst(buf);, +                        buf.release();, +            pendingUnencryptedWrites.releaseAndFailAll(ctx, cause);, +    /**, +     * Each call to SSL_write will introduce about ~100 bytes of overhead. This coalescing queue attempts to increase, +     * goodput by aggregating the plaintext in chunks of {@link #wrapDataSize}. If many small chunks are written, +     * this can increase goodput, decrease the amount of calls to SSL_write, and decrease overall encryption operations., +     */, +    private static final class SslHandlerCoalescingBufferQueue extends AbstractCoalescingBufferQueue {, +        volatile int wrapDataSize = MAX_PLAINTEXT_LENGTH;, +, +        SslHandlerCoalescingBufferQueue(int initSize) {, +            super(initSize);, +        }, +, +        @Override, +        protected ByteBuf compose(ByteBufAllocator alloc, ByteBuf cumulation, ByteBuf next) {, +            final int wrapDataSize = this.wrapDataSize;]