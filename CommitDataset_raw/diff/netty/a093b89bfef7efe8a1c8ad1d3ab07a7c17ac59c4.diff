[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpClientCodec.java, +    private final boolean parseHttpAfterConnectRequest;, +        this(maxInitialLineLength, maxHeaderSize, maxChunkSize, failOnMissingResponse, validateHeaders, false);, +    }, +, +    /**, +     * Creates a new instance with the specified decoder options., +     */, +    public HttpClientCodec(, +            int maxInitialLineLength, int maxHeaderSize, int maxChunkSize, boolean failOnMissingResponse,, +            boolean validateHeaders, boolean parseHttpAfterConnectRequest) {, +        this.parseHttpAfterConnectRequest = parseHttpAfterConnectRequest;, +        this(maxInitialLineLength, maxHeaderSize, maxChunkSize, failOnMissingResponse, validateHeaders,, +                initialBufferSize, false);, +    }, +, +    /**, +     * Creates a new instance with the specified decoder options., +     */, +    public HttpClientCodec(, +            int maxInitialLineLength, int maxHeaderSize, int maxChunkSize, boolean failOnMissingResponse,, +            boolean validateHeaders, int initialBufferSize, boolean parseHttpAfterConnectRequest) {, +        this.parseHttpAfterConnectRequest = parseHttpAfterConnectRequest;, +            if (failOnMissingResponse && !done) {, +                        // Proxy connection established - Parse HTTP only if configured by parseHttpAfterConnectRequest,, +                        // else pass through., +                        if (!parseHttpAfterConnectRequest) {, +                        }, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpClientCodec.java, +    private final boolean parseHttpAfterConnectRequest;, +        this(maxInitialLineLength, maxHeaderSize, maxChunkSize, failOnMissingResponse, validateHeaders, false);, +    }, +, +    /**, +     * Creates a new instance with the specified decoder options., +     */, +    public HttpClientCodec(, +            int maxInitialLineLength, int maxHeaderSize, int maxChunkSize, boolean failOnMissingResponse,, +            boolean validateHeaders, boolean parseHttpAfterConnectRequest) {, +        this.parseHttpAfterConnectRequest = parseHttpAfterConnectRequest;, +        this(maxInitialLineLength, maxHeaderSize, maxChunkSize, failOnMissingResponse, validateHeaders,, +                initialBufferSize, false);, +    }, +, +    /**, +     * Creates a new instance with the specified decoder options., +     */, +    public HttpClientCodec(, +            int maxInitialLineLength, int maxHeaderSize, int maxChunkSize, boolean failOnMissingResponse,, +            boolean validateHeaders, int initialBufferSize, boolean parseHttpAfterConnectRequest) {, +        this.parseHttpAfterConnectRequest = parseHttpAfterConnectRequest;, +            if (failOnMissingResponse && !done) {, +                        // Proxy connection established - Parse HTTP only if configured by parseHttpAfterConnectRequest,, +                        // else pass through., +                        if (!parseHttpAfterConnectRequest) {, +                        }, +++ b/codec-http/src/test/java/io/netty/handler/codec/http/HttpClientCodecTest.java, +import static org.hamcrest.Matchers.not;, +import static org.junit.Assert.assertFalse;, +    private static final String EMPTY_RESPONSE = "HTTP/1.0 200 OK\r\nContent-Length: 0\r\n\r\n";, +    public void testConnectWithResponseContent() {, +        sendRequestAndReadResponse(ch, HttpMethod.CONNECT, RESPONSE);, +        sendRequestAndReadResponse(ch, HttpMethod.GET, CHUNKED_RESPONSE);, +, +    @Test, +    public void testContinueParsingAfterConnect() throws Exception {, +        testAfterConnect(true);, +    }, +, +    @Test, +    public void testPassThroughAfterConnect() throws Exception {, +        testAfterConnect(false);, +    }, +, +    private static void testAfterConnect(final boolean parseAfterConnect) throws Exception {, +        EmbeddedChannel ch = new EmbeddedChannel(new HttpClientCodec(4096, 8192, 8192, true, true, parseAfterConnect));, +, +        Consumer connectResponseConsumer = new Consumer();, +        sendRequestAndReadResponse(ch, HttpMethod.CONNECT, EMPTY_RESPONSE, connectResponseConsumer);, +        assertTrue("No connect response messages received.", connectResponseConsumer.getReceivedCount() > 0);, +        Consumer responseConsumer = new Consumer() {, +            @Override, +            void accept(Object object) {, +                if (parseAfterConnect) {, +                    assertThat("Unexpected response message type.", object, instanceOf(HttpObject.class));, +                } else {, +                    assertThat("Unexpected response message type.", object, not(instanceOf(HttpObject.class)));, +                }, +            }, +        };, +        sendRequestAndReadResponse(ch, HttpMethod.GET, RESPONSE, responseConsumer);, +        assertTrue("No response messages received.", responseConsumer.getReceivedCount() > 0);, +        assertFalse("Channel finish failed.", ch.finish());, +    }, +, +    private static void sendRequestAndReadResponse(EmbeddedChannel ch, HttpMethod httpMethod, String response) {, +        sendRequestAndReadResponse(ch, httpMethod, response, new Consumer());, +    }, +, +    private static void sendRequestAndReadResponse(EmbeddedChannel ch, HttpMethod httpMethod, String response,]