[+++ b/src/main/java/org/jboss/netty/channel/socket/nio/NioWorker.java, +import java.util.concurrent.locks.ReadWriteLock;, +import java.util.concurrent.locks.ReentrantReadWriteLock;, +import org.jboss.netty.channel.MessageEvent;, +    final ReadWriteLock selectorGuard = new ReentrantReadWriteLock();, +            selectorGuard.readLock().lock();, +            try {, +            } finally {, +                selectorGuard.readLock().unlock();, +, +            selectorGuard.writeLock().lock();, +            selectorGuard.writeLock().unlock();, +, +, +                        selectorGuard.writeLock().lock();, +                        try {, +                        } finally {, +                            selectorGuard.writeLock().unlock();, +        final NioSocketChannelConfig cfg = channel.getConfig();, +        final int writeSpinCount = cfg.getWriteSpinCount();, +        if (cfg.isReadWriteFair()) {, +                cfg.getReceiveBufferSizePredictor().nextReceiveBufferSize();, +            writeFair(channel, mightNeedWakeup, writeSpinCount, maxWrittenBytes);, +            writeUnfair(channel, mightNeedWakeup, writeSpinCount);, +    }, +, +    private static void writeUnfair(NioSocketChannel channel,, +            boolean mightNeedWakeup, final int writeSpinCount) {, +, +        boolean addOpWrite = false;, +        boolean removeOpWrite = false;, +, +        MessageEvent evt;, +        ChannelBuffer buf;, +        int bufIdx;, +            evt = channel.currentWriteEvent;, +                if (evt == null) {, +                    evt = channel.writeBuffer.poll();, +                    if (evt == null) {, +                        channel.currentWriteEvent = null;, +                    buf = (ChannelBuffer) evt.getMessage();, +                    bufIdx = buf.readerIndex();, +                    buf = (ChannelBuffer) evt.getMessage();, +                    bufIdx = channel.currentWriteIndex;, +                    for (int i = writeSpinCount; i > 0; i --) {, +                        int localWrittenBytes = buf.getBytes(, +                            bufIdx,, +                            buf.writerIndex() - bufIdx);, +, +                            bufIdx += localWrittenBytes;, +                    if (bufIdx == buf.writerIndex()) {, +                        evt.getFuture().setSuccess();, +                        evt = null;, +                        channel.currentWriteEvent = evt;, +                        channel.currentWriteIndex = bufIdx;, +                } catch (Throwable t) {, +                    evt.getFuture().setFailure(t);, +                    evt = null;, +                    fireExceptionCaught(channel, t);, +                }, +            }, +        }, +, +        if (addOpWrite) {, +            setOpWrite(channel, true, mightNeedWakeup);, +        } else if (removeOpWrite) {, +            setOpWrite(channel, false, mightNeedWakeup);, +        }, +    }, +, +    private static void writeFair(NioSocketChannel channel,, +            boolean mightNeedWakeup, final int writeSpinCount,, +            final int maxWrittenBytes) {, +, +        boolean addOpWrite = false;, +        boolean removeOpWrite = false;, +, +        int writtenBytes = 0;, +        MessageEvent evt;, +        ChannelBuffer buf;, +        int bufIdx;, +, +        synchronized (channel.writeBuffer) {, +            evt = channel.currentWriteEvent;, +            for (;;) {, +                if (evt == null) {, +                    evt = channel.writeBuffer.poll();, +                    if (evt == null) {, +                        channel.currentWriteEvent = null;, +                        removeOpWrite = true;, +                        break;, +                    }, +                    buf = (ChannelBuffer) evt.getMessage();, +                    bufIdx = buf.readerIndex();, +                } else {, +                    buf = (ChannelBuffer) evt.getMessage();, +                    bufIdx = channel.currentWriteIndex;, +                }, +, +                try {]