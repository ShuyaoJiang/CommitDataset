[+++ b/common/src/main/java/io/netty/util/concurrent/DefaultPromise.java, +import java.util.ArrayDeque;, +import java.util.Queue;, +    private static final FastThreadLocal<Queue<DefaultPromise<?>>> STACK_OVERFLOW_DELAYED_PROMISES =, +            new FastThreadLocal<Queue<DefaultPromise<?>>>() {, +        @Override, +        protected Queue<DefaultPromise<?>> initialValue() throws Exception {, +            return new ArrayDeque<DefaultPromise<?>>(2);, +        }, +    };, +    /**, +     * This queue will hold pairs of {@code <Future, GenericFutureListener>} which are always inserted sequentially., +     * <p>, +     * This is only used for static utility method {@link #notifyListener(EventExecutor, Future, GenericFutureListener)}, +     * and not instances of {@link DefaultPromise}., +     */, +    private static final FastThreadLocal<Queue<Object>> STACK_OVERFLOW_DELAYED_FUTURES =, +            new FastThreadLocal<Queue<Object>>() {, +        @Override, +        protected Queue<Object> initialValue() throws Exception {, +            return new ArrayDeque<Object>(2);, +        }, +    };, +     * @param eventExecutor the executor to use to notify the listener {@code listener}., +     * @param listener the listener to notify., +            EventExecutor eventExecutor, final Future<?> future, final GenericFutureListener<?> listener) {, +        checkNotNull(future, "future");, +        checkNotNull(listener, "listener");, +            notifyListenerWithStackOverFlowProtection(future, listener);, +        } else {, +                    notifyListenerWithStackOverFlowProtection(future, listener);, +    }, +            notifyListenersWithStackOverFlowProtection();, +        } else {, +                    notifyListenersWithStackOverFlowProtection();, +    }, +    private void notifyListenersWithStackOverFlowProtection() {, +        final InternalThreadLocalMap threadLocals = InternalThreadLocalMap.get();, +        final int stackDepth = threadLocals.futureListenerStackDepth();, +        if (stackDepth < MAX_LISTENER_STACK_DEPTH) {, +            threadLocals.setFutureListenerStackDepth(stackDepth + 1);, +            try {, +                notifyListenersNow();, +            } finally {, +                threadLocals.setFutureListenerStackDepth(stackDepth);, +                if (stackDepth == 0) {, +                    // We want to force all notifications to occur at the same depth on the stack as the initial method, +                    // invocation. If we leave the stackDepth at 0 then notifyListeners could occur from a, +                    // delayedPromise's stack which could lead to a stack overflow. So force the stack depth to 1 here,, +                    // and later set it back to 0 after all delayedPromises have been notified., +                    threadLocals.setFutureListenerStackDepth(1);, +                    try {, +                        Queue<DefaultPromise<?>> delayedPromiseQueue = STACK_OVERFLOW_DELAYED_PROMISES.get();, +                        DefaultPromise<?> delayedPromise;, +                        while ((delayedPromise = delayedPromiseQueue.poll()) != null) {, +                            delayedPromise.notifyListenersWithStackOverFlowProtection();, +                        }, +                    } finally {, +                        threadLocals.setFutureListenerStackDepth(0);, +                    }, +                }, +            }, +        } else {, +            STACK_OVERFLOW_DELAYED_PROMISES.get().add(this);, +        }, +    }, +, +    /**, +     * The logic in this method should be identical to {@link #notifyListenersWithStackOverFlowProtection()} but, +     * cannot share code because the listener(s) can not be queued for an instance of {@link DefaultPromise} since the, +     * listener(s) may be changed and is protected by a synchronized operation., +     */, +    private static void notifyListenerWithStackOverFlowProtection(Future<?> future, GenericFutureListener<?> listener) {, +        final InternalThreadLocalMap threadLocals = InternalThreadLocalMap.get();, +        final int stackDepth = threadLocals.futureListenerStackDepth();, +        if (stackDepth < MAX_LISTENER_STACK_DEPTH) {, +            threadLocals.setFutureListenerStackDepth(stackDepth + 1);, +            try {, +                notifyListener0(future, listener);, +            } finally {, +                threadLocals.setFutureListenerStackDepth(stackDepth);, +                if (stackDepth == 0) {, +                    // We want to force all notifications to occur at the same depth on the stack as the initial method, +                    // invocation. If we leave the stackDepth at 0 then notifyListeners could occur from a, +                    // delayedPromise's stack which could lead to a stack overflow. So force the stack depth to 1 here,, +                    // and later set it back to 0 after all delayedPromises have been notified., +                    threadLocals.setFutureListenerStackDepth(1);, +                    try {, +                        Queue<Object> delayedFutureQueue = STACK_OVERFLOW_DELAYED_FUTURES.get();, +                        Object delayedFuture;, +                        while ((delayedFuture = delayedFutureQueue.poll()) != null) {, +                            notifyListenerWithStackOverFlowProtection((Future<?>) delayedFuture,, +                                    (GenericFutureListener<?>) delayedFutureQueue.poll());, +                        }, +                    } finally {, +                        threadLocals.setFutureListenerStackDepth(0);, +                    }, +                }, +            }, +        } else {]