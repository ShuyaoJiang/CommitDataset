[+++ b/handler/src/main/java/io/netty/handler/ssl/SslHandler.java, +    private enum SslEngineType {, +        TCNATIVE(true, COMPOSITE_CUMULATOR) {, +            @Override, +            SSLEngineResult unwrap(SslHandler handler, ByteBuf in, int readerIndex, int len, ByteBuf out), +                    throws SSLException {, +                int nioBufferCount = in.nioBufferCount();, +                int writerIndex = out.writerIndex();, +                final SSLEngineResult result;, +                if (nioBufferCount > 1) {, +                    /**, +                     * If {@link OpenSslEngine} is in use,, +                     * we can use a special {@link OpenSslEngine#unwrap(ByteBuffer[], ByteBuffer[])} method, +                     * that accepts multiple {@link ByteBuffer}s without additional memory copies., +                     */, +                    OpenSslEngine opensslEngine = (OpenSslEngine) handler.engine;, +                    try {, +                        handler.singleBuffer[0] = toByteBuffer(out, writerIndex,, +                            out.writableBytes());, +                        result = opensslEngine.unwrap(in.nioBuffers(readerIndex, len), handler.singleBuffer);, +                        out.writerIndex(writerIndex + result.bytesProduced());, +                    } finally {, +                        handler.singleBuffer[0] = null;, +                    }, +                } else {, +                    result = handler.engine.unwrap(toByteBuffer(in, readerIndex, len),, +                        toByteBuffer(out, writerIndex, out.writableBytes()));, +                }, +                out.writerIndex(writerIndex + result.bytesProduced());, +                return result;, +            }, +        },, +        JDK(false, MERGE_CUMULATOR) {, +            @Override, +            SSLEngineResult unwrap(SslHandler handler, ByteBuf in, int readerIndex, int len, ByteBuf out), +                    throws SSLException {, +                int writerIndex = out.writerIndex();, +                final SSLEngineResult result = handler.engine.unwrap(toByteBuffer(in, readerIndex, len),, +                    toByteBuffer(out, writerIndex, out.writableBytes()));, +                out.writerIndex(writerIndex + result.bytesProduced());, +                return result;, +            }, +        };, +, +        static SslEngineType forEngine(SSLEngine engine) {, +            if (engine instanceof OpenSslEngine) {, +                return TCNATIVE;, +            }, +            return JDK;, +        }, +, +        SslEngineType(boolean wantsDirectBuffer, Cumulator cumulator) {, +            this.wantsDirectBuffer = wantsDirectBuffer;, +            this.cumulator = cumulator;, +        }, +, +        abstract SSLEngineResult unwrap(SslHandler handler, ByteBuf in, int readerIndex, int len, ByteBuf out), +                throws SSLException;, +, +        // BEGIN Platform-dependent flags, +, +        /**, +         * {@code true} if and only if {@link SSLEngine} expects a direct buffer., +         */, +        final boolean wantsDirectBuffer;, +, +        // END Platform-dependent flags, +, +        /**, +         * When using JDK {@link SSLEngine}, we use {@link #MERGE_CUMULATOR} because it works only with, +         * one {@link ByteBuffer}., +         *, +         * When using {@link OpenSslEngine}, we can use {@link #COMPOSITE_CUMULATOR} because it has, +         * {@link OpenSslEngine#unwrap(ByteBuffer[], ByteBuffer[])} which works with multiple {@link ByteBuffer}s, +         * and which does not need to do extra memory copies., +         */, +        final Cumulator cumulator;, +    }, +, +    private final SslEngineType engineType;, +        this.engineType = SslEngineType.forEngine(engine);, +        setCumulator(engineType.cumulator);, +            if (in.isDirect() || !engineType.wantsDirectBuffer) {, +                final SSLEngineResult result = engineType.unwrap(this, packet, offset, length, decodeOut);, +        if (engineType.wantsDirectBuffer) {]