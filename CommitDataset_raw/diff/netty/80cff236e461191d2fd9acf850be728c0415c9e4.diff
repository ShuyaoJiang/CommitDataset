[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/UniformStreamByteDistributor.java, +            if (state.windowNegative) {, +                continue;, +            }, +            if (maxBytes == 0 && state.streamableBytes > 0) {, +                // Stop at the first state that can't send. Add this state back to the head of the queue. Note, +                // that empty frames at the head of the queue will always be written, assuming the stream window, +                // is not negative., +        boolean windowNegative;, +            // In addition to only enqueuing state when they have frames we enforce the following restrictions:, +            // 1. If the window has gone negative. We never want to queue a state. However we also don't want to, +            //    Immediately remove the item if it is already queued because removal from dequeue is O(n). So, +            //    we allow it to stay queued and rely on the distribution loop to remove this state., +            // 2. If the window is zero we only want to queue if we are not writing. If we are writing that means, +            //    we gave the state a chance to write zero length frames. We wait until updateStreamableBytes is, +            //    called again before this state is allowed to write., +            windowNegative = windowSize < 0;, +            if (hasFrame && (windowSize > 0 || (windowSize == 0 && !writing))) {, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/UniformStreamByteDistributor.java, +            if (state.windowNegative) {, +                continue;, +            }, +            if (maxBytes == 0 && state.streamableBytes > 0) {, +                // Stop at the first state that can't send. Add this state back to the head of the queue. Note, +                // that empty frames at the head of the queue will always be written, assuming the stream window, +                // is not negative., +        boolean windowNegative;, +            // In addition to only enqueuing state when they have frames we enforce the following restrictions:, +            // 1. If the window has gone negative. We never want to queue a state. However we also don't want to, +            //    Immediately remove the item if it is already queued because removal from dequeue is O(n). So, +            //    we allow it to stay queued and rely on the distribution loop to remove this state., +            // 2. If the window is zero we only want to queue if we are not writing. If we are writing that means, +            //    we gave the state a chance to write zero length frames. We wait until updateStreamableBytes is, +            //    called again before this state is allowed to write., +            windowNegative = windowSize < 0;, +            if (hasFrame && (windowSize > 0 || (windowSize == 0 && !writing))) {, +++ b/codec-http2/src/test/java/io/netty/handler/codec/http2/UniformStreamByteDistributorTest.java, +    @Test, +    public void streamWindowExhaustedDoesNotWrite() throws Http2Exception {, +        updateStream(STREAM_A, 0, true, false);, +        updateStream(STREAM_B, 0, true);, +        updateStream(STREAM_C, 0, true);, +        updateStream(STREAM_D, 0, true, false);, +, +        assertFalse(write(10));, +        verifyWrite(STREAM_B, 0);, +        verifyWrite(STREAM_C, 0);, +        verifyNoMoreInteractions(writer);, +    }, +]