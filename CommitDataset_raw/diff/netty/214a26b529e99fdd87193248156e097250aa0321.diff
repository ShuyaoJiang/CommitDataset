[+++ b/src/main/java/org/jboss/netty/channel/xnio/AbstractXnioChannelHandler.java, +package org.jboss.netty.channel.xnio;, +, +import static org.jboss.netty.channel.Channels.*;, +, +import java.io.IOException;, +import java.net.SocketAddress;, +import java.nio.ByteBuffer;, +import java.nio.channels.AsynchronousCloseException;, +import java.nio.channels.GatheringByteChannel;, +import java.nio.channels.ScatteringByteChannel;, +import java.util.Queue;, +, +import org.jboss.netty.buffer.ChannelBuffer;, +import org.jboss.netty.buffer.ChannelBuffers;, +import org.jboss.netty.channel.MessageEvent;, +import org.jboss.xnio.IoHandler;, +import org.jboss.xnio.channels.MultipointReadResult;, +import org.jboss.xnio.channels.MultipointReadableMessageChannel;, +import org.jboss.xnio.channels.MultipointWritableMessageChannel;, +import org.jboss.xnio.channels.ReadableMessageChannel;, +import org.jboss.xnio.channels.SuspendableReadChannel;, +import org.jboss.xnio.channels.SuspendableWriteChannel;, +import org.jboss.xnio.channels.WritableMessageChannel;, +, +/**, + * @author The Netty Project (netty-dev@lists.jboss.org), + * @author Trustin Lee (tlee@redhat.com), + * @version $Rev$, $Date$, + */, +@SuppressWarnings("unchecked"), +public abstract class AbstractXnioChannelHandler implements IoHandler<java.nio.channels.Channel> {, +, +    protected AbstractXnioChannelHandler() {, +        super();, +    }, +, +    public void handleReadable(java.nio.channels.Channel channel) {, +        XnioChannel c = XnioChannelRegistry.getChannel(channel);, +, +        boolean closed = false;, +, +        // TODO: Use ReceiveBufferSizePredictor, +        ChannelBuffer buf = c.getConfig().getBufferFactory().getBuffer(2048);, +        SocketAddress remoteAddress = null;, +        Throwable exception = null;, +        if (channel instanceof ScatteringByteChannel) {, +            try {, +                while (buf.writable()) {, +                    int readBytes = buf.writeBytes((ScatteringByteChannel) channel, buf.writableBytes());, +                    if (readBytes == 0) {, +                        break;, +                    } else if (readBytes < 0) {, +                        closed = true;, +                        break;, +                    }, +                }, +            } catch (IOException e) {, +                exception = e;, +                closed = true;, +            }, +        } else if (channel instanceof MultipointReadableMessageChannel) {, +            ByteBuffer nioBuf = buf.toByteBuffer();, +            try {, +                MultipointReadResult res = ((MultipointReadableMessageChannel) channel).receive(nioBuf);, +                if (res != null) {, +                    buf = ChannelBuffers.wrappedBuffer(nioBuf);, +                    remoteAddress = (SocketAddress) res.getSourceAddress();, +                }, +            } catch (IOException e) {, +                exception = e;, +                closed = true;, +            }, +        } else if (channel instanceof ReadableMessageChannel) {, +            ByteBuffer nioBuf = buf.toByteBuffer();, +            try {, +                int readBytes = ((ReadableMessageChannel) channel).receive(nioBuf);, +                if (readBytes > 0) {, +                    buf = ChannelBuffers.wrappedBuffer(nioBuf);, +                } else if (readBytes < 0) {, +                    closed = true;, +                }, +            } catch (IOException e) {, +                exception = e;, +                closed = true;, +            }, +        }, +, +        if (buf.readable()) {, +            fireMessageReceived(c, buf, remoteAddress);, +        }, +        if (exception != null) {, +            fireExceptionCaught(c, exception);, +        }, +, +        if (closed) {, +            close(c);, +        } else {, +            resumeRead(channel);, +        }]