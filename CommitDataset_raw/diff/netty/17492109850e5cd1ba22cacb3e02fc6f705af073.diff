[+++ b/common/src/main/java/io/netty/util/concurrent/AbstractEventExecutor.java, +    public boolean inEventLoop() {, +        return inEventLoop(Thread.currentThread());, +    }, +, +    @Override, +++ b/common/src/main/java/io/netty/util/concurrent/AbstractEventExecutor.java, +    public boolean inEventLoop() {, +        return inEventLoop(Thread.currentThread());, +    }, +, +    @Override, +++ b/common/src/main/java/io/netty/util/concurrent/GlobalEventExecutor.java, +/*, + * Copyright 2012 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + *   http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the, + * License for the specific language governing permissions and limitations, + * under the License., + */, +package io.netty.util.concurrent;, +, +import io.netty.util.internal.logging.InternalLogger;, +import io.netty.util.internal.logging.InternalLoggerFactory;, +, +import java.util.Iterator;, +import java.util.PriorityQueue;, +import java.util.Queue;, +import java.util.concurrent.BlockingQueue;, +import java.util.concurrent.Callable;, +import java.util.concurrent.Executors;, +import java.util.concurrent.LinkedBlockingQueue;, +import java.util.concurrent.RejectedExecutionException;, +import java.util.concurrent.ThreadFactory;, +import java.util.concurrent.TimeUnit;, +, +/**, + * Single-thread singleton {@link EventExecutor}.  It starts the thread automatically and stops it when there is no, + * task pending in the task queue for 1 second.  Please note it is not scalable to schedule large number of tasks to, + * this executor; use a dedicated executor., + */, +public final class GlobalEventExecutor extends AbstractEventExecutor {, +, +    private static final InternalLogger logger = InternalLoggerFactory.getInstance(GlobalEventExecutor.class);, +, +    private static final int ST_NOT_STARTED = 1;, +    private static final int ST_STARTED = 2;, +, +    private static final long SCHEDULE_PURGE_INTERVAL = TimeUnit.SECONDS.toNanos(1);, +, +    public static final GlobalEventExecutor INSTANCE = new GlobalEventExecutor();, +, +    final Queue<Runnable> taskQueue = new LinkedBlockingQueue<Runnable>();, +    final Queue<ScheduledFutureTask<?>> delayedTaskQueue = new PriorityQueue<ScheduledFutureTask<?>>();, +    final ScheduledFutureTask<Void> purgeTask = new ScheduledFutureTask<Void>(, +            this, delayedTaskQueue, Executors.<Void>callable(new PurgeTask(), null),, +            ScheduledFutureTask.deadlineNanos(SCHEDULE_PURGE_INTERVAL), -SCHEDULE_PURGE_INTERVAL);, +, +    private final ThreadFactory threadFactory = new DefaultThreadFactory(getClass());, +    private final TaskRunner taskRunner = new TaskRunner();, +    private final Object stateLock = new Object();, +, +    volatile Thread thread;, +    private volatile int state = ST_NOT_STARTED;, +, +    private GlobalEventExecutor() {, +        delayedTaskQueue.add(purgeTask);, +    }, +, +    @Override, +    public EventExecutorGroup parent() {, +        return null;, +    }, +, +    /**, +     * Take the next {@link Runnable} from the task queue and so will block if no task is currently present., +     *, +     * @return {@code null} if the executor thread has been interrupted or waken up., +     */, +    Runnable takeTask() {, +        BlockingQueue<Runnable> taskQueue = (BlockingQueue<Runnable>) this.taskQueue;, +        for (;;) {, +            ScheduledFutureTask<?> delayedTask = delayedTaskQueue.peek();, +            if (delayedTask == null) {, +                Runnable task = null;, +                try {, +                    task = taskQueue.take();, +                } catch (InterruptedException e) {, +                    // Ignore, +                }, +                return task;, +            } else {]