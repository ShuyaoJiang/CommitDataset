[+++ b/handler/src/test/java/io/netty/handler/ssl/SniClientTest.java, +import javax.net.ssl.SSLException;, +    @Test(timeout = 30000, expected = SSLException.class), +    @Test(timeout = 30000, expected = SSLException.class), +    @Test(timeout = 30000, expected = SSLException.class), +    @Test(timeout = 30000, expected = SSLException.class), +++ b/handler/src/test/java/io/netty/handler/ssl/SniClientTest.java, +import javax.net.ssl.SSLException;, +    @Test(timeout = 30000, expected = SSLException.class), +    @Test(timeout = 30000, expected = SSLException.class), +    @Test(timeout = 30000, expected = SSLException.class), +    @Test(timeout = 30000, expected = SSLException.class), +++ b/transport/src/main/java/io/netty/channel/local/LocalChannel.java, +                if (writeInProgress && peer != null) {, +                    finishPeerRead(peer);, +                }, +                // Always call peer.eventLoop().execute() even if peer.eventLoop().inEventLoop() is true., +                // This ensures that if both channels are on the same event loop, the peer's channelInActive, +                // event is triggered *after* this peer's channelInActive event, +++ b/handler/src/test/java/io/netty/handler/ssl/SniClientTest.java, +import javax.net.ssl.SSLException;, +    @Test(timeout = 30000, expected = SSLException.class), +    @Test(timeout = 30000, expected = SSLException.class), +    @Test(timeout = 30000, expected = SSLException.class), +    @Test(timeout = 30000, expected = SSLException.class), +++ b/transport/src/main/java/io/netty/channel/local/LocalChannel.java, +                if (writeInProgress && peer != null) {, +                    finishPeerRead(peer);, +                }, +                // Always call peer.eventLoop().execute() even if peer.eventLoop().inEventLoop() is true., +                // This ensures that if both channels are on the same event loop, the peer's channelInActive, +                // event is triggered *after* this peer's channelInActive event, +++ b/transport/src/test/java/io/netty/channel/local/LocalChannelTest.java, +    public void testCloseAfterWriteInSameEventLoopPreservesOrder() throws InterruptedException {, +        Bootstrap cb = new Bootstrap();, +        ServerBootstrap sb = new ServerBootstrap();, +        final CountDownLatch messageLatch = new CountDownLatch(3);, +        final ByteBuf data = Unpooled.wrappedBuffer(new byte[1024]);, +, +        try {, +            cb.group(sharedGroup), +                    .channel(LocalChannel.class), +                    .handler(new ChannelInboundHandlerAdapter() {, +                        @Override, +                        public void channelActive(ChannelHandlerContext ctx) throws Exception {, +                            ctx.writeAndFlush(data.retainedDuplicate());, +                        }, +, +                        @Override, +                        public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {, +                            if (data.equals(msg)) {, +                                ReferenceCountUtil.safeRelease(msg);, +                                messageLatch.countDown();, +                            } else {, +                                super.channelRead(ctx, msg);, +                            }, +                        }, +                    });, +, +            sb.group(sharedGroup), +                    .channel(LocalServerChannel.class), +                    .childHandler(new ChannelInboundHandlerAdapter() {, +                        @Override, +                        public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {, +                            if (data.equals(msg)) {, +                                messageLatch.countDown();, +                                ctx.writeAndFlush(data);, +                                ctx.close();, +                            } else {, +                                super.channelRead(ctx, msg);, +                            }, +                        }, +, +                        @Override, +                        public void channelInactive(ChannelHandlerContext ctx) throws Exception {, +                            messageLatch.countDown();, +                            super.channelInactive(ctx);, +                        }, +                    });, +, +            Channel sc = null;, +            Channel cc = null;, +            try {, +                // Start server, +                sc = sb.bind(TEST_ADDRESS).syncUninterruptibly().channel();, +, +                // Connect to the server, +                cc = cb.connect(sc.localAddress()).syncUninterruptibly().channel();, +                assertTrue(messageLatch.await(5, SECONDS));, +                assertFalse(cc.isOpen());, +            } finally {, +                closeChannel(cc);, +                closeChannel(sc);, +            }, +        } finally {, +            data.release();, +        }, +    }, +, +    @Test]