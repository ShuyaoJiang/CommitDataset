[+++ b/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverContext.java, +            new RuntimeException("No matching record type found"),, +    private static final RuntimeException NAME_SERVERS_EXHAUSTED_EXCEPTION = ThrowableUtil.unknownStackTrace(, +            new RuntimeException("No name servers returned an answer"),, +            DnsNameResolverContext.class,, +            "tryToFinishResolve(..)");, +        DnsRecordType[] recordTypes = parent.resolveRecordTypes();, +        assert recordTypes.length > 0;, +        final int end = recordTypes.length - 1;, +        for (int i = 0; i < end; ++i) {, +            if (!query(hostname, recordTypes[i], nameServerAddressStream.duplicate(), promise)) {, +        query(hostname, recordTypes[end], nameServerAddressStream, promise);, +    private void query(final DnsServerAddressStream nameServerAddrStream, final int nameServerAddrStreamIndex,, +                       final DnsQuestion question,, +        query(nameServerAddrStream, nameServerAddrStreamIndex, question,, +                parent.dnsQueryLifecycleObserverFactory().newDnsQueryLifecycleObserver(question), promise);, +    private void query(final DnsServerAddressStream nameServerAddrStream,, +                       final int nameServerAddrStreamIndex,, +                       final DnsQuestion question,, +        if (nameServerAddrStreamIndex >= nameServerAddrStream.size() || allowedQueries == 0 || promise.isCancelled()) {, +            tryToFinishResolve(nameServerAddrStream, nameServerAddrStreamIndex, question, queryLifecycleObserver,, +                               promise);, +        --allowedQueries;, +                        onResponse(nameServerAddrStream, nameServerAddrStreamIndex, question, future.getNow(),, +                                   queryLifecycleObserver, promise);, +                        query(nameServerAddrStream, nameServerAddrStreamIndex + 1, question, promise);, +                    tryToFinishResolve(nameServerAddrStream, nameServerAddrStreamIndex, question,, +                                       // queryLifecycleObserver has already been terminated at this point so we must, +                                       // not allow it to be terminated again by tryToFinishResolve., +                                       NoopDnsQueryLifecycleObserver.INSTANCE,, +                                       promise);, +    void onResponse(final DnsServerAddressStream nameServerAddrStream, final int nameServerAddrStreamIndex,, +                    final DnsQuestion question, AddressedEnvelope<DnsResponse, InetSocketAddress> envelope,, +                query(nameServerAddrStream, nameServerAddrStreamIndex + 1, question,, +                      queryLifecycleObserver.queryNoAnswer(code), promise);, +                    query(parent.uncachedRedirectDnsServerStream(nameServers), 0, question,, +            followCname(resolved, queryLifecycleObserver, promise);, +    void tryToFinishResolve(final DnsServerAddressStream nameServerAddrStream,, +                            final int nameServerAddrStreamIndex,, +                            final DnsQuestion question,, +                            final DnsQueryLifecycleObserver queryLifecycleObserver,, +                            final Promise<T> promise) {, +        // There are no queries left to try., +            queryLifecycleObserver.queryCancelled(allowedQueries);, +, +            if (nameServerAddrStreamIndex < nameServerAddrStream.size()) {, +                if (queryLifecycleObserver == NoopDnsQueryLifecycleObserver.INSTANCE) {, +                    // If the queryLifecycleObserver has already been terminated we should create a new one for this, +                    // fresh query., +                    query(nameServerAddrStream, nameServerAddrStreamIndex + 1, question, promise);, +                } else {, +                    query(nameServerAddrStream, nameServerAddrStreamIndex + 1, question, queryLifecycleObserver,, +                          promise);, +                }, +                return;, +            }, +, +            queryLifecycleObserver.queryFailed(NAME_SERVERS_EXHAUSTED_EXCEPTION);, +, +        } else {, +            queryLifecycleObserver.queryCancelled(allowedQueries);, +    private void followCname(String cname, final DnsQueryLifecycleObserver queryLifecycleObserver, Promise<T> promise) {, +            query(stream, 0, cnameQuestion, queryLifecycleObserver.queryCNAMEd(cnameQuestion), promise);, +            query(stream, 0, cnameQuestion, queryLifecycleObserver.queryCNAMEd(cnameQuestion), promise);, +        query(dnsServerAddressStream, 0, question, promise);, +++ b/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverContext.java, +            new RuntimeException("No matching record type found"),, +    private static final RuntimeException NAME_SERVERS_EXHAUSTED_EXCEPTION = ThrowableUtil.unknownStackTrace(, +            new RuntimeException("No name servers returned an answer"),, +            DnsNameResolverContext.class,, +            "tryToFinishResolve(..)");, +        DnsRecordType[] recordTypes = parent.resolveRecordTypes();, +        assert recordTypes.length > 0;, +        final int end = recordTypes.length - 1;, +        for (int i = 0; i < end; ++i) {, +            if (!query(hostname, recordTypes[i], nameServerAddressStream.duplicate(), promise)) {, +        query(hostname, recordTypes[end], nameServerAddressStream, promise);, +    private void query(final DnsServerAddressStream nameServerAddrStream, final int nameServerAddrStreamIndex,, +                       final DnsQuestion question,, +        query(nameServerAddrStream, nameServerAddrStreamIndex, question,, +                parent.dnsQueryLifecycleObserverFactory().newDnsQueryLifecycleObserver(question), promise);, +    private void query(final DnsServerAddressStream nameServerAddrStream,, +                       final int nameServerAddrStreamIndex,, +                       final DnsQuestion question,, +        if (nameServerAddrStreamIndex >= nameServerAddrStream.size() || allowedQueries == 0 || promise.isCancelled()) {, +            tryToFinishResolve(nameServerAddrStream, nameServerAddrStreamIndex, question, queryLifecycleObserver,, +                               promise);, +        --allowedQueries;, +                        onResponse(nameServerAddrStream, nameServerAddrStreamIndex, question, future.getNow(),, +                                   queryLifecycleObserver, promise);, +                        query(nameServerAddrStream, nameServerAddrStreamIndex + 1, question, promise);, +                    tryToFinishResolve(nameServerAddrStream, nameServerAddrStreamIndex, question,, +                                       // queryLifecycleObserver has already been terminated at this point so we must, +                                       // not allow it to be terminated again by tryToFinishResolve., +                                       NoopDnsQueryLifecycleObserver.INSTANCE,, +                                       promise);, +    void onResponse(final DnsServerAddressStream nameServerAddrStream, final int nameServerAddrStreamIndex,, +                    final DnsQuestion question, AddressedEnvelope<DnsResponse, InetSocketAddress> envelope,, +                query(nameServerAddrStream, nameServerAddrStreamIndex + 1, question,, +                      queryLifecycleObserver.queryNoAnswer(code), promise);]