[+++ b/src/main/java/org/jboss/netty/channel/socket/nio/NioWorker.java, +import java.util.Queue;, +    private static final boolean USE_DIRECT_BUFFER = false;  // Hard-coded for now, +    final Queue<Runnable> taskQueue = new ConcurrentLinkedQueue<Runnable>();, +, +                // TODO Replace ReceiveBufferSizePredictor with, +                //      ChannelBufferAllocator and let user specify it per, +                //      Channel. (Netty 3.1), +, +                if (USE_DIRECT_BUFFER) {, +                    readIntoDirectBuffer(k);, +                } else {, +                    readIntoHeapBuffer(k);, +                }, +    private static void readIntoHeapBuffer(SelectionKey k) {, +, +    private ChannelBuffer preallocatedDirectBuffer;, +, +    private static void readIntoDirectBuffer(SelectionKey k) {, +        ScatteringByteChannel ch = (ScatteringByteChannel) k.channel();, +        NioSocketChannel channel = (NioSocketChannel) k.attachment();, +, +        ReceiveBufferSizePredictor predictor =, +            channel.getConfig().getReceiveBufferSizePredictor();, +, +        ChannelBuffer preallocatedDirectBuffer = channel.getWorker().preallocatedDirectBuffer;, +        NioWorker worker = channel.getWorker();, +        worker.preallocatedDirectBuffer = null;, +, +        if (preallocatedDirectBuffer == null) {, +            preallocatedDirectBuffer = ChannelBuffers.directBuffer(1048576);, +        }, +, +        int ret = 0;, +        int readBytes = 0;, +        boolean failure = true;, +        try {, +            while ((ret = preallocatedDirectBuffer.writeBytes(ch, preallocatedDirectBuffer.writableBytes())) > 0) {, +                readBytes += ret;, +                if (!preallocatedDirectBuffer.writable()) {, +                    break;, +                }, +            }, +            failure = false;, +        } catch (AsynchronousCloseException e) {, +            // Can happen, and doesn't need a user attention., +        } catch (Throwable t) {, +            fireExceptionCaught(channel, t);, +        }, +, +        if (readBytes > 0) {, +            // Update the predictor., +            predictor.previousReceiveBufferSize(readBytes);, +, +            // Fire the event., +            ChannelBuffer slice = preallocatedDirectBuffer.slice(, +                    preallocatedDirectBuffer.readerIndex(),, +                    preallocatedDirectBuffer.readableBytes());, +            preallocatedDirectBuffer.readerIndex(preallocatedDirectBuffer.writerIndex());, +            if (preallocatedDirectBuffer.writable()) {, +                worker.preallocatedDirectBuffer = preallocatedDirectBuffer;, +            }, +            fireMessageReceived(channel, slice);, +        } else if (readBytes == 0) {, +            worker.preallocatedDirectBuffer = preallocatedDirectBuffer;, +        }, +, +        if (ret < 0 || failure) {, +            close(k);, +        }, +    }, +]