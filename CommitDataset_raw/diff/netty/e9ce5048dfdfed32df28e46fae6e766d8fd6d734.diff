[+++ b/handler/src/main/java/io/netty/handler/ssl/ReferenceCountedOpenSslClientContext.java, +            // On the client side we always need to use SSL_CVERIFY_OPTIONAL (which will translate to SSL_VERIFY_PEER), +            // to ensure that when the TrustManager throws we will produce the correct alert back to the server., +            //, +            // See:, +            //   - https://www.openssl.org/docs/man1.0.2/man3/SSL_CTX_set_verify.html, +            //   - https://github.com/netty/netty/issues/8942, +            SSLContext.setVerify(ctx, SSL.SSL_CVERIFY_OPTIONAL, VERIFY_DEPTH);, +++ b/handler/src/main/java/io/netty/handler/ssl/ReferenceCountedOpenSslClientContext.java, +            // On the client side we always need to use SSL_CVERIFY_OPTIONAL (which will translate to SSL_VERIFY_PEER), +            // to ensure that when the TrustManager throws we will produce the correct alert back to the server., +            //, +            // See:, +            //   - https://www.openssl.org/docs/man1.0.2/man3/SSL_CTX_set_verify.html, +            //   - https://github.com/netty/netty/issues/8942, +            SSLContext.setVerify(ctx, SSL.SSL_CVERIFY_OPTIONAL, VERIFY_DEPTH);, +++ b/handler/src/test/java/io/netty/handler/ssl/SslErrorTest.java, +    @Parameterized.Parameters(, +            name = "{index}: serverProvider = {0}, clientProvider = {1}, exception = {2}, serverProduceError = {3}"), +                    params.add(new Object[] { serverProvider, clientProvider, exception, true });, +                    params.add(new Object[] { serverProvider, clientProvider, exception, false });, +    private final boolean serverProduceError;, +    public SslErrorTest(SslProvider serverProvider, SslProvider clientProvider,, +                        CertificateException exception, boolean serverProduceError) {, +        this.serverProduceError = serverProduceError;, +, +        SslContextBuilder sslServerCtxBuilder = SslContextBuilder.forServer(ssc.certificate(), ssc.privateKey()), +                .clientAuth(ClientAuth.REQUIRE);, +        SslContextBuilder sslClientCtxBuilder =  SslContextBuilder.forClient(), +                .keyManager(new File(getClass().getResource("test.crt").getFile()),, +                        new File(getClass().getResource("test_unencrypted.pem").getFile())), +                .sslProvider(clientProvider);, +, +        if (serverProduceError) {, +            sslServerCtxBuilder.trustManager(new ExceptionTrustManagerFactory());, +            sslClientCtxBuilder.trustManager(InsecureTrustManagerFactory.INSTANCE);, +        } else {, +            sslServerCtxBuilder.trustManager(InsecureTrustManagerFactory.INSTANCE);, +            sslClientCtxBuilder.trustManager(new ExceptionTrustManagerFactory());, +        }, +, +        final SslContext sslServerCtx = sslServerCtxBuilder.build();, +        final SslContext sslClientCtx = sslClientCtxBuilder.build();, +, +        Channel serverChannel = null;, +        Channel clientChannel = null;, +        EventLoopGroup group = new NioEventLoopGroup();, +        final Promise<Void> promise = group.next().newPromise();, +        try {, +            serverChannel = new ServerBootstrap().group(group), +                    .channel(NioServerSocketChannel.class), +                    .handler(new LoggingHandler(LogLevel.INFO)), +                    .childHandler(new ChannelInitializer<Channel>() {, +                        @Override, +                        protected void initChannel(Channel ch) {, +                            ch.pipeline().addLast(sslServerCtx.newHandler(ch.alloc()));, +                            if (!serverProduceError) {, +                                ch.pipeline().addLast(new AlertValidationHandler(promise));, +                            }, +                            ch.pipeline().addLast(new ChannelInboundHandlerAdapter() {, +, +                                @Override, +                                public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {, +                                    ctx.close();, +                                }, +                            });, +                        }, +                    }).bind(0).sync().channel();, +, +            clientChannel = new Bootstrap().group(group), +                    .channel(NioSocketChannel.class), +                    .handler(new ChannelInitializer<Channel>() {, +                        @Override, +                        protected void initChannel(Channel ch) {, +                            ch.pipeline().addLast(sslClientCtx.newHandler(ch.alloc()));, +                            if (serverProduceError) {, +                                ch.pipeline().addLast(new AlertValidationHandler(promise));, +                            }, +                            ch.pipeline().addLast(new ChannelInboundHandlerAdapter() {, +, +                                @Override, +                                public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {, +                                    ctx.close();, +                                }, +                            });, +                        }, +                    }).connect(serverChannel.localAddress()).syncUninterruptibly().channel();, +            // Block until we received the correct exception, +            promise.syncUninterruptibly();, +        } finally {, +            if (clientChannel != null) {, +                clientChannel.close().syncUninterruptibly();, +            }, +            if (serverChannel != null) {, +                serverChannel.close().syncUninterruptibly();, +            }, +            group.shutdownGracefully();, +, +            ReferenceCountUtil.release(sslServerCtx);, +            ReferenceCountUtil.release(sslClientCtx);]