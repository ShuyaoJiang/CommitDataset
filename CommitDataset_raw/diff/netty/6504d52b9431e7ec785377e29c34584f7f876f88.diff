[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2ConnectionDecoder.java, +            connection.local().flowController(new DefaultHttp2LocalFlowController(connection));, +        connection.local().flowController().frameWriter(encoder.frameWriter());, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2ConnectionDecoder.java, +            connection.local().flowController(new DefaultHttp2LocalFlowController(connection));, +        connection.local().flowController().frameWriter(encoder.frameWriter());, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2ConnectionEncoder.java, +        return frameWriter.writePriority(ctx, streamId, streamDependency, weight, exclusive, promise);, +        return frameWriter.writeSettings(ctx, settings, promise);, +        return frameWriter.writeSettingsAck(ctx, promise);, +        return frameWriter.writePing(ctx, ack, data, promise);, +        return frameWriter.writePushPromise(ctx, streamId, promisedStreamId, headers, padding, promise);, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2ConnectionDecoder.java, +            connection.local().flowController(new DefaultHttp2LocalFlowController(connection));, +        connection.local().flowController().frameWriter(encoder.frameWriter());, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2ConnectionEncoder.java, +        return frameWriter.writePriority(ctx, streamId, streamDependency, weight, exclusive, promise);, +        return frameWriter.writeSettings(ctx, settings, promise);, +        return frameWriter.writeSettingsAck(ctx, promise);, +        return frameWriter.writePing(ctx, ack, data, promise);, +        return frameWriter.writePushPromise(ctx, streamId, promisedStreamId, headers, padding, promise);, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2LocalFlowController.java, +    private Http2FrameWriter frameWriter;, +    public DefaultHttp2LocalFlowController(Http2Connection connection) {, +        this(connection, DEFAULT_WINDOW_UPDATE_RATIO, false);, +    /**, +     * Constructs a controller with the given settings., +     *, +     * @param connection the connection state., +     * @param windowUpdateRatio the window percentage below which to send a {@code WINDOW_UPDATE}., +     * @param autoRefillConnectionWindow if {@code true}, effectively disables the connection window, +     * in the flow control algorithm as they will always refill automatically without requiring the, +     * application to consume the bytes. When enabled, the maximum bytes you must be prepared to, +     * queue is proportional to {@code maximum number of concurrent streams * the initial window, +     * size per stream}, +     * (<a href="https://tools.ietf.org/html/rfc7540#section-6.5.2">SETTINGS_MAX_CONCURRENT_STREAMS</a>, +     * <a href="https://tools.ietf.org/html/rfc7540#section-6.5.2">SETTINGS_INITIAL_WINDOW_SIZE</a>)., +     */, +                                           float windowUpdateRatio,, +                                           boolean autoRefillConnectionWindow) {, +        FlowState connectionState = autoRefillConnectionWindow ?, +                new AutoRefillState(connection.connectionStream(), initialWindowSize) :, +                new DefaultState(connection.connectionStream(), initialWindowSize);, +        connection.connectionStream().setProperty(stateKey, connectionState);, +    public DefaultHttp2LocalFlowController frameWriter(Http2FrameWriter frameWriter) {, +        this.frameWriter = checkNotNull(frameWriter, "frameWriter");, +        return this;, +    }, +, +    @Override, +        this.ctx = checkNotNull(ctx, "ctx");, +     * Flow control state that does autorefill of the flow control window when the data is, +     * received., +     */, +    private final class AutoRefillState extends DefaultState {, +        public AutoRefillState(Http2Stream stream, int initialWindowSize) {, +            super(stream, initialWindowSize);, +        }, +, +        @Override, +        public void receiveFlowControlledFrame(int dataLength) throws Http2Exception {, +            super.receiveFlowControlledFrame(dataLength);, +            // Need to call the super to consume the bytes, since this.consumeBytes does nothing., +            super.consumeBytes(dataLength);, +        }, +, +        @Override, +        public boolean consumeBytes(int numBytes) throws Http2Exception {, +            // Do nothing, since the bytes are already consumed upon receiving the data., +            return false;, +        }, +    }, +, +    /**, +    private class DefaultState implements FlowState {, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2ConnectionDecoder.java, +            connection.local().flowController(new DefaultHttp2LocalFlowController(connection));, +        connection.local().flowController().frameWriter(encoder.frameWriter());, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2ConnectionEncoder.java, +        return frameWriter.writePriority(ctx, streamId, streamDependency, weight, exclusive, promise);, +        return frameWriter.writeSettings(ctx, settings, promise);, +        return frameWriter.writeSettingsAck(ctx, promise);, +        return frameWriter.writePing(ctx, ack, data, promise);, +        return frameWriter.writePushPromise(ctx, streamId, promisedStreamId, headers, padding, promise);, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2LocalFlowController.java, +    private Http2FrameWriter frameWriter;, +    public DefaultHttp2LocalFlowController(Http2Connection connection) {, +        this(connection, DEFAULT_WINDOW_UPDATE_RATIO, false);, +    /**, +     * Constructs a controller with the given settings., +     *, +     * @param connection the connection state., +     * @param windowUpdateRatio the window percentage below which to send a {@code WINDOW_UPDATE}., +     * @param autoRefillConnectionWindow if {@code true}, effectively disables the connection window, +     * in the flow control algorithm as they will always refill automatically without requiring the, +     * application to consume the bytes. When enabled, the maximum bytes you must be prepared to, +     * queue is proportional to {@code maximum number of concurrent streams * the initial window, +     * size per stream}, +     * (<a href="https://tools.ietf.org/html/rfc7540#section-6.5.2">SETTINGS_MAX_CONCURRENT_STREAMS</a>, +     * <a href="https://tools.ietf.org/html/rfc7540#section-6.5.2">SETTINGS_INITIAL_WINDOW_SIZE</a>).]