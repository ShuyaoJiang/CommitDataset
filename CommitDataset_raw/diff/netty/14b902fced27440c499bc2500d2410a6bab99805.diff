[+++ b/common/src/main/java/io/netty/util/HashedWheelTimer.java, +import java.util.concurrent.atomic.AtomicBoolean;, +import java.util.concurrent.atomic.AtomicInteger;, +import static io.netty.util.internal.StringUtil.simpleClassName;, +, +    private static final AtomicInteger INSTANCE_COUNTER = new AtomicInteger();, +    private static final AtomicBoolean WARNED_TOO_MANY_INSTANCES = new AtomicBoolean();, +    private static final int INSTANCE_COUNT_LIMIT = 64;, +            .newResourceLeakDetector(HashedWheelTimer.class, 1);, +, +        if (INSTANCE_COUNTER.incrementAndGet() > INSTANCE_COUNT_LIMIT &&, +            WARNED_TOO_MANY_INSTANCES.compareAndSet(false, true)) {, +            reportTooManyInstances();, +        }, +    }, +, +    @Override, +    protected void finalize() throws Throwable {, +        try {, +            super.finalize();, +        } finally {, +            // This object is going to be GCed and it is assumed the ship has sailed to do a proper shutdown. If, +            // we have not yet shutdown then we want to make sure we decrement the active instance count., +            if (WORKER_STATE_UPDATER.getAndSet(this, WORKER_STATE_SHUTDOWN) != WORKER_STATE_SHUTDOWN) {, +                INSTANCE_COUNTER.decrementAndGet();, +            }, +        }, +            if (WORKER_STATE_UPDATER.getAndSet(this, WORKER_STATE_SHUTDOWN) != WORKER_STATE_SHUTDOWN) {, +                INSTANCE_COUNTER.decrementAndGet();, +            }, +        try {, +        } finally {, +            INSTANCE_COUNTER.decrementAndGet();, +        }, +    private static void reportTooManyInstances() {, +        String resourceType = simpleClassName(HashedWheelTimer.class);, +        logger.error("You are creating too many " + resourceType + " instances. " +, +                resourceType + " is a shared resource that must be reused across the JVM," +, +                "so that only a few instances are created.");, +    }, +, +               .append(simpleClassName(this)), +++ b/common/src/main/java/io/netty/util/HashedWheelTimer.java, +import java.util.concurrent.atomic.AtomicBoolean;, +import java.util.concurrent.atomic.AtomicInteger;, +import static io.netty.util.internal.StringUtil.simpleClassName;, +, +    private static final AtomicInteger INSTANCE_COUNTER = new AtomicInteger();, +    private static final AtomicBoolean WARNED_TOO_MANY_INSTANCES = new AtomicBoolean();, +    private static final int INSTANCE_COUNT_LIMIT = 64;, +            .newResourceLeakDetector(HashedWheelTimer.class, 1);, +, +        if (INSTANCE_COUNTER.incrementAndGet() > INSTANCE_COUNT_LIMIT &&, +            WARNED_TOO_MANY_INSTANCES.compareAndSet(false, true)) {, +            reportTooManyInstances();, +        }, +    }, +, +    @Override, +    protected void finalize() throws Throwable {, +        try {, +            super.finalize();, +        } finally {, +            // This object is going to be GCed and it is assumed the ship has sailed to do a proper shutdown. If, +            // we have not yet shutdown then we want to make sure we decrement the active instance count., +            if (WORKER_STATE_UPDATER.getAndSet(this, WORKER_STATE_SHUTDOWN) != WORKER_STATE_SHUTDOWN) {, +                INSTANCE_COUNTER.decrementAndGet();, +            }, +        }, +            if (WORKER_STATE_UPDATER.getAndSet(this, WORKER_STATE_SHUTDOWN) != WORKER_STATE_SHUTDOWN) {, +                INSTANCE_COUNTER.decrementAndGet();, +            }, +        try {, +        } finally {, +            INSTANCE_COUNTER.decrementAndGet();, +        }, +    private static void reportTooManyInstances() {, +        String resourceType = simpleClassName(HashedWheelTimer.class);, +        logger.error("You are creating too many " + resourceType + " instances. " +, +                resourceType + " is a shared resource that must be reused across the JVM," +, +                "so that only a few instances are created.");, +    }, +, +               .append(simpleClassName(this)), +++ b/common/src/main/java/io/netty/util/ResourceLeakDetector.java, +     * @deprecated Use {@link ResourceLeakDetector#ResourceLeakDetector(Class, int)}., +     * <p>, +     * This should not be used directly by users of {@link ResourceLeakDetector}., +     * Please use {@link ResourceLeakDetectorFactory#newResourceLeakDetector(Class)}, +     * or {@link ResourceLeakDetectorFactory#newResourceLeakDetector(Class, int, long)}, +     *, +     * @param maxActive This is deprecated and will be ignored., +     */, +    @Deprecated, +    public ResourceLeakDetector(Class<?> resourceType, int samplingInterval, long maxActive) {, +        this(resourceType, samplingInterval);, +    }, +, +    /**, +    public ResourceLeakDetector(Class<?> resourceType, int samplingInterval) {]