[+++ b/buffer/src/main/java/io/netty/buffer/UnpooledDirectByteBuf.java, +import io.netty.util.internal.DetectionUtil;, +import io.netty.util.internal.DirectByteBufUtil;, +, +    static void freeDirect(ByteBuffer buffer) {, +        if (DetectionUtil.canFreeDirectBuffer()) {, +            DirectByteBufUtil.freeDirect(buffer);, +        }, +    }, +++ b/buffer/src/main/java/io/netty/buffer/UnpooledDirectByteBuf.java, +import io.netty.util.internal.DetectionUtil;, +import io.netty.util.internal.DirectByteBufUtil;, +, +    static void freeDirect(ByteBuffer buffer) {, +        if (DetectionUtil.canFreeDirectBuffer()) {, +            DirectByteBufUtil.freeDirect(buffer);, +        }, +    }, +++ b/common/src/main/java/io/netty/util/internal/DetectionUtil.java, +        // Only try to use DirectByteBufUtil if it is not android as otherwise it will give errors because, +        // it try to access sun.misc.Cleaner, +        if (!isAndroid()) {, +                canFreeDirectBuffer = DirectByteBufUtil.canFreeDirect();, +        }, +     * Return {@code true} if {@link sun.misc.Unsafe} was found on the classpath and can be used., +        if (isAndroid()) {, +    private static boolean isAndroid() {, +        // Android, +        try {, +            Class.forName("android.app.Application", false, ClassLoader.getSystemClassLoader());, +            return true;, +        } catch (Exception e) {, +            // Ignore, +        }, +        return false;, +    }, +, +++ b/buffer/src/main/java/io/netty/buffer/UnpooledDirectByteBuf.java, +import io.netty.util.internal.DetectionUtil;, +import io.netty.util.internal.DirectByteBufUtil;, +, +    static void freeDirect(ByteBuffer buffer) {, +        if (DetectionUtil.canFreeDirectBuffer()) {, +            DirectByteBufUtil.freeDirect(buffer);, +        }, +    }, +++ b/common/src/main/java/io/netty/util/internal/DetectionUtil.java, +        // Only try to use DirectByteBufUtil if it is not android as otherwise it will give errors because, +        // it try to access sun.misc.Cleaner, +        if (!isAndroid()) {, +                canFreeDirectBuffer = DirectByteBufUtil.canFreeDirect();, +        }, +     * Return {@code true} if {@link sun.misc.Unsafe} was found on the classpath and can be used., +        if (isAndroid()) {, +    private static boolean isAndroid() {, +        // Android, +        try {, +            Class.forName("android.app.Application", false, ClassLoader.getSystemClassLoader());, +            return true;, +        } catch (Exception e) {, +            // Ignore, +        }, +        return false;, +    }, +, +++ b/common/src/main/java/io/netty/util/internal/DirectByteBufUtil.java, +/*, + * Copyright 2013 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + *   http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the, + * License for the specific language governing permissions and limitations, + * under the License., + */, +package io.netty.util.internal;, +, +import sun.misc.Cleaner;, +, +import java.lang.reflect.Field;, +import java.nio.ByteBuffer;, +, +// This resist in common because otherwise we would produce a cycle dependency between common and buffer., +public final class DirectByteBufUtil {, +, +    private static final Field CLEANER_FIELD;, +, +    static {, +        ByteBuffer direct = ByteBuffer.allocateDirect(1);, +        Field cleanerField;, +        try {, +            cleanerField = direct.getClass().getDeclaredField("cleaner");, +            cleanerField.setAccessible(true);, +            Cleaner cleaner = (Cleaner) cleanerField.get(direct);]