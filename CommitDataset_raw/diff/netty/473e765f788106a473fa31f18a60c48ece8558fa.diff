[+++ b/src/main/java/org/jboss/netty/util/HashedWheelTimer.java, +    public Timeout newTimeout(TimerTask task, long initialDelay, TimeUnit unit) {, +        if (task == null) {, +            throw new NullPointerException("task");, +        }, +        if (unit == null) {, +            throw new NullPointerException("unit");, +        }, +, +                    task, wheelCursor, System.nanoTime(), initialDelay);, +                    "delay must be greater than " +, +        private final TimerTask task;, +, +        private volatile boolean cancelled;, +        HashedWheelTimeout(TimerTask task, int startIndex, long startTime, long initialDelay) {, +            this.task = task;, +        public TimerTask getTask() {, +            return task;, +        }, +, +        public void cancel() {, +            if (cancelled) {, +                return;, +            }, +, +            synchronized (this) {, +            }, +            if (cancelled) {, +                throw new IllegalStateException("cancelled");, +            }, +, +                extensionCount ++;, +        public int getExtensionCount() {, +            return cancelled;, +            if (cancelled) {, +            long currentTime = System.nanoTime();, +            synchronized (this) {, +                return currentTime > deadline;, +            }, +            if (cancelled) {, +                return;, +            try {, +                task.run(this);, +            } catch (Throwable t) {, +                // FIXME log the exception, +            buf.append("initialDelay: ");, +            buf.append(initialDelay / 1000000);, +            buf.append(" ms, ");, +, +            buf.append("cumulativeDelay: ");, +            buf.append(cumulativeDelay / 1000000);, +            buf.append(" ms, ");, +                buf.append(remaining / 1000000);, +                buf.append(" ms later, ");, +                buf.append(-remaining / 1000000);, +                buf.append(" ms ago, ");, +                buf.append("now, ");, +            }, +, +            buf.append("extended: ");, +            switch (getExtensionCount()) {, +            case 0:, +                buf.append("never");, +                break;, +            case 1:, +                buf.append("once");, +                break;, +            default:, +                buf.append(getExtensionCount());, +                buf.append(" times");, +                break;, +            }, +, +            if (isCancelled()) {, +                buf.append (", cancelled");, +                100, TimeUnit.MILLISECONDS, 4);, +        timer.newTimeout(new TimerTask() {, +            public void run(Timeout timeout) throws Exception {, +                System.out.println(timeout.getExtensionCount() + ": " + timeout);, +                timeout.extend();, +            }, +        }, 1200, TimeUnit.MILLISECONDS);, +++ b/src/main/java/org/jboss/netty/util/HashedWheelTimer.java, +    public Timeout newTimeout(TimerTask task, long initialDelay, TimeUnit unit) {, +        if (task == null) {, +            throw new NullPointerException("task");, +        }, +        if (unit == null) {, +            throw new NullPointerException("unit");, +        }, +, +                    task, wheelCursor, System.nanoTime(), initialDelay);, +                    "delay must be greater than " +, +        private final TimerTask task;, +, +        private volatile boolean cancelled;, +        HashedWheelTimeout(TimerTask task, int startIndex, long startTime, long initialDelay) {, +            this.task = task;, +        public TimerTask getTask() {, +            return task;]