[+++ b/handler/src/main/java/io/netty/handler/timeout/IdleStateHandler.java, +import io.netty.channel.Channel.Unsafe;, +import io.netty.channel.ChannelOutboundBuffer;, +            lastWriteTime = ticksInNanos();, +    private final boolean observeOutput;, +    private long lastChangeCheckTimeStamp;, +    private int lastMessageHashCode;, +    private long lastPendingWriteBytes;, +, +     * @see #IdleStateHandler(boolean, long, long, long, TimeUnit), +     */, +    public IdleStateHandler(, +            long readerIdleTime, long writerIdleTime, long allIdleTime,, +            TimeUnit unit) {, +        this(false, readerIdleTime, writerIdleTime, allIdleTime, unit);, +    }, +, +    /**, +     * @param observeOutput, +     *        whether or not the consumption of {@code bytes} should be taken into, +     *        consideration when assessing write idleness. The default is {@code false}., +    public IdleStateHandler(boolean observeOutput,, +        this.observeOutput = observeOutput;, +, +            lastReadTime = ticksInNanos();, +        initOutputChanged(ctx);, +        lastReadTime = lastWriteTime = ticksInNanos();, +            readerIdleTimeout = schedule(ctx, new ReaderIdleTimeoutTask(ctx),, +            writerIdleTimeout = schedule(ctx, new WriterIdleTimeoutTask(ctx),, +            allIdleTimeout = schedule(ctx, new AllIdleTimeoutTask(ctx),, +    /**, +     * This method is visible for testing!, +     */, +    long ticksInNanos() {, +        return System.nanoTime();, +    }, +, +    /**, +     * This method is visible for testing!, +     */, +    ScheduledFuture<?> schedule(ChannelHandlerContext ctx, Runnable task, long delay, TimeUnit unit) {, +        return ctx.executor().schedule(task, delay, unit);, +    }, +, +                throw new IllegalArgumentException("Unhandled: state=" + state + ", first=" + first);, +    /**, +     * @see #hasOutputChanged(ChannelHandlerContext, boolean), +     */, +    private void initOutputChanged(ChannelHandlerContext ctx) {, +        if (observeOutput) {, +            Channel channel = ctx.channel();, +            Unsafe unsafe = channel.unsafe();, +            ChannelOutboundBuffer buf = unsafe.outboundBuffer();, +, +            if (buf != null) {, +                lastMessageHashCode = System.identityHashCode(buf.current());, +                lastPendingWriteBytes = buf.totalPendingWriteBytes();, +            }, +        }, +    }, +, +    /**, +     * Returns {@code true} if and only if the {@link IdleStateHandler} was constructed, +     * with {@link #observeOutput} enabled and there has been an observed change in the, +     * {@link ChannelOutboundBuffer} between two consecutive calls of this method., +     *, +     * https://github.com/netty/netty/issues/6150, +     */, +    private boolean hasOutputChanged(ChannelHandlerContext ctx, boolean first) {, +        if (observeOutput) {, +, +            // We can take this shortcut if the ChannelPromises that got passed into write(), +            // appear to complete. It indicates "change" on message level and we simply assume, +            // that there's change happening on byte level. If the user doesn't observe channel, +            // writability events then they'll eventually OOME and there's clearly a different, +            // problem and idleness is least of their concerns., +            if (lastChangeCheckTimeStamp != lastWriteTime) {, +                lastChangeCheckTimeStamp = lastWriteTime;, +, +                // But this applies only if it's the non-first call., +                if (!first) {, +                    return true;, +                }, +            }, +, +            Channel channel = ctx.channel();, +            Unsafe unsafe = channel.unsafe();, +            ChannelOutboundBuffer buf = unsafe.outboundBuffer();, +, +            if (buf != null) {, +                int messageHashCode = System.identityHashCode(buf.current());, +                long pendingWriteBytes = buf.totalPendingWriteBytes();, +, +                if (messageHashCode != lastMessageHashCode || pendingWriteBytes != lastPendingWriteBytes) {, +                    lastMessageHashCode = messageHashCode;, +                    lastPendingWriteBytes = pendingWriteBytes;, +, +                    if (!first) {, +                        return true;, +                    }]