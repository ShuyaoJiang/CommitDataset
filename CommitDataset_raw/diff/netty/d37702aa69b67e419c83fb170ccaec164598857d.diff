[+++ b/handler/src/main/java/io/netty/handler/ssl/SslHandler.java, +    private final LazyChannelPromise sslClosePromise = new LazyChannelPromise();, +        return sslClosePromise;, +, +        // Ensure we always notify the sslClosePromise as well, +        sslClosePromise.tryFailure(CHANNEL_CLOSED);, +        if (!(t instanceof SSLException) && t instanceof IOException && sslClosePromise.isDone()) {, +                sslClosePromise.trySuccess(ctx.channel());, +++ b/handler/src/main/java/io/netty/handler/ssl/SslHandler.java, +    private final LazyChannelPromise sslClosePromise = new LazyChannelPromise();, +        return sslClosePromise;, +, +        // Ensure we always notify the sslClosePromise as well, +        sslClosePromise.tryFailure(CHANNEL_CLOSED);, +        if (!(t instanceof SSLException) && t instanceof IOException && sslClosePromise.isDone()) {, +                sslClosePromise.trySuccess(ctx.channel());, +++ b/handler/src/test/java/io/netty/handler/ssl/SslHandlerTest.java, +import java.nio.channels.ClosedChannelException;, +, +    @Test, +    public void testCloseFutureNotified() throws Exception {, +        SslHandler handler = new SslHandler(SSLContext.getDefault().createSSLEngine());, +        EmbeddedChannel ch = new EmbeddedChannel(handler);, +, +        // Closing the Channel will also produce a close_notify so it is expected to return true., +        assertTrue(ch.finishAndReleaseAll());, +, +        assertTrue(handler.handshakeFuture().cause() instanceof ClosedChannelException);, +        assertTrue(handler.sslCloseFuture().cause() instanceof ClosedChannelException);, +    }]