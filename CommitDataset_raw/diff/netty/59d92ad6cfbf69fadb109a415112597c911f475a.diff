[+++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollSocketChannel.java, +                    byteBuf = allocHandle.allocate(allocator);, +++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollSocketChannel.java, +                    byteBuf = allocHandle.allocate(allocator);, +++ b/transport/src/main/java/io/netty/channel/nio/AbstractNioByteChannel.java, +                    byteBuf = allocHandle.allocate(allocator);, +++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollSocketChannel.java, +                    byteBuf = allocHandle.allocate(allocator);, +++ b/transport/src/main/java/io/netty/channel/nio/AbstractNioByteChannel.java, +                    byteBuf = allocHandle.allocate(allocator);, +++ b/transport/src/main/java/io/netty/channel/oio/AbstractOioByteChannel.java, +import io.netty.channel.RecvByteBufAllocator;, +    private RecvByteBufAllocator.Handle allocHandle;, +        RecvByteBufAllocator.Handle allocHandle = this.allocHandle;, +        if (allocHandle == null) {, +            this.allocHandle = allocHandle = config.getRecvByteBufAllocator().newHandle();, +        }, +, +        ByteBuf byteBuf = allocHandle.allocate(alloc());, +, +            int totalReadAmount = 0;, +, +, +                if (totalReadAmount >= Integer.MAX_VALUE - localReadAmount) {, +                    // Avoid overflow., +                    totalReadAmount = Integer.MAX_VALUE;, +                    break;, +                }, +, +                totalReadAmount += localReadAmount;, +, +            allocHandle.record(totalReadAmount);, +]