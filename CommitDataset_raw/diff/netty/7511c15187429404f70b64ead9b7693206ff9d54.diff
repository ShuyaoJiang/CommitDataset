[+++ b/transport/src/main/java/io/netty/channel/AbstractCoalescingBufferQueue.java, +     * Add a buffer to the front of the queue and associate a promise with it that should be completed when, +     * all the buffer's bytes have been consumed from the queue and written., +     * @param buf to add to the head of the queue, +     * @param promise to complete when all the bytes have been consumed and written, can be void., +        addFirst(buf, toChannelFutureListener(promise));, +    }, +    private void addFirst(ByteBuf buf, ChannelFutureListener listener) {, +        if (listener != null) {, +            bufAndListenerPairs.addFirst(listener);, +        }, +        bufAndListenerPairs.addFirst(buf);, +     * all the buffer's bytes have been consumed from the queue and written., +        add(buf, toChannelFutureListener(promise));, +, +    private static ChannelFutureListener toChannelFutureListener(ChannelPromise promise) {, +        return promise.isVoid() ? null : new DelegatingChannelPromiseNotifier(promise);, +    }, +++ b/transport/src/main/java/io/netty/channel/AbstractCoalescingBufferQueue.java, +     * Add a buffer to the front of the queue and associate a promise with it that should be completed when, +     * all the buffer's bytes have been consumed from the queue and written., +     * @param buf to add to the head of the queue, +     * @param promise to complete when all the bytes have been consumed and written, can be void., +        addFirst(buf, toChannelFutureListener(promise));, +    }, +    private void addFirst(ByteBuf buf, ChannelFutureListener listener) {, +        if (listener != null) {, +            bufAndListenerPairs.addFirst(listener);, +        }, +        bufAndListenerPairs.addFirst(buf);, +     * all the buffer's bytes have been consumed from the queue and written., +        add(buf, toChannelFutureListener(promise));, +, +    private static ChannelFutureListener toChannelFutureListener(ChannelPromise promise) {, +        return promise.isVoid() ? null : new DelegatingChannelPromiseNotifier(promise);, +    }, +++ b/transport/src/test/java/io/netty/channel/CoalescingBufferQueueTest.java, +    public void testAddFirstPromiseRetained() {, +        writeQueue.add(cat, catPromise);, +        assertQueueSize(3, false);, +        writeQueue.add(mouse, mouseListener);, +        assertQueueSize(8, false);, +        ChannelPromise aggregatePromise = newPromise();, +        assertEquals("catmous", dequeue(7, aggregatePromise));, +        ByteBuf remainder = Unpooled.wrappedBuffer("mous".getBytes(CharsetUtil.US_ASCII));, +        writeQueue.addFirst(remainder, aggregatePromise);, +        ChannelPromise aggregatePromise2 = newPromise();, +        assertEquals("mouse", dequeue(5, aggregatePromise2));, +        aggregatePromise2.setSuccess();, +        assertTrue(catPromise.isSuccess());, +        assertTrue(mouseSuccess);, +        assertEquals(0, cat.refCnt());, +        assertEquals(0, mouse.refCnt());, +    }, +, +    @Test, +    public void testAddFirstVoidPromise() {, +        writeQueue.add(cat, catPromise);, +        assertQueueSize(3, false);, +        writeQueue.add(mouse, mouseListener);, +        assertQueueSize(8, false);, +        ChannelPromise aggregatePromise = newPromise();, +        assertEquals("catmous", dequeue(7, aggregatePromise));, +        ByteBuf remainder = Unpooled.wrappedBuffer("mous".getBytes(CharsetUtil.US_ASCII));, +        writeQueue.addFirst(remainder, voidPromise);, +        ChannelPromise aggregatePromise2 = newPromise();, +        assertEquals("mouse", dequeue(5, aggregatePromise2));, +        aggregatePromise2.setSuccess();, +        // Because we used a void promise above, we shouldn't complete catPromise until aggregatePromise is completed., +        assertFalse(catPromise.isSuccess());, +        assertTrue(mouseSuccess);, +        aggregatePromise.setSuccess();, +        assertTrue(catPromise.isSuccess());, +        assertTrue(mouseSuccess);, +        assertEquals(0, cat.refCnt());, +        assertEquals(0, mouse.refCnt());, +    }, +, +    @Test]