[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2Connection.java, +    /**, +     * Closed streams may stay in the priority tree if they have dependents that are in prioritizable states., +     * When a stream is requested to be removed we can only actually remove that stream when there are no more, +     * prioritizable children., +     * (see [1] {@link Http2Stream#prioritizableForTree()} and [2] {@link DefaultStream#removeChild(DefaultStream)})., +     * When a priority tree edge changes we also have to re-evaluate viable nodes, +     * (see [3] {@link DefaultStream#takeChild(DefaultStream, boolean, List)})., +     * @param stream The stream to remove., +     */, +    void removeStream(DefaultStream stream) {, +        // [1] Check if this stream can be removed because it has no prioritizable descendants., +        if (stream.parent().removeChild(stream)) {, +            // Remove it from the map and priority tree., +            streamMap.remove(stream.id());, +, +        }, +        private int prioritizableForTree = 1;, +        public final Object setProperty(Object key, Object value) {, +        public final <V> V getProperty(Object key) {, +        public final <V> V removeProperty(Object key) {, +        public final int prioritizableForTree() {, +            return prioritizableForTree;, +        }, +, +        @Override, +            if (newParent != parent() || (exclusive && newParent.numChildren() != 1)) {, +                final List<ParentChangedEvent> events;, +            decrementPrioritizableForTree(1);, +        /**, +         * Recursively increment the {@link #prioritizableForTree} for this object up the parent links until, +         * either we go past the root or {@code oldParent} is encountered., +         * @param amt The amount to increment by. This must be positive., +         * @param oldParent The previous parent for this stream., +         */, +        private void incrementPrioritizableForTree(int amt, Http2Stream oldParent) {, +            if (amt != 0) {, +                incrementPrioritizableForTree0(amt, oldParent);, +            }, +        }, +, +        /**, +         * Direct calls to this method are discouraged., +         * Instead use {@link #incrementPrioritizableForTree(int, Http2Stream)}., +         */, +        private void incrementPrioritizableForTree0(int amt, Http2Stream oldParent) {, +            assert amt > 0;, +            prioritizableForTree += amt;, +            if (parent != null && parent != oldParent) {, +                parent.incrementPrioritizableForTree(amt, oldParent);, +            }, +        }, +, +        /**, +         * Recursively increment the {@link #prioritizableForTree} for this object up the parent links until, +         * either we go past the root., +         * @param amt The amount to decrement by. This must be positive., +         */, +        private void decrementPrioritizableForTree(int amt) {, +            if (amt != 0) {, +                decrementPrioritizableForTree0(amt);, +            }, +        }, +, +        /**, +         * Direct calls to this method are discouraged. Instead use {@link #decrementPrioritizableForTree(int)}., +         */, +        private void decrementPrioritizableForTree0(int amt) {, +            assert amt > 0;, +            prioritizableForTree -= amt;, +            if (parent != null) {, +                parent.decrementPrioritizableForTree(amt);, +            }, +        }, +, +        /**, +         * Determine if this node by itself is considered to be valid in the priority tree., +         */, +        private boolean isPrioritizable() {, +            return state != CLOSED;, +        }, +, +            prioritizableForTree = isPrioritizable() ? 1 : 0;, +                // move any previous children to the child node, becoming grand children of this node., +                incrementPrioritizableForTree(child.prioritizableForTree(), oldParent);, +                if (!child.isDescendantOf(oldParent)) {, +                    oldParent.decrementPrioritizableForTree(child.prioritizableForTree());, +                    if (oldParent.prioritizableForTree() == 0) {, +                        removeStream(oldParent);, +                    }, +                }, +        final boolean removeChild(DefaultStream child) {, +            if (child.prioritizableForTree() == 0 && children.remove(child.id()) != null) {, +                List<ParentChangedEvent> events = new ArrayList<ParentChangedEvent>(1 + child.numChildren());, +                decrementPrioritizableForTree(child.prioritizableForTree());, +                if (prioritizableForTree() == 0) {, +                    removeStream(this);, +                notifyParentChanged(events);, +                return true;, +            }]