[+++ b/transport/src/main/java/io/netty/channel/DefaultChannelHandlerContext.java, +    private static final int FLAG_REMOVED = 1;, +    private static final int FLAG_FREED = 2;, +, +    private int flags;, +, +    void setRemoved() {, +        flags |= FLAG_REMOVED;, +, +        // Free all buffers before completing removal., +        if (!channel.isRegistered()) {, +            freeHandlerBuffersAfterRemoval();, +    }, +, +    private void freeHandlerBuffersAfterRemoval() {, +        if (flags == FLAG_REMOVED) { // Removed, but not freed yet, +            flags |= FLAG_FREED;, +, +    }, +                    if ((flags & FLAG_FREED) == 0) {, +++ b/transport/src/main/java/io/netty/channel/DefaultChannelHandlerContext.java, +    private static final int FLAG_REMOVED = 1;, +    private static final int FLAG_FREED = 2;, +, +    private int flags;, +, +    void setRemoved() {, +        flags |= FLAG_REMOVED;, +, +        // Free all buffers before completing removal., +        if (!channel.isRegistered()) {, +            freeHandlerBuffersAfterRemoval();, +    }, +, +    private void freeHandlerBuffersAfterRemoval() {, +        if (flags == FLAG_REMOVED) { // Removed, but not freed yet, +            flags |= FLAG_FREED;, +, +    }, +                    if ((flags & FLAG_FREED) == 0) {, +++ b/transport/src/main/java/io/netty/channel/DefaultChannelPipeline.java, +import io.netty.util.internal.PlatformDependent;, +import java.util.concurrent.ExecutionException;, +        executeOnEventLoop(newCtx, new Runnable() {, +        executeOnEventLoop(newCtx, new Runnable() {, +        executeOnEventLoop(newCtx, new Runnable() {, +        executeOnEventLoop(newCtx, new Runnable() {, +    private static void callAfterRemove(, +            final DefaultChannelHandlerContext ctx, DefaultChannelHandlerContext ctxPrev,, +, +        ctx.setRemoved();, +    }, +    /**, +     * Executes a task on the event loop and waits for it to finish.  If the task is interrupted, then the, +     * current thread will be interrupted.  It is expected that the task performs any appropriate locking., +     * <p>, +     * If the {@link Runnable#run()} call throws a {@link Throwable}, but it is not an instance of, +     * {@link Error} or {@link RuntimeException}, then it is wrapped inside a, +     * {@link ChannelPipelineException} and that is thrown instead.</p>, +     *, +     * @param r execute this runnable, +     * @see Runnable#run(), +     * @see Future#get(), +     * @throws Error if the task threw this., +     * @throws RuntimeException if the task threw this., +     * @throws ChannelPipelineException with a {@link Throwable} as a cause, if the task threw another type of, +     *         {@link Throwable}., +     */, +    private static void executeOnEventLoop(DefaultChannelHandlerContext ctx, Runnable r) {, +        waitForFuture(ctx.executor().submit(r));, +    }, +, +    /**, +     * Waits for a future to finish.  If the task is interrupted, then the current thread will be interrupted., +     * It is expected that the task performs any appropriate locking., +     * <p>, +     * If the internal call throws a {@link Throwable}, but it is not an instance of {@link Error} or, +     * {@link RuntimeException}, then it is wrapped inside a {@link ChannelPipelineException} and that is, +     * thrown instead.</p>, +     *, +     * @param future wait for this future, +     * @see Future#get(), +     * @throws Error if the task threw this., +     * @throws RuntimeException if the task threw this., +     * @throws ChannelPipelineException with a {@link Throwable} as a cause, if the task threw another type of, +     *         {@link Throwable}., +     */, +    private static void waitForFuture(Future<?> future) {, +        try {, +            future.get();, +        } catch (ExecutionException ex) {, +            // In the arbitrary case, we can throw Error, RuntimeException, and Exception, +            PlatformDependent.throwException(ex.getCause());, +        } catch (InterruptedException ex) {, +            // Interrupt the calling thread (note that this method is not called from the event loop), +, +            Thread.currentThread().interrupt();]