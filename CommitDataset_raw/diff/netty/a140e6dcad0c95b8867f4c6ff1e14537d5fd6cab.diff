[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2StreamFrameToHttpObjectCodec.java, +import io.netty.util.Attribute;, +import io.netty.util.AttributeKey;, +, +    private static final AttributeKey<HttpScheme> SCHEME_ATTR_KEY =, +        AttributeKey.valueOf(HttpScheme.class, "STREAMFRAMECODEC_SCHEME");, +, +                    final Http2Headers headers = toHttp2Headers(ctx, res);, +            Http2Headers headers = toHttp2Headers(ctx, (HttpMessage) obj);, +    private Http2Headers toHttp2Headers(final ChannelHandlerContext ctx, final HttpMessage msg) {, +                    connectionScheme(ctx));, +        // this handler is typically used on an Http2StreamChannel. At this, +        final Attribute<HttpScheme> schemeAttribute = connectionSchemeAttribute(ctx);, +        if (schemeAttribute.get() == null) {, +            final HttpScheme scheme = isSsl(ctx) ? HttpScheme.HTTPS : HttpScheme.HTTP;, +            schemeAttribute.set(scheme);, +        }, +        final Channel connChannel = connectionChannel(ctx);, +, +    private static HttpScheme connectionScheme(ChannelHandlerContext ctx) {, +        final HttpScheme scheme = connectionSchemeAttribute(ctx).get();, +        return scheme == null ? HttpScheme.HTTP : scheme;, +    }, +, +    private static Attribute<HttpScheme> connectionSchemeAttribute(ChannelHandlerContext ctx) {, +        final Channel ch = connectionChannel(ctx);, +        return ch.attr(SCHEME_ATTR_KEY);, +    }, +, +    private static Channel connectionChannel(ChannelHandlerContext ctx) {, +        final Channel ch = ctx.channel();, +        return ch instanceof Http2StreamChannel ? ch.parent() : ch;, +    }, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2StreamFrameToHttpObjectCodec.java, +import io.netty.util.Attribute;, +import io.netty.util.AttributeKey;, +, +    private static final AttributeKey<HttpScheme> SCHEME_ATTR_KEY =, +        AttributeKey.valueOf(HttpScheme.class, "STREAMFRAMECODEC_SCHEME");, +, +                    final Http2Headers headers = toHttp2Headers(ctx, res);, +            Http2Headers headers = toHttp2Headers(ctx, (HttpMessage) obj);, +    private Http2Headers toHttp2Headers(final ChannelHandlerContext ctx, final HttpMessage msg) {, +                    connectionScheme(ctx));, +        // this handler is typically used on an Http2StreamChannel. At this, +        final Attribute<HttpScheme> schemeAttribute = connectionSchemeAttribute(ctx);, +        if (schemeAttribute.get() == null) {, +            final HttpScheme scheme = isSsl(ctx) ? HttpScheme.HTTPS : HttpScheme.HTTP;, +            schemeAttribute.set(scheme);, +        }, +        final Channel connChannel = connectionChannel(ctx);, +, +    private static HttpScheme connectionScheme(ChannelHandlerContext ctx) {, +        final HttpScheme scheme = connectionSchemeAttribute(ctx).get();, +        return scheme == null ? HttpScheme.HTTP : scheme;, +    }, +, +    private static Attribute<HttpScheme> connectionSchemeAttribute(ChannelHandlerContext ctx) {, +        final Channel ch = connectionChannel(ctx);, +        return ch.attr(SCHEME_ATTR_KEY);, +    }, +, +    private static Channel connectionChannel(ChannelHandlerContext ctx) {, +        final Channel ch = ctx.channel();, +        return ch instanceof Http2StreamChannel ? ch.parent() : ch;, +    }, +++ b/codec-http2/src/test/java/io/netty/handler/codec/http2/Http2StreamFrameToHttpObjectCodecTest.java, +import io.netty.channel.ChannelHandler;, +, +    @Test, +    public void testIsSharableBetweenChannels() throws Exception {, +        final Queue<Http2StreamFrame> frames = new ConcurrentLinkedQueue<Http2StreamFrame>();, +        final ChannelHandler sharedHandler = new Http2StreamFrameToHttpObjectCodec(false);, +, +        final SslContext ctx = SslContextBuilder.forClient().sslProvider(SslProvider.JDK).build();, +        EmbeddedChannel tlsCh = new EmbeddedChannel(ctx.newHandler(ByteBufAllocator.DEFAULT),, +            new ChannelOutboundHandlerAdapter() {, +                @Override, +                public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) {, +                    if (msg instanceof Http2StreamFrame) {, +                        frames.add((Http2StreamFrame) msg);, +                        promise.setSuccess();, +                    } else {, +                        ctx.write(msg, promise);, +                    }, +                }, +            }, sharedHandler);, +, +        EmbeddedChannel plaintextCh = new EmbeddedChannel(, +            new ChannelOutboundHandlerAdapter() {, +                @Override, +                public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) {, +                    if (msg instanceof Http2StreamFrame) {, +                        frames.add((Http2StreamFrame) msg);, +                        promise.setSuccess();, +                    } else {, +                        ctx.write(msg, promise);, +                    }, +                }, +            }, sharedHandler);]