[+++ b/codec/src/main/java/io/netty/handler/codec/ByteToMessageDecoder.java, +            channelInputClosed(ctx, out);, +     * Called when the input of the channel was closed which may be because it changed to inactive or because of, +     * {@link ChannelInputShutdownEvent}., +     */, +    void channelInputClosed(ChannelHandlerContext ctx, List<Object> out) throws Exception {, +        if (cumulation != null) {, +            callDecode(ctx, cumulation, out);, +            decodeLast(ctx, cumulation, out);, +        } else {, +            decodeLast(ctx, Unpooled.EMPTY_BUFFER, out);, +        }, +    }, +, +    /**, +++ b/codec/src/main/java/io/netty/handler/codec/ByteToMessageDecoder.java, +            channelInputClosed(ctx, out);, +     * Called when the input of the channel was closed which may be because it changed to inactive or because of, +     * {@link ChannelInputShutdownEvent}., +     */, +    void channelInputClosed(ChannelHandlerContext ctx, List<Object> out) throws Exception {, +        if (cumulation != null) {, +            callDecode(ctx, cumulation, out);, +            decodeLast(ctx, cumulation, out);, +        } else {, +            decodeLast(ctx, Unpooled.EMPTY_BUFFER, out);, +        }, +    }, +, +    /**, +++ b/codec/src/main/java/io/netty/handler/codec/ReplayingDecoder.java, +import io.netty.buffer.Unpooled;, +    final void channelInputClosed(ChannelHandlerContext ctx, List<Object> out) throws Exception {, +            if (cumulation != null) {, +            } else {, +                replayable.setCumulation(Unpooled.EMPTY_BUFFER);, +                decodeLast(ctx, replayable, out);, +            }, +++ b/codec/src/main/java/io/netty/handler/codec/ByteToMessageDecoder.java, +            channelInputClosed(ctx, out);, +     * Called when the input of the channel was closed which may be because it changed to inactive or because of, +     * {@link ChannelInputShutdownEvent}., +     */, +    void channelInputClosed(ChannelHandlerContext ctx, List<Object> out) throws Exception {, +        if (cumulation != null) {, +            callDecode(ctx, cumulation, out);, +            decodeLast(ctx, cumulation, out);, +        } else {, +            decodeLast(ctx, Unpooled.EMPTY_BUFFER, out);, +        }, +    }, +, +    /**, +++ b/codec/src/main/java/io/netty/handler/codec/ReplayingDecoder.java, +import io.netty.buffer.Unpooled;, +    final void channelInputClosed(ChannelHandlerContext ctx, List<Object> out) throws Exception {, +            if (cumulation != null) {, +            } else {, +                replayable.setCumulation(Unpooled.EMPTY_BUFFER);, +                decodeLast(ctx, replayable, out);, +            }, +++ b/codec/src/test/java/io/netty/handler/codec/ReplayingDecoderTest.java, +import io.netty.channel.socket.ChannelInputShutdownEvent;, +import java.util.concurrent.atomic.AtomicReference;, +, +    @Test, +    public void testChannelInputShutdownEvent() {, +        final AtomicReference<Error> error = new AtomicReference<Error>();, +, +        EmbeddedChannel channel = new EmbeddedChannel(new ReplayingDecoder<Integer>(0) {, +            private boolean decoded;, +, +            @Override, +            protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) throws Exception {, +                if (!(in instanceof ReplayingDecoderByteBuf)) {, +                    error.set(new AssertionError("in must be of type " + ReplayingDecoderByteBuf.class, +                            + " but was " + in.getClass()));, +                    return;, +                }, +                if (!decoded) {, +                    decoded = true;, +                    in.readByte();, +                    state(1);, +                } else {, +                    // This will throw an ReplayingError, +                    in.skipBytes(Integer.MAX_VALUE);, +                }, +            }, +        });, +, +        assertFalse(channel.writeInbound(Unpooled.wrappedBuffer(new byte[] {0, 1})));, +        channel.pipeline().fireUserEventTriggered(ChannelInputShutdownEvent.INSTANCE);, +        assertFalse(channel.finishAndReleaseAll());, +, +        Error err = error.get();, +        if (err != null) {, +            throw err;, +        }, +    }]