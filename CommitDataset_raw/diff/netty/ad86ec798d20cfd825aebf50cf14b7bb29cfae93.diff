[+++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, +        int newCapacity = alloc().calculateNewCapacity(writerIndex + minWritableBytes, maxCapacity);, +        int newCapacity = alloc().calculateNewCapacity(writerIndex + minWritableBytes, maxCapacity);, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, +        int newCapacity = alloc().calculateNewCapacity(writerIndex + minWritableBytes, maxCapacity);, +        int newCapacity = alloc().calculateNewCapacity(writerIndex + minWritableBytes, maxCapacity);, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBufAllocator.java, +, +    @Override, +    public int calculateNewCapacity(int minNewCapacity, int maxCapacity) {, +        if (minNewCapacity < 0) {, +            throw new IllegalArgumentException("minNewCapacity: " + minNewCapacity + " (expectd: 0+)");, +        }, +        if (minNewCapacity > maxCapacity) {, +            throw new IllegalArgumentException(String.format(, +                    "minNewCapacity: %d (expected: not greater than maxCapacity(%d)",, +                    minNewCapacity, maxCapacity));, +        }, +        final int threshold = 1048576 * 4; // 4 MiB page, +, +        if (minNewCapacity == threshold) {, +            return threshold;, +        }, +, +        // If over threshold, do not double but just increase by threshold., +        if (minNewCapacity > threshold) {, +            int newCapacity = minNewCapacity / threshold * threshold;, +            if (newCapacity > maxCapacity - threshold) {, +                newCapacity = maxCapacity;, +            } else {, +                newCapacity += threshold;, +            }, +            return newCapacity;, +        }, +, +        // Not over threshold. Double up to 4 MiB, starting from 64., +        int newCapacity = 64;, +        while (newCapacity < minNewCapacity) {, +            newCapacity <<= 1;, +        }, +, +        return Math.min(newCapacity, maxCapacity);, +    }, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, +        int newCapacity = alloc().calculateNewCapacity(writerIndex + minWritableBytes, maxCapacity);, +        int newCapacity = alloc().calculateNewCapacity(writerIndex + minWritableBytes, maxCapacity);, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBufAllocator.java, +, +    @Override, +    public int calculateNewCapacity(int minNewCapacity, int maxCapacity) {, +        if (minNewCapacity < 0) {, +            throw new IllegalArgumentException("minNewCapacity: " + minNewCapacity + " (expectd: 0+)");, +        }, +        if (minNewCapacity > maxCapacity) {, +            throw new IllegalArgumentException(String.format(, +                    "minNewCapacity: %d (expected: not greater than maxCapacity(%d)",, +                    minNewCapacity, maxCapacity));, +        }, +        final int threshold = 1048576 * 4; // 4 MiB page, +, +        if (minNewCapacity == threshold) {, +            return threshold;, +        }, +, +        // If over threshold, do not double but just increase by threshold., +        if (minNewCapacity > threshold) {, +            int newCapacity = minNewCapacity / threshold * threshold;, +            if (newCapacity > maxCapacity - threshold) {, +                newCapacity = maxCapacity;, +            } else {, +                newCapacity += threshold;, +            }, +            return newCapacity;, +        }, +, +        // Not over threshold. Double up to 4 MiB, starting from 64., +        int newCapacity = 64;, +        while (newCapacity < minNewCapacity) {, +            newCapacity <<= 1;, +        }, +, +        return Math.min(newCapacity, maxCapacity);, +    }, +++ b/buffer/src/main/java/io/netty/buffer/ByteBufAllocator.java, +, +    /**, +     * Calculate the new capacity of a {@link ByteBuf} that is used when a {@link ByteBuf} needs to expand by the, +     * {@code minNewCapacity} with {@code maxCapacity} as upper-bound., +     */, +    int calculateNewCapacity(int minNewCapacity, int maxCapacity);]