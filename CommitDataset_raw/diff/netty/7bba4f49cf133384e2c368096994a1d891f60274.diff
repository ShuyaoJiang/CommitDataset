[+++ b/testsuite/src/main/java/io/netty/testsuite/transport/socket/DatagramUnicastTest.java, +            sc = setupServerChannel(sb, bytes, latch, false);, +        final CountDownLatch clientLatch = new CountDownLatch(count);, +, +        cb.handler(new SimpleChannelInboundHandler<DatagramPacket>() {, +            public void channelRead0(ChannelHandlerContext ctx, DatagramPacket msg) throws Exception {, +                ByteBuf buf = msg.content();, +                assertEquals(bytes.length, buf.readableBytes());, +                for (int i = 0; i < bytes.length; i++) {, +                    assertEquals(bytes[i], buf.getByte(buf.readerIndex() + i));, +                }, +, +                // Test that the channel's localAddress is equal to the message's recipient, +                assertEquals(ctx.channel().localAddress(), msg.recipient());, +, +                clientLatch.countDown();, +            sc = setupServerChannel(sb, bytes, latch, true);, +            assertTrue(clientLatch.await(10, TimeUnit.SECONDS));, +    private Channel setupServerChannel(Bootstrap sb, final byte[] bytes, final CountDownLatch latch, final boolean echo), +                        for (int i = 0; i < bytes.length; i++) {, +                            assertEquals(bytes[i], buf.getByte(buf.readerIndex() + i));, +                        if (echo) {, +                            ctx.writeAndFlush(new DatagramPacket(buf.retainedDuplicate(), msg.sender()));, +                        }, +++ b/testsuite/src/main/java/io/netty/testsuite/transport/socket/DatagramUnicastTest.java, +            sc = setupServerChannel(sb, bytes, latch, false);, +        final CountDownLatch clientLatch = new CountDownLatch(count);, +, +        cb.handler(new SimpleChannelInboundHandler<DatagramPacket>() {, +            public void channelRead0(ChannelHandlerContext ctx, DatagramPacket msg) throws Exception {, +                ByteBuf buf = msg.content();, +                assertEquals(bytes.length, buf.readableBytes());, +                for (int i = 0; i < bytes.length; i++) {, +                    assertEquals(bytes[i], buf.getByte(buf.readerIndex() + i));, +                }, +, +                // Test that the channel's localAddress is equal to the message's recipient, +                assertEquals(ctx.channel().localAddress(), msg.recipient());, +, +                clientLatch.countDown();, +            sc = setupServerChannel(sb, bytes, latch, true);, +            assertTrue(clientLatch.await(10, TimeUnit.SECONDS));, +    private Channel setupServerChannel(Bootstrap sb, final byte[] bytes, final CountDownLatch latch, final boolean echo), +                        for (int i = 0; i < bytes.length; i++) {, +                            assertEquals(bytes[i], buf.getByte(buf.readerIndex() + i));, +                        if (echo) {, +                            ctx.writeAndFlush(new DatagramPacket(buf.retainedDuplicate(), msg.sender()));, +                        }, +++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollDatagramChannel.java, +import io.netty.channel.unix.Errors;, +import java.net.PortUnreachableException;, +                ByteBuf byteBuf = null;, +                    boolean connected = isConnected();, +                        byteBuf = allocHandle.allocate(allocator);, +                        allocHandle.attemptedBytesRead(byteBuf.writableBytes());, +, +                        final DatagramPacket packet;, +                        if (connected) {, +                            try {, +                                allocHandle.lastBytesRead(doReadBytes(byteBuf));, +                            } catch (Errors.NativeIoException e) {, +                                // We need to correctly translate connect errors to match NIO behaviour., +                                if (e.expectedErr() == Errors.ERROR_ECONNREFUSED_NEGATIVE) {, +                                    PortUnreachableException error = new PortUnreachableException(e.getMessage());, +                                    error.initCause(e);, +                                    throw error;, +                                }, +                                throw e;, +                            }, +                            if (allocHandle.lastBytesRead() <= 0) {, +                                // nothing was read, release the buffer., +                                byteBuf.release();, +                                byteBuf = null;, +                                break;, +                            }, +                            packet = new DatagramPacket(, +                                    byteBuf, (InetSocketAddress) localAddress(), (InetSocketAddress) remoteAddress());, +                            final DatagramSocketAddress remoteAddress;, +                            if (byteBuf.hasMemoryAddress()) {, +                                // has a memory address so use optimized call, +                                remoteAddress = socket.recvFromAddress(byteBuf.memoryAddress(), byteBuf.writerIndex(),, +                                        byteBuf.capacity());, +                            } else {, +                                ByteBuffer nioData = byteBuf.internalNioBuffer(, +                                        byteBuf.writerIndex(), byteBuf.writableBytes());, +                                byteBuf.release();, +                                byteBuf = null;, +                            allocHandle.lastBytesRead(remoteAddress.receivedAmount());, +                            byteBuf.writerIndex(byteBuf.writerIndex() + allocHandle.lastBytesRead());, +, +                            packet = new DatagramPacket(byteBuf, localAddress, remoteAddress);, +                        }, +                        pipeline.fireChannelRead(packet);, +                        byteBuf = null;, +                    if (byteBuf != null) {, +                        byteBuf.release();, +++ b/testsuite/src/main/java/io/netty/testsuite/transport/socket/DatagramUnicastTest.java, +            sc = setupServerChannel(sb, bytes, latch, false);, +        final CountDownLatch clientLatch = new CountDownLatch(count);, +]