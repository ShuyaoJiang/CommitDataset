[+++ b/transport/src/main/java/io/netty/bootstrap/Bootstrap.java, +    ChannelFuture doBind(final SocketAddress localAddress) {, +        final Channel channel = channelFactory().newChannel();, +        final ChannelPromise promise = channel.newPromise();, +        if (initPromise.isDone()) {, +            doBind0(initPromise, channel, localAddress, promise);, +        } else {, +            initPromise.addListener(new ChannelFutureListener() {, +                @Override, +                public void operationComplete(ChannelFuture future) throws Exception {, +                    doBind0(future, channel, localAddress, promise);, +                }, +            });, +        }, +, +        return promise;, +    }, +, +    private static void doBind0(ChannelFuture initFuture, Channel channel, SocketAddress localAddress, ChannelPromise promise) {, +        if (initFuture.isSuccess()) {, +            channel.bind(localAddress, promise).addListener(ChannelFutureListener.CLOSE_ON_FAILURE);, +        } else {, +            promise.setFailure(initFuture.cause());, +        }, +    private ChannelFuture doConnect(final SocketAddress remoteAddress, final SocketAddress localAddress) {, +        final ChannelPromise promise = channel.newPromise();, +        if (initPromise.isDone()) {, +            doConnect0(initPromise, channel, remoteAddress, localAddress, promise);, +            initPromise.addListener(new ChannelFutureListener() {, +                @Override, +                public void operationComplete(ChannelFuture future) throws Exception {, +                    doConnect0(future, channel, remoteAddress, localAddress, promise);, +                }, +            });, +        return promise;, +    }, +, +    private static void doConnect0(, +            ChannelFuture initFuture, Channel channel,, +            SocketAddress remoteAddress, SocketAddress localAddress, ChannelPromise promise) {, +, +        if (initFuture.isSuccess()) {, +            if (localAddress == null) {, +                channel.connect(remoteAddress, promise);, +            } else {, +                channel.connect(remoteAddress, localAddress, promise);, +            }, +            promise.addListener(ChannelFutureListener.CLOSE_ON_FAILURE);, +        } else {, +            promise.setFailure(initFuture.cause());, +        }]