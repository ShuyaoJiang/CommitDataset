[+++ b/example/src/main/java/io/netty/example/http/file/HttpStaticFileServerHandler.java, +        final boolean keepAlive = HttpUtil.isKeepAlive(request);, +                sendListing(ctx, file, uri, keepAlive);, +                sendRedirect(ctx, uri + '/', keepAlive);, +                sendNotModified(ctx, keepAlive);, +, +        if (!keepAlive) {, +            response.headers().set(HttpHeaderNames.CONNECTION, HttpHeaderValues.CLOSE);, +        if (!keepAlive) {, +    private static void sendListing(ChannelHandlerContext ctx, File dir, String dirPath, boolean keepAlive) {, +        sendAndCleanupConnection(ctx, response, keepAlive);, +    private static void sendRedirect(ChannelHandlerContext ctx, String newUri, boolean keepAlive) {, +        sendAndCleanupConnection(ctx, response, keepAlive);, +        sendAndCleanupConnection(ctx, response, false);, +    private static void sendNotModified(ChannelHandlerContext ctx, boolean keepAlive) {, +        sendAndCleanupConnection(ctx, response, keepAlive);, +    }, +, +    /**, +     * If Keep-Alive is disabled, attaches "Connection: close" header to the response, +     * and closes the connection after the response being sent., +     */, +    private static void sendAndCleanupConnection(ChannelHandlerContext ctx, FullHttpResponse response,, +                                                 boolean keepAlive) {, +        HttpUtil.setContentLength(response, response.content().readableBytes());, +        if (!keepAlive) {, +            // We're going to close the connection as soon as the response is sent,, +            // so we should also make it clear for the client., +            response.headers().set(HttpHeaderNames.CONNECTION, HttpHeaderValues.CLOSE);, +        }, +, +        ChannelFuture flushPromise = ctx.writeAndFlush(response);, +, +        if (!keepAlive) {, +            // Close the connection as soon as the response is sent., +            flushPromise.addListener(ChannelFutureListener.CLOSE);, +        }]