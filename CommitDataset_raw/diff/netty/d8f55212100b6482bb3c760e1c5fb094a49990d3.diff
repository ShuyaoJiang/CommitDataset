[+++ b/transport/src/main/java/io/netty/channel/ChannelFlushPromiseNotifier.java, +        if (newWriteCounter >= 0x8000000000L) {, +++ b/transport/src/main/java/io/netty/channel/ChannelFlushPromiseNotifier.java, +        if (newWriteCounter >= 0x8000000000L) {, +++ b/transport/src/main/java/io/netty/channel/DefaultChannelPromise.java, +     * The first 24 bits of this field represents the number of waiters waiting for this promise with await*()., +     * The other 40 bits of this field represents the flushCheckpoint used by ChannelFlushPromiseNotifier and, +     * AbstractChannel.Unsafe.flush()., +     */, +                incWaiters();, +                    decWaiters();, +                incWaiters();, +                    decWaiters();, +                incWaiters();, +                    decWaiters();, +            if (hasWaiters()) {, +        return flushCheckpoint & 0x000000FFFFFFFFFFL;, +        if ((checkpoint & 0xFFFFFF0000000000L) != 0) {, +            throw new IllegalStateException("flushCheckpoint overflow");, +        }, +        flushCheckpoint = flushCheckpoint & 0xFFFFFF0000000000L | checkpoint;, +    }, +, +    private boolean hasWaiters() {, +        return (flushCheckpoint & 0xFFFFFF0000000000L) != 0;, +    }, +, +    private void incWaiters() {, +        long waiters = waiters() + 1;, +        if ((waiters & 0xFFFFFFFFFF000000L) != 0) {, +            throw new IllegalStateException("too many waiters");, +        }, +        flushCheckpoint = flushCheckpoint() | waiters << 40L;, +    }, +, +    private void decWaiters() {, +        flushCheckpoint = flushCheckpoint() | waiters() - 1L << 40L;, +    }, +, +    private long waiters() {, +        return flushCheckpoint >>> 40;]