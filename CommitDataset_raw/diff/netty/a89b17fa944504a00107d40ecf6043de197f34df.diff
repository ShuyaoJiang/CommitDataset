[+++ b/transport/src/main/java/io/netty/channel/AbstractChannel.java, +                ChannelOutboundBuffer outboundBuffer = this.outboundBuffer;, +                this.outboundBuffer = null; // Disallow adding any messages and flushes to outboundBuffer., +, +                // Fail all the queued messages, +                    outboundBuffer.close(CLOSED_CHANNEL_EXCEPTION);, +++ b/transport/src/main/java/io/netty/channel/AbstractChannel.java, +                ChannelOutboundBuffer outboundBuffer = this.outboundBuffer;, +                this.outboundBuffer = null; // Disallow adding any messages and flushes to outboundBuffer., +, +                // Fail all the queued messages, +                    outboundBuffer.close(CLOSED_CHANNEL_EXCEPTION);, +++ b/transport/src/main/java/io/netty/channel/ChannelOutboundBuffer.java, +import java.nio.channels.ClosedChannelException;, +    void close(final ClosedChannelException cause) {, +        if (inFail) {, +            channel.eventLoop().execute(new Runnable() {, +                @Override, +                public void run() {, +                    close(cause);, +                }, +            });, +            return;, +        }, +, +        inFail = true;, +, +        if (channel.isOpen()) {, +            throw new IllegalStateException("close() must be invoked after the channel is closed.");, +        }, +, +        if (head != tail) {, +            throw new IllegalStateException("close() must be invoked after all flushed writes are handled.");, +        }, +, +        // Release all unflushed messages., +        Object[] unflushed = this.unflushed;, +        ChannelPromise[] unflushedPromises = this.unflushedPromises;, +        int[] unflushedPendingSizes = this.unflushedPendingSizes;, +        final int unflushedCount = this.unflushedCount;, +        try {, +            for (int i = 0; i < unflushedCount; i++) {, +                safeRelease(unflushed[i]);, +                unflushed[i] = null;, +                safeFail(unflushedPromises[i], cause);, +                unflushedPromises[i] = null;, +                // Just decrease; do not trigger any events via decrementPendingOutboundBytes(), +                totalPendingSize -= unflushedPendingSizes[i];, +                unflushedPendingSizes[i] = 0;, +            }, +        } finally {, +            this.unflushedCount = 0;, +            inFail = false;, +        }, +, +        RECYCLER.recycle(this, handle);, +    }, +]