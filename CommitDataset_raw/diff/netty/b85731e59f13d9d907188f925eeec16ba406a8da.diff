[+++ b/src/main/java/org/jboss/netty/util/internal/LinkedTransferQueue.java, + * @version $Rev$, $Date$ (Upstream: 1.79), +     * for appends, so can only be removed later after other nodes are, +     * estimate of possible unsplice failures (in "sweepVotes")., +     * We trigger a full sweep when the estimate exceeds a threshold, +     * ("SWEEP_THRESHOLD") indicating the maximum number of estimated, +     * removal failures to tolerate before sweeping through, unlinking, +     * cancelled nodes that were not unlinked upon initial removal., +     * We perform sweeps by the thread hitting threshold (rather than, +     * background threads or by spreading work to other threads), +     * because in the main contexts in which removal occurs, the, +     * caller is already timed-out, cancelled, or performing a, +     * potentially O(n) operation (e.g. remove(x)), none of which are, +     * time-critical enough to warrant the overhead that alternatives, +     * would impose on other threads., +            // assert cmp == null || cmp.getClass() != Node.class;, +         * Constructs a new node.  Uses relaxed write because item can, +         * only be seen after publication via casNext., +            // assert isData;, +        // assert item == null || item.getClass() != Node.class;, +                    if (isData == haveData) { // can't match, +            } else if ((n = p.next) != null) { // not last; keep traversing, +                // assert item != s;, +            if (pred.isData != haveData) {    // phase change, +            if (pred.isMatched()) {           // probably at front, +            if (pred.waiter == null) {        // pred apparently spinning, +                if (++count == Integer.MAX_VALUE) { // saturated, +     * Unlinks matched (typically cancelled) nodes encountered in a, +     * traversal from head., +            if (!s.isMatched()) {, +                // Unmatched nodes are never self-linked, +            } else if ((n = s.next) == null) { // trailing node is pinned, +            } else if (s == n) { // stale, +                // No need to also check for p == s, since that implies s == n, +                p = head;]