[+++ b/handler/src/main/java/io/netty/handler/ssl/SslHandler.java, +import io.netty.buffer.CompositeByteBuf;, +    /**, +     * Used in {@link #unwrapNonAppData(ChannelHandlerContext)} as input for, +     * {@link #unwrap(ChannelHandlerContext, ByteBuffer, int)}.  Using this static instance reduce object, +     * creation as {@link Unpooled#EMPTY_BUFFER#nioBuffer()} creates a new {@link ByteBuffer} everytime., +     */, +    private static final ByteBuffer EMPTY_DIRECT_BYTEBUFFER = Unpooled.EMPTY_BUFFER.nioBuffer();, +    /**, +     * Used if {@link SSLEngine#wrap(ByteBuffer[], ByteBuffer)} should be called with a {@link ByteBuf} that is only, +     * backed by one {@link ByteBuffer} to reduce the object creation., +     */, +    private final ByteBuffer[] singleWrapBuffer = new ByteBuffer[1];, +, +            int readerIndex = in.readerIndex();, +, +            // We will call SslEngine.wrap(ByteBuffer[], ByteBuffer) to allow efficient handling of, +            // CompositeByteBuf without force an extra memory copy when CompositeByteBuffer.nioBuffer() is called., +            final ByteBuffer[] in0;, +            if (in.isDirect() || !wantsDirectBuffer) {, +                // As CompositeByteBuf.nioBufferCount() can be expensive (as it needs to check all composed ByteBuf, +                // to calculate the count) we will just assume a CompositeByteBuf contains more then 1 ByteBuf., +                // The worst that can happen is that we allocate an extra ByteBuffer[] in CompositeByteBuf.nioBuffers(), +                // which is better then walking the composed ByteBuf in most cases., +                if (!(in instanceof CompositeByteBuf) && in.nioBufferCount() == 1) {, +                    in0 = singleWrapBuffer;, +                    // We know its only backed by 1 ByteBuffer so use internalNioBuffer to keep object allocation, +                    // to a minimum., +                    in0[0] = in.internalNioBuffer(readerIndex, readableBytes);, +                } else {, +                    in0 = in.nioBuffers();, +                }, +            } else {, +                // We could even go further here and check if its a CompositeByteBuf and if so try to decompose it and, +                // only replace the ByteBuffer that are not direct. At the moment we just will replace the whole, +                // CompositeByteBuf to keep the complexity to a minimum, +                newDirectIn.writeBytes(in, readerIndex, readableBytes);, +                in0 = singleWrapBuffer;, +                in0[0] = newDirectIn.internalNioBuffer(0, readableBytes);, +            // Null out to allow GC of ByteBuffer, +            singleWrapBuffer[0] = null;, +, +        unwrap(ctx, EMPTY_DIRECT_BYTEBUFFER, 0);]