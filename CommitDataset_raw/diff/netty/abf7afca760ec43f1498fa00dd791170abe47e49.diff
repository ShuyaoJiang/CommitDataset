[+++ b/transport/src/main/java/io/netty/channel/PendingWriteQueue.java, +        // Guard against re-entrance by directly reset, +        head = tail = null;, +        size = 0;, +, +            recycle(write, false);, +, +        recycle(write, true);, +, +        if (size == 1) {, +            // No need to use ChannelPromiseAggregator for this case., +            return removeAndWrite();, +        }, +, +        // Guard against re-entrance by directly reset, +        head = tail = null;, +        size = 0;, +, +            recycle(write, false);, +        recycle(write, true);, +        recycle(write, true);, +    private void recycle(PendingWrite write, boolean update) {, +        if (update) {, +                // Guard against re-entrance by directly reset, +                size = 0;, +                size --;, +        }, +++ b/transport/src/main/java/io/netty/channel/PendingWriteQueue.java, +        // Guard against re-entrance by directly reset, +        head = tail = null;, +        size = 0;, +, +            recycle(write, false);, +, +        recycle(write, true);, +, +        if (size == 1) {, +            // No need to use ChannelPromiseAggregator for this case., +            return removeAndWrite();, +        }, +, +        // Guard against re-entrance by directly reset, +        head = tail = null;, +        size = 0;, +, +            recycle(write, false);, +        recycle(write, true);, +        recycle(write, true);, +    private void recycle(PendingWrite write, boolean update) {, +        if (update) {, +                // Guard against re-entrance by directly reset, +                size = 0;, +                size --;, +        }, +++ b/transport/src/test/java/io/netty/channel/PendingWriteQueueTest.java, +    @Test, +    public void testRemoveAndFailAllReentrance() {, +        EmbeddedChannel channel = new EmbeddedChannel(new ChannelInboundHandlerAdapter());, +        final PendingWriteQueue queue = new PendingWriteQueue(channel.pipeline().firstContext());, +, +        ChannelPromise promise = channel.newPromise();, +        promise.addListener(new ChannelFutureListener() {, +            @Override, +            public void operationComplete(ChannelFuture future) throws Exception {, +                queue.removeAndFailAll(new IllegalStateException());, +            }, +        });, +        queue.add(1L, promise);, +, +        ChannelPromise promise2 = channel.newPromise();, +        queue.add(2L, promise2);, +        queue.removeAndFailAll(new Exception());, +        assertFalse(promise.isSuccess());, +        assertFalse(promise2.isSuccess());, +        assertFalse(channel.finish());, +    }, +, +    @Test, +    public void testRemoveAndWriteAllReentrance() {, +        EmbeddedChannel channel = new EmbeddedChannel(new ChannelInboundHandlerAdapter());, +        final PendingWriteQueue queue = new PendingWriteQueue(channel.pipeline().firstContext());, +, +        ChannelPromise promise = channel.newPromise();, +        promise.addListener(new ChannelFutureListener() {, +            @Override, +            public void operationComplete(ChannelFuture future) throws Exception {, +                queue.removeAndWriteAll();, +            }, +        });, +        queue.add(1L, promise);, +, +        ChannelPromise promise2 = channel.newPromise();, +        queue.add(2L, promise2);, +        queue.removeAndWriteAll();, +        channel.flush();, +        assertTrue(promise.isSuccess());, +        assertTrue(promise2.isSuccess());, +        assertTrue(channel.finish());, +, +        assertEquals(1L, channel.readOutbound());]