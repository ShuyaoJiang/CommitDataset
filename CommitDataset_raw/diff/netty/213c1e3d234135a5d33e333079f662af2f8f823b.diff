[+++ b/codec-socks/src/main/java/io/netty/handler/codec/socks/SocksCmdRequest.java, +import io.netty.util.IPUtil;, +                if (!IPUtil.isValidIPV4Address(host)) {, +                if (!IPUtil.isValidIP6Address(host)) {, +                byteBuf.writeBytes(IPUtil.createByteArrayFromIPAddressString(host));, +                byteBuf.writeBytes(IPUtil.createByteArrayFromIPAddressString(host));, +++ b/codec-socks/src/main/java/io/netty/handler/codec/socks/SocksCmdRequest.java, +import io.netty.util.IPUtil;, +                if (!IPUtil.isValidIPV4Address(host)) {, +                if (!IPUtil.isValidIP6Address(host)) {, +                byteBuf.writeBytes(IPUtil.createByteArrayFromIPAddressString(host));, +                byteBuf.writeBytes(IPUtil.createByteArrayFromIPAddressString(host));, +++ b/common/src/main/java/io/netty/util/IPUtil.java, +/*, + * Copyright 2012 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + *   http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the, + * License for the specific language governing permissions and limitations, + * under the License., + */, +package io.netty.util;, +, +, +import java.util.ArrayList;, +import java.util.StringTokenizer;, +, +/**, + * Utility functions for IPV6 operations., + *, + * see Inet6Util from the Apache Harmony project, + *, + * see org.apache.harmony.util.Inet6Util, + */, +public final class IPUtil {, +, +    private IPUtil() {, +        // make this class a an utility class non-instantiable, +    }, +, +    /**, +     * Creates an byte[] based on an ipAddressString. No error handling is, +     * performed here., +     */, +    public static byte[] createByteArrayFromIPAddressString(, +            String ipAddressString) {, +, +        if (isValidIPV4Address(ipAddressString)) {, +            StringTokenizer tokenizer = new StringTokenizer(ipAddressString,, +                    ".");, +            String token;, +            int tempInt;, +            byte[] byteAddress = new byte[4];, +            for (int i = 0; i < 4; i++) {, +                token = tokenizer.nextToken();, +                tempInt = Integer.parseInt(token);, +                byteAddress[i] = (byte) tempInt;, +            }, +, +            return byteAddress;, +        }, +, +        if (ipAddressString.charAt(0) == '[') {, +            ipAddressString = ipAddressString.substring(1, ipAddressString, +                    .length() - 1);, +        }, +, +        StringTokenizer tokenizer = new StringTokenizer(ipAddressString, ":.",, +                true);, +        ArrayList<String> hexStrings = new ArrayList<String>();, +        ArrayList<String> decStrings = new ArrayList<String>();, +        String token = "";, +        String prevToken = "";, +        int doubleColonIndex = -1; // If a double colon exists, we need to, +        // insert 0s., +, +        // Go through the tokens, including the seperators ':' and '.', +        // When we hit a : or . the previous token will be added to either, +        // the hex list or decimal list. In the case where we hit a ::, +        // we will save the index of the hexStrings so we can add zeros, +        // in to fill out the string, +        while (tokenizer.hasMoreTokens()) {, +            prevToken = token;, +            token = tokenizer.nextToken();, +, +            if (":".equals(token)) {, +                if (":".equals(prevToken)) {, +                    doubleColonIndex = hexStrings.size();, +                } else if (!prevToken.isEmpty()) {, +                    hexStrings.add(prevToken);, +                }, +            } else if (".".equals(token)) {, +                decStrings.add(prevToken);]