[+++ b/buffer/src/main/java/io/netty/buffer/ByteBufUtil.java, +                return (int) Math.min(Integer.MAX_VALUE, Math.max(Integer.MIN_VALUE, res));, +++ b/buffer/src/main/java/io/netty/buffer/ByteBufUtil.java, +                return (int) Math.min(Integer.MAX_VALUE, Math.max(Integer.MIN_VALUE, res));, +++ b/buffer/src/test/java/io/netty/buffer/AbstractByteBufTest.java, +import java.util.Collections;, +import static org.junit.Assume.assumeFalse;, +import static org.junit.Assume.assumeTrue;, +    public void comparableInterfaceNotViolated() {, +        assumeFalse(buffer.isReadOnly());, +        buffer.writerIndex(buffer.readerIndex());, +        assumeTrue(buffer.writableBytes() >= 4);, +, +        buffer.writeLong(0);, +        ByteBuf buffer2 = newBuffer(CAPACITY);, +        assumeFalse(buffer2.isReadOnly());, +        buffer2.writerIndex(buffer2.readerIndex());, +        // Write an unsigned integer that will cause buffer.getUnsignedInt() - buffer2.getUnsignedInt() to underflow the, +        // int type and wrap around on the negative side., +        buffer2.writeLong(0xF0000000L);, +        assertTrue(buffer.compareTo(buffer2) < 0);, +        assertTrue(buffer2.compareTo(buffer) > 0);, +        buffer2.release();, +    }, +, +    @Test, +        assumeTrue(buffer.nioBufferCount() == 1);, +        assumeTrue(buffer.nioBufferCount() == 1);, +        assumeTrue(buffer.nioBufferCount() == 1);]