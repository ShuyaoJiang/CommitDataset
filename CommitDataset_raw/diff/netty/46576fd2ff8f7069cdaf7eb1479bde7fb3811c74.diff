[+++ b/transport/src/main/java/io/netty/channel/AbstractChannelHandlerContext.java, +++ b/transport/src/main/java/io/netty/channel/AbstractChannelHandlerContext.java, +++ b/transport/src/main/java/io/netty/channel/DefaultChannelPipeline.java, +import io.netty.util.internal.OneTimeTask;, +            destroy();, +     * Removes all handlers from the pipeline one by one from tail (exclusive) to head (exclusive) to trigger, +     * handlerRemoved()., +     *, +     * Note that we traverse up the pipeline ({@link #destroyUp(AbstractChannelHandlerContext)}), +     * before traversing down ({@link #destroyDown(Thread, AbstractChannelHandlerContext)}) so that, +     * the handlers are removed after all events are handled., +     *, +     * See: https://github.com/netty/netty/issues/3156, +    private void destroy() {, +        destroyUp(head.next);, +    }, +, +    private void destroyUp(AbstractChannelHandlerContext ctx) {, +        final Thread currentThread = Thread.currentThread();, +        final AbstractChannelHandlerContext tail = this.tail;, +        for (;;) {, +            if (ctx == tail) {, +                destroyDown(currentThread, tail.prev);, +                break;, +            }, +, +            final EventExecutor executor = ctx.executor();, +            if (!executor.inEventLoop(currentThread)) {, +                final AbstractChannelHandlerContext finalCtx = ctx;, +                executor.execute(new OneTimeTask() {, +                    @Override, +                    public void run() {, +                        destroyUp(finalCtx);, +                    }, +                });, +                break;, +            }, +, +            ctx = ctx.next;, +        }, +    }, +, +    private void destroyDown(Thread currentThread, AbstractChannelHandlerContext ctx) {, +        // We have reached at tail; now traverse backwards., +        final AbstractChannelHandlerContext head = this.head;, +        for (;;) {, +            if (ctx == head) {, +                break;, +            }, +, +            final EventExecutor executor = ctx.executor();, +            if (executor.inEventLoop(currentThread)) {, +                synchronized (this) {, +                    remove0(ctx);, +                }, +            } else {, +                final AbstractChannelHandlerContext finalCtx = ctx;, +                executor.execute(new OneTimeTask() {, +                    @Override, +                    public void run() {, +                        destroyDown(Thread.currentThread(), finalCtx);, +                    }, +                });, +                break;, +            }, +, +            ctx = ctx.prev;, +        }]