[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2MultiplexCodec.java, +                // Only ever send a reset frame if the connection is still alive and if the stream may have existed, +                // as otherwise we may send a RST on a stream in an invalid state and cause a connection error., +                if (parent().isActive() && !streamClosedWithoutError &&, +                        connection().streamMayHaveExisted(stream().id())) {, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2MultiplexCodec.java, +                // Only ever send a reset frame if the connection is still alive and if the stream may have existed, +                // as otherwise we may send a RST on a stream in an invalid state and cause a connection error., +                if (parent().isActive() && !streamClosedWithoutError &&, +                        connection().streamMayHaveExisted(stream().id())) {, +++ b/codec-http2/src/test/java/io/netty/handler/codec/http2/Http2MultiplexCodecTest.java, +    public void outboundStreamShouldNotWriteResetFrameOnClose_IfStreamDidntExist() {, +        writer = new Writer() {, +            private boolean headersWritten;, +            @Override, +            void write(Object msg, ChannelPromise promise) {, +                // We want to fail to write the first headers frame. This is what happens if the connection, +                // refuses to allocate a new stream due to having received a GOAWAY., +                if (!headersWritten && msg instanceof Http2HeadersFrame) {, +                    headersWritten = true;, +                    Http2HeadersFrame headersFrame = (Http2HeadersFrame) msg;, +                    final TestableHttp2MultiplexCodec.Stream stream =, +                            (TestableHttp2MultiplexCodec.Stream) headersFrame.stream();, +                    stream.id = 1;, +                    promise.setFailure(new Exception("boom"));, +                } else {, +                    super.write(msg, promise);, +                }, +            }, +        };, +, +        childChannelInitializer.handler = new ChannelInboundHandlerAdapter() {, +            @Override, +            public void channelActive(ChannelHandlerContext ctx) throws Exception {, +                ctx.writeAndFlush(new DefaultHttp2HeadersFrame(new DefaultHttp2Headers()));, +                ctx.fireChannelActive();, +            }, +        };, +, +        Channel childChannel = newOutboundStream();, +        assertFalse(childChannel.isActive());, +, +        childChannel.close();, +        parentChannel.runPendingTasks();, +        assertTrue(parentChannel.outboundMessages().isEmpty());, +    }, +, +    @Test, +        TestableHttp2MultiplexCodec.Stream frameStream = (TestableHttp2MultiplexCodec.Stream) headersFrame.stream();, +        frameStream.id = outboundStream.id();, +        // Create the stream in the Http2Connection., +        try {, +            Http2Stream stream = codec.connection().local().createStream(, +                    headersFrame.stream().id(), headersFrame.isEndStream());, +            frameStream.stream = stream;, +        } catch (Exception ex) {, +            throw new IllegalStateException("Failed to create a stream", ex);, +        }]