[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2ConnectionDecoder.java, +            // A client cannot push., +            if (connection().isServer()) {, +                throw connectionError(PROTOCOL_ERROR, "A client cannot push.");, +            }, +, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2ConnectionDecoder.java, +            // A client cannot push., +            if (connection().isServer()) {, +                throw connectionError(PROTOCOL_ERROR, "A client cannot push.");, +            }, +, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2FrameReader.java, +            throw connectionError(FRAME_SIZE_ERROR, "Frame length: %d exceeds maximum: %d", payloadLength,, +                                  maxFrameSize);, +        verifyAssociatedWithAStream();, +        verifyAssociatedWithAStream();, +        verifyAssociatedWithAStream();, +        verifyAssociatedWithAStream();, +            throw connectionError(FRAME_SIZE_ERROR, "Invalid frame length %d.", payloadLength);, +            throw connectionError(FRAME_SIZE_ERROR, "Ack settings frame must have an empty payload.");, +            throw connectionError(FRAME_SIZE_ERROR, "Invalid frame length %d.", payloadLength);, +        verifyAssociatedWithAStream();, +        verifyPadding(padding);, +        verifyPadding(padding);, +            if (streamDependency == streamId) {, +                throw streamError(streamId, PROTOCOL_ERROR, "A stream cannot depend on itself.");, +            }, +        if (streamDependency == streamId) {, +            throw streamError(streamId, PROTOCOL_ERROR, "A stream cannot depend on itself.");, +        }, +                        throw connectionError(PROTOCOL_ERROR, e, e.getMessage());, +        verifyPadding(padding);, +    private void verifyPadding(int padding) throws Http2Exception {, +        int len = lengthWithoutTrailingPadding(payloadLength, padding);, +        if (len < 0) {, +            throw connectionError(PROTOCOL_ERROR, "Frame payload too small for padding.");, +        }, +    }, +, +    private void verifyAssociatedWithAStream() throws Http2Exception {, +        if (streamId == 0) {, +            throw connectionError(PROTOCOL_ERROR, "Frame of type %s must be associated with a stream.", frameType);, +        }, +    }, +, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2ConnectionDecoder.java, +            // A client cannot push., +            if (connection().isServer()) {, +                throw connectionError(PROTOCOL_ERROR, "A client cannot push.");, +            }, +, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2FrameReader.java, +            throw connectionError(FRAME_SIZE_ERROR, "Frame length: %d exceeds maximum: %d", payloadLength,, +                                  maxFrameSize);, +        verifyAssociatedWithAStream();, +        verifyAssociatedWithAStream();, +        verifyAssociatedWithAStream();, +        verifyAssociatedWithAStream();, +            throw connectionError(FRAME_SIZE_ERROR, "Invalid frame length %d.", payloadLength);, +            throw connectionError(FRAME_SIZE_ERROR, "Ack settings frame must have an empty payload.");, +            throw connectionError(FRAME_SIZE_ERROR, "Invalid frame length %d.", payloadLength);, +        verifyAssociatedWithAStream();, +        verifyPadding(padding);, +        verifyPadding(padding);, +            if (streamDependency == streamId) {, +                throw streamError(streamId, PROTOCOL_ERROR, "A stream cannot depend on itself.");, +            }, +        if (streamDependency == streamId) {, +            throw streamError(streamId, PROTOCOL_ERROR, "A stream cannot depend on itself.");, +        }, +                        throw connectionError(PROTOCOL_ERROR, e, e.getMessage());, +        verifyPadding(padding);, +    private void verifyPadding(int padding) throws Http2Exception {, +        int len = lengthWithoutTrailingPadding(payloadLength, padding);, +        if (len < 0) {, +            throw connectionError(PROTOCOL_ERROR, "Frame payload too small for padding.");, +        }, +    }, +, +    private void verifyAssociatedWithAStream() throws Http2Exception {, +        if (streamId == 0) {, +            throw connectionError(PROTOCOL_ERROR, "Frame of type %s must be associated with a stream.", frameType);, +        }, +    }, +, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2ConnectionHandler.java, +                                                      clientPrefaceString, clientPrefaceString.readerIndex(),, +                                                      bytesRead)) {, +                                                      "Hex dump for first 5 bytes: %s",, +                                      hexDump(in, in.readerIndex(), 5));, +    /**, +     * Sends a {@code RST_STREAM} frame even if we don't know about the stream. This error condition is most likely, +     * triggered by the first frame of a stream being invalid. That is, there was an error reading the frame before, +     * we could create a new stream., +     */, +    private ChannelFuture resetUnknownStream(final ChannelHandlerContext ctx, int streamId, long errorCode,, +                                             ChannelPromise promise) {, +        ChannelFuture future = frameWriter().writeRstStream(ctx, streamId, errorCode, promise);, +        if (future.isDone()) {]