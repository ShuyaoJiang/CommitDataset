[+++ b/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java, +            List<String> list = PlatformDependent.isWindows(), +                    ? getSearchDomainsHack(), +                    : UnixResolverDnsServerAddressStreamProvider.parseEtcResolverSearchDomains();, +    @SuppressWarnings("unchecked"), +    private static List<String> getSearchDomainsHack() throws Exception {, +        // This code on Java 9+ yields a warning about illegal reflective access that will be denied in, +        // a future release. There doesn't seem to be a better way to get search domains for Windows yet., +        Class<?> configClass = Class.forName("sun.net.dns.ResolverConfiguration");, +        Method open = configClass.getMethod("open");, +        Method nameservers = configClass.getMethod("searchlist");, +        Object instance = open.invoke(null);, +, +        return (List<String>) nameservers.invoke(instance);, +    }, +, +++ b/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java, +            List<String> list = PlatformDependent.isWindows(), +                    ? getSearchDomainsHack(), +                    : UnixResolverDnsServerAddressStreamProvider.parseEtcResolverSearchDomains();, +    @SuppressWarnings("unchecked"), +    private static List<String> getSearchDomainsHack() throws Exception {, +        // This code on Java 9+ yields a warning about illegal reflective access that will be denied in, +        // a future release. There doesn't seem to be a better way to get search domains for Windows yet., +        Class<?> configClass = Class.forName("sun.net.dns.ResolverConfiguration");, +        Method open = configClass.getMethod("open");, +        Method nameservers = configClass.getMethod("searchlist");, +        Object instance = open.invoke(null);, +, +        return (List<String>) nameservers.invoke(instance);, +    }, +, +++ b/resolver-dns/src/main/java/io/netty/resolver/dns/UnixResolverDnsServerAddressStreamProvider.java, +import java.util.Arrays;, +import java.util.Collections;, +    private static final String SEARCH_ROW_LABEL = "search";, +, +    /**, +     * Parse a file of the format <a href="https://linux.die.net/man/5/resolver">/etc/resolv.conf</a> and return the, +     * list of search domains found in it or an empty list if not found., +     * @return List of search domains., +     * @throws IOException If a failure occurs parsing the file., +     */, +    static List<String> parseEtcResolverSearchDomains() throws IOException {, +        return parseEtcResolverSearchDomains(new File(ETC_RESOLV_CONF_FILE));, +    }, +, +    /**, +     * Parse a file of the format <a href="https://linux.die.net/man/5/resolver">/etc/resolv.conf</a> and return the, +     * list of search domains found in it or an empty list if not found., +     * @param etcResolvConf a file of the format <a href="https://linux.die.net/man/5/resolver">/etc/resolv.conf</a>., +     * @return List of search domains., +     * @throws IOException If a failure occurs parsing the file., +     */, +    static List<String> parseEtcResolverSearchDomains(File etcResolvConf) throws IOException {, +        String localDomain = null;, +        List<String> searchDomains = new ArrayList<String>();, +, +        FileReader fr = new FileReader(etcResolvConf);, +        BufferedReader br = null;, +        try {, +            br = new BufferedReader(fr);, +            String line;, +            while ((line = br.readLine()) != null) {, +                if (localDomain == null && line.startsWith(DOMAIN_ROW_LABEL)) {, +                    int i = indexOfNonWhiteSpace(line, DOMAIN_ROW_LABEL.length());, +                    if (i >= 0) {, +                        localDomain = line.substring(i);, +                    }, +                } else if (line.startsWith(SEARCH_ROW_LABEL)) {, +                    int i = indexOfNonWhiteSpace(line, SEARCH_ROW_LABEL.length());, +                    if (i >= 0) {, +                        searchDomains.add(line.substring(i));, +                    }, +                }, +            }, +        } finally {, +            if (br == null) {, +                fr.close();, +            } else {, +                br.close();, +            }, +        }, +, +        // return what was on the 'domain' line only if there were no 'search' lines, +        return localDomain != null && searchDomains.isEmpty(), +                ? Collections.singletonList(localDomain), +                : searchDomains;, +    }, +++ b/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java, +            List<String> list = PlatformDependent.isWindows(), +                    ? getSearchDomainsHack(), +                    : UnixResolverDnsServerAddressStreamProvider.parseEtcResolverSearchDomains();, +    @SuppressWarnings("unchecked"), +    private static List<String> getSearchDomainsHack() throws Exception {, +        // This code on Java 9+ yields a warning about illegal reflective access that will be denied in, +        // a future release. There doesn't seem to be a better way to get search domains for Windows yet., +        Class<?> configClass = Class.forName("sun.net.dns.ResolverConfiguration");, +        Method open = configClass.getMethod("open");, +        Method nameservers = configClass.getMethod("searchlist");]