[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DelegatingDecompressorFrameListener.java, +    private final Http2Connection.PropertyKey propertyKey;, +                    cleanup(decompressor);, +                decompressor.incrementDecompressedBytes(compressedBytes);, +                return compressedBytes;, +            }, +                Http2LocalFlowController flowController = connection.local().flowController();, +                decompressor.incrementDecompressedBytes(padding);, +                    decompressor.incrementDecompressedBytes(buf.readableBytes());, +                    // Immediately return the bytes back to the flow controller. ConsumedBytesConverter will convert, +                    // from the decompressed amount which the user knows about to the compressed amount which flow, +                    // control knows about., +                    flowController.consumeBytes(stream,, +                            listener.onDataRead(ctx, streamId, buf, padding, decompressedEndOfStream));, +                    padding = 0; // Padding is only communicated once on the first iteration., +                // We consume bytes each time we call the listener to ensure if multiple frames are decompressed, +                // that the bytes are accounted for immediately. Otherwise the user may see an inconsistent state of, +                // flow control., +                return 0;, +     * Release remaining content from the {@link EmbeddedChannel}., +    private static void cleanup(Http2Decompressor decompressor) {, +        decompressor.decompressor().finishAndReleaseAll();, +                // Convert the decompressed bytes to compressed (on the wire) bytes., +                numBytes = decompressor.consumeBytes(stream.id(), numBytes);, +            try {, +                // The stream should be closed at this point. We have already changed our state tracking the compressed, +                // bytes, and there is no guarantee we can recover if the underlying flow controller throws., +                throw streamError(stream.id(), INTERNAL_ERROR, t, "Error while returning bytes to flow control window");, +            assert delta >= 0;, +         * Increment the number of bytes after the decompression process., +        void incrementDecompressedBytes(int delta) {, +            assert delta >= 0;, +         * Determines the ratio between {@code numBytes} and {@link Http2Decompressor#decompressed}., +         * @param streamId the stream ID, +         * @param decompressedBytes The number of post-decompressed bytes to return to flow control, +        int consumeBytes(int streamId, int decompressedBytes) throws Http2Exception {, +            if (decompressedBytes < 0) {, +                throw new IllegalArgumentException("decompressedBytes must not be negative: " + decompressedBytes);, +            }, +            if (decompressed - decompressedBytes < 0) {, +                throw streamError(streamId, INTERNAL_ERROR,, +                        "Attempting to return too many bytes for stream %d. decompressed: %d " +, +                                "decompressedBytes: %d", streamId, decompressed, decompressedBytes);, +            }, +            double consumedRatio = decompressedBytes / (double) decompressed;, +            if (compressed - consumedCompressed < 0) {, +                throw streamError(streamId, INTERNAL_ERROR,, +                        "overflow when converting decompressed bytes to compressed bytes for stream %d." +, +                                "decompressedBytes: %d decompressed: %d compressed: %d consumedCompressed: %d",, +                        streamId, decompressedBytes, decompressed, compressed, consumedCompressed);, +            }, +            decompressed -= decompressedBytes;, +            compressed -= consumedCompressed;]