[+++ b/transport/src/main/java/io/netty/channel/ChannelTaskScheduler.java, +/*, + * Copyright 2012 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + *   http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the, + * License for the specific language governing permissions and limitations, + * under the License., + */, +package io.netty.channel;, +, +import io.netty.logging.InternalLogger;, +import io.netty.logging.InternalLoggerFactory;, +, +import java.util.Iterator;, +import java.util.concurrent.BlockingQueue;, +import java.util.concurrent.Callable;, +import java.util.concurrent.DelayQueue;, +import java.util.concurrent.Delayed;, +import java.util.concurrent.FutureTask;, +import java.util.concurrent.RejectedExecutionException;, +import java.util.concurrent.ScheduledFuture;, +import java.util.concurrent.Semaphore;, +import java.util.concurrent.ThreadFactory;, +import java.util.concurrent.TimeUnit;, +import java.util.concurrent.atomic.AtomicLong;, +, +public final class ChannelTaskScheduler {, +, +    private static final InternalLogger logger =, +            InternalLoggerFactory.getInstance(ChannelTaskScheduler.class);, +, +    private static final long SCHEDULE_PURGE_INTERVAL = TimeUnit.SECONDS.toNanos(1);, +    private static final long START_TIME = System.nanoTime();, +    private static final AtomicLong nextTaskId = new AtomicLong();, +, +    private static long nanoTime() {, +        return System.nanoTime() - START_TIME;, +    }, +, +    private static long deadlineNanos(long delay) {, +        return nanoTime() + delay;, +    }, +, +    private final BlockingQueue<ScheduledFutureTask<?>> taskQueue = new DelayQueue<ScheduledFutureTask<?>>();, +    private final Thread thread;, +    private final Object stateLock = new Object();, +    private final Semaphore threadLock = new Semaphore(0);, +    /** 0 - not started, 1 - started, 2 - shut down, 3 - terminated */, +    private volatile int state;, +, +    public ChannelTaskScheduler(ThreadFactory threadFactory) {, +        if (threadFactory == null) {, +            throw new NullPointerException("threadFactory");, +        }, +, +        thread = threadFactory.newThread(new Runnable() {, +            @Override, +            public void run() {, +                try {, +                    for (;;) {, +                        ScheduledFutureTask<?> task;, +                        try {, +                            task = taskQueue.take();, +                            runTask(task);, +                        } catch (InterruptedException e) {, +                            // Waken up by interruptThread(), +                        }, +, +                        if (isShutdown() && taskQueue.peek() == null) {, +                            break;, +                        }, +                    }, +                } finally {, +                    try {, +                        // Run all remaining tasks and shutdown hooks., +                        try {, +                            cleanupTasks();, +                        } finally {, +                            synchronized (stateLock) {, +                                state = 3;, +                            }, +                        }, +                        cleanupTasks();, +                    } finally {, +                        threadLock.release();, +                        assert taskQueue.isEmpty();, +                    }, +                }, +            }, +, +            private void runTask(ScheduledFutureTask<?> task) {, +                EventExecutor executor = task.executor;]