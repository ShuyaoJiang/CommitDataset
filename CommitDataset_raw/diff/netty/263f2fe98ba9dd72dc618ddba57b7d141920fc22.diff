[+++ b/src/main/java/org/jboss/netty/handler/execution/MemoryAwareThreadPoolExecutor.java, +                    // Ignore, +++ b/src/main/java/org/jboss/netty/handler/execution/MemoryAwareThreadPoolExecutor.java, +                    // Ignore, +++ b/src/main/java/org/jboss/netty/handler/execution/OrderedMemoryAwareThreadPoolExecutor.java, +import java.util.concurrent.ConcurrentLinkedQueue;, +import java.util.concurrent.atomic.AtomicBoolean;, +        private final ConcurrentLinkedQueue<Runnable> tasks = new ConcurrentLinkedQueue<Runnable>();, +        private final AtomicBoolean isRunning = new AtomicBoolean(false);, +, +            if (isRunning.get() == false) {, +            // check if its already running by using CAS. If so just return here. So in the worst case the thread, +            // is executed and do nothing, +            if (isRunning.compareAndSet(false, true)) {, +                try {, +                        final Runnable task = tasks.poll();, +                        // this should never happen but just in case check if, +                        // the queue was empty, +                        if (task == null) {, +                            break;, +                } finally {, +                    // set it back to not running, +                    isRunning.set(false);, +                }, +++ b/src/main/java/org/jboss/netty/handler/execution/MemoryAwareThreadPoolExecutor.java, +                    // Ignore, +++ b/src/main/java/org/jboss/netty/handler/execution/OrderedMemoryAwareThreadPoolExecutor.java, +import java.util.concurrent.ConcurrentLinkedQueue;, +import java.util.concurrent.atomic.AtomicBoolean;, +        private final ConcurrentLinkedQueue<Runnable> tasks = new ConcurrentLinkedQueue<Runnable>();, +        private final AtomicBoolean isRunning = new AtomicBoolean(false);, +, +            if (isRunning.get() == false) {, +            // check if its already running by using CAS. If so just return here. So in the worst case the thread, +            // is executed and do nothing, +            if (isRunning.compareAndSet(false, true)) {, +                try {, +                        final Runnable task = tasks.poll();, +                        // this should never happen but just in case check if, +                        // the queue was empty, +                        if (task == null) {, +                            break;, +                } finally {, +                    // set it back to not running, +                    isRunning.set(false);, +                }, +++ b/src/main/java/org/jboss/netty/handler/ssl/SslHandler.java, + * <h3>Handshake</h3>, + * <p>, + * If {@link #isIssueHandshake()} is {@code false}, + * (default) you will need to take care of calling {@link #handshake()} by your own. In most situations were {@link SslHandler} is used in 'client mode', + * you want to issue a handshake once the connection was established. if {@link #setIssueHandshake(boolean)} is set to <code>true</code> you don't need to , + * worry about this as the {@link SslHandler} will take care of it., + * <p>, + * , +    private volatile boolean issueHandshake = false;, +    , +    private static final ChannelFutureListener HANDSHAKE_LISTENER = new ChannelFutureListener() {, +, +        @Override, +        public void operationComplete(ChannelFuture future) throws Exception {, +            if (!future.isSuccess()) {, +                Channels.fireExceptionCaught(future.getChannel(), future.getCause());, +            }, +        }, +        , +    };, +    , +    /**, +     * Enables or disables the automatic handshake once the {@link Channel} is connected. The value will only have affect if its set before the , +     * {@link Channel} is connected., +     * , +     */, +    public void setIssueHandshake(boolean issueHandshake) {, +        this.issueHandshake = issueHandshake;, +    }, +    , +    /**, +     * Returns <code>true</code> if the automatic handshake is enabled, +     */, +    public boolean isIssueHandshake() {, +        return issueHandshake;, +    }, +    , +    , +, +    /**, +     * Calls {@link #handshake()} once the {@link Channel} is connected, +     */, +    @Override, +    public void channelConnected(ChannelHandlerContext ctx, ChannelStateEvent e) throws Exception {, +        if (issueHandshake) {, +            // issue and handshake and add a listener to it which will fire an exception event if an exception was thrown, +            // while doing the handshake, +            handshake().addListener(HANDSHAKE_LISTENER);, +        }, +        super.channelConnected(ctx, e);     , +    } ]