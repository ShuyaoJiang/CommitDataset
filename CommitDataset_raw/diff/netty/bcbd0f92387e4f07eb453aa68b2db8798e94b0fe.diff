[+++ b/src/main/java/org/jboss/netty/util/HashedWheelTimer.java, +/*, + * JBoss, Home of Professional Open Source, + *, + * Copyright 2009, Red Hat Middleware LLC, and individual contributors, + * by the @author tags. See the COPYRIGHT.txt in the distribution for a, + * full listing of individual contributors., + *, + * This is free software; you can redistribute it and/or modify it, + * under the terms of the GNU Lesser General Public License as, + * published by the Free Software Foundation; either version 2.1 of, + * the License, or (at your option) any later version., + *, + * This software is distributed in the hope that it will be useful,, + * but WITHOUT ANY WARRANTY; without even the implied warranty of, + * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU, + * Lesser General Public License for more details., + *, + * You should have received a copy of the GNU Lesser General Public, + * License along with this software; if not, write to the Free, + * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA, + * 02110-1301 USA, or see the FSF site: http://www.fsf.org., + */, +package org.jboss.netty.util;, +, +import java.util.ArrayList;, +import java.util.Iterator;, +import java.util.List;, +import java.util.Set;, +import java.util.concurrent.ConcurrentHashMap;, +import java.util.concurrent.Executor;, +import java.util.concurrent.Executors;, +import java.util.concurrent.TimeUnit;, +import java.util.concurrent.locks.ReadWriteLock;, +import java.util.concurrent.locks.ReentrantReadWriteLock;, +, +/**, + * @author The Netty Project (netty-dev@lists.jboss.org), + * @author Trustin Lee (tlee@redhat.com), + * @version $Rev$, $Date$, + */, +public class HashedWheelTimer implements Timer {, +, +    private final Executor executor;, +    private final Worker worker = new Worker();, +, +    final long tickDuration;, +    final long wheelDuration;, +    final Set<HashedWheelTimeout>[] wheel;, +    final int mask;, +    final ReadWriteLock lock = new ReentrantReadWriteLock();, +    volatile int wheelCursor;, +, +    public HashedWheelTimer(Executor executor) {, +        this(executor, 1, TimeUnit.SECONDS, 64);, +    }, +, +    public HashedWheelTimer(, +            Executor executor,, +            long tickDuration, TimeUnit unit, int ticksPerWheel) {, +, +        if (executor == null) {, +            throw new NullPointerException("executor");, +        }, +        if (unit == null) {, +            throw new NullPointerException("unit");, +        }, +        if (tickDuration <= 0) {, +            throw new IllegalArgumentException(, +                    "tickDuration must be greater than 0: " + tickDuration);, +        }, +, +        this.executor = executor;, +, +        // Normalize ticksPerWheel to power of two and initialize the wheel., +        wheel = createWheel(ticksPerWheel);, +        mask = wheel.length - 1;, +, +        // Convert checkInterval to nanoseconds., +        this.tickDuration = tickDuration = unit.toNanos(tickDuration);, +, +        // Prevent overflow., +        if (tickDuration == Long.MAX_VALUE ||, +                tickDuration >= Long.MAX_VALUE / wheel.length) {, +            throw new IllegalArgumentException(, +                    "tickDuration is too long: " +, +                    tickDuration +  ' ' + unit);, +        }, +, +        wheelDuration = tickDuration * wheel.length;, +        executor.execute(worker);, +    }, +, +    @SuppressWarnings("unchecked"), +    private static Set<HashedWheelTimeout>[] createWheel(int ticksPerWheel) {, +        if (ticksPerWheel <= 0) {, +            throw new IllegalArgumentException(, +                    "ticksPerWheel must be greater than 0: " + ticksPerWheel);, +        }, +        if (ticksPerWheel > 1073741824) {]