[+++ b/common/src/main/java/io/netty/util/concurrent/DefaultEventExecutor.java, +    DefaultEventExecutor(DefaultEventExecutorGroup parent, ThreadFactory threadFactory) {, +        super(parent, threadFactory);, +++ b/common/src/main/java/io/netty/util/concurrent/DefaultEventExecutor.java, +    DefaultEventExecutor(DefaultEventExecutorGroup parent, ThreadFactory threadFactory) {, +        super(parent, threadFactory);, +++ b/common/src/main/java/io/netty/util/concurrent/DefaultEventExecutorGroup.java, +            ThreadFactory threadFactory, Object... args) throws Exception {, +        return new DefaultEventExecutor(this, threadFactory);, +++ b/common/src/main/java/io/netty/util/concurrent/DefaultEventExecutor.java, +    DefaultEventExecutor(DefaultEventExecutorGroup parent, ThreadFactory threadFactory) {, +        super(parent, threadFactory);, +++ b/common/src/main/java/io/netty/util/concurrent/DefaultEventExecutorGroup.java, +            ThreadFactory threadFactory, Object... args) throws Exception {, +        return new DefaultEventExecutor(this, threadFactory);, +++ b/common/src/main/java/io/netty/util/concurrent/MultithreadEventExecutorGroup.java, +     * @param args              arguments which will passed to each {@link #newChild(ThreadFactory, Object...)} call, +                children[i] = newChild(threadFactory, args);, +            ThreadFactory threadFactory, Object... args) throws Exception;, +++ b/common/src/main/java/io/netty/util/concurrent/DefaultEventExecutor.java, +    DefaultEventExecutor(DefaultEventExecutorGroup parent, ThreadFactory threadFactory) {, +        super(parent, threadFactory);, +++ b/common/src/main/java/io/netty/util/concurrent/DefaultEventExecutorGroup.java, +            ThreadFactory threadFactory, Object... args) throws Exception {, +        return new DefaultEventExecutor(this, threadFactory);, +++ b/common/src/main/java/io/netty/util/concurrent/MultithreadEventExecutorGroup.java, +     * @param args              arguments which will passed to each {@link #newChild(ThreadFactory, Object...)} call, +                children[i] = newChild(threadFactory, args);, +            ThreadFactory threadFactory, Object... args) throws Exception;, +++ b/common/src/main/java/io/netty/util/concurrent/SingleThreadEventExecutor.java, +import java.util.Iterator;, +import java.util.PriorityQueue;, +import java.util.concurrent.Callable;, +import java.util.concurrent.CancellationException;, +import java.util.concurrent.Delayed;, +import java.util.concurrent.Executors;, +import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;, +import java.util.concurrent.atomic.AtomicLong;, +public abstract class SingleThreadEventExecutor extends AbstractEventExecutorWithoutScheduler {, +    final Queue<ScheduledFutureTask<?>> delayedTaskQueue = new PriorityQueue<ScheduledFutureTask<?>>();, +, +    protected SingleThreadEventExecutor(EventExecutorGroup parent, ThreadFactory threadFactory) {, +        if (!(taskQueue instanceof BlockingQueue)) {, +, +        BlockingQueue<Runnable> taskQueue = (BlockingQueue<Runnable>) this.taskQueue;, +        for (;;) {, +            ScheduledFutureTask<?> delayedTask = delayedTaskQueue.peek();, +            if (delayedTask == null) {, +                return taskQueue.take();, +            } else {, +                long delayNanos = delayedTask.delayNanos();, +                Runnable task;, +                if (delayNanos > 0) {, +                    task = taskQueue.poll(delayNanos, TimeUnit.NANOSECONDS);, +                } else {, +                    task = taskQueue.poll();, +                }, +, +                if (task == null) {, +                    fetchFromDelayedQueue();, +                    task = taskQueue.poll();, +                }, +, +                if (task != null) {, +                    return task;, +                }, +            }, +        }, +    }, +, +    private void fetchFromDelayedQueue() {, +        long nanoTime = 0L;, +        for (;;) {, +            ScheduledFutureTask<?> delayedTask = delayedTaskQueue.peek();, +            if (delayedTask == null) {, +                break;, +            }, +, +            if (nanoTime == 0L) {, +                nanoTime = nanoTime();, +            }, +, +            if (delayedTask.deadlineNanos() <= nanoTime) {, +                delayedTaskQueue.remove();, +                taskQueue.add(delayedTask);, +            } else {, +                break;, +            }, +        }, +        fetchFromDelayedQueue();, +        fetchFromDelayedQueue();, +     * Returns the ammount of time left until the scheduled task with the closest dead line is executed., +     */, +    protected long delayNanos() {, +        ScheduledFutureTask<?> delayedTask = delayedTaskQueue.peek();, +        if (delayedTask == null) {, +            return SCHEDULE_PURGE_INTERVAL;, +        }, +, +        return delayedTask.delayNanos();]