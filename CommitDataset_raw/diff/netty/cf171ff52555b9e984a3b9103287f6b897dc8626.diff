[+++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBufAllocator.java, +            default:, +                break;, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBufAllocator.java, +            default:, +                break;, +++ b/buffer/src/main/java/io/netty/buffer/PooledUnsafeDirectByteBuf.java, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBufAllocator.java, +            default:, +                break;, +++ b/buffer/src/main/java/io/netty/buffer/PooledUnsafeDirectByteBuf.java, +++ b/buffer/src/test/java/io/netty/buffer/SlicedByteBufTest.java, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBufAllocator.java, +            default:, +                break;, +++ b/buffer/src/main/java/io/netty/buffer/PooledUnsafeDirectByteBuf.java, +++ b/buffer/src/test/java/io/netty/buffer/SlicedByteBufTest.java, +++ /dev/null, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBufAllocator.java, +            default:, +                break;, +++ b/buffer/src/main/java/io/netty/buffer/PooledUnsafeDirectByteBuf.java, +++ b/buffer/src/test/java/io/netty/buffer/SlicedByteBufTest.java, +++ /dev/null, +++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/AbstractEpollChannel.java, +import io.netty.channel.RecvByteBufAllocator;, +    private static final ChannelMetadata METADATA = new ChannelMetadata(false);, +        return METADATA;, +        unsafe().recvBufAllocHandle().attemptedBytesRead(byteBuf.writableBytes());, +        private EpollRecvByteAllocatorHandle allocHandle;, +        public EpollRecvByteAllocatorHandle recvBufAllocHandle() {, +            if (allocHandle == null) {, +                allocHandle = newEpollHandle(super.recvBufAllocHandle());, +            }, +            return allocHandle;, +        }, +, +        /**, +         * Create a new {@EpollRecvByteAllocatorHandle} instance., +         * @param handle The handle to wrap with EPOLL specific logic., +         */, +        protected abstract EpollRecvByteAllocatorHandle newEpollHandle(RecvByteBufAllocator.Handle handle);, +, +        @Override, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBufAllocator.java, +            default:, +                break;, +++ b/buffer/src/main/java/io/netty/buffer/PooledUnsafeDirectByteBuf.java, +++ b/buffer/src/test/java/io/netty/buffer/SlicedByteBufTest.java, +++ /dev/null, +++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/AbstractEpollChannel.java, +import io.netty.channel.RecvByteBufAllocator;, +    private static final ChannelMetadata METADATA = new ChannelMetadata(false);, +        return METADATA;, +        unsafe().recvBufAllocHandle().attemptedBytesRead(byteBuf.writableBytes());, +        private EpollRecvByteAllocatorHandle allocHandle;, +        public EpollRecvByteAllocatorHandle recvBufAllocHandle() {, +            if (allocHandle == null) {, +                allocHandle = newEpollHandle(super.recvBufAllocHandle());, +            }, +            return allocHandle;, +        }, +, +        /**, +         * Create a new {@EpollRecvByteAllocatorHandle} instance., +         * @param handle The handle to wrap with EPOLL specific logic., +         */, +        protected abstract EpollRecvByteAllocatorHandle newEpollHandle(RecvByteBufAllocator.Handle handle);, +, +        @Override, +++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/AbstractEpollServerChannel.java, +import io.netty.channel.ChannelMetadata;, +import io.netty.channel.RecvByteBufAllocator;, +    private static final ChannelMetadata METADATA = new ChannelMetadata(false, 16);, +    public ChannelMetadata metadata() {, +        return METADATA;, +    }, +, +    @Override, +        protected EpollRecvByteAllocatorHandle newEpollHandle(RecvByteBufAllocator.Handle handle) {, +            return new EpollRecvByteAllocatorMessageHandle(handle, isFlagSet(Native.EPOLLET));, +        }, +, +        @Override, +            final EpollRecvByteAllocatorHandle allocHandle = recvBufAllocHandle();, +            allocHandle.reset(config);, +, +                        allocHandle.incMessagesRead(1);, +                            if (edgeTriggered) { // We must keep reading if ET is enabled, +                            } else {, +                                throw t;, +                    } while (allocHandle.continueReading());, +                allocHandle.readComplete();, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBufAllocator.java, +            default:, +                break;, +++ b/buffer/src/main/java/io/netty/buffer/PooledUnsafeDirectByteBuf.java, +++ b/buffer/src/test/java/io/netty/buffer/SlicedByteBufTest.java, +++ /dev/null, +++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/AbstractEpollChannel.java]