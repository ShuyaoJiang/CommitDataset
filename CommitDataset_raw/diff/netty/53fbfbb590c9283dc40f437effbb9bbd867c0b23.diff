[+++ b/codec/src/main/java/io/netty/handler/codec/DefaultHeaders.java, +        if (!equals(namesList, otherNamesList, keyComparator)) {, +            if (!equals(getAll(name), h2.getAll(name), valueComparator)) {, +    /**, +     * Compare two lists using the {@code comparator} for all comparisons (not using the equals() operator), +     * @param lhs Left hand side, +     * @param rhs Right hand side, +     * @param comparator Comparator which will be used for all comparisons (equals() on objects will not be used), +     * @return True if {@code lhs} == {@code rhs} according to {@code comparator}. False otherwise., +     */, +    private static <T> boolean equals(List<T> lhs, List<T> rhs, Comparator<? super T> comparator) {, +        final int lhsSize = lhs.size();, +        if (lhsSize != rhs.size()) {, +            return false;, +        }, +, +        // Don't use a TreeSet to do the comparison.  We want to force the comparator, +        // to be used instead of the object's equals(), +        Collections.sort(lhs, comparator);, +        Collections.sort(rhs, comparator);, +        for (int i = 0; i < lhsSize; ++i) {, +            if (comparator.compare(lhs.get(i), rhs.get(i)) != 0) {, +                return false;, +            }, +        }, +        return true;, +    }, +, +++ b/codec/src/main/java/io/netty/handler/codec/DefaultHeaders.java, +        if (!equals(namesList, otherNamesList, keyComparator)) {, +            if (!equals(getAll(name), h2.getAll(name), valueComparator)) {, +    /**, +     * Compare two lists using the {@code comparator} for all comparisons (not using the equals() operator), +     * @param lhs Left hand side, +     * @param rhs Right hand side, +     * @param comparator Comparator which will be used for all comparisons (equals() on objects will not be used), +     * @return True if {@code lhs} == {@code rhs} according to {@code comparator}. False otherwise., +     */, +    private static <T> boolean equals(List<T> lhs, List<T> rhs, Comparator<? super T> comparator) {, +        final int lhsSize = lhs.size();, +        if (lhsSize != rhs.size()) {, +            return false;, +        }, +, +        // Don't use a TreeSet to do the comparison.  We want to force the comparator, +        // to be used instead of the object's equals(), +        Collections.sort(lhs, comparator);, +        Collections.sort(rhs, comparator);, +        for (int i = 0; i < lhsSize; ++i) {, +            if (comparator.compare(lhs.get(i), rhs.get(i)) != 0) {, +                return false;, +            }, +        }, +        return true;, +    }, +, +++ /dev/null]