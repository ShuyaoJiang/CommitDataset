[+++ b/transport/src/main/java/io/netty/channel/Channel.java, +import io.netty.buffer.ByteBuf;, +import io.netty.buffer.ByteBufAllocator;, +import io.netty.util.concurrent.EventExecutor;, +import io.netty.util.concurrent.FutureListener;, +import java.net.ConnectException;, +public interface Channel extends AttributeMap, Comparable<Channel> {, +     * Return the assigned {@link ChannelPipeline}, +     */, +    ChannelPipeline pipeline();, +, +    /**, +     * Return the assigned {@link ByteBufAllocator} which will be used to allocate {@link ByteBuf}s., +     */, +    ByteBufAllocator alloc();, +, +    /**, +     * Return a new {@link ChannelPromise}., +     */, +    ChannelPromise newPromise();, +, +    /**, +     * Return an new {@link ChannelProgressivePromise}, +     */, +    ChannelProgressivePromise newProgressivePromise();, +, +    /**, +     * Create a new {@link ChannelFuture} which is marked as succeeded already. So {@link ChannelFuture#isSuccess()}, +     * will return {@code true}. All {@link FutureListener} added to it will be notified directly. Also, +     * every call of blocking methods will just return without blocking., +     */, +    ChannelFuture newSucceededFuture();, +, +    /**, +     * Create a new {@link ChannelFuture} which is marked as failed already. So {@link ChannelFuture#isSuccess()}, +     * will return {@code false}. All {@link FutureListener} added to it will be notified directly. Also, +     * every call of blocking methods will just return without blocking., +     */, +    ChannelFuture newFailedFuture(Throwable cause);, +, +    /**, +     * Return a special ChannelPromise which can be reused for different operations., +     * <p>, +     * It's only supported to use, +     * it for {@link Channel#write(Object, ChannelPromise)}., +     * </p>, +     * <p>, +     * Be aware that the returned {@link ChannelPromise} will not support most operations and should only be used, +     * if you want to save an object allocation for every write operation. You will not be able to detect if the, +     * operation  was complete, only if it failed as the implementation will call, +     * {@link ChannelPipeline#fireExceptionCaught(Throwable)} in this case., +     * </p>, +     * <strong>Be aware this is an expert feature and should be used with care!</strong>, +     */, +    ChannelPromise voidPromise();, +, +    /**, +     * Request to bind to the given {@link SocketAddress} and notify the {@link ChannelFuture} once the operation, +     * completes, either because the operation was successful or because of an error., +     * <p>, +     * This will result in having the, +     * {@link ChannelOutboundHandler#bind(ChannelHandlerContext, SocketAddress, ChannelPromise)} method, +     * called of the next {@link ChannelOutboundHandler} contained in the  {@link ChannelPipeline} of the, +     * {@link Channel}., +     */, +    ChannelFuture bind(SocketAddress localAddress);, +, +    /**, +     * Request to connect to the given {@link SocketAddress} and notify the {@link ChannelFuture} once the operation, +     * completes, either because the operation was successful or because of an error., +     * <p>, +     * If the connection fails because of a connection timeout, the {@link ChannelFuture} will get failed with, +     * a {@link ConnectTimeoutException}. If it fails because of connection refused a {@link ConnectException}, +     * will be used., +     * <p>, +     * This will result in having the, +     * {@link ChannelOutboundHandler#connect(ChannelHandlerContext, SocketAddress, SocketAddress, ChannelPromise)}, +     * method called of the next {@link ChannelOutboundHandler} contained in the  {@link ChannelPipeline} of the, +     * {@link Channel}., +     */, +    ChannelFuture connect(SocketAddress remoteAddress);, +, +    /**, +     * Request to connect to the given {@link SocketAddress} while bind to the localAddress and notify the, +     * {@link ChannelFuture} once the operation completes, either because the operation was successful or because of, +     * an error., +     * <p>, +     * This will result in having the, +     * {@link ChannelOutboundHandler#connect(ChannelHandlerContext, SocketAddress, SocketAddress, ChannelPromise)}, +     * method called of the next {@link ChannelOutboundHandler} contained in the  {@link ChannelPipeline} of the, +     * {@link Channel}., +     */, +    ChannelFuture connect(SocketAddress remoteAddress, SocketAddress localAddress);, +, +    /**, +     * Request to disconnect from the remote peer and notify the {@link ChannelFuture} once the operation completes,, +     * either because the operation was successful or because of an error., +     * <p>, +     * This will result in having the, +     * {@link ChannelOutboundHandler#disconnect(ChannelHandlerContext, ChannelPromise)}]