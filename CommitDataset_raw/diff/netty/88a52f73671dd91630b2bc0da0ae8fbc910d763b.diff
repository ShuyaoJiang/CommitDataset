[+++ b/common/src/main/templates/io/netty/util/collection/KObjectHashMap.template, +     * @return {@code true} if the next item was moved back. {@code false} otherwise., +    private boolean removeAt(final int index) {, +        boolean movedBack = false;, +                movedBack = true;, +        return movedBack;, +            if (removeAt(prevIndex)) {, +                // removeAt may move elements "back" in the array if they have been displaced because their spot in the, +                // array was occupied when they were inserted. If this occurs then the nextIndex is now invalid and, +                // should instead point to the prevIndex which now holds an element which was "moved back"., +                nextIndex = prevIndex;, +            }, +++ b/common/src/main/templates/io/netty/util/collection/KObjectHashMap.template, +     * @return {@code true} if the next item was moved back. {@code false} otherwise., +    private boolean removeAt(final int index) {, +        boolean movedBack = false;, +                movedBack = true;, +        return movedBack;, +            if (removeAt(prevIndex)) {, +                // removeAt may move elements "back" in the array if they have been displaced because their spot in the, +                // array was occupied when they were inserted. If this occurs then the nextIndex is now invalid and, +                // should instead point to the prevIndex which now holds an element which was "moved back"., +                nextIndex = prevIndex;, +            }, +++ b/common/src/test/templates/io/netty/util/collection/KObjectHashMapTest.template, +import io.netty.util.collection.@K@ObjectMap.PrimitiveEntry;, +    public void iteartorRemoveShouldNotNPE() {, +        map = new @K@ObjectHashMap<Value>(4, 1);, +        map.put((@O@)(@k@) 0, new Value("A"));, +        map.put((@O@)(@k@) 1, new Value("B"));, +        map.put((@O@)(@k@) 4, new Value("C"));, +        map.remove((@O@)(@k@) 1);, +        Iterator<PrimitiveEntry<Value>> itr = map.entries().iterator();, +        while (itr.hasNext()) {, +            PrimitiveEntry<Value> entry = itr.next();, +            assertNotNull(entry.key());, +            assertNotNull(entry.value());, +            itr.remove();, +        }, +        assertTrue(map.isEmpty());, +        assertEquals(0, map.size());, +    }, +, +    @Test]