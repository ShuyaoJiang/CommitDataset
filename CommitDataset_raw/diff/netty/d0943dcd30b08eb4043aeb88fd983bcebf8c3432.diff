[+++ b/transport/src/main/java/io/netty/channel/ChannelOutboundBuffer.java, +    private final Runnable fireChannelWritabilityChangedTask;, +    ChannelOutboundBuffer(final AbstractChannel channel) {, +        fireChannelWritabilityChangedTask = new ChannelWritabilityChangedTask(channel);, +        incrementPendingOutboundBytes(size, true);, +                    decrementPendingOutboundBytes(pending, true);, +    void incrementPendingOutboundBytes(long size, boolean notifyWritability) {, +            setUnwritable(notifyWritability);, +    void decrementPendingOutboundBytes(long size, boolean notifyWritability) {, +        if (newWriteBufferSize == 0, +            || newWriteBufferSize <= channel.config().getWriteBufferLowWaterMark()) {, +            setWritable(notifyWritability);, +            decrementPendingOutboundBytes(size, true);, +            decrementPendingOutboundBytes(size, notifyWritability);, +                    fireChannelWritabilityChanged();, +                    fireChannelWritabilityChanged();, +    private void setWritable(boolean notify) {, +                if (notify && oldValue != 0 && newValue == 0) {, +                    fireChannelWritabilityChanged();, +    private void setUnwritable(boolean notify) {, +                if (notify && oldValue == 0 && newValue != 0) {, +                    fireChannelWritabilityChanged();, +    private void fireChannelWritabilityChanged() {, +        // Always invoke it later to prevent re-entrance bug., +        // See https://github.com/netty/netty/issues/5028, +        channel.eventLoop().execute(fireChannelWritabilityChangedTask);, +, +    private static final class ChannelWritabilityChangedTask implements Runnable {, +        private final Channel channel;, +        private boolean writable = true;, +, +        ChannelWritabilityChangedTask(Channel channel) {, +            this.channel = channel;, +        }, +, +        @Override, +        public void run() {, +            if (channel.isActive()) {, +                boolean newWritable = channel.isWritable();, +, +                if (writable != newWritable) {, +                    writable = newWritable;, +                    channel.pipeline().fireChannelWritabilityChanged();, +                }, +            }, +        }, +    }, +++ b/transport/src/main/java/io/netty/channel/ChannelOutboundBuffer.java, +    private final Runnable fireChannelWritabilityChangedTask;, +    ChannelOutboundBuffer(final AbstractChannel channel) {, +        fireChannelWritabilityChangedTask = new ChannelWritabilityChangedTask(channel);, +        incrementPendingOutboundBytes(size, true);, +                    decrementPendingOutboundBytes(pending, true);, +    void incrementPendingOutboundBytes(long size, boolean notifyWritability) {, +            setUnwritable(notifyWritability);, +    void decrementPendingOutboundBytes(long size, boolean notifyWritability) {, +        if (newWriteBufferSize == 0, +            || newWriteBufferSize <= channel.config().getWriteBufferLowWaterMark()) {, +            setWritable(notifyWritability);, +            decrementPendingOutboundBytes(size, true);, +            decrementPendingOutboundBytes(size, notifyWritability);, +                    fireChannelWritabilityChanged();, +                    fireChannelWritabilityChanged();, +    private void setWritable(boolean notify) {, +                if (notify && oldValue != 0 && newValue == 0) {, +                    fireChannelWritabilityChanged();, +    private void setUnwritable(boolean notify) {, +                if (notify && oldValue == 0 && newValue != 0) {, +                    fireChannelWritabilityChanged();, +    private void fireChannelWritabilityChanged() {, +        // Always invoke it later to prevent re-entrance bug., +        // See https://github.com/netty/netty/issues/5028, +        channel.eventLoop().execute(fireChannelWritabilityChangedTask);, +, +    private static final class ChannelWritabilityChangedTask implements Runnable {, +        private final Channel channel;, +        private boolean writable = true;, +, +        ChannelWritabilityChangedTask(Channel channel) {, +            this.channel = channel;, +        }, +, +        @Override, +        public void run() {, +            if (channel.isActive()) {, +                boolean newWritable = channel.isWritable();, +, +                if (writable != newWritable) {, +                    writable = newWritable;, +                    channel.pipeline().fireChannelWritabilityChanged();, +                }, +            }, +        }, +    }, +++ b/transport/src/main/java/io/netty/channel/DefaultChannelHandlerInvoker.java, +                    // We increment the pending bytes but NOT call fireChannelWritabilityChanged() because this, +                    // will be done automaticaly once we add the message to the ChannelOutboundBuffer., +                    buffer.incrementPendingOutboundBytes(task.size, false);, +                    // We decrement the pending bytes but NOT call fireChannelWritabilityChanged() because this, +                    // will be done automaticaly once we pick up the messages out of the buffer to actually write these.]