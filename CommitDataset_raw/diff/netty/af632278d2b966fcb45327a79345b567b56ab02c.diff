[+++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslKeyMaterialManager.java, +                SSL.setCertificateChainBio(ssl, keyCertChainBio2, true);, +++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslKeyMaterialManager.java, +                SSL.setCertificateChainBio(ssl, keyCertChainBio2, true);, +++ b/handler/src/main/java/io/netty/handler/ssl/ReferenceCountedOpenSslContext.java, +            SSLContext.setCertificateChainBio(ctx, keyCertChainBio2, true);, +++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslKeyMaterialManager.java, +                SSL.setCertificateChainBio(ssl, keyCertChainBio2, true);, +++ b/handler/src/main/java/io/netty/handler/ssl/ReferenceCountedOpenSslContext.java, +            SSLContext.setCertificateChainBio(ctx, keyCertChainBio2, true);, +++ b/handler/src/main/java/io/netty/handler/ssl/ReferenceCountedOpenSslEngine.java, +    private final OpenSslSession session;, +            if (chain == null || chain.length == 0) {, +                if (clientCert == null || clientCert.length == 0) {, +                    peerCerts = EmptyArrays.EMPTY_CERTIFICATES;, +                    x509PeerCerts = EmptyArrays.EMPTY_JAVAX_X509_CERTIFICATES;, +                    peerCerts = new Certificate[1];, +                    x509PeerCerts = new X509Certificate[1];, +                    peerCerts[0] = new OpenSslX509Certificate(clientCert);, +                    x509PeerCerts[0] = new OpenSslJavaxX509Certificate(clientCert);, +            } else if (clientCert == null || clientCert.length == 0) {, +                peerCerts = new Certificate[chain.length];, +                x509PeerCerts = new X509Certificate[chain.length];, +                for (int a = 0; a < chain.length; ++a) {, +                    peerCerts[a] = new OpenSslX509Certificate(bytes);, +                    x509PeerCerts[a] = new OpenSslJavaxX509Certificate(bytes);, +                int len = clientCert.length + 1;, +                peerCerts = new Certificate[len];, +                x509PeerCerts = new X509Certificate[len];, +, +                peerCerts[0] = new OpenSslX509Certificate(clientCert);, +                x509PeerCerts[0] = new OpenSslJavaxX509Certificate(clientCert);, +, +                for (int a = 0, i = 1; a < chain.length; ++a, ++i) {, +                    byte[] bytes = chain[a];, +                    peerCerts[i] = new OpenSslX509Certificate(bytes);, +                    x509PeerCerts[i] = new OpenSslJavaxX509Certificate(bytes);, +                return peerCerts.clone();, +                return x509PeerCerts.clone();, +++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslKeyMaterialManager.java, +                SSL.setCertificateChainBio(ssl, keyCertChainBio2, true);, +++ b/handler/src/main/java/io/netty/handler/ssl/ReferenceCountedOpenSslContext.java, +            SSLContext.setCertificateChainBio(ctx, keyCertChainBio2, true);, +++ b/handler/src/main/java/io/netty/handler/ssl/ReferenceCountedOpenSslEngine.java, +    private final OpenSslSession session;, +            if (chain == null || chain.length == 0) {, +                if (clientCert == null || clientCert.length == 0) {, +                    peerCerts = EmptyArrays.EMPTY_CERTIFICATES;, +                    x509PeerCerts = EmptyArrays.EMPTY_JAVAX_X509_CERTIFICATES;, +                    peerCerts = new Certificate[1];, +                    x509PeerCerts = new X509Certificate[1];, +                    peerCerts[0] = new OpenSslX509Certificate(clientCert);, +                    x509PeerCerts[0] = new OpenSslJavaxX509Certificate(clientCert);, +            } else if (clientCert == null || clientCert.length == 0) {, +                peerCerts = new Certificate[chain.length];, +                x509PeerCerts = new X509Certificate[chain.length];, +                for (int a = 0; a < chain.length; ++a) {, +                    peerCerts[a] = new OpenSslX509Certificate(bytes);, +                    x509PeerCerts[a] = new OpenSslJavaxX509Certificate(bytes);, +                int len = clientCert.length + 1;, +                peerCerts = new Certificate[len];, +                x509PeerCerts = new X509Certificate[len];, +, +                peerCerts[0] = new OpenSslX509Certificate(clientCert);, +                x509PeerCerts[0] = new OpenSslJavaxX509Certificate(clientCert);, +, +                for (int a = 0, i = 1; a < chain.length; ++a, ++i) {, +                    byte[] bytes = chain[a];, +                    peerCerts[i] = new OpenSslX509Certificate(bytes);, +                    x509PeerCerts[i] = new OpenSslJavaxX509Certificate(bytes);, +                return peerCerts.clone();, +                return x509PeerCerts.clone();, +++ b/handler/src/test/java/io/netty/handler/ssl/JdkOpenSslEngineInteroptTest.java, +/*, + * Copyright 2016 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + *   http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the, + * License for the specific language governing permissions and limitations, + * under the License., + */, +package io.netty.handler.ssl;, +, +import org.junit.BeforeClass;, +, +import static org.junit.Assume.assumeTrue;, +, +public class JdkOpenSslEngineInteroptTest extends SSLEngineTest {, +    @BeforeClass, +    public static void checkOpenSsl() {, +        assumeTrue(OpenSsl.isAvailable());, +    }, +]