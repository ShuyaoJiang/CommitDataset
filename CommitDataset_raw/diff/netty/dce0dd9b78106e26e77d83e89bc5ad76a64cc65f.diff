[+++ b/buffer/src/main/java/io/netty/buffer/PoolArena.java, +    enum SizeClass {, +        Tiny,, +        Small,, +        Normal, +    }, +, +        q100 = new PoolChunkList<T>(null, 100, Integer.MAX_VALUE);, +        q075 = new PoolChunkList<T>(q100, 75, 100);, +        q050 = new PoolChunkList<T>(q075, 50, 100);, +        q025 = new PoolChunkList<T>(q050, 25, 75);, +        q000 = new PoolChunkList<T>(q025, 1, 50);, +        qInit = new PoolChunkList<T>(q000, Integer.MIN_VALUE, 25);, +        q100.prevList(q075);, +        q075.prevList(q050);, +        q050.prevList(q025);, +        q025.prevList(q000);, +        q000.prevList(null);, +        qInit.prevList(qInit);, +            SizeClass sizeClass = sizeClass(normCapacity);, +                PoolThreadCache cache = parent.threadCache();, +                if (cache.add(this, chunk, handle, normCapacity, sizeClass)) {, +            freeChunk(chunk, handle, sizeClass);, +        }, +    }, +    private SizeClass sizeClass(int normCapacity) {, +        if (!isTinyOrSmall(normCapacity)) {, +            return SizeClass.Normal;, +        }, +        return isTiny(normCapacity) ? SizeClass.Tiny : SizeClass.Small;, +    }, +, +    void freeChunk(PoolChunk<T> chunk, long handle, SizeClass sizeClass) {, +        final boolean destroyChunk;, +            switch (sizeClass) {, +            case Normal:, +                break;, +            case Small:, +                break;, +            case Tiny:, +                ++deallocationsTiny;, +                break;, +            default:, +                throw new Error();, +            destroyChunk = !chunk.parent.free(chunk, handle);, +        if (destroyChunk) {, +            // destroyChunk not need to be called while holding the synchronized lock., +            destroyChunk(chunk);, +        allocate(parent.threadCache(), buf, newCapacity);, +++ b/buffer/src/main/java/io/netty/buffer/PoolArena.java, +    enum SizeClass {, +        Tiny,, +        Small,, +        Normal, +    }, +, +        q100 = new PoolChunkList<T>(null, 100, Integer.MAX_VALUE);, +        q075 = new PoolChunkList<T>(q100, 75, 100);, +        q050 = new PoolChunkList<T>(q075, 50, 100);, +        q025 = new PoolChunkList<T>(q050, 25, 75);, +        q000 = new PoolChunkList<T>(q025, 1, 50);, +        qInit = new PoolChunkList<T>(q000, Integer.MIN_VALUE, 25);, +        q100.prevList(q075);, +        q075.prevList(q050);, +        q050.prevList(q025);, +        q025.prevList(q000);, +        q000.prevList(null);, +        qInit.prevList(qInit);, +            SizeClass sizeClass = sizeClass(normCapacity);, +                PoolThreadCache cache = parent.threadCache();, +                if (cache.add(this, chunk, handle, normCapacity, sizeClass)) {, +            freeChunk(chunk, handle, sizeClass);, +        }, +    }, +    private SizeClass sizeClass(int normCapacity) {, +        if (!isTinyOrSmall(normCapacity)) {, +            return SizeClass.Normal;, +        }, +        return isTiny(normCapacity) ? SizeClass.Tiny : SizeClass.Small;, +    }, +, +    void freeChunk(PoolChunk<T> chunk, long handle, SizeClass sizeClass) {, +        final boolean destroyChunk;, +            switch (sizeClass) {, +            case Normal:, +                break;, +            case Small:, +                break;, +            case Tiny:, +                ++deallocationsTiny;, +                break;, +            default:, +                throw new Error();, +            destroyChunk = !chunk.parent.free(chunk, handle);, +        if (destroyChunk) {, +            // destroyChunk not need to be called while holding the synchronized lock., +            destroyChunk(chunk);, +        allocate(parent.threadCache(), buf, newCapacity);, +++ b/buffer/src/main/java/io/netty/buffer/PoolChunkList.java, +    // This is only update once when create the linked like list of PoolChunkList in PoolArena constructor.]