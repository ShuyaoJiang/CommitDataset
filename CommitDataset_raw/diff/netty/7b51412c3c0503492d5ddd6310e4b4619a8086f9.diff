[+++ b/common/src/main/java/io/netty/util/AsyncMapping.java, +/*, + * Copyright 2015 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + *   http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the, + * License for the specific language governing permissions and limitations, + * under the License., + */, +package io.netty.util;, +, +import io.netty.util.concurrent.Future;, +import io.netty.util.concurrent.Promise;, +, +public interface AsyncMapping<IN, OUT> {, +, +    /**, +     * Returns the {@link Future} that will provide the result of the mapping. The given {@link Promise} will, +     * be fulfilled when the result is available., +     */, +    Future<OUT> map(IN input, Promise<OUT> promise);, +}, +++ b/common/src/main/java/io/netty/util/AsyncMapping.java, +/*, + * Copyright 2015 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + *   http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the, + * License for the specific language governing permissions and limitations, + * under the License., + */, +package io.netty.util;, +, +import io.netty.util.concurrent.Future;, +import io.netty.util.concurrent.Promise;, +, +public interface AsyncMapping<IN, OUT> {, +, +    /**, +     * Returns the {@link Future} that will provide the result of the mapping. The given {@link Promise} will, +     * be fulfilled when the result is available., +     */, +    Future<OUT> map(IN input, Promise<OUT> promise);, +}, +++ b/handler/src/main/java/io/netty/handler/ssl/SniHandler.java, +import io.netty.channel.ChannelOutboundHandler;, +import io.netty.channel.ChannelPromise;, +import io.netty.handler.codec.DecoderException;, +import io.netty.util.AsyncMapping;, +import io.netty.util.concurrent.Future;, +import io.netty.util.concurrent.FutureListener;, +import io.netty.util.concurrent.Promise;, +import io.netty.util.internal.ObjectUtil;, +import java.net.SocketAddress;, +public class SniHandler extends ByteToMessageDecoder implements ChannelOutboundHandler {, +    private final AsyncMapping<String, SslContext> mapping;, +    private boolean handshakeFailed;, +    private boolean suppressRead;, +    private boolean readPending;, +        this(new AsyncMappingAdapter(mapping));, +     * Creates a SNI detection handler with configured {@link SslContext}, +     * maintained by {@link AsyncMapping}, +     *, +     * @param mapping the mapping of domain name to {@link SslContext}, +     */, +    @SuppressWarnings("unchecked"), +    public SniHandler(AsyncMapping<? super String, ? extends SslContext> mapping) {, +        this.mapping = (AsyncMapping<String, SslContext>) ObjectUtil.checkNotNull(mapping, "mapping");, +    }, +, +    /**, +        if (!suppressRead && !handshakeFailed && in.readableBytes() >= SslUtils.SSL_RECORD_HEADER_LENGTH) {, +                loop:, +                for (int i = 0; i < MAX_SSL_RECORDS; i++) {, +, +    private void select(final ChannelHandlerContext ctx, final String hostname) {, +        Future<SslContext> future = mapping.map(hostname, ctx.executor().<SslContext>newPromise());, +        if (future.isDone()) {, +            if (future.isSuccess()) {, +                replaceHandler(ctx, new Selection(future.getNow(), hostname));, +            } else {, +                throw new DecoderException("failed to get the SslContext for " + hostname, future.cause());, +            }, +        } else {, +            suppressRead = true;, +            future.addListener(new FutureListener<SslContext>() {]