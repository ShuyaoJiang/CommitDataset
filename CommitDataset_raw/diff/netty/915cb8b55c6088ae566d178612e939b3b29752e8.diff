[+++ b/common/src/main/java/io/netty/util/HashedWheelTimer.java, +, +    public static final int WORKER_STATE_INIT = 0;, +    public static final int WORKER_STATE_STARTED = 1;, +    public static final int WORKER_STATE_SHUTDOWN = 2;, +            case WORKER_STATE_INIT:, +                if (workerState.compareAndSet(WORKER_STATE_INIT, WORKER_STATE_STARTED)) {, +            case WORKER_STATE_STARTED:, +            case WORKER_STATE_SHUTDOWN:, +                throw new Error("Invalid WorkerState");, +        if (!workerState.compareAndSet(WORKER_STATE_STARTED, WORKER_STATE_SHUTDOWN)) {, +            workerState.set(WORKER_STATE_SHUTDOWN);, +        long relativeIndex = (delay + tickDuration - 1) / tickDuration;, +        // if the previous line had an overflow going on, then we’ll just schedule this timeout, +        // one tick early; that shouldn’t matter since we’re talking 270 years here, +        if (relativeIndex < 0) {, +            relativeIndex = delay / tickDuration;, +        }, +        if (relativeIndex == 0) {, +            relativeIndex = 1;, +        }, +        if ((relativeIndex & mask) == 0) {, +            relativeIndex--;, +        }, +        final long remainingRounds = relativeIndex / wheel.length;, +            if (workerState.get() == WORKER_STATE_SHUTDOWN) {, +                throw new IllegalStateException("Cannot enqueue after shutdown");, +            }, +            final int stopIndex = (int) ((wheelCursor + relativeIndex) & mask);, +            while (workerState.get() == WORKER_STATE_STARTED) {, +        /**, +         * calculate goal nanoTime from startTime and current tick number,, +         * then wait until that goal has been reached., +         * @return Long.MIN_VALUE if received a shutdown request,, +         * current time otherwise (with Long.MIN_VALUE changed by +1), +         */, +                long sleepTimeMs = (deadline - currentTime + 999999) / 1000000;, +, +                if (sleepTimeMs <= 0) {, +                    tick += 1;, +                    if (currentTime == Long.MIN_VALUE) {, +                        return -Long.MAX_VALUE;, +                    } else {, +                        return currentTime;, +                    }, +                }, +                    sleepTimeMs = (sleepTimeMs / 10) * 10;, +                    Thread.sleep(sleepTimeMs);, +                    if (workerState.get() == WORKER_STATE_SHUTDOWN) {, +                        return Long.MIN_VALUE;, +++ b/common/src/main/java/io/netty/util/HashedWheelTimer.java, +, +    public static final int WORKER_STATE_INIT = 0;, +    public static final int WORKER_STATE_STARTED = 1;, +    public static final int WORKER_STATE_SHUTDOWN = 2;, +            case WORKER_STATE_INIT:, +                if (workerState.compareAndSet(WORKER_STATE_INIT, WORKER_STATE_STARTED)) {, +            case WORKER_STATE_STARTED:, +            case WORKER_STATE_SHUTDOWN:, +                throw new Error("Invalid WorkerState");, +        if (!workerState.compareAndSet(WORKER_STATE_STARTED, WORKER_STATE_SHUTDOWN)) {, +            workerState.set(WORKER_STATE_SHUTDOWN);, +        long relativeIndex = (delay + tickDuration - 1) / tickDuration;, +        // if the previous line had an overflow going on, then we’ll just schedule this timeout, +        // one tick early; that shouldn’t matter since we’re talking 270 years here, +        if (relativeIndex < 0) {, +            relativeIndex = delay / tickDuration;, +        }, +        if (relativeIndex == 0) {, +            relativeIndex = 1;, +        }, +        if ((relativeIndex & mask) == 0) {, +            relativeIndex--;, +        }, +        final long remainingRounds = relativeIndex / wheel.length;, +            if (workerState.get() == WORKER_STATE_SHUTDOWN) {, +                throw new IllegalStateException("Cannot enqueue after shutdown");, +            }, +            final int stopIndex = (int) ((wheelCursor + relativeIndex) & mask);, +            while (workerState.get() == WORKER_STATE_STARTED) {, +        /**, +         * calculate goal nanoTime from startTime and current tick number,, +         * then wait until that goal has been reached., +         * @return Long.MIN_VALUE if received a shutdown request,, +         * current time otherwise (with Long.MIN_VALUE changed by +1), +         */, +                long sleepTimeMs = (deadline - currentTime + 999999) / 1000000;, +, +                if (sleepTimeMs <= 0) {, +                    tick += 1;, +                    if (currentTime == Long.MIN_VALUE) {, +                        return -Long.MAX_VALUE;, +                    } else {, +                        return currentTime;, +                    }, +                }, +                    sleepTimeMs = (sleepTimeMs / 10) * 10;, +                    Thread.sleep(sleepTimeMs);, +                    if (workerState.get() == WORKER_STATE_SHUTDOWN) {, +                        return Long.MIN_VALUE;]