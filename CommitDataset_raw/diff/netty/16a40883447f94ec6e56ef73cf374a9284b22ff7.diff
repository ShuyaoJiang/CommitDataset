[+++ b/transport/src/main/java/io/netty/channel/ChannelStateHandler.java, +++ b/transport/src/main/java/io/netty/channel/ChannelStateHandler.java, +++ b/transport/src/main/java/io/netty/channel/DefaultChannelHandlerContext.java, +    final AtomicBoolean suspendRead = new AtomicBoolean();, +++ b/transport/src/main/java/io/netty/channel/ChannelStateHandler.java, +++ b/transport/src/main/java/io/netty/channel/DefaultChannelHandlerContext.java, +    final AtomicBoolean suspendRead = new AtomicBoolean();, +++ b/transport/src/main/java/io/netty/channel/DefaultChannelPipeline.java, +        // make sure the it's set back to readable, +        // make sure the it's set back to readable, +++ b/transport/src/main/java/io/netty/channel/ChannelStateHandler.java, +++ b/transport/src/main/java/io/netty/channel/DefaultChannelHandlerContext.java, +    final AtomicBoolean suspendRead = new AtomicBoolean();, +++ b/transport/src/main/java/io/netty/channel/DefaultChannelPipeline.java, +        // make sure the it's set back to readable, +        // make sure the it's set back to readable, +++ b/transport/src/main/java/io/netty/channel/socket/aio/AbstractAioChannel.java, +    protected abstract class AbstractAioUnsafe extends AbstractUnsafe {, +++ b/transport/src/main/java/io/netty/channel/ChannelStateHandler.java, +++ b/transport/src/main/java/io/netty/channel/DefaultChannelHandlerContext.java, +    final AtomicBoolean suspendRead = new AtomicBoolean();, +++ b/transport/src/main/java/io/netty/channel/DefaultChannelPipeline.java, +        // make sure the it's set back to readable, +        // make sure the it's set back to readable, +++ b/transport/src/main/java/io/netty/channel/socket/aio/AbstractAioChannel.java, +    protected abstract class AbstractAioUnsafe extends AbstractUnsafe {, +++ b/transport/src/main/java/io/netty/channel/socket/aio/AioServerSocketChannel.java, +    private AtomicBoolean readSuspended = new AtomicBoolean();, +, +    private final Runnable acceptTask = new Runnable() {, +, +        @Override, +        public void run() {, +            doAccept();, +        }, +    };, +        if (readSuspended.get()) {, +            if (!channel.readSuspended.get()) {, +        return new AioServerSocketUnsafe();, +    }, +, +    private final class AioServerSocketUnsafe extends AbstractAioUnsafe {, +            readSuspended.set(true);, +            if (readSuspended.compareAndSet(true, false)) {, +                if (eventLoop().inEventLoop()) {, +                } else {, +                    eventLoop().execute(acceptTask);, +        }, +++ b/transport/src/main/java/io/netty/channel/ChannelStateHandler.java, +++ b/transport/src/main/java/io/netty/channel/DefaultChannelHandlerContext.java, +    final AtomicBoolean suspendRead = new AtomicBoolean();, +++ b/transport/src/main/java/io/netty/channel/DefaultChannelPipeline.java, +        // make sure the it's set back to readable, +        // make sure the it's set back to readable, +++ b/transport/src/main/java/io/netty/channel/socket/aio/AbstractAioChannel.java, +    protected abstract class AbstractAioUnsafe extends AbstractUnsafe {, +++ b/transport/src/main/java/io/netty/channel/socket/aio/AioServerSocketChannel.java, +    private AtomicBoolean readSuspended = new AtomicBoolean();, +, +    private final Runnable acceptTask = new Runnable() {, +, +        @Override, +        public void run() {, +            doAccept();, +        }, +    };, +        if (readSuspended.get()) {, +            if (!channel.readSuspended.get()) {, +        return new AioServerSocketUnsafe();, +    }, +, +    private final class AioServerSocketUnsafe extends AbstractAioUnsafe {, +            readSuspended.set(true);, +            if (readSuspended.compareAndSet(true, false)) {, +                if (eventLoop().inEventLoop()) {, +                } else {, +                    eventLoop().execute(acceptTask);, +        }, +++ b/transport/src/main/java/io/netty/channel/socket/aio/AioSocketChannel.java, +    private final AtomicBoolean readSuspended = new AtomicBoolean();, +        if (readSuspended.get()) {, +                    if (!channel.readSuspended.get()) {, +                    if (!channel.readSuspended.get()) {, +            ((AbstractAioUnsafe) channel.unsafe()).connectSuccess();, +            ((AbstractAioUnsafe) channel.unsafe()).connectFailed(exc);, +    private final class AioSocketChannelAsyncUnsafe extends AbstractAioUnsafe {, +            readSuspended.set(true);, +            if (readSuspended.compareAndSet(true, false)) {, +++ b/transport/src/main/java/io/netty/channel/ChannelStateHandler.java, +++ b/transport/src/main/java/io/netty/channel/DefaultChannelHandlerContext.java, +    final AtomicBoolean suspendRead = new AtomicBoolean();, +++ b/transport/src/main/java/io/netty/channel/DefaultChannelPipeline.java, +        // make sure the it's set back to readable, +        // make sure the it's set back to readable, +++ b/transport/src/main/java/io/netty/channel/socket/aio/AbstractAioChannel.java, +    protected abstract class AbstractAioUnsafe extends AbstractUnsafe {, +++ b/transport/src/main/java/io/netty/channel/socket/aio/AioServerSocketChannel.java, +    private AtomicBoolean readSuspended = new AtomicBoolean();, +, +    private final Runnable acceptTask = new Runnable() {]