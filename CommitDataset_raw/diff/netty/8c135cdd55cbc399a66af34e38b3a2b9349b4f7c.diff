[+++ b/handler/src/main/java/io/netty/handler/traffic/TrafficCounter.java, + * Counts the number of read and written bytes for rate-limiting traffic., + * <p>, + * It computes the statistics for both inbound and outbound traffic periodically at the given, + * {@code checkInterval}, and calls the {@link AbstractTrafficShapingHandler#doAccounting(TrafficCounter)} method back., + * If the {@code checkInterval} is {@code 0}, no accounting will be done and statistics will only be computed at each, + * receive or write operation., + * </p>, +, +    private static final InternalLogger logger = InternalLoggerFactory.getInstance(TrafficCounter.class);, +    private final class TrafficMonitoringTask implements Runnable {, +            if (!monitorActive) {, +            resetAccounting(milliSecondFromNano());, +            if (trafficShapingHandler != null) {, +                trafficShapingHandler.doAccounting(TrafficCounter.this);, +            scheduledFuture = executor.schedule(this, checkInterval.get(), TimeUnit.MILLISECONDS);, +            monitor = new TrafficMonitoringTask();, +     * Constructor with the {@link AbstractTrafficShapingHandler} that hosts it, the {@link ScheduledExecutorService}, +     * to use, its name, the checkInterval between two computations in milliseconds., +     *, +     * @param executor, +     *            the underlying executor service for scheduling checks, might be null when used, +     * from {@link GlobalChannelTrafficCounter}., +     * @param name, +     *            the name given to this monitor., +     * @param checkInterval, +     *            the checkInterval in millisecond between two computations., +     */, +    public TrafficCounter(ScheduledExecutorService executor, String name, long checkInterval) {, +        if (executor == null) {, +            throw new NullPointerException("executor");, +        }, +        if (name == null) {, +            throw new NullPointerException("name");, +        }, +, +        trafficShapingHandler = null;, +        this.executor = executor;, +        this.name = name;, +, +        init(checkInterval);, +    }, +, +    /**, +    public TrafficCounter(, +            AbstractTrafficShapingHandler trafficShapingHandler, ScheduledExecutorService executor,, +, +            throw new IllegalArgumentException("trafficShapingHandler");, +        if (executor == null) {, +            throw new NullPointerException("executor");, +        }, +        if (name == null) {, +            throw new NullPointerException("name");, +        }, +, +, +        init(checkInterval);, +    }, +, +    private void init(long checkInterval) {]