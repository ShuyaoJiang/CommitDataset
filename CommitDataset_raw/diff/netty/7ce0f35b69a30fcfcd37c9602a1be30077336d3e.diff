[+++ b/handler/src/main/java/io/netty/handler/ssl/ReferenceCountedOpenSslEngine.java, +    private boolean outboundClosed;, +        session = new OpenSslSession(context.sessionContext());, +            isInboundDone = outboundClosed = true;, +, +            SSLEngineResult.HandshakeStatus hs = mayFinishHandshake(, +                    status != FINISHED ? getHandshakeStatus(pendingNet) : status);, +            final SSLEngineResult.Status rs;, +, +            // If isOutboundDone, then the data from the network BIO, +            // was the close_notify message and all was consumed we are not required to wait, +            if (isOutboundDone()) {, +                rs = CLOSED;, +            } else {, +                rs = OK;, +            return new SSLEngineResult(rs, hs, bytesConsumed, bytesProduced);, +            // Check to make sure the engine has not been closed and the outbound is not considered as done while the, +            // handshake was not started at all., +            if (isDestroyed() || (handshakeState == HandshakeState.NOT_STARTED && isOutboundDone())) {, +                    // Signal if the outbound is done or not., +                    return isOutboundDone() ? NEED_UNWRAP_CLOSED : NEED_UNWRAP_OK;, +                // Explicit use outboundClosed and not outboundClosed() as we want to drain any bytes that are still, +                // present., +                if (outboundClosed) {, +                    SSLEngineResult pendingNetResult = readPendingBytesFromBIO(dst, 0, 0, status);, +                    return pendingNetResult != null ? pendingNetResult : NEED_UNWRAP_CLOSED;, +                                        new SSLEngineResult(isOutboundDone() ? CLOSED : OK,, +            return newResult(isOutboundDone() ? CLOSED : OK, bytesConsumed, bytesProduced, status);, +            // Check to make sure the engine has not been closed and the inbound was not marked as done., +            if (isDestroyed() || (handshakeState == HandshakeState.NOT_STARTED && isInboundDone())) {, +                // Check if the inbound is considered to be closed if so let us try to wrap again., +                if (isInboundDone) {, +                            return newResult(isInboundDone() ? CLOSED : OK, bytesConsumed, bytesProduced, status);, +                                return newResult(isInboundDone() ? CLOSED : OK, bytesConsumed, bytesProduced, status);, +            return newResult(isInboundDone() ? CLOSED : OK, bytesConsumed, bytesProduced, status);, +    private SSLEngineResult newResult(SSLEngineResult.Status resultStatus,, +        return new SSLEngineResult(resultStatus, mayFinishHandshake(status != FINISHED ? getHandshakeStatus() : status),, +            bytesConsumed, bytesProduced);, +        return isInboundDone;, +        if (outboundClosed) {, +        outboundClosed = true;, +            if (SSL.isInInit(ssl) != 0) {, +                // Only try to call SSL_shutdown if we are not in the init state anymore., +                // Otherwise we will see 'error:140E0197:SSL routines:SSL_shutdown:shutdown while in init' in our logs., +                //, +                // See also http://hg.nginx.org/nginx/rev/062c189fee20, +                return;, +            }, +, +        // Check if there is anything left in the outbound buffer., +        // We need to ensure we only call SSL.pendingWrittenBytesInBIO(...) if the engine was not destroyed yet., +        return outboundClosed && (networkBIO == 0 || SSL.pendingWrittenBytesInBIO(networkBIO) == 0);, +        if (isDestroyed()) {, +                && (handshakeState != HandshakeState.FINISHED || isInboundDone() || isOutboundDone());, +++ b/handler/src/main/java/io/netty/handler/ssl/ReferenceCountedOpenSslEngine.java, +    private boolean outboundClosed;, +        session = new OpenSslSession(context.sessionContext());, +            isInboundDone = outboundClosed = true;, +, +            SSLEngineResult.HandshakeStatus hs = mayFinishHandshake(, +                    status != FINISHED ? getHandshakeStatus(pendingNet) : status);, +            final SSLEngineResult.Status rs;, +, +            // If isOutboundDone, then the data from the network BIO, +            // was the close_notify message and all was consumed we are not required to wait, +            if (isOutboundDone()) {, +                rs = CLOSED;, +            } else {, +                rs = OK;, +            return new SSLEngineResult(rs, hs, bytesConsumed, bytesProduced);, +            // Check to make sure the engine has not been closed and the outbound is not considered as done while the, +            // handshake was not started at all., +            if (isDestroyed() || (handshakeState == HandshakeState.NOT_STARTED && isOutboundDone())) {, +                    // Signal if the outbound is done or not., +                    return isOutboundDone() ? NEED_UNWRAP_CLOSED : NEED_UNWRAP_OK;, +                // Explicit use outboundClosed and not outboundClosed() as we want to drain any bytes that are still, +                // present., +                if (outboundClosed) {, +                    SSLEngineResult pendingNetResult = readPendingBytesFromBIO(dst, 0, 0, status);, +                    return pendingNetResult != null ? pendingNetResult : NEED_UNWRAP_CLOSED;, +                                        new SSLEngineResult(isOutboundDone() ? CLOSED : OK,, +            return newResult(isOutboundDone() ? CLOSED : OK, bytesConsumed, bytesProduced, status);, +            // Check to make sure the engine has not been closed and the inbound was not marked as done., +            if (isDestroyed() || (handshakeState == HandshakeState.NOT_STARTED && isInboundDone())) {, +                // Check if the inbound is considered to be closed if so let us try to wrap again., +                if (isInboundDone) {, +                            return newResult(isInboundDone() ? CLOSED : OK, bytesConsumed, bytesProduced, status);, +                                return newResult(isInboundDone() ? CLOSED : OK, bytesConsumed, bytesProduced, status);, +            return newResult(isInboundDone() ? CLOSED : OK, bytesConsumed, bytesProduced, status);, +    private SSLEngineResult newResult(SSLEngineResult.Status resultStatus,, +        return new SSLEngineResult(resultStatus, mayFinishHandshake(status != FINISHED ? getHandshakeStatus() : status),, +            bytesConsumed, bytesProduced);, +        return isInboundDone;, +        if (outboundClosed) {, +        outboundClosed = true;, +            if (SSL.isInInit(ssl) != 0) {, +                // Only try to call SSL_shutdown if we are not in the init state anymore., +                // Otherwise we will see 'error:140E0197:SSL routines:SSL_shutdown:shutdown while in init' in our logs., +                //, +                // See also http://hg.nginx.org/nginx/rev/062c189fee20]