[+++ b/handler/src/main/java/io/netty/handler/ssl/SslHandler.java, +        boolean needUnwrap = false;, +                            finishWrap(ctx, out, promise, inUnwrap, false);, +                            needUnwrap = true;, +            finishWrap(ctx, out, promise, inUnwrap, needUnwrap);, +    private void finishWrap(ChannelHandlerContext ctx, ByteBuf out, ChannelPromise promise, boolean inUnwrap,, +            boolean needUnwrap) {, +, +        if (needUnwrap) {, +            // The underlying engine is starving so we need to feed it with more data., +            // See https://github.com/netty/netty/pull/5039, +            readIfNeeded(ctx);, +        }, +        readIfNeeded(ctx);, +        firedChannelRead = false;, +        ctx.fireChannelReadComplete();, +    }, +, +    private void readIfNeeded(ChannelHandlerContext ctx) {, +                    if (handshakeStatus == HandshakeStatus.NEED_UNWRAP) {, +                        // The underlying engine is starving so we need to feed it with more data., +                        // See https://github.com/netty/netty/pull/5039, +                        readIfNeeded(ctx);, +                    }, +, +++ b/handler/src/main/java/io/netty/handler/ssl/SslHandler.java, +        boolean needUnwrap = false;, +                            finishWrap(ctx, out, promise, inUnwrap, false);, +                            needUnwrap = true;, +            finishWrap(ctx, out, promise, inUnwrap, needUnwrap);, +    private void finishWrap(ChannelHandlerContext ctx, ByteBuf out, ChannelPromise promise, boolean inUnwrap,, +            boolean needUnwrap) {, +, +        if (needUnwrap) {, +            // The underlying engine is starving so we need to feed it with more data., +            // See https://github.com/netty/netty/pull/5039, +            readIfNeeded(ctx);, +        }, +        readIfNeeded(ctx);, +        firedChannelRead = false;, +        ctx.fireChannelReadComplete();, +    }, +, +    private void readIfNeeded(ChannelHandlerContext ctx) {, +                    if (handshakeStatus == HandshakeStatus.NEED_UNWRAP) {, +                        // The underlying engine is starving so we need to feed it with more data., +                        // See https://github.com/netty/netty/pull/5039, +                        readIfNeeded(ctx);, +                    }, +, +++ b/handler/src/test/java/io/netty/handler/ssl/SslHandlerTest.java, +import io.netty.channel.ChannelHandler;, +import io.netty.channel.ChannelHandlerContext;, +import io.netty.channel.ChannelInboundHandlerAdapter;, +import io.netty.channel.ChannelOutboundHandlerAdapter;, +, +    private static final class TlsReadTest extends ChannelOutboundHandlerAdapter {, +        private volatile boolean readIssued;, +, +        @Override, +        public void read(ChannelHandlerContext ctx) throws Exception {, +            readIssued = true;, +            super.read(ctx);, +        }, +, +        public void test(final boolean dropChannelActive) throws Exception {, +          SSLEngine engine = SSLContext.getDefault().createSSLEngine();, +          engine.setUseClientMode(true);, +, +          EmbeddedChannel ch = new EmbeddedChannel(, +              this,, +              new SslHandler(engine),, +              new ChannelInboundHandlerAdapter() {, +                @Override, +                public void channelActive(ChannelHandlerContext ctx) throws Exception {, +                  if (!dropChannelActive) {, +                    ctx.fireChannelActive();, +                  }, +                }, +              }, +          );, +          ch.config().setAutoRead(false);, +          assertFalse(ch.config().isAutoRead());, +, +          assertTrue(ch.writeOutbound(Unpooled.EMPTY_BUFFER));, +          assertTrue(readIssued);, +          assertTrue(ch.finishAndReleaseAll());, +       }, +    }, +, +    @Test, +    public void testIssueReadAfterActiveWriteFlush() throws Exception {, +        // the handshake is initiated by channelActive, +        new TlsReadTest().test(false);, +    }, +, +    @Test, +    public void testIssueReadAfterWriteFlushActive() throws Exception {, +        // the handshake is initiated by flush, +        new TlsReadTest().test(true);]