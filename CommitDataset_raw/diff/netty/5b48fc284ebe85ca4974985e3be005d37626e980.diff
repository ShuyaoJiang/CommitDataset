[+++ b/testsuite/src/main/java/io/netty/testsuite/transport/socket/SocketAutoReadTest.java, +import io.netty.buffer.ByteBuf;, +import io.netty.buffer.ByteBufAllocator;, +import io.netty.channel.ChannelConfig;, +import io.netty.channel.ChannelInitializer;, +import io.netty.channel.ChannelOption;, +import io.netty.channel.RecvByteBufAllocator;, +import java.util.concurrent.atomic.AtomicInteger;, +import static org.junit.Assert.assertEquals;, +import static org.junit.Assert.assertFalse;, +import static org.junit.Assert.assertTrue;, +import static org.junit.Assert.fail;, +    @Test, +    public void testAutoReadOffDuringReadOnlyReadsOneTime() throws Throwable {, +    public void testAutoReadOffDuringReadOnlyReadsOneTime(ServerBootstrap sb, Bootstrap cb) throws Throwable {, +        testAutoReadOffDuringReadOnlyReadsOneTime(true, sb, cb);, +        testAutoReadOffDuringReadOnlyReadsOneTime(false, sb, cb);, +    }, +, +    private void testAutoReadOffDuringReadOnlyReadsOneTime(boolean readOutsideEventLoopThread,, +                                                           ServerBootstrap sb, Bootstrap cb) throws Throwable {, +        Channel serverChannel = null;, +        Channel clientChannel = null;, +        try {, +            AutoReadInitializer serverInitializer = new AutoReadInitializer(!readOutsideEventLoopThread);, +            AutoReadInitializer clientInitializer = new AutoReadInitializer(!readOutsideEventLoopThread);, +            sb.option(ChannelOption.SO_BACKLOG, 1024), +                    .option(ChannelOption.AUTO_READ, true), +                    .childOption(ChannelOption.AUTO_READ, true), +                    // We want to ensure that we attempt multiple individual read operations per read loop so we can, +                    // test the auto read feature being turned off when data is first read., +                    .childOption(ChannelOption.RCVBUF_ALLOCATOR, new TestRecvByteBufAllocator()), +                    .childHandler(serverInitializer);, +, +            serverChannel = sb.bind().syncUninterruptibly().channel();, +, +            cb.remoteAddress(serverChannel.localAddress()), +                    .option(ChannelOption.AUTO_READ, true), +                    // We want to ensure that we attempt multiple individual read operations per read loop so we can, +                    // test the auto read feature being turned off when data is first read., +                    .option(ChannelOption.RCVBUF_ALLOCATOR, new TestRecvByteBufAllocator()), +                    .handler(clientInitializer);, +, +            clientChannel = cb.connect().syncUninterruptibly().channel();, +, +            // 3 bytes means 3 independent reads for TestRecvByteBufAllocator, +            clientChannel.writeAndFlush(Unpooled.wrappedBuffer(new byte[3]));, +            serverInitializer.autoReadHandler.assertSingleRead();, +, +            // 3 bytes means 3 independent reads for TestRecvByteBufAllocator, +            serverInitializer.channel.writeAndFlush(Unpooled.wrappedBuffer(new byte[3]));, +            clientInitializer.autoReadHandler.assertSingleRead();, +, +            if (readOutsideEventLoopThread) {, +                serverInitializer.channel.read();, +            }, +            serverInitializer.autoReadHandler.assertSingleReadSecondTry();, +, +            if (readOutsideEventLoopThread) {, +                clientChannel.read();, +            }, +            clientInitializer.autoReadHandler.assertSingleReadSecondTry();, +        } finally {, +            if (clientChannel != null) {, +                clientChannel.close().sync();, +            }, +            if (serverChannel != null) {, +                serverChannel.close().sync();, +            }, +        }, +    }, +, +    private static class AutoReadInitializer extends ChannelInitializer<Channel> {, +        final AutoReadHandler autoReadHandler;, +        volatile Channel channel;, +, +        AutoReadInitializer(boolean readInEventLoop) {, +            autoReadHandler = new AutoReadHandler(readInEventLoop);, +        }, +, +        protected void initChannel(Channel ch) throws Exception {, +            channel = ch;, +            ch.pipeline().addLast(autoReadHandler);, +    private static final class AutoReadHandler extends ChannelInboundHandlerAdapter {, +        private final AtomicInteger count = new AtomicInteger();, +        private final CountDownLatch latch2;, +        private final boolean callRead;, +        AutoReadHandler(boolean callRead) {, +            this.callRead = callRead;, +            latch2 = new CountDownLatch(callRead ? 3 : 2);, +            if (count.incrementAndGet() == 1) {, +                ctx.channel().config().setAutoRead(false);, +            }, +            if (callRead) {, +                // Test calling read in the EventLoop thread to ensure a read is eventually done., +                ctx.read();, +            }, +        }, +, +        @Override]