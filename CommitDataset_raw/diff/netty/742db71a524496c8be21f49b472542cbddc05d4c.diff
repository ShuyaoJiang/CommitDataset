[+++ b/common/src/main/java/io/netty/util/internal/TypeParameterMatcher.java, +    private static final Object TEST_OBJECT = new Object();, +                    matcher.match(TEST_OBJECT);, +                } catch (IllegalAccessError e) {, +                    // Happens if messageType is not public., +                    matcher = null;, +                    matcher = null;, +                }, +            }, +, +            if (matcher == null) {, +, +++ b/common/src/main/java/io/netty/util/internal/TypeParameterMatcher.java, +    private static final Object TEST_OBJECT = new Object();, +                    matcher.match(TEST_OBJECT);, +                } catch (IllegalAccessError e) {, +                    // Happens if messageType is not public., +                    matcher = null;, +                    matcher = null;, +                }, +            }, +, +            if (matcher == null) {, +, +++ b/common/src/test/java/io/netty/util/internal/TypeParameterMatcherTest.java, +    public void testConcreteClass() throws Exception {, +        TypeParameterMatcher m = TypeParameterMatcher.find(new TypeQ(), TypeX.class, "A");, +    @Test(expected = IllegalStateException.class), +    public void testUnsolvedParameter() throws Exception {, +        TypeParameterMatcher.find(new TypeQ(), TypeX.class, "B");, +    }, +, +    @Test, +    public void testAnonymousClass() throws Exception {, +        TypeParameterMatcher m = TypeParameterMatcher.find(new TypeQ<BBB>() { }, TypeX.class, "B");, +    }, +    @Test, +    public void testAbstractClass() throws Exception {, +        TypeParameterMatcher m = TypeParameterMatcher.find(new TypeQ(), TypeX.class, "C");, +    public static abstract class TypeZ<G extends AA, H extends BB> extends TypeY<CC, G, H> { }, +, +    @Test, +    public void testInaccessibleClass() throws Exception {, +        TypeParameterMatcher m = TypeParameterMatcher.find(new U<T>() { }, U.class, "E");, +        assertFalse(m.match(new Object()));, +        assertTrue(m.match(new T()));, +    }, +, +    @SuppressWarnings("ClassMayBeInterface"), +    private static class T { }, +    private static class U<E> { E a; }]