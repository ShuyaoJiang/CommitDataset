[+++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, +            return Unpooled.EMPTY_BUFFER;, +        return Unpooled.decodeString(nioBuffer, charset);, +        return Unpooled.indexOf(this, fromIndex, toIndex, value);, +        return Unpooled.indexOf(this, fromIndex, toIndex, indexFinder);, +        return Unpooled.hashCode(this);, +        return Unpooled.equals(this, (ByteBuf) o);, +        return Unpooled.compare(this, that);, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, +            return Unpooled.EMPTY_BUFFER;, +        return Unpooled.decodeString(nioBuffer, charset);, +        return Unpooled.indexOf(this, fromIndex, toIndex, value);, +        return Unpooled.indexOf(this, fromIndex, toIndex, indexFinder);, +        return Unpooled.hashCode(this);, +        return Unpooled.equals(this, (ByteBuf) o);, +        return Unpooled.compare(this, that);, +++ b/buffer/src/main/java/io/netty/buffer/BigEndianHeapByteBuf.java, + * A big-endian Java heap buffer.  It is recommended to use {@link Unpooled#buffer(int)}, + * and {@link Unpooled#wrappedBuffer(byte[])} instead of calling the, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, +            return Unpooled.EMPTY_BUFFER;, +        return Unpooled.decodeString(nioBuffer, charset);, +        return Unpooled.indexOf(this, fromIndex, toIndex, value);, +        return Unpooled.indexOf(this, fromIndex, toIndex, indexFinder);, +        return Unpooled.hashCode(this);, +        return Unpooled.equals(this, (ByteBuf) o);, +        return Unpooled.compare(this, that);, +++ b/buffer/src/main/java/io/netty/buffer/BigEndianHeapByteBuf.java, + * A big-endian Java heap buffer.  It is recommended to use {@link Unpooled#buffer(int)}, + * and {@link Unpooled#wrappedBuffer(byte[])} instead of calling the, +++ b/buffer/src/main/java/io/netty/buffer/ByteBuf.java, + * {@link Unpooled} rather than calling an individual implementation's, +     * {@link ByteBuf} buf = {@link Unpooled}.buffer(8);, +     * {@link ByteBuf} buf = {@link Unpooled}.wrappedBuffer(new byte[8]);, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, +            return Unpooled.EMPTY_BUFFER;, +        return Unpooled.decodeString(nioBuffer, charset);, +        return Unpooled.indexOf(this, fromIndex, toIndex, value);, +        return Unpooled.indexOf(this, fromIndex, toIndex, indexFinder);, +        return Unpooled.hashCode(this);, +        return Unpooled.equals(this, (ByteBuf) o);, +        return Unpooled.compare(this, that);, +++ b/buffer/src/main/java/io/netty/buffer/BigEndianHeapByteBuf.java, + * A big-endian Java heap buffer.  It is recommended to use {@link Unpooled#buffer(int)}, + * and {@link Unpooled#wrappedBuffer(byte[])} instead of calling the, +++ b/buffer/src/main/java/io/netty/buffer/ByteBuf.java, + * {@link Unpooled} rather than calling an individual implementation's, +     * {@link ByteBuf} buf = {@link Unpooled}.buffer(8);, +     * {@link ByteBuf} buf = {@link Unpooled}.wrappedBuffer(new byte[8]);, +++ /dev/null, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, +            return Unpooled.EMPTY_BUFFER;, +        return Unpooled.decodeString(nioBuffer, charset);, +        return Unpooled.indexOf(this, fromIndex, toIndex, value);, +        return Unpooled.indexOf(this, fromIndex, toIndex, indexFinder);, +        return Unpooled.hashCode(this);, +        return Unpooled.equals(this, (ByteBuf) o);, +        return Unpooled.compare(this, that);, +++ b/buffer/src/main/java/io/netty/buffer/BigEndianHeapByteBuf.java, + * A big-endian Java heap buffer.  It is recommended to use {@link Unpooled#buffer(int)}, + * and {@link Unpooled#wrappedBuffer(byte[])} instead of calling the, +++ b/buffer/src/main/java/io/netty/buffer/ByteBuf.java, + * {@link Unpooled} rather than calling an individual implementation's, +     * {@link ByteBuf} buf = {@link Unpooled}.buffer(8);, +     * {@link ByteBuf} buf = {@link Unpooled}.wrappedBuffer(new byte[8]);, +++ /dev/null, +++ b/buffer/src/main/java/io/netty/buffer/CompositeByteBuf.java, + * is recommended to use {@link Unpooled#wrappedBuffer(ByteBuf...)}, +                return Unpooled.EMPTY_BUFFER;, +            return Unpooled.EMPTY_BUFFER;, +            return Unpooled.EMPTY_BUFFER;, +        final ByteBuf padding = Unpooled.buffer(order(), localReaderIndex);, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, +            return Unpooled.EMPTY_BUFFER;, +        return Unpooled.decodeString(nioBuffer, charset);, +        return Unpooled.indexOf(this, fromIndex, toIndex, value);, +        return Unpooled.indexOf(this, fromIndex, toIndex, indexFinder);, +        return Unpooled.hashCode(this);, +        return Unpooled.equals(this, (ByteBuf) o);, +        return Unpooled.compare(this, that);, +++ b/buffer/src/main/java/io/netty/buffer/BigEndianHeapByteBuf.java, + * A big-endian Java heap buffer.  It is recommended to use {@link Unpooled#buffer(int)}, + * and {@link Unpooled#wrappedBuffer(byte[])} instead of calling the, +++ b/buffer/src/main/java/io/netty/buffer/ByteBuf.java, + * {@link Unpooled} rather than calling an individual implementation's, +     * {@link ByteBuf} buf = {@link Unpooled}.buffer(8);, +     * {@link ByteBuf} buf = {@link Unpooled}.wrappedBuffer(new byte[8]);, +++ /dev/null, +++ b/buffer/src/main/java/io/netty/buffer/CompositeByteBuf.java, + * is recommended to use {@link Unpooled#wrappedBuffer(ByteBuf...)}, +                return Unpooled.EMPTY_BUFFER;, +            return Unpooled.EMPTY_BUFFER;, +            return Unpooled.EMPTY_BUFFER;, +        final ByteBuf padding = Unpooled.buffer(order(), localReaderIndex);, +++ b/buffer/src/main/java/io/netty/buffer/DirectByteBufFactory.java, +            return Unpooled.EMPTY_BUFFER;, +            return Unpooled.directBuffer(order, capacity);, +            return Unpooled.EMPTY_BUFFER;, +            return Unpooled.wrappedBuffer(nioBuffer);, +                preallocatedBEBuf = Unpooled.directBuffer(ByteOrder.BIG_ENDIAN, preallocatedBufCapacity);]