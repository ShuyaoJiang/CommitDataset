[+++ b/transport/src/main/java/io/netty/channel/pool/FixedChannelPool.java, +        this(bootstrap, handler, healthCheck, action, acquireTimeoutMillis, maxConnections, maxPendingAcquires, true);, +    }, +, +    /**, +     * Creates a new instance., +     *, +     * @param bootstrap             the {@link Bootstrap} that is used for connections, +     * @param handler               the {@link ChannelPoolHandler} that will be notified for the different pool actions, +     * @param healthCheck           the {@link ChannelHealthChecker} that will be used to check if a {@link Channel} is, +     *                              still healty when obtain from the {@link ChannelPool}, +     * @param action                the {@link AcquireTimeoutAction} to use or {@code null} if non should be used., +     *                              In this case {@param acquireTimeoutMillis} must be {@code -1}., +     * @param acquireTimeoutMillis  the time (in milliseconds) after which an pending acquire must complete or, +     *                              the {@link AcquireTimeoutAction} takes place., +     * @param maxConnections        the numnber of maximal active connections, once this is reached new tries to, +     *                              acquire a {@link Channel} will be delayed until a connection is returned to the, +     *                              pool again., +     * @param maxPendingAcquires    the maximum number of pending acquires. Once this is exceed acquire tries will, +     *                              be failed., +     * @param releaseHealthCheck    will check channel health before offering back if this parameter set to, +     *                              {@code true}., +     */, +    public FixedChannelPool(Bootstrap bootstrap,, +                            ChannelPoolHandler handler,, +                            ChannelHealthChecker healthCheck, AcquireTimeoutAction action,, +                            final long acquireTimeoutMillis,, +                            int maxConnections, int maxPendingAcquires, final boolean releaseHealthCheck) {, +        super(bootstrap, handler, healthCheck, releaseHealthCheck);, +++ b/transport/src/main/java/io/netty/channel/pool/FixedChannelPool.java, +        this(bootstrap, handler, healthCheck, action, acquireTimeoutMillis, maxConnections, maxPendingAcquires, true);, +    }, +, +    /**, +     * Creates a new instance., +     *, +     * @param bootstrap             the {@link Bootstrap} that is used for connections, +     * @param handler               the {@link ChannelPoolHandler} that will be notified for the different pool actions, +     * @param healthCheck           the {@link ChannelHealthChecker} that will be used to check if a {@link Channel} is, +     *                              still healty when obtain from the {@link ChannelPool}, +     * @param action                the {@link AcquireTimeoutAction} to use or {@code null} if non should be used., +     *                              In this case {@param acquireTimeoutMillis} must be {@code -1}., +     * @param acquireTimeoutMillis  the time (in milliseconds) after which an pending acquire must complete or, +     *                              the {@link AcquireTimeoutAction} takes place., +     * @param maxConnections        the numnber of maximal active connections, once this is reached new tries to, +     *                              acquire a {@link Channel} will be delayed until a connection is returned to the, +     *                              pool again., +     * @param maxPendingAcquires    the maximum number of pending acquires. Once this is exceed acquire tries will, +     *                              be failed., +     * @param releaseHealthCheck    will check channel health before offering back if this parameter set to, +     *                              {@code true}., +     */, +    public FixedChannelPool(Bootstrap bootstrap,, +                            ChannelPoolHandler handler,, +                            ChannelHealthChecker healthCheck, AcquireTimeoutAction action,, +                            final long acquireTimeoutMillis,, +                            int maxConnections, int maxPendingAcquires, final boolean releaseHealthCheck) {, +        super(bootstrap, handler, healthCheck, releaseHealthCheck);, +++ b/transport/src/main/java/io/netty/channel/pool/SimpleChannelPool.java, +    private static final IllegalStateException UNHEALTHY_NON_OFFERED_TO_POOL =, +            new IllegalStateException("Channel is unhealthy not offering it back to pool");, +        UNHEALTHY_NON_OFFERED_TO_POOL.setStackTrace(EmptyArrays.EMPTY_STACK_TRACE);, +    private final boolean releaseHealthCheck;, +     *                          still healthy when obtain from the {@link ChannelPool}, +        this(bootstrap, handler, healthCheck, true);, +    }, +, +    /**, +     * Creates a new instance., +     *, +     * @param bootstrap          the {@link Bootstrap} that is used for connections, +     * @param handler            the {@link ChannelPoolHandler} that will be notified for the different pool actions, +     * @param healthCheck        the {@link ChannelHealthChecker} that will be used to check if a {@link Channel} is, +     *                           still healthy when obtain from the {@link ChannelPool}, +     * @param releaseHealthCheck will offercheck channel health before offering back if this parameter set to, +     *                           {@code true}., +     */, +    public SimpleChannelPool(Bootstrap bootstrap, final ChannelPoolHandler handler, ChannelHealthChecker healthCheck,, +                             boolean releaseHealthCheck) {, +        this.releaseHealthCheck = releaseHealthCheck;, +     * Bootstrap a new {@link Channel}. The default implementation uses {@link Bootstrap#connect()}, sub-classes may, +     * override this., +     * <p>, +                if (releaseHealthCheck) {, +                    doHealthCheckOnRelease(channel, promise);, +                } else {, +                    releaseAndOffer(channel, promise);, +                }, +            } catch (Throwable cause) {, +                closeAndFail(channel, cause, promise);, +            }, +        }, +    }, +, +    private void doHealthCheckOnRelease(final Channel channel, final Promise<Void> promise) throws Exception {, +        final Future<Boolean> f = healthCheck.isHealthy(channel);, +        if (f.isDone()) {, +            releaseAndOfferIfHealthy(channel, promise, f);, +        } else {, +            f.addListener(new FutureListener<Boolean>() {]