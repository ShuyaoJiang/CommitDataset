[+++ b/common/src/main/java/io/netty/util/internal/MpscLinkedQueue.java, +import static java.util.concurrent.atomic.AtomicReferenceFieldUpdater.newUpdater;, +, +import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;, +, +abstract class MpscLinkedQueuePad0<E> {, +    long p00, p01, p02, p03, p04, p05, p06, p07;, +    long p30, p31, p32, p33, p34, p35, p36, p37;, +}, +, +abstract class MpscLinkedQueueHeadRef<E> extends MpscLinkedQueuePad0<E> {, +    @SuppressWarnings("rawtypes"), +    private static final AtomicReferenceFieldUpdater<MpscLinkedQueueHeadRef, MpscLinkedQueueNode> UPDATER =, +        newUpdater(MpscLinkedQueueHeadRef.class, MpscLinkedQueueNode.class, "headRef");, +    private volatile MpscLinkedQueueNode<E> headRef;, +, +    protected final MpscLinkedQueueNode<E> headRef() {, +        return headRef;, +    }, +    protected final void headRef(MpscLinkedQueueNode<E> val) {, +        headRef = val;, +    }, +    protected final void lazySetHeadRef(MpscLinkedQueueNode<E> newVal) {, +        UPDATER.lazySet(this, newVal);, +    }, +}, +, +abstract class MpscLinkedQueuePad1<E> extends MpscLinkedQueueHeadRef<E> {, +    long p00, p01, p02, p03, p04, p05, p06, p07;, +    long p30, p31, p32, p33, p34, p35, p36, p37;, +}, +, +abstract class MpscLinkedQueueTailRef<E> extends MpscLinkedQueuePad1<E> {, +    @SuppressWarnings("rawtypes"), +    private static final AtomicReferenceFieldUpdater<MpscLinkedQueueTailRef, MpscLinkedQueueNode> UPDATER =, +        newUpdater(MpscLinkedQueueTailRef.class, MpscLinkedQueueNode.class, "tailRef");, +    private volatile MpscLinkedQueueNode<E> tailRef;, +    protected final MpscLinkedQueueNode<E> tailRef() {, +        return tailRef;, +    }, +    protected final void tailRef(MpscLinkedQueueNode<E> val) {, +        tailRef = val;, +    }, +    @SuppressWarnings("unchecked"), +    protected final MpscLinkedQueueNode<E> getAndSetTailRef(MpscLinkedQueueNode<E> newVal) {, +        return (MpscLinkedQueueNode<E>) UPDATER.getAndSet(this, newVal);, +    }, +}, + * data structure modified to avoid false sharing between head and tail Ref as per implementation of MpscLinkedQueue, + * on <a href="https://github.com/JCTools/JCTools">JCTools project</a>., +public final class MpscLinkedQueue<E> extends MpscLinkedQueueTailRef<E> implements Queue<E> {, +        headRef(tombstone);, +        tailRef(tombstone);, +            final MpscLinkedQueueNode<E> head = headRef();, +            if (head == tailRef()) {, +        MpscLinkedQueueNode<E> oldTail = getAndSetTailRef(newTail);, +        MpscLinkedQueueNode<E> oldHead = headRef();, +        // See: http://psy-lob-saw.blogspot.com/2012/12/atomiclazyset-is-performance-win-for.html, +        lazySetHeadRef(next);, +        headRef(tombstone);, +        tailRef(tombstone);]