[+++ b/handler/src/main/java/io/netty/handler/ssl/SslHandler.java, +import java.util.ArrayList;, +import java.util.concurrent.CountDownLatch;, +        this(engine, false);, +    @SuppressWarnings("deprecation"), +     * @deprecated Use {@link #SslHandler(SSLEngine)} instead., +    @Deprecated, +     * @deprecated Use {@link #SslHandler(SSLEngine, boolean)} instead., +    @Deprecated, +    /**, +     * Fetches all delegated tasks from the {@link SSLEngine} and runs them via the {@link #delegatedTaskExecutor}., +     * If the {@link #delegatedTaskExecutor} is {@link ImmediateExecutor}, just call {@link Runnable#run()} directly, +     * instead of using {@link Executor#execute(Runnable)}.  Otherwise, run the tasks via, +     * the {@link #delegatedTaskExecutor} and wait until the tasks are finished., +     */, +        if (delegatedTaskExecutor == ImmediateExecutor.INSTANCE) {, +                task.run();, +            }, +        } else {, +            final List<Runnable> tasks = new ArrayList<Runnable>(2);, +            for (;;) {, +                final Runnable task = engine.getDelegatedTask();, +                if (task == null) {, +                    break;, +                }, +, +                tasks.add(task);, +            }, +, +            if (tasks.isEmpty()) {, +                return;, +            }, +, +            final CountDownLatch latch = new CountDownLatch(1);, +            delegatedTaskExecutor.execute(new Runnable() {, +                @Override, +                public void run() {, +                    try {, +                        for (Runnable task: tasks) {, +                            task.run();, +                        }, +                    } catch (Exception e) {, +                        ctx.fireExceptionCaught(e);, +                    } finally {, +                        latch.countDown();, +                    }, +                }, +            });, +, +            boolean interrupted = false;, +            while (latch.getCount() != 0) {, +                try {, +                    latch.await();, +                } catch (InterruptedException e) {, +                    // Interrupt later., +                    interrupted = true;, +                }, +            }, +, +            if (interrupted) {, +                Thread.currentThread().interrupt();, +            }, +++ b/handler/src/main/java/io/netty/handler/ssl/SslHandler.java, +import java.util.ArrayList;, +import java.util.concurrent.CountDownLatch;, +        this(engine, false);, +    @SuppressWarnings("deprecation"), +     * @deprecated Use {@link #SslHandler(SSLEngine)} instead., +    @Deprecated, +     * @deprecated Use {@link #SslHandler(SSLEngine, boolean)} instead., +    @Deprecated, +    /**, +     * Fetches all delegated tasks from the {@link SSLEngine} and runs them via the {@link #delegatedTaskExecutor}., +     * If the {@link #delegatedTaskExecutor} is {@link ImmediateExecutor}, just call {@link Runnable#run()} directly, +     * instead of using {@link Executor#execute(Runnable)}.  Otherwise, run the tasks via, +     * the {@link #delegatedTaskExecutor} and wait until the tasks are finished., +     */, +        if (delegatedTaskExecutor == ImmediateExecutor.INSTANCE) {, +                task.run();, +            }, +        } else {, +            final List<Runnable> tasks = new ArrayList<Runnable>(2);, +            for (;;) {, +                final Runnable task = engine.getDelegatedTask();, +                if (task == null) {, +                    break;, +                }, +, +                tasks.add(task);, +            }, +, +            if (tasks.isEmpty()) {, +                return;, +            }, +, +            final CountDownLatch latch = new CountDownLatch(1);, +            delegatedTaskExecutor.execute(new Runnable() {, +                @Override, +                public void run() {, +                    try {]