[+++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/AbstractEpollChannel.java, +            maybeMoreDataToRead = allocHandle.maybeMoreDataToRead();, +, +            if (allocHandle.isReceivedRdHup() || (readPending && maybeMoreDataToRead)) {, +            } else if (!readPending && !config.isAutoRead()) {, +                // Check if there is a readPending which was not processed yet., +                // This could be for two reasons:, +                // * The user called Channel.read() or ChannelHandlerContext.read() in channelRead(...) method, +                // * The user called Channel.read() or ChannelHandlerContext.read() in channelReadComplete(...) method, +                //, +                // See https://github.com/netty/netty/issues/2254, +                clearEpollIn();, +++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/AbstractEpollChannel.java, +            maybeMoreDataToRead = allocHandle.maybeMoreDataToRead();, +, +            if (allocHandle.isReceivedRdHup() || (readPending && maybeMoreDataToRead)) {, +            } else if (!readPending && !config.isAutoRead()) {, +                // Check if there is a readPending which was not processed yet., +                // This could be for two reasons:, +                // * The user called Channel.read() or ChannelHandlerContext.read() in channelRead(...) method, +                // * The user called Channel.read() or ChannelHandlerContext.read() in channelReadComplete(...) method, +                //, +                // See https://github.com/netty/netty/issues/2254, +                clearEpollIn();, +++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollRecvByteAllocatorHandle.java, +         *, +         * It is assumed RDHUP is handled externally by checking {@link #isReceivedRdHup()}., +               (!isEdgeTriggered && lastBytesRead() == attemptedBytesRead());, +++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/AbstractEpollChannel.java, +            maybeMoreDataToRead = allocHandle.maybeMoreDataToRead();, +, +            if (allocHandle.isReceivedRdHup() || (readPending && maybeMoreDataToRead)) {, +            } else if (!readPending && !config.isAutoRead()) {, +                // Check if there is a readPending which was not processed yet., +                // This could be for two reasons:, +                // * The user called Channel.read() or ChannelHandlerContext.read() in channelRead(...) method, +                // * The user called Channel.read() or ChannelHandlerContext.read() in channelReadComplete(...) method, +                //, +                // See https://github.com/netty/netty/issues/2254, +                clearEpollIn();, +++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollRecvByteAllocatorHandle.java, +         *, +         * It is assumed RDHUP is handled externally by checking {@link #isReceivedRdHup()}., +               (!isEdgeTriggered && lastBytesRead() == attemptedBytesRead());, +++ b/transport-native-kqueue/src/main/java/io/netty/channel/kqueue/AbstractKQueueChannel.java, +, +            if (allocHandle.isReadEOF() || (readPending && maybeMoreDataToRead)) {, +            } else if (!readPending && !config.isAutoRead()) {, +                // Check if there is a readPending which was not processed yet., +                // This could be for two reasons:, +                // * The user called Channel.read() or ChannelHandlerContext.read() in channelRead(...) method, +                // * The user called Channel.read() or ChannelHandlerContext.read() in channelReadComplete(...) method, +                //, +                // See https://github.com/netty/netty/issues/2254, +                clearReadFilter0();, +++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/AbstractEpollChannel.java, +            maybeMoreDataToRead = allocHandle.maybeMoreDataToRead();, +, +            if (allocHandle.isReceivedRdHup() || (readPending && maybeMoreDataToRead)) {, +            } else if (!readPending && !config.isAutoRead()) {, +                // Check if there is a readPending which was not processed yet., +                // This could be for two reasons:, +                // * The user called Channel.read() or ChannelHandlerContext.read() in channelRead(...) method, +                // * The user called Channel.read() or ChannelHandlerContext.read() in channelReadComplete(...) method, +                //, +                // See https://github.com/netty/netty/issues/2254, +                clearEpollIn();, +++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollRecvByteAllocatorHandle.java, +         *, +         * It is assumed RDHUP is handled externally by checking {@link #isReceivedRdHup()}., +               (!isEdgeTriggered && lastBytesRead() == attemptedBytesRead());, +++ b/transport-native-kqueue/src/main/java/io/netty/channel/kqueue/AbstractKQueueChannel.java, +, +            if (allocHandle.isReadEOF() || (readPending && maybeMoreDataToRead)) {, +            } else if (!readPending && !config.isAutoRead()) {, +                // Check if there is a readPending which was not processed yet., +                // This could be for two reasons:, +                // * The user called Channel.read() or ChannelHandlerContext.read() in channelRead(...) method, +                // * The user called Channel.read() or ChannelHandlerContext.read() in channelReadComplete(...) method, +                //, +                // See https://github.com/netty/netty/issues/2254, +                clearReadFilter0();, +++ b/transport-native-kqueue/src/main/java/io/netty/channel/kqueue/KQueueRecvByteAllocatorHandle.java, +    boolean isReadEOF() {, +        return readEOF;, +    }, +, +         * It is assumed EOF is handled externally by checking {@link #isReadEOF()}., +        return numberBytesPending != 0;, +++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/AbstractEpollChannel.java, +            maybeMoreDataToRead = allocHandle.maybeMoreDataToRead();, +, +            if (allocHandle.isReceivedRdHup() || (readPending && maybeMoreDataToRead)) {, +            } else if (!readPending && !config.isAutoRead()) {, +                // Check if there is a readPending which was not processed yet., +                // This could be for two reasons:, +                // * The user called Channel.read() or ChannelHandlerContext.read() in channelRead(...) method, +                // * The user called Channel.read() or ChannelHandlerContext.read() in channelReadComplete(...) method, +                //, +                // See https://github.com/netty/netty/issues/2254]