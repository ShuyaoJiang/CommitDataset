[+++ b/src/docbook/en-US/module/architecture.xml, +      to represent a sequence of bytes. This approach has significant advantages, +      &ChannelBuffer; has been designed from the ground up to address the problems, +            You can define your own buffer type if necessary., +            Transparent zero copy is achieved by a built-in composite buffer type., +      Traditional I/O APIs in Java provide different types and methods for, +      another tedious and difficult.  The lack of portability between, +      transports becomes a problem when you need to support additional, +      transports, as this often entails rewriting the network layer of the, +      application.  Logically, many protocols can run on more than one, +      transport such as TCP/IP, UDP/IP, SCTP, and serial port communication., +      To make matters worse, Java's New I/O (NIO) API introduced, +      incompatibilities with the old blocking I/O (OIO) API and will continue, +      to do so in the next release, NIO.2 (AIO).  Because all these APIs are, +      different from each other in design and performance characteristics, you, +      are often forced to determine which API your application will depend on, +      before you even begin the implementation phase., +      to be in trouble when your business grows exponentially and your server, +      needs to serve tens of thousands of clients simultaneously.  You could, +      start with NIO, but doing so may hinder rapid development by greatly, +      increasing development time due to the complexity of the NIO Selector, +      API., +      Netty has a universal asynchronous I/O interface called a &Channel;, which, +      abstracts away all operations required for point-to-point communication., +      Switching from one transport to another usually takes just a couple, +      Also, you are even able to take advantage of new transports which aren't, +      yet written (such as serial port communication transport), again, +      write your own transport by extending the core API., +      A well-defined and extensible event model is a must for an event-driven, +      application.  Netty has a well-defined event model focused on I/O.  It, +      also allows you to implement your own event type without breaking the, +      existing code because each event type is distinguished from another by, +      a strict type hierarchy.  This is another differentiator against other, +      frameworks.  Many NIO frameworks have no or a very limited notion of an, +      event model. If they offer extension at all, they often break the, +      existing code when you try to add custom event types, +      you can define what to do when data is read from a socket:, +      You can also define what to do when a handler receives a write request:, +      For more information on the event model, please refer to the, +      of advanced features to accelerate the page of development even more., +        idea to separate a protocol codec from business logic. However, there, +        multi-layered (i.e. built on top of other lower level protocols). Some, +        that generates maintainable user codecs., +        Netty provides a number of basic and advanced codecs to address most, +        issues you will encounter when you write a protocol codec regardless, +        if it is simple or not, binary or text - simply whatever., +        as SSL itself.  You have to manage all possible states such as cipher, +        suite and encryption key negotiation (or re-negotiation), certificate, +        exchange, and validation.  Moreover, <classname>SSLEngine</classname> is, +        not even completely thread-safe, as one would expect., +        the &SslHandler; and insert it into your &ChannelPipeline;.  It also, +        allows you to implement advanced features like, +        It gives you complete control over how HTTP messages are exchanged at a, +        low level.  Because it is basically the combination of an HTTP codec and, +        HTTP message classes, there is no restriction such as an enforced thread, +        exactly the way you want.  You have full control over everything that's, +        in the HTTP specification, including the thread model, connection life, +        cycle, and chunked encoding., +              until the whole media is streamed (e.g. 2 hours of video), +              File server that allows the uploading of large files without, +              memory pressure (e.g. uploading 1GB per request), +              Scalable mash-up client that connects to tens of thousands of 3rd, +        binary protocols that evolve over time.  With &ProtobufEncoder; and, +        &ProtobufDecoder;, you can turn the message classes generated by the, +        Google Protocol Buffers Compiler (protoc) into Netty codec.  Please take, +        a look into the, +        <ulink url="&XRef;example/localtime/package-summary.html">'LocalTime' example</ulink>, +      feature standpoint.  Netty has a simple, yet powerful architecture., +      difficult to understand the more advanced features which were covered, +      briefly in this chapter., +      You might still have unanswered questions about what the overall, +      architecture looks like exactly and how each of the features work, +      together.  If so, it is a good idea to, +      <ulink url="&Community;">talk to us</ulink> to improve this guide., +++ b/src/docbook/en-US/module/architecture.xml, +      to represent a sequence of bytes. This approach has significant advantages, +      &ChannelBuffer; has been designed from the ground up to address the problems, +            You can define your own buffer type if necessary., +            Transparent zero copy is achieved by a built-in composite buffer type., +      Traditional I/O APIs in Java provide different types and methods for, +      another tedious and difficult.  The lack of portability between, +      transports becomes a problem when you need to support additional, +      transports, as this often entails rewriting the network layer of the, +      application.  Logically, many protocols can run on more than one, +      transport such as TCP/IP, UDP/IP, SCTP, and serial port communication., +      To make matters worse, Java's New I/O (NIO) API introduced, +      incompatibilities with the old blocking I/O (OIO) API and will continue, +      to do so in the next release, NIO.2 (AIO).  Because all these APIs are, +      different from each other in design and performance characteristics, you, +      are often forced to determine which API your application will depend on, +      before you even begin the implementation phase., +      to be in trouble when your business grows exponentially and your server, +      needs to serve tens of thousands of clients simultaneously.  You could, +      start with NIO, but doing so may hinder rapid development by greatly, +      increasing development time due to the complexity of the NIO Selector, +      API., +      Netty has a universal asynchronous I/O interface called a &Channel;, which, +      abstracts away all operations required for point-to-point communication., +      Switching from one transport to another usually takes just a couple, +      Also, you are even able to take advantage of new transports which aren't]