[+++ b/handler/src/main/java/io/netty/handler/ssl/SslHandler.java, +                switch (status) {, +                case BUFFER_OVERFLOW:, +                    int readableBytes = decodeOut.readableBytes();, +                    if (readableBytes > 0) {, +                        decoded = true;, +                        ctx.fireChannelRead(decodeOut);, +                    } else {, +                        decodeOut.release();, +                    }, +                    // Allocate a new buffer which can hold all the rest data and loop again., +                    // TODO: We may want to reconsider how we calculate the length here as we may, +                    // have more then one ssl message to decode., +                    decodeOut = allocate(ctx, engine.getSession().getApplicationBufferSize() - readableBytes);, +                    continue;, +                case CLOSED:, +                    break;, +                default:, +                    break;, +        int writerIndex = out.writerIndex();, +        final SSLEngineResult result;, +                singleBuffer[0] = toByteBuffer(out, writerIndex, out.writableBytes());, +                result = opensslEngine.unwrap(in.nioBuffers(readerIndex, len), singleBuffer);, +                out.writerIndex(writerIndex + result.bytesProduced());, +            result = engine.unwrap(toByteBuffer(in, readerIndex, len),, +                                                   toByteBuffer(out, writerIndex, out.writableBytes()));, +        out.writerIndex(writerIndex + result.bytesProduced());, +, +    private static ByteBuffer toByteBuffer(ByteBuf out, int index, int len) {, +        return out.nioBufferCount() == 1 ? out.internalNioBuffer(index, len) :, +                out.nioBuffer(index, len);]