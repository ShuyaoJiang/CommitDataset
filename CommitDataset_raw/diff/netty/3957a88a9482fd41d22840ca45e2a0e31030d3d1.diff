[+++ b/transport/src/main/java/io/netty/channel/PendingWriteQueue.java, +        final PendingWrite next = write.next;, +        final long writeSize = write.size;, +, +, +        write.recycle();, +        buffer.decrementPendingOutboundBytes(writeSize);, +++ b/transport/src/main/java/io/netty/channel/PendingWriteQueue.java, +        final PendingWrite next = write.next;, +        final long writeSize = write.size;, +, +, +        write.recycle();, +        buffer.decrementPendingOutboundBytes(writeSize);, +++ b/transport/src/test/java/io/netty/channel/PendingWriteQueueTest.java, +import java.util.concurrent.atomic.AtomicReference;, +, +import static org.hamcrest.Matchers.*;, +import static org.junit.Assert.*;, +, +                assertFalse("Should not be writable anymore", ctx.channel().isWritable());, +                assertFalse("Should not be writable anymore", ctx.channel().isWritable());, +    @Test, +    public void shouldFireChannelWritabilityChangedAfterRemoval() {, +        final AtomicReference<ChannelHandlerContext> ctxRef = new AtomicReference<ChannelHandlerContext>();, +        final AtomicReference<PendingWriteQueue> queueRef = new AtomicReference<PendingWriteQueue>();, +        final ByteBuf msg = Unpooled.copiedBuffer("test", CharsetUtil.US_ASCII);, +, +        final EmbeddedChannel channel = new EmbeddedChannel(new ChannelInboundHandlerAdapter() {, +            @Override, +            public void handlerAdded(ChannelHandlerContext ctx) throws Exception {, +                ctxRef.set(ctx);, +                queueRef.set(new PendingWriteQueue(ctx));, +            }, +, +            @Override, +            public void channelWritabilityChanged(ChannelHandlerContext ctx) throws Exception {, +                final PendingWriteQueue queue = queueRef.get();, +, +                final ByteBuf msg = (ByteBuf) queue.current();, +                if (msg == null) {, +                    return;, +                }, +, +                assertThat(msg.refCnt(), is(1));, +, +                // This call will trigger another channelWritabilityChanged() event because the number of, +                // pending bytes will go below the low watermark., +                //, +                // If PendingWriteQueue.remove() did not remove the current entry before triggering, +                // channelWritabilityChanged() event, we will end up with attempting to remove the same, +                // element twice, resulting in the double release., +                queue.remove();, +, +                assertThat(msg.refCnt(), is(0));, +            }, +        });, +, +        channel.config().setWriteBufferLowWaterMark(1);, +        channel.config().setWriteBufferHighWaterMark(3);, +, +        final PendingWriteQueue queue = queueRef.get();, +, +        // Trigger channelWritabilityChanged() by adding a message that's larger than the high watermark., +        queue.add(msg, channel.newPromise());, +, +        channel.finish();, +, +        assertThat(msg.refCnt(), is(0));, +    }, +, +        assertTrue(channel.writeOutbound(buffers));, +        assertTrue(channel.finish());, +        assertNull(channel.readOutbound());, +        ByteBuf written = channel.readOutbound();, +        assertEquals(buffer, written);, +        assertTrue(queue.isEmpty());, +        assertEquals(0, queue.size());, +        assertNull(queue.current());, +        assertNull(queue.removeAndWrite());, +        assertNull(queue.removeAndWriteAll());, +            assertFalse(channel.writeOutbound(buffers));, +            fail();, +            assertTrue(e instanceof TestException);, +        assertFalse(channel.finish());, +        assertNull(channel.readOutbound());, +            assertTrue("Should be writable", ctx.channel().isWritable());, +            assertFalse(queue.isEmpty());, +            assertEquals(++expectedSize, queue.size());, +            assertNotNull(queue.current());]