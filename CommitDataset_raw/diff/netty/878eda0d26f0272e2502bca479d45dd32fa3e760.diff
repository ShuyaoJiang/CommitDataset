[+++ b/src/main/java/org/jboss/netty/channel/socket/nio/NioClientSocketPipelineSink.java, +import java.util.Queue;, +import org.jboss.netty.util.LinkedTransferQueue;, +        volatile Selector selector;, +        private boolean started;, +        private final AtomicBoolean wakenUp = new AtomicBoolean();, +        private final Object startStopLock = new Object();, +        private final Queue<Runnable> registerTaskQueue = new LinkedTransferQueue<Runnable>();, +            Runnable registerTask = new RegisterTask(this, channel);, +, +            synchronized (startStopLock) {, +                if (!started) {, +                    // Open a selector if this worker didn't start yet., +                    } catch (Throwable t) {, +                                "Failed to create a selector.", t);, +                    // Start the worker thread with the new Selector., +                    boolean success = false;, +                        success = true;, +                    } finally {, +                        if (!success) {, +                            // Release the Selector if the execution fails., +                                selector.close();, +                            } catch (Throwable t) {, +                                logger.warn("Failed to close a selector.", t);, +                            }, +                            this.selector = selector = null;, +                            // The method will return to the caller at this point., +                } else {, +                    // Use the existing selector if this worker has been started., +                    selector = this.selector;, +                }, +, +                assert selector != null && selector.isOpen();, +, +                started = true;, +                registerTaskQueue.offer(registerTask);, +            }, +, +            if (wakenUp.compareAndSet(false, true)) {, +                selector.wakeup();, +                wakenUp.set(false);, +, +, +                    processRegisterTaskQueue();, +, +                            synchronized (startStopLock) {, +                                if (registerTaskQueue.isEmpty() && selector.keys().isEmpty()) {, +                                    started = false;, +                                                "Failed to close a selector.", e);, +        private void processRegisterTaskQueue() {, +            for (;;) {, +                final Runnable task = registerTaskQueue.poll();, +                if (task == null) {, +                    break;, +                }, +, +                task.run();, +            }, +        }, +, +, +    private final class RegisterTask implements Runnable {, +        private final Boss boss;, +        private final NioSocketChannel channel;, +, +        RegisterTask(Boss boss, NioSocketChannel channel) {, +            this.boss = boss;, +            this.channel = channel;, +        }, +, +        public void run() {, +            try {, +                channel.socket.register(, +                        boss.selector, SelectionKey.OP_CONNECT, channel);, +            } catch (ClosedChannelException e) {, +                throw new ChannelException(, +                        "Failed to register a socket to the selector.", e);, +            }, +        }, +    }]