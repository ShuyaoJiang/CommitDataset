[+++ b/src/main/java/org/jboss/netty/util/internal/LinkedTransferQueue.java, + * <p>Beware that, unlike in most collections, the {@code size}, +        final boolean casNext(QNode cmp, QNode val) {, +        private synchronized final boolean alternativeCasNext(QNode cmp, QNode val) {, +, +        final void clearNext() {, +            // nextUpdater.lazySet(this, this);, +            next = this; // allows run on java5, +        }, +            h.clearNext(); // forget old next, +     *, +     * simplifies control paths both here and in xfer., +     * Returns validated tail for use in cleaning methods., +     *, +, +        if (pred == null) {, +            return;, +        }, +, +     *, +     * Creates an initially empty {@code LinkedTransferQueue}., +     * Creates a {@code LinkedTransferQueue}, +     *, +    @Override, +    public boolean add(E e) {, +        if (e == null) {, +            throw new NullPointerException();, +        }, +        xfer(e, NOWAIT, 0);, +        return true;, +    }, +, +     * Returns head after performing any outstanding helping steps., +            reclean();, +        QNode next;        // node to return next, +        QNode pnext;       // predecessor of next, +        QNode snext;       // successor of next, +        QNode curr;        // last returned node, for remove(), +        QNode pcurr;       // predecessor of curr, for remove(), +            findNext();, +        /**, +         * Ensure next points to next valid node, or null if none., +         */, +        void findNext() {, +                QNode pred = pnext;, +                QNode q = next;, +                if (pred == null || pred == q) {, +                    pred = traversalHead();, +                    q = pred.next;, +                if (q == null || !q.isData) {, +                    next = null;, +                    return;, +                Object x = q.get();, +                QNode s = q.next;, +                if (x != null && q != x && q != s) {, +                    nextItem = cast(x);, +                    snext = s;, +                    pnext = pred;, +                    next = q;, +                    return;, +                }, +                pnext = q;, +                next = s;, +            return next != null;, +            if (next == null) {, +            pcurr = pnext;, +            curr = next;, +            pnext = next;, +            next = snext;, +            E x = nextItem;, +            findNext();, +            return x;, +            QNode p = curr;, +            if (p == null) {, +                clean(pcurr, p);, +     * contains more than {@code Integer.MAX_VALUE} elements, returns, +     * {@code Integer.MAX_VALUE}., +, +    @Override, +    public boolean remove(Object o) {, +        if (o == null) {, +            return false;, +        }, +        for (;;) {, +            QNode pred = traversalHead();, +            for (;;) {, +                QNode q = pred.next;, +                if (q == null || !q.isData) {, +                    return false;, +                }, +                if (q == pred) {// restart, +                    break;, +                }, +                Object x = q.get();, +                if (x != null && x != q && o.equals(x) &&, +                        q.compareAndSet(x, q)) {, +                    clean(pred, q);, +                    return true;, +                }, +                pred = q;]