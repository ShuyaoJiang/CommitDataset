[+++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslEngine.java, +import io.netty.util.internal.PlatformDependent;, +import javax.net.ssl.SSLSessionBindingEvent;, +import javax.net.ssl.SSLSessionBindingListener;, +import java.util.HashMap;, +import java.util.Map;, +import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;, +, +        AtomicIntegerFieldUpdater<OpenSslEngine> destroyedUpdater =, +                PlatformDependent.newAtomicIntegerFieldUpdater(OpenSslEngine.class, "destroyed");, +        if (destroyedUpdater == null) {, +            destroyedUpdater = AtomicIntegerFieldUpdater.newUpdater(OpenSslEngine.class, "destroyed");, +        }, +        DESTROYED_UPDATER = destroyedUpdater;, +        AtomicReferenceFieldUpdater<OpenSslEngine, SSLSession> sessionUpdater =, +                PlatformDependent.newAtomicReferenceFieldUpdater(OpenSslEngine.class, "session");, +        if (sessionUpdater == null) {, +            sessionUpdater = AtomicReferenceFieldUpdater.newUpdater(OpenSslEngine.class, SSLSession.class, "session");, +        }, +        SESSION_UPDATER = sessionUpdater;, +    private static final AtomicIntegerFieldUpdater<OpenSslEngine> DESTROYED_UPDATER;, +    private static final AtomicReferenceFieldUpdater<OpenSslEngine, SSLSession> SESSION_UPDATER;, +, +    // We store this outside of the SslSession so we not need to create an instance during verifyCertificates(...), +, +    @SuppressWarnings("unused"), +    private volatile SSLSession session;, +        // A other methods on SSLEngine are thread-safe we also need to make this thread-safe..., +            session = new SSLSession() {, +                // SSLSession implementation seems to not need to be thread-safe so no need for volatile etc., +                private byte[] id;, +                private X509Certificate[] x509PeerCerts;, +, +                // lazy init for memory reasons, +                private Map<String, Object> values;, +                    // We need ot multiple by 1000 as openssl uses seconds and we need milli-seconds., +                    return SSL.getTime(ssl) * 1000L;, +                    // TODO: Add proper implementation, +                    return getCreationTime();, +                    // NOOP, +                public void putValue(String name, Object value) {, +                    if (name == null) {, +                        throw new NullPointerException("name");, +                    }, +                    if (value == null) {, +                        throw new NullPointerException("value");, +                    }, +                    Map<String, Object> values = this.values;, +                    if (values == null) {, +                        // Use size of 2 to keep the memory overhead small, +                        values = this.values = new HashMap<String, Object>(2);, +                    }, +                    Object old = values.put(name, value);, +                    if (value instanceof SSLSessionBindingListener) {, +                        ((SSLSessionBindingListener) value).valueBound(new SSLSessionBindingEvent(this, name));, +                    }, +                    notifyUnbound(old, name);, +                public Object getValue(String name) {, +                    if (name == null) {, +                        throw new NullPointerException("name");, +                    }, +                    if (values == null) {, +                    return values.get(name);, +                }, +                public void removeValue(String name) {, +                    if (name == null) {, +                        throw new NullPointerException("name");, +                    }, +                    Map<String, Object> values = this.values;, +                    if (values == null) {, +                        return;, +                    }, +                    Object old = values.remove(name);, +                    notifyUnbound(old, name);, +                    Map<String, Object> values = this.values;, +                    if (values == null || values.isEmpty()) {, +                    return values.keySet().toArray(new String[values.size()]);, +                }, +, +                private void notifyUnbound(Object value, String name) {, +                    if (value instanceof SSLSessionBindingListener) {, +                        ((SSLSessionBindingListener) value).valueUnbound(new SSLSessionBindingEvent(this, name));, +                    }, +                }, +                    // TODO: Find out how to get these, +                public Principal getPeerPrincipal() throws SSLPeerUnverifiedException {, +                    Certificate[] peer = getPeerCertificates();, +                    if (peer == null || peer.length == 0) {, +                    return principal(peer);, +                }, +                    Certificate[] local = getLocalCertificates();, +                    if (local == null || local.length == 0) {, +                    return principal(local);, +                }, +, +                private Principal principal(Certificate[] certs) {, +                    return ((java.security.cert.X509Certificate) certs[0]).getIssuerX500Principal();, +                }, +                    String version = SSL.getVersion(ssl);, +                        return version;]