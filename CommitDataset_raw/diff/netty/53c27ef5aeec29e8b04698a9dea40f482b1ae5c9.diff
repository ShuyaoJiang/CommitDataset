[+++ b/codec/src/main/java/io/netty/handler/codec/ByteToMessageCodec.java, +        outboundMsgMatcher = TypeParameterMatcher.find(this, ByteToMessageCodec.class, "I");, +++ b/codec/src/main/java/io/netty/handler/codec/ByteToMessageCodec.java, +        outboundMsgMatcher = TypeParameterMatcher.find(this, ByteToMessageCodec.class, "I");, +++ b/codec/src/main/java/io/netty/handler/codec/MessageToByteEncoder.java, +++ b/codec/src/main/java/io/netty/handler/codec/ByteToMessageCodec.java, +        outboundMsgMatcher = TypeParameterMatcher.find(this, ByteToMessageCodec.class, "I");, +++ b/codec/src/main/java/io/netty/handler/codec/MessageToByteEncoder.java, +++ b/codec/src/main/java/io/netty/handler/codec/MessageToMessageCodec.java, +        inboundMsgMatcher = TypeParameterMatcher.find(this, MessageToMessageCodec.class, "INBOUND_IN");, +        outboundMsgMatcher = TypeParameterMatcher.find(this, MessageToMessageCodec.class, "OUTBOUND_IN");, +++ b/codec/src/main/java/io/netty/handler/codec/ByteToMessageCodec.java, +        outboundMsgMatcher = TypeParameterMatcher.find(this, ByteToMessageCodec.class, "I");, +++ b/codec/src/main/java/io/netty/handler/codec/MessageToByteEncoder.java, +++ b/codec/src/main/java/io/netty/handler/codec/MessageToMessageCodec.java, +        inboundMsgMatcher = TypeParameterMatcher.find(this, MessageToMessageCodec.class, "INBOUND_IN");, +        outboundMsgMatcher = TypeParameterMatcher.find(this, MessageToMessageCodec.class, "OUTBOUND_IN");, +++ b/codec/src/main/java/io/netty/handler/codec/MessageToMessageDecoder.java, +++ b/codec/src/main/java/io/netty/handler/codec/ByteToMessageCodec.java, +        outboundMsgMatcher = TypeParameterMatcher.find(this, ByteToMessageCodec.class, "I");, +++ b/codec/src/main/java/io/netty/handler/codec/MessageToByteEncoder.java, +++ b/codec/src/main/java/io/netty/handler/codec/MessageToMessageCodec.java, +        inboundMsgMatcher = TypeParameterMatcher.find(this, MessageToMessageCodec.class, "INBOUND_IN");, +        outboundMsgMatcher = TypeParameterMatcher.find(this, MessageToMessageCodec.class, "OUTBOUND_IN");, +++ b/codec/src/main/java/io/netty/handler/codec/MessageToMessageDecoder.java, +++ b/codec/src/main/java/io/netty/handler/codec/MessageToMessageEncoder.java, +++ b/codec/src/main/java/io/netty/handler/codec/ByteToMessageCodec.java, +        outboundMsgMatcher = TypeParameterMatcher.find(this, ByteToMessageCodec.class, "I");, +++ b/codec/src/main/java/io/netty/handler/codec/MessageToByteEncoder.java, +++ b/codec/src/main/java/io/netty/handler/codec/MessageToMessageCodec.java, +        inboundMsgMatcher = TypeParameterMatcher.find(this, MessageToMessageCodec.class, "INBOUND_IN");, +        outboundMsgMatcher = TypeParameterMatcher.find(this, MessageToMessageCodec.class, "OUTBOUND_IN");, +++ b/codec/src/main/java/io/netty/handler/codec/MessageToMessageDecoder.java, +++ b/codec/src/main/java/io/netty/handler/codec/MessageToMessageEncoder.java, +++ b/common/src/main/java/io/netty/util/internal/TypeParameterMatcher.java, +import java.lang.reflect.GenericDeclaration;, +import java.lang.reflect.TypeVariable;, +import java.util.HashMap;, +    private static final ThreadLocal<Map<Class<?>, Map<String, TypeParameterMatcher>>> typeMap =, +            new ThreadLocal<Map<Class<?>, Map<String, TypeParameterMatcher>>>() {, +                protected Map<Class<?>, Map<String, TypeParameterMatcher>> initialValue() {, +                    return new IdentityHashMap<Class<?>, Map<String, TypeParameterMatcher>>();, +            final Object object, final GenericDeclaration parameterizedSuperclass, final String typeParamName) {, +        final Map<Class<?>, Map<String, TypeParameterMatcher>> typeMap = TypeParameterMatcher.typeMap.get();, +        Map<String, TypeParameterMatcher> map = typeMap.get(thisClass);, +        if (map == null) {, +            map = new HashMap<String, TypeParameterMatcher>();, +            typeMap.put(thisClass, map);, +        }, +, +        TypeParameterMatcher matcher = map.get(typeParamName);, +            Class<?> messageType = find0(object, parameterizedSuperclass, typeParamName);, +            map.put(typeParamName, matcher);, +    private static Class<?> find0(, +            final Object object, GenericDeclaration parameterizedSuperclass, String typeParamName) {, +, +        final Class<?> thisClass = object.getClass();, +        Class<?> currentClass = thisClass;, +        for (;;) {, +            if (currentClass.getSuperclass() == parameterizedSuperclass) {, +                int typeParamIndex = -1;, +                TypeVariable<?>[] typeParams = currentClass.getSuperclass().getTypeParameters();, +                for (int i = 0; i < typeParams.length; i ++) {, +                    if (typeParamName.equals(typeParams[i].getName())) {, +                        typeParamIndex = i;, +                        break;, +                    }, +                }, +, +                if (typeParamIndex < 0) {, +                    throw new IllegalStateException(, +                            "unknown type parameter '" + typeParamName + "': " + parameterizedSuperclass);, +                }, +, +                Type[] actualTypeParams =, +                        ((ParameterizedType) currentClass.getGenericSuperclass()).getActualTypeArguments();, +, +                Type actualTypeParam = actualTypeParams[typeParamIndex];, +                if (actualTypeParam instanceof Class) {, +                    return (Class<?>) actualTypeParam;, +                }, +                if (actualTypeParam instanceof ParameterizedType) {, +                    return (Class<?>) ((ParameterizedType) actualTypeParam).getRawType();, +                }, +                if (actualTypeParam instanceof TypeVariable) {, +                    // Resolved type parameter points to another type parameter., +                    TypeVariable<?> v = (TypeVariable<?>) actualTypeParam;, +                    currentClass = thisClass;, +                    parameterizedSuperclass = v.getGenericDeclaration();, +                    typeParamName = v.getName();, +                    continue;, +                }, +, +                return fail(thisClass, typeParamName);, +            }, +            currentClass = currentClass.getSuperclass();, +            if (currentClass == null) {, +                return fail(thisClass, typeParamName);, +            }, +        }]