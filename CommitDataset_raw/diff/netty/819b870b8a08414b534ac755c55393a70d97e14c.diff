[+++ b/buffer/src/main/java/io/netty/buffer/ReadOnlyUnsafeDirectByteBuf.java, +    ReadOnlyUnsafeDirectByteBuf(ByteBufAllocator allocator, ByteBuffer byteBuffer) {, +        super(allocator, byteBuffer);, +        // Use buffer as the super class will slice the passed in ByteBuffer which means the memoryAddress, +        // may be different if the position != 0., +++ b/buffer/src/main/java/io/netty/buffer/ReadOnlyUnsafeDirectByteBuf.java, +    ReadOnlyUnsafeDirectByteBuf(ByteBufAllocator allocator, ByteBuffer byteBuffer) {, +        super(allocator, byteBuffer);, +        // Use buffer as the super class will slice the passed in ByteBuffer which means the memoryAddress, +        // may be different if the position != 0., +++ b/buffer/src/test/java/io/netty/buffer/ReadOnlyDirectByteBufferBufTest.java, +import io.netty.util.internal.PlatformDependent;, +import java.io.File;, +import java.io.FileInputStream;, +import java.io.FileOutputStream;, +import java.nio.channels.FileChannel;, +, +    @Test, +    public void testWrapMemoryMapped() throws Exception {, +        File file = File.createTempFile("netty-test", "tmp");, +        FileChannel output = null;, +        FileChannel input = null;, +        ByteBuf b1 = null;, +        ByteBuf b2 = null;, +, +        try {, +            output = new FileOutputStream(file).getChannel();, +            byte[] bytes = new byte[1024];, +            PlatformDependent.threadLocalRandom().nextBytes(bytes);, +            output.write(ByteBuffer.wrap(bytes));, +, +            input = new FileInputStream(file).getChannel();, +            ByteBuffer m = input.map(FileChannel.MapMode.READ_ONLY, 0, input.size());, +, +            b1 = buffer(m);, +, +            ByteBuffer dup = m.duplicate();, +            dup.position(2);, +            dup.limit(4);, +, +            b2 = buffer(dup);, +, +            Assert.assertEquals(b2, b1.slice(2, 2));, +        } finally {, +            if (b1 != null) {, +                b1.release();, +            }, +            if (b2 != null) {, +                b2.release();, +            }, +            if (output != null) {, +                output.close();, +            }, +            if (input != null) {, +                input.close();, +            }, +            file.delete();, +        }, +    }, +++ b/buffer/src/main/java/io/netty/buffer/ReadOnlyUnsafeDirectByteBuf.java, +    ReadOnlyUnsafeDirectByteBuf(ByteBufAllocator allocator, ByteBuffer byteBuffer) {, +        super(allocator, byteBuffer);, +        // Use buffer as the super class will slice the passed in ByteBuffer which means the memoryAddress, +        // may be different if the position != 0., +++ b/buffer/src/test/java/io/netty/buffer/ReadOnlyDirectByteBufferBufTest.java, +import io.netty.util.internal.PlatformDependent;, +import java.io.File;, +import java.io.FileInputStream;, +import java.io.FileOutputStream;, +import java.nio.channels.FileChannel;, +, +    @Test, +    public void testWrapMemoryMapped() throws Exception {, +        File file = File.createTempFile("netty-test", "tmp");, +        FileChannel output = null;, +        FileChannel input = null;, +        ByteBuf b1 = null;, +        ByteBuf b2 = null;, +, +        try {, +            output = new FileOutputStream(file).getChannel();, +            byte[] bytes = new byte[1024];, +            PlatformDependent.threadLocalRandom().nextBytes(bytes);, +            output.write(ByteBuffer.wrap(bytes));, +, +            input = new FileInputStream(file).getChannel();, +            ByteBuffer m = input.map(FileChannel.MapMode.READ_ONLY, 0, input.size());, +, +            b1 = buffer(m);, +, +            ByteBuffer dup = m.duplicate();, +            dup.position(2);, +            dup.limit(4);, +, +            b2 = buffer(dup);, +, +            Assert.assertEquals(b2, b1.slice(2, 2));, +        } finally {, +            if (b1 != null) {, +                b1.release();]