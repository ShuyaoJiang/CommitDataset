[+++ b/codec/src/main/java/io/netty/handler/codec/compression/Snappy.java, +    // used as a return value to indicate that we haven't yet read our full preamble, +    private static final int PREAMBLE_NOT_FULL = -1;, +, +    private State state = State.READY;, +    private byte tag;, +, +    private static enum State {, +        READY,, +        READING_PREAMBLE,, +        READING_TAG,, +        READING_LITERAL,, +        READING_COPY, +    }, +        state = State.READY;, +        tag = 0;, +    public void decode(ByteBuf in, ByteBuf out) {, +        while (in.isReadable()) {, +            switch (state) {, +            case READY:, +                state = State.READING_PREAMBLE;, +            case READING_PREAMBLE:, +                int uncompressedLength = readPreamble(in);, +                if (uncompressedLength == PREAMBLE_NOT_FULL) {, +                    // We've not yet read all of the preamble, so wait until we can, +                if (uncompressedLength == 0) {, +                    // Should never happen, but it does mean we have nothing further to do, +                    state = State.READY;, +                    return;, +                }, +                out.ensureWritable(uncompressedLength);, +                state = State.READING_TAG;, +            case READING_TAG:, +                if (!in.isReadable()) {, +                    return;, +                }, +                tag = in.readByte();, +                    state = State.READING_LITERAL;, +                case COPY_2_BYTE_OFFSET:, +                case COPY_4_BYTE_OFFSET:, +                    state = State.READING_COPY;, +                    break;, +                }, +                break;, +            case READING_LITERAL:, +                if (decodeLiteral(tag, in, out)) {, +                    state = State.READING_TAG;, +                } else {, +                    // Need to wait for more data, +                    return;, +                }, +                break;, +            case READING_COPY:, +                switch (tag & 0x03) {, +                case COPY_1_BYTE_OFFSET:, +                    if (decodeCopyWith1ByteOffset(tag, in, out)) {, +                        state = State.READING_TAG;, +                    } else {, +                        // Need to wait for more data, +                        return;, +                    }, +                    if (decodeCopyWith2ByteOffset(tag, in, out)) {, +                        state = State.READING_TAG;, +                    } else {, +                        // Need to wait for more data, +                        return;, +                    }, +                    if (decodeCopyWith4ByteOffset(tag, in, out)) {, +                        state = State.READING_TAG;, +                    } else {, +                        // Need to wait for more data, +                        return;, +                    }, +    }, +    private static boolean decodeLiteral(byte tag, ByteBuf in, ByteBuf out) {, +        in.markReaderIndex();, +            if (!in.isReadable()) {, +                return false;, +            }, +            if (in.readableBytes() < 2) {, +                return false;, +            }, +            if (in.readableBytes() < 3) {, +                return false;, +            }, +            if (in.readableBytes() < 4) {, +                return false;, +            }, +        if (in.readableBytes() < length) {, +            in.resetReaderIndex();, +            return false;, +        }, +, +        return true;, +    private static boolean decodeCopyWith1ByteOffset(byte tag, ByteBuf in, ByteBuf out) {, +        if (!in.isReadable()) {, +            return false;, +        }, +, +        int initialIndex = out.readableBytes();]