[+++ b/testsuite/src/test/java/io/netty/testsuite/transport/socket/AbstractDatagramTest.java, +import io.netty.bootstrap.Bootstrap;, +import io.netty.logging.InternalLogger;, +import io.netty.logging.InternalLoggerFactory;, +import io.netty.testsuite.transport.socket.SocketTestPermutation.Factory;, +import io.netty.testsuite.util.TestUtils;, +import io.netty.util.SocketAddresses;, +import java.lang.reflect.Method;, +import java.util.List;, +import java.util.Map.Entry;, +import org.junit.Rule;, +import org.junit.rules.TestName;, +    private static final List<Entry<Factory<Bootstrap>, Factory<Bootstrap>>> COMBO =, +            SocketTestPermutation.datagram();, +    @Rule, +    public final TestName testName = new TestName();, +    protected final InternalLogger logger = InternalLoggerFactory.getInstance(getClass());, +, +    protected volatile Bootstrap sb;, +    protected volatile Bootstrap cb;, +    protected volatile InetSocketAddress addr;, +, +    protected void run() throws Exception {, +        int i = 0;, +        for (Entry<Factory<Bootstrap>, Factory<Bootstrap>> e: COMBO) {, +            sb = e.getKey().newInstance();, +            cb = e.getValue().newInstance();, +            addr = new InetSocketAddress(, +                    SocketAddresses.LOCALHOST, TestUtils.getFreePort());, +            sb.localAddress(addr);, +            cb.localAddress(0).remoteAddress(addr);, +, +            logger.info(String.format(, +                    "Running: %s %d of %d", testName.getMethodName(), ++ i, COMBO.size()));, +            try {, +                Method m = getClass().getDeclaredMethod(, +                        testName.getMethodName(), Bootstrap.class, Bootstrap.class);, +                m.invoke(this, sb, cb);, +            } finally {, +                sb.shutdown();, +                cb.shutdown();, +++ b/testsuite/src/test/java/io/netty/testsuite/transport/socket/AbstractDatagramTest.java, +import io.netty.bootstrap.Bootstrap;, +import io.netty.logging.InternalLogger;, +import io.netty.logging.InternalLoggerFactory;, +import io.netty.testsuite.transport.socket.SocketTestPermutation.Factory;, +import io.netty.testsuite.util.TestUtils;, +import io.netty.util.SocketAddresses;, +import java.lang.reflect.Method;, +import java.util.List;, +import java.util.Map.Entry;, +import org.junit.Rule;, +import org.junit.rules.TestName;, +    private static final List<Entry<Factory<Bootstrap>, Factory<Bootstrap>>> COMBO =, +            SocketTestPermutation.datagram();, +    @Rule, +    public final TestName testName = new TestName();, +    protected final InternalLogger logger = InternalLoggerFactory.getInstance(getClass());, +, +    protected volatile Bootstrap sb;, +    protected volatile Bootstrap cb;, +    protected volatile InetSocketAddress addr;, +, +    protected void run() throws Exception {, +        int i = 0;, +        for (Entry<Factory<Bootstrap>, Factory<Bootstrap>> e: COMBO) {, +            sb = e.getKey().newInstance();, +            cb = e.getValue().newInstance();, +            addr = new InetSocketAddress(, +                    SocketAddresses.LOCALHOST, TestUtils.getFreePort());, +            sb.localAddress(addr);, +            cb.localAddress(0).remoteAddress(addr);, +, +            logger.info(String.format(, +                    "Running: %s %d of %d", testName.getMethodName(), ++ i, COMBO.size()));, +            try {, +                Method m = getClass().getDeclaredMethod(, +                        testName.getMethodName(), Bootstrap.class, Bootstrap.class);, +                m.invoke(this, sb, cb);, +            } finally {, +                sb.shutdown();, +                cb.shutdown();, +++ /dev/null, +++ b/testsuite/src/test/java/io/netty/testsuite/transport/socket/AbstractDatagramTest.java, +import io.netty.bootstrap.Bootstrap;, +import io.netty.logging.InternalLogger;, +import io.netty.logging.InternalLoggerFactory;, +import io.netty.testsuite.transport.socket.SocketTestPermutation.Factory;, +import io.netty.testsuite.util.TestUtils;, +import io.netty.util.SocketAddresses;, +import java.lang.reflect.Method;, +import java.util.List;, +import java.util.Map.Entry;, +import org.junit.Rule;, +import org.junit.rules.TestName;, +    private static final List<Entry<Factory<Bootstrap>, Factory<Bootstrap>>> COMBO =, +            SocketTestPermutation.datagram();, +    @Rule, +    public final TestName testName = new TestName();, +    protected final InternalLogger logger = InternalLoggerFactory.getInstance(getClass());]