[+++ b/handler/src/main/java/io/netty/handler/ssl/ReferenceCountedOpenSslClientContext.java, +                assert engine.handshakeException == null;, +++ b/handler/src/main/java/io/netty/handler/ssl/ReferenceCountedOpenSslClientContext.java, +                assert engine.handshakeException == null;, +++ b/handler/src/main/java/io/netty/handler/ssl/ReferenceCountedOpenSslContext.java, +                assert engine.handshakeException == null;, +++ b/handler/src/main/java/io/netty/handler/ssl/ReferenceCountedOpenSslClientContext.java, +                assert engine.handshakeException == null;, +++ b/handler/src/main/java/io/netty/handler/ssl/ReferenceCountedOpenSslContext.java, +                assert engine.handshakeException == null;, +++ b/handler/src/main/java/io/netty/handler/ssl/ReferenceCountedOpenSslEngine.java, +                    if (handshakeException != null) {, +                        //, +                        // unwrap(...) will then ensure we propagate the handshake error back to the user., +                        return newResult(NEED_UNWRAP, 0, bytesProduced);, +                        } else if (sslError == SSL.SSL_ERROR_WANT_X509_LOOKUP ||, +                                sslError == SSL.SSL_ERROR_WANT_CERTIFICATE_VERIFY) {, +                                } else if (sslError == SSL.SSL_ERROR_WANT_X509_LOOKUP, +                                        || sslError == SSL.SSL_ERROR_WANT_CERTIFICATE_VERIFY) {, +                try {, +    private SSLEngineResult.HandshakeStatus handshakeException() throws SSLException {, +, +        SSLHandshakeException exception = handshakeException;, +        assert exception != null;, +    private SSLEngineResult.HandshakeStatus handshake() throws SSLException {, +        if (needTask) {, +            return NEED_TASK;, +        }, +        if (handshakeState == HandshakeState.FINISHED) {, +            return FINISHED;, +        }, +, +        checkEngineClosed(HANDSHAKE_ENGINE_CLOSED);, +, +        if (handshakeException != null) {, +            return handshakeException();, +        }, +, +            if (sslError == SSL.SSL_ERROR_WANT_X509_LOOKUP || sslError == SSL.SSL_ERROR_WANT_CERTIFICATE_VERIFY) {, +            // Check if we have a pending exception that was created during the handshake and if so throw it after, +            // shutdown the connection., +            if (handshakeException != null) {, +                return handshakeException();, +            }, +, +++ b/handler/src/main/java/io/netty/handler/ssl/ReferenceCountedOpenSslClientContext.java, +                assert engine.handshakeException == null;, +++ b/handler/src/main/java/io/netty/handler/ssl/ReferenceCountedOpenSslContext.java, +                assert engine.handshakeException == null;, +++ b/handler/src/main/java/io/netty/handler/ssl/ReferenceCountedOpenSslEngine.java, +                    if (handshakeException != null) {, +                        //, +                        // unwrap(...) will then ensure we propagate the handshake error back to the user., +                        return newResult(NEED_UNWRAP, 0, bytesProduced);, +                        } else if (sslError == SSL.SSL_ERROR_WANT_X509_LOOKUP ||, +                                sslError == SSL.SSL_ERROR_WANT_CERTIFICATE_VERIFY) {, +                                } else if (sslError == SSL.SSL_ERROR_WANT_X509_LOOKUP, +                                        || sslError == SSL.SSL_ERROR_WANT_CERTIFICATE_VERIFY) {, +                try {, +    private SSLEngineResult.HandshakeStatus handshakeException() throws SSLException {, +, +        SSLHandshakeException exception = handshakeException;, +        assert exception != null;, +    private SSLEngineResult.HandshakeStatus handshake() throws SSLException {, +        if (needTask) {, +            return NEED_TASK;, +        }, +        if (handshakeState == HandshakeState.FINISHED) {, +            return FINISHED;, +        }, +, +        checkEngineClosed(HANDSHAKE_ENGINE_CLOSED);, +, +        if (handshakeException != null) {, +            return handshakeException();, +        }, +, +            if (sslError == SSL.SSL_ERROR_WANT_X509_LOOKUP || sslError == SSL.SSL_ERROR_WANT_CERTIFICATE_VERIFY) {, +            // Check if we have a pending exception that was created during the handshake and if so throw it after, +            // shutdown the connection., +            if (handshakeException != null) {, +                return handshakeException();, +            }, +, +++ b/handler/src/main/java/io/netty/handler/ssl/ReferenceCountedOpenSslServerContext.java, +                assert engine.handshakeException == null;, +++ b/handler/src/main/java/io/netty/handler/ssl/ReferenceCountedOpenSslClientContext.java, +                assert engine.handshakeException == null;, +++ b/handler/src/main/java/io/netty/handler/ssl/ReferenceCountedOpenSslContext.java, +                assert engine.handshakeException == null;, +++ b/handler/src/main/java/io/netty/handler/ssl/ReferenceCountedOpenSslEngine.java, +                    if (handshakeException != null) {, +                        //, +                        // unwrap(...) will then ensure we propagate the handshake error back to the user., +                        return newResult(NEED_UNWRAP, 0, bytesProduced);, +                        } else if (sslError == SSL.SSL_ERROR_WANT_X509_LOOKUP ||, +                                sslError == SSL.SSL_ERROR_WANT_CERTIFICATE_VERIFY) {, +                                } else if (sslError == SSL.SSL_ERROR_WANT_X509_LOOKUP, +                                        || sslError == SSL.SSL_ERROR_WANT_CERTIFICATE_VERIFY) {, +                try {]