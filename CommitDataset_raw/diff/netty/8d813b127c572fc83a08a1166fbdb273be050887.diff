[+++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, +    private final int maxCapacity;, +    int refCnt = 1;, +, +    protected AbstractByteBuf(ByteOrder endianness, int maxCapacity) {, +        if (maxCapacity < 0) {, +            throw new IllegalArgumentException("maxCapacity: " + maxCapacity + " (expected: >= 0)");, +        }, +        this.maxCapacity = maxCapacity;, +    public int maxCapacity() {, +        return maxCapacity;, +    }, +, +    @Override, +            adjustMarkers(readerIndex);, +            adjustMarkers(readerIndex);, +    protected void adjustMarkers(int decrement) {, +        markedReaderIndex = Math.max(markedReaderIndex - decrement, 0);, +        markedWriterIndex = Math.max(markedWriterIndex - decrement, 0);, +, +    @Override, +    public void ensureWritableBytes(int minWritableBytes) {, +        if (minWritableBytes <= writableBytes()) {, +            return;, +        }, +, +        if (minWritableBytes > maxCapacity - writerIndex) {, +            throw new IllegalArgumentException(String.format(, +                    "minWritableBytes(%d) + writerIndex(%d) > maxCapacity(%d)",, +                    minWritableBytes, writerIndex, maxCapacity));, +        }, +, +        int minNewCapacity = writerIndex + minWritableBytes;, +, +        if (minNewCapacity > maxCapacity) {, +            throw new IllegalArgumentException(String.format(, +                    "minWritableBytes: %d (exceeds maxCapacity(%d))", minWritableBytes, maxCapacity));, +        }, +, +        // Normalize the current capacity to the power of 2., +        int newCapacity = calculateNewCapacity(minNewCapacity);, +, +        // Adjust to the new capacity., +        capacity(newCapacity);, +    }, +, +    private int calculateNewCapacity(int minNewCapacity) {, +        final int threshold = 1048576 * 4; // 4 MiB page, +, +        if (minNewCapacity == threshold) {, +            return minNewCapacity;, +        }, +, +        // If over threshold, do not double but just increase by threshold., +        if (minNewCapacity > threshold) {, +            int newCapacity = minNewCapacity / threshold * threshold;, +            if (newCapacity > maxCapacity - threshold) {, +                newCapacity = maxCapacity;, +            } else {, +                newCapacity += threshold;, +            }, +            return newCapacity;, +        }, +, +        // Not over threshold. Double up to 4 MiB, starting from 64., +        int newCapacity = 64;, +        while (newCapacity < minNewCapacity) {, +            newCapacity <<= 1;, +        }, +        return newCapacity;, +        ByteBuf buf = unsafe().newBuffer(length);, +        ensureWritableBytes(1);, +        ensureWritableBytes(2);, +        ensureWritableBytes(3);, +        ensureWritableBytes(4);, +        ensureWritableBytes(8);, +        ensureWritableBytes(length);, +        ensureWritableBytes(length);, +        ensureWritableBytes(length);, +        ensureWritableBytes(length);, +        ensureWritableBytes(length);, +    public ByteBuf duplicate() {, +        return new DuplicatedByteBuf(this);, +    }, +, +    @Override, +    public ByteBuf slice(int index, int length) {, +        if (length == 0) {, +            return Unpooled.EMPTY_BUFFER;, +        }, +, +        return new SlicedByteBuf(this, index, length);, +    }, +, +    @Override, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, +    private final int maxCapacity;, +    int refCnt = 1;, +, +    protected AbstractByteBuf(ByteOrder endianness, int maxCapacity) {]