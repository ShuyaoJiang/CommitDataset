[+++ b/transport/src/main/java/io/netty/bootstrap/AbstractBootstrap.java, +                        promise.registered();, +    static final class PendingRegistrationPromise extends DefaultChannelPromise {, +, +        private volatile boolean registered;, +        PendingRegistrationPromise(Channel channel) {, +        void registered() {, +            registered = true;, +        }, +, +            if (registered) {, +                return super.executor();, +++ b/transport/src/main/java/io/netty/bootstrap/AbstractBootstrap.java, +                        promise.registered();, +    static final class PendingRegistrationPromise extends DefaultChannelPromise {, +, +        private volatile boolean registered;, +        PendingRegistrationPromise(Channel channel) {, +        void registered() {, +            registered = true;, +        }, +, +            if (registered) {, +                return super.executor();, +++ b/transport/src/main/java/io/netty/bootstrap/Bootstrap.java, +    private ChannelFuture doResolveAndConnect(final SocketAddress remoteAddress, final SocketAddress localAddress) {, +        final Channel channel = regFuture.channel();, +, +        if (regFuture.isDone()) {, +            if (!regFuture.isSuccess()) {, +            return doResolveAndConnect0(channel, remoteAddress, localAddress, channel.newPromise());, +        } else {, +            // Registration future is almost always fulfilled already, but just in case it's not., +            final PendingRegistrationPromise promise = new PendingRegistrationPromise(channel);, +            regFuture.addListener(new ChannelFutureListener() {, +                @Override, +                public void operationComplete(ChannelFuture future) throws Exception {, +                    // Direclty obtain the cause and do a null check so we only need one volatile read in case of a, +                    // failure., +                    Throwable cause = future.cause();, +                    if (cause != null) {, +                        // Registration on the EventLoop failed so fail the ChannelPromise directly to not cause an, +                        // IllegalStateException once we try to access the EventLoop of the Channel., +                        promise.setFailure(cause);, +                    } else {, +                        // Registration was successful, so set the correct executor to use., +                        // See https://github.com/netty/netty/issues/2586, +                        promise.registered();, +                        doResolveAndConnect0(channel, remoteAddress, localAddress, promise);, +                    }, +                }, +            });, +            return promise;, +        }, +    }, +    private ChannelFuture doResolveAndConnect0(final Channel channel, SocketAddress remoteAddress,, +                                               final SocketAddress localAddress, final ChannelPromise promise) {, +            doConnect(remoteAddress, localAddress, promise);, +            return promise;, +                promise.setFailure(resolveFailureCause);, +            } else {, +                doConnect(resolveFuture.getNow(), localAddress, promise);, +            }, +            return promise;, +                    promise.setFailure(future.cause());, +                    doConnect(future.getNow(), localAddress, promise);, +        return promise;, +    private static void doConnect(, +            final SocketAddress remoteAddress, final SocketAddress localAddress, final ChannelPromise connectPromise) {, +++ b/transport/src/main/java/io/netty/bootstrap/AbstractBootstrap.java, +                        promise.registered();, +    static final class PendingRegistrationPromise extends DefaultChannelPromise {, +, +        private volatile boolean registered;, +        PendingRegistrationPromise(Channel channel) {, +        void registered() {, +            registered = true;, +        }, +, +            if (registered) {, +                return super.executor();, +++ b/transport/src/main/java/io/netty/bootstrap/Bootstrap.java, +    private ChannelFuture doResolveAndConnect(final SocketAddress remoteAddress, final SocketAddress localAddress) {, +        final Channel channel = regFuture.channel();, +, +        if (regFuture.isDone()) {, +            if (!regFuture.isSuccess()) {, +            return doResolveAndConnect0(channel, remoteAddress, localAddress, channel.newPromise());, +        } else {, +            // Registration future is almost always fulfilled already, but just in case it's not., +            final PendingRegistrationPromise promise = new PendingRegistrationPromise(channel);, +            regFuture.addListener(new ChannelFutureListener() {, +                @Override, +                public void operationComplete(ChannelFuture future) throws Exception {, +                    // Direclty obtain the cause and do a null check so we only need one volatile read in case of a, +                    // failure., +                    Throwable cause = future.cause();, +                    if (cause != null) {, +                        // Registration on the EventLoop failed so fail the ChannelPromise directly to not cause an, +                        // IllegalStateException once we try to access the EventLoop of the Channel.]