[+++ b/transport/src/main/java/io/netty/channel/ChannelFlushFutureNotifier.java, +/**, + * This implementation allows to register {@link ChannelFuture} instances which will get notified once some amount of, + * data was written and so a checkpoint was reached., + */, +++ b/transport/src/main/java/io/netty/channel/ChannelFlushFutureNotifier.java, +/**, + * This implementation allows to register {@link ChannelFuture} instances which will get notified once some amount of, + * data was written and so a checkpoint was reached., + */, +++ b/transport/src/main/java/io/netty/channel/ChannelFuture.java, +import io.netty.bootstrap.Bootstrap;, +, +, + * public void messageReceived({@link ChannelHandlerContext} ctx, GoodByeMessage msg) {, + *     {@link ChannelFuture} future = ctx.channel().close();, + * public void messageReceived({@link ChannelHandlerContext} ctx,  GoodByeMessage msg) {, + *     {@link ChannelFuture} future = ctx.channel().close();, + * {@link BlockingOperationException} will be raised to prevent a dead lock., + * <b>b.setOption({@link ChannelOption}.CONNECT_TIMEOUT_MILLIS, 10000);</b>, +++ b/transport/src/main/java/io/netty/channel/ChannelFlushFutureNotifier.java, +/**, + * This implementation allows to register {@link ChannelFuture} instances which will get notified once some amount of, + * data was written and so a checkpoint was reached., + */, +++ b/transport/src/main/java/io/netty/channel/ChannelFuture.java, +import io.netty.bootstrap.Bootstrap;, +, +, + * public void messageReceived({@link ChannelHandlerContext} ctx, GoodByeMessage msg) {, + *     {@link ChannelFuture} future = ctx.channel().close();, + * public void messageReceived({@link ChannelHandlerContext} ctx,  GoodByeMessage msg) {, + *     {@link ChannelFuture} future = ctx.channel().close();, + * {@link BlockingOperationException} will be raised to prevent a dead lock., + * <b>b.setOption({@link ChannelOption}.CONNECT_TIMEOUT_MILLIS, 10000);</b>, +++ b/transport/src/main/java/io/netty/channel/ChannelFutureAggregator.java, +public final class ChannelFutureAggregator implements ChannelFutureListener {, +++ b/transport/src/main/java/io/netty/channel/ChannelFlushFutureNotifier.java, +/**, + * This implementation allows to register {@link ChannelFuture} instances which will get notified once some amount of, + * data was written and so a checkpoint was reached., + */, +++ b/transport/src/main/java/io/netty/channel/ChannelFuture.java, +import io.netty.bootstrap.Bootstrap;, +, +, + * public void messageReceived({@link ChannelHandlerContext} ctx, GoodByeMessage msg) {, + *     {@link ChannelFuture} future = ctx.channel().close();, + * public void messageReceived({@link ChannelHandlerContext} ctx,  GoodByeMessage msg) {, + *     {@link ChannelFuture} future = ctx.channel().close();, + * {@link BlockingOperationException} will be raised to prevent a dead lock., + * <b>b.setOption({@link ChannelOption}.CONNECT_TIMEOUT_MILLIS, 10000);</b>, +++ b/transport/src/main/java/io/netty/channel/ChannelFutureAggregator.java, +public final class ChannelFutureAggregator implements ChannelFutureListener {, +++ b/transport/src/main/java/io/netty/channel/ChannelHandlerAdapter.java, +/**, + * {@link ChannelHandler} implementation which represents a combination out of a {@link ChannelStateHandler} and, + * the {@link ChannelOperationHandler}., + *, + * It is a good starting point if your {@link ChannelHandler} implementation needs to intercept operations and also, + * state updates., + */, +public abstract class ChannelHandlerAdapter extends ChannelStateHandlerAdapter implements ChannelOperationHandler {, +    /**, +     * Calls {@link ChannelHandlerContext#bind(SocketAddress, ChannelFuture)} to forward, +     * to the next {@link ChannelOperationHandler} in the {@link ChannelPipeline}., +     *, +     * Sub-classes may override this method to change behavior., +     */, +    public void bind(ChannelHandlerContext ctx, SocketAddress localAddress,, +                     ChannelFuture future) throws Exception {, +    /**, +     * Calls {@link ChannelHandlerContext#connect(SocketAddress, SocketAddress, ChannelFuture)} to forward, +     * to the next {@link ChannelOperationHandler} in the {@link ChannelPipeline}., +     *, +     * Sub-classes may override this method to change behavior., +     */, +    public void connect(ChannelHandlerContext ctx, SocketAddress remoteAddress,, +                        SocketAddress localAddress, ChannelFuture future) throws Exception {, +    /**, +     * Calls {@link ChannelHandlerContext#disconnect(ChannelFuture)} to forward, +     * to the next {@link ChannelOperationHandler} in the {@link ChannelPipeline}., +     *, +     * Sub-classes may override this method to change behavior., +     */, +    public void disconnect(ChannelHandlerContext ctx, ChannelFuture future), +            throws Exception {, +    /**, +     * Calls {@link ChannelHandlerContext#close(ChannelFuture)} to forward, +     * to the next {@link ChannelOperationHandler} in the {@link ChannelPipeline}., +     *, +     * Sub-classes may override this method to change behavior., +     */, +    public void close(ChannelHandlerContext ctx, ChannelFuture future), +            throws Exception {, +    /**, +     * Calls {@link ChannelHandlerContext#close(ChannelFuture)} to forward, +     * to the next {@link ChannelOperationHandler} in the {@link ChannelPipeline}., +     *, +     * Sub-classes may override this method to change behavior.]