[+++ b/transport-native-epoll/src/main/c/io_netty_channel_epoll_Native.c, +// macro to calculate the length of a sockaddr_un struct for a given path length., +// see sys/un.h#SUN_LEN, this is modified to allow nul bytes, +#define _UNIX_ADDR_LENGTH(path_len) (((struct sockaddr_un *) 0)->sun_path) + path_len, +, +JNIEXPORT jint JNICALL Java_io_netty_channel_epoll_Native_bindDomainSocket(JNIEnv* env, jclass clazz, jint fd, jbyteArray socketPath) {, +    const jbyte* socket_path = (*env)->GetByteArrayElements(env, socketPath, 0);, +    jint socket_path_len = (*env)->GetArrayLength(env, socketPath);, +    if (socket_path_len > sizeof(addr.sun_path)) {, +        socket_path_len = sizeof(addr.sun_path);, +    }, +    memcpy(addr.sun_path, socket_path, socket_path_len);, +    int res = bind(fd, (struct sockaddr*) &addr, _UNIX_ADDR_LENGTH(socket_path_len));, +    (*env)->ReleaseByteArrayElements(env, socketPath, socket_path, 0);, +JNIEXPORT jint JNICALL Java_io_netty_channel_epoll_Native_connectDomainSocket(JNIEnv* env, jclass clazz, jint fd, jbyteArray socketPath) {, +    jint socket_path_len;, +    const jbyte* socket_path = (*env)->GetByteArrayElements(env, socketPath, 0);, +    socket_path_len = (*env)->GetArrayLength(env, socketPath);, +    if (socket_path_len > sizeof(addr.sun_path)) {, +        socket_path_len = sizeof(addr.sun_path);, +    }, +    memcpy(addr.sun_path, socket_path, socket_path_len);, +        res = connect(fd, (struct sockaddr*) &addr, _UNIX_ADDR_LENGTH(socket_path_len));, +    (*env)->ReleaseByteArrayElements(env, socketPath, socket_path, 0);, +++ b/transport-native-epoll/src/main/c/io_netty_channel_epoll_Native.c, +// macro to calculate the length of a sockaddr_un struct for a given path length., +// see sys/un.h#SUN_LEN, this is modified to allow nul bytes, +#define _UNIX_ADDR_LENGTH(path_len) (((struct sockaddr_un *) 0)->sun_path) + path_len, +, +JNIEXPORT jint JNICALL Java_io_netty_channel_epoll_Native_bindDomainSocket(JNIEnv* env, jclass clazz, jint fd, jbyteArray socketPath) {, +    const jbyte* socket_path = (*env)->GetByteArrayElements(env, socketPath, 0);, +    jint socket_path_len = (*env)->GetArrayLength(env, socketPath);, +    if (socket_path_len > sizeof(addr.sun_path)) {, +        socket_path_len = sizeof(addr.sun_path);, +    }, +    memcpy(addr.sun_path, socket_path, socket_path_len);, +    int res = bind(fd, (struct sockaddr*) &addr, _UNIX_ADDR_LENGTH(socket_path_len));, +    (*env)->ReleaseByteArrayElements(env, socketPath, socket_path, 0);, +JNIEXPORT jint JNICALL Java_io_netty_channel_epoll_Native_connectDomainSocket(JNIEnv* env, jclass clazz, jint fd, jbyteArray socketPath) {, +    jint socket_path_len;, +    const jbyte* socket_path = (*env)->GetByteArrayElements(env, socketPath, 0);, +    socket_path_len = (*env)->GetArrayLength(env, socketPath);, +    if (socket_path_len > sizeof(addr.sun_path)) {, +        socket_path_len = sizeof(addr.sun_path);, +    }, +    memcpy(addr.sun_path, socket_path, socket_path_len);, +        res = connect(fd, (struct sockaddr*) &addr, _UNIX_ADDR_LENGTH(socket_path_len));, +    (*env)->ReleaseByteArrayElements(env, socketPath, socket_path, 0);, +++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/Native.java, +import io.netty.util.CharsetUtil;, +            int res = bindDomainSocket(fd, addr.path().getBytes(CharsetUtil.UTF_8));, +    private static native int bindDomainSocket(int fd, byte[] path);, +            res = connectDomainSocket(fd, unixDomainSocketAddress.path().getBytes(CharsetUtil.UTF_8));, +    private static native int connectDomainSocket(int fd, byte[] path);, +++ b/transport-native-epoll/src/main/c/io_netty_channel_epoll_Native.c, +// macro to calculate the length of a sockaddr_un struct for a given path length., +// see sys/un.h#SUN_LEN, this is modified to allow nul bytes, +#define _UNIX_ADDR_LENGTH(path_len) (((struct sockaddr_un *) 0)->sun_path) + path_len, +, +JNIEXPORT jint JNICALL Java_io_netty_channel_epoll_Native_bindDomainSocket(JNIEnv* env, jclass clazz, jint fd, jbyteArray socketPath) {, +    const jbyte* socket_path = (*env)->GetByteArrayElements(env, socketPath, 0);, +    jint socket_path_len = (*env)->GetArrayLength(env, socketPath);, +    if (socket_path_len > sizeof(addr.sun_path)) {, +        socket_path_len = sizeof(addr.sun_path);, +    }, +    memcpy(addr.sun_path, socket_path, socket_path_len);, +    int res = bind(fd, (struct sockaddr*) &addr, _UNIX_ADDR_LENGTH(socket_path_len));, +    (*env)->ReleaseByteArrayElements(env, socketPath, socket_path, 0);, +JNIEXPORT jint JNICALL Java_io_netty_channel_epoll_Native_connectDomainSocket(JNIEnv* env, jclass clazz, jint fd, jbyteArray socketPath) {, +    jint socket_path_len;, +    const jbyte* socket_path = (*env)->GetByteArrayElements(env, socketPath, 0);, +    socket_path_len = (*env)->GetArrayLength(env, socketPath);, +    if (socket_path_len > sizeof(addr.sun_path)) {, +        socket_path_len = sizeof(addr.sun_path);, +    }, +    memcpy(addr.sun_path, socket_path, socket_path_len);, +        res = connect(fd, (struct sockaddr*) &addr, _UNIX_ADDR_LENGTH(socket_path_len));, +    (*env)->ReleaseByteArrayElements(env, socketPath, socket_path, 0);, +++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/Native.java, +import io.netty.util.CharsetUtil;, +            int res = bindDomainSocket(fd, addr.path().getBytes(CharsetUtil.UTF_8));, +    private static native int bindDomainSocket(int fd, byte[] path);, +            res = connectDomainSocket(fd, unixDomainSocketAddress.path().getBytes(CharsetUtil.UTF_8));, +    private static native int connectDomainSocket(int fd, byte[] path);, +++ b/transport-native-epoll/src/test/java/io/netty/channel/epoll/EpollAbstractDomainSocketEchoTest.java, +/*, + * Copyright 2015 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + *   http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the, + * License for the specific language governing permissions and limitations, + * under the License., + */]