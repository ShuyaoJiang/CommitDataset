[+++ b/common/src/main/java/io/netty/util/HashedWheelTimer.java, +            long calculated = deadline / tickDuration;, +            final long ticks = Math.max(calculated, tick); // Ensure we don't schedule for past., +            remainingRounds = (calculated - tick) / wheel.length;, +++ b/common/src/main/java/io/netty/util/HashedWheelTimer.java, +            long calculated = deadline / tickDuration;, +            final long ticks = Math.max(calculated, tick); // Ensure we don't schedule for past., +            remainingRounds = (calculated - tick) / wheel.length;, +++ b/common/src/test/java/io/netty/util/HashedWheelTimerTest.java, +, +import java.util.concurrent.Executors;, +import java.util.concurrent.atomic.AtomicInteger;, +, +, +    @Test, +    public void testTimerOverflowWheelLength() throws InterruptedException {, +        final HashedWheelTimer timer = new HashedWheelTimer(, +                Executors.defaultThreadFactory(), 100, TimeUnit.MILLISECONDS, 32);, +        final AtomicInteger counter = new AtomicInteger();, +, +        timer.newTimeout(new TimerTask() {, +            @Override, +            public void run(final Timeout timeout) throws Exception {, +                counter.incrementAndGet();, +                timer.newTimeout(this, 1, TimeUnit.SECONDS);, +            }, +        }, 1, TimeUnit.SECONDS);, +        Thread.sleep(3500);, +        assertEquals(3, counter.get());, +    }]