[+++ b/common/src/main/java/io/netty/util/NetUtil.java, +import java.net.UnknownHostException;, +     * This defines how many words (represented as ints) are needed to represent an IPv6 address, +     */, +    private static final int IPV6_WORD_COUNT = 8;, +, +    /**, +     * The maximum number of characters for an IPV6 string with no scope, +     */, +    private static final int IPV6_MAX_CHAR_COUNT = 39;, +, +    /**, +     * Number of bytes needed to represent and IPV6 value, +     */, +    private static final int IPV6_BYTE_COUNT = 16;, +, +    /**, +     * Maximum amount of value adding characters in between IPV6 separators, +     */, +    private static final int IPV6_MAX_CHAR_BETWEEN_SEPARATOR = 4;, +, +    /**, +     * Minimum number of separators that must be present in an IPv6 string, +     */, +    private static final int IPV6_MIN_SEPARATORS = 2;, +, +    /**, +     * Maximum number of separators that must be present in an IPv6 string, +     */, +    private static final int IPV6_MAX_SEPARATORS = 8;, +, +    /**, +     * Number of bytes needed to represent and IPV4 value, +     */, +    private static final int IPV4_BYTE_COUNT = 4;, +, +    /**, +     * Maximum amount of value adding characters in between IPV4 separators, +     */, +    private static final int IPV4_MAX_CHAR_BETWEEN_SEPARATOR = 3;, +, +    /**, +     * Number of separators that must be present in an IPv4 string, +     */, +    private static final int IPV4_SEPARATORS = 3;, +, +    /**, +            byte[] byteAddress = new byte[IPV4_BYTE_COUNT];, +            for (int i = 0; i < IPV4_BYTE_COUNT; i ++) {, +            byte[] ipByteArray = new byte[IPV6_BYTE_COUNT];, +                convertToBytes(hexStrings.get(i), ipByteArray, i << 1);, +    private static boolean isValidHexChar(char c) {, +    private static boolean isValidNumericChar(char c) {, +        return c >= '0' && c <= '9';, +    }, +, +     * Returns the {@link Inet6Address} representation of a {@link CharSequence} IP address., +     * <p>, +     * This method will treat all IPv4 type addresses as "IPv4 mapped" (see {@link #getByName(CharSequence, boolean)}), +     * @param ip {@link CharSequence} IP address to be converted to a {@link Inet6Address}, +     * @return {@link Inet6Address} representation of the {@code ip} or {@code null} if not a valid IP address., +     */, +    public static Inet6Address getByName(CharSequence ip) {, +        return getByName(ip, true);, +    }, +, +    /**, +     * Returns the {@link Inet6Address} representation of a {@link CharSequence} IP address., +     * <p>, +     * The {@code ipv4Mapped} parameter specifies how IPv4 addresses should be treated., +     * "IPv4 mapped" format as, +     * defined in <a href="http://tools.ietf.org/html/rfc4291#section-2.5.5">rfc 4291 section 2</a> is supported., +     * @param ip {@link CharSequence} IP address to be converted to a {@link Inet6Address}, +     * @param ipv4Mapped, +     * <ul>, +     * <li>{@code true} To allow IPv4 mapped inputs to be translated into {@link Inet6Address}</li>, +     * <li>{@code false} Don't turn IPv4 addressed to mapped addresses</li>, +     * </ul>, +     * @return {@link Inet6Address} representation of the {@code ip} or {@code null} if not a valid IP address., +     */, +    public static Inet6Address getByName(CharSequence ip, boolean ipv4Mapped) {, +        final byte[] bytes = new byte[IPV6_BYTE_COUNT];, +        final int ipLength = ip.length();, +        int compressBegin = 0;, +        int compressLength = 0;, +        int currentIndex = 0;, +        int value = 0;, +        int begin = -1;, +        int i = 0;, +        int ipv6Seperators = 0;, +        int ipv4Seperators = 0;, +        int tmp = 0;, +        boolean needsShift = false;, +        for (; i < ipLength; ++i) {, +            final char c = ip.charAt(i);, +            switch (c) {, +            case ':':, +                ++ipv6Seperators;, +                if (i - begin > IPV6_MAX_CHAR_BETWEEN_SEPARATOR ||, +                        ipv4Seperators > 0 || ipv6Seperators > IPV6_MAX_SEPARATORS ||]