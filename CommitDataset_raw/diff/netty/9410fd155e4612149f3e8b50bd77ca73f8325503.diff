[+++ b/src/main/java/org/jboss/netty/channel/local/LocalChannel.java, +import java.nio.channels.ClosedChannelException;, +import java.nio.channels.NotYetConnectedException;, +import java.util.concurrent.atomic.AtomicBoolean;, +import org.jboss.netty.channel.ChannelFuture;, +    volatile LocalChannel pairedChannel;, +    volatile LocalAddress localAddress;, +    final AtomicBoolean bound = new AtomicBoolean();, +    protected LocalChannel(ChannelFactory factory, ChannelPipeline pipeline, ChannelSink sink, LocalChannel pairedChannel) {, +        this.pairedChannel = pairedChannel;, +        return isOpen() && bound.get();, +        return pairedChannel != null;, +        return isBound()? localAddress : null;, +        LocalChannel pairedChannel = this.pairedChannel;, +        if (pairedChannel == null) {, +        } else {, +            return pairedChannel.getLocalAddress();, +        }, +    void closeNow(ChannelFuture future) {, +        LocalAddress localAddress = this.localAddress;, +        try {, +            // Close the self., +            if (!setClosed()) {, +                future.setSuccess();, +                return;, +            }, +, +            LocalChannel pairedChannel = this.pairedChannel;, +            if (pairedChannel != null) {, +                this.pairedChannel = null;, +                this.localAddress = null;, +                fireChannelDisconnected(this);, +                fireChannelUnbound(this);, +            }, +            fireChannelClosed(this);, +, +            // Close the peer., +            if (!pairedChannel.setClosed()) {, +                return;, +            }, +, +            LocalChannel me = pairedChannel.pairedChannel;, +            if (me != null) {, +                pairedChannel.pairedChannel = null;, +                pairedChannel.localAddress = null;, +                fireChannelDisconnected(pairedChannel);, +                fireChannelUnbound(pairedChannel);, +            }, +            fireChannelClosed(pairedChannel);, +        } finally {, +            if (localAddress != null) {, +                LocalChannelRegistry.unregister(localAddress);, +            }, +        }, +    }, +, +    void flushWriteBuffer() {, +        LocalChannel pairedChannel = this.pairedChannel;, +        if (pairedChannel == null || !pairedChannel.isConnected()) {, +            // Channel is closed or not connected yet - notify as failures., +            Exception cause;, +            if (isOpen()) {, +                cause = new NotYetConnectedException();, +            } else {, +                cause = new ClosedChannelException();, +            }, +, +            for (;;) {, +                MessageEvent e = writeBuffer.poll();, +                if(e == null) {, +                    break;, +                }, +, +                e.getFuture().setFailure(cause);, +                fireExceptionCaught(this, cause);, +            }, +        } else {, +            // Channel is open and connected - trigger events., +}, +++ b/src/main/java/org/jboss/netty/channel/local/LocalChannel.java, +import java.nio.channels.ClosedChannelException;, +import java.nio.channels.NotYetConnectedException;, +import java.util.concurrent.atomic.AtomicBoolean;, +import org.jboss.netty.channel.ChannelFuture;, +    volatile LocalChannel pairedChannel;, +    volatile LocalAddress localAddress;, +    final AtomicBoolean bound = new AtomicBoolean();, +    protected LocalChannel(ChannelFactory factory, ChannelPipeline pipeline, ChannelSink sink, LocalChannel pairedChannel) {, +        this.pairedChannel = pairedChannel;, +        return isOpen() && bound.get();, +        return pairedChannel != null;, +        return isBound()? localAddress : null;, +        LocalChannel pairedChannel = this.pairedChannel;, +        if (pairedChannel == null) {, +        } else {, +            return pairedChannel.getLocalAddress();, +        }, +    void closeNow(ChannelFuture future) {, +        LocalAddress localAddress = this.localAddress;, +        try {]