[+++ b/handler/src/main/java/io/netty/handler/timeout/ReadTimeoutHandler.java, +import io.netty.channel.ChannelBufferHolder;, +import io.netty.channel.ChannelBufferHolders;, +import io.netty.channel.ChannelInboundHandlerAdapter;, +import io.netty.channel.ChannelInboundHandlerContext;, +import io.netty.channel.EventLoop;, +, +import java.nio.channels.Channels;, +import java.util.concurrent.ScheduledFuture;, +import java.util.concurrent.TimeUnit;, +public class ReadTimeoutHandler extends ChannelInboundHandlerAdapter<Object> {, +    private static final ReadTimeoutException EXCEPTION = new ReadTimeoutException();, +    static {, +        EXCEPTION.setStackTrace(new StackTraceElement[0]);, +    }, +, +    private final long timeoutMillis;, +, +    private volatile ScheduledFuture<?> timeout;, +    private volatile long lastReadTime;, +    private volatile boolean destroyed;, +    public ReadTimeoutHandler(int timeoutSeconds) {, +        this(timeoutSeconds, TimeUnit.SECONDS);, +    public ReadTimeoutHandler(long timeout, TimeUnit unit) {, +    public ChannelBufferHolder<Object> newInboundBuffer(, +            ChannelInboundHandlerContext<Object> ctx) throws Exception {, +        return ChannelBufferHolders.inboundBypassBuffer(ctx);, +        if (ctx.channel().isActive()) {, +            // channelActvie() event has been fired already, which means this.channelActive() will, +            // not be invoked. We have to initialize here instead., +            // channelActive() event has not been fired yet.  this.channelOpen() will be invoked, +            // and initialization will occur there., +        destroy();, +    public void channelActive(ChannelInboundHandlerContext<Object> ctx), +        // before channelActive() event is fired.  If a user adds this handler, +        // after the channelActive() event, initialize() will be called by beforeAdd()., +        super.channelActive(ctx);, +    public void channelInactive(ChannelInboundHandlerContext<Object> ctx) throws Exception {, +        destroy();, +        super.channelInactive(ctx);, +    public void inboundBufferUpdated(ChannelInboundHandlerContext<Object> ctx) throws Exception {, +        lastReadTime = System.currentTimeMillis();, +        ctx.fireInboundBufferUpdated();, +        if (destroyed) {, +        EventLoop loop = ctx.eventLoop();, +, +        lastReadTime = System.currentTimeMillis();, +            timeout = loop.schedule(, +                    new ReadTimeoutTask(ctx),, +                    timeoutMillis, TimeUnit.MILLISECONDS);, +    private void destroy() {, +        destroyed = true;, +        if (timeout != null) {, +            timeout.cancel(false);, +            timeout = null;, +        ctx.fireExceptionCaught(EXCEPTION);, +    private final class ReadTimeoutTask implements Runnable {, +        public void run() {, +            long nextDelay = timeoutMillis - (currentTime - lastReadTime);, +                timeout = ctx.eventLoop().schedule(this, timeoutMillis, TimeUnit.MILLISECONDS);, +                    ctx.fireExceptionCaught(t);, +                timeout = ctx.eventLoop().schedule(this, nextDelay, TimeUnit.MILLISECONDS);]