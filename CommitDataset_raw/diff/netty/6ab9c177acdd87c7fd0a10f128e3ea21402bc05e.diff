[+++ b/codec/src/main/java/io/netty/handler/codec/compression/Snappy.java, +        final int shift = Integer.numberOfLeadingZeros(table.length) + 1;, +        return in.getInt(index) * 0x1e35a7bd >>> shift;, +        return new short[htSize];, +++ b/codec/src/main/java/io/netty/handler/codec/compression/Snappy.java, +        final int shift = Integer.numberOfLeadingZeros(table.length) + 1;, +        return in.getInt(index) * 0x1e35a7bd >>> shift;, +        return new short[htSize];, +++ b/codec/src/test/java/io/netty/handler/codec/compression/SnappyTest.java, +import io.netty.util.CharsetUtil;, +, +        in.release();, +        out.release();, +        expected.release();, +, +        in.release();, +        out.release();, +        expected.release();, +        try {, +        } finally {, +            in.release();, +            out.release();, +        }, +        try {, +        } finally {, +            in.release();, +            out.release();, +        }, +        try {, +        } finally {, +            in.release();, +            out.release();, +        }, +, +        in.release();, +        out.release();, +        expected.release();, +    public void encodeAndDecodeLongTextUsesCopy() throws Exception {, +        String srcStr = "Netty has been designed carefully with the experiences " +, +                   "text-based legacy protocols";, +        ByteBuf in = Unpooled.wrappedBuffer(srcStr.getBytes("US-ASCII"));, +        // The only compressibility in the above are the words:, +        // "the ", "rotocols", " of ", "TP, " and "and ". So this is a literal,, +        // followed by a copy followed by another literal, followed by another copy..., +            // copy of "the ", +            0x01, 0x1c, 0x58,, +            0x69, 0x6d, 0x70, 0x6c, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x61,, +            0x74, 0x69, 0x6f, 0x6e, 0x20, 0x6f, 0x66, 0x20, 0x61, 0x20,, +            0x6c, 0x6f, 0x74,, +            // copy of " of ", +            0x01, 0x09, 0x60,, +, +            // literal, +            0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x6f, 0x6c, 0x73, 0x20,, +            0x73, 0x75, 0x63, 0x68, 0x20, 0x61, 0x73, 0x20, 0x46, 0x54,, +            0x50, 0x2c, 0x20, 0x53, 0x4d,, +, +            // copy of " TP, ", +            0x01, 0x06, 0x04,, +, +            // literal, +            0x48, 0x54,, +, +            // copy of " TP, ", +            0x01, 0x06, 0x44,, +, +            // literal, +            0x61, 0x6e, 0x64, 0x20, 0x76, 0x61, 0x72, 0x69, 0x6f, 0x75,, +            0x73, 0x20, 0x62, 0x69, 0x6e, 0x61, 0x72, 0x79,, +, +            // copy of "and ", +            0x05, 0x13, 0x48,, +, +            // literal, +            0x74, 0x65, 0x78, 0x74, 0x2d, 0x62, 0x61, 0x73, 0x65,, +            0x64, 0x20, 0x6c, 0x65, 0x67, 0x61, 0x63, 0x79, 0x20, 0x70,, +, +            // copy of "rotocols", +            0x11, 0x4c,, +, +        // Decode, +        ByteBuf outDecoded = Unpooled.buffer();, +        snappy.decode(out, outDecoded);, +        assertEquals(srcStr, outDecoded.getCharSequence(0, outDecoded.writerIndex(), CharsetUtil.US_ASCII));, +, +        in.release();, +        out.release();, +        outDecoded.release();, +        input.release();, +        input.release();, +        try {, +        } finally {, +            input.release();, +        }, +        int[] lengths = {, +                encodeLiteral(in, encoded, len);, +                decodeLiteral(tag, encoded, decoded);]