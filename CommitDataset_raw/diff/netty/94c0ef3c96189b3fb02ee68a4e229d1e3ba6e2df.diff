[+++ b/transport/src/main/java/io/netty/channel/pool/SimpleChannelPool.java, +        } else { //channel not healthy, just releasing it., +            promise.setSuccess(null);, +++ b/transport/src/main/java/io/netty/channel/pool/SimpleChannelPool.java, +        } else { //channel not healthy, just releasing it., +            promise.setSuccess(null);, +++ b/transport/src/test/java/io/netty/channel/pool/FixedChannelPoolTest.java, +import org.junit.AfterClass;, +import org.junit.BeforeClass;, +    private static EventLoopGroup group;, +, +    @BeforeClass, +    public static void createEventLoop() {, +        group = new LocalEventLoopGroup();, +    }, +, +    @AfterClass, +    public static void destroyEventLoop() {, +        if (group != null) {, +            group.shutdownGracefully();, +        }, +    }, +, +    @Test, +    public void testReleaseClosed() {, +        LocalAddress addr = new LocalAddress(LOCAL_ADDR_ID);, +        Bootstrap cb = new Bootstrap();, +        cb.remoteAddress(addr);, +        cb.group(group).channel(LocalChannel.class);, +, +        ServerBootstrap sb = new ServerBootstrap();, +        sb.group(group), +                .channel(LocalServerChannel.class), +                .childHandler(new ChannelInitializer<LocalChannel>() {, +                    @Override, +                    public void initChannel(LocalChannel ch) throws Exception {, +                        ch.pipeline().addLast(new ChannelInboundHandlerAdapter());, +                    }, +                });, +, +        // Start server, +        Channel sc = sb.bind(addr).syncUninterruptibly().channel();, +, +        FixedChannelPool pool = new FixedChannelPool(cb, new TestChannelPoolHandler(), 2);, +        Channel channel = pool.acquire().syncUninterruptibly().getNow();, +        channel.close().syncUninterruptibly();, +        pool.release(channel).syncUninterruptibly();, +, +        sc.close().syncUninterruptibly();, +    }, +, +++ b/transport/src/main/java/io/netty/channel/pool/SimpleChannelPool.java, +        } else { //channel not healthy, just releasing it., +            promise.setSuccess(null);, +++ b/transport/src/test/java/io/netty/channel/pool/FixedChannelPoolTest.java, +import org.junit.AfterClass;, +import org.junit.BeforeClass;, +    private static EventLoopGroup group;, +, +    @BeforeClass, +    public static void createEventLoop() {, +        group = new LocalEventLoopGroup();, +    }, +, +    @AfterClass, +    public static void destroyEventLoop() {, +        if (group != null) {, +            group.shutdownGracefully();, +        }, +    }, +, +    @Test, +    public void testReleaseClosed() {, +        LocalAddress addr = new LocalAddress(LOCAL_ADDR_ID);, +        Bootstrap cb = new Bootstrap();, +        cb.remoteAddress(addr);, +        cb.group(group).channel(LocalChannel.class);, +, +        ServerBootstrap sb = new ServerBootstrap();, +        sb.group(group), +                .channel(LocalServerChannel.class), +                .childHandler(new ChannelInitializer<LocalChannel>() {, +                    @Override, +                    public void initChannel(LocalChannel ch) throws Exception {, +                        ch.pipeline().addLast(new ChannelInboundHandlerAdapter());, +                    }, +                });, +, +        // Start server, +        Channel sc = sb.bind(addr).syncUninterruptibly().channel();, +, +        FixedChannelPool pool = new FixedChannelPool(cb, new TestChannelPoolHandler(), 2);, +        Channel channel = pool.acquire().syncUninterruptibly().getNow();, +        channel.close().syncUninterruptibly();, +        pool.release(channel).syncUninterruptibly();, +, +        sc.close().syncUninterruptibly();, +    }, +, +++ b/transport/src/test/java/io/netty/channel/pool/SimpleChannelPoolTest.java]