[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2MultiplexCodec.java, +                    promise.setFailure(wrapStreamClosedError(cause));, +                    promise.setFailure(error);, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2MultiplexCodec.java, +                    promise.setFailure(wrapStreamClosedError(cause));, +                    promise.setFailure(error);, +++ b/codec-http2/src/test/java/io/netty/handler/codec/http2/Http2MultiplexCodecTest.java, +import java.util.ArrayDeque;, +import java.util.Queue;, +import io.netty.util.ReferenceCountUtil;, +        assertFalse(channelActive.get());, +        assertFalse(channelActive.get());, +        assertFalse(childChannel.isActive());, +    }, +, +    @Test, +    public void channelClosedWhenWriteFutureFails() {, +        final Queue<ChannelPromise> writePromises = new ArrayDeque<ChannelPromise>();, +        writer = new Writer() {, +            @Override, +            void write(Object msg, ChannelPromise promise) {, +                ReferenceCountUtil.release(msg);, +                writePromises.offer(promise);, +            }, +        };, +, +        LastInboundHandler inboundHandler = streamActiveAndWriteHeaders(inboundStream);, +        Http2StreamChannel childChannel = (Http2StreamChannel) inboundHandler.channel();, +, +        assertTrue(childChannel.isOpen());, +        assertTrue(childChannel.isActive());, +, +        final AtomicBoolean channelOpen = new AtomicBoolean(true);, +        final AtomicBoolean channelActive = new AtomicBoolean(true);, +, +        ChannelFuture f = childChannel.writeAndFlush(new DefaultHttp2HeadersFrame(new DefaultHttp2Headers()));, +        assertFalse(f.isDone());, +        f.addListener(new ChannelFutureListener() {, +            @Override, +            public void operationComplete(ChannelFuture future) throws Exception {, +                channelOpen.set(future.channel().isOpen());, +                channelActive.set(future.channel().isActive());, +            }, +        });, +, +        ChannelPromise first = writePromises.poll();, +        first.setFailure(new ClosedChannelException());, +        f.awaitUninterruptibly();, +, +        assertFalse(channelOpen.get());, +        assertFalse(channelActive.get());]