[+++ b/testsuite/src/main/java/io/netty/testsuite/transport/socket/AbstractSocketShutdownOutputByPeerTest.java, +/*, + * Copyright 2019 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + *   http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the, + * License for the specific language governing permissions and limitations, + * under the License., + */, +package io.netty.testsuite.transport.socket;, +, +import io.netty.bootstrap.ServerBootstrap;, +import io.netty.buffer.ByteBuf;, +import io.netty.channel.Channel;, +import io.netty.channel.ChannelHandlerContext;, +import io.netty.channel.ChannelOption;, +import io.netty.channel.SimpleChannelInboundHandler;, +import io.netty.channel.socket.ChannelInputShutdownEvent;, +import io.netty.channel.socket.DuplexChannel;, +import org.junit.Test;, +, +import java.io.IOException;, +import java.net.SocketAddress;, +import java.util.concurrent.BlockingQueue;, +import java.util.concurrent.CountDownLatch;, +import java.util.concurrent.LinkedBlockingQueue;, +import java.util.concurrent.atomic.AtomicInteger;, +, +import static org.junit.Assert.*;, +, +public abstract class AbstractSocketShutdownOutputByPeerTest<Socket> extends AbstractServerSocketTest {, +, +    @Test(timeout = 30000), +    public void testShutdownOutput() throws Throwable {, +        run();, +    }, +, +    public void testShutdownOutput(ServerBootstrap sb) throws Throwable {, +        TestHandler h = new TestHandler();, +        Socket s = newSocket();, +        Channel sc = null;, +        try {, +            sc = sb.childHandler(h).childOption(ChannelOption.ALLOW_HALF_CLOSURE, true).bind().sync().channel();, +, +            connect(s, sc.localAddress());, +            write(s, 1);, +, +            assertEquals(1, (int) h.queue.take());, +, +            assertTrue(h.ch.isOpen());, +            assertTrue(h.ch.isActive());, +            assertFalse(h.ch.isInputShutdown());, +            assertFalse(h.ch.isOutputShutdown());, +, +            shutdownOutput(s);, +, +            h.halfClosure.await();, +, +            assertTrue(h.ch.isOpen());, +            assertTrue(h.ch.isActive());, +            assertTrue(h.ch.isInputShutdown());, +            assertFalse(h.ch.isOutputShutdown());, +, +            while (h.closure.getCount() != 1 && h.halfClosureCount.intValue() != 1) {, +                Thread.sleep(100);, +            }, +        } finally {, +            if (sc != null) {, +                sc.close();, +            }, +            close(s);, +        }, +    }, +, +    @Test(timeout = 30000), +    public void testShutdownOutputWithoutOption() throws Throwable {, +        run();, +    }, +, +    public void testShutdownOutputWithoutOption(ServerBootstrap sb) throws Throwable {, +        TestHandler h = new TestHandler();, +        Socket s = newSocket();, +        Channel sc = null;, +        try {, +            sc = sb.childHandler(h).bind().sync().channel();, +, +            connect(s, sc.localAddress());, +            write(s, 1);, +, +            assertEquals(1, (int) h.queue.take());, +, +            assertTrue(h.ch.isOpen());, +            assertTrue(h.ch.isActive());]