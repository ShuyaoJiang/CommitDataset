[+++ b/handler/src/main/java/io/netty/handler/ssl/SniHandler.java, +    // Maximal number of ssl records to inspect before fallback to the default SslContext., +    private static final int MAX_SSL_RECORDS = 4;, +, +    private static final Selection EMPTY_SELECTION = new Selection(null, null);, +    private boolean handshakeFailed;, +, +    private volatile Selection selection = EMPTY_SELECTION;, +        return selection.hostname;, +        return selection.context;, +        if (!handshakeFailed && in.readableBytes() >= SslUtils.SSL_RECORD_HEADER_LENGTH) {, +            int writerIndex = in.writerIndex();, +                loop: for (int i = 0; i < MAX_SSL_RECORDS; i++) {, +                        case SslUtils.SSL_CONTENT_TYPE_CHANGE_CIPHER_SPEC:, +                        case SslUtils.SSL_CONTENT_TYPE_ALERT:, +                            int len = SslUtils.getEncryptedPacketLength(in, readerIndex);, +                            // Not an SSL/TLS packet, +                            if (len == -1) {, +                                handshakeFailed = true;, +                                NotSslRecordException e = new NotSslRecordException(, +                                        "not an SSL/TLS record: " + ByteBufUtil.hexDump(in));, +                                in.skipBytes(in.readableBytes());, +                                ctx.fireExceptionCaught(e);, +, +                                SslUtils.notifyHandshakeFailure(ctx, e);, +                                return;, +                            }, +                            if (writerIndex - readerIndex - SslUtils.SSL_RECORD_HEADER_LENGTH < len) {, +                                // Not enough data, +                                return;, +                            }, +                            // increase readerIndex and try again., +                            readerIndex += len;, +                            continue;, +                        case SslUtils.SSL_CONTENT_TYPE_HANDSHAKE:, +                                int packetLength = in.getUnsignedShort(readerIndex + 3), +                                        + SslUtils.SSL_RECORD_HEADER_LENGTH;, +                                if (in.readableBytes() < packetLength) {, +                                    // client hello incomplete try again to decode once more data is ready., +                                    return;, +                                }, +                                // See https://tools.ietf.org/html/rfc5246#section-7.4.1.2, +                                //, +                                // Decode the ssl client hello packet., +                                // We have to skip bytes until SessionID (which sum to 43 bytes)., +                                //, +                                // struct {, +                                //    ProtocolVersion client_version;, +                                //    Random random;, +                                //    SessionID session_id;, +                                //    CipherSuite cipher_suites<2..2^16-2>;, +                                //    CompressionMethod compression_methods<1..2^8-1>;, +                                //    select (extensions_present) {, +                                //        case false:, +                                //            struct {};, +                                //        case true:, +                                //            Extension extensions<0..2^16-1>;, +                                //    };, +                                // } ClientHello;, +                                //, +                                    // See https://tools.ietf.org/html/rfc6066#page-6, +                                            String hostname = in.toString(offset + 5, serverNameLength,, +                                            select(ctx, IDN.toASCII(hostname,, +                                                    IDN.ALLOW_UNASSIGNED).toLowerCase(Locale.US));, +                                            return;, +                                            break loop;, +                            // Fall-through, +                        default:, +                            //not tls, ssl or application data, do not try sni, +                            break loop;, +                    }, +            }, +            // Just select the default SslContext, +            select(ctx, null);, +        }, +    }, +, +    private void select(ChannelHandlerContext ctx, String hostname) {, +        SslContext selectedContext = mapping.map(hostname);, +        selection = new Selection(selectedContext, hostname);, +        SslHandler sslHandler = selectedContext.newHandler(ctx.alloc());, +        ctx.pipeline().replace(this, SslHandler.class.getName(), sslHandler);, +    }, +, +    private static final class Selection {, +        final SslContext context;, +        final String hostname;, +, +        Selection(SslContext context, String hostname) {, +            this.context = context;, +            this.hostname = hostname;, +++ b/handler/src/main/java/io/netty/handler/ssl/SniHandler.java, +    // Maximal number of ssl records to inspect before fallback to the default SslContext., +    private static final int MAX_SSL_RECORDS = 4;, +, +    private static final Selection EMPTY_SELECTION = new Selection(null, null);, +    private boolean handshakeFailed;, +, +    private volatile Selection selection = EMPTY_SELECTION;, +        return selection.hostname;]