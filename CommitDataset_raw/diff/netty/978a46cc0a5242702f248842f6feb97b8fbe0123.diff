[+++ b/handler/src/main/java/io/netty/handler/ssl/SslHandler.java, +            // We should attempt to notify the handshake failure before writing any pending data. If we are in unwrap, +            // and failed during the handshake process, and we attempt to wrap, then promises will fail, and if, +            // listeners immediately close the Channel then we may end up firing the handshake event after the Channel, +            // has been closed., +            if (handshakePromise.tryFailure(cause)) {, +                ctx.fireUserEventTriggered(new SslHandshakeCompletionEvent(cause));, +            }, +, +            setHandshakeFailure(ctx, cause, true, false);, +++ b/handler/src/main/java/io/netty/handler/ssl/SslHandler.java, +            // We should attempt to notify the handshake failure before writing any pending data. If we are in unwrap, +            // and failed during the handshake process, and we attempt to wrap, then promises will fail, and if, +            // listeners immediately close the Channel then we may end up firing the handshake event after the Channel, +            // has been closed., +            if (handshakePromise.tryFailure(cause)) {, +                ctx.fireUserEventTriggered(new SslHandshakeCompletionEvent(cause));, +            }, +, +            setHandshakeFailure(ctx, cause, true, false);, +++ b/handler/src/test/java/io/netty/handler/ssl/SslHandlerTest.java, +import io.netty.channel.ChannelFuture;, +import io.netty.channel.ChannelFutureListener;, +import io.netty.channel.DefaultEventLoopGroup;, +import io.netty.channel.local.LocalAddress;, +import io.netty.channel.local.LocalChannel;, +import io.netty.channel.local.LocalServerChannel;, +    @Test(timeout = 5000), +    public void testHandshakeFailBeforeWritePromise() throws Exception {, +        SelfSignedCertificate ssc = new SelfSignedCertificate();, +        final SslContext sslServerCtx = SslContextBuilder.forServer(ssc.certificate(), ssc.privateKey()).build();, +        final CountDownLatch latch = new CountDownLatch(2);, +        final CountDownLatch latch2 = new CountDownLatch(2);, +        final BlockingQueue<Object> events = new LinkedBlockingQueue<Object>();, +        Channel serverChannel = null;, +        Channel clientChannel = null;, +        EventLoopGroup group = new DefaultEventLoopGroup();, +        try {, +            ServerBootstrap sb = new ServerBootstrap();, +            sb.group(group), +                .channel(LocalServerChannel.class), +                .childHandler(new ChannelInitializer<Channel>() {, +                  @Override, +                  protected void initChannel(Channel ch) {, +                      ch.pipeline().addLast(sslServerCtx.newHandler(ch.alloc()));, +                      ch.pipeline().addLast(new ChannelInboundHandlerAdapter() {, +                          @Override, +                          public void channelActive(ChannelHandlerContext ctx) {, +                              ByteBuf buf = ctx.alloc().buffer(10);, +                              buf.writeZero(buf.capacity());, +                              ctx.writeAndFlush(buf).addListener(new ChannelFutureListener() {, +                                  @Override, +                                  public void operationComplete(ChannelFuture future) {, +                                      events.add(future);, +                                      latch.countDown();, +                                  }, +                              });, +                          }, +, +                          @Override, +                          public void userEventTriggered(ChannelHandlerContext ctx, Object evt) {, +                              if (evt instanceof SslCompletionEvent) {, +                                  events.add(evt);, +                                  latch.countDown();, +                                  latch2.countDown();, +                              }, +                          }, +                      });, +                  }, +                });, +, +            Bootstrap cb = new Bootstrap();, +            cb.group(group), +                .channel(LocalChannel.class), +                .handler(new ChannelInitializer<Channel>() {, +                    @Override, +                    protected void initChannel(Channel ch) {, +                        ch.pipeline().addFirst(new ChannelInboundHandlerAdapter() {, +                            @Override, +                            public void channelActive(ChannelHandlerContext ctx) {, +                                ByteBuf buf = ctx.alloc().buffer(1000);, +                                buf.writeZero(buf.capacity());, +                                ctx.writeAndFlush(buf);, +                            }, +                        });, +                    }, +                });, +, +            serverChannel = sb.bind(new LocalAddress("SslHandlerTest")).sync().channel();, +            clientChannel = cb.connect(serverChannel.localAddress()).sync().channel();, +            latch.await();, +, +            SslCompletionEvent evt = (SslCompletionEvent) events.take();, +            assertTrue(evt instanceof SslHandshakeCompletionEvent);, +            assertThat(evt.cause(), is(instanceOf(SSLException.class)));, +, +            ChannelFuture future = (ChannelFuture) events.take();, +            assertThat(future.cause(), is(instanceOf(SSLException.class)));, +, +            serverChannel.close().sync();]