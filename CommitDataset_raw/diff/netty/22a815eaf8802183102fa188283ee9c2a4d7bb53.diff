[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpClientCodec.java, +            if (msg instanceof HttpRequest && !done) {, +                return super.decode(ctx, channel, buffer, state);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpClientCodec.java, +            if (msg instanceof HttpRequest && !done) {, +                return super.decode(ctx, channel, buffer, state);, +++ /dev/null, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpClientCodec.java, +            if (msg instanceof HttpRequest && !done) {, +                return super.decode(ctx, channel, buffer, state);, +++ /dev/null, +++ /dev/null, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpClientCodec.java, +            if (msg instanceof HttpRequest && !done) {, +                return super.decode(ctx, channel, buffer, state);, +++ /dev/null, +++ /dev/null, +++ b/common/src/main/java/io/netty/util/Attribute.java, +package io.netty.util;, +, +public interface Attribute<T> {, +    T get();, +    void set(T value);, +    T getAndSet(T value);, +    T setIfAbsent(T value);, +    boolean compareAndSet(T oldValue, T newValue);, +    void remove();, +}, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpClientCodec.java, +            if (msg instanceof HttpRequest && !done) {, +                return super.decode(ctx, channel, buffer, state);, +++ /dev/null, +++ /dev/null, +++ b/common/src/main/java/io/netty/util/Attribute.java, +package io.netty.util;, +, +public interface Attribute<T> {, +    T get();, +    void set(T value);, +    T getAndSet(T value);, +    T setIfAbsent(T value);, +    boolean compareAndSet(T oldValue, T newValue);, +    void remove();, +}, +++ b/common/src/main/java/io/netty/util/AttributeKey.java, +package io.netty.util;, +, +import java.io.Serializable;, +import java.util.concurrent.ConcurrentHashMap;, +import java.util.concurrent.ConcurrentMap;, +, +public final class AttributeKey<T> implements Serializable, Comparable<AttributeKey<T>> {, +, +    private static final long serialVersionUID = 2783354860083517323L;, +, +    private static final ConcurrentMap<String, Boolean> names = new ConcurrentHashMap<String, Boolean>();, +, +    private final String name;, +    private final Class<T> valueType;, +, +    public AttributeKey(String name, Class<T> valueType) {, +        if (name == null) {, +            throw new NullPointerException("name");, +        }, +        if (valueType == null) {, +            throw new NullPointerException("valueType");, +        }, +, +        if (names.putIfAbsent(name, Boolean.TRUE) != null) {, +            throw new IllegalArgumentException("key name already in use: " + name);, +        }, +, +        this.name = name;, +        this.valueType = valueType;, +    }, +, +    public String name() {, +        return name;, +    }, +, +    public Class<T> valueType() {, +        return valueType;, +    }, +, +    @Override, +    public int hashCode() {, +        return System.identityHashCode(this);, +    }, +, +    @Override, +    public boolean equals(Object o) {, +        return this == o;, +    }, +, +    @Override, +    public int compareTo(AttributeKey<T> o) {, +        return name().compareTo(o.name());, +    }, +, +    @Override]