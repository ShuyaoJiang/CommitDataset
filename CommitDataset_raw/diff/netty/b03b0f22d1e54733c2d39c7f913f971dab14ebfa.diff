[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/HttpPostBodyUtil.java, +        /**, +         * @param buffer buffer with a backing byte array, +         */, +        SeekAheadOptimize(ByteBuf buffer) {, +                throw new IllegalArgumentException("buffer hasn't backing byte array");, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/HttpPostBodyUtil.java, +        /**, +         * @param buffer buffer with a backing byte array, +         */, +        SeekAheadOptimize(ByteBuf buffer) {, +                throw new IllegalArgumentException("buffer hasn't backing byte array");, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/HttpPostMultipartRequestDecoder.java, +import static io.netty.util.internal.ObjectUtil.*;, +        this.request = checkNotNull(request, "request");, +        this.charset = checkNotNull(charset, "charset");, +        this.factory = checkNotNull(factory, "factory");, +        this.discardThreshold = checkPositiveOrZero(discardThreshold, "discardThreshold");, +                loadFieldMultipart(undecodedChunk, multipartDataBoundary, currentAttribute);, +    private static void skipControlCharacters(ByteBuf undecodedChunk) {, +        if (!undecodedChunk.hasArray()) {, +                skipControlCharactersStandard(undecodedChunk);, +        SeekAheadOptimize sao = new SeekAheadOptimize(undecodedChunk);, +    private static void skipControlCharactersStandard(ByteBuf undecodedChunk) {, +            skipControlCharacters(undecodedChunk);, +            newline = readDelimiter(undecodedChunk, delimiter);, +                skipControlCharacters(undecodedChunk);, +                newline = readLine(undecodedChunk, charset);, +            readFileUploadByteMultipart(undecodedChunk, delimiter, currentFileUpload);, +    private static String readLineStandard(ByteBuf undecodedChunk, Charset charset) {, +    private static String readLine(ByteBuf undecodedChunk, Charset charset) {, +        if (!undecodedChunk.hasArray()) {, +            return readLineStandard(undecodedChunk, charset);, +        SeekAheadOptimize sao = new SeekAheadOptimize(undecodedChunk);, +    private static String readDelimiterStandard(ByteBuf undecodedChunk, String delimiter) {, +    private static String readDelimiter(ByteBuf undecodedChunk, String delimiter) {, +        if (!undecodedChunk.hasArray()) {, +            return readDelimiterStandard(undecodedChunk, delimiter);, +        SeekAheadOptimize sao = new SeekAheadOptimize(undecodedChunk);, +    private static void readFileUploadByteMultipartStandard(ByteBuf undecodedChunk, String delimiter,, +                                                            FileUpload currentFileUpload) {, +    private static void readFileUploadByteMultipart(ByteBuf undecodedChunk, String delimiter,, +                                                    FileUpload currentFileUpload) {, +        if (!undecodedChunk.hasArray()) {, +            readFileUploadByteMultipartStandard(undecodedChunk, delimiter, currentFileUpload);, +        SeekAheadOptimize sao = new SeekAheadOptimize(undecodedChunk);, +    private static void loadFieldMultipartStandard(ByteBuf undecodedChunk, String delimiter,, +                                                   Attribute currentAttribute) {, +    private static void loadFieldMultipart(ByteBuf undecodedChunk, String delimiter, Attribute currentAttribute) {, +        if (!undecodedChunk.hasArray()) {, +            loadFieldMultipartStandard(undecodedChunk, delimiter, currentAttribute);, +        SeekAheadOptimize sao = new SeekAheadOptimize(undecodedChunk);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/HttpPostBodyUtil.java, +        /**, +         * @param buffer buffer with a backing byte array, +         */, +        SeekAheadOptimize(ByteBuf buffer) {, +                throw new IllegalArgumentException("buffer hasn't backing byte array");, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/HttpPostMultipartRequestDecoder.java, +import static io.netty.util.internal.ObjectUtil.*;, +        this.request = checkNotNull(request, "request");, +        this.charset = checkNotNull(charset, "charset");, +        this.factory = checkNotNull(factory, "factory");, +        this.discardThreshold = checkPositiveOrZero(discardThreshold, "discardThreshold");, +                loadFieldMultipart(undecodedChunk, multipartDataBoundary, currentAttribute);, +    private static void skipControlCharacters(ByteBuf undecodedChunk) {, +        if (!undecodedChunk.hasArray()) {, +                skipControlCharactersStandard(undecodedChunk);, +        SeekAheadOptimize sao = new SeekAheadOptimize(undecodedChunk);, +    private static void skipControlCharactersStandard(ByteBuf undecodedChunk) {, +            skipControlCharacters(undecodedChunk);, +            newline = readDelimiter(undecodedChunk, delimiter);, +                skipControlCharacters(undecodedChunk);, +                newline = readLine(undecodedChunk, charset);, +            readFileUploadByteMultipart(undecodedChunk, delimiter, currentFileUpload);, +    private static String readLineStandard(ByteBuf undecodedChunk, Charset charset) {, +    private static String readLine(ByteBuf undecodedChunk, Charset charset) {, +        if (!undecodedChunk.hasArray()) {, +            return readLineStandard(undecodedChunk, charset);, +        SeekAheadOptimize sao = new SeekAheadOptimize(undecodedChunk);, +    private static String readDelimiterStandard(ByteBuf undecodedChunk, String delimiter) {, +    private static String readDelimiter(ByteBuf undecodedChunk, String delimiter) {, +        if (!undecodedChunk.hasArray()) {, +            return readDelimiterStandard(undecodedChunk, delimiter);, +        SeekAheadOptimize sao = new SeekAheadOptimize(undecodedChunk);, +    private static void readFileUploadByteMultipartStandard(ByteBuf undecodedChunk, String delimiter,, +                                                            FileUpload currentFileUpload) {, +    private static void readFileUploadByteMultipart(ByteBuf undecodedChunk, String delimiter,, +                                                    FileUpload currentFileUpload) {, +        if (!undecodedChunk.hasArray()) {, +            readFileUploadByteMultipartStandard(undecodedChunk, delimiter, currentFileUpload);, +        SeekAheadOptimize sao = new SeekAheadOptimize(undecodedChunk);, +    private static void loadFieldMultipartStandard(ByteBuf undecodedChunk, String delimiter,, +                                                   Attribute currentAttribute) {, +    private static void loadFieldMultipart(ByteBuf undecodedChunk, String delimiter, Attribute currentAttribute) {, +        if (!undecodedChunk.hasArray()) {, +            loadFieldMultipartStandard(undecodedChunk, delimiter, currentAttribute);, +        SeekAheadOptimize sao = new SeekAheadOptimize(undecodedChunk);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/HttpPostStandardRequestDecoder.java, +import static io.netty.util.internal.ObjectUtil.*;]