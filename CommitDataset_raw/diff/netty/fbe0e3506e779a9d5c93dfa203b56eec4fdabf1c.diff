[+++ b/handler/src/main/java/io/netty/handler/ssl/ReferenceCountedOpenSslEngine.java, +import static io.netty.handler.ssl.SslUtils.SSL_RECORD_HEADER_LENGTH;, +import static io.netty.internal.tcnative.SSL.SSL_MAX_PLAINTEXT_LENGTH;, +import static io.netty.internal.tcnative.SSL.SSL_MAX_RECORD_LENGTH;, +import static io.netty.util.internal.EmptyArrays.EMPTY_CERTIFICATES;, +import static io.netty.util.internal.EmptyArrays.EMPTY_JAVAX_X509_CERTIFICATES;, +import static io.netty.util.internal.ObjectUtil.checkNotNull;, +    static final int MAX_PLAINTEXT_LENGTH = SSL_MAX_PLAINTEXT_LENGTH;, +    /**, +     * Depends upon tcnative ... only use if tcnative is available!, +     */, +    private static final int MAX_RECORD_SIZE = SSL_MAX_RECORD_LENGTH;, +                if (len < SSL_RECORD_HEADER_LENGTH) {, +                final int packetLengthDataOnly = packetLength - SSL_RECORD_HEADER_LENGTH;, +                if (packetLengthDataOnly > capacity) {, +                    // Not enough space in the destination buffer so signal the caller that the buffer needs to be, +                    // increased., +                    if (packetLengthDataOnly > MAX_RECORD_SIZE) {, +                        // The packet length MUST NOT exceed 2^14 [1]. However we do accommodate more data to support, +                        // legacy use cases which may violate this condition (e.g. OpenJDK's SslEngineImpl). If the max, +                        // length is exceeded we fail fast here to avoid an infinite loop due to the fact that we, +                        // won't allocate a buffer large enough., +                        // [1] https://tools.ietf.org/html/rfc5246#section-6.2.1, +                        throw new SSLException("Illegal packet length: " + packetLengthDataOnly + " > " +, +                                                session.getApplicationBufferSize());, +                    } else {, +                        session.tryExpandApplicationBufferSize(packetLengthDataOnly);, +                    }, +                    // We either don't have enough data to read the packet length or not enough for reading the whole, +                    // packet., +                            // We are directly using the ByteBuffer memory for the write, and so we only know what has, +                            // been consumed after we let SSL decrypt the data. At this point we should update the, +                            // number of bytes consumed, update the ByteBuffer position, and release temp ByteBuf., +                                } else if (packetLength == 0 || jdkCompatibilityMode) {, +                                    // We either consumed all data or we are in jdkCompatibilityMode and have consumed, +                                    // a single TLS packet and should stop consuming until this method is called again., +        private volatile int applicationBufferSize = MAX_PLAINTEXT_LENGTH;, +            return applicationBufferSize;, +        }, +, +        /**, +         * Expand (or increase) the value returned by {@link #getApplicationBufferSize()} if necessary., +         * <p>, +         * This is only called in a synchronized block, so no need to use atomic operations., +         * @param packetLengthDataOnly The packet size which exceeds the current {@link #getApplicationBufferSize()}., +         */, +        void tryExpandApplicationBufferSize(int packetLengthDataOnly) {, +            if (packetLengthDataOnly > MAX_PLAINTEXT_LENGTH && applicationBufferSize != MAX_RECORD_SIZE) {, +                applicationBufferSize = MAX_RECORD_SIZE;, +            }, +++ b/handler/src/main/java/io/netty/handler/ssl/ReferenceCountedOpenSslEngine.java, +import static io.netty.handler.ssl.SslUtils.SSL_RECORD_HEADER_LENGTH;, +import static io.netty.internal.tcnative.SSL.SSL_MAX_PLAINTEXT_LENGTH;, +import static io.netty.internal.tcnative.SSL.SSL_MAX_RECORD_LENGTH;, +import static io.netty.util.internal.EmptyArrays.EMPTY_CERTIFICATES;, +import static io.netty.util.internal.EmptyArrays.EMPTY_JAVAX_X509_CERTIFICATES;, +import static io.netty.util.internal.ObjectUtil.checkNotNull;, +    static final int MAX_PLAINTEXT_LENGTH = SSL_MAX_PLAINTEXT_LENGTH;, +    /**, +     * Depends upon tcnative ... only use if tcnative is available!, +     */, +    private static final int MAX_RECORD_SIZE = SSL_MAX_RECORD_LENGTH;, +                if (len < SSL_RECORD_HEADER_LENGTH) {, +                final int packetLengthDataOnly = packetLength - SSL_RECORD_HEADER_LENGTH;, +                if (packetLengthDataOnly > capacity) {, +                    // Not enough space in the destination buffer so signal the caller that the buffer needs to be, +                    // increased., +                    if (packetLengthDataOnly > MAX_RECORD_SIZE) {, +                        // The packet length MUST NOT exceed 2^14 [1]. However we do accommodate more data to support, +                        // legacy use cases which may violate this condition (e.g. OpenJDK's SslEngineImpl). If the max, +                        // length is exceeded we fail fast here to avoid an infinite loop due to the fact that we, +                        // won't allocate a buffer large enough., +                        // [1] https://tools.ietf.org/html/rfc5246#section-6.2.1, +                        throw new SSLException("Illegal packet length: " + packetLengthDataOnly + " > " +, +                                                session.getApplicationBufferSize());, +                    } else {, +                        session.tryExpandApplicationBufferSize(packetLengthDataOnly);, +                    }, +                    // We either don't have enough data to read the packet length or not enough for reading the whole, +                    // packet., +                            // We are directly using the ByteBuffer memory for the write, and so we only know what has, +                            // been consumed after we let SSL decrypt the data. At this point we should update the, +                            // number of bytes consumed, update the ByteBuffer position, and release temp ByteBuf., +                                } else if (packetLength == 0 || jdkCompatibilityMode) {, +                                    // We either consumed all data or we are in jdkCompatibilityMode and have consumed, +                                    // a single TLS packet and should stop consuming until this method is called again., +        private volatile int applicationBufferSize = MAX_PLAINTEXT_LENGTH;, +            return applicationBufferSize;, +        }, +, +        /**, +         * Expand (or increase) the value returned by {@link #getApplicationBufferSize()} if necessary., +         * <p>, +         * This is only called in a synchronized block, so no need to use atomic operations., +         * @param packetLengthDataOnly The packet size which exceeds the current {@link #getApplicationBufferSize()}., +         */, +        void tryExpandApplicationBufferSize(int packetLengthDataOnly) {, +            if (packetLengthDataOnly > MAX_PLAINTEXT_LENGTH && applicationBufferSize != MAX_RECORD_SIZE) {, +                applicationBufferSize = MAX_RECORD_SIZE;, +            }]