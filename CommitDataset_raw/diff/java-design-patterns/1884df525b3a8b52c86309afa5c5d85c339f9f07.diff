[+++ b/async-method-invocation/pom.xml, +    <dependency>, +      <groupId>org.mockito</groupId>, +      <artifactId>mockito-core</artifactId>, +      <scope>test</scope>, +    </dependency>, +++ b/async-method-invocation/pom.xml, +    <dependency>, +      <groupId>org.mockito</groupId>, +      <artifactId>mockito-core</artifactId>, +      <scope>test</scope>, +    </dependency>, +++ b/async-method-invocation/src/test/java/com/iluwatar/async/method/invocation/ThreadAsyncExecutorTest.java, +package com.iluwatar.async.method.invocation;, +, +import org.junit.Test;, +import org.mockito.ArgumentCaptor;, +import org.mockito.Matchers;, +, +import java.util.Optional;, +import java.util.concurrent.Callable;, +import java.util.concurrent.ExecutionException;, +, +import static org.junit.Assert.assertEquals;, +import static org.junit.Assert.assertFalse;, +import static org.junit.Assert.assertNotNull;, +import static org.junit.Assert.assertSame;, +import static org.junit.Assert.assertTrue;, +import static org.junit.Assert.fail;, +import static org.mockito.Matchers.eq;, +import static org.mockito.Mockito.mock;, +import static org.mockito.Mockito.timeout;, +import static org.mockito.Mockito.verify;, +import static org.mockito.Mockito.verifyNoMoreInteractions;, +import static org.mockito.Mockito.verifyZeroInteractions;, +import static org.mockito.Mockito.when;, +import static org.mockito.internal.verification.VerificationModeFactory.times;, +, +/**, + * Date: 12/6/15 - 10:49 AM, + *, + * @author Jeroen Meulemeester, + */, +public class ThreadAsyncExecutorTest {, +, +	/**, +	 * Test used to verify the happy path of {@link ThreadAsyncExecutor#startProcess(Callable)}, +	 */, +	@Test(timeout = 3000), +	public void testSuccessfulTaskWithoutCallback() throws Exception {, +		// Instantiate a new executor and start a new 'null' task ..., +		final ThreadAsyncExecutor executor = new ThreadAsyncExecutor();, +, +		final Object result = new Object();, +		final Callable<Object> task = mock(Callable.class);, +		when(task.call()).thenReturn(result);, +, +		final AsyncResult<Object> asyncResult = executor.startProcess(task);, +		assertNotNull(asyncResult);, +		asyncResult.await(); // Prevent timing issues, and wait until the result is available, +		assertTrue(asyncResult.isCompleted());, +, +		// Our task should only execute once ..., +		verify(task, times(1)).call();, +, +		// ... and the result should be exactly the same object, +		assertSame(result, asyncResult.getValue());, +	}, +, +	/**, +	 * Test used to verify the happy path of {@link ThreadAsyncExecutor#startProcess(Callable, AsyncCallback)}, +	 */, +	@Test(timeout = 3000), +	public void testSuccessfulTaskWithCallback() throws Exception {, +		// Instantiate a new executor and start a new 'null' task ..., +		final ThreadAsyncExecutor executor = new ThreadAsyncExecutor();, +, +		final Object result = new Object();, +		final Callable<Object> task = mock(Callable.class);, +		when(task.call()).thenReturn(result);, +, +		final AsyncCallback callback = mock(AsyncCallback.class);, +		final AsyncResult<Object> asyncResult = executor.startProcess(task, callback);, +		assertNotNull(asyncResult);, +		asyncResult.await(); // Prevent timing issues, and wait until the result is available, +		assertTrue(asyncResult.isCompleted());, +, +		// Our task should only execute once ..., +		verify(task, times(1)).call();, +, +		// ... same for the callback, we expect our object, +		final ArgumentCaptor<Optional<Exception>> optionalCaptor = ArgumentCaptor.forClass((Class) Optional.class);, +		verify(callback, times(1)).onComplete(eq(result), optionalCaptor.capture());, +, +		final Optional<Exception> optionalException = optionalCaptor.getValue();, +		assertNotNull(optionalException);, +		assertFalse(optionalException.isPresent());, +, +		// ... and the result should be exactly the same object, +		assertSame(result, asyncResult.getValue());]