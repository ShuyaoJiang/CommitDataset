[+++ b/abstract-factory/src/main/java/com/iluwatar/abstractfactory/App.java, +, + * The Abstract Factory pattern provides a way to encapsulate a group of individual factories that, + * have a common theme without specifying their concrete classes. In normal usage, the client, + * software creates a concrete implementation of the abstract factory and then uses the generic, + * interface of the factory to create the concrete objects that are part of the theme. The client, + * does not know (or care) which concrete objects it gets from each of these internal factories,, + * since it uses only the generic interfaces of their products. This pattern separates the details, + * of implementation of a set of objects from their general usage and relies on object composition,, + * as object creation is implemented in methods exposed in the factory interface., + * The essence of the Abstract Factory pattern is a factory interface ({@link KingdomFactory}) and, + * its implementations ({@link ElfKingdomFactory}, {@link OrcKingdomFactory}). The example uses both, + * concrete implementations to create a king, a castle and an army., +, +   * , +   * @param factory, +  Castle getCastle(final KingdomFactory factory) {, +    return factory.createCastle();, +  }, +, +  Army getArmy(final KingdomFactory factory) {, +    return factory.createArmy();, +  }, +, +, +   * @param args command line args, +++ b/abstract-factory/src/main/java/com/iluwatar/abstractfactory/App.java, +, + * The Abstract Factory pattern provides a way to encapsulate a group of individual factories that, + * have a common theme without specifying their concrete classes. In normal usage, the client, + * software creates a concrete implementation of the abstract factory and then uses the generic, + * interface of the factory to create the concrete objects that are part of the theme. The client, + * does not know (or care) which concrete objects it gets from each of these internal factories,, + * since it uses only the generic interfaces of their products. This pattern separates the details, + * of implementation of a set of objects from their general usage and relies on object composition,, + * as object creation is implemented in methods exposed in the factory interface., + * The essence of the Abstract Factory pattern is a factory interface ({@link KingdomFactory}) and, + * its implementations ({@link ElfKingdomFactory}, {@link OrcKingdomFactory}). The example uses both, + * concrete implementations to create a king, a castle and an army., +, +   * , +   * @param factory, +  Castle getCastle(final KingdomFactory factory) {, +    return factory.createCastle();, +  }, +, +  Army getArmy(final KingdomFactory factory) {, +    return factory.createArmy();, +  }, +, +, +   * @param args command line args, +++ b/async-method-invocation/src/main/java/com/iluwatar/async/method/invocation/App.java, + * <code>AsyncResult</code> which is an intermediate container for an asynchronously evaluated, + * value, <code>AsyncCallback</code> which can be provided to be executed on task completion and, + * <code>AsyncExecutor</code> that manages the execution of the async tasks., + * The main method shows example flow of async invocations. The main thread starts multiple tasks, + * with variable durations and then continues its own work. When the main thread has done it's job, + * it collects the results of the async tasks. Two of the tasks are handled with callbacks, meaning, + * the callbacks are executed immediately when the tasks complete., + * Noteworthy difference of thread usage between the async results and callbacks is that the async, + * results are collected in the main thread but the callbacks are executed within the worker, + * threads. This should be noted when working with thread pools., + * Java provides its own implementations of async method invocation pattern. FutureTask,, + * CompletableFuture and ExecutorService are the real world implementations of this pattern. But due, + * to the nature of parallel programming, the implementations are not trivial. This example does not, + * take all possible scenarios into account but rather provides a simple version that helps to, + * understand the pattern., +    AsyncResult<Integer> asyncResult4 =, +        executor.startProcess(lazyval(20, 400), callback("Callback result 4"));, +    AsyncResult<String> asyncResult5 =, +        executor.startProcess(lazyval("callback", 600), callback("Callback result 5"));, +   * @param value value to evaluate, +   * @param delayMillis artificial delay in milliseconds, +   * @param name callback name, +++ b/abstract-factory/src/main/java/com/iluwatar/abstractfactory/App.java, +, + * The Abstract Factory pattern provides a way to encapsulate a group of individual factories that, + * have a common theme without specifying their concrete classes. In normal usage, the client, + * software creates a concrete implementation of the abstract factory and then uses the generic, + * interface of the factory to create the concrete objects that are part of the theme. The client, + * does not know (or care) which concrete objects it gets from each of these internal factories,, + * since it uses only the generic interfaces of their products. This pattern separates the details, + * of implementation of a set of objects from their general usage and relies on object composition,, + * as object creation is implemented in methods exposed in the factory interface., + * The essence of the Abstract Factory pattern is a factory interface ({@link KingdomFactory}) and, + * its implementations ({@link ElfKingdomFactory}, {@link OrcKingdomFactory}). The example uses both, + * concrete implementations to create a king, a castle and an army., +, +   * , +   * @param factory, +  Castle getCastle(final KingdomFactory factory) {, +    return factory.createCastle();, +  }, +, +  Army getArmy(final KingdomFactory factory) {, +    return factory.createArmy();, +  }, +, +]