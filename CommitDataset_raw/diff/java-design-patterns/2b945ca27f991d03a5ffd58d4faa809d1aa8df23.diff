[+++ b/promise/pom.xml, +++ b/promise/pom.xml, +++ b/promise/src/main/java/com/iluwatar/promise/App.java, +import java.util.concurrent.ExecutionException;, +import java.util.concurrent.Executor;, +import java.util.concurrent.ExecutorService;, +import java.util.concurrent.Executors;, +   * @throws ExecutionException , +  public static void main(String[] args) throws InterruptedException, ExecutionException {, +    ExecutorService executor = Executors.newSingleThreadExecutor();, +    try {, +      promiseUsage(executor);, +    } finally {, +      executor.shutdownNow();, +    }, +  }, +  private static void promiseUsage(Executor executor), +      throws InterruptedException, ExecutionException {, +      System.out.println("Consumed transformed int value: " + value);, +    consumedPromise.get();, +    transformedPromise.get();, +++ b/promise/pom.xml, +++ b/promise/src/main/java/com/iluwatar/promise/App.java, +import java.util.concurrent.ExecutionException;, +import java.util.concurrent.Executor;, +import java.util.concurrent.ExecutorService;, +import java.util.concurrent.Executors;, +   * @throws ExecutionException , +  public static void main(String[] args) throws InterruptedException, ExecutionException {, +    ExecutorService executor = Executors.newSingleThreadExecutor();, +    try {, +      promiseUsage(executor);, +    } finally {, +      executor.shutdownNow();, +    }, +  }, +  private static void promiseUsage(Executor executor), +      throws InterruptedException, ExecutionException {, +      System.out.println("Consumed transformed int value: " + value);, +    consumedPromise.get();, +    transformedPromise.get();, +++ b/promise/src/main/java/com/iluwatar/promise/Promise.java, +import java.util.concurrent.Executor;, +import java.util.concurrent.Future;, +import java.util.concurrent.TimeUnit;, +import java.util.concurrent.TimeoutException;, +public class Promise<T> extends PromiseSupport<T> {, +   * @param value the fulfilled value that can be accessed using {@link #get()}., +  public void fulfill(T value) {, +    super.fulfill(value);, +    postFulfillment();, +   *        when accessing the value using {@link #get()}., +  public void fulfillExceptionally(Exception exception) {, +    super.fulfillExceptionally(exception);, +    postFulfillment();, +  void postFulfillment() {, +  public Promise<T> fulfillInAsync(final Callable<T> task, Executor executor) {, +    executor.execute(() -> {, +      try {, +        fulfill(task.call());, +      } catch (Exception e) {, +        fulfillExceptionally(e);, +    fulfillmentAction = new TransformAction<V>(this, dest, func);, +  /**, +   * A consume action provides the action, the value from source promise and fulfills the, +   * destination promise., +   */, +    private Promise<T> src;, +    ConsumeAction(Promise<T> src, Promise<Void> dest, Consumer<? super T> action) {, +      this.src = src;, +        action.accept(src.get());, +        dest.fulfill(null);, +        dest.fulfillExceptionally((Exception) e.getCause());, +  /**, +   * A function action provides transformation function, value from source promise and fulfills the, +   * destination promise with the transformed value., +   */, +  private class TransformAction<V> implements Runnable {, +    private Promise<T> src;, +    TransformAction(Promise<T> src, Promise<V> dest, Function<? super T, V> func) {, +      this.src = src;, +        V result = func.apply(src.get());, +        dest.fulfill(result);, +        dest.fulfillExceptionally((Exception) e.getCause());, +      }, +    }, +  }, +}, +, +, +/**, + * A really simplified implementation of future that allows completing it successfully with a value , + * or exceptionally with an exception., + */, +class PromiseSupport<T> implements Future<T> {, +, +  static final int RUNNING = 1;, +  static final int FAILED = 2;, +  static final int COMPLETED = 3;, +]