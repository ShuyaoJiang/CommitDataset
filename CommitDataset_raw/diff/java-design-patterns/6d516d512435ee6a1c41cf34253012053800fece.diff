[+++ /dev/null, +++ /dev/null, +++ b/README.md, +# Design pattern samples in Java, +[![Coverity Scan Build Status](https://scan.coverity.com/projects/5634/badge.svg)](https://scan.coverity.com/projects/5634), +If you are willing to contribute to the project you will find the relevant information in our [developer wiki](https://github.com/iluwatar/java-design-patterns/wiki)., +++ /dev/null, +++ b/README.md, +# Design pattern samples in Java, +[![Coverity Scan Build Status](https://scan.coverity.com/projects/5634/badge.svg)](https://scan.coverity.com/projects/5634), +If you are willing to contribute to the project you will find the relevant information in our [developer wiki](https://github.com/iluwatar/java-design-patterns/wiki)., +++ b/abstract-factory/index.md, +++ /dev/null, +++ b/README.md, +# Design pattern samples in Java, +[![Coverity Scan Build Status](https://scan.coverity.com/projects/5634/badge.svg)](https://scan.coverity.com/projects/5634), +If you are willing to contribute to the project you will find the relevant information in our [developer wiki](https://github.com/iluwatar/java-design-patterns/wiki)., +++ b/abstract-factory/index.md, +++ b/abstract-factory/src/main/java/com/iluwatar/abstractfactory/App.java, +, + * The Abstract Factory pattern provides a way to encapsulate a group of individual factories that, + * have a common theme without specifying their concrete classes. In normal usage, the client, + * software creates a concrete implementation of the abstract factory and then uses the generic, + * interface of the factory to create the concrete objects that are part of the theme. The client, + * does not know (or care) which concrete objects it gets from each of these internal factories,, + * since it uses only the generic interfaces of their products. This pattern separates the details, + * of implementation of a set of objects from their general usage and relies on object composition,, + * as object creation is implemented in methods exposed in the factory interface., + * The essence of the Abstract Factory pattern is a factory interface ({@link KingdomFactory}) and, + * its implementations ({@link ElfKingdomFactory}, {@link OrcKingdomFactory}). The example uses both, + * concrete implementations to create a king, a castle and an army., +, +   * , +   * @param factory, +  Castle getCastle(final KingdomFactory factory) {, +    return factory.createCastle();, +  }, +, +  Army getArmy(final KingdomFactory factory) {, +    return factory.createArmy();, +  }, +, +, +   * @param args command line args, +++ /dev/null, +++ b/README.md, +# Design pattern samples in Java, +[![Coverity Scan Build Status](https://scan.coverity.com/projects/5634/badge.svg)](https://scan.coverity.com/projects/5634), +If you are willing to contribute to the project you will find the relevant information in our [developer wiki](https://github.com/iluwatar/java-design-patterns/wiki)., +++ b/abstract-factory/index.md, +++ b/abstract-factory/src/main/java/com/iluwatar/abstractfactory/App.java, +, + * The Abstract Factory pattern provides a way to encapsulate a group of individual factories that, + * have a common theme without specifying their concrete classes. In normal usage, the client, + * software creates a concrete implementation of the abstract factory and then uses the generic, + * interface of the factory to create the concrete objects that are part of the theme. The client, + * does not know (or care) which concrete objects it gets from each of these internal factories,, + * since it uses only the generic interfaces of their products. This pattern separates the details, + * of implementation of a set of objects from their general usage and relies on object composition,, + * as object creation is implemented in methods exposed in the factory interface., + * The essence of the Abstract Factory pattern is a factory interface ({@link KingdomFactory}) and, + * its implementations ({@link ElfKingdomFactory}, {@link OrcKingdomFactory}). The example uses both, + * concrete implementations to create a king, a castle and an army., +, +   * , +   * @param factory, +  Castle getCastle(final KingdomFactory factory) {, +    return factory.createCastle();, +  }, +, +  Army getArmy(final KingdomFactory factory) {, +    return factory.createArmy();, +  }, +, +, +   * @param args command line args, +++ b/adapter/index.md, +++ /dev/null, +++ b/README.md, +# Design pattern samples in Java, +[![Coverity Scan Build Status](https://scan.coverity.com/projects/5634/badge.svg)](https://scan.coverity.com/projects/5634), +If you are willing to contribute to the project you will find the relevant information in our [developer wiki](https://github.com/iluwatar/java-design-patterns/wiki)., +++ b/abstract-factory/index.md, +++ b/abstract-factory/src/main/java/com/iluwatar/abstractfactory/App.java, +, + * The Abstract Factory pattern provides a way to encapsulate a group of individual factories that, + * have a common theme without specifying their concrete classes. In normal usage, the client, + * software creates a concrete implementation of the abstract factory and then uses the generic, + * interface of the factory to create the concrete objects that are part of the theme. The client, + * does not know (or care) which concrete objects it gets from each of these internal factories,, + * since it uses only the generic interfaces of their products. This pattern separates the details, + * of implementation of a set of objects from their general usage and relies on object composition,, + * as object creation is implemented in methods exposed in the factory interface., + * The essence of the Abstract Factory pattern is a factory interface ({@link KingdomFactory}) and, + * its implementations ({@link ElfKingdomFactory}, {@link OrcKingdomFactory}). The example uses both, + * concrete implementations to create a king, a castle and an army., +, +   * , +   * @param factory, +  Castle getCastle(final KingdomFactory factory) {]