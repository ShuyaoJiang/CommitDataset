[+++ b/object-pool/src/main/java/com/iluwatar/App.java, +/**, + * , + * When it is necessary to work with a large number of objects that are particularly expensive to instantiate , + * and each object is only needed for a short period of time, the performance of an entire application may be , + * adversely affected. An object pool design pattern may be deemed desirable in cases such as these. , + * , + * The object pool design pattern creates a set of objects that may be reused. When a new object is needed, it , + * is requested from the pool. If a previously prepared object is available it is returned immediately, avoiding , + * the instantiation cost. If no objects are present in the pool, a new item is created and returned. When the , + * object has been used and is no longer needed, it is returned to the pool, allowing it to be used again in the , + * future without repeating the computationally expensive instantiation process. It is important to note that , + * once an object has been used and returned, existing references will become invalid., + * , + * In this example we have created OliphauntPool inheriting from generic ObjectPool. Oliphaunts can be checked, + * out from the pool and later returned to it. The pool tracks created instances and their status (available,, + * inUse)., + *, + */, +++ b/object-pool/src/main/java/com/iluwatar/App.java, +/**, + * , + * When it is necessary to work with a large number of objects that are particularly expensive to instantiate , + * and each object is only needed for a short period of time, the performance of an entire application may be , + * adversely affected. An object pool design pattern may be deemed desirable in cases such as these. , + * , + * The object pool design pattern creates a set of objects that may be reused. When a new object is needed, it , + * is requested from the pool. If a previously prepared object is available it is returned immediately, avoiding , + * the instantiation cost. If no objects are present in the pool, a new item is created and returned. When the , + * object has been used and is no longer needed, it is returned to the pool, allowing it to be used again in the , + * future without repeating the computationally expensive instantiation process. It is important to note that , + * once an object has been used and returned, existing references will become invalid., + * , + * In this example we have created OliphauntPool inheriting from generic ObjectPool. Oliphaunts can be checked, + * out from the pool and later returned to it. The pool tracks created instances and their status (available,, + * inUse)., + *, + */, +++ b/object-pool/src/main/java/com/iluwatar/ObjectPool.java, +/**, + * , + * Generic object pool, + *, + * @param <T>, + */, +	private HashSet<T> available = new HashSet<>();, +	private HashSet<T> inUse = new HashSet<>();, +++ b/object-pool/src/main/java/com/iluwatar/App.java, +/**, + * , + * When it is necessary to work with a large number of objects that are particularly expensive to instantiate , + * and each object is only needed for a short period of time, the performance of an entire application may be , + * adversely affected. An object pool design pattern may be deemed desirable in cases such as these. , + * , + * The object pool design pattern creates a set of objects that may be reused. When a new object is needed, it , + * is requested from the pool. If a previously prepared object is available it is returned immediately, avoiding , + * the instantiation cost. If no objects are present in the pool, a new item is created and returned. When the , + * object has been used and is no longer needed, it is returned to the pool, allowing it to be used again in the , + * future without repeating the computationally expensive instantiation process. It is important to note that , + * once an object has been used and returned, existing references will become invalid., + * , + * In this example we have created OliphauntPool inheriting from generic ObjectPool. Oliphaunts can be checked, + * out from the pool and later returned to it. The pool tracks created instances and their status (available,, + * inUse)., + *, + */, +++ b/object-pool/src/main/java/com/iluwatar/ObjectPool.java, +/**, + * , + * Generic object pool, + *, + * @param <T>, + */, +	private HashSet<T> available = new HashSet<>();, +	private HashSet<T> inUse = new HashSet<>();, +++ b/object-pool/src/main/java/com/iluwatar/Oliphaunt.java, +/**, + * , + * Oliphaunts are expensive to create, + *, + */, +		try {, +			Thread.sleep(1000);, +		} catch (InterruptedException e) {, +			e.printStackTrace();, +		}, +++ b/object-pool/src/main/java/com/iluwatar/App.java, +/**, + * , + * When it is necessary to work with a large number of objects that are particularly expensive to instantiate , + * and each object is only needed for a short period of time, the performance of an entire application may be , + * adversely affected. An object pool design pattern may be deemed desirable in cases such as these. , + * , + * The object pool design pattern creates a set of objects that may be reused. When a new object is needed, it , + * is requested from the pool. If a previously prepared object is available it is returned immediately, avoiding , + * the instantiation cost. If no objects are present in the pool, a new item is created and returned. When the , + * object has been used and is no longer needed, it is returned to the pool, allowing it to be used again in the , + * future without repeating the computationally expensive instantiation process. It is important to note that , + * once an object has been used and returned, existing references will become invalid., + * ]