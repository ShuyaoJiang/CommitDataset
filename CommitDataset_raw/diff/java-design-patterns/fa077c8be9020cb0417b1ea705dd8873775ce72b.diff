[+++ b/dao/pom.xml, +    <dependency>, +        <groupId>com.h2database</groupId>, +        <artifactId>h2</artifactId>, +      </dependency>, +    <dependency>, +      <groupId>de.bechte.junit</groupId>, +      <artifactId>junit-hierarchicalcontextrunner</artifactId>, +    </dependency>, +    <dependency>, +        <groupId>org.mockito</groupId>, +        <artifactId>mockito-core</artifactId>, +    </dependency>, +++ b/dao/pom.xml, +    <dependency>, +        <groupId>com.h2database</groupId>, +        <artifactId>h2</artifactId>, +      </dependency>, +    <dependency>, +      <groupId>de.bechte.junit</groupId>, +      <artifactId>junit-hierarchicalcontextrunner</artifactId>, +    </dependency>, +    <dependency>, +        <groupId>org.mockito</groupId>, +        <artifactId>mockito-core</artifactId>, +    </dependency>, +++ b/dao/src/main/java/com/iluwatar/dao/App.java, +   * @throws Exception if any error occurs. , +  public static void main(final String[] args) throws Exception {, +    final CustomerDao customerDao = new InMemoryCustomerDao();, +    addCustomers(customerDao);, +    log.info("customerDao.getAllCustomers(): " + customerDao.getAll());, +    log.info("customerDao.getCusterById(2): " + customerDao.getById(2));, +    customerDao.add(customer);, +    log.info("customerDao.getAllCustomers(): " + customerDao.getAll());, +    customerDao.update(customer);, +    log.info("customerDao.getAllCustomers(): " + customerDao.getAll());, +    customerDao.delete(customer);, +    log.info("customerDao.getAllCustomers(): " + customerDao.getAll());, +  }, +, +  private static void addCustomers(CustomerDao customerDao) throws Exception {, +    for (Customer customer : generateSampleCustomers()) {, +      customerDao.add(customer);, +    }, +++ b/dao/pom.xml, +    <dependency>, +        <groupId>com.h2database</groupId>, +        <artifactId>h2</artifactId>, +      </dependency>, +    <dependency>, +      <groupId>de.bechte.junit</groupId>, +      <artifactId>junit-hierarchicalcontextrunner</artifactId>, +    </dependency>, +    <dependency>, +        <groupId>org.mockito</groupId>, +        <artifactId>mockito-core</artifactId>, +    </dependency>, +++ b/dao/src/main/java/com/iluwatar/dao/App.java, +   * @throws Exception if any error occurs. , +  public static void main(final String[] args) throws Exception {, +    final CustomerDao customerDao = new InMemoryCustomerDao();, +    addCustomers(customerDao);, +    log.info("customerDao.getAllCustomers(): " + customerDao.getAll());, +    log.info("customerDao.getCusterById(2): " + customerDao.getById(2));, +    customerDao.add(customer);, +    log.info("customerDao.getAllCustomers(): " + customerDao.getAll());, +    customerDao.update(customer);, +    log.info("customerDao.getAllCustomers(): " + customerDao.getAll());, +    customerDao.delete(customer);, +    log.info("customerDao.getAllCustomers(): " + customerDao.getAll());, +  }, +, +  private static void addCustomers(CustomerDao customerDao) throws Exception {, +    for (Customer customer : generateSampleCustomers()) {, +      customerDao.add(customer);, +    }, +++ b/dao/src/main/java/com/iluwatar/dao/CustomerDao.java, +import java.util.stream.Stream;, + * In an application the Data Access Object (DAO) is a part of Data access layer. It is an object, + * that provides an interface to some type of persistence mechanism. By mapping application calls, + * to the persistence layer, DAO provides some specific data operations without exposing details , + * of the database. This isolation supports the Single responsibility principle. It separates what, + * data accesses the application needs, in terms of domain-specific objects and data types , + * (the public interface of the DAO), from how these needs can be satisfied with a specific DBMS,, + * database schema, etc., + * <br/><br/>, + * Any change in the way data is stored and retrieved will not change the client code as the client, + * will be using interface and need not worry about exact source., + * @see InMemoryCustomerDao, + * @see DBCustomerDao, +  /**, +   * @return all the customers as a stream. The stream may be lazily or eagerly evaluated based on the, +   * implementation. The stream must be closed after use., +   * @throws Exception if any error occurs., +   */, +  Stream<Customer> getAll() throws Exception;, +  /**, +   * @param id unique identifier of the customer., +   * @return customer with unique identifier <code>id</code> is found, null otherwise.]