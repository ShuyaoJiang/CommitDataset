[+++ /dev/null, +++ /dev/null, +++ b/README.md, +**Intent:** Convert the interface of a class into another interface clients expect. Adapter lets classes work together that couldn't otherwise because of incompatible interfaces., +![alt text](https://github.com/iluwatar/java-design-patterns/blob/master/double-checked-locking/etc/double_checked_locking.jpg "Double Checked Locking"), +, +**Applicability:** Use the Visitor pattern when, +* an object structure contains many classes of objects with differing interfaces, and you want to perform operations on these objects that depend on their concrete classes, +* many distinct and unrelated operations need to be performed on objects in an object structure, and you want to avoid "polluting" their classes with these operations. Visitor lets you keep related operations together by defining them in one class. When the object structure is shared by many applications, use Visitor to put operations in just those applications that need them, +* the classes defining the object structure rarely change, but you often want to define new operations over the structure. Changing the object structure classes requires redefining the interface to all visitors, which is potentially costly. If the object structure classes change often, then it's probably better to define the operations in those classes, +++ /dev/null, +++ b/README.md, +**Intent:** Convert the interface of a class into another interface clients expect. Adapter lets classes work together that couldn't otherwise because of incompatible interfaces., +![alt text](https://github.com/iluwatar/java-design-patterns/blob/master/double-checked-locking/etc/double_checked_locking.jpg "Double Checked Locking"), +, +**Applicability:** Use the Visitor pattern when, +* an object structure contains many classes of objects with differing interfaces, and you want to perform operations on these objects that depend on their concrete classes, +* many distinct and unrelated operations need to be performed on objects in an object structure, and you want to avoid "polluting" their classes with these operations. Visitor lets you keep related operations together by defining them in one class. When the object structure is shared by many applications, use Visitor to put operations in just those applications that need them, +* the classes defining the object structure rarely change, but you often want to define new operations over the structure. Changing the object structure classes requires redefining the interface to all visitors, which is potentially costly. If the object structure classes change often, then it's probably better to define the operations in those classes, +++ b/adapter/etc/adapter.jpg, +++ /dev/null, +++ b/README.md, +**Intent:** Convert the interface of a class into another interface clients expect. Adapter lets classes work together that couldn't otherwise because of incompatible interfaces., +![alt text](https://github.com/iluwatar/java-design-patterns/blob/master/double-checked-locking/etc/double_checked_locking.jpg "Double Checked Locking"), +, +**Applicability:** Use the Visitor pattern when, +* an object structure contains many classes of objects with differing interfaces, and you want to perform operations on these objects that depend on their concrete classes, +* many distinct and unrelated operations need to be performed on objects in an object structure, and you want to avoid "polluting" their classes with these operations. Visitor lets you keep related operations together by defining them in one class. When the object structure is shared by many applications, use Visitor to put operations in just those applications that need them, +* the classes defining the object structure rarely change, but you often want to define new operations over the structure. Changing the object structure classes requires redefining the interface to all visitors, which is potentially costly. If the object structure classes change often, then it's probably better to define the operations in those classes, +++ b/adapter/etc/adapter.jpg, +++ b/adapter/src/main/java/com/iluwatar/App.java, + * Adapter (GnomeEngineer) converts the interface of the, + * target class (GoblinGlider) into suitable one., +    	GnomeEngineer engineer = new GnomeEngineer();, +    	engineer.operateDevice();, +++ /dev/null, +++ b/README.md, +**Intent:** Convert the interface of a class into another interface clients expect. Adapter lets classes work together that couldn't otherwise because of incompatible interfaces., +![alt text](https://github.com/iluwatar/java-design-patterns/blob/master/double-checked-locking/etc/double_checked_locking.jpg "Double Checked Locking"), +, +**Applicability:** Use the Visitor pattern when, +* an object structure contains many classes of objects with differing interfaces, and you want to perform operations on these objects that depend on their concrete classes, +* many distinct and unrelated operations need to be performed on objects in an object structure, and you want to avoid "polluting" their classes with these operations. Visitor lets you keep related operations together by defining them in one class. When the object structure is shared by many applications, use Visitor to put operations in just those applications that need them, +* the classes defining the object structure rarely change, but you often want to define new operations over the structure. Changing the object structure classes requires redefining the interface to all visitors, which is potentially costly. If the object structure classes change often, then it's probably better to define the operations in those classes, +++ b/adapter/etc/adapter.jpg, +++ b/adapter/src/main/java/com/iluwatar/App.java, + * Adapter (GnomeEngineer) converts the interface of the, + * target class (GoblinGlider) into suitable one., +    	GnomeEngineer engineer = new GnomeEngineer();, +    	engineer.operateDevice();, +++ b/adapter/src/main/java/com/iluwatar/Engineer.java, + * The interface the client knows how, + * to use., +++ /dev/null, +++ b/README.md, +**Intent:** Convert the interface of a class into another interface clients expect. Adapter lets classes work together that couldn't otherwise because of incompatible interfaces., +![alt text](https://github.com/iluwatar/java-design-patterns/blob/master/double-checked-locking/etc/double_checked_locking.jpg "Double Checked Locking"), +, +**Applicability:** Use the Visitor pattern when, +* an object structure contains many classes of objects with differing interfaces, and you want to perform operations on these objects that depend on their concrete classes, +* many distinct and unrelated operations need to be performed on objects in an object structure, and you want to avoid "polluting" their classes with these operations. Visitor lets you keep related operations together by defining them in one class. When the object structure is shared by many applications, use Visitor to put operations in just those applications that need them, +* the classes defining the object structure rarely change, but you often want to define new operations over the structure. Changing the object structure classes requires redefining the interface to all visitors, which is potentially costly. If the object structure classes change often, then it's probably better to define the operations in those classes, +++ b/adapter/etc/adapter.jpg, +++ b/adapter/src/main/java/com/iluwatar/App.java, + * Adapter (GnomeEngineer) converts the interface of the, + * target class (GoblinGlider) into suitable one., +    	GnomeEngineer engineer = new GnomeEngineer();, +    	engineer.operateDevice();, +++ b/adapter/src/main/java/com/iluwatar/Engineer.java, + * The interface the client knows how, + * to use., +++ b/adapter/src/main/java/com/iluwatar/GnomeEngineer.java, + * Adapter class. Adapts the interface of the, + * GoblinGlider into Engineer expected by the, + * client., +++ /dev/null, +++ b/README.md, +**Intent:** Convert the interface of a class into another interface clients expect. Adapter lets classes work together that couldn't otherwise because of incompatible interfaces., +![alt text](https://github.com/iluwatar/java-design-patterns/blob/master/double-checked-locking/etc/double_checked_locking.jpg "Double Checked Locking"), +, +**Applicability:** Use the Visitor pattern when, +* an object structure contains many classes of objects with differing interfaces, and you want to perform operations on these objects that depend on their concrete classes, +* many distinct and unrelated operations need to be performed on objects in an object structure, and you want to avoid "polluting" their classes with these operations. Visitor lets you keep related operations together by defining them in one class. When the object structure is shared by many applications, use Visitor to put operations in just those applications that need them, +* the classes defining the object structure rarely change, but you often want to define new operations over the structure. Changing the object structure classes requires redefining the interface to all visitors, which is potentially costly. If the object structure classes change often, then it's probably better to define the operations in those classes, +++ b/adapter/etc/adapter.jpg, +++ b/adapter/src/main/java/com/iluwatar/App.java, + * Adapter (GnomeEngineer) converts the interface of the, + * target class (GoblinGlider) into suitable one., +    	GnomeEngineer engineer = new GnomeEngineer();, +    	engineer.operateDevice();, +++ b/adapter/src/main/java/com/iluwatar/Engineer.java, + * The interface the client knows how, + * to use., +++ b/adapter/src/main/java/com/iluwatar/GnomeEngineer.java, + * Adapter class. Adapts the interface of the, + * GoblinGlider into Engineer expected by the, + * client., +++ /dev/null, +++ /dev/null, +++ b/README.md]