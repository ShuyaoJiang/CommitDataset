[+++ b/double-checked-locking/src/main/java/com/iluwatar/doublechecked/locking/App.java, + * Double Checked Locking is a concurrency design pattern used to reduce the overhead of acquiring a, + * lock by first testing the locking criterion (the "lock hint") without actually acquiring the, + * lock. Only if the locking criterion check indicates that locking is required does the actual, + * locking logic proceed., + * In {@link Inventory} we store the items with a given size. However, we do not store more items, + * than the inventory size. To address concurrent access problems we use double checked locking to, + * add item to inventory. In this method, the thread which gets the lock first adds the item., +   * , +        while (inventory.addItem(new Item()));, +++ b/double-checked-locking/src/main/java/com/iluwatar/doublechecked/locking/App.java, + * Double Checked Locking is a concurrency design pattern used to reduce the overhead of acquiring a, + * lock by first testing the locking criterion (the "lock hint") without actually acquiring the, + * lock. Only if the locking criterion check indicates that locking is required does the actual, + * locking logic proceed., + * In {@link Inventory} we store the items with a given size. However, we do not store more items, + * than the inventory size. To address concurrent access problems we use double checked locking to, + * add item to inventory. In this method, the thread which gets the lock first adds the item., +   * , +        while (inventory.addItem(new Item()));, +++ b/double-checked-locking/src/main/java/com/iluwatar/doublechecked/locking/Inventory.java, +          System.out.println(Thread.currentThread() + ": items.size()=" + items.size(), +++ b/double-checked-locking/src/main/java/com/iluwatar/doublechecked/locking/App.java, + * Double Checked Locking is a concurrency design pattern used to reduce the overhead of acquiring a, + * lock by first testing the locking criterion (the "lock hint") without actually acquiring the, + * lock. Only if the locking criterion check indicates that locking is required does the actual, + * locking logic proceed., + * In {@link Inventory} we store the items with a given size. However, we do not store more items, + * than the inventory size. To address concurrent access problems we use double checked locking to, + * add item to inventory. In this method, the thread which gets the lock first adds the item., +   * , +        while (inventory.addItem(new Item()));, +++ b/double-checked-locking/src/main/java/com/iluwatar/doublechecked/locking/Inventory.java, +          System.out.println(Thread.currentThread() + ": items.size()=" + items.size(), +++ b/double-checked-locking/src/main/java/com/iluwatar/doublechecked/locking/Item.java, +++ b/double-checked-locking/src/main/java/com/iluwatar/doublechecked/locking/App.java, + * Double Checked Locking is a concurrency design pattern used to reduce the overhead of acquiring a, + * lock by first testing the locking criterion (the "lock hint") without actually acquiring the, + * lock. Only if the locking criterion check indicates that locking is required does the actual, + * locking logic proceed., + * In {@link Inventory} we store the items with a given size. However, we do not store more items, + * than the inventory size. To address concurrent access problems we use double checked locking to, + * add item to inventory. In this method, the thread which gets the lock first adds the item., +   * , +        while (inventory.addItem(new Item()));, +++ b/double-checked-locking/src/main/java/com/iluwatar/doublechecked/locking/Inventory.java, +          System.out.println(Thread.currentThread() + ": items.size()=" + items.size(), +++ b/double-checked-locking/src/main/java/com/iluwatar/doublechecked/locking/Item.java, +++ b/double-checked-locking/src/test/java/com/iluwatar/doublechecked/locking/AppTest.java, +++ b/double-checked-locking/src/main/java/com/iluwatar/doublechecked/locking/App.java, + * Double Checked Locking is a concurrency design pattern used to reduce the overhead of acquiring a, + * lock by first testing the locking criterion (the "lock hint") without actually acquiring the, + * lock. Only if the locking criterion check indicates that locking is required does the actual, + * locking logic proceed., + * In {@link Inventory} we store the items with a given size. However, we do not store more items, + * than the inventory size. To address concurrent access problems we use double checked locking to, + * add item to inventory. In this method, the thread which gets the lock first adds the item., +   * , +        while (inventory.addItem(new Item()));, +++ b/double-checked-locking/src/main/java/com/iluwatar/doublechecked/locking/Inventory.java, +          System.out.println(Thread.currentThread() + ": items.size()=" + items.size(), +++ b/double-checked-locking/src/main/java/com/iluwatar/doublechecked/locking/Item.java, +++ b/double-checked-locking/src/test/java/com/iluwatar/doublechecked/locking/AppTest.java, +++ b/double-dispatch/src/main/java/com/iluwatar/doubledispatch/App.java, + * implementation of that method in the receiver. Sometimes the behaviour must also be determined by, + * the type of the parameter., + * One way to implement this would be to create multiple instanceof-checks for the methods, + * parameter. However, this creates a maintenance issue. When new types are added we would also need, + * to change the method's implementation and add a new instanceof-check. This violates the single, + * responsibility principle - a class should have only one reason to change., + * In this example we have hierarchy of objects ({@link GameObject}) that can collide to each other., + * Each object has its own coordinates which are checked against the other objects' coordinates. If, +   * , +    objects.stream().forEach(o1 -> objects.stream().forEach(o2 -> {, +      if (o1 != o2 && o1.intersectsWith(o2)), +        o1.collision(o2);, +    }));, +++ b/double-checked-locking/src/main/java/com/iluwatar/doublechecked/locking/App.java, + * Double Checked Locking is a concurrency design pattern used to reduce the overhead of acquiring a, + * lock by first testing the locking criterion (the "lock hint") without actually acquiring the, + * lock. Only if the locking criterion check indicates that locking is required does the actual, + * locking logic proceed., + * In {@link Inventory} we store the items with a given size. However, we do not store more items, + * than the inventory size. To address concurrent access problems we use double checked locking to, + * add item to inventory. In this method, the thread which gets the lock first adds the item., +   * , +        while (inventory.addItem(new Item()));, +++ b/double-checked-locking/src/main/java/com/iluwatar/doublechecked/locking/Inventory.java, +          System.out.println(Thread.currentThread() + ": items.size()=" + items.size(), +++ b/double-checked-locking/src/main/java/com/iluwatar/doublechecked/locking/Item.java, +++ b/double-checked-locking/src/test/java/com/iluwatar/doublechecked/locking/AppTest.java, +++ b/double-dispatch/src/main/java/com/iluwatar/doubledispatch/App.java, + * implementation of that method in the receiver. Sometimes the behaviour must also be determined by, + * the type of the parameter., + * One way to implement this would be to create multiple instanceof-checks for the methods, + * parameter. However, this creates a maintenance issue. When new types are added we would also need, + * to change the method's implementation and add a new instanceof-check. This violates the single, + * responsibility principle - a class should have only one reason to change., + * In this example we have hierarchy of objects ({@link GameObject}) that can collide to each other., + * Each object has its own coordinates which are checked against the other objects' coordinates. If]