[+++ b/reactor/src/main/java/com/iluwatar/reactor/app/App.java, + * This application demonstrates Reactor pattern. The example demonstrated is a Distributed Logging, + * Service where it listens on multiple TCP or UDP sockets for incoming log requests., + * <i>INTENT</i> <br/>, + * <i>PROBLEM</i> <br/>, + * <i>PARTICIPANTS</i> <br/>, + * <ul>, + * <li>Synchronous Event De-multiplexer</li> {@link NioReactor} plays the role of synchronous event, + * de-multiplexer. It waits for events on multiple channels registered to it in an event loop., + * , + * <p>, + * <li>Initiation Dispatcher</li> {@link NioReactor} plays this role as the application specific, + * {@link ChannelHandler}s are registered to the reactor., + * , + * <p>, + * <li>Handle</li> {@link AbstractNioChannel} acts as a handle that is registered to the reactor., + * When any events occur on a handle, reactor calls the appropriate handler., + * , + * <p>, + * <li>Event Handler</li> {@link ChannelHandler} acts as an event handler, which is bound to a, + * channel and is called back when any event occurs on any of its associated handles. Application, + * logic resides in event handlers., + * </ul>, + * , + * <p>, + * The application utilizes single thread to listen for requests on all ports. It does not create a, + * separate thread for each client, which provides better scalability under load (number of clients, +   * , +   * , +     * This represents application specific business logic that dispatcher will call on appropriate, +     * events. These events are read events in our example., +     * Our application binds to multiple channels and uses same logging handler to handle incoming, +     * log requests., +    reactor.registerChannel(tcpChannel(6666, loggingHandler)).registerChannel(tcpChannel(6667, loggingHandler)), +        .registerChannel(udpChannel(6668, loggingHandler)).start();, +   * , +   * @throws InterruptedException if interrupted while stopping the reactor., +  public void stop() throws InterruptedException {, +++ b/reactor/src/main/java/com/iluwatar/reactor/app/App.java, + * This application demonstrates Reactor pattern. The example demonstrated is a Distributed Logging, + * Service where it listens on multiple TCP or UDP sockets for incoming log requests., + * <i>INTENT</i> <br/>, + * <i>PROBLEM</i> <br/>, + * <i>PARTICIPANTS</i> <br/>, + * <ul>, + * <li>Synchronous Event De-multiplexer</li> {@link NioReactor} plays the role of synchronous event, + * de-multiplexer. It waits for events on multiple channels registered to it in an event loop., + * , + * <p>, + * <li>Initiation Dispatcher</li> {@link NioReactor} plays this role as the application specific, + * {@link ChannelHandler}s are registered to the reactor., + * , + * <p>, + * <li>Handle</li> {@link AbstractNioChannel} acts as a handle that is registered to the reactor., + * When any events occur on a handle, reactor calls the appropriate handler., + * , + * <p>, + * <li>Event Handler</li> {@link ChannelHandler} acts as an event handler, which is bound to a, + * channel and is called back when any event occurs on any of its associated handles. Application, + * logic resides in event handlers., + * </ul>, + * , + * <p>, + * The application utilizes single thread to listen for requests on all ports. It does not create a, + * separate thread for each client, which provides better scalability under load (number of clients, +   * , +   * , +     * This represents application specific business logic that dispatcher will call on appropriate, +     * events. These events are read events in our example., +     * Our application binds to multiple channels and uses same logging handler to handle incoming, +     * log requests., +    reactor.registerChannel(tcpChannel(6666, loggingHandler)).registerChannel(tcpChannel(6667, loggingHandler)), +        .registerChannel(udpChannel(6668, loggingHandler)).start();, +   * , +   * @throws InterruptedException if interrupted while stopping the reactor., +  public void stop() throws InterruptedException {, +++ b/reactor/src/main/java/com/iluwatar/reactor/app/AppClient.java, +  private final ExecutorService service = Executors.newFixedThreadPool(4);, +   * , +   * , +    private final int serverPort;, +    private final String clientName;, +    private final String clientName;, +    private final InetSocketAddress remoteAddress;, +          DatagramPacket request = new DatagramPacket(message.getBytes(), message.getBytes().length, remoteAddress);, +++ b/reactor/src/main/java/com/iluwatar/reactor/app/App.java, + * This application demonstrates Reactor pattern. The example demonstrated is a Distributed Logging, + * Service where it listens on multiple TCP or UDP sockets for incoming log requests., + * <i>INTENT</i> <br/>, + * <i>PROBLEM</i> <br/>, + * <i>PARTICIPANTS</i> <br/>, + * <ul>, + * <li>Synchronous Event De-multiplexer</li> {@link NioReactor} plays the role of synchronous event, + * de-multiplexer. It waits for events on multiple channels registered to it in an event loop., + * , + * <p>, + * <li>Initiation Dispatcher</li> {@link NioReactor} plays this role as the application specific, + * {@link ChannelHandler}s are registered to the reactor., + * , + * <p>]