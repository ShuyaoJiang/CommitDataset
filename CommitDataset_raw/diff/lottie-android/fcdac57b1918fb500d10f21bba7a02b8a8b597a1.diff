[+++ b/LottieSample/screenshots/lottiefiles.com_-_Emoji_Shock.png, +++ b/LottieSample/screenshots/lottiefiles.com_-_Emoji_Shock.png, +++ b/LottieSample/screenshots/lottiefiles.com_-_Loading_2.png, +++ b/LottieSample/screenshots/lottiefiles.com_-_Emoji_Shock.png, +++ b/LottieSample/screenshots/lottiefiles.com_-_Loading_2.png, +++ b/lottie/src/main/java/com/airbnb/lottie/CompositionLayer.java, +        } else if (layer instanceof CompositionLayer && ((CompositionLayer) layer).hasMasks()) {, +          hasMasks = true;, +          return  true;, +++ b/LottieSample/screenshots/lottiefiles.com_-_Emoji_Shock.png, +++ b/LottieSample/screenshots/lottiefiles.com_-_Loading_2.png, +++ b/lottie/src/main/java/com/airbnb/lottie/CompositionLayer.java, +        } else if (layer instanceof CompositionLayer && ((CompositionLayer) layer).hasMasks()) {, +          hasMasks = true;, +          return  true;, +++ b/lottie/src/main/java/com/airbnb/lottie/LottieAnimationView.java, +++ b/LottieSample/screenshots/lottiefiles.com_-_Emoji_Shock.png, +++ b/LottieSample/screenshots/lottiefiles.com_-_Loading_2.png, +++ b/lottie/src/main/java/com/airbnb/lottie/CompositionLayer.java, +        } else if (layer instanceof CompositionLayer && ((CompositionLayer) layer).hasMasks()) {, +          hasMasks = true;, +          return  true;, +++ b/lottie/src/main/java/com/airbnb/lottie/LottieAnimationView.java, +++ b/lottie/src/main/java/com/airbnb/lottie/LottieDrawable.java, +  @SuppressWarnings("WeakerAccess") public void setPerformanceTrackingEnabled(boolean enabled) {, +    float extraScale = 1f;, +    boolean hasExtraScale = false;, +    float maxScale = getMaxScale(canvas);, +    if (compositionLayer.hasMatte() || compositionLayer.hasMasks()) {, +      // Since we can only scale up the animation so much before masks and mattes get clipped, we, +      // may have to scale the canvas to fake the rest. This isn't a problem for software rendering, +      // but hardware accelerated scaling is rasterized so it will appear pixelated., +      extraScale = scale / maxScale;, +      scale = Math.min(scale, maxScale);, +      // This check fixes some floating point rounding issues., +      hasExtraScale = extraScale > 1.001f;, +    if (hasExtraScale) {, +      canvas.save();, +      // This is extraScale ^2 because what happens is when the scale increases, the intrinsic size, +      // of the view increases. That causes the drawable to keep growing even though we are only, +      // rendering to the size of the view in the top left quarter, leaving the rest blank., +      // The first scale by extraScale scales up the canvas so that we are back at the original, +      // size. The second extraScale is what actually has the scaling effect., +      float extraScaleSquared = extraScale * extraScale;, +      int px = (int) ((composition.getBounds().width() * scale / 2f));, +      int py = (int) ((composition.getBounds().height() * scale / 2f));, +      canvas.scale(extraScaleSquared, extraScaleSquared, px, py);, +, +    }, +    if (hasExtraScale) {, +      canvas.restore();, +    }, +  @SuppressWarnings("WeakerAccess"), +    float scale = getScale();, +  /**, +   * If there are masks or mattes, we can't scale the animation larger than the canvas or else, +   * the off screen rendering for masks and mattes after saveLayer calls will get clipped., +   */]