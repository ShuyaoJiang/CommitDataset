[+++ b/lotte/src/main/java/com/airbnb/lotte/model/LotteAnimatableNumberValue.java, +import com.airbnb.lotte.utils.LotteKeyframeAnimation;, +, +    public LotteKeyframeAnimation animationForKeyPath(String keyPath) {, +        LotteKeyframeAnimation animation = new LotteKeyframeAnimation(keyPath, durationMs, keyTimes, valueKeyframes);, +        animation.setStartDelay(delayMs);, +        return animation;, +++ b/lotte/src/main/java/com/airbnb/lotte/model/LotteAnimatableNumberValue.java, +import com.airbnb.lotte.utils.LotteKeyframeAnimation;, +, +    public LotteKeyframeAnimation animationForKeyPath(String keyPath) {, +        LotteKeyframeAnimation animation = new LotteKeyframeAnimation(keyPath, durationMs, keyTimes, valueKeyframes);, +        animation.setStartDelay(delayMs);, +        return animation;, +++ b/lotte/src/main/java/com/airbnb/lotte/model/LotteAnimatablePointValue.java, +    private final List<Interpolator> interpolators = new ArrayList<>();, +            PointF outPoint = null;, +                    PointF vertex = outPoint;, +                    interpolators.add(new LinearInterpolator());, +                        interpolators.add(new LinearInterpolator());, +                        PointF inVertex = startPoint;, +                        animationPath.cubicTo(, +                                inVertex.x + cp1.x, inVertex.y + cp1.y,, +                                vertex.x + cp2.x, vertex.y + cp2.y,, +                                vertex.x, vertex.y);, +                        animationPath.lineTo(vertex.x, vertex.y);, +, +                    Interpolator interpolator;, +                    if (keyframe.has("o") && keyframe.has("i")) {, +                        PointF cp1 = pointFromValueObject(keyframe.getJSONObject("o"));, +                        PointF cp2 = pointFromValueObject(keyframe.getJSONObject("i"));, +                        interpolator = PathInterpolatorCompat.create(cp1.x, cp1.y, cp2.x, cp2.y);, +                    } else {, +                        interpolator = new LinearInterpolator();, +                    }, +                    interpolators.add(interpolator);, +                    outPoint = startPoint;, +    private PointF pointFromValueObject(JSONObject value) {, +        try {, +            Object x = value.get("x");, +            Object y = value.get("y");, +, +            PointF point = new PointF();, +            if (x instanceof JSONArray) {, +                point.x = new Float(((JSONArray) x).getDouble(0));, +            } else {, +                point.x = new Float((Double) x);, +            }, +, +            if (y instanceof JSONArray) {, +                point.y = new Float(((JSONArray) y).getDouble(0));, +            } else {, +                point.y = new Float((Double) y);, +            }, +, +            return point;, +        } catch (JSONException e) {, +            throw new IllegalArgumentException("Unable to parse point for " + value);, +        }, +    }, +]