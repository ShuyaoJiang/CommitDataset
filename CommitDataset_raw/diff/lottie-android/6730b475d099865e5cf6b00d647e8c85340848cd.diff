[+++ b/lottie/src/main/java/com/airbnb/lottie/AnimatableGradientColorValue.java, +import android.support.annotation.IntRange;, +          .newInstance(json, 1, composition, new ValueFactory(json.optInt("p"))), +    private final int colorPoints;, +    private ValueFactory(int colorPoints) {, +      this.colorPoints = colorPoints;, +    /**, +     * Both the color stops and opacity stops are in the same array., +     * There are {@link #colorPoints} colors sequentially as:, +     * [, +     *     ...,, +     *     position,, +     *     red,, +     *     green,, +     *     blue,, +     *     ..., +     * ], +     *, +     * The remainder of the array is the opacity stops sequentially as:, +     * [, +     *     ...,, +     *     position,, +     *     opacity,, +     *     ..., +     * ], +     */, +      float[] positions = new float[colorPoints];, +      int[] colors = new int[colorPoints];, +      if (array.length() != colorPoints * 4) {, +            ". Expected " + (colorPoints * 4) + ". This may affect the appearance of the gradient. " +, +      for (int i = 0; i < colorPoints * 4; i++) {, +, +      addOpacityStopsToGradientIfNeeded(gradientColor, array);, +, +    /**, +     * This cheats a little bit., +     * Opacity stops can be at arbitrary intervals independent of color stops., +     * This uses the existing color stops and modifies the opacity at each existing color stop, +     * based on what the opacity would be., +     *, +     * This should be a good approximation is nearly all cases. However, if there are many more, +     * opacity stops than color stops, information will be lost., +     */, +    private void addOpacityStopsToGradientIfNeeded(GradientColor gradientColor, JSONArray array) {, +      int startIndex = colorPoints * 4;, +      if (array.length() <= startIndex) {, +        return;, +      }, +, +      int opacityStops = (array.length() - startIndex) / 2;, +      double[] positions = new double[opacityStops];, +      double[] opacities = new double[opacityStops];, +, +      for (int i = startIndex, j = 0; i < array.length(); i++) {, +        if (i % 2 == 0) {, +          positions[j] = array.optDouble(i);, +        } else {, +          opacities[j] = array.optDouble(i);, +          j++;, +        }, +      }, +, +      for (int i = 0; i < gradientColor.getSize(); i++) {, +        int color = gradientColor.getColors()[i];, +        color = Color.argb(, +            getOpacityAtPosition(gradientColor.getPositions()[i], positions, opacities),, +            Color.red(color),, +            Color.green(color),, +            Color.blue(color), +        );, +        gradientColor.getColors()[i] = color;, +      }, +    }, +, +    @IntRange(from=0, to=255), +    private int getOpacityAtPosition(double position, double[] positions, double[] opacities) {, +      for (int i = 1; i < positions.length; i++) {, +        double lastPosition = positions[i - 1];, +        double thisPosition = positions[i];, +        if (positions[i] >= position) {, +          double progress = (position - lastPosition) / (thisPosition - lastPosition);, +          return (int) (255 * MiscUtils.lerp(opacities[i - 1], opacities[i], progress));, +        }, +      }, +      return (int) (255 * opacities[opacities.length - 1]);, +    }, +++ b/lottie/src/main/java/com/airbnb/lottie/AnimatableGradientColorValue.java, +import android.support.annotation.IntRange;, +          .newInstance(json, 1, composition, new ValueFactory(json.optInt("p"))), +    private final int colorPoints;, +    private ValueFactory(int colorPoints) {, +      this.colorPoints = colorPoints;, +    /**, +     * Both the color stops and opacity stops are in the same array., +     * There are {@link #colorPoints} colors sequentially as:, +     * [, +     *     ...,, +     *     position,, +     *     red,, +     *     green,]