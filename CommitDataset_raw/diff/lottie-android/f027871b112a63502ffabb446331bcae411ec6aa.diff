[+++ b/LottieSample/screenshots/MotionCorpse-Jrcanest.png, +++ b/LottieSample/screenshots/MotionCorpse-Jrcanest.png, +++ b/lottie/src/main/java/com/airbnb/lottie/BaseLayer.java, +import android.support.annotation.CallSuper;, +  private final RectF maskBoundsRect = new RectF();, +  private final RectF matteBoundsRect = new RectF();, +  private final RectF tempMaskBoundsRect = new RectF();, +  final Matrix boundsMatrix = new Matrix();, +  @CallSuper @Override public void getBounds(RectF outBounds, Matrix parentMatrix) {, +    boundsMatrix.set(parentMatrix);, +    boundsMatrix.preConcat(transform.getMatrix());, +  }, +, +      matrix.preConcat(transform.getMatrix());, +    rect.set(0, 0, 0, 0);, +    getBounds(rect, matrix);, +    intersectBoundsWithMatte(rect, matrix);, +, +    matrix.preConcat(transform.getMatrix());, +    intersectBoundsWithMask(rect, matrix);, +, +    rect.set(0, 0, canvas.getWidth(), canvas.getHeight());, +, +    clearCanvas(canvas);, +      clearCanvas(canvas);, +  private void clearCanvas(Canvas canvas) {, +    // If we don't pad the clear draw, some phones leave a 1px border of the graphics buffer., +    canvas.drawRect(rect.left - 1, rect.top - 1, rect.right + 1, rect.bottom + 1, clearPaint);, +  }, +, +  private void intersectBoundsWithMask(RectF rect, Matrix matrix) {, +    maskBoundsRect.set(0, 0, 0, 0);, +    if (!hasMasksOnThisLayer()) {, +      return;, +    }, +    //noinspection ConstantConditions, +    int size = mask.getMasks().size();, +    for (int i = 0; i < size; i++) {, +      Mask mask = this.mask.getMasks().get(i);, +      BaseKeyframeAnimation<?, Path> maskAnimation = this.mask.getMaskAnimations().get(i);, +      Path maskPath = maskAnimation.getValue();, +      path.set(maskPath);, +      path.transform(matrix);, +, +      switch (mask.getMaskMode()) {, +        case MaskModeSubtract:, +          // If there is a subtract mask, the mask could potentially be the size of the entire, +          // canvas so we can't use the mask bounds., +          return;, +        case MaskModeAdd:, +        default:, +          path.computeBounds(tempMaskBoundsRect, false);, +          // As we iterate through the masks, we want to calculate the union region of the masks., +          // We initialize the rect with the first mask. If we don't call set() on the first call,, +          // the rect will always extend to (0,0)., +          if (i == 0) {, +            maskBoundsRect.set(tempMaskBoundsRect);, +          } else {, +            maskBoundsRect.set(, +              Math.min(maskBoundsRect.left, tempMaskBoundsRect.left),, +              Math.min(maskBoundsRect.top, tempMaskBoundsRect.top),, +              Math.max(maskBoundsRect.right, tempMaskBoundsRect.right),, +              Math.max(maskBoundsRect.bottom, tempMaskBoundsRect.bottom), +            );, +          }, +      }, +    }, +, +    rect.set(, +        Math.max(rect.left, maskBoundsRect.left),, +        Math.max(rect.top, maskBoundsRect.top),, +        Math.min(rect.right, maskBoundsRect.right),, +        Math.min(rect.bottom, maskBoundsRect.bottom), +    );, +  }, +, +  private void intersectBoundsWithMatte(RectF rect, Matrix matrix) {, +    if (!hasMatteOnThisLayer()) {, +      return;, +    }, +    if (layerModel.getMatteType() == Layer.MatteType.Invert) {, +      // We can't trim the bounds if the mask is inverted since it extends all the way to the, +      // composition bounds., +      return;, +    }, +    //noinspection ConstantConditions, +    matteLayer.getBounds(matteBoundsRect, matrix);, +    rect.set(, +        Math.max(rect.left, matteBoundsRect.left),, +        Math.max(rect.top, matteBoundsRect.top),, +        Math.min(rect.right, matteBoundsRect.right),, +        Math.min(rect.bottom, matteBoundsRect.bottom), +    );, +  }, +, +    clearCanvas(canvas);, +          path.setFillType(Path.FillType.INVERSE_WINDING);, +          path.setFillType(Path.FillType.WINDING);, +++ b/LottieSample/screenshots/MotionCorpse-Jrcanest.png, +++ b/lottie/src/main/java/com/airbnb/lottie/BaseLayer.java]