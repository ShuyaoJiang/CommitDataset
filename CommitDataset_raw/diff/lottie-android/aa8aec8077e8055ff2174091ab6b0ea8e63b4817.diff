[+++ b/LottieSample/src/main/kotlin/com/airbnb/lottie/samples/AnimationFragment.kt, +        view.animationView.addAnimatorUpdateListener { animation ->, +            if (animation.isRunning) {, +                seekBar.progress = (animation.animatedValue as Float * 100f).toInt(), +            }, +++ b/LottieSample/src/main/kotlin/com/airbnb/lottie/samples/AnimationFragment.kt, +        view.animationView.addAnimatorUpdateListener { animation ->, +            if (animation.isRunning) {, +                seekBar.progress = (animation.animatedValue as Float * 100f).toInt(), +            }, +++ b/LottieSample/src/main/kotlin/com/airbnb/lottie/samples/TrimView.kt, +            return if (child == leftAnchor) {, +                maxOf(minOf(left, rightAnchor.left - leftAnchor.width), 0), +                minOf(maxOf(leftAnchor.right, left), width - rightAnchor.width), +++ b/LottieSample/src/main/kotlin/com/airbnb/lottie/samples/AnimationFragment.kt, +        view.animationView.addAnimatorUpdateListener { animation ->, +            if (animation.isRunning) {, +                seekBar.progress = (animation.animatedValue as Float * 100f).toInt(), +            }, +++ b/LottieSample/src/main/kotlin/com/airbnb/lottie/samples/TrimView.kt, +            return if (child == leftAnchor) {, +                maxOf(minOf(left, rightAnchor.left - leftAnchor.width), 0), +                minOf(maxOf(leftAnchor.right, left), width - rightAnchor.width), +++ b/lottie/src/main/java/com/airbnb/lottie/LottieDrawable.java, +          setProgress((Float) animation.getAnimatedValue());, +  public void resumeAnimation() {, +    playAnimation(animator.getAnimatedFraction() == 1f);, +  }, +, +  private void playAnimation(final boolean resetProgress) {, +          playAnimation(resetProgress);, +    float progress = animator.getProgress();, +    if (resetProgress || animator.getAnimatedFraction() == 1f) {, +      animator.setProgress(animator.getMinProgress());, +    } else {, +      animator.setProgress(progress);, +          playAnimation(startFrame, endFrame);, +    reverseAnimation(false);, +    float progress = getProgress();, +    reverseAnimation(true);, +  private void reverseAnimation(final boolean resetProgress) {, +          reverseAnimation(resetProgress);, +    float progress = animator.getProgress();, +    if (resetProgress || getProgress() == 1f) {, +      animator.setProgress(animator.getMinProgress());, +    } else {, +      animator.setProgress(progress);, +    }, +  public void setMinFrame(final int minFrame) {, +          setMinFrame(minFrame);, +    setMinProgress(minFrame / composition.getDurationFrames());, +   public void setMinProgress(float minProgress) {, +    animator.setMinProgress(minProgress);, +  public void setMaxFrame(final int maxFrame) {, +          setMaxFrame(maxFrame);, +    setMaxProgress(maxFrame / composition.getDurationFrames());, +  public void setMaxProgress(float maxProgress) {, +    animator.setMaxProgress(maxProgress);, +    animator.setProgress(progress);, +    return animator.getProgress();, +++ b/LottieSample/src/main/kotlin/com/airbnb/lottie/samples/AnimationFragment.kt, +        view.animationView.addAnimatorUpdateListener { animation ->, +            if (animation.isRunning) {, +                seekBar.progress = (animation.animatedValue as Float * 100f).toInt(), +            }, +++ b/LottieSample/src/main/kotlin/com/airbnb/lottie/samples/TrimView.kt, +            return if (child == leftAnchor) {, +                maxOf(minOf(left, rightAnchor.left - leftAnchor.width), 0), +                minOf(maxOf(leftAnchor.right, left), width - rightAnchor.width), +++ b/lottie/src/main/java/com/airbnb/lottie/LottieDrawable.java, +          setProgress((Float) animation.getAnimatedValue());, +  public void resumeAnimation() {, +    playAnimation(animator.getAnimatedFraction() == 1f);, +  }, +, +  private void playAnimation(final boolean resetProgress) {, +          playAnimation(resetProgress);, +    float progress = animator.getProgress();, +    if (resetProgress || animator.getAnimatedFraction() == 1f) {, +      animator.setProgress(animator.getMinProgress());, +    } else {, +      animator.setProgress(progress);, +          playAnimation(startFrame, endFrame);, +    reverseAnimation(false);, +    float progress = getProgress();, +    reverseAnimation(true);, +  private void reverseAnimation(final boolean resetProgress) {, +          reverseAnimation(resetProgress);, +    float progress = animator.getProgress();, +    if (resetProgress || getProgress() == 1f) {, +      animator.setProgress(animator.getMinProgress());, +    } else {, +      animator.setProgress(progress);, +    }, +  public void setMinFrame(final int minFrame) {, +          setMinFrame(minFrame);, +    setMinProgress(minFrame / composition.getDurationFrames());, +   public void setMinProgress(float minProgress) {, +    animator.setMinProgress(minProgress);, +  public void setMaxFrame(final int maxFrame) {]