[+++ b/lottie/src/main/java/com/airbnb/lottie/LottieDrawable.java, +++ b/lottie/src/main/java/com/airbnb/lottie/LottieDrawable.java, +++ b/lottie/src/main/java/com/airbnb/lottie/model/layer/BaseLayer.java, +  private final Paint dstOutPaint = new LPaint(Paint.ANTI_ALIAS_FLAG, PorterDuff.Mode.DST_OUT);, +          if (mask.isInverted()) {, +            applyInvertedIntersectMask(canvas, matrix, mask, maskAnimation, opacityAnimation);, +          } else {, +          }, +    contentPaint.setAlpha((int) (opacityAnimation.getValue() * 2.55f));, +    canvas.drawPath(path, contentPaint);, +    saveLayerCompat(canvas, rect, contentPaint, true);, +    canvas.drawRect(rect, contentPaint);, +    contentPaint.setAlpha((int) (opacityAnimation.getValue() * 2.55f));, +    canvas.drawPath(path, dstOutPaint);, +    canvas.drawPath(path, dstOutPaint);, +    saveLayerCompat(canvas, rect, dstOutPaint, true);, +    canvas.drawRect(rect, contentPaint);, +    dstOutPaint.setAlpha((int) (opacityAnimation.getValue() * 2.55f));, +    canvas.drawPath(path, dstOutPaint);, +  private void applyInvertedIntersectMask(Canvas canvas, Matrix matrix, Mask mask,, +      BaseKeyframeAnimation<ShapeData, Path> maskAnimation, BaseKeyframeAnimation<Integer, Integer> opacityAnimation) {, +    saveLayerCompat(canvas, rect, dstInPaint, true);, +    canvas.drawRect(rect, contentPaint);, +    dstOutPaint.setAlpha((int) (opacityAnimation.getValue() * 2.55f));, +    Path maskPath = maskAnimation.getValue();, +    path.set(maskPath);, +    path.transform(matrix);, +    canvas.drawPath(path, dstOutPaint);, +    canvas.restore();, +  }, +]