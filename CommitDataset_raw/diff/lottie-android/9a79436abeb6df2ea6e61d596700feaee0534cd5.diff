[+++ b/LottieSample/src/main/kotlin/com/airbnb/lottie/samples/DynamicFragment.kt, +        animationView.addValueCallback(KeyPath("LeftArmWave"), LottieProperty.TIME_REMAP) { frameInfo ->, +            2 * speed.toFloat() * frameInfo.overallProgress, +        val shirt = KeyPath("Shirt", "Group 5", "Fill 1"), +        val leftArm = KeyPath("LeftArmWave", "LeftArm", "Group 6", "Fill 1"), +        val rightArm = KeyPath("RightArm", "Group 6", "Fill 1"), +, +        animationView.addValueCallback(shirt, LottieProperty.COLOR) { COLORS[colorIndex] }, +        animationView.addValueCallback(leftArm, LottieProperty.COLOR) { COLORS[colorIndex] }, +        animationView.addValueCallback(rightArm, LottieProperty.COLOR) { COLORS[colorIndex] }, +        animationView.addValueCallback(KeyPath("Body"), LottieProperty.TRANSFORM_POSITION) { frameInfo ->, +            val startX = frameInfo.startValue.x, +            var startY = frameInfo.startValue.y, +            var endY = frameInfo.endValue.y, +            if (startY > endY) {, +            } else if (endY > startY) {, +            point.set(startX, MiscUtils.lerp(startY, endY, frameInfo.interpolatedKeyframeProgress)), +            point, +++ b/LottieSample/src/main/kotlin/com/airbnb/lottie/samples/DynamicFragment.kt, +        animationView.addValueCallback(KeyPath("LeftArmWave"), LottieProperty.TIME_REMAP) { frameInfo ->, +            2 * speed.toFloat() * frameInfo.overallProgress, +        val shirt = KeyPath("Shirt", "Group 5", "Fill 1"), +        val leftArm = KeyPath("LeftArmWave", "LeftArm", "Group 6", "Fill 1"), +        val rightArm = KeyPath("RightArm", "Group 6", "Fill 1"), +, +        animationView.addValueCallback(shirt, LottieProperty.COLOR) { COLORS[colorIndex] }, +        animationView.addValueCallback(leftArm, LottieProperty.COLOR) { COLORS[colorIndex] }, +        animationView.addValueCallback(rightArm, LottieProperty.COLOR) { COLORS[colorIndex] }, +        animationView.addValueCallback(KeyPath("Body"), LottieProperty.TRANSFORM_POSITION) { frameInfo ->, +            val startX = frameInfo.startValue.x, +            var startY = frameInfo.startValue.y, +            var endY = frameInfo.endValue.y, +            if (startY > endY) {, +            } else if (endY > startY) {, +            point.set(startX, MiscUtils.lerp(startY, endY, frameInfo.interpolatedKeyframeProgress)), +            point, +++ b/lottie/src/main/java/com/airbnb/lottie/LottieAnimationView.java, +import com.airbnb.lottie.value.LottieFrameInfo;, +import com.airbnb.lottie.value.SimpleLottieValueCallback;, +   * Overload of {@link #addValueCallback(KeyPath, Object, LottieValueCallback)} that takes an interface. This allows you to use a single abstract, +   * method code block in Kotlin such as:, +   * animationView.addValueCallback(yourKeyPath, LottieProperty.COLOR) { yourColor }, +   */, +  public <T> void addValueCallback(KeyPath keyPath, T property,, +      final SimpleLottieValueCallback<T> callback) {, +    lottieDrawable.addValueCallback(keyPath, property, new LottieValueCallback<T>() {, +      @Override public T getValue(LottieFrameInfo<T> frameInfo) {, +        return callback.getValue(frameInfo);, +      }, +    });, +  }, +, +    /**, +++ b/LottieSample/src/main/kotlin/com/airbnb/lottie/samples/DynamicFragment.kt, +        animationView.addValueCallback(KeyPath("LeftArmWave"), LottieProperty.TIME_REMAP) { frameInfo ->, +            2 * speed.toFloat() * frameInfo.overallProgress, +        val shirt = KeyPath("Shirt", "Group 5", "Fill 1"), +        val leftArm = KeyPath("LeftArmWave", "LeftArm", "Group 6", "Fill 1"), +        val rightArm = KeyPath("RightArm", "Group 6", "Fill 1"), +, +        animationView.addValueCallback(shirt, LottieProperty.COLOR) { COLORS[colorIndex] }, +        animationView.addValueCallback(leftArm, LottieProperty.COLOR) { COLORS[colorIndex] }, +        animationView.addValueCallback(rightArm, LottieProperty.COLOR) { COLORS[colorIndex] }, +        animationView.addValueCallback(KeyPath("Body"), LottieProperty.TRANSFORM_POSITION) { frameInfo ->, +            val startX = frameInfo.startValue.x, +            var startY = frameInfo.startValue.y, +            var endY = frameInfo.endValue.y, +            if (startY > endY) {, +            } else if (endY > startY) {, +            point.set(startX, MiscUtils.lerp(startY, endY, frameInfo.interpolatedKeyframeProgress)), +            point, +++ b/lottie/src/main/java/com/airbnb/lottie/LottieAnimationView.java, +import com.airbnb.lottie.value.LottieFrameInfo;, +import com.airbnb.lottie.value.SimpleLottieValueCallback;, +   * Overload of {@link #addValueCallback(KeyPath, Object, LottieValueCallback)} that takes an interface. This allows you to use a single abstract, +   * method code block in Kotlin such as:, +   * animationView.addValueCallback(yourKeyPath, LottieProperty.COLOR) { yourColor }, +   */, +  public <T> void addValueCallback(KeyPath keyPath, T property,, +      final SimpleLottieValueCallback<T> callback) {, +    lottieDrawable.addValueCallback(keyPath, property, new LottieValueCallback<T>() {, +      @Override public T getValue(LottieFrameInfo<T> frameInfo) {, +        return callback.getValue(frameInfo);, +      }, +    });, +  }, +, +    /**, +++ b/lottie/src/main/java/com/airbnb/lottie/LottieDrawable.java, +import com.airbnb.lottie.value.LottieFrameInfo;, +import com.airbnb.lottie.value.SimpleLottieValueCallback;, +   * Overload of {@link #addValueCallback(KeyPath, Object, LottieValueCallback)} that takes an interface. This allows you to use a single abstract, +   * method code block in Kotlin such as:, +   * drawable.addValueCallback(yourKeyPath, LottieProperty.COLOR) { yourColor }, +   */, +  public <T> void addValueCallback(KeyPath keyPath, T property,, +      final SimpleLottieValueCallback<T> callback) {, +    addValueCallback(keyPath, property, new LottieValueCallback<T>() {, +      @Override public T getValue(LottieFrameInfo<T> frameInfo) {, +        return callback.getValue(frameInfo);]