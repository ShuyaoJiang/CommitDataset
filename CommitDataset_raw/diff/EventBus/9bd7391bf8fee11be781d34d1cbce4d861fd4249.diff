[+++ b/EventBus/src/de/greenrobot/event/SubscriberIndexEntry.java, +package de.greenrobot.event;, +, +/** Preprocessed index as used with annotation-preprocessed code generation */, +public class SubscriberIndexEntry {, +    final Class<?> subscriberType;, +    final String methodName;, +    final Class<?> eventType;, +    final ThreadMode threadMode;, +, +    public SubscriberIndexEntry(Class<?> subscriberType, String methodName, Class<?> eventType,, +                                ThreadMode threadMode) {, +        this.subscriberType = subscriberType;, +        this.methodName = methodName;, +        this.eventType = eventType;, +        this.threadMode = threadMode;, +    }, +}, +++ b/EventBus/src/de/greenrobot/event/SubscriberIndexEntry.java, +package de.greenrobot.event;, +, +/** Preprocessed index as used with annotation-preprocessed code generation */, +public class SubscriberIndexEntry {, +    final Class<?> subscriberType;, +    final String methodName;, +    final Class<?> eventType;, +    final ThreadMode threadMode;, +, +    public SubscriberIndexEntry(Class<?> subscriberType, String methodName, Class<?> eventType,, +                                ThreadMode threadMode) {, +        this.subscriberType = subscriberType;, +        this.methodName = methodName;, +        this.eventType = eventType;, +        this.threadMode = threadMode;, +    }, +}, +++ b/EventBus/src/de/greenrobot/event/SubscriberMethodFinder.java, +import android.util.Log;, +, +    private static final Map<String, List<SubscriberMethod>> METHOD_CACHE = new HashMap<String, List<SubscriberMethod>>();, +, +    /** Optional generated index without entries from subscribers super classes */, +    private static final Map<String, List<SubscriberMethod>> METHOD_INDEX;, +, +    static {, +        Map<String, List<SubscriberMethod>> index = null;, +        try {, +            Class<?> clazz = Class.forName("MyGeneratedEventBusSubscriberIndex");, +            SubscriberIndexEntry[] entries = (SubscriberIndexEntry[]) clazz.getField("INDEX").get(null);, +            Map<String, List<SubscriberMethod>> newIndex = new HashMap<String, List<SubscriberMethod>>();, +            for (SubscriberIndexEntry entry : entries) {, +                String key = entry.subscriberType.getName();, +                List<SubscriberMethod> subscriberMethods = newIndex.get(key);, +                if (subscriberMethods == null) {, +                    subscriberMethods = new ArrayList<SubscriberMethod>();, +                    newIndex.put(key, subscriberMethods);, +                }, +                Method method = entry.subscriberType.getMethod(entry.methodName, entry.eventType);, +                SubscriberMethod subscriberMethod = new SubscriberMethod(method, entry.threadMode, entry.eventType);, +                subscriberMethods.add(subscriberMethod);, +            }, +            index = newIndex;, +        } catch (ClassNotFoundException e) {, +            // Fine, +        } catch (Exception e) {, +            Log.w("Could not init @Subscribe index, reverting to dynamic look-up (slower)", e);, +        }, +        METHOD_INDEX = index;, +    }, +, +        synchronized (METHOD_CACHE) {, +            subscriberMethods = METHOD_CACHE.get(key);, +        if(METHOD_INDEX != null) {, +            subscriberMethods = findSubscriberMethodsWithIndex(subscriberClass);, +        } else {, +            subscriberMethods = findSubscriberMethodsWithReflection(subscriberClass);, +        }, +        if (subscriberMethods.isEmpty()) {, +            throw new EventBusException("Subscriber " + subscriberClass, +                    + " and its super classes have no public methods with the @Subscribe annotation");, +        } else {, +            synchronized (METHOD_CACHE) {, +                METHOD_CACHE.put(key, subscriberMethods);, +            }, +            return subscriberMethods;, +        }, +    }, +, +    private List<SubscriberMethod> findSubscriberMethodsWithIndex(Class<?> subscriberClass) {, +        List<SubscriberMethod> subscriberMethods = new ArrayList<SubscriberMethod>();, +        Class<?> clazz = subscriberClass;, +        while (clazz != null) {, +            String name = clazz.getName();, +            if (name.startsWith("java.") || name.startsWith("javax.") || name.startsWith("android.")) {, +                // Skip system classes, this just degrades performance, +                break;, +            }, +            List<SubscriberMethod> flatList = METHOD_INDEX.get(name);, +            subscriberMethods.addAll(flatList);, +]