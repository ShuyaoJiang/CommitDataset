[+++ b/EventBus/src/de/greenrobot/event/SubscriberMethodFinder.java, +        HashMap<String, Class> eventTypesFound = new HashMap<String, Class>();, +            try {, +                // This is faster than getMethods, especially when subscribers a fat classes like Activities, +                filterSubscriberMethods(subscriberMethods, eventTypesFound, methodKeyBuilder, methods);, +            } catch (Throwable th) {, +                th.printStackTrace();, +                // Workaround for java.lang.NoClassDefFoundError, see https://github.com/greenrobot/EventBus/issues/149, +                Method[] methods = subscriberClass.getMethods();, +                subscriberMethods.clear();, +                eventTypesFound.clear();, +                filterSubscriberMethods(subscriberMethods, eventTypesFound, methodKeyBuilder, methods);, +                break;, +    private void filterSubscriberMethods(List<SubscriberMethod> subscriberMethods,, +                                         HashMap<String, Class> eventTypesFound, StringBuilder methodKeyBuilder,, +                                         Method[] methods) {, +        for (Method method : methods) {, +            String methodName = method.getName();, +            if (methodName.startsWith(ON_EVENT_METHOD_NAME)) {, +                int modifiers = method.getModifiers();, +                Class<?> methodClass = method.getDeclaringClass();, +                if ((modifiers & Modifier.PUBLIC) != 0 && (modifiers & MODIFIERS_IGNORE) == 0) {, +                    Class<?>[] parameterTypes = method.getParameterTypes();, +                    if (parameterTypes.length == 1) {, +                        ThreadMode threadMode = getThreadMode(methodClass, method, methodName);, +                        if (threadMode == null) {, +                            continue;, +                        }, +                        Class<?> eventType = parameterTypes[0];, +                        methodKeyBuilder.setLength(0);, +                        methodKeyBuilder.append(methodName);, +                        methodKeyBuilder.append('>').append(eventType.getName());, +                        String methodKey = methodKeyBuilder.toString();, +                        Class methodClassOld = eventTypesFound.put(methodKey, methodClass);, +                        if (methodClassOld == null || methodClassOld.isAssignableFrom(methodClass)) {, +                            // Only add if not already found in a sub class, +                            subscriberMethods.add(new SubscriberMethod(method, threadMode, eventType));, +                        } else {, +                            // Revert the put, old class is further down the class hierarchy, +                            eventTypesFound.put(methodKey, methodClassOld);, +                        }, +                    }, +                } else if (!skipMethodVerificationForClasses.containsKey(methodClass)) {, +                    Log.d(EventBus.TAG, "Skipping method (not public, static or abstract): " + methodClass + ".", +                            + methodName);, +                }, +            }, +        }, +    }, +, +    private ThreadMode getThreadMode(Class<?> clazz, Method method, String methodName) {, +        String modifierString = methodName.substring(ON_EVENT_METHOD_NAME.length());, +        ThreadMode threadMode;, +        if (modifierString.length() == 0) {, +            threadMode = ThreadMode.PostThread;, +        } else if (modifierString.equals("MainThread")) {, +            threadMode = ThreadMode.MainThread;, +        } else if (modifierString.equals("BackgroundThread")) {, +            threadMode = ThreadMode.BackgroundThread;, +        } else if (modifierString.equals("Async")) {, +            threadMode = ThreadMode.Async;, +        } else {, +            if (!skipMethodVerificationForClasses.containsKey(clazz)) {, +                throw new EventBusException("Illegal onEvent method, check for typos: " + method);, +            } else {, +                threadMode = null;, +            }, +        }, +        return threadMode;, +    }, +]