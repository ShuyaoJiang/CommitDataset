[+++ b/EventBus/src/de/greenrobot/event/EventBus.java, +        if (subscribedClasses != null) {, +            if (subscribedClasses.isEmpty()) {, +                typesBySubscriber.remove(subscriber);, +            }, +        if (subscribedTypes != null) {, +            typesBySubscriber.remove(subscriber);, +++ b/EventBus/src/de/greenrobot/event/EventBus.java, +        if (subscribedClasses != null) {, +            if (subscribedClasses.isEmpty()) {, +                typesBySubscriber.remove(subscriber);, +            }, +        if (subscribedTypes != null) {, +            typesBySubscriber.remove(subscriber);, +++ b/EventBusTest/src/de/greenrobot/event/test/EventBusBasicTest.java, +import java.lang.ref.WeakReference;, +, +    public void testUnregisterNotLeaking() {, +        EventBusBasicTest subscriber = new EventBusBasicTest();, +        eventBus.register(subscriber);, +        eventBus.unregister(subscriber);, +, +        WeakReference<EventBusBasicTest> ref = new WeakReference<EventBusBasicTest>(subscriber);, +        subscriber = null;, +        assertSubscriberNotReferenced(ref);, +    }, +, +    public void testUnregisterForClassNotLeaking() {, +        EventBusBasicTest subscriber = new EventBusBasicTest();, +        eventBus.register(subscriber, String.class);, +        eventBus.unregister(subscriber, String.class);, +, +        WeakReference<EventBusBasicTest> ref = new WeakReference<EventBusBasicTest>(subscriber);, +        subscriber = null;, +        assertSubscriberNotReferenced(ref);, +    }, +, +    private void assertSubscriberNotReferenced(WeakReference<EventBusBasicTest> ref) {, +        EventBusBasicTest subscriberTest = new EventBusBasicTest();, +        WeakReference<EventBusBasicTest> refTest = new WeakReference<EventBusBasicTest>(subscriberTest);, +        subscriberTest = null;, +, +        // Yeah, in theory is is questionable (in practice just fine so far...), +        System.gc();, +, +        assertNull(refTest.get());, +        assertNull(ref.get());, +    }, +, +++ b/EventBus/src/de/greenrobot/event/EventBus.java, +        if (subscribedClasses != null) {, +            if (subscribedClasses.isEmpty()) {, +                typesBySubscriber.remove(subscriber);, +            }, +        if (subscribedTypes != null) {, +            typesBySubscriber.remove(subscriber);, +++ b/EventBusTest/src/de/greenrobot/event/test/EventBusBasicTest.java, +import java.lang.ref.WeakReference;, +, +    public void testUnregisterNotLeaking() {, +        EventBusBasicTest subscriber = new EventBusBasicTest();, +        eventBus.register(subscriber);, +        eventBus.unregister(subscriber);, +, +        WeakReference<EventBusBasicTest> ref = new WeakReference<EventBusBasicTest>(subscriber);, +        subscriber = null;, +        assertSubscriberNotReferenced(ref);, +    }, +, +    public void testUnregisterForClassNotLeaking() {, +        EventBusBasicTest subscriber = new EventBusBasicTest();, +        eventBus.register(subscriber, String.class);, +        eventBus.unregister(subscriber, String.class);, +, +        WeakReference<EventBusBasicTest> ref = new WeakReference<EventBusBasicTest>(subscriber);, +        subscriber = null;, +        assertSubscriberNotReferenced(ref);, +    }, +, +    private void assertSubscriberNotReferenced(WeakReference<EventBusBasicTest> ref) {, +        EventBusBasicTest subscriberTest = new EventBusBasicTest();, +        WeakReference<EventBusBasicTest> refTest = new WeakReference<EventBusBasicTest>(subscriberTest);, +        subscriberTest = null;, +, +        // Yeah, in theory is is questionable (in practice just fine so far...), +        System.gc();, +, +        assertNull(refTest.get());, +        assertNull(ref.get());, +    }, +, +++ b/README.md, +EventBus is an Android optimized publish/subscribe event bus. A typical use case for Android apps is gluing Activities, Fragments, and background threads together. Conventional wiring of those elements often introduces complex and error-prone dependencies and life cycle issues. Propagating listeners through all participants (e.g. background service -> activity -> multiple fragments or helper classes) becomes deprecated. EventBus decouples event senders and receivers and thus simplifies communication between app components. And you don't need to implement a single interface!, +1. Implement any number of event handling methods in the subscriber: public void onEvent(AnyEventType event) {}, +2. Register subscribers: eventBus.register(this);, +3. Post events to the bus: eventBus.post(event);, +4. Unregister subscriber: eventBus.unregister(this);, +The API is very close to (Guava's event bus)[http://code.google.com/p/guava-libraries/wiki/EventBusExplained] and its Android port [otto](http://square.github.com/otto/) ([announcement](http://corner.squareup.com/2012/07/otto.html)). Have a look at their documentation for publishers and posting events (skip producers, EventBus does not support producers because we haven't figured out valid use cases for those)., +* *Simple to use thread transitions:* Events can be received in Android's main thread, even if they were posted in a background thread. Subscribers that want to be called on the main thread call registerForMainThread() instead of register(). For example, UI updates become trivial for state changes caused by background workers. And because of the decoupling, , +* *NOT based on annotations:* Querying annotations are slow on Android, especially before Android 4.0. Have a look at this (Android bug report)[http://code.google.com/p/android/issues/detail?id=7811]]