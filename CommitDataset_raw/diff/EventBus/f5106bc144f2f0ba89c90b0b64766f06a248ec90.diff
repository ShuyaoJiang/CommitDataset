[+++ b/EventBus/src/de/greenrobot/event/SubscriberMethodFinder.java, +            Class<?> clazz = Class.forName("de.greenrobot.event.GeneratedSubscriberIndex");, +            if (subscriberMethods.isEmpty()) {, +                subscriberMethods = findSubscriberMethodsWithReflection(subscriberClass);, +            }, +++ b/EventBus/src/de/greenrobot/event/SubscriberMethodFinder.java, +            Class<?> clazz = Class.forName("de.greenrobot.event.GeneratedSubscriberIndex");, +            if (subscriberMethods.isEmpty()) {, +                subscriberMethods = findSubscriberMethodsWithReflection(subscriberClass);, +            }, +++ b/EventBusAnnotationProcessor/src/de/greenrobot/event/annotationprocessor/EventBusAnnotationProcessor.java, +    private final Map<TypeElement, List<ExecutableElement>> methodsByClass =, +            new HashMap<TypeElement, List<ExecutableElement>>();, +    private final Set<TypeElement> classesToSkip = new HashSet<TypeElement>();, +, +        try {, +            checkForSubscribersToSkip(messager);, +        } catch (RuntimeException e) {, +            // IntelliJ does not handle exceptions nicely, so log and print a message, +            e.printStackTrace();, +            messager.printMessage(Diagnostic.Kind.ERROR, "Unexpected error in EventBusAnnotationProcessor: " + e);, +        }, +    private void collectSubscribers(Set<? extends TypeElement> annotations, RoundEnvironment env, Messager messager) {, +        for (TypeElement annotation : annotations) {, +            Set<? extends Element> elements = env.getElementsAnnotatedWith(annotation);, +            for (Element element : elements) {, +                if (element instanceof ExecutableElement) {, +                    ExecutableElement method = (ExecutableElement) element;, +                    if (checkHasErrors(method, messager)) {, +                        Element classElement = method.getEnclosingElement();, +                        List<ExecutableElement> methods = methodsByClass.get(classElement);, +                        if (methods == null) {, +                            methods = new ArrayList<ExecutableElement>();, +                            methodsByClass.put((TypeElement) classElement, methods);, +                        }, +                        methods.add(method);, +                    }, +                } else {, +                    messager.printMessage(Diagnostic.Kind.ERROR, "@Subscribe is only valid for methods", element);, +                }, +            }, +        }, +    }, +, +    private boolean checkHasErrors(ExecutableElement element, Messager messager) {, +    private void checkForSubscribersToSkip(Messager messager) {, +        for (Map.Entry<TypeElement, List<ExecutableElement>> entry : methodsByClass.entrySet()) {, +            TypeElement skipCandidate = entry.getKey();, +            TypeElement subscriberClass = skipCandidate;, +            while (subscriberClass != null) {, +                if (!subscriberClass.getModifiers().contains(Modifier.PUBLIC)) {, +                    boolean added = classesToSkip.add(skipCandidate);, +                    if (added) {, +                        String msg;, +                        if (subscriberClass.equals(skipCandidate)) {, +                            msg = "Falling back to reflection because class is not public";, +                        } else {, +                            msg = "Falling back to reflection because " + skipCandidate +, +                                    " has a non-public super class";, +                        messager.printMessage(Diagnostic.Kind.NOTE, msg, subscriberClass);, +                    }, +                    break;, +                }, +                List<ExecutableElement> methods = methodsByClass.get(subscriberClass);, +                if (methods != null) {, +                    for (ExecutableElement method : methods) {, +                        VariableElement param = method.getParameters().get(0);, +                        DeclaredType paramType = (DeclaredType) param.asType();, +                        Set<Modifier> eventClassModifiers = paramType.asElement().getModifiers();, +                        if (!eventClassModifiers.contains(Modifier.PUBLIC)) {, +                            boolean added = classesToSkip.add(skipCandidate);, +                            if (added) {, +                                String msg;, +                                if (subscriberClass.equals(skipCandidate)) {, +                                    msg = "Falling back to reflection because event type is not public";, +                                } else {, +                                    msg = "Falling back to reflection because " + skipCandidate +, +                                            " has a super class using a non-public event type";, +                                }, +                                messager.printMessage(Diagnostic.Kind.NOTE, msg, subscriberClass);, +                            }, +                            break;, +                subscriberClass = getSuperclass(subscriberClass);, +            }, +        }, +    }, +, +    private TypeElement getSuperclass(TypeElement type) {, +        if (type.getSuperclass().getKind() == TypeKind.DECLARED) {, +            TypeElement superclass = (TypeElement) processingEnv.getTypeUtils().asElement(type.getSuperclass());, +            String name = superclass.getQualifiedName().toString();, +            if (name.startsWith("java.") || name.startsWith("javax.") || name.startsWith("android.")) {, +                // Skip system classes, this just degrades performance, +                return null;, +            } else {, +                return superclass;, +            }, +        } else {, +            return null;, +        }]