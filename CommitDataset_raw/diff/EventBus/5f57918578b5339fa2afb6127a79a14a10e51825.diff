[+++ b/EventBus/src/de/greenrobot/event/EventBus.java, +                Subscription subscription = subscriptions.get(i);, +                if (subscription.subscriber == subscriber) {, +                    subscription.active = false;, +    /**, +     * Invokes the subscriber if the subscriptions is still active. Skipping subscriptions prevents race conditions, +     * between {@link #unregister(Object)} and event delivery. Otherwise the event might be delivered after the, +     * subscriber unregistered. This is particularly important for main thread delivery and registrations bound to the, +     * live cycle of an Activity or Fragment., +     */, +        if (subscription.active) {, +    }, +++ b/EventBus/src/de/greenrobot/event/EventBus.java, +                Subscription subscription = subscriptions.get(i);, +                if (subscription.subscriber == subscriber) {, +                    subscription.active = false;, +    /**, +     * Invokes the subscriber if the subscriptions is still active. Skipping subscriptions prevents race conditions, +     * between {@link #unregister(Object)} and event delivery. Otherwise the event might be delivered after the, +     * subscriber unregistered. This is particularly important for main thread delivery and registrations bound to the, +     * live cycle of an Activity or Fragment., +     */, +        if (subscription.active) {, +    }, +++ b/EventBus/src/de/greenrobot/event/SubscriberMethod.java, +            SubscriberMethod otherSubscriberMethod = (SubscriberMethod)other;, +            otherSubscriberMethod.checkMethodString();, +            return methodString.equals(otherSubscriberMethod.methodString);, +++ b/EventBus/src/de/greenrobot/event/EventBus.java, +                Subscription subscription = subscriptions.get(i);, +                if (subscription.subscriber == subscriber) {, +                    subscription.active = false;, +    /**, +     * Invokes the subscriber if the subscriptions is still active. Skipping subscriptions prevents race conditions, +     * between {@link #unregister(Object)} and event delivery. Otherwise the event might be delivered after the, +     * subscriber unregistered. This is particularly important for main thread delivery and registrations bound to the, +     * live cycle of an Activity or Fragment., +     */, +        if (subscription.active) {, +    }, +++ b/EventBus/src/de/greenrobot/event/SubscriberMethod.java, +            SubscriberMethod otherSubscriberMethod = (SubscriberMethod)other;, +            otherSubscriberMethod.checkMethodString();, +            return methodString.equals(otherSubscriberMethod.methodString);, +++ b/EventBus/src/de/greenrobot/event/Subscription.java, +    /**, +     * Becomes false as soon as {@link EventBus#unregister(Object)} is called, which is checked by queued event delivery, +     * {@link EventBus#invokeSubscriber(PendingPost)} to prevent race conditions., +     */, +    volatile boolean active;, +        active = true;, +            return subscriber == otherSubscription.subscriber, +                    && subscriberMethod.equals(otherSubscription.subscriberMethod);, +++ b/EventBus/src/de/greenrobot/event/EventBus.java, +                Subscription subscription = subscriptions.get(i);, +                if (subscription.subscriber == subscriber) {, +                    subscription.active = false;, +    /**, +     * Invokes the subscriber if the subscriptions is still active. Skipping subscriptions prevents race conditions, +     * between {@link #unregister(Object)} and event delivery. Otherwise the event might be delivered after the, +     * subscriber unregistered. This is particularly important for main thread delivery and registrations bound to the, +     * live cycle of an Activity or Fragment., +     */, +        if (subscription.active) {, +    }, +++ b/EventBus/src/de/greenrobot/event/SubscriberMethod.java, +            SubscriberMethod otherSubscriberMethod = (SubscriberMethod)other;, +            otherSubscriberMethod.checkMethodString();, +            return methodString.equals(otherSubscriberMethod.methodString);, +++ b/EventBus/src/de/greenrobot/event/Subscription.java, +    /**, +     * Becomes false as soon as {@link EventBus#unregister(Object)} is called, which is checked by queued event delivery, +     * {@link EventBus#invokeSubscriber(PendingPost)} to prevent race conditions., +     */, +    volatile boolean active;, +        active = true;, +            return subscriber == otherSubscription.subscriber, +                    && subscriberMethod.equals(otherSubscription.subscriberMethod);, +++ b/EventBusTest/src/de/greenrobot/event/test/EventBusMainThreadRacingTest.java, +/*, + * Copyright (C) 2013 Markus Junginger, greenrobot (http://greenrobot.de), + *, + * Licensed under the Apache License, Version 2.0 (the "License");, + * you may not use this file except in compliance with the License., + * You may obtain a copy of the License at, + *, + *      http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS,, + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied., + * See the License for the specific language governing permissions and, + * limitations under the License., + */, +package de.greenrobot.event.test;, +, +import java.util.Random;, +import java.util.concurrent.CountDownLatch;, +import java.util.concurrent.TimeUnit;, +]