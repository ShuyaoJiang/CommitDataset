[+++ b/HOWTO.md, +EventBus How-To, +===============, +In the [README file](README.md), you got to know EventBus, some of its basic principles, and even some code examples. In that README, you also saw how to add EventBus to your project using Maven Central. Great, now let's dive deeper!, +, +General usage and API, +---------------------, +**1- Define event class (aka POJO - plain old Java object)**, +```java, +public class MessageEvent {, +    public final String message;, +, +    public MessageEvent(String message) {, +        this.message = message;, +    }, +, +}, +```, +**2- Subscribers register to EventBus**, +, +The **subscribers** implement event handling `onEvent` methods that will be called when an event is received. They also need to register themselves to the bus. , +, +```java, +    @Override, +    public void onStart() {, +        super.onStart();, +        EventBus.getDefault().register(this);, +    }, +, +    @Override, +    public void onStop() {, +        EventBus.getDefault().unregister(this);, +        super.onStop();, +    }, +    , +    // This method will be called when a MessageEvent is posted, +    public void onEvent(MessageEvent event){, +        Toast.makeText(getActivity(), event.getMessage().toString(), Toast.LENGTH_SHORT).show();, +    }, +    , +    // In case many events are subscribed, just add another method with the event type, +    // This method will be called when a SomeOtherMessageEvent is posted, +    public void onEvent(SomeOtherEvent event){, +        Toast.makeText(getActivity(), event.getMessage().toString(), Toast.LENGTH_SHORT).show();, +    }, +    , +```, +**3- Post event**, +Post an event from any part of your code. All subscribers matching the event type, will receive it., +```java, +    EventBus.getDefault().post(new MessageEvent("hello!"));, +```, +Delivery threads and ThreadModes, +--------------------------------, +EventBus can handle threading for you: events can be posted in threads different from the posting thread. , +, +A common use case is dealing with UI changes. In Android, UI changes must be done in the UI thread and networking (or any time consuming task) must be done in other treads. EventBus will help you to deal with those tasks and synchronize with the UI thread (without having to delve into thread transitions, using AsyncTask, etc)., +, +In EventBus, you may define the thread that will call the event handling method `onEvent` by using a **ThreadMode**:, +* **PostThread:** Subscriber will be called in the same thread, which is posting the event. This is the default. Event delivery implies the least overhead because it avoids thread switching completely. Thus this is the recommended mode for simple tasks that are known to complete is a very short time without requiring the main thread. Event handlers using this mode must return quickly to avoid blocking the posting thread, which may be the main thread., +Example:, +```java, +    // Called in the same thread (default), +    public void onEvent(MessageEvent event) {, +        log(event.message);, +    }, +```, +* **MainThread:** Subscriber will be called in Android's main thread (sometimes referred to as UI thread). If the posting thread is the main thread, event handler methods will be called directly. Event handlers using this mode must return quickly to avoid blocking the main thread., +Example:, +```java, +    // Called in Android UI's main thread, +    public void onEventMainThread(MessageEvent event) {, +        textField.setText(event.message);, +    }, +```, +* **BackgroundThread:** Subscriber will be called in a background thread. If posting thread is not the main thread, event handler methods will be called directly in the posting thread. If the posting thread is the main thread, EventBus uses a single background thread that will deliver all its events sequentially. Event handlers using this mode should try to return quickly to avoid blocking the background thread., +```java, +    // Called in the background thread, +    public void onEventBackgroundThread(MessageEvent event){, +        saveToDisk(event.message);, +    }, +```, +* **Async:** Event handler methods are called in a separate thread. This is always independent from the posting thread and the main thread. Posting events never wait for event handler methods using this mode. Event handler methods should use this mode if their execution might take some time, e.g. for network access. Avoid triggering a large number of long running asynchronous handler methods at the same time to limit the number of concurrent threads. EventBus uses a thread pool to efficiently reuse threads from completed asynchronous event handler notifications., +```java, +    // Called in a separate thread, +    public void onEventAsync(MessageEvent event){, +        backend.send(event.message);, +    }, +```, +, +*Note:* EventBus takes care of calling the `onEvent` method in the proper thread depending on its name (onEvent, onEventAsync, etc.)., +, +Subscriber priorities and ordered event delivery, +------------------------------------------------, +You may change the order of event delivery by providing a priority to the subscriber during registration., +, +```java, +    int priority = 1 ;, +    EventBus.getDefault().register(this, priority);, +```]