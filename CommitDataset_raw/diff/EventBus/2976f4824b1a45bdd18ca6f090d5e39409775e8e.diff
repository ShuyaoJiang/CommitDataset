[+++ b/COMPARISON.md, +        <td>Name conventions</td>, +++ b/COMPARISON.md, +        <td>Name conventions</td>, +++ b/EventBus/build.gradle, +version = '2.4.2-SNAPSHOT', +, +            pom.artifactId = 'eventbus', +++ b/COMPARISON.md, +        <td>Name conventions</td>, +++ b/EventBus/build.gradle, +version = '2.4.2-SNAPSHOT', +, +            pom.artifactId = 'eventbus', +++ b/EventBus/src/de/greenrobot/event/EventBus.java, + * Copyright (C) 2012 Markus Junginger, greenrobot (http://greenrobot.de), + * subscribers must register themselves to the bus using {@link #register(Object)}. Once registered,, + * subscribers receive events until {@link #unregister(Object)} is called. By convention, event handling methods must, + * be named "onEvent", be public, return nothing (void), and have exactly one parameter (the event)., +    public static String TAG = "Event";, +    private static final Map<Class<?>, List<Class<?>>> eventTypesCache = new HashMap<Class<?>, List<Class<?>>>();, +, +        subscriptionsByEventType = new HashMap<Class<?>, CopyOnWriteArrayList<Subscription>>();, +        typesBySubscriber = new HashMap<Object, List<Class<?>>>();, +        stickyEvents = new ConcurrentHashMap<Class<?>, Object>();, +        subscriberMethodFinder = new SubscriberMethodFinder(builder.skipMethodVerificationForClasses);, +, +     * Subscribers have event handling methods that are identified by their name, typically called "onEvent". Event, +     * handling methods must have exactly one parameter, the event. If the event handling method is to be called in a, +     * specific thread, a modifier is appended to the method name. Valid modifiers match one of the {@link ThreadMode}, +     * enums. For example, if a method is to be called in the UI/main thread by EventBus, it would be called, +     * "onEventMainThread"., +        register(subscriber, false, 0);, +, +    /**, +     * Like {@link #register(Object)} with an additional subscriber priority to influence the order of event delivery., +     * Within the same delivery thread ({@link ThreadMode}), higher priority subscribers will receive events before, +     * others with a lower priority. The default priority is 0. Note: the priority does *NOT* affect the order of, +     * delivery among subscribers with different {@link ThreadMode}s!, +     */, +    public void register(Object subscriber, int priority) {, +        register(subscriber, false, priority);, +    }, +, +    /**, +     * Like {@link #register(Object)}, but also triggers delivery of the most recent sticky event (posted with, +     * {@link #postSticky(Object)}) to the given subscriber., +     */, +    public void registerSticky(Object subscriber) {, +        register(subscriber, true, 0);, +    }, +, +    /**, +     * Like {@link #register(Object, int)}, but also triggers delivery of the most recent sticky event (posted with, +     * {@link #postSticky(Object)}) to the given subscriber., +     */, +    public void registerSticky(Object subscriber, int priority) {, +        register(subscriber, true, priority);, +    }, +, +    private synchronized void register(Object subscriber, boolean sticky, int priority) {, +        List<SubscriberMethod> subscriberMethods = subscriberMethodFinder.findSubscriberMethods(subscriber.getClass());, +        for (SubscriberMethod subscriberMethod : subscriberMethods) {, +            subscribe(subscriber, subscriberMethod, sticky, priority);, +    private void subscribe(Object subscriber, SubscriberMethod subscriberMethod, boolean sticky, int priority) {, +        Subscription newSubscription = new Subscription(subscriber, subscriberMethod, priority);, +            subscriptions = new CopyOnWriteArrayList<Subscription>();, +        // Starting with EventBus 2.2 we enforced methods to be public (might change with annotations again), +        // subscriberMethod.method.setAccessible(true);, +, +            if (i == size || newSubscription.priority > subscriptions.get(i).priority) {, +            subscribedEvents = new ArrayList<Class<?>>();, +        if (sticky) {, +     * {@link #register(Object, int)}). Canceling is restricted to event handling methods running in posting thread, +     * {@link ThreadMode#PostThread}., +        } else if (postingState.subscription.subscriberMethod.threadMode != ThreadMode.PostThread) {, +     * event of an event's type is kept in memory for future access. This can be {@link #registerSticky(Object)} or, +     * {@link #getStickyEvent(Class)}., +            case PostThread:, +            case MainThread:, +            case BackgroundThread:, +            case Async:, +    private List<Class<?>> lookupAllEventTypes(Class<?> eventClass) {, +                eventTypes = new ArrayList<Class<?>>();, +++ b/COMPARISON.md, +        <td>Name conventions</td>, +++ b/EventBus/build.gradle, +version = '2.4.2-SNAPSHOT', +, +            pom.artifactId = 'eventbus', +++ b/EventBus/src/de/greenrobot/event/EventBus.java, + * Copyright (C) 2012 Markus Junginger, greenrobot (http://greenrobot.de), + * subscribers must register themselves to the bus using {@link #register(Object)}. Once registered,, + * subscribers receive events until {@link #unregister(Object)} is called. By convention, event handling methods must, + * be named "onEvent", be public, return nothing (void), and have exactly one parameter (the event)., +    public static String TAG = "Event";, +    private static final Map<Class<?>, List<Class<?>>> eventTypesCache = new HashMap<Class<?>, List<Class<?>>>();, +, +        subscriptionsByEventType = new HashMap<Class<?>, CopyOnWriteArrayList<Subscription>>();, +        typesBySubscriber = new HashMap<Object, List<Class<?>>>();]