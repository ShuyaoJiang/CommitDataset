[+++ b/EventBusAnnotationProcessor/res/META-INF/services/javax.annotation.processing.Processor, +org.greenrobot.eventbus.annotationprocessor.EventBusAnnotationProcessor, +++ b/EventBusAnnotationProcessor/res/META-INF/services/javax.annotation.processing.Processor, +org.greenrobot.eventbus.annotationprocessor.EventBusAnnotationProcessor, +++ /dev/null, +++ b/EventBusAnnotationProcessor/res/META-INF/services/javax.annotation.processing.Processor, +org.greenrobot.eventbus.annotationprocessor.EventBusAnnotationProcessor, +++ /dev/null, +++ b/EventBusAnnotationProcessor/src/org/greenrobot/eventbus/annotationprocessor/EventBusAnnotationProcessor.java, +package org.greenrobot.eventbus.annotationprocessor;, +, +import org.greenrobot.eventbus.Subscribe;, +import org.greenrobot.eventbus.ThreadMode;, +, +import java.io.BufferedWriter;, +import java.io.IOException;, +import java.util.ArrayList;, +import java.util.HashMap;, +import java.util.HashSet;, +import java.util.List;, +import java.util.Map;, +import java.util.Set;, +, +import javax.annotation.processing.AbstractProcessor;, +import javax.annotation.processing.Messager;, +import javax.annotation.processing.RoundEnvironment;, +import javax.annotation.processing.SupportedAnnotationTypes;, +import javax.lang.model.SourceVersion;, +import javax.lang.model.element.Element;, +import javax.lang.model.element.ExecutableElement;, +import javax.lang.model.element.Modifier;, +import javax.lang.model.element.PackageElement;, +import javax.lang.model.element.TypeElement;, +import javax.lang.model.element.VariableElement;, +import javax.lang.model.type.DeclaredType;, +import javax.lang.model.type.TypeKind;, +import javax.lang.model.type.TypeMirror;, +import javax.tools.Diagnostic;, +import javax.tools.JavaFileObject;, +, +@SupportedAnnotationTypes("org.greenrobot.eventbus.Subscribe"), +public class EventBusAnnotationProcessor extends AbstractProcessor {, +    public static final String INFO_CLASS_POSTFIX = "_EventBusInfo";, +, +    /** Found subscriber methods for a class (without superclasses). */, +    private final Map<TypeElement, List<ExecutableElement>> methodsByClass = new HashMap<>();, +    private final Map<TypeElement, String> infoByClass = new HashMap<>();, +    private final Set<TypeElement> classesToSkip = new HashSet<>();, +, +    private boolean writerRoundDone;, +    private int round;, +, +    @Override, +    public SourceVersion getSupportedSourceVersion() {, +        return SourceVersion.latest();, +    }, +, +    @Override, +    public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment env) {, +        Messager messager = processingEnv.getMessager();, +        try {, +            round++;, +            messager.printMessage(Diagnostic.Kind.NOTE, "Processing round " + round + ", new annotations: " +, +                    !annotations.isEmpty() + ", processingOver: " + env.processingOver());, +            if (env.processingOver()) {, +                if (!annotations.isEmpty()) {, +                    messager.printMessage(Diagnostic.Kind.ERROR,, +                            "Unexpected processing state: annotations still available after processing over");, +                    return false;, +                }, +            }, +            if (annotations.isEmpty()) {, +                return false;, +            }, +, +            if (writerRoundDone) {, +                messager.printMessage(Diagnostic.Kind.ERROR,, +                        "Unexpected processing state: annotations still available after writing.");, +            }, +            collectSubscribers(annotations, env, messager);, +            checkForSubscribersToSkip(messager);, +, +            if (!methodsByClass.isEmpty()) {, +                createInfoFiles();, +                String index = processingEnv.getOptions().get("eventBusIndex");, +                if (index != null) {, +                    createInfoIndexFile(index);, +                }, +            } else {, +                messager.printMessage(Diagnostic.Kind.WARNING, "No @Subscribe annotations found");, +            }, +            writerRoundDone = true;, +        } catch (RuntimeException e) {, +            // IntelliJ does not handle exceptions nicely, so log and print a message, +            e.printStackTrace();, +            messager.printMessage(Diagnostic.Kind.ERROR, "Unexpected error in EventBusAnnotationProcessor: " + e);, +        }, +        return true;, +    }, +]