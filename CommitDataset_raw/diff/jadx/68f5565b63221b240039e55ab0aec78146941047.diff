[+++ b/jadx-core/src/main/java/jadx/core/dex/instructions/InsnDecoder.java, +		} catch (Exception e) {, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/InsnDecoder.java, +		} catch (Exception e) {, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java, +		if (catchBlocks.length == 0 && tries.length == 0) {, +			return;, +		}, +			InsnNode insn = insnByOffset[offset];, +			insn.add(AFlag.TRY_ENTER);, +				insn = insnByOffset[offset];, +				catchBlock.addInsn(insn);, +			} else {, +				insn.add(AFlag.TRY_LEAVE);, +			if (parentClass.getClassInfo().isInner(), +					&& !parentClass.getAccessFlags().isStatic()) {, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/InsnDecoder.java, +		} catch (Exception e) {, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java, +		if (catchBlocks.length == 0 && tries.length == 0) {, +			return;, +		}, +			InsnNode insn = insnByOffset[offset];, +			insn.add(AFlag.TRY_ENTER);, +				insn = insnByOffset[offset];, +				catchBlock.addInsn(insn);, +			} else {, +				insn.add(AFlag.TRY_LEAVE);, +			if (parentClass.getClassInfo().isInner(), +					&& !parentClass.getAccessFlags().isStatic()) {, +++ b/jadx-core/src/main/java/jadx/core/dex/regions/loops/LoopRegion.java, +			}, +		return "LOOP:" + info.getId() + ": " + baseString();, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/InsnDecoder.java, +		} catch (Exception e) {, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java, +		if (catchBlocks.length == 0 && tries.length == 0) {, +			return;, +		}, +			InsnNode insn = insnByOffset[offset];, +			insn.add(AFlag.TRY_ENTER);, +				insn = insnByOffset[offset];, +				catchBlock.addInsn(insn);, +			} else {, +				insn.add(AFlag.TRY_LEAVE);, +			if (parentClass.getClassInfo().isInner(), +					&& !parentClass.getAccessFlags().isStatic()) {, +++ b/jadx-core/src/main/java/jadx/core/dex/regions/loops/LoopRegion.java, +			}, +		return "LOOP:" + info.getId() + ": " + baseString();, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/BlockMakerVisitor.java, +				SplitterBlockAttr splitter = new SplitterBlockAttr(curBlock);, +				block.addAttr(splitter);, +				curBlock.addAttr(splitter);, +					BlockNode splitterBlock = spl.getBlock();, +					boolean tryEnd = insn.contains(AFlag.TRY_LEAVE);, +						BlockNode handlerBlock = getBlock(h.getHandleOffset(), blocksMap);, +						if (splitterBlock != handlerBlock) {, +							connect(splitterBlock, handlerBlock);, +						}, +						if (tryEnd) {, +							connect(block, handlerBlock);, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/InsnDecoder.java, +		} catch (Exception e) {, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java, +		if (catchBlocks.length == 0 && tries.length == 0) {, +			return;, +		}, +			InsnNode insn = insnByOffset[offset];, +			insn.add(AFlag.TRY_ENTER);, +				insn = insnByOffset[offset];, +				catchBlock.addInsn(insn);, +			} else {, +				insn.add(AFlag.TRY_LEAVE);, +			if (parentClass.getClassInfo().isInner(), +					&& !parentClass.getAccessFlags().isStatic()) {, +++ b/jadx-core/src/main/java/jadx/core/dex/regions/loops/LoopRegion.java, +			}, +		return "LOOP:" + info.getId() + ": " + baseString();, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/BlockMakerVisitor.java, +				SplitterBlockAttr splitter = new SplitterBlockAttr(curBlock);, +				block.addAttr(splitter);, +				curBlock.addAttr(splitter);, +					BlockNode splitterBlock = spl.getBlock();, +					boolean tryEnd = insn.contains(AFlag.TRY_LEAVE);, +						BlockNode handlerBlock = getBlock(h.getHandleOffset(), blocksMap);, +						if (splitterBlock != handlerBlock) {, +							connect(splitterBlock, handlerBlock);, +						}, +						if (tryEnd) {, +							connect(block, handlerBlock);, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java, +		if (!exitBlocks.isEmpty()) {, +				List<LoopInfo> list = mth.getAllLoopsForBlock(block);, +				if (list.size() >= 2) {, +					// bad condition if successors going out of all loops, +					boolean allOuter = true;, +					for (BlockNode outerBlock : block.getCleanSuccessors()) {, +						List<LoopInfo> outLoopList = mth.getAllLoopsForBlock(outerBlock);, +						outLoopList.remove(loop);]