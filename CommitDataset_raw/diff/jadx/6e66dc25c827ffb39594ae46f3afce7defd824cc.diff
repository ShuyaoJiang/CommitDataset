[+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/IfRegionVisitor.java, +		if (!RegionUtils.hasExitBlock(ifRegion.getThenRegion())) {, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/IfRegionVisitor.java, +		if (!RegionUtils.hasExitBlock(ifRegion.getThenRegion())) {, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java, +import java.util.Optional;, +						insertLoopBreak(stack, loop, loopExit, exitEdge);, +			if (found && !checkLoopExits(loop, block)) {, +				found = false;, +			}, +	private boolean checkLoopExits(LoopInfo loop, BlockNode mainExitBlock) {, +		List<Edge> exitEdges = loop.getExitEdges();, +		if (exitEdges.size() < 2) {, +			return true;, +		}, +		Optional<Edge> mainEdgeOpt = exitEdges.stream().filter(edge -> edge.getSource() == mainExitBlock).findFirst();, +		if (!mainEdgeOpt.isPresent()) {, +			throw new JadxRuntimeException("Not found exit edge by exit block: " + mainExitBlock);, +		}, +		Edge mainExitEdge = mainEdgeOpt.get();, +		BlockNode mainOutBlock = skipSyntheticSuccessor(mainExitEdge.getTarget());, +		for (Edge exitEdge : exitEdges) {, +			if (exitEdge != mainExitEdge) {, +				BlockNode outBlock = skipSyntheticSuccessor(exitEdge.getTarget());, +				// all exit paths must be same or don't cross (will be inside loop), +				if (!isEqualPaths(mainOutBlock, outBlock)) {, +					BlockNode crossBlock = BlockUtils.getPathCross(mth, mainOutBlock, outBlock);, +					if (crossBlock != null) {, +						return false;, +					}, +				}, +			}, +		}, +		return true;, +	}, +, +			if (insertLoopBreak(stack, loop, exit, exitEdge)) {, +						insertLoopBreak(stack, loop, block, exitEdge);, +						insertLoopBreak(stack, loop, exit, exitEdge);, +	private boolean insertLoopBreak(RegionStack stack, LoopInfo loop, BlockNode loopExit, Edge exitEdge) {, +		breakInsn.addAttr(AType.LOOP, loop);, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/IfRegionVisitor.java, +		if (!RegionUtils.hasExitBlock(ifRegion.getThenRegion())) {, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java, +import java.util.Optional;, +						insertLoopBreak(stack, loop, loopExit, exitEdge);, +			if (found && !checkLoopExits(loop, block)) {, +				found = false;, +			}, +	private boolean checkLoopExits(LoopInfo loop, BlockNode mainExitBlock) {, +		List<Edge> exitEdges = loop.getExitEdges();, +		if (exitEdges.size() < 2) {, +			return true;, +		}, +		Optional<Edge> mainEdgeOpt = exitEdges.stream().filter(edge -> edge.getSource() == mainExitBlock).findFirst();, +		if (!mainEdgeOpt.isPresent()) {, +			throw new JadxRuntimeException("Not found exit edge by exit block: " + mainExitBlock);, +		}, +		Edge mainExitEdge = mainEdgeOpt.get();, +		BlockNode mainOutBlock = skipSyntheticSuccessor(mainExitEdge.getTarget());, +		for (Edge exitEdge : exitEdges) {, +			if (exitEdge != mainExitEdge) {, +				BlockNode outBlock = skipSyntheticSuccessor(exitEdge.getTarget());, +				// all exit paths must be same or don't cross (will be inside loop), +				if (!isEqualPaths(mainOutBlock, outBlock)) {, +					BlockNode crossBlock = BlockUtils.getPathCross(mth, mainOutBlock, outBlock);, +					if (crossBlock != null) {, +						return false;, +					}, +				}, +			}, +		}, +		return true;, +	}, +, +			if (insertLoopBreak(stack, loop, exit, exitEdge)) {, +						insertLoopBreak(stack, loop, block, exitEdge);, +						insertLoopBreak(stack, loop, exit, exitEdge);, +	private boolean insertLoopBreak(RegionStack stack, LoopInfo loop, BlockNode loopExit, Edge exitEdge) {, +		breakInsn.addAttr(AType.LOOP, loop);, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMakerVisitor.java, +		if (last instanceof BlockNode) {, +			BlockNode block = (BlockNode) last;, +			if (block.getInstructions().isEmpty()) {, +				block.getInstructions().add(insnAttr.getInsn());, +				return;, +			}, +		}, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/IfRegionVisitor.java, +		if (!RegionUtils.hasExitBlock(ifRegion.getThenRegion())) {, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java, +import java.util.Optional;, +						insertLoopBreak(stack, loop, loopExit, exitEdge);, +			if (found && !checkLoopExits(loop, block)) {, +				found = false;, +			}, +	private boolean checkLoopExits(LoopInfo loop, BlockNode mainExitBlock) {, +		List<Edge> exitEdges = loop.getExitEdges();, +		if (exitEdges.size() < 2) {, +			return true;]