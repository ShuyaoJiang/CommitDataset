[+++ b/jadx-cli/src/main/java/jadx/cli/JadxCLI.java, +import jadx.core.xmlgen.BinaryXMLParser;, +, +		BinaryXMLParser bxp = new BinaryXMLParser(args[0]);, +		bxp.parse();, +		System.exit(4);, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLI.java, +import jadx.core.xmlgen.BinaryXMLParser;, +, +		BinaryXMLParser bxp = new BinaryXMLParser(args[0]);, +		bxp.parse();, +		System.exit(4);, +++ b/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java, +package jadx.core.xmlgen;, +, +import java.nio.ByteBuffer;, +import java.nio.charset.Charset;, +import java.io.BufferedInputStream;, +import java.io.File;, +import java.io.FileInputStream;, +import java.io.FileNotFoundException;, +import java.io.InputStream;, +import java.io.IOException;, +import java.io.UnsupportedEncodingException;, +, +public class BinaryXMLParser {, +	private byte[] bytes;, +	private String[] strings;, +	private int count;, +	private String nsPrefix="ERROR";, +	public BinaryXMLParser(String xmlfilepath) {, +		System.out.println(xmlfilepath);, +		File manifest = new File(xmlfilepath);, +		if(null==manifest) die("null==manifest");, +		bytes = new byte[(int) manifest.length()];, +		try {, +			InputStream is = null;, +			try {, +				is = new BufferedInputStream(new FileInputStream(manifest));, +				int total = 0;, +				while(total < bytes.length) {, +					int remain = bytes.length - total;, +					int read = is.read(bytes, total, remain);, +					if(read > 0) total += read;, +				}, +			} finally {, +				is.close();, +			}, +		} catch(FileNotFoundException fnfe) { die("FILE NOT FOUND"); }, +		catch(IOException ioe) { die("IOE"); }, +		count=0;, +	}, +, +	public void parse() {, +		if(cInt16(bytes, count) != 0x0003) die("Version is not 3");, +		if(cInt16(bytes, count) != 0x0008) die("Size of header is not 8");, +		if(cInt32(bytes, count) != bytes.length) die("Size of manifest doesn't match");, +		while(true) {, +			int type = cInt16(bytes, count);, +			if(type==0x0001) parseStringPool();, +			else if(type==0x0180) parseResourceMap();, +			else if(type==0x0100) parseNameSpace();, +			else if(type==0x0102) parseElement();, +			else die("Type: " + Integer.toHexString(type) + " not yet implemented");, +			System.out.println("COUNT: "+Integer.toHexString(count));, +		}, +		//die("Done");, +	}, +, +	private void parseStringPool() {, +		if(cInt16(bytes, count) != 0x001c) die("Header header size not 28");, +		int hsize = cInt32(bytes, count);, +		int stringCount = cInt32(bytes, count);, +		int styleCount = cInt32(bytes, count);, +		int flags = cInt32(bytes, count);, +		int stringsStart = cInt32(bytes, count);, +		int stylesStart = cInt32(bytes, count);, +/*, +		System.out.println(hsize);, +		System.out.println(stringCount);, +		System.out.println(styleCount);, +		System.out.println(flags);, +		System.out.println(stringsStart);, +		System.out.println(stylesStart);, +*/, +		int[] stringsOffsets = new int[stringCount];, +		for(int i=0; i<stringCount; i++) {, +			stringsOffsets[i] = cInt32(bytes, count);, +			//System.out.println("i["+i+"]: " + stringsOffsets[i]);, +		}, +		strings = new String[stringCount];, +		for(int i=0; i<stringCount; i++) {, +			int off = 8 + stringsStart + stringsOffsets[i];, +			int strlen = cInt16(bytes, off);, +			//System.out.println("strlen: " + strlen);, +			byte[] str = new byte[strlen*2];, +			System.arraycopy(bytes, count, str, 0, strlen*2);, +			count+=strlen*2;, +			strings[i] = new String(str, Charset.forName("UTF-16LE"));, +			System.out.println("index i["+i+"] string: " + strings[i]);]