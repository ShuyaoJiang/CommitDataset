[+++ b/jadx-core/src/main/java/jadx/core/codegen/TypeGen.java, +			if (Math.abs(lit) > 100) {, +			}, +++ b/jadx-core/src/main/java/jadx/core/codegen/TypeGen.java, +			if (Math.abs(lit) > 100) {, +			}, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/ArgType.java, +	public static final ArgType NARROW_NUMBERS = unknown(, +			PrimitiveType.INT, PrimitiveType.FLOAT,, +			PrimitiveType.BOOLEAN, PrimitiveType.SHORT, PrimitiveType.BYTE, PrimitiveType.CHAR);, +, +			if (type == PrimitiveType.LONG || type == PrimitiveType.DOUBLE) {, +			} else {, +				return 1;, +			}, +		}, +		if (!isTypeKnown()) {, +			return 0;, +++ b/jadx-core/src/main/java/jadx/core/codegen/TypeGen.java, +			if (Math.abs(lit) > 100) {, +			}, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/ArgType.java, +	public static final ArgType NARROW_NUMBERS = unknown(, +			PrimitiveType.INT, PrimitiveType.FLOAT,, +			PrimitiveType.BOOLEAN, PrimitiveType.SHORT, PrimitiveType.BYTE, PrimitiveType.CHAR);, +, +			if (type == PrimitiveType.LONG || type == PrimitiveType.DOUBLE) {, +			} else {, +				return 1;, +			}, +		}, +		if (!isTypeKnown()) {, +			return 0;, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/LiteralArg.java, +		if (value != 0) {, +			if (type.isObject()) {, +				throw new JadxRuntimeException("Wrong literal type: " + type + " for value: " + value);, +			} else if (!type.isTypeKnown(), +					&& !type.contains(PrimitiveType.LONG), +					&& !type.contains(PrimitiveType.DOUBLE)) {, +				ArgType m = ArgType.merge(type, ArgType.NARROW_NUMBERS);, +				if (m != null) {, +					type = m;, +				}, +			}, +		}, +++ b/jadx-core/src/main/java/jadx/core/codegen/TypeGen.java, +			if (Math.abs(lit) > 100) {, +			}, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/ArgType.java, +	public static final ArgType NARROW_NUMBERS = unknown(, +			PrimitiveType.INT, PrimitiveType.FLOAT,, +			PrimitiveType.BOOLEAN, PrimitiveType.SHORT, PrimitiveType.BYTE, PrimitiveType.CHAR);, +, +			if (type == PrimitiveType.LONG || type == PrimitiveType.DOUBLE) {, +			} else {, +				return 1;, +			}, +		}, +		if (!isTypeKnown()) {, +			return 0;, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/LiteralArg.java, +		if (value != 0) {, +			if (type.isObject()) {, +				throw new JadxRuntimeException("Wrong literal type: " + type + " for value: " + value);, +			} else if (!type.isTypeKnown(), +					&& !type.contains(PrimitiveType.LONG), +					&& !type.contains(PrimitiveType.DOUBLE)) {, +				ArgType m = ArgType.merge(type, ArgType.NARROW_NUMBERS);, +				if (m != null) {, +					type = m;, +				}, +			}, +		}, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ConstInlinerVisitor.java, +			if (arg.isLiteral()) {, +				ArgType resType = insn.getResult().getType();, +				// make sure arg has correct type, +				if (!arg.getType().isTypeKnown()) {, +					arg.merge(resType);, +				}, +					LiteralArg litArg = InsnArg.lit(literal, ArgType.UNKNOWN);, +						fixTypes(mth, useInsn, litArg);, +	private static void fixTypes(MethodNode mth, InsnNode insn, LiteralArg litArg) {, +			case IF: {, +					InsnArg arg0 = insn.getArg(0);, +					InsnArg arg1 = insn.getArg(1);, +					if (arg0 == litArg) {, +						arg0.merge(arg1);, +					} else {, +						arg1.merge(arg0);, +					}, +			}, +			case CMP_G:, +			case CMP_L: {, +				InsnArg arg0 = insn.getArg(0);, +				InsnArg arg1 = insn.getArg(1);, +				if (arg0 == litArg) {, +					arg0.merge(arg1);, +				} else {]