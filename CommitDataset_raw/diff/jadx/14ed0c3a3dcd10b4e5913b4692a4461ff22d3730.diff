[+++ b/jadx-core/src/main/java/jadx/core/deobf/Deobfuscator.java, +	private static final String CLASS_NAME_SEPARATOR = ".";, +	private static final String INNER_CLASS_SEPARATOR = "$";, +	private final Set<String> pkgSet = new TreeSet<String>();, +		if (fullPkgName.isEmpty() || fullPkgName.equals(CLASS_NAME_SEPARATOR)) {, +			int idx = fullPkgName.indexOf(CLASS_NAME_SEPARATOR);, +				prefix += INNER_CLASS_SEPARATOR;, +			return pkg.getFullAlias() + CLASS_NAME_SEPARATOR + makeNameWithoutPkg();, +			prefix += INNER_CLASS_SEPARATOR;, +		return String.format("C%04d%s", clsIndex++, makeName(clsName));, +		if (!pkg.hasAlias() && shouldRename(pkgName)) {, +			final String pkgAlias = String.format("p%03d%s", pkgIndex++, makeName(pkgName));, +		return s.length() > maxLength, +				|| s.length() < minLength, +				|| NameMapper.isReserved(s), +				|| !NameMapper.isAllCharsPrintable(s);, +	}, +, +	private String makeName(String name) {, +		if (name.length() > maxLength) {, +			return "x" + Integer.toHexString(name.hashCode());, +		}, +		if (NameMapper.isReserved(name)) {, +			return name;, +		}, +		if (!NameMapper.isAllCharsPrintable(name)) {, +			return removeInvalidChars(name);, +		}, +		return name;, +	}, +, +	private String removeInvalidChars(String name) {, +		StringBuilder sb = new StringBuilder();, +		for (int i = 0; i < name.length(); i++) {, +			int ch = name.charAt(i);, +			if (NameMapper.isPrintableChar(ch)) {, +				sb.append((char) ch);, +			}, +		}, +		return sb.toString();, +				String[] va = splitAndTrim(l);, +				String[] va = splitAndTrim(l);, +		return getPackageName(clsInfo.getPackage()) + CLASS_NAME_SEPARATOR + getClassName(clsInfo);, +++ b/jadx-core/src/main/java/jadx/core/deobf/Deobfuscator.java, +	private static final String CLASS_NAME_SEPARATOR = ".";, +	private static final String INNER_CLASS_SEPARATOR = "$";, +	private final Set<String> pkgSet = new TreeSet<String>();, +		if (fullPkgName.isEmpty() || fullPkgName.equals(CLASS_NAME_SEPARATOR)) {, +			int idx = fullPkgName.indexOf(CLASS_NAME_SEPARATOR);, +				prefix += INNER_CLASS_SEPARATOR;, +			return pkg.getFullAlias() + CLASS_NAME_SEPARATOR + makeNameWithoutPkg();, +			prefix += INNER_CLASS_SEPARATOR;, +		return String.format("C%04d%s", clsIndex++, makeName(clsName));, +		if (!pkg.hasAlias() && shouldRename(pkgName)) {, +			final String pkgAlias = String.format("p%03d%s", pkgIndex++, makeName(pkgName));, +		return s.length() > maxLength, +				|| s.length() < minLength, +				|| NameMapper.isReserved(s), +				|| !NameMapper.isAllCharsPrintable(s);, +	}, +, +	private String makeName(String name) {, +		if (name.length() > maxLength) {, +			return "x" + Integer.toHexString(name.hashCode());, +		}, +		if (NameMapper.isReserved(name)) {, +			return name;, +		}, +		if (!NameMapper.isAllCharsPrintable(name)) {, +			return removeInvalidChars(name);, +		}, +		return name;, +	}, +, +	private String removeInvalidChars(String name) {, +		StringBuilder sb = new StringBuilder();, +		for (int i = 0; i < name.length(); i++) {, +			int ch = name.charAt(i);, +			if (NameMapper.isPrintableChar(ch)) {, +				sb.append((char) ch);, +			}, +		}, +		return sb.toString();, +				String[] va = splitAndTrim(l);, +				String[] va = splitAndTrim(l);, +		return getPackageName(clsInfo.getPackage()) + CLASS_NAME_SEPARATOR + getClassName(clsInfo);, +++ b/jadx-core/src/main/java/jadx/core/deobf/NameMapper.java, +		return VALID_JAVA_IDENTIFIER.matcher(str).matches() && isAllCharsPrintable(str);, +		return VALID_JAVA_FULL_IDENTIFIER.matcher(str).matches() && isAllCharsPrintable(str);, +	}, +, +	public static boolean isPrintableChar(int c) {, +		return 32 <= c && c <= 126;, +	}, +, +	public static boolean isAllCharsPrintable(String str) {, +		for (int i = 0; i < str.length(); i++) {, +			 if (!isPrintableChar(str.charAt(i))) {, +				 return false;, +			 }]