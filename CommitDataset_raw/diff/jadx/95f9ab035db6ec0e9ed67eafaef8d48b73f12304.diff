[+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ConstInlineVisitor.java, +import jadx.core.utils.exceptions.JadxOverflowException;, +				checkInsn(mth, insn, toRemove);, +	private static void checkInsn(MethodNode mth, InsnNode insn, List<InsnNode> toRemove) {, +		if (insn.contains(AFlag.DONT_INLINE)) {, +			return;, +		}, +		InsnType insnType = insn.getType();, +		if (insnType != InsnType.CONST && insnType != InsnType.MOVE) {, +			return;, +			return;, +			return;, +		replaceConst(mth, insn, lit, toRemove);, +	private static void replaceConst(MethodNode mth, InsnNode constInsn, long literal, List<InsnNode> toRemove) {, +		SSAVar ssaVar = constInsn.getResult().getSVar();, +		List<RegisterArg> useList = new ArrayList<>(ssaVar.getUseList());, +		for (RegisterArg arg : useList) {, +			if (replaceArg(mth, arg, literal, constInsn, toRemove)) {, +				replaceCount++;, +		}, +		if (replaceCount == useList.size()) {, +			toRemove.add(constInsn);, +		}, +	}, +, +	private static boolean replaceArg(MethodNode mth, RegisterArg arg, long literal, InsnNode constInsn, List<InsnNode> toRemove) {, +		InsnNode useInsn = arg.getParentInsn();, +		if (useInsn == null) {, +			return false;, +		}, +		InsnType insnType = useInsn.getType();, +		if (insnType == InsnType.PHI || insnType == InsnType.MERGE) {, +			return false;, +		}, +		ArgType argType = arg.getInitType();, +		LiteralArg litArg = InsnArg.lit(literal, argType);, +		if (!useInsn.replaceArg(arg, litArg)) {, +			return false;, +		// arg replaced, made some optimizations, +		FieldNode fieldNode = null;, +			fieldNode = mth.getParentClass().getConstFieldByLiteralArg(litArg);, +			fieldNode = mth.getParentClass().getConstField((int) literal, false);, +		if (fieldNode != null) {, +			litArg.wrapInstruction(new IndexInsnNode(InsnType.SGET, fieldNode.getFieldInfo(), 0));, +		}, +, +		if (insnType == InsnType.RETURN) {, +			useInsn.setSourceLine(constInsn.getSourceLine());, +		} else if (insnType == InsnType.MOVE) {, +			try {, +				replaceConst(mth, useInsn, literal, toRemove);, +			} catch (StackOverflowError e) {, +				throw new JadxOverflowException("Stack overflow at const inline visitor");, +		return true;, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ConstInlineVisitor.java, +import jadx.core.utils.exceptions.JadxOverflowException;, +				checkInsn(mth, insn, toRemove);, +	private static void checkInsn(MethodNode mth, InsnNode insn, List<InsnNode> toRemove) {, +		if (insn.contains(AFlag.DONT_INLINE)) {, +			return;, +		}, +		InsnType insnType = insn.getType();, +		if (insnType != InsnType.CONST && insnType != InsnType.MOVE) {, +			return;, +			return;, +			return;, +		replaceConst(mth, insn, lit, toRemove);, +	private static void replaceConst(MethodNode mth, InsnNode constInsn, long literal, List<InsnNode> toRemove) {, +		SSAVar ssaVar = constInsn.getResult().getSVar();, +		List<RegisterArg> useList = new ArrayList<>(ssaVar.getUseList());, +		for (RegisterArg arg : useList) {, +			if (replaceArg(mth, arg, literal, constInsn, toRemove)) {, +				replaceCount++;, +		}, +		if (replaceCount == useList.size()) {, +			toRemove.add(constInsn);, +		}, +	}, +, +	private static boolean replaceArg(MethodNode mth, RegisterArg arg, long literal, InsnNode constInsn, List<InsnNode> toRemove) {, +		InsnNode useInsn = arg.getParentInsn();, +		if (useInsn == null) {, +			return false;, +		}, +		InsnType insnType = useInsn.getType();, +		if (insnType == InsnType.PHI || insnType == InsnType.MERGE) {, +			return false;, +		}, +		ArgType argType = arg.getInitType();, +		LiteralArg litArg = InsnArg.lit(literal, argType);, +		if (!useInsn.replaceArg(arg, litArg)) {, +			return false;, +		// arg replaced, made some optimizations, +		FieldNode fieldNode = null;, +			fieldNode = mth.getParentClass().getConstFieldByLiteralArg(litArg);, +			fieldNode = mth.getParentClass().getConstField((int) literal, false);, +		if (fieldNode != null) {, +			litArg.wrapInstruction(new IndexInsnNode(InsnType.SGET, fieldNode.getFieldInfo(), 0));, +		}, +]