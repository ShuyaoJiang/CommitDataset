[+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ClassModifier.java, +import jadx.core.dex.instructions.InvokeNode;, +import jadx.core.dex.instructions.args.InsnWrapArg;, +		cls.getMethods().forEach(mth -> removeSyntheticMethods(cls, mth));, +		cls.getMethods().forEach(ClassModifier::removeEmptyMethods);, +	private static void removeSyntheticMethods(ClassNode cls, MethodNode mth) {, +			return;, +		if (!af.isSynthetic()) {, +			return;, +		}, +		if (removeBridgeMethod(cls, mth)) {, +			return;, +		}, +		if (af.isConstructor() && mth.getBasicBlocks().size() == 2) {, +	private static boolean removeBridgeMethod(ClassNode cls, MethodNode mth) {, +		List<InsnNode> allInsns = BlockUtils.collectAllInsns(mth.getBasicBlocks());, +		if (allInsns.size() == 1) {, +			InsnNode wrappedInsn = allInsns.get(0);, +			if (wrappedInsn.getType() == InsnType.RETURN) {, +				InsnArg arg = wrappedInsn.getArg(0);, +				if (arg.isInsnWrap()) {, +					wrappedInsn = ((InsnWrapArg) arg).getWrapInsn();, +				}, +			}, +			if (checkSyntheticWrapper(mth, wrappedInsn)) {, +				return true;, +			}, +		}, +		return !isMethodUnique(cls, mth);, +	}, +, +	private static boolean checkSyntheticWrapper(MethodNode mth, InsnNode insn) {, +		InsnType insnType = insn.getType();, +		if (insnType == InsnType.INVOKE) {, +			MethodInfo callMth = ((InvokeNode) insn).getCallMth();, +			MethodNode wrappedMth = mth.root().deepResolveMethod(callMth);, +			if (wrappedMth != null) {, +				String alias = mth.getAlias();, +				if (!wrappedMth.getAlias().equals(alias) && wrappedMth.isVirtual()) {, +					wrappedMth.getMethodInfo().setAlias(alias);, +				}, +				return true;, +			}, +		}, +		return false;, +	}, +, +	private static boolean isMethodUnique(ClassNode cls, MethodNode mth) {, +	private static void removeEmptyMethods(MethodNode mth) {, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ClassModifier.java, +import jadx.core.dex.instructions.InvokeNode;, +import jadx.core.dex.instructions.args.InsnWrapArg;, +		cls.getMethods().forEach(mth -> removeSyntheticMethods(cls, mth));, +		cls.getMethods().forEach(ClassModifier::removeEmptyMethods);, +	private static void removeSyntheticMethods(ClassNode cls, MethodNode mth) {, +			return;, +		if (!af.isSynthetic()) {, +			return;, +		}, +		if (removeBridgeMethod(cls, mth)) {, +			return;, +		}, +		if (af.isConstructor() && mth.getBasicBlocks().size() == 2) {, +	private static boolean removeBridgeMethod(ClassNode cls, MethodNode mth) {, +		List<InsnNode> allInsns = BlockUtils.collectAllInsns(mth.getBasicBlocks());, +		if (allInsns.size() == 1) {, +			InsnNode wrappedInsn = allInsns.get(0);, +			if (wrappedInsn.getType() == InsnType.RETURN) {, +				InsnArg arg = wrappedInsn.getArg(0);, +				if (arg.isInsnWrap()) {, +					wrappedInsn = ((InsnWrapArg) arg).getWrapInsn();, +				}, +			}, +			if (checkSyntheticWrapper(mth, wrappedInsn)) {, +				return true;, +			}, +		}, +		return !isMethodUnique(cls, mth);, +	}, +, +	private static boolean checkSyntheticWrapper(MethodNode mth, InsnNode insn) {, +		InsnType insnType = insn.getType();, +		if (insnType == InsnType.INVOKE) {, +			MethodInfo callMth = ((InvokeNode) insn).getCallMth();, +			MethodNode wrappedMth = mth.root().deepResolveMethod(callMth);, +			if (wrappedMth != null) {, +				String alias = mth.getAlias();, +				if (!wrappedMth.getAlias().equals(alias) && wrappedMth.isVirtual()) {, +					wrappedMth.getMethodInfo().setAlias(alias);, +				}, +				return true;, +			}, +		}, +		return false;, +	}, +, +	private static boolean isMethodUnique(ClassNode cls, MethodNode mth) {, +	private static void removeEmptyMethods(MethodNode mth) {, +++ b/jadx-core/src/main/java/jadx/core/utils/BlockUtils.java, +]