[+++ b/jadx-core/src/main/java/jadx/core/dex/instructions/mods/ConstructorInsn.java, +	public boolean isNewInstance() {, +		return callType == CallType.CONSTRUCTOR;, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/mods/ConstructorInsn.java, +	public boolean isNewInstance() {, +		return callType == CallType.CONSTRUCTOR;, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/parser/DebugInfoParser.java, +		int maxAddr = insnByOffset.length - 1;, +		newAddr = Math.min(newAddr, maxAddr);, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/mods/ConstructorInsn.java, +	public boolean isNewInstance() {, +		return callType == CallType.CONSTRUCTOR;, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/parser/DebugInfoParser.java, +		int maxAddr = insnByOffset.length - 1;, +		newAddr = Math.min(newAddr, maxAddr);, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ModVisitor.java, +, +		InstructionRemover remover = new InstructionRemover(mth);, +		replaceStep(mth, remover);, +		removeStep(mth, remover);, +	private static void replaceStep(MethodNode mth, InstructionRemover remover) {, +			remover.setBlock(block);, +						processInvoke(mth, block, i, remover);, +	private static void processInvoke(MethodNode mth, BlockNode block, int insnNumber, InstructionRemover remover) {, +		ClassNode parentClass = mth.getParentClass();, +		InsnNode insn = block.getInstructions().get(insnNumber);, +		InvokeNode inv = (InvokeNode) insn;, +		MethodInfo callMth = inv.getCallMth();, +		if (callMth.isConstructor()) {, +			InsnNode instArgAssignInsn = ((RegisterArg) inv.getArg(0)).getAssignInsn();, +			ConstructorInsn co = new ConstructorInsn(mth, inv);, +			boolean remove = false;, +			if (co.isSuper() && (co.getArgsCount() == 0 || parentClass.isEnum())) {, +				remove = true;, +			} else if (co.isThis() && co.getArgsCount() == 0) {, +				MethodNode defCo = parentClass.searchMethodByName(callMth.getShortId());, +				if (defCo == null || defCo.isNoCode()) {, +					// default constructor not implemented, +					remove = true;, +				}, +			}, +			// remove super() call in instance initializer, +			if (parentClass.isAnonymous() && mth.isDefaultConstructor() && co.isSuper()) {, +				remove = true;, +			}, +			if (remove) {, +				remover.add(insn);, +			} else {, +				replaceInsn(block, insnNumber, co);, +				if (co.isNewInstance()) {, +					removeAssignChain(instArgAssignInsn, remover, InsnType.NEW_INSTANCE);, +				}, +			}, +		} else if (inv.getArgsCount() > 0) {, +			for (int j = 0; j < inv.getArgsCount(); j++) {, +				InsnArg arg = inv.getArg(j);, +				if (arg.isLiteral()) {, +					FieldNode f = parentClass.getConstFieldByLiteralArg((LiteralArg) arg);, +					if (f != null) {, +						arg.wrapInstruction(new IndexInsnNode(InsnType.SGET, f.getFieldInfo(), 0));, +					}, +				}, +			}, +		}, +	}, +, +	/**, +	 * Remove instructions on 'move' chain until instruction with type 'insnType', +	 */, +	private static void removeAssignChain(InsnNode insn, InstructionRemover remover, InsnType insnType) {, +		if (insn == null) {, +			return;, +		}, +		remover.add(insn);, +		InsnType type = insn.getType();, +		if (type == insnType) {, +			return;, +		}, +		if (type == InsnType.MOVE) {, +			RegisterArg arg = (RegisterArg) insn.getArg(0);, +			removeAssignChain(arg.getAssignInsn(), remover, insnType);, +		}, +	}, +, +	private static void removeStep(MethodNode mth, InstructionRemover remover) {, +			remover.setBlock(block);, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/mods/ConstructorInsn.java, +	public boolean isNewInstance() {, +		return callType == CallType.CONSTRUCTOR;, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/parser/DebugInfoParser.java, +		int maxAddr = insnByOffset.length - 1;, +		newAddr = Math.min(newAddr, maxAddr);]